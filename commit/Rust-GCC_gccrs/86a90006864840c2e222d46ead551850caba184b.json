{"sha": "86a90006864840c2e222d46ead551850caba184b", "node_id": "C_kwDOANBUbNoAKDg2YTkwMDA2ODY0ODQwYzJlMjIyZDQ2ZWFkNTUxODUwY2FiYTE4NGI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-15T18:53:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-15T18:53:42Z"}, "message": "analyzer: add warnings relating to sockets [PR106140]\n\nThis patch generalizes the analyzer's file descriptor state machine\nso that it tracks the states of sockets.\n\nIt adds two new warnings relating to misuses of socket APIs:\n* -Wanalyzer-fd-phase-mismatch (e.g. calling 'accept' on a socket\nbefore calling 'listen' on it)\n* -Wanalyzer-fd-type-mismatch (e.g. using a stream socket operation\non a datagram socket)\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106140\n\t* analyzer-language.cc (on_finish_translation_unit): Stash named\n\tconstants \"SOCK_STREAM\" and \"SOCK_DGRAM\".\n\t* analyzer.opt (Wanalyzer-fd-phase-mismatch): New.\n\t(Wanalyzer-fd-type-mismatch): New.\n\t* engine.cc (impl_region_model_context::get_state_map_by_name):\n\tAdd \"out_sm_context\" param.  Allow out_sm_idx to be NULL.\n\t* exploded-graph.h\n\t(impl_region_model_context::get_state_map_by_name):\n\tAdd \"out_sm_context\" param.\n\t* region-model-impl-calls.cc (region_model::impl_call_accept): New.\n\t(region_model::impl_call_bind): New.\n\t(region_model::impl_call_connect): New.\n\t(region_model::impl_call_listen): New.\n\t(region_model::impl_call_socket): New.\n\t* region-model.cc (region_model::on_call_pre): Special-case\n\t\"bind\".\n\t(region_model::on_call_post): Special-case \"accept\", \"bind\",\n\t\"connect\", \"listen\", and \"socket\".\n\t* region-model.h (region_model::impl_call_accept): New decl.\n\t(region_model::impl_call_bind): New decl.\n\t(region_model::impl_call_connect): New decl.\n\t(region_model::impl_call_listen): New decl.\n\t(region_model::impl_call_socket): New decl.\n\t(region_model::on_socket): New decl.\n\t(region_model::on_bind): New decl.\n\t(region_model::on_listen): New decl.\n\t(region_model::on_accept): New decl.\n\t(region_model::on_connect): New decl.\n\t(region_model::add_constraint): Make public.\n\t(region_model::check_for_poison): Make public.\n\t(region_model_context::get_state_map_by_name): Add out_sm_context param.\n\t(region_model_context::get_fd_map): Likewise.\n\t(region_model_context::get_malloc_map): Likewise.\n\t(region_model_context::get_taint_map): Likewise.\n\t(noop_region_model_context::get_state_map_by_name): Likewise.\n\t(region_model_context_decorator::get_state_map_by_name): Likewise.\n\t* sm-fd.cc: Include \"analyzer/supergraph.h\" and\n\t\"analyzer/analyzer-language.h\".\n\t(enum expected_phase): New enum.\n\t(fd_state_machine::m_new_datagram_socket): New.\n\t(fd_state_machine::m_new_stream_socket): New.\n\t(fd_state_machine::m_new_unknown_socket): New.\n\t(fd_state_machine::m_bound_datagram_socket): New.\n\t(fd_state_machine::m_bound_stream_socket): New.\n\t(fd_state_machine::m_bound_unknown_socket): New.\n\t(fd_state_machine::m_listening_stream_socket): New.\n\t(fd_state_machine::m_m_connected_stream_socket): New.\n\t(fd_state_machine::m_SOCK_STREAM): New.\n\t(fd_state_machine::m_SOCK_DGRAM): New.\n\t(fd_diagnostic::describe_state_change): Handle socket states.\n\t(fd_diagnostic::get_meaning_for_state_change): Likewise.\n\t(class fd_phase_mismatch): New.\n\t(enum expected_type): New enum.\n\t(class fd_type_mismatch): New.\n\t(fd_state_machine::fd_state_machine): Initialize new states and\n\tstashed named constants.\n\t(fd_state_machine::is_socket_fd_p): New.\n\t(fd_state_machine::is_datagram_socket_fd_p): New.\n\t(fd_state_machine::is_stream_socket_fd_p): New.\n\t(fd_state_machine::on_close): Handle the socket states.\n\t(fd_state_machine::check_for_open_fd): Complain about fncalls on\n\tsockets in the wrong phase.  Support socket FDs.\n\t(add_constraint_ge_zero): New.\n\t(fd_state_machine::get_state_for_socket_type): New.\n\t(fd_state_machine::on_socket): New.\n\t(fd_state_machine::check_for_socket_fd): New.\n\t(fd_state_machine::check_for_new_socket_fd): New.\n\t(fd_state_machine::on_bind): New.\n\t(fd_state_machine::on_listen): New.\n\t(fd_state_machine::on_accept): New.\n\t(fd_state_machine::on_connect): New.\n\t(fd_state_machine::can_purge_p): Don't purge socket values.\n\t(get_fd_state): New.\n\t(region_model::mark_as_valid_fd): Use get_fd_state.\n\t(region_model::on_socket): New.\n\t(region_model::on_bind): New.\n\t(region_model::on_listen): New.\n\t(region_model::on_accept): New.\n\t(region_model::on_connect): New.\n\t* sm-fd.dot: Update to reflect sm-fd.cc changes.\n\ngcc/ChangeLog:\n\tPR analyzer/106140\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-Wanalyzer-fd-phase-mismatch and -Wanalyzer-fd-type-mismatch.  Add\n\t\"socket\", \"bind\", \"listen\", \"accept\", and \"connect\" to the list of\n\tfunctions known to the analyzer.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106140\n\t* gcc.dg/analyzer/fd-accept.c: New test.\n\t* gcc.dg/analyzer/fd-bind.c: New test.\n\t* gcc.dg/analyzer/fd-connect.c: New test.\n\t* gcc.dg/analyzer/fd-datagram-socket.c: New test.\n\t* gcc.dg/analyzer/fd-glibc-byte-stream-connection-server.c: New test.\n\t* gcc.dg/analyzer/fd-glibc-byte-stream-socket.c: New test.\n\t* gcc.dg/analyzer/fd-glibc-datagram-client.c: New test.\n\t* gcc.dg/analyzer/fd-glibc-datagram-socket.c: New test.\n\t* gcc.dg/analyzer/fd-glibc-make_named_socket.h: New test.\n\t* gcc.dg/analyzer/fd-listen.c: New test.\n\t* gcc.dg/analyzer/fd-manpage-getaddrinfo-client.c: New test.\n\t* gcc.dg/analyzer/fd-mappage-getaddrinfo-server.c: New test.\n\t* gcc.dg/analyzer/fd-socket-meaning.c: New test.\n\t* gcc.dg/analyzer/fd-socket-misuse.c: New test.\n\t* gcc.dg/analyzer/fd-stream-socket-active-open.c: New test.\n\t* gcc.dg/analyzer/fd-stream-socket-passive-open.c: New test.\n\t* gcc.dg/analyzer/fd-stream-socket.c: New test.\n\t* gcc.dg/analyzer/fd-symbolic-socket.c: New test.\n\t* gcc.dg/analyzer/pr104369-1.c: Add -Wno-analyzer-too-complex and\n\t-Wno-analyzer-fd-leak to options.\n\t* gcc.dg/analyzer/pr104369-2.c: Add -Wno-analyzer-fd-leak to\n\toptions.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "dbd40ec5eead9974edb997d246a79036eed69d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd40ec5eead9974edb997d246a79036eed69d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86a90006864840c2e222d46ead551850caba184b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a90006864840c2e222d46ead551850caba184b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a90006864840c2e222d46ead551850caba184b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a90006864840c2e222d46ead551850caba184b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8aba860b34203621586df8c5a6756b18c2a0c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aba860b34203621586df8c5a6756b18c2a0c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8aba860b34203621586df8c5a6756b18c2a0c32"}], "stats": {"total": 3067, "additions": 3007, "deletions": 60}, "files": [{"sha": "0629b681e7c1bf3500efed32842439922b05fad5", "filename": "gcc/analyzer/analyzer-language.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fanalyzer-language.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fanalyzer-language.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-language.cc?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -72,6 +72,8 @@ on_finish_translation_unit (const translation_unit &tu)\n   maybe_stash_named_constant (tu, \"O_ACCMODE\");\n   maybe_stash_named_constant (tu, \"O_RDONLY\");\n   maybe_stash_named_constant (tu, \"O_WRONLY\");\n+  maybe_stash_named_constant (tu, \"SOCK_STREAM\");\n+  maybe_stash_named_constant (tu, \"SOCK_DGRAM\");\n }\n \n /* Lookup NAME in the named constants stashed when the frontend TU finished."}, {"sha": "c4e79069dfaf4ad80d8b86e891b99cf883406617", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -90,6 +90,14 @@ Wanalyzer-fd-leak\n Common Var(warn_analyzer_fd_leak) Init(1) Warning\n Warn about code paths in which a file descriptor is not closed.\n \n+Wanalyzer-fd-phase-mismatch\n+Common Var(warn_analyzer_fd_phase_mismatch) Init(1) Warning\n+Warn about code paths in which an operation is attempted in the wrong phase of a file descriptor's lifetime.\n+\n+Wanalyzer-fd-type-mismatch\n+Common Var(warn_analyzer_fd_type_mismatch) Init(1) Warning\n+Warn about code paths in which an operation is attempted on the wrong type of file descriptor.\n+\n Wanalyzer-fd-use-after-close\n Common Var(warn_analyzer_fd_use_after_close) Init(1) Warning\n Warn about code paths in which a read or write is performed on a closed file descriptor."}, {"sha": "3ef411cae93af63b3756aa194471704f943c35e7", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -206,25 +206,6 @@ impl_region_model_context::terminate_path ()\n     return m_path_ctxt->terminate_path ();\n }\n \n-bool\n-impl_region_model_context::get_state_map_by_name (const char *name,\n-\t\t\t\t\t\t  sm_state_map **out_smap,\n-\t\t\t\t\t\t  const state_machine **out_sm,\n-\t\t\t\t\t\t  unsigned *out_sm_idx)\n-{\n-  if (!m_new_state)\n-    return false;\n-\n-  unsigned sm_idx;\n-  if (!m_ext_state.get_sm_idx_by_name (name, &sm_idx))\n-    return false;\n-\n-  *out_smap = m_new_state->m_checker_states[sm_idx];\n-  *out_sm = &m_ext_state.get_sm (sm_idx);\n-  *out_sm_idx = sm_idx;\n-  return true;\n-}\n-\n /* struct setjmp_record.  */\n \n int\n@@ -527,6 +508,47 @@ class impl_sm_context : public sm_context\n   bool m_unknown_side_effects;\n };\n \n+bool\n+impl_region_model_context::\n+get_state_map_by_name (const char *name,\n+\t\t       sm_state_map **out_smap,\n+\t\t       const state_machine **out_sm,\n+\t\t       unsigned *out_sm_idx,\n+\t\t       std::unique_ptr<sm_context> *out_sm_context)\n+{\n+  if (!m_new_state)\n+    return false;\n+\n+  unsigned sm_idx;\n+  if (!m_ext_state.get_sm_idx_by_name (name, &sm_idx))\n+    return false;\n+\n+  const state_machine *sm = &m_ext_state.get_sm (sm_idx);\n+  sm_state_map *new_smap = m_new_state->m_checker_states[sm_idx];\n+\n+  *out_smap = new_smap;\n+  *out_sm = sm;\n+  if (out_sm_idx)\n+    *out_sm_idx = sm_idx;\n+  if (out_sm_context)\n+    {\n+      const sm_state_map *old_smap = m_old_state->m_checker_states[sm_idx];\n+      *out_sm_context\n+\t= make_unique<impl_sm_context> (*m_eg,\n+\t\t\t\t\tsm_idx,\n+\t\t\t\t\t*sm,\n+\t\t\t\t\tm_enode_for_diag,\n+\t\t\t\t\tm_old_state,\n+\t\t\t\t\tm_new_state,\n+\t\t\t\t\told_smap,\n+\t\t\t\t\tnew_smap,\n+\t\t\t\t\tm_path_ctxt,\n+\t\t\t\t\tm_stmt_finder,\n+\t\t\t\t\tfalse);\n+    }\n+  return true;\n+}\n+\n /* Subclass of stmt_finder for finding the best stmt to report the leak at,\n    given the emission path.  */\n "}, {"sha": "86644c10835518ffc28c7f0fab8bfb9074ef9343", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -98,10 +98,12 @@ class impl_region_model_context : public region_model_context\n   {\n     return &m_ext_state;\n   }\n-  bool get_state_map_by_name (const char *name,\n-\t\t\t      sm_state_map **out_smap,\n-\t\t\t      const state_machine **out_sm,\n-\t\t\t      unsigned *out_sm_idx) override;\n+  bool\n+  get_state_map_by_name (const char *name,\n+\t\t\t sm_state_map **out_smap,\n+\t\t\t const state_machine **out_sm,\n+\t\t\t unsigned *out_sm_idx,\n+\t\t\t std::unique_ptr<sm_context> *out_sm_context) override;\n \n   const gimple *get_stmt () const override { return m_stmt; }\n "}, {"sha": "99597e0667a9ebabbca3ffd728c5f832cbb1d3a8", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -407,6 +407,66 @@ region_model::impl_call_analyzer_get_unknown_ptr (const call_details &cd)\n   cd.maybe_set_lhs (ptr_sval);\n }\n \n+/* Handle the on_call_post part of \"accept\".  */\n+\n+void\n+region_model::impl_call_accept (const call_details &cd)\n+{\n+  class outcome_of_accept : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_accept (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_accept (cd, m_success);\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_accept.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, false));\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_accept> (cd, true));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n+/* Handle the on_call_post part of \"bind\".  */\n+\n+void\n+region_model::impl_call_bind (const call_details &cd)\n+{\n+  class outcome_of_bind : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_bind (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_bind (cd, m_success);\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_bind.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, false));\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_bind> (cd, true));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* Handle the on_call_pre part of \"__builtin_expect\" etc.  */\n \n void\n@@ -441,6 +501,36 @@ region_model::impl_call_calloc (const call_details &cd)\n     }\n }\n \n+/* Handle the on_call_post part of \"connect\".  */\n+\n+void\n+region_model::impl_call_connect (const call_details &cd)\n+{\n+  class outcome_of_connect : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_connect (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_connect (cd, m_success);\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_connect.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, false));\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_connect> (cd, true));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* Handle the on_call_pre part of \"__errno_location\".  */\n \n void\n@@ -543,6 +633,36 @@ region_model::impl_call_free (const call_details &cd)\n     }\n }\n \n+/* Handle the on_call_post part of \"listen\".  */\n+\n+void\n+region_model::impl_call_listen (const call_details &cd)\n+{\n+  class outcome_of_listen : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_listen (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_listen (cd, m_success);\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_listen.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, false));\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_listen> (cd, true));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* Handle the on_call_pre part of \"malloc\".  */\n \n void\n@@ -1055,6 +1175,36 @@ region_model::impl_call_realloc (const call_details &cd)\n     }\n }\n \n+/* Handle the on_call_post part of \"socket\".  */\n+\n+void\n+region_model::impl_call_socket (const call_details &cd)\n+{\n+  class outcome_of_socket : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_socket (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      return cd.get_model ()->on_socket (cd, m_success);\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_socket.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, false));\n+      cd.get_ctxt ()->bifurcate (make_unique<outcome_of_socket> (cd, true));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* Handle the on_call_post part of \"strchr\" and \"__builtin_strchr\".  */\n \n void"}, {"sha": "5f1dd0112d13940357886ba67b34c02694ba392a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -2293,6 +2293,11 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_realloc (cd);\n \t  return false;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"bind\", call, 3))\n+\t{\n+\t  /* Handle in \"on_call_post\".  */\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"__errno_location\", call, 0))\n \t{\n \t  impl_call_errno_location (cd);\n@@ -2422,12 +2427,37 @@ region_model::on_call_post (const gcall *call,\n \t  impl_call_operator_delete (cd);\n \t  return;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"accept\", call, 3))\n+\t{\n+\t  impl_call_accept (cd);\n+\t  return;\n+\t}\n+      else if (is_named_call_p (callee_fndecl, \"bind\", call, 3))\n+\t{\n+\t  impl_call_bind (cd);\n+\t  return;\n+\t}\n+      else if (is_named_call_p (callee_fndecl, \"connect\", call, 3))\n+\t{\n+\t  impl_call_connect (cd);\n+\t  return;\n+\t}\n+      else if (is_named_call_p (callee_fndecl, \"listen\", call, 2))\n+\t{\n+\t  impl_call_listen (cd);\n+\t  return;\n+\t}\n       else if (is_pipe_call_p (callee_fndecl, \"pipe\", call, 1)\n \t       || is_pipe_call_p (callee_fndecl, \"pipe2\", call, 2))\n \t{\n \t  impl_call_pipe (cd);\n \t  return;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"socket\", call, 3))\n+\t{\n+\t  impl_call_socket (cd);\n+\t  return;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{"}, {"sha": "1e72c551dfa05f950718c6a561639a948f3fe684", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -338,6 +338,7 @@ class region_model\n   void purge_state_involving (const svalue *sval, region_model_context *ctxt);\n \n   /* Specific handling for on_call_pre.  */\n+  void impl_call_accept (const call_details &cd);\n   void impl_call_alloca (const call_details &cd);\n   void impl_call_analyzer_describe (const gcall *call,\n \t\t\t\t    region_model_context *ctxt);\n@@ -349,20 +350,24 @@ class region_model\n   void impl_call_analyzer_eval (const gcall *call,\n \t\t\t\tregion_model_context *ctxt);\n   void impl_call_analyzer_get_unknown_ptr (const call_details &cd);\n+  void impl_call_bind (const call_details &cd);\n   void impl_call_builtin_expect (const call_details &cd);\n   void impl_call_calloc (const call_details &cd);\n+  void impl_call_connect (const call_details &cd);\n   void impl_call_errno_location (const call_details &cd);\n   bool impl_call_error (const call_details &cd, unsigned min_args,\n \t\t\tbool *out_terminate_path);\n   void impl_call_fgets (const call_details &cd);\n   void impl_call_fread (const call_details &cd);\n   void impl_call_free (const call_details &cd);\n+  void impl_call_listen (const call_details &cd);\n   void impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n   void impl_call_memset (const call_details &cd);\n   void impl_call_pipe (const call_details &cd);\n   void impl_call_putenv (const call_details &cd);\n   void impl_call_realloc (const call_details &cd);\n+  void impl_call_socket (const call_details &cd);\n   void impl_call_strchr (const call_details &cd);\n   void impl_call_strcpy (const call_details &cd);\n   void impl_call_strlen (const call_details &cd);\n@@ -548,6 +553,11 @@ class region_model\n \n   /* Implemented in sm-fd.cc  */\n   void mark_as_valid_fd (const svalue *sval, region_model_context *ctxt);\n+  bool on_socket (const call_details &cd, bool successful);\n+  bool on_bind (const call_details &cd, bool successful);\n+  bool on_listen (const call_details &cd, bool successful);\n+  bool on_accept (const call_details &cd, bool successful);\n+  bool on_connect (const call_details &cd, bool successful);\n \n   /* Implemented in sm-malloc.cc  */\n   void on_realloc_with_move (const call_details &cd,\n@@ -558,7 +568,16 @@ class region_model\n   void mark_as_tainted (const svalue *sval,\n \t\t\tregion_model_context *ctxt);\n \n- private:\n+  bool add_constraint (const svalue *lhs,\n+\t\t       enum tree_code op,\n+\t\t       const svalue *rhs,\n+\t\t       region_model_context *ctxt);\n+\n+  const svalue *check_for_poison (const svalue *sval,\n+\t\t\t\t  tree expr,\n+\t\t\t\t  region_model_context *ctxt) const;\n+\n+private:\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt) const;\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt) const;\n \n@@ -571,10 +590,6 @@ class region_model\n \n   const known_function *get_known_function (tree fndecl) const;\n \n-  bool add_constraint (const svalue *lhs,\n-\t\t       enum tree_code op,\n-\t\t       const svalue *rhs,\n-\t\t       region_model_context *ctxt);\n   bool add_constraints_from_binop (const svalue *outer_lhs,\n \t\t\t\t   enum tree_code outer_op,\n \t\t\t\t   const svalue *outer_rhs,\n@@ -605,9 +620,6 @@ class region_model\n   bool called_from_main_p () const;\n   const svalue *get_initial_value_for_global (const region *reg) const;\n \n-  const svalue *check_for_poison (const svalue *sval,\n-\t\t\t\t  tree expr,\n-\t\t\t\t  region_model_context *ctxt) const;\n   const region * get_region_for_poisoned_expr (tree expr) const;\n \n   void check_dynamic_size_for_taint (enum memory_space mem_space,\n@@ -744,30 +756,33 @@ class region_model_context\n \n   /* Hook for clients to access the a specific state machine in\n      any underlying program_state.  */\n-  virtual bool get_state_map_by_name (const char *name,\n-\t\t\t\t      sm_state_map **out_smap,\n-\t\t\t\t      const state_machine **out_sm,\n-\t\t\t\t      unsigned *out_sm_idx) = 0;\n+  virtual bool\n+  get_state_map_by_name (const char *name,\n+\t\t\t sm_state_map **out_smap,\n+\t\t\t const state_machine **out_sm,\n+\t\t\t unsigned *out_sm_idx,\n+\t\t\t std::unique_ptr<sm_context> *out_sm_context) = 0;\n \n   /* Precanned ways for clients to access specific state machines.  */\n   bool get_fd_map (sm_state_map **out_smap,\n \t\t   const state_machine **out_sm,\n-\t\t   unsigned *out_sm_idx)\n+\t\t   unsigned *out_sm_idx,\n+\t\t   std::unique_ptr<sm_context> *out_sm_context)\n   {\n     return get_state_map_by_name (\"file-descriptor\", out_smap, out_sm,\n-\t\t\t\t  out_sm_idx);\n+\t\t\t\t  out_sm_idx, out_sm_context);\n   }\n   bool get_malloc_map (sm_state_map **out_smap,\n \t\t       const state_machine **out_sm,\n \t\t       unsigned *out_sm_idx)\n   {\n-    return get_state_map_by_name (\"malloc\", out_smap, out_sm, out_sm_idx);\n+    return get_state_map_by_name (\"malloc\", out_smap, out_sm, out_sm_idx, NULL);\n   }\n   bool get_taint_map (sm_state_map **out_smap,\n \t\t      const state_machine **out_sm,\n \t\t      unsigned *out_sm_idx)\n   {\n-    return get_state_map_by_name (\"taint\", out_smap, out_sm, out_sm_idx);\n+    return get_state_map_by_name (\"taint\", out_smap, out_sm, out_sm_idx, NULL);\n   }\n \n   /* Get the current statement, if any.  */\n@@ -819,7 +834,8 @@ class noop_region_model_context : public region_model_context\n   bool get_state_map_by_name (const char *,\n \t\t\t      sm_state_map **,\n \t\t\t      const state_machine **,\n-\t\t\t      unsigned *) override\n+\t\t\t      unsigned *,\n+\t\t\t      std::unique_ptr<sm_context> *) override\n   {\n     return false;\n   }\n@@ -946,9 +962,12 @@ class region_model_context_decorator : public region_model_context\n   bool get_state_map_by_name (const char *name,\n \t\t\t      sm_state_map **out_smap,\n \t\t\t      const state_machine **out_sm,\n-\t\t\t      unsigned *out_sm_idx) override\n+\t\t\t      unsigned *out_sm_idx,\n+\t\t\t      std::unique_ptr<sm_context> *out_sm_context)\n+    override\n   {\n-    return m_inner->get_state_map_by_name (name, out_smap, out_sm, out_sm_idx);\n+    return m_inner->get_state_map_by_name (name, out_smap, out_sm, out_sm_idx,\n+\t\t\t\t\t   out_sm_context);\n   }\n \n   const gimple *get_stmt () const override"}, {"sha": "d0b587143d0af089e63525c8d0d2f9cdf7157de8", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 1094, "deletions": 16, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model.h\"\n #include \"bitmap.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/analyzer-language.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -76,6 +78,17 @@ enum dup\n   DUP_3\n };\n \n+/* Enum for use by -Wanalyzer-fd-phase-mismatch.  */\n+\n+enum expected_phase\n+{\n+  EXPECTED_PHASE_CAN_TRANSFER, /* can \"read\"/\"write\".  */\n+  EXPECTED_PHASE_CAN_BIND,\n+  EXPECTED_PHASE_CAN_LISTEN,\n+  EXPECTED_PHASE_CAN_ACCEPT,\n+  EXPECTED_PHASE_CAN_CONNECT\n+};\n+\n class fd_state_machine : public state_machine\n {\n public:\n@@ -116,6 +129,9 @@ class fd_state_machine : public state_machine\n \n   bool is_unchecked_fd_p (state_t s) const;\n   bool is_valid_fd_p (state_t s) const;\n+  bool is_socket_fd_p (state_t s) const;\n+  bool is_datagram_socket_fd_p (state_t s) const;\n+  bool is_stream_socket_fd_p (state_t s) const;\n   bool is_closed_fd_p (state_t s) const;\n   bool is_constant_fd_p (state_t s) const;\n   bool is_readonly_fd_p (state_t s) const;\n@@ -130,6 +146,27 @@ class fd_state_machine : public state_machine\n \t\t\t const svalue *fd_sval,\n \t\t\t const extrinsic_state &ext_state) const;\n \n+  bool on_socket (const call_details &cd,\n+\t\t  bool successful,\n+\t\t  sm_context *sm_ctxt,\n+\t\t  const extrinsic_state &ext_state) const;\n+  bool on_bind (const call_details &cd,\n+\t\tbool successful,\n+\t\tsm_context *sm_ctxt,\n+\t\tconst extrinsic_state &ext_state) const;\n+  bool on_listen (const call_details &cd,\n+\t\t  bool successful,\n+\t\t  sm_context *sm_ctxt,\n+\t\t  const extrinsic_state &ext_state) const;\n+  bool on_accept (const call_details &cd,\n+\t\t  bool successful,\n+\t\t  sm_context *sm_ctxt,\n+\t\t  const extrinsic_state &ext_state) const;\n+  bool on_connect (const call_details &cd,\n+\t\t   bool successful,\n+\t\t   sm_context *sm_ctxt,\n+\t\t   const extrinsic_state &ext_state) const;\n+\n   /* State for a constant file descriptor (>= 0) */\n   state_t m_constant_fd;\n \n@@ -156,13 +193,38 @@ class fd_state_machine : public state_machine\n   /* State for a file descriptor that has been closed.  */\n   state_t m_closed;\n \n+  /* States for FDs relating to socket APIs.  */\n+\n+  /* Result of successful \"socket\" with SOCK_DGRAM.  */\n+  state_t m_new_datagram_socket;\n+  /* Result of successful \"socket\" with SOCK_STREAM.  */\n+  state_t m_new_stream_socket;\n+  /* Result of successful \"socket\" with unknown type.  */\n+  state_t m_new_unknown_socket;\n+\n+  /* The above after a successful call to \"bind\".  */\n+  state_t m_bound_datagram_socket;\n+  state_t m_bound_stream_socket;\n+  state_t m_bound_unknown_socket;\n+\n+  /* A bound socket after a successful call to \"listen\" (stream or unknown).  */\n+  state_t m_listening_stream_socket;\n+\n+  /* (i) the new FD as a result of a succesful call to \"accept\" on a\n+     listening socket (via a passive open), or\n+     (ii) an active socket after a successful call to \"connect\"\n+     (via an active open).  */\n+  state_t m_connected_stream_socket;\n+\n   /* State for a file descriptor that we do not want to track anymore . */\n   state_t m_stop;\n \n   /* Stashed constant values from the frontend.  These could be NULL.  */\n   tree m_O_ACCMODE;\n   tree m_O_RDONLY;\n   tree m_O_WRONLY;\n+  tree m_SOCK_STREAM;\n+  tree m_SOCK_DGRAM;\n \n private:\n   void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n@@ -195,6 +257,23 @@ class fd_state_machine : public state_machine\n   void check_for_dup (sm_context *sm_ctxt, const supernode *node,\n        const gimple *stmt, const gcall *call, const tree callee_fndecl,\n        enum dup kind) const;\n+\n+  state_t get_state_for_socket_type (const svalue *socket_type_sval) const;\n+\n+  bool check_for_socket_fd (const call_details &cd,\n+\t\t\t    bool successful,\n+\t\t\t    sm_context *sm_ctxt,\n+\t\t\t    const svalue *fd_sval,\n+\t\t\t    const supernode *node,\n+\t\t\t    state_t old_state,\n+\t\t\t    bool *complained = NULL) const;\n+  bool check_for_new_socket_fd (const call_details &cd,\n+\t\t\t\tbool successful,\n+\t\t\t\tsm_context *sm_ctxt,\n+\t\t\t\tconst svalue *fd_sval,\n+\t\t\t\tconst supernode *node,\n+\t\t\t\tstate_t old_state,\n+\t\t\t\tenum expected_phase expected_phase) const;\n };\n \n /* Base diagnostic class relative to fd_state_machine.  */\n@@ -214,9 +293,7 @@ class fd_diagnostic : public pending_diagnostic\n   label_text\n   describe_state_change (const evdesc::state_change &change) override\n   {\n-    if (change.m_old_state == m_sm.get_start_state ()\n-\t&& (m_sm.is_unchecked_fd_p (change.m_new_state)\n-\t    || m_sm.is_valid_fd_p (change.m_new_state)))\n+    if (change.m_old_state == m_sm.get_start_state ())\n       {\n \tif (change.m_new_state == m_sm.m_unchecked_read_write\n \t    || change.m_new_state == m_sm.m_valid_read_write)\n@@ -229,8 +306,32 @@ class fd_diagnostic : public pending_diagnostic\n \tif (change.m_new_state == m_sm.m_unchecked_write_only\n \t    || change.m_new_state == m_sm.m_valid_write_only)\n \t  return change.formatted_print (\"opened here as write-only\");\n+\n+\tif (change.m_new_state == m_sm.m_new_datagram_socket)\n+\t  return change.formatted_print (\"datagram socket created here\");\n+\n+\tif (change.m_new_state == m_sm.m_new_stream_socket)\n+\t  return change.formatted_print (\"stream socket created here\");\n+\n+\tif (change.m_new_state == m_sm.m_new_unknown_socket\n+\t    || change.m_new_state == m_sm.m_connected_stream_socket)\n+\t  return change.formatted_print (\"socket created here\");\n       }\n \n+    if (change.m_new_state == m_sm.m_bound_datagram_socket)\n+      return change.formatted_print (\"datagram socket bound here\");\n+\n+    if (change.m_new_state == m_sm.m_bound_stream_socket)\n+      return change.formatted_print (\"stream socket bound here\");\n+\n+    if (change.m_new_state == m_sm.m_bound_unknown_socket\n+\t|| change.m_new_state == m_sm.m_connected_stream_socket)\n+\t  return change.formatted_print (\"socket bound here\");\n+\n+    if (change.m_new_state == m_sm.m_listening_stream_socket)\n+      return change.formatted_print\n+\t(\"stream socket marked as passive here via %qs\", \"listen\");\n+\n     if (change.m_new_state == m_sm.m_closed)\n       return change.formatted_print (\"closed here\");\n \n@@ -263,7 +364,10 @@ class fd_diagnostic : public pending_diagnostic\n       const evdesc::state_change &change) const final override\n   {\n     if (change.m_old_state == m_sm.get_start_state ()\n-\t\t&& (m_sm.is_unchecked_fd_p (change.m_new_state)))\n+\t&& (m_sm.is_unchecked_fd_p (change.m_new_state)\n+\t    || change.m_new_state == m_sm.m_new_datagram_socket\n+\t    || change.m_new_state == m_sm.m_new_stream_socket\n+\t    || change.m_new_state == m_sm.m_new_unknown_socket))\n       return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n \t\t\t diagnostic_event::NOUN_resource);\n     if (change.m_new_state == m_sm.m_closed)\n@@ -680,6 +784,289 @@ class fd_use_without_check : public fd_param_diagnostic\n   diagnostic_event_id_t m_first_open_event;\n };\n \n+/* Concrete pending_diagnostic subclass for -Wanalyzer-fd-phase-mismatch.  */\n+\n+class fd_phase_mismatch : public fd_param_diagnostic\n+{\n+public:\n+  fd_phase_mismatch (const fd_state_machine &sm, tree arg,\n+\t\t     const tree callee_fndecl,\n+\t\t     state_machine::state_t actual_state,\n+\t\t     enum expected_phase expected_phase)\n+  : fd_param_diagnostic (sm, arg, callee_fndecl),\n+    m_actual_state (actual_state),\n+    m_expected_phase (expected_phase)\n+  {\n+    gcc_assert (m_sm.is_socket_fd_p (actual_state));\n+    switch (expected_phase)\n+      {\n+      case EXPECTED_PHASE_CAN_TRANSFER:\n+\tgcc_assert (actual_state == m_sm.m_new_stream_socket\n+\t\t    || actual_state == m_sm.m_bound_stream_socket\n+\t\t    || actual_state == m_sm.m_listening_stream_socket);\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_BIND:\n+\tgcc_assert (actual_state == m_sm.m_bound_datagram_socket\n+\t\t    || actual_state == m_sm.m_bound_stream_socket\n+\t\t    || actual_state == m_sm.m_bound_unknown_socket\n+\t\t    || actual_state == m_sm.m_connected_stream_socket\n+\t\t    || actual_state == m_sm.m_listening_stream_socket);\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_LISTEN:\n+\tgcc_assert (actual_state == m_sm.m_new_stream_socket\n+\t\t    || actual_state == m_sm.m_new_unknown_socket\n+\t\t    || actual_state == m_sm.m_connected_stream_socket);\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_ACCEPT:\n+\tgcc_assert (actual_state == m_sm.m_new_stream_socket\n+\t\t    || actual_state == m_sm.m_new_unknown_socket\n+\t\t    || actual_state == m_sm.m_bound_stream_socket\n+\t\t    || actual_state == m_sm.m_bound_unknown_socket\n+\t\t    || actual_state == m_sm.m_connected_stream_socket);\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_CONNECT:\n+\tgcc_assert (actual_state == m_sm.m_bound_datagram_socket\n+\t\t    || actual_state == m_sm.m_bound_stream_socket\n+\t\t    || actual_state == m_sm.m_bound_unknown_socket\n+\t\t    || actual_state == m_sm.m_listening_stream_socket\n+\t\t    || actual_state == m_sm.m_connected_stream_socket);\n+\tbreak;\n+      }\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_phase_mismatch\";\n+  }\n+\n+  bool\n+  subclass_equal_p (const pending_diagnostic &base_other) const final override\n+  {\n+    const fd_phase_mismatch &sub_other = (const fd_phase_mismatch &)base_other;\n+    if (!fd_param_diagnostic ::subclass_equal_p (sub_other))\n+      return false;\n+    return (m_actual_state == sub_other.m_actual_state\n+\t    && m_expected_phase == sub_other.m_expected_phase);\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_phase_mismatch;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    /* CWE-666: Operation on Resource in Wrong Phase of Lifetime.  */\n+    diagnostic_metadata m;\n+    m.add_cwe (666);\n+    return warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"%qE on file descriptor %qE in wrong phase\",\n+\t\t       m_callee_fndecl, m_arg);\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    switch (m_expected_phase)\n+      {\n+      case EXPECTED_PHASE_CAN_TRANSFER:\n+\t{\n+\t  if (m_actual_state == m_sm.m_new_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a stream socket to be connected via %qs\"\n+\t       \" but %qE has not yet been bound\",\n+\t       m_callee_fndecl, \"accept\", m_arg);\n+\t  if (m_actual_state == m_sm.m_bound_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a stream socket to be connected via %qs\"\n+\t       \" but %qE is not yet listening\",\n+\t       m_callee_fndecl, \"accept\", m_arg);\n+\t  if (m_actual_state == m_sm.m_listening_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a stream socket to be connected via\"\n+\t       \" the return value of %qs\"\n+\t       \" but %qE is listening; wrong file descriptor?\",\n+\t       m_callee_fndecl, \"accept\", m_arg);\n+\t}\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_BIND:\n+\t{\n+\t  if (m_actual_state == m_sm.m_bound_datagram_socket\n+\t      || m_actual_state == m_sm.m_bound_stream_socket\n+\t      || m_actual_state == m_sm.m_bound_unknown_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a new socket file descriptor\"\n+\t       \" but %qE has already been bound\",\n+\t       m_callee_fndecl, m_arg);\n+\t  if (m_actual_state == m_sm.m_connected_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a new socket file descriptor\"\n+\t       \" but %qE is already connected\",\n+\t       m_callee_fndecl, m_arg);\n+\t  if (m_actual_state == m_sm.m_listening_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a new socket file descriptor\"\n+\t       \" but %qE is already listening\",\n+\t       m_callee_fndecl, m_arg);\n+\t}\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_LISTEN:\n+\t{\n+\t  if (m_actual_state == m_sm.m_new_stream_socket\n+\t      || m_actual_state == m_sm.m_new_unknown_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a bound stream socket file descriptor\"\n+\t       \" but %qE has not yet been bound\",\n+\t       m_callee_fndecl, m_arg);\n+\t  if (m_actual_state == m_sm.m_connected_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a bound stream socket file descriptor\"\n+\t       \" but %qE is connected\",\n+\t       m_callee_fndecl, m_arg);\n+\t}\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_ACCEPT:\n+\t{\n+\t  if (m_actual_state == m_sm.m_new_stream_socket\n+\t      || m_actual_state == m_sm.m_new_unknown_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a listening stream socket file descriptor\"\n+\t       \" but %qE has not yet been bound\",\n+\t       m_callee_fndecl, m_arg);\n+\t  if (m_actual_state == m_sm.m_bound_stream_socket\n+\t      || m_actual_state == m_sm.m_bound_unknown_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a listening stream socket file descriptor\"\n+\t       \" whereas %qE is bound but not yet listening\",\n+\t       m_callee_fndecl, m_arg);\n+\t  if (m_actual_state == m_sm.m_connected_stream_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a listening stream socket file descriptor\"\n+\t       \" but %qE is connected\",\n+\t       m_callee_fndecl, m_arg);\n+\t}\n+\tbreak;\n+      case EXPECTED_PHASE_CAN_CONNECT:\n+\t{\n+\t  if (m_actual_state == m_sm.m_bound_datagram_socket\n+\t      || m_actual_state == m_sm.m_bound_stream_socket\n+\t      || m_actual_state == m_sm.m_bound_unknown_socket)\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a new socket file descriptor but %qE is bound\",\n+\t       m_callee_fndecl, m_arg);\n+\t  else\n+\t    return ev.formatted_print\n+\t      (\"%qE expects a new socket file descriptor\", m_callee_fndecl);\n+\t}\n+\tbreak;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+private:\n+  state_machine::state_t m_actual_state;\n+  enum expected_phase m_expected_phase;\n+};\n+\n+/* Enum for use by -Wanalyzer-fd-type-mismatch.  */\n+\n+enum expected_type\n+{\n+ EXPECTED_TYPE_SOCKET,\n+ EXPECTED_TYPE_STREAM_SOCKET\n+};\n+\n+/* Concrete pending_diagnostic subclass for -Wanalyzer-fd-type-mismatch.  */\n+\n+class fd_type_mismatch : public fd_param_diagnostic\n+{\n+public:\n+  fd_type_mismatch (const fd_state_machine &sm, tree arg,\n+\t\t    const tree callee_fndecl,\n+\t\t    state_machine::state_t actual_state,\n+\t\t    enum expected_type expected_type)\n+  : fd_param_diagnostic (sm, arg, callee_fndecl),\n+    m_actual_state (actual_state),\n+    m_expected_type (expected_type)\n+  {\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_type_mismatch\";\n+  }\n+\n+  bool\n+  subclass_equal_p (const pending_diagnostic &base_other) const final override\n+  {\n+    const fd_type_mismatch &sub_other = (const fd_type_mismatch &)base_other;\n+    if (!fd_param_diagnostic ::subclass_equal_p (sub_other))\n+      return false;\n+    return (m_actual_state == sub_other.m_actual_state\n+\t    && m_expected_type == sub_other.m_expected_type);\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_type_mismatch;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    switch (m_expected_type)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case EXPECTED_TYPE_SOCKET:\n+\treturn warning_at (rich_loc, get_controlling_option (),\n+\t\t\t   \"%qE on non-socket file descriptor %qE\",\n+\t\t\t   m_callee_fndecl, m_arg);\n+      case EXPECTED_TYPE_STREAM_SOCKET:\n+\tif (m_sm.is_datagram_socket_fd_p (m_actual_state))\n+\t  return warning_at (rich_loc, get_controlling_option (),\n+\t\t\t     \"%qE on datagram socket file descriptor %qE\",\n+\t\t\t     m_callee_fndecl, m_arg);\n+\telse\n+\t  return warning_at (rich_loc, get_controlling_option (),\n+\t\t\t     \"%qE on non-stream-socket file descriptor %qE\",\n+\t\t\t     m_callee_fndecl, m_arg);\n+      }\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    switch (m_expected_type)\n+      {\n+      default:\n+\tbreak;\n+\tgcc_unreachable ();\n+      case EXPECTED_TYPE_SOCKET:\n+      case EXPECTED_TYPE_STREAM_SOCKET:\n+\tif (!m_sm.is_socket_fd_p (m_actual_state))\n+\t  return ev.formatted_print (\"%qE expects a socket file descriptor\"\n+\t\t\t\t     \" but %qE is not a socket\",\n+\t\t\t\t     m_callee_fndecl, m_arg);\n+      }\n+    gcc_assert (m_expected_type == EXPECTED_TYPE_STREAM_SOCKET);\n+    gcc_assert (m_sm.is_datagram_socket_fd_p (m_actual_state));\n+    return ev.formatted_print\n+      (\"%qE expects a stream socket file descriptor\"\n+       \" but %qE is a datagram socket\",\n+       m_callee_fndecl, m_arg);\n+  }\n+\n+private:\n+  state_machine::state_t m_actual_state;\n+  enum expected_type m_expected_type;\n+};\n+\n fd_state_machine::fd_state_machine (logger *logger)\n     : state_machine (\"file-descriptor\", logger),\n       m_constant_fd (add_state (\"fd-constant\")),\n@@ -691,10 +1078,20 @@ fd_state_machine::fd_state_machine (logger *logger)\n       m_valid_write_only (add_state (\"fd-valid-write-only\")),\n       m_invalid (add_state (\"fd-invalid\")),\n       m_closed (add_state (\"fd-closed\")),\n+      m_new_datagram_socket (add_state (\"fd-new-datagram-socket\")),\n+      m_new_stream_socket (add_state (\"fd-new-stream-socket\")),\n+      m_new_unknown_socket (add_state (\"fd-new-unknown-socket\")),\n+      m_bound_datagram_socket (add_state (\"fd-bound-datagram-socket\")),\n+      m_bound_stream_socket (add_state (\"fd-bound-stream-socket\")),\n+      m_bound_unknown_socket (add_state (\"fd-bound-unknown-socket\")),\n+      m_listening_stream_socket (add_state (\"fd-listening-stream-socket\")),\n+      m_connected_stream_socket (add_state (\"fd-connected-stream-socket\")),\n       m_stop (add_state (\"fd-stop\")),\n       m_O_ACCMODE (get_stashed_constant_by_name (\"O_ACCMODE\")),\n       m_O_RDONLY (get_stashed_constant_by_name (\"O_RDONLY\")),\n-      m_O_WRONLY (get_stashed_constant_by_name (\"O_WRONLY\"))\n+      m_O_WRONLY (get_stashed_constant_by_name (\"O_WRONLY\")),\n+      m_SOCK_STREAM (get_stashed_constant_by_name (\"SOCK_STREAM\")),\n+      m_SOCK_DGRAM (get_stashed_constant_by_name (\"SOCK_DGRAM\"))\n {\n }\n \n@@ -714,6 +1111,39 @@ fd_state_machine::is_valid_fd_p (state_t s) const\n        || s == m_valid_write_only);\n }\n \n+bool\n+fd_state_machine::is_socket_fd_p (state_t s) const\n+{\n+  return (s == m_new_datagram_socket\n+\t  || s == m_new_stream_socket\n+\t  || s == m_new_unknown_socket\n+\t  || s == m_bound_datagram_socket\n+\t  || s == m_bound_stream_socket\n+\t  || s == m_bound_unknown_socket\n+\t  || s == m_listening_stream_socket\n+\t  || s == m_connected_stream_socket);\n+}\n+\n+bool\n+fd_state_machine::is_datagram_socket_fd_p (state_t s) const\n+{\n+  return (s == m_new_datagram_socket\n+\t  || s == m_new_unknown_socket\n+\t  || s == m_bound_datagram_socket\n+\t  || s == m_bound_unknown_socket);\n+}\n+\n+bool\n+fd_state_machine::is_stream_socket_fd_p (state_t s) const\n+{\n+  return (s == m_new_stream_socket\n+\t  || s == m_new_unknown_socket\n+\t  || s == m_bound_stream_socket\n+\t  || s == m_bound_unknown_socket\n+\t  || s == m_listening_stream_socket\n+\t  || s == m_connected_stream_socket);\n+}\n+\n enum access_mode\n fd_state_machine::get_access_mode_from_flag (int flag) const\n {\n@@ -1079,6 +1509,14 @@ fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\n   sm_ctxt->on_transition (node, stmt, arg, m_valid_read_only, m_closed);\n   sm_ctxt->on_transition (node, stmt, arg, m_valid_write_only, m_closed);\n   sm_ctxt->on_transition (node, stmt, arg, m_constant_fd, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_new_datagram_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_new_stream_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_new_unknown_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_bound_datagram_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_bound_stream_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_bound_unknown_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_listening_stream_socket, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_connected_stream_socket, m_closed);\n \n   if (is_closed_fd_p (state))\n     {\n@@ -1121,7 +1559,22 @@ fd_state_machine::check_for_open_fd (\n \n   else\n     {\n-      if (!(is_valid_fd_p (state) || state == m_start || state == m_stop))\n+      if (state == m_new_stream_socket\n+\t  || state == m_bound_stream_socket\n+\t  || state == m_listening_stream_socket)\n+\t/* Complain about fncall on socket in wrong phase.  */\n+\tsm_ctxt->warn\n+\t  (node, stmt, arg,\n+\t   make_unique<fd_phase_mismatch> (*this, diag_arg,\n+\t\t\t\t\t   callee_fndecl,\n+\t\t\t\t\t   state,\n+\t\t\t\t\t   EXPECTED_PHASE_CAN_TRANSFER));\n+      else if (!(is_valid_fd_p (state)\n+\t\t || state == m_new_datagram_socket\n+\t\t || state == m_bound_unknown_socket\n+\t\t || state == m_connected_stream_socket\n+\t\t || state == m_start\n+\t\t || state == m_stop))\n \t{\n \t  if (!is_constant_fd_p (state))\n \t    sm_ctxt->warn (\n@@ -1157,6 +1610,529 @@ fd_state_machine::check_for_open_fd (\n     }\n }\n \n+static bool\n+add_constraint_ge_zero (region_model *model,\n+\t\t\tconst svalue *fd_sval,\n+\t\t\tregion_model_context *ctxt)\n+{\n+  const svalue *zero\n+    = model->get_manager ()->get_or_create_int_cst (integer_type_node, 0);\n+  return model->add_constraint (fd_sval, GE_EXPR, zero, ctxt);\n+}\n+\n+/* Get the state for a new socket type based on SOCKET_TYPE_SVAL,\n+   a SOCK_* value.  */\n+\n+state_machine::state_t\n+fd_state_machine::\n+get_state_for_socket_type (const svalue *socket_type_sval) const\n+{\n+  if (tree socket_type_cst = socket_type_sval->maybe_get_constant ())\n+    {\n+      /* Attempt to use SOCK_* constants stashed from the frontend.  */\n+      if (tree_int_cst_equal (socket_type_cst, m_SOCK_STREAM))\n+\treturn m_new_stream_socket;\n+      if (tree_int_cst_equal (socket_type_cst, m_SOCK_DGRAM))\n+\treturn m_new_datagram_socket;\n+    }\n+\n+  /* Unrecognized constant, or a symbolic \"type\" value.  */\n+  return m_new_unknown_socket;\n+}\n+\n+/* Update the model and fd state for an outcome of a call to \"socket\",\n+   where SUCCESSFUL indicate which of the two outcomes.\n+   Return true if the outcome is feasible, or false to reject it.  */\n+\n+bool\n+fd_state_machine::on_socket (const call_details &cd,\n+\t\t\t     bool successful,\n+\t\t\t     sm_context *sm_ctxt,\n+\t\t\t     const extrinsic_state &ext_state) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+  engine *eng = ext_state.get_engine ();\n+  const supergraph *sg = eng->get_supergraph ();\n+  const supernode *node = sg->get_supernode_for_stmt (stmt);\n+  region_model *model = cd.get_model ();\n+\n+  if (successful)\n+    {\n+      if (gimple_call_lhs (stmt))\n+\t{\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  region_model_manager *mgr = model->get_manager ();\n+\t  const svalue *new_fd\n+\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n+\t\t\t\t\t\t  stmt,\n+\t\t\t\t\t\t  cd.get_lhs_region (),\n+\t\t\t\t\t\t  p);\n+\t  if (!add_constraint_ge_zero (model, new_fd, cd.get_ctxt ()))\n+\t    return false;\n+\n+\t  const svalue *socket_type_sval = cd.get_arg_svalue (1);\n+\t  state_machine::state_t new_state\n+\t    = get_state_for_socket_type (socket_type_sval);\n+\t  sm_ctxt->on_transition (node, stmt, new_fd, m_start, new_state);\n+\t  model->set_value (cd.get_lhs_region (), new_fd, cd.get_ctxt ());\n+\t}\n+      else\n+\tsm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t       make_unique<fd_leak> (*this, NULL_TREE));\n+    }\n+  else\n+    {\n+      /* Return -1; set errno.  */\n+      model->update_for_int_cst_return (cd, -1, true);\n+      model->set_errno (cd);\n+    }\n+\n+  return true;\n+}\n+\n+/* Check that FD_SVAL is usable by socket APIs.\n+   Complain if it has been closed, if it is a non-socket,\n+   or is invalid.\n+   If COMPLAINED is non-NULL and a problem is found,\n+   write *COMPLAINED = true.\n+\n+   If SUCCESSFUL is true, attempt to add the constraint that FD_SVAL >= 0.\n+   Return true if this outcome is feasible.  */\n+\n+bool\n+fd_state_machine::check_for_socket_fd (const call_details &cd,\n+\t\t\t\t       bool successful,\n+\t\t\t\t       sm_context *sm_ctxt,\n+\t\t\t\t       const svalue *fd_sval,\n+\t\t\t\t       const supernode *node,\n+\t\t\t\t       state_t old_state,\n+\t\t\t\t       bool *complained) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+\n+  if (is_closed_fd_p (old_state))\n+    {\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      sm_ctxt->warn\n+\t(node, stmt, fd_sval,\n+\t make_unique<fd_use_after_close> (*this, diag_arg,\n+\t\t\t\t\t  cd.get_fndecl_for_call ()));\n+      if (complained)\n+\t*complained = true;\n+      if (successful)\n+\treturn false;\n+    }\n+  else if (is_unchecked_fd_p (old_state) || is_valid_fd_p (old_state))\n+    {\n+      /* Complain about non-socket.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      sm_ctxt->warn\n+\t(node, stmt, fd_sval,\n+\t make_unique<fd_type_mismatch> (*this, diag_arg,\n+\t\t\t\t\tcd.get_fndecl_for_call (),\n+\t\t\t\t\told_state,\n+\t\t\t\t\tEXPECTED_TYPE_SOCKET));\n+      if (complained)\n+\t*complained = true;\n+      if (successful)\n+\treturn false;\n+    }\n+  else if (old_state == m_invalid)\n+    {\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      sm_ctxt->warn\n+\t(node, stmt, fd_sval,\n+\t make_unique<fd_use_without_check> (*this, diag_arg,\n+\t\t\t\t\t    cd.get_fndecl_for_call ()));\n+      if (complained)\n+\t*complained = true;\n+      if (successful)\n+\treturn false;\n+    }\n+\n+  if (successful)\n+    if (!add_constraint_ge_zero (cd.get_model (), fd_sval, cd.get_ctxt ()))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* For use by \"bind\" and \"connect\".\n+   As per fd_state_machine::check_for_socket_fd above,\n+   but also complain if we don't have a new socket, and check that\n+   we can read up to the size bytes from the address.  */\n+\n+bool\n+fd_state_machine::check_for_new_socket_fd (const call_details &cd,\n+\t\t\t\t\t   bool successful,\n+\t\t\t\t\t   sm_context *sm_ctxt,\n+\t\t\t\t\t   const svalue *fd_sval,\n+\t\t\t\t\t   const supernode *node,\n+\t\t\t\t\t   state_t old_state,\n+\t\t\t\t\t   enum expected_phase expected_phase)\n+  const\n+{\n+  bool complained = false;\n+\n+  /* Check address and len.  */\n+  const svalue *address_sval = cd.get_arg_svalue (1);\n+  const svalue *len_sval = cd.get_arg_svalue (2);\n+\n+  /* Check that we can read the given number of bytes from the\n+     address.  */\n+  region_model *model = cd.get_model ();\n+  const region *address_reg\n+    = model->deref_rvalue (address_sval, cd.get_arg_tree (1),\n+\t\t\t   cd.get_ctxt ());\n+  const region *sized_address_reg\n+    = model->get_manager ()->get_sized_region (address_reg,\n+\t\t\t\t\t       NULL_TREE,\n+\t\t\t\t\t       len_sval);\n+  model->get_store_value (sized_address_reg, cd.get_ctxt ());\n+\n+  if (!check_for_socket_fd (cd, successful, sm_ctxt,\n+\t\t\t    fd_sval, node, old_state, &complained))\n+    return false;\n+  else if (!complained\n+\t   && !(old_state == m_new_stream_socket\n+\t\t|| old_state == m_new_datagram_socket\n+\t\t|| old_state == m_new_unknown_socket\n+\t\t|| old_state == m_start\n+\t\t|| old_state == m_stop))\n+    {\n+      /* Complain about \"bind\" or \"connect\" in wrong phase.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      sm_ctxt->warn\n+\t(node, cd.get_call_stmt (), fd_sval,\n+\t make_unique<fd_phase_mismatch> (*this, diag_arg,\n+\t\t\t\t\t cd.get_fndecl_for_call (),\n+\t\t\t\t\t old_state,\n+\t\t\t\t\t expected_phase));\n+      if (successful)\n+\treturn false;\n+    }\n+  else if (!successful)\n+    {\n+      /* If we were in the start state, assume we had a new socket.  */\n+      if (old_state == m_start)\n+\tsm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval,\n+\t\t\t\t m_new_unknown_socket);\n+    }\n+\n+  /* Passing NULL as the address will lead to failure.  */\n+  if (successful)\n+    if (address_sval->all_zeroes_p ())\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Update the model and fd state for an outcome of a call to \"bind\",\n+   where SUCCESSFUL indicate which of the two outcomes.\n+   Return true if the outcome is feasible, or false to reject it.  */\n+\n+bool\n+fd_state_machine::on_bind (const call_details &cd,\n+\t\t\t   bool successful,\n+\t\t\t   sm_context *sm_ctxt,\n+\t\t\t   const extrinsic_state &ext_state) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+  engine *eng = ext_state.get_engine ();\n+  const supergraph *sg = eng->get_supergraph ();\n+  const supernode *node = sg->get_supernode_for_stmt (stmt);\n+  const svalue *fd_sval = cd.get_arg_svalue (0);\n+  region_model *model = cd.get_model ();\n+  state_t old_state = sm_ctxt->get_state (stmt, fd_sval);\n+\n+  if (!check_for_new_socket_fd (cd, successful, sm_ctxt,\n+\t\t\t\tfd_sval, node, old_state,\n+\t\t\t\tEXPECTED_PHASE_CAN_BIND))\n+    return false;\n+\n+  if (successful)\n+    {\n+      state_t next_state = NULL;\n+      if (old_state == m_new_stream_socket)\n+\tnext_state = m_bound_stream_socket;\n+      else if (old_state == m_new_datagram_socket)\n+\tnext_state = m_bound_datagram_socket;\n+      else if (old_state == m_new_unknown_socket)\n+\tnext_state = m_bound_unknown_socket;\n+      else if (old_state == m_start)\n+\tnext_state = m_bound_unknown_socket;\n+      else if (old_state == m_stop)\n+\tnext_state = m_stop;\n+      else\n+\tgcc_unreachable ();\n+      sm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval, next_state);\n+      model->update_for_zero_return (cd, true);\n+    }\n+  else\n+    {\n+      /* Return -1; set errno.  */\n+      model->update_for_int_cst_return (cd, -1, true);\n+      model->set_errno (cd);\n+    }\n+\n+  return true;\n+}\n+\n+/* Update the model and fd state for an outcome of a call to \"listen\",\n+   where SUCCESSFUL indicate which of the two outcomes.\n+   Return true if the outcome is feasible, or false to reject it.  */\n+\n+bool\n+fd_state_machine::on_listen (const call_details &cd,\n+\t\t\t     bool successful,\n+\t\t\t     sm_context *sm_ctxt,\n+\t\t\t     const extrinsic_state &ext_state) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+  engine *eng = ext_state.get_engine ();\n+  const supergraph *sg = eng->get_supergraph ();\n+  const supernode *node = sg->get_supernode_for_stmt (cd.get_call_stmt ());\n+  const svalue *fd_sval = cd.get_arg_svalue (0);\n+  region_model *model = cd.get_model ();\n+  state_t old_state = sm_ctxt->get_state (stmt, fd_sval);\n+\n+  /* We expect a stream socket that's had \"bind\" called on it.  */\n+  if (!check_for_socket_fd (cd, successful, sm_ctxt, fd_sval, node, old_state))\n+    return false;\n+  if (!(old_state == m_start\n+\t|| old_state == m_stop\n+\t|| old_state == m_bound_stream_socket\n+\t|| old_state == m_bound_unknown_socket\n+\t/* Assume it's OK to call \"listen\" more than once.  */\n+\t|| old_state == m_listening_stream_socket))\n+    {\n+      /* Complain about fncall on wrong type or in wrong phase.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      if (is_stream_socket_fd_p (old_state))\n+\tsm_ctxt->warn\n+\t  (node, stmt, fd_sval,\n+\t   make_unique<fd_phase_mismatch> (*this, diag_arg,\n+\t\t\t\t\t   cd.get_fndecl_for_call (),\n+\t\t\t\t\t   old_state,\n+\t\t\t\t\t   EXPECTED_PHASE_CAN_LISTEN));\n+      else\n+\tsm_ctxt->warn\n+\t  (node, stmt, fd_sval,\n+\t   make_unique<fd_type_mismatch> (*this, diag_arg,\n+\t\t\t\t\t  cd.get_fndecl_for_call (),\n+\t\t\t\t\t  old_state,\n+\t\t\t\t\t  EXPECTED_TYPE_STREAM_SOCKET));\n+      if (successful)\n+\treturn false;\n+    }\n+\n+  if (successful)\n+    {\n+      model->update_for_zero_return (cd, true);\n+      sm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval,\n+\t\t\t       m_listening_stream_socket);\n+    }\n+  else\n+    {\n+      /* Return -1; set errno.  */\n+      model->update_for_int_cst_return (cd, -1, true);\n+      model->set_errno (cd);\n+      if (old_state == m_start)\n+\tsm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval,\n+\t\t\t\t m_bound_stream_socket);\n+    }\n+\n+  return true;\n+}\n+\n+/* Update the model and fd state for an outcome of a call to \"accept\",\n+   where SUCCESSFUL indicate which of the two outcomes.\n+   Return true if the outcome is feasible, or false to reject it.  */\n+\n+bool\n+fd_state_machine::on_accept (const call_details &cd,\n+\t\t\t     bool successful,\n+\t\t\t     sm_context *sm_ctxt,\n+\t\t\t     const extrinsic_state &ext_state) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+  engine *eng = ext_state.get_engine ();\n+  const supergraph *sg = eng->get_supergraph ();\n+  const supernode *node = sg->get_supernode_for_stmt (stmt);\n+  const svalue *fd_sval = cd.get_arg_svalue (0);\n+  const svalue *address_sval = cd.get_arg_svalue (1);\n+  const svalue *len_ptr_sval = cd.get_arg_svalue (2);\n+  region_model *model = cd.get_model ();\n+  state_t old_state = sm_ctxt->get_state (stmt, fd_sval);\n+\n+  if (!address_sval->all_zeroes_p ())\n+    {\n+      region_model_manager *mgr = model->get_manager ();\n+\n+      /* We might have a union of various pointer types, rather than a\n+\t pointer type; cast to (void *) before dereferencing.  */\n+      address_sval = mgr->get_or_create_cast (ptr_type_node, address_sval);\n+\n+      const region *address_reg\n+\t= model->deref_rvalue (address_sval, cd.get_arg_tree (1),\n+\t\t\t       cd.get_ctxt ());\n+      const region *len_reg\n+\t= model->deref_rvalue (len_ptr_sval, cd.get_arg_tree (2),\n+\t\t\t       cd.get_ctxt ());\n+      const svalue *old_len_sval\n+\t= model->get_store_value (len_reg, cd.get_ctxt ());\n+      tree len_ptr = cd.get_arg_tree (2);\n+      tree star_len_ptr = build2 (MEM_REF, TREE_TYPE (TREE_TYPE (len_ptr)),\n+\t\t\t\t  len_ptr,\n+\t\t\t\t  build_int_cst (TREE_TYPE (len_ptr), 0));\n+      old_len_sval = model->check_for_poison (old_len_sval,\n+\t\t\t\t\t      star_len_ptr,\n+\t\t\t\t\t      cd.get_ctxt ());\n+      if (successful)\n+\t{\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  const region *old_sized_address_reg\n+\t    = mgr->get_sized_region (address_reg,\n+\t\t\t\t     NULL_TREE,\n+\t\t\t\t     old_len_sval);\n+\t  const svalue *new_addr_sval\n+\t    = mgr->get_or_create_conjured_svalue (NULL_TREE,\n+\t\t\t\t\t\t  stmt,\n+\t\t\t\t\t\t  old_sized_address_reg,\n+\t\t\t\t\t\t  p);\n+\t  model->set_value (old_sized_address_reg, new_addr_sval,\n+\t\t\t    cd.get_ctxt ());\n+\t  const svalue *new_addr_len\n+\t    = mgr->get_or_create_conjured_svalue (NULL_TREE,\n+\t\t\t\t\t\t  stmt,\n+\t\t\t\t\t\t  len_reg,\n+\t\t\t\t\t\t  p);\n+\t  model->set_value (len_reg, new_addr_len, cd.get_ctxt ());\n+\t}\n+    }\n+\n+  /* We expect a stream socket in the \"listening\" state.  */\n+  if (!check_for_socket_fd (cd, successful, sm_ctxt, fd_sval, node, old_state))\n+    return false;\n+\n+  if (old_state == m_start)\n+    /* If we were in the start state, assume we had the expected state.  */\n+    sm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval,\n+\t\t\t     m_listening_stream_socket);\n+  else if (old_state == m_stop)\n+    {\n+      /* No further complaints.  */\n+    }\n+  else if (old_state != m_listening_stream_socket)\n+    {\n+      /* Complain about fncall on wrong type or in wrong phase.  */\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (fd_sval);\n+      if (is_stream_socket_fd_p (old_state))\n+\tsm_ctxt->warn\n+\t  (node, stmt, fd_sval,\n+\t   make_unique<fd_phase_mismatch> (*this, diag_arg,\n+\t\t\t\t\t   cd.get_fndecl_for_call (),\n+\t\t\t\t\t   old_state,\n+\t\t\t\t\t   EXPECTED_PHASE_CAN_ACCEPT));\n+      else\n+\tsm_ctxt->warn\n+\t  (node, stmt, fd_sval,\n+\t   make_unique<fd_type_mismatch> (*this, diag_arg,\n+\t\t\t\t\t  cd.get_fndecl_for_call (),\n+\t\t\t\t\t  old_state,\n+\t\t\t\t\t  EXPECTED_TYPE_STREAM_SOCKET));\n+      if (successful)\n+\treturn false;\n+    }\n+\n+  if (successful)\n+    {\n+      /* Return new conjured FD in \"connected\" state.  */\n+      if (gimple_call_lhs (stmt))\n+\t{\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  region_model_manager *mgr = model->get_manager ();\n+\t  const svalue *new_fd\n+\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n+\t\t\t\t\t\t  stmt,\n+\t\t\t\t\t\t  cd.get_lhs_region (),\n+\t\t\t\t\t\t  p);\n+\t  if (!add_constraint_ge_zero (model, new_fd, cd.get_ctxt ()))\n+\t    return false;\n+\t  sm_ctxt->on_transition (node, stmt, new_fd,\n+\t\t\t\t  m_start, m_connected_stream_socket);\n+\t  model->set_value (cd.get_lhs_region (), new_fd, cd.get_ctxt ());\n+\t}\n+      else\n+\tsm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t       make_unique<fd_leak> (*this, NULL_TREE));\n+    }\n+  else\n+    {\n+      /* Return -1; set errno.  */\n+      model->update_for_int_cst_return (cd, -1, true);\n+      model->set_errno (cd);\n+    }\n+\n+  return true;\n+}\n+\n+/* Update the model and fd state for an outcome of a call to \"connect\",\n+   where SUCCESSFUL indicate which of the two outcomes.\n+   Return true if the outcome is feasible, or false to reject it.  */\n+\n+bool\n+fd_state_machine::on_connect (const call_details &cd,\n+\t\t\t      bool successful,\n+\t\t\t      sm_context *sm_ctxt,\n+\t\t\t      const extrinsic_state &ext_state) const\n+{\n+  const gcall *stmt = cd.get_call_stmt ();\n+  engine *eng = ext_state.get_engine ();\n+  const supergraph *sg = eng->get_supergraph ();\n+  const supernode *node = sg->get_supernode_for_stmt (stmt);\n+  const svalue *fd_sval = cd.get_arg_svalue (0);\n+  region_model *model = cd.get_model ();\n+  state_t old_state = sm_ctxt->get_state (stmt, fd_sval);\n+\n+  if (!check_for_new_socket_fd (cd, successful, sm_ctxt,\n+\t\t\t\tfd_sval, node, old_state,\n+\t\t\t\tEXPECTED_PHASE_CAN_CONNECT))\n+    return false;\n+\n+  if (successful)\n+    {\n+      model->update_for_zero_return (cd, true);\n+      state_t next_state = NULL;\n+      if (old_state == m_new_stream_socket)\n+\tnext_state = m_connected_stream_socket;\n+      else if (old_state == m_new_datagram_socket)\n+\t/* It's legal to call connect on a datagram socket, potentially\n+\t   more than once.  We don't transition states for this.  */\n+\tnext_state = m_new_datagram_socket;\n+      else if (old_state == m_new_unknown_socket)\n+\tnext_state = m_stop;\n+      else if (old_state == m_start)\n+\tnext_state = m_stop;\n+      else if (old_state == m_stop)\n+\tnext_state = m_stop;\n+      else\n+\tgcc_unreachable ();\n+      sm_ctxt->set_next_state (cd.get_call_stmt (), fd_sval, next_state);\n+    }\n+  else\n+    {\n+      /* Return -1; set errno.  */\n+      model->update_for_int_cst_return (cd, -1, true);\n+      model->set_errno (cd);\n+      /* TODO: perhaps transition to a failed state, since the\n+\t portable way to handle a failed \"connect\" is to close\n+\t the socket and try again with a new socket.  */\n+    }\n+\n+  return true;\n+}\n+\n void\n fd_state_machine::on_condition (sm_context *sm_ctxt, const supernode *node,\n \t\t\t\tconst gimple *stmt, const svalue *lhs,\n@@ -1215,7 +2191,9 @@ fd_state_machine::make_invalid_transitions_on_condition (\n bool\n fd_state_machine::can_purge_p (state_t s) const\n {\n-  if (is_unchecked_fd_p (s) || is_valid_fd_p (s))\n+  if (is_unchecked_fd_p (s)\n+      || is_valid_fd_p (s)\n+      || is_socket_fd_p (s))\n     return false;\n   else\n     return true;\n@@ -1234,30 +2212,130 @@ make_fd_state_machine (logger *logger)\n   return new fd_state_machine (logger);\n }\n \n+static bool\n+get_fd_state (region_model_context *ctxt,\n+\t      sm_state_map **out_smap,\n+\t      const fd_state_machine **out_sm,\n+\t      unsigned *out_sm_idx,\n+\t      std::unique_ptr<sm_context> *out_sm_context)\n+{\n+  if (!ctxt)\n+    return false;\n+\n+  const state_machine *sm;\n+  if (!ctxt->get_fd_map (out_smap, &sm, out_sm_idx, out_sm_context))\n+    return false;\n+\n+  gcc_assert (sm);\n+\n+  *out_sm = (const fd_state_machine *)sm;\n+  return true;\n+}\n+\n /* Specialcase hook for handling pipe, for use by\n    region_model::impl_call_pipe::success::update_model.  */\n \n void\n region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n {\n-  if (!ctxt)\n+  sm_state_map *smap;\n+  const fd_state_machine *fd_sm;\n+  if (!get_fd_state (ctxt, &smap, &fd_sm, NULL, NULL))\n     return;\n   const extrinsic_state *ext_state = ctxt->get_ext_state ();\n   if (!ext_state)\n     return;\n+  fd_sm->mark_as_valid_fd (this, smap, sval, *ext_state);\n+}\n \n+/* Specialcase hook for handling \"socket\", for use by\n+   region_model::impl_call_socket::outcome_of_socket::update_model.  */\n+\n+bool\n+region_model::on_socket (const call_details &cd, bool successful)\n+{\n   sm_state_map *smap;\n-  const state_machine *sm;\n-  unsigned sm_idx;\n-  if (!ctxt->get_fd_map (&smap, &sm, &sm_idx))\n-    return;\n+  const fd_state_machine *fd_sm;\n+  std::unique_ptr<sm_context> sm_ctxt;\n+  if (!get_fd_state (cd.get_ctxt (), &smap, &fd_sm, NULL, &sm_ctxt))\n+    return true;\n+  const extrinsic_state *ext_state = cd.get_ctxt ()->get_ext_state ();\n+  if (!ext_state)\n+    return true;\n \n-  gcc_assert (smap);\n-  gcc_assert (sm);\n+  return fd_sm->on_socket (cd, successful, sm_ctxt.get (), *ext_state);\n+}\n+\n+/* Specialcase hook for handling \"bind\", for use by\n+   region_model::impl_call_bind::outcome_of_bind::update_model.  */\n+\n+bool\n+region_model::on_bind (const call_details &cd, bool successful)\n+{\n+  sm_state_map *smap;\n+  const fd_state_machine *fd_sm;\n+  std::unique_ptr<sm_context> sm_ctxt;\n+  if (!get_fd_state (cd.get_ctxt (), &smap, &fd_sm, NULL, &sm_ctxt))\n+    return true;\n+  const extrinsic_state *ext_state = cd.get_ctxt ()->get_ext_state ();\n+  if (!ext_state)\n+    return true;\n+\n+  return fd_sm->on_bind (cd, successful, sm_ctxt.get (), *ext_state);\n+}\n+\n+/* Specialcase hook for handling \"listen\", for use by\n+   region_model::impl_call_listen::outcome_of_listen::update_model.  */\n+\n+bool\n+region_model::on_listen (const call_details &cd, bool successful)\n+{\n+  sm_state_map *smap;\n+  const fd_state_machine *fd_sm;\n+  std::unique_ptr<sm_context> sm_ctxt;\n+  if (!get_fd_state (cd.get_ctxt (), &smap, &fd_sm, NULL, &sm_ctxt))\n+    return true;\n+  const extrinsic_state *ext_state = cd.get_ctxt ()->get_ext_state ();\n+  if (!ext_state)\n+    return true;\n+\n+  return fd_sm->on_listen (cd, successful, sm_ctxt.get (), *ext_state);\n+}\n+\n+/* Specialcase hook for handling \"accept\", for use by\n+   region_model::impl_call_accept::outcome_of_accept::update_model.  */\n+\n+bool\n+region_model::on_accept (const call_details &cd, bool successful)\n+{\n+  sm_state_map *smap;\n+  const fd_state_machine *fd_sm;\n+  std::unique_ptr<sm_context> sm_ctxt;\n+  if (!get_fd_state (cd.get_ctxt (), &smap, &fd_sm, NULL, &sm_ctxt))\n+    return true;\n+  const extrinsic_state *ext_state = cd.get_ctxt ()->get_ext_state ();\n+  if (!ext_state)\n+    return true;\n+\n+  return fd_sm->on_accept (cd, successful, sm_ctxt.get (), *ext_state);\n+}\n \n-  const fd_state_machine &fd_sm = (const fd_state_machine &)*sm;\n+/* Specialcase hook for handling \"connect\", for use by\n+   region_model::impl_call_connect::outcome_of_connect::update_model.  */\n+\n+bool\n+region_model::on_connect (const call_details &cd, bool successful)\n+{\n+  sm_state_map *smap;\n+  const fd_state_machine *fd_sm;\n+  std::unique_ptr<sm_context> sm_ctxt;\n+  if (!get_fd_state (cd.get_ctxt (), &smap, &fd_sm, NULL, &sm_ctxt))\n+    return true;\n+  const extrinsic_state *ext_state = cd.get_ctxt ()->get_ext_state ();\n+  if (!ext_state)\n+    return true;\n \n-  fd_sm.mark_as_valid_fd (this, smap, sval, *ext_state);\n+  return fd_sm->on_connect (cd, successful, sm_ctxt.get (), *ext_state);\n }\n \n } // namespace ana"}, {"sha": "da925b0989fefb258e50d324c60e28f704343d5d", "filename": "gcc/analyzer/sm-fd.dot", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fsm-fd.dot", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fanalyzer%2Fsm-fd.dot", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.dot?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -46,6 +46,29 @@ digraph \"fd\" {\n   /* State for a file descriptor that has been closed.  */\n   closed;\n \n+  /* States for FDs relating to socket APIs.  */\n+\n+  /* Result of successful \"socket\" with SOCK_DGRAM.  */\n+  new_datagram_socket;\n+  /* Result of successful \"socket\" with SOCK_STREAM.  */\n+  new_stream_socket;\n+  /* Result of successful \"socket\" with unknown type.  */\n+  new_unknown_socket;\n+\n+  /* The above after a successful call to \"bind\".  */\n+  bound_datagram_socket;\n+  bound_stream_socket;\n+  bound_unknown_socket;\n+\n+  /* A bound socket after a successful call to \"listen\" (stream or unknown).  */\n+  listening_stream_socket;\n+\n+  /* (i) the new FD as a result of a succesful call to \"accept\" on a\n+      listening socket (via a passive open), or\n+     (ii) an active socket after a successful call to \"connect\"\n+     (via an active open).  */\n+  connected_stream_socket;\n+\n   /* State for a file descriptor that we do not want to track anymore . */\n   stop;\n \n@@ -68,6 +91,14 @@ digraph \"fd\" {\n   valid_read_only -> closed [label=\"on 'close(X);'\"];\n   valid_write_only -> closed [label=\"on 'close(X);'\"];\n   constant_fd -> closed [label=\"on 'close(X);'\"];\n+  new_datagram_socket -> closed [label=\"on 'close(X);'\"];\n+  new_stream_socket -> closed [label=\"on 'close(X);'\"];\n+  new_unknown_socket -> closed [label=\"on 'close(X);'\"];\n+  bound_datagram_socket -> closed [label=\"on 'close(X);'\"];\n+  bound_stream_socket -> closed [label=\"on 'close(X);'\"];\n+  bound_unknown_socket -> closed [label=\"on 'close(X);'\"];\n+  listening_stream_socket -> closed [label=\"on 'close(X);'\"];\n+  connected_stream_socket -> closed [label=\"on 'close(X);'\"];\n   closed -> stop [label=\"on 'close(X);':\\nWarn('double close')\"];\n \n   /* On \"read\".  */\n@@ -91,6 +122,31 @@ digraph \"fd\" {\n   /* On \"pipe\".  */\n   start -> valid_read_write [label=\"when 'pipe()' succeeds\"];\n \n+  /* On \"socket\".  */\n+  start -> new_datagram_socket [label=\"when 'socket(..., SOCK_DGRAM, ...)' succeeds\"];\n+  start -> new_stream_socket [label=\"when 'socket(..., SOCK_STREAM, ...)' succeeds\"];\n+  start -> new_unknown_socket [label=\"when 'socket(..., ..., ...)' succeeds\"];\n+\n+  /* On \"bind\".  */\n+  start -> bound_unknown_socket [label=\"when 'bind(X, ...)' succeeds\"];\n+  new_stream_socket -> bound_stream_socket [label=\"when 'bind(X, ...)' succeeds\"];\n+  new_datagram_socket -> bound_datagram_socket [label=\"when 'bind(X, ...)' succeeds\"];\n+  new_unknown_socket -> bound_unknown_socket [label=\"when 'bind(X, ...)' succeeds\"];\n+\n+  /* On \"listen\".  */\n+  start -> listening_stream_socket [label=\"when 'listen(X, ...)' succeeds\"];\n+  bound_stream_socket -> listening_stream_socket [label=\"when 'listen(X, ...)' succeeds\"];\n+  bound_unknown_socket -> listening_stream_socket [label=\"when 'listen(X, ...)' succeeds\"];\n+\n+  /* On \"accept\".  */\n+  start -> connected_stream_socket [label=\"when 'accept(OTHER, ...)' succeeds on a listening_stream_socket\"];\n+\n+  /* On \"connect\".  */\n+  new_stream_socket -> connected_stream_socket [label=\"when 'connect(X, ...)' succeeds\"];\n+  new_datagram_socket -> new_datagram_socket [label=\"when 'connect(X, ...)' succeeds\"];\n+  new_unknown_socket -> stop [label=\"when 'connect(X, ...)' succeeds\"];\n+  start -> stop [label=\"when 'connect(X, ...)' succeeds\"];\n+\n   /* on_condition.  */\n   unchecked_read_write -> valid_read_write [label=\"on 'X >= 0'\"];\n   unchecked_read_only -> valid_read_only [label=\"on 'X >= 0'\"];\n@@ -106,4 +162,12 @@ digraph \"fd\" {\n   valid_read_write -> stop [label=\"on leak:\\nWarn('leak')\"];\n   valid_read_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n   valid_write_only -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  new_datagram_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  new_stream_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  new_unknown_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  bound_datagram_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  bound_stream_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  bound_unknown_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  listening_stream_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  connected_stream_socket -> stop [label=\"on leak:\\nWarn('leak')\"];\n }"}, {"sha": "057439a004cc1f3897a4ccbfb12920fbcffaa24b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -453,6 +453,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-fd-access-mode-mismatch @gol\n -Wno-analyzer-fd-double-close @gol\n -Wno-analyzer-fd-leak @gol\n+-Wno-analyzer-fd-phase-mismatch @gol\n+-Wno-analyzer-fd-type-mismatch @gol\n -Wno-analyzer-fd-use-after-close @gol\n -Wno-analyzer-fd-use-without-check @gol\n -Wno-analyzer-file-leak @gol\n@@ -9899,6 +9901,8 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-fd-access-mode-mismatch @gol\n -Wanalyzer-fd-double-close @gol\n -Wanalyzer-fd-leak @gol\n+-Wanalyzer-fd-phase-mismatch @gol\n+-Wanalyzer-fd-type-mismatch @gol\n -Wanalyzer-fd-use-after-close @gol\n -Wanalyzer-fd-use-without-check @gol\n -Wanalyzer-file-leak @gol\n@@ -10077,6 +10081,33 @@ open file descriptor is leaked.\n \n See @uref{https://cwe.mitre.org/data/definitions/775.html, CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime}.\n \n+@item -Wno-analyzer-fd-phase-mismatch\n+@opindex Wanalyzer-fd-phase-mismatch\n+@opindex Wno-analyzer-fd-phase-mismatch\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-phase-mismatch}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which an operation is\n+attempted in the wrong phase of a file descriptor's lifetime.\n+For example, it will warn on attempts to call @code{accept} on a stream\n+socket that has not yet had @code{listen} successfully called on it.\n+\n+See @uref{https://cwe.mitre.org/data/definitions/666.html, CWE-666: Operation on Resource in Wrong Phase of Lifetime}.\n+\n+@item -Wno-analyzer-fd-type-mismatch\n+@opindex Wanalyzer-fd-type-mismatch\n+@opindex Wno-analyzer-fd-type-mismatch\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-type-mismatch}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which an\n+operation is attempted on the wrong type of file descriptor.\n+For example, it will warn on attempts to use socket operations\n+on a file descriptor obtained via @code{open}, or when attempting\n+to use a stream socket operation on a datagram socket.\n+\n @item -Wno-analyzer-fd-use-after-close\n @opindex Wanalyzer-fd-use-after-close\n @opindex Wno-analyzer-fd-use-after-close\n@@ -10616,6 +10647,7 @@ of the following functions for working with file descriptors:\n @item @code{pipe}, and @code{pipe2}\n @item @code{read}\n @item @code{write}\n+@item @code{socket}, @code{bind}, @code{listen}, @code{accept}, and @code{connect}\n @end itemize\n \n of the following functions for working with @code{<stdio.h>} streams:"}, {"sha": "36cc7af7184379cf088e448ee6bfcb946c821088", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-accept.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-accept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-accept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-accept.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,69 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+int test_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n+{\n+  return accept (fd, addr, addrlen);\n+}\n+\n+void test_accept_leak_no_lhs (int fd, struct sockaddr *addr, socklen_t *addrlen)\n+{\n+  accept (fd, addr, addrlen); /* { dg-warning \"leak of file descriptor\" } */\n+}\n+\n+void test_accept_leak_with_lhs (int fd, struct sockaddr *addr, socklen_t *addrlen)\n+{\n+  int newfd = accept (fd, addr, addrlen); /* { dg-message \"socket created here\" } */\n+} /* { dg-warning \"leak of file descriptor 'newfd'\" } */\n+\n+int test_accept_null_addr (int fd)\n+{\n+  return accept (fd, NULL, 0);\n+}\n+\n+int test_accept_uninit_addrlen (int fd)\n+{\n+  struct sockaddr_storage addr;\n+  socklen_t addr_len;\n+  return accept (fd, (struct sockaddr *)&addr, &addr_len); /* { dg-warning \"use of uninitialized value 'addr_len'\" } */\n+}\n+\n+int test_accept_writes_to_addr_and_len (int fd)\n+{\n+  struct sockaddr_storage addr;\n+  socklen_t addr_len = sizeof (addr);\n+  __analyzer_eval (addr_len == sizeof (addr)); /* { dg-warning \"TRUE\" } */\n+  int newfd = accept (fd, (struct sockaddr *)&addr, &addr_len);\n+  if (newfd == -1)\n+    return newfd;\n+  /* Check that the analyzer considers addr and addr_len to\n+     have been written to.  */\n+  __analyzer_eval (((char *)&addr)[0]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (addr_len == sizeof (addr)); /* { dg-warning \"UNKNOWN\" } */\n+  return newfd;\n+}\n+\n+void test_accept_on_new_datagram_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n+  if (fd == -1)\n+    return;\n+  accept (fd, NULL, NULL); /* { dg-message \"'accept' on datagram socket file descriptor 'fd' \\\\\\[-Wanalyzer-fd-type-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'accept' expects a stream socket file descriptor but 'fd' is a datagram socket\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+int test_accept_on_accept (int fd_a)\n+{\n+  int fd_b = accept (fd_a, NULL, 0);\n+  if (fd_b == -1)\n+    return -1;\n+\n+  int fd_c = accept (fd_b, NULL, 0);  /* { dg-warning \"'accept' on file descriptor 'fd_b' in wrong phase \\\\\\[-Wanalyzer-fd-phase-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'accept' expects a listening stream socket file descriptor but 'fd_b' is connected\" \"final event\" { target *-*-* } .-1 } */\n+\n+  return fd_b;\n+}"}, {"sha": "6f91bc4b794eec800b71baaed6724af0daf0ce45", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-bind.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-bind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-bind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-bind.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,74 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_bind (int fd, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+  else\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+void test_null_bind (int fd)\n+{\n+  errno = 0;\n+  int result = bind (fd, NULL, 0);\n+  __analyzer_eval (result == -1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_double_bind (int fd, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on file descriptor 'fd' in wrong phase \\\\\\[-Wanalyzer-fd-phase-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'bind' expects a new socket file descriptor but 'fd' has already been bound\" \"final event\" { target *-*-* } .-1 } */\n+}\n+\n+int test_uninit_addr (int fd, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  return bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  // TODO: complain about uninit addr.\n+}\n+\n+void test_bind_after_connect (int fd, const char *sockname,\n+\t\t\t\tconst struct sockaddr *caddr, socklen_t caddrlen)\n+{\n+  if (connect (fd, caddr, caddrlen) == -1)\n+    return;\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  /* TODO: we don't warn for this; after the plain \"connect\" we're\n+     in the stop state.  */\n+}\n+\n+void test_bind_after_accept (int fd, const char *sockname)\n+{\n+  int afd = accept (fd, NULL, NULL);\n+  if (afd == -1)\n+    return;\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (afd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on file descriptor 'afd' in wrong phase \\\\\\[-Wanalyzer-fd-phase-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'bind' expects a new socket file descriptor but 'afd' is already connected\" \"final event\" { target *-*-* } .-1 } */\n+\n+  close (afd);\n+}"}, {"sha": "1ab54d01f36c87732d8165f16a46c6dc431122bb", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-connect.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-connect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-connect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-connect.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,46 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+int test_connect (int sockfd, const struct sockaddr *addr,\n+\t\t  socklen_t addrlen)\n+{\n+  return connect (sockfd, addr, addrlen);\n+}\n+\n+void test_null_connect (int fd)\n+{\n+  errno = 0;\n+  int result = connect (fd, NULL, 0);\n+  __analyzer_eval (result == -1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+}\n+\n+int test_uninit_addr (int fd, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  return connect (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  // TODO: complain about uninit addr.\n+}\n+\n+void test_connect_after_bind (const char *sockname,\n+\t\t\t      const struct sockaddr *baddr, socklen_t baddrlen,\n+\t\t\t      const struct sockaddr *caddr, socklen_t caddrlen)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1)\n+    return;\n+\n+  if (bind (fd, baddr, baddrlen) == -1)\n+    {\n+      close (fd);\n+      return;\n+    }\n+\n+  connect (fd, caddr, caddrlen); /* { dg-warning \"'connect' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'connect' expects a new socket file descriptor but 'fd' is bound\" \"final event\" { target *-*-* } .-1 } */\n+\n+  close (fd);      \n+}"}, {"sha": "045bdfa32d3d7f97b1838926ed0244f83fb5ae27", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-datagram-socket.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-datagram-socket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-datagram-socket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-datagram-socket.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,108 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_leak_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"datagram socket created here\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+\n+void test_leak_socket_no_lhs (void)\n+{\n+  socket (AF_UNIX, SOCK_DGRAM, 0);  /* { dg-warning \"leak of file descriptor\" } */\n+}\n+\n+void test_close_unchecked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n+  close (fd);\n+}\n+\n+void test_close_checked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n+  if (fd == -1)\n+    return;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-datagram-socket'\" } */\n+  close (fd);\n+}\n+\n+void test_leak_checked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"datagram socket created here\" } */\n+  if (fd == -1) /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+    return;\n+  // TODO: strange location for leak message\n+}\n+\n+void test_bind (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n+  if (fd == -1)\n+    return;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-datagram-socket'\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  close (fd);\n+}\n+\n+void test_bind_on_unchecked_socket (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"when 'socket' fails\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on possibly invalid file descriptor 'fd'\" } */\n+  close (fd);\n+}\n+\n+void test_leak_of_bound_socket (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"datagram socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+}\n+\n+void test_listen_on_datagram_socket_without_bind (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"datagram socket created here\" }  */\n+  if (fd == -1)\n+    return;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-datagram-socket'\" } */\n+  listen (fd, 5); /* { dg-warning \"'listen' on datagram socket file descriptor 'fd' \\\\\\[-Wanalyzer-fd-type-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a stream socket file descriptor but 'fd' is a datagram socket\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listen_on_datagram_socket_with_bind (const char *sockname)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"datagram socket created here\" }  */\n+  if (fd == -1)\n+    return;\n+\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-datagram-socket'\" } */\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1) /* { dg message \"datagram socket bound here\" } */\n+    {\n+      close (fd);\n+      return;\n+    }\n+  listen (fd, 5); /* { dg-warning \"'listen' on datagram socket file descriptor 'fd' \\\\\\[-Wanalyzer-fd-type-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a stream socket file descriptor but 'fd' is a datagram socket\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}"}, {"sha": "1ff902894afbe97d7e0ac19e7e2c1c589b1e580e", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-glibc-byte-stream-connection-server.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-connection-server.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-connection-server.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-connection-server.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,133 @@\n+/* Example from glibc manual (16.9.7).  */\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+\n+#define PORT    5555\n+#define MAXMSG  512\n+\n+int\n+make_socket (uint16_t port)\n+{\n+  int sock;\n+  struct sockaddr_in name;\n+\n+  /* Create the socket. */\n+  sock = socket (PF_INET, SOCK_STREAM, 0);\n+  if (sock < 0)\n+    {\n+      perror (\"socket\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Give the socket a name. */\n+  name.sin_family = AF_INET;\n+  name.sin_port = htons (port);\n+  name.sin_addr.s_addr = htonl (INADDR_ANY);\n+  if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)\n+    {\n+      perror (\"bind\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  return sock;\n+}\n+\n+int\n+read_from_client (int filedes)\n+{\n+  char buffer[MAXMSG];\n+  int nbytes;\n+\n+  nbytes = read (filedes, buffer, MAXMSG);\n+  if (nbytes < 0)\n+    {\n+      /* Read error. */\n+      perror (\"read\");\n+      exit (EXIT_FAILURE);\n+    }\n+  else if (nbytes == 0)\n+    /* End-of-file. */\n+    return -1;\n+  else\n+    {\n+      /* Data read. */\n+      fprintf (stderr, \"Server: got message: `%s'\\n\", buffer);\n+      return 0;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int sock;\n+  fd_set active_fd_set, read_fd_set;\n+  int i;\n+  struct sockaddr_in clientname;\n+  socklen_t size;\n+\n+  /* Create the socket and set it up to accept connections. */\n+  sock = make_socket (PORT);\n+  if (listen (sock, 1) < 0)\n+    {\n+      perror (\"listen\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Initialize the set of active sockets. */\n+  FD_ZERO (&active_fd_set);\n+  FD_SET (sock, &active_fd_set);\n+\n+  while (1)\n+    {\n+      /* Block until input arrives on one or more active sockets. */\n+      read_fd_set = active_fd_set;\n+      if (select (FD_SETSIZE, &read_fd_set, NULL, NULL, NULL) < 0)\n+        {\n+          perror (\"select\");\n+          exit (EXIT_FAILURE);\n+        }\n+\n+      /* Service all the sockets with input pending. */\n+      for (i = 0; i < FD_SETSIZE; ++i)\n+        if (FD_ISSET (i, &read_fd_set))\n+          {\n+            if (i == sock)\n+              {\n+                /* Connection request on original socket. */\n+                int new;\n+                size = sizeof (clientname);\n+                new = accept (sock,\n+                              (struct sockaddr *) &clientname,\n+                              &size);\n+                if (new < 0)\n+                  {\n+                    perror (\"accept\");\n+                    exit (EXIT_FAILURE);\n+                  }\n+                fprintf (stderr,\n+                         \"Server: connect from host %s, port %hd.\\n\",\n+                         inet_ntoa (clientname.sin_addr),\n+                         ntohs (clientname.sin_port));\n+                FD_SET (new, &active_fd_set);\n+              }\n+            else\n+              {\n+                /* Data arriving on an already-connected socket. */\n+                if (read_from_client (i) < 0)\n+                  {\n+                    close (i);\n+                    FD_CLR (i, &active_fd_set);\n+                  }\n+              }\n+          }\n+    }\n+}"}, {"sha": "f96da8101cc2a3924eea3ec01b619e185ff642c6", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-glibc-byte-stream-socket.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-socket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-socket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-byte-stream-socket.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,62 @@\n+/* Example from glibc manual (16.9.6).  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netdb.h>\n+\n+#define PORT            5555\n+#define MESSAGE         \"Yow!!! Are we having fun yet?!?\"\n+#define SERVERHOST      \"www.gnu.org\"\n+\n+void\n+write_to_server (int filedes)\n+{\n+  int nbytes;\n+\n+  nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);\n+  if (nbytes < 0)\n+    {\n+      perror (\"write\");\n+      exit (EXIT_FAILURE);\n+    }\n+}\n+\n+\n+int\n+main (void)\n+{\n+  extern void init_sockaddr (struct sockaddr_in *name,\n+                             const char *hostname,\n+                             uint16_t port);\n+  int sock;\n+  struct sockaddr_in servername;\n+\n+  /* Create the socket. */\n+  sock = socket (PF_INET, SOCK_STREAM, 0);\n+  if (sock < 0)\n+    {\n+      perror (\"socket (client)\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Connect to the server. */\n+  init_sockaddr (&servername, SERVERHOST, PORT);\n+  if (0 > connect (sock,\n+                   (struct sockaddr *) &servername,\n+                   sizeof (servername)))\n+    {\n+      perror (\"connect (client)\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Send data to the server. */\n+  write_to_server (sock);\n+  close (sock);\n+  exit (EXIT_SUCCESS);\n+}"}, {"sha": "888c751e88d4af6fd0021ee070443f70640e23b5", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-glibc-datagram-client.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-client.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-client.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-client.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,56 @@\n+/* Example from the glibc manual (16.10.4).  */\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include \"fd-glibc-make_named_socket.h\"\n+\n+#define SERVER  \"/tmp/serversocket\"\n+#define CLIENT  \"/tmp/mysocket\"\n+#define MAXMSG  512\n+#define MESSAGE \"Yow!!! Are we having fun yet?!?\"\n+\n+int\n+main (void)\n+{\n+  int sock;\n+  char message[MAXMSG];\n+  struct sockaddr_un name;\n+  size_t size;\n+  int nbytes;\n+\n+  /* Make the socket. */\n+  sock = make_named_socket (CLIENT);\n+\n+  /* Initialize the server socket address. */\n+  name.sun_family = AF_LOCAL;\n+  strcpy (name.sun_path, SERVER);\n+  size = strlen (name.sun_path) + sizeof (name.sun_family);\n+\n+  /* Send the datagram. */\n+  nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,\n+                   (struct sockaddr *) & name, size);\n+  if (nbytes < 0)\n+    {\n+      perror (\"sendto (client)\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Wait for a reply. */\n+  nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);\n+  if (nbytes < 0)\n+    {\n+      perror (\"recfrom (client)\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Print a diagnostic message. */\n+  fprintf (stderr, \"Client: got message: %s\\n\", message);\n+\n+  /* Clean up. */\n+  remove (CLIENT);\n+  close (sock);\n+}"}, {"sha": "b8b68768c34ee4344ad7ebf08f90bfcadf35416c", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-glibc-datagram-socket.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-socket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-socket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-datagram-socket.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,52 @@\n+/* Example from glibc manual (16.10.3).  */\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include \"fd-glibc-make_named_socket.h\"\n+\n+#define SERVER  \"/tmp/serversocket\"\n+#define MAXMSG  512\n+\n+int\n+main (void)\n+{\n+  int sock;\n+  char message[MAXMSG];\n+  struct sockaddr_un name;\n+  socklen_t size;\n+  int nbytes;\n+\n+  /* Remove the filename first, it\u2019s ok if the call fails */\n+  unlink (SERVER);\n+\n+  /* Make the socket, then loop endlessly. */\n+  sock = make_named_socket (SERVER);\n+  while (1)\n+    {\n+      /* Wait for a datagram. */\n+      size = sizeof (name);\n+      nbytes = recvfrom (sock, message, MAXMSG, 0,\n+                         (struct sockaddr *) & name, &size);\n+      if (nbytes < 0)\n+        {\n+          perror (\"recfrom (server)\");\n+          exit (EXIT_FAILURE);\n+        }\n+\n+      /* Give a diagnostic message. */\n+      fprintf (stderr, \"Server: got message: %s\\n\", message);\n+\n+      /* Bounce the message back to the sender. */\n+      nbytes = sendto (sock, message, nbytes, 0,\n+                       (struct sockaddr *) & name, size);\n+      if (nbytes < 0)\n+        {\n+          perror (\"sendto (server)\");\n+          exit (EXIT_FAILURE);\n+        }\n+    }\n+}"}, {"sha": "bdb6de0ae15e695560dbc93ac10caa4dae05ff00", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-glibc-make_named_socket.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-make_named_socket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-make_named_socket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-glibc-make_named_socket.h?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,47 @@\n+/* Example of Local-Namespace Sockets from the glibc manual (16.5.3).  */\n+\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+\n+int\n+make_named_socket (const char *filename)\n+{\n+  struct sockaddr_un name;\n+  int sock;\n+  size_t size;\n+\n+  /* Create the socket. */\n+  sock = socket (PF_LOCAL, SOCK_DGRAM, 0);\n+  if (sock < 0)\n+    {\n+      perror (\"socket\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /* Bind a name to the socket. */\n+  name.sun_family = AF_LOCAL;\n+  strncpy (name.sun_path, filename, sizeof (name.sun_path));\n+  name.sun_path[sizeof (name.sun_path) - 1] = '\\0';\n+\n+  /* The size of the address is\n+     the offset of the start of the filename,\n+     plus its length (not including the terminating null byte).\n+     Alternatively you can just do:\n+     size = SUN_LEN (&name);\n+ */\n+  size = (offsetof (struct sockaddr_un, sun_path)\n+          + strlen (name.sun_path));\n+\n+  if (bind (sock, (struct sockaddr *) &name, size) < 0)\n+    {\n+      perror (\"bind\");\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  return sock;\n+}"}, {"sha": "1f54a8f295367f59d9a7ab6b7540f4bd6e51c092", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-listen.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-listen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-listen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-listen.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,63 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+int test_listen (int fd, int backlog)\n+{\n+  return listen (fd, backlog);\n+}\n+\n+/* Some systems seem to allow repeated calls to listen.  */\n+\n+void test_double_listen (int fd, int backlog)\n+{\n+  listen (fd, backlog);\n+  listen (fd, backlog);\n+}\n+\n+void test_listen_before_bind (int fd, const char *sockname)\n+{\n+  if (listen (fd, 5) == -1) /* { dg-message \"stream socket marked as passive here via 'listen'\" } */\n+    return;\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'bind' expects a new socket file descriptor but 'fd' is already listening\" \"final event\" { target *-*-* } .-1 } */\n+}\n+\n+void test_listen_on_unchecked_bind (int fd, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-message \"when 'bind' fails\" } */\n+  listen (fd, 5); /* { dg-warning \"'listen' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listen_on_new_datagram_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n+  if (fd == -1)\n+    return;\n+  listen (fd, 5); /* { dg-message \"'listen' on datagram socket file descriptor 'fd' \\\\\\[-Wanalyzer-fd-type-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a stream socket file descriptor but 'fd' is a datagram socket\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listed_on_connected_socket (int fd)\n+{\n+  int afd = accept (fd, NULL, 0);\n+  if (afd == -1)\n+    return;\n+  listen (afd, 5); /* { dg-warning \"'listen' on file descriptor 'afd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'afd' is connected\" \"final event\" { target *-*-* } .-1 } */\n+  close (afd);\n+}"}, {"sha": "d9c3ff05de84039f4764beb0654207c425d3840a", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-manpage-getaddrinfo-client.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-manpage-getaddrinfo-client.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-manpage-getaddrinfo-client.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-manpage-getaddrinfo-client.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,122 @@\n+/* Example from getaddrinfo.3 manpage, which has this license:\n+\n+Copyright (c) 2007, 2008 Michael Kerrisk <mtk.manpages@gmail.com>\n+and Copyright (c) 2006 Ulrich Drepper <drepper@redhat.com>\n+A few pieces of an earlier version remain:\n+Copyright 2000, Sam Varshavchik <mrsam@courier-mta.com>\n+\n+Permission is granted to make and distribute verbatim copies of this\n+manual provided the copyright notice and this permission notice are\n+preserved on all copies.\n+\n+Permission is granted to copy and distribute modified versions of this\n+manual under the conditions for verbatim copying, provided that the\n+entire resulting derived work is distributed under the terms of a\n+permission notice identical to this one.\n+\n+Since the Linux kernel and libraries are constantly changing, this\n+manual page may be incorrect or out-of-date.  The author(s) assume no\n+responsibility for errors or omissions, or for damages resulting from\n+the use of the information contained herein.  The author(s) may not\n+have taken the same level of care in the production of this manual,\n+which is licensed free of charge, as they might when working\n+professionally.\n+\n+Formatted or processed versions of this manual, if unaccompanied by\n+the source, must acknowledge the copyright and authors of this work.\n+*/\n+\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netdb.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <string.h>\n+\n+#define BUF_SIZE 500\n+\n+int\n+main(int argc, char *argv[])\n+{\n+  struct addrinfo hints;\n+  struct addrinfo *result, *rp;\n+  int sfd, s;\n+  size_t len;\n+  ssize_t nread;\n+  char buf[BUF_SIZE];\n+\n+  if (argc < 3) {\n+    fprintf(stderr, \"Usage: %s host port msg...\\n\", argv[0]);\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  /* Obtain address(es) matching host/port. */\n+\n+  memset(&hints, 0, sizeof(hints));\n+  hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n+  hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n+  hints.ai_flags = 0;\n+  hints.ai_protocol = 0;          /* Any protocol */\n+\n+  s = getaddrinfo(argv[1], argv[2], &hints, &result);\n+  if (s != 0) {\n+    fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  /* getaddrinfo() returns a list of address structures.\n+     Try each address until we successfully connect(2).\n+     If socket(2) (or connect(2)) fails, we (close the socket\n+     and) try the next address. */\n+\n+  for (rp = result; rp != NULL; rp = rp->ai_next) {\n+    sfd = socket(rp->ai_family, rp->ai_socktype,\n+\t\t rp->ai_protocol);\n+    if (sfd == -1)\n+      continue;\n+\n+    if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)\n+      break;                  /* Success */\n+\n+    close(sfd);\n+  }\n+\n+  freeaddrinfo(result);           /* No longer needed */\n+\n+  if (rp == NULL) {               /* No address succeeded */\n+    fprintf(stderr, \"Could not connect\\n\");\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  /* Send remaining command-line arguments as separate\n+     datagrams, and read responses from server. */\n+\n+  for (int j = 3; j < argc; j++) {\n+    len = strlen(argv[j]) + 1;\n+    /* +1 for terminating null byte */\n+\n+    if (len > BUF_SIZE) {\n+      fprintf(stderr,\n+\t      \"Ignoring long message in argument %d\\n\", j);\n+      continue;\n+    }\n+\n+    if (write(sfd, argv[j], len) != len) {\n+      fprintf(stderr, \"partial/failed write\\n\");\n+      exit(EXIT_FAILURE);\n+    }\n+\n+    nread = read(sfd, buf, BUF_SIZE);\n+    if (nread == -1) {\n+      perror(\"read\");\n+      exit(EXIT_FAILURE);\n+    }\n+\n+    printf(\"Received %zd bytes: %s\\n\", nread, buf);\n+  }\n+\n+  exit(EXIT_SUCCESS);\n+}"}, {"sha": "66398e834ccf3ff6015dee9b4280a91233d3a815", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-mappage-getaddrinfo-server.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-mappage-getaddrinfo-server.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-mappage-getaddrinfo-server.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-mappage-getaddrinfo-server.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,119 @@\n+/* Example from getaddrinfo.3 manpage, which has this license:\n+\n+Copyright (c) 2007, 2008 Michael Kerrisk <mtk.manpages@gmail.com>\n+and Copyright (c) 2006 Ulrich Drepper <drepper@redhat.com>\n+A few pieces of an earlier version remain:\n+Copyright 2000, Sam Varshavchik <mrsam@courier-mta.com>\n+\n+Permission is granted to make and distribute verbatim copies of this\n+manual provided the copyright notice and this permission notice are\n+preserved on all copies.\n+\n+Permission is granted to copy and distribute modified versions of this\n+manual under the conditions for verbatim copying, provided that the\n+entire resulting derived work is distributed under the terms of a\n+permission notice identical to this one.\n+\n+Since the Linux kernel and libraries are constantly changing, this\n+manual page may be incorrect or out-of-date.  The author(s) assume no\n+responsibility for errors or omissions, or for damages resulting from\n+the use of the information contained herein.  The author(s) may not\n+have taken the same level of care in the production of this manual,\n+which is licensed free of charge, as they might when working\n+professionally.\n+\n+Formatted or processed versions of this manual, if unaccompanied by\n+the source, must acknowledge the copyright and authors of this work.\n+*/\n+\n+#include <sys/types.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include <sys/socket.h>\n+#include <netdb.h>\n+\n+#define BUF_SIZE 500\n+\n+int\n+main(int argc, char *argv[])\n+{\n+  struct addrinfo hints;\n+  struct addrinfo *result, *rp;\n+  int sfd, s;\n+  struct sockaddr_storage peer_addr;\n+  socklen_t peer_addr_len;\n+  ssize_t nread;\n+  char buf[BUF_SIZE];\n+\n+  if (argc != 2) {\n+    fprintf(stderr, \"Usage: %s port\\n\", argv[0]);\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  memset(&hints, 0, sizeof(hints));\n+  hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n+  hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n+  hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n+  hints.ai_protocol = 0;          /* Any protocol */\n+  hints.ai_canonname = NULL;\n+  hints.ai_addr = NULL;\n+  hints.ai_next = NULL;\n+\n+  s = getaddrinfo(NULL, argv[1], &hints, &result);\n+  if (s != 0) {\n+    fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  /* getaddrinfo() returns a list of address structures.\n+     Try each address until we successfully bind(2).\n+     If socket(2) (or bind(2)) fails, we (close the socket\n+     and) try the next address. */\n+\n+  for (rp = result; rp != NULL; rp = rp->ai_next) {\n+    sfd = socket(rp->ai_family, rp->ai_socktype,\n+\t\t rp->ai_protocol);\n+    if (sfd == -1)\n+      continue;\n+\n+    if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)\n+      break;                  /* Success */\n+\n+    close(sfd);\n+  }\n+\n+  freeaddrinfo(result);           /* No longer needed */\n+\n+  if (rp == NULL) {               /* No address succeeded */\n+    fprintf(stderr, \"Could not bind\\n\");\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  /* Read datagrams and echo them back to sender. */\n+\n+  for (;;) {\n+    peer_addr_len = sizeof(peer_addr);\n+    nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n+\t\t     (struct sockaddr *) &peer_addr, &peer_addr_len);\n+    if (nread == -1)\n+      continue;               /* Ignore failed request */\n+\n+    char host[NI_MAXHOST], service[NI_MAXSERV];\n+\n+    s = getnameinfo((struct sockaddr *) &peer_addr,\n+\t\t    peer_addr_len, host, NI_MAXHOST,\n+\t\t    service, NI_MAXSERV, NI_NUMERICSERV);\n+    if (s == 0)\n+      printf(\"Received %zd bytes from %s:%s\\n\",\n+\t     nread, host, service);\n+    else\n+      fprintf(stderr, \"getnameinfo: %s\\n\", gai_strerror(s));\n+    \n+    if (sendto(sfd, buf, nread, 0,\n+\t       (struct sockaddr *) &peer_addr,\n+\t       peer_addr_len) != nread)\n+      fprintf(stderr, \"Error sending response\\n\");\n+  }\n+}"}, {"sha": "5bfb57f68fb9233e629ce4de96ab03f0d6b69635", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-socket-meaning.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-meaning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-meaning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-meaning.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-additional-options \"-fanalyzer-verbose-state-changes\" } */\n+\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+void test_leak_unchecked_stream_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"meaning: \\\\{verb: 'acquire', noun: 'resource'\\\\}\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+\n+void test_leak_unchecked_datagram_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_DGRAM, 0); /* { dg-message \"meaning: \\\\{verb: 'acquire', noun: 'resource'\\\\}\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+\n+void test_leak_unchecked_socket (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0); /* { dg-message \"meaning: \\\\{verb: 'acquire', noun: 'resource'\\\\}\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */"}, {"sha": "4ff08d5ec19df4ba62335cfb193b47b22894127a", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-socket-misuse.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-misuse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-misuse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-socket-misuse.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,98 @@\n+/* Various operations done on sockets in the wrong phase.  */\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_read_on_new_socket (void *buf)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  read (fd, buf, 1); /* { dg-warning \"'read' on file descriptor 'fd' in wrong phase \\\\\\[-Wanalyzer-fd-phase-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'read' expects a stream socket to be connected via 'accept' but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_read_on_bound_socket (int fd, const char *sockname, void *buf)\n+{\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    return;\n+  /* This could be a datagram socket, so we shouldn't complain here.  */\n+  read (fd, buf, 1);\n+}\n+\n+void test_read_on_listening_socket (int fd, void *buf)\n+{\n+  if (listen (fd, 5) == -1) /* { dg-message \"stream socket marked as passive here via 'listen'\" } */\n+    return;\n+  read (fd, buf, 1); /* { dg-message \"'read' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'read' expects a stream socket to be connected via the return value of 'accept' but 'fd' is listening; wrong file descriptor\\\\\\?\" \"final event\" { target *-*-* } .-1 } */\n+}\n+\n+void test_bind_on_non_socket (const char *filename, const char *sockname)\n+{\n+  int fd = open (filename, O_RDONLY);\n+  if (fd == -1)\n+    return;\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  int result = bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on non-socket file descriptor 'fd' \\\\\\[-Wanalyzer-fd-type-mismatch\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"'bind' expects a socket file descriptor but 'fd' is not a socket\" \"final event\" { target *-*-* } .-1 } */\n+  __analyzer_eval (result == -1); /* { dg-warning \"TRUE\" } */\n+  \n+  close (fd);\n+}\n+\n+void test_passive_open_read_on_wrong_socket (int sfd)\n+{\n+  int cfd = accept (sfd, NULL, NULL);\n+  write (sfd, \"hello\", 6); /* { dg-warning \"'write' on file descriptor 'sfd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'write' expects a stream socket to be connected via the return value of 'accept' but 'sfd' is listening; wrong file descriptor\\\\\\?\" \"final event\" { target *-*-* } .-1 } */\n+  close (cfd);\n+}\n+\n+void test_listen_on_new_stream_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    return;\n+  listen (fd, 5); /* { dg-message \"'listen' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_accept_on_new_stream_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    return;\n+  accept (fd, NULL, NULL); /* { dg-message \"'accept' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'accept' expects a listening stream socket file descriptor but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listen_before_bind (int fd, const char *sockname)\n+{\n+  if (listen (fd, 5) == -1) /* { dg-message \"stream socket marked as passive here via 'listen'\" } */\n+    return;\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'bind' expects a new socket file descriptor but 'fd' is already listening\" \"final event\" { target *-*-* } .-1 } */\n+}"}, {"sha": "7fde0ef6285f40eb0ba15995b2359389a40422dc", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-stream-socket-active-open.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-active-open.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-active-open.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-active-open.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,74 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_active_open_from_scratch (const char *sockname, void *buf)\n+{\n+  errno = 0;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-invalid'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+\n+  errno = 0;\n+  if (connect (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-connected-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (fd, \"hello\", 6);\n+  read (fd, buf, 100);\n+\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+}\n+\n+void test_active_open_from_connect (int fd, const char *sockname, void *buf)\n+{\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'start'\" } */\n+\n+  struct sockaddr_un addr;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+\n+  errno = 0;\n+  if (connect (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-unknown-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-stop'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (fd, \"hello\", 6);\n+  read (fd, buf, 100);\n+\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-stop'\" } */\n+}"}, {"sha": "c31e5b5eefb9cdcc10985e4aaf6f3201a85b558a", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-stream-socket-passive-open.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-passive-open.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-passive-open.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket-passive-open.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,197 @@\n+/* Verify the various states when performing a passive open,\n+   either from scratch, or when various phases are assumed to already\n+   be done.  */\n+\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_passive_open_from_scratch (const char *sockname, void *buf)\n+{\n+  struct sockaddr_un addr;\n+  int afd;\n+  errno = 0;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-invalid'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  errno = 0;\n+  if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-bound-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  if (listen (fd, 5) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-bound-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  afd = accept (fd, NULL, NULL);\n+  if (afd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-connected-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (afd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (afd, \"hello\", 6);\n+  read (afd, buf, 100);\n+  \n+  close (afd);\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-closed'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+}\n+\n+void test_passive_open_from_bind (int fd, const char *sockname, void *buf)\n+{\n+  struct sockaddr_un addr;\n+  int afd;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'start'\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  errno = 0;\n+  if (bind (fd, (struct sockaddr *)&addr, sizeof (addr)) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-new-unknown-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-bound-unknown-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  if (listen (fd, 5) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-bound-unknown-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  afd = accept (fd, NULL, NULL);\n+  if (afd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-connected-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (afd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (afd, \"hello\", 6);  \n+  read (afd, buf, 100);\n+\n+  close (afd);\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-closed'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+}\n+\n+void test_passive_open_from_listen (int fd, void *buf)\n+{\n+  int afd;\n+  errno = 0;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'start'\" } */\n+  if (listen (fd, 5) == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-bound-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  afd = accept (fd, NULL, NULL);\n+  if (afd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-connected-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (afd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (afd, \"hello\", 6);\n+  read (afd, buf, 100);\n+\n+  close (afd);\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-closed'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+}\n+\n+void test_passive_open_from_accept (int fd, void *buf)\n+{\n+  int afd;\n+  errno = 0;\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'start'\" } */\n+  afd = accept (fd, NULL, NULL);\n+  if (afd == -1)\n+    {\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      close (fd);\n+      __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+      return;\n+    }\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-listening-stream-socket'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-connected-stream-socket'\" } */\n+  __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fd >= 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (afd >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  write (afd, \"hello\", 6);\n+  read (afd, buf, 100);\n+\n+  close (afd);\n+  close (fd);\n+  __analyzer_dump_state (\"file-descriptor\", afd); /* { dg-warning \"state: 'fd-closed'\" } */\n+  __analyzer_dump_state (\"file-descriptor\", fd); /* { dg-warning \"state: 'fd-closed'\" } */\n+}"}, {"sha": "3a292d0e2d240c8c71036ae896fefa195faf159c", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-stream-socket.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-stream-socket.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,98 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_leak_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+\n+void test_leak_socket_no_lhs (void)\n+{\n+  socket (AF_UNIX, SOCK_STREAM, 0);  /* { dg-warning \"leak of file descriptor\" } */\n+}\n+\n+void test_close_unchecked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  close (fd);\n+}\n+\n+void test_close_checked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    return;\n+  close (fd);\n+}\n+\n+void test_leak_checked_socket (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1) /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+    return;\n+  // TODO: strange location for leak message\n+}\n+\n+void test_bind_on_checked_socket (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0);\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  close (fd);\n+}\n+\n+void test_bind_on_unchecked_socket (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"when 'socket' fails\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on possibly invalid file descriptor 'fd'\" } */\n+  close (fd);\n+}\n+\n+void test_leak_of_bound_socket (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+}\n+\n+void test_listen_without_bind (void)\n+{\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  listen (fd, 5); /* { dg-warning \"'listen' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listen_on_unchecked_bind (const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, SOCK_STREAM, 0); /* { dg-message \"stream socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-message \"when 'bind' fails\" } */\n+  listen (fd, 5); /* { dg-warning \"'listen' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"final event\" { target *-*-* } .-1 } */\n+  close (fd);\n+}"}, {"sha": "83400c18f50e186fddac0b7ecccc87777cf15274", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-symbolic-socket.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-symbolic-socket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-symbolic-socket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-symbolic-socket.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -0,0 +1,98 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_leak_socket (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0); /* { dg-message \"socket created here\" } */\n+} /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+\n+void test_leak_socket_no_lhs (int type)\n+{\n+  socket (AF_UNIX, type, 0);  /* { dg-warning \"leak of file descriptor\" } */\n+}\n+\n+void test_close_unchecked_socket (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0);\n+  close (fd);\n+}\n+\n+void test_close_checked_socket (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0);\n+  if (fd == -1)\n+    return;\n+  close (fd);\n+}\n+\n+void test_leak_checked_socket (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0); /* { dg-message \"socket created here\" } */\n+  if (fd == -1) /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+    return;\n+  // TODO: strange location for leak message\n+}\n+\n+void test_bind_on_checked_socket (int type, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, type, 0);\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr));\n+  close (fd);\n+}\n+\n+void test_bind_on_unchecked_socket (int type, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, type, 0); /* { dg-message \"when 'socket' fails\" } */\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"'bind' on possibly invalid file descriptor 'fd'\" } */\n+  close (fd);\n+}\n+\n+void test_leak_of_bound_socket (int type, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, type, 0); /* { dg-message \"socket created here\" } */\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-warning \"leak of file descriptor 'fd'\" } */\n+}\n+\n+void test_listen_without_bind (int type)\n+{\n+  int fd = socket (AF_UNIX, type, 0);\n+  if (fd == -1)\n+    return;\n+  listen (fd, 5); /* { dg-warning \"'listen' on file descriptor 'fd' in wrong phase\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"msg\" { target *-*-* } .-1 } */\n+  close (fd);\n+}\n+\n+void test_listen_on_unchecked_bind (int type, const char *sockname)\n+{\n+  struct sockaddr_un addr;\n+  int fd = socket (AF_UNIX, type, 0);\n+  if (fd == -1)\n+    return;\n+  memset (&addr, 0, sizeof (addr));\n+  addr.sun_family = AF_UNIX;\n+  strncpy (addr.sun_path, sockname, sizeof(addr.sun_path) - 1);\n+  bind (fd, (struct sockaddr *)&addr, sizeof (addr)); /* { dg-message \"when 'bind' fails\" } */\n+  listen (fd, 5); /* { dg-warning \"'listen' on file descriptor 'fd' in wrong phase\" \"warning\" } */\n+  /* { dg-message \"'listen' expects a bound stream socket file descriptor but 'fd' has not yet been bound\" \"msg\" { target *-*-* } .-1 } */\n+  close (fd);\n+}"}, {"sha": "c05137bb219b3cd041a8c03a8b491f0543f9d0ea", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104369-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-1.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-additional-options \"--param analyzer-max-enodes-per-program-point=10\" } */\n-// TODO: remove need for this option\n+/* { dg-additional-options \"-Wno-analyzer-too-complex -Wno-analyzer-fd-leak\" } */\n+// TODO: remove need for these options\n \n typedef __SIZE_TYPE__ size_t;\n #define NULL ((void *)0)"}, {"sha": "93d9987d0ba039cdfa5b365eccc8f83d4ff438a7", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104369-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a90006864840c2e222d46ead551850caba184b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104369-2.c?ref=86a90006864840c2e222d46ead551850caba184b", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-additional-options \"-Wno-analyzer-fd-leak\" } */\n+// TODO: remove need for this option\n+\n typedef __SIZE_TYPE__ size_t;\n #define NULL ((void *)0)\n #define POLLIN 0x001"}]}