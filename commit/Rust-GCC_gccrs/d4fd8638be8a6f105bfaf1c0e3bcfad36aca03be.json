{"sha": "d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmZDg2MzhiZThhNmYxMDViZmFmMWMwZTNiY2ZhZDM2YWNhMDNiZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-27T16:32:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-27T16:32:53Z"}, "message": "libstdc++: Fix ODR violations caused by <tr1/functional>\n\nThe placeholders for std::tr1::bind are defined in an anonymous\nnamespace, which means they have internal linkage. This will cause ODR\nviolations when used in function templates (such as std::tr1::bind) from\nmultiple translation units. Although probably harmless (every definition\nwill generate identical code, even if technically ill-formed) we can\navoid the ODR violations by reusing the std::placeholder objects as the\nstd::tr1::placeholder objects.\n\nTo make this work, the std::_Placeholder type needs to be defined for\nC++98 mode, so that <tr1/functional> can use it. The members of the\nstd::placeholder namespace must not be defined by <functional> in C++98\nmode, because \"placeholders\", \"_1\", \"_2\" etc. are not reserved names in\nC++98. Instead they can be declared in <tr1/functional>, because those\nnames *are* reserved in that header. With the std::placeholders objects\ndeclared, a simple using-directive suffices to redeclare them in\nnamespace std::tr1::placeholders. This means any use of the TR1\nplaceholders actually refers to the C++11 placeholders, which are\ndefined with external linkage and exported from the library, so don't\ncause ODR violations.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/functional (std::_Placeholder): Define for C++98\n\tas well as later standards.\n\t* include/tr1/functional (std::placeholders::_1 etc): Declare\n\tfor C++98.\n\t(tr1::_Placeholder): Replace with using-declaration for\n\tstd::_Placeholder.\n\t(tr1::placeholders::_1 etc.): Replace with using-directive for\n\tstd::placeholders.", "tree": {"sha": "ab33757b7854e5f9f5c2e6c804c626bb29bb9e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab33757b7854e5f9f5c2e6c804c626bb29bb9e2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86558afc09e65b172377d4e759b00094dd985e8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86558afc09e65b172377d4e759b00094dd985e8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86558afc09e65b172377d4e759b00094dd985e8a"}], "stats": {"total": 148, "additions": 66, "deletions": 82}, "files": [{"sha": "4e2d053f778c6ce9fb7451ff6192b2c2e3a45a48", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "patch": "@@ -69,10 +69,19 @@\n # include <compare>\n #endif\n \n+#endif // C++11\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  /** @brief The type of placeholder objects defined by libstdc++.\n+   *  @ingroup binders\n+   */\n+  template<int _Num> struct _Placeholder { };\n+\n+#if __cplusplus >= 201103L\n+\n #if __cplusplus >= 201703L\n # define __cpp_lib_invoke 201411L\n # if __cplusplus > 201703L\n@@ -203,11 +212,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     = is_placeholder<_Tp>::value;\n #endif // C++17\n \n-  /** @brief The type of placeholder objects defined by libstdc++.\n-   *  @ingroup binders\n-   */\n-  template<int _Num> struct _Placeholder { };\n-\n   /** @namespace std::placeholders\n    *  @brief ISO C++ 2011 namespace for std::bind placeholders.\n    *  @ingroup binders\n@@ -1271,10 +1275,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #endif // C++17\n #endif // C++14\n+#endif // C++11\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n-#endif // C++11\n-\n #endif // _GLIBCXX_FUNCTIONAL"}, {"sha": "79eaeb8b99f17e6ab809aae00d4dd755ad411330", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 56, "deletions": 75, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=d4fd8638be8a6f105bfaf1c0e3bcfad36aca03be", "patch": "@@ -31,8 +31,7 @@\n \n #pragma GCC system_header\n \n-#include <bits/c++config.h>\n-#include <bits/stl_function.h>\n+#include <functional> // for std::_Placeholder, std::_Bind, std::_Bind_result\n \n #include <typeinfo>\n #include <new>\n@@ -42,18 +41,49 @@\n #include <tr1/functional_hash.h>\n #include <ext/type_traits.h>\n #include <bits/move.h> // for std::__addressof\n-#if __cplusplus >= 201103L\n-#  include <type_traits> // for integral_constant, true_type, false_type\n-#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-#if __cplusplus >= 201103L\n-  template<int> struct _Placeholder;\n-  template<typename> class _Bind;\n-  template<typename, typename> class _Bind_result;\n-#endif\n+\n+#if __cplusplus < 201103L\n+  // In C++98 mode, <functional> doesn't declare std::placeholders::_1 etc.\n+  // because they are not reserved names in C++98. However, they are reserved\n+  // by <tr1/functional> so we can declare them here, in order to redeclare\n+  // them in the std::tr1::placeholders namespace below.\n+  namespace placeholders\n+  {\n+    extern const _Placeholder<1> _1;\n+    extern const _Placeholder<2> _2;\n+    extern const _Placeholder<3> _3;\n+    extern const _Placeholder<4> _4;\n+    extern const _Placeholder<5> _5;\n+    extern const _Placeholder<6> _6;\n+    extern const _Placeholder<7> _7;\n+    extern const _Placeholder<8> _8;\n+    extern const _Placeholder<9> _9;\n+    extern const _Placeholder<10> _10;\n+    extern const _Placeholder<11> _11;\n+    extern const _Placeholder<12> _12;\n+    extern const _Placeholder<13> _13;\n+    extern const _Placeholder<14> _14;\n+    extern const _Placeholder<15> _15;\n+    extern const _Placeholder<16> _16;\n+    extern const _Placeholder<17> _17;\n+    extern const _Placeholder<18> _18;\n+    extern const _Placeholder<19> _19;\n+    extern const _Placeholder<20> _20;\n+    extern const _Placeholder<21> _21;\n+    extern const _Placeholder<22> _22;\n+    extern const _Placeholder<23> _23;\n+    extern const _Placeholder<24> _24;\n+    extern const _Placeholder<25> _25;\n+    extern const _Placeholder<26> _26;\n+    extern const _Placeholder<27> _27;\n+    extern const _Placeholder<28> _28;\n+    extern const _Placeholder<29> _29;\n+  }\n+#endif // C++98\n \n namespace tr1\n {\n@@ -850,49 +880,18 @@ namespace tr1\n     const int is_placeholder<_Tp>::value;\n \n   /// The type of placeholder objects defined by libstdc++.\n-  template<int _Num> struct _Placeholder { };\n+  using ::std::_Placeholder;\n \n   /** @namespace std::tr1::placeholders\n    *  @brief Sub-namespace for tr1/functional.\n    */\n-  namespace placeholders \n-  { \n-    /*  Define a large number of placeholders. There is no way to\n-     *  simplify this with variadic templates, because we're introducing\n-     *  unique names for each.\n-     */\n-    namespace \n-    {\n-      _Placeholder<1> _1;\n-      _Placeholder<2> _2;\n-      _Placeholder<3> _3;\n-      _Placeholder<4> _4;\n-      _Placeholder<5> _5;\n-      _Placeholder<6> _6;\n-      _Placeholder<7> _7;\n-      _Placeholder<8> _8;\n-      _Placeholder<9> _9;\n-      _Placeholder<10> _10;\n-      _Placeholder<11> _11;\n-      _Placeholder<12> _12;\n-      _Placeholder<13> _13;\n-      _Placeholder<14> _14;\n-      _Placeholder<15> _15;\n-      _Placeholder<16> _16;\n-      _Placeholder<17> _17;\n-      _Placeholder<18> _18;\n-      _Placeholder<19> _19;\n-      _Placeholder<20> _20;\n-      _Placeholder<21> _21;\n-      _Placeholder<22> _22;\n-      _Placeholder<23> _23;\n-      _Placeholder<24> _24;\n-      _Placeholder<25> _25;\n-      _Placeholder<26> _26;\n-      _Placeholder<27> _27;\n-      _Placeholder<28> _28;\n-      _Placeholder<29> _29;\n-    } \n+  namespace placeholders\n+  {\n+    // The C++11 std::placeholders are already exported from the library.\n+    // Reusing them here avoids needing to export additional symbols for\n+    // the TR1 placeholders, and avoids ODR violations due to defining\n+    // them with internal linkage (as we used to do).\n+    using namespace ::std::placeholders;\n   }\n \n   /**\n@@ -901,22 +900,13 @@ namespace tr1\n    */\n   template<int _Num>\n     struct is_placeholder<_Placeholder<_Num> >\n-    { static const int value = _Num; };\n-\n-  template<int _Num>\n-    const int is_placeholder<_Placeholder<_Num> >::value;\n-\n-#if __cplusplus >= 201103L\n-  template<int _Num>\n-    struct is_placeholder<std::_Placeholder<_Num>>\n-    : std::integral_constant<int, _Num>\n+    : integral_constant<int, _Num>\n     { };\n \n   template<int _Num>\n-    struct is_placeholder<const std::_Placeholder<_Num>>\n-    : std::integral_constant<int, _Num>\n+    struct is_placeholder<const _Placeholder<_Num> >\n+    : integral_constant<int, _Num>\n     { };\n-#endif\n \n   /**\n    * Stores a tuple of indices. Used by bind() to extract the elements\n@@ -1423,6 +1413,9 @@ namespace tr1\n                                                    _Signature> >::value;\n \n #if __cplusplus >= 201103L\n+  // Specialize tr1::is_bind_expression for std::bind closure types,\n+  // so that they can also work with tr1::bind.\n+\n   template<typename _Signature>\n     struct is_bind_expression<std::_Bind<_Signature>>\n     : true_type { };\n@@ -2242,20 +2235,8 @@ namespace tr1\n }\n \n #if __cplusplus >= 201103L\n-\n-  template<typename> struct is_placeholder;\n-\n-  template<int _Num>\n-    struct is_placeholder<tr1::_Placeholder<_Num>>\n-    : integral_constant<int, _Num>\n-    { };\n-\n-  template<int _Num>\n-    struct is_placeholder<const tr1::_Placeholder<_Num>>\n-    : integral_constant<int, _Num>\n-    { };\n-\n-  template<typename> struct is_bind_expression;\n+  // Specialize std::is_bind_expression for tr1::bind closure types,\n+  // so that they can also work with std::bind.\n \n   template<typename _Signature>\n     struct is_bind_expression<tr1::_Bind<_Signature>>"}]}