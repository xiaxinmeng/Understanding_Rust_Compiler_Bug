{"sha": "59c8e96dd02383baec4c15665985da3caadaaa5e", "node_id": "C_kwDOANBUbNoAKDU5YzhlOTZkZDAyMzgzYmFlYzRjMTU2NjU5ODVkYTNjYWFkYWFhNWU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-03-14T12:27:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T08:55:45Z"}, "message": "Implement generic range temporaries.\n\nNow that we have generic ranges, we need a way to define generic local\ntemporaries on the stack for intermediate calculations in the ranger\nand elsewhere.  We need temporaries analogous to int_range_max, but\nfor any of the supported types (currently just integers, but soon\nintegers, pointers, and floats).\n\nThe Value_Range object is such a temporary.  It is designed to be\ntransparently used as a vrange.  It shares vrange's abstract API, and\nimplicitly casts itself to a vrange when passed around.\n\nThe ultimate name will be value_range, but we need to remove legacy\nfirst for that to happen.  Until then, Value_Range will do.\n\nSample usage is as follows.  Instead of:\n\n\textern void foo (vrange &);\n\n\tint_range_max t;\n\tt.set_nonzero (type);\n\tfoo (t);\n\none does:\n\n\tValue_Range t (type);\n\tt.set_nonzero (type);\n\tfoo (t);\n\nYou can also delay initialization, for use in loops for example:\n\n\tValue_Range t;\n\t...\n\tt.set_type (type);\n\tt.set_varying (type);\n\nCreating an supported range type, will result in an unsupported_range\nobject being created, which will trap if anything but set_undefined()\nand undefined_p() are called on it.  There's no size penalty for the\nunsupported_range, since its immutable and can be shared across\ninstances.\n\nSince supports_type_p() is called at construction time for each\ntemporary, I've removed the non-zero check from this function, which\nwas mostly unneeded.  I fixed the handful of callers that were\npassing null types, and in the process sped things up a bit.\n\nAs more range types come about, the Value_Range class will be augmented\nto support them by adding the relevant bits in the initialization\ncode, etc.\n\nTested on x86-64 & ppc64le Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-fold.h (gimple_range_type): Check type before\n\tcalling supports_type_p.\n\t* gimple-range-path.cc (path_range_query::range_of_stmt): Same.\n\t* value-query.cc (range_query::get_tree_range): Same.\n\t* value-range.cc (Value_Range::lower_bound): New.\n\t(Value_Range::upper_bound): New.\n\t(Value_Range::dump): New.\n\t* value-range.h (class Value_Range): New.\n\t(irange::supports_type_p): Do not check if type is non-zero.", "tree": {"sha": "141e126d9ba14b585c2c5a8883d7f8732f33cfc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/141e126d9ba14b585c2c5a8883d7f8732f33cfc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59c8e96dd02383baec4c15665985da3caadaaa5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c8e96dd02383baec4c15665985da3caadaaa5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c8e96dd02383baec4c15665985da3caadaaa5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c8e96dd02383baec4c15665985da3caadaaa5e/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1bce19f6d51af1dfe1118cfbec19c55d3909fc"}], "stats": {"total": 180, "additions": 174, "deletions": 6}, "files": [{"sha": "20cb73dabb9cfc4ed83a1f47e68e4577ddb306e0", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=59c8e96dd02383baec4c15665985da3caadaaa5e", "patch": "@@ -81,7 +81,7 @@ gimple_range_type (const gimple *s)\n \t    type = TREE_TYPE (type);\n \t}\n     }\n-  if (irange::supports_type_p (type))\n+  if (type && irange::supports_type_p (type))\n     return type;\n   return NULL_TREE;\n }"}, {"sha": "66f433dd1d5d4c2396a4167af6b869b121993f0d", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=59c8e96dd02383baec4c15665985da3caadaaa5e", "patch": "@@ -755,7 +755,7 @@ path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n {\n   tree type = gimple_range_type (stmt);\n \n-  if (!irange::supports_type_p (type))\n+  if (!type || !irange::supports_type_p (type))\n     return false;\n \n   // If resolving unknowns, fold the statement making use of any"}, {"sha": "26e3858103b49500db3b3731972df8c019961576", "filename": "gcc/value-query.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=59c8e96dd02383baec4c15665985da3caadaaa5e", "patch": "@@ -249,7 +249,8 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n   if (UNARY_CLASS_P (expr))\n     {\n       range_operator *op = range_op_handler (TREE_CODE (expr), type);\n-      if (op)\n+      tree op0_type = TREE_TYPE (TREE_OPERAND (expr, 0));\n+      if (op && irange::supports_type_p (op0_type))\n \t{\n \t  int_range_max r0;\n \t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);"}, {"sha": "429672737a86faeec50ea927412cd24788d3148b", "filename": "gcc/value-range.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=59c8e96dd02383baec4c15665985da3caadaaa5e", "patch": "@@ -30,6 +30,42 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"gimple-range.h\"\n \n+// Convenience function only available for integers and pointers.\n+\n+wide_int\n+Value_Range::lower_bound () const\n+{\n+  if (is_a <irange> (*m_vrange))\n+    return as_a <irange> (*m_vrange).lower_bound ();\n+  gcc_unreachable ();\n+}\n+\n+// Convenience function only available for integers and pointers.\n+\n+wide_int\n+Value_Range::upper_bound () const\n+{\n+  if (is_a <irange> (*m_vrange))\n+    return as_a <irange> (*m_vrange).upper_bound ();\n+  gcc_unreachable ();\n+}\n+\n+void\n+Value_Range::dump (FILE *out) const\n+{\n+  if (m_vrange)\n+    m_vrange->dump (out);\n+  else\n+    fprintf (out, \"NULL\");\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const Value_Range &r)\n+{\n+  r.dump (stderr);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n // Default implementation when none has been defined.\n \n bool\n@@ -186,6 +222,8 @@ unsupported_range::fits_p (const vrange &) const\n   return false;\n }\n \n+unsupported_range Value_Range::m_unsupported;\n+\n // Here we copy between any two irange's.  The ranges can be legacy or\n // multi-ranges, and copying between any combination works correctly.\n "}, {"sha": "b7ea8c76f87490c1180007dab0b46e6c85ee7b73", "filename": "gcc/value-range.h", "status": "modified", "additions": 132, "deletions": 3, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c8e96dd02383baec4c15665985da3caadaaa5e/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=59c8e96dd02383baec4c15665985da3caadaaa5e", "patch": "@@ -54,6 +54,7 @@ enum value_range_discriminator\n class vrange\n {\n   template <typename T> friend bool is_a (vrange &);\n+  friend class Value_Range;\n public:\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) = 0;\n   virtual tree type () const = 0;\n@@ -313,6 +314,136 @@ typedef int_range<1> value_range;\n // calculations.\n typedef int_range<255> int_range_max;\n \n+// This is an \"infinite\" precision range object for use in temporary\n+// calculations for any of the handled types.  The object can be\n+// transparently used as a vrange.\n+\n+class Value_Range\n+{\n+public:\n+  Value_Range ();\n+  Value_Range (const vrange &r);\n+  Value_Range (tree type);\n+  void set_type (tree type);\n+  vrange& operator= (const vrange &);\n+  bool operator== (const Value_Range &r) const;\n+  bool operator!= (const Value_Range &r) const;\n+  operator vrange &();\n+  operator const vrange &() const;\n+  void dump (FILE *out = stderr) const;\n+\n+  // Convenience methods for vrange compatability.\n+  void set (tree min, tree max, value_range_kind kind = VR_RANGE)\n+    { return m_vrange->set (min, max, kind); }\n+  tree type () { return m_vrange->type (); }\n+  enum value_range_kind kind () { return m_vrange->kind (); }\n+  bool varying_p () const { return m_vrange->varying_p (); }\n+  bool undefined_p () const { return m_vrange->undefined_p (); }\n+  void set_varying (tree type) { m_vrange->set_varying (type); }\n+  void set_undefined () { m_vrange->set_undefined (); }\n+  bool union_ (const vrange &r) { return m_vrange->union_ (r); }\n+  bool intersect (const vrange &r) { return m_vrange->intersect (r); }\n+  bool singleton_p (tree *result = NULL) const\n+    { return m_vrange->singleton_p (result); }\n+  bool zero_p () const { return m_vrange->zero_p (); }\n+  wide_int lower_bound () const; // For irange/prange compatability.\n+  wide_int upper_bound () const; // For irange/prange compatability.\n+private:\n+  void init (tree type);\n+  static unsupported_range m_unsupported;\n+  vrange *m_vrange;\n+  int_range_max m_irange;\n+  DISABLE_COPY_AND_ASSIGN (Value_Range);\n+};\n+\n+inline\n+Value_Range::Value_Range ()\n+{\n+  m_vrange = &m_unsupported;\n+}\n+\n+// Copy constructor from a vrange.\n+\n+inline\n+Value_Range::Value_Range (const vrange &r)\n+{\n+  *this = r;\n+}\n+\n+// Copy constructor from a TYPE.  The range of the temporary is set to\n+// UNDEFINED.\n+\n+inline\n+Value_Range::Value_Range (tree type)\n+{\n+  init (type);\n+}\n+\n+// Initialize object so it is possible to store temporaries of TYPE\n+// into it.\n+\n+inline void\n+Value_Range::init (tree type)\n+{\n+  gcc_checking_assert (TYPE_P (type));\n+\n+  if (irange::supports_type_p (type))\n+    m_vrange = &m_irange;\n+  else\n+    m_vrange = &m_unsupported;\n+}\n+\n+// Set the temporary to allow storing temporaries of TYPE.  The range\n+// of the temporary is set to UNDEFINED.\n+\n+inline void\n+Value_Range::set_type (tree type)\n+{\n+  init (type);\n+  m_vrange->set_undefined ();\n+}\n+\n+// Assignment operator for temporaries.  Copying incompatible types is\n+// allowed.\n+\n+inline vrange &\n+Value_Range::operator= (const vrange &r)\n+{\n+  if (is_a <irange> (r))\n+    {\n+      m_irange = as_a <irange> (r);\n+      m_vrange = &m_irange;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return *m_vrange;\n+}\n+\n+inline bool\n+Value_Range::operator== (const Value_Range &r) const\n+{\n+  return *m_vrange == *r.m_vrange;\n+}\n+\n+inline bool\n+Value_Range::operator!= (const Value_Range &r) const\n+{\n+  return *m_vrange != *r.m_vrange;\n+}\n+\n+inline\n+Value_Range::operator vrange &()\n+{\n+  return *m_vrange;\n+}\n+\n+inline\n+Value_Range::operator const vrange &() const\n+{\n+  return *m_vrange;\n+}\n+\n // Returns true for an old-school value_range as described above.\n inline bool\n irange::legacy_mode_p () const\n@@ -451,9 +582,7 @@ irange::nonzero_p () const\n inline bool\n irange::supports_type_p (tree type)\n {\n-  if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n-    return type;\n-  return false;\n+  return INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type);\n }\n \n inline bool"}]}