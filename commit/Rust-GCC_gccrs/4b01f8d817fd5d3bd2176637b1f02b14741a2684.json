{"sha": "4b01f8d817fd5d3bd2176637b1f02b14741a2684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwMWY4ZDgxN2ZkNWQzYmQyMTc2NjM3YjFmMDJiMTQ3NDFhMjY4NA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-07-17T11:58:54Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-07-17T11:58:54Z"}, "message": "c-parse.in (all_prefix_attributes): New variable.\n\n\t* c-parse.in (all_prefix_attributes): New variable.\n\t(PUSH_DECLSPEC_STACK, POP_DECLSPEC_STACK): New macros.\n\t(maybe_resetattrs): New production.\n\t(c_parse_init, datadef, fndef, datadecl, setspecs, setattrs, decl,\n\tmaybe_type_quals_setattrs, initdecls, notype_initdecls, initdcl,\n\tnotype_initdcl, nested_function, notype_nested_function,\n\tcomponent_decl, components, components_notype,\n\tcomponent_declarator, component_notype_declarator,\n\tabsdcl_maybe_attribute, parm, firstparm, setspecs_fp, ivar_decl,\n\tivars, mydecl, myparm): Update.  Avoid prefix attributes just\n\tafter a comma being applied to more than one declarator.\n\t* doc/extend.texi (Attribute Syntax): Update.  Remove\n\tdocumentation of bugs that are no longer present.\n\ntestsuite:\n\t* gcc.c-torture/compile/20010714-1.c, gcc.dg/format/attr-4.c: New\n\ttests.\n\nFrom-SVN: r44070", "tree": {"sha": "c445adeac5f944ebf602b7f57989eb9c6f6c4a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c445adeac5f944ebf602b7f57989eb9c6f6c4a83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b01f8d817fd5d3bd2176637b1f02b14741a2684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b01f8d817fd5d3bd2176637b1f02b14741a2684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b01f8d817fd5d3bd2176637b1f02b14741a2684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b01f8d817fd5d3bd2176637b1f02b14741a2684/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eae4bce3a43dad89963794efbc5c4b3b6271bcd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae4bce3a43dad89963794efbc5c4b3b6271bcd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae4bce3a43dad89963794efbc5c4b3b6271bcd8"}], "stats": {"total": 303, "additions": 159, "deletions": 144}, "files": [{"sha": "48466608a65518da48ec7a8d23b3bae25bab4e42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -1,3 +1,19 @@\n+2001-07-17  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-parse.in (all_prefix_attributes): New variable.\n+\t(PUSH_DECLSPEC_STACK, POP_DECLSPEC_STACK): New macros.\n+\t(maybe_resetattrs): New production.\n+\t(c_parse_init, datadef, fndef, datadecl, setspecs, setattrs, decl,\n+\tmaybe_type_quals_setattrs, initdecls, notype_initdecls, initdcl,\n+\tnotype_initdcl, nested_function, notype_nested_function,\n+\tcomponent_decl, components, components_notype,\n+\tcomponent_declarator, component_notype_declarator,\n+\tabsdcl_maybe_attribute, parm, firstparm, setspecs_fp, ivar_decl,\n+\tivars, mydecl, myparm): Update.  Avoid prefix attributes just\n+\tafter a comma being applied to more than one declarator.\n+\t* doc/extend.texi (Attribute Syntax): Update.  Remove\n+\tdocumentation of bugs that are no longer present.\n+\n 2001-07-13  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.h: Change TUNE_MIPS* options to use"}, {"sha": "d33a8c56b487f7e27cb755608f3ad4d3c2ed5df7", "filename": "gcc/c-parse.in", "status": "modified", "additions": 102, "deletions": 133, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -244,9 +244,33 @@ static int if_stmt_line;\n static tree current_declspecs = NULL_TREE;\n static tree prefix_attributes = NULL_TREE;\n \n-/* Stack of saved values of current_declspecs and prefix_attributes.  */\n+/* List of all the attributes applying to the identifier currently being\n+   declared; includes prefix_attributes and possibly some more attributes\n+   just after a comma.  */\n+static tree all_prefix_attributes = NULL_TREE;\n+\n+/* Stack of saved values of current_declspecs, prefix_attributes and\n+   all_prefix_attributes.  */\n static tree declspec_stack;\n \n+/* PUSH_DECLSPEC_STACK is called from setspecs; POP_DECLSPEC_STACK\n+   should be called from the productions making use of setspecs.  */\n+#define PUSH_DECLSPEC_STACK\t\t\t\t\t\t \\\n+  do {\t\t\t\t\t\t\t\t\t \\\n+    declspec_stack = tree_cons (build_tree_list (prefix_attributes,\t \\\n+\t\t\t\t\t\t all_prefix_attributes), \\\n+\t\t\t\tcurrent_declspecs,\t\t\t \\\n+\t\t\t\tdeclspec_stack);\t\t\t \\\n+  } while (0)\n+\n+#define POP_DECLSPEC_STACK\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    current_declspecs = TREE_VALUE (declspec_stack);\t\t\t\\\n+    prefix_attributes = TREE_PURPOSE (TREE_PURPOSE (declspec_stack));\t\\\n+    all_prefix_attributes = TREE_VALUE (TREE_PURPOSE (declspec_stack));\t\\\n+    declspec_stack = TREE_CHAIN (declspec_stack);\t\t\t\\\n+  } while (0)\n+\n /* For __extension__, save/restore the warning flags which are\n    controlled by __extension__.  */\n #define SAVE_WARN_FLAGS()\t\\\n@@ -291,6 +315,7 @@ c_parse_init ()\n   ggc_add_tree_root (&declspec_stack, 1);\n   ggc_add_tree_root (&current_declspecs, 1);\n   ggc_add_tree_root (&prefix_attributes, 1);\n+  ggc_add_tree_root (&all_prefix_attributes, 1);\n ifobjc\n   ggc_add_tree_root (&objc_interface_context, 1);\n   ggc_add_tree_root (&objc_implementation_context, 1);\n@@ -355,17 +380,11 @@ datadef:\n \t\t  else if (!flag_traditional)\n \t\t    warning (\"data definition has no type or storage class\"); \n \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n         | declspecs_nots setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs ';'\n \t  { shadow_tag ($1); }\n \t| error ';'\n@@ -378,7 +397,7 @@ datadef:\n fndef:\n \t  declspecs_ts setspecs declarator\n \t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes))\n+\t\t\t\t\tall_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls\n@@ -387,16 +406,12 @@ fndef:\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n \t\t  finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_declarator\n \t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes))\n+\t\t\t\t\tall_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls\n@@ -405,16 +420,12 @@ fndef:\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n \t\t  finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| setspecs notype_declarator\n \t\t{ if (! start_function (NULL_TREE, $2,\n-\t\t\t\t\tprefix_attributes))\n+\t\t\t\t\tall_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls\n@@ -423,13 +434,9 @@ fndef:\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $6;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $7;\n \t\t  finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t;\n \n identifier:\n@@ -800,13 +807,9 @@ datadecls:\n    style parm.  */\n datadecl:\n \tdeclspecs_ts_nosa setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_nots_nosa setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\t\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_ts_nosa ';'\n \t\t{ shadow_tag_warned ($1, 1);\n \t\t  pedwarn (\"empty declaration\"); }\n@@ -829,16 +832,15 @@ lineno_decl:\n    for the sake of parm declarations nested in function declarators.  */\n setspecs: /* empty */\n \t\t{ pending_xref_error ();\n-\t\t  declspec_stack = tree_cons (prefix_attributes,\n-\t\t\t\t\t      current_declspecs,\n-\t\t\t\t\t      declspec_stack);\n+\t\t  PUSH_DECLSPEC_STACK;\n \t\t  split_specs_attrs ($<ttype>0,\n-\t\t\t\t     &current_declspecs, &prefix_attributes); }\n+\t\t\t\t     &current_declspecs, &prefix_attributes);\n+\t\t  all_prefix_attributes = prefix_attributes; }\n \t;\n \n /* ??? Yuck.  See maybe_setattrs.  */\n setattrs: /* empty */\n-\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n+\t\t{ all_prefix_attributes = chainon ($<ttype>0, all_prefix_attributes); }\n \t;\n \n maybe_setattrs:\n@@ -854,23 +856,22 @@ maybe_setattrs:\n \t  maybe_attribute setattrs\n \t;\n \n+/* Possibly attributes after a comma, which should reset all_prefix_attributes\n+   to prefix_attributes with these ones chained on the front.  */\n+maybe_resetattrs:\n+\t\t{ all_prefix_attributes = prefix_attributes; }\n+\t  maybe_setattrs\n+\t;\n+\n decl:\n \tdeclspecs_ts setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs ';'\n \t\t{ shadow_tag ($1); }\n \t| extension decl\n@@ -1347,7 +1348,7 @@ maybe_type_quals_setattrs:\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n \t\t  /* ??? Yuck.  See maybe_setattrs.  */\n \t\t  if (attrs != NULL_TREE)\n-\t\t    prefix_attributes = chainon (prefix_attributes, attrs);\n+\t\t    all_prefix_attributes = chainon (attrs, all_prefix_attributes);\n \t\t  $$ = specs; }\n \t;\n \n@@ -1416,12 +1417,12 @@ end ifobjc\n \n initdecls:\n \tinitdcl\n-\t| initdecls ',' maybe_setattrs initdcl\n+\t| initdecls ',' maybe_resetattrs initdcl\n \t;\n \n notype_initdecls:\n \tnotype_initdcl\n-\t| notype_initdecls ',' maybe_setattrs notype_initdcl\n+\t| notype_initdecls ',' maybe_resetattrs notype_initdcl\n \t;\n \n maybeasm:\n@@ -1436,31 +1437,31 @@ maybeasm:\n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  chainon ($3, prefix_attributes));\n+\t\t\t\t\t  chainon ($3, all_prefix_attributes));\n \t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       chainon ($3, prefix_attributes));\n+\t\t\t\t       chainon ($3, all_prefix_attributes));\n \t\t  finish_decl (d, NULL_TREE, $2); \n                 }\n \t;\n \n notype_initdcl:\n \t  notype_declarator maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  chainon ($3, prefix_attributes));\n+\t\t\t\t\t  chainon ($3, all_prefix_attributes));\n \t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       chainon ($3, prefix_attributes));\n+\t\t\t\t       chainon ($3, all_prefix_attributes));\n \t\t  finish_decl (d, NULL_TREE, $2); }\n \t;\n /* the * rules are dummies to accept the Apollo extended syntax\n@@ -1594,7 +1595,7 @@ nested_function:\n \n \t\t  push_function_context ();\n \t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes))\n+\t\t\t\t\tall_prefix_attributes))\n \t\t    {\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n@@ -1624,7 +1625,7 @@ notype_nested_function:\n \n \t\t  push_function_context ();\n \t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes))\n+\t\t\t\t\tall_prefix_attributes))\n \t\t    {\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n@@ -1848,9 +1849,7 @@ end ifobjc\n component_decl:\n \t  declspecs_nosc_ts setspecs components\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_ts setspecs save_filename save_lineno\n \t\t{\n \t\t  /* Support for unnamed structs or unions as members of \n@@ -1860,15 +1859,10 @@ component_decl:\n \t\t    pedwarn (\"ISO C doesn't support unnamed structs/unions\");\n \n \t\t  $$ = grokfield($3, $4, NULL, current_declspecs, NULL_TREE);\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n-\t\t}\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_nots setspecs components_notype\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_nots\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"ISO C forbids member declarations with no members\");\n@@ -1883,40 +1877,40 @@ component_decl:\n \n components:\n \t  component_declarator\n-\t| components ',' maybe_setattrs component_declarator\n+\t| components ',' maybe_resetattrs component_declarator\n \t\t{ $$ = chainon ($1, $4); }\n \t;\n \n components_notype:\n \t  component_notype_declarator\n-\t| components_notype ',' maybe_setattrs component_notype_declarator\n+\t| components_notype ',' maybe_resetattrs component_notype_declarator\n \t\t{ $$ = chainon ($1, $4); }\n \t;\n \n component_declarator:\n \t  save_filename save_lineno declarator maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n-\t\t  decl_attributes (&$$, chainon ($4, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($4, all_prefix_attributes), 0); }\n \t| save_filename save_lineno\n \t  declarator ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n-\t\t  decl_attributes (&$$, chainon ($6, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($6, all_prefix_attributes), 0); }\n \t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n-\t\t  decl_attributes (&$$, chainon ($5, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($5, all_prefix_attributes), 0); }\n \t;\n \n component_notype_declarator:\n \t  save_filename save_lineno notype_declarator maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n-\t\t  decl_attributes (&$$, chainon ($4, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($4, all_prefix_attributes), 0); }\n \t| save_filename save_lineno\n \t  notype_declarator ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n-\t\t  decl_attributes (&$$, chainon ($6, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($6, all_prefix_attributes), 0); }\n \t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n-\t\t  decl_attributes (&$$, chainon ($5, prefix_attributes), 0); }\n+\t\t  decl_attributes (&$$, chainon ($5, all_prefix_attributes), 0); }\n \t;\n \n /* We chain the enumerators in reverse order.\n@@ -1966,15 +1960,15 @@ absdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */\n \t/* empty */\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t NULL_TREE),\n-\t\t\t\t\tprefix_attributes); }\n+\t\t\t\t\tall_prefix_attributes); }\n \t| absdcl1\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $1),\n-\t\t\t\t\tprefix_attributes); }\n+\t\t\t\t\tall_prefix_attributes); }\n \t| absdcl1_noea attributes\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $1),\n-\t\t\t\t\tchainon ($2, prefix_attributes)); }\n+\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n \t;\n \n absdcl1:  /* a nonempty absolute declarator */\n@@ -2564,35 +2558,25 @@ parm:\n \t  declspecs_ts setspecs parm_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes)); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes)); \n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs absdcl_maybe_attribute\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n+\t\t  POP_DECLSPEC_STACK; }\n \n \t| declspecs_nots setspecs absdcl_maybe_attribute\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t;\n \n /* The first parm, which must suck attributes from off the top of the parser\n@@ -2601,40 +2585,31 @@ firstparm:\n \t  declspecs_ts_nosa setspecs_fp parm_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes)); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes)); \n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nots_nosa setspecs_fp notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, prefix_attributes));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n+\t\t  POP_DECLSPEC_STACK; }\n \n \t| declspecs_nots_nosa setspecs_fp absdcl_maybe_attribute\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t;\n \n setspecs_fp:\n \t  setspecs\n-\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>-2); }\n+\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>-2);\n+\t\t  all_prefix_attributes = prefix_attributes; }\n \t;\n \n /* This is used in a function definition\n@@ -2918,14 +2893,10 @@ ivar_decls:\n ivar_decl:\n \tdeclspecs_nosc_ts setspecs ivars\n \t        { $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_nots setspecs ivars\n \t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t  POP_DECLSPEC_STACK; }\n \t| error\n \t\t{ $$ = NULL_TREE; }\n \t;\n@@ -2934,7 +2905,7 @@ ivars:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| ivar_declarator\n-\t| ivars ',' maybe_setattrs ivar_declarator\n+\t| ivars ',' maybe_resetattrs ivar_declarator\n \t;\n \n ivar_declarator:\n@@ -3081,9 +3052,7 @@ mydecls:\n \n mydecl:\n \tdeclspecs_ts setspecs myparms ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n+\t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_ts ';'\n \t\t{ shadow_tag ($1); }\n \t| declspecs_nots ';'\n@@ -3104,11 +3073,11 @@ myparm:\n \t  parm_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $1),\n-\t\t\t\t\tchainon ($2, prefix_attributes)); }\n+\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n \t| notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $1),\n-\t\t\t\t\tchainon ($2, prefix_attributes)); }\n+\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n \t| absdcl_maybe_attribute\n \t\t{ $$ = $1; }\n \t;"}, {"sha": "74dd33effd72b64f85881beeef37c05c80b7f5ec", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -2188,15 +2188,12 @@ other specifiers or qualifiers.\n An attribute specifier list may appear immediately before a declarator\n (other than the first) in a comma-separated list of declarators in a\n declaration of more than one identifier using a single list of\n-specifiers and qualifiers.  At present, such attribute specifiers apply\n-not only to the identifier before whose declarator they appear, but to\n-all subsequent identifiers declared in that declaration, but in future\n-they may apply only to that single identifier.  For example, in\n+specifiers and qualifiers.  Such attribute specifiers apply\n+only to the identifier before whose declarator they appear.  For example, in\n @code{__attribute__((noreturn)) void d0 (void),\n __attribute__((format(printf, 1, 2))) d1 (const char *, ...), d2\n (void)}, the @code{noreturn} attribute applies to all the functions\n-declared; the @code{format} attribute should only apply to @code{d1},\n-but at present applies to @code{d2} as well (and so causes an error).\n+declared; the @code{format} attribute only applies to @code{d1}.\n \n An attribute specifier list may appear immediately before the comma,\n @code{=} or semicolon terminating the declaration of an identifier other\n@@ -2227,12 +2224,10 @@ ignored.\n \n An attribute specifier list may appear at the start of a nested\n declarator.  At present, there are some limitations in this usage: the\n-attributes apply to the identifier declared, and to all subsequent\n-identifiers declared in that declaration (if it includes a\n-comma-separated list of declarators), rather than to a specific\n+attributes apply to the identifier declared, rather than to a specific\n declarator.  When attribute specifiers follow the @code{*} of a pointer\n-declarator, they must presently follow any type qualifiers present, and\n-cannot be mixed with them.  The following describes intended future\n+declarator, they may be mixed with any type qualifiers present.\n+The following describes intended future\n semantics which make this syntax more useful only.  It will make the\n most sense if you are familiar with the formal specification of\n declarators in the ISO C standard."}, {"sha": "5d8d2dc3102672bbf6678bb3e20209f73224d318", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -1,3 +1,8 @@\n+2001-07-17  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.c-torture/compile/20010714-1.c, gcc.dg/format/attr-4.c: New\n+\ttests.\n+\n 2001-07-17  Peter Schmid  <schmid@snake.iap.physik.tu-darmstadt.de>\n \n \t* g++.old-deja/g++.robertl/eb130.C: Include the correct header file."}, {"sha": "fc4bdbac7d5cee62caa66702fe6229048e2e960a", "filename": "gcc/testsuite/gcc.c-torture/compile/20010714-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010714-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010714-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010714-1.c?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -0,0 +1,5 @@\n+/* Test that prefix attributes after a comma only apply to a single\n+   declared object or function.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */\n+\n+__attribute__((noreturn)) void d0 (void), __attribute__((format(printf, 1, 2))) d1 (const char *, ...), d2 (void);"}, {"sha": "ef50c494f35d1a8a6bea850c8918ac205cc7e367", "filename": "gcc/testsuite/gcc.dg/format/attr-4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b01f8d817fd5d3bd2176637b1f02b14741a2684/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-4.c?ref=4b01f8d817fd5d3bd2176637b1f02b14741a2684", "patch": "@@ -0,0 +1,25 @@\n+/* Test for format attributes: test use of __attribute__\n+   in prefix attributes.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#include \"format.h\"\n+\n+extern __attribute__((format(printf, 1, 2))) void tformatprintf0 (const char *, ...);\n+extern void __attribute__((format(printf, 1, 2))) tformatprintf1 (const char *, ...);\n+extern void foo (void), __attribute__((format(printf, 1, 2))) tformatprintf2 (const char *, ...);\n+extern __attribute__((noreturn)) void bar (void), __attribute__((format(printf, 1, 2))) tformatprintf3 (const char *, ...);\n+\n+void\n+baz (int i, int *ip, double d)\n+{\n+  tformatprintf0 (\"%d\", i);\n+  tformatprintf0 (\"%\"); /* { dg-warning \"format\" \"attribute format printf case 0\" } */\n+  tformatprintf1 (\"%d\", i);\n+  tformatprintf1 (\"%\"); /* { dg-warning \"format\" \"attribute format printf case 1\" } */\n+  tformatprintf2 (\"%d\", i);\n+  tformatprintf2 (\"%\"); /* { dg-warning \"format\" \"attribute format printf case 2\" } */\n+  tformatprintf3 (\"%d\", i);\n+  tformatprintf3 (\"%\"); /* { dg-warning \"format\" \"attribute format printf case 3\" } */\n+}"}]}