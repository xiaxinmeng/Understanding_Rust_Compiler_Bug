{"sha": "518dc85936a6b0706be276e004c0d556bca3ef83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE4ZGM4NTkzNmE2YjA3MDZiZTI3NmUwMDRjMGQ1NTZiY2EzZWY4Mw==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2005-08-01T07:26:30Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2005-08-01T07:26:30Z"}, "message": "ipa-cp.c: New file.\n\n\t* ipa-cp.c: New file. Contains IPCP specific functionality.\n\t* ipa-prop.h: New file. Contains structures/definitions that can be\n\tused by several interprocedural data flow optimizations (and also IPCP).\n\t* ipa-prop.c: New file.\n\nFrom-SVN: r102624", "tree": {"sha": "66b9768fe0dd90a22c39e11c0cfc926ed3a4e804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66b9768fe0dd90a22c39e11c0cfc926ed3a4e804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/518dc85936a6b0706be276e004c0d556bca3ef83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518dc85936a6b0706be276e004c0d556bca3ef83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518dc85936a6b0706be276e004c0d556bca3ef83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518dc85936a6b0706be276e004c0d556bca3ef83/comments", "author": null, "committer": null, "parents": [{"sha": "ee2242a25a2ff4babe1995c94aef0606d4244dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee2242a25a2ff4babe1995c94aef0606d4244dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee2242a25a2ff4babe1995c94aef0606d4244dcb"}], "stats": {"total": 2023, "additions": 2023, "deletions": 0}, "files": [{"sha": "f7dad3f63e44585c300f204a5a555d2510b8b044", "filename": "gcc/ipa-cp.c", "status": "added", "additions": 1143, "deletions": 0, "changes": 1143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=518dc85936a6b0706be276e004c0d556bca3ef83", "patch": "@@ -0,0 +1,1143 @@\n+/* Interprocedural constant propagation\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Razya Ladelsky <RAZYA@il.ibm.com>\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Interprocedural constant propagation.\n+   The aim of interprocedural constant propagation (IPCP) is to find which \n+   function's argument has the same constant value in each invocation throughout \n+   the whole program. For example, for an application consisting of two files, \n+   foo1.c, foo2.c:\n+\n+   foo1.c contains :\n+   \n+   int f (int x)\n+   {\n+     g (x);\n+   }\n+   void main (void)\n+   {\n+     f (3);\n+     h (3);\n+   }\n+   \n+   foo2.c contains :\n+   \n+   int h (int y)\n+   {\n+     g (y);\n+   }\n+   int g (int y)\n+   {\n+     printf (\"value is %d\",y);\n+   }\n+   \n+   The IPCP algorithm will find that g's formal argument y\n+   is always called with the value 3.\n+   \n+   The algorithm used is based on \"Interprocedural Constant Propagation\",\n+   by Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, \n+   pg 152-161\n+   \n+   The optimization is divided into three stages:\n+\n+   First stage - intraprocedural analysis\n+   =======================================\n+   This phase computes jump_function and modify information.\n+   \n+   A jump function for a callsite represents the values passed as actual \n+   arguments\n+   of the callsite. There are three types of values :\n+   Formal - the caller's formal parameter is passed as an actual argument.\n+   Constant - a constant is passed as a an actual argument.\n+   Unknown - neither of the above.\n+   \n+   In order to compute the jump functions, we need the modify information for \n+   the formal parameters of methods.\n+   \n+   The jump function info, ipa_jump_func, is defined in ipa_edge\n+   structure (defined in ipa_prop.h and pointed to by cgraph_node->aux)\n+   The modify info, ipa_modify, is defined in ipa_node structure\n+   (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n+   \n+   -ipcp_init_stage() is the first stage driver.\n+\n+   Second stage - interprocedural analysis\n+   ========================================\n+   This phase does the interprocedural constant propagation.\n+   It computes for all formal parameters in the program\n+   their cval value that may be:\n+   TOP - unknown.\n+   BOTTOM - non constant.\n+   CONSTANT_TYPE - constant value.\n+   \n+   Cval of formal f will have a constant value if all callsites to this\n+   function have the same constant value passed to f.\n+   \n+   The cval info, ipcp_formal, is defined in ipa_node structure\n+   (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n+\n+   -ipcp_iterate_stage() is the second stage driver.\n+\n+   Third phase - transformation of methods code\n+   ============================================\n+   Propagates the constant-valued formals into the function.\n+   For each method mt, whose parameters are consts, we create a clone/version.\n+\n+   We use two ways to annotate the versioned function with the constant \n+   formal information:\n+   1. We insert an assignment statement 'parameter = const' at the beginning\n+   of the cloned method.\n+   2. For read-only formals whose address is not taken, we replace all uses \n+   of the formal with the constant (we provide versioning with an \n+   ipa_replace_map struct representing the trees we want to replace).\n+\n+   We also need to modify some callsites to call to the cloned methods instead\n+   of the original ones. For a callsite passing an argument found to be a\n+   constant by IPCP, there are two different cases to handle:\n+   1. A constant is passed as an argument.\n+   2. A parameter (of the caller) passed as an argument (pass through argument).\n+\n+   In the first case, the callsite in the original caller should be redirected\n+   to call the cloned callee.\n+   In the second case, both the caller and the callee have clones\n+   and the callsite of the cloned caller would be redirected to call to\n+   the cloned callee.\n+\n+   The callgraph is updated accordingly.\n+\n+   This update is done in two stages:\n+   First all cloned methods are created during a traversal of the callgraph,\n+   during which all callsites are redirected to call the cloned method.\n+   Then the callsites are traversed and updated as described above.\n+\n+   -ipcp_insert_stage() is the third phase driver.\n+   \n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"ipa-prop.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+\n+/* Get orig node field of ipa_node associated with method MT.  */\n+static inline struct cgraph_node *\n+ipcp_method_orig_node (struct cgraph_node *mt)\n+{\n+  return IPA_NODE_REF (mt)->ipcp_orig_node;\n+}\n+\n+/* Return true if NODE is a cloned/versioned method.  */\n+static inline bool\n+ipcp_method_is_cloned (struct cgraph_node *node)\n+{\n+  return (ipcp_method_orig_node (node) != NULL);\n+}\n+\n+/* Set ORIG_NODE in ipa_node associated with method NODE.  */\n+static inline void\n+ipcp_method_set_orig_node (struct cgraph_node *node,\n+\t\t\t   struct cgraph_node *orig_node)\n+{\n+  IPA_NODE_REF (node)->ipcp_orig_node = orig_node;\n+}\n+\n+/* Create ipa_node and its data strutures for NEW_NODE.\n+   Set ORIG_NODE as the orig_node field in ipa_node.  */\n+static void\n+ipcp_cloned_create (struct cgraph_node *orig_node,\n+\t\t    struct cgraph_node *new_node)\n+{\n+  ipa_node_create (new_node);\n+  ipcp_method_set_orig_node (new_node, orig_node);\n+  ipa_method_formal_compute_count (new_node);\n+  ipa_method_compute_tree_map (new_node);\n+}\n+\n+/* Return cval_type field of CVAL.  */\n+static inline enum cvalue_type\n+ipcp_cval_get_cvalue_type (struct ipcp_formal *cval)\n+{\n+  return cval->cval_type;\n+}\n+\n+/* Return scale for MT.  */\n+static inline gcov_type\n+ipcp_method_get_scale (struct cgraph_node *mt)\n+{\n+  return IPA_NODE_REF (mt)->count_scale;\n+}\n+\n+/* Set COUNT as scale for MT.  */\n+static inline void\n+ipcp_method_set_scale (struct cgraph_node *node, gcov_type count)\n+{\n+  IPA_NODE_REF (node)->count_scale = count;\n+}\n+\n+/* Set TYPE as cval_type field of CVAL.  */\n+static inline void\n+ipcp_cval_set_cvalue_type (struct ipcp_formal *cval, enum cvalue_type type)\n+{\n+  cval->cval_type = type;\n+}\n+\n+/* Return cvalue field of CVAL.  */\n+static inline union parameter_info *\n+ipcp_cval_get_cvalue (struct ipcp_formal *cval)\n+{\n+  return &(cval->cvalue);\n+}\n+\n+/* Set VALUE as cvalue field  CVAL.  */\n+static inline void\n+ipcp_cval_set_cvalue (struct ipcp_formal *cval, union parameter_info *value,\n+\t\t      enum cvalue_type type)\n+{\n+  if (type == CONST_VALUE || type == CONST_VALUE_REF)\n+    cval->cvalue.value =  value->value;\n+}\n+\n+/* Return whether TYPE is a constant type.  */\n+static bool\n+ipcp_type_is_const (enum cvalue_type type)\n+{\n+  if (type == CONST_VALUE || type == CONST_VALUE_REF)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Return true if CONST_VAL1 and CONST_VAL2 are equal.  */\n+static inline bool\n+ipcp_cval_equal_cvalues (union parameter_info *const_val1,\n+\t\t\t union parameter_info *const_val2,\n+\t\t\t enum cvalue_type type1, enum cvalue_type type2)\n+{\n+  gcc_assert (ipcp_type_is_const (type1) && ipcp_type_is_const (type2));\n+  if (type1 != type2)\n+    return false;\n+\n+  if (operand_equal_p (const_val1->value, const_val2->value, 0))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Compute Meet arithmetics:\n+   Meet (BOTTOM, x) = BOTTOM\n+   Meet (TOP,x) = x\n+   Meet (const_a,const_b) = BOTTOM,  if const_a != const_b.  \n+   MEET (const_a,const_b) = const_a, if const_a == const_b.*/\n+static void\n+ipcp_cval_meet (struct ipcp_formal *cval, struct ipcp_formal *cval1,\n+\t\tstruct ipcp_formal *cval2)\n+{\n+  if (ipcp_cval_get_cvalue_type (cval1) == BOTTOM\n+      || ipcp_cval_get_cvalue_type (cval2) == BOTTOM)\n+    {\n+      ipcp_cval_set_cvalue_type (cval, BOTTOM);\n+      return;\n+    }\n+  if (ipcp_cval_get_cvalue_type (cval1) == TOP)\n+    {\n+      ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval2));\n+      ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval2),\n+\t\t\t    ipcp_cval_get_cvalue_type (cval2));\n+      return;\n+    }\n+  if (ipcp_cval_get_cvalue_type (cval2) == TOP)\n+    {\n+      ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n+      ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval1),\n+\t\t\t    ipcp_cval_get_cvalue_type (cval1));\n+      return;\n+    }\n+  if (!ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n+\t\t\t\tipcp_cval_get_cvalue (cval2),\n+\t\t\t\tipcp_cval_get_cvalue_type (cval1),\n+\t\t\t\tipcp_cval_get_cvalue_type (cval2)))\n+    {\n+      ipcp_cval_set_cvalue_type (cval, BOTTOM);\n+      return;\n+    }\n+  ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n+  ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval1),\n+\t\t\tipcp_cval_get_cvalue_type (cval1));\n+}\n+\n+/* Return cval structure for the formal at index INFO_TYPE in MT.  */\n+static inline struct ipcp_formal *\n+ipcp_method_cval (struct cgraph_node *mt, int info_type)\n+{\n+  return &(IPA_NODE_REF (mt)->ipcp_cval[info_type]);\n+}\n+\n+/* Given the jump function (TYPE, INFO_TYPE), compute a new value of CVAL.  \n+   If TYPE is FORMAL_IPA_TYPE, the cval of the corresponding formal is \n+   drawn from MT.  */\n+static void\n+ipcp_cval_compute (struct ipcp_formal *cval, struct cgraph_node *mt,\n+\t\t   enum jump_func_type type, union parameter_info *info_type)\n+{\n+  if (type == UNKNOWN_IPATYPE)\n+    ipcp_cval_set_cvalue_type (cval, BOTTOM);\n+  else if (type == CONST_IPATYPE)\n+    {\n+      ipcp_cval_set_cvalue_type (cval, CONST_VALUE);\n+      ipcp_cval_set_cvalue (cval, info_type, CONST_VALUE);\n+    }\n+  else if (type == CONST_IPATYPE_REF)\n+    {\n+      ipcp_cval_set_cvalue_type (cval, CONST_VALUE_REF);\n+      ipcp_cval_set_cvalue (cval, info_type, CONST_VALUE_REF);\n+    }\n+  else if (type == FORMAL_IPATYPE)\n+    {\n+      enum cvalue_type type =\n+\tipcp_cval_get_cvalue_type (ipcp_method_cval\n+\t\t\t\t   (mt, info_type->formal_id));\n+      ipcp_cval_set_cvalue_type (cval, type);\n+      ipcp_cval_set_cvalue (cval,\n+\t\t\t    ipcp_cval_get_cvalue (ipcp_method_cval\n+\t\t\t\t\t\t  (mt, info_type->formal_id)),\n+\t\t\t    type);\n+    }\n+}\n+\n+/* True when CVAL1 and CVAL2 values are not the same.  */\n+static bool\n+ipcp_cval_changed (struct ipcp_formal *cval1, struct ipcp_formal *cval2)\n+{\n+  if (ipcp_cval_get_cvalue_type (cval1) == ipcp_cval_get_cvalue_type (cval2))\n+    {\n+      if (ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE &&\n+\t  ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE_REF)\t \n+\treturn false;\n+      if (ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n+\t\t\t\t   ipcp_cval_get_cvalue (cval2),\n+\t\t\t\t   ipcp_cval_get_cvalue_type (cval1),\n+\t\t\t\t   ipcp_cval_get_cvalue_type (cval2)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Create cval structure for method MT.  */\n+static inline void\n+ipcp_formal_create (struct cgraph_node *mt)\n+{\n+  IPA_NODE_REF (mt)->ipcp_cval =\n+    xcalloc (ipa_method_formal_count (mt), sizeof (struct ipcp_formal));\n+}\n+\n+/* Set cval structure of I-th formal of MT to CVAL.  */\n+static inline void\n+ipcp_method_cval_set (struct cgraph_node *mt, int i, struct ipcp_formal *cval)\n+{\n+  IPA_NODE_REF (mt)->ipcp_cval[i].cval_type = cval->cval_type;\n+  ipcp_cval_set_cvalue (ipcp_method_cval (mt, i),\n+\t\t\tipcp_cval_get_cvalue (cval), cval->cval_type);\n+}\n+\n+/* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */\n+static inline void\n+ipcp_method_cval_set_cvalue_type (struct cgraph_node *mt, int i,\n+\t\t\t\t  enum cvalue_type cval_type1)\n+{\n+  IPA_NODE_REF (mt)->ipcp_cval[i].cval_type = cval_type1;\n+}\n+\n+/* Print ipcp_cval data structures to F.  */\n+static void\n+ipcp_method_cval_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+  int i, count;\n+  tree cvalue;\n+ \n+  fprintf (f, \"\\nCVAL PRINT\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"Printing cvals %s:\\n\", cgraph_node_name (node));\n+      count = ipa_method_formal_count (node);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  if (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i))\n+\t      == CONST_VALUE\n+\t      || ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) ==\n+\t      CONST_VALUE_REF)\n+\t    {\n+\t      fprintf (f, \" param [%d]: \", i);\n+\t      fprintf (f, \"type is CONST \");\n+\t      cvalue =\n+\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i))->\n+\t\t  value;\n+              print_generic_expr (f, cvalue, 0);\n+              fprintf (f, \"\\n\");\n+\t    }\n+\t  else if (ipcp_method_cval (node, i)->cval_type == TOP)\n+\t    fprintf (f, \"param [%d]: type is TOP  \\n\", i);\n+\t  else\n+\t    fprintf (f, \"param [%d]: type is BOTTOM  \\n\", i);\n+\t}\n+    }\n+}\n+\n+/* Initialize ipcp_cval array of MT with TOP values.\n+   All cvals for a method's formal parameters are initialized to BOTTOM\n+   The currently supported types are integer types, real types and\n+   Fortran constants (i.e. references to constants defined as\n+   const_decls). All other types are not analyzed and therefore are\n+   assigned with BOTTOM.  */\n+static void\n+ipcp_method_cval_init (struct cgraph_node *mt)\n+{\n+  int i;\n+  tree parm_tree;\n+\n+  ipcp_formal_create (mt);\n+  for (i = 0; i < ipa_method_formal_count (mt); i++)\n+    {\n+      parm_tree = ipa_method_get_tree (mt, i);\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (parm_tree)) \n+\t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (parm_tree)) \n+\t  || POINTER_TYPE_P (TREE_TYPE (parm_tree)))\n+\tipcp_method_cval_set_cvalue_type (mt, i, TOP);\n+      else\n+\tipcp_method_cval_set_cvalue_type (mt, i, BOTTOM);\n+    }\n+}\n+\n+/* Create a new assignment statment and make\n+   it the first statemant in the function FN\n+   tree.\n+   PARM1 is the lhs of the assignment and\n+   VAL is the rhs. */\n+static void\n+constant_val_insert (tree fn, tree parm1, tree val)\n+{\n+  struct function *func;\n+  tree init_stmt;\n+  edge e_step;\n+  edge_iterator ei;\n+\n+  init_stmt = build2 (MODIFY_EXPR, void_type_node, parm1, val);\n+  func = DECL_STRUCT_FUNCTION (fn);\n+  cfun = func;\n+  current_function_decl = fn;\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n+    FOR_EACH_EDGE (e_step, ei, ENTRY_BLOCK_PTR_FOR_FUNCTION (func)->succs)\n+      bsi_insert_on_edge_immediate (e_step, init_stmt);\n+}\n+\n+/* build INTEGER_CST tree with type TREE_TYPE and \n+   value according to CVALUE. Return the tree.   */\n+static tree\n+build_const_val (union parameter_info *cvalue, enum cvalue_type type,\n+\t\t tree tree_type)\n+{\n+  tree const_val = NULL;\n+\n+  gcc_assert (ipcp_type_is_const (type));\n+  const_val = fold_convert (tree_type, cvalue->value);\n+  return const_val;\n+}\n+\n+/* Build the tree representing the constant and call \n+   constant_val_insert().  */\n+static void\n+ipcp_propagate_const (struct cgraph_node *mt, int param,\n+\t\t      union parameter_info *cvalue ,enum cvalue_type type)\n+{\n+  tree fndecl;\n+  tree const_val;\n+  tree parm_tree;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (mt));\n+  fndecl = mt->decl;\n+  parm_tree = ipa_method_get_tree (mt, param);\n+  const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n+  constant_val_insert (fndecl, parm_tree, const_val);\n+}\n+\n+/* Compute the proper scale for NODE.  It is the ratio between \n+   the number of direct calls (represented on the incoming \n+   cgraph_edges) and sum of all invocations of NODE (represented \n+   as count in cgraph_node). */\n+static void\n+ipcp_method_compute_scale (struct cgraph_node *node)\n+{\n+  gcov_type sum;\n+  struct cgraph_edge *cs;\n+\n+  sum = 0;\n+  /* Compute sum of all counts of callers. */\n+  for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n+    sum += cs->count;\n+  if (node->count == 0)\n+    ipcp_method_set_scale (node, 0);\n+  else\n+    ipcp_method_set_scale (node, sum * REG_BR_PROB_BASE / node->count);\n+}\n+\n+/* Initialization and computation of IPCP data structures. \n+   It is an intraprocedural\n+   analysis of methods, which gathers information to be propagated\n+   later on.  */\n+static void\n+ipcp_init_stage (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      ipa_method_formal_compute_count (node);\n+      ipa_method_compute_tree_map (node);\n+      ipcp_method_cval_init (node);\n+      ipa_method_compute_modify (node);\n+      ipcp_method_compute_scale (node);\n+    }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      /* building jump functions  */\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  ipa_callsite_compute_count (cs);\n+\t  if (ipa_callsite_param_count (cs)\n+\t      != ipa_method_formal_count (cs->callee))\n+\t    {\n+\t      /* Handle cases of functions with \n+\t         a variable number of parameters.  */\n+\t      ipa_callsite_param_count_set (cs, 0);\n+\t      ipa_method_formal_count_set (cs->callee, 0);\n+\t    }\n+\t  else\n+\t    ipa_callsite_compute_param (cs);\n+\t}\n+    }\n+}\n+\n+/* Return true if there are some formal parameters whose value is TOP.\n+   Change their values to BOTTOM, since they weren't determined.  */\n+static bool\n+ipcp_after_propagate (void)\n+{\n+  int i, count;\n+  struct cgraph_node *node;\n+  bool prop_again;\n+\n+  prop_again = false;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      count = ipa_method_formal_count (node);\n+      for (i = 0; i < count; i++)\n+\tif (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) == TOP)\n+\t  {\n+\t    prop_again = true;\n+\t    ipcp_method_cval_set_cvalue_type (node, i, BOTTOM);\n+\t  }\n+    }\n+  return prop_again;\n+}\n+\n+/* Interprocedural analysis. The algorithm propagates constants from\n+   the caller's parameters to the callee's arguments.  */\n+static void\n+ipcp_propagate_stage (void)\n+{\n+  int i;\n+  struct ipcp_formal cval1 = { 0, {0} }, cval = { 0,{0} };\n+  struct ipcp_formal *cval2;\n+  struct cgraph_node *mt, *callee;\n+  struct cgraph_edge *cs;\n+  struct ipa_jump_func *jump_func;\n+  enum jump_func_type type;\n+  union parameter_info *info_type;\n+  ipa_methodlist_p wl;\n+  int count;\n+\n+  /* Initialize worklist to contain all methods.  */\n+  wl = ipa_methodlist_init ();\n+  while (ipa_methodlist_not_empty (wl))\n+    {\n+      mt = ipa_remove_method (&wl);\n+      for (cs = mt->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  callee = ipa_callsite_callee (cs);\n+\t  count = ipa_callsite_param_count (cs);\n+\t  for (i = 0; i < count; i++)\n+\t    {\n+\t      jump_func = ipa_callsite_param (cs, i);\n+\t      type = get_type (jump_func);\n+\t      info_type = ipa_jf_get_info_type (jump_func);\n+\t      ipcp_cval_compute (&cval1, mt, type, info_type);\n+\t      cval2 = ipcp_method_cval (callee, i);\n+\t      ipcp_cval_meet (&cval, &cval1, cval2);\n+\t      if (ipcp_cval_changed (&cval, cval2))\n+\t\t{\n+\t\t  ipcp_method_cval_set (callee, i, &cval);\n+\t\t  ipa_add_method (&wl, callee);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Call the constant propagation algorithm and re-call it if necessary\n+   (if there are undetermined values left).  */\n+static void\n+ipcp_iterate_stage (void)\n+{\n+  ipcp_propagate_stage ();\n+  if (ipcp_after_propagate ())\n+    /* Some cvals have changed from TOP to BOTTOM.  \n+       This change should be propagated.  */\n+    ipcp_propagate_stage ();\n+}\n+\n+/* Check conditions to forbid constant insertion to MT.  */\n+static bool\n+ipcp_method_dont_insert_const (struct cgraph_node *mt)\n+{\n+  /* ??? Handle pending sizes case.  */\n+  if (DECL_UNINLINABLE (mt->decl))\n+    return true;\n+  return false;\n+}\n+\n+/* Print ipa_jump_func data structures to F.  */\n+static void\n+ipcp_callsite_param_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+  int i, count;\n+  struct cgraph_edge *cs;\n+  struct ipa_jump_func *jump_func;\n+  enum jump_func_type type;\n+  tree info_type;\n+ \n+  fprintf (f, \"\\nCALLSITE PARAM PRINT\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  fprintf (f, \"callsite  %s \", cgraph_node_name (node));\n+\t  fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n+\t  count = ipa_callsite_param_count (cs);\n+\t  for (i = 0; i < count; i++)\n+\t    {\n+\t      jump_func = ipa_callsite_param (cs, i);\n+\t      type = get_type (jump_func);\n+\n+\t      fprintf (f, \" param %d: \", i);\n+\t      if (type == UNKNOWN_IPATYPE)\n+\t\tfprintf (f, \"UNKNOWN\\n\");\n+\t      else if (type == CONST_IPATYPE || type == CONST_IPATYPE_REF)\n+\t\t{\n+\t\t  info_type =\n+\t\t    ipa_jf_get_info_type (jump_func)->value;\n+                  fprintf (f, \"CONST : \");\n+                  print_generic_expr (f, info_type, 0);\n+                  fprintf (f, \"\\n\");\n+\t\t}\n+\t      else if (type == FORMAL_IPATYPE)\n+\t\t{\n+\t\t  fprintf (f, \"FORMAL : \");\n+\t\t  fprintf (f, \"%d\\n\",\n+\t\t\t   ipa_jf_get_info_type (jump_func)->formal_id);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Print count scale data structures.  */\n+static void\n+ipcp_method_scale_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"printing scale for %s: \", cgraph_node_name (node));\n+      fprintf (f, \"value is  \" HOST_WIDE_INT_PRINT_DEC\n+\t       \"  \\n\", (HOST_WIDE_INT) ipcp_method_get_scale (node));\n+    }\n+}\n+\n+/* Print counts of all cgraph nodes.  */\n+static void\n+ipcp_profile_mt_count_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"method %s: \", cgraph_node_name (node));\n+      fprintf (f, \"count is  \" HOST_WIDE_INT_PRINT_DEC\n+\t       \"  \\n\", (HOST_WIDE_INT) node->count);\n+    }\n+}\n+\n+/* Print counts of all cgraph edgess.  */\n+static void\n+ipcp_profile_cs_count_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  fprintf (f, \"%s -> %s \", cgraph_node_name (cs->caller),\n+\t\t   cgraph_node_name (cs->callee));\n+\t  fprintf (f, \"count is  \" HOST_WIDE_INT_PRINT_DEC \"  \\n\",\n+\t\t   (HOST_WIDE_INT) cs->count);\n+\t}\n+    }\n+}\n+\n+/* Print all counts and probabilities of cfg edges of all methods.  */\n+static void\n+ipcp_profile_edge_print (FILE * f)\n+{\n+  struct cgraph_node *node;\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"method %s: \\n\", cgraph_node_name (node));\n+      if (DECL_SAVED_TREE (node->decl))\n+\t{\n+\t  bb =\n+\t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n+\t  fprintf (f, \"ENTRY: \");\n+\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t   \" %d\\n\", (HOST_WIDE_INT) bb->count, bb->frequency);\n+\n+\t  if (bb->succs)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (e->dest ==\n+\t\t  EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION\n+\t\t\t\t\t       (node->decl)))\n+\t\tfprintf (f, \"edge ENTRY -> EXIT,  Count\");\n+\t      else\n+\t\tfprintf (f, \"edge ENTRY -> %d,  Count\", e->dest->index);\n+\t      fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t       \" Prob %d\\n\", (HOST_WIDE_INT) e->count,\n+\t\t       e->probability);\n+\t    }\n+\t  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+\t  {\n+\t    fprintf (f, \"bb[%d]: \", bb->index);\n+\t    fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t     \" %d\\n\", (HOST_WIDE_INT) bb->count, bb->frequency);\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (e->dest ==\n+\t\t  EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION\n+\t\t\t\t\t       (node->decl)))\n+\t\tfprintf (f, \"edge %d -> EXIT,  Count\", e->src->index);\n+\t      else\n+\t\tfprintf (f, \"edge %d -> %d,  Count\", e->src->index,\n+\t\t\t e->dest->index);\n+\t      fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC \" Prob %d\\n\",\n+\t\t       (HOST_WIDE_INT) e->count, e->probability);\n+\t    }\n+\t  }\n+\t}\n+    }\n+}\n+\n+/* Print counts and frequencies for all basic blocks of all methods.  */\n+static void\n+ipcp_profile_bb_print (FILE * f)\n+{\n+  basic_block bb;\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"method %s: \\n\", cgraph_node_name (node));\n+      if (DECL_SAVED_TREE (node->decl))\n+\t{\n+\t  bb =\n+\t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n+\t  fprintf (f, \"ENTRY: Count\");\n+\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t   \" Frquency  %d\\n\", (HOST_WIDE_INT) bb->count,\n+\t\t   bb->frequency);\n+\n+\t  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+\t  {\n+\t    fprintf (f, \"bb[%d]: Count\", bb->index);\n+\t    fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t     \" Frequency %d\\n\", (HOST_WIDE_INT) bb->count,\n+\t\t     bb->frequency);\n+\t  }\n+\t  bb =\n+\t    EXIT_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n+\t  fprintf (f, \"EXIT: Count\");\n+\t  fprintf (f, \" \" HOST_WIDE_INT_PRINT_DEC\n+\t\t   \" Frequency %d\\n\", (HOST_WIDE_INT) bb->count,\n+\t\t   bb->frequency);\n+\n+\t}\n+    }\n+}\n+\n+/* Print all IPCP data structures to F.  */\n+static void\n+ipcp_structures_print (FILE * f)\n+{\n+  ipcp_method_cval_print (f);\n+  ipcp_method_scale_print (f);\n+  ipa_method_tree_print (f);\n+  ipa_method_modify_print (f);\n+  ipcp_callsite_param_print (f);\n+}\n+\n+/* Print profile info for all methods.  */\n+static void\n+ipcp_profile_print (FILE * f)\n+{\n+  fprintf (f, \"\\nNODE COUNTS :\\n\");\n+  ipcp_profile_mt_count_print (f);\n+  fprintf (f, \"\\nCS COUNTS stage:\\n\");\n+  ipcp_profile_cs_count_print (f);\n+  fprintf (f, \"\\nBB COUNTS and FREQUENCIES :\\n\");\n+  ipcp_profile_bb_print (f);\n+  fprintf (f, \"\\nCFG EDGES COUNTS and PROBABILITIES :\\n\");\n+  ipcp_profile_edge_print (f);\n+}\n+\n+/* Build and initialize ipa_replace_map struct\n+   according to TYPE. This struct is read by versioning, which\n+   operates according to the flags sent.  PARM_TREE is the \n+   formal's tree found to be constant.  CVALUE represents the constant.  */\n+static struct ipa_replace_map *\n+ipcp_replace_map_create (enum cvalue_type type, tree parm_tree,\n+\t\t\t union parameter_info *cvalue)\n+{\n+  struct ipa_replace_map *replace_map;\n+  tree const_val;\n+\n+  replace_map = xcalloc (1, sizeof (struct ipa_replace_map));\n+  gcc_assert (ipcp_type_is_const (type));\n+  if (type == CONST_VALUE_REF )\n+    {\n+      const_val =\n+\tbuild_const_val (cvalue, type, TREE_TYPE (TREE_TYPE (parm_tree)));\n+      replace_map->old_tree = parm_tree;\n+      replace_map->new_tree = const_val;\n+      replace_map->replace_p = true;\n+      replace_map->ref_p = true;\n+    }\n+  else if (TREE_READONLY (parm_tree) && !TREE_ADDRESSABLE (parm_tree))\n+    {\n+      const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n+      replace_map->old_tree = parm_tree;\n+      replace_map->new_tree = const_val;\n+      replace_map->replace_p = true;\n+      replace_map->ref_p = false;\n+    }\n+  else\n+    {\n+      replace_map->old_tree = NULL;\n+      replace_map->new_tree = NULL;\n+      replace_map->replace_p = false;\n+      replace_map->ref_p = false;\n+    }\n+\n+  return replace_map;\n+}\n+\n+/* Return true if this callsite should be redirected to\n+   the orig callee (instead of the cloned one).  */\n+static bool\n+ipcp_redirect (struct cgraph_edge *cs)\n+{\n+  struct cgraph_node *caller, *callee, *orig_callee;\n+  int i, count;\n+  struct ipa_jump_func *jump_func;\n+  enum jump_func_type type;\n+  enum cvalue_type cval_type;\n+\n+  caller = cs->caller;\n+  callee = cs->callee;\n+  orig_callee = ipcp_method_orig_node (callee);\n+  count = ipa_method_formal_count (orig_callee);\n+  for (i = 0; i < count; i++)\n+    {\n+      cval_type =\n+\tipcp_cval_get_cvalue_type (ipcp_method_cval (orig_callee, i));\n+      if (ipcp_type_is_const (cval_type))\n+\t{\n+\t  jump_func = ipa_callsite_param (cs, i);\n+\t  type = get_type (jump_func);\n+\t  if (type != CONST_IPATYPE \n+\t      && type != CONST_IPATYPE_REF)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Fix the callsites and the callgraph after function cloning was done.  */\n+static void\n+ipcp_update_callgraph (void)\n+{\n+  struct cgraph_node *node, *orig_callee;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      /* want to fix only original nodes  */\n+      if (ipcp_method_is_cloned (node))\n+\tcontinue;\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\tif (ipcp_method_is_cloned (cs->callee))\n+\t  {\n+\t    /* Callee is a cloned node  */\n+\t    orig_callee = ipcp_method_orig_node (cs->callee);\n+\t    if (ipcp_redirect (cs))\n+\t      {\n+\t\tcgraph_redirect_edge_callee (cs, orig_callee);\n+\t\tTREE_OPERAND (TREE_OPERAND\n+\t\t\t      (get_call_expr_in (cs->call_stmt), 0), 0) =\n+\t\t  orig_callee->decl;\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Update all cfg basic blocks in NODE according to SCALE.  */\n+static void\n+ipcp_update_bb_counts (struct cgraph_node *node, gcov_type scale)\n+{\n+  basic_block bb;\n+\n+  FOR_ALL_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+    bb->count = bb->count * scale / REG_BR_PROB_BASE;\n+}\n+\n+/* Update all cfg edges in NODE according to SCALE.  */\n+static void\n+ipcp_update_edges_counts (struct cgraph_node *node, gcov_type scale)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_ALL_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->count = e->count * scale / REG_BR_PROB_BASE;\n+}\n+\n+/* Update profiling info for versioned methods and the\n+   methods they were versioned from.  */\n+static void\n+ipcp_update_profiling (void)\n+{\n+  struct cgraph_node *node, *orig_node;\n+  gcov_type scale, scale_complement;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (ipcp_method_is_cloned (node))\n+\t{\n+\t  orig_node = ipcp_method_orig_node (node);\n+\t  scale = ipcp_method_get_scale (orig_node);\n+\t  node->count = orig_node->count * scale / REG_BR_PROB_BASE;\n+\t  scale_complement = REG_BR_PROB_BASE - scale;\n+\t  orig_node->count =\n+\t    orig_node->count * scale_complement / REG_BR_PROB_BASE;\n+\t  for (cs = node->callees; cs; cs = cs->next_callee)\n+\t    cs->count = cs->count * scale / REG_BR_PROB_BASE;\n+\t  for (cs = orig_node->callees; cs; cs = cs->next_callee)\n+\t    cs->count = cs->count * scale_complement / REG_BR_PROB_BASE;\n+\t  ipcp_update_bb_counts (node, scale);\n+\t  ipcp_update_bb_counts (orig_node, scale_complement);\n+\t  ipcp_update_edges_counts (node, scale);\n+\t  ipcp_update_edges_counts (orig_node, scale_complement);\n+\t}\n+    }\n+}\n+\n+/* Propagate the constant parameters found by ipcp_iterate_stage()\n+   to the function's code.  */\n+static void\n+ipcp_insert_stage (void)\n+{\n+  struct cgraph_node *node, *node1 = NULL;\n+  int i, const_param;\n+  union parameter_info *cvalue;\n+  varray_type redirect_callers, replace_trees;\n+  struct cgraph_edge *cs;\n+  int node_callers, count;\n+  tree parm_tree;\n+  enum cvalue_type type;\n+  struct ipa_replace_map *replace_param;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      /* Propagation of the constant is forbidden in \n+         certain conditions.  */\n+      if (ipcp_method_dont_insert_const (node))\n+\tcontinue;\n+      const_param = 0;\n+      count = ipa_method_formal_count (node);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n+\t  if (ipcp_type_is_const (type))\n+\t    const_param++;\n+\t}\n+      if (const_param == 0)\n+\tcontinue;\n+      VARRAY_GENERIC_PTR_INIT (replace_trees, const_param, \"replace_trees\");\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n+\t  if (ipcp_type_is_const (type))\n+\t    {\n+\t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n+\t      parm_tree = ipa_method_get_tree (node, i);\n+\t      replace_param =\n+\t\tipcp_replace_map_create (type, parm_tree, cvalue);\n+\t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n+\t    }\n+\t}\n+      /* Compute how many callers node has.  */\n+      node_callers = 0;\n+      for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n+\tnode_callers++;\n+      VARRAY_GENERIC_PTR_INIT (redirect_callers, node_callers,\n+\t\t\t       \"redirect_callers\");\n+      for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n+\tVARRAY_PUSH_GENERIC_PTR (redirect_callers, cs);\n+      /* Redirecting all the callers of the node to the\n+         new versioned node.  */\n+      node1 =\n+\tcgraph_function_versioning (node, redirect_callers, replace_trees);\n+      VARRAY_CLEAR (redirect_callers);\n+      VARRAY_CLEAR (replace_trees);\n+      if (node1 == NULL)\n+\tcontinue;\n+      if (dump_file)\n+\tfprintf (dump_file, \"versioned function %s\\n\",\n+\t\t cgraph_node_name (node));\n+      ipcp_cloned_create (node, node1);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n+\t  if (ipcp_type_is_const (type))\n+\t    {\n+\t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n+\t      parm_tree = ipa_method_get_tree (node, i);\n+\t      if (type != CONST_VALUE_REF \n+\t\t  && !TREE_READONLY (parm_tree))\n+\t\tipcp_propagate_const (node1, i, cvalue, type);\n+\t    }\n+\t}\n+    }\n+  ipcp_update_callgraph ();\n+  ipcp_update_profiling ();\n+}\n+\n+/* The IPCP driver.  */\n+void\n+ipcp_driver (void)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n+  ipa_nodes_create ();\n+  ipa_edges_create ();\n+  /* 1. Call the init stage to initialize \n+     the ipa_node and ipa_edge structures.  */\n+  ipcp_init_stage ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n+      ipcp_structures_print (dump_file);\n+    }\n+  /* 2. Do the interprocedural propagation.  */\n+  ipcp_iterate_stage ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nIPA structures after propagation:\\n\");\n+      ipcp_structures_print (dump_file);\n+      fprintf (dump_file, \"\\nProfiling info before insert stage:\\n\");\n+      ipcp_profile_print (dump_file);\n+    }\n+  /* 3. Insert the constants found to the functions.  */\n+  ipcp_insert_stage ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nProfiling info after insert stage:\\n\");\n+      ipcp_profile_print (dump_file);\n+    }\n+  /* Free all IPCP structures.  */\n+  ipa_free ();\n+  ipa_nodes_free ();\n+  ipa_edges_free ();\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nIPA constant propagation end\\n\");\n+  cgraph_remove_unreachable_nodes (true, NULL);\n+}\n+\n+/* Gate for IPCP optimization.  */\n+static bool\n+cgraph_gate_cp (void)\n+{\n+  return flag_ipa_cp;\n+}\n+\n+struct tree_opt_pass pass_ipa_cp = {\n+  \"cp\",\t\t\t\t/* name */\n+  cgraph_gate_cp,\t\t/* gate */\n+  ipcp_driver,\t\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_IPA_CONSTANT_PROP,\t\t/* tv_id */\n+  0,\t\t\t\t/* properties_required */\n+  PROP_trees,\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n+};"}, {"sha": "cdbf94be8aba6ad9ff8d065559b091619222a844", "filename": "gcc/ipa-prop.c", "status": "added", "additions": 676, "deletions": 0, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=518dc85936a6b0706be276e004c0d556bca3ef83", "patch": "@@ -0,0 +1,676 @@\n+/* Interprocedural analyses.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"ipa-prop.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"timevar.h\"\n+\n+/* This file contains interfaces that can be used for various IPA \n+   optimizations:\n+\n+   - ipa_methodlist interface - It is used to create and handle a temporary \n+   worklist used in  the propagation stage of IPCP. (can be used for more \n+   IPA optimizations).  \n+\n+   - ipa_callsite interface - for each callsite this interface creates and \n+   handles ipa_edge structure associated with it.\n+\n+   - ipa_method interface - for each method this interface creates and \n+   handles ipa_node structure associated with it.  */\n+\n+/* ipa_methodlist interface.  */\n+\n+/* Create a new worklist node.  */\n+static inline ipa_methodlist_p\n+ipa_create_methodlist_node (void)\n+{\n+  return (ipa_methodlist_p) xcalloc (1, sizeof (struct ipa_methodlist));\n+}\n+\n+/* Return true if worklist WL is empty.  */\n+bool\n+ipa_methodlist_not_empty (ipa_methodlist_p wl)\n+{\n+  return (wl != NULL);\n+}\n+\n+/* Return the method in worklist element WL.  */\n+static inline struct cgraph_node *\n+ipa_methodlist_method (ipa_methodlist_p wl)\n+{\n+  return wl->method_p;\n+}\n+\n+/* Make worklist element WL point to method MT in the callgraph.  */\n+static inline void\n+ipa_methodlist_method_set (ipa_methodlist_p wl, struct cgraph_node *mt)\n+{\n+  wl->method_p = mt;\n+}\n+\n+/* Return the next element in the worklist following worklist \n+   element WL.  */\n+static inline ipa_methodlist_p\n+ipa_methodlist_next_method (ipa_methodlist_p wl)\n+{\n+  return wl->next_method;\n+}\n+\n+/* Set worklist element WL1 to point to worklist element WL2.  */\n+static inline void\n+ipa_methodlist_next_method_set (ipa_methodlist_p wl1, ipa_methodlist_p wl2)\n+{\n+  wl1->next_method = wl2;\n+}\n+\n+/* Initialize worklist to contain all methods.  */\n+ipa_methodlist_p\n+ipa_methodlist_init (void)\n+{\n+  struct cgraph_node *node;\n+  ipa_methodlist_p wl;\n+\n+  wl = NULL;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    ipa_add_method (&wl, node);\n+\n+  return wl;\n+}\n+\n+/* Add method MT to the worklist. Set worklist element WL  \n+   to point to MT.  */\n+void\n+ipa_add_method (ipa_methodlist_p * wl, struct cgraph_node *mt)\n+{\n+  ipa_methodlist_p temp;\n+\n+  temp = ipa_create_methodlist_node ();\n+  ipa_methodlist_method_set (temp, mt);\n+  ipa_methodlist_next_method_set (temp, *wl);\n+  *wl = temp;\n+}\n+\n+/* Remove a method from the worklist. WL points to the first \n+   element in the list, which is removed.  */\n+struct cgraph_node *\n+ipa_remove_method (ipa_methodlist_p * wl)\n+{\n+  ipa_methodlist_p first;\n+  struct cgraph_node *return_method;\n+\n+  first = *wl;\n+  *wl = ipa_methodlist_next_method (*wl);\n+  return_method = ipa_methodlist_method (first);\n+  free (first);\n+  return return_method;\n+}\n+\n+/* ipa_method interface.  */\n+\n+/* Return number of formals of method MT.  */\n+int\n+ipa_method_formal_count (struct cgraph_node *mt)\n+{\n+  return IPA_NODE_REF (mt)->ipa_arg_num;\n+}\n+\n+/* Set number of formals of method MT to I.  */\n+void\n+ipa_method_formal_count_set (struct cgraph_node *mt, int i)\n+{\n+  IPA_NODE_REF (mt)->ipa_arg_num = i;\n+}\n+\n+/* Return whether I-th formal of MT is modified in MT.  */\n+static inline bool\n+ipa_method_is_modified (struct cgraph_node *mt, int i)\n+{\n+  return IPA_NODE_REF (mt)->ipa_mod[i];\n+}\n+\n+/* Return the tree of I-th formal of MT.  */\n+tree\n+ipa_method_get_tree (struct cgraph_node *mt, int i)\n+{\n+  return IPA_NODE_REF (mt)->ipa_param_tree[i];\n+}\n+\n+/* Create tree map structure for MT.  */\n+static inline void\n+ipa_method_tree_map_create (struct cgraph_node *mt)\n+{\n+  IPA_NODE_REF (mt)->ipa_param_tree =\n+    xcalloc (ipa_method_formal_count (mt), sizeof (tree));\n+}\n+\n+/* Create modify structure for MT.  */\n+static inline void\n+ipa_method_modify_create (struct cgraph_node *mt)\n+{\n+  ((struct ipa_node *) mt->aux)->ipa_mod =\n+    xcalloc (ipa_method_formal_count (mt), sizeof (bool));\n+}\n+\n+/* Set modify of I-th formal of MT to VAL.  */\n+static inline void\n+ipa_method_modify_set (struct cgraph_node *mt, int i, bool val)\n+{\n+  IPA_NODE_REF (mt)->ipa_mod[i] = val;\n+}\n+\n+/* Return index of the formal whose tree is PTREE in method MT.  */\n+static int\n+ipa_method_tree_map (struct cgraph_node *mt, tree ptree)\n+{\n+  int i, count;\n+\n+  count = ipa_method_formal_count (mt);\n+  for (i = 0; i < count; i++)\n+    if (IPA_NODE_REF (mt)->ipa_param_tree[i] == ptree)\n+      return i;\n+\n+  return -1;\n+}\n+\n+/* Insert the formal trees to the ipa_param_tree array in method MT.  */\n+void\n+ipa_method_compute_tree_map (struct cgraph_node *mt)\n+{\n+  tree fndecl;\n+  tree fnargs;\n+  tree parm;\n+  int param_num;\n+\n+  ipa_method_tree_map_create (mt);\n+  fndecl = mt->decl;\n+  fnargs = DECL_ARGUMENTS (fndecl);\n+  param_num = 0;\n+  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n+    {\n+      IPA_NODE_REF (mt)->ipa_param_tree[param_num] = parm;\n+      param_num++;\n+    }\n+}\n+\n+/* Count number of formals in MT. Insert the result to the \n+   ipa_node.  */\n+void\n+ipa_method_formal_compute_count (struct cgraph_node *mt)\n+{\n+  tree fndecl;\n+  tree fnargs;\n+  tree parm;\n+  int param_num;\n+\n+  fndecl = mt->decl;\n+  fnargs = DECL_ARGUMENTS (fndecl);\n+  param_num = 0;\n+  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n+    param_num++;\n+  ipa_method_formal_count_set (mt, param_num);\n+}\n+\n+/* Check STMT to detect whether a formal is modified within MT,\n+   the appropriate entry is updated in the ipa_mod array of ipa_node\n+   (associated with MT).  */\n+static void\n+ipa_method_modify_stmt (struct cgraph_node *mt, tree stmt)\n+{\n+  int i, j;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case MODIFY_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == PARM_DECL)\n+\t{\n+\t  i = ipa_method_tree_map (mt, TREE_OPERAND (stmt, 0));\n+\t  if (i >= 0)\n+            ipa_method_modify_set (mt, i, true);\n+\t}\n+      break;\n+    case ASM_EXPR:\n+      /* Asm code could modify any of the parameters.  */\n+      for (j = 0; j < ipa_method_formal_count (mt); j++)\n+\tipa_method_modify_set (mt, j, true);\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Initialize ipa_mod array of MT.  */\n+static void\n+ipa_method_modify_init (struct cgraph_node *mt)\n+{\n+  int i, count;\n+\n+  ipa_method_modify_create (mt);\n+  count = ipa_method_formal_count (mt);\n+  for (i = 0; i < count; i++)\n+    ipa_method_modify_set (mt, i, false);\n+}\n+\n+/* The modify computation driver for MT. Compute which formal arguments \n+   of method MT are locally modified.  Formals may be modified in MT \n+   if their address is taken, or if\n+   they appear on the left hand side of an assignment.  */\n+void\n+ipa_method_compute_modify (struct cgraph_node *mt)\n+{\n+  tree decl;\n+  tree body;\n+  int j, count;\n+  basic_block bb;\n+  struct function *func;\n+  block_stmt_iterator bsi;\n+  tree stmt, parm_tree;\n+\n+  ipa_method_modify_init (mt);\n+  decl = mt->decl;\n+  count = ipa_method_formal_count (mt);\n+  /* ??? Handle pending sizes case. Set all parameters \n+     of the method to be modified.  */\n+  if (DECL_UNINLINABLE (decl))\n+    {\n+      for (j = 0; j < count; j++)\n+\tipa_method_modify_set (mt, j, true);\n+      return;\n+    }\n+  /* Formals whose address is taken are considered modified.  */\n+  for (j = 0; j < count; j++)\n+    {\n+      parm_tree = ipa_method_get_tree (mt, j);\n+      if (TREE_ADDRESSABLE (parm_tree))\n+\tipa_method_modify_set (mt, j, true);\n+    }\n+  body = DECL_SAVED_TREE (decl);\n+  if (body != NULL)\n+    {\n+      func = DECL_STRUCT_FUNCTION (decl);\n+      FOR_EACH_BB_FN (bb, func)\n+      {\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  {\n+\t    stmt = bsi_stmt (bsi);\n+\t    ipa_method_modify_stmt (mt, stmt);\n+\t  }\n+      }\n+    }\n+}\n+\n+\n+/* ipa_callsite interface.  */\n+\n+/* Return number of arguments in callsite CS.  */\n+int\n+ipa_callsite_param_count (struct cgraph_edge *cs)\n+{\n+  return IPA_EDGE_REF (cs)->ipa_param_num;\n+}\n+\n+/* Set number of arguments in callsite CS to I.  */\n+void\n+ipa_callsite_param_count_set (struct cgraph_edge *cs, int i)\n+{\n+  IPA_EDGE_REF (cs)->ipa_param_num = i;\n+}\n+\n+/* Return the jump function (ipa_jump_func struct) for argument I of \n+   callsite CS.  */\n+struct ipa_jump_func *\n+ipa_callsite_param (struct cgraph_edge *cs, int i)\n+{\n+  return &(IPA_EDGE_REF (cs)->ipa_param_map[i]);\n+}\n+\n+/* return the callee (cgraph_node) of callsite CS.  */\n+struct cgraph_node *\n+ipa_callsite_callee (struct cgraph_edge *cs)\n+{\n+  return cs->callee;\n+}\n+\n+/* Set field 'type' of jump function (ipa_jump_func struct) of argument I \n+   in callsite CS.  */\n+static inline void\n+ipa_callsite_param_set_type (struct cgraph_edge *cs, int i,\n+\t\t\t     enum jump_func_type type1)\n+{\n+  IPA_EDGE_REF (cs)->ipa_param_map[i].type = type1;\n+}\n+\n+/* Set FORMAL as 'info_type' field of jump function (ipa_jump_func struct)\n+   of argument I of callsite CS.  */\n+static inline void\n+ipa_callsite_param_set_info_type_formal (struct cgraph_edge *cs, int i,\n+\t\t\t\t\t unsigned int formal)\n+{\n+  ipa_callsite_param (cs, i)->info_type.formal_id = formal;\n+}\n+\n+/* Set int-valued INFO_TYPE1 as 'info_type' field of \n+   jump function (ipa_jump_func struct) of argument I of callsite CS.  */\n+static inline void\n+ipa_callsite_param_set_info_type (struct cgraph_edge *cs, int i, tree info_type1)\n+{\n+  ipa_callsite_param (cs, i)->info_type.value = info_type1;\n+}\n+\n+/* Allocate space for callsite CS.  */\n+static inline void\n+ipa_callsite_param_map_create (struct cgraph_edge *cs)\n+{\n+  IPA_EDGE_REF (cs)->ipa_param_map =\n+    xcalloc (ipa_callsite_param_count (cs), sizeof (struct ipa_jump_func));\n+}\n+\n+/* Return the call expr tree related to callsite CS.  */\n+static inline tree\n+ipa_callsite_tree (struct cgraph_edge *cs)\n+{\n+  return cs->call_stmt;\n+}\n+\n+/* Return the caller (cgraph_node) of CS.  */\n+static inline struct cgraph_node *\n+ipa_callsite_caller (struct cgraph_edge *cs)\n+{\n+  return cs->caller;\n+}\n+\n+/* Count number of arguments callsite CS has and store it in \n+   ipa_edge structure corresponding to this callsite.  */\n+void\n+ipa_callsite_compute_count (struct cgraph_edge *cs)\n+{\n+  tree call_tree;\n+  tree arg;\n+  int arg_num;\n+\n+  call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n+  gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n+  arg = TREE_OPERAND (call_tree, 1);\n+  arg_num = 0;\n+  for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+    arg_num++;\n+  ipa_callsite_param_count_set (cs, arg_num);\n+}\n+\n+/* Compute jump function for all arguments of callsite CS \n+   and insert the information in the ipa_param_map array \n+   in the ipa_edge corresponding to this callsite. (Explanation \n+   on jump functions is in ipa-prop.h).  */\n+void\n+ipa_callsite_compute_param (struct cgraph_edge *cs)\n+{\n+  tree call_tree;\n+  tree arg, cst_decl, arg_type, formal_type;\n+  int arg_num;\n+  int i;\n+  struct cgraph_node *mt;\n+\n+  if (ipa_callsite_param_count (cs) == 0)\n+    return;\n+  ipa_callsite_param_map_create (cs);\n+  call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n+  gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n+  arg = TREE_OPERAND (call_tree, 1);\n+  arg_num = 0;\n+\n+  for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+    {\n+      /* If the formal parameter was passed as argument, we store \n+         FORMAL_IPATYPE and its index in the caller as the jump function \n+         of this argument.  */\n+      if (TREE_CODE (TREE_VALUE (arg)) == PARM_DECL)\n+\t{\n+\t  mt = ipa_callsite_caller (cs);\n+\t  i = ipa_method_tree_map (mt, TREE_VALUE (arg));\n+\t  if (i < 0 || ipa_method_is_modified (mt, i))\n+\t    ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\t  else\n+\t    {\n+\t\targ_type = TREE_TYPE (TREE_VALUE (arg));\n+\t  \tformal_type = TREE_TYPE (ipa_method_get_tree (cs->callee, arg_num));\n+\t  \tif (TYPE_NAME (arg_type) == TYPE_NAME (formal_type)\n+\t\t    && TYPE_CONTEXT (arg_type) == TYPE_CONTEXT (formal_type)\n+\t\t    && attribute_list_equal (TYPE_ATTRIBUTES (arg_type),\n+\t\t\t\t\t     TYPE_ATTRIBUTES (formal_type)))\n+\t\t  {\n+\t\t    ipa_callsite_param_set_type (cs, arg_num, FORMAL_IPATYPE);\n+\t\t    ipa_callsite_param_set_info_type_formal (cs, arg_num, i);\n+\t\t  }\n+\t \telse\n+\t\t  ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\t    }\n+\t}\n+      /* If a constant value was passed as argument, \n+         we store CONST_IPATYPE and its value as the jump function \n+         of this argument.  */\n+      else if (TREE_CODE (TREE_VALUE (arg)) == INTEGER_CST\n+\t       || TREE_CODE (TREE_VALUE (arg)) == REAL_CST)\n+\t{\n+\t  arg_type = TREE_TYPE (TREE_VALUE (arg));\n+\t  formal_type = TREE_TYPE (ipa_method_get_tree (cs->callee, arg_num));\n+\t  if (TYPE_NAME (arg_type) == TYPE_NAME (formal_type)\n+\t      && TYPE_CONTEXT (arg_type) == TYPE_CONTEXT (formal_type)\n+\t      && attribute_list_equal (TYPE_ATTRIBUTES (arg_type),\n+\t\t\t\t       TYPE_ATTRIBUTES (formal_type)))\n+\t    {\n+\t      ipa_callsite_param_set_type (cs, arg_num, CONST_IPATYPE);\n+\t      ipa_callsite_param_set_info_type (cs, arg_num, TREE_VALUE (arg));\n+\t    }\n+\t  else\n+\t    ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\t}\n+      /* This is for the case of Fortran. If the address of a const_decl \n+         was passed as argument then we store \n+         CONST_IPATYPE_REF/CONST_IPATYPE_REF and the costant \n+         value as the jump function corresponding to this argument.  */\n+      else if (TREE_CODE (TREE_VALUE (arg)) == ADDR_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (TREE_VALUE (arg), 0)) ==\n+\t       CONST_DECL)\n+\t{\n+\t  cst_decl = TREE_OPERAND (TREE_VALUE (arg), 0);\n+\t  arg_type = TREE_TYPE (DECL_INITIAL (cst_decl));\n+\t  formal_type =\n+\t    TREE_TYPE (TREE_TYPE (ipa_method_get_tree (cs->callee, arg_num)));\n+\t  if (TREE_CODE (DECL_INITIAL (cst_decl)) == INTEGER_CST\n+\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST)\n+\t    {\n+\t      if (TYPE_NAME (arg_type) == TYPE_NAME (formal_type)\n+\t\t  && TYPE_CONTEXT (arg_type) == TYPE_CONTEXT (formal_type)\n+\t\t  && attribute_list_equal (TYPE_ATTRIBUTES (arg_type),\n+\t\t\t\t\t   TYPE_ATTRIBUTES (formal_type)))\n+\n+\t\t{\n+\t\t  ipa_callsite_param_set_type (cs, arg_num,\n+\t\t\t\t\t       CONST_IPATYPE_REF);\n+\t\t  ipa_callsite_param_set_info_type (cs, arg_num, DECL_INITIAL (cst_decl));\n+\n+\t\t}\n+\t      else\n+\t\tipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\t    }\n+\t}\n+      else\n+\tipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+      arg_num++;\n+    }\n+}\n+\n+/* Return type of jump function JF.  */\n+enum jump_func_type\n+get_type (struct ipa_jump_func *jf)\n+{\n+  return jf->type;\n+}\n+\n+/* Return info type of jump function JF.  */\n+union parameter_info *\n+ipa_jf_get_info_type (struct ipa_jump_func *jf)\n+{\n+  return &(jf->info_type);\n+}\n+\n+/* Allocate and initialize ipa_node structure.  \n+   cgraph_node NODE points to the new allocated ipa_node.  */\n+void\n+ipa_node_create (struct cgraph_node *node)\n+{\n+  node->aux = xcalloc (1, sizeof (struct ipa_node));\n+}\n+\n+/* Allocate and initialize ipa_node structure for all\n+   nodes in callgraph.  */\n+void\n+ipa_nodes_create (void)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    ipa_node_create (node);\n+}\n+\n+/* Allocate and initialize ipa_edge structure.  */\n+void\n+ipa_edges_create (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    for (cs = node->callees; cs; cs = cs->next_callee)\n+      cs->aux = xcalloc (1, sizeof (struct ipa_edge));\n+}\n+\n+/* Free ipa_node structure.  */\n+void\n+ipa_nodes_free (void)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      free (node->aux);\n+      node->aux = NULL;\n+    }\n+}\n+\n+/* Free ipa_edge structure.  */\n+void\n+ipa_edges_free (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    for (cs = node->callees; cs; cs = cs->next_callee)\n+      {\n+\tfree (cs->aux);\n+\tcs->aux = NULL;\n+      }\n+}\n+\n+/* Free ipa data structures of ipa_node and ipa_edge.  */\n+void\n+ipa_free (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (node->aux == NULL)\n+\tcontinue;\n+      if (IPA_NODE_REF (node)->ipcp_cval)\n+\tfree (IPA_NODE_REF (node)->ipcp_cval);\n+      if (IPA_NODE_REF (node)->ipa_param_tree)\n+\tfree (IPA_NODE_REF (node)->ipa_param_tree);\n+      if (IPA_NODE_REF (node)->ipa_mod)\n+\tfree (IPA_NODE_REF (node)->ipa_mod);\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  if (cs->aux)\n+\t    if (IPA_EDGE_REF (cs)->ipa_param_map)\n+\t      free (IPA_EDGE_REF (cs)->ipa_param_map);\n+\t}\n+    }\n+}\n+\n+/* Print ipa_tree_map data structures of all methods in the \n+   callgraph to F.  */\n+void\n+ipa_method_tree_print (FILE * f)\n+{\n+  int i, count;\n+  tree temp;\n+  struct cgraph_node *node;\n+\n+  fprintf (f, \"\\nPARAM TREE MAP PRINT\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"method  %s Trees :: \\n\", cgraph_node_name (node));\n+      count = ipa_method_formal_count (node);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  temp = ipa_method_get_tree (node, i);\n+\t  if (TREE_CODE (temp) == PARM_DECL)\n+\t    fprintf (f, \"  param [%d] : %s\\n\", i,\n+\t\t     (*lang_hooks.decl_printable_name) (temp, 2));\n+\t}\n+\n+    }\n+}\n+\n+/* Print ipa_modify data structures of all methods in the \n+   callgraph to F.  */\n+void\n+ipa_method_modify_print (FILE * f)\n+{\n+  int i, count;\n+  bool temp;\n+  struct cgraph_node *node;\n+\n+  fprintf (f, \"\\nMODIFY PRINT\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      fprintf (f, \"method  %s :: \\n\", cgraph_node_name (node));\n+      count = ipa_method_formal_count (node);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  temp = ipa_method_is_modified (node, i);\n+\t  if (temp)\n+\t    fprintf (f, \" param [%d] true \\n\", i);\n+\t  else\n+\t    fprintf (f, \" param [%d] false \\n\", i);\n+\t}\n+    }\n+}"}, {"sha": "db9b91691a59859f6392418422beeaf7ff365a5d", "filename": "gcc/ipa-prop.h", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/518dc85936a6b0706be276e004c0d556bca3ef83/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=518dc85936a6b0706be276e004c0d556bca3ef83", "patch": "@@ -0,0 +1,204 @@\n+/* Interprocedural analyses.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef IPA_PROP_H\n+#define IPA_PROP_H\n+\n+#include \"tree.h\"\n+\n+/* The following definitions and interfaces are used by\n+   interprocedural analyses.  */\n+\n+/* A jump function for a callsite represents the values passed as actual \n+   arguments of the callsite. There are three main types of values :\n+   Formal - the caller's formal parameter is passed as an actual argument.\n+   Constant - a constant is passed as a an actual argument.\n+   Unknown - neither of the above.\n+   Integer and real constants are represented as CONST_IPATYPE and Fortran \n+   constants are represented as CONST_IPATYPE_REF.  */\n+enum jump_func_type\n+{\n+  UNKNOWN_IPATYPE,\n+  CONST_IPATYPE,\n+  CONST_IPATYPE_REF,\n+  FORMAL_IPATYPE\n+};\n+\n+/* All formal parameters in the program have a cval computed by \n+   the interprocedural stage of IPCP.  \n+   There are three main values of cval :\n+   TOP - unknown.\n+   BOTTOM - non constant.\n+   CONSTANT_TYPE - constant value.\n+   Cval of formal f will have a constant value if all callsites to this\n+   function have the same constant value passed to f.\n+   Integer and real constants are represented as CONST_IPATYPE and Fortran\n+   constants are represented as CONST_IPATYPE_REF.  */\n+enum cvalue_type\n+{\n+  BOTTOM,\n+  CONST_VALUE,\n+  CONST_VALUE_REF,\n+  TOP\n+};\n+\n+/* Represents the value of either jump function or cval.\n+   value represnts a constant.\n+   formal_id is used only in jump function context and represents \n+   pass-through parameter (the formal of caller is passed \n+   as argument).  */\n+union parameter_info\n+{\n+  unsigned int formal_id;\n+  tree value;\n+};\n+\n+/* A jump function for a callsite represents the values passed as actual \n+   arguments of the callsite. See enum jump_func_type for the various \n+   types of jump functions supported.  */\n+struct ipa_jump_func\n+{\n+  enum jump_func_type type;\n+  union parameter_info info_type;\n+};\n+\n+/* All formal parameters in the program have a cval computed by \n+   the interprocedural stage of IPCP. See enum cvalue_type for \n+   the various types of cvals supported */\n+struct ipcp_formal\n+{\n+  enum cvalue_type cval_type;\n+  union parameter_info cvalue;\n+};\n+\n+/* Represent which DECL tree (or reference to such tree)\n+   will be replaced by another tree while versioning.  */\n+struct ipa_replace_map\n+{\n+  /* The tree that will be replaced.  */\n+  tree old_tree;\n+  /* The new (replacing) tree.  */ \n+  tree new_tree;\n+  /* True when a substitution should be done, false otherwise.  */\n+  bool replace_p;\n+  /* True when we replace a reference to old_tree.  */\n+  bool ref_p;\n+};\n+\n+/* Return the field in cgraph_node/cgraph_edge struct that points\n+   to ipa_node/ipa_edge struct.  */\n+#define IPA_NODE_REF(MT) ((struct ipa_node *)(MT)->aux)\n+#define IPA_EDGE_REF(EDGE) ((struct ipa_edge *)(EDGE)->aux)\n+\n+/* ipa_node stores information related to a method and\n+   its formal parameters. It is pointed to by a field in the\n+   method's corresponding cgraph_node.\n+\n+   ipa_edge stores information related to a callsite and\n+   its arguments. It is pointed to by a field in the\n+   callsite's corresponding cgraph_edge.  */\n+struct ipa_node\n+{\n+  /* Number of formal parameters of this method.  When set to 0,\n+     this method's parameters would not be analyzed by the different\n+     stages of IPA CP.  */\n+  int ipa_arg_num;\n+  /* Array of cvals.  */\n+  struct ipcp_formal *ipcp_cval;\n+  /* Mapping each parameter to its PARM_DECL tree.  */\n+  tree *ipa_param_tree;\n+  /* Indicating which parameter is modified in its method.  */\n+  bool *ipa_mod;\n+  /* Only for versioned nodes this field would not be NULL,\n+     it points to the node that IPA cp cloned from.  */\n+  struct cgraph_node *ipcp_orig_node;\n+  /* Meaningful only for original methods.  Expresses the \n+     ratio between the direct calls and sum of all invocations of \n+     this function (given by profiling info).  It is used to calculate \n+     the profiling information of the original function and the versioned\n+     one.  */\n+  gcov_type count_scale;\n+};\n+\n+struct ipa_edge\n+{\n+  /* Number of actual arguments in this callsite.  When set to 0,\n+     this callsite's parameters would not be analyzed by the different\n+     stages of IPA CP.  */\n+  int ipa_param_num;\n+  /* Array of the callsite's jump function of each parameter.  */\n+  struct ipa_jump_func *ipa_param_map;\n+};\n+\n+/* A methodlist element (referred to also as methodlist node). It is used \n+   to create a temporary worklist used in \n+   the propagation stage of IPCP. (can be used for more IPA \n+   optimizations)  */\n+struct ipa_methodlist\n+{\n+  struct cgraph_node *method_p;\n+  struct ipa_methodlist *next_method;\n+};\n+\n+/* A pointer to a methodlist elemement.  */\n+typedef struct ipa_methodlist *ipa_methodlist_p;\n+\n+/* ipa_methodlist interface.  */\n+ipa_methodlist_p ipa_methodlist_init (void);\n+bool ipa_methodlist_not_empty (ipa_methodlist_p);\n+void ipa_add_method (ipa_methodlist_p *, struct cgraph_node *);\n+struct cgraph_node *ipa_remove_method (ipa_methodlist_p *);\n+\n+/* ipa_callsite interface.  */\n+int ipa_callsite_param_count (struct cgraph_edge *);\n+void ipa_callsite_param_count_set (struct cgraph_edge *, int);\n+struct ipa_jump_func *ipa_callsite_param (struct cgraph_edge *, int);\n+struct cgraph_node *ipa_callsite_callee (struct cgraph_edge *);\n+void ipa_callsite_compute_param (struct cgraph_edge *);\n+void ipa_callsite_compute_count (struct cgraph_edge *);\n+\n+/* ipa_method interface.  */\n+int ipa_method_formal_count (struct cgraph_node *);\n+void ipa_method_formal_count_set (struct cgraph_node *, int);\n+tree ipa_method_get_tree (struct cgraph_node *, int);\n+void ipa_method_compute_tree_map (struct cgraph_node *);\n+void ipa_method_formal_compute_count (struct cgraph_node *);\n+void ipa_method_compute_modify (struct cgraph_node *);\n+\n+/* jump function interface.  */\n+enum jump_func_type get_type (struct ipa_jump_func *);\n+union parameter_info *ipa_jf_get_info_type (struct ipa_jump_func *);\n+\n+/* ipa_node and ipa_edge interfaces.  */\n+void ipa_node_create (struct cgraph_node *);\n+void ipa_free (void);\n+void ipa_nodes_create (void);\n+void ipa_edges_create (void);\n+void ipa_edges_free (void);\n+void ipa_nodes_free (void);\n+\n+\n+/* Debugging interface.  */\n+void ipa_method_tree_print (FILE *);\n+void ipa_method_modify_print (FILE *);\n+\n+void ipcp_driver (void);\n+\n+#endif /* IPA_PROP_H */"}]}