{"sha": "1aa1419556f53e401b1ba132a3dc500947141a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFhMTQxOTU1NmY1M2U0MDFiMWJhMTMyYTNkYzUwMDk0NzE0MWE0NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-11T15:15:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-11T15:15:48Z"}, "message": "re PR tree-optimization/44063 (build broken for libgcc cris-elf, ICE in cgraph_estimate_size_after_inlining, at ipa-inline)\n\n\n\tPR tree-optimize/44063\n\t* ipa-inline.c (cgraph_edge_badness): Move always inlines to top of queue.\n\t(cgraph_decide_inlining_of_small_function): Skip check when disrgarding\n\tlimits.\n\t(estimate_function_body_sizes): Compute sizes even when disregarding.\n\t* gcc.c-torture/compile/pr44063.c: New testcase.\n\nFrom-SVN: r159273", "tree": {"sha": "220e3acd3a6863dda6117e518abafed885f7adac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/220e3acd3a6863dda6117e518abafed885f7adac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1aa1419556f53e401b1ba132a3dc500947141a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa1419556f53e401b1ba132a3dc500947141a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa1419556f53e401b1ba132a3dc500947141a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa1419556f53e401b1ba132a3dc500947141a45/comments", "author": null, "committer": null, "parents": [{"sha": "f088f0aee27fbfbc2dd4c5fb73af24f12910418c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f088f0aee27fbfbc2dd4c5fb73af24f12910418c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f088f0aee27fbfbc2dd4c5fb73af24f12910418c"}], "stats": {"total": 73, "additions": 59, "deletions": 14}, "files": [{"sha": "70e5809d3fefeebc98da329f1cf9e955f6dd355f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1aa1419556f53e401b1ba132a3dc500947141a45", "patch": "@@ -1,3 +1,11 @@\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimize/44063\n+\t* ipa-inline.c (cgraph_edge_badness): Move always inlines to top of queue.\n+\t(cgraph_decide_inlining_of_small_function): Skip check when disrgarding\n+\tlimits.\n+\t(estimate_function_body_sizes): Compute sizes even when disregarding.\n+\n 2010-05-11  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* collect2.c (maybe_lto_object_file): Add x64-coff magic and check."}, {"sha": "6f189a6da2dd89b5e5f1c70df02a280fbd485d20", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1aa1419556f53e401b1ba132a3dc500947141a45", "patch": "@@ -541,6 +541,9 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n     (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n      - edge->caller->global.size);\n \n+  if (edge->callee->local.disregard_inline_limits)\n+    return INT_MIN;\n+\n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculcation for %s -> %s\\n\",\n@@ -1068,12 +1071,14 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t}\n \n-      if (!cgraph_maybe_hot_edge_p (edge))\n+      if (edge->callee->local.disregard_inline_limits)\n+\t;\n+      else if (!cgraph_maybe_hot_edge_p (edge))\n  \tnot_good = CIF_UNLIKELY_CALL;\n-      if (!flag_inline_functions\n+      else if (!flag_inline_functions\n \t  && !DECL_DECLARED_INLINE_P (edge->callee->decl))\n  \tnot_good = CIF_NOT_DECLARED_INLINED;\n-      if (optimize_function_for_size_p (DECL_STRUCT_FUNCTION(edge->caller->decl)))\n+      else if (optimize_function_for_size_p (DECL_STRUCT_FUNCTION(edge->caller->decl)))\n  \tnot_good = CIF_OPTIMIZING_FOR_SIZE;\n       if (not_good && growth > 0 && cgraph_estimate_growth (edge->callee) > 0)\n \t{\n@@ -1833,17 +1838,6 @@ estimate_function_body_sizes (struct cgraph_node *node)\n   int freq;\n   tree funtype = TREE_TYPE (node->decl);\n \n-  if (node->local.disregard_inline_limits)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Disregarding inline limits.\\n\");\n-      inline_summary (node)->self_time = 0;\n-      inline_summary (node)->self_size = 0;\n-      inline_summary (node)->time_inlining_benefit = 0;\n-      inline_summary (node)->size_inlining_benefit = 0;\n-      return;\n-    }\n-\n   if (dump_file)\n     fprintf (dump_file, \"Analyzing function body size: %s\\n\",\n \t     cgraph_node_name (node));"}, {"sha": "c664140fe399b9f54dcff6d45e1f5bcdf2e0e8cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1aa1419556f53e401b1ba132a3dc500947141a45", "patch": "@@ -1,3 +1,8 @@\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimize/44063\n+\t* gcc.c-torture/compile/pr44063.c: New testcase.\n+\n 2010-05-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/44023"}, {"sha": "596e1dc991f09c287e4fffa4971ee18698fd1376", "filename": "gcc/testsuite/gcc.c-torture/compile/pr44063.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr44063.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa1419556f53e401b1ba132a3dc500947141a45/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr44063.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr44063.c?ref=1aa1419556f53e401b1ba132a3dc500947141a45", "patch": "@@ -0,0 +1,38 @@\n+typedef signed char int8_t;\n+typedef short int16_t;\n+typedef unsigned char uint8_t;\n+typedef unsigned int uint32_t;\n+\n+union unaligned_32 {uint32_t l;} __attribute__((packed)) __attribute__((may_alias));\n+static inline uint32_t NEG_USR32(uint32_t a, int8_t s){return a << (32 - s);}\n+typedef struct GetBitContext { const uint8_t *buffer, *buffer_end; int index;}GetBitContext;\n+typedef struct VLC {int16_t (*table)[2];} VLC;\n+static __attribute__((always_inline)) inline int get_vlc2(GetBitContext *s, int16_t (*table)[2], int bits, int max_depth) {\n+    unsigned int re_index= (s)->index;\n+    int re_cache= 0;\n+    {\n+        int n, nb_bits;\n+        unsigned int index;\n+        index= NEG_USR32(re_cache, bits);\n+        n = table[index][1];\n+        if(max_depth > 1 && n < 0){\n+            re_cache= bswap_32((((const union unaligned_32 *) (((const uint8_t *)(s)->buffer)+(re_index>>3)))->l)) << (re_index&0x07);\n+        }\n+    }\n+}\n+typedef struct HYuvContext{GetBitContext gb; int decorrelate; int bitstream_bpp; uint8_t *temp[3]; VLC vlc[6];} HYuvContext;\n+static __attribute__((always_inline)) inline void decode_bgr_1(HYuvContext *s, int count, int decorrelate, int alpha){\n+    int i;\n+        int code = get_vlc2(&s->gb, s->vlc[3].table, 11, 1);\n+        if(code != -1){\n+            s->temp[0][4*i+0] = get_vlc2(&s->gb, s->vlc[0].table, 11, 3);\n+            s->temp[0][4*i+1] = get_vlc2(&s->gb, s->vlc[1].table, 11, 3);\n+            s->temp[0][4*i+2] = get_vlc2(&s->gb, s->vlc[2].table, 11, 3);\n+        }\n+}\n+void decode_bgr_bitstream(HYuvContext *s, int count){\n+    if(s->decorrelate){\n+        if(s->bitstream_bpp==24) decode_bgr_1(s, count, 1, 0);\n+        else             decode_bgr_1(s, count, 1, 1);\n+    }\n+}"}]}