{"sha": "b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE0OGFlYWE0Zjk0YTdjZGJjNzRkNDkzYmViN2U1Y2ZmNDc3OWQ1MQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-08-24T19:00:49Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-08-24T19:00:49Z"}, "message": "dependence.c (dependence_string, [...]): Hide unused identifiers.\n\n\t* dependence.c (dependence_string, direction_string,\n\tdump_one_node, dump_node_dependence): Hide unused identifiers.\n\t(get_low_bound, normalize_coefficients): Match definition to\n\tstatic prototype.\n\t(get_one_coefficient): Initialize variables `value0_is_idx' and\n\t`value1_is_idx'.\n\t(ziv_test, gcd_test): Mark parameters with ATTRIBUTE_UNUSED.\n\t(ziv_test): Delete variable `idx', use parameter `sub' instead.\n\t(direction_merge): Avoid automatic aggregate initialization.\n\t(have_dependence_p): Use `src' not `dest' to set `src_idx'.\n\tInitialize variables `dest_idx' and `src_idx'.\n\t(end_dependence_analysis): Avoid C89 style function definition.\n\nFrom-SVN: r35942", "tree": {"sha": "273686faebed23b37faddf8a1f100bb0ac0d1626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/273686faebed23b37faddf8a1f100bb0ac0d1626"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51/comments", "author": null, "committer": null, "parents": [{"sha": "4d0e4296fdc603d518c041a336af69a135dcc841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0e4296fdc603d518c041a336af69a135dcc841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0e4296fdc603d518c041a336af69a135dcc841"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "e9025fd8d8b5d16487a656fdc6e68ffbf24780e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "patch": "@@ -1,3 +1,18 @@\n+2000-08-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* dependence.c (dependence_string, direction_string,\n+\tdump_one_node, dump_node_dependence): Hide unused identifiers.\n+\t(get_low_bound, normalize_coefficients): Match definition to\n+\tstatic prototype.\n+\t(get_one_coefficient): Initialize variables `value0_is_idx' and\n+\t`value1_is_idx'.\n+\t(ziv_test, gcd_test): Mark parameters with ATTRIBUTE_UNUSED.\n+\t(ziv_test): Delete variable `idx', use parameter `sub' instead.\n+\t(direction_merge): Avoid automatic aggregate initialization.\n+\t(have_dependence_p): Use `src' not `dest' to set `src_idx'.\n+\tInitialize variables `dest_idx' and `src_idx'.\n+\t(end_dependence_analysis): Avoid C89 style function definition.\n+\n 2000-08-24  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.c (time_char_table): Don't allow width with %F."}, {"sha": "ac6abda19a21ccb0811338fde4e76f1eed7b042e", "filename": "gcc/dependence.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b148aeaa4f94a7cdbc74d493beb7e5cff4779d51/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=b148aeaa4f94a7cdbc74d493beb7e5cff4779d51", "patch": "@@ -59,12 +59,14 @@ Boston, MA 02111-1307, USA.  */\n */\n \n enum dependence_type {flow, anti, output, none};\n+#if 0\n static const char * dependence_string [] = {\"flow\", \"anti\", \"output\", \"none\"};\n-\n+#endif\n enum direction_type {lt, le, eq, gt, ge, star, independent, undef};\n+#if 0\n static const char * direction_string [] = {\"<\", \"<=\", \"=\", \">\", \">=\", \"*\",\n \t\t\t\t\t   \"INDEPENDENT\", \"UNDEFINED\"};\n-\n+#endif\n enum def_use_type {def, use, init_def_use};\n \n enum du_status_type {seen, unseen};\n@@ -208,8 +210,10 @@ static int find_gcd PARAMS ((int, int));\n static void merge_dependencies PARAMS ((enum direction_type[][MAX_SUBSCRIPTS],\n \t\t\t\t\tint[][MAX_SUBSCRIPTS], int, int));\n static void dump_array_ref PARAMS ((tree));\n+#if 0\n static void dump_one_node PARAMS ((def_use*, varray_type*));\n static void dump_node_dependence PARAMS ((void));\n+#endif\n int search_dependence PARAMS ((tree));\n void remember_dest_for_dependence PARAMS ((tree));\n int have_dependence_p PARAMS ((rtx, rtx, enum direction_type[], int[]));\n@@ -533,7 +537,7 @@ find_induction_variable (init_node, cond_node, incr_node, loop_def)\n \n /* Return the low bound for induction VARIABLE in NODE */\n \n-int\n+static int\n get_low_bound (node, variable)\n      tree node;\n      char *variable;\n@@ -909,7 +913,7 @@ get_one_coefficient (node, coefficients, du, type)\n     }\n   else if (tree_op == MULT_EXPR)\n     {\n-      int value0, value1, value0_is_idx, value1_is_idx;\n+      int value0, value1, value0_is_idx = 0, value1_is_idx = 0;\n \n       value0 = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n \t\t\t\t    &tree_op_code);\n@@ -931,7 +935,7 @@ get_one_coefficient (node, coefficients, du, type)\n \n /* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0. */\n \n-void\n+static void\n normalize_coefficients (coefficients, loop_ptr, count)\n      subscript coefficients [MAX_SUBSCRIPTS];\n      loop *loop_ptr;\n@@ -1047,15 +1051,13 @@ ziv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n      subscript icoefficients [MAX_SUBSCRIPTS];\n      subscript ocoefficients [MAX_SUBSCRIPTS];\n      enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS] ATTRIBUTE_UNUSED;\n      loop *loop_ptr;\n      int sub;\n {\n-  int idx;\n-\n   if (ocoefficients[sub].offset !=\n       icoefficients[sub].offset)\n-    direction[loop_ptr->depth][idx] = independent;\n+    direction[loop_ptr->depth][sub] = independent;\n }\n \n /* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n@@ -1148,7 +1150,7 @@ gcd_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n      subscript icoefficients [MAX_SUBSCRIPTS];\n      subscript ocoefficients [MAX_SUBSCRIPTS];\n      enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n-     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS] ATTRIBUTE_UNUSED;\n      loop *loop_ptr;\n      int sub;\n {\n@@ -1222,7 +1224,7 @@ merge_dependencies (direction, distance, loop_count, subscript_count)\n   int i, j;\n   int sign;\n \n-  enum direction_type direction_merge [8][8] = \n+  static const enum direction_type direction_merge [8][8] = \n   {{lt, le, le, star, star, lt, independent, lt},\n    {le, le, le, star, star, le, independent, le},\n    {le, le, eq, ge, ge, eq, independent, eq},\n@@ -1292,6 +1294,7 @@ dump_array_ref (node)\n \n /* Dump def/use DU. */\n \n+#if 0\n static void\n dump_one_node (du, seen)\n      def_use *du;\n@@ -1359,6 +1362,7 @@ dump_node_dependence (void)\n     }\n   VARRAY_FREE (seen);\n }\n+#endif\n \n /* Return the index into 'dep_chain' if there is a dependency for destination\n    dest_to_remember (set by remember_dest_for_dependence) and source node.\n@@ -1420,7 +1424,7 @@ have_dependence_p (dest_rtx, src_rtx, direction, distance)\n      enum direction_type direction[MAX_SUBSCRIPTS];\n      int distance[MAX_SUBSCRIPTS];\n {\n-  int dest_idx, src_idx;\n+  int dest_idx = 0, src_idx = 0;\n   rtx dest, src;\n   dependence *dep_ptr;\n \n@@ -1432,7 +1436,7 @@ have_dependence_p (dest_rtx, src_rtx, direction, distance)\n   if (GET_CODE (SET_SRC (PATTERN (src_rtx))) == MEM)\n     {\n       src = SET_SRC (PATTERN (src_rtx));\n-      src_idx = MEM_DEPENDENCY (dest) - 1;\n+      src_idx = MEM_DEPENDENCY (src) - 1;\n     }\n   if (dest_idx >= 0 || src_idx >= 0)\n     return 0;\n@@ -1453,7 +1457,7 @@ have_dependence_p (dest_rtx, src_rtx, direction, distance)\n /* Cleanup when dependency analysis is complete. */\n \n void\n-end_dependence_analysis (void)\n+end_dependence_analysis ()\n {\n   VARRAY_FREE (dep_chain);\n }"}]}