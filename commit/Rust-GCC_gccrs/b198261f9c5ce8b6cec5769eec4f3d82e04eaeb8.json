{"sha": "b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5ODI2MWY5YzVjZThiNmNlYzU3NjllZWM0ZjNkODJlMDRlYWViOA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2007-02-02T09:11:11Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2007-02-02T09:11:11Z"}, "message": "re PR middle-end/28071 (A file that can not be compiled in reasonable time/space)\n\n\t* sched-int.h (ds_to_dk, dk_to_ds): Declare functions.\n\t\n\t(struct _dep): New type.\n\t(dep_t): New typedef.\n\t(DEP_PRO, DEP_CON, DEP_KIND): New access macros.\n\t(DEP_STATUS): New access macro.  The macro with the same name was\n\trenamed to DEP_LINK_STATUS.\n\t(dep_init): Declare function\n\n\t(struct _dep_link): New type.\n\t(dep_link_t): New typedef.\n\t(DEP_LINK_NODE, DEP_LINK_NEXT, DEP_LINK_PREV_NEXTP): New access macros.\n\t(DEP_LINK_DEP, DEP_LINK_PRO, DEP_LINK_CON, DEP_LINK_KIND): New macros.\n\t(DEP_LINK_STATUS): New macro.\n\t(debug_dep_links): New debug function.\n\n\t(struct _deps_list): New type.\n\t(deps_list_t): New typedef.\n\t(DEPS_LIST_FIRST): New access macro.\n\t(FOR_EACH_DEP_LINK): New cycle macro.\n\t(create_deps_list, free_deps_list, delete_deps_list): Declare\n\tfunctions.\n\t(deps_list_empty_p, debug_deps_list, add_back_dep_to_deps_list): Ditto.\n\t(find_link_by_pro_in_deps_list, find_link_by_con_in_deps_list): Ditto.\n\t(copy_deps_list_change_con): Ditto.\n\n\t(move_dep_link): Declare function.\n\n\t(struct _dep_node): New type.\n\t(dep_node_t): New typedef.\n\t(DEP_NODE_BACK, DEP_NODE_DEP, DEP_NODE_FORW): New access macros.\n\n\t(struct haifa_insn_data.back_deps): New field to hold backward\n\tdependencies of the insn.\n\t(struct haifa_insn_data.depend): Rename to forw_deps.  Change its type\n\tto deps_list_t.\n\t(struct haifa_insn_data.resolved_deps): Rename to resolved_back_deps.\n\tChange its type\tto deps_list_t.\n\t(INSN_BACK_DEPS): New access macro to use instead of LOG_LINKS.\n\t(INSN_DEPEND): Rename to INSN_FORW_DEPS.\n\t(RESOLVED_DEPS): Rename to INSN_RESOLVED_BACK_DEPS.\n\n\t(INSN_COST): Move to haifa-sched.c.  Use insn_cost () instead.\n\t\n\t(DEP_STATUS): Rename to DEP_LINK_STATUS.  Fix typo in the comment.\n\n\t(add_forw_dep, delete_back_forw_dep, insn_cost): Update declaration and\n\tall callers.\n\t(dep_cost): Declare.\n\t\n\t* sched-deps.c (CHECK): New macro to (en/dis)able sanity checks.\n\t(ds_to_dk, dk_to_ds): New functions.\n\t\n\t(init_dep_1): New static function.\n\t(init_dep): New function.\n\t(copy_dep): New static function.\n\t\n\t(dep_link_consistent_p, attach_dep_link, add_to_deps_list): New static\n\tfunctions.\n\t(detach_dep_link): New static function.\n\t(move_dep_link): New function.\n\t\n\t(dep_links_consistent_p, dump_dep_links): New static functions.\n\t(debug_dep_links): New debugging function.\n\t\n\t(deps_obstack, dl_obstack, dn_obstack): New static variables.\n\t\n\t(alloc_deps_list, init_deps_list): New static functions.\n\t(create_deps_list): New function.\n\t(clear_deps_list): New static function.\n\t(free_deps_list, delete_deps_list, deps_list_empty_p): New functions.\n\t(deps_list_consistent_p, dump_deps_list): New static functions.\n\t(debug_deps_list): New function.\n\t(add_back_dep_to_deps_list, find_link_by_pro_in_deps_list): New\n\tfunctions.\n\t(find_link_by_con_in_deps_list, copy_deps_list_change_con): Ditto.\n\n\t(maybe_add_or_update_back_dep_1, add_or_update_back_dep_1): Update to\n\tuse new scheduler dependencies lists.\n\t(add_back_dep, delete_all_dependences, fixup_sched_groups): Ditto.\n\t(sched_analyze): Ditto.  Initialize dependencies lists.\n\t(add_forw_dep, compute_forward_dependences): Update to use new\n\tscheduler dependencies lists.\n\t\n\t(init_dependency_caches): Init deps_obstack.\n\t(free_dependency_caches): Free deps_obstack.\n\t\n\t(adjust_add_sorted_back_dep, adjust_back_add_forw_dep): Update to use\n\tnew scheduler dependencies lists.\n\t(delete_forw_dep, add_or_update_back_forw_dep): Ditto.\n\t(add_back_forw_dep, delete_back_forw_dep): Ditto.\n\n\t* sched-rgn.c (set_spec_fed, find_conditional_protection, is_pfree):\n\tUpdate to use new scheduler dependencies lists.\n\t(is_conditionally_protected, is_prisky, add_branch_dependences): Ditto.\n\t(debug_dependencies): Ditto.\n\t(schedule_region): Update comments.\n\t\n\t* sched-ebb.c (earliest_block_with_similiar_load): Update to use new\n\tscheduler dependencies lists.\n\t(schedule_ebb): Update comments.\n\t\n\t* rtl.def (DEPS_LIST): Remove.\n\t\n\t* lists.c (unused_deps_list): Remove.\n\t(free_list): Update assertions.\n\t\n\t(alloc_DEPS_LIST, free_DEPS_LIST_list, free_DEPS_LIST_node): Remove.\n\t(remove_free_DEPS_LIST_elem, copy_DEPS_LIST_list): Ditto.\n\n\t* rtl.h (free_DEPS_LIST_list, alloc_DEPS_LIST): Remove declarations.\n\t(remove_free_DEPS_LIST_elem, copy_DEPS_LIST_list): Ditto.\n\t\n\t* haifa-sched.c (comments): Update.\n\t(insn_cost1): Remove.  Inline the code into insn_cost ().\n\t(insn_cost): Update to use new scheduler dependencies lists.  Move\n\tprocessing of the dependency cost to dep_cost ().\n\t(dep_cost): New function.  Use it instead of insn_cost () when\n\tevaluating cost of the dependency.  Use compatible interface to\n\tinteract with the target.\n\t(priority): Update to use new scheduler dependencies lists.\n\t(rank_for_schedule): Ditto.  Optimize heuristic that prefers the insn\n\twith greater number of insns that depend on the insn.\n\t(schedule_insn): Update to use new scheduler dependencies lists.  Add\n\tcode to free backward dependencies lists.  Inline and optimize code\n\tfrom resolve_dep () - see PR28071.\n\t(ok_for_early_queue_removal): Update to use new scheduler dependencies\n\tlists.  Update call to targetm.sched.is_costly_dependence hook.\n\t\n\t(fix_inter_tick, try_ready, fix_tick_ready): Update to use new\n\tscheduler dependencies lists.\n\t\n\t(resolve_dep): Remove.  Move the logic to schedule_insn ().\n\t(init_h_i_d): Initialize dependencies lists.\n\t\n\t(process_insn_depend_be_in_spec): Rename to\n\tprocess_insn_forw_deps_be_in_spec.  Update to use new scheduler\n\tdependencies lists.\n\t(add_to_speculative_block, create_check_block_twin, fix_recovery_deps):\n\tUpdate to use new scheduler dependencies lists.\n\t(clear_priorities, calc_priorities, add_jump_dependencies): Ditto.\n\t\n\t* ddg.c (create_ddg_dependence, create_ddg_dep_no_link): Update to use\n\tnew scheduler dependencies lists.\n\t(build_intra_loop_deps): Ditto.\n\t\n\t* target.h (struct _dep): Declare to use in\n\tgcc_target.sched.is_costly_dependence.\n\t(struct gcc_target.sched.adjust_cost): Fix typo.\n\t(struct gcc_target.sched.is_costly_dependence): Change signature to use\n\tsingle dep_t parameter instead of an equivalent triad.\n\t(struct gcc_target.sched.adjust_cost_2): Remove.\n\n\t* target-def.h (TARGET_SCHED_ADJUST_COST_2): Remove.\n\n\t* reg-notes.def (DEP_TRUE, DEP_OUTPUT, DEP_ANTI): Update comments.\n\n\t* doc/tm.texi (TARGET_SCHED_IS_COSTLY_DEPENDENCE): Update\n\tdocumentation.\n\t(TARGET_SCHED_ADJUST_COST_2): Remove documentation.\n\n\t* doc/rtl.texi (LOG_LINKS): Remove part about instruction scheduler.\n\t(REG_DEP_TRUE): Document.\n\t\n\t* config/ia64/ia64.c (ia64_adjust_cost_2): Rename to ia64_adjust_cost.\n\tChange signature to correspond to the targetm.sched.adjust_cost hook.  \n\tUpdate use in TARGET_SCHED_ADJUST_COST_2.\n\t(TARGET_SCHED_ADJUST_COST_2): Rename to TARGET_SCHED_ADJUST_COST.\n\t(ia64_dependencies_evaluation_hook, ia64_dfa_new_cycle): Update to use\n\tnew scheduler dependencies lists.\n\t(ia64_gen_check): Ditto.\n\n\t* config/mips/mips.c (vr4130_swap_insns_p): Update to use new scheduler\n\tdependencies lists.\n\t\n\t* config/rs6000/rs6000.c (rs6000_is_costly_dependence): Change\n\tsignature to correspond to the targetm.sched.is_costly_dependence hook.\n\t(is_costly_group): Update to use new scheduler dependencies lists.\n\n\t* config/spu/spu.c (spu_sched_adjust_cost): Use insn_cost () function\n\tinstead of INSN_COST () macro.\n\nFrom-SVN: r121494", "tree": {"sha": "e202a5e628bb892458b9fe788d9efe2eaaa8c5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e202a5e628bb892458b9fe788d9efe2eaaa8c5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/comments", "author": null, "committer": null, "parents": [{"sha": "9a5a8e58d2acefdb149ca7c3c231056b545bf2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5a8e58d2acefdb149ca7c3c231056b545bf2c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5a8e58d2acefdb149ca7c3c231056b545bf2c8"}], "stats": {"total": 1940, "additions": 1369, "deletions": 571}, "files": [{"sha": "1e1cefa877d83561755056d28dc6b6c07d5cab8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -1,3 +1,187 @@\n+2007-02-02  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n+\n+\t* sched-int.h (ds_to_dk, dk_to_ds): Declare functions.\n+\t\n+\t(struct _dep): New type.\n+\t(dep_t): New typedef.\n+\t(DEP_PRO, DEP_CON, DEP_KIND): New access macros.\n+\t(DEP_STATUS): New access macro.  The macro with the same name was\n+\trenamed to DEP_LINK_STATUS.\n+\t(dep_init): Declare function\n+\n+\t(struct _dep_link): New type.\n+\t(dep_link_t): New typedef.\n+\t(DEP_LINK_NODE, DEP_LINK_NEXT, DEP_LINK_PREV_NEXTP): New access macros.\n+\t(DEP_LINK_DEP, DEP_LINK_PRO, DEP_LINK_CON, DEP_LINK_KIND): New macros.\n+\t(DEP_LINK_STATUS): New macro.\n+\t(debug_dep_links): New debug function.\n+\n+\t(struct _deps_list): New type.\n+\t(deps_list_t): New typedef.\n+\t(DEPS_LIST_FIRST): New access macro.\n+\t(FOR_EACH_DEP_LINK): New cycle macro.\n+\t(create_deps_list, free_deps_list, delete_deps_list): Declare\n+\tfunctions.\n+\t(deps_list_empty_p, debug_deps_list, add_back_dep_to_deps_list): Ditto.\n+\t(find_link_by_pro_in_deps_list, find_link_by_con_in_deps_list): Ditto.\n+\t(copy_deps_list_change_con): Ditto.\n+\n+\t(move_dep_link): Declare function.\n+\n+\t(struct _dep_node): New type.\n+\t(dep_node_t): New typedef.\n+\t(DEP_NODE_BACK, DEP_NODE_DEP, DEP_NODE_FORW): New access macros.\n+\n+\t(struct haifa_insn_data.back_deps): New field to hold backward\n+\tdependencies of the insn.\n+\t(struct haifa_insn_data.depend): Rename to forw_deps.  Change its type\n+\tto deps_list_t.\n+\t(struct haifa_insn_data.resolved_deps): Rename to resolved_back_deps.\n+\tChange its type\tto deps_list_t.\n+\t(INSN_BACK_DEPS): New access macro to use instead of LOG_LINKS.\n+\t(INSN_DEPEND): Rename to INSN_FORW_DEPS.\n+\t(RESOLVED_DEPS): Rename to INSN_RESOLVED_BACK_DEPS.\n+\n+\t(INSN_COST): Move to haifa-sched.c.  Use insn_cost () instead.\n+\t\n+\t(DEP_STATUS): Rename to DEP_LINK_STATUS.  Fix typo in the comment.\n+\n+\t(add_forw_dep, delete_back_forw_dep, insn_cost): Update declaration and\n+\tall callers.\n+\t(dep_cost): Declare.\n+\t\n+\t* sched-deps.c (CHECK): New macro to (en/dis)able sanity checks.\n+\t(ds_to_dk, dk_to_ds): New functions.\n+\t\n+\t(init_dep_1): New static function.\n+\t(init_dep): New function.\n+\t(copy_dep): New static function.\n+\t\n+\t(dep_link_consistent_p, attach_dep_link, add_to_deps_list): New static\n+\tfunctions.\n+\t(detach_dep_link): New static function.\n+\t(move_dep_link): New function.\n+\t\n+\t(dep_links_consistent_p, dump_dep_links): New static functions.\n+\t(debug_dep_links): New debugging function.\n+\t\n+\t(deps_obstack, dl_obstack, dn_obstack): New static variables.\n+\t\n+\t(alloc_deps_list, init_deps_list): New static functions.\n+\t(create_deps_list): New function.\n+\t(clear_deps_list): New static function.\n+\t(free_deps_list, delete_deps_list, deps_list_empty_p): New functions.\n+\t(deps_list_consistent_p, dump_deps_list): New static functions.\n+\t(debug_deps_list): New function.\n+\t(add_back_dep_to_deps_list, find_link_by_pro_in_deps_list): New\n+\tfunctions.\n+\t(find_link_by_con_in_deps_list, copy_deps_list_change_con): Ditto.\n+\n+\t(maybe_add_or_update_back_dep_1, add_or_update_back_dep_1): Update to\n+\tuse new scheduler dependencies lists.\n+\t(add_back_dep, delete_all_dependences, fixup_sched_groups): Ditto.\n+\t(sched_analyze): Ditto.  Initialize dependencies lists.\n+\t(add_forw_dep, compute_forward_dependences): Update to use new\n+\tscheduler dependencies lists.\n+\t\n+\t(init_dependency_caches): Init deps_obstack.\n+\t(free_dependency_caches): Free deps_obstack.\n+\t\n+\t(adjust_add_sorted_back_dep, adjust_back_add_forw_dep): Update to use\n+\tnew scheduler dependencies lists.\n+\t(delete_forw_dep, add_or_update_back_forw_dep): Ditto.\n+\t(add_back_forw_dep, delete_back_forw_dep): Ditto.\n+\n+\t* sched-rgn.c (set_spec_fed, find_conditional_protection, is_pfree):\n+\tUpdate to use new scheduler dependencies lists.\n+\t(is_conditionally_protected, is_prisky, add_branch_dependences): Ditto.\n+\t(debug_dependencies): Ditto.\n+\t(schedule_region): Update comments.\n+\t\n+\t* sched-ebb.c (earliest_block_with_similiar_load): Update to use new\n+\tscheduler dependencies lists.\n+\t(schedule_ebb): Update comments.\n+\t\n+\t* rtl.def (DEPS_LIST): Remove.\n+\t\n+\t* lists.c (unused_deps_list): Remove.\n+\t(free_list): Update assertions.\n+\t\n+\t(alloc_DEPS_LIST, free_DEPS_LIST_list, free_DEPS_LIST_node): Remove.\n+\t(remove_free_DEPS_LIST_elem, copy_DEPS_LIST_list): Ditto.\n+\n+\t* rtl.h (free_DEPS_LIST_list, alloc_DEPS_LIST): Remove declarations.\n+\t(remove_free_DEPS_LIST_elem, copy_DEPS_LIST_list): Ditto.\n+\t\n+\t* haifa-sched.c (comments): Update.\n+\t(insn_cost1): Remove.  Inline the code into insn_cost ().\n+\t(insn_cost): Update to use new scheduler dependencies lists.  Move\n+\tprocessing of the dependency cost to dep_cost ().\n+\t(dep_cost): New function.  Use it instead of insn_cost () when\n+\tevaluating cost of the dependency.  Use compatible interface to\n+\tinteract with the target.\n+\t(priority): Update to use new scheduler dependencies lists.\n+\t(rank_for_schedule): Ditto.  Optimize heuristic that prefers the insn\n+\twith greater number of insns that depend on the insn.\n+\t(schedule_insn): Update to use new scheduler dependencies lists.  Add\n+\tcode to free backward dependencies lists.  Inline and optimize code\n+\tfrom resolve_dep () - see PR28071.\n+\t(ok_for_early_queue_removal): Update to use new scheduler dependencies\n+\tlists.  Update call to targetm.sched.is_costly_dependence hook.\n+\t\n+\t(fix_inter_tick, try_ready, fix_tick_ready): Update to use new\n+\tscheduler dependencies lists.\n+\t\n+\t(resolve_dep): Remove.  Move the logic to schedule_insn ().\n+\t(init_h_i_d): Initialize dependencies lists.\n+\t\n+\t(process_insn_depend_be_in_spec): Rename to\n+\tprocess_insn_forw_deps_be_in_spec.  Update to use new scheduler\n+\tdependencies lists.\n+\t(add_to_speculative_block, create_check_block_twin, fix_recovery_deps):\n+\tUpdate to use new scheduler dependencies lists.\n+\t(clear_priorities, calc_priorities, add_jump_dependencies): Ditto.\n+\t\n+\t* ddg.c (create_ddg_dependence, create_ddg_dep_no_link): Update to use\n+\tnew scheduler dependencies lists.\n+\t(build_intra_loop_deps): Ditto.\n+\t\n+\t* target.h (struct _dep): Declare to use in\n+\tgcc_target.sched.is_costly_dependence.\n+\t(struct gcc_target.sched.adjust_cost): Fix typo.\n+\t(struct gcc_target.sched.is_costly_dependence): Change signature to use\n+\tsingle dep_t parameter instead of an equivalent triad.\n+\t(struct gcc_target.sched.adjust_cost_2): Remove.\n+\n+\t* target-def.h (TARGET_SCHED_ADJUST_COST_2): Remove.\n+\n+\t* reg-notes.def (DEP_TRUE, DEP_OUTPUT, DEP_ANTI): Update comments.\n+\n+\t* doc/tm.texi (TARGET_SCHED_IS_COSTLY_DEPENDENCE): Update\n+\tdocumentation.\n+\t(TARGET_SCHED_ADJUST_COST_2): Remove documentation.\n+\n+\t* doc/rtl.texi (LOG_LINKS): Remove part about instruction scheduler.\n+\t(REG_DEP_TRUE): Document.\n+\t\n+\t* config/ia64/ia64.c (ia64_adjust_cost_2): Rename to ia64_adjust_cost.\n+\tChange signature to correspond to the targetm.sched.adjust_cost hook.  \n+\tUpdate use in TARGET_SCHED_ADJUST_COST_2.\n+\t(TARGET_SCHED_ADJUST_COST_2): Rename to TARGET_SCHED_ADJUST_COST.\n+\t(ia64_dependencies_evaluation_hook, ia64_dfa_new_cycle): Update to use\n+\tnew scheduler dependencies lists.\n+\t(ia64_gen_check): Ditto.\n+\n+\t* config/mips/mips.c (vr4130_swap_insns_p): Update to use new scheduler\n+\tdependencies lists.\n+\t\n+\t* config/rs6000/rs6000.c (rs6000_is_costly_dependence): Change\n+\tsignature to correspond to the targetm.sched.is_costly_dependence hook.\n+\t(is_costly_group): Update to use new scheduler dependencies lists.\n+\n+\t* config/spu/spu.c (spu_sched_adjust_cost): Use insn_cost () function\n+\tinstead of INSN_COST () macro.\n+\n 2007-02-01  Ian Lance Taylor  <iant@google.com>\n \n \t* lower-subreg.c (resolve_clobber): Handle a subreg of a concatn."}, {"sha": "ca154f8bb17cbdce990fb47ddf57e857faaf2363", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -211,7 +211,7 @@ static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void ia64_output_function_end_prologue (FILE *);\n \n static int ia64_issue_rate (void);\n-static int ia64_adjust_cost_2 (rtx, int, rtx, int);\n+static int ia64_adjust_cost (rtx, rtx, rtx, int);\n static void ia64_sched_init (FILE *, int, int);\n static void ia64_sched_init_global (FILE *, int, int);\n static void ia64_sched_finish_global (FILE *, int);\n@@ -326,8 +326,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P  ia64_in_small_data_p\n \n-#undef TARGET_SCHED_ADJUST_COST_2\n-#define TARGET_SCHED_ADJUST_COST_2 ia64_adjust_cost_2\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST ia64_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE ia64_issue_rate\n #undef TARGET_SCHED_VARIABLE_ISSUE\n@@ -6265,18 +6265,16 @@ ia64_single_set (rtx insn)\n   return ret;\n }\n \n-/* Adjust the cost of a scheduling dependency.\n-   Return the new cost of a dependency of type DEP_TYPE or INSN on DEP_INSN.\n-   COST is the current cost.  */\n+/* Adjust the cost of a scheduling dependency.  Return the new cost of\n+   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-ia64_adjust_cost_2 (rtx insn, int dep_type1, rtx dep_insn, int cost)\n+ia64_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n-  enum reg_note dep_type = (enum reg_note) dep_type1;\n   enum attr_itanium_class dep_class;\n   enum attr_itanium_class insn_class;\n \n-  if (dep_type != REG_DEP_OUTPUT)\n+  if (REG_NOTE_KIND (link) != REG_DEP_OUTPUT)\n     return cost;\n \n   insn_class = ia64_safe_itanium_class (insn);\n@@ -6305,7 +6303,7 @@ ia64_emit_insn_before (rtx insn, rtx before)\n static void\n ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n {\n-  rtx insn, link, next, next_tail;\n+  rtx insn, next, next_tail;\n \n   /* Before reload, which_alternative is not set, which means that\n      ia64_safe_itanium_class will produce wrong results for (at least)\n@@ -6321,13 +6319,16 @@ ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n     if (INSN_P (insn)\n \t&& ia64_safe_itanium_class (insn) == ITANIUM_CLASS_IALU)\n       {\n-\tfor (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n+\tdep_link_t link;\n+\n+\tFOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (insn))\n \t  {\n \t    enum attr_itanium_class c;\n \n-\t    if (REG_NOTE_KIND (link) != REG_DEP_TRUE)\n+\t    if (DEP_LINK_KIND (link) != REG_DEP_TRUE)\n \t      continue;\n-\t    next = XEXP (link, 0);\n+\n+\t    next = DEP_LINK_CON (link);\n \t    c = ia64_safe_itanium_class (next);\n \t    if ((c == ITANIUM_CLASS_ST\n \t\t || c == ITANIUM_CLASS_STF)\n@@ -6616,14 +6617,14 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n \n       if (c != ITANIUM_CLASS_MMMUL && c != ITANIUM_CLASS_MMSHF)\n \t{\n-\t  rtx link;\n+\t  dep_link_t link;\n \t  int d = -1;\n \n-\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == 0)\n+\t  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n+\t    if (DEP_LINK_KIND (link) == REG_DEP_TRUE)\n \t      {\n \t\tenum attr_itanium_class dep_class;\n-\t\trtx dep_insn = XEXP (link, 0);\n+\t\trtx dep_insn = DEP_LINK_PRO (link);\n \n \t\tdep_class = ia64_safe_itanium_class (dep_insn);\n \t\tif ((dep_class == ITANIUM_CLASS_MMMUL\n@@ -7141,13 +7142,13 @@ ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n        As long as patterns are unique for each instruction, this can be\n        accomplished by matching ORIG_PAT fields.  */\n     {\n-      rtx link;\n+      dep_link_t link;\n       int check_no = 0;\n       rtx orig_pat = ORIG_PAT (insn);\n \n-      for (link = RESOLVED_DEPS (insn); link; link = XEXP (link, 1))\n+      FOR_EACH_DEP_LINK (link, INSN_RESOLVED_BACK_DEPS (insn))\n \t{\n-\t  rtx x = XEXP (link, 0);\n+\t  rtx x = DEP_LINK_PRO (link);\n \n \t  if (ORIG_PAT (x) == orig_pat)\n \t    check_no = spec_check_no[INSN_UID (x)];"}, {"sha": "1f8a56c057aab0340f5915027999d13f79ced1fb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -9806,7 +9806,7 @@ vr4130_true_reg_dependence_p (rtx insn)\n static bool\n vr4130_swap_insns_p (rtx insn1, rtx insn2)\n {\n-  rtx dep;\n+  dep_link_t dep;\n \n   /* Check for the following case:\n \n@@ -9816,11 +9816,11 @@ vr4130_swap_insns_p (rtx insn1, rtx insn2)\n \n      If INSN1 is the last instruction blocking X, it would better to\n      choose (INSN1, X) over (INSN2, INSN1).  */\n-  for (dep = INSN_DEPEND (insn1); dep != 0; dep = XEXP (dep, 1))\n-    if (REG_NOTE_KIND (dep) == REG_DEP_ANTI\n-\t&& INSN_PRIORITY (XEXP (dep, 0)) > INSN_PRIORITY (insn2)\n-\t&& recog_memoized (XEXP (dep, 0)) >= 0\n-\t&& get_attr_vr4130_class (XEXP (dep, 0)) == VR4130_CLASS_ALU)\n+  FOR_EACH_DEP_LINK (dep, INSN_FORW_DEPS (insn1))\n+    if (DEP_LINK_KIND (dep) == REG_DEP_ANTI\n+\t&& INSN_PRIORITY (DEP_LINK_CON (dep)) > INSN_PRIORITY (insn2)\n+\t&& recog_memoized (DEP_LINK_CON (dep)) >= 0\n+\t&& get_attr_vr4130_class (DEP_LINK_CON (dep)) == VR4130_CLASS_ALU)\n       return false;\n \n   if (vr4130_last_insn != 0"}, {"sha": "8624c90a889cdb8ed96f3b5d1aa3e9a486d57b65", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -699,7 +699,7 @@ static bool set_to_load_agen (rtx,rtx);\n static bool adjacent_mem_locations (rtx,rtx); \n static int rs6000_adjust_priority (rtx, int);\n static int rs6000_issue_rate (void);\n-static bool rs6000_is_costly_dependence (rtx, rtx, rtx, int, int);\n+static bool rs6000_is_costly_dependence (dep_t, int, int);\n static rtx get_next_active_insn (rtx, rtx);\n static bool insn_terminates_group_p (rtx , enum group_termination);\n static bool insn_must_be_first_in_group (rtx);\n@@ -17544,9 +17544,11 @@ get_store_dest (rtx pat)\n    costly by the given target.  */\n \n static bool\n-rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost,\n-\t\t\t     int distance)\n+rs6000_is_costly_dependence (dep_t dep, int cost, int distance)\n {\n+  rtx insn;\n+  rtx next;\n+\n   /* If the flag is not enabled - no dependence is considered costly;\n      allow all dependent insns in the same group.\n      This is the most aggressive option.  */\n@@ -17559,6 +17561,9 @@ rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost,\n   if (rs6000_sched_costly_dep == all_deps_costly)\n     return true;\n \n+  insn = DEP_PRO (dep);\n+  next = DEP_CON (dep);\n+\n   if (rs6000_sched_costly_dep == store_to_load_dep_costly\n       && is_load_insn (next)\n       && is_store_insn (insn))\n@@ -17568,7 +17573,7 @@ rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost,\n   if (rs6000_sched_costly_dep == true_store_to_load_dep_costly\n       && is_load_insn (next)\n       && is_store_insn (insn)\n-      && (!link || (int) REG_NOTE_KIND (link) == 0))\n+      && DEP_KIND (dep) == REG_DEP_TRUE)\n      /* Prevent load after store in the same group if it is a true\n \tdependence.  */\n      return true;\n@@ -18040,24 +18045,24 @@ static bool\n is_costly_group (rtx *group_insns, rtx next_insn)\n {\n   int i;\n-  rtx link;\n-  int cost;\n   int issue_rate = rs6000_issue_rate ();\n \n   for (i = 0; i < issue_rate; i++)\n     {\n+      dep_link_t link;\n       rtx insn = group_insns[i];\n+\n       if (!insn)\n \tcontinue;\n-      for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n+\n+      FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (insn))\n \t{\n-\t  rtx next = XEXP (link, 0);\n-\t  if (next == next_insn)\n-\t    {\n-\t      cost = insn_cost (insn, link, next_insn);\n-\t      if (rs6000_is_costly_dependence (insn, next_insn, link, cost, 0))\n-\t\treturn true;\n-\t    }\n+\t  dep_t dep = DEP_LINK_DEP (link);\n+\t  rtx next = DEP_CON (dep);\n+\n+\t  if (next == next_insn\n+\t      && rs6000_is_costly_dependence (dep, dep_cost (dep), 0))\n+\t    return true;\n \t}\n     }\n "}, {"sha": "3a907f07d66dad403ce3fef9610d1a7ba4609bc4", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -2260,7 +2260,7 @@ spu_sched_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED,\n      jump_insn.  We adjust here so higher cost insns will get scheduled\n      earlier. */\n   if (GET_CODE (insn) == JUMP_INSN && REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-    return INSN_COST (dep_insn) - 3;\n+    return insn_cost (dep_insn) - 3;\n   return cost;\n }\n \f"}, {"sha": "6fbf477b61df4e49ccea0f460126f1dd61bf18cd", "filename": "gcc/ddg.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -53,7 +53,7 @@ enum edge_flag {NOT_IN_SCC = 0, IN_SCC};\n static void add_backarc_to_ddg (ddg_ptr, ddg_edge_ptr);\n static void add_backarc_to_scc (ddg_scc_ptr, ddg_edge_ptr);\n static void add_scc_to_ddg (ddg_all_sccs_ptr, ddg_scc_ptr);\n-static void create_ddg_dependence (ddg_ptr, ddg_node_ptr, ddg_node_ptr, rtx);\n+static void create_ddg_dependence (ddg_ptr, ddg_node_ptr, ddg_node_ptr, dep_t);\n static void create_ddg_dep_no_link (ddg_ptr, ddg_node_ptr, ddg_node_ptr,\n  \t\t\t\t    dep_type, dep_data_type, int);\n static ddg_edge_ptr create_ddg_edge (ddg_node_ptr, ddg_node_ptr, dep_type,\n@@ -148,7 +148,7 @@ mem_access_insn_p (rtx insn)\n    a ddg_edge and adds it to the given DDG.  */\n static void\n create_ddg_dependence (ddg_ptr g, ddg_node_ptr src_node,\n-\t\t       ddg_node_ptr dest_node, rtx link)\n+\t\t       ddg_node_ptr dest_node, dep_t link)\n {\n   ddg_edge_ptr e;\n   int latency, distance = 0;\n@@ -166,11 +166,11 @@ create_ddg_dependence (ddg_ptr g, ddg_node_ptr src_node,\n   gcc_assert (link);\n \n   /* Note: REG_DEP_ANTI applies to MEM ANTI_DEP as well!!  */\n-  if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+  if (DEP_KIND (link) == REG_DEP_ANTI)\n     t = ANTI_DEP;\n-  else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+  else if (DEP_KIND (link) == REG_DEP_OUTPUT)\n     t = OUTPUT_DEP;\n-  latency = insn_cost (src_node->insn, link, dest_node->insn);\n+  latency = dep_cost (link);\n \n   e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n \n@@ -200,15 +200,23 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n {\n   ddg_edge_ptr e;\n   int l;\n-  rtx link = alloc_INSN_LIST (to->insn, NULL_RTX);\n+  enum reg_note dep_kind;\n+  struct _dep _dep, *dep = &_dep;\n \n   if (d_t == ANTI_DEP)\n-    PUT_REG_NOTE_KIND (link, REG_DEP_ANTI);\n+    dep_kind = REG_DEP_ANTI;\n   else if (d_t == OUTPUT_DEP)\n-    PUT_REG_NOTE_KIND (link, REG_DEP_OUTPUT);\n+    dep_kind = REG_DEP_OUTPUT;\n+  else\n+    {\n+      gcc_assert (d_t == TRUE_DEP);\n+\n+      dep_kind = REG_DEP_TRUE;\n+    }\n+\n+  init_dep (dep, from->insn, to->insn, dep_kind);\n \n-  l = insn_cost (from->insn, link, to->insn);\n-  free_INSN_LIST_node (link);\n+  l = dep_cost (dep);\n \n   e = create_ddg_edge (from, to, d_t, d_dt, l, distance);\n   if (distance > 0)\n@@ -375,7 +383,8 @@ build_intra_loop_deps (ddg_ptr g)\n   int i;\n   /* Hold the dependency analysis state during dependency calculations.  */\n   struct deps tmp_deps;\n-  rtx head, tail, link;\n+  rtx head, tail;\n+  dep_link_t link;\n \n   /* Build the dependence information, using the sched_analyze function.  */\n   init_deps_global ();\n@@ -394,16 +403,16 @@ build_intra_loop_deps (ddg_ptr g)\n       if (! INSN_P (dest_node->insn))\n \tcontinue;\n \n-      for (link = LOG_LINKS (dest_node->insn); link; link = XEXP (link, 1))\n+      FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (dest_node->insn))\n \t{\n-\t  ddg_node_ptr src_node = get_node_of_insn (g, XEXP (link, 0));\n+\t  dep_t dep = DEP_LINK_DEP (link);\n+\t  ddg_node_ptr src_node = get_node_of_insn (g, DEP_PRO (dep));\n \n \t  if (!src_node)\n \t    continue;\n \n-      \t  add_forw_dep (dest_node->insn, link);\n-\t  create_ddg_dependence (g, src_node, dest_node,\n-\t\t\t\t INSN_DEPEND (src_node->insn));\n+      \t  add_forw_dep (link);\n+\t  create_ddg_dependence (g, src_node, dest_node, dep);\n \t}\n \n       /* If this insn modifies memory, add an edge to all insns that access"}, {"sha": "0ba9b95c25bf99b9678d300b4a2e91764a64ad27", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -3271,13 +3271,7 @@ This list is originally set up by the flow analysis pass; it is a null\n pointer until then.  Flow only adds links for those data dependencies\n which can be used for instruction combination.  For each insn, the flow\n analysis pass adds a link to insns which store into registers values\n-that are used for the first time in this insn.  The instruction\n-scheduling pass adds extra links so that every dependence will be\n-represented.  Links represent data dependencies, antidependencies and\n-output dependencies; the machine mode of the link distinguishes these\n-three types: antidependencies have mode @code{REG_DEP_ANTI}, output\n-dependencies have mode @code{REG_DEP_OUTPUT}, and data dependencies have\n-mode @code{VOIDmode}.\n+that are used for the first time in this insn.\n \n The @code{REG_NOTES} field of an insn is a chain similar to the\n @code{LOG_LINKS} field but it includes @code{expr_list} expressions in\n@@ -3500,13 +3494,18 @@ they simply have mode @code{VOIDmode}, and are printed without any\n descriptive text.\n \n @table @code\n-@findex REG_DEP_ANTI\n-@item REG_DEP_ANTI\n-This indicates an anti dependence (a write after read dependence).\n+@findex REG_DEP_TRUE\n+@item REG_DEP_TRUE\n+This indicates a true dependence (a read after write dependence).\n \n @findex REG_DEP_OUTPUT\n @item REG_DEP_OUTPUT\n This indicates an output dependence (a write after write dependence).\n+\n+@findex REG_DEP_ANTI\n+@item REG_DEP_ANTI\n+This indicates an anti dependence (a write after read dependence).\n+\n @end table\n \n These notes describe information gathered from gcov profile data.  They"}, {"sha": "7c2eca5df09120bfbae01a9c2f0478fe5a5a0b6a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -6112,14 +6112,13 @@ correspondingly processor cycle on which the previous insn has been\n issued and the current processor cycle.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (rtx @var{insn1}, rtx @var{insn2}, rtx @var{dep_link}, int @var{dep_cost}, int @var{distance})\n+@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct dep_def *@var{_dep}, int @var{cost}, int @var{distance})\n This hook is used to define which dependences are considered costly by\n the target, so costly that it is not advisable to schedule the insns that\n are involved in the dependence too close to one another.  The parameters\n-to this hook are as follows:  The second parameter @var{insn2} is dependent\n-upon the first parameter @var{insn1}.  The dependence between @var{insn1}\n-and @var{insn2} is represented by the third parameter @var{dep_link}.  The\n-fourth parameter @var{cost} is the cost of the dependence, and the fifth\n+to this hook are as follows:  The first parameter @var{_dep} is the dependence\n+being evaluated.  The second parameter @var{cost} is the cost of the\n+dependence, and the third\n parameter @var{distance} is the distance in cycles between the two insns.\n The hook returns @code{true} if considering the distance between the two\n insns the dependence between them is considered costly by the target,\n@@ -6134,14 +6133,6 @@ closer to one another---i.e., closer than the dependence distance;  however,\n not in cases of \"costly dependences\", which this hooks allows to define.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST_2 (rtx @var{insn}, int @var{dep_type}, rtx @var{dep_insn}, int @var{cost})\n-This hook is a modified version of @samp{TARGET_SCHED_ADJUST_COST}.  Instead\n-of passing dependence as a second parameter, it passes a type of that\n-dependence.  This is useful to calculate cost of dependence between insns\n-not having the corresponding link.  If @samp{TARGET_SCHED_ADJUST_COST_2} is\n-defined it is used instead of @samp{TARGET_SCHED_ADJUST_COST}.\n-@end deftypefn\n-\n @deftypefn {Target Hook} void TARGET_SCHED_H_I_D_EXTENDED (void)\n This hook is called by the insn scheduler after emitting a new instruction to\n the instruction stream.  The hook notifies a target backend to extend its"}, {"sha": "87d7bd11910f623fecf1badbba4407214c827fc5", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 290, "deletions": 214, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -82,9 +82,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    compute_block_backward_dependences ().\n \n    Dependencies set up by memory references are treated in exactly the\n-   same way as other dependencies, by using LOG_LINKS backward\n-   dependences.  LOG_LINKS are translated into INSN_DEPEND forward\n-   dependences for the purpose of forward list scheduling.\n+   same way as other dependencies, by using insn backward dependences\n+   INSN_BACK_DEPS.  INSN_BACK_DEPS are translated into forward dependences\n+   INSN_FORW_DEPS the purpose of forward list scheduling.\n \n    Having optimized the critical path, we may have also unduly\n    extended the lifetimes of some registers.  If an operation requires\n@@ -251,8 +251,8 @@ static basic_block before_recovery;\n    sufficient time has passed to make them ready.  As time passes,\n    insns move from the \"Queued\" set to the \"Ready\" list.\n \n-   The \"Pending\" list (P) are the insns in the INSN_DEPEND of the unscheduled\n-   insns, i.e., those that are ready, queued, and pending.\n+   The \"Pending\" list (P) are the insns in the INSN_FORW_DEPS of the\n+   unscheduled insns, i.e., those that are ready, queued, and pending.\n    The \"Queued\" set (Q) is implemented by the variable `insn_queue'.\n    The \"Ready\" list (R) is implemented by the variables `ready' and\n    `n_ready'.\n@@ -489,7 +489,6 @@ haifa_classify_insn (rtx insn)\n \n /* Forward declarations.  */\n \n-HAIFA_INLINE static int insn_cost1 (rtx, enum reg_note, rtx, rtx);\n static int priority (rtx);\n static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx *, int);\n@@ -544,7 +543,6 @@ static rtx choose_ready (struct ready_list *);\n static void fix_inter_tick (rtx, rtx);\n static int fix_tick_ready (rtx);\n static void change_queue_index (rtx, int);\n-static void resolve_dep (rtx, rtx);\n \n /* The following functions are used to implement scheduling of data/control\n    speculative instructions.  */\n@@ -555,7 +553,7 @@ static void extend_global (rtx);\n static void extend_all (rtx);\n static void init_h_i_d (rtx);\n static void generate_recovery_code (rtx);\n-static void process_insn_depend_be_in_spec (rtx, rtx, ds_t);\n+static void process_insn_forw_deps_be_in_spec (deps_list_t, rtx, ds_t);\n static void begin_speculative_block (rtx);\n static void add_to_speculative_block (rtx);\n static dw_t dep_weak (ds_t);\n@@ -607,27 +605,15 @@ static struct sched_info current_sched_info_var;\n \n static rtx last_scheduled_insn;\n \n-/* Compute cost of executing INSN given the dependence LINK on the insn USED.\n-   This is the number of cycles between instruction issue and\n-   instruction results.  */\n+/* Cached cost of the instruction.  Use below function to get cost of the\n+   insn.  -1 here means that the field is not initialized.  */\n+#define INSN_COST(INSN)\t\t(h_i_d[INSN_UID (INSN)].cost)\n \n-HAIFA_INLINE int\n-insn_cost (rtx insn, rtx link, rtx used)\n-{\n-  return insn_cost1 (insn, used ? REG_NOTE_KIND (link) : REG_NOTE_MAX,\n-\t\t     link, used);\n-}\n-\n-/* Compute cost of executing INSN given the dependence on the insn USED.\n-   If LINK is not NULL, then its REG_NOTE_KIND is used as a dependence type.\n-   Otherwise, dependence between INSN and USED is assumed to be of type\n-   DEP_TYPE.  This function was introduced as a workaround for\n-   targetm.adjust_cost hook.\n+/* Compute cost of executing INSN.\n    This is the number of cycles between instruction issue and\n    instruction results.  */\n-\n-HAIFA_INLINE static int\n-insn_cost1 (rtx insn, enum reg_note dep_type, rtx link, rtx used)\n+HAIFA_INLINE int\n+insn_cost (rtx insn)\n {\n   int cost = INSN_COST (insn);\n \n@@ -652,9 +638,17 @@ insn_cost1 (rtx insn, enum reg_note dep_type, rtx link, rtx used)\n \t}\n     }\n \n-  /* In this case estimate cost without caring how insn is used.  */\n-  if (used == 0)\n-    return cost;\n+  return cost;\n+}\n+\n+/* Compute cost of dependence LINK.\n+   This is the number of cycles between instruction issue and\n+   instruction results.  */\n+int\n+dep_cost (dep_t link)\n+{\n+  rtx used = DEP_CON (link);\n+  int cost;\n \n   /* A USE insn should never require the value used to be computed.\n      This allows the computation of a function's result and parameter\n@@ -663,7 +657,10 @@ insn_cost1 (rtx insn, enum reg_note dep_type, rtx link, rtx used)\n     cost = 0;\n   else\n     {\n-      gcc_assert (!link || dep_type == REG_NOTE_KIND (link));\n+      rtx insn = DEP_PRO (link);\n+      enum reg_note dep_type = DEP_KIND (link);\n+\n+      cost = insn_cost (insn);\n \n       if (INSN_CODE (insn) >= 0)\n \t{\n@@ -680,13 +677,23 @@ insn_cost1 (rtx insn, enum reg_note dep_type, rtx link, rtx used)\n \t    cost = insn_latency (insn, used);\n \t}\n \n-      if (targetm.sched.adjust_cost_2)\n-\tcost = targetm.sched.adjust_cost_2 (used, (int) dep_type, insn, cost);\n-      else\n+      if (targetm.sched.adjust_cost != NULL)\n \t{\n-\t  gcc_assert (link);\n-\t  if (targetm.sched.adjust_cost)\n-\t    cost = targetm.sched.adjust_cost (used, link, insn, cost);\n+\t  /* This variable is used for backward compatibility with the\n+\t     targets.  */\n+\t  rtx dep_cost_rtx_link = alloc_INSN_LIST (NULL_RTX, NULL_RTX);\n+\n+\t  /* Make it self-cycled, so that if some tries to walk over this\n+\t     incomplete list he/she will be cought in an endless loop.  */\n+\t  XEXP (dep_cost_rtx_link, 1) = dep_cost_rtx_link;\n+\n+\t  /* Targets use only REG_NOTE_KIND of the link.  */\n+\t  PUT_REG_NOTE_KIND (dep_cost_rtx_link, DEP_KIND (link));\n+\n+\t  cost = targetm.sched.adjust_cost (used, dep_cost_rtx_link,\n+\t\t\t\t\t    insn, cost);\n+\n+\t  free_INSN_LIST_node (dep_cost_rtx_link);\n \t}\n \n       if (cost < 0)\n@@ -701,7 +708,7 @@ insn_cost1 (rtx insn, enum reg_note dep_type, rtx link, rtx used)\n static int\n priority (rtx insn)\n {\n-  rtx link;\n+  dep_link_t link;\n \n   if (! INSN_P (insn))\n     return 0;\n@@ -710,17 +717,22 @@ priority (rtx insn)\n     {\n       int this_priority = 0;\n \n-      if (INSN_DEPEND (insn) == 0)\n-\tthis_priority = insn_cost (insn, 0, 0);\n+      if (deps_list_empty_p (INSN_FORW_DEPS (insn)))\n+\t/* ??? We should set INSN_PRIORITY to insn_cost when and insn has\n+\t   some forward deps but all of them are ignored by\n+\t   contributes_to_priority hook.  At the moment we set priority of\n+\t   such insn to 0.  */\n+\tthis_priority = insn_cost (insn);\n       else\n \t{\n \t  rtx prev_first, twin;\n \t  basic_block rec;\n \n \t  /* For recovery check instructions we calculate priority slightly\n \t     different than that of normal instructions.  Instead of walking\n-\t     through INSN_DEPEND (check) list, we walk through INSN_DEPEND list\n-\t     of each instruction in the corresponding recovery block.  */ \n+\t     through INSN_FORW_DEPS (check) list, we walk through\n+\t     INSN_FORW_DEPS list of each instruction in the corresponding\n+\t     recovery block.  */ \n \n \t  rec = RECOVERY_BLOCK (insn);\n \t  if (!rec || rec == EXIT_BLOCK_PTR)\n@@ -736,15 +748,18 @@ priority (rtx insn)\n \n \t  do\n \t    {\n-\t      for (link = INSN_DEPEND (twin); link; link = XEXP (link, 1))\n+\t      FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (twin))\n \t\t{\n \t\t  rtx next;\n \t\t  int next_priority;\n-\t\t  \n-\t\t  next = XEXP (link, 0);\n-\t\t  \n+\t\t  dep_t dep = DEP_LINK_DEP (link);\n+\n+\t\t  next = DEP_CON (dep);\n+\n \t\t  if (BLOCK_FOR_INSN (next) != rec)\n \t\t    {\n+\t\t      int cost;\n+\n \t\t      /* Critical path is meaningful in block boundaries\n \t\t\t only.  */\n \t\t      if (! (*current_sched_info->contributes_to_priority)\n@@ -756,17 +771,23 @@ priority (rtx insn)\n \t\t\t     producers will more likely be scheduled, thus,\n \t\t\t     resolving the dependence.  */\n \t\t\t  || ((current_sched_info->flags & DO_SPECULATION)\n-\t\t\t      && (DEP_STATUS (link) & SPECULATIVE)\n+\t\t\t      && (DEP_STATUS (dep) & SPECULATIVE)\n \t\t\t      && !(spec_info->flags\n \t\t\t\t   & COUNT_SPEC_IN_CRITICAL_PATH)))\n \t\t\tcontinue;\n-\t\t      \n-\t\t      next_priority = insn_cost1 (insn,\n-\t\t\t\t\t\t  twin == insn ?\n-\t\t\t\t\t\t  REG_NOTE_KIND (link) :\n-\t\t\t\t\t\t  REG_DEP_ANTI,\n-\t\t\t\t\t\t  twin == insn ? link : 0,\n-\t\t\t\t\t\t  next) + priority (next);\n+\n+\t\t      if (twin == insn)\n+\t\t\tcost = dep_cost (dep);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  struct _dep _dep1, *dep1 = &_dep1;\n+\n+\t\t\t  init_dep (dep1, insn, next, REG_DEP_ANTI);\n+\n+\t\t\t  cost = dep_cost (dep1);\n+\t\t\t}\n+\n+\t\t      next_priority = cost + priority (next);\n \n \t\t      if (next_priority > this_priority)\n \t\t\tthis_priority = next_priority;\n@@ -803,8 +824,8 @@ rank_for_schedule (const void *x, const void *y)\n {\n   rtx tmp = *(const rtx *) y;\n   rtx tmp2 = *(const rtx *) x;\n-  rtx link;\n-  int tmp_class, tmp2_class, depend_count1, depend_count2;\n+  dep_link_t link1, link2;\n+  int tmp_class, tmp2_class;\n   int val, priority_val, weight_val, info_val;\n \n   /* The insn in a schedule group should be issued the first.  */\n@@ -858,18 +879,26 @@ rank_for_schedule (const void *x, const void *y)\n          2) Anti/Output dependent on last scheduled insn.\n          3) Independent of last scheduled insn, or has latency of one.\n          Choose the insn from the highest numbered class if different.  */\n-      link = find_insn_list (tmp, INSN_DEPEND (last_scheduled_insn));\n-      if (link == 0 || insn_cost (last_scheduled_insn, link, tmp) == 1)\n+      link1\n+\t= find_link_by_con_in_deps_list (INSN_FORW_DEPS (last_scheduled_insn),\n+\t\t\t\t\t tmp);\n+\n+      if (link1 == NULL || dep_cost (DEP_LINK_DEP (link1)) == 1)\n \ttmp_class = 3;\n-      else if (REG_NOTE_KIND (link) == 0)\t/* Data dependence.  */\n+      else if (/* Data dependence.  */\n+\t       DEP_LINK_KIND (link1) == REG_DEP_TRUE)\n \ttmp_class = 1;\n       else\n \ttmp_class = 2;\n \n-      link = find_insn_list (tmp2, INSN_DEPEND (last_scheduled_insn));\n-      if (link == 0 || insn_cost (last_scheduled_insn, link, tmp2) == 1)\n+      link2\n+\t= find_link_by_con_in_deps_list (INSN_FORW_DEPS (last_scheduled_insn),\n+\t\t\t\t\t tmp2);\n+\n+      if (link2 == NULL || dep_cost (DEP_LINK_DEP (link2))  == 1)\n \ttmp2_class = 3;\n-      else if (REG_NOTE_KIND (link) == 0)\t/* Data dependence.  */\n+      else if (/* Data dependence.  */\n+\t       DEP_LINK_KIND (link2) == REG_DEP_TRUE)\n \ttmp2_class = 1;\n       else\n \ttmp2_class = 2;\n@@ -881,17 +910,22 @@ rank_for_schedule (const void *x, const void *y)\n   /* Prefer the insn which has more later insns that depend on it.\n      This gives the scheduler more freedom when scheduling later\n      instructions at the expense of added register pressure.  */\n-  depend_count1 = 0;\n-  for (link = INSN_DEPEND (tmp); link; link = XEXP (link, 1))\n-    depend_count1++;\n \n-  depend_count2 = 0;\n-  for (link = INSN_DEPEND (tmp2); link; link = XEXP (link, 1))\n-    depend_count2++;\n+  link1 = DEPS_LIST_FIRST (INSN_FORW_DEPS (tmp));\n+  link2 = DEPS_LIST_FIRST (INSN_FORW_DEPS (tmp2));\n \n-  val = depend_count2 - depend_count1;\n-  if (val)\n-    return val;\n+  while (link1 != NULL && link2 != NULL)\n+    {\n+      link1 = DEP_LINK_NEXT (link1);\n+      link2 = DEP_LINK_NEXT (link2);\n+    }\n+\n+  if (link1 != NULL && link2 == NULL)\n+    /* TMP (Y) has more insns that depend on it.  */\n+    return -1;\n+  if (link1 == NULL && link2 != NULL)\n+    /* TMP2 (X) has more insns that depend on it.  */\n+    return 1;\n \n   /* If insns are equally good, sort by INSN_LUID (original insn order),\n      so that we make the sort stable.  This minimizes instruction movement,\n@@ -1127,7 +1161,7 @@ static int last_clock_var;\n static int\n schedule_insn (rtx insn)\n {\n-  rtx link;\n+  dep_link_t link;\n   int advance = 0;\n \n   if (sched_verbose >= 1)\n@@ -1147,18 +1181,16 @@ schedule_insn (rtx insn)\n \n   /* Scheduling instruction should have all its dependencies resolved and\n      should have been removed from the ready list.  */\n-  gcc_assert (INSN_DEP_COUNT (insn) == 0);\n-  gcc_assert (!LOG_LINKS (insn));\n-  gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n+  gcc_assert (INSN_DEP_COUNT (insn) == 0\n+\t      && deps_list_empty_p (INSN_BACK_DEPS (insn)));\n+  free_deps_list (INSN_BACK_DEPS (insn));\n+\n+  /* Now we can free INSN_RESOLVED_BACK_DEPS list.  */\n+  delete_deps_list (INSN_RESOLVED_BACK_DEPS (insn));\n \n+  gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n   QUEUE_INDEX (insn) = QUEUE_SCHEDULED;\n-  \n-  /* Now we can free RESOLVED_DEPS list.  */\n-  if (current_sched_info->flags & USE_DEPS_LIST)\n-    free_DEPS_LIST_list (&RESOLVED_DEPS (insn));\n-  else\n-    free_INSN_LIST_list (&RESOLVED_DEPS (insn));\n-    \n+\n   gcc_assert (INSN_TICK (insn) >= MIN_TICK);\n   if (INSN_TICK (insn) > clock_var)\n     /* INSN has been prematurely moved from the queue to the ready list.\n@@ -1170,11 +1202,19 @@ schedule_insn (rtx insn)\n   INSN_TICK (insn) = clock_var;\n \n   /* Update dependent instructions.  */\n-  for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (insn))\n     {\n-      rtx next = XEXP (link, 0);\n+      rtx next = DEP_LINK_CON (link);\n+\n+      /* Resolve the dependence between INSN and NEXT.  */\n+\n+      INSN_DEP_COUNT (next)--;\n \n-      resolve_dep (next, insn);\n+      move_dep_link (DEP_NODE_BACK (DEP_LINK_NODE (link)),\n+\t\t\tINSN_RESOLVED_BACK_DEPS (next));\n+\n+      gcc_assert ((INSN_DEP_COUNT (next) == 0)\n+\t\t  == deps_list_empty_p (INSN_BACK_DEPS (next)));\n \n       if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t{\n@@ -1191,7 +1231,7 @@ schedule_insn (rtx insn)\n \t/* Check always has only one forward dependence (to the first insn in\n \t   the recovery block), therefore, this will be executed only once.  */\n \t{\n-\t  gcc_assert (XEXP (link, 1) == 0);\n+\t  gcc_assert (DEP_LINK_NEXT (link) == NULL);\n \t  fix_recovery_deps (RECOVERY_BLOCK (insn));\n \t}\n     }\n@@ -1525,17 +1565,22 @@ ok_for_early_queue_removal (rtx insn)\n \t{\n \t  for ( ; prev_insn; prev_insn = PREV_INSN (prev_insn))\n \t    {\n-\t      rtx dep_link = 0;\n-\t      int dep_cost;\n+\t      int cost;\n \n \t      if (!NOTE_P (prev_insn))\n \t\t{\n-\t\t  dep_link = find_insn_list (insn, INSN_DEPEND (prev_insn));\n+\t\t  dep_link_t dep_link;\n+\n+\t\t  dep_link = (find_link_by_con_in_deps_list\n+\t\t\t      (INSN_FORW_DEPS (prev_insn), insn));\n+\n \t\t  if (dep_link)\n \t\t    {\n-\t\t      dep_cost = insn_cost (prev_insn, dep_link, insn) ;\n-\t\t      if (targetm.sched.is_costly_dependence (prev_insn, insn, \n-\t\t\t\tdep_link, dep_cost, \n+\t\t      dep_t dep = DEP_LINK_DEP (dep_link);\n+\n+\t\t      cost = dep_cost (dep);\n+\n+\t\t      if (targetm.sched.is_costly_dependence (dep, cost,\n \t\t\t\tflag_sched_stalled_insns_dep - n_cycles))\n \t\t\treturn false;\n \t\t    }\n@@ -2705,7 +2750,7 @@ fix_inter_tick (rtx head, rtx tail)\n       if (INSN_P (head))\n \t{\n \t  int tick;\n-\t  rtx link;\n+\t  dep_link_t link;\n                   \n \t  tick = INSN_TICK (head);\n \t  gcc_assert (tick >= MIN_TICK);\n@@ -2722,11 +2767,11 @@ fix_inter_tick (rtx head, rtx tail)\n \t      INSN_TICK (head) = tick;\t\t \n \t    }\n \t  \n-\t  for (link = INSN_DEPEND (head); link; link = XEXP (link, 1))\n+\t  FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (head))\n \t    {\n \t      rtx next;\n \t      \n-\t      next = XEXP (link, 0);\n+\t      next = DEP_LINK_CON (link);\n \t      tick = INSN_TICK (next);\n \n \t      if (tick != INVALID_TICK\n@@ -2764,7 +2809,7 @@ int\n try_ready (rtx next)\n {  \n   ds_t old_ts, *ts;\n-  rtx link;\n+  dep_link_t link;\n \n   ts = &TODO_SPEC (next);\n   old_ts = *ts;\n@@ -2775,27 +2820,34 @@ try_ready (rtx next)\n   \n   if (!(current_sched_info->flags & DO_SPECULATION))\n     {\n-      if (!LOG_LINKS (next))\n+      if (deps_list_empty_p (INSN_BACK_DEPS (next)))\n         *ts &= ~HARD_DEP;\n     }\n   else\n     {\n-      *ts &= ~SPECULATIVE & ~HARD_DEP;          \n-  \n-      link = LOG_LINKS (next);\n-      if (link)\n+      *ts &= ~SPECULATIVE & ~HARD_DEP;\n+\n+      link = DEPS_LIST_FIRST (INSN_BACK_DEPS (next));\n+\n+      if (link != NULL)\n         {\n-          /* LOG_LINKS are maintained sorted. \n+\t  ds_t ds = DEP_LINK_STATUS (link) & SPECULATIVE;\n+\n+          /* Backward dependencies of the insn are maintained sorted. \n              So if DEP_STATUS of the first dep is SPECULATIVE,\n              than all other deps are speculative too.  */\n-          if (DEP_STATUS (link) & SPECULATIVE)          \n+          if (ds != 0)\n             {          \n               /* Now we've got NEXT with speculative deps only.\n                  1. Look at the deps to see what we have to do.\n                  2. Check if we can do 'todo'.  */\n-\t      *ts = DEP_STATUS (link) & SPECULATIVE;\n-              while ((link = XEXP (link, 1)))\n-\t\t*ts = ds_merge (*ts, DEP_STATUS (link) & SPECULATIVE);\n+\t      *ts = ds;\n+\n+              while ((link = DEP_LINK_NEXT (link)) != NULL)\n+\t\t{\n+\t\t  ds = DEP_LINK_STATUS (link) & SPECULATIVE;\n+\t\t  *ts = ds_merge (*ts, ds);\n+\t\t}\n \n \t      if (dep_weak (*ts) < spec_info->weakness_cutoff)\n \t\t/* Too few points.  */\n@@ -2805,25 +2857,25 @@ try_ready (rtx next)\n             *ts |= HARD_DEP;\n         }\n     }\n-  \n+\n   if (*ts & HARD_DEP)\n     gcc_assert (*ts == old_ts\n \t\t&& QUEUE_INDEX (next) == QUEUE_NOWHERE);\n   else if (current_sched_info->new_ready)\n-    *ts = current_sched_info->new_ready (next, *ts);  \n+    *ts = current_sched_info->new_ready (next, *ts);\n \n-  /* * if !(old_ts & SPECULATIVE) (e.g. HARD_DEP or 0), then insn might \n+  /* * if !(old_ts & SPECULATIVE) (e.g. HARD_DEP or 0), then insn might\n      have its original pattern or changed (speculative) one.  This is due\n      to changing ebb in region scheduling.\n      * But if (old_ts & SPECULATIVE), then we are pretty sure that insn\n      has speculative pattern.\n-     \n+\n      We can't assert (!(*ts & HARD_DEP) || *ts == old_ts) here because\n      control-speculative NEXT could have been discarded by sched-rgn.c\n      (the same case as when discarded by can_schedule_ready_p ()).  */\n-  \n+\n   if ((*ts & SPECULATIVE)\n-      /* If (old_ts == *ts), then (old_ts & SPECULATIVE) and we don't \n+      /* If (old_ts == *ts), then (old_ts & SPECULATIVE) and we don't\n \t need to change anything.  */\n       && *ts != old_ts)\n     {\n@@ -2920,33 +2972,34 @@ try_ready (rtx next)\n static int\n fix_tick_ready (rtx next)\n {\n-  rtx link;\n   int tick, delay;\n \n-  link = RESOLVED_DEPS (next);\n-      \n-  if (link)\n+  if (!deps_list_empty_p (INSN_RESOLVED_BACK_DEPS (next)))\n     {\n       int full_p;\n+      dep_link_t link;\n \n       tick = INSN_TICK (next);\n       /* if tick is not equal to INVALID_TICK, then update\n \t INSN_TICK of NEXT with the most recent resolved dependence\n \t cost.  Otherwise, recalculate from scratch.  */\n-      full_p = tick == INVALID_TICK;\n-      do\n-        {        \n-          rtx pro;\n+      full_p = (tick == INVALID_TICK);\n+\n+      FOR_EACH_DEP_LINK (link, INSN_RESOLVED_BACK_DEPS (next))\n+        {       \n+\t  dep_t dep = DEP_LINK_DEP (link);\n+          rtx pro = DEP_PRO (dep);\n           int tick1;\n               \n-          pro = XEXP (link, 0);\n \t  gcc_assert (INSN_TICK (pro) >= MIN_TICK);\n \n-          tick1 = INSN_TICK (pro) + insn_cost (pro, link, next);\n+          tick1 = INSN_TICK (pro) + dep_cost (dep);\n           if (tick1 > tick)\n             tick = tick1;\n+\n+\t  if (!full_p)\n+\t    break;\n         }\n-      while ((link = XEXP (link, 1)) && full_p);\n     }\n   else\n     tick = -1;\n@@ -3005,22 +3058,6 @@ change_queue_index (rtx next, int delay)\n     }\n }\n \n-/* INSN is being scheduled.  Resolve the dependence between INSN and NEXT.  */\n-static void\n-resolve_dep (rtx next, rtx insn)\n-{\n-  rtx dep;\n-\n-  INSN_DEP_COUNT (next)--;\n-  \n-  dep = remove_list_elem (insn, &LOG_LINKS (next));\n-  XEXP (dep, 1) = RESOLVED_DEPS (next);\n-  RESOLVED_DEPS (next) = dep;\n-  \n-  gcc_assert ((INSN_DEP_COUNT (next) != 0 || !LOG_LINKS (next))\n-\t      && (LOG_LINKS (next) || INSN_DEP_COUNT (next) == 0));\n-}\n-\n /* Extend H_I_D data.  */\n static void\n extend_h_i_d (void)\n@@ -3095,7 +3132,15 @@ init_h_i_d (rtx insn)\n   QUEUE_INDEX (insn) = QUEUE_NOWHERE;\n   INSN_TICK (insn) = INVALID_TICK;\n   INTER_TICK (insn) = INVALID_TICK;\n-  find_insn_reg_weight1 (insn);  \n+  find_insn_reg_weight1 (insn);\n+\n+  /* These two lists will be freed in schedule_insn ().  */\n+  INSN_BACK_DEPS (insn) = create_deps_list (false);\n+  INSN_RESOLVED_BACK_DEPS (insn) = create_deps_list (false);\n+\n+  /* This one should be allocated on the obstack because it should live till\n+     the scheduling ends.  */\n+  INSN_FORW_DEPS (insn) = create_deps_list (true);\n }\n \n /* Generates recovery code for INSN.  */\n@@ -3114,18 +3159,20 @@ generate_recovery_code (rtx insn)\n \n /* Helper function.\n    Tries to add speculative dependencies of type FS between instructions\n-   in LINK list and TWIN.  */\n+   in deps_list L and TWIN.  */\n static void\n-process_insn_depend_be_in_spec (rtx link, rtx twin, ds_t fs)\n+process_insn_forw_deps_be_in_spec (deps_list_t l, rtx twin, ds_t fs)\n {\n-  for (; link; link = XEXP (link, 1))\n+  dep_link_t link;\n+\n+  FOR_EACH_DEP_LINK (link, l)\n     {\n       ds_t ds;\n       rtx consumer;\n \n-      consumer = XEXP (link, 0);\n+      consumer = DEP_LINK_CON (link);\n \n-      ds = DEP_STATUS (link);\n+      ds = DEP_LINK_STATUS (link);\n \n       if (/* If we want to create speculative dep.  */\n \t  fs\n@@ -3152,7 +3199,7 @@ process_insn_depend_be_in_spec (rtx link, rtx twin, ds_t fs)\n \t    ds |= fs;\n \t}\n \n-      add_back_forw_dep (consumer, twin, REG_NOTE_KIND (link), ds);\n+      add_back_forw_dep (consumer, twin, DEP_LINK_KIND (link), ds);\n     }\n }\n \n@@ -3175,7 +3222,8 @@ static void\n add_to_speculative_block (rtx insn)\n {\n   ds_t ts;\n-  rtx link, twins = NULL;\n+  dep_link_t link;\n+  rtx twins = NULL;\n \n   ts = TODO_SPEC (insn);\n   gcc_assert (!(ts & ~BE_IN_SPEC));\n@@ -3191,34 +3239,37 @@ add_to_speculative_block (rtx insn)\n   DONE_SPEC (insn) |= ts;\n \n   /* First we convert all simple checks to branchy.  */\n-  for (link = LOG_LINKS (insn); link;)\n+  for (link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)); link != NULL;)\n     {\n-      rtx check;\n-\n-      check = XEXP (link, 0);\n+      rtx check = DEP_LINK_PRO (link);\n \n       if (IS_SPECULATION_SIMPLE_CHECK_P (check))\n \t{\n \t  create_check_block_twin (check, true);\n-\t  link = LOG_LINKS (insn);\n+\n+\t  /* Restart search.  */\n+\t  link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n \t}\n       else\n-\tlink = XEXP (link, 1);\n+\t/* Continue search.  */\n+\tlink = DEP_LINK_NEXT (link);\n     }\n \n   clear_priorities (insn);\n  \n   do\n     {\n-      rtx link, check, twin;\n+      dep_link_t link;\n+      rtx check, twin;\n       basic_block rec;\n \n-      link = LOG_LINKS (insn);\n-      gcc_assert (!(DEP_STATUS (link) & BEGIN_SPEC)\n-\t\t  && (DEP_STATUS (link) & BE_IN_SPEC)\n-\t\t  && (DEP_STATUS (link) & DEP_TYPES) == DEP_TRUE);\n+      link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n \n-      check = XEXP (link, 0);\n+      gcc_assert ((DEP_LINK_STATUS (link) & BEGIN_SPEC) == 0\n+\t\t  && (DEP_LINK_STATUS (link) & BE_IN_SPEC) != 0\n+\t\t  && (DEP_LINK_STATUS (link) & DEP_TYPES) == DEP_TRUE);\n+\n+      check = DEP_LINK_PRO (link);\n \n       gcc_assert (!IS_SPECULATION_CHECK_P (check) && !ORIG_PAT (check)\n \t\t  && QUEUE_INDEX (check) == QUEUE_NOWHERE);\n@@ -3228,7 +3279,9 @@ add_to_speculative_block (rtx insn)\n       twin = emit_insn_before (copy_rtx (PATTERN (insn)), BB_END (rec));\n       extend_global (twin);\n \n-      RESOLVED_DEPS (twin) = copy_DEPS_LIST_list (RESOLVED_DEPS (insn));\n+      copy_deps_list_change_con (INSN_RESOLVED_BACK_DEPS (twin),\n+\t\t\t\t INSN_RESOLVED_BACK_DEPS (insn),\n+\t\t\t\t twin);\n \n       if (sched_verbose && spec_info->dump)\n         /* INSN_BB (insn) isn't determined for twin insns yet.\n@@ -3246,10 +3299,11 @@ add_to_speculative_block (rtx insn)\n \t  \n \t  do\t    \t  \n \t    {  \n-\t      link = XEXP (link, 1);\n-\t      if (link)\n+\t      link = DEP_LINK_NEXT (link);\n+\n+\t      if (link != NULL)\n \t\t{\n-\t\t  check = XEXP (link, 0);\n+\t\t  check = DEP_LINK_PRO (link);\n \t\t  if (BLOCK_FOR_INSN (check) == rec)\n \t\t    break;\n \t\t}\n@@ -3258,27 +3312,31 @@ add_to_speculative_block (rtx insn)\n \t    }\n \t  while (1);\n \t}\n-      while (link);\n+      while (link != NULL);\n \n-      process_insn_depend_be_in_spec (INSN_DEPEND (insn), twin, ts);\n+      process_insn_forw_deps_be_in_spec (INSN_FORW_DEPS (insn), twin, ts);\n \n-      for (link = LOG_LINKS (insn); link;)\n+      /* Remove all dependencies between INSN and insns in REC.  */\n+      for (link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)); link != NULL;)\n \t{\n-\t  check = XEXP (link, 0);\n+\t  check = DEP_LINK_PRO (link);\n \n \t  if (BLOCK_FOR_INSN (check) == rec)\n \t    {\n-\t      delete_back_forw_dep (insn, check);\n-\t      link = LOG_LINKS (insn);\n+\t      delete_back_forw_dep (link);\n+\n+\t      /* Restart search.  */\n+\t      link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n \t    }\n \t  else\n-\t    link = XEXP (link, 1);\n+\t    /* Continue search.  */\n+\t    link = DEP_LINK_NEXT (link);\n \t}\n     }\n-  while (LOG_LINKS (insn));\n+  while (!deps_list_empty_p (INSN_BACK_DEPS (insn)));\n \n-  /* We can't add the dependence between insn and twin earlier because\n-     that would make twin appear in the INSN_DEPEND (insn).  */\n+  /* We couldn't have added the dependencies between INSN and TWINS earlier\n+     because that would make TWINS appear in the INSN_BACK_DEPS (INSN).  */\n   while (twins)\n     {\n       rtx twin;\n@@ -3471,7 +3529,8 @@ static void\n create_check_block_twin (rtx insn, bool mutate_p)\n {\n   basic_block rec;\n-  rtx label, check, twin, link;\n+  rtx label, check, twin;\n+  dep_link_t link;\n   ds_t fs;\n \n   gcc_assert (ORIG_PAT (insn)\n@@ -3521,14 +3580,14 @@ create_check_block_twin (rtx insn, bool mutate_p)\n      in the recovery block).  */\n   if (rec != EXIT_BLOCK_PTR)\n     {\n-      rtx link;\n-\n-      for (link = RESOLVED_DEPS (insn); link; link = XEXP (link, 1))    \n-\tif (DEP_STATUS (link) & DEP_OUTPUT)\n+      FOR_EACH_DEP_LINK (link, INSN_RESOLVED_BACK_DEPS (insn))\n+\tif ((DEP_LINK_STATUS (link) & DEP_OUTPUT) != 0)\n \t  {\n-\t    RESOLVED_DEPS (check) = \n-\t      alloc_DEPS_LIST (XEXP (link, 0), RESOLVED_DEPS (check), DEP_TRUE);\n-\t    PUT_REG_NOTE_KIND (RESOLVED_DEPS (check), REG_DEP_TRUE);\n+\t    struct _dep _dep, *dep = &_dep;\n+\n+\t    init_dep (dep, DEP_LINK_PRO (link), check, REG_DEP_TRUE);\n+\n+\t    add_back_dep_to_deps_list (INSN_RESOLVED_BACK_DEPS (check), dep);\n \t  }\n \n       twin = emit_insn_after (ORIG_PAT (insn), BB_END (rec));\n@@ -3549,7 +3608,9 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t (TRUE | OUTPUT).  */\n     }\n \n-  RESOLVED_DEPS (twin) = copy_DEPS_LIST_list (RESOLVED_DEPS (insn));  \n+  copy_deps_list_change_con (INSN_RESOLVED_BACK_DEPS (twin),\n+\t\t\t     INSN_RESOLVED_BACK_DEPS (insn),\n+\t\t\t     twin);\n \n   if (rec != EXIT_BLOCK_PTR)\n     /* In case of branchy check, fix CFG.  */\n@@ -3612,8 +3673,10 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n   /* Move backward dependences from INSN to CHECK and \n      move forward dependences from INSN to TWIN.  */\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n     {\n+      rtx pro = DEP_LINK_PRO (link);\n+      enum reg_note dk = DEP_LINK_KIND (link);\n       ds_t ds;\n \n       /* If BEGIN_DATA: [insn ~~TRUE~~> producer]:\n@@ -3631,7 +3694,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t twin  ~~TRUE~~> producer\n \t twin  --ANTI--> check  */\t      \t  \n \n-      ds = DEP_STATUS (link);\n+      ds = DEP_LINK_STATUS (link);\n \n       if (ds & BEGIN_SPEC)\n \t{\n@@ -3641,24 +3704,27 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n       if (rec != EXIT_BLOCK_PTR)\n \t{\n-\t  add_back_forw_dep (check, XEXP (link, 0), REG_NOTE_KIND (link), ds);\n-\t  add_back_forw_dep (twin, XEXP (link, 0), REG_NOTE_KIND (link), ds);\n+\t  add_back_forw_dep (check, pro, dk, ds);\n+\t  add_back_forw_dep (twin, pro, dk, ds);\n \t}    \n       else\n-\tadd_back_forw_dep (check, XEXP (link, 0), REG_NOTE_KIND (link), ds);\n+\tadd_back_forw_dep (check, pro, dk, ds);\n     }\n \n-  for (link = LOG_LINKS (insn); link;)\n-    if ((DEP_STATUS (link) & BEGIN_SPEC)\n+  for (link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)); link != NULL;)\n+    if ((DEP_LINK_STATUS (link) & BEGIN_SPEC)\n \t|| mutate_p)\n       /* We can delete this dep only if we totally overcome it with\n \t BEGIN_SPECULATION.  */\n       {\n-        delete_back_forw_dep (insn, XEXP (link, 0));\n-        link = LOG_LINKS (insn);\n+        delete_back_forw_dep (link);\n+\n+\t/* Restart search.  */\n+        link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n       }\n     else\n-      link = XEXP (link, 1);    \n+      /* Continue search.  */\n+      link = DEP_LINK_NEXT (link);    \n \n   fs = 0;\n \n@@ -3683,7 +3749,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     CHECK_SPEC (check) = CHECK_SPEC (insn);\n \n   /* Future speculations: call the helper.  */\n-  process_insn_depend_be_in_spec (INSN_DEPEND (insn), twin, fs);\n+  process_insn_forw_deps_be_in_spec (INSN_FORW_DEPS (insn), twin, fs);\n \n   if (rec != EXIT_BLOCK_PTR)\n     {\n@@ -3698,12 +3764,19 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t}\n       else\n \t{\n+\t  dep_link_t link;\n+\n \t  if (spec_info->dump)    \n \t    fprintf (spec_info->dump, \";;\\t\\tRemoved simple check : %s\\n\",\n \t\t     (*current_sched_info->print_insn) (insn, 0));\n \n-\t  for (link = INSN_DEPEND (insn); link; link = INSN_DEPEND (insn))\n-\t    delete_back_forw_dep (XEXP (link, 0), insn);\n+\t  /* Remove all forward dependencies of the INSN.  */\n+\t  link = DEPS_LIST_FIRST (INSN_FORW_DEPS (insn));\n+\t  while (link != NULL)\n+\t    {\n+\t      delete_back_forw_dep (link);\n+\t      link = DEPS_LIST_FIRST (INSN_FORW_DEPS (insn));\n+\t    }\n \n \t  if (QUEUE_INDEX (insn) != QUEUE_NOWHERE)\n \t    try_ready (check);\n@@ -3731,8 +3804,10 @@ create_check_block_twin (rtx insn, bool mutate_p)\n static void\n fix_recovery_deps (basic_block rec)\n {\n-  rtx note, insn, link, jump, ready_list = 0;\n+  dep_link_t link;\n+  rtx note, insn, jump, ready_list = 0;\n   bitmap_head in_ready;\n+  rtx link1;\n \n   bitmap_initialize (&in_ready, 0);\n   \n@@ -3745,29 +3820,31 @@ fix_recovery_deps (basic_block rec)\n \n   do\n     {    \n-      for (link = INSN_DEPEND (insn); link;)\n+      for (link = DEPS_LIST_FIRST (INSN_FORW_DEPS (insn)); link != NULL;)\n \t{\n \t  rtx consumer;\n \n-\t  consumer = XEXP (link, 0);\n+\t  consumer = DEP_LINK_CON (link);\n \n \t  if (BLOCK_FOR_INSN (consumer) != rec)\n \t    {\n-\t      delete_back_forw_dep (consumer, insn);\n+\t      delete_back_forw_dep (link);\n \n \t      if (!bitmap_bit_p (&in_ready, INSN_LUID (consumer)))\n \t\t{\n \t\t  ready_list = alloc_INSN_LIST (consumer, ready_list);\n \t\t  bitmap_set_bit (&in_ready, INSN_LUID (consumer));\n \t\t}\n-\t      \n-\t      link = INSN_DEPEND (insn);\n+\n+\t      /* Restart search.  */\n+\t      link = DEPS_LIST_FIRST (INSN_FORW_DEPS (insn));\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert ((DEP_STATUS (link) & DEP_TYPES) == DEP_TRUE);\n+\t      gcc_assert ((DEP_LINK_STATUS (link) & DEP_TYPES) == DEP_TRUE);\n \n-\t      link = XEXP (link, 1);\n+\t      /* Continue search.  */\n+\t      link = DEP_LINK_NEXT (link);\n \t    }\n \t}\n       \n@@ -3778,8 +3855,8 @@ fix_recovery_deps (basic_block rec)\n   bitmap_clear (&in_ready);\n \n   /* Try to add instructions to the ready or queue list.  */\n-  for (link = ready_list; link; link = XEXP (link, 1))\n-    try_ready (XEXP (link, 0));\n+  for (link1 = ready_list; link1; link1 = XEXP (link1, 1))\n+    try_ready (XEXP (link1, 0));\n   free_INSN_LIST_list (&ready_list);\n \n   /* Fixing jump's dependences.  */\n@@ -4209,13 +4286,12 @@ sched_remove_insn (rtx insn)\n static void\n clear_priorities (rtx insn)\n {\n-  rtx link;\n+  dep_link_t link;\n \n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n     {\n-      rtx pro;\n+      rtx pro = DEP_LINK_PRO (link);\n \n-      pro = XEXP (link, 0);\n       if (INSN_PRIORITY_KNOWN (pro))\n \t{\n \t  INSN_PRIORITY_KNOWN (pro) = 0;\n@@ -4229,13 +4305,12 @@ clear_priorities (rtx insn)\n static void\n calc_priorities (rtx insn)\n {\n-  rtx link;\n+  dep_link_t link;\n \n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n     {\n-      rtx pro;\n+      rtx pro = DEP_LINK_PRO (link);\n \n-      pro = XEXP (link, 0);\n       if (!INSN_PRIORITY_KNOWN (pro))\n \t{\n \t  priority (pro);\n@@ -4256,11 +4331,12 @@ add_jump_dependencies (rtx insn, rtx jump)\n       if (insn == jump)\n \tbreak;\n       \n-      if (!INSN_DEPEND (insn))\t    \n+      if (deps_list_empty_p (INSN_FORW_DEPS (insn)))\n \tadd_back_forw_dep (jump, insn, REG_DEP_ANTI, DEP_ANTI);\n     }\n   while (1);\n-  gcc_assert (LOG_LINKS (jump));\n+\n+  gcc_assert (!deps_list_empty_p (INSN_BACK_DEPS (jump)));\n }\n \n /* Return the NOTE_INSN_BASIC_BLOCK of BB.  */"}, {"sha": "ff4ad8fa652958ea1f989c2085feeb401c8a8dcf", "filename": "gcc/lists.c", "status": "modified", "additions": 4, "deletions": 80, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -28,7 +28,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n \n static void free_list (rtx *, rtx *);\n-static void free_DEPS_LIST_node (rtx);\n \n /* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */\n \n@@ -38,10 +37,6 @@ static GTY ((deletable)) rtx unused_insn_list;\n /* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n static GTY ((deletable)) rtx unused_expr_list;\n \n-/* An DEPS_LIST containing all DEPS_LISTs allocated but currently unused.  */\n-static GTY ((deletable)) rtx unused_deps_list;\n-\n-\n /* This function will free an entire list of either EXPR_LIST, INSN_LIST\n    or DEPS_LIST nodes.  This is to be used only on lists that consist\n    exclusively of nodes of one type only.  This is only called by\n@@ -54,17 +49,13 @@ free_list (rtx *listp, rtx *unused_listp)\n   prev_link = *listp;\n   link = XEXP (prev_link, 1);\n \n-  gcc_assert ((unused_listp != &unused_insn_list\n-\t       || GET_CODE (prev_link) == INSN_LIST)\n-\t      && (unused_listp != &unused_deps_list\n-\t\t  || GET_CODE (prev_link) == DEPS_LIST));\n+  gcc_assert (unused_listp != &unused_insn_list\n+\t      || GET_CODE (prev_link) == INSN_LIST);\n   \n   while (link)\n     {\n-      gcc_assert ((unused_listp != &unused_insn_list\n-\t\t   || GET_CODE (prev_link) == INSN_LIST)\n-\t\t  && (unused_listp != &unused_deps_list\n-\t\t      || GET_CODE (prev_link) == DEPS_LIST));\n+      gcc_assert (unused_listp != &unused_insn_list\n+\t\t  || GET_CODE (prev_link) == INSN_LIST);\n   \n       prev_link = link;\n       link = XEXP (link, 1);\n@@ -155,31 +146,6 @@ alloc_EXPR_LIST (int kind, rtx val, rtx next)\n   return r;\n }\n \n-/* This call is used in place of a gen_rtx_DEPS_LIST.  If there is a cached\n-   node available, we'll use it, otherwise a call to gen_rtx_DEPS_LIST\n-   is made.  */\n-rtx\n-alloc_DEPS_LIST (rtx val, rtx next, int ds)\n-{\n-  rtx r;\n-\n-  if (unused_deps_list)\n-    {\n-      r = unused_deps_list;\n-      unused_deps_list = XEXP (r, 1);\n-      XEXP (r, 0) = val;\n-      XEXP (r, 1) = next;\n-      XINT (r, 2) = ds;\n-      PUT_REG_NOTE_KIND (r, VOIDmode);\n-\n-      gcc_assert (GET_CODE (r) == DEPS_LIST);\n-    }\n-  else\n-    r = gen_rtx_DEPS_LIST (VOIDmode, val, next, ds);\n-\n-  return r;\n-}\n-\n /* This function will free up an entire list of EXPR_LIST nodes.  */\n void\n free_EXPR_LIST_list (rtx *listp)\n@@ -198,15 +164,6 @@ free_INSN_LIST_list (rtx *listp)\n   free_list (listp, &unused_insn_list);\n }\n \n-/* This function will free up an entire list of DEPS_LIST nodes.  */\n-void\n-free_DEPS_LIST_list (rtx *listp)\n-{\n-  if (*listp == 0)\n-    return;\n-  free_list (listp, &unused_deps_list);\n-}\n-\n /* This function will free up an individual EXPR_LIST node.  */\n void\n free_EXPR_LIST_node (rtx ptr)\n@@ -224,23 +181,6 @@ free_INSN_LIST_node (rtx ptr)\n   unused_insn_list = ptr;\n }\n \n-/* This function will free up an individual DEPS_LIST node.  */\n-static void\n-free_DEPS_LIST_node (rtx ptr)\n-{\n-  gcc_assert (GET_CODE (ptr) == DEPS_LIST);\n-  XEXP (ptr, 1) = unused_deps_list;\n-  unused_deps_list = ptr;\n-}\n-\n-/* Remove and free corresponding to ELEM node in the DEPS_LIST pointed to\n-   by LISTP.  */\n-void\n-remove_free_DEPS_LIST_elem (rtx elem, rtx *listp)\n-{\n-  free_DEPS_LIST_node (remove_list_elem (elem, listp));\n-}\n-\n /* Remove and free corresponding to ELEM node in the INSN_LIST pointed to\n    by LISTP.  */\n void\n@@ -249,20 +189,4 @@ remove_free_INSN_LIST_elem (rtx elem, rtx *listp)\n   free_INSN_LIST_node (remove_list_elem (elem, listp));\n }\n \n-/* Create and return a copy of the DEPS_LIST LIST.  */\n-rtx\n-copy_DEPS_LIST_list (rtx list)\n-{\n-  rtx res = NULL_RTX, *resp = &res;\n-\n-  while (list)\n-    {\n-      *resp = alloc_DEPS_LIST (XEXP (list, 0), 0, XINT (list, 2));\n-      PUT_REG_NOTE_KIND (*resp, REG_NOTE_KIND (list));\n-      resp = &XEXP (*resp, 1);\n-      list = XEXP (list, 1);\n-    }\n-  return res;\n-}\n-\n #include \"gt-lists.h\""}, {"sha": "096b2fb651785b50123e4820fbbb2bca44706124", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -26,10 +26,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Shorthand.  */\n #define REG_NOTE(NAME) DEF_REG_NOTE (REG_##NAME)\n \n-/* REG_DEP_TRUE is used in LOG_LINKS to represent a read-after-write\n-   dependency (i.e. a true data dependency).  This is here, not\n-   grouped with REG_DEP_ANTI and REG_DEP_OUTPUT, because some passes\n-   use a literal 0 for it.  */\n+/* REG_DEP_TRUE is used in scheduler dependencies lists to represent a\n+   read-after-write dependency (i.e. a true data dependency).  This is\n+   here, not grouped with REG_DEP_ANTI and REG_DEP_OUTPUT, because some\n+   passes use a literal 0 for it.  */\n REG_NOTE (DEP_TRUE)\n \n /* The value in REG dies in this insn (i.e., it is not needed past\n@@ -97,8 +97,9 @@ REG_NOTE (CC_USER)\n    This note is an INSN_LIST.  */\n REG_NOTE (LABEL)\n \n-/* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n-   write-after-read and write-after-write dependencies respectively.  */\n+/* REG_DEP_OUTPUT and REG_DEP_ANTI are used in scheduler dependencies lists\n+   to represent write-after-write and write-after-read dependencies\n+   respectively.  */\n REG_NOTE (DEP_OUTPUT)\n REG_NOTE (DEP_ANTI)\n "}, {"sha": "7a04d88735cb2a5b1c10ab78c2e7879a8b935a4d", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -93,11 +93,6 @@ DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", RTX_EXTRA)\n    The insns are represented in print by their uids.  */\n DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", RTX_EXTRA)\n \n-/* a linked list of dependencies. \n-   The insns are represented in print by their uids. \n-   Operand 2 is the status of a dependence (see sched-int.h for more).  */\n-DEF_RTL_EXPR(DEPS_LIST, \"deps_list\", \"uei\", RTX_EXTRA)\n-\n /* SEQUENCE appears in the result of a `gen_...' function\n    for a DEFINE_EXPAND that wants to make several insns.\n    Its elements are the bodies of the insns that should be made."}, {"sha": "5cf87b8427d7f326e2a98ac374f1f2a28ff2256c", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -1751,12 +1751,8 @@ void free_EXPR_LIST_node\t\t(rtx);\n void free_INSN_LIST_node\t\t(rtx);\n rtx alloc_INSN_LIST\t\t\t(rtx, rtx);\n rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n-void free_DEPS_LIST_list (rtx *);\n-rtx alloc_DEPS_LIST (rtx, rtx, int);\n-void remove_free_DEPS_LIST_elem (rtx, rtx *);\n void remove_free_INSN_LIST_elem (rtx, rtx *);\n rtx remove_list_elem (rtx, rtx *);\n-rtx copy_DEPS_LIST_list (rtx);\n \n /* regclass.c */\n "}, {"sha": "6de5296ecde93032a2cb4b25dbc6204f8f156a56", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 506, "deletions": 104, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -44,6 +44,365 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cselib.h\"\n #include \"df.h\"\n \n+#ifdef ENABLE_CHECKING\n+#define CHECK (true)\n+#else\n+#define CHECK (false)\n+#endif\n+\n+/* Return the major type present in the DS.  */\n+enum reg_note\n+ds_to_dk (ds_t ds)\n+{\n+  if (ds & DEP_TRUE)\n+    return REG_DEP_TRUE;\n+\n+  if (ds & DEP_OUTPUT)\n+    return REG_DEP_OUTPUT;\n+\n+  gcc_assert (ds & DEP_ANTI);\n+\n+  return REG_DEP_ANTI;\n+}\n+\n+/* Return equivalent dep_status.  */\n+ds_t\n+dk_to_ds (enum reg_note dk)\n+{\n+  switch (dk)\n+    {\n+    case REG_DEP_TRUE:\n+      return DEP_TRUE;\n+\n+    case REG_DEP_OUTPUT:\n+      return DEP_OUTPUT;\n+\n+    default:\n+      gcc_assert (dk == REG_DEP_ANTI);\n+      return DEP_ANTI;\n+    }\n+}\n+\n+/* Functions to operate with dependence information container - dep_t.  */\n+\n+/* Init DEP with the arguments.  */\n+static void\n+init_dep_1 (dep_t dep, rtx pro, rtx con, enum reg_note kind, ds_t ds)\n+{\n+  DEP_PRO (dep) = pro;\n+  DEP_CON (dep) = con;\n+  DEP_KIND (dep) = kind;\n+  DEP_STATUS (dep) = ds;\n+}\n+\n+/* Init DEP with the arguments.\n+   While most of the scheduler (including targets) only need the major type\n+   of the dependency, it is convinient to hide full dep_status from them.  */\n+void\n+init_dep (dep_t dep, rtx pro, rtx con, enum reg_note kind)\n+{\n+  ds_t ds;\n+\n+  if ((current_sched_info->flags & USE_DEPS_LIST) != 0)\n+    ds = dk_to_ds (kind);\n+  else\n+    ds = -1;\n+\n+  init_dep_1 (dep, pro, con, kind, ds);\n+}\n+\n+/* Make a copy of FROM in TO.  */\n+static void\n+copy_dep (dep_t to, dep_t from)\n+{\n+  memcpy (to, from, sizeof (*to));\n+}\n+\n+/* Functions to operate with a single link from the dependencies lists -\n+   dep_link_t.  */\n+\n+/* Return true if dep_link L is consistent.  */\n+static bool\n+dep_link_consistent_p (dep_link_t l)\n+{\n+  dep_link_t next = DEP_LINK_NEXT (l);\n+\n+  return (next == NULL\n+\t  || &DEP_LINK_NEXT (l) == DEP_LINK_PREV_NEXTP (next));\n+}\n+\n+/* Attach L to appear after link X whose &DEP_LINK_NEXT (X) is given by\n+   PREV_NEXT_P.  */\n+static void\n+attach_dep_link (dep_link_t l, dep_link_t *prev_nextp)\n+{\n+  dep_link_t next = *prev_nextp;\n+\n+  gcc_assert (DEP_LINK_PREV_NEXTP (l) == NULL\n+\t      && DEP_LINK_NEXT (l) == NULL);\n+\n+  /* Init node being inserted.  */\n+  DEP_LINK_PREV_NEXTP (l) = prev_nextp;\n+  DEP_LINK_NEXT (l) = next;\n+\n+  /* Fix next node.  */\n+  if (next != NULL)\n+    {\n+      gcc_assert (DEP_LINK_PREV_NEXTP (next) == prev_nextp);\n+\n+      DEP_LINK_PREV_NEXTP (next) = &DEP_LINK_NEXT (l);\n+    }\n+\n+  /* Fix prev node.  */\n+  *prev_nextp = l;\n+}\n+\n+/* Add dep_link LINK to deps_list L.  */\n+static void\n+add_to_deps_list (dep_link_t link, deps_list_t l)\n+{\n+  attach_dep_link (link, &DEPS_LIST_FIRST (l));\n+}\n+\n+/* Detach dep_link L from the list.  */\n+static void\n+detach_dep_link (dep_link_t l)\n+{\n+  dep_link_t *prev_nextp = DEP_LINK_PREV_NEXTP (l);\n+  dep_link_t next = DEP_LINK_NEXT (l);\n+\n+  *prev_nextp = next;\n+\n+  if (next != NULL)\n+    DEP_LINK_PREV_NEXTP (next) = prev_nextp;\n+\n+  /* Though this is property is not used anywhere but in the assert in\n+     attach_dep_link (), this can prevent latent errors.  */\n+  DEP_LINK_PREV_NEXTP (l) = NULL;\n+  DEP_LINK_NEXT (l) = NULL;\n+}\n+\n+/* Move LINK from whatever list it is now to L.  */\n+void\n+move_dep_link (dep_link_t link, deps_list_t l)\n+{\n+  detach_dep_link (link);\n+  add_to_deps_list (link, l);\n+}\n+\n+/* Check L's and its successors' consistency.\n+   This is, potentially, an expensive check, hence it should be guarded by\n+   ENABLE_CHECKING at all times.  */\n+static bool\n+dep_links_consistent_p (dep_link_t l)\n+{\n+  while (l != NULL)\n+    {\n+      if (dep_link_consistent_p (l))\n+\tl = DEP_LINK_NEXT (l);\n+      else\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Dump dep_nodes starting from l.  */\n+static void\n+dump_dep_links (FILE *dump, dep_link_t l)\n+{\n+  while (l != NULL)\n+    {\n+      dep_t d = DEP_LINK_DEP (l);\n+\n+      fprintf (dump, \"%d%c>%d \", INSN_UID (DEP_PRO (d)),\n+\t       dep_link_consistent_p (l) ? '-' : '!', INSN_UID (DEP_CON (d)));\n+\n+      l = DEP_LINK_NEXT (l);\n+    }\n+\n+  fprintf (dump, \"\\n\");\n+}\n+\n+/* Dump dep_nodes starting from L to stderr.  */\n+void\n+debug_dep_links (dep_link_t l)\n+{\n+  dump_dep_links (stderr, l);\n+}\n+\n+/* Obstack to allocate dep_nodes and deps_lists on.  */\n+static struct obstack deps_obstack;\n+\n+/* Obstack to hold forward dependencies lists (deps_list_t).  */\n+static struct obstack *dl_obstack = &deps_obstack;\n+\n+/* Obstack to hold all dependency nodes (dep_node_t).  */\n+static struct obstack *dn_obstack = &deps_obstack;\n+\n+/* Functions to operate with dependences lists - deps_list_t.  */\n+\n+/* Allocate deps_list.\n+\n+   If ON_OBSTACK_P is true, allocate the list on the obstack.  This is done for\n+   INSN_FORW_DEPS lists because they should live till the end of scheduling.\n+\n+   INSN_BACK_DEPS and INSN_RESOLVED_BACK_DEPS lists are allocated on the free\n+   store and are being freed in haifa-sched.c: schedule_insn ().  */\n+static deps_list_t\n+alloc_deps_list (bool on_obstack_p)\n+{\n+  if (on_obstack_p)\n+    return obstack_alloc (dl_obstack, sizeof (struct _deps_list));\n+  else\n+    return xmalloc (sizeof (struct _deps_list));\n+}\n+\n+/* Initialize deps_list L.  */\n+static void\n+init_deps_list (deps_list_t l)\n+{\n+  DEPS_LIST_FIRST (l) = NULL;\n+}\n+\n+/* Create (allocate and init) deps_list.\n+   The meaning of ON_OBSTACK_P is the same as in alloc_deps_list ().  */\n+deps_list_t\n+create_deps_list (bool on_obstack_p)\n+{\n+  deps_list_t l = alloc_deps_list (on_obstack_p);\n+\n+  init_deps_list (l);\n+  return l;\n+}\n+\n+/* Free dep_data_nodes that present in L.  */\n+static void\n+clear_deps_list (deps_list_t l)\n+{\n+  /* All dep_nodes are allocated on the dn_obstack.  They'll be freed with\n+     the obstack.  */\n+\n+  DEPS_LIST_FIRST (l) = NULL;\n+}\n+\n+/* Free deps_list L.  */\n+void\n+free_deps_list (deps_list_t l)\n+{\n+  gcc_assert (deps_list_empty_p (l));\n+  free (l);\n+}\n+\n+/* Delete (clear and free) deps_list L.  */\n+void\n+delete_deps_list (deps_list_t l)\n+{\n+  clear_deps_list (l);\n+  free_deps_list (l);\n+}\n+\n+/* Return true if L is empty.  */\n+bool\n+deps_list_empty_p (deps_list_t l)\n+{\n+  return DEPS_LIST_FIRST (l) == NULL;\n+}\n+\n+/* Check L's consistency.\n+   This is, potentially, an expensive check, hence it should be guarded by\n+   ENABLE_CHECKING at all times.  */\n+static bool\n+deps_list_consistent_p (deps_list_t l)\n+{\n+  dep_link_t first = DEPS_LIST_FIRST (l);\n+\n+  return (first == NULL\n+\t  || (&DEPS_LIST_FIRST (l) == DEP_LINK_PREV_NEXTP (first)\n+\t      && dep_links_consistent_p (first)));\n+}\n+\n+/* Dump L to F.  */\n+static void\n+dump_deps_list (FILE *f, deps_list_t l)\n+{\n+  dump_dep_links (f, DEPS_LIST_FIRST (l));\n+}\n+\n+/* Dump L to STDERR.  */\n+void\n+debug_deps_list (deps_list_t l)\n+{\n+  dump_deps_list (stderr, l);\n+}\n+\n+/* Add a dependency described by DEP to the list L.\n+   L should be either INSN_BACK_DEPS or INSN_RESOLVED_BACK_DEPS.  */\n+void\n+add_back_dep_to_deps_list (deps_list_t l, dep_t dep_from)\n+{\n+  dep_node_t n = (dep_node_t) obstack_alloc (dn_obstack,\n+\t\t\t\t\t     sizeof (*n));\n+  dep_t dep_to = DEP_NODE_DEP (n);\n+  dep_link_t back = DEP_NODE_BACK (n);\n+  dep_link_t forw = DEP_NODE_FORW (n);\n+\n+  copy_dep (dep_to, dep_from);\n+\n+  DEP_LINK_NODE (back) = n;\n+  DEP_LINK_NODE (forw) = n;\n+\n+  /* There is no particular need to initialize these four fields except to make\n+     assert in attach_dep_link () happy.  */\n+  DEP_LINK_NEXT (back) = NULL;\n+  DEP_LINK_PREV_NEXTP (back) = NULL;\n+  DEP_LINK_NEXT (forw) = NULL;\n+  DEP_LINK_PREV_NEXTP (forw) = NULL;\n+\n+  add_to_deps_list (back, l);\n+}\n+\n+/* Find the dep_link with producer PRO in deps_list L.  */\n+dep_link_t\n+find_link_by_pro_in_deps_list (deps_list_t l, rtx pro)\n+{\n+  dep_link_t link;\n+\n+  FOR_EACH_DEP_LINK (link, l)\n+    if (DEP_LINK_PRO (link) == pro)\n+      return link;\n+\n+  return NULL;\n+}\n+\n+/* Find the dep_link with consumer CON in deps_list L.  */\n+dep_link_t\n+find_link_by_con_in_deps_list (deps_list_t l, rtx con)\n+{\n+  dep_link_t link;\n+\n+  FOR_EACH_DEP_LINK (link, l)\n+    if (DEP_LINK_CON (link) == con)\n+      return link;\n+\n+  return NULL;\n+}\n+\n+/* Make a copy of FROM in TO with substituting consumer with CON.\n+   TO and FROM should be RESOLVED_BACK_DEPS lists.  */\n+void\n+copy_deps_list_change_con (deps_list_t to, deps_list_t from, rtx con)\n+{\n+  dep_link_t l;\n+\n+  gcc_assert (deps_list_empty_p (to));\n+\n+  FOR_EACH_DEP_LINK (l, from)\n+    {\n+      add_back_dep_to_deps_list (to, DEP_LINK_DEP (l));\n+      DEP_LINK_CON (DEPS_LIST_FIRST (to)) = con;\n+    }\n+}\n \n static regset reg_pending_sets;\n static regset reg_pending_clobbers;\n@@ -103,14 +462,14 @@ static rtx sched_get_condition (rtx);\n static int conditions_mutex_p (rtx, rtx);\n \n static enum DEPS_ADJUST_RESULT maybe_add_or_update_back_dep_1 (rtx, rtx, \n-\t\t\t       enum reg_note, ds_t, rtx, rtx, rtx **);\n+\t\t\t       enum reg_note, ds_t, rtx, rtx, dep_link_t **);\n static enum DEPS_ADJUST_RESULT add_or_update_back_dep_1 (rtx, rtx, \n-                               enum reg_note, ds_t, rtx, rtx, rtx **);\n+                               enum reg_note, ds_t, rtx, rtx, dep_link_t **);\n static void add_back_dep (rtx, rtx, enum reg_note, ds_t);\n \n-static void adjust_add_sorted_back_dep (rtx, rtx, rtx *);\n-static void adjust_back_add_forw_dep (rtx, rtx *);\n-static void delete_forw_dep (rtx, rtx);\n+static void adjust_add_sorted_back_dep (rtx, dep_link_t, dep_link_t *);\n+static void adjust_back_add_forw_dep (rtx, dep_link_t *);\n+static void delete_forw_dep (dep_link_t);\n static dw_t estimate_dep_weak (rtx, rtx);\n #ifdef INSN_SCHEDULING\n #ifdef ENABLE_CHECKING\n@@ -225,13 +584,13 @@ sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n   return false;\n }\n \f\n-/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n-   LOG_LINKS of INSN, if it is not already there.  DEP_TYPE indicates the\n+/* Add ELEM wrapped in an dep_link with reg note kind DEP_TYPE to the\n+   INSN_BACK_DEPS (INSN), if it is not already there.  DEP_TYPE indicates the\n    type of dependence that this link represents.  DS, if nonzero,\n    indicates speculations, through which this dependence can be overcome.\n    MEM1 and MEM2, if non-null, corresponds to memory locations in case of\n    data speculation.  The function returns a value indicating if an old entry\n-   has been changed or a new entry has been added to insn's LOG_LINK.\n+   has been changed or a new entry has been added to insn's backward deps.\n    In case of changed entry CHANGED_LINKPP sets to its address.\n    See also the definition of enum DEPS_ADJUST_RESULT in sched-int.h.  \n    Actual manipulation of dependence data structures is performed in \n@@ -240,7 +599,7 @@ sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n static enum DEPS_ADJUST_RESULT\n maybe_add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n \t\t\t\tds_t ds, rtx mem1, rtx mem2,\n-\t\t\t\trtx **changed_linkpp)\n+\t\t\t\tdep_link_t **changed_linkpp)\n {\n   gcc_assert (INSN_P (insn) && INSN_P (elem));\n \n@@ -267,7 +626,7 @@ static enum DEPS_ADJUST_RESULT\n add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type, \n \t\t\t  ds_t ds ATTRIBUTE_UNUSED,\n \t\t\t  rtx mem1 ATTRIBUTE_UNUSED, rtx mem2 ATTRIBUTE_UNUSED,\n-\t\t\t  rtx **changed_linkpp ATTRIBUTE_UNUSED)\n+\t\t\t  dep_link_t **changed_linkpp ATTRIBUTE_UNUSED)\n {\n   bool maybe_present_p = true, present_p = false;\n \n@@ -359,15 +718,17 @@ add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n   /* Check that we don't already have this dependence.  */\n   if (maybe_present_p)\n     {\n-      rtx *linkp;\n+      dep_link_t *linkp;\n \n-      for (linkp = &LOG_LINKS (insn); *linkp; linkp = &XEXP (*linkp, 1))\n+      for (linkp = &DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n+\t   *linkp != NULL;\n+\t   linkp = &DEP_LINK_NEXT (*linkp))\n         {\n-          rtx link = *linkp;\n+          dep_t link = DEP_LINK_DEP (*linkp);\n \n \t  gcc_assert (true_dependency_cache == 0 || present_p);\n \t  \n-          if (XEXP (link, 0) == elem)\n+          if (DEP_PRO (link) == elem)\n             {\n               enum DEPS_ADJUST_RESULT changed_p = DEP_PRESENT;\n \n@@ -412,7 +773,7 @@ add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n               if (true_dependency_cache != NULL\n \t\t  && !(current_sched_info->flags & USE_DEPS_LIST))\n \t\t{\n-\t\t  enum reg_note kind = REG_NOTE_KIND (link);\n+\t\t  enum reg_note kind = DEP_KIND (link);\n \n \t\t  switch (kind)\n \t\t    {\n@@ -440,9 +801,9 @@ add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n               /* If this is a more restrictive type of dependence than the\n \t\t existing one, then change the existing dependence to this\n \t\t type.  */\n-              if ((int) dep_type < (int) REG_NOTE_KIND (link))\n+              if ((int) dep_type < (int) DEP_KIND (link))\n                 {\n-                  PUT_REG_NOTE_KIND (link, dep_type);\n+\t\t  DEP_KIND (link) = dep_type;\n                   changed_p = DEP_CHANGED;\n                 }\n \n@@ -453,13 +814,13 @@ add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n                 {\n                   if (!(current_sched_info->flags & USE_DEPS_LIST))\n                     {\n-                      if (REG_NOTE_KIND (link) == REG_DEP_TRUE)\n+                      if (DEP_KIND (link) == REG_DEP_TRUE)\n                         bitmap_set_bit (&true_dependency_cache\n \t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n-                      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+                      else if (DEP_KIND (link) == REG_DEP_OUTPUT)\n                         bitmap_set_bit (&output_dependency_cache\n \t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n-                      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+                      else if (DEP_KIND (link) == REG_DEP_ANTI)\n                         bitmap_set_bit (&anti_dependency_cache\n \t\t\t\t\t[INSN_LUID (insn)], INSN_LUID (elem));\n                     }\n@@ -511,16 +872,17 @@ add_or_update_back_dep_1 (rtx insn, rtx elem, enum reg_note dep_type,\n static void\n add_back_dep (rtx insn, rtx elem, enum reg_note dep_type, ds_t ds)\n {\n+  struct _dep _dep, *dep = &_dep;\n+\n   gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n \n   if (current_sched_info->flags & USE_DEPS_LIST)\n-    LOG_LINKS (insn) = alloc_DEPS_LIST (elem, LOG_LINKS (insn), ds);\n+    init_dep_1 (dep, elem, insn, dep_type, ds);\n   else\n-    LOG_LINKS (insn) = alloc_INSN_LIST (elem, LOG_LINKS (insn));\n-  \n-  /* Insn dependency, not data dependency.  */\n-  PUT_REG_NOTE_KIND (LOG_LINKS (insn), dep_type);\n-    \n+    init_dep_1 (dep, elem, insn, dep_type, -1);\n+\n+  add_back_dep_to_deps_list (INSN_BACK_DEPS (insn), dep);\n+\n #ifdef INSN_SCHEDULING\n #ifdef ENABLE_CHECKING\n   check_dep_status (dep_type, ds, false);\n@@ -612,12 +974,7 @@ delete_all_dependences (rtx insn)\n     }\n #endif\n \n-  if (!(current_sched_info->flags & USE_DEPS_LIST))\n-    /* In this case LOG_LINKS are formed from the DEPS_LISTs,\n-       not the INSN_LISTs.  */\n-    free_INSN_LIST_list (&LOG_LINKS (insn));  \n-  else\n-    free_DEPS_LIST_list (&LOG_LINKS (insn));\n+  clear_deps_list (INSN_BACK_DEPS (insn));  \n }\n \n /* All insns in a scheduling group except the first should only have\n@@ -629,20 +986,25 @@ delete_all_dependences (rtx insn)\n static void\n fixup_sched_groups (rtx insn)\n {\n-  rtx link, prev_nonnote;\n+  dep_link_t link;\n+  rtx prev_nonnote;\n \n-  for (link = LOG_LINKS (insn); link ; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n     {\n       rtx i = insn;\n+      dep_t dep = DEP_LINK_DEP (link);\n+      rtx pro = DEP_PRO (dep);\n+\n       do\n \t{\n \t  i = prev_nonnote_insn (i);\n \n-\t  if (XEXP (link, 0) == i)\n+\t  if (pro == i)\n \t    goto next_link;\n \t} while (SCHED_GROUP_P (i));\n-      if (! sched_insns_conditions_mutex_p (i, XEXP (link, 0)))\n-\tadd_dependence (i, XEXP (link, 0), REG_NOTE_KIND (link));\n+\n+      if (! sched_insns_conditions_mutex_p (i, pro))\n+\tadd_dependence (i, pro, DEP_KIND (dep));\n     next_link:;\n     }\n \n@@ -1450,8 +1812,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n     fixup_sched_groups (insn);\n }\n \n-/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS\n-   for every dependency.  */\n+/* Analyze every insn between HEAD and TAIL inclusive, creating backward\n+   dependencies for each insn.  */\n \n void\n sched_analyze (struct deps *deps, rtx head, rtx tail)\n@@ -1474,11 +1836,22 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n     {\n       rtx link, end_seq, r0, set;\n \n-      if (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n+      if (INSN_P (insn))\n \t{\n \t  /* Clear out the stale LOG_LINKS from flow.  */\n \t  free_INSN_LIST_list (&LOG_LINKS (insn));\n \n+\t  /* These two lists will be freed in schedule_insn ().  */\n+\t  INSN_BACK_DEPS (insn) = create_deps_list (false);\n+\t  INSN_RESOLVED_BACK_DEPS (insn) = create_deps_list (false);\n+\n+\t  /* This one should be allocated on the obstack because it should live\n+\t     till the scheduling ends.  */\n+\t  INSN_FORW_DEPS (insn) = create_deps_list (true);\n+\t}\n+\n+      if (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n+\t{\n \t  /* Make each JUMP_INSN a scheduling barrier for memory\n              references.  */\n \t  if (JUMP_P (insn))\n@@ -1498,9 +1871,6 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \n \t  CANT_MOVE (insn) = 1;\n \n-\t  /* Clear out the stale LOG_LINKS from flow.  */\n-\t  free_INSN_LIST_list (&LOG_LINKS (insn));\n-\n \t  if (find_reg_note (insn, REG_SETJMP, NULL))\n \t    {\n \t      /* This is setjmp.  Assume that all registers, not just\n@@ -1625,11 +1995,11 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n    given DEP_TYPE.  The forward dependence should be not exist before.  */\n \n void\n-add_forw_dep (rtx to, rtx link)\n+add_forw_dep (dep_link_t link)\n {\n-  rtx new_link, from;\n-\n-  from = XEXP (link, 0);\n+  dep_t dep = DEP_LINK_DEP (link);\n+  rtx to = DEP_CON (dep);\n+  rtx from = DEP_PRO (dep);\n \n #ifdef ENABLE_CHECKING\n   /* If add_dependence is working properly there should never\n@@ -1647,24 +2017,20 @@ add_forw_dep (rtx to, rtx link)\n       bitmap_set_bit (&forward_dependency_cache[INSN_LUID (from)],\n \t\t      INSN_LUID (to));\n     }\n-  else\n-    gcc_assert (!find_insn_list (to, INSN_DEPEND (from)));\n-#endif\n \n-  if (!(current_sched_info->flags & USE_DEPS_LIST))\n-    new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n-  else\n-    new_link = alloc_DEPS_LIST (to, INSN_DEPEND (from), DEP_STATUS (link));\n+  gcc_assert (find_link_by_con_in_deps_list (INSN_FORW_DEPS (from), to)\n+\t      == NULL);\n+#endif\n \n-  PUT_REG_NOTE_KIND (new_link, REG_NOTE_KIND (link));\n+  add_to_deps_list (DEP_NODE_FORW (DEP_LINK_NODE (link)),\n+\t\t    INSN_FORW_DEPS (from));\n \n-  INSN_DEPEND (from) = new_link;\n   INSN_DEP_COUNT (to) += 1;\n }\n \n /* Examine insns in the range [ HEAD, TAIL ] and Use the backward\n-   dependences from LOG_LINKS to build forward dependences in\n-   INSN_DEPEND.  */\n+   dependences from INSN_BACK_DEPS list to build forward dependences in\n+   INSN_FORW_DEPS.  */\n \n void\n compute_forward_dependences (rtx head, rtx tail)\n@@ -1675,26 +2041,41 @@ compute_forward_dependences (rtx head, rtx tail)\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx link;\n+      dep_link_t link;\n       \n       if (! INSN_P (insn))\n \tcontinue;\n       \n       if (current_sched_info->flags & DO_SPECULATION)\n         {\n-          rtx new = 0, link, next;\n+\t  /* We will add links, preserving order, from INSN_BACK_DEPS to\n+\t     NEW.  */\n+          dep_link_t new = NULL;\n \n-          for (link = LOG_LINKS (insn); link; link = next)\n+\t  link = DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n+\n+\t  while (link != NULL)\n             {\n-              next = XEXP (link, 1);\n+\t      dep_link_t next = DEP_LINK_NEXT (link);\n+\n+\t      detach_dep_link (link);\n               adjust_add_sorted_back_dep (insn, link, &new);\n+\n+\t      link = next;\n             }\n \n-          LOG_LINKS (insn) = new;\n+\t  /* Attach NEW to be the list of backward dependencies.  */\n+\t  if (new != NULL)\n+\t    {\n+\t      DEP_LINK_PREV_NEXTP (new)\n+\t\t= &DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n+\n+\t      DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)) = new;\n+\t    }\n         }\n \n-      for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-        add_forw_dep (insn, link);\n+      FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n+        add_forw_dep (link);\n     }\n }\n \f\n@@ -1775,6 +2156,16 @@ init_dependency_caches (int luid)\n       cache_size = 0;\n       extend_dependency_caches (luid, true);\n     }\n+\n+  /* Lifetime of this obstack is whole function scheduling (not single region\n+     scheduling) because some dependencies can be manually generated for\n+     outside regions.  See dont_calc_deps in sched-{rgn, ebb}.c .\n+\n+     Possible solution would be to have two obstacks:\n+     * the big one for regular dependencies with region scheduling lifetime,\n+     * and the small one for manually generated dependencies with function\n+     scheduling lifetime.  */\n+  gcc_obstack_init (&deps_obstack);\n }\n \n /* Create or extend (depending on CREATE_P) dependency caches to\n@@ -1820,6 +2211,8 @@ extend_dependency_caches (int n, bool create_p)\n void\n free_dependency_caches (void)\n {\n+  obstack_free (&deps_obstack, NULL);\n+\n   if (true_dependency_cache)\n     {\n       int i;\n@@ -1878,63 +2271,67 @@ finish_deps_global (void)\n /* Insert LINK into the dependence chain pointed to by LINKP and \n    maintain the sort order.  */\n static void\n-adjust_add_sorted_back_dep (rtx insn, rtx link, rtx *linkp)\n+adjust_add_sorted_back_dep (rtx insn, dep_link_t link, dep_link_t *linkp)\n {\n   gcc_assert (current_sched_info->flags & DO_SPECULATION);\n   \n   /* If the insn cannot move speculatively, but the link is speculative,   \n      make it hard dependence.  */\n   if (HAS_INTERNAL_DEP (insn)\n-      && (DEP_STATUS (link) & SPECULATIVE))\n+      && (DEP_LINK_STATUS (link) & SPECULATIVE))\n     {      \n-      DEP_STATUS (link) &= ~SPECULATIVE;\n+      DEP_LINK_STATUS (link) &= ~SPECULATIVE;\n       \n       if (true_dependency_cache)\n         bitmap_clear_bit (&spec_dependency_cache[INSN_LUID (insn)],\n-\t\t\t  INSN_LUID (XEXP (link, 0)));\n+\t\t\t  INSN_LUID (DEP_LINK_PRO (link)));\n     }\n \n-  /* Non-speculative links go at the head of LOG_LINKS, followed by\n+  /* Non-speculative links go at the head of deps_list, followed by\n      speculative links.  */\n-  if (DEP_STATUS (link) & SPECULATIVE)\n-    while (*linkp && !(DEP_STATUS (*linkp) & SPECULATIVE))\n-      linkp = &XEXP (*linkp, 1);\n+  if (DEP_LINK_STATUS (link) & SPECULATIVE)\n+    while (*linkp && !(DEP_LINK_STATUS (*linkp) & SPECULATIVE))\n+      linkp = &DEP_LINK_NEXT (*linkp);\n \n-  XEXP (link, 1) = *linkp;\n-  *linkp = link;\n+  attach_dep_link (link, linkp);\n+\n+  if (CHECK)\n+    gcc_assert (deps_list_consistent_p (INSN_BACK_DEPS (insn)));\n }\n \n /* Move the dependence pointed to by LINKP to the back dependencies  \n-   of INSN, and also add this dependence to the forward ones.  All LOG_LINKS,\n+   of INSN, and also add this dependence to the forward ones.  All dep_links,\n    except one pointed to by LINKP, must be sorted.  */\n static void\n-adjust_back_add_forw_dep (rtx insn, rtx *linkp)\n+adjust_back_add_forw_dep (rtx insn, dep_link_t *linkp)\n {\n-  rtx link;\n+  dep_link_t link;\n \n   gcc_assert (current_sched_info->flags & DO_SPECULATION);\n \n   link = *linkp;\n-  *linkp = XEXP (*linkp, 1);  \n+  detach_dep_link (link);\n \n-  adjust_add_sorted_back_dep (insn, link, &LOG_LINKS (insn));\n-  add_forw_dep (insn, link);\n+  adjust_add_sorted_back_dep (insn, link,\n+\t\t\t      &DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)));\n+  add_forw_dep (link);\n }\n \n-/* Remove forward dependence ELEM from the DEPS_LIST of INSN.  */\n+/* Remove forward dependence described by L.  */\n static void\n-delete_forw_dep (rtx insn, rtx elem)\n+delete_forw_dep (dep_link_t l)\n {\n   gcc_assert (current_sched_info->flags & DO_SPECULATION);\n \n #ifdef ENABLE_CHECKING\n   if (true_dependency_cache)\n-    bitmap_clear_bit (&forward_dependency_cache[INSN_LUID (elem)],\n-\t\t      INSN_LUID (insn));\n+    bitmap_clear_bit (&forward_dependency_cache[INSN_LUID (DEP_LINK_PRO (l))],\n+\t\t      INSN_LUID (DEP_LINK_CON (l)));\n #endif\n \n-  remove_free_DEPS_LIST_elem (insn, &INSN_DEPEND (elem));    \n-  INSN_DEP_COUNT (insn)--;\n+  detach_dep_link (l);\n+\n+  INSN_DEP_COUNT (DEP_LINK_CON (l))--;\n }\n \n /* Estimate the weakness of dependence between MEM1 and MEM2.  */\n@@ -2001,16 +2398,16 @@ add_or_update_back_forw_dep (rtx insn, rtx elem, enum reg_note dep_type,\n \t\t\t     ds_t ds)\n {\n   enum DEPS_ADJUST_RESULT res;\n-  rtx *linkp;\n+  dep_link_t *linkp;\n \n   res = add_or_update_back_dep_1 (insn, elem, dep_type, ds, 0, 0, &linkp);\n \n   if (res == DEP_CHANGED || res == DEP_CREATED)\n     {\n       if (res == DEP_CHANGED)\n-\tdelete_forw_dep (insn, elem);\n+\tdelete_forw_dep (DEP_NODE_FORW (DEP_LINK_NODE (*linkp)));\n       else if (res == DEP_CREATED)\n-\tlinkp = &LOG_LINKS (insn);\n+\tlinkp = &DEPS_LIST_FIRST (INSN_BACK_DEPS (insn));\n \n       adjust_back_add_forw_dep (insn, linkp);\n     }\n@@ -2021,30 +2418,35 @@ add_or_update_back_forw_dep (rtx insn, rtx elem, enum reg_note dep_type,\n void\n add_back_forw_dep (rtx insn, rtx elem, enum reg_note dep_type, ds_t ds)\n {\n-  add_back_dep (insn, elem, dep_type, ds);  \n-  adjust_back_add_forw_dep (insn, &LOG_LINKS (insn));    \n+  add_back_dep (insn, elem, dep_type, ds);\n+  adjust_back_add_forw_dep (insn, &DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)));\n+\n+  if (CHECK)\n+    gcc_assert (deps_list_consistent_p (INSN_BACK_DEPS (insn)));\n }\n \n-/* Remove both backward and forward dependencies between INSN and ELEM.  */\n+/* Remove a dependency refered by L.  */\n void\n-delete_back_forw_dep (rtx insn, rtx elem)\n+delete_back_forw_dep (dep_link_t l)\n {\n+  dep_node_t n = DEP_LINK_NODE (l);\n+\n   gcc_assert (current_sched_info->flags & DO_SPECULATION);\n \n   if (true_dependency_cache != NULL)\n     {\n-      bitmap_clear_bit (&true_dependency_cache[INSN_LUID (insn)],\n-\t\t\tINSN_LUID (elem));\n-      bitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\tINSN_LUID (elem));\n-      bitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n-\t\t\tINSN_LUID (elem));\n-      bitmap_clear_bit (&spec_dependency_cache[INSN_LUID (insn)],\n-\t\t\tINSN_LUID (elem));\n+      dep_t dep = DEP_NODE_DEP (n);\n+      int elem_luid = INSN_LUID (DEP_PRO (dep));\n+      int insn_luid = INSN_LUID (DEP_CON (dep));\n+\n+      bitmap_clear_bit (&true_dependency_cache[insn_luid], elem_luid);\n+      bitmap_clear_bit (&anti_dependency_cache[insn_luid], elem_luid);\n+      bitmap_clear_bit (&output_dependency_cache[insn_luid], elem_luid);\n+      bitmap_clear_bit (&spec_dependency_cache[insn_luid], elem_luid);\n     }\n \n-  remove_free_DEPS_LIST_elem (elem, &LOG_LINKS (insn));\n-  delete_forw_dep (insn, elem);\n+  delete_forw_dep (DEP_NODE_FORW (n));\n+  detach_dep_link (DEP_NODE_BACK (n));\n }\n \n /* Return weakness of speculative type TYPE in the dep_status DS.  */"}, {"sha": "f6dc8ec04fe673a26c0f17aa851fb432d6ad4711", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -300,28 +300,24 @@ static struct sched_info ebb_sched_info =\n static basic_block\n earliest_block_with_similiar_load (basic_block last_block, rtx load_insn)\n {\n-  rtx back_link;\n+  dep_link_t back_link;\n   basic_block bb, earliest_block = NULL;\n \n-  for (back_link = LOG_LINKS (load_insn);\n-       back_link;\n-       back_link = XEXP (back_link, 1))\n+  FOR_EACH_DEP_LINK (back_link, INSN_BACK_DEPS (load_insn))\n     {\n-      rtx insn1 = XEXP (back_link, 0);\n+      rtx insn1 = DEP_LINK_PRO (back_link);\n \n-      if (GET_MODE (back_link) == VOIDmode)\n+      if (DEP_LINK_KIND (back_link) == REG_DEP_TRUE)\n \t{\n \t  /* Found a DEF-USE dependence (insn1, load_insn).  */\n-\t  rtx fore_link;\n+\t  dep_link_t fore_link;\n \n-\t  for (fore_link = INSN_DEPEND (insn1);\n-\t       fore_link;\n-\t       fore_link = XEXP (fore_link, 1))\n+\t  FOR_EACH_DEP_LINK (fore_link, INSN_FORW_DEPS (insn1))\n \t    {\n-\t      rtx insn2 = XEXP (fore_link, 0);\n+\t      rtx insn2 = DEP_LINK_CON (fore_link);\n \t      basic_block insn2_block = BLOCK_FOR_INSN (insn2);\n \n-\t      if (GET_MODE (fore_link) == VOIDmode)\n+\t      if (DEP_LINK_KIND (fore_link) == REG_DEP_TRUE)\n \t\t{\n \t\t  if (earliest_block != NULL\n \t\t      && earliest_block->index < insn2_block->index)\n@@ -404,7 +400,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n \t\t\t\t\t\t  REG_DEP_ANTI, DEP_ANTI);\n \n \t\t    if (res == DEP_CREATED)\n-\t\t      add_forw_dep (insn, LOG_LINKS (insn));\n+\t\t      add_forw_dep (DEPS_LIST_FIRST (INSN_BACK_DEPS (insn)));\n \t\t    else\n \t\t      gcc_assert (res != DEP_CHANGED);\n \t\t  }\n@@ -451,12 +447,12 @@ schedule_ebb (rtx head, rtx tail)\n     {\n       init_deps_global ();\n \n-      /* Compute LOG_LINKS.  */\n+      /* Compute backward dependencies.  */\n       init_deps (&tmp_deps);\n       sched_analyze (&tmp_deps, head, tail);\n       free_deps (&tmp_deps);\n \n-      /* Compute INSN_DEPEND.  */\n+      /* Compute forward dependencies.  */\n       compute_forward_dependences (head, tail);\n \n       add_deps_for_risky_insns (head, tail);"}, {"sha": "f47aab785e9a9d1e4572289e24c01bb81989b814", "filename": "gcc/sched-int.h", "status": "modified", "additions": 237, "deletions": 14, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -42,6 +42,218 @@ typedef int ds_t;\n /* Type to represent weakness of speculative dependence.  */\n typedef int dw_t;\n \n+extern enum reg_note ds_to_dk (ds_t);\n+extern ds_t dk_to_ds (enum reg_note);\n+\n+/* Information about the dependency.  */\n+struct _dep\n+{\n+  /* Producer.  */\n+  rtx pro;\n+\n+  /* Consumer.  */\n+  rtx con;\n+\n+  /* Dependency kind (aka dependency major type).  This field is superseded\n+     by STATUS below.  Though, it is still in place because all the backends\n+     use it.  */\n+  enum reg_note kind;\n+\n+  /* Dependency status.  This field holds all dependency types and additional\n+     information for speculative dependencies.  */\n+  ds_t status;\n+};\n+typedef struct _dep *dep_t;\n+\n+#define DEP_PRO(D) ((D)->pro)\n+#define DEP_CON(D) ((D)->con)\n+#define DEP_KIND(D) ((D)->kind)\n+#define DEP_STATUS(D) ((D)->status)\n+\n+/* Functions to work with dep.  */\n+\n+extern void init_dep (dep_t, rtx, rtx, enum reg_note);\n+\n+/* Definition of this struct resides below.  */\n+struct _dep_node;\n+\n+/* A link in the dependency list.  This is essentially an equivalent of a\n+   single {INSN, DEPS}_LIST rtx.  */\n+struct _dep_link\n+{\n+  /* Dep node with all the data.  */\n+  struct _dep_node *node;\n+\n+  /* Next link in the list. For the last one it is NULL.  */\n+  struct _dep_link *next;\n+\n+  /* Pointer to the next field of the previous link in the list.\n+     For the first link this points to the deps_list->first.\n+\n+     With help of this field it is easy to remove and insert links to the\n+     list.  */\n+  struct _dep_link **prev_nextp;\n+};\n+typedef struct _dep_link *dep_link_t;\n+\n+#define DEP_LINK_NODE(N) ((N)->node)\n+#define DEP_LINK_NEXT(N) ((N)->next)\n+#define DEP_LINK_PREV_NEXTP(N) ((N)->prev_nextp)\n+\n+/* Macros to work dep_link.  For most usecases only part of the dependency\n+   information is need.  These macros conveniently provide that piece of\n+   information.  */\n+\n+#define DEP_LINK_DEP(N) (DEP_NODE_DEP (DEP_LINK_NODE (N)))\n+#define DEP_LINK_PRO(N) (DEP_PRO (DEP_LINK_DEP (N)))\n+#define DEP_LINK_CON(N) (DEP_CON (DEP_LINK_DEP (N)))\n+#define DEP_LINK_KIND(N) (DEP_KIND (DEP_LINK_DEP (N)))\n+#define DEP_LINK_STATUS(N) (DEP_STATUS (DEP_LINK_DEP (N)))\n+\n+void debug_dep_links (dep_link_t);\n+\n+/* A list of dep_links.  Lists of this type are now used instead of rtx\n+   LOG_LINKS and alike lists.  */\n+struct _deps_list\n+{\n+  dep_link_t first;\n+};\n+typedef struct _deps_list *deps_list_t;\n+\n+#define DEPS_LIST_FIRST(L) ((L)->first)\n+\n+/* Macro to walk through deps_list.  */\n+#define FOR_EACH_DEP_LINK(LINK, LIST) \\\n+  for ((LINK) = DEPS_LIST_FIRST (LIST); \\\n+       (LINK) != NULL; \\\n+       (LINK) = DEP_LINK_NEXT (LINK))\n+\n+/* Functions to work with deps_list.  */\n+\n+deps_list_t create_deps_list (bool);\n+void free_deps_list (deps_list_t);\n+void delete_deps_list (deps_list_t);\n+bool deps_list_empty_p (deps_list_t);\n+void debug_deps_list (deps_list_t);\n+void add_back_dep_to_deps_list (deps_list_t, dep_t);\n+dep_link_t find_link_by_pro_in_deps_list (deps_list_t, rtx);\n+dep_link_t find_link_by_con_in_deps_list (deps_list_t, rtx);\n+void copy_deps_list_change_con (deps_list_t, deps_list_t, rtx);\n+\n+void move_dep_link (dep_link_t, deps_list_t);\n+\n+/* Suppose we have a depedence Y between insn pro1 and con1, where pro1 has\n+   additional dependants con0 and con2, and con1 is dependant on additional\n+   insns pro0 and pro1:\n+\n+   .con0      pro0\n+   . ^         |\n+   . |         |\n+   . |         |\n+   . X         A\n+   . |         |\n+   . |         |\n+   . |         V\n+   .pro1--Y-->con1\n+   . |         ^\n+   . |         |\n+   . |         |\n+   . Z         B\n+   . |         |\n+   . |         |\n+   . V         |\n+   .con2      pro2\n+\n+   This is represented using a \"dep_node\" for each dependence arc, which are\n+   connected as follows (diagram is centered around Y which is fully shown;\n+   other dep_nodes shown partially):\n+\n+   .          +------------+    +--------------+    +------------+\n+   .          : dep_node X :    |  dep_node Y  |    : dep_node Z :\n+   .          :            :    |              |    :            :\n+   .          :            :    |              |    :            :\n+   .          : forw       :    |  forw        |    : forw       :\n+   .          : +--------+ :    |  +--------+  |    : +--------+ :\n+   forw_deps  : |dep_link| :    |  |dep_link|  |    : |dep_link| :\n+   +-----+    : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   |first|----->| |next|-+------+->| |next|-+--+----->| |next|-+--->NULL\n+   +-----+    : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   . ^  ^     : |     ^  | :    |  |     ^  |  |    : |        | :\n+   . |  |     : |     |  | :    |  |     |  |  |    : |        | :\n+   . |  +--<----+--+  +--+---<--+--+--+  +--+--+--<---+--+     | :\n+   . |        : |  |     | :    |  |  |     |  |    : |  |     | :\n+   . |        : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   . |        : | |prev| | :    |  | |prev| |  |    : | |prev| | :\n+   . |        : | |next| | :    |  | |next| |  |    : | |next| | :\n+   . |        : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   . |        : |        | :<-+ |  |        |  |<-+ : |        | :<-+\n+   . |        : | +----+ | :  | |  | +----+ |  |  | : | +----+ | :  |\n+   . |        : | |node|-+----+ |  | |node|-+--+--+ : | |node|-+----+\n+   . |        : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   . |        : |        | :    |  |        |  |    : |        | :\n+   . |        : +--------+ :    |  +--------+  |    : +--------+ :\n+   . |        :            :    |              |    :            :\n+   . |        :  SAME pro1 :    |  +--------+  |    :  SAME pro1 :\n+   . |        :  DIFF con0 :    |  |dep     |  |    :  DIFF con2 :\n+   . |        :            :    |  |        |  |    :            :\n+   . |                          |  | +----+ |  |\n+   .RTX<------------------------+--+-|pro1| |  |\n+   .pro1                        |  | +----+ |  |\n+   .                            |  |        |  |\n+   .                            |  | +----+ |  |\n+   .RTX<------------------------+--+-|con1| |  |\n+   .con1                        |  | +----+ |  |\n+   . |                          |  |        |  |\n+   . |                          |  | +----+ |  |\n+   . |                          |  | |kind| |  |\n+   . |                          |  | +----+ |  |\n+   . |        :            :    |  | |stat| |  |    :            :\n+   . |        :  DIFF pro0 :    |  | +----+ |  |    :  DIFF pro2 :\n+   . |        :  SAME con1 :    |  |        |  |    :  SAME con1 :\n+   . |        :            :    |  +--------+  |    :            :\n+   . |        :            :    |              |    :            :\n+   . |        : back       :    |  back        |    : back       :\n+   . v        : +--------+ :    |  +--------+  |    : +--------+ :\n+   back_deps  : |dep_link| :    |  |dep_link|  |    : |dep_link| :\n+   +-----+    : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   |first|----->| |next|-+------+->| |next|-+--+----->| |next|-+--->NULL\n+   +-----+    : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   .    ^     : |     ^  | :    |  |     ^  |  |    : |        | :\n+   .    |     : |     |  | :    |  |     |  |  |    : |        | :\n+   .    +--<----+--+  +--+---<--+--+--+  +--+--+--<---+--+     | :\n+   .          : |  |     | :    |  |  |     |  |    : |  |     | :\n+   .          : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   .          : | |prev| | :    |  | |prev| |  |    : | |prev| | :\n+   .          : | |next| | :    |  | |next| |  |    : | |next| | :\n+   .          : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   .          : |        | :<-+ |  |        |  |<-+ : |        | :<-+\n+   .          : | +----+ | :  | |  | +----+ |  |  | : | +----+ | :  |\n+   .          : | |node|-+----+ |  | |node|-+--+--+ : | |node|-+----+\n+   .          : | +----+ | :    |  | +----+ |  |    : | +----+ | :\n+   .          : |        | :    |  |        |  |    : |        | :\n+   .          : +--------+ :    |  +--------+  |    : +--------+ :\n+   .          :            :    |              |    :            :\n+   .          : dep_node A :    |  dep_node Y  |    : dep_node B :\n+   .          +------------+    +--------------+    +------------+\n+*/\n+\n+struct _dep_node\n+{\n+  /* Backward link.  */\n+  struct _dep_link back;\n+\n+  /* The dep.  */\n+  struct _dep dep;\n+\n+  /* Forward link.  */\n+  struct _dep_link forw;\n+};\n+typedef struct _dep_node *dep_node_t;\n+\n+#define DEP_NODE_BACK(N) (&(N)->back)\n+#define DEP_NODE_DEP(N) (&(N)->dep)\n+#define DEP_NODE_FORW(N) (&(N)->forw)\n+\n /* Describe state of dependencies used during sched_analyze phase.  */\n struct deps\n {\n@@ -263,13 +475,23 @@ extern struct sched_info *current_sched_info;\n \n struct haifa_insn_data\n {\n-  /* A list of insns which depend on the instruction.  Unlike LOG_LINKS,\n+  /* NB: We can't place 'struct _deps_list' here instead of deps_list_t into\n+     h_i_d because when h_i_d extends, addresses of the deps_list->first\n+     change without updating deps_list->first->next->prev_nextp.  Thus\n+     BACK_DEPS and RESOLVED_BACK_DEPS are allocated on the heap and FORW_DEPS\n+     list is allocated on the obstack.  */\n+\n+  /* A list of backward dependencies.  The insn is a consumer of all the\n+     deps mentioned here.  */\n+  deps_list_t back_deps;\n+\n+  /* A list of insns which depend on the instruction.  Unlike 'back_deps',\n      it represents forward dependencies.  */\n-  rtx depend;\n+  deps_list_t forw_deps;\n \n   /* A list of scheduled producers of the instruction.  Links are being moved\n-     from LOG_LINKS to RESOLVED_DEPS during scheduling.  */\n-  rtx resolved_deps;\n+     from 'back_deps' to 'resolved_back_deps' while scheduling.  */\n+  deps_list_t resolved_back_deps;\n  \n   /* Logical uid gives the original ordering of the insns.  */\n   int luid;\n@@ -339,14 +561,15 @@ extern regset *glat_start, *glat_end;\n \n /* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n    sched-rgn.c.  */\n-#define INSN_DEPEND(INSN)\t(h_i_d[INSN_UID (INSN)].depend)\n-#define RESOLVED_DEPS(INSN)     (h_i_d[INSN_UID (INSN)].resolved_deps)\n+#define INSN_BACK_DEPS(INSN) (h_i_d[INSN_UID (INSN)].back_deps)\n+#define INSN_FORW_DEPS(INSN) (h_i_d[INSN_UID (INSN)].forw_deps)\n+#define INSN_RESOLVED_BACK_DEPS(INSN) \\\n+  (h_i_d[INSN_UID (INSN)].resolved_back_deps)\n #define INSN_LUID(INSN)\t\t(h_i_d[INSN_UID (INSN)].luid)\n #define CANT_MOVE(insn)\t\t(h_i_d[INSN_UID (insn)].cant_move)\n #define INSN_DEP_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].dep_count)\n #define INSN_PRIORITY(INSN)\t(h_i_d[INSN_UID (INSN)].priority)\n #define INSN_PRIORITY_KNOWN(INSN) (h_i_d[INSN_UID (INSN)].priority_known)\n-#define INSN_COST(INSN)\t\t(h_i_d[INSN_UID (INSN)].cost)\n #define INSN_REG_WEIGHT(INSN)\t(h_i_d[INSN_UID (INSN)].reg_weight)\n #define HAS_INTERNAL_DEP(INSN)  (h_i_d[INSN_UID (INSN)].has_internal_dep)\n #define TODO_SPEC(INSN)         (h_i_d[INSN_UID (INSN)].todo_spec)\n@@ -370,8 +593,8 @@ extern regset *glat_start, *glat_end;\n #define IS_SPECULATION_BRANCHY_CHECK_P(INSN) \\\n   (RECOVERY_BLOCK (INSN) != NULL && RECOVERY_BLOCK (INSN) != EXIT_BLOCK_PTR)\n \n-/* DEP_STATUS of the link encapsulates information, that is needed for\n-   speculative scheduling.  Namely, it is 4 integers in the range\n+/* Dep status (aka ds_t) of the link encapsulates information, that is needed\n+   for speculative scheduling.  Namely, it is 4 integers in the range\n    [0, MAX_DEP_WEAK] and 3 bits.\n    The integers correspond to the probability of the dependence to *not*\n    exist, it is the probability, that overcoming of this dependence will\n@@ -386,9 +609,8 @@ extern regset *glat_start, *glat_end;\n    as only true dependence can be overcome.\n    There also is the 4-th bit in the DEP_STATUS (HARD_DEP), that is reserved\n    for using to describe instruction's status.  It is set whenever instruction\n-   has at least one dependence, that cannot be overcome.\n+   has at least one dependence, that cannot be overcame.\n    See also: check_dep_status () in sched-deps.c .  */\n-#define DEP_STATUS(LINK) XINT (LINK, 2)\n \n /* We exclude sign bit.  */\n #define BITS_PER_DEP_STATUS (HOST_BITS_PER_INT - 1)\n@@ -610,7 +832,7 @@ extern void init_deps (struct deps *);\n extern void free_deps (struct deps *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n-extern void add_forw_dep (rtx, rtx);\n+extern void add_forw_dep (dep_link_t);\n extern void compute_forward_dependences (rtx, rtx);\n extern rtx find_insn_list (rtx, rtx);\n extern void init_dependency_caches (int);\n@@ -620,7 +842,7 @@ extern enum DEPS_ADJUST_RESULT add_or_update_back_dep (rtx, rtx,\n \t\t\t\t\t\t       enum reg_note, ds_t);\n extern void add_or_update_back_forw_dep (rtx, rtx, enum reg_note, ds_t);\n extern void add_back_forw_dep (rtx, rtx, enum reg_note, ds_t);\n-extern void delete_back_forw_dep (rtx, rtx);\n+extern void delete_back_forw_dep (dep_link_t);\n extern dw_t get_dep_weak (ds_t, ds_t);\n extern ds_t set_dep_weak (ds_t, ds_t, dw_t);\n extern ds_t ds_merge (ds_t, ds_t);\n@@ -632,7 +854,8 @@ extern int no_real_insns_p (rtx, rtx);\n \n extern void rm_other_notes (rtx, rtx);\n \n-extern int insn_cost (rtx, rtx, rtx);\n+extern int insn_cost (rtx);\n+extern int dep_cost (dep_t);\n extern int set_priorities (rtx, rtx);\n \n extern void schedule_block (basic_block *, int);"}, {"sha": "82f3d125668a1cb6092dde9393ade4c7cdd69c49", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -1711,30 +1711,31 @@ update_live (rtx insn, int src)\n static void\n set_spec_fed (rtx load_insn)\n {\n-  rtx link;\n+  dep_link_t link;\n \n-  for (link = INSN_DEPEND (load_insn); link; link = XEXP (link, 1))\n-    if (GET_MODE (link) == VOIDmode)\n-      FED_BY_SPEC_LOAD (XEXP (link, 0)) = 1;\n-}\t\t\t\t/* set_spec_fed */\n+  FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (load_insn))\n+    if (DEP_LINK_KIND (link) == REG_DEP_TRUE)\n+      FED_BY_SPEC_LOAD (DEP_LINK_CON (link)) = 1;\n+}\n \n /* On the path from the insn to load_insn_bb, find a conditional\n branch depending on insn, that guards the speculative load.  */\n \n static int\n find_conditional_protection (rtx insn, int load_insn_bb)\n {\n-  rtx link;\n+  dep_link_t link;\n \n   /* Iterate through DEF-USE forward dependences.  */\n-  for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (insn))\n     {\n-      rtx next = XEXP (link, 0);\n+      rtx next = DEP_LINK_CON (link);\n+\n       if ((CONTAINING_RGN (BLOCK_NUM (next)) ==\n \t   CONTAINING_RGN (BB_TO_BLOCK (load_insn_bb)))\n \t  && IS_REACHABLE (INSN_BB (next), load_insn_bb)\n \t  && load_insn_bb != INSN_BB (next)\n-\t  && GET_MODE (link) == VOIDmode\n+\t  && DEP_LINK_KIND (link) == REG_DEP_TRUE\n \t  && (JUMP_P (next)\n \t      || find_conditional_protection (next, load_insn_bb)))\n \treturn 1;\n@@ -1753,20 +1754,20 @@ find_conditional_protection (rtx insn, int load_insn_bb)\n    and if insn1 is on the path\n    region-entry -> ... -> bb_trg -> ... load_insn.\n \n-   Locate insn1 by climbing on LOG_LINKS from load_insn.\n-   Locate the branch by following INSN_DEPEND from insn1.  */\n+   Locate insn1 by climbing on INSN_BACK_DEPS from load_insn.\n+   Locate the branch by following INSN_FORW_DEPS from insn1.  */\n \n static int\n is_conditionally_protected (rtx load_insn, int bb_src, int bb_trg)\n {\n-  rtx link;\n+  dep_link_t link;\n \n-  for (link = LOG_LINKS (load_insn); link; link = XEXP (link, 1))\n+  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (load_insn))\n     {\n-      rtx insn1 = XEXP (link, 0);\n+      rtx insn1 = DEP_LINK_PRO (link);\n \n       /* Must be a DEF-USE dependence upon non-branch.  */\n-      if (GET_MODE (link) != VOIDmode\n+      if (DEP_LINK_KIND (link) != REG_DEP_TRUE\n \t  || JUMP_P (insn1))\n \tcontinue;\n \n@@ -1809,28 +1810,27 @@ is_conditionally_protected (rtx load_insn, int bb_src, int bb_trg)\n static int\n is_pfree (rtx load_insn, int bb_src, int bb_trg)\n {\n-  rtx back_link;\n+  dep_link_t back_link;\n   candidate *candp = candidate_table + bb_src;\n \n   if (candp->split_bbs.nr_members != 1)\n     /* Must have exactly one escape block.  */\n     return 0;\n \n-  for (back_link = LOG_LINKS (load_insn);\n-       back_link; back_link = XEXP (back_link, 1))\n+  FOR_EACH_DEP_LINK (back_link, INSN_BACK_DEPS (load_insn))\n     {\n-      rtx insn1 = XEXP (back_link, 0);\n+      rtx insn1 = DEP_LINK_PRO (back_link);\n \n-      if (GET_MODE (back_link) == VOIDmode)\n+      if (DEP_LINK_KIND (back_link) == REG_DEP_TRUE)\n \t{\n \t  /* Found a DEF-USE dependence (insn1, load_insn).  */\n-\t  rtx fore_link;\n+\t  dep_link_t fore_link;\n \n-\t  for (fore_link = INSN_DEPEND (insn1);\n-\t       fore_link; fore_link = XEXP (fore_link, 1))\n+\t  FOR_EACH_DEP_LINK (fore_link, INSN_FORW_DEPS (insn1))\n \t    {\n-\t      rtx insn2 = XEXP (fore_link, 0);\n-\t      if (GET_MODE (fore_link) == VOIDmode)\n+\t      rtx insn2 = DEP_LINK_CON (fore_link);\n+\n+\t      if (DEP_LINK_KIND (fore_link) == REG_DEP_TRUE)\n \t\t{\n \t\t  /* Found a DEF-USE dependence (insn1, insn2).  */\n \t\t  if (haifa_classify_insn (insn2) != PFREE_CANDIDATE)\n@@ -1863,7 +1863,7 @@ is_prisky (rtx load_insn, int bb_src, int bb_trg)\n   if (FED_BY_SPEC_LOAD (load_insn))\n     return 1;\n \n-  if (LOG_LINKS (load_insn) == NULL)\n+  if (deps_list_empty_p (INSN_BACK_DEPS (load_insn)))\n     /* Dependence may 'hide' out of the region.  */\n     return 1;\n \n@@ -2284,7 +2284,9 @@ add_branch_dependences (rtx head, rtx tail)\n     {\n       if (!NOTE_P (insn))\n \t{\n-\t  if (last != 0 && !find_insn_list (insn, LOG_LINKS (last)))\n+\t  if (last != 0\n+\t      && (find_link_by_pro_in_deps_list (INSN_BACK_DEPS (last), insn)\n+\t\t  == NULL))\n \t    {\n \t      if (! sched_insns_conditions_mutex_p (last, insn))\n \t\tadd_dependence (last, insn, REG_DEP_ANTI);\n@@ -2573,7 +2575,7 @@ debug_dependencies (void)\n \n       for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n \t{\n-\t  rtx link;\n+\t  dep_link_t link;\n \n \t  if (! INSN_P (insn))\n \t    {\n@@ -2598,16 +2600,16 @@ debug_dependencies (void)\n \t\t   INSN_BB (insn),\n \t\t   INSN_DEP_COUNT (insn),\n \t\t   INSN_PRIORITY (insn),\n-\t\t   insn_cost (insn, 0, 0));\n+\t\t   insn_cost (insn));\n \n \t  if (recog_memoized (insn) < 0)\n \t    fprintf (sched_dump, \"nothing\");\n \t  else\n \t    print_reservation (sched_dump, insn);\n \n \t  fprintf (sched_dump, \"\\t: \");\n-\t  for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n-\t    fprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));\n+\t  FOR_EACH_DEP_LINK (link, INSN_FORW_DEPS (insn))\n+\t    fprintf (sched_dump, \"%d \", INSN_UID (DEP_LINK_CON (link)));\n \t  fprintf (sched_dump, \"\\n\");\n \t}\n     }\n@@ -2665,11 +2667,11 @@ schedule_region (int rgn)\n       for (bb = 0; bb < current_nr_blocks; bb++)\n \tinit_deps (bb_deps + bb);\n \n-      /* Compute LOG_LINKS.  */\n+      /* Compute backward dependencies.  */\n       for (bb = 0; bb < current_nr_blocks; bb++)\n         compute_block_backward_dependences (bb);\n \n-      /* Compute INSN_DEPEND.  */\n+      /* Compute forward dependencies.  */\n       for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n         {\n           rtx head, tail;"}, {"sha": "e13b4933e6ceb43fa3d8e92e0319877e44995c8a", "filename": "gcc/target-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -308,7 +308,6 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD 0\n #define TARGET_SCHED_DFA_NEW_CYCLE 0\n #define TARGET_SCHED_IS_COSTLY_DEPENDENCE 0\n-#define TARGET_SCHED_ADJUST_COST_2 0\n #define TARGET_SCHED_H_I_D_EXTENDED 0\n #define TARGET_SCHED_SPECULATE_INSN 0\n #define TARGET_SCHED_NEEDS_BLOCK_P 0\n@@ -337,7 +336,6 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n    TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n    TARGET_SCHED_IS_COSTLY_DEPENDENCE,                           \\\n-   TARGET_SCHED_ADJUST_COST_2,                                  \\\n    TARGET_SCHED_H_I_D_EXTENDED,\t\t\t\t\t\\\n    TARGET_SCHED_SPECULATE_INSN,                                 \\\n    TARGET_SCHED_NEEDS_BLOCK_P,                                  \\"}, {"sha": "f4678e44bc4703bb79a58549eb584ae0c10c0730", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b198261f9c5ce8b6cec5769eec4f3d82e04eaeb8", "patch": "@@ -84,6 +84,8 @@ typedef struct secondary_reload_info\n   int t_icode; /* Actually an enum insn_code - see above.  */\n } secondary_reload_info;\n \n+/* This is defined in sched-int.h .  */\n+struct _dep;\n \n struct gcc_target\n {\n@@ -241,7 +243,7 @@ struct gcc_target\n     /* Given the current cost, COST, of an insn, INSN, calculate and\n        return a new cost based on its relationship to DEP_INSN through\n        the dependence LINK.  The default is to make no adjustment.  */\n-    int (* adjust_cost) (rtx insn, rtx link, rtx def_insn, int cost);\n+    int (* adjust_cost) (rtx insn, rtx link, rtx dep_insn, int cost);\n \n     /* Adjust the priority of an insn as you see fit.  Returns the new\n        priority.  */\n@@ -324,22 +326,16 @@ struct gcc_target\n        cycle.  */\n     int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n \n-    /* The following member value is a pointer to a function called\n-       by the insn scheduler.  It should return true if there exists a\n-       dependence which is considered costly by the target, between\n-       the insn passed as the first parameter, and the insn passed as\n-       the second parameter.  The third parameter is the INSN_DEPEND\n-       link that represents the dependence between the two insns.  The\n-       fourth argument is the cost of the dependence as estimated by\n+    /* The following member value is a pointer to a function called by the\n+       insn scheduler.  It should return true if there exists a dependence\n+       which is considered costly by the target, between the insn\n+       DEP_PRO (&_DEP), and the insn DEP_CON (&_DEP).  The first parameter is\n+       the dep that represents the dependence between the two insns.  The\n+       second argument is the cost of the dependence as estimated by\n        the scheduler.  The last argument is the distance in cycles\n        between the already scheduled insn (first parameter) and the\n        the second insn (second parameter).  */\n-    bool (* is_costly_dependence) (rtx, rtx, rtx, int, int);\n-\n-    /* Given the current cost, COST, of an insn, INSN, calculate and\n-       return a new cost based on its relationship to DEP_INSN through the\n-       dependence of type DEP_TYPE.  The default is to make no adjustment.  */\n-    int (* adjust_cost_2) (rtx insn, int, rtx def_insn, int cost);\n+    bool (* is_costly_dependence) (struct _dep *_dep, int, int);\n \n     /* The following member value is a pointer to a function called\n        by the insn scheduler. This hook is called to notify the backend"}]}