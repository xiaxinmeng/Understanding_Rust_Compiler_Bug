{"sha": "3fd1c229ad10fda68318882329568f400a38fb6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkMWMyMjlhZDEwZmRhNjgzMTg4ODIzMjk1NjhmNDAwYTM4ZmI2ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-09T21:24:57Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-09T21:24:57Z"}, "message": "libstdc++: Implement LWG 3324 for [cmp.alg] function objects (LWG 3324)\n\nLWG 3324 changed the [cmp.alg] types to use std::compare_three_way\ninstead of the <=> operator, but we were still using the old\nspecification. In order to make the existing tests pass the N::X type\nneeds to be equality comparable, so that three_way_comparable is\nsatisfied and compare_three_way can be used.\n\nAs part of this change I noticed that the compare_three_way call\noperator was unconditionally noexcept, which is incorrect.\n\n\t* libsupc++/compare (compare_three_way): Fix noexcept-specifier.\n\t(strong_order, weak_order, partial_order): Replace uses of <=> with\n\tcompare_three_way function object (LWG 3324).\n\t* testsuite/18_support/comparisons/algorithms/partial_order.cc: Add\n\tequality operator so that X satisfies three_way_comparable.\n\t* testsuite/18_support/comparisons/algorithms/strong_order.cc:\n\tLikewise.\n\t* testsuite/18_support/comparisons/algorithms/weak_order.cc: Likewise.", "tree": {"sha": "0ea879584b331c2c5af5612db18b60ef67379f8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ea879584b331c2c5af5612db18b60ef67379f8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd1c229ad10fda68318882329568f400a38fb6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd1c229ad10fda68318882329568f400a38fb6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd1c229ad10fda68318882329568f400a38fb6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd1c229ad10fda68318882329568f400a38fb6d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b074864f8c593fd4bccee788a023a37b446b2ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b074864f8c593fd4bccee788a023a37b446b2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b074864f8c593fd4bccee788a023a37b446b2ed"}], "stats": {"total": 70, "additions": 50, "deletions": 20}, "files": [{"sha": "3ca7a0e7165fc233f1e62ffb7f5d4d6a11797a20", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3fd1c229ad10fda68318882329568f400a38fb6d", "patch": "@@ -1,5 +1,14 @@\n 2020-04-09  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* libsupc++/compare (compare_three_way): Fix noexcept-specifier.\n+\t(strong_order, weak_order, partial_order): Replace uses of <=> with\n+\tcompare_three_way function object (LWG 3324).\n+\t* testsuite/18_support/comparisons/algorithms/partial_order.cc: Add\n+\tequality operator so that X satisfies three_way_comparable.\n+\t* testsuite/18_support/comparisons/algorithms/strong_order.cc:\n+\tLikewise.\n+\t* testsuite/18_support/comparisons/algorithms/weak_order.cc: Likewise.\n+\n \t* include/bits/unique_ptr.h (operator<=>): Define for C++20.\n \t* testsuite/20_util/default_delete/48631_neg.cc: Adjust dg-error line.\n \t* testsuite/20_util/default_delete/void_neg.cc: Likewise."}, {"sha": "37601d32648886c29293ce7bee3370c7081d753a", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=3fd1c229ad10fda68318882329568f400a38fb6d", "patch": "@@ -419,7 +419,8 @@ namespace std\n       = __detail::__weakly_eq_cmp_with<_Tp, _Tp>\n       && __detail::__partially_ordered_with<_Tp, _Tp>\n       && requires(const remove_reference_t<_Tp>& __a,\n-\t\t  const remove_reference_t<_Tp>& __b) {\n+\t\t  const remove_reference_t<_Tp>& __b)\n+      {\n \t{ __a <=> __b } -> __detail::__compares_as<_Cat>;\n       };\n \n@@ -435,7 +436,8 @@ namespace std\n       && __detail::__weakly_eq_cmp_with<_Tp, _Up>\n       && __detail::__partially_ordered_with<_Tp, _Up>\n       && requires(const remove_reference_t<_Tp>& __t,\n-\t\t  const remove_reference_t<_Up>& __u) {\n+\t\t  const remove_reference_t<_Up>& __u)\n+      {\n \t{ __t <=> __u } -> __detail::__compares_as<_Cat>;\n \t{ __u <=> __t } -> __detail::__compares_as<_Cat>;\n       };\n@@ -494,7 +496,8 @@ namespace std\n     template<typename _Tp, typename _Up>\n       requires three_way_comparable_with<_Tp, _Up>\n       constexpr auto\n-      operator()(_Tp&& __t, _Up&& __u) const noexcept\n+      operator()(_Tp&& __t, _Up&& __u) const\n+      noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))\n       {\n \tif constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)\n \t  {\n@@ -579,16 +582,16 @@ namespace std\n \t};\n \n     template<typename _Ord, typename _Tp, typename _Up>\n-      concept __op_cmp = requires(_Tp&& __t, _Up&& __u)\n+      concept __cmp3way = requires(_Tp&& __t, _Up&& __u, compare_three_way __c)\n \t{\n-\t  _Ord(static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u));\n+\t  _Ord(__c(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)));\n \t};\n \n     template<typename _Tp, typename _Up>\n       concept __strongly_ordered\n \t= __adl_strong<_Tp, _Up>\n \t  // FIXME: || floating_point<remove_reference_t<_Tp>>\n-\t  || __op_cmp<strong_ordering, _Tp, _Up>;\n+\t  || __cmp3way<strong_ordering, _Tp, _Up>;\n \n     class _Strong_order\n     {\n@@ -601,8 +604,9 @@ namespace std\n \t  else if constexpr (__adl_strong<_Tp, _Up>)\n \t    return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),\n \t\t\t\t\t\t\t std::declval<_Up>())));\n-\t  else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)\n-\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t  else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)\n+\t    return noexcept(compare_three_way()(std::declval<_Tp>(),\n+\t\t\t\t\t\tstd::declval<_Up>()));\n \t}\n \n       friend class _Weak_order;\n@@ -623,16 +627,17 @@ namespace std\n \t  else */ if constexpr (__adl_strong<_Tp, _Up>)\n \t    return strong_ordering(strong_order(static_cast<_Tp&&>(__e),\n \t\t\t\t\t\tstatic_cast<_Up&&>(__f)));\n-\t  else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)\n-\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t  else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)\n+\t    return compare_three_way()(static_cast<_Tp&&>(__e),\n+\t\t\t\t       static_cast<_Up&&>(__f));\n \t}\n     };\n \n     template<typename _Tp, typename _Up>\n       concept __weakly_ordered\n \t= floating_point<remove_reference_t<_Tp>>\n \t  || __adl_weak<_Tp, _Up>\n-\t  || __op_cmp<weak_ordering, _Tp, _Up>\n+\t  || __cmp3way<weak_ordering, _Tp, _Up>\n \t  || __strongly_ordered<_Tp, _Up>;\n \n     class _Weak_order\n@@ -646,8 +651,9 @@ namespace std\n \t  else if constexpr (__adl_weak<_Tp, _Up>)\n \t    return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),\n \t\t\t\t\t\t     std::declval<_Up>())));\n-\t  else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)\n-\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t  else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)\n+\t    return noexcept(compare_three_way()(std::declval<_Tp>(),\n+\t\t\t\t\t\tstd::declval<_Up>()));\n \t  else if constexpr (__strongly_ordered<_Tp, _Up>)\n \t    return _Strong_order::_S_noexcept<_Tp, _Up>();\n \t}\n@@ -669,8 +675,9 @@ namespace std\n \t  else if constexpr (__adl_weak<_Tp, _Up>)\n \t    return weak_ordering(weak_order(static_cast<_Tp&&>(__e),\n \t\t\t\t\t    static_cast<_Up&&>(__f)));\n-\t  else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)\n-\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t  else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)\n+\t    return compare_three_way()(static_cast<_Tp&&>(__e),\n+\t\t\t\t       static_cast<_Up&&>(__f));\n \t  else if constexpr (__strongly_ordered<_Tp, _Up>)\n \t    return _Strong_order{}(static_cast<_Tp&&>(__e),\n \t\t\t\t   static_cast<_Up&&>(__f));\n@@ -680,7 +687,7 @@ namespace std\n     template<typename _Tp, typename _Up>\n       concept __partially_ordered\n \t= __adl_partial<_Tp, _Up>\n-\t|| __op_cmp<partial_ordering, _Tp, _Up>\n+\t|| __cmp3way<partial_ordering, _Tp, _Up>\n \t|| __weakly_ordered<_Tp, _Up>;\n \n     class _Partial_order\n@@ -692,8 +699,9 @@ namespace std\n \t  if constexpr (__adl_partial<_Tp, _Up>)\n \t    return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),\n \t\t\t\t\t\t\t std::declval<_Up>())));\n-\t  else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)\n-\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t  else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)\n+\t    return noexcept(compare_three_way()(std::declval<_Tp>(),\n+\t\t\t\t\t\tstd::declval<_Up>()));\n \t  else if constexpr (__weakly_ordered<_Tp, _Up>)\n \t    return _Weak_order::_S_noexcept<_Tp, _Up>();\n \t}\n@@ -712,8 +720,9 @@ namespace std\n \t  if constexpr (__adl_partial<_Tp, _Up>)\n \t    return partial_ordering(partial_order(static_cast<_Tp&&>(__e),\n \t\t\t\t\t\t  static_cast<_Up&&>(__f)));\n-\t  else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)\n-\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t  else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)\n+\t    return compare_three_way()(static_cast<_Tp&&>(__e),\n+\t\t\t\t       static_cast<_Up&&>(__f));\n \t  else if constexpr (__weakly_ordered<_Tp, _Up>)\n \t    return _Weak_order{}(static_cast<_Tp&&>(__e),\n \t\t\t\t static_cast<_Up&&>(__f));"}, {"sha": "0806eabf74a13073baa24cd1c6245d5b25f86cc1", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/partial_order.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc?ref=3fd1c229ad10fda68318882329568f400a38fb6d", "patch": "@@ -94,6 +94,10 @@ namespace N\n       return partial_ordering::equivalent;\n     return r.i <=> l.i;\n   }\n+\n+  constexpr bool operator==(X l, X r) { return std::is_eq(l <=> r); }\n+\n+  static_assert(std::three_way_comparable<X>);\n }\n \n void"}, {"sha": "edbcc9f1acbdec97697c4b0d5c5ed0c48da39d56", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/strong_order.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc?ref=3fd1c229ad10fda68318882329568f400a38fb6d", "patch": "@@ -47,6 +47,10 @@ namespace N\n       return strong_ordering::equivalent;\n     return r.i <=> l.i;\n   }\n+\n+  constexpr bool operator==(X l, X r) { return std::is_eq(l <=> r); }\n+\n+  static_assert(std::three_way_comparable<X>);\n }\n using N::X;\n "}, {"sha": "d7d43ade8d2622b1ea841a6b15ff94ef55afe0e3", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/weak_order.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1c229ad10fda68318882329568f400a38fb6d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc?ref=3fd1c229ad10fda68318882329568f400a38fb6d", "patch": "@@ -95,6 +95,10 @@ namespace N\n       return weak_ordering::equivalent;\n     return r.i <=> l.i;\n   }\n+\n+  constexpr bool operator==(X l, X r) { return std::is_eq(l <=> r); }\n+\n+  static_assert(std::three_way_comparable<X>);\n }\n \n void"}]}