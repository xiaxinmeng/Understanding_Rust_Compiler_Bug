{"sha": "b821466067dd32988497bc8166fe0ae13f9a3b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyMTQ2NjA2N2RkMzI5ODg0OTdiYzgxNjZmZTBhZTEzZjlhM2I4ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-05-30T16:31:17Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-05-30T16:31:17Z"}, "message": "tuple: Implement uses-allocator construction.\n\n2011-05-30  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/std/tuple: Implement uses-allocator construction.\n\t* include/bits/allocator.h (uses_allocator): Move to ...\n\t* include/bits/uses_allocator.h: New file.\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/20_util/uses_allocator/cons_neg.cc: New.\n\t* testsuite/20_util/uses_allocator/construction.cc: New.\n\t* testsuite/20_util/tuple/cons/allocate_noncopyable.cc: New.\n\t* testsuite/20_util/tuple/cons/allocators.cc: New.\n\nFrom-SVN: r174443", "tree": {"sha": "c89a0f8f7618adc87a58aed670bc36f999248aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c89a0f8f7618adc87a58aed670bc36f999248aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b821466067dd32988497bc8166fe0ae13f9a3b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b821466067dd32988497bc8166fe0ae13f9a3b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b821466067dd32988497bc8166fe0ae13f9a3b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b821466067dd32988497bc8166fe0ae13f9a3b8e/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fd7879d121537c3fb6e2874bc683ea506760375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd7879d121537c3fb6e2874bc683ea506760375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd7879d121537c3fb6e2874bc683ea506760375"}], "stats": {"total": 796, "additions": 765, "deletions": 31}, "files": [{"sha": "9875d6c6f426b545b6fabfb917771ebae0036032", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -1,3 +1,15 @@\n+2011-05-30  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/tuple: Implement uses-allocator construction.\n+\t* include/bits/allocator.h (uses_allocator): Move to ...\n+\t* include/bits/uses_allocator.h: New file.\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/20_util/uses_allocator/cons_neg.cc: New.\n+\t* testsuite/20_util/uses_allocator/construction.cc: New.\n+\t* testsuite/20_util/tuple/cons/allocate_noncopyable.cc: New.\n+\t* testsuite/20_util/tuple/cons/allocators.cc: New.\n+\n 2011-05-28  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* testsuite/20_util/pointer_traits/pointer_to.cc: Fix."}, {"sha": "a4b7f27aaa4fff8da7b372d2248b01604869e1a3", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -168,6 +168,7 @@ bits_headers = \\\n \t${bits_srcdir}/unique_ptr.h \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\\n+\t${bits_srcdir}/uses_allocator.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "3cbe0e4500ece415be8f9af56ef26dd45cc24050", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -419,6 +419,7 @@ bits_headers = \\\n \t${bits_srcdir}/unique_ptr.h \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\\n+\t${bits_srcdir}/uses_allocator.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n \t${bits_srcdir}/valarray_before.h \\"}, {"sha": "6fccba51bb1ec8e7ed7784c3c9a0ac7049787982", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -49,7 +49,7 @@\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <bits/ptr_traits.h>\n-#include <type_traits> // For _GLIBCXX_HAS_NESTED_TYPE\n+#include <bits/uses_allocator.h>\n #include <limits>\n #endif\n \n@@ -207,32 +207,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-\n-  /// [allocator.tag]\n-  struct allocator_arg_t { };\n-\n-  constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n-\n-_GLIBCXX_HAS_NESTED_TYPE(allocator_type)\n-\n-  template<typename _Tp, typename _Alloc,\n-\t   bool = __has_allocator_type<_Tp>::value>\n-    struct __uses_allocator_helper\n-    : public false_type { };\n-\n-  template<typename _Tp, typename _Alloc>\n-    struct __uses_allocator_helper<_Tp, _Alloc, true>\n-    : public integral_constant<bool, is_convertible<_Alloc,\n-\t\t\t\t     typename _Tp::allocator_type>::value>\n-    { };\n-\n-  /// [allocator.uses.trait]\n-  template<typename _Tp, typename _Alloc>\n-    struct uses_allocator\n-    : public integral_constant<bool,\n-\t\t\t       __uses_allocator_helper<_Tp, _Alloc>::value>\n-    { };\n-\n   template<typename _Alloc, typename _Tp>\n     class __alloctr_rebind_helper\n     {"}, {"sha": "49b5409c15abaea865b1e1f88dd63423d2d022b3", "filename": "libstdc++-v3/include/bits/uses_allocator.h", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator.h?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -0,0 +1,109 @@\n+// Uses-allocator Construction -*- C++ -*-\n+\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _USES_ALLOCATOR_H\n+#define _USES_ALLOCATOR_H 1\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <type_traits>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// [allocator.tag]\n+  struct allocator_arg_t { };\n+\n+  constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n+\n+_GLIBCXX_HAS_NESTED_TYPE(allocator_type)\n+\n+  template<typename _Tp, typename _Alloc,\n+\t   bool = __has_allocator_type<_Tp>::value>\n+    struct __uses_allocator_helper\n+    : public false_type { };\n+\n+  template<typename _Tp, typename _Alloc>\n+    struct __uses_allocator_helper<_Tp, _Alloc, true>\n+    : public integral_constant<bool, is_convertible<_Alloc,\n+\t\t\t\t     typename _Tp::allocator_type>::value>\n+    { };\n+\n+  /// [allocator.uses.trait]\n+  template<typename _Tp, typename _Alloc>\n+    struct uses_allocator\n+    : public integral_constant<bool,\n+\t\t\t       __uses_allocator_helper<_Tp, _Alloc>::value>\n+    { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __uses_allocator_arg\n+    : is_constructible<_Tp, _Alloc, _Args...>\n+    { static_assert( uses_allocator<_Tp, _Alloc>::value, \"uses allocator\" ); };\n+\n+  struct __uses_alloc_base { };\n+  struct __uses_alloc0 : __uses_alloc_base\n+  { struct _Anything { _Anything(...) { } } _M_a; };\n+  template<typename _Alloc>\n+    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };\n+  template<typename _Alloc>\n+    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };\n+\n+  template<bool, typename _Alloc, typename... _Args>\n+    struct __uses_alloc;\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __uses_alloc<true, _Tp, _Alloc, _Args...>\n+    : conditional<\n+        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,\n+        __uses_alloc1<_Alloc>,\n+       \t__uses_alloc2<_Alloc>>::type\n+    { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __uses_alloc<false, _Tp, _Alloc, _Args...>\n+    : __uses_alloc0 { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    struct __uses_alloc_impl\n+    : __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp,  _Alloc, _Args...>\n+    { };\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    __uses_alloc_impl<_Tp, _Alloc, _Args...>\n+    __use_alloc(const _Alloc& __a)\n+    {\n+      __uses_alloc_impl<_Tp, _Alloc, _Args...> __ret;\n+      __ret._M_a = &__a;\n+      return __ret;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif\n+#endif"}, {"sha": "a0e9e694dc2bb586dfffecd5aee68373b75e88c2", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 243, "deletions": 4, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -36,6 +36,7 @@\n #else\n \n #include <utility>\n+#include <bits/uses_allocator.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -81,10 +82,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Head_base(const _Head& __h)\n       : _Head(__h) { }\n \n-      template<typename _UHead>\n+      template<typename _UHead, typename = typename\n+\t       enable_if<!is_convertible<_UHead,\n+\t                                 __uses_alloc_base>::value>::type>\n         _Head_base(_UHead&& __h)\n \t: _Head(std::forward<_UHead>(__h)) { }\n \n+      _Head_base(__uses_alloc0)\n+      : _Head() { }\n+\n+      template<typename _Alloc>\n+\t_Head_base(__uses_alloc1<_Alloc> __a)\n+\t: _Head(allocator_arg, *__a._M_a) { }\n+\n+      template<typename _Alloc>\n+\t_Head_base(__uses_alloc2<_Alloc> __a)\n+\t: _Head(*__a._M_a) { }\n+\n+      template<typename _UHead>\n+\t_Head_base(__uses_alloc0, _UHead&& __uhead)\n+\t: _Head(std::forward<_UHead>(__uhead)) { }\n+\n+      template<typename _Alloc, typename _UHead>\n+\t_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n+\t: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }\n+\n+      template<typename _Alloc, typename _UHead>\n+\t_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n+\t: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }\n+\n       _Head&       _M_head() noexcept       { return *this; }\n       const _Head& _M_head() const noexcept { return *this; }\n     };\n@@ -98,10 +124,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Head_base(const _Head& __h)\n       : _M_head_impl(__h) { }\n \n-      template<typename _UHead>\n+      template<typename _UHead, typename = typename\n+\t       enable_if<!is_convertible<_UHead,\n+\t                                 __uses_alloc_base>::value>::type>\n         _Head_base(_UHead&& __h)\n \t: _M_head_impl(std::forward<_UHead>(__h)) { }\n \n+      _Head_base(__uses_alloc0)\n+      : _M_head_impl() { }\n+\n+      template<typename _Alloc>\n+\t_Head_base(__uses_alloc1<_Alloc> __a)\n+\t: _M_head_impl(allocator_arg, *__a._M_a) { }\n+\n+      template<typename _Alloc>\n+\t_Head_base(__uses_alloc2<_Alloc> __a)\n+\t: _M_head_impl(*__a._M_a) { }\n+\n+      template<typename _UHead>\n+\t_Head_base(__uses_alloc0, _UHead&& __uhead)\n+\t: _M_head_impl(std::forward<_UHead>(__uhead)) { }\n+\n+      template<typename _Alloc, typename _UHead>\n+\t_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n+\t: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))\n+\t{ }\n+\n+      template<typename _Alloc, typename _UHead>\n+\t_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n+\t: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }\n+\n       _Head&       _M_head() noexcept       { return _M_head_impl; }\n       const _Head& _M_head() const noexcept { return _M_head_impl; }        \n \n@@ -128,6 +180,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       template<std::size_t, typename...> friend class _Tuple_impl;\n \n+      _Tuple_impl() = default;\n+\n+      template<typename _Alloc>\n+        _Tuple_impl(allocator_arg_t, const _Alloc&) { }\n+\n+      template<typename _Alloc>\n+        _Tuple_impl(allocator_arg_t, const _Alloc&, const _Tuple_impl&) { }\n+\n+      template<typename _Alloc>\n+        _Tuple_impl(allocator_arg_t, const _Alloc&, _Tuple_impl&&) { }\n+\n     protected:\n       void _M_swap(_Tuple_impl&) noexcept { /* no-op */ }\n     };\n@@ -160,7 +223,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)\n       : _Inherited(__tail...), _Base(__head) { }\n \n-      template<typename _UHead, typename... _UTail> \n+      template<typename _UHead, typename... _UTail, typename = typename\n+               std::enable_if<sizeof...(_Tail)==sizeof...(_UTail)>::type> \n         explicit\n         _Tuple_impl(_UHead&& __head, _UTail&&... __tail)\n \t: _Inherited(std::forward<_UTail>(__tail)...),\n@@ -183,6 +247,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Inherited(std::move(__in._M_tail())),\n \t  _Base(std::forward<_UHead>(__in._M_head())) { }\n \n+      template<typename _Alloc>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n+\t: _Inherited(__tag, __a),\n+          _Base(__use_alloc<_Head>(__a)) { }\n+\n+      template<typename _Alloc>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t    const _Head& __head, const _Tail&... __tail)\n+\t: _Inherited(__tag, __a, __tail...),\n+          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }\n+\n+      template<typename _Alloc, typename _UHead, typename... _UTail,\n+               typename = typename std::enable_if<sizeof...(_Tail)\n+\t\t                                  ==sizeof...(_UTail)>::type>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t            _UHead&& __head, _UTail&&... __tail)\n+\t: _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),\n+          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n+\t        std::forward<_UHead>(__head)) { }\n+\n+      template<typename _Alloc>\n+        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t            const _Tuple_impl& __in)\n+\t: _Inherited(__tag, __a, __in._M_tail()), \n+          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __in._M_head()) { }\n+\n+      template<typename _Alloc>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t            _Tuple_impl&& __in)\n+\tnoexcept(std::is_nothrow_move_constructible<_Head>::value\n+\t\t && std::is_nothrow_move_constructible<_Inherited>::value)\n+\t: _Inherited(__tag, __a, std::move(__in._M_tail())), \n+\t  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n+\t        std::forward<_Head>(__in._M_head())) { }\n+\n+      template<typename _Alloc, typename... _UElements>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t            const _Tuple_impl<_Idx, _UElements...>& __in)\n+\t: _Inherited(__tag, __a, __in._M_tail()),\n+\t  _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __in._M_head()) { }\n+\n+      template<typename _Alloc, typename _UHead, typename... _UTails>\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t            _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n+\t: _Inherited(__tag, __a, std::move(__in._M_tail())),\n+\t  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n+                std::forward<_UHead>(__in._M_head())) { }\n+\n       _Tuple_impl&\n       operator=(const _Tuple_impl& __in)\n       {\n@@ -269,6 +381,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         tuple(tuple<_UElements...>&& __in)\n         : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n+      // allocator-extended constructors\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a)\n+\t: _Inherited(__tag, __a) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const _Elements&... __elements)\n+\t: _Inherited(__tag, __a, __elements...) { }\n+\n+      template<typename _Alloc, typename... _UElements, typename = typename\n+\t       std::enable_if<sizeof...(_UElements)\n+\t\t\t      == sizeof...(_Elements)>::type>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      _UElements&&... __elements)\n+\t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n+       \t{ }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n+\t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n+\n+      template<typename _Alloc, typename... _UElements, typename = typename\n+\t       std::enable_if<sizeof...(_UElements)\n+\t\t\t      == sizeof...(_Elements)>::type>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_UElements...>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename... _UElements, typename = typename\n+\t       std::enable_if<sizeof...(_UElements)\n+\t\t\t      == sizeof...(_Elements)>::type>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      tuple<_UElements...>&& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n+\t{ }\n+\n       tuple&\n       operator=(const tuple& __in)\n       {\n@@ -356,6 +513,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n+      // allocator-extended constructors\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a)\n+\t: _Inherited(__tag, __a) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const _T1& __a1, const _T2& __a2)\n+\t: _Inherited(__tag, __a, __a1, __a2) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)\n+\t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n+\t             std::forward<_U2>(__a2)) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n+\t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+        tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const pair<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a, __in.first, __in.second) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n+\t\t     std::forward<_U2>(__in.second)) { }\n+\n       tuple&\n       operator=(const tuple& __in)\n       {\n@@ -426,7 +629,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _Inherited(__a1) { }\n \n       template<typename _U1, typename = typename\n-\t       std::enable_if<std::is_convertible<_U1, _T1>::value>::type>\n+\t       std::enable_if<std::is_constructible<_T1, _U1&&>::value>::type>\n         explicit\n         tuple(_U1&& __a1)\n \t: _Inherited(std::forward<_U1>(__a1)) { }\n@@ -442,6 +645,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         tuple(tuple<_U1>&& __in)\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1>&&>(__in)) { }\n \n+      // allocator-extended constructors\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a)\n+\t: _Inherited(__tag, __a) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const _T1& __a1)\n+\t: _Inherited(__tag, __a, __a1) { }\n+\n+      // TODO: constrain for is_uses_allocator_constructible<_T1, _U1&&, _Alloc>\n+      template<typename _Alloc, typename _U1>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1)\n+\t: _Inherited(__tag, __a, std::forward<_U1>(__a1)) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n+\t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n+\n+      template<typename _Alloc>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n+\n+      template<typename _Alloc, typename _U1>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple<_U1>& __in)\n+\t: _Inherited(__tag, __a, static_cast<const _Tuple_impl<0, _U1>&>(__in))\n+       \t{ }\n+\n+      template<typename _Alloc, typename _U1>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1>&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1>&&>(__in)) { }\n+\n       tuple&\n       operator=(const tuple& __in)\n       {\n@@ -804,6 +1039,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   const _Swallow_assign ignore{};\n \n+  /// Partial specialization for tuples\n+  template<typename... _Types, typename _Alloc>\n+    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };\n+\n   /**\n    * Stores a tuple of indices. Used by bind() to extract the elements\n    * in a tuple. "}, {"sha": "d729178b609a36b552156f91e9ce6432837eec1e", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/allocate_noncopyable.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocate_noncopyable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocate_noncopyable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocate_noncopyable.cc?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.4.2.1 [tuple.cnstr] Allocator-extended constructors\n+\n+#include <memory>\n+#include <tuple>\n+\n+struct MyAlloc { };\n+\n+struct Tag0 { };\n+struct Tag1 { };\n+struct Tag2 { };\n+\n+// A non-copyable and non-movable type\n+struct Type\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  explicit Type(Tag0) { }\n+  Type(std::allocator_arg_t, MyAlloc, Tag1) { }\n+  Type(Tag2, MyAlloc) { }\n+\n+  Type(const Type&) = delete;\n+  Type(Type&&) = delete;\n+  Type& operator=(const Type&) = delete;\n+  Type& operator=(Type&&) = delete;\n+};\n+\n+void test01()\n+{\n+  using std::allocator_arg;\n+  using std::tuple;\n+\n+  MyAlloc a;\n+  Tag0 tag0;\n+  Tag1 tag1;\n+  Tag2 tag2;\n+\n+  // N.B. cannot use Tag0 with uses-allocator construction, because\n+  // uses_allocator<Type, MyAlloc> is true but no suitable cosntructor\n+  tuple<Type>\t\t  t1(tag0);\n+\n+  tuple<Type> \t\t  t2(allocator_arg, a, tag1);\n+  tuple<Type> \t\t  t3(allocator_arg, a, tag2);\n+\n+  tuple<Type, Type> \t  t4(allocator_arg, a, tag1, tag2);\n+\n+  tuple<Type, Type, Type> t5(allocator_arg, a, tag2, tag1, tag2);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ae9dc8d7be20a299510a878441fb0680815e9cd2", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -0,0 +1,169 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.4.2.1 [tuple.cnstr] Allocator-extended constructors\n+\n+#include <memory>\n+#include <tuple>\n+#include <testsuite_hooks.h>\n+\n+struct MyAlloc { };\n+\n+// type that can't be constructed with an allocator\n+struct CannotUse\n+{\n+  CannotUse(int = 0, int = 0) : ok(true) { }\n+\n+  bool ok;\n+};\n+\n+// type that can be constructed with an allocator\n+// but which has uses_allocator == false\n+struct DoesNotUse\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  DoesNotUse(int = 0) : ok(true) { }\n+  DoesNotUse(std::allocator_arg_t, MyAlloc, int = 0) : ok(false) { }\n+  DoesNotUse(MyAlloc) : ok(false) { }\n+  DoesNotUse(int, MyAlloc) : ok(false) { }\n+\n+  DoesNotUse(const DoesNotUse&) : ok(true) { }\n+  DoesNotUse(std::allocator_arg_t, MyAlloc, const DoesNotUse&) : ok(false) { }\n+  DoesNotUse(const DoesNotUse&, MyAlloc) : ok(false) { }\n+\n+  DoesNotUse(DoesNotUse&&) : ok(true) { }\n+  DoesNotUse(std::allocator_arg_t, MyAlloc, DoesNotUse&&) : ok(false) { }\n+  DoesNotUse(DoesNotUse&&, MyAlloc) : ok(false) { }\n+\n+  bool ok;\n+};\n+\n+namespace std\n+{\n+  template<typename A> \n+    struct uses_allocator<DoesNotUse, A> : false_type { };\n+}\n+\n+// type that can be constructed with an allocator as second argument\n+struct UsesWithTag\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  UsesWithTag(int = 0) : ok(false) { }\n+  UsesWithTag(std::allocator_arg_t, MyAlloc, int = 0) : ok(true) { }\n+  UsesWithTag(MyAlloc) : ok(false) {  }\n+  UsesWithTag(int, MyAlloc) : ok(false) {  }\n+\n+  UsesWithTag(const UsesWithTag&) : ok(false) { }\n+  UsesWithTag(std::allocator_arg_t, MyAlloc, const UsesWithTag&) : ok(true) { }\n+  UsesWithTag(const UsesWithTag&, MyAlloc) : ok(false) {  }\n+\n+  UsesWithTag(UsesWithTag&&) : ok(false) { }\n+  UsesWithTag(std::allocator_arg_t, MyAlloc, UsesWithTag&&) : ok(true) { }\n+  UsesWithTag(UsesWithTag&&, MyAlloc) : ok(false) {  }\n+\n+  bool ok;\n+};\n+\n+// type that can be constructed with an allocator as last argument\n+struct UsesWithoutTag\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  UsesWithoutTag(int = 0) : ok(false) { }\n+  UsesWithoutTag(MyAlloc) : ok(true) { }\n+  UsesWithoutTag(int, MyAlloc) : ok(true) { }\n+\n+  UsesWithoutTag(const UsesWithoutTag&) : ok(false) { }\n+  UsesWithoutTag(const UsesWithoutTag&, MyAlloc) : ok(true) { }\n+\n+  UsesWithoutTag(UsesWithoutTag&&) : ok(false) { }\n+  UsesWithoutTag(UsesWithoutTag&&, MyAlloc) : ok(true) { }\n+\n+  bool ok;\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::allocator_arg;\n+  using std::tuple;\n+  using std::make_tuple;\n+  using std::get;\n+\n+  typedef CannotUse T1;\n+  typedef DoesNotUse T2;\n+  typedef UsesWithTag T3;\n+  typedef UsesWithoutTag T4;\n+  typedef tuple<T1, T2, T3, T4> test_type;\n+\n+  MyAlloc a;\n+\n+  // default construction\n+  test_type t1(allocator_arg, a);\n+  VERIFY( get<0>(t1).ok );\n+  VERIFY( get<1>(t1).ok );\n+  VERIFY( get<2>(t1).ok );\n+  VERIFY( get<3>(t1).ok );\n+\n+  // copy construction\n+  test_type t2(allocator_arg, a, t1);\n+  VERIFY( get<0>(t2).ok );\n+  VERIFY( get<1>(t2).ok );\n+  VERIFY( get<2>(t2).ok );\n+  VERIFY( get<3>(t2).ok );\n+\n+  // move construction\n+  test_type t3(allocator_arg, a, std::move(t1));\n+  VERIFY( get<0>(t3).ok );\n+  VERIFY( get<1>(t3).ok );\n+  VERIFY( get<2>(t3).ok );\n+  VERIFY( get<3>(t3).ok );\n+\n+  // construction from int\n+  test_type t4(allocator_arg, a, 1, 2, 3, 4);\n+  VERIFY( get<0>(t4).ok );\n+  VERIFY( get<1>(t4).ok );\n+  VERIFY( get<2>(t4).ok );\n+  VERIFY( get<3>(t4).ok );\n+\n+  auto ints = make_tuple(1, 2, 3, 4);\n+\n+  // construction from lvalue tuple of ints\n+  test_type t5(allocator_arg, a, ints);\n+  VERIFY( get<0>(t5).ok );\n+  VERIFY( get<1>(t5).ok );\n+  VERIFY( get<2>(t5).ok );\n+  VERIFY( get<3>(t2).ok );\n+\n+  // construction from rvalue tuple of ints\n+  test_type t6(allocator_arg, a, std::move(ints));\n+  VERIFY( get<0>(t6).ok );\n+  VERIFY( get<1>(t6).ok );\n+  VERIFY( get<2>(t6).ok );\n+  VERIFY( get<3>(t6).ok );\n+\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b6b706c67eba2ad2ab6d284730caf8b0ff6995d7", "filename": "libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fcons_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fcons_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fcons_neg.cc?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.4.2.1 [tuple.cnstr] Allocator-extended constructors\n+\n+#include <memory>\n+#include <tuple>\n+\n+struct MyAlloc { };\n+\n+struct Type\n+{\n+  typedef MyAlloc allocator_type; // uses_allocator<Type, MyAlloc> is true\n+\n+  explicit Type(int) { }\n+\n+  Type(std::allocator_arg_t, MyAlloc) { }\n+  Type(MyAlloc) { }\n+};\n+\n+void test01()\n+{\n+  using std::allocator_arg;\n+  using std::tuple;\n+\n+  MyAlloc a;\n+\n+  tuple<Type> t(allocator_arg, a, 1);\n+}\n+// { dg-error \"no matching function\" \"\" { target *-*-* } 112 }\n+// { dg-excess-errors \"note\" }"}, {"sha": "94fca79c25233ae1f86ded6b6992e2d5cf080591", "filename": "libstdc++-v3/testsuite/20_util/uses_allocator/construction.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fconstruction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b821466067dd32988497bc8166fe0ae13f9a3b8e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fconstruction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fconstruction.cc?ref=b821466067dd32988497bc8166fe0ae13f9a3b8e", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.6.7.2 uses-allocator construction\n+\n+#include <memory>\n+#include <tuple>\n+#include <testsuite_hooks.h>\n+\n+struct MyAlloc { };\n+\n+// type that can't be constructed with an allocator\n+struct CannotUse\n+{\n+  CannotUse(int) : ok(true) { }\n+\n+  bool ok;\n+};\n+\n+// type that can be constructed with an allocator\n+// but which has uses_allocator == false\n+struct DoesNotUse\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  DoesNotUse(int) : ok(true) { }\n+  DoesNotUse(std::allocator_arg_t, MyAlloc, int) : ok(false) { }\n+  DoesNotUse(int, MyAlloc) : ok(false) { }\n+\n+  bool ok;\n+};\n+\n+namespace std\n+{\n+  template<typename A> \n+    struct uses_allocator<DoesNotUse, A> : false_type { };\n+}\n+\n+// type that can be constructed with an allocator as second argument\n+struct UsesWithTag\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  UsesWithTag(int) : ok(false) { }\n+  UsesWithTag(std::allocator_arg_t, MyAlloc, int) : ok(true) { }\n+  UsesWithTag(int, MyAlloc) : ok(false) {  }\n+\n+  bool ok;\n+};\n+\n+// type that can be constructed with an allocator as last argument\n+struct UsesWithoutTag\n+{\n+  typedef MyAlloc allocator_type;\n+\n+  UsesWithoutTag(int) : ok(false) { }\n+  UsesWithoutTag(int, MyAlloc) : ok(true) { }\n+\n+  bool ok;\n+};\n+\n+\n+template<typename TestType, typename... T>\n+  bool test2(T... args)\n+  {\n+    using std::allocator_arg;\n+    using std::tuple;\n+    using std::get;\n+\n+    tuple<TestType, T...> t(allocator_arg, MyAlloc(), 1, args...);\n+\n+    return get<0>(t).ok;\n+  }\n+\n+template<typename... T>\n+  void test(T... args)\n+  {\n+    bool test __attribute__((unused)) = true;\n+\n+    VERIFY( test2<CannotUse>(args...) );\n+    VERIFY( test2<DoesNotUse>(args...) );\n+    VERIFY( test2<UsesWithTag>(args...) );\n+    VERIFY( test2<UsesWithoutTag>(args...) );\n+  }\n+\n+int main()\n+{\n+  test();\n+  test(1);\n+  test(1, 2);\n+  return 0;\n+}"}]}