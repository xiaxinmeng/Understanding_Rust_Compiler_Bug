{"sha": "cc806ac109a1cc625e80d9a38d94a7a589a559ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M4MDZhYzEwOWExY2M2MjVlODBkOWEzOGQ5NGE3YTU4OWE1NTllZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-04-21T18:55:13Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-04-21T18:55:13Z"}, "message": "dbgcnt.def (ra_byte_scan): Added.\n\n2008-04-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* dbgcnt.def (ra_byte_scan): Added.\n\t* dbgcnt.c (dbg_cnt): Added code to print message to dump_file\n\twhen the last hit happens for a counter.  \n\t* timevar.def (TV_DF_BYTE_LR): New variable.\n\t* tree-pass.h (pass_fast_rtl_byte_dce): New pass.\n\t* passes.c (pass_fast_rtl_byte_dce): New pass.\n\t* fwprop.c (update_df): Added mode to call df_ref_create.\n\tRenamed DF_REF_WIDTH and DF_REF_OFFSET to DF_REF_EXTRACT_WIDTH and\n\tDF_REF_EXTRACT_OFFSET.\n\t* df.h (DF_BYTE_LR, DF_BYTE_LR_BB_INFO, DF_BYTE_LR_IN, \n\tDF_BYTE_LR_OUT, df_byte_lr): New macro.\n\t(df_mm): New enum.\n\t(df_ref_extract): Added mode field.\n\t(DF_REF_WIDTH, DF_REF_OFFSET) Renamed to DF_REF_EXTRACT_WIDTH and\n\tDF_REF_EXTRACT_OFFSET.\n\t(DF_REF_EXTRACT_MODE): New macro.\n\t(df_byte_lr_bb_info): New structure.\n\t(df_print_byte_regset, df_compute_accessed_bytes, \n\tdf_byte_lr_add_problem, df_byte_lr_get_regno_start,\n\tdf_byte_lr_get_regno_len, df_byte_lr_simulate_defs,\n\tdf_byte_lr_simulate_uses,\n\tdf_byte_lr_simulate_artificial_refs_at_top,\n\tdf_byte_lr_simulate_artificial_refs_at_end,\n\tdf_compute_accessed_bytes): New function.\n\t(df_ref_create): Add parameter.\n\t(df_byte_lr_get_bb_info): New inline function.\n\t* df-scan.c (df_ref_record, df_uses_record,\n\tdf_ref_create_structure): Added mode parameter.\n\t(df_ref_create, df_notes_rescan, df_ref_record, df_def_record_1, \n\tdf_defs_record, df_uses_record, df_get_conditional_uses,\n\tdf_get_call_refs, df_insn_refs_collect, df_bb_refs_collect, \n\tdf_entry_block_defs_collect, df_exit_block_uses_collect):\n\tAdded mode parameter to calls to df_ref_record, df_uses_record,\n\tdf_ref_create_structure.\n       \t(df_ref_equal_p, df_ref_compare): Added test for modes.\n\t(df_ref_create_structure): Added code to set mode.  Renamed\n\tDF_REF_WIDTH and DF_REF_OFFSET to DF_REF_EXTRACT_WIDTH and\n\tDF_REF_EXTRACT_OFFSET.\n\t* df-core.c (df_print_byte_regset): New function.\n\t* df-byte-scan.c: New file.\n\t* df-problems.c (df_rd_transfer_function): Removed unnecessary\n\tcalls to BITMAP_FREE.  \n\t(df_byte_lr_problem_data, df_problem problem_BYTE_LR): New structure.\n\t(df_byte_lr_get_regno_start, df_byte_lr_get_regno_len,\n\tdf_byte_lr_set_bb_info, df_byte_lr_free_bb_info, \n\tdf_byte_lr_check_regs, df_byte_lr_expand_bitmap, \n\tdf_byte_lr_alloc, df_byte_lr_reset, df_byte_lr_bb_local_compute,\n\tdf_byte_lr_local_compute, df_byte_lr_init,\n\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n, \n\tdf_byte_lr_transfer_function, df_byte_lr_free, \n\tdf_byte_lr_top_dump, df_byte_lr_bottom_dump,\n\tdf_byte_lr_add_problem, df_byte_lr_simulate_defs, \n\tdf_byte_lr_simulate_uses,\n\tdf_byte_lr_simulate_artificial_refs_at_top,\n\tdf_byte_lr_simulate_artificial_refs_at_end): New function.\n\t* dce.c (byte_dce_process_block): New function.\n\t(dce_process_block): au is now passed in rather than computed\n\tlocally.  Changed loops that look at artificial defs to not look\n\tfor conditional or partial ones, because there never are any.  \n\t(fast_dce): Now is able to drive byte_dce_process_block or \n\tdce_process_block depending on the kind of dce being done.\n\t(rest_of_handle_fast_dce): Add parameter to fast_dce.\n\t(rest_of_handle_fast_byte_dce): New function.\n\t(rtl_opt_pass pass_fast_rtl_byte_dce): New pass.\n\t* Makefile.in (df-byte-scan.o, debugcnt.o): Added dependencies.\n\n\n\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r134523", "tree": {"sha": "7a1b19b42f86a47fffcfe11926a453b8d560f7dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a1b19b42f86a47fffcfe11926a453b8d560f7dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc806ac109a1cc625e80d9a38d94a7a589a559ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc806ac109a1cc625e80d9a38d94a7a589a559ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc806ac109a1cc625e80d9a38d94a7a589a559ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc806ac109a1cc625e80d9a38d94a7a589a559ee/comments", "author": null, "committer": null, "parents": [{"sha": "f7546fa716b5617bd46712f6b042b1f40c31fe68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7546fa716b5617bd46712f6b042b1f40c31fe68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7546fa716b5617bd46712f6b042b1f40c31fe68"}], "stats": {"total": 1484, "additions": 1318, "deletions": 166}, "files": [{"sha": "ed1c788617f9da06caecb741647f667e8b48184a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -1,3 +1,73 @@\n+2008-04-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* dbgcnt.def (ra_byte_scan): Added.\n+\t* dbgcnt.c (dbg_cnt): Added code to print message to dump_file\n+\twhen the last hit happens for a counter.  \n+\t* timevar.def (TV_DF_BYTE_LR): New variable.\n+\t* tree-pass.h (pass_fast_rtl_byte_dce): New pass.\n+\t* passes.c (pass_fast_rtl_byte_dce): New pass.\n+\t* fwprop.c (update_df): Added mode to call df_ref_create.\n+\tRenamed DF_REF_WIDTH and DF_REF_OFFSET to DF_REF_EXTRACT_WIDTH and\n+\tDF_REF_EXTRACT_OFFSET.\n+\t* df.h (DF_BYTE_LR, DF_BYTE_LR_BB_INFO, DF_BYTE_LR_IN, \n+\tDF_BYTE_LR_OUT, df_byte_lr): New macro.\n+\t(df_mm): New enum.\n+\t(df_ref_extract): Added mode field.\n+\t(DF_REF_WIDTH, DF_REF_OFFSET) Renamed to DF_REF_EXTRACT_WIDTH and\n+\tDF_REF_EXTRACT_OFFSET.\n+\t(DF_REF_EXTRACT_MODE): New macro.\n+\t(df_byte_lr_bb_info): New structure.\n+\t(df_print_byte_regset, df_compute_accessed_bytes, \n+\tdf_byte_lr_add_problem, df_byte_lr_get_regno_start,\n+\tdf_byte_lr_get_regno_len, df_byte_lr_simulate_defs,\n+\tdf_byte_lr_simulate_uses,\n+\tdf_byte_lr_simulate_artificial_refs_at_top,\n+\tdf_byte_lr_simulate_artificial_refs_at_end,\n+\tdf_compute_accessed_bytes): New function.\n+\t(df_ref_create): Add parameter.\n+\t(df_byte_lr_get_bb_info): New inline function.\n+\t* df-scan.c (df_ref_record, df_uses_record,\n+\tdf_ref_create_structure): Added mode parameter.\n+\t(df_ref_create, df_notes_rescan, df_ref_record, df_def_record_1, \n+\tdf_defs_record, df_uses_record, df_get_conditional_uses,\n+\tdf_get_call_refs, df_insn_refs_collect, df_bb_refs_collect, \n+\tdf_entry_block_defs_collect, df_exit_block_uses_collect):\n+\tAdded mode parameter to calls to df_ref_record, df_uses_record,\n+\tdf_ref_create_structure.\n+       \t(df_ref_equal_p, df_ref_compare): Added test for modes.\n+\t(df_ref_create_structure): Added code to set mode.  Renamed\n+\tDF_REF_WIDTH and DF_REF_OFFSET to DF_REF_EXTRACT_WIDTH and\n+\tDF_REF_EXTRACT_OFFSET.\n+\t* df-core.c (df_print_byte_regset): New function.\n+\t* df-byte-scan.c: New file.\n+\t* df-problems.c (df_rd_transfer_function): Removed unnecessary\n+\tcalls to BITMAP_FREE.  \n+\t(df_byte_lr_problem_data, df_problem problem_BYTE_LR): New structure.\n+\t(df_byte_lr_get_regno_start, df_byte_lr_get_regno_len,\n+\tdf_byte_lr_set_bb_info, df_byte_lr_free_bb_info, \n+\tdf_byte_lr_check_regs, df_byte_lr_expand_bitmap, \n+\tdf_byte_lr_alloc, df_byte_lr_reset, df_byte_lr_bb_local_compute,\n+\tdf_byte_lr_local_compute, df_byte_lr_init,\n+\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n, \n+\tdf_byte_lr_transfer_function, df_byte_lr_free, \n+\tdf_byte_lr_top_dump, df_byte_lr_bottom_dump,\n+\tdf_byte_lr_add_problem, df_byte_lr_simulate_defs, \n+\tdf_byte_lr_simulate_uses,\n+\tdf_byte_lr_simulate_artificial_refs_at_top,\n+\tdf_byte_lr_simulate_artificial_refs_at_end): New function.\n+\t* dce.c (byte_dce_process_block): New function.\n+\t(dce_process_block): au is now passed in rather than computed\n+\tlocally.  Changed loops that look at artificial defs to not look\n+\tfor conditional or partial ones, because there never are any.  \n+\t(fast_dce): Now is able to drive byte_dce_process_block or \n+\tdce_process_block depending on the kind of dce being done.\n+\t(rest_of_handle_fast_dce): Add parameter to fast_dce.\n+\t(rest_of_handle_fast_byte_dce): New function.\n+\t(rtl_opt_pass pass_fast_rtl_byte_dce): New pass.\n+\t* Makefile.in (df-byte-scan.o, debugcnt.o): Added dependencies.\n+\n+\n 2008-04-21  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/35019"}, {"sha": "c88bbcd4b97c0ac4f21a53c775a4550fb010b500", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -797,7 +797,7 @@ IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h bitmap.h $(TREE_H)\n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)\n CGRAPH_H = cgraph.h $(TREE_H)\n-DF_H = df.h bitmap.h $(BASIC_BLOCK_H) alloc-pool.h\n+DF_H = df.h bitmap.h $(BASIC_BLOCK_H) alloc-pool.h \n RESOURCE_H = resource.h hard-reg-set.h $(DF_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h\n@@ -1026,6 +1026,7 @@ OBJS-common = \\\n \tdce.o \\\n \tddg.o \\\n \tdebug.o \\\n+\tdf-byte-scan.o \\\n \tdf-core.o \\\n \tdf-problems.o \\\n \tdf-scan.o \\\n@@ -2617,6 +2618,8 @@ df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n    $(FLAGS_H) $(TARGET_H) $(TARGET_DEF_H) $(TREE_H) output.h tree-pass.h\n+df-byte-scan.o : df-byte-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(DF_H) output.h $(DBGCNT_H)\n regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) $(FLAGS_H) $(REGS_H) output.h except.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(TIMEVAR_H) $(DF_H)\n@@ -2729,7 +2732,7 @@ global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n ra-conflict.o : ra-conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h $(DF_H) $(RA_H) sbitmap.h \n+   $(TIMEVAR_H) vecprim.h $(DF_H) $(RA_H) sbitmap.h\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) toplev.h\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\\n@@ -2882,7 +2885,8 @@ hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n pretty-print.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h $(PRETTY_PRINT_H) \\\n    $(TREE_H)\n errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h $(BCONFIG_H)\n-dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DBGCNT_H)\n+dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DBGCNT_H) $(TM_H) \\\n+   $(RTL_H) output.h\n lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) bitmap.h \\"}, {"sha": "47ba28a96489ac4d73adcbb96b501678b9955bc3", "filename": "gcc/dbgcnt.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdbgcnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdbgcnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -23,6 +23,9 @@ See dbgcnt.def for usage information.  */\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"errors.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n \n #include \"dbgcnt.h\"\n \n@@ -58,6 +61,10 @@ bool\n dbg_cnt (enum debug_counter index)\n {\n   count[index]++;\n+  if (dump_file && count[index] == limit[index])\n+    fprintf (dump_file, \"***dbgcnt: limit reached for %s.***\\n\", \n+\t     map[index].name);\n+\n   return dbg_cnt_is_enabled (index);\n }\n \n@@ -132,7 +139,8 @@ dbg_cnt_process_opt (const char *arg)\n \n /* Print name, limit and count of all counters.   */\n \n-void dbg_cnt_list_all_counters (void)\n+void \n+dbg_cnt_list_all_counters (void)\n {\n   int i;\n   printf (\"  %-30s %-5s %-5s\\n\", \"counter name\",  \"limit\", \"value\");"}, {"sha": "7a59af30e20bf47660f321a5b30966d5b67c9ab6", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -61,6 +61,83 @@ along with GCC; see the file COPYING3.  If not see\n    Use -fdbg-cnt=counter1:N,counter2:M,...\n    which sets the limit for counter1 to N, and the limit for counter2 to M, etc.\n    e.g. setting a limit to zero will make dbg_cnt () return false *always*.\n+\n+   The following shell file can then be used to binary search for\n+   exact transformation that causes the bug.  A second shell script\n+   should be written, say \"tryTest\", which exits with 1 if the\n+   compiled program fails and exits with 0 if the program succeeds.\n+   This shell script should take 1 parameter, the value to be passed\n+   to set the counter of the compilation command in tryTest.  Then,\n+   assuming that the following script is called binarySearch,\n+   the command:\n+\n+\tbinarySearch tryTest \n+\n+   will automatically find the highest value of the counter for which\n+   the program fails.  If tryTest never fails, binarySearch will\n+   produce unpredictable results as it will try to find an upper bound\n+   that does not exist.\n+\n+   When dbgcnt does hits the limit, it writes a comment in the current\n+   dump_file of the form:\n+\n+       ***dbgcnt: limit reached for %s.***\n+\t\n+   Assuming that the dump file is logging the analysis/transformations\n+   it is making, this pinpoints the exact position in the log file\n+   where the problem transformation is being logged.\n+\n+=====================================\n+#!/bin/bash\n+\n+while getopts \"l:u:i:\" opt\n+do\n+    case $opt in\n+        l) lb=\"$OPTARG\";;\n+        u) ub=\"$OPTARG\";;\n+        i) init=\"$OPTARG\";;\n+        ?) usage; exit 3;;\n+    esac\n+done\n+\n+shift $(($OPTIND - 1))\n+echo $@\n+cmd=${1+\"${@}\"}\n+\n+lb=${lb:=0}\n+init=${init:=100}\n+\n+$cmd $lb\n+lb_val=$?\n+if [ -z \"$ub\" ]; then\n+    # find the upper bound\n+    ub=$(($init + $lb))\n+    true\n+    while [ $? -eq $lb_val ]; do\n+        ub=$(($ub * 10))\n+        #ub=`expr $ub \\* 10`\n+        $cmd $ub\n+    done\n+fi\n+\n+echo command: $cmd\n+\n+true\n+while [ `expr $ub - $lb` -gt 1 ]; do\n+    try=$(($lb + ( $ub - $lb ) / 2))\n+    $cmd $try\n+    if [ $? -eq $lb_val ]; then\n+        lb=$try\n+    else\n+        ub=$try\n+    fi\n+done\n+\n+echo lbound: $lb\n+echo ubound: $ub\n+\n+=====================================\n+\n */\n \n /* Debug counter definitions.  */\n@@ -73,6 +150,7 @@ DEBUG_COUNTER (dce)\n DEBUG_COUNTER (dce_fast)\n DEBUG_COUNTER (dce_ud)\n DEBUG_COUNTER (delete_trivial_dead)\n+DEBUG_COUNTER (df_byte_scan)\n DEBUG_COUNTER (dse)\n DEBUG_COUNTER (dse1)\n DEBUG_COUNTER (dse2)"}, {"sha": "7b2ffe92581d6d97ea4684bd199819f1415d0401", "filename": "gcc/dce.c", "status": "modified", "additions": 171, "deletions": 53, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -1,5 +1,5 @@\n /* RTL dead code elimination.\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -593,17 +593,18 @@ struct rtl_opt_pass pass_ud_rtl_dce =\n    Fast DCE functions\n    ------------------------------------------------------------------------- */\n \n-/* Process basic block BB.  Return true if the live_in set has changed.  */\n+/* Process basic block BB.  Return true if the live_in set has\n+   changed. REDO_OUT is true if the info at the bottom of the block\n+   needs to be recalculated before starting.  AU is the proper set of\n+   artificial uses. */\n \n static bool\n-dce_process_block (basic_block bb, bool redo_out)\n+byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n {\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n-  bitmap au;\n   rtx insn;\n   bool block_changed;\n-  struct df_ref **def_rec, **use_rec;\n-  unsigned int bb_index = bb->index;\n+  struct df_ref **def_rec;\n \n   if (redo_out)\n     {\n@@ -612,44 +613,125 @@ dce_process_block (basic_block bb, bool redo_out)\n \t set.  */\n       edge e;\n       edge_iterator ei;\n-      df_confluence_function_n con_fun_n = df_lr->problem->con_fun_n;\n-      bitmap_clear (DF_LR_OUT (bb));\n+      df_confluence_function_n con_fun_n = df_byte_lr->problem->con_fun_n;\n+      bitmap_clear (DF_BYTE_LR_OUT (bb));\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t(*con_fun_n) (e);\n     }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"processing block %d live out = \", bb->index);\n-      df_print_regset (dump_file, DF_LR_OUT (bb));\n+      df_print_byte_regset (dump_file, DF_BYTE_LR_OUT (bb));\n     }\n \n-  bitmap_copy (local_live, DF_LR_OUT (bb));\n+  bitmap_copy (local_live, DF_BYTE_LR_OUT (bb));\n+\n+  df_byte_lr_simulate_artificial_refs_at_end (bb, local_live);\n+\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n+    if (INSN_P (insn))\n+      {\n+\t/* The insn is needed if there is someone who uses the output.  */\n+\tfor (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t  {\n+\t    struct df_ref *def = *def_rec;\n+\t    unsigned int last;\n+\t    unsigned int dregno = DF_REF_REGNO (def);\n+\t    unsigned int start = df_byte_lr_get_regno_start (dregno);\n+\t    unsigned int len = df_byte_lr_get_regno_len (dregno);\n+\n+\t    unsigned int sb;\n+\t    unsigned int lb;\n+\t    /* This is one of the only places where DF_MM_MAY should\n+\t       be used for defs.  Need to make sure that we are\n+\t       checking for all of the bits that may be used.  */\n+\n+\t    if (!df_compute_accessed_bytes (def, DF_MM_MAY, &sb, &lb))\n+\t      {\n+\t\tstart += sb;\n+\t\tlen = lb - sb;\n+\t      }\n+\n+\t    if (bitmap_bit_p (au, dregno))\n+\t      {\n+\t\tmark_insn (insn, true);\n+\t\tgoto quickexit;\n+\t      }\n+\t    \n+\t    last = start + len;\n+\t    while (start < last)\n+\t      if (bitmap_bit_p (local_live, start++))\n+\t\t{\n+\t\t  mark_insn (insn, true);\n+\t\t  goto quickexit;\n+\t\t}\n+\t  }\n+\t\n+      quickexit: \n+\t\n+\t/* No matter if the instruction is needed or not, we remove\n+\t   any regno in the defs from the live set.  */\n+\tdf_byte_lr_simulate_defs (insn, local_live);\n+\n+\t/* On the other hand, we do not allow the dead uses to set\n+\t   anything in local_live.  */\n+\tif (marked_insn_p (insn))\n+\t  df_byte_lr_simulate_uses (insn, local_live);\n+\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"finished processing insn %d live out = \", \n+\t\t     INSN_UID (insn));\n+\t    df_print_byte_regset (dump_file, local_live);\n+\t  }\n+      }\n+  \n+  df_byte_lr_simulate_artificial_refs_at_top (bb, local_live);\n+\n+  block_changed = !bitmap_equal_p (local_live, DF_BYTE_LR_IN (bb));\n+  if (block_changed)\n+    bitmap_copy (DF_BYTE_LR_IN (bb), local_live);\n+  BITMAP_FREE (local_live);\n+  return block_changed;\n+}\n+\n+\n+/* Process basic block BB.  Return true if the live_in set has\n+   changed. REDO_OUT is true if the info at the bottom of the block\n+   needs to be recalculated before starting.  AU is the proper set of\n+   artificial uses. */\n+\n+static bool\n+dce_process_block (basic_block bb, bool redo_out, bitmap au)\n+{\n+  bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n+  rtx insn;\n+  bool block_changed;\n+  struct df_ref **def_rec;\n \n-  /* Process the artificial defs and uses at the bottom of the block.  */\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+  if (redo_out)\n     {\n-      struct df_ref *def = *def_rec;\n-      if (((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n-\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n-\tbitmap_clear_bit (local_live, DF_REF_REGNO (def));\n+      /* Need to redo the live_out set of this block if when one of\n+\t the succs of this block has had a change in it live in\n+\t set.  */\n+      edge e;\n+      edge_iterator ei;\n+      df_confluence_function_n con_fun_n = df_lr->problem->con_fun_n;\n+      bitmap_clear (DF_LR_OUT (bb));\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t(*con_fun_n) (e);\n     }\n \n-  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+  if (dump_file)\n     {\n-      struct df_ref *use = *use_rec;\n-      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n-\tbitmap_set_bit (local_live, DF_REF_REGNO (use));\n+      fprintf (dump_file, \"processing block %d live out = \", bb->index);\n+      df_print_regset (dump_file, DF_LR_OUT (bb));\n     }\n \n-  /* These regs are considered always live so if they end up dying\n-     because of some def, we need to bring the back again.\n-     Calling df_simulate_fixup_sets has the disadvantage of calling\n-     bb_has_eh_pred once per insn, so we cache the information here.  */\n-  if (bb_has_eh_pred (bb))\n-    au = df->eh_block_artificial_uses;\n-  else\n-    au = df->regular_block_artificial_uses;\n+  bitmap_copy (local_live, DF_LR_OUT (bb));\n+\n+  df_simulate_artificial_refs_at_end (bb, local_live);\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (INSN_P (insn))\n@@ -678,24 +760,7 @@ dce_process_block (basic_block bb, bool redo_out)\n \t  df_simulate_uses (insn, local_live);\n       }\n   \n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      struct df_ref *def = *def_rec;\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n-\tbitmap_clear_bit (local_live, DF_REF_REGNO (def));\n-    }\n-\n-#ifdef EH_USES\n-  /* Process the uses that are live into an exception handler.  */\n-  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n-    {\n-      /* Add use to set of uses in this BB.  */\n-      struct df_ref *use = *use_rec;\n-      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n-\tbitmap_set_bit (local_live, DF_REF_REGNO (use));\n-    }\n-#endif\n+  df_simulate_artificial_refs_at_top (bb, local_live);\n \n   block_changed = !bitmap_equal_p (local_live, DF_LR_IN (bb));\n   if (block_changed)\n@@ -706,10 +771,12 @@ dce_process_block (basic_block bb, bool redo_out)\n }\n \n \n-/* Perform fast DCE once initialization is done.  */\n+/* Perform fast DCE once initialization is done.  If BYTE_LEVEL is\n+   true, use the byte level dce, otherwise do it at the pseudo\n+   level.  */\n \n static void\n-fast_dce (void)\n+fast_dce (bool byte_level)\n {\n   int *postorder = df_get_postorder (DF_BACKWARD);\n   int n_blocks = df_get_n_blocks (DF_BACKWARD);\n@@ -720,6 +787,14 @@ fast_dce (void)\n   bitmap redo_out = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n   bitmap all_blocks = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n   bool global_changed = true;\n+\n+  /* These regs are considered always live so if they end up dying\n+     because of some def, we need to bring the back again.  Calling\n+     df_simulate_fixup_sets has the disadvantage of calling\n+     bb_has_eh_pred once per insn, so we cache the information\n+     here.  */\n+  bitmap au = df->regular_block_artificial_uses;\n+  bitmap au_eh = df->eh_block_artificial_uses;\n   int i;\n \n   prescan_insns_for_dce (true);\n@@ -743,8 +818,14 @@ fast_dce (void)\n \t      continue;\n \t    }\n \n-\t  local_changed \n-\t    = dce_process_block (bb, bitmap_bit_p (redo_out, index));\n+\t  if (byte_level)\n+\t    local_changed \n+\t      = byte_dce_process_block (bb, bitmap_bit_p (redo_out, index),\n+\t\t\t\t\t  bb_has_eh_pred (bb) ? au_eh : au);\n+\t  else\n+\t    local_changed \n+\t      = dce_process_block (bb, bitmap_bit_p (redo_out, index),\n+\t\t\t\t   bb_has_eh_pred (bb) ? au_eh : au);\n \t  bitmap_set_bit (processed, index);\n \t  \n \t  if (local_changed)\n@@ -780,7 +861,10 @@ fast_dce (void)\n \t     to redo the dataflow equations for the blocks that had a\n \t     change at the top of the block.  Then we need to redo the\n \t     iteration.  */ \n-\t  df_analyze_problem (df_lr, all_blocks, postorder, n_blocks);\n+\t  if (byte_level)\n+\t    df_analyze_problem (df_byte_lr, all_blocks, postorder, n_blocks);\n+\t  else\n+\t    df_analyze_problem (df_lr, all_blocks, postorder, n_blocks);\n \n \t  if (old_flag & DF_LR_RUN_DCE)\n \t    df_set_flags (DF_LR_RUN_DCE);\n@@ -797,13 +881,26 @@ fast_dce (void)\n }\n \n \n-/* Fast DCE.  */\n+/* Fast register level DCE.  */\n \n static unsigned int\n rest_of_handle_fast_dce (void)\n {\n   init_dce (true);\n-  fast_dce ();\n+  fast_dce (false);\n+  fini_dce (true);\n+  return 0;\n+}\n+\n+\n+/* Fast byte level DCE.  */\n+\n+static unsigned int\n+rest_of_handle_fast_byte_dce (void)\n+{\n+  df_byte_lr_add_problem ();\n+  init_dce (true);\n+  fast_dce (true);\n   fini_dce (true);\n   return 0;\n }\n@@ -875,3 +972,24 @@ struct rtl_opt_pass pass_fast_rtl_dce =\n   TODO_ggc_collect                      /* todo_flags_finish */\n  }\n };\n+\n+struct rtl_opt_pass pass_fast_rtl_byte_dce =\n+{\n+ {\n+  RTL_PASS,\n+  \"byte-dce\",                           /* name */\n+  gate_fast_dce,                        /* gate */\n+  rest_of_handle_fast_byte_dce,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_DCE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  TODO_ggc_collect                      /* todo_flags_finish */\n+ }\n+};"}, {"sha": "8efbd21a0147203a8e01b9b242ed27fa4b17ae2f", "filename": "gcc/df-core.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -1875,6 +1875,69 @@ df_print_regset (FILE *file, bitmap r)\n }\n \n \n+/* Write information about registers and basic blocks into FILE.  The\n+   bitmap is in the form used by df_byte_lr.  This is part of making a\n+   debugging dump.  */\n+\n+void\n+df_print_byte_regset (FILE *file, bitmap r)\n+{\n+  unsigned int max_reg = max_reg_num ();\n+  bitmap_iterator bi;\n+\n+  if (r == NULL)\n+    fputs (\" (nil)\", file);\n+  else\n+    {\n+      unsigned int i;\n+      for (i = 0; i < max_reg; i++)\n+\t{\n+\t  unsigned int first = df_byte_lr_get_regno_start (i);\n+\t  unsigned int len = df_byte_lr_get_regno_len (i);\n+\n+\t  if (len > 1)\n+\t    {\n+\t      bool found = false;\n+\t      unsigned int j;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (r, first, j, bi)\n+\t\t{\n+\t\t  found = j < first + len;\n+\t\t  break;\n+\t\t}\n+\t      if (found)\n+\t\t{\n+\t\t  const char * sep = \"\";\n+\t\t  fprintf (file, \" %d\", i);\n+\t\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t\t    fprintf (file, \" [%s]\", reg_names[i]);\n+\t\t  fprintf (file, \"(\");\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (r, first, j, bi)\n+\t\t    {\n+\t\t      if (j > first + len - 1)\n+\t\t\tbreak;\n+\t\t      fprintf (file, \"%s%d\", sep, j-first);\n+\t\t      sep = \", \";\n+\t\t    }\n+\t\t  fprintf (file, \")\");\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (bitmap_bit_p (r, first))\n+\t\t{\n+\t\t  fprintf (file, \" %d\", i);\n+\t\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t\t    fprintf (file, \" [%s]\", reg_names[i]);\n+\t\t}\n+\t    }\n+\n+\t}\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n /* Dump dataflow info.  */\n \n void"}, {"sha": "f7288c78e8e29fd67d9855351ce502e5dde18cfc", "filename": "gcc/df-problems.c", "status": "modified", "additions": 735, "deletions": 20, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -1,5 +1,6 @@\n /* Standard problems for dataflow support routines.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+\n    Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n@@ -566,28 +567,12 @@ df_rd_transfer_function (int bb_index)\n static void\n df_rd_free (void)\n {\n-  unsigned int i;\n   struct df_rd_problem_data *problem_data\n     = (struct df_rd_problem_data *) df_rd->problem_data;\n \n   if (problem_data)\n     {\n-      for (i = 0; i < df_rd->block_info_size; i++)\n-\t{\n-\t  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (i);\n-\t  if (bb_info)\n-\t    {\n-\t      BITMAP_FREE (bb_info->kill);\n-\t      BITMAP_FREE (bb_info->sparse_kill);\n-\t      BITMAP_FREE (bb_info->gen);\n-\t      BITMAP_FREE (bb_info->in);\n-\t      BITMAP_FREE (bb_info->out);\n-\t    }\n-\t}\n-      \n       free_alloc_pool (df_rd->block_pool);\n-      BITMAP_FREE (problem_data->sparse_invalidated_by_call);\n-      BITMAP_FREE (problem_data->dense_invalidated_by_call);\n       bitmap_obstack_release (&problem_data->rd_bitmaps);\n       \n       df_rd->block_info_size = 0;\n@@ -706,7 +691,7 @@ df_rd_add_problem (void)\n \n    Find the locations in the function where any use of a pseudo can\n    reach in the backwards direction.  In and out bitvectors are built\n-   for each basic block.  The regnum is used to index into these sets.\n+   for each basic block.  The regno is used to index into these sets.\n    See df.h for details.\n    ----------------------------------------------------------------------------*/\n \n@@ -1878,7 +1863,7 @@ struct df_link *\n df_chain_create (struct df_ref *src, struct df_ref *dst)\n {\n   struct df_link *head = DF_REF_CHAIN (src);\n-  struct df_link *link = pool_alloc (df_chain->block_pool);;\n+  struct df_link *link = pool_alloc (df_chain->block_pool);\n   \n   DF_REF_CHAIN (src) = link;\n   link->next = head;\n@@ -2344,7 +2329,733 @@ df_chain_add_problem (enum df_chain_flags chain_flags)\n \n \f\n /*----------------------------------------------------------------------------\n-   This pass computes REG_DEAD and REG_UNUSED notes.\n+   BYTE LEVEL LIVE REGISTERS\n+\n+   Find the locations in the function where any use of a pseudo can\n+   reach in the backwards direction.  In and out bitvectors are built\n+   for each basic block.  There are two mapping functions,\n+   df_byte_lr_get_regno_start and df_byte_lr_get_regno_len that are\n+   used to map regnos into bit vector postions.  \n+\n+   This problem differs from the regular df_lr function in the way\n+   that subregs, *_extracts and strict_low_parts are handled. In lr\n+   these are consider partial kills, here, the exact set of bytes is\n+   modeled.  Note that any reg that has none of these operations is\n+   only modeled with a single bit since all operations access the\n+   entire register.\n+\n+   This problem is more brittle that the regular lr.  It currently can\n+   be used in dce incrementally, but cannot be used in an environment\n+   where insns are created or modified.  The problem is that the\n+   mapping of regnos to bitmap positions is relatively compact, in\n+   that if a pseudo does not do any of the byte wise operations, only\n+   one slot is allocated, rather than a slot for each byte.  If insn\n+   are created, where a subreg is used for a reg that had no subregs,\n+   the mapping would be wrong.  Likewise, there are no checks to see\n+   that new pseudos have been added.  These issues could be addressed\n+   by adding a problem specific flag to not use the compact mapping,\n+   if there was a need to do so.\n+\n+   ----------------------------------------------------------------------------*/\n+\n+/* Private data used to verify the solution for this problem.  */\n+struct df_byte_lr_problem_data\n+{\n+  /* Expanded versions of bitvectors used in lr.  */\n+  bitmap invalidated_by_call;\n+  bitmap hardware_regs_used;\n+\n+  /* Indexed by regno, this is true if there are subregs, extracts or\n+     strict_low_parts for this regno.  */\n+  bitmap needs_expansion;\n+\n+  /* The start position and len for each regno in the various bit\n+     vectors.  */ \n+  unsigned int* regno_start;  \n+  unsigned int* regno_len;\n+  /* An obstack for the bitmaps we need for this problem.  */\n+  bitmap_obstack byte_lr_bitmaps;\n+};\n+\n+\n+/* Get the starting location for REGNO in the df_byte_lr bitmaps.  */\n+\n+int \n+df_byte_lr_get_regno_start (unsigned int regno)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n+  return problem_data->regno_start[regno];\n+}\n+\n+\n+/* Get the len for REGNO in the df_byte_lr bitmaps.  */\n+\n+int \n+df_byte_lr_get_regno_len (unsigned int regno)\n+{  \n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n+  return problem_data->regno_len[regno];\n+}\n+\n+\n+/* Set basic block info.  */\n+\n+static void\n+df_byte_lr_set_bb_info (unsigned int index, \n+\t\t\tstruct df_byte_lr_bb_info *bb_info)\n+{\n+  gcc_assert (df_byte_lr);\n+  gcc_assert (index < df_byte_lr->block_info_size);\n+  df_byte_lr->block_info[index] = bb_info;\n+}\n+\n+ \n+/* Free basic block info.  */\n+\n+static void\n+df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+\t\t\t void *vbb_info)\n+{\n+  struct df_byte_lr_bb_info *bb_info = (struct df_byte_lr_bb_info *) vbb_info;\n+  if (bb_info)\n+    {\n+      BITMAP_FREE (bb_info->use);\n+      BITMAP_FREE (bb_info->def);\n+      BITMAP_FREE (bb_info->in);\n+      BITMAP_FREE (bb_info->out);\n+      pool_free (df_byte_lr->block_pool, bb_info);\n+    }\n+}\n+\n+\n+/* Check all of the refs in REF_REC to see if any of them are\n+   extracts, subregs or strict_low_parts.  */\n+\n+static void\n+df_byte_lr_check_regs (struct df_ref **ref_rec)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+\n+  for (; *ref_rec; ref_rec++)\n+    {\n+      struct df_ref *ref = *ref_rec;\n+      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT \n+\t\t\t       | DF_REF_ZERO_EXTRACT \n+\t\t\t       | DF_REF_STRICT_LOW_PART)\n+\t  || GET_CODE (DF_REF_REG (ref)) == SUBREG)\n+\tbitmap_set_bit (problem_data->needs_expansion, DF_REF_REGNO (ref));\n+    }\n+}\n+\n+\n+/* Expand bitmap SRC which is indexed by regno to DEST which is indexed by \n+   regno_start and regno_len.  */\n+\n+static void\n+df_byte_lr_expand_bitmap (bitmap dest, bitmap src)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+\n+  bitmap_clear (dest);\n+  EXECUTE_IF_SET_IN_BITMAP (src, 0, i, bi)\n+    {\n+      bitmap_set_range (dest, problem_data->regno_start[i], \n+\t\t\tproblem_data->regno_len[i]);\n+    }\n+}\n+\n+\n+/* Allocate or reset bitmaps for DF_BYTE_LR blocks. The solution bits are\n+   not touched unless the block is new.  */\n+\n+static void \n+df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+  basic_block bb;\n+  unsigned int regno;\n+  unsigned int index = 0;\n+  unsigned int max_reg = max_reg_num();\n+  struct df_byte_lr_problem_data *problem_data \n+    = problem_data = XNEW (struct df_byte_lr_problem_data);\n+\n+  df_byte_lr->problem_data = problem_data;\n+\n+  if (!df_byte_lr->block_pool)\n+    df_byte_lr->block_pool = create_alloc_pool (\"df_byte_lr_block pool\", \n+\t\t\t\t\t   sizeof (struct df_byte_lr_bb_info), 50);\n+\n+  df_grow_bb_info (df_byte_lr);\n+\n+  /* Create the mapping from regnos to slots. This does not change\n+     unless the problem is destroyed and recreated.  In particular, if\n+     we end up deleting the only insn that used a subreg, we do not\n+     want to redo the mapping because this would invalidate everything\n+     else.  */\n+\n+  bitmap_obstack_initialize (&problem_data->byte_lr_bitmaps);\n+  problem_data->regno_start = XNEWVEC (unsigned int, max_reg);\n+  problem_data->regno_len = XNEWVEC (unsigned int, max_reg);\n+  problem_data->hardware_regs_used = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+  problem_data->invalidated_by_call = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+  problem_data->needs_expansion = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+  \n+  /* Discover which regno's use subregs, extracts or\n+     strict_low_parts.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      df_byte_lr_check_regs (DF_INSN_DEFS (insn));\n+\t      df_byte_lr_check_regs (DF_INSN_USES (insn));\n+\t    }\n+\t}\n+      bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, bb->index);\n+    }\n+\n+  bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, ENTRY_BLOCK);\n+  bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, EXIT_BLOCK);\n+  \n+  /* Allocate the slots for each regno.  */\n+  for (regno = 0; regno < max_reg; regno++)\n+    {\n+      int len;\n+      problem_data->regno_start[regno] = index;\n+      if (bitmap_bit_p (problem_data->needs_expansion, regno))\n+\tlen = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n+      else \n+\tlen = 1;\n+      \n+      problem_data->regno_len[regno] = len;\n+      index += len;\n+    }\n+\n+  df_byte_lr_expand_bitmap (problem_data->hardware_regs_used, \n+\t\t\t    df->hardware_regs_used);\n+  df_byte_lr_expand_bitmap (problem_data->invalidated_by_call, \n+\t\t\t    df_invalidated_by_call);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n+    {\n+      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      if (bb_info)\n+\t{ \n+\t  bitmap_clear (bb_info->def);\n+\t  bitmap_clear (bb_info->use);\n+\t}\n+      else\n+\t{ \n+\t  bb_info = (struct df_byte_lr_bb_info *) pool_alloc (df_byte_lr->block_pool);\n+\t  df_byte_lr_set_bb_info (bb_index, bb_info);\n+\t  bb_info->use = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+\t  bb_info->def = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+\t  bb_info->in = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+\t  bb_info->out = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+\t}\n+    }\n+  \n+  df_byte_lr->optional_p = true;\n+}\n+\n+\n+/* Reset the global solution for recalculation.  */\n+\n+static void \n+df_byte_lr_reset (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      gcc_assert (bb_info);\n+      bitmap_clear (bb_info->in);\n+      bitmap_clear (bb_info->out);\n+    }\n+}\n+\n+\n+/* Compute local live register info for basic block BB.  */\n+\n+static void\n+df_byte_lr_bb_local_compute (unsigned int bb_index)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  basic_block bb = BASIC_BLOCK (bb_index);\n+  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+  rtx insn;\n+  struct df_ref **def_rec;\n+  struct df_ref **use_rec;\n+\n+  /* Process the registers set in an exception handler.  */\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  unsigned int start = problem_data->regno_start[dregno];\n+\t  unsigned int len = problem_data->regno_len[dregno];\n+\t  bitmap_set_range (bb_info->def, start, len);\n+\t  bitmap_clear_range (bb_info->use, start, len);\n+\t}\n+    }\n+\n+  /* Process the hardware registers that are always live.  */\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      /* Add use to set of uses in this BB.  */\n+      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n+\t{\n+\t  unsigned int uregno = DF_REF_REGNO (use);\n+\t  unsigned int start = problem_data->regno_start[uregno];\n+\t  unsigned int len = problem_data->regno_len[uregno];\n+\t  bitmap_set_range (bb_info->use, start, len);\n+\t}\n+    }\n+\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\t\n+\n+      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t{\n+\t  struct df_ref *def = *def_rec;\n+\t  /* If the def is to only part of the reg, it does\n+\t     not kill the other defs that reach here.  */\n+\t  if (!(DF_REF_FLAGS (def) & (DF_REF_CONDITIONAL)))\n+\t    {\n+\t      unsigned int dregno = DF_REF_REGNO (def);\n+\t      unsigned int start = problem_data->regno_start[dregno];\n+\t      unsigned int len = problem_data->regno_len[dregno];\n+\t      unsigned int sb;\n+\t      unsigned int lb;\n+\t      if (!df_compute_accessed_bytes (def, DF_MM_MUST, &sb, &lb))\n+\t\t{\n+\t\t  start += sb;\n+\t\t  len = lb - sb;\n+\t\t}\n+\t      if (len)\n+\t\t{\n+\t\t  bitmap_set_range (bb_info->def, start, len);\n+\t\t  bitmap_clear_range (bb_info->use, start, len);\n+\t\t}\n+\t    }\n+\t}\n+\n+      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t{\n+\t  struct df_ref *use = *use_rec;\n+\t  unsigned int uregno = DF_REF_REGNO (use);\n+\t  unsigned int start = problem_data->regno_start[uregno];\n+\t  unsigned int len = problem_data->regno_len[uregno];\n+\t  unsigned int sb;\n+\t  unsigned int lb;\n+\t  if (!df_compute_accessed_bytes (use, DF_MM_MAY, &sb, &lb))\n+\t    {\n+\t      start += sb;\n+\t      len = lb - sb;\n+\t    }\n+\t  /* Add use to set of uses in this BB.  */\n+\t  if (len)\n+\t    bitmap_set_range (bb_info->use, start, len);\n+\t}\n+    }\n+\n+  /* Process the registers set in an exception handler or the hard\n+     frame pointer if this block is the target of a non local\n+     goto.  */\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  unsigned int start = problem_data->regno_start[dregno];\n+\t  unsigned int len = problem_data->regno_len[dregno];\n+\t  bitmap_set_range (bb_info->def, start, len);\n+\t  bitmap_clear_range (bb_info->use, start, len);\n+\t}\n+    }\n+  \n+#ifdef EH_USES\n+  /* Process the uses that are live into an exception handler.  */\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      /* Add use to set of uses in this BB.  */\n+      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n+\t{\n+\t  unsigned int uregno = DF_REF_REGNO (use);\n+\t  unsigned int start = problem_data->regno_start[uregno];\n+\t  unsigned int len = problem_data->regno_len[uregno];\n+\t  bitmap_set_range (bb_info->use, start, len);\n+\t}\n+    }\n+#endif\n+}\n+\n+\n+/* Compute local live register info for each basic block within BLOCKS.  */\n+\n+static void\n+df_byte_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n+    {\n+      if (bb_index == EXIT_BLOCK)\n+\t{\n+\t  /* The exit block is special for this problem and its bits are\n+\t     computed from thin air.  */\n+\t  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (EXIT_BLOCK);\n+\t  df_byte_lr_expand_bitmap (bb_info->use, df->exit_block_uses);\n+\t}\n+      else\n+\tdf_byte_lr_bb_local_compute (bb_index);\n+    }\n+\n+  bitmap_clear (df_byte_lr->out_of_date_transfer_functions);\n+}\n+\n+\n+/* Initialize the solution vectors.  */\n+\n+static void \n+df_byte_lr_init (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      bitmap_copy (bb_info->in, bb_info->use);\n+      bitmap_clear (bb_info->out);\n+    }\n+}\n+\n+\n+/* Confluence function that processes infinite loops.  This might be a\n+   noreturn function that throws.  And even if it isn't, getting the\n+   unwind info right helps debugging.  */\n+static void\n+df_byte_lr_confluence_0 (basic_block bb)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  bitmap op1 = df_byte_lr_get_bb_info (bb->index)->out;\n+  if (bb != EXIT_BLOCK_PTR)\n+    bitmap_copy (op1, problem_data->hardware_regs_used);\n+} \n+\n+\n+/* Confluence function that ignores fake edges.  */\n+\n+static void\n+df_byte_lr_confluence_n (edge e)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  bitmap op1 = df_byte_lr_get_bb_info (e->src->index)->out;\n+  bitmap op2 = df_byte_lr_get_bb_info (e->dest->index)->in;\n+ \n+  /* Call-clobbered registers die across exception and call edges.  */\n+  /* ??? Abnormal call edges ignored for the moment, as this gets\n+     confused by sibling call edges, which crashes reg-stack.  */\n+  if (e->flags & EDGE_EH)\n+    bitmap_ior_and_compl_into (op1, op2, problem_data->invalidated_by_call);\n+  else\n+    bitmap_ior_into (op1, op2);\n+\n+  bitmap_ior_into (op1, problem_data->hardware_regs_used);\n+} \n+\n+\n+/* Transfer function.  */\n+\n+static bool\n+df_byte_lr_transfer_function (int bb_index)\n+{\n+  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+  bitmap in = bb_info->in;\n+  bitmap out = bb_info->out;\n+  bitmap use = bb_info->use;\n+  bitmap def = bb_info->def;\n+\n+  return bitmap_ior_and_compl (in, use, out, def);\n+}\n+\n+\n+/* Free all storage associated with the problem.  */\n+\n+static void\n+df_byte_lr_free (void)\n+{\n+  struct df_byte_lr_problem_data *problem_data\n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+\n+\n+  if (df_byte_lr->block_info)\n+    {\n+      free_alloc_pool (df_byte_lr->block_pool);\n+      df_byte_lr->block_info_size = 0;\n+      free (df_byte_lr->block_info);\n+    }\n+\n+  BITMAP_FREE (df_byte_lr->out_of_date_transfer_functions);\n+  bitmap_obstack_release (&problem_data->byte_lr_bitmaps);\n+  free (problem_data->regno_start);\n+  free (problem_data->regno_len);\n+  free (problem_data);\n+  free (df_byte_lr);\n+}\n+\n+\n+/* Debugging info at top of bb.  */\n+\n+static void\n+df_byte_lr_top_dump (basic_block bb, FILE *file)\n+{\n+  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n+  if (!bb_info || !bb_info->in)\n+    return;\n+      \n+  fprintf (file, \";; blr  in  \\t\");\n+  df_print_byte_regset (file, bb_info->in);\n+  fprintf (file, \";; blr  use \\t\");\n+  df_print_byte_regset (file, bb_info->use);\n+  fprintf (file, \";; blr  def \\t\");\n+  df_print_byte_regset (file, bb_info->def);\n+}  \n+\n+\n+/* Debugging info at bottom of bb.  */\n+\n+static void\n+df_byte_lr_bottom_dump (basic_block bb, FILE *file)\n+{\n+  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n+  if (!bb_info || !bb_info->out)\n+    return;\n+  \n+  fprintf (file, \";; blr  out \\t\");\n+  df_print_byte_regset (file, bb_info->out);\n+}  \n+\n+\n+/* All of the information associated with every instance of the problem.  */\n+\n+static struct df_problem problem_BYTE_LR =\n+{\n+  DF_BYTE_LR,                      /* Problem id.  */\n+  DF_BACKWARD,                     /* Direction.  */\n+  df_byte_lr_alloc,                /* Allocate the problem specific data.  */\n+  df_byte_lr_reset,                /* Reset global information.  */\n+  df_byte_lr_free_bb_info,         /* Free basic block info.  */\n+  df_byte_lr_local_compute,        /* Local compute function.  */\n+  df_byte_lr_init,                 /* Init the solution specific data.  */\n+  df_worklist_dataflow,            /* Worklist solver.  */\n+  df_byte_lr_confluence_0,         /* Confluence operator 0.  */ \n+  df_byte_lr_confluence_n,         /* Confluence operator n.  */ \n+  df_byte_lr_transfer_function,    /* Transfer function.  */\n+  NULL,                            /* Finalize function.  */\n+  df_byte_lr_free,                 /* Free all of the problem information.  */\n+  df_byte_lr_free,                 /* Remove this problem from the stack of dataflow problems.  */\n+  NULL,                            /* Debugging.  */\n+  df_byte_lr_top_dump,             /* Debugging start block.  */\n+  df_byte_lr_bottom_dump,          /* Debugging end block.  */\n+  NULL,                            /* Incremental solution verify start.  */\n+  NULL,                            /* Incremental solution verify end.  */\n+  NULL,                            /* Dependent problem.  */\n+  TV_DF_BYTE_LR,                   /* Timing variable.  */ \n+  false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n+};\n+\n+\n+/* Create a new DATAFLOW instance and add it to an existing instance\n+   of DF.  The returned structure is what is used to get at the\n+   solution.  */\n+\n+void\n+df_byte_lr_add_problem (void)\n+{\n+  df_add_problem (&problem_BYTE_LR);\n+  /* These will be initialized when df_scan_blocks processes each\n+     block.  */\n+  df_byte_lr->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+}\n+\n+\n+/* Simulate the effects of the defs of INSN on LIVE.  */\n+\n+void\n+df_byte_lr_simulate_defs (rtx insn, bitmap live)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  struct df_ref **def_rec;\n+  unsigned int uid = INSN_UID (insn);\n+\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+\n+      /* If the def is to only part of the reg, it does\n+\t not kill the other defs that reach here.  */\n+      if (!(DF_REF_FLAGS (def) & DF_REF_CONDITIONAL))\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  unsigned int start = problem_data->regno_start[dregno];\n+\t  unsigned int len = problem_data->regno_len[dregno];\n+\t  unsigned int sb;\n+\t  unsigned int lb;\n+\t  if (!df_compute_accessed_bytes (def, DF_MM_MUST, &sb, &lb))\n+\t    {\n+\t      start += sb;\n+\t      len = lb - sb;\n+\t    }\n+\n+\t  if (len)\n+\t    bitmap_clear_range (live, start, len);\n+\t}\n+    }\n+}  \n+\n+\n+/* Simulate the effects of the uses of INSN on LIVE.  */\n+\n+void \n+df_byte_lr_simulate_uses (rtx insn, bitmap live)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  struct df_ref **use_rec;\n+  unsigned int uid = INSN_UID (insn);\n+\n+  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      unsigned int uregno = DF_REF_REGNO (use);\n+      unsigned int start = problem_data->regno_start[uregno];\n+      unsigned int len = problem_data->regno_len[uregno];\n+      unsigned int sb;\n+      unsigned int lb;\n+      \n+      if (!df_compute_accessed_bytes (use, DF_MM_MAY, &sb, &lb))\n+\t{\n+\t  start += sb;\n+\t  len = lb - sb;\n+\t}\n+      \n+      /* Add use to set of uses in this BB.  */\n+      if (len)\n+\tbitmap_set_range (live, start, len);\n+    }\n+}\n+\n+\n+/* Apply the artificial uses and defs at the top of BB in a forwards\n+   direction.  */\n+\n+void \n+df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  struct df_ref **def_rec;\n+#ifdef EH_USES\n+  struct df_ref **use_rec;\n+#endif\n+  int bb_index = bb->index;\n+  \n+#ifdef EH_USES\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n+\t{\n+\t  unsigned int uregno = DF_REF_REGNO (use);\n+\t  unsigned int start = problem_data->regno_start[uregno];\n+\t  unsigned int len = problem_data->regno_len[uregno];\n+\t  bitmap_set_range (live, start, len);\n+\t}\n+    }\n+#endif\n+\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t{      \n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  unsigned int start = problem_data->regno_start[dregno];\n+\t  unsigned int len = problem_data->regno_len[dregno];\n+\t  bitmap_clear_range (live, start, len);\n+\t}\n+    }\n+}\n+\n+\n+/* Apply the artificial uses and defs at the end of BB in a backwards\n+   direction.  */\n+\n+void \n+df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n+{\n+  struct df_byte_lr_problem_data *problem_data \n+    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  struct df_ref **def_rec;\n+  struct df_ref **use_rec;\n+  int bb_index = bb->index;\n+  \n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      struct df_ref *def = *def_rec;\n+      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  unsigned int start = problem_data->regno_start[dregno];\n+\t  unsigned int len = problem_data->regno_len[dregno];\n+\t  bitmap_clear_range (live, start, len);\n+\t}\n+    }\n+\n+  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n+    {\n+      struct df_ref *use = *use_rec;\n+      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n+\t{\n+\t  unsigned int uregno = DF_REF_REGNO (use);\n+\t  unsigned int start = problem_data->regno_start[uregno];\n+\t  unsigned int len = problem_data->regno_len[uregno];\n+\t  bitmap_set_range (live, start, len);\n+\t}\n+    }\n+}\n+\n+\n+\f\n+/*----------------------------------------------------------------------------\n+   This problem computes REG_DEAD and REG_UNUSED notes.\n    ----------------------------------------------------------------------------*/\n \n static void \n@@ -3053,15 +3764,19 @@ void\n df_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n {\n   struct df_ref **def_rec;\n+#ifdef EH_USES\n   struct df_ref **use_rec;\n+#endif\n   int bb_index = bb->index;\n   \n+#ifdef EH_USES\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n       struct df_ref *use = *use_rec;\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n \tbitmap_set_bit (live, DF_REF_REGNO (use));\n     }\n+#endif\n \n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {"}, {"sha": "4a733d6955cb15227f48ea5c1c414241026e2287", "filename": "gcc/df-scan.c", "status": "modified", "additions": 106, "deletions": 71, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -95,7 +95,7 @@ static struct df_mw_hardreg * df_null_mw_rec[1];\n static void df_ref_record (struct df_collection_rec *,\n \t\t\t   rtx, rtx *, \n \t\t\t   basic_block, rtx, enum df_ref_type, \n-\t\t\t   enum df_ref_flags, int, int);\n+\t\t\t   enum df_ref_flags, int, int, enum machine_mode);\n static void df_def_record_1 (struct df_collection_rec *,\n \t\t\t     rtx, basic_block, rtx,\n \t\t\t     enum df_ref_flags);\n@@ -104,11 +104,13 @@ static void df_defs_record (struct df_collection_rec *,\n \t\t\t    enum df_ref_flags);\n static void df_uses_record (struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n-\t\t\t    basic_block, rtx, enum df_ref_flags, int, int);\n+\t\t\t    basic_block, rtx, enum df_ref_flags, \n+\t\t\t    int, int, enum machine_mode);\n \n static struct df_ref *df_ref_create_structure (struct df_collection_rec *, rtx, rtx *, \n \t\t\t\t\t       basic_block, rtx, enum df_ref_type, \n-\t\t\t\t\t       enum df_ref_flags, int, int);\n+\t\t\t\t\t       enum df_ref_flags, \n+\t\t\t\t\t       int, int, enum machine_mode);\n \n static void df_insn_refs_collect (struct df_collection_rec*, \n \t\t\t\t  basic_block, rtx); \n@@ -616,16 +618,16 @@ df_scan_blocks (void)\n    LOC within INSN of BB.  This function is only used externally. \n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n-   if they were constants.  Otherwise they should be -1 if those flags\n-   were set.  */\n+   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n+   fields if they were constants.  Otherwise they should be -1 if\n+   those flags were set.  */\n \n struct df_ref *\n df_ref_create (rtx reg, rtx *loc, rtx insn, \n \t       basic_block bb,\n \t       enum df_ref_type ref_type, \n \t       enum df_ref_flags ref_flags,\n-\t       int width, int offset)\n+\t       int width, int offset, enum machine_mode mode)\n {\n   struct df_ref *ref;\n   struct df_reg_info **reg_info;\n@@ -640,7 +642,8 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   /* You cannot hack artificial refs.  */\n   gcc_assert (insn);\n   ref = df_ref_create_structure (NULL, reg, loc, bb, insn,\n-                                 ref_type, ref_flags, width, offset);\n+                                 ref_type, ref_flags, \n+\t\t\t\t width, offset, mode);\n \n   if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n     {\n@@ -2066,7 +2069,7 @@ df_notes_rescan (rtx insn)\n \t    case REG_EQUAL:\n \t      df_uses_record (&collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t      bb, insn, DF_REF_IN_NOTE, -1, -1);\n+\t\t\t      bb, insn, DF_REF_IN_NOTE, -1, -1, 0);\n \t    default:\n \t      break;\n \t    }\n@@ -2142,8 +2145,9 @@ df_ref_equal_p (struct df_ref *ref1, struct df_ref *ref2)\n      compared in the next set of tests.  */\n   if ((DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n       && (DF_REF_FLAGS_IS_SET (ref2, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-      && ((DF_REF_OFFSET (ref1) != DF_REF_OFFSET (ref2))\n-\t  || (DF_REF_WIDTH (ref1) != DF_REF_WIDTH (ref2))))\n+      && ((DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n+\t  || (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n+\t  || (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))))\n     return false;\n \n   return (ref1 == ref2) ||\n@@ -2199,10 +2203,12 @@ df_ref_compare (const void *r1, const void *r2)\n      at ref1.  */\n   if (DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n     {\n-      if (DF_REF_OFFSET (ref1) != DF_REF_OFFSET (ref2))\n-\treturn DF_REF_OFFSET (ref1) - DF_REF_OFFSET (ref2);\n-      if (DF_REF_WIDTH (ref1) != DF_REF_WIDTH (ref2))\n-\treturn DF_REF_WIDTH (ref1) - DF_REF_WIDTH (ref2);\n+      if (DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n+\treturn DF_REF_EXTRACT_OFFSET (ref1) - DF_REF_EXTRACT_OFFSET (ref2);\n+      if (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n+\treturn DF_REF_EXTRACT_WIDTH (ref1) - DF_REF_EXTRACT_WIDTH (ref2);\n+      if (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))\n+\treturn DF_REF_EXTRACT_MODE (ref1) - DF_REF_EXTRACT_MODE (ref2);\n     }\n   return 0;\n }\n@@ -2583,7 +2589,7 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n /* Allocate a ref and initialize its fields. \n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n+   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the fields\n    if they were constants.  Otherwise they should be -1 if those flags\n    were set.  */\n \n@@ -2593,7 +2599,7 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n \t\t\t basic_block bb, rtx insn, \n \t\t\t enum df_ref_type ref_type, \n \t\t\t enum df_ref_flags ref_flags,\n-\t\t\t int width, int offset)\n+\t\t\t int width, int offset, enum machine_mode mode)\n {\n   struct df_ref *this_ref;\n   int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n@@ -2603,8 +2609,9 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n   if (ref_flags & (DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n     {\n       this_ref = pool_alloc (problem_data->ref_extract_pool);\n-      DF_REF_WIDTH (this_ref) = width;\n-      DF_REF_OFFSET (this_ref) = offset;\n+      DF_REF_EXTRACT_WIDTH (this_ref) = width;\n+      DF_REF_EXTRACT_OFFSET (this_ref) = offset;\n+      DF_REF_EXTRACT_MODE (this_ref) = mode;\n     }\n   else\n     this_ref = pool_alloc (problem_data->ref_pool);\n@@ -2659,9 +2666,9 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n    at address LOC within INSN of BB. \n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n-   if they were constants.  Otherwise they should be -1 if those flags\n-   were set.  */\n+   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n+   fields if they were constants.  Otherwise they should be -1 if\n+   those flags were set.  */\n \n \n static void\n@@ -2670,7 +2677,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n \t       basic_block bb, rtx insn, \n \t       enum df_ref_type ref_type, \n \t       enum df_ref_flags ref_flags,\n-\t       int width, int offset) \n+\t       int width, int offset, enum machine_mode mode) \n {\n   unsigned int regno;\n \n@@ -2719,7 +2726,8 @@ df_ref_record (struct df_collection_rec *collection_rec,\n       for (i = regno; i < endregno; i++)\n \t{\n \t  ref = df_ref_create_structure (collection_rec, regno_reg_rtx[i], loc, \n-\t\t\t\t\t bb, insn, ref_type, ref_flags, width, offset);\n+\t\t\t\t\t bb, insn, ref_type, ref_flags, \n+\t\t\t\t\t width, offset, mode);\n \n           gcc_assert (ORIGINAL_REGNO (DF_REF_REG (ref)) == i);\n \t}\n@@ -2728,7 +2736,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n     {\n       struct df_ref *ref;\n       ref = df_ref_create_structure (collection_rec, reg, loc, bb, insn, \n-                                     ref_type, ref_flags, width, offset);\n+                                     ref_type, ref_flags, width, offset, mode);\n     }\n }\n \n@@ -2764,6 +2772,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   rtx dst;\n   int offset = -1;\n   int width = -1;\n+  enum machine_mode mode = 0;\n \n  /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n@@ -2808,6 +2817,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \t{\n \t  width = INTVAL (XEXP (dst, 1));\n \t  offset = INTVAL (XEXP (dst, 2));\n+\t  mode = GET_MODE (dst);\n \t}\n \n       loc = &XEXP (dst, 0);\n@@ -2818,13 +2828,15 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   if (REG_P (dst))\n     {\n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, width, offset);\n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, \n+\t\t     width, offset, mode);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n \tdf_ref_record (collection_rec,\n-\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags, width, offset);\n+\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags, \n+\t\t       width, offset, mode);\n     }\n   else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n     {\n@@ -2834,7 +2846,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n       flags |= DF_REF_SUBREG;\n \n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, width, offset);\n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, \n+\t\t     width, offset, mode);\n     }\n }\n \n@@ -2873,15 +2886,15 @@ df_defs_record (struct df_collection_rec *collection_rec,\n /* Process all the registers used in the rtx at address LOC.  \n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH and LOWER are used to access the fields\n-   if they were constants.  Otherwise they should be -1 if those flags\n-   were set.  */\n+   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n+   fields if they were constants.  Otherwise they should be -1 if\n+   those flags were set.  */\n \n static void\n df_uses_record (struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n \t\tbasic_block bb, rtx insn, enum df_ref_flags flags,\n-\t\tint width, int offset)\n+\t\tint width, int offset, enum machine_mode mode)\n {\n   RTX_CODE code;\n   rtx x;\n@@ -2912,15 +2925,17 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (MEM_P (XEXP (x, 0)))\n \tdf_uses_record (collection_rec,\n \t\t\t&XEXP (XEXP (x, 0), 0),\n-\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags, width, offset);\n+\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags, \n+\t\t\twidth, offset, mode);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n     case MEM:\n       df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD, \n-\t\t      bb, insn, flags & DF_REF_IN_NOTE, width, offset);\n+\t\t      bb, insn, flags & DF_REF_IN_NOTE, \n+\t\t      width, offset, mode);\n       return;\n \n     case SUBREG:\n@@ -2930,14 +2945,16 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (collection_rec, loc, ref_type, bb, insn, flags, width, offset);\n+\t  df_uses_record (collection_rec, loc, ref_type, bb, insn, flags, \n+\t\t\t  width, offset, mode);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n       df_ref_record (collection_rec, \n-\t\t     x, loc, bb, insn, ref_type, flags, width, offset);\n+\t\t     x, loc, bb, insn, ref_type, flags, \n+\t\t     width, offset, mode);\n       return;\n \n     case SIGN_EXTRACT:\n@@ -2951,14 +2968,16 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t  {\n \t    width = INTVAL (XEXP (x, 1));\n \t    offset = INTVAL (XEXP (x, 2));\n+\t    mode = GET_MODE (x);\n \n \t    if (code == ZERO_EXTRACT)\n \t      flags |= DF_REF_ZERO_EXTRACT;\n \t    else\n \t      flags |= DF_REF_SIGN_EXTRACT;\n \n \t    df_uses_record (collection_rec,\n-\t\t\t    &XEXP (x, 0), ref_type, bb, insn, flags, width, offset);\n+\t\t\t    &XEXP (x, 0), ref_type, bb, insn, flags, \n+\t\t\t    width, offset, mode);\n \t    return;\n \t  }\n       }\n@@ -2969,7 +2988,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n \tdf_uses_record (collection_rec,\n-\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn, flags, \n+\t\t\twidth, offset, mode);\n \n \tswitch (GET_CODE (dst))\n \t  {\n@@ -2978,7 +2998,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\t{\n \t\t  df_uses_record (collection_rec, &SUBREG_REG (dst), \n \t\t\t\t  DF_REF_REG_USE, bb, insn, \n-\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, width, offset);\n+\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, \n+\t\t\t\t  width, offset, mode);\n \t\t  break;\n \t\t}\n \t      /* Fall through.  */\n@@ -2990,7 +3011,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tbreak;\n \t    case MEM:\n \t      df_uses_record (collection_rec, &XEXP (dst, 0),\n-\t\t\t      DF_REF_REG_MEM_STORE, bb, insn, flags, width, offset);\n+\t\t\t      DF_REF_REG_MEM_STORE, bb, insn, flags, \n+\t\t\t      width, offset, mode);\n \t      break;\n \t    case STRICT_LOW_PART:\n \t      {\n@@ -3001,7 +3023,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tdf_uses_record (collection_rec, \n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n \t\t\t\tDF_REF_REG_USE, bb, insn, \n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, width, offset);\n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, \n+\t\t\t\twidth, offset, mode);\n \t      }\n \t      break;\n \t    case ZERO_EXTRACT:\n@@ -3011,18 +3034,22 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\t  {\n \t\t    width = INTVAL (XEXP (dst, 1));\n \t\t    offset = INTVAL (XEXP (dst, 2));\n+\t\t    mode = GET_MODE (dst);\n \t\t  }\n \t\telse \n \t\t  {\n \t\t    df_uses_record (collection_rec, &XEXP (dst, 1), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t\t    width, offset, mode);\n \t\t    df_uses_record (collection_rec, &XEXP (dst, 2), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t\t    width, offset, mode);\n \t\t  }\n \n \t\tdf_uses_record (collection_rec, &XEXP (dst, 0), \n \t\t\t\tDF_REF_REG_USE, bb, insn, \n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, width, offset);\n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n+\t\t\t\twidth, offset, mode);\n \t      }\n \t      break;\n \n@@ -3072,7 +3099,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (collection_rec, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t\t      DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t      width, offset, mode);\n \t    return;\n \t  }\n \tbreak;\n@@ -3087,7 +3115,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       /* Catch the def of the register being modified.  */\n       df_ref_record (collection_rec, XEXP (x, 0), &XEXP (x, 0), bb, insn, \n \t\t     DF_REF_REG_DEF,\n-                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, width, offset);\n+                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, \n+\t\t     width, offset, mode);\n \n       /* ... Fall through to handle uses ...  */\n \n@@ -3111,15 +3140,17 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tgoto retry;\n \t      }\n \t    df_uses_record (collection_rec, &XEXP (x, i), ref_type, \n-\t\t\t    bb, insn, flags, width, offset);\n+\t\t\t    bb, insn, flags, \n+\t\t\t    width, offset, mode);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      df_uses_record (collection_rec,\n \t\t\t      &XVECEXP (x, i, j), ref_type, \n-\t\t\t      bb, insn, flags, width, offset);\n+\t\t\t      bb, insn, flags, \n+\t\t\t      width, offset, mode);\n \t  }\n       }\n   }\n@@ -3141,19 +3172,21 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n         {\n \t  int width = -1;\n \t  int offset = -1;\n+\t  enum machine_mode mode = 0;\n           struct df_ref *use;\n \n \t  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n \t    {\n-\t      width = DF_REF_WIDTH (ref);\n-\t      offset = DF_REF_OFFSET (ref);\n+\t      width = DF_REF_EXTRACT_WIDTH (ref);\n+\t      offset = DF_REF_EXTRACT_OFFSET (ref);\n+\t      mode = DF_REF_EXTRACT_MODE (ref);\n \t    }\n \n           use = df_ref_create_structure (collection_rec, DF_REF_REG (ref),\n \t\t\t\t\t DF_REF_LOC (ref), DF_REF_BB (ref),\n \t\t\t\t\t DF_REF_INSN (ref), DF_REF_REG_USE,\n \t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL,\n-\t\t\t\t\t width, offset);\n+\t\t\t\t\t width, offset, mode);\n           DF_REF_REGNO (use) = DF_REF_REGNO (ref);\n         }\n     }\n@@ -3191,7 +3224,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n-\t\t\tDF_REF_REG_USE, bb, insn, flags, -1, -1);\n+\t\t\tDF_REF_REG_USE, bb, insn, flags, -1, -1, 0);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n@@ -3203,23 +3236,24 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t    }\n \t  else\n \t    df_uses_record (collection_rec, &XEXP (note, 0),\n-\t\t            DF_REF_REG_USE, bb, insn, flags, -1, -1);\n+\t\t            DF_REF_REG_USE, bb, insn, flags, -1, -1, 0);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n-\t\t NULL, bb, insn, DF_REF_REG_USE, DF_REF_CALL_STACK_USAGE | flags, -1, -1);\n+\t\t NULL, bb, insn, DF_REF_REG_USE, DF_REF_CALL_STACK_USAGE | flags, \n+\t\t -1, -1, 0);\n \n   /* Calls may also reference any of the global registers,\n      so they are recorded as used.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n       {\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_USE, flags, -1, -1);\n+\t\t       NULL, bb, insn, DF_REF_REG_USE, flags, -1, -1, 0);\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags, -1, -1);\n+\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags, -1, -1, 0);\n       }\n \n   is_sibling_call = SIBLING_CALL_P (insn);\n@@ -3232,7 +3266,8 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t      || refers_to_regno_p (ui, ui+1, \n \t\t\t\t    crtl->return_rtx, NULL)))\n         df_ref_record (collection_rec, regno_reg_rtx[ui], \n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags, -1, -1);\n+\t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags, \n+\t\t       -1, -1, 0);\n     }\n \n   BITMAP_FREE (defs_generated);\n@@ -3270,21 +3305,21 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         case REG_EQUAL:\n           df_uses_record (collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n-                          bb, insn, DF_REF_IN_NOTE, -1, -1);\n+                          bb, insn, DF_REF_IN_NOTE, -1, -1, 0);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n                          NULL,\n                          bb, insn, \n-                         DF_REF_REG_USE, 0, -1, -1);\n+                         DF_REF_REG_USE, 0, -1, -1, 0);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n                          NULL,\n                          bb, insn, \n-                         DF_REF_REG_USE, 0, -1, -1);\n+                         DF_REF_REG_USE, 0, -1, -1, 0);\n #endif\n           break;\n         default:\n@@ -3298,7 +3333,8 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n \n   /* Record the register uses.  */\n   df_uses_record (collection_rec,\n-\t\t  &PATTERN (insn), DF_REF_REG_USE, bb, insn, 0, -1, -1);\n+\t\t  &PATTERN (insn), DF_REF_REG_USE, bb, insn, 0, \n+\t\t  -1, -1, 0);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n   if (is_cond_exec)\n@@ -3381,7 +3417,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1);\n+\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n \t}\n     }\n #endif\n@@ -3405,15 +3441,15 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (EH_USES (i))\n \t  df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, DF_REF_AT_TOP, -1, -1);\n+\t\t\t bb, NULL, DF_REF_REG_USE, DF_REF_AT_TOP, -1, -1, 0);\n     }\n #endif\n \n   /* Add the hard_frame_pointer if this block is the target of a\n      non-local goto.  */\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n     df_ref_record (collection_rec, hard_frame_pointer_rtx, NULL,\n-\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1);\n+\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n  \n   /* Add the artificial uses.  */\n   if (bb->index >= NUM_FIXED_BLOCKS)\n@@ -3427,7 +3463,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n \t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1);\n+\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n \t}\n     }\n \n@@ -3720,7 +3756,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n       df_ref_record (collection_rec, regno_reg_rtx[i], NULL, \n-\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1);\n+\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1, 0);\n     }\n \n   df_canonize_collection_rec (collection_rec);\n@@ -3881,7 +3917,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n     df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n@@ -3891,7 +3927,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n #endif\n \n   df_canonize_collection_rec (collection_rec);\n@@ -4363,9 +4399,8 @@ df_exit_block_bitmap_verify (bool abort_if_fail)\n }\n \n \n-/* Return true if df_ref information for all insns in all BLOCKS are\n-   correct and complete.  If BLOCKS is null, all blocks are\n-   checked.  */\n+/* Return true if df_ref information for all insns in all blocks are\n+   correct and complete.  */\n \n void\n df_scan_verify (void)"}, {"sha": "3c0894736df7011d1c39c4225f172cb350e8a66b", "filename": "gcc/df.h", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -42,12 +42,13 @@ struct df_link;\n    a uniform manner.  The last four problems can be added or deleted\n    at any time are always defined (though LIVE is always there at -O2\n    or higher); the others are always there.  */\n-#define DF_SCAN  0 \n-#define DF_LR    1      /* Live Registers backward. */\n-#define DF_LIVE  2      /* Live Registers & Uninitialized Registers */\n-#define DF_RD    3      /* Reaching Defs. */\n-#define DF_CHAIN 4      /* Def-Use and/or Use-Def Chains. */\n-#define DF_NOTE  5      /* REG_DEF and REG_UNUSED notes. */\n+#define DF_SCAN    0 \n+#define DF_LR      1      /* Live Registers backward. */\n+#define DF_LIVE    2      /* Live Registers & Uninitialized Registers */\n+#define DF_RD      3      /* Reaching Defs. */\n+#define DF_CHAIN   4      /* Def-Use and/or Use-Def Chains. */\n+#define DF_BYTE_LR 5      /* Subreg tracking lr.  */\n+#define DF_NOTE    6      /* REG_DEF and REG_UNUSED notes. */\n \n #define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n \n@@ -59,6 +60,13 @@ enum df_flow_dir\n     DF_BACKWARD\n   };\n \n+/* Used in the byte scanning to determine if may or must info is to be\n+   returned.  */\n+enum df_mm\n+  {\n+    DF_MM_MAY,\n+    DF_MM_MUST\n+  };\n \n /* The first of these is a set of a register.  The remaining three are\n    all uses of a register (the mem_load and mem_store relate to how\n@@ -398,6 +406,7 @@ struct df_ref_extract\n   struct df_ref ref;\n   int width;\n   int offset;\n+  enum machine_mode mode;\n };\n \n /* These links are used for two purposes:\n@@ -573,6 +582,7 @@ struct df\n #define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n #define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n #define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n+#define DF_BYTE_LR_BB_INFO(BB) (df_byte_lr_get_bb_info((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n@@ -585,6 +595,12 @@ struct df\n #define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in) \n #define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out) \n \n+/* These macros are used by passes that are not tolerant of\n+   uninitialized variables.  This intolerance should eventually\n+   be fixed.  */\n+#define DF_BYTE_LR_IN(BB) (DF_BYTE_LR_BB_INFO(BB)->in) \n+#define DF_BYTE_LR_OUT(BB) (DF_BYTE_LR_BB_INFO(BB)->out) \n+\n /* Macros to access the elements within the ref structure.  */\n \n \n@@ -619,8 +635,9 @@ struct df\n #define DF_REF_PREV_REG(REF) ((REF)->prev_reg)\n /* The following two macros may only be applied if one of \n    DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */ \n-#define DF_REF_WIDTH(REF) (((struct df_ref_extract *)(REF))->width)\n-#define DF_REF_OFFSET(REF) (((struct df_ref_extract *)(REF))->offset)\n+#define DF_REF_EXTRACT_WIDTH(REF) (((struct df_ref_extract *)(REF))->width)\n+#define DF_REF_EXTRACT_OFFSET(REF) (((struct df_ref_extract *)(REF))->offset)\n+#define DF_REF_EXTRACT_MODE(REF) (((struct df_ref_extract *)(REF))->mode)\n /* Macros to determine the reference type.  */\n \n #define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n@@ -775,16 +792,33 @@ struct df_live_bb_info\n };\n \n \n+/* Live registers, a backwards dataflow problem.  These bitmaps are\n+indexed by the df_byte_lr_offset array which is indexed by pseudo.  */\n+\n+struct df_byte_lr_bb_info \n+{\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap def;   /* The set of registers set in this block \n+                   - except artificial defs at the top.  */\n+  bitmap use;   /* The set of registers used in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap in;    /* Just before the block itself. */\n+  bitmap out;   /* At the bottom of the block.  */\n+};\n+\n+\n /* This is used for debugging and for the dumpers to find the latest\n    instance so that the df info can be added to the dumps.  This\n    should not be used by regular code.  */ \n extern struct df *df;\n-#define df_scan  (df->problems_by_index[DF_SCAN])\n-#define df_rd    (df->problems_by_index[DF_RD])\n-#define df_lr    (df->problems_by_index[DF_LR])\n-#define df_live  (df->problems_by_index[DF_LIVE])\n-#define df_chain (df->problems_by_index[DF_CHAIN])\n-#define df_note  (df->problems_by_index[DF_NOTE])\n+#define df_scan    (df->problems_by_index[DF_SCAN])\n+#define df_rd      (df->problems_by_index[DF_RD])\n+#define df_lr      (df->problems_by_index[DF_LR])\n+#define df_live    (df->problems_by_index[DF_LIVE])\n+#define df_chain   (df->problems_by_index[DF_CHAIN])\n+#define df_byte_lr (df->problems_by_index[DF_BYTE_LR])\n+#define df_note    (df->problems_by_index[DF_NOTE])\n \n /* This symbol turns on checking that each modification of the cfg has\n   been identified to the appropriate df routines.  It is not part of\n@@ -831,6 +865,7 @@ extern struct df_ref *df_find_use (rtx, rtx);\n extern bool df_reg_used (rtx, rtx);\n extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);\n extern void df_print_regset (FILE *file, bitmap r);\n+extern void df_print_byte_regset (FILE *file, bitmap r);\n extern void df_dump (FILE *);\n extern void df_dump_region (FILE *);\n extern void df_dump_start (FILE *);\n@@ -867,6 +902,13 @@ extern void df_live_verify_transfer_functions (void);\n extern void df_live_add_problem (void);\n extern void df_live_set_all_dirty (void);\n extern void df_chain_add_problem (enum df_chain_flags);\n+extern void df_byte_lr_add_problem (void);\n+extern int df_byte_lr_get_regno_start (unsigned int);\n+extern int df_byte_lr_get_regno_len (unsigned int);\n+extern void df_byte_lr_simulate_defs (rtx, bitmap);\n+extern void df_byte_lr_simulate_uses (rtx, bitmap);\n+extern void df_byte_lr_simulate_artificial_refs_at_top (basic_block, bitmap);\n+extern void df_byte_lr_simulate_artificial_refs_at_end (basic_block, bitmap);\n extern void df_note_add_problem (void);\n extern void df_simulate_find_defs (rtx, bitmap);\n extern void df_simulate_defs (rtx, bitmap);\n@@ -885,7 +927,7 @@ extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n extern struct df_ref *df_ref_create (rtx, rtx *, rtx,basic_block, \n \t\t\t\t     enum df_ref_type, enum df_ref_flags,\n-\t\t\t\t     int, int);\n+\t\t\t\t     int, int, enum machine_mode);\n extern void df_ref_remove (struct df_ref *);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);\n@@ -911,6 +953,10 @@ extern void df_compute_regs_ever_live (bool);\n extern bool df_read_modify_subreg_p (rtx);\n extern void df_scan_verify (void);\n \n+/* Functions defined in df-byte-scan.c.  */\n+extern bool df_compute_accessed_bytes (struct df_ref *, enum df_mm, \n+\t\t\t\t       unsigned int *, unsigned int *);\n+\n \n /* Get basic block info.  */\n \n@@ -950,6 +996,15 @@ df_live_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n+static inline struct df_byte_lr_bb_info *\n+df_byte_lr_get_bb_info (unsigned int index)\n+{\n+  if (index < df_byte_lr->block_info_size)\n+    return (struct df_byte_lr_bb_info *) df_byte_lr->block_info[index];\n+  else\n+    return NULL;\n+}\n+\n /* Get the artificial defs for a basic block.  */\n \n static inline struct df_ref **"}, {"sha": "93329875705081149cd1c803b3dbc772679db808", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -679,6 +679,7 @@ update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n       struct df_ref *orig_use = use, *new_use;\n       int width = -1;\n       int offset = -1;\n+      enum machine_mode mode = 0;\n       rtx *new_loc = find_occurrence (loc, DF_REF_REG (orig_use));\n       use_rec++;\n \n@@ -687,15 +688,17 @@ update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n \n       if (DF_REF_FLAGS_IS_SET (orig_use, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n \t{\n-\t  width = DF_REF_WIDTH (orig_use);\n-\t  offset = DF_REF_OFFSET (orig_use);\n+\t  width = DF_REF_EXTRACT_WIDTH (orig_use);\n+\t  offset = DF_REF_EXTRACT_OFFSET (orig_use);\n+\t  mode = DF_REF_EXTRACT_MODE (orig_use);\n \t}\n \n       /* Add a new insn use.  Use the original type, because it says if the\n          use was within a MEM.  */\n       new_use = df_ref_create (DF_REF_REG (orig_use), new_loc,\n \t\t\t       insn, BLOCK_FOR_INSN (insn),\n-\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags, width, offset);\n+\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags, \n+\t\t\t       width, offset, mode);\n \n       /* Set up the use-def chain.  */\n       df_chain_copy (new_use, DF_REF_CHAIN (orig_use));"}, {"sha": "be7829768408736e07ee7c817b81a2b5340a8eef", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -731,6 +731,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_partition_blocks);\n       NEXT_PASS (pass_regmove);\n       NEXT_PASS (pass_split_all_insns);\n+      NEXT_PASS (pass_fast_rtl_byte_dce);\n       NEXT_PASS (pass_lower_subreg2);\n       NEXT_PASS (pass_df_initialize_no_opt);\n       NEXT_PASS (pass_stack_ptr_mod);"}, {"sha": "954bc6dc6711a24a501a051a97112901d27e45e0", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -64,6 +64,7 @@ DEFTIMEVAR (TV_DF_LR\t\t     , \"df live regs\")\n DEFTIMEVAR (TV_DF_LIVE\t\t     , \"df live&initialized regs\")\n DEFTIMEVAR (TV_DF_UREC\t\t     , \"df uninitialized regs 2\")\n DEFTIMEVAR (TV_DF_CHAIN\t\t     , \"df use-def / def-use chains\")\n+DEFTIMEVAR (TV_DF_BYTE_LR\t     , \"df live byte regs\")\n DEFTIMEVAR (TV_DF_NOTE\t\t     , \"df reg dead/unused notes\")\n DEFTIMEVAR (TV_REG_STATS\t     , \"register information\")\n "}, {"sha": "0934e14a0552f1a0dedf3807548066aecd3ea282", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc806ac109a1cc625e80d9a38d94a7a589a559ee/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=cc806ac109a1cc625e80d9a38d94a7a589a559ee", "patch": "@@ -423,6 +423,7 @@ extern struct rtl_opt_pass pass_partition_blocks;\n extern struct rtl_opt_pass pass_match_asm_constraints;\n extern struct rtl_opt_pass pass_regmove;\n extern struct rtl_opt_pass pass_split_all_insns;\n+extern struct rtl_opt_pass pass_fast_rtl_byte_dce;\n extern struct rtl_opt_pass pass_lower_subreg2;\n extern struct rtl_opt_pass pass_mode_switching;\n extern struct rtl_opt_pass pass_see;"}]}