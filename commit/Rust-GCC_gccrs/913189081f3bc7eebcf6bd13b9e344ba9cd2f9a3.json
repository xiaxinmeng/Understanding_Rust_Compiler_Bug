{"sha": "913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzMTg5MDgxZjNiYzdlZWJjZjZiZDEzYjllMzQ0YmE5Y2QyZjlhMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-26T18:42:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-26T18:42:21Z"}, "message": "cppexp.c (possible_sum_sign, [...]): Remove.\n\n\t* cppexp.c (possible_sum_sign, integer_overflow, left_shift,\n\tright_shift): Remove.\n\t(cpp_num, cpp_num_part, PART_PRECISION, HALF_MASK, LOW_PART,\n\tHIGH_PART): New.\n\t(struct op): Use cpp_num.\n\t(num_zerop, num_eq, num_positive, num_greater_freq, num_trim,\n\tnum_part_mul, num_unary_op, num_binary_op, num_negate,\n\tnum_bitwise_op, num_inequality_op, num_equality_op, num_mul,\n\tnum_div_op, num_lshift, num_rshift, append_digit): New.\n\t(interpret_number, parse_defined, eval_token, reduce): Update\n\tfor two-integer arithmetic.\n\t(binary_handler): New typedef.\n\t(optab): Update.\n\t(COMPARE, EQUALITY, BITWISE, MINMAX, UNARY, SHIFT): Delete.\n\t(_cpp_parse_expr, reduce): Update to handle two-integers.\n\t* cpplib.c (_cpp_test_assertion): Back up on CPP_EOF.\ntestsuite:\n\t* gcc.dg/cpp/arith-1.c: New semantic tests.\n\t* gcc.dg/cpp/if-1.c: Update.\n\nFrom-SVN: r53900", "tree": {"sha": "e0b28595be44974817fef680c5e031a4b195ef68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0b28595be44974817fef680c5e031a4b195ef68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/comments", "author": null, "committer": null, "parents": [{"sha": "bcb6a2be20c249fbb6edbd15b6f3d09c925a37e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb6a2be20c249fbb6edbd15b6f3d09c925a37e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb6a2be20c249fbb6edbd15b6f3d09c925a37e5"}], "stats": {"total": 1409, "additions": 1089, "deletions": 320}, "files": [{"sha": "1a028a95b7f4f114439b37815b87a0ef79ccfcb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -1,3 +1,22 @@\n+2002-05-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (possible_sum_sign, integer_overflow, left_shift,\n+\tright_shift): Remove.\n+\t(cpp_num, cpp_num_part, PART_PRECISION, HALF_MASK, LOW_PART,\n+\tHIGH_PART): New.\n+\t(struct op): Use cpp_num.\n+\t(num_zerop, num_eq, num_positive, num_greater_freq, num_trim,\n+\tnum_part_mul, num_unary_op, num_binary_op, num_negate,\n+\tnum_bitwise_op, num_inequality_op, num_equality_op, num_mul,\n+\tnum_div_op, num_lshift, num_rshift, append_digit): New.\n+\t(interpret_number, parse_defined, eval_token, reduce): Update\n+\tfor two-integer arithmetic.\n+\t(binary_handler): New typedef.\n+\t(optab): Update.\n+\t(COMPARE, EQUALITY, BITWISE, MINMAX, UNARY, SHIFT): Delete.\n+\t(_cpp_parse_expr, reduce): Update to handle two-integers.\n+\t* cpplib.c (_cpp_test_assertion): Back up on CPP_EOF.\n+\n 2002-05-26  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \t* config/avr/avr.c (avr_asm_only_p): New variable."}, {"sha": "7aa350d49bdbc82cbac2f7d89f8b7522cf7960be", "filename": "gcc/cppexp.c", "status": "modified", "additions": 805, "deletions": 319, "changes": 1124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -23,29 +23,61 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-/* Yield nonzero if adding two numbers with A's and B's signs can yield a\n-   number with SUM's sign, where A, B, and SUM are all C integers.  */\n-#define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n-\n-static void integer_overflow PARAMS ((cpp_reader *));\n-static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n-\t\t\t\t\t   unsigned int,\n-\t\t\t\t\t   unsigned HOST_WIDEST_INT));\n-static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n-\t\t\t\t\t    unsigned int,\n-\t\t\t\t\t    unsigned HOST_WIDEST_INT));\n-static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n-static struct op parse_defined PARAMS ((cpp_reader *));\n-static struct op eval_token PARAMS ((cpp_reader *, const cpp_token *));\n-static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n+typedef unsigned long cpp_num_part;\n+typedef struct cpp_num cpp_num;\n+\n+#define PART_PRECISION (sizeof (cpp_num_part) * CHAR_BIT)\n+#define HALF_MASK (~(cpp_num_part) 0 >> (PART_PRECISION / 2))\n+#define LOW_PART(num_part) (num_part & HALF_MASK)\n+#define HIGH_PART(num_part) (num_part >> (PART_PRECISION / 2))\n+\n+/* A preprocessing number.  Code assumes that any unused high bits of\n+   the double integer are set to zero.  */\n+struct cpp_num\n+{\n+  cpp_num_part high;\n+  cpp_num_part low;\n+  bool unsignedp;  /* True if value should be treated as unsigned.  */\n+  bool overflow;   /* True if the most recent calculation overflowed.  */\n+};\n \n struct op\n {\n+  cpp_num value;\t\t     /* The value logically \"right\" of op.  */\n   enum cpp_ttype op;\n-  uchar unsignedp;    /* True if value should be treated as unsigned.  */\n-  HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n \n+/* Some simple utility routines on double integers.  */\n+#define num_zerop(num) ((num.low | num.high) == 0)\n+#define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)\n+static bool num_positive PARAMS ((cpp_num, size_t));\n+static bool num_greater_eq PARAMS ((cpp_num, cpp_num, size_t));\n+static cpp_num num_trim PARAMS ((cpp_num, size_t));\n+static cpp_num num_part_mul PARAMS ((cpp_num_part, cpp_num_part));\n+\n+static cpp_num num_unary_op PARAMS ((cpp_reader *, cpp_num, enum cpp_ttype));\n+static cpp_num num_binary_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t      enum cpp_ttype));\n+static cpp_num num_negate PARAMS ((cpp_num, size_t));\n+static cpp_num num_bitwise_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t       enum cpp_ttype));\n+static cpp_num num_inequality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t\t  enum cpp_ttype));\n+static cpp_num num_equality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t\tenum cpp_ttype));\n+static cpp_num num_mul PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\tenum cpp_ttype));\n+static cpp_num num_div_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t   enum cpp_ttype));\n+static cpp_num num_lshift PARAMS ((cpp_num, size_t, size_t));\n+static cpp_num num_rshift PARAMS ((cpp_num, size_t, size_t));\n+\n+static cpp_num append_digit PARAMS ((cpp_num, int, int, size_t));\n+static cpp_num interpret_number PARAMS ((cpp_reader *, const cpp_token *));\n+static cpp_num parse_defined PARAMS ((cpp_reader *));\n+static cpp_num eval_token PARAMS ((cpp_reader *, const cpp_token *));\n+static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n+\n /* Token type abuse.  There is no \"error\" token, but we can't get\n    comments in #if, so we can abuse that token type.  Similarly,\n    create unary plus and minus operators.  */\n@@ -83,26 +115,79 @@ static const struct suffix vsuf_3[] = {\n   { \"llu\", 1, 2 }, { \"LLU\", 1, 2 }, { \"LLu\", 1, 2 }, { \"llU\", 1, 2 }\n };\n \n+/* Append DIGIT to NUM, a number of PRECISION bits being read in base\n+   BASE.  */\n+static cpp_num\n+append_digit (num, digit, base, precision)\n+     cpp_num num;\n+     int digit, base;\n+     size_t precision;\n+{\n+  cpp_num result;\n+  unsigned int shift = 3 + (base == 16);\n+  bool overflow;\n+  cpp_num_part add_high, add_low;\n+\n+  /* Multiply by 8 or 16.  Catching this overflow here means we don't\n+     need to worry about add_high overflowing.  */\n+  overflow = num.high >> (PART_PRECISION - shift);\n+  result.high = num.high << shift;\n+  result.low = num.low << shift;\n+  result.high |= num.low >> (PART_PRECISION - shift);\n+\n+  if (base == 10)\n+    {\n+      add_low = num.low << 1;\n+      add_high = (num.high << 1) + (num.low >> (PART_PRECISION - 1));\n+    }\n+  else\n+    add_high = add_low = 0;\n+\n+  if (add_low + digit < add_low)\n+    add_high++;\n+  add_low += digit;\n+    \n+  if (result.low + add_low < result.low)\n+    add_high++;\n+  if (result.high + add_high < result.high)\n+    overflow = true;\n+\n+  result.low += add_low;\n+  result.high += add_high;\n+\n+  /* The above code catches overflow of a cpp_num type.  This catches\n+     overflow of the (possibly shorter) target precision.  */\n+  num.low = result.low;\n+  num.high = result.high;\n+  result = num_trim (result, precision);\n+  if (!num_eq (result, num))\n+    overflow = true;\n+\n+  result.unsignedp = num.unsignedp;\n+  result.overflow = overflow;\n+  return result;\n+}\n+\n /* Parse and convert what is presumably an integer in TOK.  Accepts\n    decimal, hex, or octal with or without size suffixes.  Returned op\n    is CPP_ERROR on error, otherwise it is a CPP_NUMBER.  */\n-static struct op\n-parse_number (pfile, tok)\n+static cpp_num\n+interpret_number (pfile, tok)\n      cpp_reader *pfile;\n      const cpp_token *tok;\n {\n-  struct op op;\n+  cpp_num result;\n   const uchar *start = tok->val.str.text;\n   const uchar *end = start + tok->val.str.len;\n   const uchar *p = start;\n-  int c = 0, i, nsuff;\n-  unsigned HOST_WIDEST_INT n = 0, nd, MAX_over_base;\n-  int base = 10;\n-  int overflow = 0;\n-  int digit, largest_digit = 0;\n   const struct suffix *sufftab;\n+  size_t precision = CPP_OPTION (pfile, precision);\n+  unsigned int i, nsuff, base = 10, c = 0, largest_digit = 0;\n+  bool overflow = false;\n \n-  op.unsignedp = 0;\n+  result.low = result.high = 0;\n+  result.unsignedp = 0;\n+  result.overflow = 0;\n \n   if (p[0] == '0')\n     {\n@@ -118,25 +203,19 @@ parse_number (pfile, tok)\n \t}\n     }\n \n-  /* Some buggy compilers (e.g. MPW C) seem to need both casts.  */\n-  MAX_over_base = (((unsigned HOST_WIDEST_INT) -1)\n-\t\t   / ((unsigned HOST_WIDEST_INT) base));\n-\n   for(; p < end; p++)\n     {\n       c = *p;\n \n-      if (ISDIGIT (c)\n-\t  || (base == 16 && ISXDIGIT (c)))\n-\tdigit = hex_value (c);\n+      if (ISDIGIT (c) || (base == 16 && ISXDIGIT (c)))\n+\tc = hex_value (c);\n       else\n \tbreak;\n \n-      if (largest_digit < digit)\n-\tlargest_digit = digit;\n-      nd = n * base + digit;\n-      overflow |= MAX_over_base < n || nd < n;\n-      n = nd;\n+      result = append_digit (result, c, base, precision);\n+      overflow |= result.overflow;\n+      if (largest_digit < c)\n+\tlargest_digit = c;\n     }\n \n   if (p < end)\n@@ -166,7 +245,7 @@ parse_number (pfile, tok)\n \t  break;\n       if (i == nsuff)\n \tgoto invalid_suffix;\n-      op.unsignedp = sufftab[i].u;\n+      result.unsignedp = sufftab[i].u;\n \n       if (CPP_WTRADITIONAL (pfile)\n \t  && sufftab[i].u\n@@ -183,38 +262,34 @@ parse_number (pfile, tok)\n \t       \"integer constant contains digits beyond the radix\");\n \n   if (overflow)\n-    cpp_error (pfile, DL_PEDWARN, \"integer constant out of range\");\n-\n+    cpp_error (pfile, DL_PEDWARN, \"integer constant too large for its type\");\n   /* If too big to be signed, consider it unsigned.  */\n-  else if ((HOST_WIDEST_INT) n < 0 && ! op.unsignedp)\n+  else if (!result.unsignedp && !num_positive (result, precision))\n     {\n       if (base == 10)\n \tcpp_error (pfile, DL_WARNING,\n \t\t   \"integer constant is so large that it is unsigned\");\n-      op.unsignedp = 1;\n+      result.unsignedp = 1;\n     }\n \n-  op.value = n;\n-  op.op = CPP_NUMBER;\n-  return op;\n+  return result;\n \n  invalid_suffix:\n   cpp_error (pfile, DL_ERROR, \"invalid suffix '%.*s' on integer constant\",\n \t     (int) (end - p), p);\n  syntax_error:\n-  op.op = CPP_ERROR;\n-  return op;\n+  return result;\n }\n \n /* Handle meeting \"defined\" in a preprocessor expression.  */\n-static struct op\n+static cpp_num\n parse_defined (pfile)\n      cpp_reader *pfile;\n {\n+  cpp_num result;\n   int paren = 0;\n   cpp_hashnode *node = 0;\n   const cpp_token *token;\n-  struct op op;\n   cpp_context *initial_context = pfile->context;\n \n   /* Don't expand macros.  */\n@@ -253,57 +328,60 @@ parse_defined (pfile)\n \t}\n     }\n \n-  if (!node)\n-    op.op = CPP_ERROR;\n-  else\n+  if (node)\n     {\n       if (pfile->context != initial_context)\n \tcpp_error (pfile, DL_WARNING,\n \t\t   \"this use of \\\"defined\\\" may not be portable\");\n \n-      op.value = node->type == NT_MACRO;\n-      op.unsignedp = 0;\n-      op.op = CPP_NUMBER;\n-\n       /* A possible controlling macro of the form #if !defined ().\n \t _cpp_parse_expr checks there was no other junk on the line.  */\n       pfile->mi_ind_cmacro = node;\n     }\n \n   pfile->state.prevent_expansion--;\n-  return op;\n+\n+  result.unsignedp = 0;\n+  result.high = 0;\n+  result.overflow = 0;\n+  result.low = node && node->type == NT_MACRO;\n+  return result;\n }\n \n /* Convert a token into a CPP_NUMBER (an interpreted preprocessing\n    number or character constant, or the result of the \"defined\" or \"#\"\n    operators), or CPP_ERROR on error.  */\n-static struct op\n+static cpp_num\n eval_token (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n {\n+  cpp_num result;\n   unsigned int temp;\n   int unsignedp = 0;\n-  struct op op;\n-\n-  op.op = CPP_NUMBER;\n \n   switch (token->type)\n     {\n     case CPP_NUMBER:\n-      return parse_number (pfile, token);\n+      return interpret_number (pfile, token);\n \n     case CPP_WCHAR:\n     case CPP_CHAR:\n       {\n-\tcppchar_t result = cpp_interpret_charconst (pfile, token,\n-\t\t\t\t\t\t    &temp, &unsignedp);\n-\top.value = result;\n+\tcppchar_t cc = cpp_interpret_charconst (pfile, token,\n+\t\t\t\t\t\t&temp, &unsignedp);\n+\n+\tresult.high = 0;\n+\tresult.low = cc;\n \t/* Sign-extend the result if necessary.  */\n-\tif (!unsignedp && (cppchar_signed_t) result < 0\n-\t    && sizeof (HOST_WIDEST_INT) > sizeof (cppchar_t))\n-\t  op.value |= ~(((unsigned HOST_WIDEST_INT) 1 << BITS_PER_CPPCHAR_T)\n-\t\t\t- 1);\n+\tif (!unsignedp && (cppchar_signed_t) cc < 0)\n+\t  {\n+\t    if (PART_PRECISION > BITS_PER_CPPCHAR_T)\n+\t      result.low |= ~(~(cpp_num_part) 0\n+\t\t\t      >> (PART_PRECISION - BITS_PER_CPPCHAR_T));\n+\t    result.high = ~(cpp_num_part) 0;\n+\t    result = num_trim (result, CPP_OPTION (pfile, precision));\n+\t  }\n       }\n       break;\n \n@@ -314,7 +392,8 @@ eval_token (pfile, token)\n \t       && (token->val.node == pfile->spec_nodes.n_true\n \t\t   || token->val.node == pfile->spec_nodes.n_false))\n \t{\n-\t  op.value = (token->val.node == pfile->spec_nodes.n_true);\n+\t  result.high = 0;\n+\t  result.low = (token->val.node == pfile->spec_nodes.n_true);\n \n \t  /* Warn about use of true or false in #if when pedantic\n \t     and stdbool.h has not been included.  */\n@@ -326,74 +405,23 @@ eval_token (pfile, token)\n \t}\n       else\n \t{\n-\t  op.value = 0;\n+\t  result.high = 0;\n+\t  result.low = 0;\n \t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n \t    cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" is not defined\",\n \t\t       NODE_NAME (token->val.node));\n \t}\n       break;\n \n     default: /* CPP_HASH */\n-      if (_cpp_test_assertion (pfile, &temp))\n-\top.op = CPP_ERROR;\n-      op.value = temp;\n+      _cpp_test_assertion (pfile, &temp);\n+      result.high = 0;\n+      result.low = temp;\n     }\n \n-  op.unsignedp = unsignedp;\n-  return op;\n-}\n-\n-/* Warn if appropriate on overflow.  */\n-static void\n-integer_overflow (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (CPP_PEDANTIC (pfile))\n-    cpp_error (pfile, DL_PEDWARN,\n-\t       \"integer overflow in preprocessor expression\");\n-}\n-\n-/* Handle shifting A left by B bits.  UNSIGNEDP is non-zero if A is\n-   unsigned.  */\n-static HOST_WIDEST_INT\n-left_shift (pfile, a, unsignedp, b)\n-     cpp_reader *pfile;\n-     HOST_WIDEST_INT a;\n-     unsigned int unsignedp;\n-     unsigned HOST_WIDEST_INT b;\n-{\n-  if (b >= HOST_BITS_PER_WIDEST_INT)\n-    {\n-      if (! unsignedp && a != 0)\n-\tinteger_overflow (pfile);\n-      return 0;\n-    }\n-  else if (unsignedp)\n-    return (unsigned HOST_WIDEST_INT) a << b;\n-  else\n-    {\n-      HOST_WIDEST_INT l = a << b;\n-      if (l >> b != a)\n-\tinteger_overflow (pfile);\n-      return l;\n-    }\n-}\n-\n-/* Handle shifting A right by B bits.  UNSIGNEDP is non-zero if A is\n-   unsigned.  */\n-static HOST_WIDEST_INT\n-right_shift (pfile, a, unsignedp, b)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     HOST_WIDEST_INT a;\n-     unsigned int unsignedp;\n-     unsigned HOST_WIDEST_INT b;\n-{\n-  if (b >= HOST_BITS_PER_WIDEST_INT)\n-    return unsignedp ? 0 : a >> (HOST_BITS_PER_WIDEST_INT - 1);\n-  else if (unsignedp)\n-    return (unsigned HOST_WIDEST_INT) a >> b;\n-  else\n-    return a >> b;\n+  result.unsignedp = unsignedp;\n+  result.overflow = 0;\n+  return result;\n }\n \f\n /* Operator precedence and flags table.\n@@ -422,74 +450,58 @@ extra semantics need to be handled with operator-specific code.  */\n #define NO_L_OPERAND\t(1 << 0)\n #define LEFT_ASSOC\t(1 << 1)\n \n+/* Arity. */\n+#define UNARY\t\t(1 << 0)\n+#define BINARY\t\t(1 << 1)\n+#define OTHER\t\t(1 << 2)\n+\n+typedef cpp_num (*binary_handler) PARAMS ((cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t\t   enum cpp_ttype));\n /* Operator to priority map.  Must be in the same order as the first\n    N entries of enum cpp_ttype.  */\n static const struct operator\n {\n   uchar prio;\n   uchar flags;\n+  uchar arity;\n+  binary_handler handler;\n } optab[] =\n {\n-  /* EQ */\t\t{0, 0},\t\t/* Shouldn't happen.  */\n-  /* NOT */\t\t{16, NO_L_OPERAND},\n-  /* GREATER */\t\t{12, LEFT_ASSOC},\n-  /* LESS */\t\t{12, LEFT_ASSOC},\n-  /* PLUS */\t\t{14, LEFT_ASSOC},\n-  /* MINUS */\t\t{14, LEFT_ASSOC},\n-  /* MULT */\t\t{15, LEFT_ASSOC},\n-  /* DIV */\t\t{15, LEFT_ASSOC},\n-  /* MOD */\t\t{15, LEFT_ASSOC},\n-  /* AND */\t\t{9, LEFT_ASSOC},\n-  /* OR */\t\t{7, LEFT_ASSOC},\n-  /* XOR */\t\t{8, LEFT_ASSOC},\n-  /* RSHIFT */\t\t{13, LEFT_ASSOC},\n-  /* LSHIFT */\t\t{13, LEFT_ASSOC},\n-  /* MIN */\t\t{10, LEFT_ASSOC},\t/* C++ specific */\n-  /* MAX */\t\t{10, LEFT_ASSOC},\t/* extensions */\n-\n-  /* COMPL */\t\t{16, NO_L_OPERAND},\n-  /* AND_AND */\t\t{6, LEFT_ASSOC},\n-  /* OR_OR */\t\t{5, LEFT_ASSOC},\n-  /* QUERY */\t\t{3, 0},\n-  /* COLON */\t\t{4, LEFT_ASSOC},\n-  /* COMMA */\t\t{2, LEFT_ASSOC},\n-  /* OPEN_PAREN */\t{1, NO_L_OPERAND},\n-  /* CLOSE_PAREN */\t{0, 0},\n-  /* EOF */\t\t{0, 0},\n-  /* EQ_EQ */\t\t{11, LEFT_ASSOC},\n-  /* NOT_EQ */\t\t{11, LEFT_ASSOC},\n-  /* GREATER_EQ */\t{12, LEFT_ASSOC},\n-  /* LESS_EQ */\t\t{12, LEFT_ASSOC},\n-  /* UPLUS */\t\t{16, NO_L_OPERAND},\n-  /* UMINUS */\t\t{16, NO_L_OPERAND}\n+  /* EQ */\t\t{0, 0, OTHER, NULL},\t/* Shouldn't happen.  */\n+  /* NOT */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n+  /* GREATER */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n+  /* LESS */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n+  /* PLUS */\t\t{14, LEFT_ASSOC, BINARY, num_binary_op},\n+  /* MINUS */\t\t{14, LEFT_ASSOC, BINARY, num_binary_op},\n+  /* MULT */\t\t{15, LEFT_ASSOC, BINARY, num_mul},\n+  /* DIV */\t\t{15, LEFT_ASSOC, BINARY, num_div_op},\n+  /* MOD */\t\t{15, LEFT_ASSOC, BINARY, num_div_op},\n+  /* AND */\t\t{9, LEFT_ASSOC, BINARY, num_bitwise_op},\n+  /* OR */\t\t{7, LEFT_ASSOC, BINARY, num_bitwise_op},\n+  /* XOR */\t\t{8, LEFT_ASSOC, BINARY, num_bitwise_op},\n+  /* RSHIFT */\t\t{13, LEFT_ASSOC, BINARY, num_binary_op},\n+  /* LSHIFT */\t\t{13, LEFT_ASSOC, BINARY, num_binary_op},\n+\n+  /* MIN */\t\t{10, LEFT_ASSOC, BINARY, num_binary_op},\n+  /* MAX */\t\t{10, LEFT_ASSOC, BINARY, num_binary_op},\n+\n+  /* COMPL */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n+  /* AND_AND */\t\t{6, LEFT_ASSOC, OTHER, NULL},\n+  /* OR_OR */\t\t{5, LEFT_ASSOC, OTHER, NULL},\n+  /* QUERY */\t\t{3, 0, OTHER, NULL},\n+  /* COLON */\t\t{4, LEFT_ASSOC, OTHER, NULL},\n+  /* COMMA */\t\t{2, LEFT_ASSOC, BINARY, num_binary_op},\n+  /* OPEN_PAREN */\t{1, NO_L_OPERAND, OTHER, NULL},\n+  /* CLOSE_PAREN */\t{0, 0, OTHER, NULL},\n+  /* EOF */\t\t{0, 0, OTHER, NULL},\n+  /* EQ_EQ */\t\t{11, LEFT_ASSOC, BINARY, num_equality_op},\n+  /* NOT_EQ */\t\t{11, LEFT_ASSOC, BINARY, num_equality_op},\n+  /* GREATER_EQ */\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n+  /* LESS_EQ */\t\t{12, LEFT_ASSOC, BINARY, num_inequality_op},\n+  /* UPLUS */\t\t{16, NO_L_OPERAND, UNARY, NULL},\n+  /* UMINUS */\t\t{16, NO_L_OPERAND, UNARY, NULL}\n };\n \n-#define COMPARE(OP) \\\n-  top->unsignedp = 0; \\\n-  top->value = (unsigned1 | unsigned2) \\\n-  ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 \\\n-  : (v1 OP v2)\n-#define EQUALITY(OP) \\\n-  top->value = v1 OP v2; \\\n-  top->unsignedp = 0;\n-#define BITWISE(OP) \\\n-  top->value = v1 OP v2; \\\n-  top->unsignedp = unsigned1 | unsigned2;\n-#define MINMAX(OP) \\\n-  top->value = (v1 OP v2) ? v1 : v2; \\\n-  top->unsignedp = unsigned1 | unsigned2;\n-#define UNARY(OP) \\\n-  top->value = OP v2; \\\n-  top->unsignedp = unsigned2;\n-#define SHIFT(PSH, MSH) \\\n-  if (pfile->state.skip_eval)  \\\n-    break;\t\t\\\n-  top->unsignedp = unsigned1; \\\n-  if (v2 < 0 && ! unsigned2)  \\\n-    top->value = MSH (pfile, v1, unsigned1, -v2); \\\n-  else \\\n-    top->value = PSH (pfile, v1, unsigned1, v2);\n-\n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.\n \n@@ -541,11 +553,7 @@ _cpp_parse_expr (pfile)\n \t    SYNTAX_ERROR2 (\"missing binary operator before token \\\"%s\\\"\",\n \t\t\t   cpp_token_as_text (pfile, token));\n \t  want_value = false;\n-\t  op = eval_token (pfile, token);\n-\t  if (op.op == CPP_ERROR)\n-\t    goto syntax_error;\n-\t  top->value = op.value;\n-\t  top->unsignedp = op.unsignedp;\n+\t  top->value = eval_token (pfile, token);\n \t  continue;\n \n \tcase CPP_NOT:\n@@ -607,18 +615,18 @@ _cpp_parse_expr (pfile)\n \tcase CPP_CLOSE_PAREN:\n \t  continue;\n \tcase CPP_OR_OR:\n-\t  if (top->value)\n+\t  if (!num_zerop (top->value))\n \t    pfile->state.skip_eval++;\n \t  break;\n \tcase CPP_AND_AND:\n \tcase CPP_QUERY:\n-\t  if (!top->value)\n+\t  if (num_zerop (top->value))\n \t    pfile->state.skip_eval++;\n \t  break;\n \tcase CPP_COLON:\n \t  if (top->op != CPP_QUERY)\n \t    SYNTAX_ERROR (\" ':' without preceding '?'\");\n-\t  if (top[-1].value) /* Was '?' condition true?  */\n+\t  if (!num_zerop (top[-1].value)) /* Was '?' condition true?  */\n \t    pfile->state.skip_eval++;\n \t  else\n \t    pfile->state.skip_eval--;\n@@ -648,7 +656,7 @@ _cpp_parse_expr (pfile)\n       return false;  /* Return false on syntax error.  */\n     }\n \n-  return top->value != 0;\n+  return !num_zerop (top->value);\n }\n \n /* Reduce the operator / value stack if possible, in preparation for\n@@ -662,6 +670,13 @@ reduce (pfile, top, op)\n {\n   unsigned int prio;\n \n+  if (top->op <= CPP_EQ || top->op > CPP_LAST_CPP_OP + 2)\n+    {\n+    bad_op:\n+      cpp_error (pfile, DL_ICE, \"impossible operator '%u'\", top->op);\n+      return 0;\n+    }\n+\n   if (op == CPP_OPEN_PAREN)\n     return top;\n \n@@ -670,144 +685,73 @@ reduce (pfile, top, op)\n   prio = optab[op].prio - ((optab[op].flags & LEFT_ASSOC) != 0);\n   while (prio < optab[top->op].prio)\n     {\n-      HOST_WIDEST_INT v1, v2;\n-      unsigned int unsigned1, unsigned2;\n-\n-      unsigned2 = top->unsignedp, v2 = top->value;\n-      top--;\n-      unsigned1 = top->unsignedp, v1 = top->value;\n-\n-      /* Now set top->value = (top[1].op)(v1, v2); */\n-      switch (top[1].op)\n+      if (optab[top->op].arity == UNARY)\n \t{\n-\tdefault:\n-\t  cpp_error (pfile, DL_ICE, \"impossible operator '%u'\", top[1].op);\n-\t  return 0;\n-\n-\tcase CPP_NOT:\t UNARY(!);\tbreak;\n-\tcase CPP_COMPL:\t UNARY(~);\tbreak;\n-\tcase CPP_LESS: \t COMPARE(<);\tbreak;\n-\tcase CPP_GREATER: COMPARE(>);\tbreak;\n-\tcase CPP_LESS_EQ: COMPARE(<=);\tbreak;\n-\tcase CPP_GREATER_EQ: COMPARE(>=); break;\n-\tcase CPP_EQ_EQ:\t EQUALITY(==);\tbreak;\n-\tcase CPP_NOT_EQ: EQUALITY(!=);\tbreak;\n-\tcase CPP_AND:\t BITWISE(&);\tbreak;\n-\tcase CPP_XOR:\t BITWISE(^);\tbreak;\n-\tcase CPP_OR:\t BITWISE(|);\tbreak;\n-\tcase CPP_LSHIFT: SHIFT(left_shift, right_shift); break;\n-\tcase CPP_RSHIFT: SHIFT(right_shift, left_shift); break;\n-\tcase CPP_MIN:\t MINMAX(<);\tbreak;\n-\tcase CPP_MAX:\t MINMAX(>);\tbreak;\n-\n-\tcase CPP_UPLUS:\n-\t  /* Can't use UNARY(+) because K+R C did not have unary\n-\t     plus.  Can't use UNARY() because some compilers object\n-\t     to the empty argument.  */\n-\t  top->value = v2;\n-\t  top->unsignedp = unsigned2;\n-\t  if (CPP_WTRADITIONAL (pfile))\n-\t    cpp_error (pfile, DL_WARNING,\n-\t\t       \"traditional C rejects the unary plus operator\");\n-\t  break;\n-\tcase CPP_UMINUS:\n-\t  UNARY(-);\n-\t  if (!pfile->state.skip_eval && (top->value & v2) < 0 && !unsigned2)\n-\t    integer_overflow (pfile);\n+\t  if (!pfile->state.skip_eval)\n+\t    top[-1].value = num_unary_op (pfile, top->value, top->op);\n+\t  top--;\n+\t}\n+      else if (optab[top->op].arity == BINARY)\n+\t{\n+\t  if (!pfile->state.skip_eval)\n+\t    top[-1].value = (* (binary_handler) optab[top->op].handler)\n+\t      (pfile, top[-1].value, top->value, top->op);\n+\t  top--;\n+\t}\n+      /* Anything changing skip_eval has to be handled here.  */\n+      else switch (top--->op)\n+\t{\n+\tcase CPP_OR_OR:\n+\t  if (!num_zerop (top->value))\n+\t    pfile->state.skip_eval--;\n+\t  top->value.low = !num_zerop (top->value) || !num_zerop (top[1].value);\n+\t  top->value.high = 0;\n+\t  top->value.unsignedp = false;\n+\t  top->value.overflow = false;\n \t  break;\n \n-\tcase CPP_PLUS:\n-\t  top->value = v1 + v2;\n-\t  top->unsignedp = unsigned1 | unsigned2;\n-\t  if (! top->unsignedp && ! pfile->state.skip_eval\n-\t      && ! possible_sum_sign (v1, v2, top->value))\n-\t    integer_overflow (pfile);\n-\t  break;\n-\tcase CPP_MINUS:\n-\t  top->value = v1 - v2;\n-\t  top->unsignedp = unsigned1 | unsigned2;\n-\t  if (! top->unsignedp && ! pfile->state.skip_eval\n-\t      && ! possible_sum_sign (top->value, v2, v1))\n-\t    integer_overflow (pfile);\n-\t  break;\n-\tcase CPP_MULT:\n-\t  top->unsignedp = unsigned1 | unsigned2;\n-\t  if (top->unsignedp)\n-\t    top->value = (unsigned HOST_WIDEST_INT) v1 * v2;\n-\t  else if (!pfile->state.skip_eval)\n-\t    {\n-\t      top->value = v1 * v2;\n-\t      if (v1 && (top->value / v1 != v2\n-\t\t\t || (top->value & v1 & v2) < 0))\n-\t\tinteger_overflow (pfile);\n-\t    }\n+\tcase CPP_AND_AND:\n+\t  if (num_zerop (top->value))\n+\t    pfile->state.skip_eval--;\n+\t  top->value.low = !num_zerop (top->value) && !num_zerop (top[1].value);\n+\t  top->value.high = 0;\n+\t  top->value.unsignedp = false;\n+\t  top->value.overflow = false;\n \t  break;\n-\tcase CPP_DIV:\n-\tcase CPP_MOD:\n-\t  if (pfile->state.skip_eval)\n-\t    break;\n-\t  if (v2 == 0)\n+\n+\tcase CPP_OPEN_PAREN:\n+\t  if (op != CPP_CLOSE_PAREN)\n \t    {\n-\t      cpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n+\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n \t      return 0;\n \t    }\n-\t  top->unsignedp = unsigned1 | unsigned2;\n-\t  if (top[1].op == CPP_DIV)\n+\t  top->value = top[1].value;\n+\t  return top;\n+\n+\tcase CPP_COLON:\n+\t  top--;\n+\t  if (!num_zerop (top->value))\n \t    {\n-\t      if (top->unsignedp)\n-\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n-\t      else\n-\t\t{\n-\t\t  top->value = v1 / v2;\n-\t\t  if ((top->value & v1 & v2) < 0)\n-\t\t    integer_overflow (pfile);\n-\t\t}\n+\t      pfile->state.skip_eval--;\n+\t      top->value = top[1].value;\n \t    }\n \t  else\n-\t    {\n-\t      if (top->unsignedp)\n-\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 % v2;\n-\t      else\n-\t\ttop->value = v1 % v2;\n-\t    }\n+\t    top->value = top[2].value;\n+\t  top->value.unsignedp = (top[1].value.unsignedp\n+\t\t\t\t  || top[2].value.unsignedp);\n \t  break;\n \n-\tcase CPP_OR_OR:\n-\t  top->value = v1 || v2;\n-\t  top->unsignedp = 0;\n-\t  if (v1) pfile->state.skip_eval--;\n-\t  break;\n-\tcase CPP_AND_AND:\n-\t  top->value = v1 && v2;\n-\t  top->unsignedp = 0;\n-\t  if (!v1) pfile->state.skip_eval--;\n-\t  break;\n-\tcase CPP_COMMA:\n-\t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_error (pfile, DL_PEDWARN,\n-\t\t       \"comma operator in operand of #if\");\n-\t  top->value = v2;\n-\t  top->unsignedp = unsigned2;\n-\t  break;\n \tcase CPP_QUERY:\n \t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n \t  return 0;\n-\tcase CPP_COLON:\n-\t  top--;\n-\t  if (top->value) pfile->state.skip_eval--;\n-\t  top->value = top->value ? v1 : v2;\n-\t  top->unsignedp = unsigned1 | unsigned2;\n-\t  break;\n-\tcase CPP_OPEN_PAREN:\n-\t  if (op != CPP_CLOSE_PAREN)\n-\t    {\n-\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n-\t      return 0;\n-\t    }\n-\t  top->value = v2;\n-\t  top->unsignedp = unsigned2;\n-\t  return top;\n+\n+\tdefault:\n+\t  goto bad_op;\n \t}\n+\n+      if (top->value.overflow && !pfile->state.skip_eval)\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"integer overflow in preprocessor expression\");\n     }\n \n   if (op == CPP_CLOSE_PAREN)\n@@ -833,3 +777,545 @@ _cpp_expand_op_stack (pfile)\n \n   return pfile->op_stack + old_size;\n }\n+\n+/* Clears the unused high order bits of the number pointed to by PNUM.  */\n+static cpp_num\n+num_trim (num, precision)\n+     cpp_num num;\n+     size_t precision;\n+{\n+  if (precision > PART_PRECISION)\n+    {\n+      precision -= PART_PRECISION;\n+      if (precision < PART_PRECISION)\n+\tnum.high &= (1 << precision) - 1;\n+    }\n+  else\n+    {\n+      if (precision < PART_PRECISION)\n+\tnum.low &= (1 << precision) - 1;\n+      num.high = 0;\n+    }\n+\n+  return num;\n+}\n+\n+/* True iff A (presumed signed) >= 0.  */\n+static bool\n+num_positive (num, precision)\n+     cpp_num num;\n+     size_t precision;\n+{\n+  if (precision > PART_PRECISION)\n+    {\n+      precision -= PART_PRECISION;\n+      return (num.high & (1 << (precision - 1))) == 0;\n+    }\n+\n+  return (num.low & (1 << (precision - 1))) == 0;\n+}\n+\n+/* Returns the negative of NUM.  */\n+static cpp_num\n+num_negate (num, precision)\n+     cpp_num num;\n+     size_t precision;\n+{\n+  cpp_num copy;\n+\n+  copy = num;\n+  num.high = ~num.high;\n+  num.low = ~num.low;\n+  if (++num.low == 0)\n+    num.high++;\n+  num = num_trim (num, precision);\n+  num.overflow = (!num.unsignedp && num_eq (num, copy) && !num_zerop (num));\n+\n+  return num;\n+}\n+\n+/* Returns true if A >= B.  */\n+static bool\n+num_greater_eq (pa, pb, precision)\n+     cpp_num pa, pb;\n+     size_t precision;\n+{\n+  bool unsignedp;\n+\n+  unsignedp = pa.unsignedp || pb.unsignedp;\n+\n+  if (!unsignedp)\n+    {\n+      /* Both numbers have signed type.  If they are of different\n+       sign, the answer is the sign of A.  */\n+      unsignedp = num_positive (pa, precision);\n+\n+      if (unsignedp != num_positive (pb, precision))\n+\treturn unsignedp;\n+\n+      /* Otherwise we can do an unsigned comparison.  */\n+    }\n+\n+  return (pa.high > pb.high) || (pa.high == pb.high && pa.low >= pb.low);\n+}\n+\n+/* Returns LHS OP RHS, where OP is a bit-wise operation.  */\n+static cpp_num\n+num_bitwise_op (pfile, lhs, rhs, op)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op;\n+{\n+  lhs.overflow = false;\n+  lhs.unsignedp = lhs.unsignedp || rhs.unsignedp;\n+\n+  /* As excess precision is zeroed, there is no need to num_trim () as\n+     these operations cannot introduce a set bit there.  */\n+  if (op == CPP_AND)\n+    {\n+      lhs.low &= rhs.low;\n+      lhs.high &= rhs.high;\n+    }\n+  else if (op == CPP_OR)\n+    {\n+      lhs.low |= rhs.low;\n+      lhs.high |= rhs.high;\n+    }\n+  else\n+    {\n+      lhs.low ^= rhs.low;\n+      lhs.high ^= rhs.high;\n+    }\n+\n+  return lhs;\n+}\n+\n+/* Returns LHS OP RHS, where OP is an inequality.  */\n+static cpp_num\n+num_inequality_op (pfile, lhs, rhs, op)\n+     cpp_reader *pfile;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op;\n+{\n+  bool gte = num_greater_eq (lhs, rhs, CPP_OPTION (pfile, precision));\n+\n+  if (op == CPP_GREATER_EQ)\n+    lhs.low = gte;\n+  else if (op == CPP_LESS)\n+    lhs.low = !gte;\n+  else if (op == CPP_GREATER)\n+    lhs.low = gte && !num_eq (lhs, rhs);\n+  else /* CPP_LESS_EQ.  */\n+    lhs.low = !gte || num_eq (lhs, rhs);\n+\n+  lhs.high = 0;\n+  lhs.overflow = false;\n+  lhs.unsignedp = false;\n+  return lhs;\n+}\n+\n+/* Returns LHS OP RHS, where OP is == or !=.  */\n+static cpp_num\n+num_equality_op (pfile, lhs, rhs, op)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op;\n+{\n+  lhs.low = num_eq (lhs, rhs);\n+  if (op == CPP_NOT_EQ)\n+    lhs.low = !lhs.low;\n+  lhs.high = 0;\n+  lhs.overflow = false;\n+  lhs.unsignedp = false;\n+  return lhs;\n+}\n+\n+/* Shift NUM, of width PRECISION, right by N bits.  */\n+static cpp_num\n+num_rshift (num, precision, n)\n+     cpp_num num;\n+     size_t precision, n;\n+{\n+  cpp_num_part sign_mask;\n+\n+  if (num.unsignedp || num_positive (num, precision))\n+    sign_mask = 0;\n+  else\n+    sign_mask = ~(cpp_num_part) 0;\n+\n+  if (n >= precision)\n+    num.high = num.low = sign_mask;\n+  else\n+    {\n+      /* Sign-extend.  */\n+      if (precision < PART_PRECISION)\n+\tnum.high = sign_mask, num.low |= sign_mask << precision;\n+      else if (precision < 2 * PART_PRECISION)\n+\tnum.high |= sign_mask << (precision - PART_PRECISION);\n+\n+      if (n >= PART_PRECISION)\n+\t{\n+\t  n -= PART_PRECISION;\n+\t  num.low = num.high;\n+\t  num.high = sign_mask;\n+\t}\n+\n+      if (n)\n+\t{\n+\t  num.low = (num.low >> n) | (num.high << (PART_PRECISION - n));\n+\t  num.high = (num.high >> n) | (sign_mask << (PART_PRECISION - n));\n+\t}\n+    }\n+\n+  num = num_trim (num, precision);\n+  num.overflow = false;\n+  return num;\n+}\n+\n+/* Shift NUM, of width PRECISION, left by N bits.  */\n+static cpp_num\n+num_lshift (num, precision, n)\n+     cpp_num num;\n+     size_t precision, n;\n+{\n+  if (n >= precision)\n+    {\n+      num.overflow = !num.unsignedp && !num_zerop (num);\n+      num.high = num.low = 0;\n+    }\n+  else\n+    {\n+      cpp_num orig, maybe_orig;\n+      size_t m = n;\n+\n+      orig = num;\n+      if (m >= PART_PRECISION)\n+\t{\n+\t  m -= PART_PRECISION;\n+\t  num.high = num.low;\n+\t  num.low = 0;\n+\t}\n+      if (m)\n+\t{\n+\t  num.high = (num.high << m) | (num.low >> (PART_PRECISION - m));\n+\t  num.low <<= m;\n+\t}\n+      num = num_trim (num, precision);\n+\n+      if (num.unsignedp)\n+\tnum.overflow = false;\n+      else\n+\t{\n+\t  maybe_orig = num_rshift (num, precision, n);\n+\t  num.overflow = !num_eq (orig, maybe_orig);\n+\t}\n+    }\n+\n+  return num;\n+}\n+\n+/* The four unary operators: +, -, ! and ~.  */\n+static cpp_num\n+num_unary_op (pfile, num, op)\n+     cpp_reader *pfile;\n+     cpp_num num;\n+     enum cpp_ttype op;\n+{\n+  switch (op)\n+    {\n+    case CPP_UPLUS:\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"traditional C rejects the unary plus operator\");\n+      num.overflow = false;\n+      break;\n+\n+    case CPP_UMINUS:\n+      num = num_negate (num, CPP_OPTION (pfile, precision));\n+      break;\n+\n+    case CPP_COMPL:\n+      num.high = ~num.high;\n+      num.low = ~num.low;\n+      num = num_trim (num, CPP_OPTION (pfile, precision));\n+      num.overflow = false;\n+      break;\n+\n+    default: /* case CPP_NOT: */\n+      num.low = num_zerop (num);\n+      num.high = 0;\n+      num.overflow = false;\n+      num.unsignedp = false;\n+      break;\n+    }\n+\n+  return num;\n+}\n+\n+/* The various binary operators.  */\n+static cpp_num\n+num_binary_op (pfile, lhs, rhs, op)\n+     cpp_reader *pfile;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op;\n+{\n+  cpp_num result;\n+  size_t precision = CPP_OPTION (pfile, precision);\n+  bool gte;\n+  size_t n;\n+\n+  switch (op)\n+    {\n+      /* Shifts.  */\n+    case CPP_LSHIFT:\n+    case CPP_RSHIFT:\n+      if (!rhs.unsignedp && !num_positive (rhs, precision))\n+\t{\n+\t  /* A negative shift is a positive shift the other way.  */\n+\t  if (op == CPP_LSHIFT)\n+\t    op = CPP_RSHIFT;\n+\t  else\n+\t    op = CPP_LSHIFT;\n+\t  rhs = num_negate (rhs, precision);\n+\t}\n+      if (rhs.high)\n+\tn = ~0;\t\t\t/* Maximal.  */\n+      else\n+\tn = rhs.low;\n+      if (op == CPP_LSHIFT)\n+\tlhs = num_lshift (lhs, precision, n);\n+      else\n+\tlhs = num_rshift (lhs, precision, n);\n+      break;\n+\n+      /* Min / Max.  */\n+    case CPP_MIN:\n+    case CPP_MAX:\n+      {\n+\tbool unsignedp = lhs.unsignedp || rhs.unsignedp;\n+\n+\tgte = num_greater_eq (lhs, rhs, precision);\n+\tif (op == CPP_MIN)\n+\t  gte = !gte;\n+\tif (!gte)\n+\t  lhs = rhs;\n+\tlhs.unsignedp = unsignedp;\n+      }\n+      break;\n+\n+      /* Arithmetic.  */\n+    case CPP_MINUS:\n+      rhs = num_negate (rhs, precision);\n+    case CPP_PLUS:\n+      result.low = lhs.low + rhs.low;\n+      result.high = lhs.high + rhs.high;\n+      if (result.low < lhs.low)\n+\tresult.high++;\n+\n+      result = num_trim (result, precision);\n+      result.unsignedp = lhs.unsignedp || rhs.unsignedp;\n+      if (result.unsignedp)\n+\tresult.overflow = false;\n+      else\n+\t{\n+\t  bool lhsp = num_positive (lhs, precision);\n+\t  result.overflow = (lhsp == num_positive (rhs, precision)\n+\t\t\t     && lhsp != num_positive (result, precision));\n+\t}\n+      return result;\n+\n+      /* Comma.  */\n+    default: /* case CPP_COMMA: */\n+      if (CPP_PEDANTIC (pfile))\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"comma operator in operand of #if\");\n+      lhs = rhs;\n+      break;\n+    }\n+\n+  return lhs;\n+}\n+\n+/* Multiplies two unsigned cpp_num_parts to give a cpp_num.  This\n+   cannot overflow.  */\n+static cpp_num\n+num_part_mul (lhs, rhs)\n+     cpp_num_part lhs, rhs;\n+{\n+  cpp_num result;\n+  cpp_num_part middle[2], temp;\n+\n+  result.low = LOW_PART (lhs) * LOW_PART (rhs);\n+  result.high = HIGH_PART (lhs) * HIGH_PART (rhs);\n+\n+  middle[0] = LOW_PART (lhs) * HIGH_PART (rhs);\n+  middle[1] = HIGH_PART (lhs) * LOW_PART (rhs);\n+\n+  temp = result.low;\n+  result.low += LOW_PART (middle[0]) << (PART_PRECISION / 2);\n+  if (result.low < temp)\n+    result.high++;\n+\n+  temp = result.low;\n+  result.low += LOW_PART (middle[1]) << (PART_PRECISION / 2);\n+  if (result.low < temp)\n+    result.high++;\n+\n+  result.high += HIGH_PART (middle[0]);\n+  result.high += HIGH_PART (middle[1]);\n+\n+  return result;\n+}\n+\n+/* Multiply two preprocessing numbers.  */\n+static cpp_num\n+num_mul (pfile, lhs, rhs, op)\n+     cpp_reader *pfile;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op ATTRIBUTE_UNUSED;\n+{\n+  cpp_num result, temp;\n+  bool unsignedp = lhs.unsignedp || rhs.unsignedp;\n+  bool overflow, negate = false;\n+  size_t precision = CPP_OPTION (pfile, precision);\n+\n+  /* Prepare for unsigned multiplication.  */\n+  if (!unsignedp)\n+    {\n+      if (!num_positive (lhs, precision))\n+\tnegate = !negate, lhs = num_negate (lhs, precision);\n+      if (!num_positive (rhs, precision))\n+\tnegate = !negate, rhs = num_negate (rhs, precision);\n+    }\n+\n+  overflow = lhs.high && rhs.high;\n+  result = num_part_mul (lhs.low, rhs.low);\n+\n+  temp = num_part_mul (lhs.high, rhs.low);\n+  result.high += temp.low;\n+  if (temp.high)\n+    overflow = true;\n+\n+  temp = num_part_mul (lhs.low, rhs.high);\n+  result.high += temp.low;\n+  if (temp.high)\n+    overflow = true;\n+\n+  temp.low = result.low, temp.high = result.high;\n+  result = num_trim (result, precision);\n+  if (!num_eq (result, temp))\n+    overflow = true;\n+\n+  if (negate)\n+    result = num_negate (result, precision);\n+\n+  if (unsignedp)\n+    result.overflow = false;\n+  else\n+    result.overflow = overflow || (num_positive (result, precision) ^ !negate\n+\t\t\t\t   && !num_zerop (result));\n+  result.unsignedp = unsignedp;\n+\n+  return result;\n+}\n+\n+/* Divide two preprocessing numbers, returning the answer or the\n+   remainder depending upon OP.  */\n+static cpp_num\n+num_div_op (pfile, lhs, rhs, op)\n+     cpp_reader *pfile;\n+     cpp_num lhs, rhs;\n+     enum cpp_ttype op;\n+{\n+  cpp_num result, sub;\n+  cpp_num_part mask;\n+  bool unsignedp = lhs.unsignedp || rhs.unsignedp;\n+  bool negate = false, lhs_neg = false;\n+  size_t i, precision = CPP_OPTION (pfile, precision);\n+\n+  /* Prepare for unsigned division.  */\n+  if (!unsignedp)\n+    {\n+      if (!num_positive (lhs, precision))\n+\tnegate = !negate, lhs_neg = true, lhs = num_negate (lhs, precision);\n+      if (!num_positive (rhs, precision))\n+\tnegate = !negate, rhs = num_negate (rhs, precision);\n+    }\n+\n+  /* Find the high bit.  */\n+  if (rhs.high)\n+    {\n+      i = precision - 1;\n+      mask = 1 << (i - PART_PRECISION);\n+      for (; ; i--, mask >>= 1)\n+\tif (rhs.high & mask)\n+\t  break;\n+    }\n+  else if (rhs.low)\n+    {\n+      if (precision > PART_PRECISION)\n+\ti = precision - PART_PRECISION - 1;\n+      else\n+\ti = precision - 1;\n+      mask = 1 << i;\n+      for (; ; i--, mask >>= 1)\n+\tif (rhs.low & mask)\n+\t  break;\n+    }\n+  else\n+    {\n+      cpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n+      return lhs;\n+    }\n+\n+  /* First non-zero bit of RHS is bit I.  Do naive division by\n+     shifting the RHS fully left, and subtracting from LHS if LHS is\n+     at least as big, and then repeating but with one less shift.\n+     This is not very efficient, but is easy to understand.  */\n+\n+  rhs.unsignedp = true;\n+  lhs.unsignedp = true;\n+  i = precision - i - 1;\n+  sub = num_lshift (rhs, precision, i);\n+\n+  result.high = result.low = 0;\n+  for (;;)\n+    {\n+      if (num_greater_eq (lhs, sub, precision))\n+\t{\n+\t  lhs = num_binary_op (pfile, lhs, sub, CPP_MINUS);\n+\t  if (i >= PART_PRECISION)\n+\t    result.high |= 1 << (i - PART_PRECISION);\n+\t  else\n+\t    result.low |= 1 << i;\n+\t}\n+      if (i-- == 0)\n+\tbreak;\n+      sub.low = (sub.low >> 1) | (sub.high << (PART_PRECISION - 1));\n+      sub.high >>= 1;\n+    }\n+\n+  /* We divide so that the remainder has the sign of the LHS.  */\n+  if (op == CPP_DIV)\n+    {\n+      result.unsignedp = unsignedp;\n+      if (unsignedp)\n+\tresult.overflow = false;\n+      else\n+\t{\n+\t  if (negate)\n+\t    result = num_negate (result, precision);\n+\t  result.overflow = num_positive (result, precision) ^ !negate;\n+\t}\n+\n+      return result;\n+    }\n+\n+  /* CPP_MOD.  */\n+  lhs.unsignedp = unsignedp;\n+  lhs.overflow = false;\n+  if (lhs_neg)\n+    lhs = num_negate (lhs, precision);\n+\n+  return lhs;\n+}"}, {"sha": "e819ffca4d0920f96fadc2f1e2a13216f09c6f32", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -1652,6 +1652,8 @@ _cpp_test_assertion (pfile, value)\n   if (node)\n     *value = (node->type == NT_ASSERTION &&\n \t      (answer == 0 || *find_answer (node, answer) != 0));\n+  else if (pfile->cur_token[-1].type == CPP_EOF)\n+    _cpp_backup_tokens (pfile, 1);\n \n   /* We don't commit the memory for the answer - it's temporary only.  */\n   return node == 0;"}, {"sha": "51e46fb12f029bc09a6af2ff860849fa9c504792", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -1,3 +1,8 @@\n+2002-05-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/arith-1.c: New semantic tests.\n+\t* gcc.dg/cpp/if-1.c: Update.\n+\n 2002-05-24  Ben Elliston  <bje@redhat.com>\n \n \t* lib/c-torture.exp (c-torture-execute): Handle multiple sources."}, {"sha": "85d5848d8008b5909687ef502da96987bac811cc", "filename": "gcc/testsuite/gcc.dg/cpp/arith-1.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Farith-1.c?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -0,0 +1,257 @@\n+/* Preprocessor arithmetic semantic tests.  */\n+\n+/* Copyright (C) 2002 Free Software Foundation, Inc.  */\n+/* Source: Neil Booth, 25 May 2002.  */\n+\n+/* The file tests all aspects of preprocessor arithmetic that are\n+   independent of target precision.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options -fno-show-column } */\n+\n+/* Test || operator and its short circuiting.  */\n+#if 0 || 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 5 || 0\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 || 1\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 || 4\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 || (8 / 0) /* { dg-bogus \"division by zero\" }  */\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 || (1 << 256) /* { dg-bogus \"overflow\" }  */\n+#endif\n+\n+/* Test && operator and its short circuiting.  */\n+#if (0 && 0) || (0 && 1) || (1 && 0)\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 && 2\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 && (8 / 0)/* { dg-bogus \"division by zero\" }  */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 && (1 << 256) /* { dg-bogus \"overflow\" }  */\n+#endif\n+\n+/* Test == and != operators, and their signedness.  */\n+#if 1 == 0 || 0 == 1 || 20 != 0x014 || 142 != 0216\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (1 == 1) - 2 > 0 || (1U != 1U) - 2 > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test ? : operator, its short circuiting, and its signedness.  */\n+#if (1 ? 3: 5) != 3 || (0 ? 3: 5) != 5\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 ? 0: 1 / 0 /* { dg-bogus \"division by zero\" }  */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 ? 1 / 0: 0 /* { dg-bogus \"division by zero\" }  */\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0 ? (1 << 256): 0 /* { dg-bogus \"overflow\" }  */\n+#endif\n+\n+#if 1 ? 0: (1 << 256) /* { dg-bogus \"overflow\" }  */\n+#endif\n+\n+/* Test unary + and its signedness.  */\n+\n+#if 23 != +23 || 23 != + +23\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (+1 - 2) > 0 || (+1U - 2) < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test unary - and its signedness.  */\n+\n+#if -1 + 1 != 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if -1 >= 0 || -1U <= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test unary ! and its signedness.  */\n+#if !5 != 0 || !1 != 0 || !0 != 1\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if !5 - 1 > 0 || !5U - 1 > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test unary ~ and its signedness.  */\n+#if ~0 != -1 || ~~5 != 5 || ~-2 != 1\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ~5 > 0 || ~5U < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test comparison operators and their signedness.  */\n+#if 1 >= 1 && 2 >= 1 && -1 >= -1 && -1 >= -2 && 1 >= -1 && 1 >= -2 \\\n+    && !(-2 >= -1) && !(2 >= 3) && -1U >= 2 && !(-1 >= 1)\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ((1 > 0) - 2) > 0 || ((1U > 0) - 2) > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if !(1 > 1) && 2 > 1 && !(-1 > -1) && -1 > -2 && 1 > -1 && 1 > -2 \\\n+    && !(-2 > -1) && !(2 > 3) && -1U > 2 && !(-1 > 1)\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ((1 >= 0) - 2) > 0 || ((1U >= 0) - 2) > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 1 <= 1 && !(2 <= 1) && -1 <= -1 && !(-1 <= -2) && !(1 <= -1) && !(1 <= -2) \\\n+    && -2 <= -1 && 2 <= 3 && !(-1U <= 2) && -1 <= 1\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ((1 <= 0) - 2) > 0 || ((1U <= 0) - 2) > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if !(1 < 1) && !(2 < 1) && !(-1 < -1) && !(-1 < -2) && !(1 < -1) && !(1 < -2) \\\n+    && -2 < -1 && 2 < 3 && !(-1U < 2) && -1 < 1\n+#else\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if ((1 < 0) - 2) > 0 || ((1U < 0) - 2) > 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test bitwise operators and their signedness.  */\n+#if (3 & 7) != 3 || (-1 & 34) != 34\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 & 7) - 20 > 0 || (3 & 7U) - 20 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 | 5) != 7 || (-1 | 34) != -1\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 | 7) - 20 > 0 || (3 | 7U) - 20 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (7 ^ 5) != 2 || (-1 ^ 34) != ~34\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 ^ 7) - 20 > 0 || (3 ^ 7U) - 20 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test shifts and their signedness.  */\n+#if 3 << 2 != 12 || 3 << -2 != 0 || -1 << 1 != -2\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 5 >> 1 != 2 || 5 >> -2 != 20 || -5 >> 1 != -3\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (5 >> 2) - 2 >= 0 || (5U >> 2) - 2 <= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (5 << 1) - 20 >= 0 || (5U << 1) - 20 <= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 0\n+/* Test min / max and their signedness.  */\n+#if (3 >? 2) != 3 || (-3 >? -2) != -2\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 <? 2) != 2 || (-3 <? -2) != -3\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 >? 2) - 4 >= 0 || (3 >? 2U) - 4 <= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (3 <? 2) - 4 >= 0 || (3 <? 2U) - 4 <= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+#endif\n+\n+/* Test *, / and % and their signedness.  */\n+#if 3 * 2 != 6 || 3 * -2 != -6 || -2 * 3 != -6 || -2 * -3 != 6\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 3 * 2 - 7 >= 0 || 3 * 2U - 7 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 5 / 2 != 2 || -325 / 50 != -6 || 53 / -4 != -13 || -55 / -12 != 4\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 3 / 2 - 7 >= 0 || 3 / 2U - 7 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 5 % 2 != 1 || -325 % 50 != -25 || 53 % -4 != 1 || -55 % -12 != -7\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if 3 % 2 - 7 >= 0 || 3U % 2 - 7 < 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+/* Test , and its signedness.  */\n+#if (1, 2) != 2 || (2, 1) != 1\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif\n+\n+#if (1, 2) - 3 >= 0 || (1, 2U) - 3 <= 0 || (1U, 2) - 3 >= 0\n+# error\t\t/* { dg-bogus \"error\" }  */\n+#endif"}, {"sha": "c08fd2393d7b5bd964e40c7145e1118a2af16f44", "filename": "gcc/testsuite/gcc.dg/cpp/if-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c?ref=913189081f3bc7eebcf6bd13b9e344ba9cd2f9a3", "patch": "@@ -37,5 +37,5 @@\n #if 099 /* { dg-error \"digits beyond the radix\" \"decimal in octal constant\" } */\n #endif\n \n-#if 0xfffffffffffffffff /* { dg-error \"integer constant out of range\" \"range error\" } */\n+#if 0xfffffffffffffffff /* { dg-error \"integer constant\" \"range error\" } */\n #endif"}]}