{"sha": "ae2eceaad2f95f7228e69ab5513f355e868ab787", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUyZWNlYWFkMmY5NWY3MjI4ZTY5YWI1NTEzZjM1NWU4NjhhYjc4Nw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-10-27T23:50:15Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-10-27T23:50:15Z"}, "message": "* cpp.texi: Update.\n\nFrom-SVN: r37094", "tree": {"sha": "3cd78f7e5e215f575359c58525b2b8ef4648fcb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cd78f7e5e215f575359c58525b2b8ef4648fcb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae2eceaad2f95f7228e69ab5513f355e868ab787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2eceaad2f95f7228e69ab5513f355e868ab787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae2eceaad2f95f7228e69ab5513f355e868ab787", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2eceaad2f95f7228e69ab5513f355e868ab787/comments", "author": null, "committer": null, "parents": [{"sha": "04e149abb6906c8c5c5a327a7d1254574c022a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e149abb6906c8c5c5a327a7d1254574c022a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04e149abb6906c8c5c5a327a7d1254574c022a1d"}], "stats": {"total": 65, "additions": 44, "deletions": 21}, "files": [{"sha": "d23a4e2cf26b96970c8a7e13ef8913cc1775d867", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2eceaad2f95f7228e69ab5513f355e868ab787/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2eceaad2f95f7228e69ab5513f355e868ab787/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae2eceaad2f95f7228e69ab5513f355e868ab787", "patch": "@@ -1,3 +1,7 @@\n+2000-10-27  Neil Booth  <neilb@earthling.net>\n+\n+\t* cpp.texi: Update.\n+\n 2000-10-27  Kelley Cook <kelley.cook@home.com>\n \n \t* invoke.texi: Document -mintel-syntax"}, {"sha": "ffbd323ebad7c8f4a6890ba86b916add3201975f", "filename": "gcc/cpp.texi", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2eceaad2f95f7228e69ab5513f355e868ab787/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2eceaad2f95f7228e69ab5513f355e868ab787/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=ae2eceaad2f95f7228e69ab5513f355e868ab787", "patch": "@@ -2379,13 +2379,14 @@ understand @code{sizeof}, or typedef names, or even the type keywords\n such as @code{int}.)\n \n @findex defined\n-The special operator @samp{defined} is used in @samp{#if} expressions to\n-test whether a certain name is defined as a macro.  Either @samp{defined\n-@var{name}} or @samp{defined (@var{name})} is an expression whose value\n-is 1 if @var{name} is defined as macro at the current point in the\n-program, and 0 otherwise.  For the @samp{defined} operator it makes no\n-difference what the definition of the macro is; all that matters is\n-whether there is a definition.  Thus, for example,@refill\n+The special operator @samp{defined} is used in @samp{#if} and\n+@samp{#elif} expressions to test whether a certain name is defined as a\n+macro.  Either @samp{defined @var{name}} or @samp{defined (@var{name})}\n+is an expression whose value is 1 if @var{name} is defined as macro at\n+the current point in the program, and 0 otherwise.  To the\n+@samp{defined} operator it makes no difference what the definition of\n+the macro is; all that matters is whether there is a definition.  Thus,\n+for example,@refill\n \n @example\n #if defined (vax) || defined (ns16000)\n@@ -2405,6 +2406,12 @@ use of the @samp{defined} operator returns 0, because the name is no\n longer defined.  If the macro is defined again with another\n @samp{#define}, @samp{defined} will recommence returning 1.\n \n+If the @samp{defined} operator appears as a result of a macro expansion,\n+the C standard says the behavior is undefined.  GNU cpp treats it as a\n+genuine @samp{defined} operator and evaluates it normally.  It will warn\n+wherever your code uses this feature if you use the command-line option\n+@samp{-pedantic}, since other compilers may handle it differently.\n+\n @findex #ifdef\n @findex #ifndef\n Conditionals that test whether a single macro is defined are very common,\n@@ -2793,29 +2800,31 @@ This indicates that the following text should be treated as C@.\n @end table\n \n @node Implementation, Unreliable Features, Output, Top\n-@section Implementation-defined Behavior and Implemenation Limits\n+@section Implementation-defined Behavior and Implementation Limits\n @cindex implementation limits\n @cindex implementation-defined behavior\n \n The ISO C standard mandates that implementations document various\n aspects of preprocessor behavior.  You should try to avoid undue\n-reliance on behaviour described here, as it is probable that it will\n+reliance on behaviour described here, as it is possible that it will\n change subtly in future implementations.\n \n @itemize @bullet\n \n-@item The mapping of physical source file multibyte characters to the execution\n-character set.\n+@item The mapping of physical source file multi-byte characters to the\n+execution character set.\n \n-Currenty, GNU cpp only supports character sets that are strict supersets\n+Currently, GNU cpp only supports character sets that are strict supersets\n of ASCII, and performs no translation of characters.\n \n @item Non-empty sequences of whitespace characters.\n \n Each whitespace sequence is not preserved, but collapsed to a single\n-space.\n+space.  For aesthetic reasons, the first token on each non-directive\n+line of output is preceded with sufficient spaces that it appears in the\n+same column as it did in the original source file.\n \n-@item The numeric value of characeter constants in preprocessor expressions.\n+@item The numeric value of character constants in preprocessor expressions.\n \n The preprocessor interprets character constants in preprocessing\n directives on the host machine.  Expressions outside preprocessing\n@@ -2824,6 +2833,16 @@ normal case of a native compiler, these two environments are the same\n and so character constants will be evaluated identically in both cases.\n However, in the case of a cross compiler, the values may be different.\n \n+Multi-character character constants are interpreted a character at a\n+time, shifting the previous result left by the number of bits per\n+character on the host, and adding the new character.  For example, 'ab'\n+on an 8-bit host would be interpreted as 'a' * 256 + 'b'.  If there are\n+more characters in the constant than can fit in the widest native\n+integer type on the host, usually a @samp{long}, the behavior is\n+undefined.\n+\n+Evaluation of wide character constants is not properly implemented yet.\n+\n @item Source file inclusion.\n \n For a discussion on how the preprocessor locates header files,\n@@ -2858,17 +2877,17 @@ The following documents internal limits of GNU cpp.\n @item Nesting levels of @samp{#include} files.\n \n We impose an arbitrary limit of 200 levels, to avoid runaway recursion.\n-The standard requires at least 15 levels be permitted.\n+The standard requires at least 15 levels.\n \n @item Nesting levels of conditional inclusion.\n \n The C standard mandates this be at least 63.  The GNU C preprocessor\n is limited only by available memory.\n \n-@item Levels of paranthesised expressions within a full expression.\n+@item Levels of parenthesised expressions within a full expression.\n \n The C standard requires this to be at least 63.  In preprocessor\n-conditional expresssions it is limited only by available memory.\n+conditional expressions it is limited only by available memory.\n \n @item Significant initial characters in an identifier or macro name.\n \n@@ -2880,7 +2899,7 @@ requires only that the first 63 be significant.\n The standard requires at least 4095 be possible; GNU cpp is limited only\n by available memory.\n \n-@item Number of paramters in a macro definition and arguments in a macro call.\n+@item Number of parameters in a macro definition and arguments in a macro call.\n \n We allow USHRT_MAX, which is normally 65,535, and above the minimum of\n 127 required by the standard.\n@@ -2956,7 +2975,7 @@ Formerly, in a macro expansion, if @samp{##} appeared before a variable\n arguments parameter, and the set of tokens specified for that argument in\n the macro invocation was empty, previous versions of the GNU C\n preprocessor would back up and remove the preceding sequence of\n-nonwhitespace characters (@strong{not} the preceding token).  This\n+non-whitespace characters (@strong{not} the preceding token).  This\n extension is in direct conflict with the 1999 C standard and has been\n drastically pared back.\n \n@@ -2995,7 +3014,7 @@ used at all.\n \n @item #pragma poison\n \n-This pragma has been superceded by @samp{#pragma GCC poison}.\n+This pragma has been superseded by @samp{#pragma GCC poison}.\n @xref{Poisoning}.\n \n @item Multi-line string literals in directives\n@@ -3531,7 +3550,7 @@ The 1999 C standard plus GNU extensions.\n \n @item -ftabstop=NUMBER\n @findex -ftabstop\n-Set the distance between tabstops.  This helps the preprocessor\n+Set the distance between tab stops.  This helps the preprocessor\n report correct column numbers in warnings or errors, even if tabs appear\n on the line.  Values less than 1 or greater than 100 are ignored.  The\n default is 8."}]}