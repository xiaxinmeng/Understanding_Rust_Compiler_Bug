{"sha": "7849b3de894a9e76cff084f4cd58c28c722b8713", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg0OWIzZGU4OTRhOWU3NmNmZjA4NGY0Y2Q1OGMyOGM3MjJiODcxMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-08-25T16:02:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-08-25T16:02:23Z"}, "message": "random (bernoulli_distribution::operator()): Fix wrt generators returning integers.\n\n2006-08-25  Paolo Carlini  <pcarlini@suse.de>\n\n        * include/tr1/random (bernoulli_distribution::operator()): Fix\n        wrt generators returning integers.\n\t(uniform_int<>::_M_call): Add.\n\t(uniform_int<>::operator()): Use it.\n\n\t* include/tr1/random (_Adaptor<>::min, _Adaptor<>::max): Add.\n\t(_Adaptor<>::operator()): Allow for nonzero _M_g.min().\n\n\t* include/tr1/random.tcc (linear_congruential<>::min, max):\n\tMove inline...\n\t(__mod): Move ...\n\t* include/tr1/random: ... here.\n\t(struct _Mod): Declare.\n\n\t* include/tr1/random (struct _To_Unsigned_Type): Only declare,\n\tmove...\n\t* include/tr1/random.tcc: ... here.\n\nFrom-SVN: r116402", "tree": {"sha": "2706929ee99b7642eb8d567ba87f98f03c731103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2706929ee99b7642eb8d567ba87f98f03c731103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7849b3de894a9e76cff084f4cd58c28c722b8713", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7849b3de894a9e76cff084f4cd58c28c722b8713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7849b3de894a9e76cff084f4cd58c28c722b8713", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7849b3de894a9e76cff084f4cd58c28c722b8713/comments", "author": null, "committer": null, "parents": [{"sha": "4eb585a4731413faa3ed0f224674ff31c7ab7a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb585a4731413faa3ed0f224674ff31c7ab7a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb585a4731413faa3ed0f224674ff31c7ab7a76"}], "stats": {"total": 182, "additions": 118, "deletions": 64}, "files": [{"sha": "5dfa9f10e155cb8ff2897a8f0992148e140009ed", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7849b3de894a9e76cff084f4cd58c28c722b8713", "patch": "@@ -1,3 +1,23 @@\n+2006-08-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/random (bernoulli_distribution::operator()): Fix\n+        wrt generators returning integers.\n+\t(uniform_int<>::_M_call): Add.\n+\t(uniform_int<>::operator()): Use it.\n+\n+\t* include/tr1/random (_Adaptor<>::min, _Adaptor<>::max): Add.\n+\t(_Adaptor<>::operator()): Allow for nonzero _M_g.min().\n+\n+\t* include/tr1/random.tcc (linear_congruential<>::min, max):\n+\tMove inline...\n+\t(__mod): Move ...\n+\t* include/tr1/random: ... here.\n+\t(struct _Mod): Declare.\n+\n+\t* include/tr1/random (struct _To_Unsigned_Type): Only declare,\n+\tmove...\n+\t* include/tr1/random.tcc: ... here.\n+\n 2006-08-22  Phillip Jordan  <phillip.m.jordan@gmail.com>\n \n \t*include/tr1/boost_shared_ptr.h: Added locking policy to"}, {"sha": "b90d3239da26edc5695379d7a9cf9cd4a9778280", "filename": "libstdc++-v3/include/tr1/random", "status": "modified", "additions": 77, "deletions": 33, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom?ref=7849b3de894a9e76cff084f4cd58c28c722b8713", "patch": "@@ -67,15 +67,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     // Type selectors -- are these already implemented elsewhere?\n     template<bool, typename _TpTrue, typename _TpFalse>\n       struct _Select\n-      {\n-\ttypedef _TpTrue _Type;\n-      };\n+      { typedef _TpTrue _Type; };\n \n     template<typename _TpTrue, typename _TpFalse>\n       struct _Select<false, _TpTrue, _TpFalse>\n-      {\n-\ttypedef _TpFalse _Type;\n-      };\n+      { typedef _TpFalse _Type; };\n \n     template<typename _UIntType, int __w, bool = \n \t     __w < std::numeric_limits<_UIntType>::digits>\n@@ -86,27 +82,18 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       struct _Shift<_UIntType, __w, true>\n       { static const _UIntType __value = _UIntType(1) << __w; };\n \n-    template<typename _ValueT>\n-      struct _To_Unsigned_Type\n-      { typedef _ValueT _Type; };\n-\n-    template<>\n-      struct _To_Unsigned_Type<short>\n-      { typedef unsigned short _Type; };\n+    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m, bool>\n+      struct _Mod;\n \n-    template<>\n-      struct _To_Unsigned_Type<int>\n-      { typedef unsigned int _Type; };\n+    // Dispatch based on modulus value to prevent divide-by-zero compile-time\n+    // errors when m == 0.\n+    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m>\n+      inline _Tp\n+      __mod(_Tp __x)\n+      { return _Mod<_Tp, __a, __c, __m, __m == 0>::__calc(__x); }\n \n-    template<>\n-      struct _To_Unsigned_Type<long>\n-      { typedef unsigned long _Type; };\n-\n-#ifdef _GLIBCXX_USE_LONG_LONG\n-    template<>\n-      struct _To_Unsigned_Type<long long>\n-      { typedef unsigned long long _Type; };\n-#endif\n+    template<typename _ValueT>\n+      struct _To_Unsigned_Type;\n \n     typedef _Select<(sizeof(unsigned) == 4),\n \t\t    unsigned, unsigned long>::_Type _UInt32Type;\n@@ -126,6 +113,30 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t_Adaptor(const _Engine& __g)\n \t: _M_g(__g) { }\n \n+\tresult_type\n+\tmin() const\n+\t{\n+\t  result_type __return_value = 0;\n+\t  if (is_integral<_Engine_result_type>::value\n+\t      && is_integral<result_type>::value)\n+\t    __return_value = _M_g.min();\n+\t  else if (!is_integral<result_type>::value)\n+\t    __return_value = result_type(0);\n+\t  return __return_value;\n+\t}\n+\n+\tresult_type\n+\tmax() const\n+\t{\n+\t  result_type __return_value = 0;\n+\t  if (is_integral<_Engine_result_type>::value\n+\t      && is_integral<result_type>::value)\n+\t    __return_value = _M_g.max();\n+\t  else if (!is_integral<result_type>::value)\n+\t    __return_value = result_type(1);\n+\t  return __return_value;\n+\t}\n+\n \tresult_type\n \toperator()();\n \n@@ -151,11 +162,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  __return_value = _M_g();\n       \telse if (is_integral<_Engine_result_type>::value\n \t\t && !is_integral<result_type>::value)\n-\t  __return_value = result_type(_M_g())\n+\t  __return_value = result_type(_M_g() - _M_g.min())\n \t    / result_type(_M_g.max() - _M_g.min() + result_type(1));\n \telse if (!is_integral<_Engine_result_type>::value\n \t\t && !is_integral<result_type>::value)\n-\t  __return_value = result_type(_M_g())\n+\t  __return_value = result_type(_M_g() - _M_g.min())\n \t    / result_type(_M_g.max() - _M_g.min());\n       \treturn __return_value;\n       }\n@@ -177,7 +188,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     public:\n       typedef _Engine                                engine_type;\n-      typedef _Adaptor<_Engine, _Dist>     engine_value_type;\n+      typedef _Adaptor<_Engine, _Dist>               engine_value_type;\n       typedef _Dist                                  distribution_type;\n       typedef typename _Dist::result_type            result_type;\n \n@@ -372,15 +383,20 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Gets the smallest possible value in the output range.\n+       *\n+       * The minumum depends on the @p __c parameter: if it is zero, the\n+       * minimum generated must be > 0, otherwise 0 is allowed.\n        */\n       result_type\n-      min() const;\n+      min() const\n+      { return (__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n \n       /**\n        * Gets the largest possible value in the output range.\n        */\n       result_type\n-      max() const;\n+      max() const\n+      { return __m - 1; }\n \n       /**\n        * Gets the next random number in the sequence.\n@@ -1391,6 +1407,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       base2() const\n       { return _M_b2; }\n \n+      // FIXME: Cannot be always correct.  FWIW, the solution in N2032\n+      // in practice isn't much better..\n       result_type\n       min() const\n       { return _M_b1.min() ^ _M_b2.min(); }\n@@ -1651,7 +1669,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       template<typename _UniformRandomNumberGenerator>\n         result_type\n         operator()(_UniformRandomNumberGenerator& __urng)\n-        { return (__urng() % (_M_max - _M_min + 1)) + _M_min; }\n+        {\n+\t  typedef typename _UniformRandomNumberGenerator::result_type\n+\t    _UResult_type;\n+\t  return _M_call(__urng, _M_min, _M_max,\n+\t\t\t typename is_integral<_UResult_type>::type());\n+\t}\n \n       /**\n        * Gets a uniform random number in the range @f$[0, n)@f$.\n@@ -1661,7 +1684,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       template<typename _UniformRandomNumberGenerator>\n         result_type\n         operator()(_UniformRandomNumberGenerator& __urng, result_type __n)\n-        { return __urng() % __n; }\n+        {\n+\t  typedef typename _UniformRandomNumberGenerator::result_type\n+\t    _UResult_type;\n+\t  return _M_call(__urng, 0, __n - 1,\n+\t\t\t typename is_integral<_UResult_type>::type());\n+\t}\n \n       /**\n        * Inserts a %uniform_int random number distribution @p __x into the\n@@ -1693,6 +1721,22 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t   uniform_int<_IntType1>& __x);\n \n     private:\n+      template<typename _UniformRandomNumberGenerator>\n+        result_type\n+        _M_call(_UniformRandomNumberGenerator& __urng,\n+\t\tresult_type __min, result_type __max, true_type)\n+        { return result_type(__urng() % (__max - __min + 1)) + __min; }\n+\n+      template<typename _UniformRandomNumberGenerator>\n+        result_type\n+        _M_call(_UniformRandomNumberGenerator& __urng,\n+\t\tresult_type __min, result_type __max, false_type)\n+        {\n+\t  return result_type((__urng() - __urng.min())\n+\t\t\t     / (__urng.max() - __urng.min())\n+\t\t\t     * (__max - __min + 1)) + __min;\n+\t}\n+\n       _IntType _M_min;\n       _IntType _M_max;\n     };\n@@ -1753,7 +1797,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       result_type\n       operator()(_UniformRandomNumberGenerator& __urng)\n       {\n-\tif (__urng() < _M_p)\n+\tif ((__urng() - __urng.min()) < _M_p * (__urng.max() - __urng.min()))\n \t  return true;\n \treturn false;\n       }"}, {"sha": "b95a5f8d3f51549ab63b39f3b7d2bc82e3fe6a7f", "filename": "libstdc++-v3/include/tr1/random.tcc", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7849b3de894a9e76cff084f4cd58c28c722b8713/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc?ref=7849b3de894a9e76cff084f4cd58c28c722b8713", "patch": "@@ -87,12 +87,27 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t{ return __a * __x + __c; }\n       };\n \n-    // Dispatch based on modulus value to prevent divide-by-zero compile-time\n-    // errors when m == 0.\n-    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m>\n-      inline _Tp\n-      __mod(_Tp __x)\n-      { return _Mod<_Tp, __a, __c, __m, __m == 0>::__calc(__x); }\n+    template<typename _ValueT>\n+      struct _To_Unsigned_Type\n+      { typedef _ValueT _Type; };\n+\n+    template<>\n+      struct _To_Unsigned_Type<short>\n+      { typedef unsigned short _Type; };\n+\n+    template<>\n+      struct _To_Unsigned_Type<int>\n+      { typedef unsigned int _Type; };\n+\n+    template<>\n+      struct _To_Unsigned_Type<long>\n+      { typedef unsigned long _Type; };\n+\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+    template<>\n+      struct _To_Unsigned_Type<long long>\n+      { typedef unsigned long long _Type; };\n+#endif\n \n     // See N1822.\n     template<typename _RealType>\n@@ -137,31 +152,6 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  _M_x = __mod<_UIntType, 1, 0, __m>(__x0);\n       }\n \n-  /**\n-   * Returns a value that is less than or equal to all values potentially\n-   * returned by operator(). The return value of this function does not\n-   * change during the lifetime of the object..\n-   *\n-   * The minumum depends on the @p __c parameter: if it is zero, the\n-   * minimum generated must be > 0, otherwise 0 is allowed.\n-   */\n-  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n-    linear_congruential<_UIntType, __a, __c, __m>::\n-    min() const\n-    { return (__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n-\n-  /**\n-   * Gets the maximum possible value of the generated range.\n-   *\n-   * For a linear congruential generator, the maximum is always @p __m - 1.\n-   */\n-  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n-    typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n-    linear_congruential<_UIntType, __a, __c, __m>::\n-    max() const\n-    { return (__m == 0) ? std::numeric_limits<_UIntType>::max() : (__m - 1); }\n-\n   /**\n    * Gets the next generated value in sequence.\n    */"}]}