{"sha": "bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5MTBkY2Y3YTNkOGI3MWM0MzA1YzkxYzIyZTJlNDgzMTU1NGRjZg==", "commit": {"author": {"name": "Charles M. Hannum", "email": "root@ihack.net", "date": "1999-03-26T22:23:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-26T22:23:02Z"}, "message": "fold-const.c (fold_truthop): Build a type for both the lhs and rhs and use it appropriately.\n\n        * fold-const.c (fold_truthop): Build a type for both the lhs and\n        rhs and use it appropriately.\n\nFrom-SVN: r26005", "tree": {"sha": "9f6d374a80a1a14914d864d6317d257481a501d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f6d374a80a1a14914d864d6317d257481a501d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf/comments", "author": {"login": "mycroftxxx", "id": 1772872, "node_id": "MDQ6VXNlcjE3NzI4NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1772872?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mycroftxxx", "html_url": "https://github.com/mycroftxxx", "followers_url": "https://api.github.com/users/mycroftxxx/followers", "following_url": "https://api.github.com/users/mycroftxxx/following{/other_user}", "gists_url": "https://api.github.com/users/mycroftxxx/gists{/gist_id}", "starred_url": "https://api.github.com/users/mycroftxxx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mycroftxxx/subscriptions", "organizations_url": "https://api.github.com/users/mycroftxxx/orgs", "repos_url": "https://api.github.com/users/mycroftxxx/repos", "events_url": "https://api.github.com/users/mycroftxxx/events{/privacy}", "received_events_url": "https://api.github.com/users/mycroftxxx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97ea717682ff2c82773a482c9dc9d467810c03ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97ea717682ff2c82773a482c9dc9d467810c03ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97ea717682ff2c82773a482c9dc9d467810c03ef"}], "stats": {"total": 77, "additions": 52, "deletions": 25}, "files": [{"sha": "8822a94d096420d50270358a889e3f4681546c41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "patch": "@@ -65,6 +65,9 @@ Fri Mar 26 10:43:47 1999  Nick Clifton  <nickc@cygnus.com>\n \n Fri Mar 26 01:59:15 1999  \"Charles M. Hannum\" <root@ihack.net>\n \n+\t* fold-const.c (fold_truthop): Build a type for both the lhs and\n+\trhs and use it appropriately.\n+\n \t* fold-const.c (fold_truthop): Mask the lhs and rhs after merging\n \tadjacent bitfield references. \n "}, {"sha": "d96aa3c8279b62920e6a59c8b0c4d899198b4b69", "filename": "gcc/fold-const.c", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd910dcf7a3d8b71c4305c91c22e2e4831554dcf/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=bd910dcf7a3d8b71c4305c91c22e2e4831554dcf", "patch": "@@ -3710,7 +3710,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n   tree ll_mask, lr_mask, rl_mask, rr_mask;\n   tree ll_and_mask, lr_and_mask, rl_and_mask, rr_and_mask;\n   tree l_const, r_const;\n-  tree type, result;\n+  tree lntype, rntype, result;\n   int first_bit, end_bit;\n   int volatilep;\n \n@@ -3848,7 +3848,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \n   lnbitsize = GET_MODE_BITSIZE (lnmode);\n   lnbitpos = first_bit & ~ (lnbitsize - 1);\n-  type = type_for_size (lnbitsize, 1);\n+  lntype = type_for_size (lnbitsize, 1);\n   xll_bitpos = ll_bitpos - lnbitpos, xrl_bitpos = rl_bitpos - lnbitpos;\n \n   if (BYTES_BIG_ENDIAN)\n@@ -3857,19 +3857,19 @@ fold_truthop (code, truth_type, lhs, rhs)\n       xrl_bitpos = lnbitsize - xrl_bitpos - rl_bitsize;\n     }\n \n-  ll_mask = const_binop (LSHIFT_EXPR, convert (type, ll_mask),\n+  ll_mask = const_binop (LSHIFT_EXPR, convert (lntype, ll_mask),\n \t\t\t size_int (xll_bitpos), 0);\n-  rl_mask = const_binop (LSHIFT_EXPR, convert (type, rl_mask),\n+  rl_mask = const_binop (LSHIFT_EXPR, convert (lntype, rl_mask),\n \t\t\t size_int (xrl_bitpos), 0);\n \n   if (l_const)\n     {\n-      l_const = convert (type, l_const);\n+      l_const = convert (lntype, l_const);\n       l_const = unextend (l_const,  ll_bitsize, ll_unsignedp, ll_and_mask);\n       l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n \t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t\t\t      type, ll_mask)),\n+\t\t\t\t\t\t      lntype, ll_mask)),\n \t\t\t\t\t0)))\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n@@ -3881,12 +3881,12 @@ fold_truthop (code, truth_type, lhs, rhs)\n     }\n   if (r_const)\n     {\n-      r_const = convert (type, r_const);\n+      r_const = convert (lntype, r_const);\n       r_const = unextend (r_const, rl_bitsize, rl_unsignedp, rl_and_mask);\n       r_const = const_binop (LSHIFT_EXPR, r_const, size_int (xrl_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, r_const,\n \t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t\t\t      type, rl_mask)),\n+\t\t\t\t\t\t      lntype, rl_mask)),\n \t\t\t\t\t0)))\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n@@ -3919,6 +3919,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \n       rnbitsize = GET_MODE_BITSIZE (rnmode);\n       rnbitpos = first_bit & ~ (rnbitsize - 1);\n+      rntype = type_for_size (rnbitsize, 1);\n       xlr_bitpos = lr_bitpos - rnbitpos, xrr_bitpos = rr_bitpos - rnbitpos;\n \n       if (BYTES_BIG_ENDIAN)\n@@ -3927,29 +3928,30 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t  xrr_bitpos = rnbitsize - xrr_bitpos - rr_bitsize;\n \t}\n \n-      lr_mask = const_binop (LSHIFT_EXPR, convert (type, lr_mask),\n+      lr_mask = const_binop (LSHIFT_EXPR, convert (rntype, lr_mask),\n \t\t\t     size_int (xlr_bitpos), 0);\n-      rr_mask = const_binop (LSHIFT_EXPR, convert (type, rr_mask),\n+      rr_mask = const_binop (LSHIFT_EXPR, convert (rntype, rr_mask),\n \t\t\t     size_int (xrr_bitpos), 0);\n \n       /* Make a mask that corresponds to both fields being compared.\n \t Do this for both items being compared.  If the masks agree,\n-\t and the bits being compared are in the same position, then\n-\t we can do this by masking both and comparing the masked\n-\t results.  */\n+\t and the bits being compared are in the same position, and the\n+\t types agree, then we can do this by masking both and comparing\n+\t the masked results.  */\n       ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask, 0);\n       lr_mask = const_binop (BIT_IOR_EXPR, lr_mask, rr_mask, 0);\n       if (operand_equal_p (ll_mask, lr_mask, 0)\n-\t  && lnbitsize == rnbitsize && xll_bitpos == xlr_bitpos)\n+\t  && lnbitsize == rnbitsize && xll_bitpos == xlr_bitpos\n+\t  && lntype == rntype)\n \t{\n-\t  lhs = make_bit_field_ref (ll_inner, type, lnbitsize, lnbitpos,\n+\t  lhs = make_bit_field_ref (ll_inner, lntype, lnbitsize, lnbitpos,\n \t\t\t\t    ll_unsignedp || rl_unsignedp);\n-\t  rhs = make_bit_field_ref (lr_inner, type, rnbitsize, rnbitpos,\n+\t  rhs = make_bit_field_ref (lr_inner, rntype, rnbitsize, rnbitpos,\n \t\t\t\t    lr_unsignedp || rr_unsignedp);\n \t  if (! all_ones_mask_p (ll_mask, lnbitsize))\n \t    {\n-\t      lhs = build (BIT_AND_EXPR, type, lhs, ll_mask);\n-\t      rhs = build (BIT_AND_EXPR, type, rhs, ll_mask);\n+\t      lhs = build (BIT_AND_EXPR, lntype, lhs, ll_mask);\n+\t      rhs = build (BIT_AND_EXPR, rntype, rhs, ll_mask);\n \t    }\n \t  return build (wanted_code, truth_type, lhs, rhs);\n \t}\n@@ -3966,17 +3968,39 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t  || (ll_bitpos == rl_bitpos + rl_bitsize\n \t      && lr_bitpos == rr_bitpos + rr_bitsize))\n \t{\n-\t  lhs = make_bit_field_ref (ll_inner, type, ll_bitsize + rl_bitsize,\n+\t  tree type;\n+\n+\t  lhs = make_bit_field_ref (ll_inner, lntype, ll_bitsize + rl_bitsize,\n \t\t\t\t    MIN (ll_bitpos, rl_bitpos), ll_unsignedp);\n+\t  rhs = make_bit_field_ref (lr_inner, rntype, lr_bitsize + rr_bitsize,\n+\t\t\t\t    MIN (lr_bitpos, rr_bitpos), lr_unsignedp);\n+\n \t  ll_mask = const_binop (RSHIFT_EXPR, ll_mask,\n \t\t\t\t size_int (MIN (xll_bitpos, xrl_bitpos)), 0);\n+\t  lr_mask = const_binop (RSHIFT_EXPR, lr_mask,\n+\t\t\t\t size_int (MIN (xlr_bitpos, xrr_bitpos)), 0);\n+\n+\t  /* Convert to the smaller type before masking out unwanted bits.  */\n+\t  type = lntype;\n+\t  if (lntype != rntype)\n+\t    {\n+\t      if (lnbitsize > rnbitsize)\n+\t\t{\n+\t\t  lhs = convert (rntype, lhs);\n+\t\t  ll_mask = convert (rntype, ll_mask);\n+\t\t  type = rntype;\n+\t\t}\n+\t      else if (lnbitsize < rnbitsize)\n+\t\t{\n+\t\t  rhs = convert (lntype, rhs);\n+\t\t  lr_mask = convert (lntype, lr_mask);\n+\t\t  type = lntype;\n+\t\t}\n+\t    }\n+\n \t  if (! all_ones_mask_p (ll_mask, ll_bitsize + rl_bitsize))\n \t    lhs = build (BIT_AND_EXPR, type, lhs, ll_mask);\n \n-\t  rhs = make_bit_field_ref (lr_inner, type, lr_bitsize + rr_bitsize,\n-\t\t\t\t    MIN (lr_bitpos, rr_bitpos), lr_unsignedp);\n-\t  lr_mask = const_binop (RSHIFT_EXPR, lr_mask,\n-\t\t\t\t size_int (MIN (xlr_bitpos, xrr_bitpos)), 0);\n \t  if (! all_ones_mask_p (lr_mask, lr_bitsize + rr_bitsize))\n \t    rhs = build (BIT_AND_EXPR, type, rhs, lr_mask);\n \n@@ -4011,12 +4035,12 @@ fold_truthop (code, truth_type, lhs, rhs)\n      reference we will make.  Unless the mask is all ones the width of\n      that field, perform the mask operation.  Then compare with the\n      merged constant.  */\n-  result = make_bit_field_ref (ll_inner, type, lnbitsize, lnbitpos,\n+  result = make_bit_field_ref (ll_inner, lntype, lnbitsize, lnbitpos,\n \t\t\t       ll_unsignedp || rl_unsignedp);\n \n   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask, 0);\n   if (! all_ones_mask_p (ll_mask, lnbitsize))\n-    result = build (BIT_AND_EXPR, type, result, ll_mask);\n+    result = build (BIT_AND_EXPR, lntype, result, ll_mask);\n \n   return build (wanted_code, truth_type, result,\n \t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));"}]}