{"sha": "b3d77404c060c0d65d8d4c97254995737d0fc032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkNzc0MDRjMDYwYzBkNjVkOGQ0Yzk3MjU0OTk1NzM3ZDBmYzAzMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-26T13:23:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-26T13:26:48Z"}, "message": "Take into account range info to optimize range tests into bit tests\n\nThe patch is aimed at addressing the following two issues:\n\n  1. In order to protect the shift operation from undefinedness, the\nnew bit test is guarded with a new test, but this new test uses the\nrange of the bit test values, not that of the shift operation so,\nif the input is in the range of the shift operation but not of the\nbit test values, then the subsequent VRP pass cannot eliminate the\nnew test.  Moreover changing the new test to use the range of the\nshift operation, instead of that of the bit test values, in the\ngeneral case would pessimize the cases which are in between.\n\n  2. If the new test can be eliminated, then it becomes profitable\nto do the optimization into a bit test for one fewer comparison in\nthe source code.\n\nTherefore the patch changes optimize_range_tests_to_bit_test to use\nthe range info of the input in order to eliminate the new test.\n\ngcc/ChangeLog:\n\t* tree-ssa-reassoc.c (dump_range_entry): New function.\n\t(debug_range_entry): New debug function.\n\t(update_range_test): Invoke dump_range_entry for dumping.\n\t(optimize_range_tests_to_bit_test): Merge the entry test in the\n\tbit test when possible and lower the profitability threshold.\n\ngcc/ada/ChangeLog:\n\t* exp_ch4.adb (Expand_Set_Membership): Expand the membership test\n\tusing left associativity instead of right associativity.\n\ngcc/testsuite/ChangeLog:\n\t* gnat.dg/opt86_pkg.ads: New helper.\n\t* gnat.dg/opt86a.adb: New test.\n\t* gnat.dg/opt86b.adb: Likewise.\n\t* gnat.dg/opt86c.adb: Likewise.", "tree": {"sha": "ea830543f92f5c3fc7054078e9352a15d9f1093e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea830543f92f5c3fc7054078e9352a15d9f1093e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3d77404c060c0d65d8d4c97254995737d0fc032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d77404c060c0d65d8d4c97254995737d0fc032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d77404c060c0d65d8d4c97254995737d0fc032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d77404c060c0d65d8d4c97254995737d0fc032/comments", "author": null, "committer": null, "parents": [{"sha": "2ca78835619f0f24c1fe5d74828d8dc95900fe96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca78835619f0f24c1fe5d74828d8dc95900fe96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca78835619f0f24c1fe5d74828d8dc95900fe96"}], "stats": {"total": 247, "additions": 212, "deletions": 35}, "files": [{"sha": "88dcb52349d43d40ff91d99214b7e2afe525fc52", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -12879,16 +12879,19 @@ package body Exp_Ch4 is\n    begin\n       Remove_Side_Effects (Lop);\n \n-      Alt := Last (Alternatives (N));\n+      Alt := First (Alternatives (N));\n       Res := Make_Cond (Alt);\n+      Next (Alt);\n+\n+      --  We use left associativity as in the equivalent boolean case. This\n+      --  kind of canonicalization helps the optimizer of the code generator.\n \n-      Prev (Alt);\n       while Present (Alt) loop\n          Res :=\n            Make_Or_Else (Sloc (Alt),\n-             Left_Opnd  => Make_Cond (Alt),\n-             Right_Opnd => Res);\n-         Prev (Alt);\n+             Left_Opnd  => Res,\n+             Right_Opnd => Make_Cond (Alt));\n+         Next (Alt);\n       end loop;\n \n       Rewrite (N, Res);"}, {"sha": "92ce45b9202d951e0474136a6ec654e06c70bb08", "filename": "gcc/testsuite/gnat.dg/opt86_pkg.ads", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86_pkg.ads?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -0,0 +1,8 @@\n+package Opt86_Pkg is\n+\n+  type Enum is (Val0, Val1, Val2, Val3, Val4, Val5, Val6, Val7,\n+                Val8, Val9, Val10, Val11, Val12, Val13, Val14, Val15,\n+                Val16, Val17, Val18, Val19, Val20, Val21, Val22, Val23,\n+                Val24, Val25, Val26, Val27, Val28, Val29, Val30, Val31);\n+\n+end Opt86_Pkg;"}, {"sha": "d8cd35ebc8bd1e47f361d6789ad4b0e8f8253f13", "filename": "gcc/testsuite/gnat.dg/opt86a.adb", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86a.adb?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -0,0 +1,36 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+with Ada.Command_Line; use Ada.Command_Line;\n+with Opt86_Pkg; use Opt86_Pkg;\n+\n+procedure Opt86a is\n+\n+  S1, S2, S3, S4 : Enum;\n+\n+begin\n+\n+  S1 := Enum'Value (Argument (1));\n+  S2 := Enum'Value (Argument (2));\n+  S3 := Enum'Value (Argument (3));\n+  S4 := Enum'Value (Argument (4));\n+\n+  if S1 in Val2 | Val3 | Val9 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S2 not in Val2 | Val3 | Val9 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S3 = Val1 or else S3 = Val4 or else S3 = Val8 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S4 /= Val1 and S4 /= Val4 and S4 /= Val8 then\n+    raise Program_Error;\n+  end if;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \">>\" 4 \"optimized\" } }"}, {"sha": "fe46f2e28c63343d8c6ab85ba1215cf74e431368", "filename": "gcc/testsuite/gnat.dg/opt86b.adb", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86b.adb?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -0,0 +1,37 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+with Ada.Command_Line; use Ada.Command_Line;\n+with Opt86_Pkg; use Opt86_Pkg;\n+\n+procedure Opt86B is\n+\n+  S1, S2, S3, S4 : Enum;\n+\n+begin\n+\n+  S1 := Enum'Value (Argument (1));\n+  S2 := Enum'Value (Argument (2));\n+  S3 := Enum'Value (Argument (3));\n+  S4 := Enum'Value (Argument (4));\n+\n+  if S1 in Val2 | Val3 | Val9 | Val29 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S2 not in Val2 | Val3 | Val9 | Val29 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S3 = Val1 or S3 = Val4 or S3 = Val8 or S3 = Val13 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S4 /= Val1 and S4 /= Val4 and S4 /= Val8 and S4 /= Val13 then\n+    raise Program_Error;\n+  end if;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"> 29\" \"optimized\" } } \n+-- { dg-final { scan-tree-dump-not \"> 13\" \"optimized\" } } "}, {"sha": "77691441eb3af000456e0261feaf83f7015eeafc", "filename": "gcc/testsuite/gnat.dg/opt86c.adb", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt86c.adb?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -0,0 +1,37 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+with Ada.Command_Line; use Ada.Command_Line;\n+with Opt86_Pkg; use Opt86_Pkg;\n+\n+procedure Opt86c is\n+\n+  S1, S2, S3, S4 : Enum;\n+\n+begin\n+\n+  S1 := Enum'Value (Argument (1));\n+  S2 := Enum'Value (Argument (2));\n+  S3 := Enum'Value (Argument (3));\n+  S4 := Enum'Value (Argument (4));\n+\n+  if S1 in Val16 | Val8 | Val26 | Val2 | Val10 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S2 not in Val16 | Val8 | Val26 | Val2 | Val10 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S3 = Val3 or S3 = Val25 or S3 = Val13 or S3 = Val29 or S3 = Val11 then\n+    raise Program_Error;\n+  end if;\n+\n+  if S4 /= Val3 and S4 /= Val25 and S4 /= Val13 and S4 /= Val29 and s4 /= Val11 then\n+    raise Program_Error;\n+  end if;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"> 26\" \"optimized\" } }\n+-- { dg-final { scan-tree-dump-not \"> 29\" \"optimized\" } }"}, {"sha": "d06b693ec768b0de86370b034819dd00671b363a", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 86, "deletions": 30, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d77404c060c0d65d8d4c97254995737d0fc032/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b3d77404c060c0d65d8d4c97254995737d0fc032", "patch": "@@ -2416,6 +2416,32 @@ struct range_entry\n   unsigned int idx, next;\n };\n \n+void dump_range_entry (FILE *file, struct range_entry *r);\n+void debug_range_entry (struct range_entry *r);\n+\n+/* Dump the range entry R to FILE, skipping its expression if SKIP_EXP.  */\n+\n+void\n+dump_range_entry (FILE *file, struct range_entry *r, bool skip_exp)\n+{\n+  if (!skip_exp)\n+    print_generic_expr (file, r->exp);\n+  fprintf (file, \" %c[\", r->in_p ? '+' : '-');\n+  print_generic_expr (file, r->low);\n+  fputs (\", \", file);\n+  print_generic_expr (file, r->high);\n+  fputc (']', file);\n+}\n+\n+/* Dump the range entry R to STDERR.  */\n+\n+DEBUG_FUNCTION void\n+debug_range_entry (struct range_entry *r)\n+{\n+  dump_range_entry (stderr, r, false);\n+  fputc ('\\n', stderr);\n+}\n+\n /* This is similar to make_range in fold-const.c, but on top of\n    GIMPLE instead of trees.  If EXP is non-NULL, it should be\n    an SSA_NAME and STMT argument is ignored, otherwise STMT\n@@ -2730,12 +2756,7 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n     {\n       struct range_entry *r;\n       fprintf (dump_file, \"Optimizing range tests \");\n-      print_generic_expr (dump_file, range->exp);\n-      fprintf (dump_file, \" %c[\", range->in_p ? '+' : '-');\n-      print_generic_expr (dump_file, range->low);\n-      fprintf (dump_file, \", \");\n-      print_generic_expr (dump_file, range->high);\n-      fprintf (dump_file, \"]\");\n+      dump_range_entry (dump_file, range, false);\n       for (i = 0; i < count; i++)\n \t{\n \t  if (otherrange)\n@@ -2747,15 +2768,13 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n \t      && TREE_CODE (r->exp) == SSA_NAME)\n \t    {\n \t      fprintf (dump_file, \" and \");\n-\t      print_generic_expr (dump_file, r->exp);\n+\t      dump_range_entry (dump_file, r, false);\n \t    }\n \t  else\n-\t    fprintf (dump_file, \" and\");\n-\t  fprintf (dump_file, \" %c[\", r->in_p ? '+' : '-');\n-\t  print_generic_expr (dump_file, r->low);\n-\t  fprintf (dump_file, \", \");\n-\t  print_generic_expr (dump_file, r->high);\n-\t  fprintf (dump_file, \"]\");\n+\t    {\n+\t      fprintf (dump_file, \" and\");\n+\t      dump_range_entry (dump_file, r, true);\n+\t    }\n \t}\n       fprintf (dump_file, \"\\n into \");\n       print_generic_expr (dump_file, tem);\n@@ -3121,7 +3140,7 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n   int prec = GET_MODE_BITSIZE (word_mode);\n   auto_vec<struct range_entry *, 64> candidates;\n \n-  for (i = first; i < length - 2; i++)\n+  for (i = first; i < length - 1; i++)\n     {\n       tree lowi, highi, lowj, highj, type;\n \n@@ -3184,8 +3203,32 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t  candidates.safe_push (&ranges[j]);\n \t}\n \n-      /* If we need otherwise 3 or more comparisons, use a bit test.  */\n-      if (candidates.length () >= 2)\n+      /* If every possible relative value of the expression is a valid shift\n+\t amount, then we can merge the entry test in the bit test.  In this\n+\t case, if we would need otherwise 2 or more comparisons, then use\n+\t the bit test; in the other cases, the threshold is 3 comparisons.  */\n+      wide_int min, max;\n+      bool entry_test_needed;\n+      if (TREE_CODE (exp) == SSA_NAME\n+\t  && get_range_info (exp, &min, &max) == VR_RANGE\n+\t  && wi::leu_p (max - min, prec - 1))\n+\t{\n+\t  wide_int ilowi = wi::to_wide (lowi);\n+\t  if (wi::lt_p (min, ilowi, TYPE_SIGN (TREE_TYPE (lowi))))\n+\t    {\n+\t      lowi = wide_int_to_tree (TREE_TYPE (lowi), min);\n+\t      mask = wi::lshift (mask, ilowi - min);\n+\t    }\n+\t  else if (wi::gt_p (min, ilowi, TYPE_SIGN (TREE_TYPE (lowi))))\n+\t    {\n+\t      lowi = wide_int_to_tree (TREE_TYPE (lowi), min);\n+\t      mask = wi::lrshift (mask, min - ilowi);\n+\t    }\n+\t  entry_test_needed = false;\n+\t}\n+      else\n+\tentry_test_needed = true;\n+      if (candidates.length () >= (entry_test_needed ? 2 : 1))\n \t{\n \t  tree high = wide_int_to_tree (TREE_TYPE (lowi),\n \t\t\t\t\twi::to_widest (lowi)\n@@ -3224,10 +3267,16 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t\t}\n \t    }\n \n-\t  tree tem = build_range_check (loc, optype, unshare_expr (exp),\n-\t\t\t\t\tfalse, lowi, high);\n-\t  if (tem == NULL_TREE || is_gimple_val (tem))\n-\t    continue;\n+\t  tree tem;\n+\t  if (entry_test_needed)\n+\t    {\n+\t      tem = build_range_check (loc, optype, unshare_expr (exp),\n+\t\t\t\t       false, lowi, high);\n+\t      if (tem == NULL_TREE || is_gimple_val (tem))\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    tem = NULL_TREE;\n \t  tree etype = unsigned_type_for (TREE_TYPE (exp));\n \t  exp = fold_build2_loc (loc, MINUS_EXPR, etype,\n \t\t\t\t fold_convert_loc (loc, etype, exp),\n@@ -3248,27 +3297,34 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t     split when it is running.  So, temporarily emit a code\n \t     with BIT_IOR_EXPR instead of &&, and fix it up in\n \t     branch_fixup.  */\n-\t  gimple_seq seq;\n-\t  tem = force_gimple_operand (tem, &seq, true, NULL_TREE);\n-\t  gcc_assert (TREE_CODE (tem) == SSA_NAME);\n-\t  gimple_set_visited (SSA_NAME_DEF_STMT (tem), true);\n+\t  gimple_seq seq = NULL;\n+\t  if (tem)\n+\t    {\n+\t      tem = force_gimple_operand (tem, &seq, true, NULL_TREE);\n+\t      gcc_assert (TREE_CODE (tem) == SSA_NAME);\n+\t      gimple_set_visited (SSA_NAME_DEF_STMT (tem), true);\n+\t    }\n \t  gimple_seq seq2;\n \t  exp = force_gimple_operand (exp, &seq2, true, NULL_TREE);\n \t  gimple_seq_add_seq_without_update (&seq, seq2);\n \t  gcc_assert (TREE_CODE (exp) == SSA_NAME);\n \t  gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);\n-\t  gimple *g = gimple_build_assign (make_ssa_name (optype),\n-\t\t\t\t\t   BIT_IOR_EXPR, tem, exp);\n-\t  gimple_set_location (g, loc);\n-\t  gimple_seq_add_stmt_without_update (&seq, g);\n-\t  exp = gimple_assign_lhs (g);\n+\t  if (tem)\n+\t    {\n+\t      gimple *g = gimple_build_assign (make_ssa_name (optype),\n+\t\t\t\t\t       BIT_IOR_EXPR, tem, exp);\n+\t      gimple_set_location (g, loc);\n+\t      gimple_seq_add_stmt_without_update (&seq, g);\n+\t      exp = gimple_assign_lhs (g);\n+\t    }\n \t  tree val = build_zero_cst (optype);\n \t  if (update_range_test (&ranges[i], NULL, candidates.address (),\n \t\t\t\t candidates.length (), opcode, ops, exp,\n \t\t\t\t seq, false, val, val, strict_overflow_p))\n \t    {\n \t      any_changes = true;\n-\t      reassoc_branch_fixups.safe_push (tem);\n+\t      if (tem)\n+\t\treassoc_branch_fixups.safe_push (tem);\n \t    }\n \t  else\n \t    gimple_seq_discard (seq);"}]}