{"sha": "d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZjZDg0ZTAzNjVlN2ZjNDVkOTk4YzgyYTRiZjgyYjEyYjM0YWUzNw==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-04-25T18:01:35Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-04-25T18:01:35Z"}, "message": "fix assignment to partially-overlapped COMPLEX\n\nFrom-SVN: r26625", "tree": {"sha": "06a70bfddeadb05621f45793665eaa03ca8eb1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a70bfddeadb05621f45793665eaa03ca8eb1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/comments", "author": null, "committer": null, "parents": [{"sha": "4433e33948b6cfeacbc9e98428dcfe0f23c4773b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4433e33948b6cfeacbc9e98428dcfe0f23c4773b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4433e33948b6cfeacbc9e98428dcfe0f23c4773b"}], "stats": {"total": 91, "additions": 90, "deletions": 1}, "files": [{"sha": "1ebe291583139950d7b1b5f7795546b305b7bb10", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "patch": "@@ -1,3 +1,12 @@\n+Sun Apr 25 20:55:10 1999  Craig Burley  <craig@jcb-sc.com>\n+\n+\tFix 19990325-0.f and 19990325-1.f:\n+\t* com.c (ffecom_possible_partial_overlap_): New function.\n+\t(ffecom_expand_let_stmt): Use it to determine whether to assign\n+\tto a COMPLEX operand through a temp.\n+\n+\t* version.c: Bump version.\n+\n Sat Apr 24 12:19:53 1999  Craig Burley  <craig@jcb-sc.com>\n \n \t* expr.c (ffeexpr_finished_): Convert DATA implied-do"}, {"sha": "3362ef3c0c3e48b929e429409e88925809e5450b", "filename": "gcc/f/com.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "patch": "@@ -1503,6 +1503,48 @@ ffecom_widest_expr_type_ (ffebld list)\n }\n #endif\n \n+/* Check whether a partial overlap between two expressions is possible.\n+\n+   Can *starting* to write a portion of expr1 change the value\n+   computed (perhaps already, *partially*) by expr2?\n+\n+   Currently, this is a concern only for a COMPLEX expr1.  But if it\n+   isn't in COMMON or local EQUIVALENCE, since we don't support\n+   aliasing of arguments, it isn't a concern.  */\n+\n+static bool\n+ffecom_possible_partial_overlap_ (ffebld expr1, ffebld expr2)\n+{\n+  ffesymbol sym;\n+  ffestorag st;\n+\n+  switch (ffebld_op (expr1))\n+    {\n+    case FFEBLD_opSYMTER:\n+      sym = ffebld_symter (expr1);\n+      break;\n+\n+    case FFEBLD_opARRAYREF:\n+      if (ffebld_op (ffebld_left (expr1)) != FFEBLD_opSYMTER)\n+\treturn FALSE;\n+      sym = ffebld_symter (ffebld_left (expr1));\n+      break;\n+\n+    default:\n+      return FALSE;\n+    }\n+\n+  if (ffesymbol_where (sym) != FFEINFO_whereCOMMON\n+      && (ffesymbol_where (sym) != FFEINFO_whereLOCAL\n+\t  || ! (st = ffesymbol_storage (sym))\n+\t  || ! ffestorag_parent (st)))\n+    return FALSE;\n+\n+  /* It's in COMMON or local EQUIVALENCE.  */\n+\n+  return TRUE;\n+}\n+\n /* Check whether dest and source might overlap.  ffebld versions of these\n    might or might not be passed, will be NULL if not.\n \n@@ -11154,6 +11196,7 @@ ffecom_expand_let_stmt (ffebld dest, ffebld source)\n   if (ffeinfo_basictype (ffebld_info (dest)) != FFEINFO_basictypeCHARACTER)\n     {\n       bool dest_used;\n+      tree assign_temp;\n \n       /* This attempts to replicate the test below, but must not be\n \t true when the test below is false.  (Always err on the side\n@@ -11174,6 +11217,22 @@ ffecom_expand_let_stmt (ffebld dest, ffebld source)\n \n       ffecom_prepare_expr_w (NULL_TREE, dest);\n \n+      /* For COMPLEX assignment like C1=C2, if partial overlap is possible,\n+\t create a temporary through which the assignment is to take place,\n+\t since MODIFY_EXPR doesn't handle partial overlap properly.  */\n+      if (ffebld_basictype (dest) == FFEINFO_basictypeCOMPLEX\n+\t  && ffecom_possible_partial_overlap_ (dest, source))\n+\t{\n+\t  assign_temp = ffecom_make_tempvar (\"complex_let\",\n+\t\t\t\t\t     ffecom_tree_type\n+\t\t\t\t\t     [ffebld_basictype (dest)]\n+\t\t\t\t\t     [ffebld_kindtype (dest)],\n+\t\t\t\t\t     FFETARGET_charactersizeNONE,\n+\t\t\t\t\t     -1);\n+\t}\n+      else\n+\tassign_temp = NULL_TREE;\n+\n       ffecom_prepare_end ();\n \n       dest_tree = ffecom_expr_w (NULL_TREE, dest);\n@@ -11195,6 +11254,27 @@ ffecom_expand_let_stmt (ffebld dest, ffebld source)\n \n       if (dest_used)\n \texpr_tree = source_tree;\n+      else if (assign_temp)\n+\t{\n+#ifdef MOVE_EXPR\n+\t  /* The back end understands a conceptual move (evaluate source;\n+\t     store into dest), so use that, in case it can determine\n+\t     that it is going to use, say, two registers as temporaries\n+\t     anyway.  So don't use the temp (and someday avoid generating\n+\t     it, once this code starts triggering regularly).  */\n+\t  expr_tree = ffecom_2s (MOVE_EXPR, void_type_node,\n+\t\t\t\t dest_tree,\n+\t\t\t\t source_tree);\n+#else\n+\t  expr_tree = ffecom_2s (MODIFY_EXPR, void_type_node,\n+\t\t\t\t assign_temp,\n+\t\t\t\t source_tree);\n+\t  expand_expr_stmt (expr_tree);\n+\t  expr_tree = ffecom_2s (MODIFY_EXPR, void_type_node,\n+\t\t\t\t dest_tree,\n+\t\t\t\t assign_temp);\n+#endif\n+\t}\n       else\n \texpr_tree = ffecom_2s (MODIFY_EXPR, void_type_node,\n \t\t\t       dest_tree,"}, {"sha": "da8caa58253f9e954d8dcbc91dcbc8e4861461fc", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6cd84e0365e7fc45d998c82a4bf82b12b34ae37/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=d6cd84e0365e7fc45d998c82a4bf82b12b34ae37", "patch": "@@ -1 +1 @@\n-const char *ffe_version_string = \"0.5.24-19990424\";\n+const char *ffe_version_string = \"0.5.24-19990425\";"}]}