{"sha": "22a4f9d54db67a17191dfad5dfb635465489be8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhNGY5ZDU0ZGI2N2ExNzE5MWRmYWQ1ZGZiNjM1NDY1NDg5YmU4Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T09:46:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T09:46:18Z"}, "message": "[multiple changes]\n\n2016-04-21  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* s-soflin.adb: Initialize the Stack_Limit global variable.\n\n2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-writ.adb: Minor reformatting.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_pakd.adb (Compute_Number_Components): New function to\n\tbuild an expression that computes the number of a components of\n\tan array that may be multidimensional.\n\t(Expan_Packed_Eq): Use it.\n\n2016-04-21  Arnaud Charlet  <charlet@adacore.com>\n\n\t* g-traceb.ads: Update list of supported platforms.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Add_Predicates): if the type is declared in\n\tan inner package it may be frozen outside of the package, and\n\tthe generated pragma has not been analyzed yet, the expression\n\tfor the predicate must be captured and added to the predicate\n\tfunction at this point.\n\n2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.adb (Analyze_Package_Body_Contract): Do not check\n\tfor a missing package refinement because 1) packages do not have\n\t\"refinement\" and 2) the check for proper state refinement is\n\tperformed in a different place.\n\t* einfo.adb (Has_Non_Null_Visible_Refinement): Reimplemented.\n\t(Has_Null_Visible_Refinement): Reimplemented.\n\t* sem_ch3.adb (Analyze_Declarations): Determine whether all\n\tabstract states have received a refinement and if not, emit\n\terrors.\n\t* sem_ch7.adb (Analyze_Package_Declaration): Code\n\tcleanup. Determine whether all abstract states of the\n\tpackage and any nested packages have received a refinement\n\tand if not, emit errors.\n\t(Requires_Completion_In_Body): Add new formal parameter\n\tDo_Abstract_States. Update the comment on usage. Propagate the\n\tDo_Abstract_States flag to all Unit_Requires_Body calls.\n\t(Unit_Requires_Body): Remove formal\n\tparameter Ignore_Abstract_States. Add new formal paramter\n\tDo_Abstract_States. Propagate the Do_Abstract_States flag to\n\tall Requires_Completion_In calls.\n\t* sem_ch7.ads (Unit_Requires_Body): Remove formal\n\tparameter Ignore_Abstract_States. Add new formal paramter\n\tDo_Abstract_States. Update the comment on usage.\n\t* sem_ch9.adb (Analyze_Single_Protected_Declaration): Do\n\tnot initialize the constituent list as this is now done on a\n\tneed-to-add-element basis.\n\t(Analyze_Single_Task_Declaration):\n\tDo not initialize the constituent list as this is now done on\n\ta need-to-add-element basis.\n\t* sem_ch10.adb (Decorate_State): Do not initialize the constituent\n\tlists as this is now done on a need-to-add-element basis.\n\t* sem_prag.adb (Analyze_Constituent): Set the\n\trefinement constituents when adding a new element.\n\t(Analyze_Part_Of_In_Decl_Part): Set the Part_Of constituents when\n\tadding a new element.\n\t(Analyze_Part_Of_Option): Set the Part_Of\n\tconstituents when adding a new element.\n\t(Analyze_Pragma): Set the Part_Of constituents when adding a new\n\telement.\n\t(Check_Constituent_Usage (all versions)): Reimplemented.\n\t(Collect_Constituent): Set the refinement constituents when adding\n\ta new element.\n\t(Create_Abstract_State): Do not initialize the\n\tconstituent lists as this is now done on a need-to-add-element basis.\n\t(Propagate_Part_Of): Set the Part_Of constituents when\n\tadding a new element.\n\t* sem_util.adb (Check_State_Refinements): New routine.\n\t(Has_Non_Null_Refinement): Reimplemented.\n\t(Has_Null_Refinement): Reimplemented.\n\t(Requires_State_Refinement): Removed.\n\t* sem_util.ads (Check_State_Refinements): New routine.\n\t(Requires_State_Refinement): Removed.\n\nFrom-SVN: r235326", "tree": {"sha": "df2aa9b9f66c3d60d3ad578b000ee3ac83c7f466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df2aa9b9f66c3d60d3ad578b000ee3ac83c7f466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a4f9d54db67a17191dfad5dfb635465489be8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a4f9d54db67a17191dfad5dfb635465489be8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a4f9d54db67a17191dfad5dfb635465489be8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a4f9d54db67a17191dfad5dfb635465489be8c/comments", "author": null, "committer": null, "parents": [{"sha": "c4dc2125063be04a54d030075a03e4ded7be38d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4dc2125063be04a54d030075a03e4ded7be38d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4dc2125063be04a54d030075a03e4ded7be38d5"}], "stats": {"total": 952, "additions": 629, "deletions": 323}, "files": [{"sha": "27476846f1bf9369824ccf9b99fec93d7b3eaa22", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -1,3 +1,85 @@\n+2016-04-21  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* s-soflin.adb: Initialize the Stack_Limit global variable.\n+\n+2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-writ.adb: Minor reformatting.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_pakd.adb (Compute_Number_Components): New function to\n+\tbuild an expression that computes the number of a components of\n+\tan array that may be multidimensional.\n+\t(Expan_Packed_Eq): Use it.\n+\n+2016-04-21  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* g-traceb.ads: Update list of supported platforms.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Add_Predicates): if the type is declared in\n+\tan inner package it may be frozen outside of the package, and\n+\tthe generated pragma has not been analyzed yet, the expression\n+\tfor the predicate must be captured and added to the predicate\n+\tfunction at this point.\n+\n+2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb (Analyze_Package_Body_Contract): Do not check\n+\tfor a missing package refinement because 1) packages do not have\n+\t\"refinement\" and 2) the check for proper state refinement is\n+\tperformed in a different place.\n+\t* einfo.adb (Has_Non_Null_Visible_Refinement): Reimplemented.\n+\t(Has_Null_Visible_Refinement): Reimplemented.\n+\t* sem_ch3.adb (Analyze_Declarations): Determine whether all\n+\tabstract states have received a refinement and if not, emit\n+\terrors.\n+\t* sem_ch7.adb (Analyze_Package_Declaration): Code\n+\tcleanup. Determine whether all abstract states of the\n+\tpackage and any nested packages have received a refinement\n+\tand if not, emit errors.\n+\t(Requires_Completion_In_Body): Add new formal parameter\n+\tDo_Abstract_States. Update the comment on usage. Propagate the\n+\tDo_Abstract_States flag to all Unit_Requires_Body calls.\n+\t(Unit_Requires_Body): Remove formal\n+\tparameter Ignore_Abstract_States. Add new formal paramter\n+\tDo_Abstract_States. Propagate the Do_Abstract_States flag to\n+\tall Requires_Completion_In calls.\n+\t* sem_ch7.ads (Unit_Requires_Body): Remove formal\n+\tparameter Ignore_Abstract_States. Add new formal paramter\n+\tDo_Abstract_States. Update the comment on usage.\n+\t* sem_ch9.adb (Analyze_Single_Protected_Declaration): Do\n+\tnot initialize the constituent list as this is now done on a\n+\tneed-to-add-element basis.\n+\t(Analyze_Single_Task_Declaration):\n+\tDo not initialize the constituent list as this is now done on\n+\ta need-to-add-element basis.\n+\t* sem_ch10.adb (Decorate_State): Do not initialize the constituent\n+\tlists as this is now done on a need-to-add-element basis.\n+\t* sem_prag.adb (Analyze_Constituent): Set the\n+\trefinement constituents when adding a new element.\n+\t(Analyze_Part_Of_In_Decl_Part): Set the Part_Of constituents when\n+\tadding a new element.\n+\t(Analyze_Part_Of_Option): Set the Part_Of\n+\tconstituents when adding a new element.\n+\t(Analyze_Pragma): Set the Part_Of constituents when adding a new\n+\telement.\n+\t(Check_Constituent_Usage (all versions)): Reimplemented.\n+\t(Collect_Constituent): Set the refinement constituents when adding\n+\ta new element.\n+\t(Create_Abstract_State): Do not initialize the\n+\tconstituent lists as this is now done on a need-to-add-element basis.\n+\t(Propagate_Part_Of): Set the Part_Of constituents when\n+\tadding a new element.\n+\t* sem_util.adb (Check_State_Refinements): New routine.\n+\t(Has_Non_Null_Refinement): Reimplemented.\n+\t(Has_Null_Refinement): Reimplemented.\n+\t(Requires_State_Refinement): Removed.\n+\t* sem_util.ads (Check_State_Refinements): New routine.\n+\t(Requires_State_Refinement): Removed.\n+\n 2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* lib-writ.adb, sem_ch6.adb: Minor reformatting and code cleanup."}, {"sha": "f6d236ffe0a8e2a5efa3b84ee237d04564390d56", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2015-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -949,15 +949,6 @@ package body Contracts is\n \n       if Present (Ref_State) then\n          Analyze_Refined_State_In_Decl_Part (Ref_State, Freeze_Id);\n-\n-      --  State refinement is required when the package declaration defines at\n-      --  least one abstract state. Null states are not considered. Refinement\n-      --  is not enforced when SPARK checks are turned off.\n-\n-      elsif SPARK_Mode /= Off\n-        and then Requires_State_Refinement (Spec_Id, Body_Id)\n-      then\n-         Error_Msg_N (\"package & requires state refinement\", Spec_Id);\n       end if;\n \n       --  Restore the SPARK_Mode of the enclosing context after all delayed"}, {"sha": "7172a2ac518a438f31418b1c4b85c31f94bfdd38", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -7351,22 +7351,21 @@ package body Einfo is\n    -------------------------------------\n \n    function Has_Non_Null_Visible_Refinement (Id : E) return B is\n+      Constits : Elist_Id;\n+\n    begin\n       --  \"Refinement\" is a concept applicable only to abstract states\n \n       pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Constits := Refinement_Constituents (Id);\n \n-      if Has_Visible_Refinement (Id) then\n-         pragma Assert (Present (Refinement_Constituents (Id)));\n-\n-         --  For a refinement to be non-null, the first constituent must be\n-         --  anything other than null.\n+      --  For a refinement to be non-null, the first constituent must be\n+      --  anything other than null.\n \n-         return\n-           Nkind (Node (First_Elmt (Refinement_Constituents (Id)))) /= N_Null;\n-      end if;\n-\n-      return False;\n+      return\n+        Has_Visible_Refinement (Id)\n+          and then Present (Constits)\n+          and then Nkind (Node (First_Elmt (Constits))) /= N_Null;\n    end Has_Non_Null_Visible_Refinement;\n \n    -----------------------------\n@@ -7387,22 +7386,21 @@ package body Einfo is\n    ---------------------------------\n \n    function Has_Null_Visible_Refinement (Id : E) return B is\n+      Constits : Elist_Id;\n+\n    begin\n       --  \"Refinement\" is a concept applicable only to abstract states\n \n       pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Constits := Refinement_Constituents (Id);\n \n-      if Has_Visible_Refinement (Id) then\n-         pragma Assert (Present (Refinement_Constituents (Id)));\n-\n-         --  For a refinement to be null, the state's sole constituent must be\n-         --  a null.\n+      --  For a refinement to be null, the state's sole constituent must be a\n+      --  null.\n \n-         return\n-           Nkind (Node (First_Elmt (Refinement_Constituents (Id)))) = N_Null;\n-      end if;\n-\n-      return False;\n+      return\n+        Has_Visible_Refinement (Id)\n+          and then Present (Constits)\n+          and then Nkind (Node (First_Elmt (Constits))) = N_Null;\n    end Has_Null_Visible_Refinement;\n \n    --------------------"}, {"sha": "0668369afa0d4ac6911f335079306ba589ae8ed7", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,6 +81,12 @@ package body Exp_Pakd is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Compute_Number_Components\n+      (N   : Node_Id;\n+       Typ : Entity_Id) return Node_Id;\n+   --  Build an expression that multiplies the length of the dimensions of the\n+   --  array, used to control array equality checks.\n+\n    procedure Compute_Linear_Subscript\n      (Atyp   : Entity_Id;\n       N      : Node_Id;\n@@ -260,6 +266,38 @@ package body Exp_Pakd is\n       return Adjusted;\n    end Revert_Storage_Order;\n \n+   -------------------------------\n+   -- Compute_Number_Components --\n+   -------------------------------\n+\n+   function Compute_Number_Components\n+      (N   : Node_Id;\n+       Typ : Entity_Id) return Node_Id\n+   is\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Len_Expr : Node_Id;\n+\n+   begin\n+      Len_Expr :=\n+        Make_Attribute_Reference (Loc,\n+          Attribute_Name => Name_Length,\n+          Prefix         => New_Occurrence_Of (Typ, Loc),\n+          Expressions    => New_List (Make_Integer_Literal (Loc, 1)));\n+\n+      for J in 2 .. Number_Dimensions (Typ) loop\n+         Len_Expr :=\n+           Make_Op_Multiply (Loc,\n+             Left_Opnd  => Len_Expr,\n+             Right_Opnd =>\n+               Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Length,\n+                Prefix         => New_Occurrence_Of (Typ, Loc),\n+                Expressions    => New_List (Make_Integer_Literal (Loc, J))));\n+      end loop;\n+\n+      return Len_Expr;\n+   end Compute_Number_Components;\n+\n    ------------------------------\n    -- Compute_Linear_Subscript --\n    ------------------------------\n@@ -451,7 +489,6 @@ package body Exp_Pakd is\n       PASize   : Uint;\n       Decl     : Node_Id;\n       PAT      : Entity_Id;\n-      Len_Dim  : Node_Id;\n       Len_Expr : Node_Id;\n       Len_Bits : Uint;\n       Bits_U1  : Node_Id;\n@@ -811,34 +848,7 @@ package body Exp_Pakd is\n          --  Build an expression for the length of the array in bits.\n          --  This is the product of the length of each of the dimensions\n \n-         declare\n-            J : Nat := 1;\n-\n-         begin\n-            Len_Expr := Empty; -- suppress junk warning\n-\n-            loop\n-               Len_Dim :=\n-                 Make_Attribute_Reference (Loc,\n-                   Attribute_Name => Name_Length,\n-                   Prefix         => New_Occurrence_Of (Typ, Loc),\n-                   Expressions    => New_List (\n-                     Make_Integer_Literal (Loc, J)));\n-\n-               if J = 1 then\n-                  Len_Expr := Len_Dim;\n-\n-               else\n-                  Len_Expr :=\n-                    Make_Op_Multiply (Loc,\n-                      Left_Opnd  => Len_Expr,\n-                      Right_Opnd => Len_Dim);\n-               end if;\n-\n-               J := J + 1;\n-               exit when J > Number_Dimensions (Typ);\n-            end loop;\n-         end;\n+         Len_Expr := Compute_Number_Components (Typ, Typ);\n \n          --  Temporarily attach the length expression to the tree and analyze\n          --  and resolve it, so that we can test its value. We assume that the\n@@ -1872,19 +1882,12 @@ package body Exp_Pakd is\n \n       LLexpr :=\n         Make_Op_Multiply (Loc,\n-          Left_Opnd =>\n-            Make_Attribute_Reference (Loc,\n-              Prefix         => New_Occurrence_Of (Ltyp, Loc),\n-              Attribute_Name => Name_Length),\n-          Right_Opnd =>\n-            Make_Integer_Literal (Loc, Component_Size (Ltyp)));\n+          Left_Opnd => Compute_Number_Components (N, Ltyp),\n+          Right_Opnd => Make_Integer_Literal (Loc, Component_Size (Ltyp)));\n \n       RLexpr :=\n         Make_Op_Multiply (Loc,\n-          Left_Opnd =>\n-            Make_Attribute_Reference (Loc,\n-              Prefix         => New_Occurrence_Of (Rtyp, Loc),\n-              Attribute_Name => Name_Length),\n+          Left_Opnd => Compute_Number_Components (N, Rtyp),\n           Right_Opnd =>\n             Make_Integer_Literal (Loc, Component_Size (Rtyp)));\n "}, {"sha": "13f5d734799169a2b870c147d663175b3cdd3a57", "filename": "gcc/ada/g-traceb.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fg-traceb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fg-traceb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-traceb.ads?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2014, AdaCore                     --\n+--                     Copyright (C) 1999-2016, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -58,14 +58,15 @@\n --  This capability is currently supported on the following targets:\n \n --     AiX PowerPC\n---     HP-UX\n --     GNU/Linux x86\n+--     GNU/Linux PowerPC\n --     LynxOS x86\n+--     LynxOS 178 xcoff PowerPC\n --     Solaris x86\n --     Solaris sparc\n --     VxWorks PowerPC\n --     VxWorks x86\n---     Windows NT/XP\n+--     Windows XP\n \n --  Note: see also GNAT.Traceback.Symbolic, a child unit in file g-trasym.ads\n --  providing symbolic trace back capability for a subset of the above targets."}, {"sha": "c5f9d01c932704aea5fba3f4792dd118ea258b97", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -1436,10 +1436,9 @@ package body Lib.Writ is\n             --  The dependency table also contains units that appear in the\n             --  context of a unit loaded through a limited_with clause. These\n             --  units are never analyzed, and thus the main unit does not\n-            --  really have a dependency on them.\n-            --  Subunits are always compiled in the context of the parent,\n-            --  and their file table entries are not properly decorated, they\n-            --  are recognized syntactically.\n+            --  really have a dependency on them. Subunits are always compiled\n+            --  in the context of the parent, and their file table entries are\n+            --  not properly decorated, they are recognized syntactically.\n \n             if Present (Cunit_Entity (Unum))\n               and then Ekind (Cunit_Entity (Unum)) = E_Void"}, {"sha": "d1c10a0c67eeaf625f79528802989081525df6e6", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,7 +51,7 @@ package body System.Soft_Links is\n \n    --  Needed for Vx6Cert (Vx653mc) GOS cert and ravenscar-cert runtimes,\n    --  VxMILS cert, ravenscar-cert and full runtimes, Vx 5 default runtime\n-   Stack_Limit : aliased System.Address;\n+   Stack_Limit : aliased System.Address := System.Null_Address;\n \n    pragma Export (C, Stack_Limit, \"__gnat_stack_limit\");\n "}, {"sha": "da5aba8c1b903975960cace925cfa7cf6a4040a8", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -5613,12 +5613,10 @@ package body Sem_Ch10 is\n \n       procedure Decorate_State (Ent : Entity_Id; Scop : Entity_Id) is\n       begin\n-         Set_Ekind                   (Ent, E_Abstract_State);\n-         Set_Etype                   (Ent, Standard_Void_Type);\n-         Set_Scope                   (Ent, Scop);\n-         Set_Encapsulating_State     (Ent, Empty);\n-         Set_Refinement_Constituents (Ent, New_Elmt_List);\n-         Set_Part_Of_Constituents    (Ent, New_Elmt_List);\n+         Set_Ekind               (Ent, E_Abstract_State);\n+         Set_Etype               (Ent, Standard_Void_Type);\n+         Set_Scope               (Ent, Scop);\n+         Set_Encapsulating_State (Ent, Empty);\n       end Decorate_State;\n \n       -------------------"}, {"sha": "894d7b564b3d90f5ce290a644f02ac094b494bb9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -8639,6 +8639,26 @@ package body Sem_Ch13 is\n               and then Pragma_Name (Ritem) = Name_Predicate\n             then\n                Add_Predicate (Ritem);\n+\n+            --  If the type is declared in an inner package it may be frozen\n+            --  outside of the package, and the generated pragma has not been\n+            --  analyzed yet, so capture the expression for the predicate\n+            --  function at this point.\n+\n+            elsif Nkind (Ritem) = N_Aspect_Specification\n+               and then Present (Aspect_Rep_Item (Ritem))\n+               and then Scope (Typ) /= Current_Scope\n+            then\n+               declare\n+                  Prag : constant Node_Id := Aspect_Rep_Item (Ritem);\n+\n+               begin\n+                  if Nkind (Prag) = N_Pragma\n+                    and then Pragma_Name (Prag) = Name_Predicate\n+                  then\n+                     Add_Predicate (Prag);\n+                  end if;\n+               end;\n             end if;\n \n             Next_Rep_Item (Ritem);"}, {"sha": "cd5fd8f8e9f2f48bd64e2bc54df17e678b0b62de", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -2513,6 +2513,13 @@ package body Sem_Ch3 is\n \n             Remove_Visible_Refinements (Corresponding_Spec (Context));\n          end if;\n+\n+         --  Verify that all abstract states found in any package declared in\n+         --  the input declarative list have proper refinements. The check is\n+         --  performed only when the context denotes a block, entry, package,\n+         --  protected, subprogram, or task body (SPARK RM 7.2.2(3)).\n+\n+         Check_State_Refinements (Context);\n       end if;\n    end Analyze_Declarations;\n "}, {"sha": "dc742dedc62eb1c5ac9d454dcef0d7a556a47de6", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -140,11 +140,13 @@ package body Sem_Ch7 is\n    --  tightened further???\n \n    function Requires_Completion_In_Body\n-     (Id      : Entity_Id;\n-      Pack_Id : Entity_Id) return Boolean;\n+     (Id                 : Entity_Id;\n+      Pack_Id            : Entity_Id;\n+      Do_Abstract_States : Boolean := False) return Boolean;\n    --  Subsidiary to routines Unit_Requires_Body and Unit_Requires_Body_Info.\n    --  Determine whether entity Id declared in package spec Pack_Id requires\n-   --  completion in a package body.\n+   --  completion in a package body. Flag Do_Abstract_Stats should be set when\n+   --  abstract states are to be considered in the completion test.\n \n    procedure Unit_Requires_Body_Info (Pack_Id : Entity_Id);\n    --  Outputs info messages showing why package Pack_Id requires a body. The\n@@ -940,15 +942,12 @@ package body Sem_Ch7 is\n       Id  : constant Node_Id := Defining_Entity (N);\n       Par : constant Node_Id := Parent_Spec (N);\n \n+      Is_Comp_Unit : constant Boolean :=\n+                       Nkind (Parent (N)) = N_Compilation_Unit;\n+\n       Body_Required : Boolean;\n       --  True when this package declaration requires a corresponding body\n \n-      Comp_Unit : Boolean;\n-      --  True when this package declaration is not a nested declaration\n-\n-      PF : Boolean;\n-      --  True when in the context of a declared pure library unit\n-\n    begin\n       if Debug_Flag_C then\n          Write_Str (\"==> package spec \");\n@@ -990,9 +989,9 @@ package body Sem_Ch7 is\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n \n-      --  Ada 2005 (AI-217): Check if the package has been illegally named\n-      --  in a limited-with clause of its own context. In this case the error\n-      --  has been previously notified by Analyze_Context.\n+      --  Ada 2005 (AI-217): Check if the package has been illegally named in\n+      --  a limited-with clause of its own context. In this case the error has\n+      --  been previously notified by Analyze_Context.\n \n       --     limited with Pkg; -- ERROR\n       --     package Pkg is ...\n@@ -1003,30 +1002,45 @@ package body Sem_Ch7 is\n \n       Push_Scope (Id);\n \n-      PF := Is_Pure (Enclosing_Lib_Unit_Entity);\n-      Set_Is_Pure (Id, PF);\n-\n+      Set_Is_Pure (Id, Is_Pure (Enclosing_Lib_Unit_Entity));\n       Set_Categorization_From_Pragmas (N);\n \n       Analyze (Specification (N));\n       Validate_Categorization_Dependency (N, Id);\n \n-      Body_Required := Unit_Requires_Body (Id);\n+      --  Determine whether the package requires a body. Abstract states are\n+      --  intentionally ignored because they do require refinement which can\n+      --  only come in a body, but at the same time they do not force the need\n+      --  for a body on their own (SPARK RM 7.1.4(4) and 7.2.2(3)).\n \n-      --  When this spec does not require an explicit body, we know that there\n-      --  are no entities requiring completion in the language sense; we call\n-      --  Check_Completion here only to ensure that any nested package\n-      --  declaration that requires an implicit body gets one. (In the case\n-      --  where a body is required, Check_Completion is called at the end of\n-      --  the body's declarative part.)\n+      Body_Required := Unit_Requires_Body (Id);\n \n       if not Body_Required then\n+\n+         --  If the package spec does not require an explicit body, then there\n+         --  are not entities requiring completion in the language sense. Call\n+         --  Check_Completion now to ensure that nested package declarations\n+         --  that require an implicit body get one. (In the case where a body\n+         --  is required, Check_Completion is called at the end of the body's\n+         --  declarative part.)\n+\n          Check_Completion;\n-      end if;\n \n-      Comp_Unit := Nkind (Parent (N)) = N_Compilation_Unit;\n+         --  If the package spec does not require an explicit body, then all\n+         --  abstract states declared in nested packages cannot possibly get\n+         --  a proper refinement (SPARK RM 7.2.2(3)). This check is performed\n+         --  only when the compilation unit is the main unit to allow for\n+         --  modular SPARK analysis where packages do not necessarily have\n+         --  bodies.\n+\n+         if Is_Comp_Unit then\n+            Check_State_Refinements\n+              (Context      => N,\n+               Is_Main_Unit => Parent (N) = Cunit (Main_Unit));\n+         end if;\n+      end if;\n \n-      if Comp_Unit then\n+      if Is_Comp_Unit then\n \n          --  Set Body_Required indication on the compilation unit node, and\n          --  determine whether elaboration warnings may be meaningful on it.\n@@ -1046,7 +1060,7 @@ package body Sem_Ch7 is\n       --  visibility tests that rely on the fact that we have exited the scope\n       --  of Id.\n \n-      if Comp_Unit then\n+      if Is_Comp_Unit then\n          Validate_RT_RAT_Component (N);\n       end if;\n \n@@ -2439,8 +2453,9 @@ package body Sem_Ch7 is\n    ---------------------------------\n \n    function Requires_Completion_In_Body\n-     (Id      : Entity_Id;\n-      Pack_Id : Entity_Id) return Boolean\n+     (Id                 : Entity_Id;\n+      Pack_Id            : Entity_Id;\n+      Do_Abstract_States : Boolean := False) return Boolean\n    is\n    begin\n       --  Always ignore child units. Child units get added to the entity list\n@@ -2473,7 +2488,7 @@ package body Sem_Ch7 is\n           (Ekind (Id) = E_Package\n             and then Id /= Pack_Id\n             and then not Has_Completion (Id)\n-            and then Unit_Requires_Body (Id))\n+            and then Unit_Requires_Body (Id, Do_Abstract_States))\n \n         or else\n           (Ekind (Id) = E_Incomplete_Type\n@@ -2488,7 +2503,7 @@ package body Sem_Ch7 is\n           (Ekind (Id) = E_Generic_Package\n             and then Id /= Pack_Id\n             and then not Has_Completion (Id)\n-            and then Unit_Requires_Body (Id))\n+            and then Unit_Requires_Body (Id, Do_Abstract_States))\n \n         or else\n           (Is_Generic_Subprogram (Id)\n@@ -2955,8 +2970,8 @@ package body Sem_Ch7 is\n    ------------------------\n \n    function Unit_Requires_Body\n-     (Pack_Id               : Entity_Id;\n-      Ignore_Abstract_State : Boolean := False) return Boolean\n+     (Pack_Id            : Entity_Id;\n+      Do_Abstract_States : Boolean := False) return Boolean\n    is\n       E : Entity_Id;\n \n@@ -3012,7 +3027,9 @@ package body Sem_Ch7 is\n          if Ekind (E) = E_Abstract_State then\n             null;\n \n-         elsif Requires_Completion_In_Body (E, Pack_Id) then\n+         elsif Requires_Completion_In_Body\n+                 (E, Pack_Id, Do_Abstract_States)\n+         then\n             Requires_Body := True;\n             exit;\n          end if;\n@@ -3025,7 +3042,7 @@ package body Sem_Ch7 is\n       --  a completion in a body (SPARK RM 7.1.4(4) and (6)). This check is not\n       --  performed if the caller requests this behavior.\n \n-      if not Ignore_Abstract_State\n+      if Do_Abstract_States\n         and then Ekind_In (Pack_Id, E_Generic_Package, E_Package)\n         and then Has_Non_Null_Abstract_State (Pack_Id)\n         and then Requires_Body"}, {"sha": "2963aed984caa93ffe3b117fa10e197cc6d35501", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,17 +53,14 @@ package Sem_Ch7 is\n    --  child for public child packages.\n \n    function Unit_Requires_Body\n-     (Pack_Id               : Entity_Id;\n-      Ignore_Abstract_State : Boolean := False) return Boolean;\n+     (Pack_Id            : Entity_Id;\n+      Do_Abstract_States : Boolean := False) return Boolean;\n    --  Determine whether package Pack_Id requires a body. A specification needs\n    --  a body if it contains declarations that require completion in the body.\n    --  A non-Ghost [generic] package does not require a body when it declares\n-   --  Ghost entities exclusively. If flag Ignore_Abstract_State is True, then\n-   --  the test for a non-null abstract state (which normally requires a body)\n-   --  is not carried out. The flag is not currently used, but may be useful\n-   --  in the future if we implement a compatibility mode which warns about\n-   --  possible incompatibilities if a SPARK 2014 program is compiled with a\n-   --  SPARK-unaware compiler.\n+   --  Ghost entities exclusively. When flag Do_Abstract_States is set to True,\n+   --  non-null abstract states are considered in determining the need for a\n+   --  body.\n \n    procedure May_Need_Implicit_Body (E : Entity_Id);\n    --  If a package declaration contains tasks or RACWs and does not require"}, {"sha": "442a71d9f0840553f3136bd49cce3d7185be10e0", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2685,7 +2685,6 @@ package body Sem_Ch9 is\n       Enter_Name (Obj_Id);\n       Set_Ekind                  (Obj_Id, E_Variable);\n       Set_Etype                  (Obj_Id, Typ);\n-      Set_Part_Of_Constituents   (Obj_Id, New_Elmt_List);\n       Set_SPARK_Pragma           (Obj_Id, SPARK_Mode_Pragma);\n       Set_SPARK_Pragma_Inherited (Obj_Id);\n \n@@ -2772,7 +2771,6 @@ package body Sem_Ch9 is\n       Enter_Name (Obj_Id);\n       Set_Ekind                  (Obj_Id, E_Variable);\n       Set_Etype                  (Obj_Id, Typ);\n-      Set_Part_Of_Constituents   (Obj_Id, New_Elmt_List);\n       Set_SPARK_Pragma           (Obj_Id, SPARK_Mode_Pragma);\n       Set_SPARK_Pragma_Inherited (Obj_Id);\n "}, {"sha": "0d75d220261bfb55cfb22204665cb4ceada9e749", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 193, "deletions": 127, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -3342,6 +3342,7 @@ package body Sem_Prag is\n       Errors   : constant Nat       := Serious_Errors_Detected;\n       Var_Decl : constant Node_Id   := Find_Related_Context (N);\n       Var_Id   : constant Entity_Id := Defining_Entity (Var_Decl);\n+      Constits : Elist_Id;\n       Encap_Id : Entity_Id;\n       Legal    : Boolean;\n \n@@ -3362,8 +3363,14 @@ package body Sem_Prag is\n \n       if Legal then\n          pragma Assert (Present (Encap_Id));\n+         Constits := Part_Of_Constituents (Encap_Id);\n+\n+         if No (Constits) then\n+            Constits := New_Elmt_List;\n+            Set_Part_Of_Constituents (Encap_Id, Constits);\n+         end if;\n \n-         Append_Elmt (Var_Id, Part_Of_Constituents (Encap_Id));\n+         Append_Elmt (Var_Id, Constits);\n          Set_Encapsulating_State (Var_Id, Encap_Id);\n       end if;\n \n@@ -10568,6 +10575,7 @@ package body Sem_Prag is\n \n                procedure Analyze_Part_Of_Option (Opt : Node_Id) is\n                   Encap    : constant Node_Id := Expression (Opt);\n+                  Constits : Elist_Id;\n                   Encap_Id : Entity_Id;\n                   Legal    : Boolean;\n \n@@ -10587,8 +10595,14 @@ package body Sem_Prag is\n \n                   if Legal then\n                      pragma Assert (Present (Encap_Id));\n+                     Constits := Part_Of_Constituents (Encap_Id);\n \n-                     Append_Elmt (State_Id, Part_Of_Constituents (Encap_Id));\n+                     if No (Constits) then\n+                        Constits := New_Elmt_List;\n+                        Set_Part_Of_Constituents (Encap_Id, Constits);\n+                     end if;\n+\n+                     Append_Elmt (State_Id, Constits);\n                      Set_Encapsulating_State (State_Id, Encap_Id);\n                   end if;\n                end Analyze_Part_Of_Option;\n@@ -10670,13 +10684,11 @@ package body Sem_Prag is\n \n                   --  Null states never come from source\n \n-                  Set_Comes_From_Source       (State_Id, not Is_Null);\n-                  Set_Parent                  (State_Id, State);\n-                  Set_Ekind                   (State_Id, E_Abstract_State);\n-                  Set_Etype                   (State_Id, Standard_Void_Type);\n-                  Set_Encapsulating_State     (State_Id, Empty);\n-                  Set_Refinement_Constituents (State_Id, New_Elmt_List);\n-                  Set_Part_Of_Constituents    (State_Id, New_Elmt_List);\n+                  Set_Comes_From_Source   (State_Id, not Is_Null);\n+                  Set_Parent              (State_Id, State);\n+                  Set_Ekind               (State_Id, E_Abstract_State);\n+                  Set_Etype               (State_Id, Standard_Void_Type);\n+                  Set_Encapsulating_State (State_Id, Empty);\n \n                   --  An abstract state declared within a Ghost region becomes\n                   --  Ghost (SPARK RM 6.9(2)).\n@@ -18193,7 +18205,8 @@ package body Sem_Prag is\n                -----------------------\n \n                procedure Propagate_Part_Of (Pack_Id : Entity_Id) is\n-                  Item_Id : Entity_Id;\n+                  Constits : Elist_Id;\n+                  Item_Id  : Entity_Id;\n \n                begin\n                   --  Traverse the entity chain of the package and set relevant\n@@ -18217,8 +18230,14 @@ package body Sem_Prag is\n                                               E_Variable)\n                      then\n                         Has_Item := True;\n+                        Constits := Part_Of_Constituents (State_Id);\n+\n+                        if No (Constits) then\n+                           Constits := New_Elmt_List;\n+                           Set_Part_Of_Constituents (State_Id, Constits);\n+                        end if;\n \n-                        Append_Elmt (Item_Id, Part_Of_Constituents (State_Id));\n+                        Append_Elmt (Item_Id, Constits);\n                         Set_Encapsulating_State (Item_Id, State_Id);\n \n                      --  Recursively handle nested packages and instantiations\n@@ -18248,6 +18267,7 @@ package body Sem_Prag is\n \n             --  Local variables\n \n+            Constits : Elist_Id;\n             Encap    : Node_Id;\n             Encap_Id : Entity_Id;\n             Item_Id  : Entity_Id;\n@@ -18334,7 +18354,14 @@ package body Sem_Prag is\n                   pragma Assert (Present (Encap_Id));\n \n                   if Ekind (Item_Id) = E_Constant then\n-                     Append_Elmt (Item_Id, Part_Of_Constituents (Encap_Id));\n+                     Constits := Part_Of_Constituents (Encap_Id);\n+\n+                     if No (Constits) then\n+                        Constits := New_Elmt_List;\n+                        Set_Part_Of_Constituents (Encap_Id, Constits);\n+                     end if;\n+\n+                     Append_Elmt (Item_Id, Constits);\n                      Set_Encapsulating_State (Item_Id, Encap_Id);\n \n                   --  Propagate the Part_Of indicator to the visible state\n@@ -23657,7 +23684,7 @@ package body Sem_Prag is\n             --  the pool of candidates. The seach continues because a single\n             --  dependence clause may have multiple matching refinements.\n \n-            if Inputs_Match and then Outputs_Match then\n+            if Inputs_Match and Outputs_Match then\n                Clause_Matched := True;\n                Remove (Ref_Clause);\n             end if;\n@@ -23769,45 +23796,49 @@ package body Sem_Prag is\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constits     : constant Elist_Id :=\n+                             Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             Posted       : Boolean := False;\n \n          begin\n-            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n \n-               --  The constituent acts as an input (SPARK RM 7.2.5(3))\n+                  --  The constituent acts as an input (SPARK RM 7.2.5(3))\n \n-               if Present (Body_Inputs)\n-                 and then Appears_In (Body_Inputs, Constit_Id)\n-               then\n-                  Error_Msg_Name_1 := Chars (State_Id);\n-                  SPARK_Msg_NE\n-                    (\"constituent & of state % must act as output in \"\n-                     & \"dependence refinement\", N, Constit_Id);\n+                  if Present (Body_Inputs)\n+                    and then Appears_In (Body_Inputs, Constit_Id)\n+                  then\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     SPARK_Msg_NE\n+                       (\"constituent & of state % must act as output in \"\n+                        & \"dependence refinement\", N, Constit_Id);\n \n-               --  The constituent is altogether missing (SPARK RM 7.2.5(3))\n+                  --  The constituent is altogether missing (SPARK RM 7.2.5(3))\n+\n+                  elsif No (Body_Outputs)\n+                    or else not Appears_In (Body_Outputs, Constit_Id)\n+                  then\n+                     if not Posted then\n+                        Posted := True;\n+                        SPARK_Msg_NE\n+                          (\"output state & must be replaced by all its \"\n+                           & \"constituents in dependence refinement\",\n+                           N, State_Id);\n+                     end if;\n \n-               elsif No (Body_Outputs)\n-                 or else not Appears_In (Body_Outputs, Constit_Id)\n-               then\n-                  if not Posted then\n-                     Posted := True;\n                      SPARK_Msg_NE\n-                       (\"output state & must be replaced by all its \"\n-                        & \"constituents in dependence refinement\",\n-                        N, State_Id);\n+                       (\"\\constituent & is missing in output list\",\n+                        N, Constit_Id);\n                   end if;\n \n-                  SPARK_Msg_NE\n-                    (\"\\constituent & is missing in output list\",\n-                     N, Constit_Id);\n-               end if;\n-\n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n          end Check_Constituent_Usage;\n \n          --  Local variables\n@@ -24328,6 +24359,8 @@ package body Sem_Prag is\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constits      : constant Elist_Id :=\n+                              Refinement_Constituents (State_Id);\n             Constit_Elmt  : Elmt_Id;\n             Constit_Id    : Entity_Id;\n             Has_Missing   : Boolean := False;\n@@ -24340,28 +24373,31 @@ package body Sem_Prag is\n             --  Process all the constituents of the state and note their modes\n             --  within the global refinement.\n \n-            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n \n-               if Present_Then_Remove (In_Constits, Constit_Id) then\n-                  Input_Seen := True;\n+                  if Present_Then_Remove (In_Constits, Constit_Id) then\n+                     Input_Seen := True;\n \n-               elsif Present_Then_Remove (In_Out_Constits, Constit_Id) then\n-                  In_Out_Seen := True;\n+                  elsif Present_Then_Remove (In_Out_Constits, Constit_Id) then\n+                     In_Out_Seen := True;\n \n-               elsif Present_Then_Remove (Out_Constits, Constit_Id) then\n-                  Output_Seen := True;\n+                  elsif Present_Then_Remove (Out_Constits, Constit_Id) then\n+                     Output_Seen := True;\n \n-               elsif Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n-                  Proof_In_Seen := True;\n+                  elsif Present_Then_Remove (Proof_In_Constits, Constit_Id)\n+                  then\n+                     Proof_In_Seen := True;\n \n-               else\n-                  Has_Missing := True;\n-               end if;\n+                  else\n+                     Has_Missing := True;\n+                  end if;\n \n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n \n             --  An In_Out constituent is a valid completion\n \n@@ -24462,40 +24498,45 @@ package body Sem_Prag is\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constits     : constant Elist_Id :=\n+                             Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             In_Seen      : Boolean := False;\n \n          begin\n-            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n \n-               --  At least one of the constituents appears as an Input\n+                  --  At least one of the constituents appears as an Input\n \n-               if Present_Then_Remove (In_Constits, Constit_Id) then\n-                  In_Seen := True;\n+                  if Present_Then_Remove (In_Constits, Constit_Id) then\n+                     In_Seen := True;\n \n-               --  A Proof_In constituent can refine an Input state as long as\n-               --  there is at least one Input constituent present.\n+                  --  A Proof_In constituent can refine an Input state as long\n+                  --  as there is at least one Input constituent present.\n \n-               elsif Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n-                  null;\n+                  elsif Present_Then_Remove (Proof_In_Constits, Constit_Id)\n+                  then\n+                     null;\n \n-               --  The constituent appears in the global refinement, but has\n-               --  mode In_Out or Output (SPARK RM 7.2.4(5)).\n+                  --  The constituent appears in the global refinement, but has\n+                  --  mode In_Out or Output (SPARK RM 7.2.4(5)).\n \n-               elsif Present_Then_Remove (In_Out_Constits, Constit_Id)\n-                 or else Present_Then_Remove (Out_Constits, Constit_Id)\n-               then\n-                  Error_Msg_Name_1 := Chars (State_Id);\n-                  SPARK_Msg_NE\n-                    (\"constituent & of state % must have mode `Input` in \"\n-                     & \"global refinement\", N, Constit_Id);\n-               end if;\n+                  elsif Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                    or else Present_Then_Remove (Out_Constits, Constit_Id)\n+                  then\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     SPARK_Msg_NE\n+                       (\"constituent & of state % must have mode `Input` in \"\n+                        & \"global refinement\", N, Constit_Id);\n+                  end if;\n \n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n \n             --  Not one of the constituents appeared as Input\n \n@@ -24557,47 +24598,51 @@ package body Sem_Prag is\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constits     : constant Elist_Id :=\n+                             Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             Posted       : Boolean := False;\n \n          begin\n-            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n \n-               if Present_Then_Remove (Out_Constits, Constit_Id) then\n-                  null;\n+                  if Present_Then_Remove (Out_Constits, Constit_Id) then\n+                     null;\n \n-               --  The constituent appears in the global refinement, but has\n-               --  mode Input, In_Out or Proof_In (SPARK RM 7.2.4(5)).\n+                  --  The constituent appears in the global refinement, but has\n+                  --  mode Input, In_Out or Proof_In (SPARK RM 7.2.4(5)).\n \n-               elsif Present_Then_Remove (In_Constits, Constit_Id)\n-                 or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n-                 or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n-               then\n-                  Error_Msg_Name_1 := Chars (State_Id);\n-                  SPARK_Msg_NE\n-                    (\"constituent & of state % must have mode `Output` in \"\n-                     & \"global refinement\", N, Constit_Id);\n+                  elsif Present_Then_Remove (In_Constits, Constit_Id)\n+                    or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                    or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n+                  then\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     SPARK_Msg_NE\n+                       (\"constituent & of state % must have mode `Output` in \"\n+                        & \"global refinement\", N, Constit_Id);\n \n-               --  The constituent is altogether missing (SPARK RM 7.2.5(3))\n+                  --  The constituent is altogether missing (SPARK RM 7.2.5(3))\n+\n+                  else\n+                     if not Posted then\n+                        Posted := True;\n+                        SPARK_Msg_NE\n+                          (\"`Output` state & must be replaced by all its \"\n+                           & \"constituents in global refinement\", N, State_Id);\n+                     end if;\n \n-               else\n-                  if not Posted then\n-                     Posted := True;\n                      SPARK_Msg_NE\n-                       (\"`Output` state & must be replaced by all its \"\n-                        & \"constituents in global refinement\", N, State_Id);\n+                       (\"\\constituent & is missing in output list\",\n+                        N, Constit_Id);\n                   end if;\n \n-                  SPARK_Msg_NE\n-                    (\"\\constituent & is missing in output list\",\n-                     N, Constit_Id);\n-               end if;\n-\n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n          end Check_Constituent_Usage;\n \n          --  Local variables\n@@ -24652,35 +24697,39 @@ package body Sem_Prag is\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constits      : constant Elist_Id :=\n+                              Refinement_Constituents (State_Id);\n             Constit_Elmt  : Elmt_Id;\n             Constit_Id    : Entity_Id;\n             Proof_In_Seen : Boolean := False;\n \n          begin\n-            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n \n-               --  At least one of the constituents appears as Proof_In\n+                  --  At least one of the constituents appears as Proof_In\n \n-               if Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n-                  Proof_In_Seen := True;\n+                  if Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n+                     Proof_In_Seen := True;\n \n-               --  The constituent appears in the global refinement, but has\n-               --  mode Input, In_Out or Output (SPARK RM 7.2.4(5)).\n+                  --  The constituent appears in the global refinement, but has\n+                  --  mode Input, In_Out or Output (SPARK RM 7.2.4(5)).\n \n-               elsif Present_Then_Remove (In_Constits, Constit_Id)\n-                 or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n-                 or else Present_Then_Remove (Out_Constits, Constit_Id)\n-               then\n-                  Error_Msg_Name_1 := Chars (State_Id);\n-                  SPARK_Msg_NE\n-                    (\"constituent & of state % must have mode `Proof_In` in \"\n-                     & \"global refinement\", N, Constit_Id);\n-               end if;\n+                  elsif Present_Then_Remove (In_Constits, Constit_Id)\n+                    or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                    or else Present_Then_Remove (Out_Constits, Constit_Id)\n+                  then\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     SPARK_Msg_NE\n+                       (\"constituent & of state % must have mode `Proof_In` \"\n+                        & \"in global refinement\", N, Constit_Id);\n+                  end if;\n \n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n \n             --  Not one of the constituents appeared as Proof_In\n \n@@ -25340,6 +25389,8 @@ package body Sem_Prag is\n                -------------------------\n \n                procedure Collect_Constituent is\n+                  Constits : Elist_Id;\n+\n                begin\n                   --  The Ghost policy in effect at the point of abstract state\n                   --  declaration and constituent must match (SPARK RM 6.9(15))\n@@ -25368,7 +25419,14 @@ package body Sem_Prag is\n                   --  and establish a relation between the refined state and\n                   --  the item.\n \n-                  Append_Elmt (Constit_Id, Refinement_Constituents (State_Id));\n+                  Constits := Refinement_Constituents (State_Id);\n+\n+                  if No (Constits) then\n+                     Constits := New_Elmt_List;\n+                     Set_Refinement_Constituents (State_Id, Constits);\n+                  end if;\n+\n+                  Append_Elmt (Constit_Id, Constits);\n                   Set_Encapsulating_State (Constit_Id, State_Id);\n \n                   --  The state has at least one legal constituent, mark the\n@@ -25482,6 +25540,7 @@ package body Sem_Prag is\n             --  Local variables\n \n             Constit_Id : Entity_Id;\n+            Constits   : Elist_Id;\n \n          --  Start of processing for Analyze_Constituent\n \n@@ -25503,7 +25562,14 @@ package body Sem_Prag is\n \n                   --  Collect the constituent in the list of refinement items\n \n-                  Append_Elmt (Constit, Refinement_Constituents (State_Id));\n+                  Constits := Refinement_Constituents (State_Id);\n+\n+                  if No (Constits) then\n+                     Constits := New_Elmt_List;\n+                     Set_Refinement_Constituents (State_Id, Constits);\n+                  end if;\n+\n+                  Append_Elmt (Constit, Constits);\n \n                   --  The state has at least one legal constituent, mark the\n                   --  start of the refinement region. The region ends when the"}, {"sha": "21157ec9086a2ae402f1968ca09c31a4cb4f59a8", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 179, "deletions": 53, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -3621,6 +3621,172 @@ package body Sem_Util is\n       end if;\n    end Check_Result_And_Post_State;\n \n+   -----------------------------\n+   -- Check_State_Refinements --\n+   -----------------------------\n+\n+   procedure Check_State_Refinements\n+     (Context      : Node_Id;\n+      Is_Main_Unit : Boolean := False)\n+   is\n+      procedure Check_Package (Pack : Node_Id);\n+      --  Verify that all abstract states of a [generic] package denoted by its\n+      --  declarative node Pack have proper refinement. Recursively verify the\n+      --  visible and private declarations of the [generic] package for other\n+      --  nested packages.\n+\n+      procedure Check_Packages_In (Decls : List_Id);\n+      --  Seek out [generic] package declarations within declarative list Decls\n+      --  and verify the status of their abstract state refinement.\n+\n+      function SPARK_Mode_Is_Off (N : Node_Id) return Boolean;\n+      --  Determine whether construct N is subject to pragma SPARK_Mode Off\n+\n+      -------------------\n+      -- Check_Package --\n+      -------------------\n+\n+      procedure Check_Package (Pack : Node_Id) is\n+         Body_Id : constant Entity_Id := Corresponding_Body (Pack);\n+         Spec    : constant Node_Id   := Specification (Pack);\n+         States  : constant Elist_Id  :=\n+                     Abstract_States (Defining_Entity (Pack));\n+\n+         State_Elmt : Elmt_Id;\n+         State_Id   : Entity_Id;\n+\n+      begin\n+         --  Do not verify proper state refinement when the package is subject\n+         --  to pragma SPARK_Mode Off because this disables the requirement for\n+         --  state refinement.\n+\n+         if SPARK_Mode_Is_Off (Pack) then\n+            null;\n+\n+         --  State refinement can only occur in a completing packge body. Do\n+         --  not verify proper state refinement when the body is subject to\n+         --  pragma SPARK_Mode Off because this disables the requirement for\n+         --  state refinement.\n+\n+         elsif Present (Body_Id)\n+           and then SPARK_Mode_Is_Off (Unit_Declaration_Node (Body_Id))\n+         then\n+            null;\n+\n+         --  Do not verify proper state refinement when the package is an\n+         --  instance as this check was already performed in the generic.\n+\n+         elsif Present (Generic_Parent (Spec)) then\n+            null;\n+\n+         --  Otherwise examine the contents of the package\n+\n+         else\n+            if Present (States) then\n+               State_Elmt := First_Elmt (States);\n+               while Present (State_Elmt) loop\n+                  State_Id := Node (State_Elmt);\n+\n+                  --  Emit an error when a non-null state lacks any form of\n+                  --  refinement.\n+\n+                  if not Is_Null_State (State_Id)\n+                    and then not Has_Null_Refinement (State_Id)\n+                    and then not Has_Non_Null_Refinement (State_Id)\n+                  then\n+                     Error_Msg_N (\"state & requires refinement\", State_Id);\n+                  end if;\n+\n+                  Next_Elmt (State_Elmt);\n+               end loop;\n+            end if;\n+\n+            Check_Packages_In (Visible_Declarations (Spec));\n+            Check_Packages_In (Private_Declarations (Spec));\n+         end if;\n+      end Check_Package;\n+\n+      -----------------------\n+      -- Check_Packages_In --\n+      -----------------------\n+\n+      procedure Check_Packages_In (Decls : List_Id) is\n+         Decl : Node_Id;\n+\n+      begin\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               if Nkind_In (Decl, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+               then\n+                  Check_Package (Decl);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end if;\n+      end Check_Packages_In;\n+\n+      -----------------------\n+      -- SPARK_Mode_Is_Off --\n+      -----------------------\n+\n+      function SPARK_Mode_Is_Off (N : Node_Id) return Boolean is\n+         Prag : constant Node_Id := SPARK_Pragma (Defining_Entity (N));\n+\n+      begin\n+         return\n+           Present (Prag) and then Get_SPARK_Mode_From_Annotation (Prag) = Off;\n+      end SPARK_Mode_Is_Off;\n+\n+   --  Start of processing for Check_State_Refinements\n+\n+   begin\n+      --  A block may declare a nested package\n+\n+      if Nkind (Context) = N_Block_Statement then\n+         Check_Packages_In (Declarations (Context));\n+\n+      --  An entry, protected, subprogram, or task body may declare a nested\n+      --  package.\n+\n+      elsif Nkind_In (Context, N_Entry_Body,\n+                               N_Protected_Body,\n+                               N_Subprogram_Body,\n+                               N_Task_Body)\n+      then\n+         --  Do not verify proper state refinement when the body is subject to\n+         --  pragma SPARK_Mode Off because this disables the requirement for\n+         --  state refinement.\n+\n+         if not SPARK_Mode_Is_Off (Context) then\n+            Check_Packages_In (Declarations (Context));\n+         end if;\n+\n+      --  A package body may declare a nested package\n+\n+      elsif Nkind (Context) = N_Package_Body then\n+         Check_Package (Unit_Declaration_Node (Corresponding_Spec (Context)));\n+\n+         --  Do not verify proper state refinement when the body is subject to\n+         --  pragma SPARK_Mode Off because this disables the requirement for\n+         --  state refinement.\n+\n+         if not SPARK_Mode_Is_Off (Context) then\n+            Check_Packages_In (Declarations (Context));\n+         end if;\n+\n+      --  A library level [generic] package may declare a nested package\n+\n+      elsif Nkind_In (Context, N_Generic_Package_Declaration,\n+                               N_Package_Declaration)\n+        and then Is_Main_Unit\n+      then\n+         Check_Package (Context);\n+      end if;\n+   end Check_State_Refinements;\n+\n    ------------------------------\n    -- Check_Unprotected_Access --\n    ------------------------------\n@@ -6294,9 +6460,9 @@ package body Sem_Util is\n            or else Is_Internal (E)\n          then\n             declare\n+               Decl     : constant Node_Id := Parent (E);\n                Prev     : Entity_Id;\n                Prev_Vis : Entity_Id;\n-               Decl     : constant Node_Id := Parent (E);\n \n             begin\n                --  If E is an implicit declaration, it cannot be the first\n@@ -9329,18 +9495,18 @@ package body Sem_Util is\n    -----------------------------\n \n    function Has_Non_Null_Refinement (Id : Entity_Id) return Boolean is\n+      Constits : Elist_Id;\n+\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Constits := Refinement_Constituents (Id);\n \n       --  For a refinement to be non-null, the first constituent must be\n       --  anything other than null.\n \n-      if Present (Refinement_Constituents (Id)) then\n-         return\n-           Nkind (Node (First_Elmt (Refinement_Constituents (Id)))) /= N_Null;\n-      end if;\n-\n-      return False;\n+      return\n+        Present (Constits)\n+          and then Nkind (Node (First_Elmt (Constits))) /= N_Null;\n    end Has_Non_Null_Refinement;\n \n    ------------------------\n@@ -9438,18 +9604,18 @@ package body Sem_Util is\n    -------------------------\n \n    function Has_Null_Refinement (Id : Entity_Id) return Boolean is\n+      Constits : Elist_Id;\n+\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Constits := Refinement_Constituents (Id);\n \n       --  For a refinement to be null, the state's sole constituent must be a\n       --  null.\n \n-      if Present (Refinement_Constituents (Id)) then\n-         return\n-           Nkind (Node (First_Elmt (Refinement_Constituents (Id)))) = N_Null;\n-      end if;\n-\n-      return False;\n+      return\n+        Present (Constits)\n+          and then Nkind (Node (First_Elmt (Constits))) = N_Null;\n    end Has_Null_Refinement;\n \n    -------------------------------\n@@ -18259,46 +18425,6 @@ package body Sem_Util is\n       end if;\n    end Require_Entity;\n \n-   -------------------------------\n-   -- Requires_State_Refinement --\n-   -------------------------------\n-\n-   function Requires_State_Refinement\n-     (Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id) return Boolean\n-   is\n-      Prag : constant Node_Id := SPARK_Pragma (Body_Id);\n-\n-   begin\n-      --  A package that does not define at least one abstract state cannot\n-      --  possibly require refinement.\n-\n-      if No (Abstract_States (Spec_Id)) then\n-         return False;\n-\n-      --  The package instroduces a single null state which does not merit\n-      --  refinement.\n-\n-      elsif Has_Null_Abstract_State (Spec_Id) then\n-         return False;\n-\n-      --  Check whether the package body is subject to pragma SPARK_Mode. If\n-      --  it is and the mode is Off, the package body is considered to be in\n-      --  regular Ada and does not require refinement.\n-\n-      elsif Present (Prag)\n-        and then Get_SPARK_Mode_From_Annotation (Prag) = Off\n-      then\n-         return False;\n-\n-      --  The spec defines at least one abstract state and the body has no way\n-      --  of circumventing the refinement.\n-\n-      else\n-         return True;\n-      end if;\n-   end Requires_State_Refinement;\n-\n    ------------------------------\n    -- Requires_Transient_Scope --\n    ------------------------------"}, {"sha": "5286ec6426e5eab5daca8c7564fca79bdff4e0e2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a4f9d54db67a17191dfad5dfb635465489be8c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=22a4f9d54db67a17191dfad5dfb635465489be8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -257,10 +257,6 @@ package Sem_Util is\n    --  not necessarily mean that CE could be raised, but a response of True\n    --  means that for sure CE cannot be raised.\n \n-   procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id);\n-   --  Verify the legality of reference Ref to variable Var_Id when the\n-   --  variable is a constituent of a single protected/task type.\n-\n    procedure Check_Dynamically_Tagged_Expression\n      (Expr        : Node_Id;\n       Typ         : Entity_Id;\n@@ -322,6 +318,10 @@ package Sem_Util is\n    --  Verify that the profile of nonvolatile function Func_Id does not contain\n    --  effectively volatile parameters or return type.\n \n+   procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id);\n+   --  Verify the legality of reference Ref to variable Var_Id when the\n+   --  variable is a constituent of a single protected/task type.\n+\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n@@ -331,6 +331,15 @@ package Sem_Util is\n    --  'Result and it contains an expression that evaluates differently in pre-\n    --  and post-state.\n \n+   procedure Check_State_Refinements\n+     (Context      : Node_Id;\n+      Is_Main_Unit : Boolean := False);\n+   --  Verify that all abstract states declared in a block statement, entry\n+   --  body, package body, protected body, subprogram body, task body, or a\n+   --  package declaration denoted by Context have proper refinement. Emit an\n+   --  error if this is not the case. Flag Is_Main_Unit should be set when\n+   --  Context denotes the main compilation unit.\n+\n    procedure Check_Unused_Body_States (Body_Id : Entity_Id);\n    --  Verify that all abstract states and objects declared in the state space\n    --  of package body Body_Id are used as constituents. Emit an error if this\n@@ -2007,12 +2016,6 @@ package Sem_Util is\n    --  This is used as a defense mechanism against ill-formed trees caused by\n    --  previous errors (particularly in -gnatq mode).\n \n-   function Requires_State_Refinement\n-     (Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id) return Boolean;\n-   --  Determine whether a package denoted by its spec and body entities\n-   --  requires refinement of abstract states.\n-\n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n    --  Id is a type entity. The result is True when temporaries of this type\n    --  need to be wrapped in a transient scope to be reclaimed properly when a"}]}