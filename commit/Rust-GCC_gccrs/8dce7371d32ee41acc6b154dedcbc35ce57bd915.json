{"sha": "8dce7371d32ee41acc6b154dedcbc35ce57bd915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjZTczNzFkMzJlZTQxYWNjNmIxNTRkZWRjYmMzNWNlNTdiZDkxNQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-16T09:50:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-16T09:50:19Z"}, "message": "[multiple changes]\n\n2017-11-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* atree.ads (Nkind_In): Add 10 and 11 parameter versions.\n\t* checks.adb (Install_Primitive_Elaboration_Check): Mark the setting of\n\tthe elaboration flag as elaboration code.\n\t* einfo.adb (Contract): Update the comments.\n\t(Ignore_SPARK_Mode_Pragmas): Update the comments.\n\t(SPARK_Aux_Pragma): Update the comments.\n\t(SPARK_Aux_Pragma_Inherited): Update the comments.\n\t(SPARK_Pragma): Update the comments. The attribute now applies\n\tto all types and abstract states.\n\t(SPARK_Pragma_Inherited): Update the comments. The attribute now\n\tapplies to all types and abstract states.\n\t(Set_Contract): Update the comments.\n\t(Set_Ignore_SPARK_Mode_Pragmas): Update the comments.\n\t(Set_SPARK_Aux_Pragma): Update the comments.\n\t(Set_SPARK_Aux_Pragma_Inherited): Update the comments.\n\t(Set_SPARK_Pragma): Update the comments. The attribute now applies to\n\tall types and abstract states.\n\t(Set_SPARK_Pragma_Inherited): Update the comments. The attribute now\n\tapplies to all types and abstract states.\n\t(Write_Field40_Name): Add output for SPARK_Pragma when it appears on a\n\ttype and abstract states.\n\t* einfo.ads: Update the documentation of attributes SPARK_Pragma and\n\tSPARK_Pragma_Inherited.  Both of them now apply to all types and\n\tabstract states.\n\t* exp_util.adb (Set_Elaboration_Flag): Mark the setting of the\n\telaboration flag as elaboration code.\n\t* sem_ch3.adb: Add with and use clauses for Sem_Elab.\n\t(Analyze_Full_Type_Declaration): Set the SPARK_Mode of the type. Record\n\ta derived type for later processing by the ABE mechanism.\n\t(Analyze_Incomplete_Type_Decl): Set the SPARK_Mode of the type.\n\t(Analyze_Private_Extension_Declaration): Set the SPARK_Mode of the\n\ttype.\n\t* sem_ch7.adb (Analyze_Private_Type_Declaration): Set the SPARK_Mode of\n\tthe type.\n\t* sem_elab.adb: Define the term \"early call region\".  Update the\n\tterminology for \"scenario\" and \"target\".  Update the architecture of\n\tthe ABE mechanism.  Update the steps which must be taken when adding a\n\tnew scenario.  Update the section on debugging ABE issues.  Add new\n\thash tables Early_Call_Regions and Recorded_SPARK_Scenarios.  Add new\n\ttable SPARK_Scenarios.  Hash table Elaboration_Context is now\n\tElaboration_Statuses.  The majority of Process_xxx routines have been\n\tupdated to better reflect their role.\n\t(Add_Unit): Reimplemented.\n\t(Check_Elaboration_Constituent): New routine.\n\t(Check_Elaboration_Scenarios): Verify previously recorded scenarios for\n\tconditional ABE issues. Verify previously recorded SPARK scenarios.\n\t(Check_SPARK_Derived_Type): New routine.\n\t(Check_SPARK_Instantiation): New routine.\n\t(Check_SPARK_Scenario): New routine.\n\t(Check_SPARK_Refined_State_Pragma): New routine.\n\t(Early_Call_Region): New routine.\n\t(Elaboration_Status): New routine.\n\t(Ensure_Prior_Elaboration): Add new formal parameter Prag_Nam. The\n\timplicit Elabotate[_All] pragma is now specified via Prag_Nam.\n\t(Find_Early_Call_Region): New routine.\n\t(Info_Scenario): Add output for refinement constituents.\n\t(Is_Recorded_SPARK_Scenario): New routine.\n\t(Is_Suitable_SPARK_Derived_Type): New routine.\n\t(Is_Suitable_SPARK_Instantiation): New routine.\n\t(Is_Suitable_SPARK_Refined_State_Pragma): New routine.\n\t(Is_Visited_Body): New routine.\n\t(Kill_Elaboration_Scenario): Reimplemented.\n\t(Output_Active_Scenarios): Add output for pragma Refined_State.\n\t(Output_SPARK_Refined_State_Pragma): New routine.\n\t(Process_Conditional_ABE_Call): Remove the use of -gnatd.v. The effect\n\tis now achieved by different means.\n\t(Process_Conditional_ABE_Call_SPARK): Verify that a call which precedes\n\tthe subprogram body appears within the early call region of the body.\n\tEither ensure the prior elaboration of external subprograms or verify\n\tthat the context meets the suitable elaboration requirement.\n\t(Process_Conditional_ABE_Instantiation_SPARK): New routine.\n\t(Record_Elaboration_Scenario): Reimplement the portion which enforces\n\tthe level restrictions of the static model. Add support for SPARK\n\tscenarios.\n\t(Record_SPARK_Elaboration_Scenario): New routine.\n\t(Reset_Visited_Bodies): New routine.\n\t(Set_Early_Call_Region): New routine.\n\t(Set_Elaboration_Status): New routine.\n\t(Set_Is_Recorded_SPARK_Scenario): New routine.\n\t(Update_Elaboration_Scenario): Reimplemented.\n\t* sem_elab.ads: Add new subtype Library_Or_Instantiation_Level.\n\t* sem_prag.adb (Analyze_Refined_State_In_Decl_Part): Save the pragma\n\tfor examination by the ABE Processing phase.\n\t(Create_Abstract_State): Save the SPARK_Mode from the context.\n\t* sem_util.adb (Is_Non_Preelaborable_Construct): New routine.\n\t* sem_util.ads (Is_Non_Preelaborable_Construct): New routine.\n\t* sinfo.adb (Is_Elaboration_Code): New routine.\n\t(Set_Is_Elaboration_Code): New routine.\n\t(Nkind_In): Add 10 and 11 parameter versions.\n\t* sinfo.ads: Add new attribute Is_Elaboration_Code along with\n\toccurrences in nodes.\n\t(Is_Elaboration_Code): New routine along with pragma Inline.\n\t(Set_Is_Elaboration_Code): New routine along with pragma Inline.\n\t(Nkind_In): Add 10 and 11 parameter versions.\n\n2017-11-16  Justin Squirek  <squirek@adacore.com>\n\n\t* sem.adb (Analyze): Remove requirement that the original node of N be\n\tan operator in the case that analysis on the node yields the relevant\n\toperator - so prefer it instead.\n\nFrom-SVN: r254802", "tree": {"sha": "b09f2d70cf0898be10ba5e7e3dfcbfe01080d4a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09f2d70cf0898be10ba5e7e3dfcbfe01080d4a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dce7371d32ee41acc6b154dedcbc35ce57bd915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dce7371d32ee41acc6b154dedcbc35ce57bd915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dce7371d32ee41acc6b154dedcbc35ce57bd915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dce7371d32ee41acc6b154dedcbc35ce57bd915/comments", "author": null, "committer": null, "parents": [{"sha": "d00301ecf48e655c08ba2554155521c2f5b0e35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00301ecf48e655c08ba2554155521c2f5b0e35e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d00301ecf48e655c08ba2554155521c2f5b0e35e"}], "stats": {"total": 7391, "additions": 5191, "deletions": 2200}, "files": [{"sha": "b18c46fef878503897d73794797f5b318b0b9da4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1,3 +1,106 @@\n+2017-11-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* atree.ads (Nkind_In): Add 10 and 11 parameter versions.\n+\t* checks.adb (Install_Primitive_Elaboration_Check): Mark the setting of\n+\tthe elaboration flag as elaboration code.\n+\t* einfo.adb (Contract): Update the comments.\n+\t(Ignore_SPARK_Mode_Pragmas): Update the comments.\n+\t(SPARK_Aux_Pragma): Update the comments.\n+\t(SPARK_Aux_Pragma_Inherited): Update the comments.\n+\t(SPARK_Pragma): Update the comments. The attribute now applies\n+\tto all types and abstract states.\n+\t(SPARK_Pragma_Inherited): Update the comments. The attribute now\n+\tapplies to all types and abstract states.\n+\t(Set_Contract): Update the comments.\n+\t(Set_Ignore_SPARK_Mode_Pragmas): Update the comments.\n+\t(Set_SPARK_Aux_Pragma): Update the comments.\n+\t(Set_SPARK_Aux_Pragma_Inherited): Update the comments.\n+\t(Set_SPARK_Pragma): Update the comments. The attribute now applies to\n+\tall types and abstract states.\n+\t(Set_SPARK_Pragma_Inherited): Update the comments. The attribute now\n+\tapplies to all types and abstract states.\n+\t(Write_Field40_Name): Add output for SPARK_Pragma when it appears on a\n+\ttype and abstract states.\n+\t* einfo.ads: Update the documentation of attributes SPARK_Pragma and\n+\tSPARK_Pragma_Inherited.  Both of them now apply to all types and\n+\tabstract states.\n+\t* exp_util.adb (Set_Elaboration_Flag): Mark the setting of the\n+\telaboration flag as elaboration code.\n+\t* sem_ch3.adb: Add with and use clauses for Sem_Elab.\n+\t(Analyze_Full_Type_Declaration): Set the SPARK_Mode of the type. Record\n+\ta derived type for later processing by the ABE mechanism.\n+\t(Analyze_Incomplete_Type_Decl): Set the SPARK_Mode of the type.\n+\t(Analyze_Private_Extension_Declaration): Set the SPARK_Mode of the\n+\ttype.\n+\t* sem_ch7.adb (Analyze_Private_Type_Declaration): Set the SPARK_Mode of\n+\tthe type.\n+\t* sem_elab.adb: Define the term \"early call region\".  Update the\n+\tterminology for \"scenario\" and \"target\".  Update the architecture of\n+\tthe ABE mechanism.  Update the steps which must be taken when adding a\n+\tnew scenario.  Update the section on debugging ABE issues.  Add new\n+\thash tables Early_Call_Regions and Recorded_SPARK_Scenarios.  Add new\n+\ttable SPARK_Scenarios.  Hash table Elaboration_Context is now\n+\tElaboration_Statuses.  The majority of Process_xxx routines have been\n+\tupdated to better reflect their role.\n+\t(Add_Unit): Reimplemented.\n+\t(Check_Elaboration_Constituent): New routine.\n+\t(Check_Elaboration_Scenarios): Verify previously recorded scenarios for\n+\tconditional ABE issues. Verify previously recorded SPARK scenarios.\n+\t(Check_SPARK_Derived_Type): New routine.\n+\t(Check_SPARK_Instantiation): New routine.\n+\t(Check_SPARK_Scenario): New routine.\n+\t(Check_SPARK_Refined_State_Pragma): New routine.\n+\t(Early_Call_Region): New routine.\n+\t(Elaboration_Status): New routine.\n+\t(Ensure_Prior_Elaboration): Add new formal parameter Prag_Nam. The\n+\timplicit Elabotate[_All] pragma is now specified via Prag_Nam.\n+\t(Find_Early_Call_Region): New routine.\n+\t(Info_Scenario): Add output for refinement constituents.\n+\t(Is_Recorded_SPARK_Scenario): New routine.\n+\t(Is_Suitable_SPARK_Derived_Type): New routine.\n+\t(Is_Suitable_SPARK_Instantiation): New routine.\n+\t(Is_Suitable_SPARK_Refined_State_Pragma): New routine.\n+\t(Is_Visited_Body): New routine.\n+\t(Kill_Elaboration_Scenario): Reimplemented.\n+\t(Output_Active_Scenarios): Add output for pragma Refined_State.\n+\t(Output_SPARK_Refined_State_Pragma): New routine.\n+\t(Process_Conditional_ABE_Call): Remove the use of -gnatd.v. The effect\n+\tis now achieved by different means.\n+\t(Process_Conditional_ABE_Call_SPARK): Verify that a call which precedes\n+\tthe subprogram body appears within the early call region of the body.\n+\tEither ensure the prior elaboration of external subprograms or verify\n+\tthat the context meets the suitable elaboration requirement.\n+\t(Process_Conditional_ABE_Instantiation_SPARK): New routine.\n+\t(Record_Elaboration_Scenario): Reimplement the portion which enforces\n+\tthe level restrictions of the static model. Add support for SPARK\n+\tscenarios.\n+\t(Record_SPARK_Elaboration_Scenario): New routine.\n+\t(Reset_Visited_Bodies): New routine.\n+\t(Set_Early_Call_Region): New routine.\n+\t(Set_Elaboration_Status): New routine.\n+\t(Set_Is_Recorded_SPARK_Scenario): New routine.\n+\t(Update_Elaboration_Scenario): Reimplemented.\n+\t* sem_elab.ads: Add new subtype Library_Or_Instantiation_Level.\n+\t* sem_prag.adb (Analyze_Refined_State_In_Decl_Part): Save the pragma\n+\tfor examination by the ABE Processing phase.\n+\t(Create_Abstract_State): Save the SPARK_Mode from the context.\n+\t* sem_util.adb (Is_Non_Preelaborable_Construct): New routine.\n+\t* sem_util.ads (Is_Non_Preelaborable_Construct): New routine.\n+\t* sinfo.adb (Is_Elaboration_Code): New routine.\n+\t(Set_Is_Elaboration_Code): New routine.\n+\t(Nkind_In): Add 10 and 11 parameter versions.\n+\t* sinfo.ads: Add new attribute Is_Elaboration_Code along with\n+\toccurrences in nodes.\n+\t(Is_Elaboration_Code): New routine along with pragma Inline.\n+\t(Set_Is_Elaboration_Code): New routine along with pragma Inline.\n+\t(Nkind_In): Add 10 and 11 parameter versions.\n+\n+2017-11-16  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem.adb (Analyze): Remove requirement that the original node of N be\n+\tan operator in the case that analysis on the node yields the relevant\n+\toperator - so prefer it instead.\n+\n 2017-11-16  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch6.adb (Create_Extra_Formals): The type of the BIP_Object_Access"}, {"sha": "0a4416488ac4f040d59a8b1b01f87a503b730f88", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1866,6 +1866,42 @@ package body Atree is\n       return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6, V7, V8, V9);\n    end Nkind_In;\n \n+   function Nkind_In\n+     (N   : Node_Id;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6, V7, V8, V9, V10);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N   : Node_Id;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind;\n+      V11 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6, V7, V8, V9, V10,\n+                                  V11);\n+   end Nkind_In;\n+\n    --------\n    -- No --\n    --------"}, {"sha": "b01f87347d996935d3ccb64f66e394b81ef9d979", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -746,6 +746,33 @@ package Atree is\n       V8 : Node_Kind;\n       V9 : Node_Kind) return Boolean;\n \n+   function Nkind_In\n+     (N   : Node_Id;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (N   : Node_Id;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind;\n+      V11 : Node_Kind) return Boolean;\n+\n    pragma Inline (Nkind_In);\n    --  Inline all above functions\n "}, {"sha": "f47e63511eefd961ebd0897da57080c0f02efe73", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -7841,10 +7841,11 @@ package body Checks is\n       Subp_Id   : constant Entity_Id  := Unique_Defining_Entity (Subp_Body);\n       Subp_Decl : constant Node_Id    := Unit_Declaration_Node (Subp_Id);\n \n-      Decls   : List_Id;\n-      Flag_Id : Entity_Id;\n-      Set_Ins : Node_Id;\n-      Tag_Typ : Entity_Id;\n+      Decls    : List_Id;\n+      Flag_Id  : Entity_Id;\n+      Set_Ins  : Node_Id;\n+      Set_Stmt : Node_Id;\n+      Tag_Typ  : Entity_Id;\n \n    --  Start of processing for Install_Primitive_Elaboration_Check\n \n@@ -7878,8 +7879,8 @@ package body Checks is\n       elsif Nkind (Context) = N_Compilation_Unit then\n          return;\n \n-      --  Only nonabstract library-level source primitives are considered for\n-      --  this check.\n+      --  Do not consider anything other than nonabstract library-level source\n+      --  primitives.\n \n       elsif not\n         (Comes_From_Source (Subp_Id)\n@@ -7996,10 +7997,18 @@ package body Checks is\n       --  Generate:\n       --    E := True;\n \n-      Insert_After_And_Analyze (Set_Ins,\n+      Set_Stmt :=\n         Make_Assignment_Statement (Loc,\n           Name       => New_Occurrence_Of (Flag_Id, Loc),\n-          Expression => New_Occurrence_Of (Standard_True, Loc)));\n+          Expression => New_Occurrence_Of (Standard_True, Loc));\n+\n+      --  Mark the assignment statement as elaboration code. This allows the\n+      --  early call region mechanism (see Sem_Elab) to properly ignore such\n+      --  assignments even though they are non-preelaborable code.\n+\n+      Set_Is_Elaboration_Code (Set_Stmt);\n+\n+      Insert_After_And_Analyze (Set_Ins, Set_Stmt);\n    end Install_Primitive_Elaboration_Check;\n \n    --------------------------"}, {"sha": "1312965b3730460450e85d28ccd7732165640a1a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1265,14 +1265,14 @@ package body Einfo is\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Body,\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+         Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n            or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Entry,               --  overloadable\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -1281,11 +1281,11 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void);                --  special purpose\n       return Node34 (Id);\n    end Contract;\n \n@@ -1996,12 +1996,12 @@ package body Einfo is\n    function Ignore_SPARK_Mode_Pragmas (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Body,      --  concurrent types\n                        E_Protected_Type,\n                        E_Task_Body,\n                        E_Task_Type)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Entry,               --  overloadable\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -2010,7 +2010,7 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       return Flag301 (Id);\n@@ -3322,10 +3322,10 @@ package body Einfo is\n    function SPARK_Aux_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       return Node41 (Id);\n@@ -3334,10 +3334,10 @@ package body Einfo is\n    function SPARK_Aux_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       return Flag266 (Id);\n@@ -3346,15 +3346,11 @@ package body Einfo is\n    function SPARK_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type)\n-          or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Abstract_State,      --  overloadable\n+                       E_Entry,\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -3363,26 +3359,27 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void                  --  special purpose\n+           or else\n+         Ekind_In (Id, E_Protected_Body,      --  types\n+                       E_Task_Body)\n+           or else\n+         Is_Type (Id));\n       return Node40 (Id);\n    end SPARK_Pragma;\n \n    function SPARK_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type)\n-          or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Abstract_State,      --  overloadable\n+                       E_Entry,\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -3391,11 +3388,16 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void                  --  special purpose\n+           or else\n+         Ekind_In (Id, E_Protected_Body,      --  types\n+                       E_Task_Body)\n+           or else\n+         Is_Type (Id));\n       return Flag265 (Id);\n    end SPARK_Pragma_Inherited;\n \n@@ -4092,14 +4094,14 @@ package body Einfo is\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Body,\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+         Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n            or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Entry,               --  overloadable\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -4108,11 +4110,11 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void);                --  special purpose\n       Set_Node34 (Id, V);\n    end Set_Contract;\n \n@@ -5173,12 +5175,12 @@ package body Einfo is\n    procedure Set_Ignore_SPARK_Mode_Pragmas (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Body,      --  concurrent types\n                        E_Protected_Type,\n                        E_Task_Body,\n                        E_Task_Type)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Entry,               --  overloadable\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -5187,7 +5189,7 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       Set_Flag301 (Id, V);\n@@ -6546,10 +6548,10 @@ package body Einfo is\n    procedure Set_SPARK_Aux_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       Set_Node41 (Id, V);\n@@ -6558,10 +6560,10 @@ package body Einfo is\n    procedure Set_SPARK_Aux_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+        (Ekind_In (Id, E_Protected_Type,      --  concurrent types\n                        E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body));\n       Set_Flag266 (Id, V);\n@@ -6570,15 +6572,11 @@ package body Einfo is\n    procedure Set_SPARK_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type)\n-          or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Abstract_State,      --  overloadable\n+                       E_Entry,\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -6587,26 +6585,27 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void                  --  special purpose\n+           or else\n+         Ekind_In (Id, E_Protected_Body,      --  types\n+                       E_Task_Body)\n+           or else\n+         Is_Type (Id));\n       Set_Node40 (Id, V);\n    end Set_SPARK_Pragma;\n \n    procedure Set_SPARK_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type)\n-          or else\n-         Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Constant,            --  objects\n                        E_Variable)\n           or else\n-         Ekind_In (Id, E_Entry,            --  overloadable variants\n+         Ekind_In (Id, E_Abstract_State,      --  overloadable\n+                       E_Entry,\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -6615,11 +6614,16 @@ package body Einfo is\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n-         Ekind_In (Id, E_Generic_Package,  --  package variants\n+         Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Void);             --  special purpose\n+         Ekind (Id) = E_Void                  --  special purpose\n+           or else\n+         Ekind_In (Id, E_Protected_Body,      --  types\n+                       E_Task_Body)\n+           or else\n+         Is_Type (Id));\n       Set_Flag265 (Id, V);\n    end Set_SPARK_Pragma_Inherited;\n \n@@ -11200,7 +11204,8 @@ package body Einfo is\n    procedure Write_Field40_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Constant\n+         when E_Abstract_State\n+            | E_Constant\n             | E_Entry\n             | E_Entry_Family\n             | E_Function\n@@ -11212,12 +11217,11 @@ package body Einfo is\n             | E_Package_Body\n             | E_Procedure\n             | E_Protected_Body\n-            | E_Protected_Type\n             | E_Subprogram_Body\n             | E_Task_Body\n-            | E_Task_Type\n             | E_Variable\n             | E_Void\n+            | Type_Kind\n          =>\n             Write_Str (\"SPARK_Pragma\");\n "}, {"sha": "ab056113c08056eb17293fc33e61891d7d36bcc0", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -4284,20 +4284,42 @@ package Einfo is\n --       inherited, rather than a local one.\n \n --    SPARK_Pragma (Node40)\n---       Present in concurrent type, constant, entry, operator, [generic]\n---       package, package body, [generic] subprogram, subprogram body and\n---       variable entities. Points to the N_Pragma node that applies to the\n---       initial declaration or body. This is either set by a local SPARK_Mode\n---       pragma or is inherited from the context (from an outer scope for the\n---       spec case or from the spec for the body case). In the case where it\n---       is inherited the flag SPARK_Pragma_Inherited is set. Empty if no\n---       SPARK_Mode pragma is applicable.\n+--       Present in the following entities:\n+--\n+--         abstract states\n+--         constants\n+--         entries\n+--         operators\n+--         [generic] packages\n+--         package bodies\n+--         [generic] subprograms\n+--         subprogram bodies\n+--         variables\n+--         types\n+--\n+--       Points to the N_Pragma node that applies to the initial declaration or\n+--       body. This is either set by a local SPARK_Mode pragma or is inherited\n+--       from the context (from an outer scope for the spec case or from the\n+--       spec for the body case). In the case where the attribute is inherited,\n+--       flag SPARK_Pragma_Inherited is set. Empty if no SPARK_Mode pragma is\n+--       applicable.\n \n --    SPARK_Pragma_Inherited (Flag265)\n---       Present in concurrent type, constant, entry, operator, [generic]\n---       package, package body, [generic] subprogram, subprogram body and\n---       variable entities. Set if the SPARK_Pragma attribute points to a\n---       pragma that is inherited, rather than a local one.\n+--       Present in the following entities:\n+--\n+--         abstract states\n+--         constants\n+--         entries\n+--         operators\n+--         [generic] packages\n+--         package bodies\n+--         [generic] subprograms\n+--         subprogram bodies\n+--         variables\n+--         types\n+--\n+--       Set if the SPARK_Pragma attribute points to an inherited pragma rather\n+--       than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -5617,6 +5639,7 @@ package Einfo is\n    --    Derived_Type_Link                   (Node31)\n    --    No_Tagged_Streams_Pragma            (Node32)\n    --    Linker_Section_Pragma               (Node33)\n+   --    SPARK_Pragma                        (Node40)\n \n    --    Depends_On_Private                  (Flag14)\n    --    Disable_Controlled                  (Flag253)\n@@ -5687,6 +5710,7 @@ package Einfo is\n    --    Partial_View_Has_Unknown_Discr      (Flag280)\n    --    Size_Depends_On_Discriminant        (Flag177)\n    --    Size_Known_At_Compile_Time          (Flag92)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Strict_Alignment                    (Flag145)  (base type only)\n    --    Suppress_Initialization             (Flag105)\n    --    Treat_As_Volatile                   (Flag41)\n@@ -5718,9 +5742,11 @@ package Einfo is\n    --    Body_References                     (Elist16)\n    --    Non_Limited_View                    (Node19)\n    --    Encapsulating_State                 (Node32)\n+   --    SPARK_Pragma                        (Node40)\n    --    From_Limited_With                   (Flag159)\n    --    Has_Partial_Visible_Refinement      (Flag296)\n    --    Has_Visible_Refinement              (Flag263)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Has_Non_Limited_View                (synth)\n    --    Has_Non_Null_Visible_Refinement     (synth)\n    --    Has_Null_Visible_Refinement         (synth)\n@@ -6488,11 +6514,9 @@ package Einfo is\n    --    Anonymous_Object                    (Node30)\n    --    Contract                            (Node34)\n    --    Entry_Max_Queue_Lengths_Array       (Node35)\n-   --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n-   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Uses_Lock_Free                      (Flag188)\n    --    First_Component                     (synth)\n    --    First_Component_Or_Discriminant     (synth)\n@@ -6506,7 +6530,6 @@ package Einfo is\n    --  E_Record_Subtype\n    --    Direct_Primitive_Operations         (Elist10)\n    --    Access_Disp_Table                   (Elist16)  (base type only)\n-   --    Access_Disp_Table_Elab_Flag         (Node30)   (base type only)\n    --    Cloned_Subtype                      (Node16)   (subtype case only)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Concurrent_Type       (Node18)\n@@ -6518,6 +6541,7 @@ package Einfo is\n    --    Interfaces                          (Elist25)\n    --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    Underlying_Record_View              (Node28)   (base type only)\n+   --    Access_Disp_Table_Elab_Flag         (Node30)   (base type only)\n    --    Component_Alignment                 (special)  (base type only)\n    --    C_Pass_By_Copy                      (Flag125)  (base type only)\n    --    Has_Dispatch_Table                  (Flag220)  (base tagged type only)\n@@ -6640,15 +6664,13 @@ package Einfo is\n    --    Relative_Deadline_Variable          (Node28)   (base type only)\n    --    Anonymous_Object                    (Node30)\n    --    Contract                            (Node34)\n-   --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Delay_Cleanups                      (Flag114)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n    --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n-   --    SPARK_Pragma_Inherited              (Flag265)\n    --    First_Component                     (synth)\n    --    First_Component_Or_Discriminant     (synth)\n    --    Has_Entries                         (synth)"}, {"sha": "c5e565b41ae14992427b86abc7d9d91a97cf61d0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -12459,11 +12459,19 @@ package body Exp_Util is\n \n          else\n             Check_Restriction (No_Elaboration_Code, N);\n+\n             Asn :=\n               Make_Assignment_Statement (Loc,\n                 Name       => New_Occurrence_Of (Ent, Loc),\n                 Expression => Make_Integer_Literal (Loc, Uint_1));\n \n+            --  Mark the assignment statement as elaboration code. This allows\n+            --  the early call region mechanism (see Sem_Elab) to properly\n+            --  ignore such assignments even though they are non-preelaborable\n+            --  code.\n+\n+            Set_Is_Elaboration_Code (Asn);\n+\n             if Nkind (Parent (N)) = N_Subunit then\n                Insert_After (Corresponding_Stub (Parent (N)), Asn);\n             else"}, {"sha": "c0c896208817d48734c0bef818735eda1a543e8e", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -740,17 +740,32 @@ package body Sem is\n \n       Debug_A_Exit (\"analyzing  \", N, \"  (done)\");\n \n-      --  Mark relevant use-type and use-package clauses as effective using the\n-      --  original node, because constant folding may have occurred and removed\n-      --  references that need to be examined. If the node in question is\n-      --  overloaded then this is deferred until resolution.\n-\n-      if Nkind (Original_Node (N)) in N_Op\n-        and then Present (Entity (Original_Node (N)))\n-        and then not Is_Overloaded (Original_Node (N))\n-      then\n-         Mark_Use_Clauses (Original_Node (N));\n-      end if;\n+      --  Mark relevant use-type and use-package clauses as effective\n+      --  preferring the original node over the analyzed one in the case that\n+      --  constant folding has occurred and removed references that need to be\n+      --  examined. Also, if the node in question is overloaded then this is\n+      --  deferred until resolution.\n+\n+      declare\n+         Operat : Node_Id := Empty;\n+      begin\n+         --  Attempt to obtain a checkable operator node\n+\n+         if Nkind (Original_Node (N)) in N_Op then\n+            Operat := Original_Node (N);\n+         elsif Nkind (N) in N_Op then\n+            Operat := N;\n+         end if;\n+\n+         --  Mark the operator\n+\n+         if Present (Operat)\n+           and then Present (Entity (Operat))\n+           and then not Is_Overloaded (Operat)\n+         then\n+            Mark_Use_Clauses (Operat);\n+         end if;\n+      end;\n \n       --  Now that we have analyzed the node, we call the expander to perform\n       --  possible expansion. We skip this for subexpressions, because we don't"}, {"sha": "2c75337d3b18e9723e40b41db50603f08dcbf38a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -61,6 +61,7 @@ with Sem_Ch13;  use Sem_Ch13;\n with Sem_Dim;   use Sem_Dim;\n with Sem_Disp;  use Sem_Disp;\n with Sem_Dist;  use Sem_Dist;\n+with Sem_Elab;  use Sem_Elab;\n with Sem_Elim;  use Sem_Elim;\n with Sem_Eval;  use Sem_Eval;\n with Sem_Mech;  use Sem_Mech;\n@@ -3120,6 +3121,11 @@ package body Sem_Ch3 is\n       if not Analyzed (T) then\n          Set_Analyzed (T);\n \n+         --  Set the SPARK mode from the current context\n+\n+         Set_SPARK_Pragma           (T, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (T);\n+\n          case Nkind (Def) is\n             when N_Access_To_Subprogram_Definition =>\n                Access_Subprogram_Declaration (T, Def);\n@@ -3167,6 +3173,11 @@ package body Sem_Ch3 is\n                   Set_Has_Predicates (Def_Id);\n                end if;\n \n+               --  Save the scenario for examination by the ABE Processing\n+               --  phase.\n+\n+               Record_Elaboration_Scenario (N);\n+\n             when N_Enumeration_Type_Definition =>\n                Enumeration_Type_Declaration (T, Def);\n \n@@ -3362,10 +3373,15 @@ package body Sem_Ch3 is\n \n       T := Find_Type_Name (N);\n \n-      Set_Ekind (T, E_Incomplete_Type);\n-      Init_Size_Align (T);\n-      Set_Is_First_Subtype (T, True);\n-      Set_Etype (T, T);\n+      Set_Ekind            (T, E_Incomplete_Type);\n+      Set_Etype            (T, T);\n+      Set_Is_First_Subtype (T);\n+      Init_Size_Align      (T);\n+\n+      --  Set the SPARK mode from the current context\n+\n+      Set_SPARK_Pragma           (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (T);\n \n       --  Ada 2005 (AI-326): Minimum decoration to give support to tagged\n       --  incomplete types.\n@@ -5065,6 +5081,11 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T);\n       Make_Class_Wide_Type (T);\n \n+      --  Set the SPARK mode from the current context\n+\n+      Set_SPARK_Pragma           (T, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (T);\n+\n       if Unknown_Discriminants_Present (N) then\n          Set_Discriminant_Constraint (T, No_Elist);\n       end if;"}, {"sha": "2e035c785757c144e9fcee512e96d7907a0d71aa", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1850,6 +1850,11 @@ package body Sem_Ch7 is\n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n \n+      --  Set the SPARK mode from the current context\n+\n+      Set_SPARK_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Id);\n+\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;"}, {"sha": "8c5611c79046bd57c1ef117ed519162006ca6256", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 4265, "deletions": 2092, "changes": 6357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915"}, {"sha": "bfb174d695f5eb155f742cb27be92fcfdca15081", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -93,6 +93,10 @@ package Sem_Elab is\n       --  This value is used to indicate that none of the levels above are in\n       --  effect.\n \n+   subtype Any_Library_Level is Enclosing_Level_Kind range\n+     Generic_Package_Spec ..\n+     Package_Body;\n+\n    subtype Generic_Library_Level is Enclosing_Level_Kind range\n      Generic_Package_Spec ..\n      Generic_Package_Body;\n@@ -101,8 +105,8 @@ package Sem_Elab is\n      Package_Spec ..\n      Package_Body;\n \n-   subtype Any_Library_Level is Enclosing_Level_Kind range\n-     Generic_Package_Spec ..\n+   subtype Library_Or_Instantiation_Level is Enclosing_Level_Kind range\n+     Instantiation ..\n      Package_Body;\n \n    function Find_Enclosing_Level (N : Node_Id) return Enclosing_Level_Kind;"}, {"sha": "219ccf53474abc021c0695b7328abaabb5140d6f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -64,6 +64,7 @@ with Sem_Ch12;  use Sem_Ch12;\n with Sem_Ch13;  use Sem_Ch13;\n with Sem_Disp;  use Sem_Disp;\n with Sem_Dist;  use Sem_Dist;\n+with Sem_Elab;  use Sem_Elab;\n with Sem_Elim;  use Sem_Elim;\n with Sem_Eval;  use Sem_Eval;\n with Sem_Intr;  use Sem_Intr;\n@@ -11563,6 +11564,11 @@ package body Sem_Prag is\n                   Set_Etype               (State_Id, Standard_Void_Type);\n                   Set_Encapsulating_State (State_Id, Empty);\n \n+                  --  Set the SPARK mode from the current context\n+\n+                  Set_SPARK_Pragma           (State_Id, SPARK_Mode_Pragma);\n+                  Set_SPARK_Pragma_Inherited (State_Id);\n+\n                   --  An abstract state declared within a Ghost region becomes\n                   --  Ghost (SPARK RM 6.9(2)).\n \n@@ -27756,6 +27762,10 @@ package body Sem_Prag is\n          return;\n       end if;\n \n+      --  Save the scenario for examination by the ABE Processing phase\n+\n+      Record_Elaboration_Scenario (N);\n+\n       --  Replicate the abstract states declared by the package because the\n       --  matching algorithm will consume states.\n "}, {"sha": "056703cb1b5128c96e351616f1ae08e295ad5d80", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -14634,6 +14634,442 @@ package body Sem_Util is\n       end case;\n    end Is_Name_Reference;\n \n+   ------------------------------------\n+   -- Is_Non_Preelaborable_Construct --\n+   ------------------------------------\n+\n+   function Is_Non_Preelaborable_Construct (N : Node_Id) return Boolean is\n+\n+      --  NOTE: the routines within Is_Non_Preelaborable_Construct are\n+      --  intentionally unnested to avoid deep indentation of code.\n+\n+      Non_Preelaborable : exception;\n+      --  This exception is raised when the construct violates preelaborability\n+      --  to terminate the recursion.\n+\n+      procedure Visit (Nod : Node_Id);\n+      --  Semantically inspect construct Nod to determine whether it violates\n+      --  preelaborability. This routine raises Non_Preelaborable.\n+\n+      procedure Visit_List (List : List_Id);\n+      pragma Inline (Visit_List);\n+      --  Invoke Visit on each element of list List. This routine raises\n+      --  Non_Preelaborable.\n+\n+      procedure Visit_Pragma (Prag : Node_Id);\n+      pragma Inline (Visit_Pragma);\n+      --  Semantically inspect pragma Prag to determine whether it violates\n+      --  preelaborability. This routine raises Non_Preelaborable.\n+\n+      procedure Visit_Subexpression (Expr : Node_Id);\n+      pragma Inline (Visit_Subexpression);\n+      --  Semantically inspect expression Expr to determine whether it violates\n+      --  preelaborability. This routine raises Non_Preelaborable.\n+\n+      -----------\n+      -- Visit --\n+      -----------\n+\n+      procedure Visit (Nod : Node_Id) is\n+      begin\n+         case Nkind (Nod) is\n+\n+            --  Declarations\n+\n+            when N_Component_Declaration =>\n+\n+               --  Defining_Identifier is left out because it is not relevant\n+               --  for preelaborability.\n+\n+               Visit (Component_Definition (Nod));\n+               Visit (Expression (Nod));\n+\n+            when N_Derived_Type_Definition =>\n+\n+               --  Interface_List is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit (Record_Extension_Part (Nod));\n+               Visit (Subtype_Indication (Nod));\n+\n+            when N_Entry_Declaration =>\n+\n+               --  A protected type with at leat one entry is not preelaborable\n+               --  while task types are never preelaborable. This renders entry\n+               --  declarations non-preelaborable.\n+\n+               raise Non_Preelaborable;\n+\n+            when N_Full_Type_Declaration =>\n+\n+               --  Defining_Identifier and Discriminant_Specifications are left\n+               --  out because they are not relevant for preelaborability.\n+\n+               Visit (Type_Definition (Nod));\n+\n+            when N_Function_Instantiation\n+               | N_Package_Instantiation\n+               | N_Procedure_Instantiation\n+            =>\n+               --  Defining_Unit_Name and Name are left out because they are\n+               --  not relevant for preelaborability.\n+\n+               Visit_List (Generic_Associations (Nod));\n+\n+            when N_Object_Declaration =>\n+\n+               --  Defining_Identifier is left out because it is not relevant\n+               --  for preelaborability.\n+\n+               Visit (Object_Definition (Nod));\n+\n+               if Has_Init_Expression (Nod) then\n+                  Visit (Expression (Nod));\n+\n+               elsif not Has_Preelaborable_Initialization\n+                           (Etype (Defining_Entity (Nod)))\n+               then\n+                  raise Non_Preelaborable;\n+               end if;\n+\n+            when N_Private_Extension_Declaration\n+               | N_Subtype_Declaration\n+            =>\n+               --  Defining_Identifier, Discriminant_Specifications, and\n+               --  Interface_List are left out because they are not relevant\n+               --  for preelaborability.\n+\n+               Visit (Subtype_Indication (Nod));\n+\n+            when N_Protected_Type_Declaration\n+               | N_Single_Protected_Declaration\n+            =>\n+               --  Defining_Identifier, Discriminant_Specifications, and\n+               --  Interface_List are left out because they are not relevant\n+               --  for preelaborability.\n+\n+               Visit (Protected_Definition (Nod));\n+\n+            --  A [single] task type is never preelaborable\n+\n+            when N_Single_Task_Declaration\n+               | N_Task_Type_Declaration\n+            =>\n+               raise Non_Preelaborable;\n+\n+            --  Pragmas\n+\n+            when N_Pragma =>\n+               Visit_Pragma (Nod);\n+\n+            --  Statements\n+\n+            when N_Statement_Other_Than_Procedure_Call =>\n+               if Nkind (Nod) /= N_Null_Statement then\n+                  raise Non_Preelaborable;\n+               end if;\n+\n+            --  Subexpressions\n+\n+            when N_Subexpr =>\n+               Visit_Subexpression (Nod);\n+\n+            --  Special\n+\n+            when N_Access_To_Object_Definition =>\n+               Visit (Subtype_Indication (Nod));\n+\n+            when N_Case_Expression_Alternative =>\n+               Visit (Expression (Nod));\n+               Visit_List (Discrete_Choices (Nod));\n+\n+            when N_Component_Definition =>\n+               Visit (Access_Definition (Nod));\n+               Visit (Subtype_Indication (Nod));\n+\n+            when N_Component_List =>\n+               Visit_List (Component_Items (Nod));\n+               Visit (Variant_Part (Nod));\n+\n+            when N_Constrained_Array_Definition =>\n+               Visit_List (Discrete_Subtype_Definitions (Nod));\n+               Visit (Component_Definition (Nod));\n+\n+            when N_Delta_Constraint\n+               | N_Digits_Constraint\n+            =>\n+               --  Delta_Expression and Digits_Expression are left out because\n+               --  they are not relevant for preelaborability.\n+\n+               Visit (Range_Constraint (Nod));\n+\n+            when N_Discriminant_Specification =>\n+\n+               --  Defining_Identifier and Expression are left out because they\n+               --  are not relevant for preelaborability.\n+\n+               Visit (Discriminant_Type (Nod));\n+\n+            when N_Generic_Association =>\n+\n+               --  Selector_Name is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit (Explicit_Generic_Actual_Parameter (Nod));\n+\n+            when N_Index_Or_Discriminant_Constraint =>\n+               Visit_List (Constraints (Nod));\n+\n+            when N_Iterator_Specification =>\n+\n+               --  Defining_Identifier is left out because it is not relevant\n+               --  for preelaborability.\n+\n+               Visit (Name (Nod));\n+               Visit (Subtype_Indication (Nod));\n+\n+            when N_Loop_Parameter_Specification =>\n+\n+               --  Defining_Identifier is left out because it is not relevant\n+               --  for preelaborability.\n+\n+               Visit (Discrete_Subtype_Definition (Nod));\n+\n+            when N_Protected_Definition =>\n+\n+               --  End_Label is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit_List (Private_Declarations (Nod));\n+               Visit_List (Visible_Declarations (Nod));\n+\n+            when N_Range_Constraint =>\n+               Visit (Range_Expression (Nod));\n+\n+            when N_Record_Definition\n+               | N_Variant\n+            =>\n+               --  End_Label, Discrete_Choices, and Interface_List are left out\n+               --  because they are not relevant for preelaborability.\n+\n+               Visit (Component_List (Nod));\n+\n+            when N_Subtype_Indication =>\n+\n+               --  Subtype_Mark is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit (Constraint (Nod));\n+\n+            when N_Unconstrained_Array_Definition =>\n+\n+               --  Subtype_Marks is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit (Component_Definition (Nod));\n+\n+            when N_Variant_Part =>\n+\n+               --  Name is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit_List (Variants (Nod));\n+\n+            --  Default\n+\n+            when others =>\n+               null;\n+         end case;\n+      end Visit;\n+\n+      ----------------\n+      -- Visit_List --\n+      ----------------\n+\n+      procedure Visit_List (List : List_Id) is\n+         Nod : Node_Id;\n+\n+      begin\n+         if Present (List) then\n+            Nod := First (List);\n+            while Present (Nod) loop\n+               Visit (Nod);\n+               Next (Nod);\n+            end loop;\n+         end if;\n+      end Visit_List;\n+\n+      ------------------\n+      -- Visit_Pragma --\n+      ------------------\n+\n+      procedure Visit_Pragma (Prag : Node_Id) is\n+      begin\n+         case Get_Pragma_Id (Prag) is\n+            when Pragma_Assert\n+               | Pragma_Assert_And_Cut\n+               | Pragma_Assume\n+               | Pragma_Async_Readers\n+               | Pragma_Async_Writers\n+               | Pragma_Attribute_Definition\n+               | Pragma_Check\n+               | Pragma_Constant_After_Elaboration\n+               | Pragma_CPU\n+               | Pragma_Deadline_Floor\n+               | Pragma_Dispatching_Domain\n+               | Pragma_Effective_Reads\n+               | Pragma_Effective_Writes\n+               | Pragma_Extensions_Visible\n+               | Pragma_Ghost\n+               | Pragma_Secondary_Stack_Size\n+               | Pragma_Task_Name\n+               | Pragma_Volatile_Function\n+            =>\n+               Visit_List (Pragma_Argument_Associations (Prag));\n+\n+            --  Default\n+\n+            when others =>\n+               null;\n+         end case;\n+      end Visit_Pragma;\n+\n+      -------------------------\n+      -- Visit_Subexpression --\n+      -------------------------\n+\n+      procedure Visit_Subexpression (Expr : Node_Id) is\n+         procedure Visit_Aggregate (Aggr : Node_Id);\n+         pragma Inline (Visit_Aggregate);\n+         --  Semantically inspect aggregate Aggr to determine whether it\n+         --  violates preelaborability.\n+\n+         ---------------------\n+         -- Visit_Aggregate --\n+         ---------------------\n+\n+         procedure Visit_Aggregate (Aggr : Node_Id) is\n+         begin\n+            if not Is_Preelaborable_Aggregate (Aggr) then\n+               raise Non_Preelaborable;\n+            end if;\n+         end Visit_Aggregate;\n+\n+      --  Start of processing for Visit_Subexpression\n+\n+      begin\n+         case Nkind (Expr) is\n+            when N_Allocator\n+               | N_Qualified_Expression\n+               | N_Type_Conversion\n+               | N_Unchecked_Expression\n+               | N_Unchecked_Type_Conversion\n+            =>\n+               --  Subpool_Handle_Name and Subtype_Mark are left out because\n+               --  they are not relevant for preelaborability.\n+\n+               Visit (Expression (Expr));\n+\n+            when N_Aggregate\n+               | N_Extension_Aggregate\n+            =>\n+               Visit_Aggregate (Expr);\n+\n+            when N_Attribute_Reference\n+               | N_Explicit_Dereference\n+               | N_Reference\n+            =>\n+               --  Attribute_Name and Expressions are left out because they are\n+               --  not relevant for preelaborability.\n+\n+               Visit (Prefix (Expr));\n+\n+            when N_Case_Expression =>\n+\n+               --  End_Span is left out because it is not relevant for\n+               --  preelaborability.\n+\n+               Visit_List (Alternatives (Expr));\n+               Visit (Expression (Expr));\n+\n+            when N_Delta_Aggregate =>\n+               Visit_Aggregate (Expr);\n+               Visit (Expression (Expr));\n+\n+            when N_Expression_With_Actions =>\n+               Visit_List (Actions (Expr));\n+               Visit (Expression (Expr));\n+\n+            when N_If_Expression =>\n+               Visit_List (Expressions (Expr));\n+\n+            when N_Quantified_Expression =>\n+               Visit (Condition (Expr));\n+               Visit (Iterator_Specification (Expr));\n+               Visit (Loop_Parameter_Specification (Expr));\n+\n+            when N_Range =>\n+               Visit (High_Bound (Expr));\n+               Visit (Low_Bound (Expr));\n+\n+            when N_Slice =>\n+               Visit (Discrete_Range (Expr));\n+               Visit (Prefix (Expr));\n+\n+            --  Default\n+\n+            when others =>\n+\n+               --  The evaluation of an object name is not preelaborable,\n+               --  unless the name is a static expression (checked further\n+               --  below), or statically denotes a discriminant.\n+\n+               if Is_Entity_Name (Expr) then\n+                  Object_Name : declare\n+                     Id : constant Entity_Id := Entity (Expr);\n+\n+                  begin\n+                     if Is_Object (Id) then\n+                        if Ekind (Id) = E_Discriminant then\n+                           null;\n+\n+                        elsif Ekind_In (Id, E_Constant, E_In_Parameter)\n+                          and then Present (Discriminal_Link (Id))\n+                        then\n+                           null;\n+\n+                        else\n+                           raise Non_Preelaborable;\n+                        end if;\n+                     end if;\n+                  end Object_Name;\n+\n+               --  A non-static expression is not preelaborable\n+\n+               elsif not Is_OK_Static_Expression (Expr) then\n+                  raise Non_Preelaborable;\n+               end if;\n+         end case;\n+      end Visit_Subexpression;\n+\n+   --  Start of processing for Is_Non_Preelaborable_Construct\n+\n+   begin\n+      Visit (N);\n+\n+      --  At this point it is known that the construct is preelaborable\n+\n+      return False;\n+\n+   exception\n+\n+      --  The elaboration of the construct performs an action which violates\n+      --  preelaborability.\n+\n+      when Non_Preelaborable =>\n+         return True;\n+   end Is_Non_Preelaborable_Construct;\n+\n    ---------------------------------\n    -- Is_Nontrivial_DIC_Procedure --\n    ---------------------------------"}, {"sha": "76fc6af266a7dc324c704a6805809d2f0a778468", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1730,6 +1730,11 @@ package Sem_Util is\n    --  without the need for a temporary, the typical example of an object not\n    --  in this category being a function call.\n \n+   function Is_Non_Preelaborable_Construct (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary construct N violates preelaborability as\n+   --  defined in ARM 10.2.1 5-9/3. This routine takes into account both the\n+   --  syntactic and semantic properties of the construct.\n+\n    function Is_Nontrivial_DIC_Procedure (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id denotes the procedure that verifies the\n    --  assertion expression of pragma Default_Initial_Condition and if it does,\n@@ -1807,7 +1812,9 @@ package Sem_Util is\n \n    function Is_Preelaborable_Construct (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N violates the restrictions of\n-   --  preelaborable constructs as defined in ARM 10.2.1(5-9).\n+   --  preelaborable constructs as defined in ARM 10.2.1(5-9). Routine\n+   --  Is_Non_Preelaborable_Construct takes into account the syntactic\n+   --  and semantic properties of N for a more accurate diagnostic.\n \n    function Is_Protected_Self_Reference (N : Node_Id) return Boolean;\n    --  Return True if node N denotes a protected type name which represents"}, {"sha": "06f62c5a92255127d4a4243840e64b2d9b893e6d", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1925,6 +1925,14 @@ package body Sinfo is\n       return Flag1 (N);\n    end Is_Elaboration_Checks_OK_Node;\n \n+   function Is_Elaboration_Code\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement);\n+      return Flag9 (N);\n+   end Is_Elaboration_Code;\n+\n    function Is_Elsif\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5353,6 +5361,14 @@ package body Sinfo is\n       Set_Flag1 (N, Val);\n    end Set_Is_Elaboration_Checks_OK_Node;\n \n+   procedure Set_Is_Elaboration_Code\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement);\n+      Set_Flag9 (N, Val);\n+   end Set_Is_Elaboration_Code;\n+\n    procedure Set_Is_Elsif\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -7123,6 +7139,60 @@ package body Sinfo is\n              T = V9;\n    end Nkind_In;\n \n+   function Nkind_In\n+     (T   : Node_Kind;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7 or else\n+             T = V8 or else\n+             T = V9 or else\n+             T = V10;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T   : Node_Kind;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind;\n+      V11 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1  or else\n+             T = V2  or else\n+             T = V3  or else\n+             T = V4  or else\n+             T = V5  or else\n+             T = V6  or else\n+             T = V7  or else\n+             T = V8  or else\n+             T = V9  or else\n+             T = V10 or else\n+             T = V11;\n+   end Nkind_In;\n+\n    -----------------\n    -- Pragma_Name --\n    -----------------"}, {"sha": "f14d2d15cb37c3f23da7664b8d35f5869553c7a3", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce7371d32ee41acc6b154dedcbc35ce57bd915/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=8dce7371d32ee41acc6b154dedcbc35ce57bd915", "patch": "@@ -1732,6 +1732,11 @@ package Sinfo is\n    --    run-time ABE checks. This flag detemines whether the ABE Processing\n    --    phase generates conditional ABE checks and guaranteed ABE failures.\n \n+   --  Is_Elaboration_Code (Flag9-Sem)\n+   --    Present in assignment statements. Set for an assignment which updates\n+   --    the elaboration flag of a package or subprogram when the corresponding\n+   --    body is successfully elaborated.\n+\n    --  Is_Entry_Barrier_Function (Flag8-Sem)\n    --    This flag is set on N_Subprogram_Declaration and N_Subprogram_Body\n    --    nodes which emulate the barrier function of a protected entry body.\n@@ -4900,6 +4905,7 @@ package Sinfo is\n       --  Backwards_OK (Flag6-Sem)\n       --  No_Ctrl_Actions (Flag7-Sem)\n       --  Has_Target_Names (Flag8-Sem)\n+      --  Is_Elaboration_Code (Flag9-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n       --  Componentwise_Assignment (Flag14-Sem)\n       --  Suppress_Assignment_Checks (Flag18-Sem)\n@@ -9704,6 +9710,9 @@ package Sinfo is\n    function Is_Elaboration_Checks_OK_Node\n      (N : Node_Id) return Boolean;    -- Flag1\n \n+   function Is_Elaboration_Code\n+     (N : Node_Id) return Boolean;    -- Flag9\n+\n    function Is_Elsif\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -10796,6 +10805,9 @@ package Sinfo is\n    procedure Set_Is_Elaboration_Checks_OK_Node\n      (N : Node_Id; Val : Boolean := True);    -- Flag1\n \n+   procedure Set_Is_Elaboration_Code\n+     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+\n    procedure Set_Is_Elsif\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -11400,6 +11412,33 @@ package Sinfo is\n       V8 : Node_Kind;\n       V9 : Node_Kind) return Boolean;\n \n+   function Nkind_In\n+     (T   : Node_Kind;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T   : Node_Kind;\n+      V1  : Node_Kind;\n+      V2  : Node_Kind;\n+      V3  : Node_Kind;\n+      V4  : Node_Kind;\n+      V5  : Node_Kind;\n+      V6  : Node_Kind;\n+      V7  : Node_Kind;\n+      V8  : Node_Kind;\n+      V9  : Node_Kind;\n+      V10 : Node_Kind;\n+      V11 : Node_Kind) return Boolean;\n+\n    pragma Inline (Nkind_In);\n    --  Inline all above functions\n \n@@ -11792,7 +11831,7 @@ package Sinfo is\n         5 => False),  --  unused\n \n      N_Delta_Aggregate =>\n-       (1 => False,   --  Expressions (List1)\n+       (1 => False,   --  Expressions (List1-Sem)\n         2 => True,    --  Component_Associations (List2)\n         3 => True,    --  Expression (Node3)\n         4 => False,   --  Unused\n@@ -12003,7 +12042,7 @@ package Sinfo is\n \n      N_Quantified_Expression =>\n        (1 => True,    --  Condition (Node1)\n-        2 => True,    --  Iterator_Specification\n+        2 => True,    --  Iterator_Specification (Node2)\n         3 => False,   --  unused\n         4 => True,    --  Loop_Parameter_Specification (Node4)\n         5 => False),  --  Etype (Node5-Sem)\n@@ -13300,6 +13339,7 @@ package Sinfo is\n    pragma Inline (Is_Dynamic_Coextension);\n    pragma Inline (Is_Effective_Use_Clause);\n    pragma Inline (Is_Elaboration_Checks_OK_Node);\n+   pragma Inline (Is_Elaboration_Code);\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n@@ -13659,6 +13699,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Dynamic_Coextension);\n    pragma Inline (Set_Is_Effective_Use_Clause);\n    pragma Inline (Set_Is_Elaboration_Checks_OK_Node);\n+   pragma Inline (Set_Is_Elaboration_Code);\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);"}]}