{"sha": "23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiMGY5ZjgxZDE2ZThmZDMwYzc5YzY3ZWEyMTQyYWYzYjZjZjU5MA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@linaro.org", "date": "2017-06-06T17:01:00Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2017-06-06T17:01:00Z"}, "message": "Improve debug output of loop data prefetching.\n\n\t* tree-ssa-loop-prefetch.c (struct mem_ref_group, struct mem_ref):\n\tNew \"uid\" fields to hold pretty-print IDs of group and ref.\n\tMemory references are now identified as <group_id>:<ref_id>\n\tinstead of using [random] addresses.\n\t(dump_mem_details): Simplify, no functional change.\n\t(dump_mem_ref): Simplify and make output more concise.\n\tReplace couple of fprintf's throughout code with calls to dump_mem_ref.\n\t(find_or_create_group): Initialize group uid.\n\t(record_ref): Initialize ref uid.  Improve debug output.\n\t(prune_group_by_reuse, should_issue_prefetch_p,)\n\t(should_issue_prefetch_p, schedule_prefetches, issue_prefetch_ref,)\n\t(mark_nontemporal_store, determine_loop_nest_reuse):\n\tImprove debug output.\n\nChange-Id: Ia594d5854de96183f3c5a669c161e5a9a73a29d7\n\nFrom-SVN: r248925", "tree": {"sha": "3bb803ff134921f703d0dc0be3a8c4a45f51950b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bb803ff134921f703d0dc0be3a8c4a45f51950b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a70c8d54274226d5613569fe7df134f882a0263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a70c8d54274226d5613569fe7df134f882a0263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a70c8d54274226d5613569fe7df134f882a0263"}], "stats": {"total": 79, "additions": 54, "deletions": 25}, "files": [{"sha": "a2877ac51ad3d5f5b67a906e744a3f1c52458deb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "patch": "@@ -1,3 +1,19 @@\n+2017-06-06  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n+\n+        * tree-ssa-loop-prefetch.c (struct mem_ref_group, struct mem_ref):\n+        New \"uid\" fields to hold pretty-print IDs of group and ref.\n+        Memory references are now identified as <group_id>:<ref_id>\n+        instead of using [random] addresses.\n+        (dump_mem_details): Simplify, no functional change.\n+        (dump_mem_ref): Simplify and make output more concise.\n+        Replace couple of fprintf's throughout code with calls to dump_mem_ref.\n+        (find_or_create_group): Initialize group uid.\n+        (record_ref): Initialize ref uid.  Improve debug output.\n+        (prune_group_by_reuse, should_issue_prefetch_p,)\n+        (should_issue_prefetch_p, schedule_prefetches, issue_prefetch_ref,)\n+        (mark_nontemporal_store, determine_loop_nest_reuse):\n+        Improve debug output.\n+\n 2017-06-06  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n         * dbgcnt.def (prefetch): New debug counter."}, {"sha": "8b5e4d139bbf05ef7aa27361781e79723f335854", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b0f9f81d16e8fd30c79c67ea2142af3b6cf590/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=23b0f9f81d16e8fd30c79c67ea2142af3b6cf590", "patch": "@@ -228,6 +228,7 @@ struct mem_ref_group\n   tree step;\t\t\t/* Step of the reference.  */\n   struct mem_ref *refs;\t\t/* References in the group.  */\n   struct mem_ref_group *next;\t/* Next group of references.  */\n+  unsigned int uid;\t\t/* Group UID, used only for debugging.  */\n };\n \n /* Assigned to PREFETCH_BEFORE when all iterations are to be prefetched.  */\n@@ -270,6 +271,7 @@ struct mem_ref\n   unsigned reuse_distance;\t/* The amount of data accessed before the first\n \t\t\t\t   reuse of this value.  */\n   struct mem_ref *next;\t\t/* The next reference in the group.  */\n+  unsigned int uid;\t\t/* Ref UID, used only for debugging.  */\n   unsigned write_p : 1;\t\t/* Is it a write?  */\n   unsigned independent_p : 1;\t/* True if the reference is independent on\n \t\t\t\t   all other references inside the loop.  */\n@@ -291,24 +293,18 @@ dump_mem_details (FILE *file, tree base, tree step,\n   else\n     print_generic_expr (file, step, TDF_SLIM);\n   fprintf (file, \")\\n\");\n-  fprintf (file, \"  delta \");\n-  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n-  fprintf (file, \"\\n\");\n-  fprintf (file, \"  %s\\n\", write_p ? \"write\" : \"read\");\n-  fprintf (file, \"\\n\");\n+  fprintf (file, \"  delta \" HOST_WIDE_INT_PRINT_DEC \"\\n\", delta);\n+  fprintf (file, \"  %s\\n\\n\", write_p ? \"write\" : \"read\");\n }\n \n /* Dumps information about reference REF to FILE.  */\n \n static void\n dump_mem_ref (FILE *file, struct mem_ref *ref)\n {\n-  fprintf (file, \"Reference %p:\\n\", (void *) ref);\n-\n-  fprintf (file, \"  group %p \", (void *) ref->group);\n-\n-  dump_mem_details (file, ref->group->base, ref->group->step, ref->delta,\n-                   ref->write_p);\n+  fprintf (file, \"reference %u:%u (\", ref->group->uid, ref->uid);\n+  print_generic_expr (file, ref->mem, TDF_SLIM);\n+  fprintf (file, \")\\n\");\n }\n \n /* Finds a group with BASE and STEP in GROUPS, or creates one if it does not\n@@ -317,6 +313,9 @@ dump_mem_ref (FILE *file, struct mem_ref *ref)\n static struct mem_ref_group *\n find_or_create_group (struct mem_ref_group **groups, tree base, tree step)\n {\n+  /* Global count for setting struct mem_ref_group->uid.  */\n+  static unsigned int last_mem_ref_group_uid = 0;\n+\n   struct mem_ref_group *group;\n \n   for (; *groups; groups = &(*groups)->next)\n@@ -336,6 +335,7 @@ find_or_create_group (struct mem_ref_group **groups, tree base, tree step)\n   group->base = base;\n   group->step = step;\n   group->refs = NULL;\n+  group->uid = ++last_mem_ref_group_uid;\n   group->next = *groups;\n   *groups = group;\n \n@@ -349,11 +349,14 @@ static void\n record_ref (struct mem_ref_group *group, gimple *stmt, tree mem,\n \t    HOST_WIDE_INT delta, bool write_p)\n {\n+  unsigned int last_mem_ref_uid = 0;\n   struct mem_ref **aref;\n \n   /* Do not record the same address twice.  */\n   for (aref = &group->refs; *aref; aref = &(*aref)->next)\n     {\n+      last_mem_ref_uid = (*aref)->uid;\n+\n       /* It does not have to be possible for write reference to reuse the read\n \t prefetch, or vice versa.  */\n       if (!WRITE_CAN_USE_READ_PREFETCH\n@@ -382,9 +385,16 @@ record_ref (struct mem_ref_group *group, gimple *stmt, tree mem,\n   (*aref)->next = NULL;\n   (*aref)->independent_p = false;\n   (*aref)->storent_p = false;\n+  (*aref)->uid = last_mem_ref_uid + 1;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_mem_ref (dump_file, *aref);\n+    {\n+      dump_mem_ref (dump_file, *aref);\n+\n+      fprintf (dump_file, \"  group %u \", group->uid);\n+      dump_mem_details (dump_file, group->base, group->step, delta,\n+\t\t\twrite_p);\n+    }\n }\n \n /* Release memory references in GROUPS.  */\n@@ -939,7 +949,7 @@ prune_group_by_reuse (struct mem_ref_group *group)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"Reference %p:\", (void *) ref_pruned);\n+\t  dump_mem_ref (dump_file, ref_pruned);\n \n \t  if (ref_pruned->prefetch_before == PREFETCH_ALL\n \t      && ref_pruned->prefetch_mod == 1)\n@@ -987,16 +997,16 @@ should_issue_prefetch_p (struct mem_ref *ref)\n   if (ref->prefetch_before != PREFETCH_ALL)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-        fprintf (dump_file, \"Ignoring %p due to prefetch_before\\n\",\n-\t\t (void *) ref);\n+        fprintf (dump_file, \"Ignoring reference %u:%u due to prefetch_before\\n\",\n+\t\t ref->group->uid, ref->uid);\n       return false;\n     }\n \n   /* Do not prefetch nontemporal stores.  */\n   if (ref->storent_p)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-        fprintf (dump_file, \"Ignoring nontemporal store %p\\n\", (void *) ref);\n+        fprintf (dump_file, \"Ignoring nontemporal store reference %u:%u\\n\", ref->group->uid, ref->uid);\n       return false;\n     }\n \n@@ -1064,6 +1074,9 @@ schedule_prefetches (struct mem_ref_group *groups, unsigned unroll_factor,\n \t  continue;\n \n \tref->issue_prefetch_p = true;\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"Decided to issue prefetch for reference %u:%u\\n\",\n+\t\t   ref->group->uid, ref->uid);\n \n \tif (remaining_prefetch_slots <= prefetch_slots)\n \t  return true;\n@@ -1127,9 +1140,9 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n   bool nontemporal = ref->reuse_distance >= L2_CACHE_SIZE_BYTES;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Issued%s prefetch for %p.\\n\",\n+    fprintf (dump_file, \"Issued%s prefetch for reference %u:%u.\\n\",\n \t     nontemporal ? \" nontemporal\" : \"\",\n-\t     (void *) ref);\n+\t     ref->group->uid, ref->uid);\n \n   bsi = gsi_for_stmt (ref->stmt);\n \n@@ -1149,8 +1162,8 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n           delta = (ahead + ap * ref->prefetch_mod) *\n \t\t   int_cst_value (ref->group->step);\n           addr = fold_build_pointer_plus_hwi (addr_base, delta);\n-          addr = force_gimple_operand_gsi (&bsi, unshare_expr (addr), true, NULL,\n-                                           true, GSI_SAME_STMT);\n+          addr = force_gimple_operand_gsi (&bsi, unshare_expr (addr), true,\n+\t\t\t\t\t   NULL, true, GSI_SAME_STMT);\n         }\n       else\n         {\n@@ -1234,8 +1247,8 @@ mark_nontemporal_store (struct mem_ref *ref)\n     return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Marked reference %p as a nontemporal store.\\n\",\n-\t     (void *) ref);\n+    fprintf (dump_file, \"Marked reference %u:%u as a nontemporal store.\\n\",\n+\t     ref->group->uid, ref->uid);\n \n   gimple_assign_set_nontemporal_move (ref->stmt, true);\n   ref->storent_p = true;\n@@ -1345,7 +1358,7 @@ should_unroll_loop_p (struct loop *loop, struct tree_niter_desc *desc,\n \n /* Determine the coefficient by that unroll LOOP, from the information\n    contained in the list of memory references REFS.  Description of\n-   umber of iterations of LOOP is stored to DESC.  NINSNS is the number of\n+   number of iterations of LOOP is stored to DESC.  NINSNS is the number of\n    insns of the LOOP.  EST_NITER is the estimated number of iterations of\n    the loop, or -1 if no estimate is available.  */\n \n@@ -1720,8 +1733,8 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n       fprintf (dump_file, \"Reuse distances:\\n\");\n       for (gr = refs; gr; gr = gr->next)\n \tfor (ref = gr->refs; ref; ref = ref->next)\n-\t  fprintf (dump_file, \" ref %p distance %u\\n\",\n-\t\t   (void *) ref, ref->reuse_distance);\n+\t  fprintf (dump_file, \" reference %u:%u distance %u\\n\",\n+\t\t   ref->group->uid, ref->uid, ref->reuse_distance);\n     }\n \n   return true;"}]}