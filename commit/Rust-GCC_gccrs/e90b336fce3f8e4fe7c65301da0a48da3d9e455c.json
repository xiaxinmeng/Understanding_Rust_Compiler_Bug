{"sha": "e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwYjMzNmZjZTNmOGU0ZmU3YzY1MzAxZGEwYTQ4ZGEzZDllNDU1Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-01-21T16:49:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-01-21T16:49:31Z"}, "message": "re PR rtl-optimization/41619 (ICE in insert_save (caller-save.c) for SPEC CPU2000's 252.eon)\n\n\n\tPR rtl-optimization/41619\n\t* caller-save.c (setup_save_areas): Break out code to determine\n\twhich hard regs are live across calls by examining the reload chains\n\tso that it is always used.\n\tEliminate code which checked REG_N_CALLS_CROSSED.\n\n\tPR rtl-optimization/41619\n\t* gcc.dg/pr41619.c: New.\n\nFrom-SVN: r169095", "tree": {"sha": "c6ff5b52d25aa0105b046aea6394eb51b3526a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6ff5b52d25aa0105b046aea6394eb51b3526a4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/comments", "author": null, "committer": null, "parents": [{"sha": "3ffe07e16cbba3f690198801696ec4251700903a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ffe07e16cbba3f690198801696ec4251700903a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ffe07e16cbba3f690198801696ec4251700903a"}], "stats": {"total": 191, "additions": 106, "deletions": 85}, "files": [{"sha": "95481b1aedf5933e58c5c46ab01c8825d78eb50f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "patch": "@@ -1,3 +1,11 @@\n+2011-01-21  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/41619\n+\t* caller-save.c (setup_save_areas): Break out code to determine\n+\twhich hard regs are live across calls by examining the reload chains\n+\tso that it is always used.\n+\tEliminate code which checked REG_N_CALLS_CROSSED.\n+\n 2011-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47355"}, {"sha": "7f7e222b4302fd33d65ae80b0a057f8ed1397a39", "filename": "gcc/caller-save.c", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "patch": "@@ -1,6 +1,6 @@\n /* Save and restore call-clobbered registers which are live across a call.\n    Copyright (C) 1989, 1992, 1994, 1995, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -416,101 +416,93 @@ saved_hard_reg_compare_func (const void *v1p, const void *v2p)\n void\n setup_save_areas (void)\n {\n-  int i, j, k;\n-  unsigned int r;\n+  int i, j, k, freq;\n   HARD_REG_SET hard_regs_used;\n+  struct saved_hard_reg *saved_reg;\n+  rtx insn;\n+  struct insn_chain *chain, *next;\n+  unsigned int regno;\n+  HARD_REG_SET hard_regs_to_save, used_regs, this_insn_sets;\n+  reg_set_iterator rsi;\n \n-  /* Allocate space in the save area for the largest multi-register\n-     pseudos first, then work backwards to single register\n-     pseudos.  */\n-\n-  /* Find and record all call-used hard-registers in this function.  */\n   CLEAR_HARD_REG_SET (hard_regs_used);\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] >= 0 && REG_N_CALLS_CROSSED (i) > 0)\n-      {\n-\tunsigned int regno = reg_renumber[i];\n-\tunsigned int endregno\n-\t  = end_hard_regno (GET_MODE (regno_reg_rtx[i]), regno);\n-\tfor (r = regno; r < endregno; r++)\n-\t  if (call_used_regs[r])\n-\t    SET_HARD_REG_BIT (hard_regs_used, r);\n-      }\n \n-  if (optimize && flag_ira_share_save_slots)\n+  /* Find every CALL_INSN and record which hard regs are live across the\n+     call into HARD_REG_MAP and HARD_REGS_USED.  */\n+  initiate_saved_hard_regs ();\n+  /* Create hard reg saved regs.  */\n+  for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n-      rtx insn, slot;\n-      struct insn_chain *chain, *next;\n-      char *saved_reg_conflicts;\n-      unsigned int regno;\n-      int next_k, freq;\n-      struct saved_hard_reg *saved_reg, *saved_reg2, *saved_reg3;\n-      int call_saved_regs_num;\n-      struct saved_hard_reg *call_saved_regs[FIRST_PSEUDO_REGISTER];\n-      HARD_REG_SET hard_regs_to_save, used_regs, this_insn_sets;\n-      reg_set_iterator rsi;\n-      int best_slot_num;\n-      int prev_save_slots_num;\n-      rtx prev_save_slots[FIRST_PSEUDO_REGISTER];\n-\n-      initiate_saved_hard_regs ();\n-      /* Create hard reg saved regs.  */\n-      for (chain = reload_insn_chain; chain != 0; chain = next)\n+      insn = chain->insn;\n+      next = chain->next;\n+      if (!CALL_P (insn)\n+\t  || find_reg_note (insn, REG_NORETURN, NULL))\n+\tcontinue;\n+      freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n+      REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n+\t\t\t       &chain->live_throughout);\n+      COPY_HARD_REG_SET (used_regs, call_used_reg_set);\n+\n+      /* Record all registers set in this call insn.  These don't\n+\t need to be saved.  N.B. the call insn might set a subreg\n+\t of a multi-hard-reg pseudo; then the pseudo is considered\n+\t live during the call, but the subreg that is set\n+\t isn't.  */\n+      CLEAR_HARD_REG_SET (this_insn_sets);\n+      note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n+      /* Sibcalls are considered to set the return value.  */\n+      if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n+\tmark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n+\n+      AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);\n+      AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);\n+      AND_HARD_REG_SET (hard_regs_to_save, used_regs);\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n+\t  {\n+\t    if (hard_reg_map[regno] != NULL)\n+\t      hard_reg_map[regno]->call_freq += freq;\n+\t    else\n+\t      saved_reg = new_saved_hard_reg (regno, freq);\n+\t    SET_HARD_REG_BIT (hard_regs_used, regno);\n+\t  }\n+      /* Look through all live pseudos, mark their hard registers.  */\n+      EXECUTE_IF_SET_IN_REG_SET\n+\t(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)\n \t{\n-\t  insn = chain->insn;\n-\t  next = chain->next;\n-\t  if (!CALL_P (insn)\n-\t      || find_reg_note (insn, REG_NORETURN, NULL))\n-\t    continue;\n-\t  freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n-\t  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n-\t\t\t\t   &chain->live_throughout);\n-\t  COPY_HARD_REG_SET (used_regs, call_used_reg_set);\n+\t  int r = reg_renumber[regno];\n+\t  int bound;\n \n-\t  /* Record all registers set in this call insn.  These don't\n-\t     need to be saved.  N.B. the call insn might set a subreg\n-\t     of a multi-hard-reg pseudo; then the pseudo is considered\n-\t     live during the call, but the subreg that is set\n-\t     isn't.  */\n-\t  CLEAR_HARD_REG_SET (this_insn_sets);\n-\t  note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);\n-\t  /* Sibcalls are considered to set the return value.  */\n-\t  if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n-\t    mark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n+\t  if (r < 0)\n+\t    continue;\n \n-\t  AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);\n-\t  AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);\n-\t  AND_HARD_REG_SET (hard_regs_to_save, used_regs);\n-\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t    if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n+\t  bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t  for (; r < bound; r++)\n+\t    if (TEST_HARD_REG_BIT (used_regs, r))\n \t      {\n-\t\tif (hard_reg_map[regno] != NULL)\n-\t\t  hard_reg_map[regno]->call_freq += freq;\n+\t\tif (hard_reg_map[r] != NULL)\n+\t\t  hard_reg_map[r]->call_freq += freq;\n \t\telse\n-\t\t  saved_reg = new_saved_hard_reg (regno, freq);\n+\t\t  saved_reg = new_saved_hard_reg (r, freq);\n+\t\t SET_HARD_REG_BIT (hard_regs_to_save, r);\n+\t\t SET_HARD_REG_BIT (hard_regs_used, r);\n \t      }\n-\t  /* Look through all live pseudos, mark their hard registers.  */\n-\t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)\n-\t    {\n-\t      int r = reg_renumber[regno];\n-\t      int bound;\n+\t}\n+    }\n \n-\t      if (r < 0)\n-\t\tcontinue;\n+  /* If requested, figure out which hard regs can share save slots.  */\n+  if (optimize && flag_ira_share_save_slots)\n+    {\n+      rtx slot;\n+      char *saved_reg_conflicts;\n+      int next_k;\n+      struct saved_hard_reg *saved_reg2, *saved_reg3;\n+      int call_saved_regs_num;\n+      struct saved_hard_reg *call_saved_regs[FIRST_PSEUDO_REGISTER];\n+      int best_slot_num;\n+      int prev_save_slots_num;\n+      rtx prev_save_slots[FIRST_PSEUDO_REGISTER];\n \n-\t      bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n-\t      for (; r < bound; r++)\n-\t\tif (TEST_HARD_REG_BIT (used_regs, r))\n-\t\t  {\n-\t\t    if (hard_reg_map[r] != NULL)\n-\t\t      hard_reg_map[r]->call_freq += freq;\n-\t\t    else\n-\t\t      saved_reg = new_saved_hard_reg (r, freq);\n-\t\t    SET_HARD_REG_BIT (hard_regs_to_save, r);\n-\t\t  }\n-\t    }\n-\t}\n       /* Find saved hard register conflicts.  */\n       saved_reg_conflicts = (char *) xmalloc (saved_regs_num * saved_regs_num);\n       memset (saved_reg_conflicts, 0, saved_regs_num * saved_regs_num);\n@@ -668,8 +660,10 @@ setup_save_areas (void)\n     }\n   else\n     {\n-      /* Now run through all the call-used hard-registers and allocate\n-\t space for them in the caller-save area.  Try to allocate space\n+      /* We are not sharing slots. \n+\n+\t Run through all the call-used hard-registers and allocate\n+\t space for each in the caller-save area.  Try to allocate space\n \t in a manner which allows multi-register saves/restores to be done.  */\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)"}, {"sha": "b8962fe151bae1fde1a33e9ada49271ca0bce17d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "patch": "@@ -1,3 +1,8 @@\n+2011-01-21  Jeff Law <law@redhat.com>\n+\n+\tPR rtl-optimization/41619\n+\t* gcc.dg/pr41619.c: New.\n+\n 2011-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47355"}, {"sha": "9c164e3a60faaaf86bfe162d70feafbb25ea42fc", "filename": "gcc/testsuite/gcc.dg/pr41619.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41619.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b336fce3f8e4fe7c65301da0a48da3d9e455c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41619.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41619.c?ref=e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ira-share-save-slots\" } */\n+\n+struct A {};\n+\n+int foo();\n+\n+struct A bar(double x)\n+{\n+  double y;\n+  if (foo())\n+    y = 1 / x;\n+  return bar(y);\n+}"}]}