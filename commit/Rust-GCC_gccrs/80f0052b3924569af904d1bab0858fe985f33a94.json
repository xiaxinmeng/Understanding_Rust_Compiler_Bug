{"sha": "80f0052b3924569af904d1bab0858fe985f33a94", "node_id": "C_kwDOANBUbNoAKDgwZjAwNTJiMzkyNDU2OWFmOTA0ZDFiYWIwODU4ZmU5ODVmMzNhOTQ", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-01-17T22:34:58Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-03-07T16:05:30Z"}, "message": "c++: -Wdangling-reference with reference wrapper [PR107532]\n\nHere, -Wdangling-reference triggers where it probably shouldn't, causing\nsome grief.  The code in question uses a reference wrapper with a member\nfunction returning a reference to a subobject of a non-temporary object:\n\n  const Plane & meta = fm.planes().inner();\n\nI've tried a few approaches, e.g., checking that the member function's\nreturn type is the same as the type of the enclosing class (which is\nthe case for member functions returning *this), but that then breaks\nWdangling-reference4.C with std::optional<std::string>.\n\nThis patch adjusts do_warn_dangling_reference so that we look through\nreference wrapper classes (meaning, has a reference member and a\nconstructor taking the same reference type, or is std::reference_wrapper\nor std::ranges::ref_view) and don't warn for them, supposing that the\nmember function returns a reference to a non-temporary object.\n\n\tPR c++/107532\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (reference_like_class_p): New.\n\t(do_warn_dangling_reference): Add new bool parameter.  See through\n\treference_like_class_p.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/warn/Wdangling-reference8.C: New test.\n\t* g++.dg/warn/Wdangling-reference9.C: New test.", "tree": {"sha": "eb1b517d17759ab683ec3b2f12676011eac85dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb1b517d17759ab683ec3b2f12676011eac85dd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80f0052b3924569af904d1bab0858fe985f33a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f0052b3924569af904d1bab0858fe985f33a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f0052b3924569af904d1bab0858fe985f33a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f0052b3924569af904d1bab0858fe985f33a94/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2b841fa25513a87fcb6e8195c2ad3ea354426d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2b841fa25513a87fcb6e8195c2ad3ea354426d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2b841fa25513a87fcb6e8195c2ad3ea354426d4"}], "stats": {"total": 196, "additions": 182, "deletions": 14}, "files": [{"sha": "3dfa12a07336739bf728fa8717f29f9b29b2f7e6", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=80f0052b3924569af904d1bab0858fe985f33a94", "patch": "@@ -13779,6 +13779,52 @@ std_pair_ref_ref_p (tree t)\n   return true;\n }\n \n+/* Return true if a class CTYPE is either std::reference_wrapper or\n+   std::ref_view, or a reference wrapper class.  We consider a class\n+   a reference wrapper class if it has a reference member and a\n+   constructor taking the same reference type.  */\n+\n+static bool\n+reference_like_class_p (tree ctype)\n+{\n+  if (!CLASS_TYPE_P (ctype))\n+    return false;\n+\n+  /* Also accept a std::pair<const T&, const T&>.  */\n+  if (std_pair_ref_ref_p (ctype))\n+    return true;\n+\n+  tree tdecl = TYPE_NAME (TYPE_MAIN_VARIANT (ctype));\n+  if (decl_in_std_namespace_p (tdecl))\n+    {\n+      tree name = DECL_NAME (tdecl);\n+      return (name\n+\t      && (id_equal (name, \"reference_wrapper\")\n+\t\t  || id_equal (name, \"ref_view\")));\n+    }\n+  for (tree fields = TYPE_FIELDS (ctype);\n+       fields;\n+       fields = DECL_CHAIN (fields))\n+    {\n+      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n+\tcontinue;\n+      tree type = TREE_TYPE (fields);\n+      if (!TYPE_REF_P (type))\n+\tcontinue;\n+      /* OK, the field is a reference member.  Do we have a constructor\n+\t taking its type?  */\n+      for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (ctype)))\n+\t{\n+\t  tree args = FUNCTION_FIRST_USER_PARMTYPE (fn);\n+\t  if (args\n+\t      && same_type_p (TREE_VALUE (args), type)\n+\t      && TREE_CHAIN (args) == void_list_node)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Helper for maybe_warn_dangling_reference to find a problematic CALL_EXPR\n    that initializes the LHS (and at least one of its arguments represents\n    a temporary, as outlined in maybe_warn_dangling_reference), or NULL_TREE\n@@ -13793,12 +13839,37 @@ std_pair_ref_ref_p (tree t)\n      const int& y = (f(1), 42); // NULL_TREE\n      const int& z = f(f(1)); // f(f(1))\n \n-   EXPR is the initializer.  */\n+   EXPR is the initializer.  If ARG_P is true, we're processing an argument\n+   to a function; the point is to distinguish between, for example,\n+\n+     Ref::inner (&TARGET_EXPR <D.2839, F::foo (fm)>)\n+\n+   where we shouldn't warn, and\n+\n+     Ref::inner (&TARGET_EXPR <D.2908, F::foo (&TARGET_EXPR <...>)>)\n+\n+   where we should warn (Ref is a reference_like_class_p so we see through\n+   it.  */\n \n static tree\n-do_warn_dangling_reference (tree expr)\n+do_warn_dangling_reference (tree expr, bool arg_p)\n {\n   STRIP_NOPS (expr);\n+\n+  if (arg_p && expr_represents_temporary_p (expr))\n+    {\n+      /* An attempt to reduce the number of -Wdangling-reference\n+\t false positives concerning reference wrappers (c++/107532).\n+\t When we encounter a reference_like_class_p, we don't warn\n+\t just yet; instead, we keep recursing to see if there were\n+\t any temporaries behind the reference-wrapper class.  */\n+      tree e = expr;\n+      while (handled_component_p (e))\n+\te = TREE_OPERAND (e, 0);\n+      if (!reference_like_class_p (TREE_TYPE (e)))\n+\treturn expr;\n+    }\n+\n   switch (TREE_CODE (expr))\n     {\n     case CALL_EXPR:\n@@ -13831,7 +13902,7 @@ do_warn_dangling_reference (tree expr)\n \t     std::pair<const int&, const int&> v = std::minmax(1, 2);\n \t   which also creates a dangling reference, because std::minmax\n \t   returns std::pair<const T&, const T&>(b, a).  */\n-\tif (!(TYPE_REF_OBJ_P (rettype) || std_pair_ref_ref_p (rettype)))\n+\tif (!(TYPE_REF_OBJ_P (rettype) || reference_like_class_p (rettype)))\n \t  return NULL_TREE;\n \n \t/* Here we're looking to see if any of the arguments is a temporary\n@@ -13844,14 +13915,13 @@ do_warn_dangling_reference (tree expr)\n \t    if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)\n \t\t&& !TYPE_REF_P (TREE_TYPE (arg)))\n \t      continue;\n-\t    /* It could also be another call taking a temporary and returning\n-\t       it and initializing this reference parameter.  */\n-\t    if (do_warn_dangling_reference (arg))\n-\t      return expr;\n \t    STRIP_NOPS (arg);\n \t    if (TREE_CODE (arg) == ADDR_EXPR)\n \t      arg = TREE_OPERAND (arg, 0);\n-\t    if (expr_represents_temporary_p (arg))\n+\t    /* Recurse to see if the argument is a temporary.  It could also\n+\t       be another call taking a temporary and returning it and\n+\t       initializing this reference parameter.  */\n+\t    if (do_warn_dangling_reference (arg, /*arg_p=*/true))\n \t      return expr;\n \t  /* Don't warn about member function like:\n \t      std::any a(...);\n@@ -13868,15 +13938,15 @@ do_warn_dangling_reference (tree expr)\n \treturn NULL_TREE;\n       }\n     case COMPOUND_EXPR:\n-      return do_warn_dangling_reference (TREE_OPERAND (expr, 1));\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 1), arg_p);\n     case COND_EXPR:\n-      if (tree t = do_warn_dangling_reference (TREE_OPERAND (expr, 1)))\n+      if (tree t = do_warn_dangling_reference (TREE_OPERAND (expr, 1), arg_p))\n \treturn t;\n-      return do_warn_dangling_reference (TREE_OPERAND (expr, 2));\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 2), arg_p);\n     case PAREN_EXPR:\n-      return do_warn_dangling_reference (TREE_OPERAND (expr, 0));\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 0), arg_p);\n     case TARGET_EXPR:\n-      return do_warn_dangling_reference (TARGET_EXPR_INITIAL (expr));\n+      return do_warn_dangling_reference (TARGET_EXPR_INITIAL (expr), arg_p);\n     default:\n       return NULL_TREE;\n     }\n@@ -13919,7 +13989,7 @@ maybe_warn_dangling_reference (const_tree decl, tree init)\n     = make_temp_override (global_dc->dc_warn_system_headers,\n \t\t\t  (!in_system_header_at (DECL_SOURCE_LOCATION (decl))\n \t\t\t   || global_dc->dc_warn_system_headers));\n-  if (tree call = do_warn_dangling_reference (init))\n+  if (tree call = do_warn_dangling_reference (init, /*arg_p=*/false))\n     {\n       auto_diagnostic_group d;\n       if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wdangling_reference,"}, {"sha": "330de1fd05ddc36f9f596d5420f0bad051360edf", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference8.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference8.C?ref=80f0052b3924569af904d1bab0858fe985f33a94", "patch": "@@ -0,0 +1,77 @@\n+// PR c++/107532\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+struct Plane { unsigned int bytesused; };\n+\n+// Passes a reference through. Does not change lifetime.\n+template <typename T>\n+struct Ref {\n+    const T& i_;\n+    Ref(const T & i) : i_(i) {}\n+    const T & inner();\n+};\n+\n+struct FrameMetadata {\n+    Ref<const Plane> planes() const { return p_; }\n+\n+    Plane p_;\n+};\n+\n+void bar(const Plane & meta);\n+void foo(const FrameMetadata & fm)\n+{\n+    const Plane & meta = fm.planes().inner();\n+    bar(meta);\n+    const Plane & meta2 = FrameMetadata().planes().inner(); // { dg-warning \"dangling reference\" }\n+    bar(meta2);\n+}\n+\n+struct S {\n+  const S& self () { return *this; }\n+} s;\n+\n+const S& r1 = s.self();\n+const S& r2 = S().self(); // { dg-warning \"dangling reference\" }\n+\n+struct D {\n+};\n+\n+struct C {\n+  D d;\n+  Ref<const D> get() const { return d; }\n+};\n+\n+struct B {\n+  C c;\n+  const C& get() const { return c; }\n+  B();\n+};\n+\n+struct A {\n+  B b;\n+  const B& get() const { return b; }\n+};\n+\n+void\n+g (const A& a)\n+{\n+  const auto& d1 = a.get().get().get().inner();\n+  (void) d1;\n+  const auto& d2 = A().get().get().get().inner(); // { dg-warning \"dangling reference\" }\n+  (void) d2;\n+  const auto& d3 = A().b.get().get().inner(); // { dg-warning \"dangling reference\" }\n+  (void) d3;\n+  const auto& d4 = a.b.get().get().inner();\n+  (void) d4;\n+  const auto& d5 = a.b.c.get().inner();\n+  (void) d5;\n+  const auto& d6 = A().b.c.get().inner(); // { dg-warning \"dangling reference\" }\n+  (void) d6;\n+  Plane p;\n+  Ref<Plane> r(p);\n+  const auto& d7 = r.inner();\n+  (void) d7;\n+  const auto& d8 = Ref<Plane>(p).inner();\n+  (void) d8;\n+}"}, {"sha": "9ad83f7365ee4ef231c3275b3463c6ca79887392", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference9.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f0052b3924569af904d1bab0858fe985f33a94/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference9.C?ref=80f0052b3924569af904d1bab0858fe985f33a94", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/107532\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+#include <functional>\n+\n+struct X { int n; };\n+\n+struct S {\n+  std::reference_wrapper<const X> wrapit() const { return x; }\n+  X x;\n+};\n+\n+void\n+g (const S& s)\n+{\n+  const auto& a1 = s.wrapit().get();\n+  (void) a1;\n+  const auto& a2 = S().wrapit().get(); // { dg-warning \"dangling reference\" }\n+  (void) a2;\n+}"}]}