{"sha": "8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxYzZmZDcxNjZiYjMzMzE5ZWJjMWQyMGZkOWNhODNkMzliMDA3OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-12-09T20:44:49Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-12-09T20:44:49Z"}, "message": "Eliminate last_basic_block macro.\n\n\t* basic-block.h (last_basic_block): Eliminate macro.\n\n\t* asan.c (transform_statements): Eliminate use of last_basic_block\n\tin favor of last_basic_block_for_fn, in order to make use of cfun\n\texplicit.\n\t* bb-reorder.c (copy_bb, reorder_basic_blocks): Likewise.\n\t* bt-load.c (compute_defs_uses_and_gen, compute_kill, compute_out,\n\tlink_btr_uses, build_btr_def_use_webs, migrate_btr_defs): Likewise.\n\t* cfg.c (compact_blocks): Likewise.\n\t* cfganal.c (mark_dfs_back_edges,\n\tcontrol_dependences::control_dependences, post_order_compute,\n\tpre_and_rev_post_order_compute_fn, dfs_enumerate_from, compute_idf,\n\tsingle_pred_before_succ_order): Likewise.\n\t* cfgbuild.c (make_edges): Likewise.\n\t* cfgexpand.c (add_scope_conflicts, gimple_expand_cfg): Likewise.\n\t* cfghooks.c (verify_flow_info): Likewise.\n\t* cfgloop.c (verify_loop_structure): Likewise.\n\t* cfgloopanal.c (just_once_each_iteration_p,\n\tmark_irreducible_loops): Likewise.\n\t* cfgloopmanip.c (fix_bb_placements, remove_path,\n\tupdate_dominators_in_loop): Likewise.\n\t* cfgrtl.c (create_basic_block_structure, rtl_create_basic_block,\n\tbreak_superblocks, rtl_flow_call_edges_add): Likewise.\n\t* config/epiphany/resolve-sw-modes.c (resolve_sw_modes): Likewise.\n\t* config/frv/frv.c (frv_optimize_membar): Likewise.\n\t* config/mips/mips.c (r10k_insert_cache_barriers): Likewise.\n\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise.\n\t* cprop.c (compute_local_properties, find_implicit_sets,\n\tbypass_conditional_jumps, one_cprop_pass): Likewise.\n\t* cse.c (cse_main): Likewise.\n\t* df-core.c (rest_of_handle_df_initialize, df_worklist_dataflow,\n\tdf_analyze, df_grow_bb_info, df_compact_blocks): Likewise.\n\t* df-problems.c (df_lr_verify_solution_start,\n\tdf_live_verify_solution_start, df_md_local_compute): Likewise.\n\t* dominance.c (init_dom_info, calc_dfs_tree_nonrec, calc_dfs_tree,\n\tcalc_idoms): Likewise.\n\t* domwalk.c (dom_walker::walk): Likewise.\n\t* dse.c (dse_step0, dse_step3): Likewise.\n\t* function.c (epilogue_done): Likewise.\n\t* gcse.c (alloc_gcse_mem, compute_local_properties,\n\tprune_insertions_deletions, compute_pre_data,\n\tpre_expr_reaches_here_p, one_pre_gcse_pass,\n\tcompute_code_hoist_vbeinout, should_hoist_expr_to_dom, hoist_code,\n\tone_code_hoisting_pass): Likewise.\n\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n\t* graphite-sese-to-poly.c (build_scop_bbs): Likewise.\n\t* haifa-sched.c (unlink_bb_notes): Likewise.\n\t* ipa-split.c (execute_split_functions): Likewise.\n\t* ira-build.c (create_loop_tree_nodes,\n\tremove_unnecessary_regions): Likewise.\n\t* ira-emit.c (ira_emit): Likewise.\n\t* ira.c (find_moveable_pseudos, ira): Likewise.\n\t* lcm.c (compute_antinout_edge, compute_laterin,\n\tcompute_insert_delete, pre_edge_lcm, compute_available,\n\tcompute_nearerout, compute_rev_insert_delete,\n\tpre_edge_rev_lcm): Likewise.\n\t* loop-unroll.c (opt_info_start_duplication,\n\tapply_opt_in_copies): Likewise.\n\t* lower-subreg.c (decompose_multiword_subregs): Likewise.\n\t* lra-lives.c (lra_create_live_ranges): Likewise.\n\t* lra.c (lra): Likewise.\n\t* mode-switching.c (optimize_mode_switching): Likewise.\n\t* recog.c (split_all_insns): Likewise.\n\t* regcprop.c (copyprop_hardreg_forward): Likewise.\n\t* regrename.c (regrename_analyze): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* resource.c (init_resource_info): Likewise.\n\t* sched-rgn.c (haifa_find_rgns, extend_rgns, compute_trg_info,\n\trealloc_bb_state_array, schedule_region, extend_regions): Likewise.\n\t* sel-sched-ir.c (sel_extend_global_bb_info, extend_region_bb_info,\n\trecompute_rev_top_order, sel_init_pipelining,\n\tmake_regions_from_the_rest): Likewise.\n\t* store-motion.c (remove_reachable_equiv_notes,build_store_vectors)\n\tLikewise.\n\t* tracer.c (tail_duplicate): Likewise.\n\t* trans-mem.c (tm_region_init, get_bb_regions_instrumented): Likewise.\n\t* tree-cfg.c (create_bb, cleanup_dead_labels, gimple_dump_cfg,\n\tgimple_flow_call_edges_add): Likewise.\n\t* tree-cfgcleanup.c (split_bbs_on_noreturn_calls,\n\tcleanup_tree_cfg_1): Likewise.\n\t* tree-complex.c (tree_lower_complex): Likewise.\n\t* tree-inline.c (copy_cfg_body): Likewise.\n\t* tree-into-ssa.c (mark_phi_for_rewrite, rewrite_into_ssa,\n\tprepare_def_site_for, update_ssa): Likewise.\n\t* tree-ssa-dce.c (tree_dce_init, perform_tree_ssa_dce): Likewise.\n\t* tree-ssa-dom.c (record_edge_info): Likewise.\n\t* tree-ssa-live.c (new_tree_live_info, live_worklist): Likewise.\n\t* tree-ssa-loop-im.c (fill_always_executed_in_1): Likewise.\n\t* tree-ssa-loop-manip.c (copy_phi_node_args\n\tgimple_duplicate_loop_to_header_edge): Likewise.\n\t* tree-ssa-pre.c (compute_antic): Likewise.\n\t* tree-ssa-propagate.c (ssa_prop_init): Likewise.\n\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n\t* tree-ssa-sccvn.c (init_scc_vn): Likewise.\n\t* tree-ssa-tail-merge.c (init_worklist): Likewise.\n\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n\t* tree-vrp.c (find_assert_locations): Likewise.\n\t* var-tracking.c (vt_find_locations): Likewise.\n\nFrom-SVN: r205826", "tree": {"sha": "65d2e5469314d74be01002d2512b443e3784d8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65d2e5469314d74be01002d2512b443e3784d8c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a6a6ac91c09c352acf13e491c02a6b8795d3e9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a6a6ac91c09c352acf13e491c02a6b8795d3e9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a6a6ac91c09c352acf13e491c02a6b8795d3e9a"}], "stats": {"total": 740, "additions": 451, "deletions": 289}, "files": [{"sha": "18967266a3fd9a3b7e0eae938c870becde6c3334", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1,3 +1,105 @@\n+2013-12-09  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* basic-block.h (last_basic_block): Eliminate macro.\n+\n+\t* asan.c (transform_statements): Eliminate use of last_basic_block\n+\tin favor of last_basic_block_for_fn, in order to make use of cfun\n+\texplicit.\n+\t* bb-reorder.c (copy_bb, reorder_basic_blocks): Likewise.\n+\t* bt-load.c (compute_defs_uses_and_gen, compute_kill, compute_out,\n+\tlink_btr_uses, build_btr_def_use_webs, migrate_btr_defs): Likewise.\n+\t* cfg.c (compact_blocks): Likewise.\n+\t* cfganal.c (mark_dfs_back_edges,\n+\tcontrol_dependences::control_dependences, post_order_compute,\n+\tpre_and_rev_post_order_compute_fn, dfs_enumerate_from, compute_idf,\n+\tsingle_pred_before_succ_order): Likewise.\n+\t* cfgbuild.c (make_edges): Likewise.\n+\t* cfgexpand.c (add_scope_conflicts, gimple_expand_cfg): Likewise.\n+\t* cfghooks.c (verify_flow_info): Likewise.\n+\t* cfgloop.c (verify_loop_structure): Likewise.\n+\t* cfgloopanal.c (just_once_each_iteration_p,\n+\tmark_irreducible_loops): Likewise.\n+\t* cfgloopmanip.c (fix_bb_placements, remove_path,\n+\tupdate_dominators_in_loop): Likewise.\n+\t* cfgrtl.c (create_basic_block_structure, rtl_create_basic_block,\n+\tbreak_superblocks, rtl_flow_call_edges_add): Likewise.\n+\t* config/epiphany/resolve-sw-modes.c (resolve_sw_modes): Likewise.\n+\t* config/frv/frv.c (frv_optimize_membar): Likewise.\n+\t* config/mips/mips.c (r10k_insert_cache_barriers): Likewise.\n+\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise.\n+\t* cprop.c (compute_local_properties, find_implicit_sets,\n+\tbypass_conditional_jumps, one_cprop_pass): Likewise.\n+\t* cse.c (cse_main): Likewise.\n+\t* df-core.c (rest_of_handle_df_initialize, df_worklist_dataflow,\n+\tdf_analyze, df_grow_bb_info, df_compact_blocks): Likewise.\n+\t* df-problems.c (df_lr_verify_solution_start,\n+\tdf_live_verify_solution_start, df_md_local_compute): Likewise.\n+\t* dominance.c (init_dom_info, calc_dfs_tree_nonrec, calc_dfs_tree,\n+\tcalc_idoms): Likewise.\n+\t* domwalk.c (dom_walker::walk): Likewise.\n+\t* dse.c (dse_step0, dse_step3): Likewise.\n+\t* function.c (epilogue_done): Likewise.\n+\t* gcse.c (alloc_gcse_mem, compute_local_properties,\n+\tprune_insertions_deletions, compute_pre_data,\n+\tpre_expr_reaches_here_p, one_pre_gcse_pass,\n+\tcompute_code_hoist_vbeinout, should_hoist_expr_to_dom, hoist_code,\n+\tone_code_hoisting_pass): Likewise.\n+\t* graph.c (draw_cfg_nodes_no_loops): Likewise.\n+\t* graphite-sese-to-poly.c (build_scop_bbs): Likewise.\n+\t* haifa-sched.c (unlink_bb_notes): Likewise.\n+\t* ipa-split.c (execute_split_functions): Likewise.\n+\t* ira-build.c (create_loop_tree_nodes,\n+\tremove_unnecessary_regions): Likewise.\n+\t* ira-emit.c (ira_emit): Likewise.\n+\t* ira.c (find_moveable_pseudos, ira): Likewise.\n+\t* lcm.c (compute_antinout_edge, compute_laterin,\n+\tcompute_insert_delete, pre_edge_lcm, compute_available,\n+\tcompute_nearerout, compute_rev_insert_delete,\n+\tpre_edge_rev_lcm): Likewise.\n+\t* loop-unroll.c (opt_info_start_duplication,\n+\tapply_opt_in_copies): Likewise.\n+\t* lower-subreg.c (decompose_multiword_subregs): Likewise.\n+\t* lra-lives.c (lra_create_live_ranges): Likewise.\n+\t* lra.c (lra): Likewise.\n+\t* mode-switching.c (optimize_mode_switching): Likewise.\n+\t* recog.c (split_all_insns): Likewise.\n+\t* regcprop.c (copyprop_hardreg_forward): Likewise.\n+\t* regrename.c (regrename_analyze): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* resource.c (init_resource_info): Likewise.\n+\t* sched-rgn.c (haifa_find_rgns, extend_rgns, compute_trg_info,\n+\trealloc_bb_state_array, schedule_region, extend_regions): Likewise.\n+\t* sel-sched-ir.c (sel_extend_global_bb_info, extend_region_bb_info,\n+\trecompute_rev_top_order, sel_init_pipelining,\n+\tmake_regions_from_the_rest): Likewise.\n+\t* store-motion.c (remove_reachable_equiv_notes,build_store_vectors)\n+\tLikewise.\n+\t* tracer.c (tail_duplicate): Likewise.\n+\t* trans-mem.c (tm_region_init, get_bb_regions_instrumented): Likewise.\n+\t* tree-cfg.c (create_bb, cleanup_dead_labels, gimple_dump_cfg,\n+\tgimple_flow_call_edges_add): Likewise.\n+\t* tree-cfgcleanup.c (split_bbs_on_noreturn_calls,\n+\tcleanup_tree_cfg_1): Likewise.\n+\t* tree-complex.c (tree_lower_complex): Likewise.\n+\t* tree-inline.c (copy_cfg_body): Likewise.\n+\t* tree-into-ssa.c (mark_phi_for_rewrite, rewrite_into_ssa,\n+\tprepare_def_site_for, update_ssa): Likewise.\n+\t* tree-ssa-dce.c (tree_dce_init, perform_tree_ssa_dce): Likewise.\n+\t* tree-ssa-dom.c (record_edge_info): Likewise.\n+\t* tree-ssa-live.c (new_tree_live_info, live_worklist): Likewise.\n+\t* tree-ssa-loop-im.c (fill_always_executed_in_1): Likewise.\n+\t* tree-ssa-loop-manip.c (copy_phi_node_args\n+\tgimple_duplicate_loop_to_header_edge): Likewise.\n+\t* tree-ssa-pre.c (compute_antic): Likewise.\n+\t* tree-ssa-propagate.c (ssa_prop_init): Likewise.\n+\t* tree-ssa-reassoc.c (init_reassoc): Likewise.\n+\t* tree-ssa-sccvn.c (init_scc_vn): Likewise.\n+\t* tree-ssa-tail-merge.c (init_worklist): Likewise.\n+\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n+\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n+\t* tree-vrp.c (find_assert_locations): Likewise.\n+\t* var-tracking.c (vt_find_locations): Likewise.\n+\n 2013-12-09  David Malcolm  <dmalcolm@redhat.com>\n \n \t* basic-block.h (profile_status): Eliminate macro."}, {"sha": "1f3964982da4b1595cdefab9f6ddb3263a6a701e", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2041,7 +2041,7 @@ transform_statements (void)\n {\n   basic_block bb, last_bb = NULL;\n   gimple_stmt_iterator i;\n-  int saved_last_basic_block = last_basic_block;\n+  int saved_last_basic_block = last_basic_block_for_fn (cfun);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "174b650d63114b853be39d670470fe4060a7fdac", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -326,9 +326,6 @@ struct GTY(()) control_flow_graph {\n #define SET_BASIC_BLOCK_FOR_FN(FN,N,BB) \\\n   ((*basic_block_info_for_fn (FN))[(N)] = (BB))\n \n-/* Defines for textual backward source compatibility.  */\n-#define last_basic_block\t(cfun->cfg->x_last_basic_block)\n-\n /* For iterating over basic blocks.  */\n #define FOR_BB_BETWEEN(BB, FROM, TO, DIR) \\\n   for (BB = FROM; BB != TO; BB = BB->DIR)"}, {"sha": "363af2da19a5a5d0334ea943950ae8a202547715", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -826,12 +826,13 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n \t     old_bb->index, new_bb->index);\n \n-  if (new_bb->index >= array_size || last_basic_block > array_size)\n+  if (new_bb->index >= array_size\n+      || last_basic_block_for_fn (cfun) > array_size)\n     {\n       int i;\n       int new_size;\n \n-      new_size = MAX (last_basic_block, new_bb->index + 1);\n+      new_size = MAX (last_basic_block_for_fn (cfun), new_bb->index + 1);\n       new_size = GET_ARRAY_SIZE (new_size);\n       bbd = XRESIZEVEC (bbro_basic_block_data, bbd, new_size);\n       for (i = array_size; i < new_size; i++)\n@@ -2234,7 +2235,7 @@ reorder_basic_blocks (void)\n     uncond_jump_length = get_uncond_jump_length ();\n \n   /* We need to know some information for each basic block.  */\n-  array_size = GET_ARRAY_SIZE (last_basic_block);\n+  array_size = GET_ARRAY_SIZE (last_basic_block_for_fn (cfun));\n   bbd = XNEWVEC (bbro_basic_block_data, array_size);\n   for (i = 0; i < array_size; i++)\n     {"}, {"sha": "83b3ebabee2ad1611b1df5bb2202315486c51a03", "filename": "gcc/bt-load.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -457,8 +457,8 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n   btr_def_group all_btr_def_groups = NULL;\n   defs_uses_info info;\n \n-  bitmap_vector_clear (bb_gen, last_basic_block);\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+  bitmap_vector_clear (bb_gen, last_basic_block_for_fn (cfun));\n+  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       int reg;\n@@ -618,8 +618,8 @@ compute_kill (sbitmap *bb_kill, sbitmap *btr_defset,\n \n   /* For each basic block, form the set BB_KILL - the set\n      of definitions that the block kills.  */\n-  bitmap_vector_clear (bb_kill, last_basic_block);\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+  bitmap_vector_clear (bb_kill, last_basic_block_for_fn (cfun));\n+  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     {\n       for (regno = first_btr; regno <= last_btr; regno++)\n \tif (TEST_HARD_REG_BIT (all_btrs, regno)\n@@ -642,14 +642,14 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n   int changed;\n   sbitmap bb_in = sbitmap_alloc (max_uid);\n \n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     bitmap_copy (bb_out[i], bb_gen[i]);\n \n   changed = 1;\n   while (changed)\n     {\n       changed = 0;\n-      for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n \t{\n \t  bitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK_FOR_FN (cfun, i));\n \t  changed |= bitmap_ior_and_compl (bb_out[i], bb_gen[i],\n@@ -668,7 +668,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \n   /* Link uses to the uses lists of all of their reaching defs.\n      Count up the number of reaching defs of each use.  */\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       rtx insn;\n@@ -780,8 +780,10 @@ build_btr_def_use_webs (fibheap_t all_btr_defs)\n   btr_user *use_array   = XCNEWVEC (btr_user, max_uid);\n   sbitmap *btr_defset   = sbitmap_vector_alloc (\n \t\t\t   (last_btr - first_btr) + 1, max_uid);\n-  sbitmap *bb_gen      = sbitmap_vector_alloc (last_basic_block, max_uid);\n-  HARD_REG_SET *btrs_written = XCNEWVEC (HARD_REG_SET, last_basic_block);\n+  sbitmap *bb_gen = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t\t  max_uid);\n+  HARD_REG_SET *btrs_written = XCNEWVEC (HARD_REG_SET,\n+\t\t\t\t\t last_basic_block_for_fn (cfun));\n   sbitmap *bb_kill;\n   sbitmap *bb_out;\n \n@@ -790,11 +792,11 @@ build_btr_def_use_webs (fibheap_t all_btr_defs)\n   compute_defs_uses_and_gen (all_btr_defs, def_array, use_array, btr_defset,\n \t\t\t     bb_gen, btrs_written);\n \n-  bb_kill = sbitmap_vector_alloc (last_basic_block, max_uid);\n+  bb_kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), max_uid);\n   compute_kill (bb_kill, btr_defset, btrs_written);\n   free (btrs_written);\n \n-  bb_out = sbitmap_vector_alloc (last_basic_block, max_uid);\n+  bb_out = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), max_uid);\n   compute_out (bb_out, bb_gen, bb_kill, max_uid);\n \n   sbitmap_vector_free (bb_gen);\n@@ -1405,7 +1407,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n     {\n       int i;\n \n-      for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n \t{\n \t  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n \t  fprintf (dump_file,\n@@ -1428,8 +1430,8 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n \t  first_btr = reg;\n       }\n \n-  btrs_live = XCNEWVEC (HARD_REG_SET, last_basic_block);\n-  btrs_live_at_end = XCNEWVEC (HARD_REG_SET, last_basic_block);\n+  btrs_live = XCNEWVEC (HARD_REG_SET, last_basic_block_for_fn (cfun));\n+  btrs_live_at_end = XCNEWVEC (HARD_REG_SET, last_basic_block_for_fn (cfun));\n \n   build_btr_def_use_webs (all_btr_defs);\n "}, {"sha": "6c3181d5471c598213edc25cc80e81dc35fb189a", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -171,10 +171,10 @@ compact_blocks (void)\n \t}\n       gcc_assert (i == n_basic_blocks_for_fn (cfun));\n \n-      for (; i < last_basic_block; i++)\n+      for (; i < last_basic_block_for_fn (cfun); i++)\n \tSET_BASIC_BLOCK_FOR_FN (cfun, i, NULL);\n     }\n-  last_basic_block = n_basic_blocks_for_fn (cfun);\n+  last_basic_block_for_fn (cfun) = n_basic_blocks_for_fn (cfun);\n }\n \n /* Remove block B from the basic block array.  */"}, {"sha": "9900d823e36bf99119e77c639066be25f56456ca", "filename": "gcc/cfganal.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -72,15 +72,15 @@ mark_dfs_back_edges (void)\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n-  pre = XCNEWVEC (int, last_basic_block);\n-  post = XCNEWVEC (int, last_basic_block);\n+  pre = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n+  post = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -428,8 +428,8 @@ control_dependences::control_dependences (struct edge_list *edges)\n   : m_el (edges)\n {\n   timevar_push (TV_CONTROL_DEPENDENCES);\n-  control_dependence_map.create (last_basic_block);\n-  for (int i = 0; i < last_basic_block; ++i)\n+  control_dependence_map.create (last_basic_block_for_fn (cfun));\n+  for (int i = 0; i < last_basic_block_for_fn (cfun); ++i)\n     control_dependence_map.quick_push (BITMAP_ALLOC (NULL));\n   for (int i = 0; i < NUM_EDGES (m_el); ++i)\n     find_control_dependence (i);\n@@ -622,7 +622,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -778,7 +778,7 @@ inverted_post_order_compute (int *post_order)\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -931,7 +931,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n     rev_post_order_num -= NUM_FIXED_BLOCKS;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n@@ -1062,7 +1062,7 @@ flow_dfs_compute_reverse_init (depth_first_search_ds data)\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  data->visited_blocks = sbitmap_alloc (last_basic_block);\n+  data->visited_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (data->visited_blocks);\n@@ -1147,7 +1147,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n #define VISITED_P(BB) (bitmap_bit_p (visited, (BB)->index))\n \n   /* Resize the VISITED sbitmap if necessary.  */\n-  size = last_basic_block;\n+  size = last_basic_block_for_fn (cfun);\n   if (size < 10)\n     size = 10;\n \n@@ -1313,7 +1313,8 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n \t form, the basic blocks where new and/or old names are defined\n \t may have disappeared by CFG cleanup calls.  In this case,\n \t we may pull a non-existing block from the work stack.  */\n-      gcc_checking_assert (bb_index < (unsigned) last_basic_block);\n+      gcc_checking_assert (bb_index\n+\t\t\t   < (unsigned) last_basic_block_for_fn (cfun));\n \n       EXECUTE_IF_AND_COMPL_IN_BITMAP (&dfs[bb_index], phi_insertion_points,\n \t                              0, i, bi)\n@@ -1508,7 +1509,7 @@ single_pred_before_succ_order (void)\n   basic_block *order = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   unsigned n = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n   unsigned np, i;\n-  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n #define MARK_VISITED(BB) (bitmap_set_bit (visited, (BB)->index))\n #define VISITED_P(BB) (bitmap_bit_p (visited, (BB)->index))"}, {"sha": "f73bbc5cfb681df50fe9336fabc986abd2554120", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -209,7 +209,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n      nearly fully-connected CFGs.  In that case we spend a significant\n      amount of time searching the edge lists for duplicates.  */\n   if (forced_labels || cfun->cfg->max_jumptable_ents > 100)\n-    edge_cache = sbitmap_alloc (last_basic_block);\n+    edge_cache = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   /* By nature of the way these get numbered, ENTRY_BLOCK_PTR->next_bb block\n      is always the entry.  */"}, {"sha": "014f78b4f4e1eb2b80d12420f220e4505cb03765", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -501,7 +501,7 @@ add_scope_conflicts (void)\n   FOR_ALL_BB (bb)\n     bb->aux = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \n-  rpo = XNEWVEC (int, last_basic_block);\n+  rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   n_bbs = pre_and_rev_post_order_compute (NULL, rpo, false);\n \n   changed = true;\n@@ -5809,7 +5809,7 @@ gimple_expand_cfg (void)\n \t}\n     }\n \n-  blocks = sbitmap_alloc (last_basic_block);\n+  blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_ones (blocks);\n   find_many_sub_basic_blocks (blocks);\n   sbitmap_free (blocks);"}, {"sha": "24009655631649eedf346d607750e0f4ceda1a00", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -98,8 +98,8 @@ verify_flow_info (void)\n   basic_block *last_visited;\n \n   timevar_push (TV_CFG_VERIFY);\n-  last_visited = XCNEWVEC (basic_block, last_basic_block);\n-  edge_checksum = XCNEWVEC (size_t, last_basic_block);\n+  last_visited = XCNEWVEC (basic_block, last_basic_block_for_fn (cfun));\n+  edge_checksum = XCNEWVEC (size_t, last_basic_block_for_fn (cfun));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun);"}, {"sha": "9d28950916d93d6591a5406deadf8cb5d4e78563", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1364,7 +1364,7 @@ verify_loop_structure (void)\n       }\n \n   /* Check the recorded loop father and sizes of loops.  */\n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n@@ -1478,7 +1478,7 @@ verify_loop_structure (void)\n   if (loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n     {\n       /* Record old info.  */\n-      irreds = sbitmap_alloc (last_basic_block);\n+      irreds = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       FOR_EACH_BB (bb)\n \t{\n \t  edge_iterator ei;"}, {"sha": "84b61c1ab5a16f7cab862cd03aca8092a5de816a", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -64,7 +64,7 @@ just_once_each_iteration_p (const struct loop *loop, const_basic_block bb)\n \n    LOOPS is the loop tree.  */\n \n-#define LOOP_REPR(LOOP) ((LOOP)->num + last_basic_block)\n+#define LOOP_REPR(LOOP) ((LOOP)->num + last_basic_block_for_fn (cfun))\n #define BB_REPR(BB) ((BB)->index + 1)\n \n bool\n@@ -94,7 +94,7 @@ mark_irreducible_loops (void)\n     }\n \n   /* Create the edge lists.  */\n-  g = new_graph (last_basic_block + num);\n+  g = new_graph (last_basic_block_for_fn (cfun) + num);\n \n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n \t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)"}, {"sha": "2bb8b6a2c754b61782d53f35a1cc813eed672776", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -204,7 +204,7 @@ fix_bb_placements (basic_block from,\n       || from == base_loop->header)\n     return;\n \n-  in_queue = sbitmap_alloc (last_basic_block);\n+  in_queue = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_queue);\n   bitmap_set_bit (in_queue, from->index);\n   /* Prevent us from going out of the base_loop.  */\n@@ -348,7 +348,7 @@ remove_path (edge e)\n \n   n_bord_bbs = 0;\n   bord_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  seen = sbitmap_alloc (last_basic_block);\n+  seen = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (seen);\n \n   /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n@@ -623,7 +623,7 @@ update_dominators_in_loop (struct loop *loop)\n   basic_block *body;\n   unsigned i;\n \n-  seen = sbitmap_alloc (last_basic_block);\n+  seen = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (seen);\n   body = get_loop_body (loop);\n "}, {"sha": "5dc52a67087a95cb2392ead7dc1bbc17637afe9d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -328,7 +328,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n \n   BB_HEAD (bb) = head;\n   BB_END (bb) = end;\n-  bb->index = last_basic_block++;\n+  bb->index = last_basic_block_for_fn (cfun)++;\n   bb->flags = BB_NEW | BB_RTL;\n   link_block (bb, after);\n   SET_BASIC_BLOCK_FOR_FN (cfun, bb->index, bb);\n@@ -355,9 +355,12 @@ rtl_create_basic_block (void *headp, void *endp, basic_block after)\n   basic_block bb;\n \n   /* Grow the basic block array if needed.  */\n-  if ((size_t) last_basic_block >= basic_block_info_for_fn (cfun)->length ())\n+  if ((size_t) last_basic_block_for_fn (cfun)\n+      >= basic_block_info_for_fn (cfun)->length ())\n     {\n-      size_t new_size = last_basic_block + (last_basic_block + 3) / 4;\n+      size_t new_size =\n+\t(last_basic_block_for_fn (cfun)\n+\t + (last_basic_block_for_fn (cfun) + 3) / 4);\n       vec_safe_grow_cleared (basic_block_info_for_fn (cfun), new_size);\n     }\n \n@@ -4252,7 +4255,7 @@ break_superblocks (void)\n   bool need = false;\n   basic_block bb;\n \n-  superblocks = sbitmap_alloc (last_basic_block);\n+  superblocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (superblocks);\n \n   FOR_EACH_BB (bb)\n@@ -4778,7 +4781,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n {\n   int i;\n   int blocks_split = 0;\n-  int last_bb = last_basic_block;\n+  int last_bb = last_basic_block_for_fn (cfun);\n   bool check_last_block = false;\n \n   if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)"}, {"sha": "a780254410d5de0ef7aa014b2c66cf49e29f3ed3", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -61,8 +61,8 @@ resolve_sw_modes (void)\n   bool need_commit = false;\n   bool finalize_fp_sets = (MACHINE_FUNCTION (cfun)->unknown_mode_sets == 0);\n \n-  todo.create (last_basic_block);\n-  pushed = sbitmap_alloc (last_basic_block);\n+  todo.create (last_basic_block_for_fn (cfun));\n+  pushed = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (pushed);\n   if (!finalize_fp_sets)\n     {"}, {"sha": "a5aeb75b3d53c67c451ebe7a4af81542f0f945e5", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -8067,8 +8067,8 @@ frv_optimize_membar (void)\n   rtx *last_membar;\n \n   compute_bb_for_insn ();\n-  first_io = XCNEWVEC (struct frv_io, last_basic_block);\n-  last_membar = XCNEWVEC (rtx, last_basic_block);\n+  first_io = XCNEWVEC (struct frv_io, last_basic_block_for_fn (cfun));\n+  last_membar = XCNEWVEC (rtx, last_basic_block_for_fn (cfun));\n \n   FOR_EACH_BB (bb)\n     frv_optimize_membar_local (bb, &first_io[bb->index],"}, {"sha": "f19478c10c8203f8f5dd35ad97bb5c78af30a763", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -15071,11 +15071,11 @@ r10k_insert_cache_barriers (void)\n \n   /* Bit X of PROTECTED_BBS is set if the last operation in basic block\n      X is protected by a cache barrier.  */\n-  protected_bbs = sbitmap_alloc (last_basic_block);\n+  protected_bbs = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (protected_bbs);\n \n   /* Iterate over the basic blocks in reverse post-order.  */\n-  rev_post_order = XNEWVEC (int, last_basic_block);\n+  rev_post_order = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   n = pre_and_rev_post_order_compute (NULL, rev_post_order, false);\n   for (i = 0; i < n; i++)\n     {"}, {"sha": "1a9895ea8e147763167927e5d7fa9f3050be412e", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2469,7 +2469,7 @@ spu_machine_dependent_reorg (void)\n       return;\n     }\n \n-  blocks = sbitmap_alloc (last_basic_block);\n+  blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (blocks);\n \n   in_spu_reorg = 1;"}, {"sha": "600c6178a22edc790f3d024dae1ce386a8ee6226", "filename": "gcc/cprop.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -595,8 +595,8 @@ compute_local_properties (sbitmap *kill, sbitmap *comp,\n   unsigned int i;\n \n   /* Initialize the bitmaps that were passed in.  */\n-  bitmap_vector_clear (kill, last_basic_block);\n-  bitmap_vector_clear (comp, last_basic_block);\n+  bitmap_vector_clear (kill, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n \n   for (i = 0; i < table->size; i++)\n     {\n@@ -1355,7 +1355,7 @@ find_implicit_sets (void)\n   rtx cond, new_rtx;\n   unsigned int count = 0;\n   bool edges_split = false;\n-  size_t implicit_sets_size = last_basic_block + 10;\n+  size_t implicit_sets_size = last_basic_block_for_fn (cfun) + 10;\n \n   implicit_sets = XCNEWVEC (rtx, implicit_sets_size);\n \n@@ -1667,7 +1667,7 @@ bypass_conditional_jumps (void)\n   if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return 0;\n \n-  bypass_last_basic_block = last_basic_block;\n+  bypass_last_basic_block = last_basic_block_for_fn (cfun);\n   mark_dfs_back_edges ();\n \n   changed = 0;\n@@ -1809,8 +1809,8 @@ one_cprop_pass (void)\n     df_analyze ();\n \n   /* Initialize implicit_set_indexes array.  */\n-  implicit_set_indexes = XNEWVEC (int, last_basic_block);\n-  for (i = 0; i < last_basic_block; i++)\n+  implicit_set_indexes = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  for (i = 0; i < last_basic_block_for_fn (cfun); i++)\n     implicit_set_indexes[i] = -1;\n \n   alloc_hash_table (&set_hash_table);\n@@ -1827,7 +1827,8 @@ one_cprop_pass (void)\n       basic_block bb;\n       rtx insn;\n \n-      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n+      alloc_cprop_mem (last_basic_block_for_fn (cfun),\n+\t\t       set_hash_table.n_elems);\n       compute_cprop_data ();\n \n       free (implicit_set_indexes);"}, {"sha": "74ae8babfd79e4515ed9ab0d6dabb1858a07f1e1", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -6522,7 +6522,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n {\n   struct cse_basic_block_data ebb_data;\n   basic_block bb;\n-  int *rc_order = XNEWVEC (int, last_basic_block);\n+  int *rc_order = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int i, n_blocks;\n \n   df_set_flags (DF_LR_RUN_DCE);\n@@ -6551,7 +6551,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n   reg_eqv_table = XNEWVEC (struct reg_eqv_elem, nregs);\n \n   /* Set up the table of already visited basic blocks.  */\n-  cse_visited_basic_blocks = sbitmap_alloc (last_basic_block);\n+  cse_visited_basic_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (cse_visited_basic_blocks);\n \n   /* Loop over basic blocks in reverse completion order (RPO),"}, {"sha": "d41fb726d777eddbc11d8abec8a35d3b1bb71822", "filename": "gcc/df-core.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -721,8 +721,8 @@ rest_of_handle_df_initialize (void)\n   if (optimize > 1)\n     df_live_add_problem ();\n \n-  df->postorder = XNEWVEC (int, last_basic_block);\n-  df->postorder_inverted = XNEWVEC (int, last_basic_block);\n+  df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   df->n_blocks = post_order_compute (df->postorder, true, true);\n   df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n   gcc_assert (df->n_blocks == df->n_blocks_inverted);\n@@ -1115,7 +1115,7 @@ df_worklist_dataflow (struct dataflow *dataflow,\n                       int n_blocks)\n {\n   bitmap pending = BITMAP_ALLOC (&df_bitmap_obstack);\n-  sbitmap considered = sbitmap_alloc (last_basic_block);\n+  sbitmap considered = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_iterator bi;\n   unsigned int *bbindex_to_postorder;\n   int i;\n@@ -1125,11 +1125,12 @@ df_worklist_dataflow (struct dataflow *dataflow,\n   gcc_assert (dir != DF_NONE);\n \n   /* BBINDEX_TO_POSTORDER maps the bb->index to the reverse postorder.  */\n-  bbindex_to_postorder = XNEWVEC (unsigned int, last_basic_block);\n+  bbindex_to_postorder = XNEWVEC (unsigned int,\n+\t\t\t\t  last_basic_block_for_fn (cfun));\n \n   /* Initialize the array to an out-of-bound value.  */\n-  for (i = 0; i < last_basic_block; i++)\n-    bbindex_to_postorder[i] = last_basic_block;\n+  for (i = 0; i < last_basic_block_for_fn (cfun); i++)\n+    bbindex_to_postorder[i] = last_basic_block_for_fn (cfun);\n \n   /* Initialize the considered map.  */\n   bitmap_clear (considered);\n@@ -1236,8 +1237,8 @@ df_analyze (void)\n \n   free (df->postorder);\n   free (df->postorder_inverted);\n-  df->postorder = XNEWVEC (int, last_basic_block);\n-  df->postorder_inverted = XNEWVEC (int, last_basic_block);\n+  df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   df->n_blocks = post_order_compute (df->postorder, true, true);\n   df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n \n@@ -1481,7 +1482,7 @@ df_set_bb_dirty (basic_block bb)\n void\n df_grow_bb_info (struct dataflow *dflow)\n {\n-  unsigned int new_size = last_basic_block + 1;\n+  unsigned int new_size = last_basic_block_for_fn (cfun) + 1;\n   if (dflow->block_info_size < new_size)\n     {\n       new_size += new_size / 4;\n@@ -1553,7 +1554,8 @@ df_compact_blocks (void)\n       /* Now shuffle the block info for the problem.  */\n       if (dflow->problem->free_bb_fun)\n \t{\n-\t  int size = last_basic_block * dflow->problem->block_info_elt_size;\n+\t  int size = (last_basic_block_for_fn (cfun)\n+\t\t      * dflow->problem->block_info_elt_size);\n \t  problem_temps = XNEWVAR (char, size);\n \t  df_grow_bb_info (dflow);\n \t  memcpy (problem_temps, dflow->block_info, size);\n@@ -1571,7 +1573,7 @@ df_compact_blocks (void)\n \t    }\n \t  memset ((char *)dflow->block_info\n \t\t  + i * dflow->problem->block_info_elt_size, 0,\n-\t\t  (last_basic_block - i)\n+\t\t  (last_basic_block_for_fn (cfun) - i)\n \t\t  * dflow->problem->block_info_elt_size);\n \t  free (problem_temps);\n \t}\n@@ -1608,7 +1610,7 @@ df_compact_blocks (void)\n \n   gcc_assert (i == n_basic_blocks_for_fn (cfun));\n \n-  for (; i < last_basic_block; i++)\n+  for (; i < last_basic_block_for_fn (cfun); i++)\n     SET_BASIC_BLOCK_FOR_FN (cfun, i, NULL);\n \n #ifdef DF_DEBUG_CFG"}, {"sha": "ab19372d83d8c9fa662d9cb2f8bccb83a9db1348", "filename": "gcc/df-problems.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1173,8 +1173,8 @@ df_lr_verify_solution_start (void)\n   df_lr->solutions_dirty = true;\n \n   problem_data = (struct df_lr_problem_data *)df_lr->problem_data;\n-  problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n-  problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n+  problem_data->in = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  problem_data->out = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n \n   FOR_ALL_BB (bb)\n     {\n@@ -1710,8 +1710,8 @@ df_live_verify_solution_start (void)\n   df_live->solutions_dirty = true;\n \n   problem_data = (struct df_live_problem_data *)df_live->problem_data;\n-  problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n-  problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n+  problem_data->in = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  problem_data->out = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n \n   FOR_ALL_BB (bb)\n     {\n@@ -4315,7 +4315,7 @@ df_md_local_compute (bitmap all_blocks)\n \n   bitmap_clear (&seen_in_insn);\n \n-  frontiers = XNEWVEC (bitmap_head, last_basic_block);\n+  frontiers = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n   FOR_ALL_BB (bb)\n     bitmap_initialize (&frontiers[bb->index], &bitmap_default_obstack);\n "}, {"sha": "af7307848b92e259b4cfdc7523725071b9a46cac", "filename": "gcc/dominance.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -159,7 +159,8 @@ init_dom_info (struct dom_info *di, enum cdi_direction dir)\n   init_ar (di->set_size, unsigned int, num, 1);\n   init_ar (di->set_child, TBB, num, 0);\n \n-  init_ar (di->dfs_order, TBB, (unsigned int) last_basic_block + 1, 0);\n+  init_ar (di->dfs_order, TBB,\n+\t   (unsigned int) last_basic_block_for_fn (cfun) + 1, 0);\n   init_ar (di->dfs_to_bb, basic_block, num, 0);\n \n   di->dfsnum = 1;\n@@ -296,7 +297,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n \t  if (bb != en_block)\n \t    my_i = di->dfs_order[bb->index];\n \t  else\n-\t    my_i = di->dfs_order[last_basic_block];\n+\t    my_i = di->dfs_order[last_basic_block_for_fn (cfun)];\n \t  child_i = di->dfs_order[bn->index] = di->dfsnum++;\n \t  di->dfs_to_bb[child_i] = bn;\n \t  di->dfs_parent[child_i] = my_i;\n@@ -335,7 +336,7 @@ calc_dfs_tree (struct dom_info *di, bool reverse)\n   /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n   basic_block begin = (reverse\n \t\t       ? EXIT_BLOCK_PTR_FOR_FN (cfun) : ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  di->dfs_order[last_basic_block] = di->dfsnum;\n+  di->dfs_order[last_basic_block_for_fn (cfun)] = di->dfsnum;\n   di->dfs_to_bb[di->dfsnum] = begin;\n   di->dfsnum++;\n \n@@ -367,7 +368,8 @@ calc_dfs_tree (struct dom_info *di, bool reverse)\n \t  bitmap_set_bit (di->fake_exit_edge, b->index);\n \t  di->dfs_order[b->index] = di->dfsnum;\n \t  di->dfs_to_bb[di->dfsnum] = b;\n-\t  di->dfs_parent[di->dfsnum] = di->dfs_order[last_basic_block];\n+\t  di->dfs_parent[di->dfsnum] =\n+\t    di->dfs_order[last_basic_block_for_fn (cfun)];\n \t  di->dfsnum++;\n \t  calc_dfs_tree_nonrec (di, b, reverse);\n \t}\n@@ -384,7 +386,8 @@ calc_dfs_tree (struct dom_info *di, bool reverse)\n \t      bitmap_set_bit (di->fake_exit_edge, b2->index);\n \t      di->dfs_order[b2->index] = di->dfsnum;\n \t      di->dfs_to_bb[di->dfsnum] = b2;\n-\t      di->dfs_parent[di->dfsnum] = di->dfs_order[last_basic_block];\n+\t      di->dfs_parent[di->dfsnum] =\n+\t\tdi->dfs_order[last_basic_block_for_fn (cfun)];\n \t      di->dfsnum++;\n \t      calc_dfs_tree_nonrec (di, b2, reverse);\n \t      gcc_checking_assert (di->dfs_order[b->index]);\n@@ -546,7 +549,7 @@ calc_idoms (struct dom_info *di, bool reverse)\n \t  if (b == en_block)\n \t    {\n \t    do_fake_exit_edge:\n-\t      k1 = di->dfs_order[last_basic_block];\n+\t      k1 = di->dfs_order[last_basic_block_for_fn (cfun)];\n \t    }\n \t  else\n \t    k1 = di->dfs_order[b->index];"}, {"sha": "e84c8f711a07e164cad72c3fcfa9b8817f305c4d", "filename": "gcc/domwalk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -159,7 +159,7 @@ dom_walker::walk (basic_block bb)\n     {\n       postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n       postorder_num = inverted_post_order_compute (postorder);\n-      bb_postorder = XNEWVEC (int, last_basic_block);\n+      bb_postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n       for (int i = 0; i < postorder_num; ++i)\n \tbb_postorder[postorder[i]] = i;\n       free (postorder);"}, {"sha": "a926cb8d458ef31dde00a679a1c81579bfd2635c", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -772,7 +772,7 @@ dse_step0 (void)\n \n   rtx_group_table.create (11);\n \n-  bb_table = XNEWVEC (bb_info_t, last_basic_block);\n+  bb_table = XNEWVEC (bb_info_t, last_basic_block_for_fn (cfun));\n   rtx_group_next_id = 0;\n \n   stores_off_frame_dead_at_return = !cfun->stdarg;\n@@ -3283,7 +3283,7 @@ static void\n dse_step3 (bool for_spills)\n {\n   basic_block bb;\n-  sbitmap unreachable_blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap unreachable_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   sbitmap_iterator sbi;\n   bitmap all_ones = NULL;\n   unsigned int i;"}, {"sha": "d257af4dda7617cab0859054a644fc3a3ab0a5d7", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -6498,7 +6498,7 @@ thread_prologue_and_epilogue_insns (void)\n       commit_edge_insertions ();\n \n       /* Look for basic blocks within the prologue insns.  */\n-      blocks = sbitmap_alloc (last_basic_block);\n+      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (blocks);\n       bitmap_set_bit (blocks, entry_edge->dest->index);\n       bitmap_set_bit (blocks, orig_entry_edge->dest->index);"}, {"sha": "fa25a4624111c2cb60680dc2d0a54626be9b285e", "filename": "gcc/gcse.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -633,8 +633,9 @@ alloc_gcse_mem (void)\n      pre-processor limitation with template types in macro arguments.  */\n   typedef vec<rtx> vec_rtx_heap;\n   typedef vec<modify_pair> vec_modify_pair_heap;\n-  modify_mem_list = GCNEWVEC (vec_rtx_heap, last_basic_block);\n-  canon_modify_mem_list = GCNEWVEC (vec_modify_pair_heap, last_basic_block);\n+  modify_mem_list = GCNEWVEC (vec_rtx_heap, last_basic_block_for_fn (cfun));\n+  canon_modify_mem_list = GCNEWVEC (vec_modify_pair_heap,\n+\t\t\t\t    last_basic_block_for_fn (cfun));\n   modify_mem_list_set = BITMAP_ALLOC (NULL);\n   blocks_with_calls = BITMAP_ALLOC (NULL);\n }\n@@ -685,13 +686,13 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n   /* Initialize any bitmaps that were passed in.  */\n   if (transp)\n     {\n-      bitmap_vector_ones (transp, last_basic_block);\n+      bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n     }\n \n   if (comp)\n-    bitmap_vector_clear (comp, last_basic_block);\n+    bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n   if (antloc)\n-    bitmap_vector_clear (antloc, last_basic_block);\n+    bitmap_vector_clear (antloc, last_basic_block_for_fn (cfun));\n \n   for (i = 0; i < table->size; i++)\n     {\n@@ -1972,7 +1973,7 @@ prune_insertions_deletions (int n_elems)\n \n   /* Similarly for deletions, but those occur in blocks rather than on\n      edges.  */\n-  for (i = 0; i < (unsigned) last_basic_block; i++)\n+  for (i = 0; i < (unsigned) last_basic_block_for_fn (cfun); i++)\n     {\n       EXECUTE_IF_SET_IN_BITMAP (pre_delete_map[i], 0, j, sbi)\n \tdeletions[j]++;\n@@ -1993,7 +1994,7 @@ prune_insertions_deletions (int n_elems)\n       for (i = 0; i < (unsigned) n_edges_for_fn (cfun); i++)\n \tbitmap_clear_bit (pre_insert_map[i], j);\n \n-      for (i = 0; i < (unsigned) last_basic_block; i++)\n+      for (i = 0; i < (unsigned) last_basic_block_for_fn (cfun); i++)\n \tbitmap_clear_bit (pre_delete_map[i], j);\n     }\n \n@@ -2012,7 +2013,7 @@ compute_pre_data (void)\n \n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   prune_expressions (true);\n-  bitmap_vector_clear (ae_kill, last_basic_block);\n+  bitmap_vector_clear (ae_kill, last_basic_block_for_fn (cfun));\n \n   /* Compute ae_kill for each basic block using:\n \n@@ -2103,7 +2104,7 @@ static int\n pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n {\n   int rval;\n-  char *visited = XCNEWVEC (char, last_basic_block);\n+  char *visited = XCNEWVEC (char, last_basic_block_for_fn (cfun));\n \n   rval = pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited);\n \n@@ -2687,7 +2688,7 @@ one_pre_gcse_pass (void)\n   if (expr_hash_table.n_elems > 0)\n     {\n       struct edge_list *edge_list;\n-      alloc_pre_mem (last_basic_block, expr_hash_table.n_elems);\n+      alloc_pre_mem (last_basic_block_for_fn (cfun), expr_hash_table.n_elems);\n       edge_list = compute_pre_data ();\n       changed |= pre_gcse (edge_list);\n       free_edge_list (edge_list);\n@@ -2816,8 +2817,8 @@ compute_code_hoist_vbeinout (void)\n   int changed, passes;\n   basic_block bb;\n \n-  bitmap_vector_clear (hoist_vbeout, last_basic_block);\n-  bitmap_vector_clear (hoist_vbein, last_basic_block);\n+  bitmap_vector_clear (hoist_vbeout, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (hoist_vbein, last_basic_block_for_fn (cfun));\n \n   passes = 0;\n   changed = 1;\n@@ -3033,7 +3034,7 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n   if (visited == NULL)\n     {\n       visited_allocated_locally = 1;\n-      visited = sbitmap_alloc (last_basic_block);\n+      visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (visited);\n     }\n \n@@ -3166,7 +3167,7 @@ hoist_code (void)\n      data to restrict distance an expression can travel.  */\n \n   to_bb_head = XCNEWVEC (int, get_max_uid ());\n-  bb_size = XCNEWVEC (int, last_basic_block);\n+  bb_size = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n \n   FOR_EACH_BB (bb)\n     {\n@@ -3622,7 +3623,8 @@ one_code_hoisting_pass (void)\n \n   if (expr_hash_table.n_elems > 0)\n     {\n-      alloc_code_hoist_mem (last_basic_block, expr_hash_table.n_elems);\n+      alloc_code_hoist_mem (last_basic_block_for_fn (cfun),\n+\t\t\t    expr_hash_table.n_elems);\n       compute_code_hoist_data ();\n       changed = hoist_code ();\n       free_code_hoist_mem ();"}, {"sha": "6c405d8cdc0fd005abaf1e20788dac7e54773912", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -157,7 +157,7 @@ draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n   int i, n;\n   sbitmap visited;\n \n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n \n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, true);"}, {"sha": "975db63942223e02837a2fc6944bb64d767c89e6", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -423,7 +423,7 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n static void\n build_scop_bbs (scop_p scop)\n {\n-  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   sese region = SCOP_REGION (scop);\n \n   bitmap_clear (visited);"}, {"sha": "d5e33095842d9e66fbb2057e8345e7739e87a632", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -8075,7 +8075,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n   if (first == last)\n     return;\n \n-  bb_header = XNEWVEC (rtx, last_basic_block);\n+  bb_header = XNEWVEC (rtx, last_basic_block_for_fn (cfun));\n \n   /* Make a sentinel.  */\n   if (last->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))"}, {"sha": "d5dfb8dcaf965c28138e79b9ede61003eb334c48", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1593,7 +1593,7 @@ execute_split_functions (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Compute local info about basic blocks and determine function size/time.  */\n-  bb_info_vec.safe_grow_cleared (last_basic_block + 1);\n+  bb_info_vec.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n   memset (&best_split_point, 0, sizeof (best_split_point));\n   FOR_EACH_BB (bb)\n     {"}, {"sha": "f9258ee3728a90b43898e821c7c75a53de559fed", "filename": "gcc/ira-build.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -138,9 +138,10 @@ create_loop_tree_nodes (void)\n \n   ira_bb_nodes\n     = ((struct ira_loop_tree_node *)\n-       ira_allocate (sizeof (struct ira_loop_tree_node) * last_basic_block));\n-  last_basic_block_before_change = last_basic_block;\n-  for (i = 0; i < (unsigned int) last_basic_block; i++)\n+       ira_allocate (sizeof (struct ira_loop_tree_node)\n+\t\t     * last_basic_block_for_fn (cfun)));\n+  last_basic_block_before_change = last_basic_block_for_fn (cfun);\n+  for (i = 0; i < (unsigned int) last_basic_block_for_fn (cfun); i++)\n     {\n       ira_bb_nodes[i].regno_allocno_map = NULL;\n       memset (ira_bb_nodes[i].reg_pressure, 0,\n@@ -2605,8 +2606,10 @@ remove_unnecessary_regions (bool all_p)\n     mark_all_loops_for_removal ();\n   else\n     mark_loops_for_removal ();\n-  children_vec.create (last_basic_block + number_of_loops (cfun));\n-  removed_loop_vec.create (last_basic_block + number_of_loops (cfun));\n+  children_vec.create (last_basic_block_for_fn (cfun)\n+\t\t       + number_of_loops (cfun));\n+  removed_loop_vec.create (last_basic_block_for_fn (cfun)\n+\t\t\t   + number_of_loops (cfun));\n   remove_uneccesary_loop_nodes_from_loop_tree (ira_loop_tree_root);\n   children_vec.release ();\n   if (all_p)"}, {"sha": "d59461b74bb3dedfceb82551e56159bbaf049be6", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1239,15 +1239,17 @@ ira_emit (bool loops_p)\n   edge e;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n+  size_t sz;\n \n   FOR_EACH_ALLOCNO (a, ai)\n     ALLOCNO_EMIT_DATA (a)->reg = regno_reg_rtx[ALLOCNO_REGNO (a)];\n   if (! loops_p)\n     return;\n-  at_bb_start = (move_t *) ira_allocate (sizeof (move_t) * last_basic_block);\n-  memset (at_bb_start, 0, sizeof (move_t) * last_basic_block);\n-  at_bb_end = (move_t *) ira_allocate (sizeof (move_t) * last_basic_block);\n-  memset (at_bb_end, 0, sizeof (move_t) * last_basic_block);\n+  sz = sizeof (move_t) * last_basic_block_for_fn (cfun);\n+  at_bb_start = (move_t *) ira_allocate (sz);\n+  memset (at_bb_start, 0, sz);\n+  at_bb_end = (move_t *) ira_allocate (sz);\n+  memset (at_bb_end, 0, sz);\n   local_allocno_bitmap = ira_allocate_bitmap ();\n   used_regno_bitmap = ira_allocate_bitmap ();\n   renamed_regno_bitmap = ira_allocate_bitmap ();"}, {"sha": "ae35035af15df96c98a1a0048086204f4b8b0318", "filename": "gcc/ira.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -4507,12 +4507,15 @@ find_moveable_pseudos (void)\n   int *uid_luid = XNEWVEC (int, max_uid);\n   rtx *closest_uses = XNEWVEC (rtx, max_regs);\n   /* A set of registers which are live but not modified throughout a block.  */\n-  bitmap_head *bb_transp_live = XNEWVEC (bitmap_head, last_basic_block);\n+  bitmap_head *bb_transp_live = XNEWVEC (bitmap_head,\n+\t\t\t\t\t last_basic_block_for_fn (cfun));\n   /* A set of registers which only exist in a given basic block.  */\n-  bitmap_head *bb_local = XNEWVEC (bitmap_head, last_basic_block);\n+  bitmap_head *bb_local = XNEWVEC (bitmap_head,\n+\t\t\t\t   last_basic_block_for_fn (cfun));\n   /* A set of registers which are set once, in an instruction that can be\n      moved freely downwards, but are otherwise transparent to a block.  */\n-  bitmap_head *bb_moveable_reg_sets = XNEWVEC (bitmap_head, last_basic_block);\n+  bitmap_head *bb_moveable_reg_sets = XNEWVEC (bitmap_head,\n+\t\t\t\t\t       last_basic_block_for_fn (cfun));\n   bitmap_head live, used, set, interesting, unusable_as_input;\n   bitmap_iterator bi;\n   bitmap_initialize (&interesting, 0);\n@@ -5187,7 +5190,8 @@ ira (FILE *f)\n      pseudos and 10K blocks or 100K pseudos and 1K blocks), we will\n      use simplified and faster algorithms in LRA.  */\n   lra_simple_p\n-    = (ira_use_lra_p && max_reg_num () >= (1 << 26) / last_basic_block);\n+    = (ira_use_lra_p\n+       && max_reg_num () >= (1 << 26) / last_basic_block_for_fn (cfun));\n   if (lra_simple_p)\n     {\n       /* It permits to skip live range splitting in LRA.  */"}, {"sha": "1129d6c65ea59dc1da7bff8ff20cf88ea3d7790c", "filename": "gcc/lcm.c", "status": "modified", "additions": 60, "deletions": 43, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -105,7 +105,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n-  bitmap_vector_ones (antin, last_basic_block);\n+  bitmap_vector_ones (antin, last_basic_block_for_fn (cfun));\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of ANTIN above.  */\n@@ -330,10 +330,10 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n   /* Computation of insertion and deletion points requires computing LATERIN\n      for the EXIT block.  We allocated an extra entry in the LATERIN array\n      for just this purpose.  */\n-  bitmap_ones (laterin[last_basic_block]);\n+  bitmap_ones (laterin[last_basic_block_for_fn (cfun)]);\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-    bitmap_and (laterin[last_basic_block],\n-\t\t     laterin[last_basic_block],\n+    bitmap_and (laterin[last_basic_block_for_fn (cfun)],\n+\t\t     laterin[last_basic_block_for_fn (cfun)],\n \t\t     later[(size_t) e->aux]);\n \n   clear_aux_for_edges ();\n@@ -359,7 +359,8 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n \n       if (b == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\tbitmap_and_compl (insert[x], later[x], laterin[last_basic_block]);\n+\tbitmap_and_compl (insert[x], later[x],\n+\t\t\t  laterin[last_basic_block_for_fn (cfun)]);\n       else\n \tbitmap_and_compl (insert[x], later[x], laterin[b->index]);\n     }\n@@ -389,29 +390,35 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n       fprintf (dump_file, \"Edge List:\\n\");\n       verify_edge_list (dump_file, edge_list);\n       print_edge_list (dump_file, edge_list);\n-      dump_bitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"antloc\", \"\", antloc, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"avloc\", \"\", avloc, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"kill\", \"\", kill, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"transp\", \"\", transp,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"antloc\", \"\", antloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"avloc\", \"\", avloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"kill\", \"\", kill,\n+\t\t\t  last_basic_block_for_fn (cfun));\n     }\n #endif\n \n   /* Compute global availability.  */\n-  avin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  avout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   compute_available (avloc, kill, avout, avin);\n   sbitmap_vector_free (avin);\n \n   /* Compute global anticipatability.  */\n-  antin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  antout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  antin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  antout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   compute_antinout_edge (antloc, transp, antin, antout);\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_bitmap_vector (dump_file, \"antin\", \"\", antin, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"antout\", \"\", antout, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"antin\", \"\", antin,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"antout\", \"\", antout,\n+\t\t\t  last_basic_block_for_fn (cfun));\n     }\n #endif\n \n@@ -431,23 +438,25 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n   later = sbitmap_vector_alloc (num_edges, n_exprs);\n \n   /* Allocate an extra element for the exit block in the laterin vector.  */\n-  laterin = sbitmap_vector_alloc (last_basic_block + 1, n_exprs);\n+  laterin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun) + 1,\n+\t\t\t\t  n_exprs);\n   compute_laterin (edge_list, earliest, antloc, later, laterin);\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_bitmap_vector (dump_file, \"laterin\", \"\", laterin, last_basic_block + 1);\n+      dump_bitmap_vector (dump_file, \"laterin\", \"\", laterin,\n+\t\t\t  last_basic_block_for_fn (cfun) + 1);\n       dump_bitmap_vector (dump_file, \"later\", \"\", later, num_edges);\n     }\n #endif\n \n   sbitmap_vector_free (earliest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *del = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  *del = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   bitmap_vector_clear (*insert, num_edges);\n-  bitmap_vector_clear (*del, last_basic_block);\n+  bitmap_vector_clear (*del, last_basic_block_for_fn (cfun));\n   compute_insert_delete (edge_list, antloc, later, laterin, *insert, *del);\n \n   sbitmap_vector_free (laterin);\n@@ -458,7 +467,7 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n     {\n       dump_bitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n       dump_bitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n-\t\t\t   last_basic_block);\n+\t\t\t  last_basic_block_for_fn (cfun));\n     }\n #endif\n \n@@ -484,7 +493,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n     XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n \n   /* We want a maximal solution.  */\n-  bitmap_vector_ones (avout, last_basic_block);\n+  bitmap_vector_ones (avout, last_basic_block_for_fn (cfun));\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  */\n@@ -666,10 +675,10 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   /* Computation of insertion and deletion points requires computing NEAREROUT\n      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n      for just this purpose.  */\n-  bitmap_ones (nearerout[last_basic_block]);\n+  bitmap_ones (nearerout[last_basic_block_for_fn (cfun)]);\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n-    bitmap_and (nearerout[last_basic_block],\n-\t\t     nearerout[last_basic_block],\n+    bitmap_and (nearerout[last_basic_block_for_fn (cfun)],\n+\t\t     nearerout[last_basic_block_for_fn (cfun)],\n \t\t     nearer[(size_t) e->aux]);\n \n   clear_aux_for_edges ();\n@@ -694,7 +703,8 @@ compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n     {\n       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n       if (b == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\tbitmap_and_compl (insert[x], nearer[x], nearerout[last_basic_block]);\n+\tbitmap_and_compl (insert[x], nearer[x],\n+\t\t\t  nearerout[last_basic_block_for_fn (cfun)]);\n       else\n \tbitmap_and_compl (insert[x], nearer[x], nearerout[b->index]);\n     }\n@@ -719,15 +729,15 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n   edge_list = create_edge_list ();\n   num_edges = NUM_EDGES (edge_list);\n \n-  st_antin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  st_antout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  bitmap_vector_clear (st_antin, last_basic_block);\n-  bitmap_vector_clear (st_antout, last_basic_block);\n+  st_antin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  st_antout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  bitmap_vector_clear (st_antin, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (st_antout, last_basic_block_for_fn (cfun));\n   compute_antinout_edge (st_antloc, transp, st_antin, st_antout);\n \n   /* Compute global anticipatability.  */\n-  st_avout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  st_avin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  st_avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  st_avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   compute_available (st_avloc, kill, st_avout, st_avin);\n \n #ifdef LCM_DEBUG_INFO\n@@ -736,20 +746,26 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n       fprintf (dump_file, \"Edge List:\\n\");\n       verify_edge_list (dump_file, edge_list);\n       print_edge_list (dump_file, edge_list);\n-      dump_bitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_antin\", \"\", st_antin, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_antout\", \"\", st_antout, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_kill\", \"\", kill, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"transp\", \"\", transp,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_antin\", \"\", st_antin,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_antout\", \"\", st_antout,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_kill\", \"\", kill,\n+\t\t\t  last_basic_block_for_fn (cfun));\n     }\n #endif\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_bitmap_vector (dump_file, \"st_avout\", \"\", st_avout, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_avin\", \"\", st_avin, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_avout\", \"\", st_avout, last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_avin\", \"\", st_avin, last_basic_block_for_fn (cfun));\n     }\n #endif\n \n@@ -772,22 +788,23 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n   nearer = sbitmap_vector_alloc (num_edges, n_exprs);\n \n   /* Allocate an extra element for the entry block.  */\n-  nearerout = sbitmap_vector_alloc (last_basic_block + 1, n_exprs);\n+  nearerout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun) + 1,\n+\t\t\t\t    n_exprs);\n   compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n       dump_bitmap_vector (dump_file, \"nearerout\", \"\", nearerout,\n-\t\t\t   last_basic_block + 1);\n+\t\t\t   last_basic_block_for_fn (cfun) + 1);\n       dump_bitmap_vector (dump_file, \"nearer\", \"\", nearer, num_edges);\n     }\n #endif\n \n   sbitmap_vector_free (farthest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *del = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  *del = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n \t\t\t     *insert, *del);\n \n@@ -799,7 +816,7 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n     {\n       dump_bitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n       dump_bitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n-\t\t\t   last_basic_block);\n+\t\t\t   last_basic_block_for_fn (cfun));\n     }\n #endif\n   return edge_list;"}, {"sha": "24ed83ff596281ccb44bf49d1711602edd6f03ee", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2007,7 +2007,7 @@ static void\n opt_info_start_duplication (struct opt_info *opt_info)\n {\n   if (opt_info)\n-    opt_info->first_new_block = last_basic_block;\n+    opt_info->first_new_block = last_basic_block_for_fn (cfun);\n }\n \n /* Determine the number of iterations between initialization of the base\n@@ -2368,7 +2368,9 @@ apply_opt_in_copies (struct opt_info *opt_info,\n     for (ivts = opt_info->iv_to_split_head; ivts; ivts = ivts->next)\n       allocate_basic_variable (ivts);\n \n-  for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = opt_info->first_new_block;\n+       i < (unsigned) last_basic_block_for_fn (cfun);\n+       i++)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       orig_bb = get_bb_original (bb);\n@@ -2444,7 +2446,9 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   /* Rewrite also the original loop body.  Find them as originals of the blocks\n      in the last copied iteration, i.e. those that have\n      get_bb_copy (get_bb_original (bb)) == bb.  */\n-  for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = opt_info->first_new_block;\n+       i < (unsigned) last_basic_block_for_fn (cfun);\n+       i++)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       orig_bb = get_bb_original (bb);"}, {"sha": "60c47b963e9a4b2bd6db08e5b80239ea4d296af1", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1537,7 +1537,7 @@ decompose_multiword_subregs (bool decompose_copies)\n \n       propagate_pseudo_copies ();\n \n-      sub_blocks = sbitmap_alloc (last_basic_block);\n+      sub_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (sub_blocks);\n \n       EXECUTE_IF_SET_IN_BITMAP (decomposable_context, 0, regno, iter)"}, {"sha": "a677f86dcf555e17155d6abcff6aa9953f962a48", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -996,7 +996,7 @@ lra_create_live_ranges (bool all_p)\n   curr_point = 0;\n   point_freq_vec.create (get_max_uid () * 2);\n   lra_point_freq = point_freq_vec.address ();\n-  int *post_order_rev_cfg = XNEWVEC (int, last_basic_block);\n+  int *post_order_rev_cfg = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int n_blocks_inverted = inverted_post_order_compute (post_order_rev_cfg);\n   lra_assert (n_blocks_inverted == n_basic_blocks_for_fn (cfun));\n   for (i = n_blocks_inverted - 1; i >= 0; --i)"}, {"sha": "50a0786cdf260146f2238cbacd97e667865012d4", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2422,7 +2422,7 @@ lra (FILE *f)\n   if (cfun->can_throw_non_call_exceptions)\n     {\n       sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block);\n+      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);"}, {"sha": "a9e5069588895da7e6d27bd8f593b405ee2c8a38", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -480,7 +480,8 @@ optimize_mode_switching (void)\n \tentry_exit_extra = 3;\n #endif\n \tbb_info[n_entities]\n-\t  = XCNEWVEC (struct bb_info, last_basic_block + entry_exit_extra);\n+\t  = XCNEWVEC (struct bb_info,\n+\t\t      last_basic_block_for_fn (cfun) + entry_exit_extra);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];\n@@ -500,11 +501,11 @@ optimize_mode_switching (void)\n \n   /* Create the bitmap vectors.  */\n \n-  antic = sbitmap_vector_alloc (last_basic_block, n_entities);\n-  transp = sbitmap_vector_alloc (last_basic_block, n_entities);\n-  comp = sbitmap_vector_alloc (last_basic_block, n_entities);\n+  antic = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n+  transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n+  comp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n \n-  bitmap_vector_ones (transp, last_basic_block);\n+  bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n \n   for (j = n_entities - 1; j >= 0; j--)\n     {\n@@ -608,16 +609,16 @@ optimize_mode_switching (void)\n #endif /* NORMAL_MODE */\n     }\n \n-  kill = sbitmap_vector_alloc (last_basic_block, n_entities);\n+  kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n   for (i = 0; i < max_num_modes; i++)\n     {\n       int current_mode[N_ENTITIES];\n       sbitmap *del;\n       sbitmap *insert;\n \n       /* Set the anticipatable and computing arrays.  */\n-      bitmap_vector_clear (antic, last_basic_block);\n-      bitmap_vector_clear (comp, last_basic_block);\n+      bitmap_vector_clear (antic, last_basic_block_for_fn (cfun));\n+      bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);"}, {"sha": "c59aa0e268e04a641af23acbe02c6c3173a9a75b", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2898,7 +2898,7 @@ split_all_insns (void)\n   bool changed;\n   basic_block bb;\n \n-  blocks = sbitmap_alloc (last_basic_block);\n+  blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (blocks);\n   changed = false;\n "}, {"sha": "0438875679d15e83f70101c94edba307b8b96354", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1066,9 +1066,9 @@ copyprop_hardreg_forward (void)\n   sbitmap visited;\n   bool analyze_called = false;\n \n-  all_vd = XNEWVEC (struct value_data, last_basic_block);\n+  all_vd = XNEWVEC (struct value_data, last_basic_block_for_fn (cfun));\n \n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n \n   if (MAY_HAVE_DEBUG_INSNS)"}, {"sha": "3c242fb6649208660a9837de84f8f9a3768a9c28", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -668,7 +668,7 @@ regrename_analyze (bitmap bb_mask)\n   int n_bbs;\n   int *inverse_postorder;\n \n-  inverse_postorder = XNEWVEC (int, last_basic_block);\n+  inverse_postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   n_bbs = pre_and_rev_post_order_compute (NULL, inverse_postorder, false);\n \n   /* Gather some information about the blocks in this function.  */"}, {"sha": "15c6db5c94eb32e222e3c419721777b5b401dedf", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1283,7 +1283,7 @@ reload (rtx first, int global)\n   if (cfun->can_throw_non_call_exceptions)\n     {\n       sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block);\n+      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);"}, {"sha": "861d969fe9867299fb6b6681449b8bfdf90a5d2d", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1216,7 +1216,7 @@ init_resource_info (rtx epilogue_insn)\n \n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n   target_hash_table = XCNEWVEC (struct target_info *, TARGET_HASH_PRIME);\n-  bb_ticks = XCNEWVEC (int, last_basic_block);\n+  bb_ticks = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n \n   /* Set the BLOCK_FOR_INSN of each label that starts a basic block.  */\n   FOR_EACH_BB (bb)"}, {"sha": "a85ee5b033cca1f3079b5a96156ca987c637d0ce", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -642,23 +642,23 @@ haifa_find_rgns (void)\n      STACK, SP and DFS_NR are only used during the first traversal.  */\n \n   /* Allocate and initialize variables for the first traversal.  */\n-  max_hdr = XNEWVEC (int, last_basic_block);\n-  dfs_nr = XCNEWVEC (int, last_basic_block);\n+  max_hdr = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  dfs_nr = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   stack = XNEWVEC (edge_iterator, n_edges_for_fn (cfun));\n \n-  inner = sbitmap_alloc (last_basic_block);\n+  inner = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_ones (inner);\n \n-  header = sbitmap_alloc (last_basic_block);\n+  header = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (header);\n \n-  in_queue = sbitmap_alloc (last_basic_block);\n+  in_queue = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_queue);\n \n-  in_stack = sbitmap_alloc (last_basic_block);\n+  in_stack = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_stack);\n \n-  for (i = 0; i < last_basic_block; i++)\n+  for (i = 0; i < last_basic_block_for_fn (cfun); i++)\n     max_hdr[i] = -1;\n \n   #define EDGE_PASSED(E) (ei_end_p ((E)) || ei_edge ((E))->aux)\n@@ -799,8 +799,9 @@ haifa_find_rgns (void)\n       extend_regions_p = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS) > 0;\n       if (extend_regions_p)\n         {\n-          degree1 = XNEWVEC (int, last_basic_block);\n-          extended_rgn_header = sbitmap_alloc (last_basic_block);\n+          degree1 = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+          extended_rgn_header =\n+\t    sbitmap_alloc (last_basic_block_for_fn (cfun));\n           bitmap_clear (extended_rgn_header);\n \t}\n \n@@ -854,7 +855,8 @@ haifa_find_rgns (void)\n                 /* We save degree in case when we meet a too_large region\n \t\t   and cancel it.  We need a correct degree later when\n                    calling extend_rgns.  */\n-                memcpy (degree1, degree, last_basic_block * sizeof (int));\n+                memcpy (degree1, degree,\n+\t\t\tlast_basic_block_for_fn (cfun) * sizeof (int));\n \n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n@@ -1161,9 +1163,9 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \n   max_iter = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS);\n \n-  max_hdr = XNEWVEC (int, last_basic_block);\n+  max_hdr = XNEWVEC (int, last_basic_block_for_fn (cfun));\n \n-  order = XNEWVEC (int, last_basic_block);\n+  order = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   post_order_compute (order, false, false);\n \n   for (i = nblocks - 1; i >= 0; i--)\n@@ -1514,7 +1516,7 @@ compute_trg_info (int trg)\n   sp->is_speculative = 0;\n   sp->src_prob = REG_BR_PROB_BASE;\n \n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n \n   for (i = trg + 1; i < current_nr_blocks; i++)\n     {\n@@ -2936,11 +2938,11 @@ static void\n realloc_bb_state_array (int saved_last_basic_block)\n {\n   char *old_bb_state_array = bb_state_array;\n-  size_t lbb = (size_t) last_basic_block;\n+  size_t lbb = (size_t) last_basic_block_for_fn (cfun);\n   size_t slbb = (size_t) saved_last_basic_block;\n \n   /* Nothing to do if nothing changed since the last time this was called.  */\n-  if (saved_last_basic_block == last_basic_block)\n+  if (saved_last_basic_block == last_basic_block_for_fn (cfun))\n     return;\n \n   /* The selective scheduler doesn't use the state arrays.  */\n@@ -3060,7 +3062,7 @@ schedule_region (int rgn)\n       if (dbg_cnt (sched_block))\n         {\n \t  edge f;\n-\t  int saved_last_basic_block = last_basic_block;\n+\t  int saved_last_basic_block = last_basic_block_for_fn (cfun);\n \n \t  schedule_block (&curr_bb, bb_state[first_bb->index]);\n \t  gcc_assert (EBB_FIRST_BB (bb) == first_bb);\n@@ -3430,9 +3432,12 @@ void\n extend_regions (void)\n {\n   rgn_table = XRESIZEVEC (region, rgn_table, n_basic_blocks_for_fn (cfun));\n-  rgn_bb_table = XRESIZEVEC (int, rgn_bb_table, n_basic_blocks_for_fn (cfun));\n-  block_to_bb = XRESIZEVEC (int, block_to_bb, last_basic_block);\n-  containing_rgn = XRESIZEVEC (int, containing_rgn, last_basic_block);\n+  rgn_bb_table = XRESIZEVEC (int, rgn_bb_table,\n+\t\t\t     n_basic_blocks_for_fn (cfun));\n+  block_to_bb = XRESIZEVEC (int, block_to_bb,\n+\t\t\t    last_basic_block_for_fn (cfun));\n+  containing_rgn = XRESIZEVEC (int, containing_rgn,\n+\t\t\t       last_basic_block_for_fn (cfun));\n }\n \n void"}, {"sha": "f7cc9eca2c6cf97c8f9d3caa126188ce63c1e1b8", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -4095,14 +4095,14 @@ get_seqno_by_preds (rtx insn)\n void\n sel_extend_global_bb_info (void)\n {\n-  sel_global_bb_info.safe_grow_cleared (last_basic_block);\n+  sel_global_bb_info.safe_grow_cleared (last_basic_block_for_fn (cfun));\n }\n \n /* Extend region-scope data structures for basic blocks.  */\n static void\n extend_region_bb_info (void)\n {\n-  sel_region_bb_info.safe_grow_cleared (last_basic_block);\n+  sel_region_bb_info.safe_grow_cleared (last_basic_block_for_fn (cfun));\n }\n \n /* Extend all data structures to fit for all basic blocks.  */\n@@ -4905,9 +4905,10 @@ recompute_rev_top_order (void)\n   int *postorder;\n   int n_blocks, i;\n \n-  if (!rev_top_order_index || rev_top_order_index_len < last_basic_block)\n+  if (!rev_top_order_index\n+      || rev_top_order_index_len < last_basic_block_for_fn (cfun))\n     {\n-      rev_top_order_index_len = last_basic_block;\n+      rev_top_order_index_len = last_basic_block_for_fn (cfun);\n       rev_top_order_index = XRESIZEVEC (int, rev_top_order_index,\n                                         rev_top_order_index_len);\n     }\n@@ -6079,7 +6080,7 @@ sel_init_pipelining (void)\n \t\t       | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS);\n   current_loop_nest = NULL;\n \n-  bbs_in_loop_rgns = sbitmap_alloc (last_basic_block);\n+  bbs_in_loop_rgns = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (bbs_in_loop_rgns);\n \n   recompute_rev_top_order ();\n@@ -6145,13 +6146,13 @@ make_regions_from_the_rest (void)\n   /* LOOP_HDR[I] == -1 if I-th bb doesn't belong to any loop,\n      LOOP_HDR[I] == LOOP_HDR[J] iff basic blocks I and J reside within the same\n      loop.  */\n-  loop_hdr = XNEWVEC (int, last_basic_block);\n-  degree = XCNEWVEC (int, last_basic_block);\n+  loop_hdr = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  degree = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n \n \n   /* For each basic block that belongs to some loop assign the number\n      of innermost loop it belongs to.  */\n-  for (i = 0; i < last_basic_block; i++)\n+  for (i = 0; i < last_basic_block_for_fn (cfun); i++)\n     loop_hdr[i] = -1;\n \n   FOR_EACH_BB (bb)"}, {"sha": "808b0a753c622d410d32a8f2d8cf6b9ec41755e7", "filename": "gcc/store-motion.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -844,7 +844,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n   edge_iterator *stack, ei;\n   int sp;\n   edge act;\n-  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   rtx last, insn, note;\n   rtx mem = smexpr->pattern;\n \n@@ -1016,11 +1016,13 @@ build_store_vectors (void)\n \n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n-  st_avloc = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  bitmap_vector_clear (st_avloc, last_basic_block);\n+  st_avloc = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t   num_stores);\n+  bitmap_vector_clear (st_avloc, last_basic_block_for_fn (cfun));\n \n-  st_antloc = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  bitmap_vector_clear (st_antloc, last_basic_block);\n+  st_antloc = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t    num_stores);\n+  bitmap_vector_clear (st_antloc, last_basic_block_for_fn (cfun));\n \n   for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))\n     {\n@@ -1052,11 +1054,11 @@ build_store_vectors (void)\n \t}\n     }\n \n-  st_kill = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  bitmap_vector_clear (st_kill, last_basic_block);\n+  st_kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), num_stores);\n+  bitmap_vector_clear (st_kill, last_basic_block_for_fn (cfun));\n \n-  st_transp = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  bitmap_vector_clear (st_transp, last_basic_block);\n+  st_transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), num_stores);\n+  bitmap_vector_clear (st_transp, last_basic_block_for_fn (cfun));\n   regs_set_in_block = XNEWVEC (int, max_gcse_regno);\n \n   FOR_EACH_BB (bb)\n@@ -1095,10 +1097,14 @@ build_store_vectors (void)\n \n   if (dump_file)\n     {\n-      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_kill\", \"\", st_kill, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_transp\", \"\", st_transp, last_basic_block);\n-      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_kill\", \"\", st_kill,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_transp\", \"\", st_transp,\n+\t\t\t  last_basic_block_for_fn (cfun));\n+      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc,\n+\t\t\t  last_basic_block_for_fn (cfun));\n     }\n }\n "}, {"sha": "de6877a08f8b6d124a92748cdbaea1310c6ac8cc", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -230,9 +230,9 @@ find_trace (basic_block bb, basic_block *trace)\n static bool\n tail_duplicate (void)\n {\n-  fibnode_t *blocks = XCNEWVEC (fibnode_t, last_basic_block);\n+  fibnode_t *blocks = XCNEWVEC (fibnode_t, last_basic_block_for_fn (cfun));\n   basic_block *trace = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n-  int *counts = XNEWVEC (int, last_basic_block);\n+  int *counts = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int ninsns = 0, nduplicated = 0;\n   gcov_type weighted_insns = 0, traced_insns = 0;\n   fibheap_t heap = fibheap_new ();\n@@ -243,7 +243,7 @@ tail_duplicate (void)\n \n   /* Create an oversized sbitmap to reduce the chance that we need to\n      resize it.  */\n-  bb_seen = sbitmap_alloc (last_basic_block * 2);\n+  bb_seen = sbitmap_alloc (last_basic_block_for_fn (cfun) * 2);\n   bitmap_clear (bb_seen);\n   initialize_original_copy_tables ();\n "}, {"sha": "2a6597dc99a979547f8ef77b73b438a7cd9171c8", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1956,7 +1956,7 @@ tm_region_init (struct tm_region *region)\n   /* We could store this information in bb->aux, but we may get called\n      through get_all_tm_blocks() from another pass that may be already\n      using bb->aux.  */\n-  bb_regions.safe_grow_cleared (last_basic_block);\n+  bb_regions.safe_grow_cleared (last_basic_block_for_fn (cfun));\n \n   queue.safe_push (bb);\n   bb_regions[bb->index] = region;\n@@ -2628,7 +2628,7 @@ static vec<tm_region_p>\n get_bb_regions_instrumented (bool traverse_clones,\n \t\t\t     bool include_uninstrumented_p)\n {\n-  unsigned n = last_basic_block;\n+  unsigned n = last_basic_block_for_fn (cfun);\n   struct bb2reg_stuff stuff;\n   vec<tm_region_p> ret;\n "}, {"sha": "ec365b566d91b70ef4a471ea65250e70d7e632f1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -597,25 +597,28 @@ create_bb (void *h, void *e, basic_block after)\n      not have to clear the newly allocated basic block here.  */\n   bb = alloc_block ();\n \n-  bb->index = last_basic_block;\n+  bb->index = last_basic_block_for_fn (cfun);\n   bb->flags = BB_NEW;\n   set_bb_seq (bb, h ? (gimple_seq) h : NULL);\n \n   /* Add the new block to the linked list of blocks.  */\n   link_block (bb, after);\n \n   /* Grow the basic block array if needed.  */\n-  if ((size_t) last_basic_block == basic_block_info_for_fn (cfun)->length ())\n+  if ((size_t) last_basic_block_for_fn (cfun)\n+      == basic_block_info_for_fn (cfun)->length ())\n     {\n-      size_t new_size = last_basic_block + (last_basic_block + 3) / 4;\n+      size_t new_size =\n+\t(last_basic_block_for_fn (cfun)\n+\t + (last_basic_block_for_fn (cfun) + 3) / 4);\n       vec_safe_grow_cleared (basic_block_info_for_fn (cfun), new_size);\n     }\n \n   /* Add the newly created block to the array.  */\n-  SET_BASIC_BLOCK_FOR_FN (cfun, last_basic_block, bb);\n+  SET_BASIC_BLOCK_FOR_FN (cfun, last_basic_block_for_fn (cfun), bb);\n \n   n_basic_blocks_for_fn (cfun)++;\n-  last_basic_block++;\n+  last_basic_block_for_fn (cfun)++;\n \n   return bb;\n }\n@@ -1228,7 +1231,7 @@ void\n cleanup_dead_labels (void)\n {\n   basic_block bb;\n-  label_for_bb = XCNEWVEC (struct label_record, last_basic_block);\n+  label_for_bb = XCNEWVEC (struct label_record, last_basic_block_for_fn (cfun));\n \n   /* Find a suitable label for each block.  We use the first user-defined\n      label if there is one, or otherwise just the first label we see.  */\n@@ -2116,7 +2119,7 @@ gimple_dump_cfg (FILE *file, int flags)\n       dump_function_header (file, current_function_decl, flags);\n       fprintf (file, \";; \\n%d basic blocks, %d edges, last basic block %d.\\n\\n\",\n \t       n_basic_blocks_for_fn (cfun), n_edges_for_fn (cfun),\n-\t       last_basic_block);\n+\t       last_basic_block_for_fn (cfun));\n \n       brief_dump_cfg (file, flags | TDF_COMMENT);\n       fprintf (file, \"\\n\");\n@@ -7430,7 +7433,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n {\n   int i;\n   int blocks_split = 0;\n-  int last_bb = last_basic_block;\n+  int last_bb = last_basic_block_for_fn (cfun);\n   bool check_last_block = false;\n \n   if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)"}, {"sha": "50b4a6836aac02ee5841cbce19d1729233eda594", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -585,7 +585,7 @@ split_bbs_on_noreturn_calls (void)\n \t   BB is present in the cfg.  */\n \tif (bb == NULL\n \t    || bb->index < NUM_FIXED_BLOCKS\n-\t    || bb->index >= last_basic_block\n+\t    || bb->index >= last_basic_block_for_fn (cfun)\n \t    || BASIC_BLOCK_FOR_FN (cfun, bb->index) != bb\n \t    || !gimple_call_noreturn_p (stmt))\n \t  continue;\n@@ -642,7 +642,7 @@ cleanup_tree_cfg_1 (void)\n \n   /* Start by iterating over all basic blocks.  We cannot use FOR_EACH_BB,\n      since the basic blocks may get removed.  */\n-  n = last_basic_block;\n+  n = last_basic_block_for_fn (cfun);\n   for (i = NUM_FIXED_BLOCKS; i < n; i++)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, i);"}, {"sha": "ff5ccab4b5b5d9dc07148f297a508cf36f305a99", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1636,7 +1636,7 @@ tree_lower_complex (void)\n   update_parameter_components ();\n \n   /* ??? Ideally we'd traverse the blocks in breadth-first order.  */\n-  old_last_basic_block = last_basic_block;\n+  old_last_basic_block = last_basic_block_for_fn (cfun);\n   FOR_EACH_BB (bb)\n     {\n       if (bb->index >= old_last_basic_block)"}, {"sha": "ed06cb9c1708b05b588394f7da3a1b3823c1281b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2488,7 +2488,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \tnew_bb->loop_father = entry_block_map->loop_father;\n       }\n \n-  last = last_basic_block;\n+  last = last_basic_block_for_fn (cfun);\n \n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   bool can_make_abormal_goto\n@@ -2544,7 +2544,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   /* Zero out AUX fields of newly created block during EH edge\n      insertion. */\n-  for (; last < last_basic_block; last++)\n+  for (; last < last_basic_block_for_fn (cfun); last++)\n     {\n       if (need_debug_cleanup)\n \tmaybe_move_debug_stmts_to_successors (id,"}, {"sha": "b6d3dd7c518feea9f3c3ec9f2aebe06172eca45d", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -964,7 +964,7 @@ mark_phi_for_rewrite (basic_block bb, gimple phi)\n \n   bitmap_set_bit (blocks_with_phis_to_rewrite, idx);\n \n-  n = (unsigned) last_basic_block + 1;\n+  n = (unsigned) last_basic_block_for_fn (cfun) + 1;\n   if (phis_to_rewrite.length () < n)\n     phis_to_rewrite.safe_grow_cleared (n);\n \n@@ -2315,11 +2315,11 @@ rewrite_into_ssa (void)\n   /* Initialize the set of interesting blocks.  The callback\n      mark_def_sites will add to this set those blocks that the renamer\n      should process.  */\n-  interesting_blocks = sbitmap_alloc (last_basic_block);\n+  interesting_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (interesting_blocks);\n \n   /* Initialize dominance frontier.  */\n-  dfs = XNEWVEC (bitmap_head, last_basic_block);\n+  dfs = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n   FOR_EACH_BB (bb)\n     bitmap_initialize (&dfs[bb->index], &bitmap_default_obstack);\n \n@@ -2635,7 +2635,7 @@ prepare_def_site_for (tree name, bool insert_phi_p)\n   bb = gimple_bb (stmt);\n   if (bb)\n     {\n-      gcc_checking_assert (bb->index < last_basic_block);\n+      gcc_checking_assert (bb->index < last_basic_block_for_fn (cfun));\n       mark_block_for_update (bb);\n       mark_def_interesting (name, stmt, bb, insert_phi_p);\n     }\n@@ -3185,7 +3185,7 @@ update_ssa (unsigned update_flags)\n \n   blocks_with_phis_to_rewrite = BITMAP_ALLOC (NULL);\n   if (!phis_to_rewrite.exists ())\n-    phis_to_rewrite.create (last_basic_block + 1);\n+    phis_to_rewrite.create (last_basic_block_for_fn (cfun) + 1);\n   blocks_to_update = BITMAP_ALLOC (NULL);\n \n   /* Ensure that the dominance information is up-to-date.  */\n@@ -3269,7 +3269,7 @@ update_ssa (unsigned update_flags)\n \n       /* If the caller requested PHI nodes to be added, compute\n \t dominance frontiers.  */\n-      dfs = XNEWVEC (bitmap_head, last_basic_block);\n+      dfs = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n       FOR_EACH_BB (bb)\n \tbitmap_initialize (&dfs[bb->index], &bitmap_default_obstack);\n       compute_dominance_frontiers (dfs);\n@@ -3317,7 +3317,7 @@ update_ssa (unsigned update_flags)\n     get_var_info (sym)->info.current_def = NULL_TREE;\n \n   /* Now start the renaming process at START_BB.  */\n-  interesting_blocks = sbitmap_alloc (last_basic_block);\n+  interesting_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (interesting_blocks);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n     bitmap_set_bit (interesting_blocks, i);\n@@ -3340,9 +3340,10 @@ update_ssa (unsigned update_flags)\n       c = 0;\n       EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n \tc++;\n-      fprintf (dump_file, \"Number of blocks in CFG: %d\\n\", last_basic_block);\n+      fprintf (dump_file, \"Number of blocks in CFG: %d\\n\",\n+\t       last_basic_block_for_fn (cfun));\n       fprintf (dump_file, \"Number of blocks to update: %d (%3.0f%%)\\n\",\n-\t       c, PERCENT (c, last_basic_block));\n+\t       c, PERCENT (c, last_basic_block_for_fn (cfun)));\n \n       if (dump_flags & TDF_DETAILS)\n \t{"}, {"sha": "701dd44599cdc825a15e78c640ca96677048dc31", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1364,9 +1364,9 @@ tree_dce_init (bool aggressive)\n \n   if (aggressive)\n     {\n-      last_stmt_necessary = sbitmap_alloc (last_basic_block);\n+      last_stmt_necessary = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (last_stmt_necessary);\n-      bb_contains_live_stmts = sbitmap_alloc (last_basic_block);\n+      bb_contains_live_stmts = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (bb_contains_live_stmts);\n     }\n \n@@ -1432,7 +1432,8 @@ perform_tree_ssa_dce (bool aggressive)\n       calculate_dominance_info (CDI_POST_DOMINATORS);\n       cd = new control_dependences (create_edge_list ());\n \n-      visited_control_parents = sbitmap_alloc (last_basic_block);\n+      visited_control_parents =\n+\tsbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (visited_control_parents);\n \n       mark_dfs_back_edges ();"}, {"sha": "6cf60be8c59738e8bf268c1c53ddba3fd095f71f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -1793,7 +1793,7 @@ record_edge_info (basic_block bb)\n \t    {\n \t      int i;\n               int n_labels = gimple_switch_num_labels (stmt);\n-\t      tree *info = XCNEWVEC (tree, last_basic_block);\n+\t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n \t      edge e;\n \t      edge_iterator ei;\n "}, {"sha": "6ccf2fb32fa7c765736e50bca21c1cbf4f7be64d", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -960,17 +960,17 @@ new_tree_live_info (var_map map)\n \n   live = XNEW (struct tree_live_info_d);\n   live->map = map;\n-  live->num_blocks = last_basic_block;\n+  live->num_blocks = last_basic_block_for_fn (cfun);\n \n-  live->livein = XNEWVEC (bitmap_head, last_basic_block);\n+  live->livein = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n   FOR_EACH_BB (bb)\n     bitmap_initialize (&live->livein[bb->index], &liveness_bitmap_obstack);\n \n-  live->liveout = XNEWVEC (bitmap_head, last_basic_block);\n+  live->liveout = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n   FOR_EACH_BB (bb)\n     bitmap_initialize (&live->liveout[bb->index], &liveness_bitmap_obstack);\n \n-  live->work_stack = XNEWVEC (int, last_basic_block);\n+  live->work_stack = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   live->stack_top = live->work_stack;\n \n   live->global = BITMAP_ALLOC (&liveness_bitmap_obstack);\n@@ -1043,7 +1043,7 @@ live_worklist (tree_live_info_p live)\n {\n   unsigned b;\n   basic_block bb;\n-  sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n+  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n   bitmap tmp = BITMAP_ALLOC (&liveness_bitmap_obstack);\n \n   bitmap_clear (visited);"}, {"sha": "3aaf2b2c7ff338e10613a517ee2139e427eb5c71", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2401,7 +2401,7 @@ fill_always_executed_in_1 (struct loop *loop, sbitmap contains_call)\n static void\n fill_always_executed_in (void)\n {\n-  sbitmap contains_call = sbitmap_alloc (last_basic_block);\n+  sbitmap contains_call = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   basic_block bb;\n   struct loop *loop;\n "}, {"sha": "76d5958e9d6e0237c97ffa05548eeedb0e5eaef6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -728,13 +728,13 @@ copy_phi_node_args (unsigned first_new_block)\n {\n   unsigned i;\n \n-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = first_new_block; i < (unsigned) last_basic_block_for_fn (cfun); i++)\n     BASIC_BLOCK_FOR_FN (cfun, i)->flags |= BB_DUPLICATED;\n \n-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = first_new_block; i < (unsigned) last_basic_block_for_fn (cfun); i++)\n     add_phi_args_after_copy_bb (BASIC_BLOCK_FOR_FN (cfun, i));\n \n-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+  for (i = first_new_block; i < (unsigned) last_basic_block_for_fn (cfun); i++)\n     BASIC_BLOCK_FOR_FN (cfun, i)->flags &= ~BB_DUPLICATED;\n }\n \n@@ -772,7 +772,7 @@ gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n     verify_loop_closed_ssa (true);\n #endif\n \n-  first_new_block = last_basic_block;\n+  first_new_block = last_basic_block_for_fn (cfun);\n   if (!duplicate_loop_to_header_edge (loop, e, ndupl, wont_exit,\n \t\t\t\t      orig, to_remove, flags))\n     return false;"}, {"sha": "99c907f9ee5b6e3db191ac1dad159b3d136cf6b6", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -2441,7 +2441,7 @@ compute_antic (void)\n \n   /* If any predecessor edges are abnormal, we punt, so antic_in is empty.\n      We pre-build the map of blocks with incoming abnormal edges here.  */\n-  has_abnormal_preds = sbitmap_alloc (last_basic_block);\n+  has_abnormal_preds = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (has_abnormal_preds);\n \n   FOR_ALL_BB (block)\n@@ -2470,7 +2470,7 @@ compute_antic (void)\n   /* At the exit block we anticipate nothing.  */\n   BB_VISITED (EXIT_BLOCK_PTR_FOR_FN (cfun)) = 1;\n \n-  changed_blocks = sbitmap_alloc (last_basic_block + 1);\n+  changed_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun) + 1);\n   bitmap_ones (changed_blocks);\n   while (changed)\n     {"}, {"sha": "55ae68bb732afdaee03ea07c4bae916e29046744", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -495,10 +495,10 @@ ssa_prop_init (void)\n   vec_alloc (interesting_ssa_edges, 20);\n   vec_alloc (varying_ssa_edges, 20);\n \n-  executable_blocks = sbitmap_alloc (last_basic_block);\n+  executable_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (executable_blocks);\n \n-  bb_in_list = sbitmap_alloc (last_basic_block);\n+  bb_in_list = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (bb_in_list);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "8106f83d4ad01d3655b9186fe7449b9765ad6e1c", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -4574,7 +4574,7 @@ init_reassoc (void)\n   /* Reverse RPO (Reverse Post Order) will give us something where\n      deeper loops come later.  */\n   pre_and_rev_post_order_compute (NULL, bbs, false);\n-  bb_rank = XCNEWVEC (long, last_basic_block);\n+  bb_rank = XCNEWVEC (long, last_basic_block_for_fn (cfun));\n   operand_rank = pointer_map_create ();\n \n   /* Give each default definition a distinct rank.  This includes"}, {"sha": "c27177826d5b7bdf1c85cd10a07032184e4f98b8", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -3984,7 +3984,7 @@ init_scc_vn (void)\n \n   shared_lookup_phiargs.create (0);\n   shared_lookup_references.create (0);\n-  rpo_numbers = XNEWVEC (int, last_basic_block);\n+  rpo_numbers = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   rpo_numbers_temp =\n     XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n   pre_and_rev_post_order_compute (NULL, rpo_numbers_temp, false);"}, {"sha": "a0eac6706188c0da15d30f12f6c73ddcea22d44a", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -771,7 +771,7 @@ init_worklist (void)\n {\n   alloc_aux_for_blocks (sizeof (struct aux_bb_info));\n   same_succ_htab.create (n_basic_blocks_for_fn (cfun));\n-  same_succ_edge_flags = XCNEWVEC (int, last_basic_block);\n+  same_succ_edge_flags = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   deleted_bbs = BITMAP_ALLOC (NULL);\n   deleted_bb_preds = BITMAP_ALLOC (NULL);\n   worklist.create (n_basic_blocks_for_fn (cfun));"}, {"sha": "d38e0dd2776c8c2fc80b4cfc59e2d746008b0066", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -179,7 +179,7 @@ associate_equivalences_with_edges (void)\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (cond))\n \t    {\n \t      int i, n_labels = gimple_switch_num_labels (stmt);\n-\t      tree *info = XCNEWVEC (tree, last_basic_block);\n+\t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n \n \t      /* Walk over the case label vector.  Record blocks\n \t\t which are reached by a single case label which represents"}, {"sha": "8b168e009f2c06e13693f1ac3288676d442d2486", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -72,7 +72,7 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n   if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n     return false;\n \n-  visited = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n   ret = true;\n "}, {"sha": "06b62596abbdad0b2b2193617f04e6943f53680c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -5934,13 +5934,13 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n static bool\n find_assert_locations (void)\n {\n-  int *rpo = XNEWVEC (int, last_basic_block);\n-  int *bb_rpo = XNEWVEC (int, last_basic_block);\n-  int *last_rpo = XCNEWVEC (int, last_basic_block);\n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   int rpo_cnt, i;\n   bool need_asserts;\n \n-  live = XCNEWVEC (sbitmap, last_basic_block);\n+  live = XCNEWVEC (sbitmap, last_basic_block_for_fn (cfun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n   for (i = 0; i < rpo_cnt; ++i)\n     bb_rpo[rpo[i]] = i;\n@@ -6034,7 +6034,7 @@ find_assert_locations (void)\n   XDELETEVEC (rpo);\n   XDELETEVEC (bb_rpo);\n   XDELETEVEC (last_rpo);\n-  for (i = 0; i < last_basic_block; ++i)\n+  for (i = 0; i < last_basic_block_for_fn (cfun); ++i)\n     if (live[i])\n       sbitmap_free (live[i]);\n   XDELETEVEC (live);"}, {"sha": "5bd0799e3db08fb34bfe6dec618c03e8c0138057", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=8b1c6fd7166bb33319ebc1d20fd9ca83d39b0079", "patch": "@@ -6928,17 +6928,17 @@ vt_find_locations (void)\n   /* Compute reverse completion order of depth first search of the CFG\n      so that the data-flow runs faster.  */\n   rc_order = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n-  bb_order = XNEWVEC (int, last_basic_block);\n+  bb_order = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   pre_and_rev_post_order_compute (NULL, rc_order, false);\n   for (i = 0; i < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; i++)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);\n \n   worklist = fibheap_new ();\n   pending = fibheap_new ();\n-  visited = sbitmap_alloc (last_basic_block);\n-  in_worklist = sbitmap_alloc (last_basic_block);\n-  in_pending = sbitmap_alloc (last_basic_block);\n+  visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  in_worklist = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  in_pending = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_worklist);\n \n   FOR_EACH_BB (bb)"}]}