{"sha": "2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "node_id": "C_kwDOANBUbNoAKDJmYmRjZjVlNThjODNhNjcxYjRkMDBmNzJiN2VmOTFjNDYyYjZmYzg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-25T13:24:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-25T15:16:33Z"}, "message": "libstdc++: Implement constexpr std::unique_ptr for C++23 (P2273R3)\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ptr_traits.h (__cpp_lib_constexpr_memory): Define\n\tconditionally.\n\t* include/bits/unique_ptr.h (__cpp_lib_constexpr_memory):\n\tDefine for C++23.\n\t(default_delete, default_delete<T[]>, __uniq_ptr_impl)\n\t(unique_ptr, unique_ptr<T[], D>): Add constexpr to all member\n\tfunctions.\n\t* include/std/version (__cpp_lib_constexpr_memory): Define new\n\tvalue for C++23.\n\t* testsuite/20_util/unique_ptr/assign/constexpr.cc: New test.\n\t* testsuite/20_util/unique_ptr/comparison/constexpr.cc: New test.\n\t* testsuite/20_util/unique_ptr/cons/constexpr_c++20.cc: New test.\n\t* testsuite/20_util/unique_ptr/creation/constexpr.cc: New test.\n\t* testsuite/20_util/unique_ptr/modifiers/constexpr.cc: New test.\n\t* testsuite/20_util/unique_ptr/specialized_algorithms/constexpr.cc:\n\tNew test.", "tree": {"sha": "430396d99d87c717c2caf14e2385278e90c78f31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/430396d99d87c717c2caf14e2385278e90c78f31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5cee0480c10bafa8ed65d49e5cedca23d98d7b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5cee0480c10bafa8ed65d49e5cedca23d98d7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5cee0480c10bafa8ed65d49e5cedca23d98d7b7"}], "stats": {"total": 487, "additions": 466, "deletions": 21}, "files": [{"sha": "047efa5cf280b78970c325fb2ca415a3378f87d5", "filename": "libstdc++-v3/include/bits/ptr_traits.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -36,7 +36,10 @@\n \n #if __cplusplus > 201703L\n #include <concepts>\n-#define __cpp_lib_constexpr_memory 201811L\n+# ifndef __cpp_lib_constexpr_memory\n+// Defined to a newer value in bits/unique_ptr.h for C++23\n+#  define __cpp_lib_constexpr_memory 201811L\n+# endif\n namespace __gnu_debug { struct _Safe_iterator_base; }\n #endif\n "}, {"sha": "ad60fada59bf491079b113f4b904ef13880bea89", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 104, "deletions": 20, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -41,6 +41,14 @@\n # include <ostream>\n #endif\n \n+#if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc\n+# if __cpp_lib_constexpr_memory < 202202L\n+// Defined with older value in bits/ptr_traits.h for C++20\n+#  undef __cpp_lib_constexpr_memory\n+#  define __cpp_lib_constexpr_memory 202202L\n+# endif\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -72,9 +80,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       template<typename _Up,\n \t       typename = _Require<is_convertible<_Up*, _Tp*>>>\n+\t_GLIBCXX23_CONSTEXPR\n         default_delete(const default_delete<_Up>&) noexcept { }\n \n       /// Calls `delete __ptr`\n+      _GLIBCXX23_CONSTEXPR\n       void\n       operator()(_Tp* __ptr) const\n       {\n@@ -108,10 +118,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       template<typename _Up,\n \t       typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>\n+\t_GLIBCXX23_CONSTEXPR\n         default_delete(const default_delete<_Up[]>&) noexcept { }\n \n       /// Calls `delete[] __ptr`\n       template<typename _Up>\n+\t_GLIBCXX23_CONSTEXPR\n \ttypename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type\n \toperator()(_Up* __ptr) const\n \t{\n@@ -152,28 +164,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     \" or an lvalue reference type\" );\n \n       __uniq_ptr_impl() = default;\n+      _GLIBCXX23_CONSTEXPR\n       __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }\n \n       template<typename _Del>\n-      __uniq_ptr_impl(pointer __p, _Del&& __d)\n+\t_GLIBCXX23_CONSTEXPR\n+\t__uniq_ptr_impl(pointer __p, _Del&& __d)\n \t: _M_t(__p, std::forward<_Del>(__d)) { }\n \n+      _GLIBCXX23_CONSTEXPR\n       __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept\n       : _M_t(std::move(__u._M_t))\n       { __u._M_ptr() = nullptr; }\n \n+      _GLIBCXX23_CONSTEXPR\n       __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept\n       {\n \treset(__u.release());\n \t_M_deleter() = std::forward<_Dp>(__u._M_deleter());\n \treturn *this;\n       }\n \n+      _GLIBCXX23_CONSTEXPR\n       pointer&   _M_ptr() noexcept { return std::get<0>(_M_t); }\n+      _GLIBCXX23_CONSTEXPR\n       pointer    _M_ptr() const noexcept { return std::get<0>(_M_t); }\n+      _GLIBCXX23_CONSTEXPR\n       _Dp&       _M_deleter() noexcept { return std::get<1>(_M_t); }\n+      _GLIBCXX23_CONSTEXPR\n       const _Dp& _M_deleter() const noexcept { return std::get<1>(_M_t); }\n \n+      _GLIBCXX23_CONSTEXPR\n       void reset(pointer __p) noexcept\n       {\n \tconst pointer __old_p = _M_ptr();\n@@ -182,13 +203,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_deleter()(__old_p);\n       }\n \n+      _GLIBCXX23_CONSTEXPR\n       pointer release() noexcept\n       {\n \tpointer __p = _M_ptr();\n \t_M_ptr() = nullptr;\n \treturn __p;\n       }\n \n+      _GLIBCXX23_CONSTEXPR\n       void\n       swap(__uniq_ptr_impl& __rhs) noexcept\n       {\n@@ -281,6 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * The deleter will be value-initialized.\n        */\n       template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>\n+\t_GLIBCXX23_CONSTEXPR\n \texplicit\n \tunique_ptr(pointer __p) noexcept\n \t: _M_t(__p)\n@@ -295,6 +319,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       template<typename _Del = deleter_type,\n \t       typename = _Require<is_copy_constructible<_Del>>>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(pointer __p, const deleter_type& __d) noexcept\n \t: _M_t(__p, __d) { }\n \n@@ -307,6 +332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       template<typename _Del = deleter_type,\n \t       typename = _Require<is_move_constructible<_Del>>>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(pointer __p,\n \t\t   __enable_if_t<!is_lvalue_reference<_Del>::value,\n \t\t\t\t _Del&&> __d) noexcept\n@@ -315,6 +341,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Del = deleter_type,\n \t       typename _DelUnref = typename remove_reference<_Del>::type>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(pointer,\n \t\t   __enable_if_t<is_lvalue_reference<_Del>::value,\n \t\t\t\t _DelUnref&&>) = delete;\n@@ -341,6 +368,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       __conditional_t<is_reference<_Dp>::value,\n \t\t\t       is_same<_Ep, _Dp>,\n \t\t\t       is_convertible<_Ep, _Dp>>>>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n \t{ }\n@@ -356,6 +384,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n       /// Destructor, invokes the deleter if the stored pointer is not null.\n+#if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc\n+      constexpr\n+#endif\n       ~unique_ptr() noexcept\n       {\n \tstatic_assert(__is_invocable<deleter_type&, pointer>::value,\n@@ -382,6 +413,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * Invokes the deleter if this object owns a pointer.\n        */\n       template<typename _Up, typename _Ep>\n+\t_GLIBCXX23_CONSTEXPR\n         typename enable_if< __and_<\n           __safe_conversion_up<_Up, _Ep>,\n           is_assignable<deleter_type&, _Ep&&>\n@@ -395,6 +427,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n+      _GLIBCXX23_CONSTEXPR\n       unique_ptr&\n       operator=(nullptr_t) noexcept\n       {\n@@ -405,6 +438,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Observers.\n \n       /// Dereference the stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       typename add_lvalue_reference<element_type>::type\n       operator*() const noexcept(noexcept(*std::declval<pointer>()))\n       {\n@@ -413,6 +447,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       /// Return the stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       pointer\n       operator->() const noexcept\n       {\n@@ -421,27 +456,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       /// Return the stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       pointer\n       get() const noexcept\n       { return _M_t._M_ptr(); }\n \n       /// Return a reference to the stored deleter.\n+      _GLIBCXX23_CONSTEXPR\n       deleter_type&\n       get_deleter() noexcept\n       { return _M_t._M_deleter(); }\n \n       /// Return a reference to the stored deleter.\n+      _GLIBCXX23_CONSTEXPR\n       const deleter_type&\n       get_deleter() const noexcept\n       { return _M_t._M_deleter(); }\n \n       /// Return @c true if the stored pointer is not null.\n+      _GLIBCXX23_CONSTEXPR\n       explicit operator bool() const noexcept\n       { return get() == pointer() ? false : true; }\n \n       // Modifiers.\n \n       /// Release ownership of any stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       pointer\n       release() noexcept\n       { return _M_t.release(); }\n@@ -452,6 +492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        * The deleter will be invoked if a pointer is already owned.\n        */\n+      _GLIBCXX23_CONSTEXPR\n       void\n       reset(pointer __p = pointer()) noexcept\n       {\n@@ -461,6 +502,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       /// Exchange the pointer and deleter with another object.\n+      _GLIBCXX23_CONSTEXPR\n       void\n       swap(unique_ptr& __u) noexcept\n       {\n@@ -551,6 +593,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       typename = _DeleterConstraint<_Vp>,\n \t       typename = typename enable_if<\n                  __safe_conversion_raw<_Up>::value, bool>::type>\n+\t_GLIBCXX23_CONSTEXPR\n \texplicit\n \tunique_ptr(_Up __p) noexcept\n \t: _M_t(__p)\n@@ -567,8 +610,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename _Del = deleter_type,\n \t       typename = _Require<__safe_conversion_raw<_Up>,\n \t\t\t\t   is_copy_constructible<_Del>>>\n-      unique_ptr(_Up __p, const deleter_type& __d) noexcept\n-      : _M_t(__p, __d) { }\n+\t_GLIBCXX23_CONSTEXPR\n+\tunique_ptr(_Up __p, const deleter_type& __d) noexcept\n+\t: _M_t(__p, __d) { }\n \n       /** Takes ownership of a pointer.\n        *\n@@ -581,6 +625,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Up, typename _Del = deleter_type,\n \t       typename = _Require<__safe_conversion_raw<_Up>,\n \t\t\t\t   is_move_constructible<_Del>>>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(_Up __p,\n \t\t   __enable_if_t<!is_lvalue_reference<_Del>::value,\n \t\t\t\t _Del&&> __d) noexcept\n@@ -608,11 +653,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       __conditional_t<is_reference<_Dp>::value,\n \t\t\t       is_same<_Ep, _Dp>,\n \t\t\t       is_convertible<_Ep, _Dp>>>>\n+\t_GLIBCXX23_CONSTEXPR\n \tunique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n \t: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n \t{ }\n \n       /// Destructor, invokes the deleter if the stored pointer is not null.\n+#if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc\n+      constexpr\n+#endif\n       ~unique_ptr()\n       {\n \tauto& __ptr = _M_t._M_ptr();\n@@ -638,6 +687,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * Invokes the deleter if this object owns a pointer.\n        */\n       template<typename _Up, typename _Ep>\n+\t_GLIBCXX23_CONSTEXPR\n \ttypename\n \tenable_if<__and_<__safe_conversion_up<_Up, _Ep>,\n                          is_assignable<deleter_type&, _Ep&&>\n@@ -651,6 +701,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       /// Reset the %unique_ptr to empty, invoking the deleter if necessary.\n+      _GLIBCXX23_CONSTEXPR\n       unique_ptr&\n       operator=(nullptr_t) noexcept\n       {\n@@ -661,6 +712,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Observers.\n \n       /// Access an element of owned array.\n+      _GLIBCXX23_CONSTEXPR\n       typename std::add_lvalue_reference<element_type>::type\n       operator[](size_t __i) const\n       {\n@@ -669,27 +721,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       /// Return the stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       pointer\n       get() const noexcept\n       { return _M_t._M_ptr(); }\n \n       /// Return a reference to the stored deleter.\n+      _GLIBCXX23_CONSTEXPR\n       deleter_type&\n       get_deleter() noexcept\n       { return _M_t._M_deleter(); }\n \n       /// Return a reference to the stored deleter.\n+      _GLIBCXX23_CONSTEXPR\n       const deleter_type&\n       get_deleter() const noexcept\n       { return _M_t._M_deleter(); }\n \n       /// Return @c true if the stored pointer is not null.\n+      _GLIBCXX23_CONSTEXPR\n       explicit operator bool() const noexcept\n       { return get() == pointer() ? false : true; }\n \n       // Modifiers.\n \n       /// Release ownership of any stored pointer.\n+      _GLIBCXX23_CONSTEXPR\n       pointer\n       release() noexcept\n       { return _M_t.release(); }\n@@ -712,14 +769,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                         >\n                   >\n                >>\n+      _GLIBCXX23_CONSTEXPR\n       void\n       reset(_Up __p) noexcept\n       { _M_t.reset(std::move(__p)); }\n \n+      _GLIBCXX23_CONSTEXPR\n       void reset(nullptr_t = nullptr) noexcept\n       { reset(pointer()); }\n \n       /// Exchange the pointer and deleter with another object.\n+      _GLIBCXX23_CONSTEXPR\n       void\n       swap(unique_ptr& __u) noexcept\n       {\n@@ -740,6 +800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n     // Constrained free swap overload, see p0185r1\n+    _GLIBCXX23_CONSTEXPR\n     typename enable_if<__is_swappable<_Dp>::value>::type\n #else\n     void\n@@ -758,49 +819,56 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Equality operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator==(const unique_ptr<_Tp, _Dp>& __x,\n \t       const unique_ptr<_Up, _Ep>& __y)\n     { return __x.get() == __y.get(); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n     { return !__x; }\n \n #ifndef __cpp_lib_three_way_comparison\n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD\n+    inline bool\n     operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n     { return !__x; }\n \n   /// Inequality operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD\n+    inline bool\n     operator!=(const unique_ptr<_Tp, _Dp>& __x,\n \t       const unique_ptr<_Up, _Ep>& __y)\n     { return __x.get() != __y.get(); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD\n+    inline bool\n     operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n     { return (bool)__x; }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD\n+    inline bool\n     operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n     { return (bool)__x; }\n #endif // three way comparison\n \n   /// Relational operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<(const unique_ptr<_Tp, _Dp>& __x,\n \t      const unique_ptr<_Up, _Ep>& __y)\n     {\n@@ -812,7 +880,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n     {\n       return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n@@ -821,7 +890,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n     {\n       return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n@@ -831,34 +901,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Relational operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<=(const unique_ptr<_Tp, _Dp>& __x,\n \t       const unique_ptr<_Up, _Ep>& __y)\n     { return !(__y < __x); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n     { return !(nullptr < __x); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n     { return !(__x < nullptr); }\n \n   /// Relational operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator>(const unique_ptr<_Tp, _Dp>& __x,\n \t      const unique_ptr<_Up, _Ep>& __y)\n     { return (__y < __x); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n     {\n       return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n@@ -867,7 +942,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n     {\n       return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n@@ -877,14 +953,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Relational operator for unique_ptr objects, compares the owned pointers\n   template<typename _Tp, typename _Dp,\n \t   typename _Up, typename _Ep>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator>=(const unique_ptr<_Tp, _Dp>& __x,\n \t       const unique_ptr<_Up, _Ep>& __y)\n     { return !(__x < __y); }\n \n   /// unique_ptr comparison with nullptr\n   template<typename _Tp, typename _Dp>\n-    _GLIBCXX_NODISCARD inline bool\n+    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR\n+    inline bool\n     operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n     { return !(__x < nullptr); }\n \n@@ -898,6 +976,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Dp, typename _Up, typename _Ep>\n     requires three_way_comparable_with<typename unique_ptr<_Tp, _Dp>::pointer,\n \t\t\t\t       typename unique_ptr<_Up, _Ep>::pointer>\n+    _GLIBCXX23_CONSTEXPR\n     inline\n     compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer,\n \t\t\t       typename unique_ptr<_Up, _Ep>::pointer>\n@@ -907,6 +986,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp, typename _Dp>\n     requires three_way_comparable<typename unique_ptr<_Tp, _Dp>::pointer>\n+    _GLIBCXX23_CONSTEXPR\n     inline\n     compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer>\n     operator<=>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n@@ -979,6 +1059,7 @@ namespace __detail\n    *  @relates unique_ptr\n    */\n   template<typename _Tp, typename... _Args>\n+    _GLIBCXX23_CONSTEXPR\n     inline __detail::__unique_ptr_t<_Tp>\n     make_unique(_Args&&... __args)\n     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }\n@@ -993,6 +1074,7 @@ namespace __detail\n    *  The array elements are value-initialized.\n    */\n   template<typename _Tp>\n+    _GLIBCXX23_CONSTEXPR\n     inline __detail::__unique_ptr_array_t<_Tp>\n     make_unique(size_t __num)\n     { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }\n@@ -1014,6 +1096,7 @@ namespace __detail\n    *  @relates unique_ptr\n    */\n   template<typename _Tp>\n+    _GLIBCXX23_CONSTEXPR\n     inline __detail::__unique_ptr_t<_Tp>\n     make_unique_for_overwrite()\n     { return unique_ptr<_Tp>(new _Tp); }\n@@ -1026,6 +1109,7 @@ namespace __detail\n    *  @relates unique_ptr\n    */\n   template<typename _Tp>\n+    _GLIBCXX23_CONSTEXPR\n     inline __detail::__unique_ptr_array_t<_Tp>\n     make_unique_for_overwrite(size_t __num)\n     { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]); }"}, {"sha": "22280e1a34974e41ba9c37dbdd202d027e27a27c", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -307,6 +307,10 @@\n \n #if _GLIBCXX_HOSTED\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n+#if __cpp_constexpr_dynamic_alloc\n+# undef __cpp_lib_constexpr_memory\n+# define __cpp_lib_constexpr_memory 202202L\n+#endif\n #if __cpp_concepts >= 202002L\n # define __cpp_lib_expected 202202L\n #endif"}, {"sha": "fb4acbda2d5b9c01dbb3a5b9aee5518440b439c5", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/constexpr.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fconstexpr.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_move()\n+{\n+  std::unique_ptr<int> p1(new int(2));\n+  std::unique_ptr<int> p2;\n+  p2 = std::move(p1);\n+  VERIFY( *p2 == 2 );\n+  std::unique_ptr<int[]> a1(new int[]{0, 1, 2});\n+  std::unique_ptr<int[]> a2;\n+  a2 = std::move(a1);\n+  VERIFY( a2[2] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_move() );\n+\n+constexpr bool\n+test_convert()\n+{\n+  std::unique_ptr<int> p1(new int(2));\n+  std::unique_ptr<const int> p2;\n+  p2 = std::move(p1);\n+  VERIFY( *p2 == 2 );\n+  std::unique_ptr<int[]> a1(new int[]{0, 1, 2});\n+  std::unique_ptr<const int[]> a2;\n+  a2 = std::move(a1);\n+  VERIFY( a2[2] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_convert() );\n+\n+constexpr bool\n+test_null()\n+{\n+  std::unique_ptr<int> p(new int(2));\n+  p = nullptr;\n+  VERIFY( !p );\n+  p = nullptr;\n+  return true;\n+}\n+static_assert( test_null() );"}, {"sha": "83e4f0826a8359f8cb9c6bfa93d395c32129061d", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/comparison/constexpr.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcomparison%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcomparison%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcomparison%2Fconstexpr.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_eq()\n+{\n+  std::unique_ptr<int> p1, p2;\n+  VERIFY( p1 == p2 );\n+  p1.reset(new int(1));\n+  VERIFY( p1 == p1 );\n+  VERIFY( p1 != p2 );\n+  struct null_deleter { constexpr void operator()(const void*) const { } };\n+  std::unique_ptr<const int[], null_deleter> p3(p1.get());\n+  VERIFY( p3 == p3 );\n+  VERIFY( p1 == p3 );\n+  VERIFY( p3 != p2 );\n+\n+  return true;\n+}\n+static_assert( test_eq() );\n+\n+constexpr bool\n+test_rel()\n+{\n+  std::unique_ptr<int> p1, p2;\n+  VERIFY( !(p1 < p2) );\n+  VERIFY( !(p1 > p2) );\n+  VERIFY( p1 <= p2 );\n+  VERIFY( p1 >= p2 );\n+  p1.reset(new int(1));\n+  VERIFY( p1 <= p1 );\n+  VERIFY( p1 >= p1 );\n+  VERIFY( p1 > p2 );\n+  VERIFY( p2 < p1 );\n+  VERIFY( p2 <= p1 );\n+  VERIFY( p1 >= p2 );\n+  struct null_deleter { constexpr void operator()(const void*) const { } };\n+  std::unique_ptr<const int[], null_deleter> p3(p1.get());\n+  VERIFY( p3 <= p3 );\n+  VERIFY( p3 >= p3 );\n+  VERIFY( p1 <= p3 );\n+  VERIFY( p3 > p2 );\n+  VERIFY( p3 >= p2 );\n+  VERIFY( p2 < p3 );\n+  VERIFY( p2 <= p3 );\n+\n+  return true;\n+}\n+static_assert( test_rel() );\n+\n+constexpr bool\n+test_3way()\n+{\n+  std::unique_ptr<int> p1, p2;\n+  VERIFY( (p1 <=> p1) == 0 );\n+  VERIFY( (p1 <=> p2) == 0 );\n+  p1.reset(new int(1));\n+  VERIFY( (p1 <=> p1) == 0 );\n+  VERIFY( (p1 <=> p2) > 0 );\n+  VERIFY( (p2 <=> p1) < 0 );\n+  struct null_deleter { constexpr void operator()(const void*) const { } };\n+  std::unique_ptr<const int[], null_deleter> p3(p1.get());\n+  VERIFY( (p3 <=> p3) == 0 );\n+  VERIFY( (p1 <=> p3) == 0 );\n+  VERIFY( (p3 <=> p2) > 0 );\n+  VERIFY( (p2 <=> p3) < 0 );\n+\n+  return true;\n+}\n+static_assert( test_3way() );"}, {"sha": "243d80aaba5ae6e9debd3338144e4cebec9cf54c", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/constexpr_c++20.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fconstexpr_c%2B%2B20.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,85 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+\n+#ifndef __cpp_lib_constexpr_memory\n+# error \"Feature test macro for constexpr unique_ptr is missing in <memory>\"\n+#elif __cpp_lib_constexpr_memory < 202202L\n+# error \"Feature test macro for constexpr unique_ptr has wrong value in <memory>\"\n+#endif\n+\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_default()\n+{\n+  std::unique_ptr<int> p;\n+  std::unique_ptr<int> np(nullptr);\n+  VERIFY( p == np );\n+\n+  std::unique_ptr<int[]> a;\n+  std::unique_ptr<int[]> na(nullptr);\n+  VERIFY( a == na );\n+\n+  return true;\n+}\n+static_assert( test_default() );\n+\n+constexpr bool\n+test_ptr()\n+{\n+  std::unique_ptr<int> p(new int(2));\n+  VERIFY( *p == 2 );\n+  std::unique_ptr<int[]> a(new int[]{0, 1, 2});\n+  VERIFY( a[2] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_ptr() );\n+\n+constexpr bool\n+test_del()\n+{\n+  const std::default_delete<int> pd;\n+  std::unique_ptr<int> p1(new int(1), pd);\n+  VERIFY( *p1 == 1 );\n+  std::unique_ptr<int> p2(new int(2), std::default_delete<int>{});\n+  VERIFY( *p2 == 2 );\n+  const std::default_delete<int[]> ad;\n+  std::unique_ptr<int[]> a1(new int[]{3, 4}, ad);\n+  VERIFY( a1[0] == 3 );\n+  std::unique_ptr<int[]> a2(new int[]{5, 6}, std::default_delete<int[]>{});\n+  VERIFY( a2[1] == 6 );\n+\n+  return true;\n+}\n+static_assert( test_del() );\n+\n+constexpr bool\n+test_move()\n+{\n+  std::unique_ptr<int> p1(new int(2));\n+  std::unique_ptr<int> p2 = std::move(p1);\n+  VERIFY( *p2 == 2 );\n+  std::unique_ptr<int[]> a1(new int[]{0, 1, 2});\n+  std::unique_ptr<int[]> a2 = std::move(a1);\n+  VERIFY( a2[2] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_move() );\n+\n+constexpr bool\n+test_convert()\n+{\n+  std::unique_ptr<int> p1(new int(2));\n+  std::unique_ptr<const int> p2 = std::move(p1);\n+  VERIFY( *p2 == 2 );\n+  std::unique_ptr<int[]> a1(new int[]{0, 1, 2});\n+  std::unique_ptr<const int[]> a2 = std::move(a1);\n+  VERIFY( a2[2] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_convert() );"}, {"sha": "90d11198578935b49aedfd57b0afe361a005f8f9", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/creation/constexpr.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcreation%2Fconstexpr.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_creation_single()\n+{\n+  std::unique_ptr<int> p = std::make_unique<int>(1);\n+  VERIFY( *p == 1 );\n+  p = std::make_unique_for_overwrite<int>();\n+  *p = 2;\n+  VERIFY( *p == 2 );\n+\n+  return true;\n+}\n+static_assert( test_creation_single() );\n+\n+constexpr bool\n+test_creation_array()\n+{\n+  std::unique_ptr<int[]> a = std::make_unique<int[]>(2);\n+  VERIFY( a[0] == 0 );\n+  VERIFY( a[1] == 0 );\n+  a = std::make_unique_for_overwrite<int[]>(2);\n+  a[0] = 1;\n+  a[1] = 2;\n+  VERIFY( a[0] == 1 );\n+  VERIFY( a[1] == 2 );\n+\n+  return true;\n+}\n+static_assert( test_creation_array() );"}, {"sha": "81908fdc0812cf403c8e6b7dd103a7d1f37f3079", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/constexpr.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Fconstexpr.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,68 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_release()\n+{\n+  std::unique_ptr<int> p1;\n+  int* r = p1.release();\n+  VERIFY( !r );\n+  VERIFY( !p1 );\n+\n+  std::unique_ptr<int> p2(new int(2));\n+  r = p2.release();\n+  VERIFY( r );\n+  VERIFY( !p2 );\n+  delete r;\n+\n+  std::unique_ptr<int[]> a1;\n+  r = a1.release();\n+  VERIFY( !r );\n+  VERIFY( !a1 );\n+\n+  std::unique_ptr<int[]> a2(new int[2]{});\n+  r = a2.release();\n+  VERIFY( r );\n+  VERIFY( !a2 );\n+  delete[] r;\n+\n+  return true;\n+}\n+static_assert( test_release() );\n+\n+constexpr bool\n+test_reset()\n+{\n+  std::unique_ptr<int> p1;\n+  p1.reset();\n+  VERIFY( !p1 );\n+  p1.reset(nullptr);\n+  VERIFY( !p1 );\n+  p1.reset(new int(2));\n+  VERIFY( *p1 == 2 );\n+  p1.reset(new int(3));\n+  VERIFY( *p1 == 3 );\n+  p1.reset(nullptr);\n+  VERIFY( !p1 );\n+\n+  std::unique_ptr<int[]> a1;\n+  a1.reset();\n+  VERIFY( !a1 );\n+  a1.reset(nullptr);\n+  VERIFY( !a1 );\n+  a1.reset(new int[]{2,3});\n+  VERIFY( a1[0] == 2 );\n+  a1.reset(new int[]{4,5,6});\n+  VERIFY( a1[1] == 5 );\n+  a1.reset(nullptr);\n+  VERIFY( !a1 );\n+\n+  std::unique_ptr<const int[]> a2;\n+  a2.reset(new int[2]{});\n+\n+  return true;\n+}\n+static_assert( test_reset() );"}, {"sha": "91a0165d2121b6b99d3194bac5e2b7a499dd2413", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/specialized_algorithms/constexpr.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fspecialized_algorithms%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fspecialized_algorithms%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fspecialized_algorithms%2Fconstexpr.cc?ref=2fbdcf5e58c83a671b4d00f72b7ef91c462b6fc8", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_swap_single()\n+{\n+  std::unique_ptr<int> p1;\n+  swap(p1, p1);\n+  VERIFY( !p1 );\n+  std::unique_ptr<int> p2;\n+  swap(p1, p2);\n+  VERIFY( !p1 && !p2 );\n+  std::unique_ptr<int> p3(new int(3));\n+  swap(p3, p3);\n+  VERIFY( *p3 == 3 );\n+  swap(p1, p3);\n+  VERIFY( *p1 == 3 );\n+  std::unique_ptr<int> p4(new int(4));\n+  swap(p4, p1);\n+  VERIFY( *p4 == 3 );\n+  VERIFY( *p1 == 4 );\n+\n+  return true;\n+}\n+static_assert( test_swap_single() );\n+\n+constexpr bool\n+test_swap_array()\n+{\n+  std::unique_ptr<int[]> a1;\n+  std::unique_ptr<int[]> a2;\n+  swap(a1, a2);\n+  VERIFY( !a1 && !a2 );\n+  std::unique_ptr<int[]> a3(new int[]{3});\n+  swap(a1, a3);\n+  VERIFY( a1[0] == 3 );\n+  std::unique_ptr<int[]> a4(new int[]{4, 5});\n+  swap(a1, a4);\n+  VERIFY( a1[1] == 5 );\n+\n+  return true;\n+}\n+static_assert( test_swap_array() );"}]}