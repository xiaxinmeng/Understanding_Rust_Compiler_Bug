{"sha": "8a72a0467609941a068dcd8688dc03cca92ea658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3MmEwNDY3NjA5OTQxYTA2OGRjZDg2ODhkYzAzY2NhOTJlYTY1OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-30T11:17:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-30T11:17:50Z"}, "message": "decl2.c (delete_sanity): Pass integer_zero_node, not integer_two_node, to build_vec_delete.\n\n\t* decl2.c (delete_sanity): Pass integer_zero_node, not\n\tinteger_two_node, to build_vec_delete.\n\t* init.c (build_array_eh_cleanup): Remove.\n\t(expand_vec_init_try_block): New function.\n\t(expand_vec_init_catch_clause): Likewise.\n\t(build_vec_delete_1): Don't deal with case that auto_delete_vec\n\tmight be integer_two_node anymore.\n\t(expand_vec_init): Rework for initialization-correctness and\n\texception-correctness.\n\t* typeck2.c (process_init_constructor): Make mutual exclusivity\n\tof cases more obvious.\n\nFrom-SVN: r23455", "tree": {"sha": "6ea7be7965d90cf685a21645babae0916ca28ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ea7be7965d90cf685a21645babae0916ca28ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a72a0467609941a068dcd8688dc03cca92ea658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a72a0467609941a068dcd8688dc03cca92ea658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a72a0467609941a068dcd8688dc03cca92ea658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a72a0467609941a068dcd8688dc03cca92ea658/comments", "author": null, "committer": null, "parents": [{"sha": "66d88624a90794771c7d17cbdfe34eceacb7924a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d88624a90794771c7d17cbdfe34eceacb7924a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d88624a90794771c7d17cbdfe34eceacb7924a"}], "stats": {"total": 370, "additions": 234, "deletions": 136}, "files": [{"sha": "e9be4735564936c3cf4034841c8e4cdefbfc976d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -1,3 +1,17 @@\n+1998-10-30  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl2.c (delete_sanity): Pass integer_zero_node, not\n+\tinteger_two_node, to build_vec_delete.\n+\t* init.c (build_array_eh_cleanup): Remove.\n+\t(expand_vec_init_try_block): New function.\n+\t(expand_vec_init_catch_clause): Likewise.\n+\t(build_vec_delete_1): Don't deal with case that auto_delete_vec\n+\tmight be integer_two_node anymore.\n+\t(expand_vec_init): Rework for initialization-correctness and\n+\texception-correctness.\n+\t* typeck2.c (process_init_constructor): Make mutual exclusivity\n+\tof cases more obvious.\n+\t\n 1998-10-29  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (lookup_name_real): OK, only warn if not lexing."}, {"sha": "cd7d515f33b1dcd7d908f7d08b5aaf0ae178489a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -1211,7 +1211,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \n   if (doing_vec)\n     return build_vec_delete (t, maxindex, integer_one_node,\n-\t\t\t     integer_two_node, use_global_delete);\n+\t\t\t     integer_zero_node, use_global_delete);\n   else\n     {\n       if (IS_AGGR_TYPE (TREE_TYPE (type))"}, {"sha": "fe1272e0ab4bacf53d4bf59c4bae411a3366e33e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 173, "deletions": 132, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -54,12 +54,13 @@ static tree build_vec_delete_1 PROTO((tree, tree, tree, tree, tree,\n static void perform_member_init PROTO((tree, tree, tree, int));\n static void sort_base_init PROTO((tree, tree *, tree *));\n static tree build_builtin_delete_call PROTO((tree));\n-static tree build_array_eh_cleanup PROTO((tree, tree, tree));\n static int member_init_ok_or_else PROTO((tree, tree, char *));\n static void expand_virtual_init PROTO((tree, tree));\n static tree sort_member_init PROTO((tree));\n static tree build_partial_cleanup_for PROTO((tree));\n static tree initializing_context PROTO((tree));\n+static void expand_vec_init_try_block PROTO((tree));\n+static void expand_vec_init_catch_clause PROTO((tree, tree, tree, tree));\n \n /* Cache the identifier nodes for the magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n@@ -2595,8 +2596,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n  no_destructor:\n   /* If the delete flag is one, or anything else with the low bit set,\n      delete the storage.  */\n-  if (auto_delete_vec == integer_zero_node\n-      || auto_delete_vec == integer_two_node)\n+  if (auto_delete_vec == integer_zero_node)\n     deallocate_expr = integer_zero_node;\n   else\n     {\n@@ -2652,18 +2652,80 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n     return cp_convert (void_type_node, body);\n }\n \n-/* Build a tree to cleanup partially built arrays.\n-   BASE is that starting address of the array.\n-   COUNT is the count of objects that have been built, that need destroying.\n-   TYPE is the type of elements in the array.  */\n+/* Protect the vector initialization with a try-block so that we can\n+   destroy the first few elements if constructing a later element\n+   causes an exception to be thrown.  TYPE is the type of the array\n+   elements.  */\n \n-static tree\n-build_array_eh_cleanup (base, count, type)\n-     tree base, count, type;\n+static void\n+expand_vec_init_try_block (type)\n+     tree type;\n+{\n+  if (!TYPE_NEEDS_DESTRUCTOR (type) || !flag_exceptions)\n+    return;\n+\n+  /* The code we generate looks like:\n+\n+       try {\n+         // Initialize the vector.\n+       } catch (...) {\n+         // Destory the elements that need destroying.\n+\t throw;\n+       } \n+\n+     Here we're just beginning the `try'.  */\n+\n+  expand_eh_region_start ();\n+}\n+\n+/* Add code to destroy the array elements constructed so far if the\n+   construction of some element in the array causes an exception to be\n+   thrown.  RVAL is the address of the last element in the array.\n+   TYPE is the type of the array elements.  MAXINDEX is the maximum\n+   allowable index into the array.  ITERATOR is an integer variable\n+   indicating how many elements remain to be constructed.  */\n+\n+static void\n+expand_vec_init_catch_clause (rval, type, maxindex, iterator)\n+     tree rval;\n+     tree type;\n+     tree maxindex;\n+     tree iterator;\n {\n-  tree expr = build_vec_delete_1 (base, count, type, integer_two_node,\n-\t\t\t\t  integer_zero_node, 0);\n-  return expr;\n+  tree e;\n+  tree cleanup;\n+\n+  if (!TYPE_NEEDS_DESTRUCTOR (type) || !flag_exceptions)\n+    return;\n+    \n+  /* We have to ensure that this can live to the cleanup expansion\n+     time, since we know it is only ever needed once, generate code\n+     now.  */\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+\n+  cleanup = make_node (RTL_EXPR);\n+  TREE_TYPE (cleanup) = void_type_node;\n+  RTL_EXPR_RTL (cleanup) = const0_rtx;\n+  TREE_SIDE_EFFECTS (cleanup) = 1;\n+  do_pending_stack_adjust ();\n+  start_sequence_for_rtl_expr (cleanup);\n+    \n+  e = build_vec_delete_1 (rval,\n+\t\t\t  build_binary_op (MINUS_EXPR, maxindex, \n+\t\t\t\t\t   iterator, 1),\n+\t\t\t  type,\n+\t\t\t  /*auto_delete_vec=*/integer_zero_node,\n+\t\t\t  /*auto_delete=*/integer_zero_node,\n+\t\t\t  /*use_global_delete=*/0);\n+  expand_expr (e, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  do_pending_stack_adjust ();\n+  RTL_EXPR_SEQUENCE (cleanup) = get_insns ();\n+  end_sequence ();\n+  cleanup = protect_with_terminate (cleanup);\n+  expand_eh_region_end (cleanup);\n+  pop_obstacks ();\n }\n \n /* `expand_vec_init' performs initialization of a vector of aggregate\n@@ -2689,9 +2751,12 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n      int from_array;\n {\n   tree rval;\n-  tree iterator, base2 = NULL_TREE;\n+  tree base2 = NULL_TREE;\n   tree type = TREE_TYPE (TREE_TYPE (base));\n   tree size;\n+  tree itype;\n+  tree iterator;\n+  int num_initialized_elts = 0;\n \n   maxindex = cp_convert (ptrdiff_type_node, maxindex);\n   if (maxindex == error_mark_node)\n@@ -2708,104 +2773,95 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \n   size = size_in_bytes (type);\n \n-  /* Set to zero in case size is <= 0.  Optimizer will delete this if\n-     it is not needed.  */\n-  rval = get_temp_regvar (build_pointer_type (type),\n-\t\t\t  cp_convert (build_pointer_type (type), null_pointer_node));\n   base = default_conversion (base);\n   base = cp_convert (build_pointer_type (type), base);\n-  expand_assignment (rval, base, 0, 0);\n+  rval = get_temp_regvar (build_pointer_type (type), base);\n   base = get_temp_regvar (build_pointer_type (type), base);\n+  iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n-  if (init != NULL_TREE\n-      && TREE_CODE (init) == CONSTRUCTOR\n-      && (! decl || TREE_TYPE (init) == TREE_TYPE (decl)))\n+  /* Protect the entire array initialization so that we can destroy\n+     the partially constructed array if an exception is thrown.  */\n+  expand_vec_init_try_block (type);\n+\n+  if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR\n+      && (!decl || comptypes (TREE_TYPE (init), \n+\t\t\t      TREE_TYPE (decl), 1)))\n     {\n-      /* Initialization of array from {...}.  */\n-      tree elts = CONSTRUCTOR_ELTS (init);\n+      /* Do non-default initialization resulting from brace-enclosed\n+\t initializers.  */\n+\n+      tree elts;\n       tree baseref = build1 (INDIRECT_REF, type, base);\n-      tree baseinc = build (PLUS_EXPR, build_pointer_type (type), base, size);\n-      int host_i = TREE_INT_CST_LOW (maxindex);\n \n-      if (IS_AGGR_TYPE (type))\n+      for (elts = CONSTRUCTOR_ELTS (init); elts; elts = TREE_CHAIN (elts))\n \t{\n-\t  while (elts)\n-\t    {\n-\t      host_i -= 1;\n-\t      expand_aggr_init (baseref, TREE_VALUE (elts), 0);\n+\t  tree elt = TREE_VALUE (elts);\n \n-\t      expand_assignment (base, baseinc, 0, 0);\n-\t      elts = TREE_CHAIN (elts);\n-\t    }\n-\t  /* Initialize any elements by default if possible.  */\n-\t  if (host_i >= 0)\n-\t    {\n-\t      if (TYPE_NEEDS_CONSTRUCTING (type) == 0)\n-\t\t{\n-\t\t  if (obey_regdecls)\n-\t\t    use_variable (DECL_RTL (base));\n-\t\t  goto done_init;\n-\t\t}\n+\t  num_initialized_elts++;\n \n-\t      iterator = get_temp_regvar (ptrdiff_type_node,\n-\t\t\t\t\t  build_int_2 (host_i, 0));\n-\t      init = NULL_TREE;\n-\t      goto init_by_default;\n-\t    }\n+\t  if (IS_AGGR_TYPE (type) || TREE_CODE (type) == ARRAY_TYPE)\n+\t    expand_aggr_init (baseref, elt, 0);\n+\t  else\n+\t    expand_assignment (baseref, elt, 0, 0);\n+\n+\t  expand_assignment (base, \n+\t\t\t     build (PLUS_EXPR, build_pointer_type (type),\n+\t\t\t\t    base, size),\n+\t\t\t     0, 0);\n+\t  expand_assignment (iterator,\n+\t\t\t     build (MINUS_EXPR, ptrdiff_type_node,\n+\t\t\t\t    iterator, integer_one_node),\n+\t\t\t     0, 0);\n \t}\n-      else\n-\twhile (elts)\n-\t  {\n-\t    expand_assignment (baseref, TREE_VALUE (elts), 0, 0);\n \n-\t    expand_assignment (base, baseinc, 0, 0);\n-\t    elts = TREE_CHAIN (elts);\n-\t  }\n+      /* Clear out INIT so that we don't get confused below.  */\n+      init = NULL_TREE;\n \n       if (obey_regdecls)\n \tuse_variable (DECL_RTL (base));\n     }\n-  else\n+  else if (from_array)\n     {\n-      tree itype;\n-\n-      iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n-\n-    init_by_default:\n-      itype = NULL_TREE;\n-\n-      /* If initializing one array from another,\n-\t initialize element by element.  */\n-      if (from_array)\n+      /* If initializing one array from another, initialize element by\n+\t element.  We rely upon the below calls the do argument\n+\t checking.  */ \n+      if (decl == NULL_TREE)\n \t{\n-\t  /* We rely upon the below calls the do argument checking */\n-\t  if (decl == NULL_TREE)\n-\t    {\n-\t      sorry (\"initialization of array from dissimilar array type\");\n-\t      return error_mark_node;\n-\t    }\n-\t  if (init)\n-\t    {\n-\t      base2 = default_conversion (init);\n-\t      itype = TREE_TYPE (base2);\n-\t      base2 = get_temp_regvar (itype, base2);\n-\t      itype = TREE_TYPE (itype);\n-\t    }\n-\t  else if (TYPE_LANG_SPECIFIC (type)\n-\t\t   && TYPE_NEEDS_CONSTRUCTING (type)\n-\t\t   && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n-\t    {\n-\t      error (\"initializer ends prematurely\");\n-\t      return error_mark_node;\n-\t    }\n+\t  sorry (\"initialization of array from dissimilar array type\");\n+\t  return error_mark_node;\n \t}\n+      if (init)\n+\t{\n+\t  base2 = default_conversion (init);\n+\t  itype = TREE_TYPE (base2);\n+\t  base2 = get_temp_regvar (itype, base2);\n+\t  itype = TREE_TYPE (itype);\n+\t}\n+      else if (TYPE_LANG_SPECIFIC (type)\n+\t       && TYPE_NEEDS_CONSTRUCTING (type)\n+\t       && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+\t{\n+\t  error (\"initializer ends prematurely\");\n+\t  return error_mark_node;\n+\t}\n+    }\n \n-      expand_start_cond (build (GE_EXPR, boolean_type_node,\n-\t\t\t\titerator, integer_zero_node), 0);\n-      if (TYPE_NEEDS_DESTRUCTOR (type))\n-\texpand_eh_region_start ();\n-      expand_start_loop_continue_elsewhere (1);\n+  /* Now, default-initialize any remaining elements.  We don't need to\n+     do that if a) the type does not need constructing, or b) we've\n+     already initialized all the elements.  */\n+  if (TYPE_NEEDS_CONSTRUCTING (type)\n+      && !(TREE_CODE (maxindex) == INTEGER_CST\n+\t   && num_initialized_elts == TREE_INT_CST_LOW (maxindex) + 1))\n+    {\n+      /* If the ITERATOR is equal to zero, then we don't have to loop;\n+\t we've already initialized all the elements.  */\n+      expand_start_cond (build (NE_EXPR, boolean_type_node,\n+\t\t\t\titerator, integer_zero_node), \n+\t\t\t 0);\n \n+      /* Otherwise, loop through the elements.  */\n+      expand_start_loop_continue_elsewhere (1);\n+  \n       /* The initialization of each array element is a full-expression.  */\n       expand_start_target_temps ();\n \n@@ -2832,70 +2888,55 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t{\n \t  if (init != 0)\n \t    sorry (\"cannot initialize multi-dimensional array with initializer\");\n-\t  expand_vec_init (decl, build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (type)), base),\n+\t  expand_vec_init (decl, \n+\t\t\t   build1 (NOP_EXPR, \n+\t\t\t\t   build_pointer_type (TREE_TYPE\n+\t\t\t\t\t\t       (type)),\n+\t\t\t\t   base),\n \t\t\t   array_type_nelts (type), 0, 0);\n \t}\n       else\n \texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0);\n \n       expand_assignment (base,\n-\t\t\t build (PLUS_EXPR, build_pointer_type (type), base, size),\n-\t\t\t 0, 0);\n+\t\t\t build (PLUS_EXPR, build_pointer_type (type), \n+\t\t\t\tbase, size), 0, 0);\n       if (base2)\n \texpand_assignment (base2,\n-\t\t\t   build (PLUS_EXPR, build_pointer_type (type), base2, size), 0, 0);\n+\t\t\t   build (PLUS_EXPR, build_pointer_type (type), \n+\t\t\t\t  base2, size), 0, 0);\n \n       /* Cleanup any temporaries needed for the initial value.  */\n       expand_end_target_temps ();\n-\n+  \n       expand_loop_continue_here ();\n       expand_exit_loop_if_false (0, build (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t   build (PREDECREMENT_EXPR, ptrdiff_type_node, iterator, integer_one_node), minus_one));\n-\n+\t\t\t\t\t   build (PREDECREMENT_EXPR, \n+\t\t\t\t\t\t  ptrdiff_type_node, \n+\t\t\t\t\t\t  iterator,\n+\t\t\t\t\t\t  integer_one_node), \n+\t\t\t\t\t   minus_one));\n+  \n       if (obey_regdecls)\n \t{\n \t  use_variable (DECL_RTL (base));\n \t  if (base2)\n \t    use_variable (DECL_RTL (base2));\n \t}\n+\n       expand_end_loop ();\n-      if (TYPE_NEEDS_DESTRUCTOR (type) && flag_exceptions)\n-\t{\n-\t  /* We have to ensure that this can live to the cleanup\n-\t     expansion time, since we know it is only ever needed\n-\t     once, generate code now.  */\n-\t  push_obstacks_nochange ();\n-\t  resume_temporary_allocation ();\n-\t  {\n-\t    tree e1, cleanup = make_node (RTL_EXPR);\n-\t    TREE_TYPE (cleanup) = void_type_node;\n-\t    RTL_EXPR_RTL (cleanup) = const0_rtx;\n-\t    TREE_SIDE_EFFECTS (cleanup) = 1;\n-\t    do_pending_stack_adjust ();\n-\t    start_sequence_for_rtl_expr (cleanup);\n-\n-\t    e1 = build_array_eh_cleanup\n-\t      (rval,\n-\t       build_binary_op (MINUS_EXPR, maxindex, iterator, 1),\n-\t       type);\n-\t    expand_expr (e1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    do_pending_stack_adjust ();\n-\t    RTL_EXPR_SEQUENCE (cleanup) = get_insns ();\n-\t    end_sequence ();\n-\n-\t    cleanup = protect_with_terminate (cleanup);\n-\t    expand_eh_region_end (cleanup);\n-\t  }\n-\t  pop_obstacks ();\n-\t}\n       expand_end_cond ();\n-      if (obey_regdecls)\n-\tuse_variable (DECL_RTL (iterator));\n     }\n- done_init:\n+\n+  /* Make sure to cleanup any partially constructed elements.  */\n+  expand_vec_init_catch_clause (rval, type, maxindex, iterator);\n \n   if (obey_regdecls)\n-    use_variable (DECL_RTL (rval));\n+    {\n+      use_variable (DECL_RTL (iterator));\n+      use_variable (DECL_RTL (rval));\n+    }\n+\n   return rval;\n }\n \n@@ -2990,7 +3031,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  return error_mark_node;\n \t}\n       return build_vec_delete (addr, array_type_nelts (type),\n-\t\t\t       auto_delete, integer_two_node,\n+\t\t\t       auto_delete, integer_zero_node,\n \t\t\t       use_global_delete);\n     }\n   else"}, {"sha": "908bb08beda1261d91bf1381cbad71e330457ca5", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -1006,7 +1006,7 @@ process_init_constructor (type, init, elts)\n \t  members = expr_tree_cons (NULL_TREE, next1, members);\n \t}\n     }\n-  if (TREE_CODE (type) == RECORD_TYPE)\n+  else if (TREE_CODE (type) == RECORD_TYPE)\n     {\n       register tree field;\n \n@@ -1108,8 +1108,7 @@ process_init_constructor (type, init, elts)\n \t\t     IDENTIFIER_POINTER (DECL_NAME (field)));\n \t}\n     }\n-\n-  if (TREE_CODE (type) == UNION_TYPE)\n+  else if (TREE_CODE (type) == UNION_TYPE)\n     {\n       register tree field = TYPE_FIELDS (type);\n       register tree next1;"}, {"sha": "0ecba7778aa4f710afa0d2be40f96e09384f05ef", "filename": "gcc/testsuite/g++.old-deja/g++.other/array1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray1.C?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -0,0 +1,26 @@\n+int i;\n+\n+struct S {\n+  S (int) {\n+    ++i;\n+    if (i == 3)\n+      throw 3;\n+  };\n+\n+  S () {}\n+\n+  ~S() {\n+    --i;\n+  }\n+};\n+\n+int main()\n+{\n+  try {\n+    S s[5] = { 0, 1, 2, 3, 4 };\n+  } catch (...) {\n+  }\n+\n+  if (i != 1)\n+    return 1;\n+}"}, {"sha": "255d8cce2d389e6aa0ee638a63ffb9ca3612304e", "filename": "gcc/testsuite/g++.old-deja/g++.other/array2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a72a0467609941a068dcd8688dc03cca92ea658/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray2.C?ref=8a72a0467609941a068dcd8688dc03cca92ea658", "patch": "@@ -0,0 +1,18 @@\n+int i;\n+\n+struct S {\n+  S () {\n+    ++i;\n+  };\n+\n+  S (int) {\n+  };\n+};\n+\n+int main()\n+{\n+  S s[3][3] = { 2 };\n+\n+  if (i != 8)\n+    return 1;\n+}"}]}