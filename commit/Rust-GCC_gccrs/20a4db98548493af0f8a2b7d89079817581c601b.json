{"sha": "20a4db98548493af0f8a2b7d89079817581c601b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhNGRiOTg1NDg0OTNhZjBmOGEyYjdkODkwNzk4MTc1ODFjNjAxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-03T19:43:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-03T19:43:31Z"}, "message": "alpha.c (alpha_emit_set_const_1): Re-order cases to prefer addition over compliments over shifts.\n\n        * alpha.c (alpha_emit_set_const_1): Re-order cases to prefer\n        addition over compliments over shifts.\n\nFrom-SVN: r32315", "tree": {"sha": "2b56afb715be0c289b7c99d44ecfd29d6d7bce7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b56afb715be0c289b7c99d44ecfd29d6d7bce7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a4db98548493af0f8a2b7d89079817581c601b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a4db98548493af0f8a2b7d89079817581c601b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a4db98548493af0f8a2b7d89079817581c601b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a4db98548493af0f8a2b7d89079817581c601b/comments", "author": null, "committer": null, "parents": [{"sha": "323eee8ae3938b3a5135b2b4d9615099de72762c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323eee8ae3938b3a5135b2b4d9615099de72762c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/323eee8ae3938b3a5135b2b4d9615099de72762c"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "118eadcf3787d7c6c3e535b9bb15d0339b9cf369", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a4db98548493af0f8a2b7d89079817581c601b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a4db98548493af0f8a2b7d89079817581c601b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20a4db98548493af0f8a2b7d89079817581c601b", "patch": "@@ -1,3 +1,8 @@\n+2000-03-03  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_emit_set_const_1): Re-order cases to prefer\n+\taddition over compliments over shifts.\n+\n Fri Mar  3 12:49:28 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload1.c (reload_combine_note_use): Handle return register USEs."}, {"sha": "601c1d2f5dfb6f47b283ce52bb0375a14991842b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a4db98548493af0f8a2b7d89079817581c601b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a4db98548493af0f8a2b7d89079817581c601b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=20a4db98548493af0f8a2b7d89079817581c601b", "patch": "@@ -1236,7 +1236,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n      HOST_WIDE_INT c;\n      int n;\n {\n-  HOST_WIDE_INT new = c;\n+  HOST_WIDE_INT new;\n   int i, bits;\n   /* Use a pseudo if highly optimizing and still generating RTL.  */\n   rtx subtarget\n@@ -1250,7 +1250,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n      cross-compiling on a narrow machine.  */\n \n   if (mode == SImode)\n-    c = (c & 0xffffffff) - 2 * (c & 0x80000000);\n+    c = ((c & 0xffffffff) ^ 0x80000000) - 0x80000000;\n #endif\n \n   /* If this is a sign-extended 32-bit constant, we can do this in at most\n@@ -1260,10 +1260,9 @@ alpha_emit_set_const_1 (target, mode, c, n)\n   if (HOST_BITS_PER_WIDE_INT != 64\n       || c >> 31 == -1 || c >> 31 == 0)\n     {\n-      HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n+      HOST_WIDE_INT low = ((c & 0xffff) ^ 0x8000) - 0x8000;\n       HOST_WIDE_INT tmp1 = c - low;\n-      HOST_WIDE_INT high\n-\t= ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+      HOST_WIDE_INT high = (((tmp1 >> 16) & 0xffff) ^ 0x8000) - 0x8000;\n       HOST_WIDE_INT extra = 0;\n \n       /* If HIGH will be interpreted as negative but the constant is\n@@ -1291,13 +1290,13 @@ alpha_emit_set_const_1 (target, mode, c, n)\n \t}\n       else if (n >= 2 + (extra != 0))\n \t{\n-\t  temp = copy_to_suggested_reg (GEN_INT (low), subtarget, mode);\n+\t  temp = copy_to_suggested_reg (GEN_INT (high << 16), subtarget, mode);\n \n \t  if (extra != 0)\n \t    temp = expand_binop (mode, add_optab, temp, GEN_INT (extra << 16),\n \t\t\t\t subtarget, 0, OPTAB_WIDEN);\n \n-\t  return expand_binop (mode, add_optab, temp, GEN_INT (high << 16),\n+\t  return expand_binop (mode, add_optab, temp, GEN_INT (low),\n \t\t\t       target, 0, OPTAB_WIDEN);\n \t}\n     }\n@@ -1311,34 +1310,22 @@ alpha_emit_set_const_1 (target, mode, c, n)\n       || (mode == SImode && ! rtx_equal_function_value_matters))\n     return 0;\n \n-#if HOST_BITS_PER_WIDE_INT == 64\n-  /* First, see if can load a value into the target that is the same as the\n-     constant except that all bytes that are 0 are changed to be 0xff.  If we\n-     can, then we can do a ZAPNOT to obtain the desired constant.  */\n-\n-  for (i = 0; i < 64; i += 8)\n-    if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n-      new |= (HOST_WIDE_INT) 0xff << i;\n-\n-  /* We are only called for SImode and DImode.  If this is SImode, ensure that\n-     we are sign extended to a full word.  */\n-\n-  if (mode == SImode)\n-    new = (new & 0xffffffff) - 2 * (new & 0x80000000);\n-\n-  if (new != c\n-      && (temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n-    return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n-\t\t\t target, 0, OPTAB_WIDEN);\n-#endif\n-\n   /* Next, see if we can load a related constant and then shift and possibly\n      negate it to get the constant we want.  Try this once each increasing\n      numbers of insns.  */\n \n   for (i = 1; i < n; i++)\n     {\n-      /* First try complementing.  */\n+      /* First, see if minus some low bits, we've an easy load of\n+\t high bits.  */\n+\n+      new = ((c & 0xffff) ^ 0x8000) - 0x8000;\n+      if (new != 0\n+          && (temp = alpha_emit_set_const (subtarget, mode, c - new, i)) != 0)\n+\treturn expand_binop (mode, add_optab, temp, GEN_INT (new),\n+\t\t\t     target, 0, OPTAB_WIDEN);\n+\n+      /* Next try complementing.  */\n       if ((temp = alpha_emit_set_const (subtarget, mode, ~ c, i)) != 0)\n \treturn expand_unop (mode, one_cmpl_optab, temp, target, 0);\n \n@@ -1354,8 +1341,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n       if ((bits = exact_log2 (c & - c)) > 0)\n \tfor (; bits > 0; bits--)\n \t  if ((temp = (alpha_emit_set_const\n-\t\t       (subtarget, mode,\n-\t\t\t(unsigned HOST_WIDE_INT) (c >> bits), i))) != 0\n+\t\t       (subtarget, mode, c >> bits, i))) != 0\n \t      || ((temp = (alpha_emit_set_const\n \t\t\t  (subtarget, mode,\n \t\t\t   ((unsigned HOST_WIDE_INT) c) >> bits, i)))\n@@ -1400,13 +1386,27 @@ alpha_emit_set_const_1 (target, mode, c, n)\n \t\t\t\t target, 0, OPTAB_WIDEN);\n     }\n \n-  /* Next, see if, minus some low bits, we've an easy load of high bits.  */\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  /* Finally, see if can load a value into the target that is the same as the\n+     constant except that all bytes that are 0 are changed to be 0xff.  If we\n+     can, then we can do a ZAPNOT to obtain the desired constant.  */\n+\n+  new = c;\n+  for (i = 0; i < 64; i += 8)\n+    if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n+      new |= (HOST_WIDE_INT) 0xff << i;\n \n-  new = ((c & 0xffff) ^ 0x8000) - 0x8000;\n-  if (new != 0\n-      && (temp = alpha_emit_set_const (subtarget, mode, c - new, n - 1)) != 0)\n-    return expand_binop (mode, add_optab, temp, GEN_INT (new),\n+  /* We are only called for SImode and DImode.  If this is SImode, ensure that\n+     we are sign extended to a full word.  */\n+\n+  if (mode == SImode)\n+    new = ((new & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\n+  if (new != c && new != -1\n+      && (temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n+    return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n \t\t\t target, 0, OPTAB_WIDEN);\n+#endif\n \n   return 0;\n }"}]}