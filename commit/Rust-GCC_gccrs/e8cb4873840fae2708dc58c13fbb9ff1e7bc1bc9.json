{"sha": "e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjYjQ4NzM4NDBmYWUyNzA4ZGM1OGMxM2ZiYjlmZjFlN2JjMWJjOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-07T22:26:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-07T22:26:37Z"}, "message": "loop.c (strength_reduce): Call check_ext_dependant_givs.\n\n        * loop.c (strength_reduce): Call check_ext_dependant_givs.\n        Properly extend the biv initial value for the giv.\n        (record_biv): Zero ext_dependant.\n        (record_giv): New argument ext_val.  Update all callers.\n        (general_induction_var): Likewise.\n        (consec_sets_giv): Likewise.\n        (simplify_giv_expr): Likewise.  Fill in ext_val if we find\n        a sign-extend, zero-extend, or truncate.\n        (combine_givs_p): Make sure modes are compatible.\n        (check_ext_dependant_givs): New.\n        (extend_value_for_giv): New.\n        * loop.h (struct induction): Add ext_dependant.\n        * unroll.c (iteration_info): Extend the biv initial value for the giv.\n        (find_splittable_givs): Likewise.\n        (final_giv_value): Likewise.\n\nFrom-SVN: r36250", "tree": {"sha": "07a0eb7b5b1bf4058491a8b16ec4c39423a361db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07a0eb7b5b1bf4058491a8b16ec4c39423a361db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/comments", "author": null, "committer": null, "parents": [{"sha": "8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b97c5f8ef218afce7499abe8cd3e6eb1f729306"}], "stats": {"total": 421, "additions": 356, "deletions": 65}, "files": [{"sha": "94d91d799e86e95fd05c19ee9bcc8327c6583b91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "patch": "@@ -1,3 +1,21 @@\n+2000-09-07  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.c (strength_reduce): Call check_ext_dependant_givs.\n+\tProperly extend the biv initial value for the giv.\n+\t(record_biv): Zero ext_dependant.\n+\t(record_giv): New argument ext_val.  Update all callers.\n+\t(general_induction_var): Likewise.\n+\t(consec_sets_giv): Likewise.\n+\t(simplify_giv_expr): Likewise.  Fill in ext_val if we find\n+\ta sign-extend, zero-extend, or truncate.\n+\t(combine_givs_p): Make sure modes are compatible.\n+\t(check_ext_dependant_givs): New.\n+\t(extend_value_for_giv): New.\n+\t* loop.h (struct induction): Add ext_dependant.\n+\t* unroll.c (iteration_info): Extend the biv initial value for the giv.\n+\t(find_splittable_givs): Likewise.\n+\t(final_giv_value): Likewise.\n+\n 2000-09-07  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* c-pragma.h: Define HANDLE_GENERIC_PRAGMAS if\n@@ -64,9 +82,9 @@ Thu 07-Sep-2000 21:29:00 BST  Neil Booth  <NeilB@earthling.net>\n \n 2000-09-07  Catherine Moore  <clm@redhat.com>\n \n-        * unroll.c (unroll_loop): Check for unconditional jumps\n-        to loop continuation.  Delete if n_iterations is 1.\n-        (ujump_to_loop_cont): New routine.\n+\t* unroll.c (unroll_loop): Check for unconditional jumps\n+\tto loop continuation.  Delete if n_iterations is 1.\n+\t(ujump_to_loop_cont): New routine.\n \n 2000-09-07  Bernd Schmidt  <bernds@redhat.co.uk>\n \n@@ -151,15 +169,15 @@ Thu 07-Sep-2000 21:29:00 BST  Neil Booth  <NeilB@earthling.net>\n \n 2000-09-06 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n-        * flow.c (insn_dead_p): Detect dead memory stores with auto increments.\n+\t* flow.c (insn_dead_p): Detect dead memory stores with auto increments.\n \n 2000-09-06  Kazu Hirata  <kazu@hxi.com>\n \n \t* calls.c: Fix formatting.\n \n 2000-09-06  Graham Stott  <grahams@cygnus.co.uk>\n \n-        * config/i386/i386.h (ADDRESS_COST): Fix typo.\n+\t* config/i386/i386.h (ADDRESS_COST): Fix typo.\n \n 2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n "}, {"sha": "a7bba71cbe60ace62e55269f6b7e675e24f86b8d", "filename": "gcc/loop.c", "status": "modified", "additions": 321, "deletions": 56, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "patch": "@@ -270,17 +270,20 @@ static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *,\n static void check_final_value PARAMS ((const struct loop *,\n \t\t\t\t       struct induction *));\n static void record_giv PARAMS ((const struct loop *, struct induction *,\n-\t\t\t\trtx, rtx, rtx, rtx, rtx, int, enum g_types,\n-\t\t\t\tint, int, rtx *));\n+\t\t\t\trtx, rtx, rtx, rtx, rtx, rtx, int,\n+\t\t\t\tenum g_types, int, int, rtx *));\n static void update_giv_derive PARAMS ((const struct loop *, rtx));\n+static void check_ext_dependant_givs PARAMS ((struct iv_class *,\n+\t\t\t\t\t      struct loop_info *));\n static int basic_induction_var PARAMS ((const struct loop *, rtx,\n \t\t\t\t\tenum machine_mode, rtx, rtx,\n \t\t\t\t\trtx *, rtx *, rtx **));\n-static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, int *));\n+static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, rtx *, int *));\n static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,\n-\t\t\t\t\t  rtx *, rtx *, int, int *, enum machine_mode));\n+\t\t\t\t\t  rtx *, rtx *, rtx *, int, int *,\n+\t\t\t\t\t  enum machine_mode));\n static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n-\t\t\t\t    rtx, rtx, rtx *, rtx *, rtx *));\n+\t\t\t\t    rtx, rtx, rtx *, rtx *, rtx *, rtx *));\n static int check_dbra_loop PARAMS ((struct loop *, int));\n static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n@@ -4412,6 +4415,10 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t}\n \n+      /* Check each extension dependant giv in this class to see if its\n+\t root biv is safe from wrapping in the interior mode.  */\n+      check_ext_dependant_givs (bl, loop_info);\n+\n       /* Combine all giv's for this iv_class.  */\n       combine_givs (bl);\n \n@@ -4733,8 +4740,9 @@ strength_reduce (loop, insn_count, flags)\n \n \t      /* Add code at loop start to initialize giv's reduced reg.  */\n \n-\t      emit_iv_add_mult (bl->initial_value, v->mult_val,\n-\t\t\t\tv->add_val, v->new_reg, loop_start);\n+\t      emit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),\n+\t\t\t\tv->mult_val, v->add_val, v->new_reg,\n+\t\t\t\tloop_start);\n \t    }\n \t}\n \n@@ -4799,8 +4807,9 @@ strength_reduce (loop, insn_count, flags)\n \t     not replaceable.  The correct final value is the same as the\n \t     value that the giv starts the reversed loop with.  */\n \t  if (bl->reversed && ! v->replaceable)\n-\t    emit_iv_add_mult (bl->initial_value, v->mult_val,\n-\t\t\t      v->add_val, v->dest_reg, end_insert_before);\n+\t    emit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),\n+\t\t\t      v->mult_val, v->add_val, v->dest_reg,\n+\t\t\t      end_insert_before);\n \t  else if (v->final_value)\n \t    {\n \t      rtx insert_before;\n@@ -5057,6 +5066,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n       rtx dest_reg;\n       rtx add_val;\n       rtx mult_val;\n+      rtx ext_val;\n       int benefit;\n       rtx regnote = 0;\n       rtx last_consec_insn;\n@@ -5067,11 +5077,11 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \n       if (/* SET_SRC is a giv.  */\n \t  (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n-\t\t\t\t  &mult_val, 0, &benefit, VOIDmode)\n+\t\t\t\t  &mult_val, &ext_val, 0, &benefit, VOIDmode)\n \t   /* Equivalent expression is a giv.  */\n \t   || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t       && general_induction_var (loop, XEXP (regnote, 0), &src_reg,\n-\t\t\t\t\t &add_val, &mult_val, 0,\n+\t\t\t\t\t &add_val, &mult_val, &ext_val, 0,\n \t\t\t\t\t &benefit, VOIDmode)))\n \t  /* Don't try to handle any regs made by loop optimization.\n \t     We have nothing on them in regno_first_uid, etc.  */\n@@ -5083,7 +5093,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t      /* or all sets must be consecutive and make a giv.  */\n \t      || (benefit = consec_sets_giv (loop, benefit, p,\n \t\t\t\t\t     src_reg, dest_reg,\n-\t\t\t\t\t     &add_val, &mult_val,\n+\t\t\t\t\t     &add_val, &mult_val, &ext_val,\n \t\t\t\t\t     &last_consec_insn))))\n \t{\n \t  struct induction *v\n@@ -5098,7 +5108,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t    p = last_consec_insn;\n \n \t  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n-\t\t      benefit, DEST_REG, not_every_iteration,\n+\t\t      ext_val, benefit, DEST_REG, not_every_iteration,\n \t\t      maybe_multiple, NULL_PTR);\n \n \t}\n@@ -5202,6 +5212,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \trtx src_reg;\n \trtx add_val;\n \trtx mult_val;\n+\trtx ext_val;\n \tint benefit;\n \n \t/* This code used to disable creating GIVs with mult_val == 1 and\n@@ -5210,15 +5221,16 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \t   this one would not be seen.   */\n \n \tif (general_induction_var (loop, XEXP (x, 0), &src_reg, &add_val,\n-\t\t\t\t   &mult_val, 1, &benefit, GET_MODE (x)))\n+\t\t\t\t   &mult_val, &ext_val, 1, &benefit,\n+\t\t\t\t   GET_MODE (x)))\n \t  {\n \t    /* Found one; record it.  */\n \t    struct induction *v\n \t      = (struct induction *) oballoc (sizeof (struct induction));\n \n \t    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,\n-\t\t\tadd_val, benefit, DEST_ADDR, not_every_iteration,\n-\t\t\tmaybe_multiple, &XEXP (x, 0));\n+\t\t\tadd_val, ext_val, benefit, DEST_ADDR,\n+\t\t\tnot_every_iteration, maybe_multiple, &XEXP (x, 0));\n \n \t    v->mem_mode = GET_MODE (x);\n \t  }\n@@ -5277,6 +5289,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n   v->dest_reg = dest_reg;\n   v->mult_val = mult_val;\n   v->add_val = inc_val;\n+  v->ext_dependant = NULL_RTX;\n   v->location = location;\n   v->mode = GET_MODE (dest_reg);\n   v->always_computable = ! not_every_iteration;\n@@ -5360,14 +5373,14 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n    LOCATION points to the place where this giv's value appears in INSN.  */\n \n static void\n-record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t    type, not_every_iteration, maybe_multiple, location)\n+record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n+\t    benefit, type, not_every_iteration, maybe_multiple, location)\n      const struct loop *loop;\n      struct induction *v;\n      rtx insn;\n      rtx src_reg;\n      rtx dest_reg;\n-     rtx mult_val, add_val;\n+     rtx mult_val, add_val, ext_val;\n      int benefit;\n      enum g_types type;\n      int not_every_iteration, maybe_multiple;\n@@ -5389,6 +5402,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->dest_reg = dest_reg;\n   v->mult_val = mult_val;\n   v->add_val = add_val;\n+  v->ext_dependant = ext_val;\n   v->benefit = benefit;\n   v->location = location;\n   v->cant_derive = 0;\n@@ -5577,6 +5591,24 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n       if (v->no_const_addval)\n \tfprintf (loop_dump_stream, \" ncav\");\n \n+      if (v->ext_dependant)\n+\t{\n+\t  switch (GET_CODE (v->ext_dependant))\n+\t    {\n+\t    case SIGN_EXTEND:\n+\t      fprintf (loop_dump_stream, \" ext se\");\n+\t      break;\n+\t    case ZERO_EXTEND:\n+\t      fprintf (loop_dump_stream, \" ext ze\");\n+\t      break;\n+\t    case TRUNCATE:\n+\t      fprintf (loop_dump_stream, \" ext tr\");\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t}\n+\n       if (GET_CODE (mult_val) == CONST_INT)\n \t{\n \t  fprintf (loop_dump_stream, \" mult \");\n@@ -5825,20 +5857,21 @@ update_giv_derive (loop, p)\n \t\t be able to compute a compensation.  */\n \t      else if (biv->insn == p)\n \t\t{\n-\t\t  tem = 0;\n+\t\t  rtx ext_val_dummy;\n \n+\t\t  tem = 0;\n \t\t  if (biv->mult_val == const1_rtx)\n \t\t    tem = simplify_giv_expr (loop,\n \t\t\t\t\t     gen_rtx_MULT (giv->mode,\n \t\t\t\t\t\t\t   biv->add_val,\n \t\t\t\t\t\t\t   giv->mult_val),\n-\t\t\t\t\t     &dummy);\n+\t\t\t\t\t     &ext_val_dummy, &dummy);\n \n \t\t  if (tem && giv->derive_adjustment)\n \t\t    tem = simplify_giv_expr\n \t\t      (loop,\n \t\t       gen_rtx_PLUS (giv->mode, tem, giv->derive_adjustment),\n-\t\t       &dummy);\n+\t\t       &ext_val_dummy, &dummy);\n \n \t\t  if (tem)\n \t\t    giv->derive_adjustment = tem;\n@@ -6058,13 +6091,14 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n      such that the value of X is biv * mult + add;  */\n \n static int\n-general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr,\n-\t\t       pbenefit, addr_mode)\n+general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n+\t\t       is_addr, pbenefit, addr_mode)\n      const struct loop *loop;\n      rtx x;\n      rtx *src_reg;\n      rtx *add_val;\n      rtx *mult_val;\n+     rtx *ext_val;\n      int is_addr;\n      int *pbenefit;\n      enum machine_mode addr_mode;\n@@ -6080,7 +6114,8 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr,\n      Mark our place on the obstack in case we don't find a giv.  */\n   storage = (char *) oballoc (0);\n   *pbenefit = 0;\n-  x = simplify_giv_expr (loop, x, pbenefit);\n+  *ext_val = NULL_RTX;\n+  x = simplify_giv_expr (loop, x, ext_val, pbenefit);\n   if (x == 0)\n     {\n       obfree (storage);\n@@ -6177,9 +6212,10 @@ static int cmp_combine_givs_stats PARAMS ((const PTR, const PTR));\n static int cmp_recombine_givs_stats PARAMS ((const PTR, const PTR));\n \n static rtx\n-simplify_giv_expr (loop, x, benefit)\n+simplify_giv_expr (loop, x, ext_val, benefit)\n      const struct loop *loop;\n      rtx x;\n+     rtx *ext_val;\n      int *benefit;\n {\n   enum machine_mode mode = GET_MODE (x);\n@@ -6196,8 +6232,8 @@ simplify_giv_expr (loop, x, benefit)\n   switch (GET_CODE (x))\n     {\n     case PLUS:\n-      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);\n-      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);\n+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);\n+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), ext_val, benefit);\n       if (arg0 == 0 || arg1 == 0)\n \treturn NULL_RTX;\n \n@@ -6249,7 +6285,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t       gen_rtx_PLUS (mode,\n \t\t\t\t\t\t\t     XEXP (arg0, 1),\n \t\t\t\t\t\t\t     arg1)),\n-\t\t\t\t benefit);\n+\t\t\t\t ext_val, benefit);\n \n \t  default:\n \t    abort ();\n@@ -6275,7 +6311,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t     gen_rtx_PLUS (mode, arg0,\n \t\t\t\t\t\t\t   XEXP (arg1, 0)),\n \t\t\t\t\t     XEXP (arg1, 1)),\n-\t\t\t       benefit);\n+\t\t\t       ext_val, benefit);\n \n       /* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */\n       if (GET_CODE (arg0) != MULT || GET_CODE (arg1) != MULT)\n@@ -6290,7 +6326,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t      gen_rtx_PLUS (mode,\n \t\t\t\t\t\t\t    XEXP (arg0, 1),\n \t\t\t\t\t\t\t    XEXP (arg1, 1))),\n-\t\t\t\tbenefit);\n+\t\t\t\text_val, benefit);\n \n     case MINUS:\n       /* Handle \"a - b\" as \"a + b * (-1)\".  */\n@@ -6300,11 +6336,11 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t      gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t    XEXP (x, 1),\n \t\t\t\t\t\t\t    constm1_rtx)),\n-\t\t\t\tbenefit);\n+\t\t\t\text_val, benefit);\n \n     case MULT:\n-      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);\n-      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);\n+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);\n+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), ext_val, benefit);\n       if (arg0 == 0 || arg1 == 0)\n \treturn NULL_RTX;\n \n@@ -6350,7 +6386,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t\t\t\t    XEXP (arg0,\n \t\t\t\t\t\t\t\t\t  1),\n \t\t\t\t\t\t\t\t    arg1)),\n-\t\t\t\t\tbenefit);\n+\t\t\t\t\text_val, benefit);\n \t    }\n \t  /* Porpagate the MULT expressions to the intermost nodes.  */\n \t  else if (GET_CODE (arg0) == PLUS)\n@@ -6366,7 +6402,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t\t\t\t    XEXP (arg0,\n \t\t\t\t\t\t\t\t\t  1),\n \t\t\t\t\t\t\t\t    arg1)),\n-\t\t\t\t\tbenefit);\n+\t\t\t\t\text_val, benefit);\n \t    }\n \t  return gen_rtx_USE (mode, gen_rtx_MULT (mode, arg0, arg1));\n \n@@ -6378,7 +6414,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t\t  gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t\tXEXP (arg0, 1),\n \t\t\t\t\t\t\t\targ1)),\n-\t\t\t\t    benefit);\n+\t\t\t\t    ext_val, benefit);\n \n \tcase PLUS:\n \t  /* (a + invar_1) * invar_2.  Distribute.  */\n@@ -6390,7 +6426,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t\t  gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t\tXEXP (arg0, 1),\n \t\t\t\t\t\t\t\targ1)),\n-\t\t\t\t    benefit);\n+\t\t\t\t    ext_val, benefit);\n \n \tdefault:\n \t  abort ();\n@@ -6407,27 +6443,44 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t\t\t XEXP (x, 0),\n \t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n \t\t\t\t\t\t  << INTVAL (XEXP (x, 1)))),\n-\t\t\t   benefit);\n+\t\t\t   ext_val, benefit);\n \n     case NEG:\n       /* \"-a\" is \"a * (-1)\" */\n       return simplify_giv_expr (loop,\n \t\t\t\tgen_rtx_MULT (mode, XEXP (x, 0), constm1_rtx),\n-\t\t\t\tbenefit);\n+\t\t\t\text_val, benefit);\n \n     case NOT:\n       /* \"~a\" is \"-a - 1\". Silly, but easy.  */\n       return simplify_giv_expr (loop,\n \t\t\t\tgen_rtx_MINUS (mode,\n \t\t\t\t\t       gen_rtx_NEG (mode, XEXP (x, 0)),\n \t\t\t\t\t       const1_rtx),\n-\t\t\t\tbenefit);\n+\t\t\t\text_val, benefit);\n \n     case USE:\n       /* Already in proper form for invariant.  */\n       return x;\n \n-    case REG:\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+    case TRUNCATE:\n+      /* Conditionally recognize extensions of simple IVs.  After we've\n+\t computed loop traversal counts and verified the range of the \n+\t source IV, we'll reevaluate this as a GIV.  */\n+      if (*ext_val == NULL_RTX)\n+\t{\n+\t  arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);\n+\t  if (arg0 && *ext_val == NULL_RTX && GET_CODE (arg0) == REG)\n+\t    {\n+\t      *ext_val = gen_rtx_fmt_e (GET_CODE (x), mode, arg0);\n+\t      return arg0;\n+\t    }\n+\t}\n+      goto do_default;\n+\n+  case REG:\n       /* If this is a new register, we can't deal with it.  */\n       if (REGNO (x) >= max_reg_before_loop)\n \treturn 0;\n@@ -6466,10 +6519,22 @@ simplify_giv_expr (loop, x, benefit)\n \n \t    if (v->derive_adjustment)\n \t      tem = gen_rtx_MINUS (mode, tem, v->derive_adjustment);\n-\t    return simplify_giv_expr (loop, tem, benefit);\n+\t    arg0 = simplify_giv_expr (loop, tem, ext_val, benefit);\n+\t    if (*ext_val)\n+\t      {\n+\t\tif (!v->ext_dependant)\n+\t\t  return arg0;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*ext_val = v->ext_dependant;\n+\t\treturn arg0;\n+\t      }\n+\t    return 0;\n \t  }\n \n \tdefault:\n+\tdo_default:\n \t  /* If it isn't an induction variable, and it is invariant, we\n \t     may be able to simplify things further by looking through\n \t     the bits we just moved outside the loop.  */\n@@ -6486,7 +6551,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t       this one is going away.  */\n \t\t    if (m->match)\n \t\t      return simplify_giv_expr (loop, m->match->set_dest,\n-\t\t\t\t\t\tbenefit);\n+\t\t\t\t\t\text_val, benefit);\n \n \t\t    /* If consec is non-zero, this is a member of a group of\n \t\t       instructions that were moved together.  We handle this\n@@ -6520,7 +6585,8 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t    || GET_CODE (tem) == CONST_INT\n \t\t\t    || GET_CODE (tem) == SYMBOL_REF)\n \t\t\t  {\n-\t\t\t    tem = simplify_giv_expr (loop, tem, benefit);\n+\t\t\t    tem = simplify_giv_expr (loop, tem, ext_val,\n+\t\t\t\t\t\t     benefit);\n \t\t\t    if (tem)\n \t\t\t      return tem;\n \t\t\t  }\n@@ -6530,7 +6596,7 @@ simplify_giv_expr (loop, x, benefit)\n \t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)\n \t\t\t  {\n \t\t\t    tem = simplify_giv_expr (loop, XEXP (tem, 0),\n-\t\t\t\t\t\t     benefit);\n+\t\t\t\t\t\t     ext_val, benefit);\n \t\t\t    if (tem)\n \t\t\t      return tem;\n \t\t\t  }\n@@ -6635,14 +6701,15 @@ sge_plus (mode, x, y)\n \n static int\n consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n-\t\t add_val, mult_val, last_consec_insn)\n+\t\t add_val, mult_val, ext_val, last_consec_insn)\n      const struct loop *loop;\n      int first_benefit;\n      rtx p;\n      rtx src_reg;\n      rtx dest_reg;\n      rtx *add_val;\n      rtx *mult_val;\n+     rtx *ext_val;\n      rtx *last_consec_insn;\n {\n   int count;\n@@ -6666,6 +6733,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n   v->benefit = first_benefit;\n   v->cant_derive = 0;\n   v->derive_adjustment = 0;\n+  v->ext_dependant = NULL_RTX;\n \n   REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;\n   REG_IV_INFO (REGNO (dest_reg)) = v;\n@@ -6686,12 +6754,13 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n \t  && GET_CODE (SET_DEST (set)) == REG\n \t  && SET_DEST (set) == dest_reg\n \t  && (general_induction_var (loop, SET_SRC (set), &src_reg,\n-\t\t\t\t     add_val, mult_val, 0, &benefit, VOIDmode)\n+\t\t\t\t     add_val, mult_val, ext_val, 0,\n+\t\t\t\t     &benefit, VOIDmode)\n \t      /* Giv created by equivalent expression.  */\n \t      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n \t\t  && general_induction_var (loop, XEXP (temp, 0), &src_reg,\n-\t\t\t\t\t    add_val, mult_val, 0, &benefit,\n-\t\t\t\t\t    VOIDmode)))\n+\t\t\t\t\t    add_val, mult_val, ext_val, 0,\n+\t\t\t\t\t    &benefit, VOIDmode)))\n \t  && src_reg == v->src_reg)\n \t{\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n@@ -6921,25 +6990,36 @@ static rtx\n combine_givs_p (g1, g2)\n      struct induction *g1, *g2;\n {\n-  rtx tem = express_from (g1, g2);\n+  rtx comb, ret;\n+\n+  /* With the introduction of ext dependant givs, we must care for modes.\n+     G2 must not use a wider mode than G1.  */\n+  if (GET_MODE_SIZE (g1->mode) < GET_MODE_SIZE (g2->mode))\n+    return NULL_RTX;\n+\n+  ret = comb = express_from (g1, g2);\n+  if (comb == NULL_RTX)\n+    return NULL_RTX;\n+  if (g1->mode != g2->mode)\n+    ret = gen_lowpart (g2->mode, comb);\n \n   /* If these givs are identical, they can be combined.  We use the results\n      of express_from because the addends are not in a canonical form, so\n      rtx_equal_p is a weaker test.  */\n   /* But don't combine a DEST_REG giv with a DEST_ADDR giv; we want the\n      combination to be the other way round.  */\n-  if (tem == g1->dest_reg\n+  if (comb == g1->dest_reg\n       && (g1->giv_type == DEST_REG || g2->giv_type == DEST_ADDR))\n     {\n-      return g1->dest_reg;\n+      return ret;\n     }\n \n   /* If G2 can be expressed as a function of G1 and that function is valid\n      as an address and no more expensive than using a register for G2,\n      the expression of G2 in terms of G1 can be used.  */\n-  if (tem != NULL_RTX\n+  if (ret != NULL_RTX\n       && g2->giv_type == DEST_ADDR\n-      && memory_address_p (g2->mem_mode, tem)\n+      && memory_address_p (g2->mem_mode, ret)\n       /* ??? Looses, especially with -fforce-addr, where *g2->location\n \t will always be a register, and so anything more complicated\n \t gets discarded.  */\n@@ -6952,12 +7032,197 @@ combine_givs_p (g1, g2)\n #endif\n       )\n     {\n-      return tem;\n+      return ret;\n     }\n \n   return NULL_RTX;\n }\n \f\n+/* Check each extension dependant giv in this class to see if its\n+   root biv is safe from wrapping in the interior mode, which would\n+   make the giv illegal.  */\n+\n+static void\n+check_ext_dependant_givs (bl, loop_info)\n+     struct iv_class *bl;\n+     struct loop_info *loop_info;\n+{\n+  int ze_ok = 0, se_ok = 0, info_ok = 0;\n+  enum machine_mode biv_mode = GET_MODE (bl->biv->src_reg);\n+  HOST_WIDE_INT start_val;\n+  unsigned HOST_WIDE_INT u_end_val, u_start_val;\n+  rtx incr = pc_rtx;\n+  struct induction *v;\n+\n+  /* Make sure the iteration data is available.  We must have\n+     constants in order to be certain of no overflow.  */\n+  /* ??? An unknown iteration count with an increment of +-1\n+     combined with friendly exit tests of against an invariant\n+     value is also ameanable to optimization.  Not implemented.  */\n+  if (loop_info->n_iterations > 0\n+      && bl->initial_value\n+      && GET_CODE (bl->initial_value) == CONST_INT\n+      && (incr = biv_total_increment (bl))\n+      && GET_CODE (incr) == CONST_INT\n+      /* Make sure the host can represent the arithmetic.  */\n+      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (biv_mode))\n+    {\n+      unsigned HOST_WIDE_INT abs_incr, total_incr;\n+      HOST_WIDE_INT s_end_val;\n+      int neg_incr;\n+\n+      info_ok = 1;\n+      start_val = INTVAL (bl->initial_value);\n+      u_start_val = start_val;\n+\t   \n+      neg_incr = 0, abs_incr = INTVAL (incr);\n+      if (INTVAL (incr) < 0)\n+\tneg_incr = 1, abs_incr = -abs_incr;\n+      total_incr = abs_incr * loop_info->n_iterations;\n+\n+      /* Check for host arithmatic overflow.  */\n+      if (total_incr / loop_info->n_iterations == abs_incr)\n+\t{\n+\t  unsigned HOST_WIDE_INT u_max;\n+\t  HOST_WIDE_INT s_max;\n+\n+\t  u_end_val = start_val + (neg_incr ? -total_incr : total_incr);\n+\t  s_end_val = u_end_val;\n+\t  u_max = GET_MODE_MASK (biv_mode);\n+\t  s_max = u_max >> 1;\n+\t\t  \n+\t  /* Check zero extension of biv ok.  */\n+\t  if (start_val >= 0\n+\t      /* Check for host arithmatic overflow.  */\n+\t      && (neg_incr\n+\t\t  ? u_end_val < u_start_val\n+\t\t  : u_end_val > u_start_val)\n+\t      /* Check for target arithmetic overflow.  */\n+\t      && (neg_incr\n+\t\t  ? 1 /* taken care of with host overflow */\n+\t\t  : u_end_val <= u_max))\n+\t    {\n+\t      ze_ok = 1;\n+\t    }\n+\t\t  \n+\t  /* Check sign extension of biv ok.  */\n+\t  /* ??? While it is true that overflow with signed and pointer\n+\t     arithmetic is undefined, I fear too many programmers don't\n+\t     keep this fact in mind -- myself included on occasion.\n+\t     So leave alone with the signed overflow optimizations.  */\n+\t  if (start_val >= -s_max - 1\n+\t      /* Check for host arithmatic overflow.  */\n+\t      && (neg_incr\n+\t\t  ? s_end_val < start_val\n+\t\t  : s_end_val > start_val)\n+\t      /* Check for target arithmetic overflow.  */\n+\t      && (neg_incr\n+\t\t  ? s_end_val >= -s_max - 1\n+\t\t  : s_end_val <= s_max))\n+\t    {\n+\t      se_ok = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Invalidate givs that fail the tests.  */\n+  for (v = bl->giv; v; v = v->next_iv)\n+    if (v->ext_dependant)\n+      {\n+\tenum rtx_code code = GET_CODE (v->ext_dependant);\n+\tint ok = 0;\n+\n+\tswitch (code)\n+\t  {\n+\t  case SIGN_EXTEND:\n+\t    ok = se_ok;\n+\t    break;\n+\t  case ZERO_EXTEND:\n+\t    ok = ze_ok;\n+\t    break;\n+\n+\t  case TRUNCATE:\n+\t    /* We don't know whether this value is being used as either\n+\t       signed or unsigned, so to safely truncate we must satisfy\n+\t       both.  The initial check here verifies the BIV itself; \n+\t       once that is successful we may check its range wrt the\n+\t       derived GIV.  */\n+\t    if (se_ok && ze_ok)\n+\t      {\n+\t\tenum machine_mode outer_mode = GET_MODE (v->ext_dependant);\n+\t\tunsigned HOST_WIDE_INT max = GET_MODE_MASK (outer_mode) >> 1;\n+\n+\t\t/* We know from the above that both endpoints are nonnegative,\n+\t\t   and that there is no wrapping.  Verify that both endpoints\n+\t\t   are within the (signed) range of the outer mode.  */\n+\t\tif (u_start_val <= max && u_end_val <= max)\n+\t\t  ok = 1;\n+\t      }\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\n+\tif (ok)\n+\t  {\n+\t    if (loop_dump_stream)\n+\t      {\n+\t\tfprintf(loop_dump_stream,\n+\t\t\t\"Verified ext dependant giv at %d of reg %d\\n\",\n+\t\t\tINSN_UID (v->insn), bl->regno);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (loop_dump_stream)\n+\t      {\n+\t\tconst char *why;\n+\n+\t\tif (info_ok)\n+\t\t  why = \"biv iteration values overflowed\";\n+\t\telse\n+\t\t  {\n+\t\t    if (incr == pc_rtx)\n+\t\t      incr = biv_total_increment (bl);\n+\t\t    if (incr == const1_rtx)\n+\t\t      why = \"biv iteration info incomplete; incr by 1\";\n+\t\t    else\n+\t\t      why = \"biv iteration info incomplete\";\n+\t\t  }\n+\n+\t\tfprintf(loop_dump_stream,\n+\t\t\t\"Failed ext dependant giv at %d, %s\\n\",\n+\t\t\tINSN_UID (v->insn), why);\n+\t      }\n+\t    v->ignore = 1;\n+\t  }\n+      }\n+}\n+\n+/* Generate a version of VALUE in a mode appropriate for initializing V.  */\n+\n+rtx\n+extend_value_for_giv (v, value)\n+     struct induction *v;\n+     rtx value;\n+{\n+  rtx ext_dep = v->ext_dependant;\n+\n+  if (! ext_dep)\n+    return value;\n+\n+  /* Recall that check_ext_dependant_givs verified that the known bounds\n+     of a biv did not overflow or wrap with respect to the extension for\n+     the giv.  Therefore, constants need no additional adjustment.  */\n+  if (CONSTANT_P (value) && GET_MODE (value) == VOIDmode)\n+    return value;\n+\n+  /* Otherwise, we must adjust the value to compensate for the\n+     differing modes of the biv and the giv.  */\n+  return gen_rtx_fmt_e (GET_CODE (ext_dep), GET_MODE (ext_dep), value);\n+}\n+\f\n struct combine_givs_stats\n {\n   int giv_number;"}, {"sha": "1bc9a35ae634e5cf0162effe1bde8e8d50784b91", "filename": "gcc/loop.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "patch": "@@ -115,6 +115,8 @@ struct induction\n \t\t\t\t   subtracted from add_val when this giv\n \t\t\t\t   derives another.  This occurs when the\n \t\t\t\t   giv spans a biv update by incrementation. */\n+  rtx ext_dependant;\t\t/* If nonzero, is a sign or zero extension\n+\t\t\t\t   if a biv on which this giv is dependant.  */\n   struct induction *next_iv;\t/* For givs, links together all givs that are\n \t\t\t\t   based on the same biv.  For bivs, links\n \t\t\t\t   together all biv entries that refer to the\n@@ -238,6 +240,7 @@ int loop_invariant_p PARAMS ((const struct loop *, rtx));\n rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\n void emit_iv_add_mult PARAMS ((rtx, rtx, rtx, rtx, rtx));\n rtx express_from PARAMS ((struct induction *, struct induction *));\n+rtx extend_value_for_giv PARAMS ((struct induction *, rtx));\n \n void unroll_loop PARAMS ((struct loop *, int, rtx, int));\n rtx biv_total_increment PARAMS ((struct iv_class *));\n@@ -251,7 +254,7 @@ void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n \n int loop_insn_first_p PARAMS ((rtx, rtx));\n-typedef rtx (*loop_insn_callback ) PARAMS ((struct loop *, rtx, int, int));\n+typedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n \n /* Forward declarations for non-static functions declared in doloop.c.  */"}, {"sha": "51a469dcb4808bed8b3a854a694c971f31e8f95a", "filename": "gcc/unroll.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e8cb4873840fae2708dc58c13fbb9ff1e7bc1bc9", "patch": "@@ -2495,6 +2495,7 @@ iteration_info (loop, iteration_var, initial_value, increment)\n     {\n       HOST_WIDE_INT offset = 0;\n       struct induction *v = REG_IV_INFO (REGNO (iteration_var));\n+      rtx biv_initial_value;\n \n       if (REGNO (v->src_reg) >= max_reg_before_loop)\n \tabort ();\n@@ -2527,11 +2528,13 @@ iteration_info (loop, iteration_var, initial_value, increment)\n \tfprintf (loop_dump_stream,\n \t\t \"Loop unrolling: Giv iterator, initial value bias %ld.\\n\",\n \t\t (long) offset);\n+\n       /* Initial value is mult_val times the biv's initial value plus\n \t add_val.  Only useful if it is a constant.  */\n+      biv_initial_value = extend_value_for_giv (v, bl->initial_value);\n       *initial_value\n \t= fold_rtx_mult_add (v->mult_val,\n-\t\t\t     plus_constant (bl->initial_value, offset),\n+\t\t\t     plus_constant (biv_initial_value, offset),\n \t\t\t     v->add_val, v->mode);\n     }\n   else\n@@ -2895,6 +2898,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t\t\tloop->start);\n \t      biv_initial_value = tem;\n \t    }\n+\t  biv_initial_value = extend_value_for_giv (v, biv_initial_value);\n \t  value = fold_rtx_mult_add (v->mult_val, biv_initial_value,\n \t\t\t\t     v->add_val, v->mode);\n \t}\n@@ -3456,10 +3460,11 @@ final_giv_value (loop, v)\n \t  insert_before = NEXT_INSN (loop_end);\n \n \t  /* Put the final biv value in tem.  */\n-\t  tem = gen_reg_rtx (bl->biv->mode);\n+\t  tem = gen_reg_rtx (v->mode);\n \t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t  emit_iv_add_mult (increment, GEN_INT (n_iterations),\n-\t\t\t    bl->initial_value, tem, insert_before);\n+\t\t\t    extend_value_for_giv (v, bl->initial_value),\n+\t\t\t    tem, insert_before);\n \n \t  /* Subtract off extra increments as we find them.  */\n \t  for (insn = NEXT_INSN (v->insn); insn != loop_end;"}]}