{"sha": "172f7610ae6b769fe9a1465424361956472955d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcyZjc2MTBhZTZiNzY5ZmU5YTE0NjU0MjQzNjE5NTY0NzI5NTVkOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-11T22:36:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-11T22:36:30Z"}, "message": "* include/bits/stl_bvector.h (_Bit_type): New.  Use throughout.\n\nFrom-SVN: r50615", "tree": {"sha": "1d386ab2c074994026993e70c4380f45f4488657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d386ab2c074994026993e70c4380f45f4488657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/172f7610ae6b769fe9a1465424361956472955d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172f7610ae6b769fe9a1465424361956472955d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/172f7610ae6b769fe9a1465424361956472955d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172f7610ae6b769fe9a1465424361956472955d8/comments", "author": null, "committer": null, "parents": [{"sha": "e1b56469bfadaf43c8af59bdfdd199ba9d6b7f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b56469bfadaf43c8af59bdfdd199ba9d6b7f14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b56469bfadaf43c8af59bdfdd199ba9d6b7f14"}], "stats": {"total": 53, "additions": 29, "deletions": 24}, "files": [{"sha": "d9288884a66ef3766d3e7d06d90209bd28bfec3c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/172f7610ae6b769fe9a1465424361956472955d8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/172f7610ae6b769fe9a1465424361956472955d8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=172f7610ae6b769fe9a1465424361956472955d8", "patch": "@@ -1,3 +1,7 @@\n+2002-03-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* include/bits/stl_bvector.h (_Bit_type): New.  Use throughout.\n+\n 2002-03-11  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* testsuite/lib/libstdc++-v3-dg.exp (libstdc++-v3-list-sourcefiles):"}, {"sha": "f6f85ea9202a54d6bee251d91385203bcddc5785", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/172f7610ae6b769fe9a1465424361956472955d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/172f7610ae6b769fe9a1465424361956472955d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=172f7610ae6b769fe9a1465424361956472955d8", "patch": "@@ -63,17 +63,19 @@\n \n namespace std\n { \n-  enum { _M_word_bit = int(CHAR_BIT * sizeof(unsigned long)) };\n+  typedef unsigned long _Bit_type;\n+  enum { _M_word_bit = int(CHAR_BIT * sizeof(_Bit_type)) };\n \n struct _Bit_reference {\n-  unsigned int* _M_p;\n-  unsigned int _M_mask;\n-  _Bit_reference(unsigned int* __x, unsigned int __y) \n+\n+  _Bit_type * _M_p;\n+  _Bit_type _M_mask;\n+  _Bit_reference(_Bit_type * __x, _Bit_type __y) \n     : _M_p(__x), _M_mask(__y) {}\n \n public:\n   _Bit_reference() : _M_p(0), _M_mask(0) {}\n-  operator bool() const { return !(!(*_M_p & _M_mask)); }\n+  operator bool() const { return !!(*_M_p & _M_mask); }\n   _Bit_reference& operator=(bool __x)\n   {\n     if (__x)  *_M_p |= _M_mask;\n@@ -84,9 +86,8 @@ struct _Bit_reference {\n     { return *this = bool(__x); }\n   bool operator==(const _Bit_reference& __x) const\n     { return bool(*this) == bool(__x); }\n-  bool operator<(const _Bit_reference& __x) const {\n-    return !bool(*this) && bool(__x);\n-  }\n+  bool operator<(const _Bit_reference& __x) const\n+    { return !bool(*this) && bool(__x); }\n   void flip() { *_M_p ^= _M_mask; }\n };\n \n@@ -99,10 +100,10 @@ inline void swap(_Bit_reference __x, _Bit_reference __y)\n \n struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>\n {\n-  unsigned int* _M_p;\n+  _Bit_type * _M_p;\n   unsigned int _M_offset;\n \n-  _Bit_iterator_base(unsigned int* __x, unsigned int __y)\n+  _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n     : _M_p(__x), _M_offset(__y) {}\n \n   void _M_bump_up() {\n@@ -162,7 +163,7 @@ struct _Bit_iterator : public _Bit_iterator_base\n   typedef _Bit_iterator   iterator;\n \n   _Bit_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_iterator(unsigned int* __x, unsigned int __y) \n+  _Bit_iterator(_Bit_type * __x, unsigned int __y) \n     : _Bit_iterator_base(__x, __y) {}\n \n   reference operator*() const { return reference(_M_p, 1U << _M_offset); }\n@@ -216,7 +217,7 @@ struct _Bit_const_iterator : public _Bit_iterator_base\n   typedef _Bit_const_iterator  const_iterator;\n \n   _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_const_iterator(unsigned int* __x, unsigned int __y) \n+  _Bit_const_iterator(_Bit_type * __x, unsigned int __y) \n     : _Bit_iterator_base(__x, __y) {}\n   _Bit_const_iterator(const _Bit_iterator& __x) \n     : _Bit_iterator_base(__x._M_p, __x._M_offset) {}\n@@ -282,19 +283,19 @@ class _Bvector_alloc_base {\n     : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}\n \n protected:\n-  unsigned int* _M_bit_alloc(size_t __n) \n+  _Bit_type * _M_bit_alloc(size_t __n) \n     { return _M_data_allocator.allocate((__n + _M_word_bit - 1)/_M_word_bit); }\n   void _M_deallocate() {\n     if (_M_start._M_p)\n       _M_data_allocator.deallocate(_M_start._M_p, \n                                    _M_end_of_storage - _M_start._M_p);\n   }  \n \n-  typename _Alloc_traits<unsigned int, _Allocator>::allocator_type \n+  typename _Alloc_traits<_Bit_type, _Allocator>::allocator_type \n           _M_data_allocator;\n   _Bit_iterator _M_start;\n   _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;\n+  _Bit_type * _M_end_of_storage;\n };\n \n // Specialization for instanceless allocators.\n@@ -309,10 +310,10 @@ class _Bvector_alloc_base<_Allocator, true> {\n     : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n \n protected:\n-  typedef typename _Alloc_traits<unsigned int, _Allocator>::_Alloc_type\n+  typedef typename _Alloc_traits<_Bit_type, _Allocator>::_Alloc_type\n           _Alloc_type;\n           \n-  unsigned int* _M_bit_alloc(size_t __n) \n+  _Bit_type * _M_bit_alloc(size_t __n) \n     { return _Alloc_type::allocate((__n + _M_word_bit - 1)/_M_word_bit); }\n   void _M_deallocate() {\n     if (_M_start._M_p)\n@@ -322,7 +323,7 @@ class _Bvector_alloc_base<_Allocator, true> {\n \n   _Bit_iterator _M_start;\n   _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;\n+  _Bit_type * _M_end_of_storage;\n };  \n \n template <class _Alloc>\n@@ -379,7 +380,7 @@ template <typename _Alloc>\n   \n   protected:\n     void _M_initialize(size_type __n) {\n-      unsigned int* __q = _M_bit_alloc(__n);\n+      _Bit_type * __q = _M_bit_alloc(__n);\n       _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n       _M_start = iterator(__q, 0);\n       _M_finish = _M_start + difference_type(__n);\n@@ -392,7 +393,7 @@ template <typename _Alloc>\n       }\n       else {\n         size_type __len = size() ? 2 * size() : _M_word_bit;\n-        unsigned int* __q = _M_bit_alloc(__len);\n+        _Bit_type * __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n         *__i++ = __x;\n         _M_finish = copy(__position, end(), __i);\n@@ -443,7 +444,7 @@ template <typename _Alloc>\n         }\n         else {\n           size_type __len = size() + max(size(), __n);\n-          unsigned int* __q = _M_bit_alloc(__len);\n+          _Bit_type * __q = _M_bit_alloc(__len);\n           iterator __i = copy(begin(), __position, iterator(__q, 0));\n           __i = copy(__first, __last, __i);\n           _M_finish = copy(__position, end(), __i);\n@@ -610,7 +611,7 @@ template <typename _Alloc>\n   \n     void reserve(size_type __n) {\n       if (capacity() < __n) {\n-        unsigned int* __q = _M_bit_alloc(__n);\n+        _Bit_type * __q = _M_bit_alloc(__n);\n         _M_finish = copy(begin(), end(), iterator(__q, 0));\n         _M_deallocate();\n         _M_start = iterator(__q, 0);\n@@ -673,7 +674,7 @@ template <typename _Alloc>\n       }\n       else {\n         size_type __len = size() + max(size(), __n);\n-        unsigned int* __q = _M_bit_alloc(__len);\n+        _Bit_type * __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n         fill_n(__i, __n, __x);\n         _M_finish = copy(__position, end(), __i + difference_type(__n));\n@@ -705,7 +706,7 @@ template <typename _Alloc>\n         insert(end(), __new_size - size(), __x);\n     }\n     void flip() {\n-      for (unsigned int* __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n+      for (_Bit_type * __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n         *__p = ~*__p;\n     }\n   "}]}