{"sha": "2310e4504dd63b79f8062abf1f33321416ad92c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMxMGU0NTA0ZGQ2M2I3OWY4MDYyYWJmMWYzMzMyMTQxNmFkOTJjOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-03-28T21:28:15Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-03-28T21:28:15Z"}, "message": "i386.c (ix86_modes_tieable_p): Handle 32bit AVX modes.\n\n\t* config/i386/i386.c (ix86_modes_tieable_p): Handle 32bit AVX modes.\n\t(ix86_expand_vector_move_misalign): Remove un-needed gen_lowpart calls.\n\nFrom-SVN: r185927", "tree": {"sha": "95a7d1277073a8fda275fef4a4ad7886b55a8907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95a7d1277073a8fda275fef4a4ad7886b55a8907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2310e4504dd63b79f8062abf1f33321416ad92c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2310e4504dd63b79f8062abf1f33321416ad92c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2310e4504dd63b79f8062abf1f33321416ad92c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2310e4504dd63b79f8062abf1f33321416ad92c8/comments", "author": null, "committer": null, "parents": [{"sha": "5caf63ca3fe0772b2b0059a373ee363fc8149e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5caf63ca3fe0772b2b0059a373ee363fc8149e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5caf63ca3fe0772b2b0059a373ee363fc8149e38"}], "stats": {"total": 56, "additions": 26, "deletions": 30}, "files": [{"sha": "f84e25e2686fa0f003d6869116afdfd6792360ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2310e4504dd63b79f8062abf1f33321416ad92c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2310e4504dd63b79f8062abf1f33321416ad92c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2310e4504dd63b79f8062abf1f33321416ad92c8", "patch": "@@ -1,3 +1,8 @@\n+2012-03-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_modes_tieable_p): Handle 32bit AVX modes.\n+\t(ix86_expand_vector_move_misalign): Remove un-needed gen_lowpart calls.\n+\n 2012-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/52691\n@@ -16,22 +21,20 @@\n \t(loop_optimizer_finalize): If loops are to be preserved only\n \tclean up optional loop features.\n \t(rtl_loop_done): Forcefully free loops here.\n-\t* cgraph.c (cgraph_release_function_body): Forcefully free\n-\tloops.\n+\t* cgraph.c (cgraph_release_function_body): Forcefully free loops.\n \t* cfgexpand.c (expand_gimple_cond): Properly add new basic-blocks\n \tto existing loops.\n \t(construct_init_block): Likewise.\n \t(construct_exit_block): Likewise.\n \t(gimple_expand_cfg): Clear LOOP_CLOSED_SSA loop state.  Cleanup\n \tthe CFG after expanding.\n-\t* cfgloop.c (verify_loop_structure): Calculate or verify\n-\tdominators.  If we needed to calculate them, free them afterwards.\n+\t* cfgloop.c (verify_loop_structure): Calculate or verify dominators.\n+\tIf we needed to calculate them, free them afterwards.\n \t* tree-pass.h (PROP_loops): New define.\n \t* tree-ssa-loop.c (pass_tree_loop_init): Provide PROP_loops.\n \t* basic-block.h (CLEANUP_CFG_CHANGED): New.\n \t* cfgcleanup.c (merge_blocks_move): Protect loop latches.\n-\t(cleanup_cfg): If we did something and have loops around, fix\n-\tthem up.\n+\t(cleanup_cfg): If we did something and have loops around, fix them up.\n \t* cse.c (rest_of_handle_cse_after_global_opts): Call cleanup_cfg\n \twith CLEANUP_CFG_CHANGED.\n \t* cfghooks.c (merge_blocks): If we merge a loop header into\n@@ -84,8 +87,7 @@\n \tPR target/52737\n \t* config.gcc (tm_file): Remove avr/multilib.h.\n \n-\t* doc/invoke.texi (AVR Options): Adjust\n-\tdocumentation of -mtiny-stack.\n+\t* doc/invoke.texi (AVR Options): Adjust documentation of -mtiny-stack.\n \n \t* config/avr/genmultilib.awk: Remove code to generate multilib.h.\n \t(BEGIN): Use -msp8 as multilib option instead of -mtiny-stack."}, {"sha": "5029be6c085736d45b6c1b0550d61b91dc5b3161", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2310e4504dd63b79f8062abf1f33321416ad92c8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2310e4504dd63b79f8062abf1f33321416ad92c8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2310e4504dd63b79f8062abf1f33321416ad92c8", "patch": "@@ -15831,17 +15831,18 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  switch (GET_MODE_SIZE (mode))\n \t    {\n \t    case 16:\n-\t      /*  If we're optimizing for size, movups is the smallest.  */\n \t      if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t\t{\n \t\t  op0 = gen_lowpart (V4SFmode, op0);\n \t\t  op1 = gen_lowpart (V4SFmode, op1);\n \t\t  emit_insn (gen_sse_movups (op0, op1));\n-\t\t  return;\n \t\t}\n-\t      op0 = gen_lowpart (V16QImode, op0);\n-\t      op1 = gen_lowpart (V16QImode, op1);\n-\t      emit_insn (gen_sse2_movdqu (op0, op1));\n+\t      else\n+\t\t{\n+\t\t  op0 = gen_lowpart (V16QImode, op0);\n+\t\t  op1 = gen_lowpart (V16QImode, op1);\n+\t\t  emit_insn (gen_sse2_movdqu (op0, op1));\n+\t\t}\n \t      break;\n \t    case 32:\n \t      op0 = gen_lowpart (V32QImode, op0);\n@@ -15853,27 +15854,22 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t    }\n \t  break;\n \tcase MODE_VECTOR_FLOAT:\n-\t  op0 = gen_lowpart (mode, op0);\n-\t  op1 = gen_lowpart (mode, op1);\n-\n \t  switch (mode)\n \t    {\n \t    case V4SFmode:\n \t      emit_insn (gen_sse_movups (op0, op1));\n \t      break;\n-\t    case V8SFmode:\n-\t      ix86_avx256_split_vector_move_misalign (op0, op1);\n-\t      break;\n \t    case V2DFmode:\n \t      if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t\t{\n \t\t  op0 = gen_lowpart (V4SFmode, op0);\n \t\t  op1 = gen_lowpart (V4SFmode, op1);\n \t\t  emit_insn (gen_sse_movups (op0, op1));\n-\t\t  return;\n \t\t}\n-\t      emit_insn (gen_sse2_movupd (op0, op1));\n+\t      else\n+\t\temit_insn (gen_sse2_movupd (op0, op1));\n \t      break;\n+\t    case V8SFmode:\n \t    case V4DFmode:\n \t      ix86_avx256_split_vector_move_misalign (op0, op1);\n \t      break;\n@@ -15918,8 +15914,6 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \n \t  if (TARGET_SSE_UNALIGNED_LOAD_OPTIMAL)\n \t    {\n-\t      op0 = gen_lowpart (V2DFmode, op0);\n-\t      op1 = gen_lowpart (V2DFmode, op1);\n \t      emit_insn (gen_sse2_movupd (op0, op1));\n \t      return;\n \t    }\n@@ -15984,8 +15978,8 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  return;\n \t}\n \n-      /* ??? Similar to above, only less clear because of quote\n-\t typeless stores unquote.  */\n+      /* ??? Similar to above, only less clear\n+\t because of typeless stores.  */\n       if (TARGET_SSE2 && !TARGET_SSE_TYPELESS_STORES\n \t  && GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n         {\n@@ -15998,11 +15992,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n       if (TARGET_SSE2 && mode == V2DFmode)\n \t{\n \t  if (TARGET_SSE_UNALIGNED_STORE_OPTIMAL)\n-\t    {\n-\t      op0 = gen_lowpart (V2DFmode, op0);\n-\t      op1 = gen_lowpart (V2DFmode, op1);\n-\t      emit_insn (gen_sse2_movupd (op0, op1));\n-\t    }\n+\t    emit_insn (gen_sse2_movupd (op0, op1));\n \t  else\n \t    {\n \t      m = adjust_address (op0, DFmode, 0);\n@@ -31399,6 +31389,10 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n \n   /* If MODE2 is only appropriate for an SSE register, then tie with\n      any other mode acceptable to SSE registers.  */\n+  if (GET_MODE_SIZE (mode2) == 32\n+      && ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode2))\n+    return (GET_MODE_SIZE (mode1) == 32\n+\t    && ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode1));\n   if (GET_MODE_SIZE (mode2) == 16\n       && ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode2))\n     return (GET_MODE_SIZE (mode1) == 16"}]}