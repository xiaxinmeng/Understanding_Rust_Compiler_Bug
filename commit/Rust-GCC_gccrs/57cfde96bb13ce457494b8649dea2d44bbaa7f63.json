{"sha": "57cfde96bb13ce457494b8649dea2d44bbaa7f63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdjZmRlOTZiYjEzY2U0NTc0OTRiODY0OWRlYTJkNDRiYmFhN2Y2Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-26T17:08:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-26T17:08:18Z"}, "message": "(alpha_emit_set_const): Don't output SImode sequences that rely on invisible overflow.\n\n(alpha_emit_set_const): Don't output SImode sequences that rely on\ninvisible overflow.  Sign extend new when SImode.  Don't recur if new\n== c.  Don't allow shift outside mode.  Make logical right shift be\nunsigned.\n\nFrom-SVN: r10589", "tree": {"sha": "bd8b0ac31514a9dad67d415967bc108b11fc70e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd8b0ac31514a9dad67d415967bc108b11fc70e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57cfde96bb13ce457494b8649dea2d44bbaa7f63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57cfde96bb13ce457494b8649dea2d44bbaa7f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57cfde96bb13ce457494b8649dea2d44bbaa7f63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57cfde96bb13ce457494b8649dea2d44bbaa7f63/comments", "author": null, "committer": null, "parents": [{"sha": "63a014a0832cc9c7b630ad105a2bad5ea2c4d660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a014a0832cc9c7b630ad105a2bad5ea2c4d660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a014a0832cc9c7b630ad105a2bad5ea2c4d660"}], "stats": {"total": 30, "additions": 23, "deletions": 7}, "files": [{"sha": "d460e8bd2d10f2412437b57594f73c41378a70ad", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57cfde96bb13ce457494b8649dea2d44bbaa7f63/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57cfde96bb13ce457494b8649dea2d44bbaa7f63/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=57cfde96bb13ce457494b8649dea2d44bbaa7f63", "patch": "@@ -713,7 +713,12 @@ alpha_emit_set_const (target, mode, c, n)\n \n       if (c == low || (low == 0 && extra == 0))\n \treturn copy_to_suggested_reg (GEN_INT (c), target, mode);\n-      else if (n >= 2 + (extra != 0))\n+      else if (n >= 2 + (extra != 0)\n+\t       /* We can't do this when SImode if HIGH required adjustment.\n+\t\t  This is because the code relies on an implicit overflow\n+\t\t  which is invisible to the RTL.  We can thus get incorrect\n+\t\t  code if the two ldah instructions are combined.  */\n+\t       && ! (mode == SImode && extra != 0))\n \t{\n \t  temp = copy_to_suggested_reg (GEN_INT (low), subtarget, mode);\n \n@@ -744,7 +749,14 @@ alpha_emit_set_const (target, mode, c, n)\n     if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n       new |= (HOST_WIDE_INT) 0xff << i;\n \n-  if ((temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n+  /* We are only called for SImode and DImode.  If this is SImode, ensure that\n+     we are sign extended to a full word.  */\n+\n+  if (mode == SImode)\n+    new = (new & 0xffffffff) - 2 * (new & 0x80000000);\n+\n+  if (new != c\n+      && (temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n     return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n \t\t\t target, 0, OPTAB_WIDEN);\n #endif\n@@ -781,9 +793,11 @@ alpha_emit_set_const (target, mode, c, n)\n \t\t\t\t target, 0, OPTAB_WIDEN);\n \n       /* Now try high-order zero bits.  Here we try the shifted-in bits as\n-\t all zero and all ones.  */\n+\t all zero and all ones.  Be careful to avoid shifting outside the\n+\t mode and to avoid shifting outside the host wide int size.  */\n \n-      if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (c) - 1) > 0)\n+      if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n+\t\t   - floor_log2 (c) - 1)) > 0)\n \tfor (; bits > 0; bits--)\n \t  if ((temp = alpha_emit_set_const (subtarget, mode,\n \t\t\t\t\t    c << bits, i)) != 0\n@@ -793,12 +807,14 @@ alpha_emit_set_const (target, mode, c, n)\n \t\t\t    i)))\n \t\t  != 0))\n \t    return expand_binop (mode, lshr_optab, temp, GEN_INT (bits),\n-\t\t\t\t target, 0, OPTAB_WIDEN);\n+\t\t\t\t target, 1, OPTAB_WIDEN);\n \n       /* Now try high-order 1 bits.  We get that with a sign-extension.\n-\t But one bit isn't enough here.  */\n+\t But one bit isn't enough here.  Be careful to avoid shifting outside\n+\t the mode and to avoid shifting outside the host wide int size. */\n       \n-      if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (~ c) - 2) > 0)\n+      if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n+\t\t   - floor_log2 (~ c) - 2)) > 0)\n \tfor (; bits > 0; bits--)\n \t  if ((temp = alpha_emit_set_const (subtarget, mode,\n \t\t\t\t\t    c << bits, i)) != 0"}]}