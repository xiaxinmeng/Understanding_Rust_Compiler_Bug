{"sha": "2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4M2Y1ODNjMjdlZjdhOWQzYjBmYjBiNWVkMzcyNDM5ZDYyMjJhOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-19T10:00:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-19T10:00:04Z"}, "message": "md.texi: Document vec_shl_<mode> pattern.\n\n\t* doc/md.texi: Document vec_shl_<mode> pattern.\n\t* optabs.def (vec_shl_optab): New optab.\n\t* optabs.c (shift_amt_for_vec_perm_mask): Add shift_optab\n\targument, if == vec_shl_optab, check for left whole vector shift\n\tpattern rather than right shift.\n\t(expand_vec_perm_const): Add vec_shl_optab support.\n\t* optabs-query.c (can_vec_perm_var_p): Mention also vec_shl optab\n\tin the comment.\n\t* tree-vect-generic.c (lower_vec_perm): Support permutations which\n\tcan be handled by vec_shl_optab.\n\t* tree-vect-stmts.c (scan_store_can_perm_p): New function.\n\t(check_scan_store): Use it.\n\t(vectorizable_scan_store): If target can't do normal permutations,\n\ttry to use whole vector left shifts and if needed a VEC_COND_EXPR\n\tafter it.\n\t* config/i386/sse.md (vec_shl_<mode>): New expander.\n\n\t* gcc.dg/vect/vect-simd-8.c: If main is defined, don't include\n\ttree-vect.h nor call check_vect.\n\t* gcc.dg/vect/vect-simd-9.c: Likewise.\n\t* gcc.dg/vect/vect-simd-10.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-8.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-9.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-10.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-8.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-9.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-10.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-8.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-9.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-10.c: New test.\n\nFrom-SVN: r272472", "tree": {"sha": "34682e23ea4f37c5d4665d95460d04025ea317b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34682e23ea4f37c5d4665d95460d04025ea317b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a2892a6d3aef8a1ce26386d626f26e6100099f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2892a6d3aef8a1ce26386d626f26e6100099f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2892a6d3aef8a1ce26386d626f26e6100099f6"}], "stats": {"total": 556, "additions": 493, "deletions": 63}, "files": [{"sha": "922d1b526071bf3b77c12ab93e4bf61ae34cbe24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -1,5 +1,22 @@\n 2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* doc/md.texi: Document vec_shl_<mode> pattern.\n+\t* optabs.def (vec_shl_optab): New optab.\n+\t* optabs.c (shift_amt_for_vec_perm_mask): Add shift_optab\n+\targument, if == vec_shl_optab, check for left whole vector shift\n+\tpattern rather than right shift.\n+\t(expand_vec_perm_const): Add vec_shl_optab support.\n+\t* optabs-query.c (can_vec_perm_var_p): Mention also vec_shl optab\n+\tin the comment.\n+\t* tree-vect-generic.c (lower_vec_perm): Support permutations which\n+\tcan be handled by vec_shl_optab.\n+\t* tree-vect-stmts.c (scan_store_can_perm_p): New function.\n+\t(check_scan_store): Use it.\n+\t(vectorizable_scan_store): If target can't do normal permutations,\n+\ttry to use whole vector left shifts and if needed a VEC_COND_EXPR\n+\tafter it.\n+\t* config/i386/sse.md (vec_shl_<mode>): New expander.\n+\n \t* omp-low.c (lower_rec_input_clauses): Handle references properly\n \tin inscan clauses.\n \t(lower_omp_scan): Likewise."}, {"sha": "26309aef5c951a7abcf6842dd8b82f424b1f027d", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -11758,6 +11758,19 @@\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n \n+(define_expand \"vec_shl_<mode>\"\n+  [(set (match_dup 3)\n+\t(ashift:V1TI\n+\t (match_operand:VI_128 1 \"register_operand\")\n+\t (match_operand:SI 2 \"const_0_to_255_mul_8_operand\")))\n+   (set (match_operand:VI_128 0 \"register_operand\") (match_dup 4))]\n+  \"TARGET_SSE2\"\n+{\n+  operands[1] = gen_lowpart (V1TImode, operands[1]);\n+  operands[3] = gen_reg_rtx (V1TImode);\n+  operands[4] = gen_lowpart (<MODE>mode, operands[3]);\n+})\n+\n (define_expand \"vec_shr_<mode>\"\n   [(set (match_dup 3)\n \t(lshiftrt:V1TI"}, {"sha": "b45b4bebce0c212d5ea900388718a3de69b87859", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -5459,6 +5459,14 @@ in operand 2.  Store the result in vector output operand 0.  Operands\n 0 and 1 have mode @var{m} and operand 2 has the mode appropriate for\n one element of @var{m}.\n \n+@cindex @code{vec_shl_@var{m}} instruction pattern\n+@item @samp{vec_shl_@var{m}}\n+Whole vector left shift in bits, i.e.@: away from element 0.\n+Operand 1 is a vector to be shifted.\n+Operand 2 is an integer shift amount in bits.\n+Operand 0 is where the resulting shifted vector is stored.\n+The output and input vectors should have the same modes.\n+\n @cindex @code{vec_shr_@var{m}} instruction pattern\n @item @samp{vec_shr_@var{m}}\n Whole vector right shift in bits, i.e.@: towards element 0."}, {"sha": "4116bfe45da01e9e98d9f79289f9fe343a9f2a0f", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -415,8 +415,9 @@ can_vec_perm_var_p (machine_mode mode)\n    permute (if the target supports that).\n \n    Note that additional permutations representing whole-vector shifts may\n-   also be handled via the vec_shr optab, but only where the second input\n-   vector is entirely constant zeroes; this case is not dealt with here.  */\n+   also be handled via the vec_shr or vec_shl optab, but only where the\n+   second input vector is entirely constant zeroes; this case is not dealt\n+   with here.  */\n \n bool\n can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,"}, {"sha": "5a718e7f635da3e4ccf06e0e76ca976dcd2533a7", "filename": "gcc/optabs.c", "status": "modified", "additions": 57, "deletions": 19, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -5444,19 +5444,45 @@ vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n }\n \n /* Check if vec_perm mask SEL is a constant equivalent to a shift of\n-   the first vec_perm operand, assuming the second operand is a constant\n-   vector of zeros.  Return the shift distance in bits if so, or NULL_RTX\n-   if the vec_perm is not a shift.  MODE is the mode of the value being\n-   shifted.  */\n+   the first vec_perm operand, assuming the second operand (for left shift\n+   first operand) is a constant vector of zeros.  Return the shift distance\n+   in bits if so, or NULL_RTX if the vec_perm is not a shift.  MODE is the\n+   mode of the value being shifted.  SHIFT_OPTAB is vec_shr_optab for right\n+   shift or vec_shl_optab for left shift.  */\n static rtx\n-shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel)\n+shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel,\n+\t\t\t     optab shift_optab)\n {\n   unsigned int bitsize = GET_MODE_UNIT_BITSIZE (mode);\n   poly_int64 first = sel[0];\n   if (maybe_ge (sel[0], GET_MODE_NUNITS (mode)))\n     return NULL_RTX;\n \n-  if (!sel.series_p (0, 1, first, 1))\n+  if (shift_optab == vec_shl_optab)\n+    {\n+      unsigned int nelt;\n+      if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n+\treturn NULL_RTX;\n+      unsigned firstidx = 0;\n+      for (unsigned int i = 0; i < nelt; i++)\n+\t{\n+\t  if (known_eq (sel[i], nelt))\n+\t    {\n+\t      if (i == 0 || firstidx)\n+\t\treturn NULL_RTX;\n+\t      firstidx = i;\n+\t    }\n+\t  else if (firstidx\n+\t\t   ? maybe_ne (sel[i], nelt + i - firstidx)\n+\t\t   : maybe_ge (sel[i], nelt))\n+\t    return NULL_RTX;\n+\t}\n+\n+      if (firstidx == 0)\n+\treturn NULL_RTX;\n+      first = firstidx;\n+    }\n+  else if (!sel.series_p (0, 1, first, 1))\n     {\n       unsigned int nelt;\n       if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n@@ -5544,25 +5570,37 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n      target instruction.  */\n   vec_perm_indices indices (sel, 2, GET_MODE_NUNITS (mode));\n \n-  /* See if this can be handled with a vec_shr.  We only do this if the\n-     second vector is all zeroes.  */\n-  insn_code shift_code = optab_handler (vec_shr_optab, mode);\n-  insn_code shift_code_qi = ((qimode != VOIDmode && qimode != mode)\n-\t\t\t     ? optab_handler (vec_shr_optab, qimode)\n-\t\t\t     : CODE_FOR_nothing);\n-\n-  if (v1 == CONST0_RTX (GET_MODE (v1))\n-      && (shift_code != CODE_FOR_nothing\n-\t  || shift_code_qi != CODE_FOR_nothing))\n+  /* See if this can be handled with a vec_shr or vec_shl.  We only do this\n+     if the second (for vec_shr) or first (for vec_shl) vector is all\n+     zeroes.  */\n+  insn_code shift_code = CODE_FOR_nothing;\n+  insn_code shift_code_qi = CODE_FOR_nothing;\n+  optab shift_optab = unknown_optab;\n+  rtx v2 = v0;\n+  if (v1 == CONST0_RTX (GET_MODE (v1)))\n+    shift_optab = vec_shr_optab;\n+  else if (v0 == CONST0_RTX (GET_MODE (v0)))\n+    {\n+      shift_optab = vec_shl_optab;\n+      v2 = v1;\n+    }\n+  if (shift_optab != unknown_optab)\n+    {\n+      shift_code = optab_handler (shift_optab, mode);\n+      shift_code_qi = ((qimode != VOIDmode && qimode != mode)\n+\t\t       ? optab_handler (shift_optab, qimode)\n+\t\t       : CODE_FOR_nothing);\n+    }\n+  if (shift_code != CODE_FOR_nothing || shift_code_qi != CODE_FOR_nothing)\n     {\n-      rtx shift_amt = shift_amt_for_vec_perm_mask (mode, indices);\n+      rtx shift_amt = shift_amt_for_vec_perm_mask (mode, indices, shift_optab);\n       if (shift_amt)\n \t{\n \t  struct expand_operand ops[3];\n \t  if (shift_code != CODE_FOR_nothing)\n \t    {\n \t      create_output_operand (&ops[0], target, mode);\n-\t      create_input_operand (&ops[1], v0, mode);\n+\t      create_input_operand (&ops[1], v2, mode);\n \t      create_convert_operand_from_type (&ops[2], shift_amt, sizetype);\n \t      if (maybe_expand_insn (shift_code, 3, ops))\n \t\treturn ops[0].value;\n@@ -5571,7 +5609,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n \t    {\n \t      rtx tmp = gen_reg_rtx (qimode);\n \t      create_output_operand (&ops[0], tmp, qimode);\n-\t      create_input_operand (&ops[1], gen_lowpart (qimode, v0), qimode);\n+\t      create_input_operand (&ops[1], gen_lowpart (qimode, v2), qimode);\n \t      create_convert_operand_from_type (&ops[2], shift_amt, sizetype);\n \t      if (maybe_expand_insn (shift_code_qi, 3, ops))\n \t\treturn gen_lowpart (mode, ops[0].value);"}, {"sha": "feee96f31eb30f98ce335d988fb7731bc70fb600", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -349,6 +349,7 @@ OPTAB_D (vec_packu_float_optab, \"vec_packu_float_$a\")\n OPTAB_D (vec_perm_optab, \"vec_perm$a\")\n OPTAB_D (vec_realign_load_optab, \"vec_realign_load_$a\")\n OPTAB_D (vec_set_optab, \"vec_set$a\")\n+OPTAB_D (vec_shl_optab, \"vec_shl_$a\")\n OPTAB_D (vec_shr_optab, \"vec_shr_$a\")\n OPTAB_D (vec_unpack_sfix_trunc_hi_optab, \"vec_unpack_sfix_trunc_hi_$a\")\n OPTAB_D (vec_unpack_sfix_trunc_lo_optab, \"vec_unpack_sfix_trunc_lo_$a\")"}, {"sha": "63711afc2463e0e6489ce46943ea00fa14d1e478", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -1,5 +1,19 @@\n 2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/vect/vect-simd-8.c: If main is defined, don't include\n+\ttree-vect.h nor call check_vect.\n+\t* gcc.dg/vect/vect-simd-9.c: Likewise.\n+\t* gcc.dg/vect/vect-simd-10.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-8.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-9.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-10.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-8.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-9.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-10.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-8.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-9.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-10.c: New test.\n+\n \t* g++.dg/vect/simd-3.cc: New test.\n \t* g++.dg/vect/simd-4.cc: New test.\n \t* g++.dg/vect/simd-5.cc: New test."}, {"sha": "d442d6b3bd453905f18481be67928464d793960d", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-10.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-10.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#ifndef main\n+#include \"tree-vect.h\"\n+#endif\n+\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp simd reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r *= a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp simd reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s = s > a[i] ? s : a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+#ifndef main\n+  check_vect ();\n+#endif\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s *= a[i];\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\t{\n+\t  a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+\t  b[i] = -231.75f;\n+\t  m += 0.75f;\n+\t}\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (s < a[i])\n+\ts = a[i];\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "5d10ad90501835bf6cac2c2d81ee98bc6ce6db5b", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-8.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -3,7 +3,9 @@\n /* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n /* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n \n+#ifndef main\n #include \"tree-vect.h\"\n+#endif\n \n int r, a[1024], b[1024];\n \n@@ -63,7 +65,9 @@ int\n main ()\n {\n   int s = 0;\n+#ifndef main\n   check_vect ();\n+#endif\n   for (int i = 0; i < 1024; ++i)\n     {\n       a[i] = i;"}, {"sha": "52eb24f680f1362ee93b7a22de5fd46d37119216", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-9.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -3,7 +3,9 @@\n /* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n /* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n \n+#ifndef main\n #include \"tree-vect.h\"\n+#endif\n \n int r, a[1024], b[1024];\n \n@@ -65,7 +67,9 @@ int\n main ()\n {\n   int s = 0;\n+#ifndef main\n   check_vect ();\n+#endif\n   for (int i = 0; i < 1024; ++i)\n     {\n       a[i] = i;"}, {"sha": "d91235130667698c4e19c3ad90e35e66ddcc05bf", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-10.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-10.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-10.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "8edd4e1a8d6c48892b7b5c9379e8d10dc919c7e2", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-8.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-8.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "ba1a3e6678639dfbe4d5ce760c192e0727caede5", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-9.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-9.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "c0d7cdfe2f3dbe643323eb4aaa63a1ad325644c3", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-10.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-10.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-10.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "f469a135178820ded5b89d11beafc9ca7d887bee", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-8.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-8.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "1e8f5e3cef40f49b76f3ccabc513d2a2fe83a485", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-9.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-9.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "3cc182aba176097bedc96ca29db7fc02aa1baa8e", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-10.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-10.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-10.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "7c7aad80ef633ebb81c15d68e1db1524cbc4ebcb", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-8.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-8.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "0fdff415327cfc10f491cae1e52790bb5c5648d3", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-9.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-9.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "4a53fc44584cc180a958eb3f9434eff14236499b", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -1367,6 +1367,32 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t      return;\n \t    }\n \t}\n+      /* And similarly vec_shl pattern.  */\n+      if (optab_handler (vec_shl_optab, TYPE_MODE (vect_type))\n+\t  != CODE_FOR_nothing\n+\t  && TREE_CODE (vec0) == VECTOR_CST\n+\t  && initializer_zerop (vec0))\n+\t{\n+\t  unsigned int first = 0;\n+\t  for (i = 0; i < elements; ++i)\n+\t    if (known_eq (poly_uint64 (indices[i]), elements))\n+\t      {\n+\t\tif (i == 0 || first)\n+\t\t  break;\n+\t\tfirst = i;\n+\t      }\n+\t    else if (first\n+\t\t     ? maybe_ne (poly_uint64 (indices[i]),\n+\t\t\t\t\t      elements + i - first)\n+\t\t     : maybe_ge (poly_uint64 (indices[i]), elements))\n+\t      break;\n+\t  if (i == elements)\n+\t    {\n+\t      gimple_assign_set_rhs3 (stmt, mask);\n+\t      update_stmt (stmt);\n+\t      return;\n+\t    }\n+\t}\n     }\n   else if (can_vec_perm_var_p (TYPE_MODE (vect_type)))\n     return;"}, {"sha": "98a5f3e04dd60d18014555da03a716e572373f51", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 107, "deletions": 42, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2e83f583c27ef7a9d3b0fb0b5ed372439d6222a8", "patch": "@@ -6354,6 +6354,71 @@ scan_operand_equal_p (tree ref1, tree ref2)\n }\n \n \n+/* Function check_scan_store.\n+\n+   Verify if we can perform the needed permutations or whole vector shifts.\n+   Return -1 on failure, otherwise exact log2 of vectype's nunits.  */\n+\n+static int\n+scan_store_can_perm_p (tree vectype, tree init, int *use_whole_vector_p = NULL)\n+{\n+  enum machine_mode vec_mode = TYPE_MODE (vectype);\n+  unsigned HOST_WIDE_INT nunits;\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n+    return -1;\n+  int units_log2 = exact_log2 (nunits);\n+  if (units_log2 <= 0)\n+    return -1;\n+\n+  int i;\n+  for (i = 0; i <= units_log2; ++i)\n+    {\n+      unsigned HOST_WIDE_INT j, k;\n+      vec_perm_builder sel (nunits, nunits, 1);\n+      sel.quick_grow (nunits);\n+      if (i == 0)\n+\t{\n+\t  for (j = 0; j < nunits; ++j)\n+\t    sel[j] = nunits - 1;\n+\t}\n+      else\n+\t{\n+\t  for (j = 0; j < (HOST_WIDE_INT_1U << (i - 1)); ++j)\n+\t    sel[j] = j;\n+\t  for (k = 0; j < nunits; ++j, ++k)\n+\t    sel[j] = nunits + k;\n+\t}\n+      vec_perm_indices indices (sel, i == 0 ? 1 : 2, nunits);\n+      if (!can_vec_perm_const_p (vec_mode, indices))\n+\tbreak;\n+    }\n+\n+  if (i == 0)\n+    return -1;\n+\n+  if (i <= units_log2)\n+    {\n+      if (optab_handler (vec_shl_optab, vec_mode) == CODE_FOR_nothing)\n+\treturn -1;\n+      int kind = 1;\n+      /* Whole vector shifts shift in zeros, so if init is all zero constant,\n+\t there is no need to do anything further.  */\n+      if ((TREE_CODE (init) != INTEGER_CST\n+\t   && TREE_CODE (init) != REAL_CST)\n+\t  || !initializer_zerop (init))\n+\t{\n+\t  tree masktype = build_same_sized_truth_vector_type (vectype);\n+\t  if (!expand_vec_cond_expr_p (vectype, masktype, VECTOR_CST))\n+\t    return -1;\n+\t  kind = 2;\n+\t}\n+      if (use_whole_vector_p)\n+\t*use_whole_vector_p = kind;\n+    }\n+  return units_log2;\n+}\n+\n+\n /* Function check_scan_store.\n \n    Check magic stores for #pragma omp scan {in,ex}clusive reductions.  */\n@@ -6596,34 +6661,9 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n   if (!optab || optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n     goto fail;\n \n-  unsigned HOST_WIDE_INT nunits;\n-  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n+  int units_log2 = scan_store_can_perm_p (vectype, *init);\n+  if (units_log2 == -1)\n     goto fail;\n-  int units_log2 = exact_log2 (nunits);\n-  if (units_log2 <= 0)\n-    goto fail;\n-\n-  for (int i = 0; i <= units_log2; ++i)\n-    {\n-      unsigned HOST_WIDE_INT j, k;\n-      vec_perm_builder sel (nunits, nunits, 1);\n-      sel.quick_grow (nunits);\n-      if (i == units_log2)\n-\t{\n-\t  for (j = 0; j < nunits; ++j)\n-\t    sel[j] = nunits - 1;\n-\t}\n-      else\n-\t{\n-\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n-\t    sel[j] = nunits + j;\n-\t  for (k = 0; j < nunits; ++j, ++k)\n-\t    sel[j] = k;\n-\t}\n-      vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n-      if (!can_vec_perm_const_p (vec_mode, indices))\n-\tgoto fail;\n-    }\n \n   return true;\n }\n@@ -6686,7 +6726,8 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   unsigned HOST_WIDE_INT nunits;\n   if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n     gcc_unreachable ();\n-  int units_log2 = exact_log2 (nunits);\n+  int use_whole_vector_p = 0;\n+  int units_log2 = scan_store_can_perm_p (vectype, *init, &use_whole_vector_p);\n   gcc_assert (units_log2 > 0);\n   auto_vec<tree, 16> perms;\n   perms.quick_grow (units_log2 + 1);\n@@ -6696,21 +6737,25 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       vec_perm_builder sel (nunits, nunits, 1);\n       sel.quick_grow (nunits);\n       if (i == units_log2)\n-\t{\n-\t  for (j = 0; j < nunits; ++j)\n-\t    sel[j] = nunits - 1;\n-\t}\n-      else\n-\t{\n-\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n-\t    sel[j] = nunits + j;\n-\t  for (k = 0; j < nunits; ++j, ++k)\n-\t    sel[j] = k;\n-\t}\n+\tfor (j = 0; j < nunits; ++j)\n+\t  sel[j] = nunits - 1;\n+\telse\n+\t  {\n+\t    for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n+\t      sel[j] = j;\n+\t    for (k = 0; j < nunits; ++j, ++k)\n+\t      sel[j] = nunits + k;\n+\t  }\n       vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n-      perms[i] = vect_gen_perm_mask_checked (vectype, indices);\n+      if (use_whole_vector_p && i < units_log2)\n+\tperms[i] = vect_gen_perm_mask_any (vectype, indices);\n+      else\n+\tperms[i] = vect_gen_perm_mask_checked (vectype, indices);\n     }\n \n+  tree zero_vec = use_whole_vector_p ? build_zero_cst (vectype) : NULL_TREE;\n+  tree masktype = (use_whole_vector_p == 2\n+\t\t   ? build_same_sized_truth_vector_type (vectype) : NULL_TREE);\n   stmt_vec_info prev_stmt_info = NULL;\n   tree vec_oprnd1 = NULL_TREE;\n   tree vec_oprnd2 = NULL_TREE;\n@@ -6742,15 +6787,35 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       for (int i = 0; i < units_log2; ++i)\n \t{\n \t  tree new_temp = make_ssa_name (vectype);\n-\t  gimple *g = gimple_build_assign (new_temp, VEC_PERM_EXPR, v,\n-\t\t\t\t\t   vec_oprnd1, perms[i]);\n+\t  gimple *g = gimple_build_assign (new_temp, VEC_PERM_EXPR,\n+\t\t\t\t\t   zero_vec ? zero_vec : vec_oprnd1, v,\n+\t\t\t\t\t   perms[i]);\n \t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n \t  if (prev_stmt_info == NULL)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \t  else\n \t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \t  prev_stmt_info = new_stmt_info;\n \n+\t  if (use_whole_vector_p == 2)\n+\t    {\n+\t      /* Whole vector shift shifted in zero bits, but if *init\n+\t\t is not initializer_zerop, we need to replace those elements\n+\t\t with elements from vec_oprnd1.  */\n+\t      tree_vector_builder vb (masktype, nunits, 1);\n+\t      for (unsigned HOST_WIDE_INT k = 0; k < nunits; ++k)\n+\t\tvb.quick_push (k < (HOST_WIDE_INT_1U << i)\n+\t\t\t       ? boolean_false_node : boolean_true_node);\n+\n+\t      tree new_temp2 = make_ssa_name (vectype);\n+\t      g = gimple_build_assign (new_temp2, VEC_COND_EXPR, vb.build (),\n+\t\t\t\t       new_temp, vec_oprnd1);\n+\t      new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t      prev_stmt_info = new_stmt_info;\n+\t      new_temp = new_temp2;\n+\t    }\n+\n \t  tree new_temp2 = make_ssa_name (vectype);\n \t  g = gimple_build_assign (new_temp2, code, v, new_temp);\n \t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);"}]}