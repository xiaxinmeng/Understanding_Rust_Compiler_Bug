{"sha": "7061821d4aa300b600f689cadb994d7658600414", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA2MTgyMWQ0YWEzMDBiNjAwZjY4OWNhZGI5OTRkNzY1ODYwMDQxNA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-10-17T16:35:11Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-17T16:35:11Z"}, "message": "reg-stack.c (compare_for_stack_reg): Add bool argument.\n\n\t* reg-stack.c (compare_for_stack_reg): Add bool argument.\n\tDetect FTST instruction and handle its register pops.  Only pop\n\tsecond operand if can_pop_second_op is true.\n\t(subst_stack_regs_pat) <case COMPARE>: Detect FCOMI instruction to\n\tset can_pop_second_op to false in the compare_for_stack_reg call.\n\n\t* config/i386/i386.md (*cmpi<FPCMP:unord><MODEF:mode>): Only call\n\toutput_fp_compare for stack register operands.\n\t* config/i386/i386.c (output_fp_compare): Do not output SSE compare\n\tinstructions here.  Do not emit stack register pops here.  Assert\n\tthat FCOMPP pops next to top stack register.  Rewrite function.\n\nFrom-SVN: r253821", "tree": {"sha": "a3619d841745f6bbd60f09336e5dcbfe8866245c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3619d841745f6bbd60f09336e5dcbfe8866245c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7061821d4aa300b600f689cadb994d7658600414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061821d4aa300b600f689cadb994d7658600414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7061821d4aa300b600f689cadb994d7658600414", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061821d4aa300b600f689cadb994d7658600414/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a2018625a1192831f76b5bac3cb679a88947577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2018625a1192831f76b5bac3cb679a88947577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2018625a1192831f76b5bac3cb679a88947577"}], "stats": {"total": 189, "additions": 81, "deletions": 108}, "files": [{"sha": "3c7fac739df76d169f3ee27b7677db2fd3fe3637", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061821d4aa300b600f689cadb994d7658600414/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061821d4aa300b600f689cadb994d7658600414/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7061821d4aa300b600f689cadb994d7658600414", "patch": "@@ -1,3 +1,17 @@\n+2017-10-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* reg-stack.c (compare_for_stack_reg): Add bool argument.\n+\tDetect FTST instruction and handle its register pops.  Only pop\n+\tsecond operand if can_pop_second_op is true.\n+\t(subst_stack_regs_pat) <case COMPARE>: Detect FCOMI instruction to\n+\tset can_pop_second_op to false in the compare_for_stack_reg call.\n+\n+\t* config/i386/i386.md (*cmpi<FPCMP:unord><MODEF:mode>): Only call\n+\toutput_fp_compare for stack register operands.\n+\t* config/i386/i386.c (output_fp_compare): Do not output SSE compare\n+\tinstructions here.  Do not emit stack register pops here.  Assert\n+\tthat FCOMPP pops next to top stack register.  Rewrite function.\n+\n 2017-10-17  Nathan Sidwell  <nathan@acm.org>\n \n \tPR middle-end/82577"}, {"sha": "2024cfea8ff96ae574ce381a558d5e64086bab8c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 42, "deletions": 97, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061821d4aa300b600f689cadb994d7658600414/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061821d4aa300b600f689cadb994d7658600414/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7061821d4aa300b600f689cadb994d7658600414", "patch": "@@ -18879,120 +18879,65 @@ output_387_ffreep (rtx *operands ATTRIBUTE_UNUSED, int opno)\n    should be used.  UNORDERED_P is true when fucom should be used.  */\n \n const char *\n-output_fp_compare (rtx_insn *insn, rtx *operands, bool eflags_p, bool unordered_p)\n+output_fp_compare (rtx_insn *insn, rtx *operands,\n+\t\t   bool eflags_p, bool unordered_p)\n {\n-  int stack_top_dies;\n-  rtx cmp_op0, cmp_op1;\n-  int is_sse = SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]);\n+  rtx *xops = eflags_p ? &operands[0] : &operands[1];\n+  bool stack_top_dies;\n \n-  if (eflags_p)\n-    {\n-      cmp_op0 = operands[0];\n-      cmp_op1 = operands[1];\n-    }\n-  else\n-    {\n-      cmp_op0 = operands[1];\n-      cmp_op1 = operands[2];\n-    }\n+  static char buf[40];\n+  const char *p, *r;\n+ \n+  gcc_assert (STACK_TOP_P (xops[0]));\n \n-  if (is_sse)\n-    {\n-      if (GET_MODE (operands[0]) == SFmode)\n-\tif (unordered_p)\n-\t  return \"%vucomiss\\t{%1, %0|%0, %1}\";\n-\telse\n-\t  return \"%vcomiss\\t{%1, %0|%0, %1}\";\n-      else\n-\tif (unordered_p)\n-\t  return \"%vucomisd\\t{%1, %0|%0, %1}\";\n-\telse\n-\t  return \"%vcomisd\\t{%1, %0|%0, %1}\";\n-    }\n+  stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG);\n \n-  gcc_assert (STACK_TOP_P (cmp_op0));\n+  if (eflags_p)\n+    {\n+      p = unordered_p ? \"fucomi\" : \"fcomi\";\n+      strcpy (buf, p);\n \n-  stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n+      r = \"p\\t{%y1, %0|%0, %y1}\";\n+      strcat (buf, r + !stack_top_dies);\n \n-  if (cmp_op1 == CONST0_RTX (GET_MODE (cmp_op1)))\n-    {\n-      if (stack_top_dies)\n-\t{\n-\t  output_asm_insn (\"ftst\\n\\tfnstsw\\t%0\", operands);\n-\t  return output_387_ffreep (operands, 1);\n-\t}\n-      else\n-\treturn \"ftst\\n\\tfnstsw\\t%0\";\n+      return buf;\n     }\n \n-  if (STACK_REG_P (cmp_op1)\n+  if (STACK_REG_P (xops[1])\n       && stack_top_dies\n-      && find_regno_note (insn, REG_DEAD, REGNO (cmp_op1))\n-      && REGNO (cmp_op1) != FIRST_STACK_REG)\n+      && find_regno_note (insn, REG_DEAD, FIRST_STACK_REG + 1))\n     {\n-      /* If both the top of the 387 stack dies, and the other operand\n-\t is also a stack register that dies, then this must be a\n-\t `fcompp' float compare */\n+      gcc_assert (REGNO (xops[1]) == FIRST_STACK_REG + 1);\n \n-      if (eflags_p)\n-\t{\n-\t  /* There is no double popping fcomi variant.  Fortunately,\n-\t     eflags is immune from the fstp's cc clobbering.  */\n-\t  if (unordered_p)\n-\t    output_asm_insn (\"fucomip\\t{%y1, %0|%0, %y1}\", operands);\n-\t  else\n-\t    output_asm_insn (\"fcomip\\t{%y1, %0|%0, %y1}\", operands);\n-\t  return output_387_ffreep (operands, 0);\n-\t}\n-      else\n-\t{\n-\t  if (unordered_p)\n-\t    return \"fucompp\\n\\tfnstsw\\t%0\";\n-\t  else\n-\t    return \"fcompp\\n\\tfnstsw\\t%0\";\n-\t}\n+      /* If both the top of the 387 stack die, and the other operand\n+\t is also a stack register that dies, then this must be a\n+\t `fcompp' float compare.  */\n+      p = unordered_p ? \"fucompp\" : \"fcompp\";\n+      strcpy (buf, p);\n+    }\n+  else if (const0_operand (xops[1], VOIDmode))\n+    {\n+      gcc_assert (!unordered_p);\n+      strcpy (buf, \"ftst\");\n     }\n   else\n     {\n-      /* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */\n-\n-      static const char * const alt[16] =\n-      {\n-\t\"fcom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fcomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\n-\t\"ficom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"ficomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\tNULL,\n-\tNULL,\n-\n-\t\"fcomi\\t{%y1, %0|%0, %y1}\",\n-\t\"fcomip\\t{%y1, %0|%0, %y1}\",\n-\t\"fucomi\\t{%y1, %0|%0, %y1}\",\n-\t\"fucomip\\t{%y1, %0|%0, %y1}\",\n-\n-\tNULL,\n-\tNULL,\n-\tNULL,\n-\tNULL\n-      };\n-\n-      int mask;\n-      const char *ret;\n-\n-      mask  = eflags_p << 3;\n-      mask |= (GET_MODE_CLASS (GET_MODE (cmp_op1)) == MODE_INT) << 2;\n-      mask |= unordered_p << 1;\n-      mask |= stack_top_dies;\n+      if (GET_MODE_CLASS (GET_MODE (xops[1])) == MODE_INT)\n+\t{\n+\t  gcc_assert (!unordered_p);\n+\t  p = \"ficom\";\n+\t}\n+      else\n+\tp = unordered_p ? \"fucom\" : \"fcom\";\n \n-      gcc_assert (mask < 16);\n-      ret = alt[mask];\n-      gcc_assert (ret);\n+      strcpy (buf, p);\n \n-      return ret;\n+      r = \"p%Z2\\t%y2\";\n+      strcat (buf, r + !stack_top_dies);\n     }\n+\n+  output_asm_insn (buf, operands);\n+  return \"fnstsw\\t%0\";\n }\n \n void"}, {"sha": "512bd64c3c30a12c505b5f06c0ec121863e0f66b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061821d4aa300b600f689cadb994d7658600414/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061821d4aa300b600f689cadb994d7658600414/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7061821d4aa300b600f689cadb994d7658600414", "patch": "@@ -1685,8 +1685,7 @@\n    (set_attr \"mode\" \"SI\")])\n \n ;; Pentium Pro can do steps 1 through 3 in one go.\n-;; comi*, ucomi*, fcomi*, ficomi*, fucomi*\n-;; (these i387 instructions set flags directly)\n+;; (these instructions set flags directly)\n \n (define_mode_iterator FPCMP [CCFP CCFPU])\n (define_mode_attr unord [(CCFP \"\") (CCFPU \"u\")])\n@@ -1698,8 +1697,10 @@\n \t  (match_operand:MODEF 1 \"register_ssemem_operand\" \"f,vm\")))]\n   \"(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_80387 && TARGET_CMOVE)\"\n-  \"* return output_fp_compare (insn, operands, true,\n-\t\t\t       <FPCMP:MODE>mode == CCFPUmode);\"\n+  \"@\n+   * return output_fp_compare (insn, operands, true, \\\n+\t\t\t       <FPCMP:MODE>mode == CCFPUmode);\n+   %v<FPCMP:unord>comi<MODEF:ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"fcmp,ssecomi\")\n    (set_attr \"prefix\" \"orig,maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")"}, {"sha": "86021ab0b90de016ac0f5a312bed129bcf7ff793", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061821d4aa300b600f689cadb994d7658600414/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061821d4aa300b600f689cadb994d7658600414/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=7061821d4aa300b600f689cadb994d7658600414", "patch": "@@ -262,7 +262,7 @@ static bool move_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n static bool move_nan_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n static int swap_rtx_condition_1 (rtx);\n static int swap_rtx_condition (rtx_insn *);\n-static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n+static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx, bool);\n static bool subst_stack_regs_pat (rtx_insn *, stack_ptr, rtx);\n static void subst_asm_stack_regs (rtx_insn *, stack_ptr);\n static bool subst_stack_regs (rtx_insn *, stack_ptr);\n@@ -1325,7 +1325,8 @@ swap_rtx_condition (rtx_insn *insn)\n    set up.  */\n \n static void\n-compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat_src)\n+compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,\n+\t\t       rtx pat_src, bool can_pop_second_op)\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n@@ -1366,8 +1367,18 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat_src)\n \n   if (src1_note)\n     {\n-      pop_stack (regstack, REGNO (XEXP (src1_note, 0)));\n-      replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+      if (*src2 == CONST0_RTX (GET_MODE (*src2)))\n+\t{\n+\t  /* This is `ftst' insn that can't pop register.  */\n+\t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src1_note, 0)));\n+\t  emit_pop_insn (insn, regstack, XEXP (src1_note, 0),\n+\t\t\t EMIT_AFTER);\n+\t}\n+      else\n+\t{\n+\t  pop_stack (regstack, REGNO (XEXP (src1_note, 0)));\n+\t  replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t}\n     }\n \n   /* If the second operand dies, handle that.  But if the operands are\n@@ -1384,7 +1395,7 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat_src)\n \t at top (FIRST_STACK_REG) now.  */\n \n       if (get_hard_regnum (regstack, XEXP (src2_note, 0)) == FIRST_STACK_REG\n-\t  && src1_note)\n+\t  && src1_note && can_pop_second_op)\n \t{\n \t  pop_stack (regstack, REGNO (XEXP (src2_note, 0)));\n \t  replace_reg (&XEXP (src2_note, 0), FIRST_STACK_REG + 1);\n@@ -1550,7 +1561,9 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \tswitch (GET_CODE (pat_src))\n \t  {\n \t  case COMPARE:\n-\t    compare_for_stack_reg (insn, regstack, pat_src);\n+\t    /* `fcomi' insn can't pop two regs.  */\n+\t    compare_for_stack_reg (insn, regstack, pat_src,\n+\t\t\t\t   REGNO (*dest) != FLAGS_REG);\n \t    break;\n \n \t  case CALL:\n@@ -1970,7 +1983,7 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \t\tpat_src = XVECEXP (pat_src, 0, 0);\n \t\tgcc_assert (GET_CODE (pat_src) == COMPARE);\n \n-\t\tcompare_for_stack_reg (insn, regstack, pat_src);\n+\t\tcompare_for_stack_reg (insn, regstack, pat_src, true);\n \t\tbreak;\n \n \t      default:"}]}