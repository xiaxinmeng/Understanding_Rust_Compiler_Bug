{"sha": "366a7b2715f740f22d428de3bcf31f2fb03d0bea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2YTdiMjcxNWY3NDBmMjJkNDI4ZGUzYmNmMzFmMmZiMDNkMGJlYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-08-29T18:18:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-08-29T18:18:15Z"}, "message": "h8300-protos.h: Add a prototype for emit_logical_op.\n\n\t* config/h8300/h8300-protos.h: Add a prototype for\n\temit_logical_op.\n\t* config/h8300/h8300.c (emit_logical_op): New.\n\t* config/h8300/h8300.md (andhi3): Use emit_logical_op.\n\t(andsi3): Likewise.\n\t(iorhi3): Likewise.\n\t(iorsi3): Likewise.\n\t(xorhi3): Likewise.\n\t(xorsi3): Likewise.\n\nFrom-SVN: r45272", "tree": {"sha": "b245f1fb30422f9a12a03a58dfde37118f0c4eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b245f1fb30422f9a12a03a58dfde37118f0c4eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/366a7b2715f740f22d428de3bcf31f2fb03d0bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366a7b2715f740f22d428de3bcf31f2fb03d0bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366a7b2715f740f22d428de3bcf31f2fb03d0bea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366a7b2715f740f22d428de3bcf31f2fb03d0bea/comments", "author": null, "committer": null, "parents": [{"sha": "6e9c53b489ad1dcda7e54ea1a668a4c74cebcfaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9c53b489ad1dcda7e54ea1a668a4c74cebcfaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9c53b489ad1dcda7e54ea1a668a4c74cebcfaf"}], "stats": {"total": 427, "additions": 268, "deletions": 159}, "files": [{"sha": "ffc4ad598b90f51c1f30673a7dbf9aaf864f0c08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=366a7b2715f740f22d428de3bcf31f2fb03d0bea", "patch": "@@ -1,3 +1,15 @@\n+2001-08-29  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/h8300/h8300-protos.h: Add a prototype for\n+\temit_logical_op.\n+\t* config/h8300/h8300.c (emit_logical_op): New.\n+\t* config/h8300/h8300.md (andhi3): Use emit_logical_op.\n+\t(andsi3): Likewise.\n+\t(iorhi3): Likewise.\n+\t(iorsi3): Likewise.\n+\t(xorhi3): Likewise.\n+\t(xorsi3): Likewise.\n+\n 2001-08-29  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa.c (move_operand): Cast GET_MODE_SIZE results to HOST_WIDE_INT for"}, {"sha": "36997e1f136f877e133495dc5e9df8ba461a32bf", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=366a7b2715f740f22d428de3bcf31f2fb03d0bea", "patch": "@@ -37,6 +37,7 @@ extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n extern int do_movsi PARAMS ((rtx[]));\n extern void notice_update_cc PARAMS ((rtx, rtx));\n+extern const char *output_logical_op PARAMS ((enum machine_mode, int, rtx *));\n extern int expand_a_shift PARAMS ((enum machine_mode, int, rtx[]));\n extern int expand_a_rotate PARAMS ((int, rtx[]));\n extern int fix_bit_operand PARAMS ((rtx *, int, enum rtx_code));"}, {"sha": "3c95e57255a43454b88c31febdd79ee6066bcc2f", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=366a7b2715f740f22d428de3bcf31f2fb03d0bea", "patch": "@@ -1601,6 +1601,150 @@ bit_operator (x, mode)\n \t  || code == IOR);\n }\n \f\n+const char *\n+output_logical_op (mode, code, operands)\n+     enum machine_mode mode;\n+     int code;\n+     rtx *operands;\n+{\n+  /* Pretend that every byte is affected if both operands are registers.  */\n+  unsigned HOST_WIDE_INT intval =\n+    (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n+\t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n+  /* The determinant of the algorithm.  If we perform an AND, 0\n+     affects a bit.  Otherwise, 1 affects a bit.  */\n+  unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  /* The name of an insn.  */\n+  const char *opname;\n+  char insn_buf[100];\n+\n+  switch (code)\n+    {\n+    case AND:\n+      opname = \"and\";\n+      break;\n+    case IOR:\n+      opname = \"or\";\n+      break;\n+    case XOR:\n+      opname = \"xor\";\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  switch (mode)\n+    {\n+    case HImode:\n+      /* First, see if we can finish with one insn.  */\n+      if ((TARGET_H8300H || TARGET_H8300S)\n+\t  && ((det & 0x00ff) != 0)\n+\t  && ((det & 0xff00) != 0))\n+\t{\n+\t  sprintf (insn_buf, \"%s.w\\t%%T2,%%T0\", opname);\n+\t  output_asm_insn (insn_buf, operands);\n+\t}\n+      else\n+\t{\n+\t  /* Take care of the lower byte.  */\n+\t  if ((det & 0x00ff) != 0)\n+\t    {\n+\t      sprintf (insn_buf, \"%s\\t%%s2,%%s0\", opname);\n+\t      output_asm_insn (insn_buf, operands);\n+\t    }\n+\t  /* Take care of the upper byte.  */\n+\t  if ((det & 0xff00) != 0)\n+\t    {\n+\t      sprintf (insn_buf, \"%s\\t%%t2,%%t0\", opname);\n+\t      output_asm_insn (insn_buf, operands);\n+\t    }\n+\t}\n+      break;\n+    case SImode:\n+      /* First, see if we can finish with one insn.\n+\n+\t If code is either AND or XOR, we exclude two special cases,\n+\t 0xffffff00 and 0xffff00ff, because insns like sub.w or neg.w\n+\t can do a better job.  */\n+      if ((TARGET_H8300H || TARGET_H8300S)\n+\t  && ((det & 0x0000ffff) != 0)\n+\t  && ((det & 0xffff0000) != 0)\n+\t  && (code == IOR || det != 0xffffff00)\n+\t  && (code == IOR || det != 0xffff00ff))\n+\t{\n+\t  sprintf (insn_buf, \"%s.l\\t%%S2,%%S0\", opname);\n+\t  output_asm_insn (insn_buf, operands);\n+\t}\n+      else\n+\t{\n+\t  /* Take care of the lower and upper words individually.  For\n+\t     each word, we try different methods in the order of\n+\n+\t     1) the special insn (in case of AND or XOR),\n+\t     2) the word-wise insn, and\n+\t     3) The byte-wise insn.  */\n+\t  if ((TARGET_H8300H || TARGET_H8300S)\n+\t      && ((det & 0x0000ffff) == 0x0000ffff)\n+\t      && code != IOR)\n+\t    output_asm_insn ((code == AND)\n+\t\t\t     ? \"sub.w\\t%f0,%f0\" : \"neg.w\\t%f0\",\n+\t\t\t     operands);\n+\t  else if ((TARGET_H8300H || TARGET_H8300S)\n+\t\t   && ((det & 0x000000ff) != 0)\n+\t\t   && ((det & 0x0000ff00) != 0))\n+\t    {\n+\t      sprintf (insn_buf, \"%s.w\\t%%f2,%%f0\", opname);\n+\t      output_asm_insn (insn_buf, operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((det & 0x000000ff) != 0)\n+\t\t{\n+\t\t  sprintf (insn_buf, \"%s\\t%%w2,%%w0\", opname);\n+\t\t  output_asm_insn (insn_buf, operands);\n+\t\t}\n+\t      if ((det & 0x0000ff00) != 0)\n+\t\t{\n+\t\t  sprintf (insn_buf, \"%s\\t%%x2,%%x0\", opname);\n+\t\t  output_asm_insn (insn_buf, operands);\n+\t\t}\n+\t    }\n+\n+\t  if ((TARGET_H8300H || TARGET_H8300S)\n+\t      && ((det & 0xffff0000) == 0xffff0000)\n+\t      && code != IOR)\n+\t    output_asm_insn ((code == AND)\n+\t\t\t     ? \"sub.w\\t%e0,%e0\" : \"neg.w\\t%e0\",\n+\t\t\t     operands);\n+\t  else if (TARGET_H8300H || TARGET_H8300S)\n+\t    {\n+\t      if ((det & 0xffff0000) != 0)\n+\t\t{\n+\t\t  sprintf (insn_buf, \"%s.w\\t%%e2,%%e0\", opname);\n+\t\t  output_asm_insn (insn_buf, operands);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((det & 0x00ff0000) != 0)\n+\t\t{\n+\t\t  sprintf (insn_buf, \"%s\\t%%y2,%%y0\", opname);\n+\t\t  output_asm_insn (insn_buf, operands);\n+\t\t}\n+\t      if ((det & 0xff000000) != 0)\n+\t\t{\n+\t\t  sprintf (insn_buf, \"%s\\t%%z2,%%z0\", opname);\n+\t\t  output_asm_insn (insn_buf, operands);\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+    default:\n+      abort ();\n+    }\n+  return \"\";\n+}\n+\f\n /* Shifts.\n \n    We devote a fair bit of code to getting efficient shifts since we can only"}, {"sha": "d9d549673a9ed80810bfaa161dfe08f787c623f8", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 111, "deletions": 159, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366a7b2715f740f22d428de3bcf31f2fb03d0bea/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=366a7b2715f740f22d428de3bcf31f2fb03d0bea", "patch": "@@ -988,83 +988,55 @@\n     DONE;\n }\")\n \n-(define_insn \"andhi3\"\n+(define_expand \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:HI 2 \"nonmemory_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n-\n-      if ((i & 0x00ff) != 0x00ff)\n-\toutput_asm_insn (\\\"and\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0xff00)\n-\toutput_asm_insn (\\\"and\t%t2,%t0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"and.w\t%T2,%T0\\\";\n-  return \\\"and\t%s2,%s0\\;and\t%t2,%t0;\\\";\n-}\"\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (HImode, AND, operands);\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"andsi3\"\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (HImode, AND, operands);\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set_znv,clobber\")])\n+\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n-      int upper_cleared, lower_cleared;\n-\n-      /* The h8300h can't do byte-wise operations on the\n-\t upper 16bits of 32bit registers.  However, if\n-\t those bits aren't going to change, or they're\n-\t going to be zero'd out, then we can work on the\n-\t low-order bits.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && ((i & 0xffff0000) != 0xffff0000\n-\t      || (i & 0xffff0000) == 0x00000000))\n-        return \\\"and.l\t%S2,%S0\\\";\n-\n-      lower_cleared = 0;\n-      if ((i & 0x0000ffff) == 0x00000000)\n-\t{\n-\t  output_asm_insn (\\\"sub.w\t%f0,%f0\\\", operands);\n-\t  lower_cleared = 1;\n-\t}\n-\n-      upper_cleared = 0;\n-      if ((i & 0xffff0000) == 0x00000000)\n-\t{\n-\t  output_asm_insn (\\\"sub.w\t%e0,%e0\\\", operands);\n-\t  upper_cleared = 1;\n-\t}\n-\n-      if ((i & 0x000000ff) != 0x000000ff && !lower_cleared)\n-\toutput_asm_insn (\\\"and\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0x0000ff00 && !lower_cleared)\n-\toutput_asm_insn (\\\"and\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared)\n-\toutput_asm_insn (\\\"and\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0xff000000 && !upper_cleared)\n-\toutput_asm_insn (\\\"and\t%z2,%z0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"and.l\t%S2,%S0\\\";\n-  return \\\"and\t%w2,%w0\\;and\t%x2,%x0\\;and\t%y2,%y0\\;and\t%z2,%z0\\\";\n-}\"\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (SImode, AND, operands);\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (SImode, AND, operands);\"\n+  [(set_attr \"length\" \"4,6\")\n+   (set_attr \"cc\" \"set_znv,clobber\")])\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n@@ -1093,66 +1065,56 @@\n     DONE;\n }\")\n \n-(define_insn \"iorhi3\"\n+(define_expand \"iorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n \t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"J,rn\")))]\n   \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n+  \"\")\n \n-      if ((i & 0x00ff) != 0)\n-\toutput_asm_insn (\\\"or\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0)\n-\toutput_asm_insn (\\\"or\t%t2,%t0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"or.w\t%T2,%T0\\\";\n-  return \\\"or\t%s2,%s0\\;or\t%t2,%t0; %2 or2\\\";\n-}\"\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"J,rn\")))]\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (HImode, IOR, operands);\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n-(define_insn \"iorsi3\"\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"J,r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (HImode, IOR, operands);\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"clobber,set_znv,clobber\")])\n+\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n-\n-      /* The h8300h can't do byte-wise operations on the\n-\t upper 16bits of 32bit registers.  However, if\n-\t those bits aren't going to change, then we can\n-\t work on the low-order bits.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && (i & 0xffff0000) != 0x00000000)\n-        return \\\"or.l\t%S2,%S0\\\";\n-\n-      if ((i & 0x000000ff) != 0)\n-\toutput_asm_insn (\\\"or\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0)\n-\toutput_asm_insn (\\\"or\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0)\n-\toutput_asm_insn (\\\"or\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0)\n-\toutput_asm_insn (\\\"or\t%z2,%z0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"or.l\t%S2,%S0\\\";\n-  return \\\"or\t%w2,%w0\\;or\t%x2,%x0\\;or\t%y2,%y0\\;or\t%z2,%z0\\\";\n-}\"\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (SImode, IOR, operands);\"\n   [(set_attr \"length\" \"2,8\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (SImode, IOR, operands);\"\n+  [(set_attr \"length\" \"2,4,6\")\n+   (set_attr \"cc\" \"clobber,set_znv,clobber\")])\n+\n ;; ----------------------------------------------------------------------\n ;; XOR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -1180,65 +1142,55 @@\n     DONE;\n }\")\n \n-(define_insn \"xorhi3\"\n+(define_expand \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"nonmemory_operand\" \"J,rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n-\n-      if ((i & 0x00ff) != 0)\n-\toutput_asm_insn (\\\"xor\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0)\n-\toutput_asm_insn (\\\"xor\t%t2,%t0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"xor.w\t%T2,%T0\\\";\n-  return \\\"xor\t%s2,%s0\\;xor\t%t2,%t0\\\";\n-}\"\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (HImode, XOR, operands);\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n \n-(define_insn \"xorsi3\"\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"J,r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (HImode, XOR, operands);\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"clobber,set_znv,clobber\")])\n+\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[2]);\n-\n-      /* The h8300h can't do byte-wise operations on the\n-\t upper 16bits of 32bit registers.  However, if\n-\t those bits aren't going to change, then we can\n-\t work on the low-order bits.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && (i & 0xffff0000) != 0x00000000)\n-        return \\\"xor.l\t%S2,%S0\\\";\n-\n-      if ((i & 0x000000ff) != 0)\n-\toutput_asm_insn (\\\"xor\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0)\n-\toutput_asm_insn (\\\"xor\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0)\n-\toutput_asm_insn (\\\"xor\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0)\n-\toutput_asm_insn (\\\"xor\t%z2,%z0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  if (TARGET_H8300H || TARGET_H8300S)\n-    return \\\"xor.l\t%S2,%S0\\\";\n-  return \\\"xor\t%w2,%w0\\;xor\t%x2,%x0\\;xor\t%y2,%y0\\;xor\t%z2,%z0\\\";\n-}\"\n+  \"TARGET_H8300\"\n+  \"* return output_logical_op (SImode, XOR, operands);\"\n   [(set_attr \"length\" \"2,8\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,r,n\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return output_logical_op (SImode, XOR, operands);\"\n+  [(set_attr \"length\" \"2,4,6\")\n+   (set_attr \"cc\" \"clobber,set_znv,clobber\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; NEGATION INSTRUCTIONS"}]}