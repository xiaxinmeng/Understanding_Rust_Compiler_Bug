{"sha": "6acf7d4b45ce7f4ef75d46dc7563076a791210fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFjZjdkNGI0NWNlN2Y0ZWY3NWQ0NmRjNzU2MzA3NmE3OTEyMTBmYg==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-29T10:41:23Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-05-29T10:41:23Z"}, "message": "docs, prep\n\n[[Split portion of a mixed commit.]]\n\nFrom-SVN: r27238.2", "tree": {"sha": "ecd9e25763935b79b4a60d2652911ed4bc4cc832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd9e25763935b79b4a60d2652911ed4bc4cc832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6acf7d4b45ce7f4ef75d46dc7563076a791210fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6acf7d4b45ce7f4ef75d46dc7563076a791210fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6acf7d4b45ce7f4ef75d46dc7563076a791210fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6acf7d4b45ce7f4ef75d46dc7563076a791210fb/comments", "author": null, "committer": null, "parents": [{"sha": "266fa0f63c6be97a21c0981406cddd3feb5785b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266fa0f63c6be97a21c0981406cddd3feb5785b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266fa0f63c6be97a21c0981406cddd3feb5785b5"}], "stats": {"total": 145, "additions": 141, "deletions": 4}, "files": [{"sha": "5a5c1c76b95dbc1f942a5d5528c5775367a4e759", "filename": "gcc/f/ffe.texi", "status": "modified", "additions": 141, "deletions": 4, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6acf7d4b45ce7f4ef75d46dc7563076a791210fb/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6acf7d4b45ce7f4ef75d46dc7563076a791210fb/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=6acf7d4b45ce7f4ef75d46dc7563076a791210fb", "patch": "@@ -588,15 +588,18 @@ a single lexeme.\n \n (This is a horrible misfeature of the Fortran 90 language.\n It's one of many such misfeatures that almost make me want\n-to not support them, and forge ahead with designing a true\n+to not support them, and forge ahead with designing a new\n ``GNU Fortran'' language that has the features,\n-without the misfeatures, of Fortran 90,\n-and provide programs to do the conversion automatically.)\n+but not the misfeatures, of Fortran 90,\n+and provide utility programs to do the conversion automatically.)\n \n So, the lexer must gather distinct chunks of decimal strings into\n a single lexeme in contexts where a single decimal lexeme might\n start a Hollerith constant.\n-(Which means it might as well do that all the time.)\n+\n+(Which probably means it might as well do that all the time\n+for all multi-character lexemes, even in free-form mode,\n+leaving it to subsequent phases to pull them apart as they see fit.)\n \n Compare the treatment of this to how\n \n@@ -613,6 +616,140 @@ CHARACTER * 12 HEY\n must be treated---the former must be diagnosed, due to the separation\n between lexemes, the latter must be accepted as a proper declaration.\n \n+@subsubsection Hollerith Constants\n+\n+Recognizing a Hollerith constant---specifically,\n+that an @samp{H} or @samp{h} after a digit string begins\n+such a constant---requires some knowledge of context.\n+\n+Hollerith constants (such as @samp{2HAB}) can appear after:\n+\n+@itemize @bullet\n+@item\n+@samp{FORMAT(}\n+\n+@item\n+@samp{,}\n+\n+@item\n+@samp{=}\n+\n+@item\n+@samp{+}, @samp{-}, @samp{/}\n+\n+@item\n+@samp{*}, except as noted below\n+@end itemize\n+\n+Hollerith constants don't appear after:\n+\n+@itemize @bullet\n+@item\n+@samp{CHARACTER*},\n+which can be treated generally as\n+any @samp{*} that is the second lexeme of a statement\n+@end itemize\n+\n+@subsubsection Confusing Function Keyword\n+\n+While\n+\n+@smallexample\n+REAL FUNCTION FOO ()\n+@end smallexample\n+\n+must be a @code{FUNCTION} statement and\n+\n+@smallexample\n+REAL FUNCTION FOO (5)\n+@end smallexample\n+\n+must be a type-definition statement,\n+\n+@smallexample\n+REAL FUNCTION FOO (@var{names})\n+@end smallexample\n+\n+where @var{names} is a comma-separated list of names,\n+can be one or the other.\n+\n+The only way to disambiguate that statement\n+(short of mandating free-form source or a short maximum\n+length for name for external procedures)\n+is based on the context of the statement.\n+\n+In particular, the statement is known to be within an\n+already-started program unit\n+(but not at the outer level of the @code{CONTAINS} block),\n+it is a type-declaration statement.\n+\n+Otherwise, the statement is a @code{FUNCTION} statement,\n+in that it begins a function program unit\n+(external, or, within @code{CONTAINS}, nested).\n+\n+@subsubsection Weird READ\n+\n+The statement\n+\n+@smallexample\n+READ (N)\n+@end smallexample\n+\n+is equivalent to either\n+\n+@smallexample\n+READ (UNIT=(N))\n+@end smallexample\n+\n+or\n+\n+@smallexample\n+READ (FMT=(N))\n+@end smallexample\n+\n+depending on which would be valid in context.\n+\n+Specifically, if @samp{N} is type @code{INTEGER},\n+@samp{READ (FMT=(N))} would not be valid,\n+because parentheses may not be used around @samp{N},\n+whereas they may around it in @samp{READ (UNIT=(N))}.\n+\n+Further, if @samp{N} is type @code{CHARACTER},\n+the opposite is true---@samp{READ (UNIT=(N))} is not valid,\n+but @samp{READ (FMT=(N))} is.\n+\n+Strictly speaking, if anything follows\n+\n+@smallexample\n+READ (N)\n+@end smallexample\n+\n+in the statement, whether the first lexeme after the close\n+parenthese is a comma could be used to disambiguate the two cases,\n+without looking at the type of @samp{N},\n+because the comma is required for the @samp{READ (FMT=(N))}\n+interpretation and disallowed for the @samp{READ (UNIT=(N))}\n+interpretation.\n+\n+However, in practice, many Fortran compilers allow\n+the comma for the @samp{READ (UNIT=(N))}\n+interpretation anyway\n+(in that they generally allow a leading comma before\n+an I/O list in an I/O statement),\n+and much code takes advantage of this allowance.\n+\n+(This is quite a reasonable allowance, since the\n+juxtaposition of a comma-separated list immediately\n+after an I/O control-specification list, which is also comma-separated,\n+without an intervening comma,\n+looks sufficiently ``wrong'' to programmers\n+that they can't resist the itch to insert the comma.\n+@samp{READ (I, J), K, L} simply looks cleaner than\n+@samp{READ (I, J) K, L}.)\n+\n+So, type-based disambiguation is needed unless strict adherence\n+to the standard is always assumed, and we're not going to assume that.\n+\n @node TBD (Transforming)\n @subsection TBD (Transforming)\n "}]}