{"sha": "a29c7ea6283b45f58d640c8747ee570a1b50bff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5YzdlYTYyODNiNDVmNThkNjQwYzg3NDdlZTU3MGExYjUwYmZmNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-02-26T14:53:39Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-02-26T14:53:39Z"}, "message": "* loop-unroll.c: New.\n\nFrom-SVN: r63470", "tree": {"sha": "d5c1ad0aaf8a976ba8dceb0f868fcbf9daad21f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5c1ad0aaf8a976ba8dceb0f868fcbf9daad21f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29c7ea6283b45f58d640c8747ee570a1b50bff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29c7ea6283b45f58d640c8747ee570a1b50bff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29c7ea6283b45f58d640c8747ee570a1b50bff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29c7ea6283b45f58d640c8747ee570a1b50bff7/comments", "author": null, "committer": null, "parents": [{"sha": "4c8826cdf88ffa3745fcc4bff438742b1116d42d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8826cdf88ffa3745fcc4bff438742b1116d42d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c8826cdf88ffa3745fcc4bff438742b1116d42d"}], "stats": {"total": 1195, "additions": 1195, "deletions": 0}, "files": [{"sha": "67eb8da45b0b53270b41d547aa815e3fdf6c469b", "filename": "gcc/loop-unroll.c", "status": "added", "additions": 1195, "deletions": 0, "changes": 1195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29c7ea6283b45f58d640c8747ee570a1b50bff7/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29c7ea6283b45f58d640c8747ee570a1b50bff7/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=a29c7ea6283b45f58d640c8747ee570a1b50bff7", "patch": "@@ -0,0 +1,1195 @@\n+/* Loop unrolling and peeling.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n+#include \"params.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+\n+/* This pass performs loop unrolling and peeling.  We only perform these\n+   optimalizations on innermost loops (with single exception) because\n+   the impact on performance is greatest here, and we want to avoid\n+   unnecessary code size growth.  The gain is caused by greater sequentiality\n+   of code, better code to optimize for futher passes and in some cases\n+   by fewer testings of exit conditions.  The main problem is code growth,\n+   that impacts performance negatively due to effect of caches.\n+\n+   What we do:\n+\n+   -- complete peeling of once-rolling loops; this is the above mentioned\n+      exception, as this causes loop to be cancelled completely and\n+      does not cause code growth\n+   -- complete peeling of loops that roll (small) constant times.\n+   -- simple peeling of first iterations of loops that do not roll much\n+      (according to profile feedback)\n+   -- unrolling of loops that roll constant times; this is almost always\n+      win, as we get rid of exit condition tests.\n+   -- unrolling of loops that roll number of times that we can compute\n+      in runtime; we also get rid of exit condition tests here, but there\n+      is the extra expense for calculating the number of iterations\n+   -- simple unrolling of remaining loops; this is performed only if we\n+      are asked to, as the gain is questionable in this case and often\n+      it may even slow down the code\n+   For more detailed descriptions of each of those, see comments at\n+   appropriate function below.\n+\n+   There is a lot of parameters (defined and described in params.def) that\n+   control how much we unroll/peel.\n+\n+   ??? A great problem is that we don't have a good way how to determine\n+   how many times we should unroll the loop; the experiments I have made\n+   showed that this choice may affect performance in order of several %.\n+   */\n+\n+static void decide_unrolling_and_peeling PARAMS ((struct loops *, int));\n+static void peel_loops_completely PARAMS ((struct loops *, int));\n+static void decide_peel_simple PARAMS ((struct loops *, struct loop *, int));\n+static void decide_peel_once_rolling PARAMS ((struct loops *, struct loop *, int));\n+static void decide_peel_completely PARAMS ((struct loops *, struct loop *, int));\n+static void decide_unroll_stupid PARAMS ((struct loops *, struct loop *, int));\n+static void decide_unroll_constant_iterations PARAMS ((struct loops *, struct loop *, int));\n+static void decide_unroll_runtime_iterations PARAMS ((struct loops *, struct loop *, int));\n+static void peel_loop_simple PARAMS ((struct loops *, struct loop *));\n+static void peel_loop_completely PARAMS ((struct loops *, struct loop *));\n+static void unroll_loop_stupid PARAMS ((struct loops *, struct loop *));\n+static void unroll_loop_constant_iterations PARAMS ((struct loops *,\n+\t\t\t\t\t\t     struct loop *));\n+static void unroll_loop_runtime_iterations PARAMS ((struct loops *,\n+\t\t\t\t\t\t    struct loop *));\n+\n+/* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n+void\n+unroll_and_peel_loops (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  struct loop *loop, *next;\n+  int check;\n+\n+  /* First perform complete loop peeling (it is almost surely a win,\n+     and affects parameters for further decision a lot).  */\n+  peel_loops_completely (loops, flags);\n+\n+  /* Now decide rest of unrolling and peeling.  */\n+  decide_unrolling_and_peeling (loops, flags);\n+\n+  loop = loops->tree_root;\n+  while (loop->inner)\n+    loop = loop->inner;\n+\n+  /* Scan the loops, inner ones first.  */\n+  while (loop != loops->tree_root)\n+    {\n+      if (loop->next)\n+\t{\n+\t  next = loop->next;\n+\t  while (next->inner)\n+\t    next = next->inner;\n+\t}\n+      else\n+\tnext = loop->outer;\n+\n+      check = 1;\n+      /* And perform the appropriate transformations.  */\n+      switch (loop->lpt_decision.decision)\n+\t{\n+\tcase LPT_PEEL_COMPLETELY:\n+\t  /* Already done.  */\n+\t  abort ();\n+\tcase LPT_PEEL_SIMPLE:\n+\t  peel_loop_simple (loops, loop);\n+\t  break;\n+\tcase LPT_UNROLL_CONSTANT:\n+\t  unroll_loop_constant_iterations (loops, loop);\n+\t  break;\n+\tcase LPT_UNROLL_RUNTIME:\n+\t  unroll_loop_runtime_iterations (loops, loop);\n+\t  break;\n+\tcase LPT_UNROLL_STUPID:\n+\t  unroll_loop_stupid (loops, loop);\n+\t  break;\n+\tcase LPT_NONE:\n+\t  check = 0;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      if (check)\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  verify_dominators (loops->cfg.dom);\n+\t  verify_loop_structure (loops);\n+#endif\n+\t}\n+      loop = next;\n+    }\n+}\n+\n+/* Check whether to peel LOOPS (depending on FLAGS) completely and do so.  */\n+static void\n+peel_loops_completely (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  struct loop *loop, *next;\n+\n+  loop = loops->tree_root;\n+  while (loop->inner)\n+    loop = loop->inner;\n+\n+  while (loop != loops->tree_root)\n+    {\n+      if (loop->next)\n+\t{\n+\t  next = loop->next;\n+\t  while (next->inner)\n+\t    next = next->inner;\n+\t}\n+      else\n+\tnext = loop->outer;\n+\n+      loop->lpt_decision.decision = LPT_NONE;\n+      loop->has_desc = 0;\n+  \n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Considering loop %d for complete peeling\\n\",\n+\t\t loop->num);\n+\n+      /* Do not peel cold areas.  */\n+      if (!maybe_hot_bb_p (loop->header))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n+\t  loop = next;\n+\t  continue;\n+\t}\n+\n+      /* Can the loop be manipulated?  */\n+      if (!can_duplicate_loop_p (loop))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \";; Not considering loop, cannot duplicate\\n\");\n+\t  loop = next;\n+\t  continue;\n+\t}\n+\n+      loop->ninsns = num_loop_insns (loop);\n+\n+      decide_peel_once_rolling (loops, loop, flags);\n+      if (loop->lpt_decision.decision == LPT_NONE)\n+\tdecide_peel_completely (loops, loop, flags);\n+\n+      if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n+\t{\n+\t  peel_loop_completely (loops, loop);\n+#ifdef ENABLE_CHECKING\n+\t  verify_dominators (loops->cfg.dom);\n+\t  verify_loop_structure (loops);\n+#endif\n+\t}\n+      loop = next;\n+    }\n+}\n+\n+/* Decide whether unroll or peel LOOPS (depending on FLAGS) and how much.  */\n+static void\n+decide_unrolling_and_peeling (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  struct loop *loop = loops->tree_root, *next;\n+\n+  while (loop->inner)\n+    loop = loop->inner;\n+\n+  /* Scan the loops, inner ones first.  */\n+  while (loop != loops->tree_root)\n+    {\n+      if (loop->next)\n+\t{\n+\t  next = loop->next;\n+\t  while (next->inner)\n+\t    next = next->inner;\n+\t}\n+      else\n+\tnext = loop->outer;\n+\n+      loop->lpt_decision.decision = LPT_NONE;\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Considering loop %d\\n\", loop->num);\n+\n+      /* Do not peel cold areas.  */\n+      if (!maybe_hot_bb_p (loop->header))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n+\t  loop = next;\n+\t  continue;\n+\t}\n+\n+      /* Can the loop be manipulated?  */\n+      if (!can_duplicate_loop_p (loop))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \";; Not considering loop, cannot duplicate\\n\");\n+\t  loop = next;\n+\t  continue;\n+\t}\n+\n+      /* Skip non-innermost loops.  */\n+      if (loop->inner)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \";; Not considering loop, is not innermost\\n\");\n+\t  loop = next;\n+\t  continue;\n+\t}\n+\n+      loop->ninsns = num_loop_insns (loop);\n+      loop->av_ninsns = average_num_loop_insns (loop);\n+\n+      /* Try transformations one by one in decreasing order of\n+\t priority.  */\n+\n+      decide_unroll_constant_iterations (loops, loop, flags);\n+      if (loop->lpt_decision.decision == LPT_NONE)\n+\tdecide_unroll_runtime_iterations (loops, loop, flags);\n+      if (loop->lpt_decision.decision == LPT_NONE)\n+\tdecide_unroll_stupid (loops, loop, flags);\n+      if (loop->lpt_decision.decision == LPT_NONE)\n+\tdecide_peel_simple (loops, loop, flags);\n+\n+      loop = next;\n+    }\n+}\n+\n+/* Decide whether the LOOP is once rolling and suitable for complete\n+   peeling.  */\n+static void\n+decide_peel_once_rolling (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags ATTRIBUTE_UNUSED;\n+{\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering peeling once rolling loop\\n\");\n+\n+  /* Is the loop small enough?  */\n+  if ((unsigned) PARAM_VALUE (PARAM_MAX_ONCE_PEELED_INSNS) < loop->ninsns)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+  loop->has_desc = 1;\n+\n+  /* Check number of iterations.  */\n+  if (!loop->simple || !loop->desc.const_iter || loop->desc.niter !=0)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Unable to prove that the loop rolls exactly once\\n\");\n+      return;\n+    }\n+\n+  /* Success.  */\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Decided to peel exactly once rolling loop\\n\");\n+  loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n+}\n+\n+/* Decide whether the LOOP is suitable for complete peeling.  */\n+static void\n+decide_peel_completely (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags ATTRIBUTE_UNUSED;\n+{\n+  unsigned npeel;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering peeling completely\\n\");\n+\n+  /* Skip non-innermost loops.  */\n+  if (loop->inner)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is not innermost\\n\");\n+      return;\n+    }\n+\n+  /* npeel = number of iterations to peel. */\n+  npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS) / loop->ninsns;\n+  if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n+    npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES);\n+\n+  /* Is the loop small enough?  */\n+  if (!npeel)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  if (!loop->has_desc)\n+    loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+\n+  /* Check number of iterations.  */\n+  if (!loop->simple || !loop->desc.const_iter)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Unable to prove that the loop iterates constant times\\n\");\n+      return;\n+    }\n+\n+  if (loop->desc.niter > npeel - 1)\n+    {\n+      if (rtl_dump_file)\n+      \t{\n+\t  fprintf (rtl_dump_file, \";; Not peeling loop completely, rolls too much (\");\n+\t  fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,(HOST_WIDEST_INT) loop->desc.niter);\n+\t  fprintf (rtl_dump_file, \"iterations > %d [maximum peelings])\\n\", npeel);\n+\t}\n+      return;\n+    }\n+\n+  /* Success.  */\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Decided to peel loop completely\\n\");\n+  loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n+}\n+\n+/* Peel all iterations of LOOP, remove exit edges and cancel the loop\n+   completely.  The transformation done:\n+   \n+   for (i = 0; i < 4; i++)\n+     body;\n+\n+   ==>\n+   \n+   i = 0; \n+   body; i++;\n+   body; i++;\n+   body; i++;\n+   body; i++;\n+   */\n+static void\n+peel_loop_completely (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  sbitmap wont_exit;\n+  unsigned HOST_WIDE_INT npeel;\n+  edge e;\n+  unsigned n_remove_edges, i;\n+  edge *remove_edges;\n+  struct loop_desc *desc = &loop->desc;\n+  \n+  npeel = desc->niter;\n+\n+  wont_exit = sbitmap_alloc (npeel + 2);\n+  sbitmap_ones (wont_exit);\n+  RESET_BIT (wont_exit, 0);\n+  RESET_BIT (wont_exit, npeel + 1);\n+  if (desc->may_be_zero)\n+    RESET_BIT (wont_exit, 1);\n+\n+  remove_edges = xcalloc (npeel, sizeof (edge));\n+  n_remove_edges = 0;\n+\n+  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\tloops, npeel + 1,\n+\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+\n+  free (wont_exit);\n+\n+  /* Remove the exit edges.  */\n+  for (i = 0; i < n_remove_edges; i++)\n+    remove_path (loops, remove_edges[i]);\n+  free (remove_edges);\n+\n+  /* Now remove the loop.  */\n+  for (e = RBI (desc->in_edge->src)->copy->succ;\n+       e && e->dest != RBI (desc->in_edge->dest)->copy;\n+       e = e->succ_next);\n+\n+  if (!e)\n+    abort ();\n+\n+  remove_path (loops, e);\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n+}\n+\n+/* Decide whether to unroll LOOP iterating constant number of times and how much.  */\n+static void\n+decide_unroll_constant_iterations (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags;\n+{\n+  unsigned nunroll, nunroll_by_av, best_copies, best_unroll = -1, n_copies, i;\n+\n+  if (!(flags & UAP_UNROLL))\n+    {\n+      /* We were not asked to, just return back silently.  */\n+      return;\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering unrolling loop with constant number of iterations\\n\");\n+\n+  /* nunroll = total number of copies of the original loop body in\n+     unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n+  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n+  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  if (nunroll > nunroll_by_av)\n+    nunroll = nunroll_by_av;\n+  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n+    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+\n+  /* Skip big loops.  */\n+  if (nunroll <= 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  if (!loop->has_desc)\n+    loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+\n+  /* Check number of iterations.  */\n+  if (!loop->simple || !loop->desc.const_iter)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Unable to prove that the loop iterates constant times\\n\");\n+      return;\n+    }\n+\n+  /* Check whether the loop rolls enough to consider.  */\n+  if (loop->desc.niter < 2 * nunroll)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      return;\n+    }\n+\n+  /* Success; now compute number of iterations to unroll.  We alter\n+     nunroll so that as few as possible copies of loop body are\n+     neccesary, while still not decreasing the number of unrollings\n+     too much (at most by 1).  */\n+  best_copies = 2 * nunroll + 10;\n+\n+  i = 2 * nunroll + 2;\n+  if ((unsigned) i - 1 >= loop->desc.niter)\n+    i = loop->desc.niter - 2;\n+\n+  for (; i >= nunroll - 1; i--)\n+    {\n+      unsigned exit_mod = loop->desc.niter % (i + 1);\n+\n+      if (loop->desc.postincr)\n+\tn_copies = exit_mod + i + 1;\n+      else if (exit_mod != (unsigned) i || loop->desc.may_be_zero)\n+\tn_copies = exit_mod + i + 2;\n+      else\n+\tn_copies = i + 1;\n+\n+      if (n_copies < best_copies)\n+\t{\n+\t  best_copies = n_copies;\n+\t  best_unroll = i;\n+\t}\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; max_unroll %d (%d copies, initial %d).\\n\",\n+\t     best_unroll + 1, best_copies, nunroll);\n+\n+  loop->lpt_decision.decision = LPT_UNROLL_CONSTANT;\n+  loop->lpt_decision.times = best_unroll;\n+}\n+\n+/* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES + 1\n+   times.  The transformation does this: \n+   \n+   for (i = 0; i < 102; i++)\n+     body;\n+   \n+   ==>\n+   \n+   i = 0;\n+   body; i++;\n+   body; i++;\n+   while (i < 102)\n+     {\n+       body; i++;\n+       body; i++;\n+       body; i++;\n+       body; i++;\n+     }\n+  */\n+static void\n+unroll_loop_constant_iterations (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  unsigned HOST_WIDE_INT niter;\n+  unsigned exit_mod;\n+  sbitmap wont_exit;\n+  unsigned n_remove_edges, i;\n+  edge *remove_edges;\n+  unsigned max_unroll = loop->lpt_decision.times;\n+  struct loop_desc *desc = &loop->desc;\n+\n+  niter = desc->niter;\n+\n+  if (niter <= (unsigned) max_unroll + 1)\n+    abort ();  /* Should not get here (such loop should be peeled instead).  */\n+\n+  exit_mod = niter % (max_unroll + 1);\n+\n+  wont_exit = sbitmap_alloc (max_unroll + 1);\n+  sbitmap_ones (wont_exit);\n+\n+  remove_edges = xcalloc (max_unroll + exit_mod + 1, sizeof (edge));\n+  n_remove_edges = 0;\n+\n+  if (desc->postincr)\n+    {\n+      /* Counter is incremented after the exit test; leave exit test\n+\t in the first copy, so that the loops that start with test\n+\t of exit condition have continuous body after unrolling.  */\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Condition on beginning of loop.\\n\");\n+\n+      /* Peel exit_mod iterations.  */\n+      RESET_BIT (wont_exit, 0);\n+      if (desc->may_be_zero)\n+\tRESET_BIT (wont_exit, 1);\n+\n+      if (exit_mod\n+\t  && !duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, exit_mod,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+\tabort ();\n+\n+      SET_BIT (wont_exit, 1);\n+    }\n+  else\n+    {\n+      /* Leave exit test in last copy, for the same reason as above if\n+\t the loop tests the condition at the end of loop body.  */\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Condition on end of loop.\\n\");\n+\n+      /* We know that niter >= max_unroll + 2; so we do not need to care of\n+\t case when we would exit before reaching the loop.  So just peel\n+\t exit_mod + 1 iterations.\n+\t */\n+      if (exit_mod != (unsigned) max_unroll || desc->may_be_zero)\n+\t{\n+\t  RESET_BIT (wont_exit, 0);\n+\t  if (desc->may_be_zero)\n+\t    RESET_BIT (wont_exit, 1);\n+\n+\t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, exit_mod + 1,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+\t    abort ();\n+\n+\t  SET_BIT (wont_exit, 0);\n+\t  SET_BIT (wont_exit, 1);\n+\t}\n+\n+      RESET_BIT (wont_exit, max_unroll);\n+    }\n+\n+  /* Now unroll the loop.  */\n+  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\tloops, max_unroll,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+\n+  free (wont_exit);\n+\n+  /* Remove the edges.  */\n+  for (i = 0; i < n_remove_edges; i++)\n+    remove_path (loops, remove_edges[i]);\n+  free (remove_edges);\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Unrolled loop %d times, constant # of iterations %i insns\\n\",max_unroll, num_loop_insns (loop));\n+}\n+\n+/* Decide whether to unroll LOOP iterating runtime computable number of times\n+   and how much.  */\n+static void\n+decide_unroll_runtime_iterations (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags;\n+{\n+  unsigned nunroll, nunroll_by_av, i;\n+\n+  if (!(flags & UAP_UNROLL))\n+    {\n+      /* We were not asked to, just return back silently.  */\n+      return;\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering unrolling loop with runtime computable number of iterations\\n\");\n+\n+  /* nunroll = total number of copies of the original loop body in\n+     unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n+  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n+  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  if (nunroll > nunroll_by_av)\n+    nunroll = nunroll_by_av;\n+  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n+    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+\n+  /* Skip big loops.  */\n+  if (nunroll <= 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  if (!loop->has_desc)\n+    loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+\n+  /* Check simpleness.  */\n+  if (!loop->simple)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Unable to prove that the number of iterations can be counted in runtime\\n\");\n+      return;\n+    }\n+\n+  if (loop->desc.const_iter)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Loop iterates constant times\\n\");\n+      return;\n+    }\n+\n+  /* If we have profile feedback, check whether the loop rolls.  */\n+  if (loop->header->count && expected_loop_iterations (loop) < 2 * nunroll)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      return;\n+    }\n+\n+  /* Success; now force nunroll to be power of 2, as we are unable to\n+     cope with overflows in computation of number of iterations.  */\n+  for (i = 1; 2 * i <= nunroll; i *= 2);\n+\n+  loop->lpt_decision.decision = LPT_UNROLL_RUNTIME;\n+  loop->lpt_decision.times = i - 1;\n+}\n+\n+/* Unroll LOOP for that we are able to count number of iterations in runtime\n+   LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some\n+   extra care for case n < 0):\n+   \n+   for (i = 0; i < n; i++)\n+     body;\n+   \n+   ==>\n+  \n+   i = 0;\n+   mod = n % 4;\n+  \n+   switch (mod)\n+     {\n+       case 3:\n+         body; i++;\n+       case 2:\n+         body; i++;\n+       case 1:\n+         body; i++;\n+       case 0: ;\n+     }\n+   \n+   while (i < n)\n+     {\n+       body; i++;\n+       body; i++;\n+       body; i++;\n+       body; i++;\n+     }\n+   */\n+static void\n+unroll_loop_runtime_iterations (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  rtx niter, init_code, branch_code, jump, label;\n+  unsigned i, j, p;\n+  basic_block preheader, *body, *dom_bbs, swtch, ezc_swtch;\n+  unsigned n_dom_bbs;\n+  sbitmap wont_exit;\n+  int may_exit_copy;\n+  unsigned n_peel, n_remove_edges;\n+  edge *remove_edges, e;\n+  bool extra_zero_check, last_may_exit;\n+  unsigned max_unroll = loop->lpt_decision.times;\n+  struct loop_desc *desc = &loop->desc;\n+\n+  /* Remember blocks whose dominators will have to be updated.  */\n+  dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n+  n_dom_bbs = 0;\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      unsigned nldom;\n+      basic_block *ldom;\n+\n+      nldom = get_dominated_by (loops->cfg.dom, body[i], &ldom);\n+      for (j = 0; j < nldom; j++)\n+\tif (!flow_bb_inside_loop_p (loop, ldom[j]))\n+\t  dom_bbs[n_dom_bbs++] = ldom[j];\n+\n+      free (ldom);\n+    }\n+  free (body);\n+\n+  if (desc->postincr)\n+    {\n+      /* Leave exit in first copy (for explanation why see comment in\n+\t unroll_loop_constant_iterations).  */\n+      may_exit_copy = 0;\n+      n_peel = max_unroll - 1;\n+      extra_zero_check = true;\n+      last_may_exit = false;\n+    }\n+  else\n+    {\n+      /* Leave exit in last copy (for explanation why see comment in\n+\t unroll_loop_constant_iterations).  */\n+      may_exit_copy = max_unroll;\n+      n_peel = max_unroll;\n+      extra_zero_check = false;\n+      last_may_exit = true;\n+    }\n+\n+  /* Get expression for number of iterations.  */\n+  start_sequence ();\n+  niter = count_loop_iterations (desc, NULL, NULL);\n+  if (!niter)\n+    abort ();\n+  niter = force_operand (niter, NULL);\n+\n+  /* Count modulo by ANDing it with max_unroll; we use the fact that\n+     the number of unrollings is a power of two, and thus this is correct\n+     even if there is overflow in the computation.  */\n+  niter = expand_simple_binop (GET_MODE (desc->var), AND,\n+\t\t\t       niter,\n+\t\t\t       GEN_INT (max_unroll),\n+\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\n+  init_code = get_insns ();\n+  end_sequence ();\n+\n+  /* Precondition the loop.  */\n+  loop_split_edge_with (loop_preheader_edge (loop), init_code, loops);\n+\n+  remove_edges = xcalloc (max_unroll + n_peel + 1, sizeof (edge));\n+  n_remove_edges = 0;\n+\n+  wont_exit = sbitmap_alloc (max_unroll + 2);\n+\n+  /* Peel the first copy of loop body (almost always we must leave exit test\n+     here; the only exception is when we have extra zero check and the number\n+     of iterations is reliable (i.e. comes out of NE condition).  Also record\n+     the place of (possible) extra zero check.  */\n+  sbitmap_zero (wont_exit);\n+  if (extra_zero_check && desc->cond == NE)\n+    SET_BIT (wont_exit, 1);\n+  ezc_swtch = loop_preheader_edge (loop)->src;\n+  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, 1,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+\n+  /* Record the place where switch will be built for preconditioning.  */\n+  swtch = loop_split_edge_with (loop_preheader_edge (loop),\n+\t\t\t\tNULL_RTX, loops);\n+\n+  for (i = 0; i < n_peel; i++)\n+    {\n+      /* Peel the copy.  */\n+      sbitmap_zero (wont_exit);\n+      if (i != n_peel - 1 || !last_may_exit)\n+\tSET_BIT (wont_exit, 1);\n+      if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, 1,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    \tabort ();\n+\n+      if (i != n_peel)\n+\t{\n+\t  /* Create item for switch.  */\n+\t  j = n_peel - i - (extra_zero_check ? 0 : 1);\n+\t  p = REG_BR_PROB_BASE / (i + 2);\n+\n+\t  preheader = loop_split_edge_with (loop_preheader_edge (loop),\n+\t\t\t\t\t    NULL_RTX, loops);\n+\t  label = block_label (preheader);\n+\t  start_sequence ();\n+\t  do_compare_rtx_and_jump (copy_rtx (niter), GEN_INT (j), EQ, 0,\n+\t\t    \t\t   GET_MODE (desc->var), NULL_RTX, NULL_RTX,\n+\t\t\t\t   label);\n+\t  jump = get_last_insn ();\n+\t  JUMP_LABEL (jump) = label;\n+\t  REG_NOTES (jump)\n+\t\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t    \t       GEN_INT (p), REG_NOTES (jump));\n+\t\n+\t  LABEL_NUSES (label)++;\n+\t  branch_code = get_insns ();\n+\t  end_sequence ();\n+\n+\t  swtch = loop_split_edge_with (swtch->pred, branch_code, loops);\n+\t  set_immediate_dominator (loops->cfg.dom, preheader, swtch);\n+\t  swtch->succ->probability = REG_BR_PROB_BASE - p;\n+\t  e = make_edge (swtch, preheader, 0);\n+\t  e->probability = p;\n+\t}\n+    }\n+\n+  if (extra_zero_check)\n+    {\n+      /* Add branch for zero iterations.  */\n+      p = REG_BR_PROB_BASE / (max_unroll + 1);\n+      swtch = ezc_swtch;\n+      preheader = loop_split_edge_with (loop_preheader_edge (loop),\n+\t\t\t\t\tNULL_RTX, loops);\n+      label = block_label (preheader);\n+      start_sequence ();\n+      do_compare_rtx_and_jump (copy_rtx (niter), const0_rtx, EQ, 0,\n+\t\t\t       GET_MODE (desc->var), NULL_RTX, NULL_RTX,\n+\t\t\t       label);\n+      jump = get_last_insn ();\n+      JUMP_LABEL (jump) = label;\n+      REG_NOTES (jump)\n+\t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t   GEN_INT (p), REG_NOTES (jump));\n+      \n+      LABEL_NUSES (label)++;\n+      branch_code = get_insns ();\n+      end_sequence ();\n+\n+      swtch = loop_split_edge_with (swtch->succ, branch_code, loops);\n+      set_immediate_dominator (loops->cfg.dom, preheader, swtch);\n+      swtch->succ->probability = REG_BR_PROB_BASE - p;\n+      e = make_edge (swtch, preheader, 0);\n+      e->probability = p;\n+    }\n+\n+  /* Recount dominators for outer blocks.  */\n+  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+\n+  /* And unroll loop.  */\n+\n+  sbitmap_ones (wont_exit);\n+  RESET_BIT (wont_exit, may_exit_copy);\n+\n+  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t \tloops, max_unroll,\n+\t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+\n+  free (wont_exit);\n+\n+  /* Remove the edges.  */\n+  for (i = 0; i < n_remove_edges; i++)\n+    remove_path (loops, remove_edges[i]);\n+  free (remove_edges);\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \";; Unrolled loop %d times, counting # of iterations in runtime, %i insns\\n\",\n+\t     max_unroll, num_loop_insns (loop));\n+}\n+  \n+/* Decide whether to simply peel LOOP and how much.  */\n+static void\n+decide_peel_simple (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags;\n+{\n+  unsigned npeel;\n+\n+  if (!(flags & UAP_PEEL))\n+    {\n+      /* We were not asked to, just return back silently.  */\n+      return;\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering simply peeling loop\\n\");\n+\n+  /* npeel = number of iterations to peel. */\n+  npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / loop->ninsns;\n+  if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_PEEL_TIMES))\n+    npeel = PARAM_VALUE (PARAM_MAX_PEEL_TIMES);\n+\n+  /* Skip big loops.  */\n+  if (!npeel)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  if (!loop->has_desc)\n+    loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+\n+  /* Check number of iterations.  */\n+  if (loop->simple && loop->desc.const_iter)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Loop iterates constant times\\n\");\n+      return;\n+    }\n+\n+  /* Do not simply peel loops with branches inside -- it increases number\n+     of mispredicts.  */\n+  if (loop->desc.n_branches > 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not peeling, contains branches\\n\");\n+      return;\n+    }\n+\n+  if (loop->header->count)\n+    {\n+      unsigned niter = expected_loop_iterations (loop);\n+      if (niter + 1 > npeel)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    {\n+\t      fprintf (rtl_dump_file, \";; Not peeling loop, rolls too much (\");\n+\t      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) (niter + 1));\n+\t      fprintf (rtl_dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n+\t    }\n+\t  return;\n+\t}\n+      npeel = niter + 1;\n+    }\n+  else\n+    {\n+      /* For now we have no good heuristics to decide whether loop peeling\n+         will be effective, so disable it.  */\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \";; Not peeling loop, no evidence it will be profitable\\n\");\n+      return;\n+    }\n+\n+  /* Success.  */\n+  loop->lpt_decision.decision = LPT_PEEL_SIMPLE;\n+  loop->lpt_decision.times = npeel;\n+}\n+\n+/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:\n+   while (cond)\n+     body;\n+\n+   ==>\n+\n+   if (!cond) goto end;\n+   body;\n+   if (!cond) goto end;\n+   body;\n+   while (cond)\n+     body;\n+   end: ;\n+   */\n+static void\n+peel_loop_simple (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  sbitmap wont_exit;\n+  unsigned npeel = loop->lpt_decision.times;\n+\n+  wont_exit = sbitmap_alloc (npeel + 1);\n+  sbitmap_zero (wont_exit);\n+\n+  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+  \n+  free (wont_exit);\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Peeling loop %d times\\n\", npeel);\n+}\n+\n+/* Decide whether to unroll LOOP stupidly and how much.  */\n+static void\n+decide_unroll_stupid (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags;\n+{\n+  unsigned nunroll, nunroll_by_av, i;\n+\n+  if (!(flags & UAP_UNROLL_ALL))\n+    {\n+      /* We were not asked to, just return back silently.  */\n+      return;\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Considering unrolling loop stupidly\\n\");\n+\n+  /* nunroll = total number of copies of the original loop body in\n+     unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n+  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n+  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  if (nunroll > nunroll_by_av)\n+    nunroll = nunroll_by_av;\n+  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n+    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+\n+  /* Skip big loops.  */\n+  if (nunroll <= 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      return;\n+    }\n+\n+  /* Check for simple loops.  */\n+  if (!loop->has_desc)\n+    loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+\n+  /* Check simpleness.  */\n+  if (loop->simple)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; The loop is simple\\n\");\n+      return;\n+    }\n+\n+  /* Do not unroll loops with branches inside -- it increases number\n+     of mispredicts.  */\n+  if (loop->desc.n_branches > 1)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unrolling, contains branches\\n\");\n+      return;\n+    }\n+\n+  /* If we have profile feedback, check whether the loop rolls.  */\n+  if (loop->header->count && expected_loop_iterations (loop) < 2 * nunroll)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      return;\n+    }\n+\n+  /* Success.  Now force nunroll to be power of 2, as it seems that this\n+     improves results (partially because of better aligments, partially\n+     because of some dark magic).  */\n+  for (i = 1; 2 * i <= nunroll; i *= 2);\n+\n+  loop->lpt_decision.decision = LPT_UNROLL_STUPID;\n+  loop->lpt_decision.times = i - 1;\n+}\n+\n+/* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:\n+   while (cond)\n+     body;\n+\n+   ==>\n+\n+   while (cond)\n+     {\n+       body;\n+       if (!cond) break;\n+       body;\n+       if (!cond) break;\n+       body;\n+       if (!cond) break;\n+       body;\n+     }\n+   */\n+static void\n+unroll_loop_stupid (loops, loop)\n+     struct loops *loops;\n+     struct loop *loop;\n+{\n+  sbitmap wont_exit;\n+  unsigned nunroll = loop->lpt_decision.times;\n+\n+  wont_exit = sbitmap_alloc (nunroll + 1);\n+  sbitmap_zero (wont_exit);\n+\n+  if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n+\t\tloops, nunroll, wont_exit, NULL, NULL, NULL,\n+\t\tDLTHE_FLAG_UPDATE_FREQ))\n+    abort ();\n+\n+  free (wont_exit);\n+  \n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \";; Unrolled loop %d times, %i insns\\n\",\n+\t     nunroll, num_loop_insns (loop));\n+}"}]}