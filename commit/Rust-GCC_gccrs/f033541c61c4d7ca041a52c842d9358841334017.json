{"sha": "f033541c61c4d7ca041a52c842d9358841334017", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzMzU0MWM2MWM0ZDdjYTA0MWE1MmM4NDJkOTM1ODg0MTMzNDAxNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-17T18:16:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-17T18:16:39Z"}, "message": "rx: Rewrite the bit manipulation patterns.\n\nThe patterns represented with ashift 1 canonically need to have\nthe ashift as the first operand of the logical operation.\n\nLeave insv represented as a zero_extract store.\nImplement a variable store to a 1 bit field as tst+bmne.\nImplement a variable store of a condition into a 1 bit field with bmcc.\n\nFrom-SVN: r168927", "tree": {"sha": "978d9ea1e829fea72f365f6ce5fa549a48d98f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/978d9ea1e829fea72f365f6ce5fa549a48d98f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f033541c61c4d7ca041a52c842d9358841334017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f033541c61c4d7ca041a52c842d9358841334017", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f033541c61c4d7ca041a52c842d9358841334017", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f033541c61c4d7ca041a52c842d9358841334017/comments", "author": null, "committer": null, "parents": [{"sha": "34fee389ffbd4e8e5a262027b253ca09a54e0578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fee389ffbd4e8e5a262027b253ca09a54e0578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34fee389ffbd4e8e5a262027b253ca09a54e0578"}], "stats": {"total": 264, "additions": 176, "deletions": 88}, "files": [{"sha": "4b6aa41acd784a7084400bd5feedfd785ff35a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f033541c61c4d7ca041a52c842d9358841334017/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f033541c61c4d7ca041a52c842d9358841334017/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f033541c61c4d7ca041a52c842d9358841334017", "patch": "@@ -1,5 +1,15 @@\n 2011-01-17  Richard Henderson  <rth@redhat.com>\n \n+\t* config/rx/predicates.md (rshift_operator): New.\n+\t* config/rx/rx.c (rx_expand_insv): Remove.\n+\t* config/rx/rx-protos.h: Update.\n+\t* config/rx/rx.md (*bitset): Rename from bitset.  Swap the ashift\n+\toperand to the canonical position.\n+\t(*bitset_in_memory, *bitinvert, *bitinvert_in_memory): Similarly.\n+\t(*bitclr, *bitclr_in_memory): Similarly.\n+\t(*insv_imm, rx_insv_reg, *insv_cond, *bmcc, *insv_cond_lt): New.\n+\t(insv): Retain the zero_extract in the expansion.\n+\n \t* config/rx/rx.md (bswapsi2): Use = not + for output reload.\n \t(bswaphi2, bitinvert, revw): Likewise.\n "}, {"sha": "5ae5d2220e0c6a6420a2dbf4f9f2d450694b9024", "filename": "gcc/config/rx/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=f033541c61c4d7ca041a52c842d9358841334017", "patch": "@@ -310,3 +310,7 @@\n (define_predicate \"rx_fp_comparison_operator\"\n   (match_code \"eq,ne,lt,ge,ordered,unordered,uneq,unlt,unge,ltgt\")\n )\n+\n+(define_predicate \"rshift_operator\"\n+  (match_code \"ashiftrt,lshiftrt\")\n+)"}, {"sha": "3c3f2d471247a6594cb78098b676feff4546e6ea", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=f033541c61c4d7ca041a52c842d9358841334017", "patch": "@@ -33,7 +33,6 @@ extern int\t\trx_initial_elimination_offset (int, int);\n extern void             rx_emit_stack_popm (rtx *, bool);\n extern void             rx_emit_stack_pushm (rtx *);\n extern void\t\trx_expand_epilogue (bool);\n-extern bool\t\trx_expand_insv (rtx *);\n extern char *\t\trx_gen_move_template (rtx *, bool);\n extern bool\t\trx_is_legitimate_constant (rtx);\n extern bool \t\trx_is_mode_dependent_addr (rtx);"}, {"sha": "8cc46e7af68caeae4e3508c29d4bcc8af8c1dbd4", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=f033541c61c4d7ca041a52c842d9358841334017", "patch": "@@ -2339,48 +2339,6 @@ rx_is_ms_bitfield_layout (const_tree record_type ATTRIBUTE_UNUSED)\n   /* The packed attribute overrides the MS behaviour.  */\n   return ! TYPE_PACKED (record_type);\n }\n-\n-/* Try to generate code for the \"isnv\" pattern which inserts bits\n-   into a word.\n-     operands[0] => Location to be altered.\n-     operands[1] => Number of bits to change.\n-     operands[2] => Starting bit.\n-     operands[3] => Value to insert.\n-   Returns TRUE if successful, FALSE otherwise.  */\n-\n-bool\n-rx_expand_insv (rtx * operands)\n-{\n-  if (INTVAL (operands[1]) != 1\n-      || ! CONST_INT_P (operands[3]))\n-    return false;\n-\n-  if (MEM_P (operands[0])\n-      && INTVAL (operands[2]) > 7)\n-    return false;\n-\n-  switch (INTVAL (operands[3]))\n-    {\n-    case 0:\n-      if (MEM_P (operands[0]))\n-\temit_insn (gen_bitclr_in_memory (operands[0], operands[0],\n-\t\t\t\t\t operands[2]));\n-      else\n-\temit_insn (gen_bitclr (operands[0], operands[0], operands[2]));\n-      break;\n-    case 1:\n-    case -1:\n-      if (MEM_P (operands[0]))\n-\temit_insn (gen_bitset_in_memory (operands[0], operands[0],\n-\t\t\t\t\t operands[2]));\n-      else\n-\temit_insn (gen_bitset (operands[0], operands[0], operands[2]));\n-      break;\n-   default:\n-      return false;\n-    }\n-  return true;\n-}\n \f\n /* Returns true if X a legitimate constant for an immediate\n    operand on the RX.  X is already known to satisfy CONSTANT_P.  */"}, {"sha": "7fa8668e46c8ebdc369ff8f8634dc9b6f08f2bb5", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 162, "deletions": 45, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f033541c61c4d7ca041a52c842d9358841334017/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=f033541c61c4d7ca041a52c842d9358841334017", "patch": "@@ -1518,91 +1518,208 @@\n )\n \f\n ;; Bit manipulation instructions.\n-;; Note - there are two versions of each pattern because the memory\n-;; accessing versions use QImode whilst the register accessing\n-;; versions use SImode.\n-;; The peephole are here because the combiner only looks at a maximum\n-;; of three instructions at a time.\n \n-(define_insn \"bitset\"\n+;; ??? The *_in_memory patterns will not be matched without further help.\n+;; At one time we had the insv expander generate them, but I suspect that\n+;; in general we get better performance by exposing the register load to\n+;; the optimizers.\n+;;\n+;; An alternate solution would be to re-organize these patterns such\n+;; that allow both register and memory operands.  This would allow the\n+;; register allocator to spill and not load the register operand.  This\n+;; would be possible only for operations for which we have a constant\n+;; bit offset, so that we can adjust the address by ofs/8 and replace\n+;; the offset in the insn by ofs%8.\n+\n+(define_insn \"*bitset\"\n   [(set (match_operand:SI                    0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI            1 \"register_operand\" \"0\")\n-\t\t(ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"ri\"))))]\n+\t(ior:SI (ashift:SI (const_int 1)\n+\t\t\t   (match_operand:SI 1 \"rx_shift_operand\" \"ri\"))\n+\t\t(match_operand:SI            2 \"register_operand\" \"0\")))]\n   \"\"\n-  \"bset\\t%2, %0\"\n+  \"bset\\t%1, %0\"\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"bitset_in_memory\"\n-  [(set (match_operand:QI                    0 \"memory_operand\" \"=m\")\n-\t(ior:QI (match_operand:QI            1 \"memory_operand\" \"0\")\n-\t\t(ashift:QI (const_int 1)\n-\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"ri\"))))]\n+(define_insn \"*bitset_in_memory\"\n+  [(set (match_operand:QI                    0 \"memory_operand\" \"+Q\")\n+\t(ior:QI (ashift:QI (const_int 1)\n+\t\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"ri\"))\n+\t\t(match_dup 0)))]\n   \"\"\n-  \"bset\\t%2, %0.B\"\n+  \"bset\\t%1, %0.B\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"timings\" \"34\")]\n )\n \n (define_insn \"*bitinvert\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t(ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"ri\"))))]\n+\t(xor:SI (ashift:SI (const_int 1)\n+\t\t\t   (match_operand:SI 1 \"rx_shift_operand\" \"ri\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n   \"\"\n-  \"bnot\\t%2, %0\"\n+  \"bnot\\t%1, %0\"\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"bitinvert_in_memory\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"+m\")\n-\t(xor:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t(ashift:QI (const_int 1)\n-\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"ri\"))))]\n+(define_insn \"*bitinvert_in_memory\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"+Q\")\n+\t(xor:QI (ashift:QI (const_int 1)\n+\t\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"ri\"))\n+\t\t(match_dup 0)))]\n   \"\"\n-  \"bnot\\t%2, %0.B\"\n+  \"bnot\\t%1, %0.B\"\n   [(set_attr \"length\" \"5\")\n    (set_attr \"timings\" \"33\")]\n )\n \n-(define_insn \"bitclr\"\n+(define_insn \"*bitclr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t(not:SI\n+\t(and:SI (not:SI\n \t\t  (ashift:SI\n \t\t    (const_int 1)\n-\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))))]\n+\t\t    (match_operand:SI 1 \"rx_shift_operand\" \"ri\")))\n+\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n   \"\"\n-  \"bclr\\t%2, %0\"\n+  \"bclr\\t%1, %0\"\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"bitclr_in_memory\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-\t(and:QI (match_operand:QI 1 \"memory_operand\" \"0\")\n-\t\t(not:QI\n+(define_insn \"*bitclr_in_memory\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"+Q\")\n+\t(and:QI (not:QI\n \t\t  (ashift:QI\n \t\t    (const_int 1)\n-\t\t    (match_operand:QI 2 \"nonmemory_operand\" \"ri\")))))]\n+\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"ri\")))\n+\t\t(match_dup 0)))]\n   \"\"\n-  \"bclr\\t%2, %0.B\"\n+  \"bclr\\t%1, %0.B\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"timings\" \"34\")]\n )\n \n+(define_insn \"*insv_imm\"\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t  (const_int 1)\n+\t  (match_operand:SI 1 \"rx_shift_operand\" \"ri\"))\n+\t(match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  if (INTVAL (operands[2]) & 1)\n+    return \"bset\\t%1, %0\";\n+  else\n+    return \"bclr\\t%1, %0\";\n+}\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn_and_split \"rx_insv_reg\"\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t  (const_int 1)\n+\t  (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 2 \"register_operand\" \"r\"))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))\n+\t(match_dup 3))]\n+{\n+  rtx flags, x;\n+\n+  /* Emit tst #1, op2.  */\n+  flags = gen_rtx_REG (CC_ZSmode, CC_REG);\n+  x = gen_rtx_AND (SImode, operands[2], const1_rtx);\n+  x = gen_rtx_COMPARE (CC_ZSmode, x, const0_rtx);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  /* Emit bmne.  */\n+  operands[3] = gen_rtx_NE (SImode, flags, const0_rtx);\n+})\n+\n+(define_insn_and_split \"*insv_cond\"\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t  (const_int 1)\n+\t  (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t(match_operator:SI 4 \"comparison_operator\"\n+\t  [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t   (match_operand:SI 3 \"rx_source_operand\" \"riQ\")]))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))\n+\t(match_dup 4))]\n+{\n+  rtx flags, x;\n+\n+  flags = gen_rtx_REG (CCmode, CC_REG);\n+  x = gen_rtx_COMPARE (CCmode, operands[2], operands[3]);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n+\t\t\t        flags, const0_rtx);\n+})\n+\n+(define_insn \"*bmcc\"\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t  (const_int 1)\n+\t  (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t(match_operator:SI 2 \"comparison_operator\"\n+\t  [(reg CC_REG) (const_int 0)]))]\n+  \"reload_completed\"\n+  \"bm%B2\\t%1, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Work around the fact that X=Y<0 is preferentially expanded as a shift.\n+(define_insn_and_split \"*insv_cond_lt\"\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t  (const_int 1)\n+\t  (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t(match_operator:SI 3 \"rshift_operator\"\n+\t  [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t   (const_int 31)]))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))\n+\t\t   (lt:SI (match_dup 2) (const_int 0)))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"\"\n+)\n+\n (define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\") ;; Destination\n-\t\t         (match_operand    1 \"immediate_operand\")    ;; # of bits to set\n-\t\t\t (match_operand    2 \"immediate_operand\"))   ;; Starting bit\n-\t(match_operand\t              3 \"immediate_operand\"))]       ;; Bits to insert\n+  [(set (zero_extract:SI\n+\t  (match_operand:SI 0 \"register_operand\")\t;; Destination\n+\t  (match_operand:SI 1 \"const_int_operand\")\t;; # of bits to set\n+\t  (match_operand:SI 2 \"nonmemory_operand\"))\t;; Starting bit\n+\t(match_operand:SI   3 \"nonmemory_operand\"))]\t;; Bits to insert\n   \"\"\n-  {\n-    if (rx_expand_insv (operands))\n+{\n+  /* We only handle single-bit inserts.  */\n+  if (!CONST_INT_P (operands[1]) || INTVAL (operands[1]) != 1)\n+    FAIL;\n+\n+  /* Either the bit to insert or the position must be constant.  */\n+  if (CONST_INT_P (operands[3]))\n+    operands[3] = GEN_INT (INTVAL (operands[3]) & 1);\n+  else if (CONST_INT_P (operands[2]))\n+    {\n+      emit_insn (gen_rx_insv_reg (operands[0], operands[2], operands[3]));\n       DONE;\n+    }\n+  else\n     FAIL;\n-  }\n-)\n+})\n \f\n ;; Atomic exchange operation.\n "}]}