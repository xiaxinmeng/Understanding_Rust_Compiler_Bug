{"sha": "de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUzNDFiZjBmYmZkZGVjOGE3YzA3MTFhYzU1MDNhNTVmN2FhZjZkYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-03-08T09:23:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-03-08T09:23:44Z"}, "message": "re PR tree-optimization/84746 (ICE on valid code at -O2 and -O3: Segmentation fault)\n\n2018-03-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/84746\n\t* tree-ssa-pre.c (find_leader_in_sets): Deal with SET1 being NULL.\n\t(phi_translate): Pass in destination ANTIC_OUT set.\n\t(phi_translate_1): Likewise.  For a simplified result lookup\n\ta leader in ANTIC_OUT and AVAIL_OUT, not the ANTIC_IN sets.\n\t(phi_translate_set): Adjust.\n\t(do_pre_regular_insertion): Likewise.\n\t(do_pre_partial_partial_insertion): Likewise.\n\n\t* gcc.dg/torture/pr84746.c: New testcase.\n\nFrom-SVN: r258361", "tree": {"sha": "4ff2849537a8e91e26e15bbc14b98adf5171ab96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ff2849537a8e91e26e15bbc14b98adf5171ab96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5223e95ac279580bc9df57bd51c9badb3f98795a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5223e95ac279580bc9df57bd51c9badb3f98795a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5223e95ac279580bc9df57bd51c9badb3f98795a"}], "stats": {"total": 79, "additions": 65, "deletions": 14}, "files": [{"sha": "380b023270e54af9ea39f7fbba142b02f110d248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "patch": "@@ -1,3 +1,14 @@\n+2018-03-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84746\n+\t* tree-ssa-pre.c (find_leader_in_sets): Deal with SET1 being NULL.\n+\t(phi_translate): Pass in destination ANTIC_OUT set.\n+\t(phi_translate_1): Likewise.  For a simplified result lookup\n+\ta leader in ANTIC_OUT and AVAIL_OUT, not the ANTIC_IN sets.\n+\t(phi_translate_set): Adjust.\n+\t(do_pre_regular_insertion): Likewise.\n+\t(do_pre_partial_partial_insertion): Likewise.\n+\n 2018-03-08  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/84735"}, {"sha": "4d3535d9633d3b95fb28bdcc80a9ea84123803f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "patch": "@@ -1,3 +1,8 @@\n+2018-03-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84746\n+\t* gcc.dg/torture/pr84746.c: New testcase.\n+\n 2018-03-08  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/84404"}, {"sha": "5c00a91874fa9d6a10406f456bc3dbfb3b4e16f9", "filename": "gcc/testsuite/gcc.dg/torture/pr84746.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84746.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84746.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84746.c?ref=de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+int a, b, c, d, e;\n+char f, g;\n+\n+void fn1 ()\n+{\n+  while (1)\n+    {\n+      if (d)\n+\tgoto L1;\n+      if (e)\n+\tgoto L3;\n+      int q = (c && a) % (f * (d || a)) && b;\n+      e = q;\n+      if (b)\n+\tbreak;\n+L1:\n+L2:\n+      c = f;\n+L3:\n+      f = g;\n+      while (a)\n+\tgoto L2;\n+    }\n+}"}, {"sha": "f165a1eb9759a69074c46711abd9aefb40696215", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=de341bf0fbfddec8a7c0711ac5503a55f7aaf6dc", "patch": "@@ -1226,9 +1226,10 @@ static inline pre_expr\n find_leader_in_sets (unsigned int val, bitmap_set_t set1, bitmap_set_t set2,\n \t\t     bitmap_set_t set3 = NULL)\n {\n-  pre_expr result;\n+  pre_expr result = NULL;\n \n-  result = bitmap_find_leader (set1, val);\n+  if (set1)\n+    result = bitmap_find_leader (set1, val);\n   if (!result && set2)\n     result = bitmap_find_leader (set2, val);\n   if (!result && set3)\n@@ -1332,14 +1333,15 @@ get_representative_for (const pre_expr e, basic_block b = NULL)\n \n \n static pre_expr\n-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e);\n+phi_translate (bitmap_set_t, pre_expr, bitmap_set_t, bitmap_set_t, edge);\n \n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each part\n    of the translated expression.  */\n \n static pre_expr\n-phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n+phi_translate_1 (bitmap_set_t dest,\n+\t\t pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n   basic_block pred = e->src;\n   basic_block phiblock = e->dest;\n@@ -1363,10 +1365,11 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n                 pre_expr leader, result;\n \t\tunsigned int op_val_id = VN_INFO (newnary->op[i])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\tresult = phi_translate (leader, set1, set2, e);\n+\t\tresult = phi_translate (dest, leader, set1, set2, e);\n \t\tif (result && result != leader)\n-\t\t  /* Force a leader as well as we are simplifying this\n-\t\t     expression.  */\n+\t\t  /* If op has a leader in the sets we translate make\n+\t\t     sure to use the value of the translated expression.\n+\t\t     We might need a new representative for that.  */\n \t\t  newnary->op[i] = get_representative_for (result, pred);\n \t\telse if (!result)\n \t\t  return NULL;\n@@ -1399,7 +1402,12 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n \t\t    else\n \t\t      {\n \t\t\tunsigned value_id = get_expr_value_id (constant);\n-\t\t\tconstant = find_leader_in_sets (value_id, set1, set2,\n+\t\t\t/* We want a leader in ANTIC_OUT or AVAIL_OUT here.\n+\t\t\t   dest has what we computed into ANTIC_OUT sofar\n+\t\t\t   so pick from that - since topological sorting\n+\t\t\t   by sorted_array_from_bitmap_set isn't perfect\n+\t\t\t   we may lose some cases here.  */\n+\t\t\tconstant = find_leader_in_sets (value_id, dest,\n \t\t\t\t\t\t\tAVAIL_OUT (pred));\n \t\t\tif (constant)\n \t\t\t  return constant;\n@@ -1485,7 +1493,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n \t\t  }\n \t\top_val_id = VN_INFO (op[n])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\topresult = phi_translate (leader, set1, set2, e);\n+\t\topresult = phi_translate (dest, leader, set1, set2, e);\n \t\tif (opresult && opresult != leader)\n \t\t  {\n \t\t    tree name = get_representative_for (opresult);\n@@ -1635,7 +1643,8 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n /* Wrapper around phi_translate_1 providing caching functionality.  */\n \n static pre_expr\n-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n+phi_translate (bitmap_set_t dest, pre_expr expr,\n+\t       bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n   expr_pred_trans_t slot = NULL;\n   pre_expr phitrans;\n@@ -1661,7 +1670,7 @@ phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n     }\n \n   /* Translate.  */\n-  phitrans = phi_translate_1 (expr, set1, set2, e);\n+  phitrans = phi_translate_1 (dest, expr, set1, set2, e);\n \n   if (slot)\n     {\n@@ -1698,7 +1707,7 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, edge e)\n   FOR_EACH_VEC_ELT (exprs, i, expr)\n     {\n       pre_expr translated;\n-      translated = phi_translate (expr, set, NULL, e);\n+      translated = phi_translate (dest, expr, set, NULL, e);\n       if (!translated)\n \tcontinue;\n \n@@ -3199,7 +3208,7 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n \t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n \t      /* We are looking at ANTIC_OUT of bprime.  */\n-\t      eprime = phi_translate (expr, ANTIC_IN (block), NULL, pred);\n+\t      eprime = phi_translate (NULL, expr, ANTIC_IN (block), NULL, pred);\n \n \t      /* eprime will generally only be NULL if the\n \t\t value of the expression, translated\n@@ -3354,7 +3363,7 @@ do_pre_partial_partial_insertion (basic_block block, basic_block dom)\n \t         and so not come across fake pred edges.  */\n \t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n-\t      eprime = phi_translate (expr, ANTIC_IN (block),\n+\t      eprime = phi_translate (NULL, expr, ANTIC_IN (block),\n \t\t\t\t      PA_IN (block), pred);\n \n \t      /* eprime will generally only be NULL if the"}]}