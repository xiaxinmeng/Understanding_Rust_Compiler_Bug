{"sha": "73bb8fe9e915cf3219f16afdc61c308c08aa7659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNiYjhmZTllOTE1Y2YzMjE5ZjE2YWZkYzYxYzMwOGMwOGFhNzY1OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-01T08:57:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-01T08:57:59Z"}, "message": "Use alternative_mask for add_insn_allocno_copies\n\nadd_insn_allocno_copies and its subroutines used HARD_REG_SET to\nrepresent a bitmask of alternatives.  There's not really any connection\nbetween the number of registers and the maximum number of alternatives,\nso this patch uses alternative_mask instead (which wasn't around when\nthis code was added).\n\nThis is just a minor clean-up making way for later patches.\n\n2019-07-01  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* ira-int.h (ira_setup_alts, ira_get_dup_out_num): Use\n\talternative_mask instead of HARD_REG_SET to represent a\n\tbitmask of alternatives.\n\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n\t* ira-conflicts.c (add_insn_allocno_copies): Likewise.\n\nFrom-SVN: r272847", "tree": {"sha": "3a497a04ea90a9a9c47a00635c78894df955213f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a497a04ea90a9a9c47a00635c78894df955213f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73bb8fe9e915cf3219f16afdc61c308c08aa7659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bb8fe9e915cf3219f16afdc61c308c08aa7659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73bb8fe9e915cf3219f16afdc61c308c08aa7659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bb8fe9e915cf3219f16afdc61c308c08aa7659/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c53930bb4e409a256b9887640d7cd217d0e01b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53930bb4e409a256b9887640d7cd217d0e01b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53930bb4e409a256b9887640d7cd217d0e01b07"}], "stats": {"total": 39, "additions": 25, "deletions": 14}, "files": [{"sha": "9b57385f5c08bc45179faf8a4c9e3b96cf718a6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73bb8fe9e915cf3219f16afdc61c308c08aa7659", "patch": "@@ -1,3 +1,11 @@\n+2019-07-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* ira-int.h (ira_setup_alts, ira_get_dup_out_num): Use\n+\talternative_mask instead of HARD_REG_SET to represent a\n+\tbitmask of alternatives.\n+\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n+\t* ira-conflicts.c (add_insn_allocno_copies): Likewise.\n+\n 2019-07-01  Martin Liska  <mliska@suse.cz>\n \n \t* edit-context.c (test_applying_fixits_unreadable_file): Do not"}, {"sha": "813a6d4103c35ac6b5d031f052f1bbcfbca3949d", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=73bb8fe9e915cf3219f16afdc61c308c08aa7659", "patch": "@@ -358,7 +358,7 @@ add_insn_allocno_copies (rtx_insn *insn)\n   rtx set, operand, dup;\n   bool bound_p[MAX_RECOG_OPERANDS];\n   int i, n, freq;\n-  HARD_REG_SET alts;\n+  alternative_mask alts;\n \n   freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n   if (freq == 0)\n@@ -379,7 +379,7 @@ add_insn_allocno_copies (rtx_insn *insn)\n      there are no dead registers, there will be no such copies.  */\n   if (! find_reg_note (insn, REG_DEAD, NULL_RTX))\n     return;\n-  ira_setup_alts (insn, alts);\n+  alts = ira_setup_alts (insn);\n   for (i = 0; i < recog_data.n_operands; i++)\n     bound_p[i] = false;\n   for (i = 0; i < recog_data.n_operands; i++)"}, {"sha": "1ea35f7e364f14c425ceb7752a3e4a53a354a641", "filename": "gcc/ira-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=73bb8fe9e915cf3219f16afdc61c308c08aa7659", "patch": "@@ -963,8 +963,8 @@ extern void ira_print_disposition (FILE *);\n extern void ira_debug_disposition (void);\n extern void ira_debug_allocno_classes (void);\n extern void ira_init_register_move_cost (machine_mode);\n-extern void ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts);\n-extern int ira_get_dup_out_num (int op_num, HARD_REG_SET &alts);\n+extern alternative_mask ira_setup_alts (rtx_insn *);\n+extern int ira_get_dup_out_num (int, alternative_mask);\n \n /* ira-build.c */\n "}, {"sha": "808f02bfbd0af19690fb903de6c5bec90ad0381f", "filename": "gcc/ira.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bb8fe9e915cf3219f16afdc61c308c08aa7659/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=73bb8fe9e915cf3219f16afdc61c308c08aa7659", "patch": "@@ -1784,9 +1784,12 @@ setup_prohibited_mode_move_regs (void)\n \n \f\n \n-/* Setup possible alternatives in ALTS for INSN.  */\n-void\n-ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n+/* Extract INSN and return the set of alternatives that we should consider.\n+   This excludes any alternatives whose constraints are obviously impossible\n+   to meet (e.g. because the constraint requires a constant and the operand\n+   is nonconstant).  */\n+alternative_mask\n+ira_setup_alts (rtx_insn *insn)\n {\n   /* MAP nalt * nop -> start of constraints for given operand and\n      alternative.  */\n@@ -1798,7 +1801,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \n   extract_insn (insn);\n   alternative_mask preferred = get_preferred_alternatives (insn);\n-  CLEAR_HARD_REG_SET (alts);\n+  alternative_mask alts = 0;\n   insn_constraints.release ();\n   insn_constraints.safe_grow_cleared (recog_data.n_operands\n \t\t\t\t      * recog_data.n_alternatives + 1);\n@@ -1833,8 +1836,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \t}\n       for (nalt = 0; nalt < recog_data.n_alternatives; nalt++)\n \t{\n-\t  if (!TEST_BIT (preferred, nalt)\n-\t      || TEST_HARD_REG_BIT (alts, nalt))\n+\t  if (!TEST_BIT (preferred, nalt) || TEST_BIT (alts, nalt))\n \t    continue;\n \n \t  for (nop = 0; nop < recog_data.n_operands; nop++)\n@@ -1906,7 +1908,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \t      ;\n \t    }\n \t  if (nop >= recog_data.n_operands)\n-\t    SET_HARD_REG_BIT (alts, nalt);\n+\t    alts |= ALTERNATIVE_BIT (nalt);\n \t}\n       if (commutative < 0)\n \tbreak;\n@@ -1916,14 +1918,15 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n       if (curr_swapped)\n \tbreak;\n     }\n+  return alts;\n }\n \n /* Return the number of the output non-early clobber operand which\n    should be the same in any case as operand with number OP_NUM (or\n    negative value if there is no such operand).  The function takes\n    only really possible alternatives into consideration.  */\n int\n-ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n+ira_get_dup_out_num (int op_num, alternative_mask alts)\n {\n   int curr_alt, c, original, dup;\n   bool ignore_p, use_commut_op_p;\n@@ -1940,7 +1943,7 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n     {\n       rtx op = recog_data.operand[op_num];\n       \n-      for (curr_alt = 0, ignore_p = !TEST_HARD_REG_BIT (alts, curr_alt),\n+      for (curr_alt = 0, ignore_p = !TEST_BIT (alts, curr_alt),\n \t   original = -1;;)\n \t{\n \t  c = *str;\n@@ -1951,7 +1954,7 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n \t  else if (c == ',')\n \t    {\n \t      curr_alt++;\n-\t      ignore_p = !TEST_HARD_REG_BIT (alts, curr_alt);\n+\t      ignore_p = !TEST_BIT (alts, curr_alt);\n \t    }\n \t  else if (! ignore_p)\n \t    switch (c)"}]}