{"sha": "2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4ZWUwYTM2NGFjN2RjOTk1OWIxY2FhYzdkNzE0NWFmZWRkMWVhYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-21T15:22:53Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:50Z"}, "message": "[Ada] Eliminate useless 128-bit overflow check for conversion\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference)\n\t<Attribute_Max_Size_In_Storage_Elements>: Apply the checks for\n\tuniversal integer contexts only in the default case.\n\t* exp_ch4.adb (Get_Size_For_Range): Move to library level.\n\t(Expand_N_Type_Conversion): If the operand has Universal_Integer\n\ttype and the conversion requires an overflow check, try to do an\n\tintermediate conversion to a narrower type.", "tree": {"sha": "3b573c52b620c5a54080e94a2a9f30feadfcdecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b573c52b620c5a54080e94a2a9f30feadfcdecf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d099fc2e643d6e0228864b5858223e55c8092d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d099fc2e643d6e0228864b5858223e55c8092d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d099fc2e643d6e0228864b5858223e55c8092d7c"}], "stats": {"total": 190, "additions": 99, "deletions": 91}, "files": [{"sha": "25bf0f76f2602fce96bc71498c2c44bb832958cf", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "patch": "@@ -4598,13 +4598,7 @@ package body Exp_Attr is\n       ----------------------------------\n \n       when Attribute_Max_Size_In_Storage_Elements => declare\n-         Typ  : constant Entity_Id := Etype (N);\n-         Attr : Node_Id;\n-         Atyp : Entity_Id;\n-\n-         Conversion_Added : Boolean := False;\n-         --  A flag which tracks whether the original attribute has been\n-         --  wrapped inside a type conversion.\n+         Typ : constant Entity_Id := Etype (N);\n \n       begin\n          --  If the prefix is X'Class, we transform it into a direct reference\n@@ -4618,40 +4612,22 @@ package body Exp_Attr is\n             return;\n          end if;\n \n-         Apply_Universal_Integer_Attribute_Checks (N);\n-\n-         --  The universal integer check may sometimes add a type conversion,\n-         --  retrieve the original attribute reference from the expression.\n-\n-         Attr := N;\n-\n-         if Nkind (Attr) = N_Type_Conversion then\n-            Attr := Expression (Attr);\n-            Conversion_Added := True;\n-         end if;\n-\n-         pragma Assert (Nkind (Attr) = N_Attribute_Reference);\n-\n          --  Heap-allocated controlled objects contain two extra pointers which\n          --  are not part of the actual type. Transform the attribute reference\n          --  into a runtime expression to add the size of the hidden header.\n \n-         if Needs_Finalization (Ptyp)\n-           and then not Header_Size_Added (Attr)\n-         then\n-            Set_Header_Size_Added (Attr);\n-\n-            Atyp := Etype (Attr);\n+         if Needs_Finalization (Ptyp) and then not Header_Size_Added (N) then\n+            Set_Header_Size_Added (N);\n \n             --  Generate:\n             --    P'Max_Size_In_Storage_Elements +\n-            --      Atyp (Header_Size_With_Padding (Ptyp'Alignment))\n+            --      Typ (Header_Size_With_Padding (Ptyp'Alignment))\n \n-            Rewrite (Attr,\n+            Rewrite (N,\n               Make_Op_Add (Loc,\n-                Left_Opnd  => Relocate_Node (Attr),\n+                Left_Opnd  => Relocate_Node (N),\n                 Right_Opnd =>\n-                  Convert_To (Atyp,\n+                  Convert_To (Typ,\n                     Make_Function_Call (Loc,\n                       Name                   =>\n                         New_Occurrence_Of\n@@ -4663,16 +4639,13 @@ package body Exp_Attr is\n                             New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_Alignment))))));\n \n-            Analyze_And_Resolve (Attr, Atyp);\n-\n-            --  Add a conversion to the target type\n-\n-            if not Conversion_Added then\n-               Convert_To_And_Rewrite (Typ, Attr);\n-            end if;\n-\n+            Analyze_And_Resolve (N, Typ);\n             return;\n          end if;\n+\n+         --  In the other cases apply the required checks\n+\n+         Apply_Universal_Integer_Attribute_Checks (N);\n       end;\n \n       --------------------"}, {"sha": "143cce137399f47edfbc59a17dc557592803b689", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 87, "deletions": 52, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2e8ee0a364ac7dc9959b1caac7d7145afedd1eaa", "patch": "@@ -172,6 +172,10 @@ package body Exp_Ch4 is\n    --  routine is to find the real type by looking up the tree. We also\n    --  determine if the operation must be rounded.\n \n+   function Get_Size_For_Range (Lo, Hi : Uint) return Uint;\n+   --  Return the size of a small signed integer type covering Lo .. Hi, the\n+   --  main goal being to return a size lower than that of standard types.\n+\n    function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n    --  discriminants if it has a constrained nominal type, unless the object\n@@ -12270,6 +12274,41 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n+      --  If the conversion is from Universal_Integer and requires an overflow\n+      --  check, try to do an intermediate conversion to a narrower type first\n+      --  without overflow check, in order to avoid doing the overflow check\n+      --  in Universal_Integer, which can be a very large type.\n+\n+      if Operand_Type = Universal_Integer and then Do_Overflow_Check (N) then\n+         declare\n+            Lo, Hi, Siz : Uint;\n+            OK          : Boolean;\n+            Typ         : Entity_Id;\n+\n+         begin\n+            Determine_Range (Operand, OK, Lo, Hi, Assume_Valid => True);\n+\n+            if OK then\n+               Siz := Get_Size_For_Range (Lo, Hi);\n+\n+               --  We use the base type instead of the first subtype because\n+               --  overflow checks are done in the base type, so this avoids\n+               --  the need for useless conversions.\n+\n+               if Siz < System_Max_Integer_Size then\n+                  Typ := Etype (Integer_Type_For (Siz, Uns => False));\n+\n+                  Convert_To_And_Rewrite (Typ, Operand);\n+                  Analyze_And_Resolve\n+                    (Operand, Typ, Suppress => Overflow_Check);\n+\n+                  Analyze_And_Resolve (N, Target_Type);\n+                  goto Done;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Do validity check if validity checking operands\n \n       if Validity_Checks_On and Validity_Check_Operands then\n@@ -13328,6 +13367,54 @@ package body Exp_Ch4 is\n       end if;\n    end Fixup_Universal_Fixed_Operation;\n \n+   ------------------------\n+   -- Get_Size_For_Range --\n+   ------------------------\n+\n+   function Get_Size_For_Range (Lo, Hi : Uint) return Uint is\n+\n+      function Is_OK_For_Range (Siz : Uint) return Boolean;\n+      --  Return True if a signed integer with given size can cover Lo .. Hi\n+\n+      --------------------------\n+      -- Is_OK_For_Range --\n+      --------------------------\n+\n+      function Is_OK_For_Range (Siz : Uint) return Boolean is\n+         B : constant Uint := Uint_2 ** (Siz - 1);\n+\n+      begin\n+         --  Test B = 2 ** (size - 1) (can accommodate -B .. +(B - 1))\n+\n+         return Lo >= -B and then Hi >= -B and then Lo < B and then Hi < B;\n+      end Is_OK_For_Range;\n+\n+   begin\n+      --  This is (almost always) the size of Integer\n+\n+      if Is_OK_For_Range (Uint_32) then\n+         return Uint_32;\n+\n+      --  Check 63\n+\n+      elsif Is_OK_For_Range (Uint_63) then\n+         return Uint_63;\n+\n+      --  This is (almost always) the size of Long_Long_Integer\n+\n+      elsif Is_OK_For_Range (Uint_64) then\n+         return Uint_64;\n+\n+      --  Check 127\n+\n+      elsif Is_OK_For_Range (Uint_127) then\n+         return Uint_127;\n+\n+      else\n+         return Uint_128;\n+      end if;\n+   end Get_Size_For_Range;\n+\n    ---------------------------------\n    -- Has_Inferable_Discriminants --\n    ---------------------------------\n@@ -14135,58 +14222,6 @@ package body Exp_Ch4 is\n       Typ    : constant Entity_Id := Etype (R);\n       Tsiz   : constant Uint      := RM_Size (Typ);\n \n-      function Get_Size_For_Range (Lo, Hi : Uint) return Uint;\n-      --  Return the size of a small signed integer type covering Lo .. Hi.\n-      --  The important thing is to return a size lower than that of Typ.\n-\n-      ------------------------\n-      -- Get_Size_For_Range --\n-      ------------------------\n-\n-      function Get_Size_For_Range (Lo, Hi : Uint) return Uint is\n-\n-         function Is_OK_For_Range (Siz : Uint) return Boolean;\n-         --  Return True if a signed integer with given size can cover Lo .. Hi\n-\n-         --------------------------\n-         -- Is_OK_For_Range --\n-         --------------------------\n-\n-         function Is_OK_For_Range (Siz : Uint) return Boolean is\n-            B : constant Uint := Uint_2 ** (Siz - 1);\n-\n-         begin\n-            --  Test B = 2 ** (size - 1) (can accommodate -B .. +(B - 1))\n-\n-            return Lo >= -B and then Hi >= -B and then Lo < B and then Hi < B;\n-         end Is_OK_For_Range;\n-\n-      begin\n-         --  This is (almost always) the size of Integer\n-\n-         if Is_OK_For_Range (Uint_32) then\n-            return Uint_32;\n-\n-         --  If the size of Typ is 64 then check 63\n-\n-         elsif Tsiz = Uint_64 and then Is_OK_For_Range (Uint_63) then\n-            return Uint_63;\n-\n-         --  This is (almost always) the size of Long_Long_Integer\n-\n-         elsif Is_OK_For_Range (Uint_64) then\n-            return Uint_64;\n-\n-         --  If the size of Typ is 128 then check 127\n-\n-         elsif Tsiz = Uint_128 and then Is_OK_For_Range (Uint_127) then\n-            return Uint_127;\n-\n-         else\n-            return Uint_128;\n-         end if;\n-      end Get_Size_For_Range;\n-\n       --  Local variables\n \n       L          : Node_Id;"}]}