{"sha": "16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhM2QxMWNjYTU4NDhmNzEwZGVkYzNhOGY4Y2VjNTM1YTFjNGI2Yw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-05-15T18:15:14Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-05-15T18:15:14Z"}, "message": "builtin-math-5.c: New.\n\n\t* gcc.dg/torture/builtin-math-5.c: New.\n\t* gcc.dg/torture/builtin-math-6.c: New.\n\t* lib/target-supports.exp (check_effective_target_mpc): New.\n\nFrom-SVN: r147593", "tree": {"sha": "039bb91f4058fe633aa4443309f1a51edba9ac5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/039bb91f4058fe633aa4443309f1a51edba9ac5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/comments", "author": null, "committer": null, "parents": [{"sha": "f9bab007121e1808d8de18564241af876ab88039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bab007121e1808d8de18564241af876ab88039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9bab007121e1808d8de18564241af876ab88039"}], "stats": {"total": 216, "additions": 216, "deletions": 0}, "files": [{"sha": "2f3cb4ec1783a66514ae9824aa06270d6a9ea508", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "patch": "@@ -1,3 +1,9 @@\n+2009-05-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-5.c: New.\n+\t* gcc.dg/torture/builtin-math-6.c: New.\n+\t* lib/target-supports.exp (check_effective_target_mpc): New.\n+\n 2009-05-15  Jan Hubicka  <jh@suse.cz>\n \n \t* testsuite/gcc.dg/tree-ssa/inline-3.c: New testcase"}, {"sha": "d266e50aff036b66b999cede02e4751d14a5de48", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-5.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-5.c?ref=16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2009  Free Software Foundation.\n+\n+   Test things that should block GCC from optimizing compile-time\n+   constants passed to a builtin complex transcendental functions.\n+\n+   Origin: Kaveh R. Ghazi,  January 28, 2009.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+extern void foof (_Complex float);\n+extern void foo (_Complex double);\n+extern void fool (_Complex long double);\n+\n+#define TESTIT(FUNC, ARG) do { \\\n+  foof (__builtin_##FUNC##f (ARG##F)); \\\n+  foo (__builtin_##FUNC (ARG)); \\\n+  fool (__builtin_##FUNC##l (ARG##L)); \\\n+} while (0)\n+\n+void bar()\n+{\n+  /* An argument of NaN is not evaluated at compile-time.  */\n+#ifndef __SPU__\n+  foof (__builtin_csqrtf (__builtin_nanf(\"\")));\n+#endif\n+  foo (__builtin_csqrt (__builtin_nan(\"\")));\n+  fool (__builtin_csqrtl (__builtin_nanl(\"\")));\n+\n+  /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n+#ifndef __SPU__\n+  foof (__builtin_csqrtf (__builtin_inff()));\n+#endif\n+  foo (__builtin_csqrt (__builtin_inf()));\n+  fool (__builtin_csqrtl (__builtin_infl()));\n+#ifndef __SPU__\n+  foof (__builtin_csqrtf (-__builtin_inff()));\n+#endif\n+  foo (__builtin_csqrt (-__builtin_inf()));\n+  fool (__builtin_csqrtl (-__builtin_infl()));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"csqrtf\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"csqrt \" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"csqrtl\" 3 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "636381f5f2ef73e45926286311eeae47e8096fb9", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-6.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-6.c?ref=16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "patch": "@@ -0,0 +1,151 @@\n+/* Copyright (C) 2009  Free Software Foundation.\n+\n+   Verify that folding of built-in complex math functions with\n+   constant arguments is correctly performed by the compiler.\n+\n+   Origin: Kaveh R. Ghazi,  January 28, 2009.  */\n+\n+/* { dg-do link } */\n+/* { dg-require-effective-target mpc } */\n+\n+/* All references to link_error should go away at compile-time.  */\n+extern void link_error(int);\n+\n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n+/* For complex numbers, test that FUNC(ARG) == (RES).  */\n+#define TESTIT_COMPLEX(FUNC, ARG, RES) do { \\\n+  if (__builtin_##FUNC##f(ARG) != (RES) \\\n+    || CKSGN_F(__real__ __builtin_##FUNC##f(ARG), __real__ (RES)) \\\n+    || CKSGN_F(__imag__ __builtin_##FUNC##f(ARG), __imag__ (RES))) \\\n+      link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG) != (RES) \\\n+    || CKSGN(__real__ __builtin_##FUNC(ARG), __real__ (RES)) \\\n+    || CKSGN(__imag__ __builtin_##FUNC(ARG), __imag__ (RES))) \\\n+      link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG) != (RES) \\\n+    || CKSGN_L(__real__ __builtin_##FUNC##l(ARG), __real__ (RES)) \\\n+    || CKSGN_L(__imag__ __builtin_##FUNC##l(ARG), __imag__ (RES))) \\\n+      link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Range test, for complex numbers check that FUNC(ARG) is within 1%\n+   of RES.  This is NOT a test for accuracy to the last-bit, we're\n+   merely checking that we get relatively sane results.  I.e. the GCC\n+   builtin is hooked up to the correct MPC function call.  We first\n+   check the magnitude and then the sign.  */\n+#define TESTIT_COMPLEX_R(FUNC, ARG, RES) do { \\\n+  if (__builtin_fabsf(__real__ __builtin_##FUNC##f(ARG)) < __builtin_fabsf(__real__ (RES)) * 0.99F \\\n+      || __builtin_fabsf(__real__ __builtin_##FUNC##f(ARG)) > __builtin_fabsf(__real__ (RES)) * 1.01F \\\n+      || __builtin_fabsf(__imag__ __builtin_##FUNC##f(ARG)) < __builtin_fabsf(__imag__ (RES)) * 0.99F \\\n+      || __builtin_fabsf(__imag__ __builtin_##FUNC##f(ARG)) > __builtin_fabsf(__imag__ (RES)) * 1.01F \\\n+      || CKSGN_F(__real__ __builtin_##FUNC##f(ARG), __real__ (RES)) \\\n+      || CKSGN_F(__imag__ __builtin_##FUNC##f(ARG), __imag__ (RES))) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_fabs(__real__ __builtin_##FUNC(ARG)) < __builtin_fabs(__real__ (RES)) * 0.99F \\\n+      || __builtin_fabs(__real__ __builtin_##FUNC(ARG)) > __builtin_fabs(__real__ (RES)) * 1.01F \\\n+      || __builtin_fabs(__imag__ __builtin_##FUNC(ARG)) < __builtin_fabs(__imag__ (RES)) * 0.99F \\\n+      || __builtin_fabs(__imag__ __builtin_##FUNC(ARG)) > __builtin_fabs(__imag__ (RES)) * 1.01F \\\n+      || CKSGN(__real__ __builtin_##FUNC(ARG), __real__ (RES)) \\\n+      || CKSGN(__imag__ __builtin_##FUNC(ARG), __imag__ (RES))) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_fabsl(__real__ __builtin_##FUNC##l(ARG)) < __builtin_fabsl(__real__ (RES)) * 0.99F \\\n+      || __builtin_fabsl(__real__ __builtin_##FUNC##l(ARG)) > __builtin_fabsl(__real__ (RES)) * 1.01F \\\n+      || __builtin_fabsl(__imag__ __builtin_##FUNC##l(ARG)) < __builtin_fabsl(__imag__ (RES)) * 0.99F \\\n+      || __builtin_fabsl(__imag__ __builtin_##FUNC##l(ARG)) > __builtin_fabsl(__imag__ (RES)) * 1.01F \\\n+      || CKSGN_L(__real__ __builtin_##FUNC##l(ARG), __real__ (RES)) \\\n+      || CKSGN_L(__imag__ __builtin_##FUNC##l(ARG), __imag__ (RES))) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+int main (void)\n+{\n+  TESTIT_COMPLEX (csin, 0.0F, 0.0F);\n+  TESTIT_COMPLEX (csin, -0.0F, -0.0F);\n+  TESTIT_COMPLEX (csin, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n+  TESTIT_COMPLEX (csin, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n+\n+  TESTIT_COMPLEX_R (csin, 3.45678F + 2.34567FI, -1.633059F - 4.917448FI);\n+  TESTIT_COMPLEX_R (csin, 3.45678F - 2.34567FI, -1.633059F + 4.917448FI);\n+  TESTIT_COMPLEX_R (csin, -3.45678F + 2.34567FI, 1.633059F - 4.917448FI);\n+  TESTIT_COMPLEX_R (csin, -3.45678F - 2.34567FI, 1.633059F + 4.917448FI);\n+  \n+  TESTIT_COMPLEX (ccos, 0.0F, __builtin_conjf(1.0F));\n+  TESTIT_COMPLEX (ccos, -0.0F, 1.0F);\n+  TESTIT_COMPLEX (ccos, __builtin_conjf(0.0F), 1.0F);\n+  TESTIT_COMPLEX (ccos, __builtin_conjf(-0.0F), __builtin_conjf(1.0F));\n+\n+  TESTIT_COMPLEX_R (ccos, 3.45678F + 2.34567FI, -5.008512F + 1.603367FI);\n+  TESTIT_COMPLEX_R (ccos, 3.45678F - 2.34567FI, -5.008512F - 1.603367FI);\n+  TESTIT_COMPLEX_R (ccos, -3.45678F + 2.34567FI, -5.008512F - 1.603367FI);\n+  TESTIT_COMPLEX_R (ccos, -3.45678F - 2.34567FI, -5.008512F + 1.603367FI);\n+\n+  TESTIT_COMPLEX (ctan, 0.0F, 0.0F);\n+  TESTIT_COMPLEX (ctan, -0.0F, -0.0F);\n+  TESTIT_COMPLEX (ctan, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n+  TESTIT_COMPLEX (ctan, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n+\n+  TESTIT_COMPLEX_R (ctan, 3.45678F + 2.34567FI, 0.010657F + 0.985230FI);\n+  TESTIT_COMPLEX_R (ctan, 3.45678F - 2.34567FI, 0.010657F - 0.985230FI);\n+  TESTIT_COMPLEX_R (ctan, -3.45678F + 2.34567FI, -0.010657F + 0.985230FI);\n+  TESTIT_COMPLEX_R (ctan, -3.45678F - 2.34567FI, -0.010657F - 0.985230FI);\n+\n+  TESTIT_COMPLEX (csinh, 0.0F, 0.0F);\n+  TESTIT_COMPLEX (csinh, -0.0F, -0.0F);\n+  TESTIT_COMPLEX (csinh, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n+  TESTIT_COMPLEX (csinh, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n+\n+  TESTIT_COMPLEX_R (csinh, 3.45678F + 2.34567FI, -11.083178F + 11.341487FI);\n+  TESTIT_COMPLEX_R (csinh, 3.45678F - 2.34567FI, -11.083178F - 11.341487FI);\n+  TESTIT_COMPLEX_R (csinh, -3.45678F + 2.34567FI, 11.083178F + 11.341487FI);\n+  TESTIT_COMPLEX_R (csinh, -3.45678F - 2.34567FI, 11.083178F - 11.341487FI);\n+\n+  TESTIT_COMPLEX (ccosh, 0.0F, 1.0F);\n+  TESTIT_COMPLEX (ccosh, -0.0F, __builtin_conjf(1.0F));\n+  TESTIT_COMPLEX (ccosh, __builtin_conjf(0.0F), __builtin_conjf(1.0F));\n+  TESTIT_COMPLEX (ccosh, __builtin_conjf(-0.0F), 1.0F);\n+\n+  TESTIT_COMPLEX_R (ccosh, 3.45678F + 2.34567FI, -11.105238F + 11.318958FI);\n+  TESTIT_COMPLEX_R (ccosh, 3.45678F - 2.34567FI, -11.105238F - 11.318958FI);\n+  TESTIT_COMPLEX_R (ccosh, -3.45678F + 2.34567FI, -11.105238F - 11.318958FI);\n+  TESTIT_COMPLEX_R (ccosh, -3.45678F - 2.34567FI, -11.105238F + 11.318958FI);\n+\n+  TESTIT_COMPLEX (ctanh, 0.0F, 0.0F);\n+  TESTIT_COMPLEX (ctanh, -0.0F, -0.0F);\n+  TESTIT_COMPLEX (ctanh, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n+  TESTIT_COMPLEX (ctanh, __builtin_conjf(-0.0F), __builtin_conjf(-0.0F));\n+\n+  TESTIT_COMPLEX_R (ctanh, 3.45678F + 2.34567FI, 1.000040F - 0.001988FI);\n+  TESTIT_COMPLEX_R (ctanh, 3.45678F - 2.34567FI, 1.000040F + 0.001988FI);\n+  TESTIT_COMPLEX_R (ctanh, -3.45678F + 2.34567FI, -1.000040F - 0.001988FI);\n+  TESTIT_COMPLEX_R (ctanh, -3.45678F - 2.34567FI, -1.000040F + 0.001988FI);\n+\n+  TESTIT_COMPLEX (clog, 1.0F, 0.0F);\n+  TESTIT_COMPLEX_R (clog, -1.0F, 3.141593FI);\n+  TESTIT_COMPLEX (clog, __builtin_conjf(1.0F), 0.0F);\n+  TESTIT_COMPLEX_R (clog, __builtin_conjf(-1.0F), 3.141593FI);\n+\n+  TESTIT_COMPLEX_R (clog, 3.45678F + 2.34567FI, 1.429713F + 0.596199FI);\n+  TESTIT_COMPLEX_R (clog, 3.45678F - 2.34567FI, 1.429713F - 0.596199FI);\n+  TESTIT_COMPLEX_R (clog, -3.45678F + 2.34567FI, 1.429713F + 2.545394FI);\n+  TESTIT_COMPLEX_R (clog, -3.45678F - 2.34567FI, 1.429713F - 2.545394FI);\n+\n+  TESTIT_COMPLEX (csqrt, 0.0F, 0.0F);\n+  TESTIT_COMPLEX (csqrt, -0.0F, 0.0F);\n+  TESTIT_COMPLEX (csqrt, __builtin_conjf(0.0F), __builtin_conjf(0.0F));\n+  TESTIT_COMPLEX (csqrt, __builtin_conjf(-0.0F), __builtin_conjf(0.0F));\n+\n+  TESTIT_COMPLEX_R (csqrt, 3.45678F + 2.34567FI, 1.953750F + 0.600299FI);\n+  TESTIT_COMPLEX_R (csqrt, 3.45678F - 2.34567FI, 1.953750F - 0.600299FI);\n+  TESTIT_COMPLEX_R (csqrt, -3.45678F + 2.34567FI, 0.600299F + 1.953750FI);\n+  TESTIT_COMPLEX_R (csqrt, -3.45678F - 2.34567FI, 0.600299F - 1.953750FI);\n+\n+  return 0;\n+}"}, {"sha": "3282d6d7b481a9f13db768a0e296d79a2a928eae", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a3d11cca5848f710dedc3a8f8cec535a1c4b6c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=16a3d11cca5848f710dedc3a8f8cec535a1c4b6c", "patch": "@@ -2930,3 +2930,16 @@ proc check_effective_target_correct_iso_cpp_string_wchar_protos { } {\n \t#endif\n     }]\n }\n+\n+# Return 1 if the MPC library is integrated with GCC, 0 otherwise.\n+\n+proc check_effective_target_mpc { } {\n+    return [check_no_compiler_messages mpc executable {\n+\textern void link_error(void);\n+\tint main ()\n+\t{\n+\t  if (__builtin_csin(0) != 0)\n+\t    link_error();\n+\t}\n+    }]\n+}"}]}