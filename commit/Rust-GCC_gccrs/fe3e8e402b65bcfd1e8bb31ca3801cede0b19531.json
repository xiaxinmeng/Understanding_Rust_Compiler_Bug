{"sha": "fe3e8e402b65bcfd1e8bb31ca3801cede0b19531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUzZThlNDAyYjY1YmNmZDFlOGJiMzFjYTM4MDFjZWRlMGIxOTUzMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-05T02:02:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-05T02:02:17Z"}, "message": "(left_shift_overflows, same_sign, overflow_sum_sign): New macros.\n\n(add_double, div_and_round_double, lshift_double, mul_double):\n(neg_double, const_binop, fold): Check for signed integer overflow.\nPropagate overflow flags from operands to result.\n(const_binop, fold_convert): Use pedwarn for overflow warnings.\nSay `constant expression', not `constant folding', for user's sake.\n\nFrom-SVN: r2053", "tree": {"sha": "2e80beab93c2f47ae23a3859ca3a1d0a81aefa33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e80beab93c2f47ae23a3859ca3a1d0a81aefa33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531/comments", "author": null, "committer": null, "parents": [{"sha": "9e9bd45dd934c75a7f0601ebd193388adca001f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9bd45dd934c75a7f0601ebd193388adca001f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9bd45dd934c75a7f0601ebd193388adca001f4"}], "stats": {"total": 169, "additions": 118, "deletions": 51}, "files": [{"sha": "cd14f75437ae740448aba565b30b548cef0e4d28", "filename": "gcc/fold-const.c", "status": "modified", "additions": 118, "deletions": 51, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe3e8e402b65bcfd1e8bb31ca3801cede0b19531/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fe3e8e402b65bcfd1e8bb31ca3801cede0b19531", "patch": "@@ -48,7 +48,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Handle floating overflow for `const_binop'.  */\n static jmp_buf float_error;\n \n-void lshift_double ();\n+int lshift_double ();\n void rshift_double ();\n void lrotate_double ();\n void rrotate_double ();\n@@ -57,6 +57,19 @@ static tree const_binop ();\n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n #endif\n+\n+/* Yield nonzero if a signed left shift of A by B bits overflows.  */\n+#define left_shift_overflows(a, b)  ((a)  !=  ((a) << (b)) >> (b))\n+\n+/* Yield nonzero if A and B have the same sign.  */\n+#define same_sign(a, b) ((a) ^ (b) >= 0)\n+\n+/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n+   Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n+   Then this yields nonzero if overflow occurred during the addition.\n+   Overflow occurs if A and B have the same sign, but A and SUM differ in sign.\n+   Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */\n+#define overflow_sum_sign(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n \f\n /* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n    We do that by representing the two-word integer as MAX_SHORTS shorts,\n@@ -161,7 +174,7 @@ force_fit_type (t)\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n-void\n+int\n add_double (l1, h1, l2, h2, lv, hv)\n      HOST_WIDE_INT l1, h1, l2, h2;\n      HOST_WIDE_INT *lv, *hv;\n@@ -182,14 +195,16 @@ add_double (l1, h1, l2, h2, lv, hv)\n     }\n \n   decode (arg1, lv, hv);\n+  return overflow_sum_sign (h1, h2, *hv);\n }\n \n /* Negate a doubleword integer with doubleword result.\n+   Return nonzero if the operation overflows, assuming it's signed.\n    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n-void\n+int\n neg_double (l1, h1, lv, hv)\n      HOST_WIDE_INT l1, h1;\n      HOST_WIDE_INT *lv, *hv;\n@@ -198,21 +213,24 @@ neg_double (l1, h1, lv, hv)\n     {\n       *lv = 0;\n       *hv = - h1;\n+      return same_sign (h1, *hv);\n     }\n   else\n     {\n       *lv = - l1;\n       *hv = ~ h1;\n+      return 0;\n     }\n }\n \f\n /* Multiply two doubleword integers with doubleword result.\n+   Return nonzero if the operation overflows, assuming it's signed.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n-void\n+int\n mul_double (l1, h1, l2, h2, lv, hv)\n      HOST_WIDE_INT l1, h1, l2, h2;\n      HOST_WIDE_INT *lv, *hv;\n@@ -222,33 +240,36 @@ mul_double (l1, h1, l2, h2, lv, hv)\n   short prod[MAX_SHORTS * 2];\n   register int carry = 0;\n   register int i, j, k;\n+  HOST_WIDE_INT toplow, tophigh, neglow, neghigh;\n \n-  /* These two cases are used extensively, arising from pointer\n-     combinations.  */\n+  /* These cases are used extensively, arising from pointer combinations.  */\n   if (h2 == 0)\n     {\n       if (l2 == 2)\n \t{\n+\t  int overflow = left_shift_overflows (h1, 1);\n \t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  *hv = h1 * 2 + (temp < l1);\n+\t  *hv = (h1 << 1) + (temp < l1);\n \t  *lv = temp;\n-\t  return;\n+\t  return overflow;\n \t}\n       if (l2 == 4)\n \t{\n+\t  int overflow = left_shift_overflows (h1, 2);\n \t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  h1 = h1 * 4 + ((temp < l1) << 1);\n+\t  h1 = (h1 << 2) + ((temp < l1) << 1);\n \t  l1 = temp;\n \t  temp += temp;\n \t  h1 += (temp < l1);\n \t  *lv = temp;\n \t  *hv = h1;\n-\t  return;\n+\t  return overflow;\n \t}\n       if (l2 == 8)\n \t{\n+\t  int overflow = left_shift_overflows (h1, 3);\n \t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  h1 = h1 * 8 + ((temp < l1) << 2);\n+\t  h1 = (h1 << 3) + ((temp < l1) << 2);\n \t  l1 = temp;\n \t  temp += temp;\n \t  h1 += (temp < l1) << 1;\n@@ -257,7 +278,7 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \t  h1 += (temp < l1);\n \t  *lv = temp;\n \t  *hv = h1;\n-\t  return;\n+\t  return overflow;\n \t}\n     }\n \n@@ -280,17 +301,33 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \t  }\n       }\n \n-  decode (prod, lv, hv);\t/* ?? decode ignores\n+  decode (prod, lv, hv);\t/* This ignores\n \t\t\t\t   prod[MAX_SHORTS] -> prod[MAX_SHORTS*2-1] */\n+\n+  /* Check for overflow by calculating the top half of the answer in full;\n+     it should agree with the low half's sign bit.  */\n+  decode (prod+MAX_SHORTS, &toplow, &tophigh);\n+  if (h1 < 0)\n+    {\n+      neg_double (l2, h2, &neglow, &neghigh);\n+      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+    }\n+  if (h2 < 0)\n+    {\n+      neg_double (l1, h1, &neglow, &neghigh);\n+      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+    }\n+  return (*hv < 0 ? ~(toplow & tophigh) : toplow | tophigh) != 0;\n }\n \f\n /* Shift the doubleword integer in L1, H1 left by COUNT places\n    keeping only PREC bits of result.\n    Shift right if COUNT is negative.\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n+   Return nonzero if the arithmetic shift overflows, assuming it's signed.\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-void\n+int\n lshift_double (l1, h1, count, prec, lv, hv, arith)\n      HOST_WIDE_INT l1, h1;\n      int count, prec;\n@@ -299,19 +336,20 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n {\n   short arg1[MAX_SHORTS];\n   register int i;\n-  register int carry;\n+  register int carry, overflow;\n \n   if (count < 0)\n     {\n       rshift_double (l1, h1, - count, prec, lv, hv, arith);\n-      return;\n+      return 0;\n     }\n \n   encode (arg1, l1, h1);\n \n   if (count > prec)\n     count = prec;\n \n+  overflow = 0;\n   while (count > 0)\n     {\n       carry = 0;\n@@ -322,9 +360,11 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n \t  carry >>= 8;\n \t}\n       count--;\n+      overflow |= carry ^ (arg1[7] >> 7);\n     }\n \n   decode (arg1, lv, hv);\n+  return overflow;\n }\n \n /* Shift the doubleword integer in L1, H1 right by COUNT places\n@@ -440,10 +480,11 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n    CODE is a tree code for a kind of division, one of\n    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR\n    or EXACT_DIV_EXPR\n-   It controls how the quotient is rounded to an integer.\n+   It controls how the quotient is rounded to a integer.\n+   Return nonzero if the operation overflows.\n    UNS nonzero says do unsigned division.  */\n \n-static void\n+static int\n div_and_round_double (code, uns,\n \t\t      lnum_orig, hnum_orig, lden_orig, hden_orig,\n \t\t      lquo, hquo, lrem, hrem)\n@@ -462,22 +503,25 @@ div_and_round_double (code, uns,\n   HOST_WIDE_INT hnum = hnum_orig;\n   unsigned HOST_WIDE_INT lden = lden_orig;\n   HOST_WIDE_INT hden = hden_orig;\n+  int overflow = 0;\n \n   if ((hden == 0) && (lden == 0))\n     abort ();\n \n   /* calculate quotient sign and convert operands to unsigned.  */\n   if (!uns) \n     {\n-      if (hden < 0) \n+      if (hnum < 0)\n \t{\n \t  quo_neg = ~ quo_neg;\n-\t  neg_double (lden, hden, &lden, &hden);\n+\t  /* (minimum integer) / (-1) is the only overflow case.  */\n+\t  if (neg_double (lnum, hnum, &lnum, &hnum) && (lden & hden) == -1)\n+\t    overflow = 1;\n \t}\n-      if (hnum < 0)\n+      if (hden < 0) \n \t{\n \t  quo_neg = ~ quo_neg;\n-\t  neg_double (lnum, hnum, &lnum, &hnum);\n+\t  neg_double (lden, hden, &lden, &hden);\n \t}\n     }\n \n@@ -650,7 +694,7 @@ div_and_round_double (code, uns,\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\t/* round toward zero */\n     case EXACT_DIV_EXPR:\t/* for this one, it shouldn't matter */\n-      return;\n+      return overflow;\n \n     case FLOOR_DIV_EXPR:\n     case FLOOR_MOD_EXPR:\t/* round toward negative infinity */\n@@ -660,7 +704,7 @@ div_and_round_double (code, uns,\n \t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n \t\t      lquo, hquo);\n \t}\n-      else return;\n+      else return overflow;\n       break;\n \n     case CEIL_DIV_EXPR:\n@@ -670,7 +714,7 @@ div_and_round_double (code, uns,\n \t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n \t\t      lquo, hquo);\n \t}\n-      else return;\n+      else return overflow;\n       break;\n     \n     case ROUND_DIV_EXPR:\n@@ -702,7 +746,7 @@ div_and_round_double (code, uns,\n \t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n \t\t\t  lquo, hquo);\n \t  }\n-\telse return;\n+\telse return overflow;\n       }\n       break;\n \n@@ -714,6 +758,7 @@ div_and_round_double (code, uns,\n   mul_double (*lquo, *hquo, lden_orig, hden_orig, lrem, hrem);\n   neg_double (*lrem, *hrem, lrem, hrem);\n   add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n+  return overflow;\n }\n \f\n /* Effectively truncate a real value to represent\n@@ -1002,6 +1047,9 @@ const_binop (code, arg1, arg2)\n       HOST_WIDE_INT garbagel, garbageh;\n       register tree t;\n       int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n+      /* Propagate overflow flags from operands; also record new overflow.  */\n+      int overflow\n+\t= TREE_CONSTANT_OVERFLOW (arg0) | TREE_CONSTANT_OVERFLOW (arg1);\n \n       switch (code)\n \t{\n@@ -1024,10 +1072,10 @@ const_binop (code, arg1, arg2)\n \tcase RSHIFT_EXPR:\n \t  int2l = - int2l;\n \tcase LSHIFT_EXPR:\n-\t  lshift_double (int1l, int1h, int2l,\n-\t\t\t TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t\t &low, &hi,\n-\t\t\t !uns);\n+\t  overflow = lshift_double (int1l, int1h, int2l,\n+\t\t\t\t    TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t\t\t    &low, &hi,\n+\t\t\t\t    !uns);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1045,19 +1093,25 @@ const_binop (code, arg1, arg2)\n \t    {\n \t      int2l += int1l;\n \t      if ((unsigned HOST_WIDE_INT) int2l < int1l)\n-\t\tint2h += 1;\n+\t\t{\n+\t\t  hi = int2h++;\n+\t\t  overflow = ! same_sign (hi, int2h);\n+\t\t}\n \t      t = build_int_2 (int2l, int2h);\n \t      break;\n \t    }\n \t  if (int2h == 0)\n \t    {\n \t      int1l += int2l;\n \t      if ((unsigned HOST_WIDE_INT) int1l < int2l)\n-\t\tint1h += 1;\n+\t\t{\n+\t\t  hi = int1h++;\n+\t\t  overflow = ! same_sign (hi, int1h);\n+\t\t}\n \t      t = build_int_2 (int1l, int1h);\n \t      break;\n \t    }\n-\t  add_double (int1l, int1h, int2l, int2h, &low, &hi);\n+\t  overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1067,8 +1121,9 @@ const_binop (code, arg1, arg2)\n \t      t = build_int_2 (int1l, int1h);\n \t      break;\n \t    }\n-\t  neg_double (int2l, int2h, &int2l, &int2h);\n-\t  add_double (int1l, int1h, int2l, int2h, &low, &hi);\n+\t  neg_double (int2l, int2h, &low, &hi);\n+\t  add_double (int1l, int1h, low, hi, &low, &hi);\n+\t  overflow = overflow_sum_sign (hi, int2h, int1h);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1087,8 +1142,9 @@ const_binop (code, arg1, arg2)\n \t\t  t = build_int_2 (int2l, int2h);\n \t\t  goto got_it;\n \t\tcase 2:\n+\t\t  overflow = left_shift_overflows (int2h, 1);\n \t\t  temp = int2l + int2l;\n-\t\t  int2h = int2h * 2 + (temp < int2l);\n+\t\t  int2h = (int2h << 1) + (temp < int2l);\n \t\t  t = build_int_2 (temp, int2h);\n \t\t  goto got_it;\n #if 0 /* This code can lose carries.  */\n@@ -1099,16 +1155,18 @@ const_binop (code, arg1, arg2)\n \t\t  goto got_it;\n #endif\n \t\tcase 4:\n+\t\t  overflow = left_shift_overflows (int2h, 2);\n \t\t  temp = int2l + int2l;\n-\t\t  int2h = int2h * 4 + ((temp < int2l) << 1);\n+\t\t  int2h = (int2h << 2) + ((temp < int2l) << 1);\n \t\t  int2l = temp;\n \t\t  temp += temp;\n \t\t  int2h += (temp < int2l);\n \t\t  t = build_int_2 (temp, int2h);\n \t\t  goto got_it;\n \t\tcase 8:\n+\t\t  overflow = left_shift_overflows (int2h, 3);\n \t\t  temp = int2l + int2l;\n-\t\t  int2h = int2h * 8 + ((temp < int2l) << 2);\n+\t\t  int2h = (int2h << 3) + ((temp < int2l) << 2);\n \t\t  int2l = temp;\n \t\t  temp += temp;\n \t\t  int2h += (temp < int2l) << 1;\n@@ -1136,7 +1194,7 @@ const_binop (code, arg1, arg2)\n \t\t}\n \t    }\n \n-\t  mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n+\t  overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1167,15 +1225,17 @@ const_binop (code, arg1, arg2)\n \t      t = build_int_2 (1, 0);\n \t      break;\n \t    }\n-\t  div_and_round_double (code, uns, int1l, int1h, int2l, int2h,\n-\t\t\t\t&low, &hi, &garbagel, &garbageh);\n+\t  overflow = div_and_round_double (code, uns,\n+\t\t\t\t\t   int1l, int1h, int2l, int2h,\n+\t\t\t\t\t   &low, &hi, &garbagel, &garbageh);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n \tcase TRUNC_MOD_EXPR: case ROUND_MOD_EXPR: \n \tcase FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n-\t  div_and_round_double (code, uns, int1l, int1h, int2l, int2h,\n-\t\t\t\t&garbagel, &garbageh, &low, &hi);\n+\t  overflow = div_and_round_double (code, uns,\n+\t\t\t\t\t   int1l, int1h, int2l, int2h,\n+\t\t\t\t\t   &garbagel, &garbageh, &low, &hi);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1209,6 +1269,7 @@ const_binop (code, arg1, arg2)\n     got_it:\n       TREE_TYPE (t) = TREE_TYPE (arg1);\n       force_fit_type (t);\n+      TREE_CONSTANT_OVERFLOW (t) = overflow;\n       return t;\n     }\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n@@ -1223,7 +1284,7 @@ const_binop (code, arg1, arg2)\n       d2 = TREE_REAL_CST (arg2);\n       if (setjmp (float_error))\n \t{\n-\t  warning (\"floating overflow in constant folding\");\n+\t  pedwarn (\"floating overflow in constant expression\");\n \t  return build (code, TREE_TYPE (arg1), arg1, arg2);\n \t}\n       set_float_handler (float_error);\n@@ -1415,6 +1476,9 @@ fold_convert (t, arg1)\n \t     appropriately sign-extended or truncated.  */\n \t  t = build_int_2 (TREE_INT_CST_LOW (arg1),\n \t\t\t   TREE_INT_CST_HIGH (arg1));\n+\t  /* Carry forward overflow indication unless truncating.  */\n+\t  if (TYPE_PRECISION (type) >= TYPE_PRECISION (TREE_TYPE (t)))\n+\t    TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg1);\n \t  TREE_TYPE (t) = type;\n \t  force_fit_type (t);\n \t}\n@@ -1437,7 +1501,7 @@ fold_convert (t, arg1)\n #endif\n \t  if (! (REAL_VALUES_LESS (l, x) && REAL_VALUES_LESS (x, u)))\n \t    {\n-\t      warning (\"real constant out of range for integer conversion\");\n+\t      pedwarn (\"real constant out of range for integer conversion\");\n \t      return t;\n \t    }\n #ifndef REAL_ARITHMETIC\n@@ -1481,7 +1545,7 @@ fold_convert (t, arg1)\n \t{\n \t  if (setjmp (float_error))\n \t    {\n-\t      warning (\"floating overflow in constant folding\");\n+\t      pedwarn (\"floating overflow in constant expression\");\n \t      return t;\n \t    }\n \t  set_float_handler (float_error);\n@@ -3142,11 +3206,13 @@ fold (expr)\n \t{\n \t  if (TREE_CODE (arg0) == INTEGER_CST)\n \t    {\n-\t      if (TREE_INT_CST_LOW (arg0) == 0)\n-\t\tt = build_int_2 (0, - TREE_INT_CST_HIGH (arg0));\n-\t      else\n-\t\tt = build_int_2 (- TREE_INT_CST_LOW (arg0),\n-\t\t\t\t ~ TREE_INT_CST_HIGH (arg0));\n+\t      HOST_WIDE_INT low, high;\n+\t      int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n+\t\t\t\t\t TREE_INT_CST_HIGH (arg0),\n+\t\t\t\t\t &low, &high);\n+\t      t = build_int_2 (low, high);\n+\t      TREE_CONSTANT_OVERFLOW (t)\n+\t\t= overflow | TREE_CONSTANT_OVERFLOW (arg0);\n \t      TREE_TYPE (t) = type;\n \t      force_fit_type (t);\n \t    }\n@@ -3199,6 +3265,7 @@ fold (expr)\n \t\t\t     ~ TREE_INT_CST_HIGH (arg0));\n \t  TREE_TYPE (t) = type;\n \t  force_fit_type (t);\n+\t  TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg0);\n \t}\n       else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n \treturn TREE_OPERAND (arg0, 0);"}]}