{"sha": "5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5YmJiNjMwZGU0M2RiNTI3YWNmNWU1YTgwYzBhM2RkNDQ2ZTBkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T06:57:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T06:57:32Z"}, "message": "poly_int: fold_comparison\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* fold-const.c (fold_comparison): Track sizes and offsets as\n\tpoly_int64s rather than HOST_WIDE_INTs when folding address\n\tcomparisons.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255913", "tree": {"sha": "c7b5184094697c069bbdf4fd5b52c03a7949f438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7b5184094697c069bbdf4fd5b52c03a7949f438"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9/comments", "author": null, "committer": null, "parents": [{"sha": "39bb8924559d0487fb7cb6d4dc33d6b1e9c41004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bb8924559d0487fb7cb6d4dc33d6b1e9c41004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bb8924559d0487fb7cb6d4dc33d6b1e9c41004"}], "stats": {"total": 80, "additions": 53, "deletions": 27}, "files": [{"sha": "acfbb4e193c86a6bbeccc06a9cbb5615a55d8223", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "patch": "@@ -1,3 +1,11 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* fold-const.c (fold_comparison): Track sizes and offsets as\n+\tpoly_int64s rather than HOST_WIDE_INTs when folding address\n+\tcomparisons.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d0a069c32cbf0f513cdca3ee9f8846bbcc825429", "filename": "gcc/fold-const.c", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9bbb630de43db527acf5e5a80c0a3dd446e0d9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5b9bbb630de43db527acf5e5a80c0a3dd446e0d9", "patch": "@@ -8426,7 +8426,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  || TREE_CODE (arg1) == POINTER_PLUS_EXPR))\n     {\n       tree base0, base1, offset0 = NULL_TREE, offset1 = NULL_TREE;\n-      HOST_WIDE_INT bitsize, bitpos0 = 0, bitpos1 = 0;\n+      poly_int64 bitsize, bitpos0 = 0, bitpos1 = 0;\n       machine_mode mode;\n       int volatilep, reversep, unsignedp;\n       bool indirect_base0 = false, indirect_base1 = false;\n@@ -8467,17 +8467,14 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  else\n \t    offset0 = size_binop (PLUS_EXPR, offset0,\n \t\t\t\t  TREE_OPERAND (arg0, 1));\n-\t  if (TREE_CODE (offset0) == INTEGER_CST)\n+\t  if (poly_int_tree_p (offset0))\n \t    {\n-\t      offset_int tem = wi::sext (wi::to_offset (offset0),\n-\t\t\t\t\t TYPE_PRECISION (sizetype));\n+\t      poly_offset_int tem = wi::sext (wi::to_poly_offset (offset0),\n+\t\t\t\t\t      TYPE_PRECISION (sizetype));\n \t      tem <<= LOG2_BITS_PER_UNIT;\n \t      tem += bitpos0;\n-\t      if (wi::fits_shwi_p (tem))\n-\t\t{\n-\t\t  bitpos0 = tem.to_shwi ();\n-\t\t  offset0 = NULL_TREE;\n-\t\t}\n+\t      if (tem.to_shwi (&bitpos0))\n+\t\toffset0 = NULL_TREE;\n \t    }\n \t}\n \n@@ -8513,17 +8510,14 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  else\n \t    offset1 = size_binop (PLUS_EXPR, offset1,\n \t\t\t\t  TREE_OPERAND (arg1, 1));\n-\t  if (TREE_CODE (offset1) == INTEGER_CST)\n+\t  if (poly_int_tree_p (offset1))\n \t    {\n-\t      offset_int tem = wi::sext (wi::to_offset (offset1),\n-\t\t\t\t\t TYPE_PRECISION (sizetype));\n+\t      poly_offset_int tem = wi::sext (wi::to_poly_offset (offset1),\n+\t\t\t\t\t      TYPE_PRECISION (sizetype));\n \t      tem <<= LOG2_BITS_PER_UNIT;\n \t      tem += bitpos1;\n-\t      if (wi::fits_shwi_p (tem))\n-\t\t{\n-\t\t  bitpos1 = tem.to_shwi ();\n-\t\t  offset1 = NULL_TREE;\n-\t\t}\n+\t      if (tem.to_shwi (&bitpos1))\n+\t\toffset1 = NULL_TREE;\n \t    }\n \t}\n \n@@ -8539,7 +8533,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t\t  && operand_equal_p (offset0, offset1, 0)))\n \t    {\n \t      if (!equality_code\n-\t\t  && bitpos0 != bitpos1\n+\t\t  && maybe_ne (bitpos0, bitpos1)\n \t\t  && (pointer_may_wrap_p (base0, offset0, bitpos0)\n \t\t      || pointer_may_wrap_p (base1, offset1, bitpos1)))\n \t\tfold_overflow_warning ((\"assuming pointer wraparound does not \"\n@@ -8550,17 +8544,41 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t      switch (code)\n \t\t{\n \t\tcase EQ_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 == bitpos1, type);\n+\t\t  if (known_eq (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_ne (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tcase NE_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 != bitpos1, type);\n+\t\t  if (known_ne (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_eq (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tcase LT_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 < bitpos1, type);\n+\t\t  if (known_lt (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_ge (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tcase LE_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 <= bitpos1, type);\n+\t\t  if (known_le (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_gt (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tcase GE_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 >= bitpos1, type);\n+\t\t  if (known_ge (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_lt (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tcase GT_EXPR:\n-\t\t  return constant_boolean_node (bitpos0 > bitpos1, type);\n+\t\t  if (known_gt (bitpos0, bitpos1))\n+\t\t    return boolean_true_node;\n+\t\t  if (known_le (bitpos0, bitpos1))\n+\t\t    return boolean_false_node;\n+\t\t  break;\n \t\tdefault:;\n \t\t}\n \t    }\n@@ -8571,7 +8589,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t     because pointer arithmetic is restricted to retain within an\n \t     object and overflow on pointer differences is undefined as of\n \t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n-\t  else if (bitpos0 == bitpos1)\n+\t  else if (known_eq (bitpos0, bitpos1))\n \t    {\n \t      /* By converting to signed sizetype we cover middle-end pointer\n \t         arithmetic which operates on unsigned pointer types of size\n@@ -8600,7 +8618,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t}\n       /* For equal offsets we can simplify to a comparison of the\n \t base addresses.  */\n-      else if (bitpos0 == bitpos1\n+      else if (known_eq (bitpos0, bitpos1)\n \t       && (indirect_base0\n \t\t   ? base0 != TREE_OPERAND (arg0, 0) : base0 != arg0)\n \t       && (indirect_base1\n@@ -8629,7 +8647,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t\t    eliminated.  When ptr is null, although the -> expression\n \t\t    is strictly speaking invalid, GCC retains it as a matter\n \t\t    of QoI.  See PR c/44555. */\n-\t\t && (offset0 == NULL_TREE && bitpos0 != 0))\n+\t\t && (offset0 == NULL_TREE && known_ne (bitpos0, 0)))\n \t\t|| CONSTANT_CLASS_P (base0))\n \t       && indirect_base0\n \t       /* The caller guarantees that when one of the arguments is"}]}