{"sha": "2ce0f5185ba95131b3c538507323d8ecb561a0c2", "node_id": "C_kwDOANBUbNoAKDJjZTBmNTE4NWJhOTUxMzFiM2M1Mzg1MDczMjNkOGVjYjU2MWEwYzI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-11T20:15:40Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-12T21:38:31Z"}, "message": "libstdc++: Reduce memory usage in std::stacktrace::current\n\nThis adds an alternative callback for use in the overload of\nbasic_stacktrace::current that takes a max_depth parameter. The new\ncallback will not allow the container to grow past the initial capacity,\nwhich is set to the specified maximum depth.  This avoids allocating\nmemory for hundreds of frames only to discard them again because of a\nsmall maximum depth limit.\n\nFor larger maximum depths the normal callback is used, with a smaller\ninitial capacity that can grow as needed. The container will be resized\nto the given max depth after the entire backtrace has been produced\n(relying on the fact that std::stacktrace_entry objects are trivially\ndestructible to elide their destruction).\n\nCurrently the value for \"larger\" limits is 128, so a max depth <= 128\nwill allocate capacity for exactly that many frames. A larger max depth\n(or an unspecified max depth) will use an initial capacity of 64 frames\nand grow as needed. Since each frame is only a uintptr_t value it might\nbe reasonable to increase the first value so that memory usage can be\ncapped for larger maximum depths.\n\nThis change also delays the creation of the libbacktrace state until we\nactually need it, so that the state is not created if allocation fails.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/stacktrace (basic_stacktrace::current): Replace\n\tcalls to _M_reserve and _S_curr_cb with call to _M_prepare.\n\tCheck return value of backtrace_simple when max depth given.\n\t(basic_stacktrace::_M_reserve): Remove.\n\t(basic_stacktrace::_S_curr_cb): Remove.\n\t(basic_stacktrace::_M_prepare(size_type)): New function to\n\treserve initial capacity and return callback.\n\t(basic_stacktrace::_Impl::_M_allocate): Remove check for 0 < n\n\tand remove redundant zeroing of _M_frames and _M_capacity.\n\t(basic_stacktrace::_Impl::_M_push_back): Add [[unlikely]]\n\tattribute. Assign _Impl instead of swapping.\n\t* testsuite/19_diagnostics/stacktrace/current.cc: New test.", "tree": {"sha": "e026d7533b9a9c86d03f8ebcfcceb78c4e2114fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e026d7533b9a9c86d03f8ebcfcceb78c4e2114fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ce0f5185ba95131b3c538507323d8ecb561a0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce0f5185ba95131b3c538507323d8ecb561a0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce0f5185ba95131b3c538507323d8ecb561a0c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce0f5185ba95131b3c538507323d8ecb561a0c2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e5ad1cc24a315d07f24c95d76c269cafe2a8182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5ad1cc24a315d07f24c95d76c269cafe2a8182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e5ad1cc24a315d07f24c95d76c269cafe2a8182"}], "stats": {"total": 196, "additions": 148, "deletions": 48}, "files": [{"sha": "5f928f10dee6e320f51ef0bc4d66e1eb18a77050", "filename": "libstdc++-v3/include/std/stacktrace", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce0f5185ba95131b3c538507323d8ecb561a0c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce0f5185ba95131b3c538507323d8ecb561a0c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace?ref=2ce0f5185ba95131b3c538507323d8ecb561a0c2", "patch": "@@ -237,15 +237,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       static basic_stacktrace\n       current(const allocator_type& __alloc = allocator_type()) noexcept\n       {\n-\tauto __state = stacktrace_entry::_S_init();\n \tbasic_stacktrace __ret(__alloc);\n-\tif (!__ret._M_reserve(64)) [[unlikely]]\n-\t  return __ret;\n-\n-\tif (__glibcxx_backtrace_simple(__state, 1, _S_curr_cb(),\n-\t\t\t\t       nullptr, std::__addressof(__ret)))\n-\t  __ret._M_clear();\n-\n+\tif (auto __cb = __ret._M_prepare()) [[likely]]\n+\t  {\n+\t    auto __state = stacktrace_entry::_S_init();\n+\t    if (__glibcxx_backtrace_simple(__state, 1, __cb, nullptr,\n+\t\t\t\t\t   std::__addressof(__ret)))\n+\t      __ret._M_clear();\n+\t  }\n \treturn __ret;\n       }\n \n@@ -254,16 +253,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       current(size_type __skip,\n \t      const allocator_type& __alloc = allocator_type()) noexcept\n       {\n-\tauto __state = stacktrace_entry::_S_init();\n \tbasic_stacktrace __ret(__alloc);\n \tif (__skip >= __INT_MAX__) [[unlikely]]\n \t  return __ret;\n-\tif (!__ret._M_reserve(64)) [[unlikely]]\n-\t  return __ret;\n-\n-\tif (__glibcxx_backtrace_simple(__state, __skip + 1, _S_curr_cb(),\n-\t\t\t\t       nullptr, std::__addressof(__ret)))\n-\t  __ret._M_clear();\n+\tif (auto __cb = __ret._M_prepare()) [[likely]]\n+\t  {\n+\t    auto __state = stacktrace_entry::_S_init();\n+\t    if (__glibcxx_backtrace_simple(__state, __skip + 1, __cb, nullptr,\n+\t\t\t\t\t   std::__addressof(__ret)))\n+\t      __ret._M_clear();\n+\t  }\n \n \treturn __ret;\n       }\n@@ -275,19 +274,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t__glibcxx_assert(__skip <= (size_type(-1) - __max_depth));\n \n-\tauto __state = stacktrace_entry::_S_init();\n \tbasic_stacktrace __ret(__alloc);\n-\tif (__max_depth == 0 || __skip >= __INT_MAX__) [[unlikely]]\n+\tif (__max_depth == 0) [[unlikely]]\n \t  return __ret;\n-\tif (!__ret._M_reserve(std::min<int>(__max_depth, 64))) [[unlikely]]\n+\tif (__skip >= __INT_MAX__) [[unlikely]]\n \t  return __ret;\n-\n-\tif (__glibcxx_backtrace_simple(__state, __skip + 1, _S_curr_cb(),\n-\t\t\t\t       nullptr, std::__addressof(__ret)))\n-\t  __ret._M_clear();\n-\telse if (__ret.size() > __max_depth)\n-\t  __ret.resize(__max_depth);\n-\n+\tif (auto __cb = __ret._M_prepare(__max_depth)) [[likely]]\n+\t  {\n+\t    auto __state = stacktrace_entry::_S_init();\n+\t    int __err = __glibcxx_backtrace_simple(__state, __skip + 1, __cb,\n+\t\t\t\t\t\t   nullptr,\n+\t\t\t\t\t\t   std::__addressof(__ret));\n+\t    if (__err < 0)\n+\t      __ret._M_clear();\n+\t    else if (__ret.size() > __max_depth)\n+\t      __ret._M_impl._M_size = __max_depth;\n+\t  }\n \treturn __ret;\n       }\n \n@@ -524,12 +526,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n     private:\n-      bool\n-      _M_reserve(size_type __n) noexcept\n-      {\n-\treturn _M_impl._M_allocate(_M_alloc, __n) != nullptr;\n-      }\n-\n+      // Precondition: _M_capacity != 0\n       bool\n       _M_push_back(const value_type& __x) noexcept\n       {\n@@ -543,18 +540,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_impl._M_deallocate(_M_alloc);\n       }\n \n-      static auto\n-      _S_curr_cb() noexcept\n+      // Precondition: __max_depth != 0\n+      auto\n+      _M_prepare(size_type __max_depth = -1) noexcept\n       -> int (*) (void*, uintptr_t)\n       {\n-\treturn [](void* __data, uintptr_t __pc) {\n+\tauto __cb = +[](void* __data, uintptr_t __pc) {\n \t  auto& __s = *static_cast<basic_stacktrace*>(__data);\n \t  stacktrace_entry __f;\n \t  __f._M_pc = __pc;\n-\t  if (__s._M_push_back(__f))\n-\t    return 0;\n-\t  return 1;\n+\t  if (__s._M_push_back(__f)) [[likely]]\n+\t    return 0; // continue tracing\n+\t  return -1; // stop tracing due to error\n \t};\n+\n+\tif (__max_depth > 128)\n+\t  __max_depth = 64; // soft limit, _M_push_back will reallocate\n+\telse\n+\t  __cb = [](void* __data, uintptr_t __pc) {\n+\t    auto& __s = *static_cast<basic_stacktrace*>(__data);\n+\t    stacktrace_entry __f;\n+\t    __f._M_pc = __pc;\n+\t    if (__s.size() == __s._M_impl._M_capacity) [[unlikely]]\n+\t      return 1; // stop tracing due to reaching max depth\n+\t    if (__s._M_push_back(__f)) [[likely]]\n+\t      return 0; // continue tracing\n+\t    return -1; // stop tracing due to error\n+\t  };\n+\n+\tif (_M_impl._M_allocate(_M_alloc, __max_depth)) [[likely]]\n+\t  return __cb;\n+\treturn nullptr;\n       }\n \n       struct _Impl\n@@ -573,24 +589,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return std::min(__size_max, __alloc_max);\n \t}\n \n-\t// Precondition: _M_frames == nullptr\n+\t// Precondition: _M_frames == nullptr && __n != 0\n \tpointer\n \t_M_allocate(allocator_type& __alloc, size_type __n) noexcept\n \t{\n-\t  __try\n+\t  if (__n <= _S_max_size(__alloc)) [[likely]]\n \t    {\n-\t      if (0 < __n && __n <= _S_max_size(__alloc)) [[likely]]\n+\t      __try\n \t\t{\n \t\t  _M_frames = __alloc.allocate(__n);\n \t\t  _M_capacity = __n;\n \t\t  return _M_frames;\n \t\t}\n+\t      __catch (...)\n+\t\t{\n+\t\t}\n \t    }\n-\t  __catch (...)\n-\t    {\n-\t    }\n-\t  _M_frames = nullptr;\n-\t  _M_capacity = 0;\n \t  return nullptr;;\n \t}\n \n@@ -612,25 +626,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_size = 0;\n \t}\n \n+\t// Precondition: _M_capacity != 0\n \tbool\n \t_M_push_back(allocator_type& __alloc,\n \t\t     const stacktrace_entry& __f) noexcept\n \t{\n-\t  if (_M_size == _M_capacity)\n+\t  if (_M_size == _M_capacity) [[unlikely]]\n \t    {\n \t      _Impl __tmp;\n \t      if (auto __f = __tmp._M_allocate(__alloc, _M_capacity * 2))\n \t\tstd::uninitialized_copy_n(_M_frames, _M_size, __f);\n \t      else\n \t\treturn false;\n \t      _M_deallocate(__alloc);\n-\t      std::swap(*this, __tmp);\n+\t      *this = __tmp;\n \t    }\n \t  stacktrace_entry* __addr = std::to_address(_M_frames + _M_size++);\n \t  std::construct_at(__addr, __f);\n \t  return true;\n \t}\n-\n       };\n \n       [[no_unique_address]] allocator_type  _M_alloc{};"}, {"sha": "184e23b460e4bbe9e42f3fd0fd49a0ca7c6885bc", "filename": "libstdc++-v3/testsuite/19_diagnostics/stacktrace/current.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce0f5185ba95131b3c538507323d8ecb561a0c2/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fcurrent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce0f5185ba95131b3c538507323d8ecb561a0c2/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fcurrent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fcurrent.cc?ref=2ce0f5185ba95131b3c538507323d8ecb561a0c2", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++23 -lstdc++_libbacktrace\" }\n+// { dg-do run { target c++23 } }\n+// { dg-require-effective-target stacktrace }\n+\n+#include <stacktrace>\n+#include <memory>\n+#include <new>\n+#include \"testsuite_hooks.h\"\n+\n+template<typename T>\n+struct Allocator\n+{\n+  using value_type = T;\n+  using propagate_on_container_move_assignment = std::true_type;\n+\n+  explicit\n+  Allocator(unsigned max = -1u) : max_size(max) { }\n+\n+  template<typename U>\n+    Allocator(const Allocator<U>& a) : max_size(a.max_size) { }\n+\n+  T*\n+  allocate(std::size_t n)\n+  {\n+    if (n > max_size)\n+      throw std::bad_alloc();\n+\n+    return std::allocator<T>().allocate(n);\n+  }\n+\n+  void\n+  deallocate(T* p, std::size_t n) noexcept\n+  {\n+    std::allocator<T>().deallocate(p, n);\n+  }\n+\n+  bool operator==(const Allocator&) const = default;\n+\n+private:\n+  unsigned max_size;\n+};\n+\n+[[gnu::optimize(\"O0\")]]\n+void\n+test_max_depth()\n+{\n+  using Stacktrace = std::basic_stacktrace<Allocator<std::stacktrace_entry>>;\n+  using Alloc = typename Stacktrace::allocator_type;\n+\n+  [] { [] { [] { [] { [] { [] { [] { [] {\n+    auto t = Stacktrace::current();\n+    VERIFY( ! t.empty() );\n+    const auto n = t.size(); // total number of frames\n+    t = Stacktrace::current(8);\n+    VERIFY( t.size() == (n - 8) );\n+    t = Stacktrace::current(n);\n+    VERIFY( t.empty() );\n+    t = Stacktrace::current(n - 2);\n+    VERIFY( t.size() == 2 );\n+    t = Stacktrace::current(2, 6);\n+    VERIFY( t.size() == 6 );\n+    t = Stacktrace::current(n - 2, 6);\n+    VERIFY( t.size() == 2 );\n+\n+    t = Stacktrace::current(Alloc(3));\n+    // Full stacktrace is larger than 3 frames, so allocation fails:\n+    VERIFY( t.empty() );\n+    t = Stacktrace::current(3, Alloc(2));\n+    // Stacktrace still too large after skipping 3 frames, so allocation fails:\n+    VERIFY( t.empty() );\n+    t = Stacktrace::current(0, 3, Alloc(3));\n+    // Capacity for exactly 3 frames is allocated:\n+    VERIFY( t.size() == 3 );\n+    t = Stacktrace::current(2, 4, Alloc(4));\n+    // Capacity for exactly 4 frames is allocated:\n+    VERIFY( t.size() == 4 );\n+    t = Stacktrace::current(0, 4, Alloc(3));\n+    // Capacity for exactly 4 frames is requested, but allocation fails:\n+    VERIFY( t.empty() );\n+  }(); }(); }(); }(); }(); }(); }(); }();\n+}\n+\n+int main()\n+{\n+  test_max_depth();\n+}"}]}