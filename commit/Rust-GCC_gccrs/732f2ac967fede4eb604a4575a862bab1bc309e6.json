{"sha": "732f2ac967fede4eb604a4575a862bab1bc309e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyZjJhYzk2N2ZlZGU0ZWI2MDRhNDU3NWE4NjJiYWIxYmMzMDllNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-06T19:45:38Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-06T19:45:38Z"}, "message": "combine.c (check_promoted_subreg, [...]): New functions.\n\n\t* combine.c (check_promoted_subreg, record_promoted_value): New\n\tfunctions.\n\t(combine_instructions): Use them to retain nonzero and sign bit\n\tinformation after SUBREGs are eliminated by optimizations in\n\tthis pass if PROMOTE_FUNCTION_RETURN.\n\nFrom-SVN: r30808", "tree": {"sha": "2a0c3098c4f80998e0552333248b50ec31e858c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a0c3098c4f80998e0552333248b50ec31e858c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/732f2ac967fede4eb604a4575a862bab1bc309e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732f2ac967fede4eb604a4575a862bab1bc309e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732f2ac967fede4eb604a4575a862bab1bc309e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732f2ac967fede4eb604a4575a862bab1bc309e6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0974e9fec8fbca107e6077874febb87ae22c8a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0974e9fec8fbca107e6077874febb87ae22c8a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0974e9fec8fbca107e6077874febb87ae22c8a83"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "119a1dbabc241ba14a2a704e9670a8a5caf38b1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732f2ac967fede4eb604a4575a862bab1bc309e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732f2ac967fede4eb604a4575a862bab1bc309e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=732f2ac967fede4eb604a4575a862bab1bc309e6", "patch": "@@ -17,6 +17,12 @@\n \talways use move_by_pieces to avoid infinite recursion.\n \t(restore_fixed_argument_area): Likewise.\n \n+\t* combine.c (check_promoted_subreg, record_promoted_value): New\n+\tfunctions.\n+\t(combine_instructions): Use them to retain nonzero and sign bit\n+\tinformation after SUBREGs are eliminated by optimizations in\n+\tthis pass if PROMOTE_FUNCTION_RETURN.\n+\n Mon Dec  6 12:24:52 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* fold-const.c (optimize_bit_field_compare): Only use one mode"}, {"sha": "825d8a746167c5b5eab9a28ac53c29a554052ac0", "filename": "gcc/combine.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732f2ac967fede4eb604a4575a862bab1bc309e6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732f2ac967fede4eb604a4575a862bab1bc309e6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=732f2ac967fede4eb604a4575a862bab1bc309e6", "patch": "@@ -403,6 +403,9 @@ static enum rtx_code simplify_comparison  PROTO((enum rtx_code, rtx *, rtx *));\n static int reversible_comparison_p  PROTO((rtx));\n static void update_table_tick\tPROTO((rtx));\n static void record_value_for_reg  PROTO((rtx, rtx, rtx));\n+#ifdef PROMOTE_FUNCTION_RETURN\n+static void check_promoted_subreg PROTO((rtx, rtx));\n+#endif\n static void record_dead_and_set_regs_1  PROTO((rtx, rtx, void *));\n static void record_dead_and_set_regs  PROTO((rtx));\n static int get_last_value_validate  PROTO((rtx *, rtx, int, int));\n@@ -608,6 +611,12 @@ combine_instructions (f, nregs)\n \n       else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n+#ifdef PROMOTE_FUNCTION_RETURN\n+\t  /* See if we know about function return values before this\n+\t     insn based upon SUBREG flags.  */\n+\t  check_promoted_subreg (insn, PATTERN (insn));\n+#endif\n+\n \t  /* Try this insn with each insn it links back to.  */\n \n \t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n@@ -11048,6 +11057,90 @@ record_dead_and_set_regs (insn)\n \n   note_stores (PATTERN (insn), record_dead_and_set_regs_1, insn);\n }\n+\n+#ifdef PROMOTE_FUNCTION_RETURN\n+/* If a SUBREG has the promoted bit set, it is in fact a property of the\n+   register present in the SUBREG, so for each such SUBREG go back and\n+   adjust nonzero and sign bit information of the registers that are\n+   known to have some zero/sign bits set.\n+\n+   This is needed because when combine blows the SUBREGs away, the\n+   information on zero/sign bits is lost and further combines can be\n+   missed because of that.  */\n+\n+static void\n+record_promoted_value (insn, subreg)\n+    rtx insn;\n+    rtx subreg;\n+{\n+  rtx links, links2, set;\n+  int regno = REGNO (SUBREG_REG (subreg));\n+  enum machine_mode mode = GET_MODE (subreg);\n+\n+  if (GET_MODE_BITSIZE (mode) >= HOST_BITS_PER_WIDE_INT)\n+    return;\n+\n+  for (links = LOG_LINKS (insn); links; )\n+    {\n+      insn = XEXP (links, 0);\n+      set = single_set (insn);\n+\n+      if (! set || GET_CODE (SET_DEST (set)) != REG\n+\t  || REGNO (SET_DEST (set)) != regno\n+\t  || GET_MODE (SET_DEST (set)) != GET_MODE (SUBREG_REG (subreg)))\n+\t{\n+\t  links = XEXP (links, 1);\n+\t  continue;\n+\t}\n+\n+      if (reg_last_set [regno] == insn)\n+        {\n+\t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg))\n+\t    reg_last_set_nonzero_bits [regno] &= GET_MODE_MASK (mode);\n+        }\n+\n+      if (GET_CODE (SET_SRC (set)) == REG)\n+\t{\n+\t  regno = REGNO (SET_SRC (set));\n+\t  links = LOG_LINKS (insn);\n+\t}\n+      else\n+\tbreak;\n+    }\n+}\n+\n+/* Scan X for promoted SUBREGs.  For each one found,\n+   note what it implies to the registers used in it.  */\n+\n+static void\n+check_promoted_subreg (insn, x)\n+    rtx insn;\n+    rtx x;\n+{\n+  if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n+      && GET_CODE (SUBREG_REG (x)) == REG)\n+    record_promoted_value (insn, x);\n+  else\n+    {\n+      const char *format = GET_RTX_FORMAT (GET_CODE (x));\n+      int i, j;\n+\n+      for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n+\tswitch (format [i])\n+\t  {\n+\t  case 'e':\n+\t    check_promoted_subreg (insn, XEXP (x, i));\n+\t    break;\n+\t  case 'V':\n+\t  case 'E':\n+\t    if (XVEC (x, i) != 0)\n+\t      for (j = 0; j < XVECLEN (x, i); j++)\n+\t\tcheck_promoted_subreg (insn, XVECEXP (x, i, j));\n+\t    break;\n+\t  }\n+    }\n+}\n+#endif\n \f\n /* Utility routine for the following function.  Verify that all the registers\n    mentioned in *LOC are valid when *LOC was part of a value set when"}]}