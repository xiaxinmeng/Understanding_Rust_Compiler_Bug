{"sha": "bced6edfc6c487a9cf671f08417be163904d8def", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlZDZlZGZjNmM0ODdhOWNmNjcxZjA4NDE3YmUxNjM5MDRkOGRlZg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-19T11:59:44Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-19T11:59:44Z"}, "message": "cpphash.h (struct cpp_reader): New member warned_dollar.\n\n\t* cpphash.h (struct cpp_reader): New member warned_dollar.\n\t* cpplex.c (continues_identifier_p): New function.\n\t(parse_identifier, parse_number, parse_string): Rename lex_identifer,\n\tlex_number and lex_string, and simplify.\n\t(parse_slow, unescaped_terminator_p): Die.\n\t(_cpp_lex_direct): Update.\n\nFrom-SVN: r65816", "tree": {"sha": "d205dc47adef09a8364abbb312879df8c18a5aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d205dc47adef09a8364abbb312879df8c18a5aeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bced6edfc6c487a9cf671f08417be163904d8def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bced6edfc6c487a9cf671f08417be163904d8def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bced6edfc6c487a9cf671f08417be163904d8def", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bced6edfc6c487a9cf671f08417be163904d8def/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1d1b741e82757450fb9daf1bad2ea85c792ad4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d1b741e82757450fb9daf1bad2ea85c792ad4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1d1b741e82757450fb9daf1bad2ea85c792ad4e"}], "stats": {"total": 328, "additions": 114, "deletions": 214}, "files": [{"sha": "4a987d567c3cfb6f1992d6fd168d1c7c4f893e46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bced6edfc6c487a9cf671f08417be163904d8def", "patch": "@@ -1,3 +1,12 @@\n+2003-04-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cpphash.h (struct cpp_reader): New member warned_dollar.\n+\t* cpplex.c (continues_identifier_p): New function.\n+\t(parse_identifier, parse_number, parse_string): Rename lex_identifer,\n+\tlex_number and lex_string, and simplify.\n+\t(parse_slow, unescaped_terminator_p): Die.\n+\t(_cpp_lex_direct): Update.\n+\n 2003-04-19  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* calls.c (expand_call): Provide init for old_stack_pointer_delta."}, {"sha": "a551aadc0f817f4a338435c67cfe030c2390388d", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=bced6edfc6c487a9cf671f08417be163904d8def", "patch": "@@ -381,6 +381,10 @@ struct cpp_reader\n   cpp_token avoid_paste;\n   cpp_token eof;\n \n+  /* True if we have already warned about dollars in identifiers or\n+     numbers for this buffer.  */\n+  bool warned_dollar;\n+\n   /* Opaque handle to the dependencies of mkdeps.c.  */\n   struct deps *deps;\n "}, {"sha": "ad68b7389c9d408c54ace876d3cf7bd100c81d80", "filename": "gcc/cpplex.c", "status": "modified", "additions": 101, "deletions": 214, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bced6edfc6c487a9cf671f08417be163904d8def/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=bced6edfc6c487a9cf671f08417be163904d8def", "patch": "@@ -62,12 +62,10 @@ static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n \n static int skip_line_comment PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n-static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n-static uchar *parse_slow PARAMS ((cpp_reader *, const uchar *, int,\n-\t\t\t\t  unsigned int *));\n-static void parse_number PARAMS ((cpp_reader *, cpp_string *, int));\n-static int unescaped_terminator_p PARAMS ((cpp_reader *, const uchar *));\n-static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n+static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *));\n+static void lex_number PARAMS ((cpp_reader *, cpp_string *));\n+static bool continues_identifier_p PARAMS ((cpp_reader *));\n+static void lex_string PARAMS ((cpp_reader *, cpp_token *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n \t\t\t\t  cppchar_t));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n@@ -377,46 +375,50 @@ name_p (pfile, string)\n   return 1;\n }\n \n-/* Parse an identifier, skipping embedded backslash-newlines.  This is\n-   a critical inner loop.  The common case is an identifier which has\n-   not been split by backslash-newline, does not contain a dollar\n-   sign, and has already been scanned (roughly 10:1 ratio of\n-   seen:unseen identifiers in normal code; the distribution is\n-   Poisson-like).  Second most common case is a new identifier, not\n-   split and no dollar sign.  The other possibilities are rare and\n-   have been relegated to parse_slow.  */\n+/* Returns TRUE if the sequence starting at buffer->cur is invalid in\n+   an identifier.  */\n+static bool\n+continues_identifier_p (pfile)\n+     cpp_reader *pfile;\n+{\n+  if (*pfile->buffer->cur != '$')\n+    return false;\n+\n+  if (CPP_PEDANTIC (pfile) && !pfile->state.skipping && !pfile->warned_dollar)\n+    {\n+      pfile->warned_dollar = true;\n+      cpp_error (pfile, DL_PEDWARN, \"'$' in identifier or number\");\n+    }\n+  pfile->buffer->cur++;\n+\n+  return true;\n+}\n+\n+/* Lex an identifier starting at BUFFER->CUR - 1.  */\n static cpp_hashnode *\n-parse_identifier (pfile)\n+lex_identifier (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *result;\n   const uchar *cur, *base;\n \n-  /* Fast-path loop.  Skim over a normal identifier.\n-     N.B. ISIDNUM does not include $.  */\n-  cur = pfile->buffer->cur;\n-  while (ISIDNUM (*cur))\n-    cur++;\n-\n-  /* Check for slow-path cases.  */\n-  if (*cur == '$')\n+  base = pfile->buffer->cur - 1;\n+  do\n     {\n-      unsigned int len;\n+      cur = pfile->buffer->cur;\n+\n+      /* N.B. ISIDNUM does not include $.  */\n+      while (ISIDNUM (*cur))\n+\tcur++;\n \n-      base = parse_slow (pfile, cur, 0, &len);\n-      result = (cpp_hashnode *)\n-\tht_lookup (pfile->hash_table, base, len, HT_ALLOCED);\n-    }\n-  else\n-    {\n-      base = pfile->buffer->cur - 1;\n       pfile->buffer->cur = cur;\n-      result = (cpp_hashnode *)\n-\tht_lookup (pfile->hash_table, base, cur - base, HT_ALLOC);\n     }\n+  while (continues_identifier_p (pfile));\n \n-  /* Rarely, identifiers require diagnostics when lexed.\n-     XXX Has to be forced out of the fast path.  */\n+  result = (cpp_hashnode *)\n+    ht_lookup (pfile->hash_table, base, cur - base, HT_ALLOC);\n+\n+  /* Rarely, identifiers require diagnostics when lexed.  */\n   if (__builtin_expect ((result->flags & NODE_DIAGNOSTIC)\n \t\t\t&& !pfile->state.skipping, 0))\n     {\n@@ -436,188 +438,66 @@ parse_identifier (pfile)\n   return result;\n }\n \n-/* Slow path.  This handles numbers and identifiers which have been\n-   split, or contain dollar signs.  The part of the token from\n-   PFILE->buffer->cur-1 to CUR has already been scanned.  NUMBER_P is\n-   1 if it's a number, and 2 if it has a leading period.  Returns a\n-   pointer to the token's NUL-terminated spelling in permanent\n-   storage, and sets PLEN to its length.  */\n-static uchar *\n-parse_slow (pfile, cur, number_p, plen)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n-     int number_p;\n-     unsigned int *plen;\n-{\n-  cpp_buffer *buffer = pfile->buffer;\n-  const uchar *base = buffer->cur - 1;\n-  struct obstack *stack = &pfile->hash_table->stack;\n-  unsigned int c, prevc, saw_dollar = 0;\n-\n-  /* Place any leading period.  */\n-  if (number_p == 2)\n-    obstack_1grow (stack, '.');\n-\n-  /* Copy the part of the token which is known to be okay.  */\n-  obstack_grow (stack, base, cur - base);\n-\n-  /* Now process the part which isn't.  We are looking at one of\n-     '$', '\\\\', or '?' on entry to this loop.  */\n-  prevc = cur[-1];\n-  c = *cur++;\n-  buffer->cur = cur;\n-  for (;;)\n-    {\n-      /* Potential escaped newline?  */\n-      buffer->backup_to = buffer->cur - 1;\n-\n-      if (!is_idchar (c))\n-\t{\n-\t  if (!number_p)\n-\t    break;\n-\t  if (c != '.' && !VALID_SIGN (c, prevc))\n-\t    break;\n-\t}\n-\n-      /* Handle normal identifier characters in this loop.  */\n-      do\n-\t{\n-\t  prevc = c;\n-\t  obstack_1grow (stack, c);\n-\n-\t  if (c == '$')\n-\t    saw_dollar++;\n-\n-\t  c = *buffer->cur++;\n-\t}\n-      while (is_idchar (c));\n-    }\n-\n-  /* Step back over the unwanted char.  */\n-  BACKUP ();\n-\n-  /* $ is not an identifier character in the standard, but is commonly\n-     accepted as an extension.  Don't warn about it in skipped\n-     conditional blocks.  */\n-  if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->state.skipping)\n-    cpp_error (pfile, DL_PEDWARN, \"'$' character(s) in identifier or number\");\n-\n-  /* Identifiers and numbers are null-terminated.  */\n-  *plen = obstack_object_size (stack);\n-  obstack_1grow (stack, '\\0');\n-  return obstack_finish (stack);\n-}\n-\n-/* Parse a number, beginning with character C, skipping embedded\n-   backslash-newlines.  LEADING_PERIOD is nonzero if there was a \".\"\n-   before C.  Place the result in NUMBER.  */\n+/* Lex a number to NUMBER starting at BUFFER->CUR - 1.  */\n static void\n-parse_number (pfile, number, leading_period)\n+lex_number (pfile, number)\n      cpp_reader *pfile;\n      cpp_string *number;\n-     int leading_period;\n {\n   const uchar *cur;\n+  const uchar *base;\n+  uchar *dest;\n \n-  /* Fast-path loop.  Skim over a normal number.\n-     N.B. ISIDNUM does not include $.  */\n-  cur = pfile->buffer->cur;\n-  while (ISIDNUM (*cur) || *cur == '.' || VALID_SIGN (*cur, cur[-1]))\n-    cur++;\n-\n-  /* Check for slow-path cases.  */\n-  if (*cur == '$')\n-    number->text = parse_slow (pfile, cur, 1 + leading_period, &number->len);\n-  else\n+  base = pfile->buffer->cur - 1;\n+  do\n     {\n-      const uchar *base = pfile->buffer->cur - 1;\n-      uchar *dest;\n+      cur = pfile->buffer->cur;\n \n-      number->len = cur - base + leading_period;\n-      dest = _cpp_unaligned_alloc (pfile, number->len + 1);\n-      dest[number->len] = '\\0';\n-      number->text = dest;\n+      /* N.B. ISIDNUM does not include $.  */\n+      while (ISIDNUM (*cur) || *cur == '.' || VALID_SIGN (*cur, cur[-1]))\n+\tcur++;\n \n-      if (leading_period)\n-\t*dest++ = '.';\n-      memcpy (dest, base, cur - base);\n       pfile->buffer->cur = cur;\n     }\n-}\n-\n-/* Subroutine of parse_string.  */\n-static int\n-unescaped_terminator_p (pfile, dest)\n-     cpp_reader *pfile;\n-     const unsigned char *dest;\n-{\n-  const unsigned char *start, *temp;\n-\n-  /* In #include-style directives, terminators are not escapable.  */\n-  if (pfile->state.angled_headers)\n-    return 1;\n-\n-  start = BUFF_FRONT (pfile->u_buff);\n+  while (continues_identifier_p (pfile));\n \n-  /* An odd number of consecutive backslashes represents an escaped\n-     terminator.  */\n-  for (temp = dest; temp > start && temp[-1] == '\\\\'; temp--)\n-    ;\n-\n-  return ((dest - temp) & 1) == 0;\n+  number->len = cur - base;\n+  dest = _cpp_unaligned_alloc (pfile, number->len + 1);\n+  memcpy (dest, base, number->len);\n+  dest[number->len] = '\\0';\n+  number->text = dest;\n }\n \n-/* Parses a string, character constant, or angle-bracketed header file\n-   name.  Handles embedded trigraphs and escaped newlines.  The stored\n-   string is guaranteed NUL-terminated, but it is not guaranteed that\n-   this is the first NUL since embedded NULs are preserved.\n-\n-   When this function returns, buffer->cur points to the next\n-   character to be processed.  */\n+/* Lexes a string, character constant, or angle-bracketed header file\n+   name.  The stored string is guaranteed NUL-terminated, but it is\n+   not guaranteed that this is the first NUL since embedded NULs are\n+   preserved.  */\n static void\n-parse_string (pfile, token, terminator)\n+lex_string (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n-     cppchar_t terminator;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned char *dest, *limit;\n-  cppchar_t c;\n   bool warned_nulls = false;\n+  const uchar *base;\n+  uchar *dest;\n+  cppchar_t terminator;\n \n-  dest = BUFF_FRONT (pfile->u_buff);\n-  limit = BUFF_LIMIT (pfile->u_buff);\n+  base = buffer->cur;\n+  terminator = base[-1];\n+  if (terminator == '<')\n+    terminator = '>';\n \n   for (;;)\n     {\n-      /* We need room for another char, possibly the terminating NUL.  */\n-      if ((size_t) (limit - dest) < 1)\n-\t{\n-\t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t  _cpp_extend_buff (pfile, &pfile->u_buff, 2);\n-\t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n-\t  limit = BUFF_LIMIT (pfile->u_buff);\n-\t}\n-\n-      c = *buffer->cur++;\n+      cppchar_t c = *buffer->cur++;\n \n-      if (c == terminator)\n-\t{\n-\t  if (unescaped_terminator_p (pfile, dest))\n-\t    break;\n-\t}\n-      else if (c == '\\n')\n-\t{\n-\t  /* No string literal may extend over multiple lines.  In\n-\t     assembly language, suppress the error except for <>\n-\t     includes.  This is a kludge around not knowing where\n-\t     comments are.  */\n-\t  if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n-\t    cpp_error (pfile, DL_ERROR, \"missing terminating %c character\",\n-\t\t       (int) terminator);\n-\t  buffer->cur--;\n-\t  break;\n-\t}\n+      /* In #include-style directives, terminators are not escapable.\n+\t \\n can follow the '\\\\' if the file's last byte is '\\\\'.  */\n+      if (c == '\\\\' && !pfile->state.angled_headers && *buffer->cur != '\\n')\n+\tbuffer->cur++;\n+      else if (c == terminator || c == '\\n')\n+\tbreak;\n       else if (c == '\\0')\n \t{\n \t  if (!warned_nulls)\n@@ -627,14 +507,25 @@ parse_string (pfile, token, terminator)\n \t\t\t \"null character(s) preserved in literal\");\n \t    }\n \t}\n-\t*dest++ = c;\n     }\n \n-  *dest = '\\0';\n+  token->val.str.len = buffer->cur - base - 1;\n+  dest = _cpp_unaligned_alloc (pfile, token->val.str.len + 1);\n+  memcpy (dest, base, token->val.str.len);\n+  dest[token->val.str.len] = '\\0';\n+  token->val.str.text = dest;\n \n-  token->val.str.text = BUFF_FRONT (pfile->u_buff);\n-  token->val.str.len = dest - BUFF_FRONT (pfile->u_buff);\n-  BUFF_FRONT (pfile->u_buff) = dest + 1;\n+  if (buffer->cur[-1] == '\\n')\n+    {\n+      /* No string literal may extend over multiple lines.  In\n+\t assembly language, suppress the error except for <>\n+\t includes.  This is a kludge around not knowing where\n+\t comments are.  */\n+      if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n+\tcpp_error (pfile, DL_ERROR, \"missing terminating %c character\",\n+\t\t   (int) terminator);\n+      buffer->cur--;\n+    }\n }\n \n /* The stored comment includes the comment start and any terminator.  */\n@@ -916,23 +807,18 @@ _cpp_lex_direct (pfile)\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n       result->type = CPP_NUMBER;\n-      parse_number (pfile, &result->val.str, 0);\n+      lex_number (pfile, &result->val.str);\n       break;\n \n     case 'L':\n       /* 'L' may introduce wide characters or strings.  */\n-      {\n-\tconst unsigned char *pos = buffer->cur;\n-\n-\tc = get_effective_char (pfile);\n-\tif (c == '\\'' || c == '\"')\n-\t  {\n-\t    result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n-\t    parse_string (pfile, result, c);\n-\t    break;\n-\t  }\n-\tbuffer->cur = pos;\n-      }\n+      if (*buffer->cur == '\\'' || *buffer->cur == '\"')\n+\t{\n+\t  result->type = (*buffer->cur == '\"' ? CPP_WSTRING: CPP_WCHAR);\n+\t  buffer->cur++;\n+\t  lex_string (pfile, result);\n+\t  break;\n+\t}\n       /* Fall through.  */\n \n     start_ident:\n@@ -948,7 +834,7 @@ _cpp_lex_direct (pfile)\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;\n-      result->val.node = parse_identifier (pfile);\n+      result->val.node = lex_identifier (pfile);\n \n       /* Convert named operators to their proper types.  */\n       if (result->val.node->flags & NODE_OPERATOR)\n@@ -961,7 +847,7 @@ _cpp_lex_direct (pfile)\n     case '\\'':\n     case '\"':\n       result->type = c == '\"' ? CPP_STRING: CPP_CHAR;\n-      parse_string (pfile, result, c);\n+      lex_string (pfile, result);\n       break;\n \n     case '/':\n@@ -1018,7 +904,7 @@ _cpp_lex_direct (pfile)\n       if (pfile->state.angled_headers)\n \t{\n \t  result->type = CPP_HEADER_NAME;\n-\t  parse_string (pfile, result, '>');\n+\t  lex_string (pfile, result);\n \t  break;\n \t}\n \n@@ -1108,8 +994,9 @@ _cpp_lex_direct (pfile)\n       /* All known character sets have 0...9 contiguous.  */\n       else if (ISDIGIT (c))\n \t{\n+\t  buffer->cur--;\n \t  result->type = CPP_NUMBER;\n-\t  parse_number (pfile, &result->val.str, 1);\n+\t  lex_number (pfile, &result->val.str);\n \t}\n       else if (c == '*' && CPP_OPTION (pfile, cplusplus))\n \tresult->type = CPP_DOT_STAR;"}]}