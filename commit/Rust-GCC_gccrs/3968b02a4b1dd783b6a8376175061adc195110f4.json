{"sha": "3968b02a4b1dd783b6a8376175061adc195110f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2OGIwMmE0YjFkZDc4M2I2YTgzNzYxNzUwNjFhZGMxOTUxMTBmNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-07-23T13:11:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-07-23T13:42:06Z"}, "message": "[Ada] Ada2020: AI12-0027 Access values and unaliased component\n\nAccess values should never designate unaliased components.\nThis new feature is documented in AI12-0027-1.\n\ngcc/ada/\n\n\t* sem_ch13.ads (Same_Representation): Renamed as\n\tHas_Compatible_Representation because now the order of the arguments\n\tare taken into account; its formals are also renamed as Target_Type\n\tand Operand_Type.\n\t* sem_ch13.adb (Same_Representation): Renamed and moved to place the\n\troutine in alphabetic order.\n\t* sem_attr.adb (Prefix_With_Safe_Accessibility_Level): New subprogram.\n\t(Resolve_Attribute): Check that the prefix of attribute Access\n\tdoes not have a value conversion of an array type.\n\t* sem_res.adb (Resolve_Actuals): Remove restrictive check on view\n\tconversions which required matching value of Has_Aliased_Components of\n\tformals and actuals.\n\t* exp_ch4.adb (Handle_Changed_Representation): Update call to\n\tSame_Representation.\n\t(Expand_N_Type_Conversion): Update call to Same_Representation.\n\t* exp_ch5.adb (Change_Of_Representation): Update call to\n\tSame_Representation.\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): Update call to\n\tSame_Representation.\n\t(Expand_Actuals): Update call to Same_Representation.\n\t(Expand_Call_Helper): Update call to Same_Representation.", "tree": {"sha": "679a428cd1c49fe08ea074ceebbaaa73f4961751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/679a428cd1c49fe08ea074ceebbaaa73f4961751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3968b02a4b1dd783b6a8376175061adc195110f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3968b02a4b1dd783b6a8376175061adc195110f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3968b02a4b1dd783b6a8376175061adc195110f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3968b02a4b1dd783b6a8376175061adc195110f4/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de8bfcc8e45d9c77c48c9f071836698aa6db5ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de8bfcc8e45d9c77c48c9f071836698aa6db5ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de8bfcc8e45d9c77c48c9f071836698aa6db5ff3"}], "stats": {"total": 584, "additions": 335, "deletions": 249}, "files": [{"sha": "2f6dc3a989f605c0f7f541056cb393f97a4b4e7f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -11436,7 +11436,7 @@ package body Exp_Ch4 is\n       begin\n          --  Nothing else to do if no change of representation\n \n-         if Same_Representation (Operand_Type, Target_Type) then\n+         if Has_Compatible_Representation (Target_Type, Operand_Type) then\n             return;\n \n          --  The real change of representation work is done by the assignment\n@@ -12454,7 +12454,7 @@ package body Exp_Ch4 is\n          --  Special processing is required if there is a change of\n          --  representation (from enumeration representation clauses).\n \n-         if not Same_Representation (Target_Type, Operand_Type)\n+         if not Has_Compatible_Representation (Target_Type, Operand_Type)\n            and then not Conversion_OK (N)\n          then\n "}, {"sha": "8482f3007358cd56a71328b208163bf012f9a316", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -278,8 +278,9 @@ package body Exp_Ch5 is\n    begin\n       return\n         Nkind (Rhs) = N_Type_Conversion\n-          and then\n-            not Same_Representation (Etype (Rhs), Etype (Expression (Rhs)));\n+          and then not Has_Compatible_Representation\n+                         (Target_Type  => Etype (Rhs),\n+                          Operand_Type => Etype (Expression (Rhs)));\n    end Change_Of_Representation;\n \n    ------------------------------"}, {"sha": "38864933b4474eea37d6ea5c57e1e49cca0d9f52", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -1571,8 +1571,9 @@ package body Exp_Ch6 is\n \n             Var := Make_Var (Expression (Actual));\n \n-            Crep := not Same_Representation\n-                          (F_Typ, Etype (Expression (Actual)));\n+            Crep := not Has_Compatible_Representation\n+                          (Target_Type  => F_Typ,\n+                           Operand_Type => Etype (Expression (Actual)));\n \n          else\n             V_Typ := Etype (Actual);\n@@ -2373,9 +2374,9 @@ package body Exp_Ch6 is\n \n                   --  Also pass by copy if change of representation\n \n-                  or else not Same_Representation\n-                                (Etype (Formal),\n-                                 Etype (Expression (Actual))))\n+                  or else not Has_Compatible_Representation\n+                                (Target_Type  => Etype (Formal),\n+                                 Operand_Type => Etype (Expression (Actual))))\n             then\n                Add_Call_By_Copy_Code;\n \n@@ -4801,7 +4802,10 @@ package body Exp_Ch6 is\n                   --  If there is a change of representation, then generate a\n                   --  warning, and do the change of representation.\n \n-                  elsif not Same_Representation (Formal_Typ, Parent_Typ) then\n+                  elsif not Has_Compatible_Representation\n+                              (Target_Type  => Formal_Typ,\n+                               Operand_Type => Parent_Typ)\n+                  then\n                      Error_Msg_N\n                        (\"??change of representation required\", Actual);\n                      Convert (Actual, Parent_Typ);"}, {"sha": "2439169cba956d2b668189b43562ce40f5f053a2", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -10556,6 +10556,13 @@ package body Sem_Attr is\n       --  Returns True if Declared_Entity is declared within the declarative\n       --  region of Generic_Unit; otherwise returns False.\n \n+      function Prefix_With_Safe_Accessibility_Level return Boolean;\n+      --  Return True if the prefix does not have a value conversion of an\n+      --  array because a value conversion is like an aggregate with respect\n+      --  to determining accessibility level (RM 3.10.2); even if evaluation\n+      --  of a value conversion is guaranteed to not create a new object,\n+      --  accessibility rules are defined as if it might.\n+\n       ---------------------------\n       -- Accessibility_Message --\n       ---------------------------\n@@ -10632,6 +10639,73 @@ package body Sem_Attr is\n          return False;\n       end Declared_Within_Generic_Unit;\n \n+      ------------------------------------------\n+      -- Prefix_With_Safe_Accessibility_Level --\n+      ------------------------------------------\n+\n+      function Prefix_With_Safe_Accessibility_Level return Boolean is\n+         function Safe_Value_Conversions return Boolean;\n+         --  Return False if the prefix has a value conversion of an array type\n+\n+         ----------------------------\n+         -- Safe_Value_Conversions --\n+         ----------------------------\n+\n+         function Safe_Value_Conversions return Boolean is\n+            PP : Node_Id := P;\n+\n+         begin\n+            loop\n+               if Nkind_In (PP, N_Selected_Component,\n+                                N_Indexed_Component)\n+               then\n+                  PP := Prefix (PP);\n+\n+               elsif Comes_From_Source (PP)\n+                 and then Nkind_In (PP, N_Type_Conversion,\n+                                        N_Unchecked_Type_Conversion)\n+                 and then Is_Array_Type (Etype (PP))\n+               then\n+                  return False;\n+\n+               elsif Comes_From_Source (PP)\n+                 and then Nkind (PP) = N_Qualified_Expression\n+                 and then Is_Array_Type (Etype (PP))\n+                 and then Nkind_In (Original_Node (Expression (PP)),\n+                             N_Aggregate,\n+                             N_Extension_Aggregate)\n+               then\n+                  return False;\n+\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end Safe_Value_Conversions;\n+\n+      --  Start of processing for Prefix_With_Safe_Accessibility_Level\n+\n+      begin\n+         --  No check required for unchecked and unrestricted access\n+\n+         if Attr_Id = Attribute_Unchecked_Access\n+           or else Attr_Id = Attribute_Unrestricted_Access\n+         then\n+            return True;\n+\n+         --  Check value conversions\n+\n+         elsif Ekind (Btyp) = E_General_Access_Type\n+           and then not Safe_Value_Conversions\n+         then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Prefix_With_Safe_Accessibility_Level;\n+\n    --  Start of processing for Resolve_Attribute\n \n    begin\n@@ -11473,6 +11547,15 @@ package body Sem_Attr is\n                end if;\n             end if;\n \n+            --  Check that the prefix does not have a value conversion of an\n+            --  array type since a value conversion is like an aggregate with\n+            --  respect to determining accessibility level (RM 3.10.2).\n+\n+            if not Prefix_With_Safe_Accessibility_Level then\n+               Accessibility_Message;\n+               return;\n+            end if;\n+\n             --  Mark that address of entity is taken in case of\n             --  'Unrestricted_Access or in case of a subprogram.\n "}, {"sha": "ec25e3d6eb43ff03257ba5d466cb12218c7659e1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 228, "deletions": 215, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -12792,6 +12792,234 @@ package body Sem_Ch13 is\n       end if;\n    end Get_Alignment_Value;\n \n+   -----------------------------------\n+   -- Has_Compatible_Representation --\n+   -----------------------------------\n+\n+   function Has_Compatible_Representation\n+     (Target_Type, Operand_Type : Entity_Id) return Boolean\n+   is\n+      T1 : constant Entity_Id := Underlying_Type (Target_Type);\n+      T2 : constant Entity_Id := Underlying_Type (Operand_Type);\n+\n+   begin\n+      --  A quick check, if base types are the same, then we definitely have\n+      --  the same representation, because the subtype specific representation\n+      --  attributes (Size and Alignment) do not affect representation from\n+      --  the point of view of this test.\n+\n+      if Base_Type (T1) = Base_Type (T2) then\n+         return True;\n+\n+      elsif Is_Private_Type (Base_Type (T2))\n+        and then Base_Type (T1) = Full_View (Base_Type (T2))\n+      then\n+         return True;\n+\n+      --  If T2 is a generic actual it is declared as a subtype, so\n+      --  check against its base type.\n+\n+      elsif Is_Generic_Actual_Type (T1)\n+        and then Has_Compatible_Representation (Base_Type (T1), T2)\n+      then\n+         return True;\n+      end if;\n+\n+      --  Tagged types always have the same representation, because it is not\n+      --  possible to specify different representations for common fields.\n+\n+      if Is_Tagged_Type (T1) then\n+         return True;\n+      end if;\n+\n+      --  Representations are definitely different if conventions differ\n+\n+      if Convention (T1) /= Convention (T2) then\n+         return False;\n+      end if;\n+\n+      --  Representations are different if component alignments or scalar\n+      --  storage orders differ.\n+\n+      if (Is_Record_Type (T1) or else Is_Array_Type (T1))\n+            and then\n+         (Is_Record_Type (T2) or else Is_Array_Type (T2))\n+        and then\n+         (Component_Alignment (T1) /= Component_Alignment (T2)\n+           or else Reverse_Storage_Order (T1) /= Reverse_Storage_Order (T2))\n+      then\n+         return False;\n+      end if;\n+\n+      --  For arrays, the only real issue is component size. If we know the\n+      --  component size for both arrays, and it is the same, then that's\n+      --  good enough to know we don't have a change of representation.\n+\n+      if Is_Array_Type (T1) then\n+\n+         --  In a view conversion, if the target type is an array type having\n+         --  aliased components and the operand type is an array type having\n+         --  unaliased components, then a new object is created (4.6(58.3/4)).\n+\n+         if Has_Aliased_Components (T1)\n+           and then not Has_Aliased_Components (T2)\n+         then\n+            return False;\n+         end if;\n+\n+         if Known_Component_Size (T1)\n+           and then Known_Component_Size (T2)\n+           and then Component_Size (T1) = Component_Size (T2)\n+         then\n+            return True;\n+         end if;\n+      end if;\n+\n+      --  For records, representations are different if reorderings differ\n+\n+      if Is_Record_Type (T1)\n+        and then Is_Record_Type (T2)\n+        and then No_Reordering (T1) /= No_Reordering (T2)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Types definitely have same representation if neither has non-standard\n+      --  representation since default representations are always consistent.\n+      --  If only one has non-standard representation, and the other does not,\n+      --  then we consider that they do not have the same representation. They\n+      --  might, but there is no way of telling early enough.\n+\n+      if Has_Non_Standard_Rep (T1) then\n+         if not Has_Non_Standard_Rep (T2) then\n+            return False;\n+         end if;\n+      else\n+         return not Has_Non_Standard_Rep (T2);\n+      end if;\n+\n+      --  Here the two types both have non-standard representation, and we need\n+      --  to determine if they have the same non-standard representation.\n+\n+      --  For arrays, we simply need to test if the component sizes are the\n+      --  same. Pragma Pack is reflected in modified component sizes, so this\n+      --  check also deals with pragma Pack.\n+\n+      if Is_Array_Type (T1) then\n+         return Component_Size (T1) = Component_Size (T2);\n+\n+      --  Case of record types\n+\n+      elsif Is_Record_Type (T1) then\n+\n+         --  Packed status must conform\n+\n+         if Is_Packed (T1) /= Is_Packed (T2) then\n+            return False;\n+\n+         --  Otherwise we must check components. Typ2 maybe a constrained\n+         --  subtype with fewer components, so we compare the components\n+         --  of the base types.\n+\n+         else\n+            Record_Case : declare\n+               CD1, CD2 : Entity_Id;\n+\n+               function Same_Rep return Boolean;\n+               --  CD1 and CD2 are either components or discriminants. This\n+               --  function tests whether they have the same representation.\n+\n+               --------------\n+               -- Same_Rep --\n+               --------------\n+\n+               function Same_Rep return Boolean is\n+               begin\n+                  if No (Component_Clause (CD1)) then\n+                     return No (Component_Clause (CD2));\n+                  else\n+                     --  Note: at this point, component clauses have been\n+                     --  normalized to the default bit order, so that the\n+                     --  comparison of Component_Bit_Offsets is meaningful.\n+\n+                     return\n+                        Present (Component_Clause (CD2))\n+                          and then\n+                        Component_Bit_Offset (CD1) = Component_Bit_Offset (CD2)\n+                          and then\n+                        Esize (CD1) = Esize (CD2);\n+                  end if;\n+               end Same_Rep;\n+\n+            --  Start of processing for Record_Case\n+\n+            begin\n+               if Has_Discriminants (T1) then\n+\n+                  --  The number of discriminants may be different if the\n+                  --  derived type has fewer (constrained by values). The\n+                  --  invisible discriminants retain the representation of\n+                  --  the original, so the discrepancy does not per se\n+                  --  indicate a different representation.\n+\n+                  CD1 := First_Discriminant (T1);\n+                  CD2 := First_Discriminant (T2);\n+                  while Present (CD1) and then Present (CD2) loop\n+                     if not Same_Rep then\n+                        return False;\n+                     else\n+                        Next_Discriminant (CD1);\n+                        Next_Discriminant (CD2);\n+                     end if;\n+                  end loop;\n+               end if;\n+\n+               CD1 := First_Component (Underlying_Type (Base_Type (T1)));\n+               CD2 := First_Component (Underlying_Type (Base_Type (T2)));\n+               while Present (CD1) loop\n+                  if not Same_Rep then\n+                     return False;\n+                  else\n+                     Next_Component (CD1);\n+                     Next_Component (CD2);\n+                  end if;\n+               end loop;\n+\n+               return True;\n+            end Record_Case;\n+         end if;\n+\n+      --  For enumeration types, we must check each literal to see if the\n+      --  representation is the same. Note that we do not permit enumeration\n+      --  representation clauses for Character and Wide_Character, so these\n+      --  cases were already dealt with.\n+\n+      elsif Is_Enumeration_Type (T1) then\n+         Enumeration_Case : declare\n+            L1, L2 : Entity_Id;\n+\n+         begin\n+            L1 := First_Literal (T1);\n+            L2 := First_Literal (T2);\n+            while Present (L1) loop\n+               if Enumeration_Rep (L1) /= Enumeration_Rep (L2) then\n+                  return False;\n+               else\n+                  Next_Literal (L1);\n+                  Next_Literal (L2);\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end Enumeration_Case;\n+\n+      --  Any other types have the same representation for these purposes\n+\n+      else\n+         return True;\n+      end if;\n+   end Has_Compatible_Representation;\n+\n    -------------------------------------\n    -- Inherit_Aspects_At_Freeze_Point --\n    -------------------------------------\n@@ -14657,221 +14885,6 @@ package body Sem_Ch13 is\n       end loop;\n    end Resolve_Aspect_Expressions;\n \n-   -------------------------\n-   -- Same_Representation --\n-   -------------------------\n-\n-   function Same_Representation (Typ1, Typ2 : Entity_Id) return Boolean is\n-      T1 : constant Entity_Id := Underlying_Type (Typ1);\n-      T2 : constant Entity_Id := Underlying_Type (Typ2);\n-\n-   begin\n-      --  A quick check, if base types are the same, then we definitely have\n-      --  the same representation, because the subtype specific representation\n-      --  attributes (Size and Alignment) do not affect representation from\n-      --  the point of view of this test.\n-\n-      if Base_Type (T1) = Base_Type (T2) then\n-         return True;\n-\n-      elsif Is_Private_Type (Base_Type (T2))\n-        and then Base_Type (T1) = Full_View (Base_Type (T2))\n-      then\n-         return True;\n-\n-      --  If T2 is a generic actual it is declared as a subtype, so\n-      --  check against its base type.\n-\n-      elsif Is_Generic_Actual_Type (T1)\n-        and then Same_Representation (Base_Type (T1), T2)\n-      then\n-         return True;\n-      end if;\n-\n-      --  Tagged types always have the same representation, because it is not\n-      --  possible to specify different representations for common fields.\n-\n-      if Is_Tagged_Type (T1) then\n-         return True;\n-      end if;\n-\n-      --  Representations are definitely different if conventions differ\n-\n-      if Convention (T1) /= Convention (T2) then\n-         return False;\n-      end if;\n-\n-      --  Representations are different if component alignments or scalar\n-      --  storage orders differ.\n-\n-      if (Is_Record_Type (T1) or else Is_Array_Type (T1))\n-            and then\n-         (Is_Record_Type (T2) or else Is_Array_Type (T2))\n-        and then\n-         (Component_Alignment (T1) /= Component_Alignment (T2)\n-           or else Reverse_Storage_Order (T1) /= Reverse_Storage_Order (T2))\n-      then\n-         return False;\n-      end if;\n-\n-      --  For arrays, the only real issue is component size. If we know the\n-      --  component size for both arrays, and it is the same, then that's\n-      --  good enough to know we don't have a change of representation.\n-\n-      if Is_Array_Type (T1) then\n-         if Known_Component_Size (T1)\n-           and then Known_Component_Size (T2)\n-           and then Component_Size (T1) = Component_Size (T2)\n-         then\n-            return True;\n-         end if;\n-      end if;\n-\n-      --  For records, representations are different if reorderings differ\n-\n-      if Is_Record_Type (T1)\n-        and then Is_Record_Type (T2)\n-        and then No_Reordering (T1) /= No_Reordering (T2)\n-      then\n-         return False;\n-      end if;\n-\n-      --  Types definitely have same representation if neither has non-standard\n-      --  representation since default representations are always consistent.\n-      --  If only one has non-standard representation, and the other does not,\n-      --  then we consider that they do not have the same representation. They\n-      --  might, but there is no way of telling early enough.\n-\n-      if Has_Non_Standard_Rep (T1) then\n-         if not Has_Non_Standard_Rep (T2) then\n-            return False;\n-         end if;\n-      else\n-         return not Has_Non_Standard_Rep (T2);\n-      end if;\n-\n-      --  Here the two types both have non-standard representation, and we need\n-      --  to determine if they have the same non-standard representation.\n-\n-      --  For arrays, we simply need to test if the component sizes are the\n-      --  same. Pragma Pack is reflected in modified component sizes, so this\n-      --  check also deals with pragma Pack.\n-\n-      if Is_Array_Type (T1) then\n-         return Component_Size (T1) = Component_Size (T2);\n-\n-      --  Case of record types\n-\n-      elsif Is_Record_Type (T1) then\n-\n-         --  Packed status must conform\n-\n-         if Is_Packed (T1) /= Is_Packed (T2) then\n-            return False;\n-\n-         --  Otherwise we must check components. Typ2 maybe a constrained\n-         --  subtype with fewer components, so we compare the components\n-         --  of the base types.\n-\n-         else\n-            Record_Case : declare\n-               CD1, CD2 : Entity_Id;\n-\n-               function Same_Rep return Boolean;\n-               --  CD1 and CD2 are either components or discriminants. This\n-               --  function tests whether they have the same representation.\n-\n-               --------------\n-               -- Same_Rep --\n-               --------------\n-\n-               function Same_Rep return Boolean is\n-               begin\n-                  if No (Component_Clause (CD1)) then\n-                     return No (Component_Clause (CD2));\n-                  else\n-                     --  Note: at this point, component clauses have been\n-                     --  normalized to the default bit order, so that the\n-                     --  comparison of Component_Bit_Offsets is meaningful.\n-\n-                     return\n-                        Present (Component_Clause (CD2))\n-                          and then\n-                        Component_Bit_Offset (CD1) = Component_Bit_Offset (CD2)\n-                          and then\n-                        Esize (CD1) = Esize (CD2);\n-                  end if;\n-               end Same_Rep;\n-\n-            --  Start of processing for Record_Case\n-\n-            begin\n-               if Has_Discriminants (T1) then\n-\n-                  --  The number of discriminants may be different if the\n-                  --  derived type has fewer (constrained by values). The\n-                  --  invisible discriminants retain the representation of\n-                  --  the original, so the discrepancy does not per se\n-                  --  indicate a different representation.\n-\n-                  CD1 := First_Discriminant (T1);\n-                  CD2 := First_Discriminant (T2);\n-                  while Present (CD1) and then Present (CD2) loop\n-                     if not Same_Rep then\n-                        return False;\n-                     else\n-                        Next_Discriminant (CD1);\n-                        Next_Discriminant (CD2);\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-               CD1 := First_Component (Underlying_Type (Base_Type (T1)));\n-               CD2 := First_Component (Underlying_Type (Base_Type (T2)));\n-               while Present (CD1) loop\n-                  if not Same_Rep then\n-                     return False;\n-                  else\n-                     Next_Component (CD1);\n-                     Next_Component (CD2);\n-                  end if;\n-               end loop;\n-\n-               return True;\n-            end Record_Case;\n-         end if;\n-\n-      --  For enumeration types, we must check each literal to see if the\n-      --  representation is the same. Note that we do not permit enumeration\n-      --  representation clauses for Character and Wide_Character, so these\n-      --  cases were already dealt with.\n-\n-      elsif Is_Enumeration_Type (T1) then\n-         Enumeration_Case : declare\n-            L1, L2 : Entity_Id;\n-\n-         begin\n-            L1 := First_Literal (T1);\n-            L2 := First_Literal (T2);\n-            while Present (L1) loop\n-               if Enumeration_Rep (L1) /= Enumeration_Rep (L2) then\n-                  return False;\n-               else\n-                  Next_Literal (L1);\n-                  Next_Literal (L2);\n-               end if;\n-            end loop;\n-\n-            return True;\n-         end Enumeration_Case;\n-\n-      --  Any other types have the same representation for these purposes\n-\n-      else\n-         return True;\n-      end if;\n-   end Same_Representation;\n-\n    ----------------------------\n    -- Parse_Aspect_Aggregate --\n    ----------------------------"}, {"sha": "3d24c04d1a89ee0984a141863dea0c06c2e169a8", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -128,6 +128,14 @@ package Sem_Ch13 is\n    --  If the size is too small, and an error message is given, then both\n    --  Esize and RM_Size are reset to the allowed minimum value in T.\n \n+   function Has_Compatible_Representation\n+     (Target_Type, Operand_Type : Entity_Id) return Boolean;\n+   --  Given two types, where the two types are related by possible derivation,\n+   --  determines if the two types have compatible representation, or different\n+   --  representations, requiring the special processing for representation\n+   --  change. A False result is possible only for array, enumeration or\n+   --  record types.\n+\n    procedure Parse_Aspect_Aggregate\n      (N                   : Node_Id;\n       Empty_Subp          : in out Node_Id;\n@@ -196,13 +204,6 @@ package Sem_Ch13 is\n    --  because such clauses are linked on to the Rep_Item chain in procedure\n    --  Sem_Ch13.Analyze_Aspect_Specifications. See that procedure for details.\n \n-   function Same_Representation (Typ1, Typ2 : Entity_Id) return Boolean;\n-   --  Given two types, where the two types are related by possible derivation,\n-   --  determines if the two types have the same representation, or different\n-   --  representations, requiring the special processing for representation\n-   --  change. A False result is possible only for array, enumeration or\n-   --  record types.\n-\n    procedure Validate_Unchecked_Conversion\n      (N        : Node_Id;\n       Act_Unit : Entity_Id);"}, {"sha": "bf4774c44910a9f682d391333cc6d2ca919e5d9c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3968b02a4b1dd783b6a8376175061adc195110f4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=3968b02a4b1dd783b6a8376175061adc195110f4", "patch": "@@ -4118,25 +4118,9 @@ package body Sem_Res is\n                   if Ekind (F) = E_In_Out_Parameter\n                     and then Is_Array_Type (Etype (F))\n                   then\n-                     --  In a view conversion, the conversion must be legal in\n-                     --  both directions, and thus both component types must be\n-                     --  aliased, or neither (4.6 (8)).\n-\n-                     --  The extra rule in 4.6 (24.9.2) seems unduly\n-                     --  restrictive: the privacy requirement should not apply\n-                     --  to generic types, and should be checked in an\n-                     --  instance. ARG query is in order ???\n-\n-                     if Has_Aliased_Components (Expr_Typ) /=\n-                        Has_Aliased_Components (Etype (F))\n-                     then\n-                        Error_Msg_N\n-                          (\"both component types in a view conversion must be\"\n-                            & \" aliased, or neither\", A);\n-\n                      --  Comment here??? what set of cases???\n \n-                     elsif not Same_Ancestor (Etype (F), Expr_Typ) then\n+                     if not Same_Ancestor (Etype (F), Expr_Typ) then\n                         --  Check view conv between unrelated by ref array\n                         --  types.\n "}]}