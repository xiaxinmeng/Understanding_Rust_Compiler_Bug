{"sha": "4efab40251962a2343621aef21450c880e939e0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVmYWI0MDI1MTk2MmEyMzQzNjIxYWVmMjE0NTBjODgwZTkzOWUwZQ==", "commit": {"author": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2015-09-03T05:28:46Z"}, "committer": {"name": "Sebastian Huber", "email": "sh@gcc.gnu.org", "date": "2015-09-03T05:28:46Z"}, "message": "RTEMS: Update RTEMS thread model\n\nlibgcc/ChangeLog\n\n\t* config/gthr-rtems.h (__GTHREADS_CXX0X): New.\n\t(__GTHREAD_HAS_COND): Likewise.\n\t(__gthread_t): Likewise.\n\t(__gthread_cond_t): Likewise.\n\t(__gthread_time_t): Likewise.\n\t(__GTHREAD_MUTEX_INIT): Likewise.\n\t(__GTHREAD_RECURSIVE_MUTEX_INIT): Likewise.\n\t(__GTHREAD_COND_INIT): Likewise.\n\t(__GTHREAD_COND_INIT_FUNCTION): Likewise.\n\t(__GTHREAD_TIME_INIT): Likewise.\n\t(__gthread_create): Likewise.\n\t(__gthread_join): Likewise.\n\t(__gthread_detach): Likewise.\n\t(__gthread_equal): Likewise.\n\t(__gthread_self): Likewise.\n\t(__gthread_yield): Likewise.\n\t(__gthread_cond_broadcast): Likewise.\n\t(__gthread_cond_signal): Likewise.\n\t(__gthread_cond_wait): Likewise.\n\t(__gthread_cond_timedwait): Likewise.\n\t(__gthread_cond_wait_recursive): Likewise.\n\t(__gthread_cond_destroy): Likewise.\n\t(rtems_gxx_once): Delete.\n\t(rtems_gxx_key_create): Likewise.\n\t(rtems_gxx_key_delete): Likewise.\n\t(rtems_gxx_getspecific): Likewise.\n\t(rtems_gxx_setspecific): Likewise.\n\t(rtems_gxx_mutex_init): Likewise.\n\t(rtems_gxx_mutex_destroy): Likewise.\n\t(rtems_gxx_mutex_lock): Likewise.\n\t(rtems_gxx_mutex_trylock): Likewise.\n\t(rtems_gxx_mutex_unlock): Likewise.\n\t(rtems_gxx_recursive_mutex_init): Likewise.\n\t(rtems_gxx_recursive_mutex_lock): Likewise.\n\t(rtems_gxx_recursive_mutex_trylock): Likewise.\n\t(rtems_gxx_recursive_mutex_unlock): Likewise.\n\t(__GTHREAD_ONCE_INIT): Use <pthread.h> initializer.\n\t(__GTHREAD_MUTEX_INIT_FUNCTION): Use <pthread.h> function.\n\t(__GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION): Likewise.\n\t(__gthread_once): Likewise.\n\t(__gthread_key_create): Likewise.\n\t(__gthread_key_delete): Likewise.\n\t(__gthread_getspecific): Likewise.\n\t(__gthread_setspecific): Likewise.\n\t(__gthread_key_t): Use <pthread.h> type.\n\t(__gthread_once_t): Likewise\n\t(__gthread_mutex_t): Use <sys/lock.h> type.\n\t(__gthread_recursive_mutex_t): Likewise\n\t(__gthread_mutex_lock): Use <sys/lock.h> function.\n\t(__gthread_mutex_trylock): Likewise.\n\t(__gthread_mutex_timedlock): Likewise.\n\t(__gthread_mutex_unlock): Likewise.\n\t(__gthread_mutex_destroy): Likewise.\n\t(__gthread_recursive_mutex_lock): Likewise.\n\t(__gthread_recursive_mutex_trylock): Likewise.\n\t(__gthread_recursive_mutex_timedlock): Likewise.\n\t(__gthread_recursive_mutex_unlock): Likewise.\n\t(__gthread_recursive_mutex_destroy): Likewise.\n\nFrom-SVN: r227428", "tree": {"sha": "70b03910b43a6e96bed36b84b1e488399b92f59f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70b03910b43a6e96bed36b84b1e488399b92f59f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4efab40251962a2343621aef21450c880e939e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efab40251962a2343621aef21450c880e939e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4efab40251962a2343621aef21450c880e939e0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efab40251962a2343621aef21450c880e939e0e/comments", "author": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc253334957be7816edb209dcc25907c624a02f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc253334957be7816edb209dcc25907c624a02f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc253334957be7816edb209dcc25907c624a02f0"}], "stats": {"total": 256, "additions": 200, "deletions": 56}, "files": [{"sha": "bca8328b831610b50c083564493dd2bd1e5ce889", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efab40251962a2343621aef21450c880e939e0e/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efab40251962a2343621aef21450c880e939e0e/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=4efab40251962a2343621aef21450c880e939e0e", "patch": "@@ -1,3 +1,64 @@\n+2015-09-03  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n+\n+\t* config/gthr-rtems.h (__GTHREADS_CXX0X): New.\n+\t(__GTHREAD_HAS_COND): Likewise.\n+\t(__gthread_t): Likewise.\n+\t(__gthread_cond_t): Likewise.\n+\t(__gthread_time_t): Likewise.\n+\t(__GTHREAD_MUTEX_INIT): Likewise.\n+\t(__GTHREAD_RECURSIVE_MUTEX_INIT): Likewise.\n+\t(__GTHREAD_COND_INIT): Likewise.\n+\t(__GTHREAD_COND_INIT_FUNCTION): Likewise.\n+\t(__GTHREAD_TIME_INIT): Likewise.\n+\t(__gthread_create): Likewise.\n+\t(__gthread_join): Likewise.\n+\t(__gthread_detach): Likewise.\n+\t(__gthread_equal): Likewise.\n+\t(__gthread_self): Likewise.\n+\t(__gthread_yield): Likewise.\n+\t(__gthread_cond_broadcast): Likewise.\n+\t(__gthread_cond_signal): Likewise.\n+\t(__gthread_cond_wait): Likewise.\n+\t(__gthread_cond_timedwait): Likewise.\n+\t(__gthread_cond_wait_recursive): Likewise.\n+\t(__gthread_cond_destroy): Likewise.\n+\t(rtems_gxx_once): Delete.\n+\t(rtems_gxx_key_create): Likewise.\n+\t(rtems_gxx_key_delete): Likewise.\n+\t(rtems_gxx_getspecific): Likewise.\n+\t(rtems_gxx_setspecific): Likewise.\n+\t(rtems_gxx_mutex_init): Likewise.\n+\t(rtems_gxx_mutex_destroy): Likewise.\n+\t(rtems_gxx_mutex_lock): Likewise.\n+\t(rtems_gxx_mutex_trylock): Likewise.\n+\t(rtems_gxx_mutex_unlock): Likewise.\n+\t(rtems_gxx_recursive_mutex_init): Likewise.\n+\t(rtems_gxx_recursive_mutex_lock): Likewise.\n+\t(rtems_gxx_recursive_mutex_trylock): Likewise.\n+\t(rtems_gxx_recursive_mutex_unlock): Likewise.\n+\t(__GTHREAD_ONCE_INIT): Use <pthread.h> initializer.\n+\t(__GTHREAD_MUTEX_INIT_FUNCTION): Use <pthread.h> function.\n+\t(__GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION): Likewise.\n+\t(__gthread_once): Likewise.\n+\t(__gthread_key_create): Likewise.\n+\t(__gthread_key_delete): Likewise.\n+\t(__gthread_getspecific): Likewise.\n+\t(__gthread_setspecific): Likewise.\n+\t(__gthread_key_t): Use <pthread.h> type.\n+\t(__gthread_once_t): Likewise\n+\t(__gthread_mutex_t): Use <sys/lock.h> type.\n+\t(__gthread_recursive_mutex_t): Likewise\n+\t(__gthread_mutex_lock): Use <sys/lock.h> function.\n+\t(__gthread_mutex_trylock): Likewise.\n+\t(__gthread_mutex_timedlock): Likewise.\n+\t(__gthread_mutex_unlock): Likewise.\n+\t(__gthread_mutex_destroy): Likewise.\n+\t(__gthread_recursive_mutex_lock): Likewise.\n+\t(__gthread_recursive_mutex_trylock): Likewise.\n+\t(__gthread_recursive_mutex_timedlock): Likewise.\n+\t(__gthread_recursive_mutex_unlock): Likewise.\n+\t(__gthread_recursive_mutex_destroy): Likewise.\n+\n 2015-08-18  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/xtensa/unwind-dw2-xtensa.c (_Unwind_GetCFA): Return"}, {"sha": "1aff329d5d065b9b57e0268d209fc0d183343fa9", "filename": "libgcc/config/gthr-rtems.h", "status": "modified", "additions": 139, "deletions": 56, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efab40251962a2343621aef21450c880e939e0e/libgcc%2Fconfig%2Fgthr-rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efab40251962a2343621aef21450c880e939e0e/libgcc%2Fconfig%2Fgthr-rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-rtems.h?ref=4efab40251962a2343621aef21450c880e939e0e", "patch": "@@ -27,134 +27,217 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef GCC_GTHR_RTEMS_H\n #define GCC_GTHR_RTEMS_H\n \n+#include <sys/lock.h>\n+#include <pthread.h>\n+#include <sched.h>\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n #define __GTHREADS 1\n+#define __GTHREADS_CXX0X 1\n+#define __GTHREAD_HAS_COND 1\n+\n+typedef pthread_t __gthread_t;\n+typedef pthread_key_t __gthread_key_t;\n+typedef pthread_once_t __gthread_once_t;\n+typedef struct _Mutex_Control __gthread_mutex_t;\n+typedef struct _Mutex_recursive_Control __gthread_recursive_mutex_t;\n+typedef struct _Condition_Control __gthread_cond_t;\n+typedef struct timespec __gthread_time_t;\n+\n+#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n+#define __GTHREAD_MUTEX_INIT _MUTEX_INITIALIZER\n+#define __GTHREAD_MUTEX_INIT_FUNCTION _Mutex_Initialize\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT _MUTEX_RECURSIVE_INITIALIZER\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION _Mutex_recursive_Initialize\n+#define __GTHREAD_COND_INIT _CONDITION_INITIALIZER\n+#define __GTHREAD_COND_INIT_FUNCTION _Condition_Initialize\n+#define __GTHREAD_TIME_INIT {0, 0}\n \n-#define __GTHREAD_ONCE_INIT  0\n-#define __GTHREAD_MUTEX_INIT_FUNCTION  rtems_gxx_mutex_init\n-#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION  rtems_gxx_recursive_mutex_init\n-\n-/* Avoid dependency on rtems specific headers.  */\n-typedef void *__gthread_key_t;\n-typedef int   __gthread_once_t;\n-typedef void *__gthread_mutex_t;\n-typedef void *__gthread_recursive_mutex_t;\n-\n-/*\n- * External functions provided by RTEMS. They are very similar to their POSIX\n- * counterparts. A \"Wrapper API\" is being use to avoid dependency on any RTEMS\n- * header files.\n- */\n-\n-/* generic per task variables */\n-extern int rtems_gxx_once (__gthread_once_t *__once, void (*__func) (void));\n-extern int rtems_gxx_key_create (__gthread_key_t *__key, void (*__dtor) (void *));\n-extern int rtems_gxx_key_delete (__gthread_key_t __key);\n-extern void *rtems_gxx_getspecific (__gthread_key_t __key);\n-extern int rtems_gxx_setspecific (__gthread_key_t __key, const void *__ptr);\n-\n-/* mutex support */\n-extern void rtems_gxx_mutex_init (__gthread_mutex_t *__mutex);\n-extern int rtems_gxx_mutex_destroy (__gthread_mutex_t *__mutex);\n-extern int rtems_gxx_mutex_lock (__gthread_mutex_t *__mutex);\n-extern int rtems_gxx_mutex_trylock (__gthread_mutex_t *__mutex);\n-extern int rtems_gxx_mutex_unlock (__gthread_mutex_t *__mutex);\n-\n-/* recursive mutex support */\n-extern void rtems_gxx_recursive_mutex_init (__gthread_recursive_mutex_t *__mutex);\n-extern int rtems_gxx_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex);\n-extern int rtems_gxx_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex);\n-extern int rtems_gxx_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex);\n-\n-/* RTEMS threading is always active */\n static inline int\n __gthread_active_p (void)\n {\n   return 1;\n }\n \n-/* Wrapper calls */\n+static inline int\n+__gthread_create (__gthread_t *__threadid, void *(*__func) (void *),\n+\t\t  void *__args)\n+{\n+  return pthread_create (__threadid, NULL, __func, __args);\n+}\n+\n+static inline int\n+__gthread_join (__gthread_t __threadid, void **__value_ptr)\n+{\n+  return pthread_join (__threadid, __value_ptr);\n+}\n+\n+static inline int\n+__gthread_detach (__gthread_t __threadid)\n+{\n+  return pthread_detach (__threadid);\n+}\n+\n+static inline int\n+__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n+{\n+  return pthread_equal (__t1, __t2);\n+}\n+\n+static inline __gthread_t\n+__gthread_self (void)\n+{\n+  return pthread_self ();\n+}\n+\n+static inline int\n+__gthread_yield (void)\n+{\n+  return sched_yield ();\n+}\n+\n static inline int\n __gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n-   return rtems_gxx_once( __once, __func );\n+   return pthread_once (__once, __func);\n }\n \n static inline int\n __gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n {\n-  return rtems_gxx_key_create( __key, __dtor );\n+  return pthread_key_create (__key, __dtor);\n }\n \n static inline int\n __gthread_key_delete (__gthread_key_t __key)\n {\n-  return rtems_gxx_key_delete (__key);\n+  return pthread_key_delete (__key);\n }\n \n static inline void *\n __gthread_getspecific (__gthread_key_t __key)\n {\n-  return rtems_gxx_getspecific (__key);\n+  return pthread_getspecific (__key);\n }\n \n static inline int\n __gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  return rtems_gxx_setspecific (__key, __ptr);\n+  return pthread_setspecific (__key, __ptr);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n+__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n-  return rtems_gxx_mutex_destroy (__mutex);\n+  _Mutex_Acquire (__mutex);\n+  return 0;\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n {\n-    return rtems_gxx_mutex_lock (__mutex);\n+  return _Mutex_Try_acquire (__mutex);\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n+__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,\n+\t\t\t   const __gthread_time_t *__abs_timeout)\n {\n-    return rtems_gxx_mutex_trylock (__mutex);\n+  return _Mutex_Acquire_timed (__mutex, __abs_timeout);\n }\n \n static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n-    return rtems_gxx_mutex_unlock( __mutex );\n+  _Mutex_Release (__mutex);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n+{\n+  _Mutex_Destroy (__mutex);\n+  return 0;\n }\n \n static inline int\n __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_lock (__mutex);\n+  _Mutex_recursive_Acquire (__mutex);\n+  return 0;\n }\n \n static inline int\n __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_trylock (__mutex);\n+  return _Mutex_recursive_Try_acquire (__mutex);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,\n+\t\t\t\t     const __gthread_time_t *__abs_timeout)\n+{\n+  return _Mutex_recursive_Acquire_timed (__mutex, __abs_timeout);\n }\n \n static inline int\n __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-    return rtems_gxx_recursive_mutex_unlock( __mutex );\n+  _Mutex_recursive_Release (__mutex);\n+  return 0;\n }\n \n static inline int\n __gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n {\n-  /* This requires that recursive and non-recursive mutexes have the same\n-     representation.  */\n-    return rtems_gxx_mutex_destroy (__mutex );\n+  _Mutex_recursive_Destroy (__mutex);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_broadcast (__gthread_cond_t *__cond)\n+{\n+  _Condition_Broadcast (__cond);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_signal (__gthread_cond_t *__cond)\n+{\n+  _Condition_Signal (__cond);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n+{\n+  _Condition_Wait (__cond, __mutex);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,\n+\t\t\t  const __gthread_time_t *__abs_timeout)\n+{\n+  return _Condition_Wait_timed (__cond, __mutex, __abs_timeout);\n+}\n+\n+static inline int\n+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n+\t\t\t       __gthread_recursive_mutex_t *__mutex)\n+{\n+  _Condition_Wait_recursive (__cond, __mutex);\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_destroy (__gthread_cond_t *__cond)\n+{\n+  _Condition_Destroy (__cond);\n+  return 0;\n }\n \n #ifdef __cplusplus"}]}