{"sha": "0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5YTQ0NWI5ZGZkNzU0YWVjOWJmNTNjZTkwNmM0OTNmNmI3NGQyNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-07T07:20:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-07T07:20:39Z"}, "message": "re PR fortran/23091 (ICE in gfc_trans_auto_array_allocation)\n\n2006-06-07  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23091\n\t* resolve.c (resolve_fl_variable): Error if an automatic\n\tobject has the SAVE attribute.\n\n\tPR fortran/24168\n\t* expr.c (simplify_intrinsic_op): Transfer the rank and\n\tthe locus to the simplified expression.\n\n\tPR fortran/25090\n\tPR fortran/25058\n\t* gfortran.h : Add int entry_id to gfc_symbol.\n\t* resolve.c : Add static variables current_entry_id and\n\tspecification_expr.\n\t(resolve_variable): During code resolution, check if a\n\treference to a dummy variable in an executable expression\n\tis preceded by its appearance as a parameter in an entry.\n\tLikewise check its specification expressions.\n\t(resolve_code): Update current_entry_id on EXEC_ENTRY.\n\t(resolve_charlen, resolve_fl_variable): Set and reset\n\tspecifiaction_expr.\n\t(is_non_constant_shape_array): Do not return on detection\n\tof a variable but continue to resolve all the expressions.\n\t(resolve_codes): set current_entry_id to an out of range\n\tvalue.\n\n2006-06-07  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23091\n\t* gfortran.dg/saved_automatic_1.f90: New test.\n\n\tPR fortran/24168\n\t* gfortran.dg/array_simplify_1.f90: New test.\n\n\tPR fortran/25090\n\t* gfortran.dg/entry_dummy_ref_1.f90: New test.\n\n\tPR fortran/25058\n\t* gfortran.dg/entry_dummy_ref_2.f90: New test.\n\nFrom-SVN: r114461", "tree": {"sha": "eeff6ac2359b106d08f0028ad7aec90547a5e62c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeff6ac2359b106d08f0028ad7aec90547a5e62c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/comments", "author": null, "committer": null, "parents": [{"sha": "d95c1c488a438af4c077b2f8eb1e940199e98e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95c1c488a438af4c077b2f8eb1e940199e98e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95c1c488a438af4c077b2f8eb1e940199e98e59"}], "stats": {"total": 257, "additions": 243, "deletions": 14}, "files": [{"sha": "23e50d1e0b8ef1dacc89c6bd77e03bf6796ef2bb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -1,3 +1,30 @@\n+2006-06-07  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23091\n+\t* resolve.c (resolve_fl_variable): Error if an automatic\n+\tobject has the SAVE attribute.\n+\n+\tPR fortran/24168\n+\t* expr.c (simplify_intrinsic_op): Transfer the rank and\n+\tthe locus to the simplified expression.\n+\n+\tPR fortran/25090\n+\tPR fortran/25058\n+\t* gfortran.h : Add int entry_id to gfc_symbol.\n+\t* resolve.c : Add static variables current_entry_id and\n+\tspecification_expr.\n+\t(resolve_variable): During code resolution, check if a\n+\treference to a dummy variable in an executable expression\n+\tis preceded by its appearance as a parameter in an entry.\n+\tLikewise check its specification expressions.\n+\t(resolve_code): Update current_entry_id on EXEC_ENTRY.\n+\t(resolve_charlen, resolve_fl_variable): Set and reset\n+\tspecifiaction_expr.\n+\t(is_non_constant_shape_array): Do not return on detection\n+\tof a variable but continue to resolve all the expressions.\n+\t(resolve_codes): set current_entry_id to an out of range\n+\tvalue.\n+\n 2006-06-06  Mike Stump  <mrs@apple.com>\n \n \t* Make-lang.in: Rename to htmldir to build_htmldir to avoid"}, {"sha": "a1631510aa657bd9052c7afeaf7abcbbfc2bc3fc", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -869,6 +869,8 @@ simplify_intrinsic_op (gfc_expr * p, int type)\n       return FAILURE;\n     }\n \n+  result->rank = p->rank;\n+  result->where = p->where;\n   gfc_replace_expr (p, result);\n \n   return SUCCESS;"}, {"sha": "6cfd93498fff148bdf6b39a7e92e571f3064aa19", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -838,6 +838,8 @@ typedef struct gfc_symbol\n      order.  */\n   int dummy_order;\n \n+  int entry_id;\n+\n   gfc_namelist *namelist, *namelist_tail;\n \n   /* Change management fields.  Symbols that might be modified by the"}, {"sha": "33e21df4ee8aaea3933141f3234e71a19b04c3fd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 126, "deletions": 14, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -60,6 +60,12 @@ static int omp_workshare_flag;\n    resets the flag each time that it is read.  */\n static int formal_arg_flag = 0;\n \n+/* True if we are resolving a specification expression.  */\n+static int specification_expr = 0;\n+\n+/* The id of the last entry seen.  */\n+static int current_entry_id;\n+\n int\n gfc_is_formal_arg (void)\n {\n@@ -2763,6 +2769,9 @@ static try\n resolve_variable (gfc_expr * e)\n {\n   gfc_symbol *sym;\n+  try t;\n+\n+  t = SUCCESS;\n \n   if (e->ref && resolve_ref (e) == FAILURE)\n     return FAILURE;\n@@ -2790,7 +2799,73 @@ resolve_variable (gfc_expr * e)\n   if (check_assumed_size_reference (sym, e))\n     return FAILURE;\n \n-  return SUCCESS;\n+  /* Deal with forward references to entries during resolve_code, to\n+     satisfy, at least partially, 12.5.2.5.  */\n+  if (gfc_current_ns->entries\n+\t&& current_entry_id == sym->entry_id\n+\t&& cs_base\n+\t&& cs_base->current\n+\t&& cs_base->current->op != EXEC_ENTRY)\n+    {\n+      gfc_entry_list *entry;\n+      gfc_formal_arglist *formal;\n+      int n;\n+      bool seen;\n+\n+      /* If the symbol is a dummy...  */\n+      if (sym->attr.dummy)\n+\t{\n+\t  entry = gfc_current_ns->entries;\n+\t  seen = false;\n+\n+\t  /* ...test if the symbol is a parameter of previous entries.  */\n+\t  for (; entry && entry->id <= current_entry_id; entry = entry->next)\n+\t    for (formal = entry->sym->formal; formal; formal = formal->next)\n+\t      {\n+\t\tif (formal->sym && sym->name == formal->sym->name)\n+\t\t  seen = true;\n+\t      }\n+\n+\t  /*  If it has not been seen as a dummy, this is an error.  */\n+\t  if (!seen)\n+\t    {\n+\t      if (specification_expr)\n+\t\tgfc_error (\"Variable '%s',used in a specification expression, \"\n+\t\t\t   \"is referenced at %L before the ENTRY statement \"\n+\t\t\t   \"in which it is a parameter\",\n+\t\t\t   sym->name, &cs_base->current->loc);\n+\t      else\n+\t\tgfc_error (\"Variable '%s' is used at %L before the ENTRY \"\n+\t\t\t   \"statement in which it is a parameter\",\n+\t\t\t   sym->name, &cs_base->current->loc);\n+\t      t = FAILURE;\n+\t    }\n+\t}\n+\n+      /* Now do the same check on the specification expressions.  */\n+      specification_expr = 1;\n+      if (sym->ts.type == BT_CHARACTER\n+\t    && gfc_resolve_expr (sym->ts.cl->length) == FAILURE)\n+\tt = FAILURE;\n+\n+      if (sym->as)\n+\tfor (n = 0; n < sym->as->rank; n++)\n+\t  {\n+\t     specification_expr = 1;\n+\t     if (gfc_resolve_expr (sym->as->lower[n]) == FAILURE)\n+\t       t = FAILURE;\n+\t     specification_expr = 1;\n+\t     if (gfc_resolve_expr (sym->as->upper[n]) == FAILURE)\n+\t       t = FAILURE;\n+\t  }\n+      specification_expr = 0;\n+\n+      if (t == SUCCESS)\n+\t/* Update the symbol's entry level.  */\n+\tsym->entry_id = current_entry_id + 1;\n+    }\n+\n+  return t;\n }\n \n \n@@ -4490,7 +4565,11 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \tcase EXEC_EXIT:\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:\n+\t  break;\n+\n \tcase EXEC_ENTRY:\n+\t  /* Keep track of which entry we are up to.  */\n+\t  current_entry_id = code->ext.entry->id;\n \t  break;\n \n \tcase EXEC_WHERE:\n@@ -4769,7 +4848,6 @@ resolve_values (gfc_symbol * sym)\n static try\n resolve_index_expr (gfc_expr * e)\n {\n-\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n@@ -4792,8 +4870,13 @@ resolve_charlen (gfc_charlen *cl)\n \n   cl->resolved = 1;\n \n+  specification_expr = 1;\n+\n   if (resolve_index_expr (cl->length) == FAILURE)\n-    return FAILURE;\n+    {\n+      specification_expr = 0;\n+      return FAILURE;\n+    }\n \n   return SUCCESS;\n }\n@@ -4806,7 +4889,9 @@ is_non_constant_shape_array (gfc_symbol *sym)\n {\n   gfc_expr *e;\n   int i;\n+  bool not_constant;\n \n+  not_constant = false;\n   if (sym->as != NULL)\n     {\n       /* Unfortunately, !gfc_is_compile_time_shape hits a legal case that\n@@ -4817,15 +4902,15 @@ is_non_constant_shape_array (gfc_symbol *sym)\n \t  e = sym->as->lower[i];\n \t  if (e && (resolve_index_expr (e) == FAILURE\n \t\t|| !gfc_is_constant_expr (e)))\n-\t    return true;\n+\t    not_constant = true;\n \n \t  e = sym->as->upper[i];\n \t  if (e && (resolve_index_expr (e) == FAILURE\n \t\t|| !gfc_is_constant_expr (e)))\n-\t    return true;\n+\t    not_constant = true;\n \t}\n     }\n-  return false;\n+  return not_constant;\n }\n \n /* Resolution of common features of flavors variable and procedure. */\n@@ -4877,22 +4962,34 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   int i;\n   gfc_expr *e;\n   gfc_expr *constructor_expr;\n+  const char * auto_save_msg;\n+\n+  auto_save_msg = \"automatic object '%s' at %L cannot have the \"\n+\t\t  \"SAVE attribute\";\n \n   if (resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n-  /* The shape of a main program or module array needs to be constant.  */\n-  if (sym->ns->proc_name\n-\t&& (sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t     || sym->ns->proc_name->attr.is_main_program)\n-\t&& !sym->attr.use_assoc\n+  /* Set this flag to check that variables are parameters of all entries.\n+     This check is effected by the call to gfc_resolve_expr through\n+     is_non_constant_shape_array.  */\n+  specification_expr = 1;\n+\n+  if (!sym->attr.use_assoc\n \t&& !sym->attr.allocatable\n \t&& !sym->attr.pointer\n \t&& is_non_constant_shape_array (sym))\n     {\n-       gfc_error (\"The module or main program array '%s' at %L must \"\n-\t\t     \"have constant shape\", sym->name, &sym->declared_at);\n-\t  return FAILURE;\n+\t/* The shape of a main program or module array needs to be constant.  */\n+\tif (sym->ns->proc_name\n+\t      && (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t\t    || sym->ns->proc_name->attr.is_main_program))\n+\t  {\n+\t    gfc_error (\"The module or main program array '%s' at %L must \"\n+\t\t       \"have constant shape\", sym->name, &sym->declared_at);\n+\t    specification_expr = 0;\n+\t    return FAILURE;\n+\t  }\n     }\n \n   if (sym->ts.type == BT_CHARACTER)\n@@ -4907,6 +5004,12 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t  return FAILURE;\n \t}\n \n+      if (e && sym->attr.save && !gfc_is_constant_expr (e))\n+\t{\n+\t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+\n       if (!gfc_is_constant_expr (e)\n \t    && !(e->expr_type == EXPR_VARIABLE\n \t    && e->symtree->n.sym->attr.flavor == FL_PARAMETER)\n@@ -4940,6 +5043,13 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t      break;\n \t    }\n \t}\n+\n+      /* Also, they must not have the SAVE attribute.  */\n+      if (flag && sym->attr.save)\n+\t{\n+\t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n   }\n \n   /* Reject illegal initializers.  */\n@@ -6416,6 +6526,8 @@ resolve_codes (gfc_namespace * ns)\n \n   gfc_current_ns = ns;\n   cs_base = NULL;\n+  /* Set to an out of range value.  */\n+  current_entry_id = -1;\n   resolve_code (ns->code, ns);\n }\n "}, {"sha": "b93f91217adb2e055ff066ef6d6be469cf6b5551", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -1,3 +1,17 @@\n+2006-06-07  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23091\n+\t* gfortran.dg/saved_automatic_1.f90: New test.\n+\n+\tPR fortran/24168\n+\t* gfortran.dg/array_simplify_1.f90: New test.\n+\n+\tPR fortran/25090\n+\t* gfortran.dg/entry_dummy_ref_1.f90: New test.\n+\n+\tPR fortran/25058\n+\t* gfortran.dg/entry_dummy_ref_2.f90: New test.\n+\n 2006-06-06  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/27177"}, {"sha": "c638dee0c3cc8445f8fb5c27cd7510b57f161cda", "filename": "gcc/testsuite/gfortran.dg/array_simplify_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_simplify_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_simplify_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_simplify_1.f90?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! Tests the fix for PR24168, in which line   would return\n+! Error: Incompatible ranks 2 and 1 in assignment at (1)\n+! This came about because the simplification of the binary\n+! operation, in the first actual argument of spread, was not\n+! returning the rank of the result.  Thus the error could\n+! be generated with any operator and other intrinsics than\n+! cshift.\n+!\n+! Contributed by Steve Kargl  <kargl@gcc.gnu.org>\n+!\n+ integer, parameter :: nx=2, ny=2\n+ real, dimension(nx, ny) :: f\n+ f = spread(2 * cshift((/ 1, 2 /), nx/2), 2, ny)\n+end\n+"}, {"sha": "8985b935b43b9bb227d3d787af4a312e5ffc9d61", "filename": "gcc/testsuite/gfortran.dg/entry_dummy_ref_1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Tests fix for PR25090 in which references in specification\n+! expressions to variables that were not entry formal arguments\n+! would be missed.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+   SUBROUTINE S1(I)\n+   CHARACTER(LEN=I+J) :: a\n+   real :: x(i:j), z\n+   a = \"\"  ! { dg-error \"before the ENTRY statement in which it is a parameter\" }\n+   x = 0.0 ! { dg-error \"before the ENTRY statement in which it is a parameter\" }\n+   ENTRY E1(J)\n+   END SUBROUTINE S1\n+   END"}, {"sha": "46dbdf6c2faa53acd0b451824c7d1acd09bd217e", "filename": "gcc/testsuite/gfortran.dg/entry_dummy_ref_2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_2.f90?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! Tests fix for PR25058 in which references to dummy\n+! parameters before the entry would be missed.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE M1\n+CONTAINS\n+FUNCTION F1(I) RESULT(RF1)\n+ INTEGER :: I,K,RE1,RF1\n+ RE1=K ! { dg-error \"before the ENTRY statement\" }\n+ RETURN\n+ ENTRY E1(K) RESULT(RE1)\n+ RE1=-I\n+ RETURN\n+END FUNCTION F1\n+END  MODULE M1\n+END\n+\n+! { dg-final { cleanup-modules \"M1\" } }"}, {"sha": "53e7dce8305df4048db79c684142ab5d6e4ad4b0", "filename": "gcc/testsuite/gfortran.dg/saved_automatic_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fsaved_automatic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9a445b9dfd754aec9bf53ce906c493f6b74d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fsaved_automatic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsaved_automatic_1.f90?ref=0e9a445b9dfd754aec9bf53ce906c493f6b74d26", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! Tests patch for PR23091, in which autmatic objects caused\n+! an ICE if they were given the SAVE attribute.\n+!\n+! Contributed by Valera Veryazov  <valera.veryazov@teokem.lu.se>\n+!\n+Subroutine My(n1)\n+  integer :: myArray(n1)\n+  character(n1) :: ch\n+  save      ! OK because only allowed objects are saved globally.\n+  call xxx(myArray, ch)\n+  return\n+  end\n+\n+Subroutine Thy(n1)\n+  integer, save :: myArray(n1) ! { dg-error \"SAVE attribute\" }\n+  character(n1), save :: ch ! { dg-error \"SAVE attribute\" }\n+  call xxx(myArray, ch)\n+  return\n+  end\n+"}]}