{"sha": "426776f1b5866046e06fd373fcc39f568c292878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI2Nzc2ZjFiNTg2NjA0NmUwNmZkMzczZmNjMzlmNTY4YzI5Mjg3OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-10-19T13:50:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-10-19T13:50:10Z"}, "message": "re PR debug/82509 (DW_AT_endianity issues with attribute scalar_storage_order)\n\n\tPR debug/82509\n\t* dwarf2out.c (new_die_raw): New static inline function.\n\t(new_die): Use it to create the DIE.\n\t(add_AT_external_die_ref): Likewise.\n\t(clone_die): Likewise.\n\t(clone_as_declaration): Likewise.\n\t(dwarf2out_vms_debug_main_pointer): Likewise.\n\t(base_type_die): Likewise.  Remove early return for corner cases.\n\tDo not call add_pubtype on the DIE here.\n\t(is_base_type): Remove ERROR_MARK and return 0 for VOID_TYPE.\n\t(modified_type_die): Adjust the lookup for reverse order DIEs.  Skip\n\ttypedefs for base types with DW_AT_endianity.  Make sure a DIE with\n\tnative order exists for base types, attach the DIE manually and call\n\tadd_pubtype on it.  Do not equate a reverse order DIE to the type.\n\nFrom-SVN: r253893", "tree": {"sha": "51b1717646414039cd001053d3fdd1567f87249a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51b1717646414039cd001053d3fdd1567f87249a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/426776f1b5866046e06fd373fcc39f568c292878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426776f1b5866046e06fd373fcc39f568c292878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426776f1b5866046e06fd373fcc39f568c292878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426776f1b5866046e06fd373fcc39f568c292878/comments", "author": null, "committer": null, "parents": [{"sha": "3bb3d60b1e67ececd2e0549f42fbf7d98e024c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb3d60b1e67ececd2e0549f42fbf7d98e024c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb3d60b1e67ececd2e0549f42fbf7d98e024c6b"}], "stats": {"total": 162, "additions": 130, "deletions": 32}, "files": [{"sha": "d8619c106cae9ca0bc38343727f1e0ea4729441e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=426776f1b5866046e06fd373fcc39f568c292878", "patch": "@@ -1,3 +1,20 @@\n+2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR debug/82509\n+\t* dwarf2out.c (new_die_raw): New static inline function.\n+\t(new_die): Use it to create the DIE.\n+\t(add_AT_external_die_ref): Likewise.\n+\t(clone_die): Likewise.\n+\t(clone_as_declaration): Likewise.\n+\t(dwarf2out_vms_debug_main_pointer): Likewise.\n+\t(base_type_die): Likewise.  Remove early return for corner cases.\n+\tDo not call add_pubtype on the DIE here.\n+\t(is_base_type): Remove ERROR_MARK and return 0 for VOID_TYPE.\n+\t(modified_type_die): Adjust the lookup for reverse order DIEs.  Skip\n+\ttypedefs for base types with DW_AT_endianity.  Make sure a DIE with\n+\tnative order exists for base types, attach the DIE manually and call\n+\tadd_pubtype on it.  Do not equate a reverse order DIE to the type.\n+\n 2017-10-19  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.c (align_ok_ldrd_strd): New function."}, {"sha": "ec9b40602b1a464c101429735668d7402f5e0e35", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=426776f1b5866046e06fd373fcc39f568c292878", "patch": "@@ -5364,6 +5364,16 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n   reparent_child (child, parent);\n }\n \n+/* Create and return a new die with TAG_VALUE as tag.  */\n+ \n+static inline dw_die_ref\n+new_die_raw (enum dwarf_tag tag_value)\n+{\n+  dw_die_ref die = ggc_cleared_alloc<die_node> ();\n+  die->die_tag = tag_value;\n+  return die;\n+}\n+\n /* Create and return a new die with a parent of PARENT_DIE.  If\n    PARENT_DIE is NULL, the new DIE is placed in limbo and an\n    associated tree T must be supplied to determine parenthood\n@@ -5372,9 +5382,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n static inline dw_die_ref\n new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n {\n-  dw_die_ref die = ggc_cleared_alloc<die_node> ();\n-\n-  die->die_tag = tag_value;\n+  dw_die_ref die = new_die_raw (tag_value);\n \n   if (parent_die != NULL)\n     add_child_die (parent_die, die);\n@@ -5568,8 +5576,7 @@ add_AT_external_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind,\n {\n   /* Create a fake DIE that contains the reference.  Don't use\n      new_die because we don't want to end up in the limbo list.  */\n-  dw_die_ref ref = ggc_cleared_alloc<die_node> ();\n-  ref->die_tag = die->die_tag;\n+  dw_die_ref ref = new_die_raw (die->die_tag);\n   ref->die_id.die_symbol = IDENTIFIER_POINTER (get_identifier (symbol));\n   ref->die_offset = offset;\n   ref->with_offset = 1;\n@@ -7712,13 +7719,10 @@ should_move_die_to_comdat (dw_die_ref die)\n static dw_die_ref\n clone_die (dw_die_ref die)\n {\n-  dw_die_ref clone;\n+  dw_die_ref clone = new_die_raw (die->die_tag);\n   dw_attr_node *a;\n   unsigned ix;\n \n-  clone = ggc_cleared_alloc<die_node> ();\n-  clone->die_tag = die->die_tag;\n-\n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     add_dwarf_attr (clone, a);\n \n@@ -7762,8 +7766,7 @@ clone_as_declaration (dw_die_ref die)\n       return clone;\n     }\n \n-  clone = ggc_cleared_alloc<die_node> ();\n-  clone->die_tag = die->die_tag;\n+  clone = new_die_raw (die->die_tag);\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n@@ -12090,9 +12093,6 @@ base_type_die (tree type, bool reverse)\n   struct fixed_point_type_info fpt_info;\n   tree type_bias = NULL_TREE;\n \n-  if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)\n-    return 0;\n-\n   /* If this is a subtype that should not be emitted as a subrange type,\n      use the base type.  See subrange_type_for_debug_p.  */\n   if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)\n@@ -12185,7 +12185,7 @@ base_type_die (tree type, bool reverse)\n       gcc_unreachable ();\n     }\n \n-  base_type_result = new_die (DW_TAG_base_type, comp_unit_die (), type);\n+  base_type_result = new_die_raw (DW_TAG_base_type);\n \n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n@@ -12241,8 +12241,6 @@ base_type_die (tree type, bool reverse)\n \t\t     | dw_scalar_form_reference,\n \t\t     NULL);\n \n-  add_pubtype (type, base_type_result);\n-\n   return base_type_result;\n }\n \n@@ -12270,8 +12268,6 @@ is_base_type (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n-    case ERROR_MARK:\n-    case VOID_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:\n@@ -12280,6 +12276,7 @@ is_base_type (tree type)\n     case POINTER_BOUNDS_TYPE:\n       return 1;\n \n+    case VOID_TYPE:\n     case ARRAY_TYPE:\n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -12485,6 +12482,8 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n   /* Only these cv-qualifiers are currently handled.  */\n   const int cv_qual_mask = (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE\n \t\t\t    | TYPE_QUAL_RESTRICT | TYPE_QUAL_ATOMIC);\n+  const bool reverse_base_type\n+    = need_endianity_attribute_p (reverse) && is_base_type (type);\n \n   if (code == ERROR_MARK)\n     return NULL;\n@@ -12535,29 +12534,33 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \tqualified_type = size_type_node;\n     }\n \n-\n   /* If we do, then we can just use its DIE, if it exists.  */\n   if (qualified_type)\n     {\n       mod_type_die = lookup_type_die (qualified_type);\n \n-      /* DW_AT_endianity doesn't come from a qualifier on the type.  */\n+      /* DW_AT_endianity doesn't come from a qualifier on the type, so it is\n+\t dealt with specially: the DIE with the attribute, if it exists, is\n+\t placed immediately after the regular DIE for the same base type.  */\n       if (mod_type_die\n-\t  && (!need_endianity_attribute_p (reverse)\n-\t      || !is_base_type (type)\n-\t      || get_AT_unsigned (mod_type_die, DW_AT_endianity)))\n+\t  && (!reverse_base_type\n+\t      || ((mod_type_die = mod_type_die->die_sib) != NULL\n+\t\t  && get_AT_unsigned (mod_type_die, DW_AT_endianity))))\n \treturn mod_type_die;\n     }\n \n   name = qualified_type ? TYPE_NAME (qualified_type) : NULL;\n \n   /* Handle C typedef types.  */\n-  if (name && TREE_CODE (name) == TYPE_DECL && DECL_ORIGINAL_TYPE (name)\n+  if (name\n+      && TREE_CODE (name) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (name)\n       && !DECL_ARTIFICIAL (name))\n     {\n       tree dtype = TREE_TYPE (name);\n \n-      if (qualified_type == dtype)\n+      /* Skip the typedef for base types with DW_AT_endianity, no big deal.  */\n+      if (qualified_type == dtype && !reverse_base_type)\n \t{\n \t  tree origin = decl_ultimate_origin (name);\n \n@@ -12670,8 +12673,7 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \t      }\n \t    if (first)\n \t      {\n-\t\td = ggc_cleared_alloc<die_node> ();\n-\t\td->die_tag = dwarf_qual_info[i].t;\n+\t\td = new_die_raw (dwarf_qual_info[i].t);\n \t\tadd_child_die_after (mod_scope, d, last);\n \t\tlast = d;\n \t      }\n@@ -12729,7 +12731,21 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n       item_type = TREE_TYPE (type);\n     }\n   else if (is_base_type (type))\n-    mod_type_die = base_type_die (type, reverse);\n+    {\n+      mod_type_die = base_type_die (type, reverse);\n+\n+      /* The DIE with DW_AT_endianity is placed right after the naked DIE.  */\n+      if (reverse_base_type)\n+\t{\n+\t  dw_die_ref after_die\n+\t    = modified_type_die (type, cv_quals, false, context_die);\n+\t  add_child_die_after (comp_unit_die (), mod_type_die, after_die);\n+\t}\n+      else\n+\tadd_child_die (comp_unit_die (), mod_type_die);\n+\n+      add_pubtype (type, mod_type_die);\n+    }\n   else\n     {\n       gen_type_die (type, context_die);\n@@ -12791,7 +12807,7 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \t\t\t  name ? IDENTIFIER_POINTER (name) : \"__unknown__\");\n     }\n \n-  if (qualified_type)\n+  if (qualified_type && !reverse_base_type)\n     equate_type_number_to_die (qualified_type, mod_type_die);\n \n   if (item_type)\n@@ -20500,8 +20516,7 @@ dwarf2out_vms_debug_main_pointer (void)\n   dw_die_ref die;\n \n   /* Allocate the VMS debug main subprogram die.  */\n-  die = ggc_cleared_alloc<die_node> ();\n-  die->die_tag = DW_TAG_subprogram;\n+  die = new_die_raw (DW_TAG_subprogram);\n   add_name_attribute (die, VMS_DEBUG_MAIN_POINTER);\n   ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,\n \t\t\t       current_function_funcdef_no);"}, {"sha": "1488f6fc03b8c9db6f31fb6035bc5e144727a44b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=426776f1b5866046e06fd373fcc39f568c292878", "patch": "@@ -1,3 +1,10 @@\n+2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/debug/dwarf2/sso.c: Rename into...\n+\t* gcc.dg/debug/dwarf2/sso-1.c: ...this.\n+\t* gcc.dg/debug/dwarf2/sso-2.c: New test.\n+\t* gcc.dg/debug/dwarf2/sso-3.c: Likewise.\n+\n 2017-10-19  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/82445"}, {"sha": "698c636a130564d64669791e63f3b627de1c9e92", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/sso-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-1.c?ref=426776f1b5866046e06fd373fcc39f568c292878", "previous_filename": "gcc/testsuite/gcc.dg/debug/dwarf2/sso.c"}, {"sha": "0965084d260843f2e6d1bf5c721127308197c91b", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/sso-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-2.c?ref=426776f1b5866046e06fd373fcc39f568c292878", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-gdwarf-3 -dA\" } */\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"big-endian\")));\n+#else\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"little-endian\")));\n+#endif\n+\n+struct reverse\n+{\n+  int i;\n+  short a[4];\n+} REVERSE_SSO;\n+\n+struct native\n+{\n+  int i;\n+  short a[4];\n+};\n+\n+struct reverse R;\n+struct native  N;\n+\n+/* Verify that we have endianity on the common base type of 'i' and the\n+ *  element of 'a' in the first 2 structures.  */\n+/* { dg-final { scan-assembler-times \" DW_AT_endianity\" 2 } } */\n+/* { dg-final { scan-assembler-times \"DIE \\\\(\\[0-9a-z\\]*\\\\) DW_TAG_base_type\" 5 } } */"}, {"sha": "004327c78ad82656bce8712ce0f2eb58b4b7e5f2", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/sso-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/426776f1b5866046e06fd373fcc39f568c292878/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fsso-3.c?ref=426776f1b5866046e06fd373fcc39f568c292878", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-gdwarf-3 -dA\" } */\n+\n+typedef int   int_t;\n+typedef short short_t;\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"big-endian\")));\n+#else\n+#define REVERSE_SSO __attribute__((scalar_storage_order(\"little-endian\")));\n+#endif\n+\n+struct reverse\n+{\n+  int_t i;\n+  short_t a[4];\n+} REVERSE_SSO;\n+\n+struct native\n+{\n+  int_t i;\n+  short_t a[4];\n+};\n+\n+struct reverse R;\n+struct native  N;\n+\n+/* Verify that we have endianity on the common base type of 'i' and the\n+ *  element of 'a' in the first 2 structures.  */\n+/* { dg-final { scan-assembler-times \" DW_AT_endianity\" 2 } } */\n+/* { dg-final { scan-assembler-times \"DIE \\\\(\\[0-9a-z\\]*\\\\) DW_TAG_base_type\" 5 } } */"}]}