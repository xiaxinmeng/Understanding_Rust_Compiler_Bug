{"sha": "8c3b269309f3b3651362697d48a3ade54bbddb55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzYjI2OTMwOWYzYjM2NTEzNjI2OTdkNDhhM2FkZTU0YmJkZGI1NQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-30T10:03:11Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-30T10:03:11Z"}, "message": "cpphash.h (POOL_ALIGN, [...]): Remove.\n\n\t* cpphash.h (POOL_ALIGN, POOL_FRONT, POOL_LIMIT, POOL_BASE,\n\tPOOL_SIZE, POOL_ROOM, POOL_COMMIT, struct cpp_chunk,\n\tstruct cpp_pool, _cpp_init_pool, _cpp_free_pool, _cpp_pool_reserve,\n\t_cpp_pool_alloc, _cpp_next_chunk): Remove.\n\t(_cpp_extend_buff, BUFF_ROOM): Update.\n\t(_cpp_append_extend_buff): New.\n\t(struct cpp_reader): Remove macro_pool, add a_buff.\n\t* cppinit.c (cpp_create_reader): Initialize a_buff, instead of\n\tmacro_pool.\n\t(cpp_destroy): Free a_buff instead of macro_pool.\n\t* cpplex.c (new_chunk, chunk_suitable, _cpp_next_chunk,\n\tnew_chunk, _cpp_init_pool, _cpp_free_pool, _cpp_pool_reserve,\n\t_cpp_pool_alloc, ): Remove.\n\t(parse_number, parse_string): Update use of _cpp_extend_buff.\n\t(_cpp_extend_buff): Update.\n\t(_cpp_append_extend_buff, cpp_aligned_alloc): New.\n\t* cpplib.c (glue_header_name, parse_answer):\n\tUpdate use of _cpp_extend_buff.\n\t(cpp_register_pragma, cpp_register_pragma_space): Use\n\t_cpp_aligned_alloc.\n\t(do_assert, do_unassert): Check for EOL, update.\n\t* cppmacro.c (stringify_arg, collect_args): Update to use\n\t_cpp_extend_buff and _cpp_append_extend_buff.\n\t(save_parameter, parse_params, alloc_expansion_token,\n\t_cpp_create_definition): Rework memory management.\n\n\t* gcc.dg/cpp/redef2.c: Add test.\n\nFrom-SVN: r45899", "tree": {"sha": "78d68f969b236c6a6934656003c802393ecd85b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78d68f969b236c6a6934656003c802393ecd85b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c3b269309f3b3651362697d48a3ade54bbddb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3b269309f3b3651362697d48a3ade54bbddb55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c3b269309f3b3651362697d48a3ade54bbddb55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3b269309f3b3651362697d48a3ade54bbddb55/comments", "author": null, "committer": null, "parents": [{"sha": "218e1e912d74b89f0a6bd7c694bdc89c4515610b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/218e1e912d74b89f0a6bd7c694bdc89c4515610b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/218e1e912d74b89f0a6bd7c694bdc89c4515610b"}], "stats": {"total": 389, "additions": 150, "deletions": 239}, "files": [{"sha": "ca88ff78c70ad6af1265e07ea069d01fb627a0a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -1,3 +1,31 @@\n+2001-09-30  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (POOL_ALIGN, POOL_FRONT, POOL_LIMIT, POOL_BASE,\n+\tPOOL_SIZE, POOL_ROOM, POOL_COMMIT, struct cpp_chunk,\n+\tstruct cpp_pool, _cpp_init_pool, _cpp_free_pool, _cpp_pool_reserve,\n+\t_cpp_pool_alloc, _cpp_next_chunk): Remove.\n+\t(_cpp_extend_buff, BUFF_ROOM): Update.\n+\t(_cpp_append_extend_buff): New.\n+\t(struct cpp_reader): Remove macro_pool, add a_buff.\n+\t* cppinit.c (cpp_create_reader): Initialize a_buff, instead of\n+\tmacro_pool.\n+\t(cpp_destroy): Free a_buff instead of macro_pool.\n+\t* cpplex.c (new_chunk, chunk_suitable, _cpp_next_chunk,\n+\tnew_chunk, _cpp_init_pool, _cpp_free_pool, _cpp_pool_reserve,\n+\t_cpp_pool_alloc, ): Remove.\n+\t(parse_number, parse_string): Update use of _cpp_extend_buff.\n+\t(_cpp_extend_buff): Update.\n+\t(_cpp_append_extend_buff, cpp_aligned_alloc): New.\n+\t* cpplib.c (glue_header_name, parse_answer):\n+\tUpdate use of _cpp_extend_buff.\n+\t(cpp_register_pragma, cpp_register_pragma_space): Use\n+\t_cpp_aligned_alloc.\n+\t(do_assert, do_unassert): Check for EOL, update.\n+\t* cppmacro.c (stringify_arg, collect_args): Update to use\n+\t_cpp_extend_buff and _cpp_append_extend_buff.\n+\t(save_parameter, parse_params, alloc_expansion_token,\n+\t_cpp_create_definition): Rework memory management.\n+\n 2001-09-29  Andris Pavenis  <pavenis@lanet.lv>\n \n \t* config/i386/xm-djgpp.h (GCC_DRIVER_HOST_INITIALIZATION): Don't"}, {"sha": "43ac8336be07d2b55de79cd47df101a71c1feb81", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -42,35 +42,6 @@ struct directive;\t\t/* Deliberately incomplete.  */\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n \n-/* Memory pools.  */\n-#define POOL_ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n-#define POOL_FRONT(p) ((p)->cur->front)\n-#define POOL_LIMIT(p) ((p)->cur->limit)\n-#define POOL_BASE(p)  ((p)->cur->base)\n-#define POOL_SIZE(p)  ((p)->cur->limit - (p)->cur->base)\n-#define POOL_ROOM(p)  ((p)->cur->limit - (p)->cur->front)\n-#define POOL_USED(p)  ((p)->cur->front - (p)->cur->base)\n-#define POOL_COMMIT(p, len) do {\\\n-  ((p)->cur->front += POOL_ALIGN (len, (p)->align));\\\n-  if ((p)->cur->front > (p)->cur->limit) abort ();} while (0)\n-\n-typedef struct cpp_chunk cpp_chunk;\n-struct cpp_chunk\n-{\n-  cpp_chunk *next;\n-  unsigned char *front;\n-  unsigned char *limit;\n-  unsigned char *base;\n-};\n-\n-typedef struct cpp_pool cpp_pool;\n-struct cpp_pool\n-{\n-  struct cpp_chunk *cur, *first;\n-  unsigned char *pos;\t\t/* Current position.  */\n-  unsigned int align;\n-};\n-\n /* A generic memory buffer.  */\n \n typedef struct _cpp_buff _cpp_buff;\n@@ -82,11 +53,13 @@ struct _cpp_buff\n \n extern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, size_t));\n extern void _cpp_release_buff PARAMS ((cpp_reader *, _cpp_buff *));\n-extern _cpp_buff *_cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n-\t\t\t\t\t    size_t));\n+extern void _cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff **, size_t));\n+extern _cpp_buff *_cpp_append_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n+\t\t\t\t\t\t   size_t));\n extern void _cpp_free_buff PARAMS ((_cpp_buff *));\n+extern unsigned char *_cpp_aligned_alloc PARAMS ((cpp_reader *, size_t));\n extern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n-#define BUFF_ROOM(BUFF) ((BUFF)->limit - (BUFF)->cur)\n+#define BUFF_ROOM(BUFF) (size_t) ((BUFF)->limit - (BUFF)->cur)\n #define BUFF_FRONT(BUFF) ((BUFF)->cur)\n #define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n \n@@ -270,10 +243,8 @@ struct cpp_reader\n   /* The line of the '#' of the current directive.  */\n   unsigned int directive_line;\n \n-  /* Memory pools.  */\n-  cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n-\n   /* Memory buffers.  */\n+  _cpp_buff *a_buff;\t\t/* Aligned permanent storage.  */\n   _cpp_buff *u_buff;\t\t/* Unaligned permanent storage.  */\n   _cpp_buff *free_buffs;\t/* Free buffer chain.  */\n \n@@ -434,13 +405,6 @@ extern cpp_token *_cpp_lex_direct\tPARAMS ((cpp_reader *));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n-extern void _cpp_init_pool\t\tPARAMS ((cpp_pool *, unsigned int,\n-\t\t\t\t\t\t  unsigned int, unsigned int));\n-extern void _cpp_free_pool\t\tPARAMS ((cpp_pool *));\n-extern unsigned char *_cpp_pool_reserve PARAMS ((cpp_pool *, unsigned int));\n-extern unsigned char *_cpp_pool_alloc\tPARAMS ((cpp_pool *, unsigned int));\n-extern unsigned char *_cpp_next_chunk\tPARAMS ((cpp_pool *, unsigned int,\n-\t\t\t\t\t\t unsigned char **));\n \n /* In cppinit.c.  */\n extern bool _cpp_push_next_buffer\tPARAMS ((cpp_reader *));"}, {"sha": "45d9b6aebd556f5672a97b06d56934d751b772b0", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -527,12 +527,10 @@ cpp_create_reader (table, lang)\n   pfile->base_context.macro = 0;\n   pfile->base_context.prev = pfile->base_context.next = 0;\n \n-  /* Unaligned storage.  */\n+  /* Aligned and unaligned storage.  */\n+  pfile->a_buff = _cpp_get_buff (pfile, 0);\n   pfile->u_buff = _cpp_get_buff (pfile, 0);\n \n-  /* Macro pool initially 8K.  Aligned, permanent pool.  */\n-  _cpp_init_pool (&pfile->macro_pool, 8 * 1024, 0, 0);\n-\n   /* Initialise the buffer obstack.  */\n   gcc_obstack_init (&pfile->buffer_ob);\n \n@@ -585,7 +583,7 @@ cpp_destroy (pfile)\n   _cpp_destroy_hashtable (pfile);\n   _cpp_cleanup_includes (pfile);\n \n-  _cpp_free_pool (&pfile->macro_pool);\n+  _cpp_free_buff (pfile->a_buff);\n   _cpp_free_buff (pfile->u_buff);\n   _cpp_free_buff (pfile->free_buffs);\n "}, {"sha": "4a6c483a2ec39c5a0da8a5192043e1a8dd312ef1", "filename": "gcc/cpplex.c", "status": "modified", "additions": 44, "deletions": 121, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -104,8 +104,6 @@ static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n \t\t\t\t   const unsigned char *, unsigned int *));\n static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n \n-static cpp_chunk *new_chunk PARAMS ((unsigned int));\n-static int chunk_suitable PARAMS ((cpp_chunk *, unsigned int));\n static unsigned int hex_digit_value PARAMS ((unsigned int));\n static _cpp_buff *new_buff PARAMS ((size_t));\n \n@@ -609,7 +607,7 @@ parse_number (pfile, number, c, leading_period)\n     {\n       if (dest == limit)\n \t{\n-\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 1);\n+\t  _cpp_extend_buff (pfile, &pfile->u_buff, 1);\n \t  dest = BUFF_FRONT (pfile->u_buff);\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n@@ -624,7 +622,7 @@ parse_number (pfile, number, c, leading_period)\n \t  if ((size_t) (limit - dest) < 2)\n \t    {\n \t      size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t      pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 2);\n+\t      _cpp_extend_buff (pfile, &pfile->u_buff, 2);\n \t      dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t      limit = BUFF_LIMIT (pfile->u_buff);\n \t    }\n@@ -726,7 +724,7 @@ parse_string (pfile, token, terminator)\n       if ((size_t) (limit - dest) < 1)\n \t{\n \t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 2);\n+\t  _cpp_extend_buff (pfile, &pfile->u_buff, 2);\n \t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n@@ -2112,20 +2110,42 @@ _cpp_get_buff (pfile, min_size)\n   return result;\n }\n \n-/* Return a buffer chained on the end of BUFF.  Copy to it the\n-   uncommitted remaining bytes of BUFF, with at least MIN_EXTRA more\n-   bytes.  */\n+/* Creates a new buffer with enough space to hold the the uncommitted\n+   remaining bytes of BUFF, and at least MIN_EXTRA more bytes.  Copies\n+   the excess bytes to the new buffer.  Chains the new buffer after\n+   BUFF, and returns the new buffer.  */\n _cpp_buff *\n-_cpp_extend_buff (pfile, buff, min_extra)\n+_cpp_append_extend_buff (pfile, buff, min_extra)\n      cpp_reader *pfile;\n      _cpp_buff *buff;\n      size_t min_extra;\n {\n   size_t size = EXTENDED_BUFF_SIZE (buff, min_extra);\n+  _cpp_buff *new_buff = _cpp_get_buff (pfile, size);\n \n-  buff->next = _cpp_get_buff (pfile, size);\n-  memcpy (buff->next->base, buff->cur, buff->limit - buff->cur);\n-  return buff->next;\n+  buff->next = new_buff;\n+  memcpy (new_buff->base, buff->cur, BUFF_ROOM (buff));\n+  return new_buff;\n+}\n+\n+/* Creates a new buffer with enough space to hold the the uncommitted\n+   remaining bytes of the buffer pointed to by BUFF, and at least\n+   MIN_EXTRA more bytes.  Copies the excess bytes to the new buffer.\n+   Chains the new buffer before the buffer pointed to by BUFF, and\n+   updates the pointer to point to the new buffer.  */\n+void\n+_cpp_extend_buff (pfile, pbuff, min_extra)\n+     cpp_reader *pfile;\n+     _cpp_buff **pbuff;\n+     size_t min_extra;\n+{\n+  _cpp_buff *new_buff, *old_buff = *pbuff;\n+  size_t size = EXTENDED_BUFF_SIZE (old_buff, min_extra);\n+\n+  new_buff = _cpp_get_buff (pfile, size);\n+  memcpy (new_buff->base, old_buff->cur, BUFF_ROOM (old_buff));\n+  new_buff->next = old_buff;\n+  *pbuff = new_buff;\n }\n \n /* Free a chain of buffers starting at BUFF.  */\n@@ -2163,120 +2183,23 @@ _cpp_unaligned_alloc (pfile, len)\n   return result;\n }\n \n-static int\n-chunk_suitable (chunk, size)\n-     cpp_chunk *chunk;\n-     unsigned int size;\n-{\n-  /* Being at least twice SIZE means we can use memcpy in\n-     _cpp_next_chunk rather than memmove.  Besides, it's a good idea\n-     anyway.  */\n-  return (chunk && (unsigned int) (chunk->limit - chunk->base) >= size * 2);\n-}\n-\n-/* Returns the end of the new pool.  PTR points to a char in the old\n-   pool, and is updated to point to the same char in the new pool.  */\n+/* Allocate permanent, unaligned storage of length LEN.  */\n unsigned char *\n-_cpp_next_chunk (pool, len, ptr)\n-     cpp_pool *pool;\n-     unsigned int len;\n-     unsigned char **ptr;\n-{\n-  cpp_chunk *chunk = pool->cur->next;\n-\n-  /* LEN is the minimum size we want in the new pool.  */\n-  len += POOL_ROOM (pool);\n-  if (! chunk_suitable (chunk, len))\n-    {\n-      chunk = new_chunk (POOL_SIZE (pool) * 2 + len);\n-\n-      chunk->next = pool->cur->next;\n-      pool->cur->next = chunk;\n-    }\n-\n-  /* Update the pointer before changing chunk's front.  */\n-  if (ptr)\n-    *ptr += chunk->base - POOL_FRONT (pool);\n-\n-  memcpy (chunk->base, POOL_FRONT (pool), POOL_ROOM (pool));\n-  chunk->front = chunk->base;\n-\n-  pool->cur = chunk;\n-  return POOL_LIMIT (pool);\n-}\n-\n-static cpp_chunk *\n-new_chunk (size)\n-     unsigned int size;\n-{\n-  unsigned char *base;\n-  cpp_chunk *result;\n-\n-  size = POOL_ALIGN (size, DEFAULT_ALIGNMENT);\n-  base = (unsigned char *) xmalloc (size + sizeof (cpp_chunk));\n-  /* Put the chunk descriptor at the end.  Then chunk overruns will\n-     cause obvious chaos.  */\n-  result = (cpp_chunk *) (base + size);\n-  result->base = base;\n-  result->front = base;\n-  result->limit = base + size;\n-  result->next = 0;\n-\n-  return result;\n-}\n-\n-void\n-_cpp_init_pool (pool, size, align, temp)\n-     cpp_pool *pool;\n-     unsigned int size, align, temp;\n-{\n-  if (align == 0)\n-    align = DEFAULT_ALIGNMENT;\n-  if (align & (align - 1))\n-    abort ();\n-  pool->align = align;\n-  pool->first = new_chunk (size);\n-  pool->cur = pool->first;\n-  if (temp)\n-    pool->cur->next = pool->cur;\n-}\n-\n-void\n-_cpp_free_pool (pool)\n-     cpp_pool *pool;\n+_cpp_aligned_alloc (pfile, len)\n+     cpp_reader *pfile;\n+     size_t len;\n {\n-  cpp_chunk *chunk = pool->first, *next;\n+  _cpp_buff *buff = pfile->a_buff;\n+  unsigned char *result = buff->cur;\n \n-  do\n+  if (len > (size_t) (buff->limit - result))\n     {\n-      next = chunk->next;\n-      free (chunk->base);\n-      chunk = next;\n+      buff = _cpp_get_buff (pfile, len);\n+      buff->next = pfile->a_buff;\n+      pfile->a_buff = buff;\n+      result = buff->cur;\n     }\n-  while (chunk && chunk != pool->first);\n-}\n-\n-/* Reserve LEN bytes from a memory pool.  */\n-unsigned char *\n-_cpp_pool_reserve (pool, len)\n-     cpp_pool *pool;\n-     unsigned int len;\n-{\n-  len = POOL_ALIGN (len, pool->align);\n-  if (len > (unsigned int) POOL_ROOM (pool))\n-    _cpp_next_chunk (pool, len, 0);\n \n-  return POOL_FRONT (pool);\n-}\n-\n-/* Allocate LEN bytes from a memory pool.  */\n-unsigned char *\n-_cpp_pool_alloc (pool, len)\n-     cpp_pool *pool;\n-     unsigned int len;\n-{\n-  unsigned char *result = _cpp_pool_reserve (pool, len);\n-\n-  POOL_COMMIT (pool, len);\n+  buff->cur = result + len;\n   return result;\n }"}, {"sha": "f5d10e0633acf28f0e630d8862bf7a6cd42425fd", "filename": "gcc/cpplib.c", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -512,7 +512,7 @@ glue_header_name (pfile)\n       if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n \t{\n \t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, len);\n+\t  _cpp_extend_buff (pfile, &pfile->u_buff, len);\n \t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t}\n \n@@ -893,7 +893,7 @@ cpp_register_pragma (pfile, space, name, handler)\n \n  found:\n   new = (struct pragma_entry *)\n-    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n+    _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n   new->name = name;\n   new->len = strlen (name);\n   new->isnspace = 0;\n@@ -922,7 +922,7 @@ cpp_register_pragma_space (pfile, space)\n     }\n \n   new = (struct pragma_entry *)\n-    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n+    _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n   new->name = space;\n   new->len = len;\n   new->isnspace = 1;\n@@ -1406,12 +1406,7 @@ parse_answer (pfile, answerp, type)\n {\n   const cpp_token *paren;\n   struct answer *answer;\n-\n-  if (POOL_FRONT (&pfile->macro_pool) + sizeof (struct answer) >\n-      POOL_LIMIT (&pfile->macro_pool))\n-    _cpp_next_chunk (&pfile->macro_pool, sizeof (struct answer), 0);\n-  answer = (struct answer *) POOL_FRONT (&pfile->macro_pool);\n-  answer->count = 0;\n+  unsigned int acount;\n \n   /* In a conditional, it is legal to not have an open paren.  We\n      should save the following token in this case.  */\n@@ -1436,18 +1431,12 @@ parse_answer (pfile, answerp, type)\n       return 1;\n     }\n \n-  for (;;)\n+  for (acount = 0;; acount++)\n     {\n-      cpp_token *token = &answer->first[answer->count];\n-      /* Check we have room for the token.  */\n-      if ((unsigned char *) (token + 1) >= POOL_LIMIT (&pfile->macro_pool))\n-\t{\n-\t  _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_token),\n-\t\t\t   (unsigned char **) &answer);\n-\t  token = &answer->first[answer->count];\n-\t}\n+      size_t room_needed;\n+      const cpp_token *token = cpp_get_token (pfile);\n+      cpp_token *dest;\n \n-      *token = *cpp_get_token (pfile);\n       if (token->type == CPP_CLOSE_PAREN)\n \tbreak;\n \n@@ -1456,21 +1445,32 @@ parse_answer (pfile, answerp, type)\n \t  cpp_error (pfile, \"missing ')' to complete answer\");\n \t  return 1;\n \t}\n-      answer->count++;\n+\n+      /* struct answer includes the space for one token.  */\n+      room_needed = (sizeof (struct answer) + acount * sizeof (cpp_token));\n+\n+      if (BUFF_ROOM (pfile->a_buff) < room_needed)\n+\t_cpp_extend_buff (pfile, &pfile->a_buff, sizeof (struct answer));\n+\n+      dest = &((struct answer *) BUFF_FRONT (pfile->a_buff))->first[acount];\n+      *dest = *token;\n+\n+      /* Drop whitespace at start, for answer equivalence purposes.  */\n+      if (acount == 0)\n+\tdest->flags &= ~PREV_WHITE;\n     }\n \n-  if (answer->count == 0)\n+  if (acount == 0)\n     {\n       cpp_error (pfile, \"predicate's answer is empty\");\n       return 1;\n     }\n \n-  /* Drop whitespace at start.  */\n-  answer->first->flags &= ~PREV_WHITE;\n+  answer = (struct answer *) BUFF_FRONT (pfile->a_buff);\n+  answer->count = acount;\n+  answer->next = NULL;\n   *answerp = answer;\n \n-  if (type == T_ASSERT || type == T_UNASSERT)\n-    check_eol (pfile);\n   return 0;\n }\n \n@@ -1580,11 +1580,13 @@ do_assert (pfile)\n \t    }\n \t  new_answer->next = node->value.answers;\n \t}\n+\n       node->type = NT_ASSERTION;\n       node->value.answers = new_answer;\n-      POOL_COMMIT (&pfile->macro_pool, (sizeof (struct answer)\n-\t\t\t\t\t+ (new_answer->count - 1)\n-\t\t\t\t\t* sizeof (cpp_token)));\n+      BUFF_FRONT (pfile->a_buff) += (sizeof (struct answer)\n+\t\t\t\t     + (new_answer->count - 1)\n+\t\t\t\t     * sizeof (cpp_token));\n+      check_eol (pfile);\n     }\n }\n \n@@ -1611,6 +1613,8 @@ do_unassert (pfile)\n \t  /* Did we free the last answer?  */\n \t  if (node->value.answers == 0)\n \t    node->type = NT_VOID;\n+\n+\t  check_eol (pfile);\n \t}\n       else\n \t_cpp_free_definition (node);"}, {"sha": "845d90b99eb602f31f073c1c744f2f2133a35921", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -285,7 +285,7 @@ stringify_arg (pfile, arg)\n       if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n \t{\n \t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, len);\n+\t  _cpp_extend_buff (pfile, &pfile->u_buff, len);\n \t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t}\n \n@@ -465,8 +465,8 @@ collect_args (pfile, node)\n \t  /* Require space for 2 new tokens (including a CPP_EOF).  */\n \t  if ((unsigned char *) &arg->first[ntokens + 2] > buff->limit)\n \t    {\n-\t      buff = _cpp_extend_buff (pfile, buff,\n-\t\t\t\t       1000 * sizeof (cpp_token *));\n+\t      buff = _cpp_append_extend_buff (pfile, buff,\n+\t\t\t\t\t      1000 * sizeof (cpp_token *));\n \t      arg->first = (const cpp_token **) buff->cur;\n \t    }\n \n@@ -1129,39 +1129,30 @@ save_parameter (pfile, macro, node)\n      cpp_macro *macro;\n      cpp_hashnode *node;\n {\n-  cpp_hashnode **dest;\n-\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n   if (node->arg_index)\n     {\n       cpp_error (pfile, \"duplicate macro parameter \\\"%s\\\"\", NODE_NAME (node));\n       return 1;\n     }\n \n-  dest = &macro->params[macro->paramc];\n-\n-  /* Check we have room for the parameters.  */\n-  if ((unsigned char *) (dest + 1) >= POOL_LIMIT (&pfile->macro_pool))\n-    {\n-      _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_hashnode *),\n-\t\t       (unsigned char **) &macro->params);\n-      dest = &macro->params[macro->paramc];\n-    }\n+  if (BUFF_ROOM (pfile->a_buff)\n+      < (macro->paramc + 1) * sizeof (cpp_hashnode *))\n+    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_hashnode *));\n \n-  *dest = node;\n-  node->arg_index = ++macro->paramc;\n+  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[macro->paramc++] = node;\n+  node->arg_index = macro->paramc;\n   return 0;\n }\n \n-/* Check the syntax of the paramters in a MACRO definition.  */\n+/* Check the syntax of the parameters in a MACRO definition.  */\n static int\n parse_params (pfile, macro)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n {\n   unsigned int prev_ident = 0;\n \n-  macro->params = (cpp_hashnode **) POOL_FRONT (&pfile->macro_pool);\n   for (;;)\n     {\n       const cpp_token *token = _cpp_lex_token (pfile);\n@@ -1187,7 +1178,7 @@ parse_params (pfile, macro)\n \n \tcase CPP_CLOSE_PAREN:\n \t  if (prev_ident || macro->paramc == 0)\n-\t    break;\n+\t    return 1;\n \n \t  /* Fall through to pick up the error.  */\n \tcase CPP_COMMA:\n@@ -1215,18 +1206,13 @@ parse_params (pfile, macro)\n \t  /* We're at the end, and just expect a closing parenthesis.  */\n \t  token = _cpp_lex_token (pfile);\n \t  if (token->type == CPP_CLOSE_PAREN)\n-\t    break;\n+\t    return 1;\n \t  /* Fall through.  */\n \n \tcase CPP_EOF:\n \t  cpp_error (pfile, \"missing ')' in macro parameter list\");\n \t  return 0;\n \t}\n-\n-      /* Success.  Commit the parameter array.  */\n-      POOL_COMMIT (&pfile->macro_pool,\n-\t\t   macro->paramc * sizeof (cpp_hashnode *));\n-      return 1;\n     }\n }\n \n@@ -1236,18 +1222,10 @@ alloc_expansion_token (pfile, macro)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n {\n-  cpp_token *token = &macro->expansion[macro->count];\n-\n-  /* Check we have room for the token.  */\n-  if ((unsigned char *) (token + 1) >= POOL_LIMIT (&pfile->macro_pool))\n-    {\n-      _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_token),\n-\t\t       (unsigned char **) &macro->expansion);\n-      token = &macro->expansion[macro->count];\n-    }\n+  if (BUFF_ROOM (pfile->a_buff) < (macro->count + 1) * sizeof (cpp_token))\n+    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_token));\n \n-  macro->count++;\n-  return token;\n+  return &((cpp_token *) BUFF_FRONT (pfile->a_buff))[macro->count++];\n }\n \n static cpp_token *\n@@ -1284,8 +1262,7 @@ _cpp_create_definition (pfile, node)\n   const cpp_token *ctoken;\n   unsigned int i, ok = 1;\n \n-  macro = (cpp_macro *) _cpp_pool_alloc (&pfile->macro_pool,\n-\t\t\t\t\t sizeof (cpp_macro));\n+  macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n   macro->line = pfile->directive_line;\n   macro->params = 0;\n   macro->paramc = 0;\n@@ -1299,16 +1276,20 @@ _cpp_create_definition (pfile, node)\n \n   if (ctoken->type == CPP_OPEN_PAREN && !(ctoken->flags & PREV_WHITE))\n     {\n-      if (!(ok = parse_params (pfile, macro)))\n+      ok = parse_params (pfile, macro);\n+      macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n+      if (!ok)\n \tgoto cleanup2;\n+\n+      /* Success.  Commit the parameter array.  */\n+      BUFF_FRONT (pfile->a_buff) = (U_CHAR *) &macro->params[macro->paramc];\n       macro->fun_like = 1;\n     }\n   else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n     cpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n \n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n   saved_cur_token = pfile->cur_token;\n-  macro->expansion = (cpp_token *) POOL_FRONT (&pfile->macro_pool);\n \n   if (macro->fun_like)\n     token = lex_expansion_token (pfile, macro);\n@@ -1366,9 +1347,18 @@ _cpp_create_definition (pfile, node)\n       token = lex_expansion_token (pfile, macro);\n     }\n \n+  macro->expansion = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n+\n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n \n+  /* Clear whitespace on first token for macro equivalence purposes.  */\n+  if (macro->count)\n+    macro->expansion[0].flags &= ~PREV_WHITE;\n+\n+  /* Commit the memory.  */\n+  BUFF_FRONT (pfile->a_buff) = (U_CHAR *) &macro->expansion[macro->count];\n+\n   /* Implement the macro-defined-to-itself optimisation.  */\n   macro->disabled = (macro->count == 1 && !macro->fun_like\n \t\t     && macro->expansion[0].type == CPP_NAME\n@@ -1377,9 +1367,6 @@ _cpp_create_definition (pfile, node)\n   /* To suppress some diagnostics.  */\n   macro->syshdr = pfile->map->sysp != 0;\n \n-  /* Commit the memory.  */\n-  POOL_COMMIT (&pfile->macro_pool, macro->count * sizeof (cpp_token));\n-\n   if (node->type != NT_VOID)\n     {\n       if (warn_of_redefinition (pfile, node, macro))"}, {"sha": "0e8f92e7a9d0971e8f7576340e4ffcd90b13bf6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -1,3 +1,7 @@\n+2001-09-30  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/redef2.c: Add test.\n+\n 2001-09-27  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* gcc.c-torture/execute/loop-2e.x: This is a manifestation of a"}, {"sha": "7001d67eb002f0c1c9ab54c0c4908134e1aa5616", "filename": "gcc/testsuite/gcc.dg/cpp/redef2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fredef2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3b269309f3b3651362697d48a3ade54bbddb55/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fredef2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fredef2.c?ref=8c3b269309f3b3651362697d48a3ade54bbddb55", "patch": "@@ -14,6 +14,9 @@\n #define va(a...) a\n #define va(...) __VA_ARGS__\n \n+#define foo(x) x\n+#define foo(x)x\t\t/* { dg-bogus \"redefined\" \"redefined foo\" } */\n+\n /* { dg-warning \"redefined\" \"redef mac\"     { target *-*-* } 7  }\n    { dg-warning \"redefined\" \"redef mac\"     { target *-*-* } 8  }\n    { dg-warning \"redefined\" \"redef mac\"     { target *-*-* } 9  }"}]}