{"sha": "ece320145fe3b1e1e344c82bcec5cec3b509fdda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlMzIwMTQ1ZmUzYjFlMWUzNDRjODJiY2VjNWNlYzNiNTA5ZmRkYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-28T07:44:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-28T07:44:12Z"}, "message": "c-common.c (c_get_alias_set): Tighten slightly for FUNCTION_TYPEs and ARRAY_TYPEs.\n\n\t* c-common.c (c_get_alias_set): Tighten slightly for FUNCTION_TYPEs\n\tand ARRAY_TYPEs.  Tidy up.  Improve support for type-punning.\n\t* expr.c (store_field): Add alias_set parameter.  Set the\n\tMEM_ALIAS_SET accordingly, if the target is a MEM.\n\t(expand_assignment): Use it.\n\t(store_constructor_field): Pass 0.\n\t(expand_expr): Likewise.\n\nFrom-SVN: r22620", "tree": {"sha": "db22c9fa0067adc3ff20a3a568eba5dcf67ce3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db22c9fa0067adc3ff20a3a568eba5dcf67ce3c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ece320145fe3b1e1e344c82bcec5cec3b509fdda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece320145fe3b1e1e344c82bcec5cec3b509fdda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece320145fe3b1e1e344c82bcec5cec3b509fdda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece320145fe3b1e1e344c82bcec5cec3b509fdda/comments", "author": null, "committer": null, "parents": [{"sha": "7d0756fbf15a0b02e566ce3a2193cb51772e3c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0756fbf15a0b02e566ce3a2193cb51772e3c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0756fbf15a0b02e566ce3a2193cb51772e3c0c"}], "stats": {"total": 99, "additions": 62, "deletions": 37}, "files": [{"sha": "154165c3c78297227b662a513c4be86840d55ae3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ece320145fe3b1e1e344c82bcec5cec3b509fdda", "patch": "@@ -1,3 +1,13 @@\n+Mon Sep 28 07:43:34 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* c-common.c (c_get_alias_set): Tighten slightly for FUNCTION_TYPEs\n+\tand ARRAY_TYPEs.  Tidy up.  Improve support for type-punning. \n+\t* expr.c (store_field): Add alias_set parameter.  Set the\n+\tMEM_ALIAS_SET accordingly, if the target is a MEM.\n+\t(expand_assignment): Use it.\n+\t(store_constructor_field): Pass 0.\n+\t(expand_expr): Likewise.\n+\n Mon Sep 28 07:54:03 1998  Catherine Moore  <clm@cygnus.com>\n  \n         * flags.h:  Add flag_data_sections."}, {"sha": "4d2e7a090a8b0b42098990360e0f84e2159362a6", "filename": "gcc/c-common.c", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ece320145fe3b1e1e344c82bcec5cec3b509fdda", "patch": "@@ -2990,21 +2990,21 @@ c_get_alias_set (t)\n     return 0;\n \n   type = (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    ? t :  TREE_TYPE (t);\n+    ? t : TREE_TYPE (t);\n \n   if (type == error_mark_node)\n     return 0;\n \n-  if (TYPE_ALIAS_SET_KNOWN_P (type))\n-    /* If we've already calculated the value, just return it.  */\n-    return TYPE_ALIAS_SET (type);\n+  /* Deal with special cases first; for certain kinds of references\n+     we're interested in more than just the type.  */\n \n   if (TREE_CODE (t) == BIT_FIELD_REF)\n     /* Perhaps reads and writes to this piece of data alias fields\n        neighboring the bitfield.  Perhaps that's impossible.  For now,\n        let's just assume that bitfields can alias everything, which is\n        the conservative assumption.  */\n     return 0;\n+\n   if (TREE_CODE (t) == COMPONENT_REF\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n     /* Permit type-punning when accessing a union, provided the\n@@ -3014,13 +3014,16 @@ c_get_alias_set (t)\n        GCC extension, albeit a common and useful one; the C standard\n        says that such accesses have implementation-defined behavior.  */ \n     return 0;\n+\n+  /* From here on, only the type matters.  */\n+\n+  if (TYPE_ALIAS_SET_KNOWN_P (type))\n+    /* If we've already calculated the value, just return it.  */\n+    return TYPE_ALIAS_SET (type);\n   else if (TYPE_MAIN_VARIANT (type) != type)\n-    {\n-      /* The C standard specifically allows aliasing between\n-\t cv-qualified variants of types.  */\n-      TYPE_ALIAS_SET (type) = c_get_alias_set (TYPE_MAIN_VARIANT (type));\n-      return TYPE_ALIAS_SET (type);\n-    }\n+    /* The C standard specifically allows aliasing between\n+       cv-qualified variants of types.  */\n+    TYPE_ALIAS_SET (type) = c_get_alias_set (TYPE_MAIN_VARIANT (type));\n   else if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n       tree signed_variant;\n@@ -3031,34 +3034,37 @@ c_get_alias_set (t)\n       signed_variant = signed_type (type);\n \n       if (signed_variant != type)\n-\t{\n-\t  TYPE_ALIAS_SET (type) = c_get_alias_set (signed_variant);\n-\t  return TYPE_ALIAS_SET (type);\n-\t}\n+\tTYPE_ALIAS_SET (type) = c_get_alias_set (signed_variant);\n       else if (signed_variant == signed_char_type_node)\n \t/* The C standard guarantess that any object may be accessed\n \t   via an lvalue that has character type.  We don't have to\n \t   check for unsigned_char_type_node or char_type_node because\n \t   we are specifically looking at the signed variant.  */\n-\t{\n-\t  TYPE_ALIAS_SET (type) = 0;\n-\t  return TYPE_ALIAS_SET (type);\n-\t}\n+\tTYPE_ALIAS_SET (type) = 0;\n     }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    /* Anything that can alias one of the array elements can alias\n+       the entire array as well.  */\n+    TYPE_ALIAS_SET (type) = c_get_alias_set (TREE_TYPE (type));\n+  else if (TREE_CODE (type) == FUNCTION_TYPE)\n+    /* There are no objects of FUNCTION_TYPE, so there's no point in\n+       using up an alias set for them.  (There are, of course,\n+       pointers and references to functions, but that's \n+       different.)  */\n+    TYPE_ALIAS_SET (type) = 0;\n   else if (TREE_CODE (type) == RECORD_TYPE\n \t   || TREE_CODE (type) == UNION_TYPE)\n-    {\n-      /* If TYPE is a struct or union type then we're reading or\n-\t writing an entire struct.  Thus, we don't know anything about\n-\t aliasing.  (In theory, such an access can only alias objects\n-\t whose type is the same as one of the fields, recursively, but\n-\t we don't yet make any use of that information.)  */\n-      TYPE_ALIAS_SET (type) = 0;\n-      return TYPE_ALIAS_SET (type);\n-    }\n+    /* If TYPE is a struct or union type then we're reading or\n+       writing an entire struct.  Thus, we don't know anything about\n+       aliasing.  (In theory, such an access can only alias objects\n+       whose type is the same as one of the fields, recursively, but\n+       we don't yet make any use of that information.)  */\n+    TYPE_ALIAS_SET (type) = 0;\n+\n+  if (!TYPE_ALIAS_SET_KNOWN_P (type)) \n+    /* TYPE is something we haven't seen before.  Put it in a new\n+       alias set.  */\n+    TYPE_ALIAS_SET (type) = new_alias_set ();\n \n-  /* TYPE is something we haven't seen before.  Put it in a new alias\n-     set.  */\n-  TYPE_ALIAS_SET (type) = new_alias_set ();\n   return TYPE_ALIAS_SET (type);\n }"}, {"sha": "19885880efcd049f4207eb8c4498b7567c3472ed", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece320145fe3b1e1e344c82bcec5cec3b509fdda/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ece320145fe3b1e1e344c82bcec5cec3b509fdda", "patch": "@@ -168,7 +168,8 @@ static void store_constructor_field PROTO((rtx, int, int, enum machine_mode,\n \t\t\t\t\t   tree, tree, int));\n static void store_constructor\tPROTO((tree, rtx, int));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n-\t\t\t\t       enum machine_mode, int, int, int));\n+\t\t\t\t       enum machine_mode, int, int,\n+\t\t\t\t       int, int));\n static enum memory_use_mode\n   get_memory_usage_from_modifier PROTO((enum expand_modifier));\n static tree save_noncopied_parts PROTO((tree, tree));\n@@ -3223,7 +3224,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t    unsignedp,\n \t\t\t    /* Required alignment of containing datum.  */\n \t\t\t    alignment,\n-\t\t\t    int_size_in_bytes (TREE_TYPE (tem)));\n+\t\t\t    int_size_in_bytes (TREE_TYPE (tem)),\n+\t\t\t    get_alias_set (to));\n       preserve_temp_slots (result);\n       free_temp_slots ();\n       pop_temp_slots ();\n@@ -3805,7 +3807,7 @@ store_constructor_field (target, bitsize, bitpos,\n   else\n     store_field (target, bitsize, bitpos, mode, exp,\n \t\t VOIDmode, 0, TYPE_ALIGN (type) / BITS_PER_UNIT,\n-\t\t int_size_in_bytes (type));\n+\t\t int_size_in_bytes (type), 0);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -4385,11 +4387,15 @@ store_constructor (exp, target, cleared)\n    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.\n \n    ALIGN is the alignment that TARGET is known to have, measured in bytes.\n-   TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.  */\n+   TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.  \n+\n+   ALIAS_SET is the alias set for the destination.  This value will\n+   (in general) be different from that for TARGET, since TARGET is a\n+   reference to the containing structure.  */\n \n static rtx\n store_field (target, bitsize, bitpos, mode, exp, value_mode,\n-\t     unsignedp, align, total_size)\n+\t     unsignedp, align, total_size, alias_set)\n      rtx target;\n      int bitsize, bitpos;\n      enum machine_mode mode;\n@@ -4398,6 +4404,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n      int unsignedp;\n      int align;\n      int total_size;\n+     int alias_set;\n {\n   HOST_WIDE_INT width_mask = 0;\n \n@@ -4433,7 +4440,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \temit_move_insn (object, target);\n \n       store_field (blk_object, bitsize, bitpos, mode, exp, VOIDmode, 0,\n-\t\t   align, total_size);\n+\t\t   align, total_size, alias_set);\n \n       /* Even though we aren't returning target, we need to\n \t give it the updated value.  */\n@@ -4548,6 +4555,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t\t\t\t(bitpos\n \t\t\t\t\t\t\t / BITS_PER_UNIT))));\n       MEM_IN_STRUCT_P (to_rtx) = 1;\n+      MEM_ALIAS_SET (to_rtx) = alias_set;\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n     }\n@@ -6614,7 +6622,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    store_field (target, GET_MODE_BITSIZE (TYPE_MODE (valtype)), 0,\n \t\t\t TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n \t\t\t VOIDmode, 0, 1,\n-\t\t\t int_size_in_bytes (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t\t int_size_in_bytes (TREE_TYPE (TREE_OPERAND (exp, 0))),\n+\t\t\t 0);\n \t  else\n \t    abort ();\n "}]}