{"sha": "e575382e2c7333247e5d8652e25657bf471c76f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3NTM4MmUyYzczMzMyNDdlNWQ4NjUyZTI1NjU3YmY0NzFjNzZmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-16T21:17:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-16T21:17:31Z"}, "message": "lto-symtab.c (merge_incomplete_and_complete_type): Remove.\n\n2009-10-16  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-symtab.c (merge_incomplete_and_complete_type): Remove.\n\t(maybe_merge_incomplete_and_complete_type): Likewise.\n\t(lto_symtab_merge): Do not call them.  Do not warn for\n\tcomplete vs. incomplete compatible types.\n\t(lto_symtab_merge_decls_2): Simplify.\n\t* gimple.c (gimple_force_type_merge): Remove.\n\t(gimple_types_compatible_p): Make it static.\n\t* gimple.h (gimple_force_type_merge): Remove.\n\t(gimple_types_compatible_p): Likewise.\n\nFrom-SVN: r152920", "tree": {"sha": "0742f0e935ac95e01024bdf0bebd8f8e4f270192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0742f0e935ac95e01024bdf0bebd8f8e4f270192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e575382e2c7333247e5d8652e25657bf471c76f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e575382e2c7333247e5d8652e25657bf471c76f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e575382e2c7333247e5d8652e25657bf471c76f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e575382e2c7333247e5d8652e25657bf471c76f7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ae278e724b821268d715bdb7535aefef0575b1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae278e724b821268d715bdb7535aefef0575b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae278e724b821268d715bdb7535aefef0575b1e"}], "stats": {"total": 332, "additions": 142, "deletions": 190}, "files": [{"sha": "ed8d6e3bec658656731dd144baf29b8eb461dda5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e575382e2c7333247e5d8652e25657bf471c76f7", "patch": "@@ -1,3 +1,15 @@\n+2009-10-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-symtab.c (merge_incomplete_and_complete_type): Remove.\n+\t(maybe_merge_incomplete_and_complete_type): Likewise.\n+\t(lto_symtab_merge): Do not call them.  Do not warn for\n+\tcomplete vs. incomplete compatible types.\n+\t(lto_symtab_merge_decls_2): Simplify.\n+\t* gimple.c (gimple_force_type_merge): Remove.\n+\t(gimple_types_compatible_p): Make it static.\n+\t* gimple.h (gimple_force_type_merge): Remove.\n+\t(gimple_types_compatible_p): Likewise.\n+\n 2009-10-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (mem_loc_descriptor) <case ZERO_EXTRACT>: Cast"}, {"sha": "80c2cf468315a284891940fc5c8ee9b9f275badd", "filename": "gcc/gimple.c", "status": "modified", "additions": 82, "deletions": 111, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e575382e2c7333247e5d8652e25657bf471c76f7", "patch": "@@ -3090,35 +3090,6 @@ lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n }\n \n \n-/* Force merging the type T2 into the type T1.  */\n-\n-void\n-gimple_force_type_merge (tree t1, tree t2)\n-{\n-  void **slot;\n-  type_pair_t p;\n-\n-  /* There's no other way than copying t2 to t1 in this case.\n-     Yuck.  We'll just call this \"completing\" t1.  */\n-  memcpy (t1, t2, tree_size (t1));\n-\n-  /* Adjust the hash value of T1 if it was computed already.  Otherwise\n-     we would be forced to not hash fields of structs to match the\n-     hash value of an incomplete struct.  */\n-  if (type_hash_cache\n-      && (slot = pointer_map_contains (type_hash_cache, t1)) != NULL)\n-    {\n-      gimple_type_hash (t2);\n-      *slot = *pointer_map_contains (type_hash_cache, t2);\n-    }\n-\n-  /* Adjust cached comparison results for T1 and T2 to make sure\n-     they now compare compatible.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n-  p->same_p = 1;\n-}\n-\n-\n /* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n    true then if any type has no name return false, otherwise return\n    true if both types have no names.  */\n@@ -3196,7 +3167,7 @@ compare_field_offset (tree f1, tree f2)\n /* Return 1 iff T1 and T2 are structurally identical.\n    Otherwise, return 0.  */\n \n-int\n+static int\n gimple_types_compatible_p (tree t1, tree t2)\n {\n   type_pair_t p = NULL;\n@@ -3404,107 +3375,107 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-\t{\n-\t  /* If the two pointers have different ref-all attributes,\n-\t     they can't be the same type.  */\n-\t  if (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n-\t    goto different_types;\n-\n-\t  /* If one pointer points to an incomplete type variant of\n-\t     the other pointed-to type they are the same.  */\n-\t  if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n-\t      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t1))\n-\t      && (!COMPLETE_TYPE_P (TREE_TYPE (t1))\n-\t\t  || !COMPLETE_TYPE_P (TREE_TYPE (t2)))\n-\t      && compare_type_names_p (TREE_TYPE (t1), TREE_TYPE (t2), true))\n-\t    {\n-\t      /* Replace the pointed-to incomplete type with the\n-\t\t complete one.  */\n-\t      if (COMPLETE_TYPE_P (TREE_TYPE (t2)))\n-\t\tTREE_TYPE (t1) = TREE_TYPE (t2);\n-\t      else\n-\t\tTREE_TYPE (t2) = TREE_TYPE (t1);\n-\t      goto same_types;\n-\t    }\n+      {\n+\t/* If the two pointers have different ref-all attributes,\n+\t   they can't be the same type.  */\n+\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t  goto different_types;\n \n-\t  /* Otherwise, pointer and reference types are the same if the\n-\t     pointed-to types are the same.  */\n-\t  if (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t/* If one pointer points to an incomplete type variant of\n+\t   the other pointed-to type they are the same.  */\n+\tif (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n+\t    && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t1))\n+\t    && (!COMPLETE_TYPE_P (TREE_TYPE (t1))\n+\t\t|| !COMPLETE_TYPE_P (TREE_TYPE (t2)))\n+\t    && compare_type_names_p (TREE_TYPE (t1), TREE_TYPE (t2), true))\n+\t  {\n+\t    /* Replace the pointed-to incomplete type with the\n+\t       complete one.  */\n+\t    if (COMPLETE_TYPE_P (TREE_TYPE (t2)))\n+\t      TREE_TYPE (t1) = TREE_TYPE (t2);\n+\t    else\n+\t      TREE_TYPE (t2) = TREE_TYPE (t1);\n \t    goto same_types;\n-\t  \n-\t  goto different_types;\n-\t}\n+\t  }\n+\n+\t/* Otherwise, pointer and reference types are the same if the\n+\t   pointed-to types are the same.  */\n+\tif (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t  goto same_types;\n+\n+\tgoto different_types;\n+      }\n \n     case ENUMERAL_TYPE:\n-\t{\n-\t  /* For enumeral types, all the values must be the same.  */\n-\t  tree v1, v2;\n+      {\n+\t/* For enumeral types, all the values must be the same.  */\n+\ttree v1, v2;\n \n-\t  if (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n-\t    goto same_types;\n+\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n+\t  goto same_types;\n \n-\t  for (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n-\t       v1 && v2;\n-\t       v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n-\t    {\n-\t      tree c1 = TREE_VALUE (v1);\n-\t      tree c2 = TREE_VALUE (v2);\n+\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n+\t     v1 && v2;\n+\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n+\t  {\n+\t    tree c1 = TREE_VALUE (v1);\n+\t    tree c2 = TREE_VALUE (v2);\n \n-\t      if (TREE_CODE (c1) == CONST_DECL)\n-\t\tc1 = DECL_INITIAL (c1);\n+\t    if (TREE_CODE (c1) == CONST_DECL)\n+\t      c1 = DECL_INITIAL (c1);\n \n-\t      if (TREE_CODE (c2) == CONST_DECL)\n-\t\tc2 = DECL_INITIAL (c2);\n+\t    if (TREE_CODE (c2) == CONST_DECL)\n+\t      c2 = DECL_INITIAL (c2);\n \n-\t      if (tree_int_cst_equal (c1, c2) != 1)\n-\t\tgoto different_types;\n-\t    }\n+\t    if (tree_int_cst_equal (c1, c2) != 1)\n+\t      goto different_types;\n+\t  }\n \n-\t  /* If one enumeration has more values than the other, they\n-\t     are not the same.  */\n-\t  if (v1 || v2)\n-\t    goto different_types;\n+\t/* If one enumeration has more values than the other, they\n+\t   are not the same.  */\n+\tif (v1 || v2)\n+\t  goto different_types;\n \n-\t  goto same_types;\n-\t}\n+\tgoto same_types;\n+      }\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-\t{\n-\t  tree f1, f2;\n+      {\n+\ttree f1, f2;\n \n-\t  /* If one type requires structural equality checks and the\n-\t     other doesn't, do not merge the types.  */\n-\t  if (TYPE_STRUCTURAL_EQUALITY_P (t1)\n-\t      != TYPE_STRUCTURAL_EQUALITY_P (t2))\n-\t    goto different_types;\n+\t/* If one type requires structural equality checks and the\n+\t   other doesn't, do not merge the types.  */\n+\tif (TYPE_STRUCTURAL_EQUALITY_P (t1)\n+\t    != TYPE_STRUCTURAL_EQUALITY_P (t2))\n+\t  goto different_types;\n \n-\t  /* The struct tags shall compare equal.  */\n-\t  if (!compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n-\t\t\t\t     TYPE_MAIN_VARIANT (t2), false))\n-\t    goto different_types;\n+\t/* The struct tags shall compare equal.  */\n+\tif (!compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n+\t\t\t\t   TYPE_MAIN_VARIANT (t2), false))\n+\t  goto different_types;\n \n-\t  /* For aggregate types, all the fields must be the same.  */\n-\t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t       f1 && f2;\n-\t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t    {\n-\t      /* The fields must have the same name, offset and type.  */\n-\t      if (DECL_NAME (f1) != DECL_NAME (f2)\n-\t\t  || !compare_field_offset (f1, f2)\n-\t\t  || !gimple_types_compatible_p (TREE_TYPE (f1),\n-\t\t\t\t\t    TREE_TYPE (f2)))\n-\t\tgoto different_types;\n-\t    }\n+\t/* For aggregate types, all the fields must be the same.  */\n+\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t     f1 && f2;\n+\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t  {\n+\t    /* The fields must have the same name, offset and type.  */\n+\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n+\t\t|| !compare_field_offset (f1, f2)\n+\t\t|| !gimple_types_compatible_p (TREE_TYPE (f1),\n+\t\t\t\t\t       TREE_TYPE (f2)))\n+\t      goto different_types;\n+\t  }\n \n-\t  /* If one aggregate has more fields than the other, they\n-\t     are not the same.  */\n-\t  if (f1 || f2)\n-\t    goto different_types;\n+\t/* If one aggregate has more fields than the other, they\n+\t   are not the same.  */\n+\tif (f1 || f2)\n+\t  goto different_types;\n \n-\t  goto same_types;\n-\t}\n+\tgoto same_types;\n+      }\n \n     case VECTOR_TYPE:\n       if (TYPE_VECTOR_SUBPARTS (t1) != TYPE_VECTOR_SUBPARTS (t2))"}, {"sha": "87309b694d40899b826d9727e4aa3f49530f4f0b", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e575382e2c7333247e5d8652e25657bf471c76f7", "patch": "@@ -915,8 +915,6 @@ extern bool is_gimple_call_addr (tree);\n extern tree get_call_expr_in (tree t);\n \n extern void recalculate_side_effects (tree);\n-extern void gimple_force_type_merge (tree, tree);\n-extern int gimple_types_compatible_p (tree, tree);\n extern tree gimple_register_type (tree);\n extern void print_gimple_types_stats (void);\n extern void free_gimple_type_tables (void);"}, {"sha": "275875180c62842359beae737868dd018244770e", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 48, "deletions": 77, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e575382e2c7333247e5d8652e25657bf471c76f7/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=e575382e2c7333247e5d8652e25657bf471c76f7", "patch": "@@ -182,57 +182,6 @@ lto_symtab_get_resolution (tree decl)\n }\n \n \n-static bool maybe_merge_incomplete_and_complete_type (tree, tree);\n-\n-/* Try to merge an incomplete type INCOMPLETE with a complete type\n-   COMPLETE of same kinds.\n-   Return true if they were merged, false otherwise.  */\n-\n-static bool\n-merge_incomplete_and_complete_type (tree incomplete, tree complete)\n-{\n-  /* For merging array types do some extra sanity checking.  */\n-  if (TREE_CODE (incomplete) == ARRAY_TYPE\n-      && !maybe_merge_incomplete_and_complete_type (TREE_TYPE (incomplete),\n-\t\t\t\t\t\t    TREE_TYPE (complete))\n-      && !gimple_types_compatible_p (TREE_TYPE (incomplete),\n-\t\t\t\t     TREE_TYPE (complete)))\n-    return false;\n-\n-  /* ??? Ideally we would do this by means of a common canonical type, but\n-     that's difficult as we do not have links from the canonical type\n-     back to all its children.  */\n-  gimple_force_type_merge (incomplete, complete);\n-\n-  return true;\n-}\n-\n-/* Try to merge a maybe complete / incomplete type pair TYPE1 and TYPE2.\n-   Return true if they were merged, false otherwise.  */\n-\n-static bool\n-maybe_merge_incomplete_and_complete_type (tree type1, tree type2)\n-{\n-  bool res = false;\n-\n-  if (TREE_CODE (type1) != TREE_CODE (type2))\n-    return false;\n-\n-  if (!COMPLETE_TYPE_P (type1) && COMPLETE_TYPE_P (type2))\n-    res = merge_incomplete_and_complete_type (type1, type2);\n-  else if (COMPLETE_TYPE_P (type1) && !COMPLETE_TYPE_P (type2))\n-    res = merge_incomplete_and_complete_type (type2, type1);\n-\n-  /* Recurse on pointer targets.  */\n-  if (!res\n-      && POINTER_TYPE_P (type1)\n-      && POINTER_TYPE_P (type2))\n-    res = maybe_merge_incomplete_and_complete_type (TREE_TYPE (type1),\n-\t\t\t\t\t\t    TREE_TYPE (type2));\n-\n-  return res;\n-}\n-\n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n \n@@ -300,8 +249,7 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      if (!gimple_types_compatible_p (TREE_TYPE (prevailing_decl),\n-\t\t\t\t      TREE_TYPE (decl)))\n+      if (TREE_TYPE (prevailing_decl) != TREE_TYPE (decl))\n \t/* If we don't have a merged type yet...sigh.  The linker\n \t   wouldn't complain if the types were mismatched, so we\n \t   probably shouldn't either.  Just use the type from\n@@ -315,32 +263,56 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n \n   /* Now we exclusively deal with VAR_DECLs.  */\n \n-  /* Handle external declarations with incomplete type or pointed-to\n-     incomplete types by forcefully merging the types.\n-     ???  In principle all types involved in the two decls should\n-     be merged forcefully, for example without considering type or\n-     field names.  */\n-  prevailing_type = TREE_TYPE (prevailing_decl);\n-  type = TREE_TYPE (decl);\n-\n-  /* If the types are structurally equivalent we can use the knowledge\n-     that both bind to the same symbol to complete incomplete types\n-     of external declarations or of pointer targets.\n-     ???  We should apply this recursively to aggregate members here\n-     and get rid of the completion in gimple_types_compatible_p.  */\n-  if (DECL_EXTERNAL (prevailing_decl) || DECL_EXTERNAL (decl))\n-    maybe_merge_incomplete_and_complete_type (prevailing_type, type);\n-  else if (POINTER_TYPE_P (prevailing_type)\n-\t   && POINTER_TYPE_P (type))\n-    maybe_merge_incomplete_and_complete_type (TREE_TYPE (prevailing_type),\n-\t\t\t\t\t      TREE_TYPE (type));\n+  /* Sharing a global symbol is a strong hint that two types are\n+     compatible.  We could use this information to complete\n+     incomplete pointed-to types more aggressively here, ignoring\n+     mismatches in both field and tag names.  It's difficult though\n+     to guarantee that this does not have side-effects on merging\n+     more compatible types from other translation units though.  */\n \n   /* We can tolerate differences in type qualification, the\n-     qualification of the prevailing definition will prevail.  */\n+     qualification of the prevailing definition will prevail.\n+     ???  In principle we might want to only warn for structurally\n+     incompatible types here, but unless we have protective measures\n+     for TBAA in place that would hide useful information.  */\n   prevailing_type = TYPE_MAIN_VARIANT (TREE_TYPE (prevailing_decl));\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n-  if (!gimple_types_compatible_p (prevailing_type, type))\n-    return false;\n+\n+  /* We have to register and fetch canonical types here as the global\n+     fixup process didn't yet run.  */\n+  prevailing_type = gimple_register_type (prevailing_type);\n+  type = gimple_register_type (type);\n+  if (prevailing_type != type)\n+    {\n+      if (COMPLETE_TYPE_P (type))\n+\treturn false;\n+\n+      /* If type is incomplete then avoid warnings in the cases\n+\t that TBAA handles just fine.  */\n+\n+      if (TREE_CODE (prevailing_type) != TREE_CODE (type))\n+\treturn false;\n+\n+      if (TREE_CODE (prevailing_type) == ARRAY_TYPE)\n+\t{\n+\t  tree tem1 = TREE_TYPE (prevailing_type);\n+\t  tree tem2 = TREE_TYPE (type);\n+\t  while (TREE_CODE (tem1) == ARRAY_TYPE\n+\t\t && TREE_CODE (tem2) == ARRAY_TYPE)\n+\t    {\n+\t      tem1 = TREE_TYPE (tem1);\n+\t      tem2 = TREE_TYPE (tem2);\n+\t    }\n+\n+\t  if (TREE_CODE (tem1) != TREE_CODE (tem2))\n+\t    return false;\n+\n+\t  if (gimple_register_type (tem1) != gimple_register_type (tem2))\n+\t    return false;\n+\t}\n+\n+      /* Fallthru.  Compatible enough.  */\n+    }\n \n   /* ???  We might want to emit a warning here if type qualification\n      differences were spotted.  Do not do this unconditionally though.  */\n@@ -505,8 +477,7 @@ lto_symtab_merge_decls_2 (void **slot)\n   /* Diagnose all mismatched re-declarations.  */\n   for (i = 0; VEC_iterate (tree, mismatches, i, decl); ++i)\n     {\n-      if (!gimple_types_compatible_p (TREE_TYPE (prevailing->decl),\n-\t\t\t\t      TREE_TYPE (decl)))\n+      if (TREE_TYPE (prevailing->decl) != TREE_TYPE (decl))\n \tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t   \"type of %qD does not match original \"\n \t\t\t\t   \"declaration\", decl);"}]}