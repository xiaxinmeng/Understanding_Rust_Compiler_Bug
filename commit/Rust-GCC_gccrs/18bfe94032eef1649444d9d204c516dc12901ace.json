{"sha": "18bfe94032eef1649444d9d204c516dc12901ace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThiZmU5NDAzMmVlZjE2NDk0NDRkOWQyMDRjNTE2ZGMxMjkwMWFjZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-05-03T07:49:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-05-03T07:49:43Z"}, "message": "re PR tree-optimization/79472 (x86-64: Switch table generation fails if default case has different code)\n\n\tPR tree-optimization/79472\n\t* tree-switch-conversion.c (struct switch_conv_info): Add\n\tcontiguous_range and default_case_nonstandard fields.\n\t(collect_switch_conv_info): Compute contiguous_range and\n\tdefault_case_nonstandard fields, don't clear final_bb if\n\tcontiguous_range and only the default case doesn't have the required\n\tstructure.\n\t(check_all_empty_except_final): Set default_case_nonstandard instead\n\tof failing if contiguous_range and the default case doesn't have empty\n\tblock.\n\t(check_final_bb): Add SWTCH argument, don't fail if contiguous_range\n\tand only the default case doesn't have the required constants.  Skip\n\tvirtual phis.\n\t(gather_default_values): Skip virtual phis.  Allow non-NULL CASE_LOW\n\tif default_case_nonstandard.\n\t(build_constructors): Build constant 1 just once.  Assert that default\n\tvalues aren't inserted in between cases if contiguous_range.  Skip\n\tvirtual phis.\n\t(build_arrays): Skip virtual phis.\n\t(prune_bbs): Add DEFAULT_BB argument, don't remove that bb.\n\t(fix_phi_nodes): Don't add e2f phi arg if default_case_nonstandard.\n\tHandle virtual phis.\n\t(gen_inbound_check): Handle default_case_nonstandard case.\n\t(process_switch): Adjust check_final_bb caller.  Call\n\tgather_default_values with the first non-default case instead of\n\tdefault case if default_case_nonstandard.\n\n\t* gcc.dg/tree-ssa/vrp40.c: Add -fno-tree-switch-conversion to dg-options.\n\t* gcc.dg/tree-ssa/vrp113.c: New test.\n\t* gcc.dg/tree-ssa/cswtch-3.c: New test.\n\t* gcc.dg/tree-ssa/cswtch-4.c: New test.\n\t* gcc.dg/tree-ssa/cswtch-5.c: New test.\n\nFrom-SVN: r247538", "tree": {"sha": "677559067befe1b2fabb60fceaf581474fa32f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/677559067befe1b2fabb60fceaf581474fa32f64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18bfe94032eef1649444d9d204c516dc12901ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bfe94032eef1649444d9d204c516dc12901ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18bfe94032eef1649444d9d204c516dc12901ace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bfe94032eef1649444d9d204c516dc12901ace/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53e62089fbe61bbf59dd1b14d006a619de7b5f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e62089fbe61bbf59dd1b14d006a619de7b5f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e62089fbe61bbf59dd1b14d006a619de7b5f87"}], "stats": {"total": 787, "additions": 716, "deletions": 71}, "files": [{"sha": "c565697058e3f7d0107077dde40225905e21125f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -1,3 +1,32 @@\n+2017-05-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79472\n+\t* tree-switch-conversion.c (struct switch_conv_info): Add\n+\tcontiguous_range and default_case_nonstandard fields.\n+\t(collect_switch_conv_info): Compute contiguous_range and\n+\tdefault_case_nonstandard fields, don't clear final_bb if\n+\tcontiguous_range and only the default case doesn't have the required\n+\tstructure.\n+\t(check_all_empty_except_final): Set default_case_nonstandard instead\n+\tof failing if contiguous_range and the default case doesn't have empty\n+\tblock.\n+\t(check_final_bb): Add SWTCH argument, don't fail if contiguous_range\n+\tand only the default case doesn't have the required constants.  Skip\n+\tvirtual phis.\n+\t(gather_default_values): Skip virtual phis.  Allow non-NULL CASE_LOW\n+\tif default_case_nonstandard.\n+\t(build_constructors): Build constant 1 just once.  Assert that default\n+\tvalues aren't inserted in between cases if contiguous_range.  Skip\n+\tvirtual phis.\n+\t(build_arrays): Skip virtual phis.\n+\t(prune_bbs): Add DEFAULT_BB argument, don't remove that bb.\n+\t(fix_phi_nodes): Don't add e2f phi arg if default_case_nonstandard.\n+\tHandle virtual phis.\n+\t(gen_inbound_check): Handle default_case_nonstandard case.\n+\t(process_switch): Adjust check_final_bb caller.  Call\n+\tgather_default_values with the first non-default case instead of\n+\tdefault case if default_case_nonstandard.\n+\n 2017-05-02  Nathan Sidwell  <nathan@acm.org>\n \n \t* ggc-page.c (move_ptes_to_front): Replace unsigned >0 with i--"}, {"sha": "3f6190bd0747527d02910c2b5e9f10e0fecb72bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -1,3 +1,12 @@\n+2017-05-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79472\n+\t* gcc.dg/tree-ssa/vrp40.c: Add -fno-tree-switch-conversion to dg-options.\n+\t* gcc.dg/tree-ssa/vrp113.c: New test.\n+\t* gcc.dg/tree-ssa/cswtch-3.c: New test.\n+\t* gcc.dg/tree-ssa/cswtch-4.c: New test.\n+\t* gcc.dg/tree-ssa/cswtch-5.c: New test.\n+\n 2017-05-03  Tom de Vries  <tom@codesourcery.com>\n \n \tPR testsuite/80557"}, {"sha": "b983c8fbe9280a52829d86d6d7363c306a31c556", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cswtch-3.c", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-3.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -0,0 +1,330 @@\n+/* PR tree-optimization/79472 */\n+/* { dg-options \"-O2 -fdump-tree-switchconv\" } */\n+/* { dg-do run } */\n+\n+int *expected;\n+\n+void\n+foo (int x, int y)\n+{\n+  if (x != expected[0] || y != expected[1])\n+    __builtin_abort ();\n+  expected += 2;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int v, int w)\n+{\n+  int i, j;\n+  if (w)\n+    {\n+      i = 129;\n+      j = i - 1;\n+      goto lab;\n+    }\n+  switch (v)\n+    {\n+    case 170:\n+      j = 7;\n+      i = 27;\n+      break;\n+    case 171:\n+      i = 8;\n+      j = 122;\n+      break;\n+    case 172:\n+      i = 21;\n+      j = -19;\n+      break;\n+    case 173:\n+      i = 18;\n+      j = 17;\n+      break;\n+    case 174:\n+      i = 139;\n+      j = -5;\n+      break;\n+    case 175:\n+      i = 14;\n+      j = -26;\n+      break;\n+    case 176:\n+      j = 5;\n+      i = -14;\n+      break;\n+    case 177:\n+      j = 8;\n+      i = 12;\n+      break;\n+    default:\n+      __builtin_abort ();\n+    }\n+\n+ lab:\n+  foo (i, j);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int v)\n+{\n+  int i, j;\n+  switch (v)\n+    {\n+    case 170:\n+      j = 7;\n+      i = 27;\n+      break;\n+    case 171:\n+      i = 8;\n+      j = 122;\n+      break;\n+    case 172:\n+      i = 21;\n+      j = -19;\n+      break;\n+    case 173:\n+      i = 18;\n+      j = 17;\n+      break;\n+    case 174:\n+      i = 139;\n+      j = -5;\n+      break;\n+    case 175:\n+      i = 14;\n+      j = -26;\n+      break;\n+    case 176:\n+      j = 5;\n+      i = -14;\n+      break;\n+    case 177:\n+      j = 8;\n+      i = 12;\n+      break;\n+    default:\n+      foo (5, 12);\n+      foo (17, 19);\n+      i = 8;\n+      j = 19;\n+      break;\n+    }\n+\n+  foo (i, j);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (int v)\n+{\n+  int i;\n+  switch (v)\n+    {\n+    default:\n+      i = v;\n+      goto lab;\n+    case 170:\n+      i = 27;\n+      break;\n+    case 171:\n+      i = 8;\n+      break;\n+    case 172:\n+      i = 21;\n+      break;\n+    case 173:\n+      i = 18;\n+      break;\n+    case 174:\n+      i = 139;\n+      break;\n+    case 175:\n+      i = 14;\n+      break;\n+    case 176:\n+      i = -14;\n+      break;\n+    case 177:\n+      i = 12;\n+      break;\n+    }\n+\n+ lab:\n+  foo (i, -5);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (int v, int w)\n+{\n+  int i, j, k = 5;\n+  if (w)\n+    {\n+      foo (0, 0);\n+      k = 26;\n+      goto do_default;\n+    }\n+  switch (v)\n+    {\n+    case 170:\n+      j = 7;\n+      i = 27;\n+      break;\n+    case 171:\n+      i = 8;\n+      j = 122;\n+      break;\n+    case 172:\n+      i = 21;\n+      j = -19;\n+      break;\n+    case 173:\n+      i = 18;\n+      j = 17;\n+      break;\n+    case 174:\n+      i = 139;\n+      j = -5;\n+      break;\n+    case 175:\n+      i = 14;\n+      j = -26;\n+      break;\n+    case 176:\n+      j = 5;\n+      i = -14;\n+      break;\n+    case 177:\n+      j = 8;\n+      i = 12;\n+      break;\n+    default:\n+    do_default:\n+      foo (5, 12);\n+      foo (17, 19);\n+      i = 8;\n+      j = 19;\n+      break;\n+    }\n+\n+  foo (i, j + k);\n+}\n+\n+void\n+f5 (int v, int w)\n+{\n+  int i;\n+  if (w)\n+    {\n+      foo (23, 0);\n+      i = 129;\n+    }\n+  else\n+    switch (v)\n+      {\n+      case 170:\n+\ti = 27;\n+\tbreak;\n+      case 171:\n+\ti = 8;\n+\tbreak;\n+      case 172:\n+\ti = 21;\n+\tbreak;\n+      case 173:\n+\ti = 18;\n+\tbreak;\n+      case 174:\n+\ti = 139;\n+\tbreak;\n+      case 175:\n+\ti = 14;\n+\tbreak;\n+      case 176:\n+\ti = -14;\n+\tbreak;\n+      case 177:\n+\ti = 12;\n+\tbreak;\n+      default:\n+\ti = 80;\n+\tbreak;\n+      }\n+\n+ lab:\n+  foo (i, 0);\n+}\n+\n+int\n+main ()\n+{\n+  int *e;\n+#define T(call, cnt, ...) \\\n+  expected = e = (int []) __VA_ARGS__;\t\t\\\n+  call;\t\t\t\t\t\t\\\n+  if (expected != e + cnt)\t\t\t\\\n+    __builtin_abort ()\n+  T (f1 (171, 1), 2, { 129, 128 });\n+  T (f1 (140, 1), 2, { 129, 128 });\n+  T (f1 (170, 0), 2, { 27, 7 });\n+  T (f1 (171, 0), 2, { 8, 122 });\n+  T (f1 (172, 0), 2, { 21, -19 });\n+  T (f1 (173, 0), 2, { 18, 17 });\n+  T (f1 (174, 0), 2, { 139, -5 });\n+  T (f1 (175, 0), 2, { 14, -26 });\n+  T (f1 (176, 0), 2, { -14, 5 });\n+  T (f1 (177, 0), 2, { 12, 8 });\n+  T (f2 (-31), 6, { 5, 12, 17, 19, 8, 19 });\n+  T (f2 (169), 6, { 5, 12, 17, 19, 8, 19 });\n+  T (f2 (170), 2, { 27, 7 });\n+  T (f2 (171), 2, { 8, 122 });\n+  T (f2 (172), 2, { 21, -19 });\n+  T (f2 (173), 2, { 18, 17 });\n+  T (f2 (174), 2, { 139, -5 });\n+  T (f2 (175), 2, { 14, -26 });\n+  T (f2 (176), 2, { -14, 5 });\n+  T (f2 (177), 2, { 12, 8 });\n+  T (f2 (178), 6, { 5, 12, 17, 19, 8, 19 });\n+  T (f2 (231), 6, { 5, 12, 17, 19, 8, 19 });\n+  T (f3 (-31), 2, { -31, -5 });\n+  T (f3 (169), 2, { 169, -5 });\n+  T (f3 (170), 2, { 27, -5 });\n+  T (f3 (171), 2, { 8, -5 });\n+  T (f3 (172), 2, { 21, -5 });\n+  T (f3 (173), 2, { 18, -5 });\n+  T (f3 (174), 2, { 139, -5 });\n+  T (f3 (175), 2, { 14, -5 });\n+  T (f3 (176), 2, { -14, -5 });\n+  T (f3 (177), 2, { 12, -5 });\n+  T (f3 (178), 2, { 178, -5 });\n+  T (f3 (231), 2, { 231, -5 });\n+  T (f4 (171, 1), 8, { 0, 0, 5, 12, 17, 19, 8, 45 });\n+  T (f4 (140, 1), 8, { 0, 0, 5, 12, 17, 19, 8, 45 });\n+  T (f4 (-31, 0), 6, { 5, 12, 17, 19, 8, 24 });\n+  T (f4 (169, 0), 6, { 5, 12, 17, 19, 8, 24 });\n+  T (f4 (170, 0), 2, { 27, 12 });\n+  T (f4 (171, 0), 2, { 8, 127 });\n+  T (f4 (172, 0), 2, { 21, -14 });\n+  T (f4 (173, 0), 2, { 18, 22 });\n+  T (f4 (174, 0), 2, { 139, 0 });\n+  T (f4 (175, 0), 2, { 14, -21 });\n+  T (f4 (176, 0), 2, { -14, 10 });\n+  T (f4 (177, 0), 2, { 12, 13 });\n+  T (f4 (178, 0), 6, { 5, 12, 17, 19, 8, 24 });\n+  T (f4 (231, 0), 6, { 5, 12, 17, 19, 8, 24 });\n+  T (f5 (171, 1), 4, { 23, 0, 129, 0 });\n+  T (f5 (140, 1), 4, { 23, 0, 129, 0 });\n+  T (f5 (-31, 0), 2, { 80, 0 });\n+  T (f5 (169, 0), 2, { 80, 0 });\n+  T (f5 (170, 0), 2, { 27, 0 });\n+  T (f5 (171, 0), 2, { 8, 0 });\n+  T (f5 (172, 0), 2, { 21, 0 });\n+  T (f5 (173, 0), 2, { 18, 0 });\n+  T (f5 (174, 0), 2, { 139, 0 });\n+  T (f5 (175, 0), 2, { 14, 0 });\n+  T (f5 (176, 0), 2, { -14, 0 });\n+  T (f5 (177, 0), 2, { 12, 0 });\n+  T (f5 (178, 0), 2, { 80, 0 });\n+  T (f5 (231, 0), 2, { 80, 0 });\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Switch converted\" 5 \"switchconv\" } } */\n+/* { dg-final { scan-tree-dump-times \"= CSWTCH\" 8 \"switchconv\" } } */"}, {"sha": "962690d75e69b64a01d59930698a0c6fb4d8b50d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cswtch-4.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-4.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -0,0 +1,57 @@\n+/* PR tree-optimization/79472 */\n+/* { dg-options \"-O2 -fdump-tree-switchconv\" } */\n+/* { dg-do compile } */\n+\n+void\n+frobulate (unsigned int v)\n+{\n+  const char *s;\n+  \n+  switch (v)\n+    {\n+    case 0:\n+      s = \"foo\";\n+      break;\n+    case 1:\n+      s = \"bar\";\n+      break;\n+    case 2:\n+      s = \"spam\";\n+      break;\n+    default:\n+      __builtin_abort ();\n+      break;\n+    }\n+\n+  __builtin_printf (\"%s\\n\", s);\n+}\n+\n+void\n+frobulate_for_gcc (unsigned int v)\n+{\n+  const char *s;\n+  \n+  switch (v)\n+    {\n+    case 0:\n+      s = \"foo\";\n+      break;\n+    case 1:\n+      s = \"bar\";\n+      break;\n+    case 2:\n+      s = \"spam\";\n+      break;\n+    default:\n+      s = (const char *) 0;\n+      break;\n+    }\n+  \n+  if (!s)\n+    __builtin_abort ();\n+  \n+  __builtin_printf (\"%s\\n\", s);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Switch converted\" 2 \"switchconv\" } } */\n+/* { dg-final { scan-tree-dump-times \"= CSWTCH\" 2 \"switchconv\" } } */"}, {"sha": "96a86bb87cfb8682bb8b1f197f99d153c7edc066", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cswtch-5.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch-5.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -0,0 +1,66 @@\n+/* PR tree-optimization/79472 */\n+/* { dg-options \"-O2 -fdump-tree-switchconv\" } */\n+/* { dg-do compile } */\n+\n+void\n+foo (unsigned int v)\n+{\n+  const char *s;\n+  \n+  switch (v)\n+    {\n+    case 0:\n+      s = \"foo\";\n+      break;\n+    case 1:\n+      s = \"bar\";\n+      break;\n+    case 2:\n+      s = \"spam\";\n+      break;\n+    default:\n+      for (int i = 0; i < v; i++)\n+        __builtin_printf (\"baz\\n\");\n+      return;\n+    }\n+\n+  __builtin_printf (\"%s\\n\", s);\n+}\n+\n+int\n+bar (unsigned int v, int w)\n+{\n+  const char *s;\n+  \n+  switch (v)\n+    {\n+    case 0:\n+      s = \"foo\";\n+      break;\n+    case 1:\n+      s = \"bar\";\n+      break;\n+    case 2:\n+      s = \"spam\";\n+      break;\n+    default:\n+      __builtin_printf (\"baz\\n\");\n+      if (v > 25)\n+\t__builtin_printf (\"bl1\\n\");\n+      else\n+\t__builtin_printf (\"bl2\\n\");\n+      goto lab;\n+    }\n+\n+  __builtin_printf (\"%s\\n\", s);\n+  if (w > 25)\n+    __builtin_printf (\"cl1\\n\");\n+  else\n+    __builtin_printf (\"cl2\\n\");\n+ lab:\n+  __builtin_printf (\"dl\\n\");\n+  return v + w;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Switch converted\" 2 \"switchconv\" } } */\n+/* { dg-final { scan-tree-dump-times \"= CSWTCH\" 2 \"switchconv\" } } */"}, {"sha": "5069fdfa784ae736ea26b0a5fca2ce96dc7283f1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp113.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp113.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp113.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp113.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int f(int a) {\n+    switch (a & 1) {\n+      case 0:\n+      case 1: return  3;\n+      case 2: return  5;\n+      case 3: return  7;\n+      case 4: return 11;\n+      case 5: return 13;\n+      case 6: return 17;\n+      case 7: return 19;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 3;\" \"vrp1\" { xfail *-*-* } } } */"}, {"sha": "394b5fcf44edea6ea6e5f76e2939775f9b4fbb50", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp40.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1 -fno-tree-switch-conversion\" } */\n \n int f(int a) {\n     switch (a & 1) {"}, {"sha": "14e605dc001071cf85dbe100ae400484305f48fc", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 207, "deletions": 70, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bfe94032eef1649444d9d204c516dc12901ace/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=18bfe94032eef1649444d9d204c516dc12901ace", "patch": "@@ -592,6 +592,14 @@ struct switch_conv_info\n      dump file, if there is one.  */\n   const char *reason;\n \n+  /* True if default case is not used for any value between range_min and\n+     range_max inclusive.  */\n+  bool contiguous_range;\n+\n+  /* True if default case does not have the required shape for other case\n+     labels.  */\n+  bool default_case_nonstandard;\n+\n   /* Parameters for expand_switch_using_bit_tests.  Should be computed\n      the same way as in expand_case.  */\n   unsigned int uniq;\n@@ -606,8 +614,9 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n   tree min_case, max_case;\n   unsigned int count, i;\n-  edge e, e_default;\n+  edge e, e_default, e_first;\n   edge_iterator ei;\n+  basic_block first;\n \n   memset (info, 0, sizeof (*info));\n \n@@ -616,26 +625,63 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n      Collect the bits we can deduce from the CFG.  */\n   info->index_expr = gimple_switch_index (swtch);\n   info->switch_bb = gimple_bb (swtch);\n-  info->default_bb =\n-    label_to_block (CASE_LABEL (gimple_switch_default_label (swtch)));\n+  info->default_bb\n+    = label_to_block (CASE_LABEL (gimple_switch_default_label (swtch)));\n   e_default = find_edge (info->switch_bb, info->default_bb);\n   info->default_prob = e_default->probability;\n   info->default_count = e_default->count;\n   FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n     if (e != e_default)\n       info->other_count += e->count;\n \n+  /* Get upper and lower bounds of case values, and the covered range.  */\n+  min_case = gimple_switch_label (swtch, 1);\n+  max_case = gimple_switch_label (swtch, branch_num - 1);\n+\n+  info->range_min = CASE_LOW (min_case);\n+  if (CASE_HIGH (max_case) != NULL_TREE)\n+    info->range_max = CASE_HIGH (max_case);\n+  else\n+    info->range_max = CASE_LOW (max_case);\n+\n+  info->contiguous_range = true;\n+  tree last = CASE_HIGH (min_case) ? CASE_HIGH (min_case) : info->range_min;\n+  for (i = 2; i < branch_num; i++)\n+    {\n+      tree elt = gimple_switch_label (swtch, i);\n+      wide_int w = last;\n+      if (w + 1 != CASE_LOW (elt))\n+\t{\n+\t  info->contiguous_range = false;\n+\t  break;\n+\t}\n+      last = CASE_HIGH (elt) ? CASE_HIGH (elt) : CASE_LOW (elt);\n+    }\n+\n+  if (info->contiguous_range)\n+    {\n+      first = label_to_block (CASE_LABEL (gimple_switch_label (swtch, 1)));\n+      e_first = find_edge (info->switch_bb, first);\n+    }\n+  else\n+    {\n+      first = info->default_bb;\n+      e_first = e_default;\n+    }\n+\n   /* See if there is one common successor block for all branch\n      targets.  If it exists, record it in FINAL_BB.\n-     Start with the destination of the default case as guess\n-     or its destination in case it is a forwarder block.  */\n-  if (! single_pred_p (e_default->dest))\n-    info->final_bb = e_default->dest;\n-  else if (single_succ_p (e_default->dest)\n-\t   && ! single_pred_p (single_succ (e_default->dest)))\n-    info->final_bb = single_succ (e_default->dest);\n+     Start with the destination of the first non-default case\n+     if the range is contiguous and default case otherwise as\n+     guess or its destination in case it is a forwarder block.  */\n+  if (! single_pred_p (e_first->dest))\n+    info->final_bb = e_first->dest;\n+  else if (single_succ_p (e_first->dest)\n+\t   && ! single_pred_p (single_succ (e_first->dest)))\n+    info->final_bb = single_succ (e_first->dest);\n   /* Require that all switch destinations are either that common\n-     FINAL_BB or a forwarder to it.  */\n+     FINAL_BB or a forwarder to it, except for the default\n+     case if contiguous range.  */\n   if (info->final_bb)\n     FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n       {\n@@ -647,22 +693,18 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n \t    && single_succ (e->dest) == info->final_bb)\n \t  continue;\n \n+\tif (e == e_default && info->contiguous_range)\n+\t  {\n+\t    info->default_case_nonstandard = true;\n+\t    continue;\n+\t  }\n+\n \tinfo->final_bb = NULL;\n \tbreak;\n       }\n \n-  /* Get upper and lower bounds of case values, and the covered range.  */\n-  min_case = gimple_switch_label (swtch, 1);\n-  max_case = gimple_switch_label (swtch, branch_num - 1);\n-\n-  info->range_min = CASE_LOW (min_case);\n-  if (CASE_HIGH (max_case) != NULL_TREE)\n-    info->range_max = CASE_HIGH (max_case);\n-  else\n-    info->range_max = CASE_LOW (max_case);\n-\n-  info->range_size =\n-    int_const_binop (MINUS_EXPR, info->range_max, info->range_min);\n+  info->range_size\n+    = int_const_binop (MINUS_EXPR, info->range_max, info->range_min);\n \n   /* Get a count of the number of case labels.  Single-valued case labels\n      simply count as one, but a case range counts double, since it may\n@@ -713,7 +755,7 @@ check_range (struct switch_conv_info *info)\n static bool\n check_all_empty_except_final (struct switch_conv_info *info)\n {\n-  edge e;\n+  edge e, e_default = find_edge (info->switch_bb, info->default_bb);\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n@@ -723,6 +765,12 @@ check_all_empty_except_final (struct switch_conv_info *info)\n \n       if (!empty_block_p (e->dest))\n \t{\n+\t  if (info->contiguous_range && e == e_default)\n+\t    {\n+\t      info->default_case_nonstandard = true;\n+\t      continue;\n+\t    }\n+\n \t  info->reason = \"bad case - a non-final BB not empty\";\n \t  return false;\n \t}\n@@ -737,7 +785,7 @@ check_all_empty_except_final (struct switch_conv_info *info)\n    phi nodes are OK, otherwise false.  */\n \n static bool\n-check_final_bb (struct switch_conv_info *info)\n+check_final_bb (gswitch *swtch, struct switch_conv_info *info)\n {\n   gphi_iterator gsi;\n \n@@ -747,34 +795,65 @@ check_final_bb (struct switch_conv_info *info)\n       gphi *phi = gsi.phi ();\n       unsigned int i;\n \n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\tcontinue;\n+\n       info->phi_count++;\n \n       for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t{\n \t  basic_block bb = gimple_phi_arg_edge (phi, i)->src;\n \n \t  if (bb == info->switch_bb\n-\t      || (single_pred_p (bb) && single_pred (bb) == info->switch_bb))\n+\t      || (single_pred_p (bb)\n+\t\t  && single_pred (bb) == info->switch_bb\n+\t\t  && (!info->default_case_nonstandard\n+\t\t      || empty_block_p (bb))))\n \t    {\n \t      tree reloc, val;\n+\t      const char *reason = NULL;\n \n \t      val = gimple_phi_arg_def (phi, i);\n \t      if (!is_gimple_ip_invariant (val))\n+\t\treason = \"non-invariant value from a case\";\n+\t      else\n \t\t{\n-\t\t  info->reason = \"non-invariant value from a case\";\n-\t\t  return false; /* Non-invariant argument.  */\n+\t\t  reloc = initializer_constant_valid_p (val, TREE_TYPE (val));\n+\t\t  if ((flag_pic && reloc != null_pointer_node)\n+\t\t      || (!flag_pic && reloc == NULL_TREE))\n+\t\t    {\n+\t\t      if (reloc)\n+\t\t\treason\n+\t\t\t  = \"value from a case would need runtime relocations\";\n+\t\t      else\n+\t\t\treason\n+\t\t\t  = \"value from a case is not a valid initializer\";\n+\t\t    }\n \t\t}\n-\t      reloc = initializer_constant_valid_p (val, TREE_TYPE (val));\n-\t      if ((flag_pic && reloc != null_pointer_node)\n-\t\t  || (!flag_pic && reloc == NULL_TREE))\n+\t      if (reason)\n \t\t{\n-\t\t  if (reloc)\n-\t\t    info->reason\n-\t\t      = \"value from a case would need runtime relocations\";\n-\t\t  else\n-\t\t    info->reason\n-\t\t      = \"value from a case is not a valid initializer\";\n-\t\t  return false;\n+\t\t  /* For contiguous range, we can allow non-constant\n+\t\t     or one that needs relocation, as long as it is\n+\t\t     only reachable from the default case.  */\n+\t\t  if (bb == info->switch_bb)\n+\t\t    bb = info->final_bb;\n+\t\t  if (!info->contiguous_range || bb != info->default_bb)\n+\t\t    {\n+\t\t      info->reason = reason;\n+\t\t      return false;\n+\t\t    }\n+\n+\t\t  unsigned int branch_num = gimple_switch_num_labels (swtch);\n+\t\t  for (unsigned int i = 1; i < branch_num; i++)\n+\t\t    {\n+\t\t      tree lab = CASE_LABEL (gimple_switch_label (swtch, i));\n+\t\t      if (label_to_block (lab) == bb)\n+\t\t\t{\n+\t\t\t  info->reason = reason;\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t    }\n+\t\t  info->default_case_nonstandard = true;\n \t\t}\n \t    }\n \t}\n@@ -815,7 +894,9 @@ free_temp_arrays (struct switch_conv_info *info)\n }\n \n /* Populate the array of default values in the order of phi nodes.\n-   DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch.  */\n+   DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch\n+   if the range is non-contiguous or the default case has standard\n+   structure, otherwise it is the first non-default case instead.  */\n \n static void\n gather_default_values (tree default_case, struct switch_conv_info *info)\n@@ -825,7 +906,8 @@ gather_default_values (tree default_case, struct switch_conv_info *info)\n   edge e;\n   int i = 0;\n \n-  gcc_assert (CASE_LOW (default_case) == NULL_TREE);\n+  gcc_assert (CASE_LOW (default_case) == NULL_TREE\n+\t      || info->default_case_nonstandard);\n \n   if (bb == info->final_bb)\n     e = find_edge (info->switch_bb, bb);\n@@ -835,6 +917,8 @@ gather_default_values (tree default_case, struct switch_conv_info *info)\n   for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\tcontinue;\n       tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       gcc_assert (val);\n       info->default_values[i++] = val;\n@@ -850,6 +934,7 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n {\n   unsigned i, branch_num = gimple_switch_num_labels (swtch);\n   tree pos = info->range_min;\n+  tree pos_one = build_int_cst (TREE_TYPE (pos), 1);\n \n   for (i = 1; i < branch_num; i++)\n     {\n@@ -869,6 +954,7 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n       while (tree_int_cst_lt (pos, CASE_LOW (cs)))\n \t{\n \t  int k;\n+\t  gcc_assert (!info->contiguous_range);\n \t  for (k = 0; k < info->phi_count; k++)\n \t    {\n \t      constructor_elt elt;\n@@ -879,8 +965,7 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n \t      info->constructors[k]->quick_push (elt);\n \t    }\n \n-\t  pos = int_const_binop (PLUS_EXPR, pos,\n-\t\t\t\t build_int_cst (TREE_TYPE (pos), 1));\n+\t  pos = int_const_binop (PLUS_EXPR, pos, pos_one);\n \t}\n       gcc_assert (tree_int_cst_equal (pos, CASE_LOW (cs)));\n \n@@ -893,6 +978,8 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    continue;\n \t  tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t  tree low = CASE_LOW (cs);\n \t  pos = CASE_LOW (cs);\n@@ -905,8 +992,7 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n \t      elt.value = unshare_expr_without_location (val);\n \t      info->constructors[j]->quick_push (elt);\n \n-\t      pos = int_const_binop (PLUS_EXPR, pos,\n-\t\t\t\t     build_int_cst (TREE_TYPE (pos), 1));\n+\t      pos = int_const_binop (PLUS_EXPR, pos, pos_one);\n \t    } while (!tree_int_cst_lt (high, pos)\n \t\t     && tree_int_cst_lt (low, pos));\n \t  j++;\n@@ -1125,8 +1211,12 @@ build_arrays (gswitch *swtch, struct switch_conv_info *info)\n   info->arr_ref_first = stmt;\n \n   for (gpi = gsi_start_phis (info->final_bb), i = 0;\n-       !gsi_end_p (gpi); gsi_next (&gpi), i++)\n-    build_one_array (swtch, i, arr_index_type, gpi.phi (), tidx, info);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      gphi *phi = gpi.phi ();\n+      if (!virtual_operand_p (gimple_phi_result (phi)))\n+\tbuild_one_array (swtch, i++, arr_index_type, phi, tidx, info);\n+    }\n }\n \n /* Generates and appropriately inserts loads of default values at the position\n@@ -1155,7 +1245,7 @@ gen_def_assigns (gimple_stmt_iterator *gsi, struct switch_conv_info *info)\n    of succession).  */\n \n static void\n-prune_bbs (basic_block bbd, basic_block final)\n+prune_bbs (basic_block bbd, basic_block final, basic_block default_bb)\n {\n   edge_iterator ei;\n   edge e;\n@@ -1165,7 +1255,7 @@ prune_bbs (basic_block bbd, basic_block final)\n       basic_block bb;\n       bb = e->dest;\n       remove_edge (e);\n-      if (bb != final)\n+      if (bb != final && bb != default_bb)\n \tdelete_basic_block (bb);\n     }\n   delete_basic_block (bbd);\n@@ -1184,11 +1274,20 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n   int i;\n \n   for (gsi = gsi_start_phis (bbf), i = 0;\n-       !gsi_end_p (gsi); gsi_next (&gsi), i++)\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n-      add_phi_arg (phi, info->target_inbound_names[i], e1f, UNKNOWN_LOCATION);\n-      add_phi_arg (phi, info->target_outbound_names[i], e2f, UNKNOWN_LOCATION);\n+      tree inbound, outbound;\n+      if (virtual_operand_p (gimple_phi_result (phi)))\n+\tinbound = outbound = gimple_vop (cfun);\n+      else\n+\t{\n+\t  inbound = info->target_inbound_names[i];\n+\t  outbound = info->target_outbound_names[i++];\n+\t}\n+      add_phi_arg (phi, inbound, e1f, UNKNOWN_LOCATION);\n+      if (!info->default_case_nonstandard)\n+\tadd_phi_arg (phi, outbound, e2f, UNKNOWN_LOCATION);\n     }\n }\n \n@@ -1225,10 +1324,10 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n \n   gcond *cond_stmt;\n \n-  gassign *last_assign;\n+  gassign *last_assign = NULL;\n   gimple_stmt_iterator gsi;\n   basic_block bb0, bb1, bb2, bbf, bbd;\n-  edge e01, e02, e21, e1d, e1f, e2f;\n+  edge e01 = NULL, e02, e21, e1d, e1f, e2f;\n   location_t loc = gimple_location (swtch);\n \n   gcc_assert (info->default_values);\n@@ -1248,9 +1347,12 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   update_stmt (cond_stmt);\n \n   /* block 2 */\n-  label2 = gimple_build_label (label_decl2);\n-  gsi_insert_before (&gsi, label2, GSI_SAME_STMT);\n-  last_assign = gen_def_assigns (&gsi, info);\n+  if (!info->default_case_nonstandard)\n+    {\n+      label2 = gimple_build_label (label_decl2);\n+      gsi_insert_before (&gsi, label2, GSI_SAME_STMT);\n+      last_assign = gen_def_assigns (&gsi, info);\n+    }\n \n   /* block 1 */\n   label1 = gimple_build_label (label_decl1);\n@@ -1265,16 +1367,40 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   e02 = split_block (bb0, cond_stmt);\n   bb2 = e02->dest;\n \n-  e21 = split_block (bb2, last_assign);\n-  bb1 = e21->dest;\n-  remove_edge (e21);\n+  if (info->default_case_nonstandard)\n+    {\n+      bb1 = bb2;\n+      bb2 = info->default_bb;\n+      e01 = e02;\n+      e01->flags = EDGE_TRUE_VALUE;\n+      e02 = make_edge (bb0, bb2, EDGE_FALSE_VALUE);\n+      edge e_default = find_edge (bb1, bb2);\n+      for (gphi_iterator gsi = gsi_start_phis (bb2);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e_default);\n+\t  add_phi_arg (phi, arg, e02,\n+\t\t       gimple_phi_arg_location_from_edge (phi, e_default));\n+\t}\n+      /* Partially fix the dominator tree, if it is available.  */\n+      if (dom_info_available_p (CDI_DOMINATORS))\n+\tredirect_immediate_dominators (CDI_DOMINATORS, bb1, bb0);\n+    }\n+  else\n+    {\n+      e21 = split_block (bb2, last_assign);\n+      bb1 = e21->dest;\n+      remove_edge (e21);\n+    }\n \n   e1d = split_block (bb1, info->arr_ref_last);\n   bbd = e1d->dest;\n   remove_edge (e1d);\n \n   /* flags and profiles of the edge for in-range values */\n-  e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n+  if (!info->default_case_nonstandard)\n+    e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n   e01->probability = REG_BR_PROB_BASE - info->default_prob;\n   e01->count = info->other_count;\n \n@@ -1290,17 +1416,24 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   e1f->probability = REG_BR_PROB_BASE;\n   e1f->count = info->other_count;\n \n-  e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n-  e2f->probability = REG_BR_PROB_BASE;\n-  e2f->count = info->default_count;\n+  if (info->default_case_nonstandard)\n+    e2f = NULL;\n+  else\n+    {\n+      e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n+      e2f->probability = REG_BR_PROB_BASE;\n+      e2f->count = info->default_count;\n+    }\n \n   /* frequencies of the new BBs */\n   bb1->frequency = EDGE_FREQUENCY (e01);\n   bb2->frequency = EDGE_FREQUENCY (e02);\n-  bbf->frequency = EDGE_FREQUENCY (e1f) + EDGE_FREQUENCY (e2f);\n+  if (!info->default_case_nonstandard)\n+    bbf->frequency = EDGE_FREQUENCY (e1f) + EDGE_FREQUENCY (e2f);\n \n   /* Tidy blocks that have become unreachable.  */\n-  prune_bbs (bbd, info->final_bb);\n+  prune_bbs (bbd, info->final_bb,\n+\t     info->default_case_nonstandard ? info->default_bb : NULL);\n \n   /* Fixup the PHI nodes in bbF.  */\n   fix_phi_nodes (e1f, e2f, bbf, info);\n@@ -1311,15 +1444,17 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n       vec<basic_block> bbs_to_fix_dom;\n \n       set_immediate_dominator (CDI_DOMINATORS, bb1, bb0);\n-      set_immediate_dominator (CDI_DOMINATORS, bb2, bb0);\n+      if (!info->default_case_nonstandard)\n+\tset_immediate_dominator (CDI_DOMINATORS, bb2, bb0);\n       if (! get_immediate_dominator (CDI_DOMINATORS, bbf))\n \t/* If bbD was the immediate dominator ...  */\n \tset_immediate_dominator (CDI_DOMINATORS, bbf, bb0);\n \n-      bbs_to_fix_dom.create (4);\n+      bbs_to_fix_dom.create (3 + (bb2 != bbf));\n       bbs_to_fix_dom.quick_push (bb0);\n       bbs_to_fix_dom.quick_push (bb1);\n-      bbs_to_fix_dom.quick_push (bb2);\n+      if (bb2 != bbf)\n+\tbbs_to_fix_dom.quick_push (bb2);\n       bbs_to_fix_dom.quick_push (bbf);\n \n       iterate_fix_dominators (CDI_DOMINATORS, bbs_to_fix_dom, true);\n@@ -1394,7 +1529,7 @@ process_switch (gswitch *swtch)\n       gcc_assert (info.reason);\n       return info.reason;\n     }\n-  if (!check_final_bb (&info))\n+  if (!check_final_bb (swtch, &info))\n     {\n       gcc_assert (info.reason);\n       return info.reason;\n@@ -1404,7 +1539,9 @@ process_switch (gswitch *swtch)\n      transformation.  */\n \n   create_temp_arrays (&info);\n-  gather_default_values (gimple_switch_default_label (swtch), &info);\n+  gather_default_values (info.default_case_nonstandard\n+\t\t\t ? gimple_switch_label (swtch, 1)\n+\t\t\t : gimple_switch_default_label (swtch), &info);\n   build_constructors (swtch, &info);\n \n   build_arrays (swtch, &info); /* Build the static arrays and assignments.   */"}]}