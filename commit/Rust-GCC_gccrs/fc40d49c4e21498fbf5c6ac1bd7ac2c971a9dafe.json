{"sha": "fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0MGQ0OWM0ZTIxNDk4ZmJmNWM2YWMxYmQ3YWMyYzk3MWE5ZGFmZQ==", "commit": {"author": {"name": "Lee Millward", "email": "lee.millward@codesourcery.com", "date": "2007-01-06T01:06:04Z"}, "committer": {"name": "Lee Millward", "email": "lmillward@gcc.gnu.org", "date": "2007-01-06T01:06:04Z"}, "message": "re PR c++/19439 (Duplicate destructor accepted)\n\n       PR c++/19439\n       * class.c (add_method): Don't wait until template\n       instantiation time to complain about duplicate methods.\n\n       * g++.dg/template/duplicate1.C: New test\n       * g++.dg/template/memfriend6.C: Adjust error markers.\n\nFrom-SVN: r120520", "tree": {"sha": "31f90be90aa6483c30ebb38a4dce943b957bb1c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31f90be90aa6483c30ebb38a4dce943b957bb1c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/comments", "author": null, "committer": null, "parents": [{"sha": "70973361c13cf27b33d9a19d9aad18c585bfdda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70973361c13cf27b33d9a19d9aad18c585bfdda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70973361c13cf27b33d9a19d9aad18c585bfdda7"}], "stats": {"total": 176, "additions": 94, "deletions": 82}, "files": [{"sha": "fc2637fc27418508ad6df748f5af7bbcc4548624", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "patch": "@@ -1,3 +1,9 @@\n+2007-01-06  Lee Millward  <lee.millward@codesourcery.com>\n+\n+       PR c++/19439\n+       * class.c (add_method): Don't wait until template\n+       instantiation time to complain about duplicate methods.\n+\t\n 2007-01-05  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/19978"}, {"sha": "b56ef8476de63a25c95ba63544ab5661d5d37fd0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "patch": "@@ -1,6 +1,7 @@\n /* Functions related to building classes and their related objects.\n    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -898,6 +899,7 @@ add_method (tree type, tree method, tree using_decl)\n   bool complete_p;\n   bool insert_p = false;\n   tree current_fns;\n+  tree fns;\n \n   if (method == error_mark_node)\n     return false;\n@@ -975,92 +977,83 @@ add_method (tree type, tree method, tree using_decl)\n     }\n   current_fns = insert_p ? NULL_TREE : VEC_index (tree, method_vec, slot);\n \n-  if (processing_template_decl)\n-    /* TYPE is a template class.  Don't issue any errors now; wait\n-       until instantiation time to complain.  */\n-    ;\n-  else\n+  /* Check to see if we've already got this method.  */\n+  for (fns = current_fns; fns; fns = OVL_NEXT (fns))\n     {\n-      tree fns;\n-\n-      /* Check to see if we've already got this method.  */\n-      for (fns = current_fns; fns; fns = OVL_NEXT (fns))\n-\t{\n-\t  tree fn = OVL_CURRENT (fns);\n-\t  tree fn_type;\n-\t  tree method_type;\n-\t  tree parms1;\n-\t  tree parms2;\n+      tree fn = OVL_CURRENT (fns);\n+      tree fn_type;\n+      tree method_type;\n+      tree parms1;\n+      tree parms2;\n \n-\t  if (TREE_CODE (fn) != TREE_CODE (method))\n-\t    continue;\n+      if (TREE_CODE (fn) != TREE_CODE (method))\n+\tcontinue;\n \n-\t  /* [over.load] Member function declarations with the\n-\t     same name and the same parameter types cannot be\n-\t     overloaded if any of them is a static member\n-\t     function declaration.\n-\n-\t     [namespace.udecl] When a using-declaration brings names\n-\t     from a base class into a derived class scope, member\n-\t     functions in the derived class override and/or hide member\n-\t     functions with the same name and parameter types in a base\n-\t     class (rather than conflicting).  */\n-\t  fn_type = TREE_TYPE (fn);\n-\t  method_type = TREE_TYPE (method);\n-\t  parms1 = TYPE_ARG_TYPES (fn_type);\n-\t  parms2 = TYPE_ARG_TYPES (method_type);\n-\n-\t  /* Compare the quals on the 'this' parm.  Don't compare\n-\t     the whole types, as used functions are treated as\n-\t     coming from the using class in overload resolution.  */\n-\t  if (! DECL_STATIC_FUNCTION_P (fn)\n-\t      && ! DECL_STATIC_FUNCTION_P (method)\n-\t      && (TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms1)))\n-\t\t  != TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms2)))))\n-\t    continue;\n+      /* [over.load] Member function declarations with the\n+\t same name and the same parameter types cannot be\n+\t overloaded if any of them is a static member\n+\t function declaration.\n+\n+\t [namespace.udecl] When a using-declaration brings names\n+\t from a base class into a derived class scope, member\n+\t functions in the derived class override and/or hide member\n+\t functions with the same name and parameter types in a base\n+\t class (rather than conflicting).  */\n+      fn_type = TREE_TYPE (fn);\n+      method_type = TREE_TYPE (method);\n+      parms1 = TYPE_ARG_TYPES (fn_type);\n+      parms2 = TYPE_ARG_TYPES (method_type);\n+\n+      /* Compare the quals on the 'this' parm.  Don't compare\n+\t the whole types, as used functions are treated as\n+\t coming from the using class in overload resolution.  */\n+      if (! DECL_STATIC_FUNCTION_P (fn)\n+\t  && ! DECL_STATIC_FUNCTION_P (method)\n+\t  && (TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms1)))\n+\t      != TYPE_QUALS (TREE_TYPE (TREE_VALUE (parms2)))))\n+\tcontinue;\n \n-\t  /* For templates, the return type and template parameters\n-\t     must be identical.  */\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL\n-\t      && (!same_type_p (TREE_TYPE (fn_type),\n-\t\t\t\tTREE_TYPE (method_type))\n-\t\t  || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n-\t\t\t\t\t   DECL_TEMPLATE_PARMS (method))))\n-\t    continue;\n+      /* For templates, the return type and template parameters\n+\t must be identical.  */\n+      if (TREE_CODE (fn) == TEMPLATE_DECL\n+\t  && (!same_type_p (TREE_TYPE (fn_type),\n+\t\t\t    TREE_TYPE (method_type))\n+\t      || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n+\t\t\t\t       DECL_TEMPLATE_PARMS (method))))\n+\tcontinue;\n \n-\t  if (! DECL_STATIC_FUNCTION_P (fn))\n-\t    parms1 = TREE_CHAIN (parms1);\n-\t  if (! DECL_STATIC_FUNCTION_P (method))\n-\t    parms2 = TREE_CHAIN (parms2);\n+      if (! DECL_STATIC_FUNCTION_P (fn))\n+\tparms1 = TREE_CHAIN (parms1);\n+      if (! DECL_STATIC_FUNCTION_P (method))\n+\tparms2 = TREE_CHAIN (parms2);\n \n-\t  if (compparms (parms1, parms2)\n-\t      && (!DECL_CONV_FN_P (fn)\n-\t\t  || same_type_p (TREE_TYPE (fn_type),\n-\t\t\t\t  TREE_TYPE (method_type))))\n+      if (compparms (parms1, parms2)\n+\t  && (!DECL_CONV_FN_P (fn)\n+\t      || same_type_p (TREE_TYPE (fn_type),\n+\t\t\t      TREE_TYPE (method_type))))\n+\t{\n+\t  if (using_decl)\n \t    {\n-\t      if (using_decl)\n-\t\t{\n-\t\t  if (DECL_CONTEXT (fn) == type)\n-\t\t    /* Defer to the local function.  */\n-\t\t    return false;\n-\t\t  if (DECL_CONTEXT (fn) == DECL_CONTEXT (method))\n-\t\t    error (\"repeated using declaration %q+D\", using_decl);\n-\t\t  else\n-\t\t    error (\"using declaration %q+D conflicts with a previous using declaration\",\n-\t\t\t   using_decl);\n-\t\t}\n+\t      if (DECL_CONTEXT (fn) == type)\n+\t\t/* Defer to the local function.  */\n+\t\treturn false;\n+\t      if (DECL_CONTEXT (fn) == DECL_CONTEXT (method))\n+\t\terror (\"repeated using declaration %q+D\", using_decl);\n \t      else\n-\t\t{\n-\t\t  error (\"%q+#D cannot be overloaded\", method);\n-\t\t  error (\"with %q+#D\", fn);\n-\t\t}\n-\n-\t      /* We don't call duplicate_decls here to merge the\n-\t\t declarations because that will confuse things if the\n-\t\t methods have inline definitions.  In particular, we\n-\t\t will crash while processing the definitions.  */\n-\t      return false;\n+\t\terror (\"using declaration %q+D conflicts with a previous using declaration\",\n+\t\t       using_decl);\n+\t    }\n+\t  else\n+\t    {\n+\t      error (\"%q+#D cannot be overloaded\", method);\n+\t      error (\"with %q+#D\", fn);\n \t    }\n+\n+\t  /* We don't call duplicate_decls here to merge the\n+\t     declarations because that will confuse things if the\n+\t     methods have inline definitions.  In particular, we\n+\t     will crash while processing the definitions.  */\n+\t  return false;\n \t}\n     }\n "}, {"sha": "7f815e4ba63897f2da4c5b8b788f26bb800fd8ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "patch": "@@ -1,3 +1,9 @@\n+2006-01-06  Lee Millward  <lee.millward@codesourcery.com>\n+\n+       PR c++/19439\n+       * g++.dg/template/duplicate1.C: New test\n+       * g++.dg/template/memfriend6.C: Adjust error markers.\n+\t\n 2007-01-05  Andrew Pinski  <Andrew_Pinski@playstation.sony.com>\n \n \tPR tree-opt/30385"}, {"sha": "c9cdab4b932163b80c3d5a3c1b789a5ffb4465e8", "filename": "gcc/testsuite/g++.dg/template/duplicate1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fduplicate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fduplicate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fduplicate1.C?ref=fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "patch": "@@ -0,0 +1,7 @@\n+//PR c++/19439\n+\n+template<int> struct A\n+{\n+  ~A() {}\t// { dg-error \"with\" }\n+  ~A() {}\t// { dg-error \"cannot be overloaded\" }\n+};"}, {"sha": "5f82339af549546e9cc1c60b77849e592740f556", "filename": "gcc/testsuite/g++.dg/template/memfriend6.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C?ref=fc40d49c4e21498fbf5c6ac1bd7ac2c971a9dafe", "patch": "@@ -8,16 +8,16 @@\n \n template <class T> struct A {\n   template <class U> void f(U);\t\t// { dg-error \"candidate\" }\n-  void g();\t\t\t\t// { dg-error \"candidate\" }\n-  void h();\t\t\t\t// { dg-error \"candidate\" }\n+  void g();\t\t\t\t// { dg-error \"candidate|with\" }\n+  void h();\t\t\t\t// { dg-error \"candidate|with\" }\n   void i(int);\t\t\t\t// { dg-error \"candidate\" }\n };\n \n class C {\n   int ii;\n   template <class U> friend void A<U>::f(U);\t// { dg-error \"not match\" }\n   template <class U> template <class V>\n-    friend void A<U>::g();\t\t\t// { dg-error \"not match\" }\n-  template <class U> friend int A<U>::h();\t// { dg-error \"not match\" }\n+    friend void A<U>::g();\t\t\t// { dg-error \"not match|cannot be overloaded\" }\n+  template <class U> friend int A<U>::h();\t// { dg-error \"not match|cannot be overloaded\" }\n   template <class U> friend void A<U>::i(char);\t// { dg-error \"not match\" }\n };"}]}