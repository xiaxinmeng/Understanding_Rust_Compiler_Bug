{"sha": "c34102419d7a73cafeb889085d73db22e79f0316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0MTAyNDE5ZDdhNzNjYWZlYjg4OTA4NWQ3M2RiMjJlNzlmMDMxNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-24T11:28:51Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-24T11:28:51Z"}, "message": "Avoid hard register combinations\n\nFrom-SVN: r37704", "tree": {"sha": "9895ecc87e3425f396aabee5296b1e7ac316c0ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9895ecc87e3425f396aabee5296b1e7ac316c0ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34102419d7a73cafeb889085d73db22e79f0316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34102419d7a73cafeb889085d73db22e79f0316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34102419d7a73cafeb889085d73db22e79f0316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34102419d7a73cafeb889085d73db22e79f0316/comments", "author": null, "committer": null, "parents": [{"sha": "2f401cc807e4a272e511d76e7711c05c967956da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f401cc807e4a272e511d76e7711c05c967956da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f401cc807e4a272e511d76e7711c05c967956da"}], "stats": {"total": 61, "additions": 54, "deletions": 7}, "files": [{"sha": "d8801970ea680243a31a4706ae7833101a377e53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34102419d7a73cafeb889085d73db22e79f0316/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34102419d7a73cafeb889085d73db22e79f0316/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c34102419d7a73cafeb889085d73db22e79f0316", "patch": "@@ -1,3 +1,8 @@\n+2000-11-24  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* combine.c (cant_combine_insn_p): New function.\n+\t(try_combine): Use it.\n+\n 2000-11-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-parse.in (unary_expr): Move VA_ARG from here ..."}, {"sha": "cd76aeefbb149bbfc2089271f9055fa4e578e08c", "filename": "gcc/combine.c", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34102419d7a73cafeb889085d73db22e79f0316/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34102419d7a73cafeb889085d73db22e79f0316/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c34102419d7a73cafeb889085d73db22e79f0316", "patch": "@@ -366,6 +366,7 @@ static void do_SUBST_INT\t\tPARAMS ((unsigned int *,\n static void init_reg_last_arrays\tPARAMS ((void));\n static void setup_incoming_promotions   PARAMS ((void));\n static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));\n+static int cant_combine_insn_p\tPARAMS ((rtx));\n static int can_combine_p\tPARAMS ((rtx, rtx, rtx, rtx, rtx *, rtx *));\n static int sets_function_arg_p\tPARAMS ((rtx));\n static int combinable_i3pat\tPARAMS ((rtx, rtx *, rtx, rtx, int, rtx *));\n@@ -1455,6 +1456,46 @@ contains_muldiv (x)\n     }\n }\n \f\n+/* Determine whether INSN can be used in a combination.  Return nonzero if\n+   not.  This is used in try_combine to detect early some cases where we\n+   can't perform combinations.  */\n+\n+static int\n+cant_combine_insn_p (insn)\n+     rtx insn;\n+{\n+  rtx set;\n+  rtx src, dest;\n+  \n+  /* If this isn't really an insn, we can't do anything.\n+     This can occur when flow deletes an insn that it has merged into an\n+     auto-increment address.  */\n+  if (! INSN_P (insn))\n+    return 1;\n+\n+  /* Never combine loads and stores involving hard regs.  The register\n+     allocator can usually handle such reg-reg moves by tying.  If we allow\n+     the combiner to make substitutions of hard regs, we risk aborting in\n+     reload on machines that have SMALL_REGISTER_CLASSES.\n+     As an exception, we allow combinations involving fixed regs; these are\n+     not available to the register allocator so there's no risk involved.  */\n+\n+  set = single_set (insn);\n+  if (! set)\n+    return 0;\n+  src = SET_SRC (set);\n+  dest = SET_DEST (set);\n+  if (REG_P (src)\n+      && REGNO (src) < FIRST_PSEUDO_REGISTER\n+      && ! fixed_regs[REGNO (src)])\n+    return 1;\n+  if (REG_P (dest)\n+      && REGNO (dest) < FIRST_PSEUDO_REGISTER\n+      && ! fixed_regs[REGNO (dest)])\n+    return 1;\n+  return 0;\n+}\n+\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n@@ -1509,13 +1550,14 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n   register rtx link;\n   int i;\n \n-  /* If any of I1, I2, and I3 isn't really an insn, we can't do anything.\n-     This can occur when flow deletes an insn that it has merged into an\n-     auto-increment address.  We also can't do anything if I3 has a\n-     REG_LIBCALL note since we don't want to disrupt the contiguity of a\n-     libcall.  */\n-\n-  if (! INSN_P (i3) || ! INSN_P (i2) || (i1 && ! INSN_P (i1))\n+  /* Exit early if one of the insns involved can't be used for\n+     combinations.  */\n+  if (cant_combine_insn_p (i3)\n+      || cant_combine_insn_p (i2)\n+      || (i1 && cant_combine_insn_p (i1))\n+      /* We also can't do anything if I3 has a\n+\t REG_LIBCALL note since we don't want to disrupt the contiguity of a\n+\t libcall.  */\n #if 0\n       /* ??? This gives worse code, and appears to be unnecessary, since no\n \t pass after flow uses REG_LIBCALL/REG_RETVAL notes.  */"}]}