{"sha": "1eb5852081801218c02c934db5aa9852fc284645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViNTg1MjA4MTgwMTIxOGMwMmM5MzRkYjVhYTk4NTJmYzI4NDY0NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T13:46:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T13:46:29Z"}, "message": "ada-tree.h (DECL_BY_DESCRIPTOR_P): Delete.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/ada-tree.h (DECL_BY_DESCRIPTOR_P): Delete.\n\t(DECL_FUNCTION_STUB): Likewise.\n\t(SET_DECL_FUNCTION_STUB): Likewise.\n\t(DECL_PARM_ALT_TYPE): Likewise.\n\t(SET_DECL_PARM_ALT_TYPE): Likewise.\n\t(TYPE_VAX_FLOATING_POINT_P): Delete.\n\t(TYPE_DIGITS_VALUE): Likewise.\n\t(SET_TYPE_DIGITS_VALUE): Likewise.\n\t* gcc-interface/gigi.h (standard_datatypes): Remove ADT_malloc32_decl.\n\t(malloc32_decl): Delete.\n\t(build_vms_descriptor): Likewise.\n\t(build_vms_descriptor32): Likewise.\n\t(fill_vms_descriptor): Likewise.\n\t(convert_vms_descriptor): Likewise.\n\t(TARGET_ABI_OPEN_VMS): Likewise.\n\t(TARGET_MALLOC64): Likewise.\n\t* gcc-interface/decl.c (add_parallel_type_for_packed_array): New.\n\t(gnat_to_gnu_entity): Call it to add the original type as a parallel\n\ttype to the implementation type of a packed array type.\n\t<E_Procedure>: Remove now obsolete kludge.\n\t<E_Exception>: Delete obsolete comment.\n\t<object>: Small tweak.\n\t<E_Subprogram_Type>: Remove support for stub subprograms, as well as\n\tfor the descriptor passing mechanism.\n\t(gnat_to_gnu_param): Likewise.\n\t* gcc-interface/misc.c (gnat_init_gcc_fp): Remove special case.\n\t(gnat_print_type): Adjust.\n\t* gcc-interface/trans.c (gigi): Remove obsolete initializations.\n\t(vms_builtin_establish_handler_decl): Delete.\n\t(gnat_vms_condition_handler_decl): Likewise.\n\t(establish_gnat_vms_condition_handler): Likewise.\n\t(build_function_stub): Likewise.\n\t(Subprogram_Body_to_gnu): Do not call above functions.\n\t(Call_to_gnu): Remove support for the descriptor passing mechanism.\n\t* gcc-interface/utils.c (make_descriptor_field): Delete.\n\t(build_vms_descriptor32): Likewise.\n\t(build_vms_descriptor): Likewise.\n\t(fill_vms_descriptor): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\t(convert_vms_descriptor): Likewise.\n\t* gcc-interface/utils.c (unchecked_convert): Likewise.\n\t* gcc-interface/utils2.c (maybe_wrap_malloc): Remove obsolete stuff.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/trans.c (gigi): Use gnat_to_gnu_type for the exception\n\ttype and get_unpadded_type for the longest FP type.\n\t(Attribute_to_gnu) <Machine>: Compare the precision of the types.\n\t(convert_with_check): Adjust formatting and remove FIXME.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tDo not convert the RM bounds to the base type.\n\t(E_Floating_Point_Subtype): Likewise.\n\t(E_Array_Subtype): Convert the bounds to the base type.\n\t* gcc-interface/trans.c (get_type_length): New function.\n\t(Attribute_to_gnu) <Range_Length>: Call it.\n\t<Length>: Likewise.\n\t(Loop_Statement_to_gnu): Convert the bounds to the base type.\n\t(gnat_to_gnu) <N_In>: Likewise.\n\t* gcc-interface/utils.c (make_type_from_size): Do not convert the RM\n\tbounds to the base type.\n\t(create_range_type): Likewise.\n\t(convert): Convert the bounds to the base type for biased types.\n\t* gcc-interface/utils2.c (compare_arrays): Convert the bounds to the\n\tbase type.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Selected_Component>: Remove\n\tincorrect implicit type derivation.\n\t* gcc-interface/utils.c (max_size) <tcc_reference>: Convert the bounds\n\tto the base type.\n\nFrom-SVN: r213462", "tree": {"sha": "17c3243a6166917936352164905bb90a504297ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17c3243a6166917936352164905bb90a504297ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb5852081801218c02c934db5aa9852fc284645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb5852081801218c02c934db5aa9852fc284645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb5852081801218c02c934db5aa9852fc284645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb5852081801218c02c934db5aa9852fc284645/comments", "author": null, "committer": null, "parents": [{"sha": "ecda544d41f26433d80a0632c09dec07fd2a8dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecda544d41f26433d80a0632c09dec07fd2a8dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecda544d41f26433d80a0632c09dec07fd2a8dfd"}], "stats": {"total": 1832, "additions": 314, "deletions": 1518}, "files": [{"sha": "e7f05cb90e89c7fac35a27216a0fcc71c04a0987", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -1,3 +1,119 @@\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_BY_DESCRIPTOR_P): Delete.\n+\t(DECL_FUNCTION_STUB): Likewise.\n+\t(SET_DECL_FUNCTION_STUB): Likewise.\n+\t(DECL_PARM_ALT_TYPE): Likewise.\n+\t(SET_DECL_PARM_ALT_TYPE): Likewise.\n+\t(TYPE_VAX_FLOATING_POINT_P): Delete.\n+\t(TYPE_DIGITS_VALUE): Likewise.\n+\t(SET_TYPE_DIGITS_VALUE): Likewise.\n+\t* gcc-interface/gigi.h (standard_datatypes): Remove ADT_malloc32_decl.\n+\t(malloc32_decl): Delete.\n+\t(build_vms_descriptor): Likewise.\n+\t(build_vms_descriptor32): Likewise.\n+\t(fill_vms_descriptor): Likewise.\n+\t(convert_vms_descriptor): Likewise.\n+\t(TARGET_ABI_OPEN_VMS): Likewise.\n+\t(TARGET_MALLOC64): Likewise.\n+\t* gcc-interface/decl.c (add_parallel_type_for_packed_array): New.\n+\t(gnat_to_gnu_entity): Call it to add the original type as a parallel\n+\ttype to the implementation type of a packed array type.\n+\t<E_Procedure>: Remove now obsolete kludge.\n+\t<E_Exception>: Delete obsolete comment.\n+\t<object>: Small tweak.\n+\t<E_Subprogram_Type>: Remove support for stub subprograms, as well as\n+\tfor the descriptor passing mechanism.\n+\t(gnat_to_gnu_param): Likewise.\n+\t* gcc-interface/misc.c (gnat_init_gcc_fp): Remove special case.\n+\t(gnat_print_type): Adjust.\n+\t* gcc-interface/trans.c (gigi): Remove obsolete initializations.\n+\t(vms_builtin_establish_handler_decl): Delete.\n+\t(gnat_vms_condition_handler_decl): Likewise.\n+\t(establish_gnat_vms_condition_handler): Likewise.\n+\t(build_function_stub): Likewise.\n+\t(Subprogram_Body_to_gnu): Do not call above functions.\n+\t(Call_to_gnu): Remove support for the descriptor passing mechanism.\n+\t* gcc-interface/utils.c (make_descriptor_field): Delete.\n+\t(build_vms_descriptor32): Likewise.\n+\t(build_vms_descriptor): Likewise.\n+\t(fill_vms_descriptor): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(convert_vms_descriptor): Likewise.\n+\t* gcc-interface/utils.c (unchecked_convert): Likewise.\n+\t* gcc-interface/utils2.c (maybe_wrap_malloc): Remove obsolete stuff.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gigi): Use gnat_to_gnu_type for the exception\n+\ttype and get_unpadded_type for the longest FP type.\n+\t(Attribute_to_gnu) <Machine>: Compare the precision of the types.\n+\t(convert_with_check): Adjust formatting and remove FIXME.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tDo not convert the RM bounds to the base type.\n+\t(E_Floating_Point_Subtype): Likewise.\n+\t(E_Array_Subtype): Convert the bounds to the base type.\n+\t* gcc-interface/trans.c (get_type_length): New function.\n+\t(Attribute_to_gnu) <Range_Length>: Call it.\n+\t<Length>: Likewise.\n+\t(Loop_Statement_to_gnu): Convert the bounds to the base type.\n+\t(gnat_to_gnu) <N_In>: Likewise.\n+\t* gcc-interface/utils.c (make_type_from_size): Do not convert the RM\n+\tbounds to the base type.\n+\t(create_range_type): Likewise.\n+\t(convert): Convert the bounds to the base type for biased types.\n+\t* gcc-interface/utils2.c (compare_arrays): Convert the bounds to the\n+\tbase type.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Selected_Component>: Remove\n+\tincorrect implicit type derivation.\n+\t* gcc-interface/utils.c (max_size) <tcc_reference>: Convert the bounds\n+\tto the base type.\n+\n+2014-08-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Preanalyze and resolve the\n+\tprefix of attribute Loop_Entry.\n+\t* sem_prag.adb (Analyze_Pragma): Verify the placement of pragma\n+\tLoop_Variant with respect to an enclosing loop (if any).\n+\t(Contains_Loop_Entry): Update the parameter profile and all\n+\tcalls to this routine.\n+\t* sem_res.adb (Resolve_Call): Code reformatting. Do not ask\n+\tfor the corresponding body before determining the nature of the\n+\tultimate alias's declarative node.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat1drv.adb, sem_ch4.adb: Minor reformatting.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_eval.adb (Rewrite_In_Raise_CE): Don't try to reuse inner\n+\tconstraint error node since it is a list member.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_warn.adb: Minor reformatting.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.adb (Underlying_Type): Return the underlying full view\n+\tof a private type if present.\n+\t* freeze.adb (Freeze_Entity):\n+\tBuild a single freeze node for partial, full and underlying full\n+\tviews, if any.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Private_Type>: Add a\n+\tmissing guard before the access to the Underlying_Full_View.\n+\t* gcc-interface/trans.c (process_freeze_entity): Deal with underlying\n+\tfull view if present.\n+\t* gcc-interface/utils.c (make_dummy_type): Avoid superfluous work.\n+\n 2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Resolve_Entry_Call): When an entry has"}, {"sha": "ba5765d0dbaa3aff0b268a2156d0034e8df7b912", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -120,11 +120,6 @@ do {\t\t\t\t\t\t\t \\\n     || TREE_CODE (NODE) == ENUMERAL_TYPE)\t    \\\n    && TYPE_BY_REFERENCE_P (NODE))\n \n-/* For INTEGER_TYPE, nonzero if this really represents a VAX\n-   floating-point type.  */\n-#define TYPE_VAX_FLOATING_POINT_P(NODE) \\\n-  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n-\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n    type for an object whose type includes its template in addition to\n    its value (only true for RECORD_TYPE).  */\n@@ -257,7 +252,11 @@ do {\t\t\t\t\t\t   \\\n    bound but they must nevertheless be valid in the GCC type system, otherwise\n    the optimizer can pretend that they simply don't exist.  Therefore they\n    must be within the range of values allowed by the lower bound in the GCC\n-   sense, hence the GCC lower bound be set to that of the base type.  */\n+   sense, hence the GCC lower bound be set to that of the base type.\n+\n+   This lower bound is translated directly without the adjustments that may\n+   be required for type compatibility, so it will generally be necessary to\n+   convert it to the base type of the numerical type before using it.  */\n #define TYPE_RM_MIN_VALUE(NODE) TYPE_RM_VALUE ((NODE), 1)\n #define SET_TYPE_RM_MIN_VALUE(NODE, X) SET_TYPE_RM_VALUE ((NODE), 1, (X))\n \n@@ -269,7 +268,11 @@ do {\t\t\t\t\t\t   \\\n    bound but they must nevertheless be valid in the GCC type system, otherwise\n    the optimizer can pretend that they simply don't exist.  Therefore they\n    must be within the range of values allowed by the upper bound in the GCC\n-   sense, hence the GCC upper bound be set to that of the base type.  */\n+   sense, hence the GCC upper bound be set to that of the base type.\n+\n+   This upper bound is translated directly without the adjustments that may\n+   be required for type compatibility, so it will generally be necessary to\n+   convert it to the base type of the numerical type before using it.  */\n #define TYPE_RM_MAX_VALUE(NODE) TYPE_RM_VALUE ((NODE), 2)\n #define SET_TYPE_RM_MAX_VALUE(NODE, X) SET_TYPE_RM_VALUE ((NODE), 2, (X))\n \n@@ -294,15 +297,18 @@ do {\t\t\t\t\t\t   \\\n #define SET_TYPE_MODULUS(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n-/* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, this is the\n-   Digits_Value.  */\n-#define TYPE_DIGITS_VALUE(NODE) \\\n-  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_DIGITS_VALUE(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n-\n /* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, this is\n-   the type corresponding to the Ada index type.  */\n+   the type corresponding to the Ada index type.  It is necessary to keep\n+   these 2 views for every array type because the TYPE_DOMAIN is subject\n+   to strong constraints in GENERIC: it must be a subtype of SIZETYPE and\n+   may not be superflat, i.e. the upper bound must always be larger or\n+   equal to the lower bound minus 1 (i.e. the canonical length formula\n+   must always yield a non-negative number), which means that at least\n+   one of the bounds may need to be a conditional expression.  There are\n+   no such constraints on the TYPE_INDEX_TYPE because gigi is prepared to\n+   deal with the superflat case; moreover the TYPE_INDEX_TYPE is used as\n+   the index type for the debug info and, therefore, needs to be as close\n+   as possible to the source index type.  */\n #define TYPE_INDEX_TYPE(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_INDEX_TYPE(NODE, X) \\\n@@ -388,9 +394,6 @@ do {\t\t\t\t\t\t   \\\n    is readonly.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n \n-/* Nonzero in a PARM_DECL if we are to pass by descriptor.  */\n-#define DECL_BY_DESCRIPTOR_P(NODE) DECL_LANG_FLAG_5 (PARM_DECL_CHECK (NODE))\n-\n /* Nonzero in a VAR_DECL if it is a pointer renaming a global object.  */\n #define DECL_RENAMING_GLOBAL_P(NODE) DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n \n@@ -448,19 +451,6 @@ do {\t\t\t\t\t\t   \\\n #define SET_DECL_PARALLEL_TYPE(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE), X)\n \n-/* In a FUNCTION_DECL, points to the stub associated with the function\n-   if any, otherwise 0.  */\n-#define DECL_FUNCTION_STUB(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\n-#define SET_DECL_FUNCTION_STUB(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE), X)\n-\n-/* In a PARM_DECL, points to the alternate TREE_TYPE.  */\n-#define DECL_PARM_ALT_TYPE(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE))\n-#define SET_DECL_PARM_ALT_TYPE(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE), X)\n-\n \n /* Flags added to ref nodes.  */\n "}, {"sha": "2145a4776067f67bb4f794466905d715d14e3737", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 67, "deletions": 164, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -172,6 +172,7 @@ static tree get_rep_part (tree);\n static tree create_variant_part_from (tree, vec<variant_desc> , tree,\n \t\t\t\t      tree, vec<subst_pair> );\n static void copy_and_substitute_in_size (tree, tree, vec<subst_pair> );\n+static void add_parallel_type_for_packed_array (tree, Entity_Id);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibility checks.  */\n@@ -488,15 +489,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       goto object;\n \n     case E_Exception:\n-      /* We used to special case VMS exceptions here to directly map them to\n-\t their associated condition code.  Since this code had to be masked\n-\t dynamically to strip off the severity bits, this caused trouble in\n-\t the GCC/ZCX case because the \"type\" pointers we store in the tables\n-\t have to be static.  We now don't special case here anymore, and let\n-\t the regular processing take place, which leaves us with a regular\n-\t exception data object for VMS exceptions too.  The condition code\n-\t mapping is taken care of by the front end and the bitmasking by the\n-\t run-time library.  */\n       goto object;\n \n     case E_Component:\n@@ -1431,14 +1423,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t && get_variant_part (TREE_TYPE (gnu_expr)) == NULL_TREE))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n-\t/* If this name is external or there was a name specified, use it,\n-\t   Don't use the Interface_Name if there is an address clause\n-\t   (see CD30005).  */\n+\t/* If this name is external or a name was specified, use it, but don't\n+\t   use the Interface_Name with an address clause (see cd30005).  */\n \tif ((Present (Interface_Name (gnat_entity))\n \t     && No (Address_Clause (gnat_entity)))\n \t    || (Is_Public (gnat_entity)\n-\t\t&& (!Is_Imported (gnat_entity)\n-\t            || Is_Exported (gnat_entity))))\n+\t\t&& (!Is_Imported (gnat_entity) || Is_Exported (gnat_entity))))\n \t  gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \n \t/* If this is an aggregate constant initialized to a constant, force it\n@@ -1754,20 +1744,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n \n       SET_TYPE_RM_MIN_VALUE\n-\t(gnu_type,\n-\t convert (TREE_TYPE (gnu_type),\n-\t\t  elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\tgnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\tdefinition, true,\n-\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n+\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\t definition, true,\n+\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       SET_TYPE_RM_MAX_VALUE\n-\t(gnu_type,\n-\t convert (TREE_TYPE (gnu_type),\n-\t\t  elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\tgnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\tdefinition, true,\n-\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n+\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\t definition, true,\n+\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n@@ -1790,12 +1776,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t= create_type_stub_decl (gnu_entity_name, gnu_type);\n \n       /* For a packed array, make the original array type a parallel type.  */\n-      if (debug_info_p\n-\t  && Is_Packed_Array_Impl_Type (gnat_entity)\n-\t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\tadd_parallel_type (gnu_type,\n-\t\t\t   gnat_to_gnu_type\n-\t\t\t   (Original_Array_Type (gnat_entity)));\n+      if (debug_info_p && Is_Packed_Array_Impl_Type (gnat_entity))\n+\tadd_parallel_type_for_packed_array (gnu_type, gnat_entity);\n \n     discrete_type:\n \n@@ -1867,10 +1849,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  if (debug_info_p)\n \t    {\n \t      /* Make the original array type a parallel type.  */\n-\t      if (present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\t\tadd_parallel_type (gnu_type,\n-\t\t\t\t   gnat_to_gnu_type\n-\t\t\t\t   (Original_Array_Type (gnat_entity)));\n+\t      add_parallel_type_for_packed_array (gnu_type, gnat_entity);\n \n \t      rest_of_record_type_compilation (gnu_type);\n \t    }\n@@ -1947,20 +1926,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       layout_type (gnu_type);\n \n       SET_TYPE_RM_MIN_VALUE\n-\t(gnu_type,\n-\t convert (TREE_TYPE (gnu_type),\n-\t\t  elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\tgnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\tdefinition, true,\n-\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n+\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\t definition, true,\n+\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       SET_TYPE_RM_MAX_VALUE\n-\t(gnu_type,\n-\t convert (TREE_TYPE (gnu_type),\n-\t\t  elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\tgnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\tdefinition, true,\n-\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n+\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\t definition, true,\n+\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       /* Inherit our alias set from what we're a subtype of, as for\n \t integer subtypes.  */\n@@ -2335,14 +2310,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n-\t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n+\t      tree gnu_index_base_type = get_base_type (gnu_index_type);\n+\t      tree gnu_orig_min\n+\t\t= convert (gnu_index_base_type,\n+\t\t\t   TYPE_MIN_VALUE (gnu_index_type));\n+\t      tree gnu_orig_max\n+\t\t= convert (gnu_index_base_type,\n+\t\t\t   TYPE_MAX_VALUE (gnu_index_type));\n \t      tree gnu_min = convert (sizetype, gnu_orig_min);\n \t      tree gnu_max = convert (sizetype, gnu_orig_max);\n \t      tree gnu_base_index_type\n \t\t= get_unpadded_type (Etype (gnat_base_index));\n-\t      tree gnu_base_orig_min = TYPE_MIN_VALUE (gnu_base_index_type);\n-\t      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);\n+\t      tree gnu_base_index_base_type\n+\t        = get_base_type (gnu_base_index_type);\n+\t      tree gnu_base_orig_min\n+\t\t= convert (gnu_base_index_base_type,\n+\t\t\t   TYPE_MIN_VALUE (gnu_base_index_type));\n+\t      tree gnu_base_orig_max\n+\t        = convert (gnu_base_index_base_type,\n+\t\t\t   TYPE_MAX_VALUE (gnu_base_index_type));\n \t      tree gnu_high;\n \n \t      /* See if the base array type is already flat.  If it is, we\n@@ -2655,11 +2641,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     isn't artificial to make sure it is kept in the debug info.  */\n \t  if (debug_info_p)\n \t    {\n-\t      if (Is_Packed_Array_Impl_Type (gnat_entity)\n-\t\t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\t\tadd_parallel_type (gnu_type,\n-\t\t\t\t   gnat_to_gnu_type\n-\t\t\t\t   (Original_Array_Type (gnat_entity)));\n+\t      if (Is_Packed_Array_Impl_Type (gnat_entity))\n+\t\tadd_parallel_type_for_packed_array (gnu_type, gnat_entity);\n \t      else\n \t\t{\n \t\t  tree gnu_base_decl\n@@ -4102,8 +4085,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   PARM_DECL nodes are chained through the DECL_CHAIN field, so this\n \t   actually is the head of this parameter list.  */\n \ttree gnu_param_list = NULL_TREE;\n-\t/* Likewise for the stub associated with an exported procedure.  */\n-\ttree gnu_stub_param_list = NULL_TREE;\n \t/* Non-null for subprograms containing parameters passed by copy-in\n \t   copy-out (Ada In Out or Out parameters not passed by reference),\n \t   in which case it is the list of nodes used to specify the values\n@@ -4119,8 +4100,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If an import pragma asks to map this subprogram to a GCC builtin,\n \t   this is the builtin DECL node.  */\n \ttree gnu_builtin_decl = NULL_TREE;\n-\t/* For the stub associated with an exported procedure.  */\n-\ttree gnu_stub_type = NULL_TREE, gnu_stub_name = NULL_TREE;\n \ttree gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \tEntity_Id gnat_param;\n \tenum inline_status_t inline_status\n@@ -4148,7 +4127,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool return_by_direct_ref_p = false;\n \tbool return_by_invisi_ref_p = false;\n \tbool return_unconstrained_p = false;\n-\tbool has_stub = false;\n \tint parmnum;\n \n \t/* A parameter may refer to this type, so defer completion of any\n@@ -4352,15 +4330,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Otherwise, see if a Mechanism was supplied that forced this\n \t       parameter to be passed one way or another.  */\n \t    else if (mech == Default\n-\t\t     || mech == By_Copy || mech == By_Reference)\n+\t\t     || mech == By_Copy\n+\t\t     || mech == By_Reference)\n \t      ;\n-\t    else if (By_Descriptor_Last <= mech && mech <= By_Descriptor)\n-\t      mech = By_Descriptor;\n-\n-\t    else if (By_Short_Descriptor_Last <= mech &&\n-                     mech <= By_Short_Descriptor)\n-\t      mech = By_Short_Descriptor;\n-\n \t    else if (mech > 0)\n \t      {\n \t\tif (TREE_CODE (gnu_param_type) == UNCONSTRAINED_ARRAY_TYPE\n@@ -4418,26 +4390,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    if (gnu_param)\n \t      {\n-\t\t/* If it's an exported subprogram, we build a parameter list\n-\t\t   in parallel, in case we need to emit a stub for it.  */\n-\t\tif (Is_Exported (gnat_entity))\n-\t\t  {\n-\t\t    gnu_stub_param_list\n-\t\t      = chainon (gnu_param, gnu_stub_param_list);\n-\t\t    /* Change By_Descriptor parameter to By_Reference for\n-\t\t       the internal version of an exported subprogram.  */\n-\t\t    if (mech == By_Descriptor || mech == By_Short_Descriptor)\n-\t\t      {\n-\t\t\tgnu_param\n-\t\t\t  = gnat_to_gnu_param (gnat_param, By_Reference,\n-\t\t\t\t\t       gnat_entity, false,\n-\t\t\t\t\t       &copy_in_copy_out);\n-\t\t\thas_stub = true;\n-\t\t      }\n-\t\t    else\n-\t\t      gnu_param = copy_node (gnu_param);\n-\t\t  }\n-\n \t\tgnu_param_list = chainon (gnu_param, gnu_param_list);\n \t\tSloc_to_locus (Sloc (gnat_param),\n \t\t\t       &DECL_SOURCE_LOCATION (gnu_param));\n@@ -4572,8 +4524,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* The lists have been built in reverse.  */\n \tgnu_param_list = nreverse (gnu_param_list);\n-\tif (has_stub)\n-\t  gnu_stub_param_list = nreverse (gnu_stub_param_list);\n \tgnu_cico_list = nreverse (gnu_cico_list);\n \n \tif (kind == E_Function)\n@@ -4587,13 +4537,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t return_by_direct_ref_p,\n \t\t\t\t return_by_invisi_ref_p);\n \n-\tif (has_stub)\n-\t  gnu_stub_type\n-\t    = create_subprog_type (gnu_return_type, gnu_stub_param_list,\n-\t\t\t\t   gnu_cico_list, return_unconstrained_p,\n-\t\t\t\t   return_by_direct_ref_p,\n-\t\t\t\t   return_by_invisi_ref_p);\n-\n \t/* A subprogram (something that doesn't return anything) shouldn't\n \t   be considered const since there would be no reason for such a\n \t   subprogram.  Note that procedures with Out (or In Out) parameters\n@@ -4608,9 +4551,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t| (volatile_flag ? TYPE_QUAL_VOLATILE : 0);\n \n \t    gnu_type = change_qualified_type (gnu_type, quals);\n-\n-\t    if (has_stub)\n-\t      gnu_stub_type = change_qualified_type (gnu_stub_type, quals);\n \t  }\n \n \t/* If we have a builtin decl for that function, use it.  Check if the\n@@ -4683,39 +4623,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \telse\n \t  {\n-\t    /* ??? When only the spec of a package is provided, downgrade\n-\t       is_required to is_enabled to avoid issuing an error later.  */\n-\t    if (inline_status == is_required)\n-\t      {\n-\t\tNode_Id gnat_body = Parent (Declaration_Node (gnat_entity));\n-\t\tif (Nkind (gnat_body) != N_Subprogram_Body\n-\t\t    && No (Corresponding_Body (gnat_body)))\n-\t\t  inline_status = is_enabled;\n-\t      }\n-\n-\t    if (has_stub)\n-\t      {\n-\t\tgnu_stub_name = gnu_ext_name;\n-\t\tgnu_ext_name = create_concat_name (gnat_entity, \"internal\");\n-\t\tpublic_flag = false;\n- \t\tartificial_flag = true;\n-\t      }\n-\n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t     gnu_param_list, inline_status,\n \t\t\t\t     public_flag, extern_flag, artificial_flag,\n \t\t\t\t     attr_list, gnat_entity);\n-\t    if (has_stub)\n-\t      {\n-\t\ttree gnu_stub_decl\n-\t\t  = create_subprog_decl (gnu_entity_name, gnu_stub_name,\n-\t\t\t\t\t gnu_stub_type, gnu_stub_param_list,\n-\t\t\t\t\t inline_status, true, extern_flag,\n-\t\t\t\t\t false, attr_list, gnat_entity);\n-\t\tSET_DECL_FUNCTION_STUB (gnu_decl, gnu_stub_decl);\n-\t      }\n-\n \t    /* This is unrelated to the stub built right above.  */\n \t    DECL_STUBBED_P (gnu_decl)\n \t      = Convention (gnat_entity) == Convention_Stubbed;\n@@ -5663,7 +5575,6 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n {\n   tree gnu_param_name = get_entity_name (gnat_param);\n   tree gnu_param_type = gnat_to_gnu_type (Etype (gnat_param));\n-  tree gnu_param_type_alt = NULL_TREE;\n   bool in_param = (Ekind (gnat_param) == E_In_Parameter);\n   /* The parameter can be indirectly modified if its address is taken.  */\n   bool ro_param = in_param && !Address_Taken (gnat_param);\n@@ -5714,31 +5625,8 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n       && Is_Descendent_Of_Address (Etype (gnat_param)))\n     gnu_param_type = ptr_void_type_node;\n \n-  /* VMS descriptors are themselves passed by reference.  */\n-  if (mech == By_Short_Descriptor ||\n-      (mech == By_Descriptor && TARGET_ABI_OPEN_VMS && !flag_vms_malloc64))\n-    gnu_param_type\n-      = build_pointer_type (build_vms_descriptor32 (gnu_param_type,\n-\t\t\t\t\t\t    Mechanism (gnat_param),\n-\t\t\t\t\t\t    gnat_subprog));\n-  else if (mech == By_Descriptor)\n-    {\n-      /* Build both a 32-bit and 64-bit descriptor, one of which will be\n-\t chosen in fill_vms_descriptor.  */\n-      gnu_param_type_alt\n-        = build_pointer_type (build_vms_descriptor32 (gnu_param_type,\n-\t\t\t\t\t\t      Mechanism (gnat_param),\n-\t\t\t\t\t\t      gnat_subprog));\n-      gnu_param_type\n-        = build_pointer_type (build_vms_descriptor (gnu_param_type,\n-\t\t\t\t\t\t    Mechanism (gnat_param),\n-\t\t\t\t\t\t    gnat_subprog));\n-    }\n-\n   /* Arrays are passed as pointers to element type for foreign conventions.  */\n-  else if (foreign\n-\t   && mech != By_Copy\n-\t   && TREE_CODE (gnu_param_type) == ARRAY_TYPE)\n+  if (foreign && mech != By_Copy && TREE_CODE (gnu_param_type) == ARRAY_TYPE)\n     {\n       /* Strip off any multi-dimensional entries, then strip\n \t off the last array to get the component type.  */\n@@ -5821,9 +5709,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   if (Ekind (gnat_param) == E_Out_Parameter\n       && !by_ref\n       && (by_return\n-\t  || (mech != By_Descriptor\n-              && mech != By_Short_Descriptor\n-\t      && !POINTER_TYPE_P (gnu_param_type)\n+\t  || (!POINTER_TYPE_P (gnu_param_type)\n \t      && !AGGREGATE_TYPE_P (gnu_param_type)\n \t      && !Has_Default_Aspect (Etype (gnat_param))))\n       && !(Is_Array_Type (Etype (gnat_param))\n@@ -5835,16 +5721,10 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \t\t\t\t ro_param || by_ref || by_component_ptr);\n   DECL_BY_REF_P (gnu_param) = by_ref;\n   DECL_BY_COMPONENT_PTR_P (gnu_param) = by_component_ptr;\n-  DECL_BY_DESCRIPTOR_P (gnu_param)\n-    = (mech == By_Descriptor || mech == By_Short_Descriptor);\n   DECL_POINTS_TO_READONLY_P (gnu_param)\n     = (ro_param && (by_ref || by_component_ptr));\n   DECL_CAN_NEVER_BE_NULL_P (gnu_param) = Can_Never_Be_Null (gnat_param);\n \n-  /* Save the alternate descriptor type, if any.  */\n-  if (gnu_param_type_alt)\n-    SET_DECL_PARM_ALT_TYPE (gnu_param, gnu_param_type_alt);\n-\n   /* If no Mechanism was specified, indicate what we're using, then\n      back-annotate it.  */\n   if (mech == Default)\n@@ -6307,6 +6187,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, true, expr_public_p,\n \t   !definition, expr_global_p, !need_debug, NULL, gnat_entity);\n \n+      DECL_ARTIFICIAL (gnu_decl) = 1;\n       if (use_variable)\n \treturn gnu_decl;\n     }\n@@ -8647,6 +8528,28 @@ copy_and_substitute_in_size (tree new_type, tree old_type,\n   TYPE_SIZE (new_type) = variable_size (TYPE_SIZE (new_type));\n   TYPE_SIZE_UNIT (new_type) = variable_size (TYPE_SIZE_UNIT (new_type));\n }\n+\n+/* Add a parallel type to GNU_TYPE, the translation of GNAT_ENTITY, which is\n+   the implementation type of a packed array type (Is_Packed_Array_Impl_Type).\n+   The parallel type is the original array type if it has been translated.  */\n+\n+static void\n+add_parallel_type_for_packed_array (tree gnu_type, Entity_Id gnat_entity)\n+{\n+  Entity_Id gnat_original_array_type\n+    = Underlying_Type (Original_Array_Type (gnat_entity));\n+  tree gnu_original_array_type;\n+\n+  if (!present_gnu_tree (gnat_original_array_type))\n+    return;\n+\n+  gnu_original_array_type = gnat_to_gnu_type (gnat_original_array_type);\n+\n+  if (TYPE_IS_DUMMY_P (gnu_original_array_type))\n+    return;\n+\n+  add_parallel_type (gnu_type, gnu_original_array_type);\n+}\n \f\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a\n    type with all size expressions that contain F in a PLACEHOLDER_EXPR"}, {"sha": "72983f8cf190854af147ab889085fd3299f28a80", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -395,10 +395,8 @@ enum standard_datatypes\n   ADT_sbitsize_unit_node,\n \n   /* Function declaration nodes for run-time functions for allocating memory.\n-     Ada allocators cause calls to these functions to be generated.  Malloc32\n-     is used only on 64bit systems needing to allocate 32bit memory.  */\n+     Ada allocators cause calls to this function to be generated.  */\n   ADT_malloc_decl,\n-  ADT_malloc32_decl,\n \n   /* Likewise for freeing memory.  */\n   ADT_free_decl,\n@@ -471,7 +469,6 @@ extern GTY(()) tree gnat_raise_decls_ext[(int) LAST_REASON_CODE + 1];\n #define sbitsize_one_node gnat_std_decls[(int) ADT_sbitsize_one_node]\n #define sbitsize_unit_node gnat_std_decls[(int) ADT_sbitsize_unit_node]\n #define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n-#define malloc32_decl gnat_std_decls[(int) ADT_malloc32_decl]\n #define free_decl gnat_std_decls[(int) ADT_free_decl]\n #define mulv64_decl gnat_std_decls[(int) ADT_mulv64_decl]\n #define parent_name_id gnat_std_decls[(int) ADT_parent_name_id]\n@@ -783,19 +780,6 @@ extern void rest_of_subprog_body_compilation (tree subprog_decl);\n    Return a constructor for the template.  */\n extern tree build_template (tree template_type, tree array_type, tree expr);\n \n-/* Build a 64bit VMS descriptor from a Mechanism_Type, which must specify\n-   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n-   in the type contains in its DECL_INITIAL the expression to use when\n-   a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n-   to print out an error message if the mechanism cannot be applied to\n-   an object of that type and also for the name.  */\n-extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n-                                  Entity_Id gnat_entity);\n-\n-/* Build a 32bit VMS descriptor from a Mechanism_Type. See above.  */\n-extern tree build_vms_descriptor32 (tree type, Mechanism_Type mech,\n-                                  Entity_Id gnat_entity);\n-\n /* Build a type to be used to represent an aliased object whose nominal type\n    is an unconstrained array.  This consists of a RECORD_TYPE containing a\n    field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an ARRAY_TYPE.\n@@ -963,19 +947,6 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Entity_Id gnat_proc, Entity_Id gnat_pool,\n                              Node_Id gnat_node, bool);\n \n-/* Fill in a VMS descriptor of GNU_TYPE for GNU_EXPR and return the result.\n-   GNAT_ACTUAL is the actual parameter for which the descriptor is built.  */\n-extern tree fill_vms_descriptor (tree gnu_type, tree gnu_expr,\n-                                 Node_Id gnat_actual);\n-\n-/* Convert GNU_EXPR, a pointer to a VMS descriptor, to GNU_TYPE, a regular\n-   pointer or fat pointer type.  GNU_EXPR_ALT_TYPE is the alternate (32-bit)\n-   pointer type of GNU_EXPR.  GNAT_SUBPROG is the subprogram to which the\n-   descriptor is passed.  */\n-extern tree convert_vms_descriptor (tree gnu_type, tree gnu_expr,\n-\t\t\t\t    tree gnu_expr_alt_type,\n-\t\t\t\t    Entity_Id gnat_subprog);\n-\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n extern bool gnat_mark_addressable (tree t);\n@@ -1067,19 +1038,6 @@ extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n }\n #endif\n \n-/* Let code know whether we are targeting VMS without need of\n-   intrusive preprocessor directives.  */\n-#ifndef TARGET_ABI_OPEN_VMS\n-#define TARGET_ABI_OPEN_VMS 0\n-#endif\n-\n-/* VMS option set by default, when clear forces 32bit mallocs and 32bit\n-   Descriptors.  Always used in combination with TARGET_ABI_OPEN_VMS\n-   so no effect on non-VMS systems.  */\n-#if TARGET_ABI_OPEN_VMS == 0\n-#define flag_vms_malloc64 0\n-#endif\n-\n /* Convenient shortcuts.  */\n #define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)\n "}, {"sha": "240ca445d21b2e5894f0e48f07a794281dd80b29", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -407,10 +407,8 @@ gnat_init_gcc_fp (void)\n     flag_signed_zeros = 0;\n \n   /* Assume that FP operations can trap if S'Machine_Overflow is true,\n-     but don't override the user if not.\n-\n-     ??? Alpha/VMS enables FP traps without declaring it.  */\n-  if (Machine_Overflows_On_Target || TARGET_ABI_OPEN_VMS)\n+     but don't override the user if not.  */\n+  if (Machine_Overflows_On_Target)\n     flag_trapping_math = 1;\n   else if (!global_options_set.x_flag_trapping_math)\n     flag_trapping_math = 0;\n@@ -469,8 +467,6 @@ gnat_print_type (FILE *file, tree node, int indent)\n       else if (TYPE_HAS_ACTUAL_BOUNDS_P (node))\n \tprint_node (file, \"actual bounds\", TYPE_ACTUAL_BOUNDS (node),\n \t\t    indent + 4);\n-      else if (TYPE_VAX_FLOATING_POINT_P (node))\n-\t;\n       else\n \tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n "}, {"sha": "1b7d86100fe1ab4d7e94391878d38436b9478bd0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 67, "deletions": 272, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -285,8 +285,7 @@ gigi (Node_Id gnat_root,\n {\n   Node_Id gnat_iter;\n   Entity_Id gnat_literal;\n-  tree long_long_float_type, exception_type, t, ftype;\n-  tree int64_type = gnat_type_for_size (64, 0);\n+  tree t, ftype, int64_type;\n   struct elab_info *info;\n   int i;\n \n@@ -304,10 +303,6 @@ gigi (Node_Id gnat_root,\n \n   type_annotate_only = (gigi_operating_mode == 1);\n \n-#if TARGET_ABI_OPEN_VMS\n-  vms_float_format = Float_Format;\n-#endif\n-\n   for (i = 0; i < number_file; i++)\n     {\n       /* Use the identifier table to make a permanent copy of the filename as\n@@ -412,14 +407,6 @@ gigi (Node_Id gnat_root,\n \t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n-  /* malloc32 is a function declaration tree for a function to allocate\n-     32-bit memory on a 64-bit system.  Needed only on 64-bit VMS.  */\n-  malloc32_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_malloc32\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n-\t\t\t   NULL, Empty);\n-  DECL_IS_MALLOC (malloc32_decl) = 1;\n-\n   /* free is a function declaration tree for a function to free memory.  */\n   free_decl\n     = create_subprog_decl (get_identifier (\"__gnat_free\"), NULL_TREE,\n@@ -430,6 +417,7 @@ gigi (Node_Id gnat_root,\n \t\t\t   Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n+  int64_type = gnat_type_for_size (64, 0);\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n@@ -557,9 +545,7 @@ gigi (Node_Id gnat_root,\n     }\n \n   /* Set the types that GCC and Gigi use from the front end.  */\n-  exception_type\n-    = gnat_to_gnu_entity (Base_Type (standard_exception_type),  NULL_TREE, 0);\n-  except_type_node = TREE_TYPE (exception_type);\n+  except_type_node = gnat_to_gnu_type (Base_Type (standard_exception_type));\n \n   /* Make other functions used for exception processing.  */\n   get_excptr_decl\n@@ -624,21 +610,8 @@ gigi (Node_Id gnat_root,\n       null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_vec);\n     }\n \n-  long_long_float_type\n-    = gnat_to_gnu_entity (Base_Type (standard_long_long_float), NULL_TREE, 0);\n-\n-  if (TREE_CODE (TREE_TYPE (long_long_float_type)) == INTEGER_TYPE)\n-    {\n-      /* In this case, the builtin floating point types are VAX float,\n-\t so make up a type for use.  */\n-      longest_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (longest_float_type_node) = LONG_DOUBLE_TYPE_SIZE;\n-      layout_type (longest_float_type_node);\n-      record_builtin_type (\"longest float type\", longest_float_type_node,\n-\t\t\t   false);\n-    }\n-  else\n-    longest_float_type_node = TREE_TYPE (long_long_float_type);\n+  longest_float_type_node\n+    = get_unpadded_type (Base_Type (standard_long_long_float));\n \n   /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n      tables.  These are exported by a-exexpr-gcc.adb, so see this unit for\n@@ -1497,6 +1470,38 @@ Pragma_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* Return an expression for the length of TYPE, an integral type, computed in\n+   RESULT_TYPE, another integral type.\n+\n+   We used to compute the length as MAX (hb - lb + 1, 0) which could overflow\n+   when lb == TYPE'First.  We now compute it as (hb >= lb) ? hb - lb + 1 : 0\n+   which would only overflow in much rarer cases, for extremely large arrays\n+   we expect never to encounter in practice.  Besides, the former computation\n+   required the use of potentially constraining signed arithmetics while the\n+   latter does not.  Note that the comparison must be done in the original\n+   base index type in order to avoid any overflow during the conversion.  */\n+\n+static tree\n+get_type_length (tree type, tree result_type)\n+{\n+  tree comp_type = get_base_type (result_type);\n+  tree base_type = get_base_type (type);\n+  tree lb = convert (base_type, TYPE_MIN_VALUE (type));\n+  tree hb = convert (base_type, TYPE_MAX_VALUE (type));\n+  tree length\n+    = build_binary_op (PLUS_EXPR, comp_type,\n+\t\t       build_binary_op (MINUS_EXPR, comp_type,\n+\t\t\t\t\tconvert (comp_type, hb),\n+\t\t\t\t\tconvert (comp_type, lb)),\n+\t\t       convert (comp_type, integer_one_node));\n+  length\n+    = build_cond_expr (result_type,\n+\t\t       build_binary_op (GE_EXPR, boolean_type_node, hb, lb),\n+\t\t       convert (result_type, length),\n+\t\t       convert (result_type, integer_zero_node));\n+  return length;\n+}\n+\n /* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Attribute node,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n    where we should place the result type.  ATTRIBUTE is the attribute ID.  */\n@@ -1886,20 +1891,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  else if (attribute == Attr_Last)\n \t    gnu_result = TYPE_MAX_VALUE (gnu_type);\n \t  else\n-\t    gnu_result\n-\t      = build_binary_op\n-\t\t(MAX_EXPR, get_base_type (gnu_result_type),\n-\t\t build_binary_op\n-\t\t (PLUS_EXPR, get_base_type (gnu_result_type),\n-\t\t  build_binary_op (MINUS_EXPR,\n-\t\t\t\t   get_base_type (gnu_result_type),\n-\t\t\t\t   convert (gnu_result_type,\n-\t\t\t\t\t    TYPE_MAX_VALUE (gnu_type)),\n-\t\t\t\t   convert (gnu_result_type,\n-\t\t\t\t\t    TYPE_MIN_VALUE (gnu_type))),\n-\t\t  convert (gnu_result_type, integer_one_node)),\n-\t\t convert (gnu_result_type, integer_zero_node));\n-\n+\t    gnu_result = get_type_length (gnu_type, gnu_result_type);\n \t  break;\n \t}\n \n@@ -2031,37 +2023,10 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\tgnu_result = pa->length;\n \t\tbreak;\n \t      }\n-\t    else\n-\t      {\n-\t\t/* We used to compute the length as max (hb - lb + 1, 0),\n-\t\t   which could overflow for some cases of empty arrays, e.g.\n-\t\t   when lb == index_type'first.  We now compute the length as\n-\t\t   (hb >= lb) ? hb - lb + 1 : 0, which would only overflow in\n-\t\t   much rarer cases, for extremely large arrays we expect\n-\t\t   never to encounter in practice.  In addition, the former\n-\t\t   computation required the use of potentially constraining\n-\t\t   signed arithmetic while the latter doesn't.  Note that\n-\t\t   the comparison must be done in the original index type,\n-\t\t   to avoid any overflow during the conversion.  */\n-\t\ttree comp_type = get_base_type (gnu_result_type);\n-\t\ttree index_type = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n-\t\ttree lb = TYPE_MIN_VALUE (index_type);\n-\t\ttree hb = TYPE_MAX_VALUE (index_type);\n-\t\tgnu_result\n-\t\t  = build_binary_op (PLUS_EXPR, comp_type,\n-\t\t\t\t     build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t      comp_type,\n-\t\t\t\t\t\t      convert (comp_type, hb),\n-\t\t\t\t\t\t      convert (comp_type, lb)),\n-\t\t\t\t     convert (comp_type, integer_one_node));\n-\t\tgnu_result\n-\t\t  = build_cond_expr (comp_type,\n-\t\t\t\t     build_binary_op (GE_EXPR,\n-\t\t\t\t\t\t      boolean_type_node,\n-\t\t\t\t\t\t      hb, lb),\n-\t\t\t\t     gnu_result,\n-\t\t\t\t     convert (comp_type, integer_zero_node));\n-\t      }\n+\n+\t    gnu_result\n+\t      = get_type_length (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)),\n+\t\t\t\t gnu_result_type);\n \t  }\n \n \t/* If this has a PLACEHOLDER_EXPR, qualify it by the object we are\n@@ -2334,14 +2299,16 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n     case Attr_Machine:\n       /* The trick is to force the compiler to store the result in memory so\n \t that we do not have extra precision used.  But do this only when this\n-\t is necessary, i.e. for a type that is not the longest floating-point\n-\t type and if FP_ARITH_MAY_WIDEN is true.  */\n+\t is necessary, i.e. if FP_ARITH_MAY_WIDEN is true and the precision of\n+\t the type is lower than that of the longest floating-point type.  */\n       prefix_unused = true;\n       gnu_expr = gnat_to_gnu (First (Expressions (gnat_node)));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result = convert (gnu_result_type, gnu_expr);\n \n-      if (gnu_result_type != longest_float_type_node && fp_arith_may_widen)\n+      if (fp_arith_may_widen\n+\t  && TYPE_PRECISION (gnu_result_type)\n+\t     < TYPE_PRECISION (longest_float_type_node))\n \t{\n \t  tree rec_type = make_node (RECORD_TYPE);\n \t  tree field\n@@ -2677,8 +2644,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       enum tree_code update_code, test_code, shift_code;\n       bool reverse = Reverse_Present (gnat_loop_spec), use_iv = false;\n \n-      gnu_low = TYPE_MIN_VALUE (gnu_type);\n-      gnu_high = TYPE_MAX_VALUE (gnu_type);\n+      gnu_low = convert (gnu_base_type, TYPE_MIN_VALUE (gnu_type));\n+      gnu_high = convert (gnu_base_type, TYPE_MAX_VALUE (gnu_type));\n \n       /* We must disable modulo reduction for the iteration variable, if any,\n \t in order for the loop comparison to be effective.  */\n@@ -2971,61 +2938,6 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n-/* Emit statements to establish __gnat_handle_vms_condition as a VMS condition\n-   handler for the current function.  */\n-\n-/* This is implemented by issuing a call to the appropriate VMS specific\n-   builtin.  To avoid having VMS specific sections in the global gigi decls\n-   array, we maintain the decls of interest here.  We can't declare them\n-   inside the function because we must mark them never to be GC'd, which we\n-   can only do at the global level.  */\n-\n-static GTY(()) tree vms_builtin_establish_handler_decl = NULL_TREE;\n-static GTY(()) tree gnat_vms_condition_handler_decl = NULL_TREE;\n-\n-static void\n-establish_gnat_vms_condition_handler (void)\n-{\n-  tree establish_stmt;\n-\n-  /* Elaborate the required decls on the first call.  Check on the decl for\n-     the gnat condition handler to decide, as this is one we create so we are\n-     sure that it will be non null on subsequent calls.  The builtin decl is\n-     looked up so remains null on targets where it is not implemented yet.  */\n-  if (gnat_vms_condition_handler_decl == NULL_TREE)\n-    {\n-      vms_builtin_establish_handler_decl\n-\t= builtin_decl_for\n-\t  (get_identifier (\"__builtin_establish_vms_condition_handler\"));\n-\n-      gnat_vms_condition_handler_decl\n-\t= create_subprog_decl (get_identifier (\"__gnat_handle_vms_condition\"),\n-\t\t\t       NULL_TREE,\n-\t\t\t       build_function_type_list (boolean_type_node,\n-\t\t\t\t\t\t\t ptr_void_type_node,\n-\t\t\t\t\t\t\t ptr_void_type_node,\n-\t\t\t\t\t\t\t NULL_TREE),\n-\t\t\t       NULL_TREE, is_disabled, true, true, true, NULL,\n-\t\t\t       Empty);\n-\n-      /* ??? DECL_CONTEXT shouldn't have been set because of DECL_EXTERNAL.  */\n-      DECL_CONTEXT (gnat_vms_condition_handler_decl) = NULL_TREE;\n-    }\n-\n-  /* Do nothing if the establish builtin is not available, which might happen\n-     on targets where the facility is not implemented.  */\n-  if (vms_builtin_establish_handler_decl == NULL_TREE)\n-    return;\n-\n-  establish_stmt\n-    = build_call_n_expr (vms_builtin_establish_handler_decl, 1,\n-\t\t\t build_unary_op\n-\t\t\t (ADDR_EXPR, NULL_TREE,\n-\t\t\t  gnat_vms_condition_handler_decl));\n-\n-  add_stmt (establish_stmt);\n-}\n-\n /* This page implements a form of Named Return Value optimization modelled\n    on the C++ optimization of the same name.  The main difference is that\n    we disregard any semantical considerations when applying it here, the\n@@ -3519,69 +3431,6 @@ build_return_expr (tree ret_obj, tree ret_val)\n \n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }\n-\n-/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n-   and the GNAT node GNAT_SUBPROG.  */\n-\n-static void\n-build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n-{\n-  tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n-  tree gnu_subprog_param, gnu_stub_param, gnu_param;\n-  tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n-  vec<tree, va_gc> *gnu_param_vec = NULL;\n-\n-  gnu_subprog_type = TREE_TYPE (gnu_subprog);\n-\n-  /* Initialize the information structure for the function.  */\n-  allocate_struct_function (gnu_stub_decl, false);\n-  set_cfun (NULL);\n-\n-  begin_subprog_body (gnu_stub_decl);\n-\n-  start_stmt_group ();\n-  gnat_pushlevel ();\n-\n-  /* Loop over the parameters of the stub and translate any of them\n-     passed by descriptor into a by reference one.  */\n-  for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n-       gnu_subprog_param = DECL_ARGUMENTS (gnu_subprog);\n-       gnu_stub_param;\n-       gnu_stub_param = DECL_CHAIN (gnu_stub_param),\n-       gnu_subprog_param = DECL_CHAIN (gnu_subprog_param))\n-    {\n-      if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n-\t{\n-\t  gcc_assert (DECL_BY_REF_P (gnu_subprog_param));\n-\t  gnu_param\n-\t    = convert_vms_descriptor (TREE_TYPE (gnu_subprog_param),\n-\t\t\t\t      gnu_stub_param,\n-\t\t\t\t      DECL_PARM_ALT_TYPE (gnu_stub_param),\n-\t\t\t\t      gnat_subprog);\n-\t}\n-      else\n-\tgnu_param = gnu_stub_param;\n-\n-      vec_safe_push (gnu_param_vec, gnu_param);\n-    }\n-\n-  /* Invoke the internal subprogram.  */\n-  gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n-\t\t\t     gnu_subprog);\n-  gnu_subprog_call = build_call_vec (TREE_TYPE (gnu_subprog_type),\n-                                     gnu_subprog_addr, gnu_param_vec);\n-\n-  /* Propagate the return value, if any.  */\n-  if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))\n-    add_stmt (gnu_subprog_call);\n-  else\n-    add_stmt (build_return_expr (DECL_RESULT (gnu_stub_decl),\n-\t\t\t\t gnu_subprog_call));\n-\n-  gnat_poplevel ();\n-  end_subprog_body (end_stmt_group ());\n-  rest_of_subprog_body_compilation (gnu_stub_decl);\n-}\n \f\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n    don't return anything.  */\n@@ -3730,22 +3579,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   start_stmt_group ();\n   gnat_pushlevel ();\n \n-  /* On VMS, establish our condition handler to possibly turn a condition into\n-     the corresponding exception if the subprogram has a foreign convention or\n-     is exported.\n-\n-     To ensure proper execution of local finalizations on condition instances,\n-     we must turn a condition into the corresponding exception even if there\n-     is no applicable Ada handler, and need at least one condition handler per\n-     possible call chain involving GNAT code.  OTOH, establishing the handler\n-     has a cost so we want to minimize the number of subprograms into which\n-     this happens.  The foreign or exported condition is expected to satisfy\n-     all the constraints.  */\n-  if (TARGET_ABI_OPEN_VMS\n-      && (Has_Foreign_Convention (gnat_subprog_id)\n-\t  || Is_Exported (gnat_subprog_id)))\n-    establish_gnat_vms_condition_handler ();\n-\n   process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n   /* Generate the code of the subprogram itself.  A return statement will be\n@@ -3878,10 +3711,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     }\n \n   rest_of_subprog_body_compilation (gnu_subprog_decl);\n-\n-  /* If there is a stub associated with the function, build it now.  */\n-  if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n-    build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n }\n \f\n /* Return true if GNAT_NODE requires atomic synchronization.  */\n@@ -4091,10 +3920,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       const bool is_true_formal_parm\n \t= gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL;\n       const bool is_by_ref_formal_parm\n- \t= is_true_formal_parm\n- \t  && (DECL_BY_REF_P (gnu_formal)\n-\t      || DECL_BY_COMPONENT_PTR_P (gnu_formal)\n-\t      || DECL_BY_DESCRIPTOR_P (gnu_formal));\n+\t= is_true_formal_parm\n+\t  && (DECL_BY_REF_P (gnu_formal)\n+\t      || DECL_BY_COMPONENT_PTR_P (gnu_formal));\n       /* In the Out or In Out case, we must suppress conversions that yield\n \t an lvalue but can nevertheless cause the creation of a temporary,\n \t because we need the real object in this case, either to pass its\n@@ -4351,24 +4179,6 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n \n-      /* Then see if the parameter is passed by descriptor.  */\n-      else if (is_true_formal_parm && DECL_BY_DESCRIPTOR_P (gnu_formal))\n-\t{\n-\t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n-\n-\t  /* If this is 'Null_Parameter, pass a zero descriptor.  */\n-\t  if ((TREE_CODE (gnu_actual) == INDIRECT_REF\n-\t       || TREE_CODE (gnu_actual) == UNCONSTRAINED_ARRAY_REF)\n-\t      && TREE_PRIVATE (gnu_actual))\n-\t    gnu_actual\n-\t      = convert (DECL_ARG_TYPE (gnu_formal), integer_zero_node);\n-\t  else\n-\t    gnu_actual = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t fill_vms_descriptor\n-\t\t\t\t\t (TREE_TYPE (TREE_TYPE (gnu_formal)),\n-\t\t\t\t\t  gnu_actual, gnat_actual));\n-\t}\n-\n       /* Otherwise the parameter is passed by copy.  */\n       else\n \t{\n@@ -4482,10 +4292,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \tif (!(present_gnu_tree (gnat_formal)\n \t      && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n \t      && (DECL_BY_REF_P (get_gnu_tree (gnat_formal))\n-\t\t  || (TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n-\t\t      && ((DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal))\n-\t\t\t   || (DECL_BY_DESCRIPTOR_P\n-\t\t\t       (get_gnu_tree (gnat_formal))))))))\n+\t\t  || DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal))))\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t  {\n \t    /* Get the value to assign to this Out or In Out parameter.  It is\n@@ -4986,9 +4793,6 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n \n \t  gnu_expr = gnat_to_gnu_entity (gnat_ex_id, NULL_TREE, 0);\n \t  gnu_etype = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);\n-\n-\t  /* The Non_Ada_Error case for VMS exceptions is handled\n-\t     by the personality routine.  */\n \t}\n       else\n \tgcc_unreachable ();\n@@ -5943,25 +5747,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Selected_Component:\n       {\n-\ttree gnu_prefix = gnat_to_gnu (Prefix (gnat_node));\n+\tEntity_Id gnat_prefix = Prefix (gnat_node);\n \tEntity_Id gnat_field = Entity (Selector_Name (gnat_node));\n-\tEntity_Id gnat_pref_type = Etype (Prefix (gnat_node));\n+\ttree gnu_prefix = gnat_to_gnu (gnat_prefix);\n \ttree gnu_field;\n \n-\twhile (IN (Ekind (gnat_pref_type), Incomplete_Or_Private_Kind)\n-\t       || IN (Ekind (gnat_pref_type), Access_Kind))\n-\t  {\n-\t    if (IN (Ekind (gnat_pref_type), Incomplete_Or_Private_Kind))\n-\t      gnat_pref_type = Underlying_Type (gnat_pref_type);\n-\t    else if (IN (Ekind (gnat_pref_type), Access_Kind))\n-\t      gnat_pref_type = Designated_Type (gnat_pref_type);\n-\t  }\n-\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \n \t/* For discriminant references in tagged types always substitute the\n \t   corresponding discriminant as the actual selected component.  */\n-\tif (Is_Tagged_Type (gnat_pref_type))\n+\tif (Is_Tagged_Type (Etype (gnat_prefix)))\n \t  while (Present (Corresponding_Discriminant (gnat_field)))\n \t    gnat_field = Corresponding_Discriminant (gnat_field);\n \n@@ -6170,9 +5965,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t || Nkind (gnat_range) == N_Expanded_Name)\n \t  {\n \t    tree gnu_range_type = get_unpadded_type (Entity (gnat_range));\n+\t    tree gnu_range_base_type = get_base_type (gnu_range_type);\n \n-\t    gnu_low = TYPE_MIN_VALUE (gnu_range_type);\n-\t    gnu_high = TYPE_MAX_VALUE (gnu_range_type);\n+\t    gnu_low\n+\t      = convert (gnu_range_base_type, TYPE_MIN_VALUE (gnu_range_type));\n+\t    gnu_high\n+\t      = convert (gnu_range_base_type, TYPE_MAX_VALUE (gnu_range_type));\n \t  }\n \telse\n \t  gcc_unreachable ();\n@@ -8625,11 +8423,12 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   tree gnu_base_type = get_base_type (gnu_type);\n   tree gnu_result = gnu_expr;\n \n-  /* If we are not doing any checks, the output is an integral type, and\n-     the input is not a floating type, just do the conversion.  This\n-     shortcut is required to avoid problems with packed array types\n-     and simplifies code in all cases anyway.   */\n-  if (!rangep && !overflowp && INTEGRAL_TYPE_P (gnu_base_type)\n+  /* If we are not doing any checks, the output is an integral type and the\n+     input is not a floating-point type, just do the conversion.  This is\n+     required for packed array types and is simpler in all cases anyway.   */\n+  if (!rangep\n+      && !overflowp\n+      && INTEGRAL_TYPE_P (gnu_base_type)\n       && !FLOAT_TYPE_P (gnu_in_type))\n     return convert (gnu_type, gnu_expr);\n \n@@ -8730,10 +8529,6 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       calc_type\n \t= fp_arith_may_widen ? longest_float_type_node : gnu_in_basetype;\n \n-      /* FIXME: Should not have padding in the first place.  */\n-      if (TYPE_IS_PADDING_P (calc_type))\n-\tcalc_type = TREE_TYPE (TYPE_FIELDS (calc_type));\n-\n       /* Compute the exact value calc_type'Pred (0.5) at compile time.  */\n       fmt = REAL_MODE_FORMAT (TYPE_MODE (calc_type));\n       real_2expN (&half_minus_pred_half, -(fmt->p) - 1, TYPE_MODE (calc_type));"}, {"sha": "f450f24ed9d3ed47d081108a68b05600ec851059", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 22, "deletions": 980, "changes": 1002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -954,12 +954,8 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       else\n \tnew_type = make_signed_type (size);\n       TREE_TYPE (new_type) = TREE_TYPE (type) ? TREE_TYPE (type) : type;\n-      SET_TYPE_RM_MIN_VALUE (new_type,\n-\t\t\t     convert (TREE_TYPE (new_type),\n-\t\t\t\t      TYPE_MIN_VALUE (type)));\n-      SET_TYPE_RM_MAX_VALUE (new_type,\n-\t\t\t     convert (TREE_TYPE (new_type),\n-\t\t\t\t      TYPE_MAX_VALUE (type)));\n+      SET_TYPE_RM_MIN_VALUE (new_type, TYPE_MIN_VALUE (type));\n+      SET_TYPE_RM_MAX_VALUE (new_type, TYPE_MAX_VALUE (type));\n       /* Copy the name to show that it's essentially the same type and\n \t not a subrange type.  */\n       TYPE_NAME (new_type) = TYPE_NAME (type);\n@@ -2051,8 +2047,8 @@ create_range_type (tree type, tree min, tree max)\n \t\t\t\t\t\t TYPE_MAX_VALUE (type));\n \n   /* Then set the actual range.  */\n-  SET_TYPE_RM_MIN_VALUE (range_type, convert (type, min));\n-  SET_TYPE_RM_MAX_VALUE (range_type, convert (type, max));\n+  SET_TYPE_RM_MIN_VALUE (range_type, min);\n+  SET_TYPE_RM_MAX_VALUE (range_type, max);\n \n   return range_type;\n }\n@@ -2734,10 +2730,11 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n \n     case is_required:\n       if (Back_End_Inlining)\n-        decl_attributes (&subprog_decl,\n-\t\t\t\t  tree_cons (get_identifier (\"always_inline\"),\n-                    NULL_TREE, NULL_TREE),\n-              ATTR_FLAG_TYPE_IN_PLACE);\n+\tdecl_attributes (&subprog_decl,\n+\t\t\t tree_cons (get_identifier (\"always_inline\"),\n+\t\t\t\t    NULL_TREE, NULL_TREE),\n+\t\t\t ATTR_FLAG_TYPE_IN_PLACE);\n+\n       /* ... fall through ... */\n \n     case is_enabled:\n@@ -3108,12 +3105,14 @@ max_size (tree exp, bool max_p)\n     case tcc_reference:\n       /* If this contains a PLACEHOLDER_EXPR, it is the thing we want to\n \t modify.  Otherwise, we treat it like a variable.  */\n-      if (!CONTAINS_PLACEHOLDER_P (exp))\n-\treturn exp;\n+      if (CONTAINS_PLACEHOLDER_P (exp))\n+\t{\n+\t  tree val_type = TREE_TYPE (TREE_OPERAND (exp, 1));\n+\t  tree val = (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type));\n+\t  return max_size (convert (get_base_type (val_type), val), true);\n+\t}\n \n-      type = TREE_TYPE (TREE_OPERAND (exp, 1));\n-      return\n-\tmax_size (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type), true);\n+      return exp;\n \n     case tcc_comparison:\n       return max_p ? size_one_node : size_zero_node;\n@@ -3343,962 +3342,6 @@ build_vector_type_for_array (tree array_type, tree attribute)\n   return vector_type;\n }\n \f\n-/* Helper routine to make a descriptor field.  FIELD_LIST is the list of decls\n-   being built; the new decl is chained on to the front of the list.  */\n-\n-static tree\n-make_descriptor_field (const char *name, tree type, tree rec_type,\n-\t\t       tree initial, tree field_list)\n-{\n-  tree field\n-    = create_field_decl (get_identifier (name), type, rec_type, NULL_TREE,\n-\t\t\t NULL_TREE, 0, 0);\n-\n-  DECL_INITIAL (field) = initial;\n-  DECL_CHAIN (field) = field_list;\n-  return field;\n-}\n-\n-/* Build a 32-bit VMS descriptor from a Mechanism_Type, which must specify a\n-   descriptor type, and the GCC type of an object.  Each FIELD_DECL in the\n-   type contains in its DECL_INITIAL the expression to use when a constructor\n-   is made for the type.  GNAT_ENTITY is an entity used to print out an error\n-   message if the mechanism cannot be applied to an object of that type and\n-   also for the name.  */\n-\n-tree\n-build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n-{\n-  tree record_type = make_node (RECORD_TYPE);\n-  tree pointer32_type, pointer64_type;\n-  tree field_list = NULL_TREE;\n-  int klass, ndim, i, dtype = 0;\n-  tree inner_type, tem;\n-  tree *idx_arr;\n-\n-  /* If TYPE is an unconstrained array, use the underlying array type.  */\n-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n-    type = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type))));\n-\n-  /* If this is an array, compute the number of dimensions in the array,\n-     get the index types, and point to the inner type.  */\n-  if (TREE_CODE (type) != ARRAY_TYPE)\n-    ndim = 0;\n-  else\n-    for (ndim = 1, inner_type = type;\n-\t TREE_CODE (TREE_TYPE (inner_type)) == ARRAY_TYPE\n-\t && TYPE_MULTI_ARRAY_P (TREE_TYPE (inner_type));\n-\t ndim++, inner_type = TREE_TYPE (inner_type))\n-      ;\n-\n-  idx_arr = XALLOCAVEC (tree, ndim);\n-\n-  if (mech != By_Descriptor_NCA && mech != By_Short_Descriptor_NCA\n-      && TREE_CODE (type) == ARRAY_TYPE && TYPE_CONVENTION_FORTRAN_P (type))\n-    for (i = ndim - 1, inner_type = type;\n-\t i >= 0;\n-\t i--, inner_type = TREE_TYPE (inner_type))\n-      idx_arr[i] = TYPE_DOMAIN (inner_type);\n-  else\n-    for (i = 0, inner_type = type;\n-\t i < ndim;\n-\t i++, inner_type = TREE_TYPE (inner_type))\n-      idx_arr[i] = TYPE_DOMAIN (inner_type);\n-\n-  /* Now get the DTYPE value.  */\n-  switch (TREE_CODE (type))\n-    {\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      if (TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch (tree_to_uhwi (TYPE_DIGITS_VALUE (type)))\n-\t  {\n-\t  case 6:\n-\t    dtype = 10;\n-\t    break;\n-\t  case 9:\n-\t    dtype = 11;\n-\t    break;\n-\t  case 15:\n-\t    dtype = 27;\n-\t    break;\n-\t  }\n-      else\n-\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\t  {\n-\t  case 8:\n-\t    dtype = TYPE_UNSIGNED (type) ? 2 : 6;\n-\t    break;\n-\t  case 16:\n-\t    dtype = TYPE_UNSIGNED (type) ? 3 : 7;\n-\t    break;\n-\t  case 32:\n-\t    dtype = TYPE_UNSIGNED (type) ? 4 : 8;\n-\t    break;\n-\t  case 64:\n-\t    dtype = TYPE_UNSIGNED (type) ? 5 : 9;\n-\t    break;\n-\t  case 128:\n-\t    dtype = TYPE_UNSIGNED (type) ? 25 : 26;\n-\t    break;\n-\t  }\n-      break;\n-\n-    case REAL_TYPE:\n-      dtype = GET_MODE_BITSIZE (TYPE_MODE (type)) == 32 ? 52 : 53;\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n-\t  && TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch (tree_to_uhwi (TYPE_DIGITS_VALUE (type)))\n-\t  {\n-\t  case 6:\n-\t    dtype = 12;\n-\t    break;\n-\t  case 9:\n-\t    dtype = 13;\n-\t    break;\n-\t  case 15:\n-\t    dtype = 29;\n-\t  }\n-      else\n-\tdtype = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) == 32 ? 54: 55;\n-      break;\n-\n-    case ARRAY_TYPE:\n-      dtype = 14;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Get the CLASS value.  */\n-  switch (mech)\n-    {\n-    case By_Descriptor_A:\n-    case By_Short_Descriptor_A:\n-      klass = 4;\n-      break;\n-    case By_Descriptor_NCA:\n-    case By_Short_Descriptor_NCA:\n-      klass = 10;\n-      break;\n-    case By_Descriptor_SB:\n-    case By_Short_Descriptor_SB:\n-      klass = 15;\n-      break;\n-    case By_Descriptor:\n-    case By_Short_Descriptor:\n-    case By_Descriptor_S:\n-    case By_Short_Descriptor_S:\n-    default:\n-      klass = 1;\n-      break;\n-    }\n-\n-  /* Make the type for a descriptor for VMS.  The first four fields are the\n-     same for all types.  */\n-  field_list\n-    = make_descriptor_field (\"LENGTH\", gnat_type_for_size (16, 1), record_type,\n-\t\t\t     size_in_bytes ((mech == By_Descriptor_A\n-\t\t\t\t\t     || mech == By_Short_Descriptor_A)\n-\t\t\t\t\t    ? inner_type : type),\n-\t\t\t     field_list);\n-  field_list\n-    = make_descriptor_field (\"DTYPE\", gnat_type_for_size (8, 1), record_type,\n-\t\t\t     size_int (dtype), field_list);\n-  field_list\n-    = make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1), record_type,\n-\t\t\t     size_int (klass), field_list);\n-\n-  pointer32_type = build_pointer_type_for_mode (type, SImode, false);\n-  pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n-\n-  /* Ensure that only 32-bit pointers are passed in 32-bit descriptors.  Note\n-     that we cannot build a template call to the CE routine as it would get a\n-     wrong source location; instead we use a second placeholder for it.  */\n-  tem = build_unary_op (ADDR_EXPR, pointer64_type,\n-\t\t\tbuild0 (PLACEHOLDER_EXPR, type));\n-  tem = build3 (COND_EXPR, pointer32_type,\n-\t\tPmode != SImode\n-\t\t? build_binary_op (GE_EXPR, boolean_type_node, tem,\n-\t\t\t\t   build_int_cstu (pointer64_type, 0x80000000))\n-\t\t: boolean_false_node,\n-\t\tbuild0 (PLACEHOLDER_EXPR, void_type_node),\n-\t\tconvert (pointer32_type, tem));\n-\n-  field_list\n-    = make_descriptor_field (\"POINTER\", pointer32_type, record_type, tem,\n-\t\t\t     field_list);\n-\n-  switch (mech)\n-    {\n-    case By_Descriptor:\n-    case By_Short_Descriptor:\n-    case By_Descriptor_S:\n-    case By_Short_Descriptor_S:\n-      break;\n-\n-    case By_Descriptor_SB:\n-    case By_Short_Descriptor_SB:\n-      field_list\n-\t= make_descriptor_field (\"SB_L1\", gnat_type_for_size (32, 1),\n-\t\t\t         record_type,\n-\t\t\t         (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t\t  ? TYPE_MIN_VALUE (TYPE_DOMAIN (type))\n-\t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list);\n-      field_list\n-\t= make_descriptor_field (\"SB_U1\", gnat_type_for_size (32, 1),\n-\t\t\t\t record_type,\n-\t\t\t\t (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t\t  ? TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n-\t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list);\n-      break;\n-\n-    case By_Descriptor_A:\n-    case By_Short_Descriptor_A:\n-    case By_Descriptor_NCA:\n-    case By_Short_Descriptor_NCA:\n-      field_list\n-\t= make_descriptor_field (\"SCALE\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_zero_node, field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"DIGITS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_zero_node, field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"AFLAGS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type,\n-\t\t\t\t size_int ((mech == By_Descriptor_NCA\n-\t\t\t\t\t    || mech == By_Short_Descriptor_NCA)\n-\t\t\t\t\t   ? 0\n-\t\t\t\t\t   /* Set FL_COLUMN, FL_COEFF, and\n-\t\t\t\t\t      FL_BOUNDS.  */\n-\t\t\t\t\t   : (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t\t\t      && TYPE_CONVENTION_FORTRAN_P\n-\t\t\t\t\t\t (type)\n-\t\t\t\t\t     ? 224 : 192)),\n-\t\t\t\t field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"DIMCT\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_int (ndim), field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"ARSIZE\", gnat_type_for_size (32, 1),\n-\t\t\t\t record_type, size_in_bytes (type),\n-\t\t\t\t field_list);\n-\n-      /* Now build a pointer to the 0,0,0... element.  */\n-      tem = build0 (PLACEHOLDER_EXPR, type);\n-      for (i = 0, inner_type = type; i < ndim;\n-\t   i++, inner_type = TREE_TYPE (inner_type))\n-\ttem = build4 (ARRAY_REF, TREE_TYPE (inner_type), tem,\n-\t\t      convert (TYPE_DOMAIN (inner_type), size_zero_node),\n-\t\t      NULL_TREE, NULL_TREE);\n-\n-      field_list\n-\t= make_descriptor_field (\"A0\", pointer32_type, record_type,\n-\t\t\t\t build1 (ADDR_EXPR, pointer32_type, tem),\n-\t\t\t\t field_list);\n-\n-      /* Next come the addressing coefficients.  */\n-      tem = size_one_node;\n-      for (i = 0; i < ndim; i++)\n-\t{\n-\t  char fname[3];\n-\t  tree idx_length\n-\t    = size_binop (MULT_EXPR, tem,\n-\t\t\t  size_binop (PLUS_EXPR,\n-\t\t\t\t      size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t  TYPE_MAX_VALUE (idx_arr[i]),\n-\t\t\t\t\t\t  TYPE_MIN_VALUE (idx_arr[i])),\n-\t\t\t\t      size_int (1)));\n-\n-\t  fname[0] = ((mech == By_Descriptor_NCA ||\n-                       mech == By_Short_Descriptor_NCA) ? 'S' : 'M');\n-\t  fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (32, 1),\n-\t\t\t\t     record_type, idx_length, field_list);\n-\n-\t  if (mech == By_Descriptor_NCA || mech == By_Short_Descriptor_NCA)\n-\t    tem = idx_length;\n-\t}\n-\n-      /* Finally here are the bounds.  */\n-      for (i = 0; i < ndim; i++)\n-\t{\n-\t  char fname[3];\n-\n-\t  fname[0] = 'L', fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (32, 1),\n-\t\t\t\t     record_type, TYPE_MIN_VALUE (idx_arr[i]),\n-\t\t\t\t     field_list);\n-\n-\t  fname[0] = 'U';\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (32, 1),\n-\t\t\t\t     record_type, TYPE_MAX_VALUE (idx_arr[i]),\n-\t\t\t\t     field_list);\n-\t}\n-      break;\n-\n-    default:\n-      post_error (\"unsupported descriptor type for &\", gnat_entity);\n-    }\n-\n-  TYPE_NAME (record_type) = create_concat_name (gnat_entity, \"DESC\");\n-  finish_record_type (record_type, nreverse (field_list), 0, false);\n-  return record_type;\n-}\n-\n-/* Build a 64-bit VMS descriptor from a Mechanism_Type, which must specify a\n-   descriptor type, and the GCC type of an object.  Each FIELD_DECL in the\n-   type contains in its DECL_INITIAL the expression to use when a constructor\n-   is made for the type.  GNAT_ENTITY is an entity used to print out an error\n-   message if the mechanism cannot be applied to an object of that type and\n-   also for the name.  */\n-\n-tree\n-build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n-{\n-  tree record_type = make_node (RECORD_TYPE);\n-  tree pointer64_type;\n-  tree field_list = NULL_TREE;\n-  int klass, ndim, i, dtype = 0;\n-  tree inner_type, tem;\n-  tree *idx_arr;\n-\n-  /* If TYPE is an unconstrained array, use the underlying array type.  */\n-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n-    type = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type))));\n-\n-  /* If this is an array, compute the number of dimensions in the array,\n-     get the index types, and point to the inner type.  */\n-  if (TREE_CODE (type) != ARRAY_TYPE)\n-    ndim = 0;\n-  else\n-    for (ndim = 1, inner_type = type;\n-\t TREE_CODE (TREE_TYPE (inner_type)) == ARRAY_TYPE\n-\t && TYPE_MULTI_ARRAY_P (TREE_TYPE (inner_type));\n-\t ndim++, inner_type = TREE_TYPE (inner_type))\n-      ;\n-\n-  idx_arr = XALLOCAVEC (tree, ndim);\n-\n-  if (mech != By_Descriptor_NCA\n-      && TREE_CODE (type) == ARRAY_TYPE && TYPE_CONVENTION_FORTRAN_P (type))\n-    for (i = ndim - 1, inner_type = type;\n-\t i >= 0;\n-\t i--, inner_type = TREE_TYPE (inner_type))\n-      idx_arr[i] = TYPE_DOMAIN (inner_type);\n-  else\n-    for (i = 0, inner_type = type;\n-\t i < ndim;\n-\t i++, inner_type = TREE_TYPE (inner_type))\n-      idx_arr[i] = TYPE_DOMAIN (inner_type);\n-\n-  /* Now get the DTYPE value.  */\n-  switch (TREE_CODE (type))\n-    {\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      if (TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch (tree_to_uhwi (TYPE_DIGITS_VALUE (type)))\n-\t  {\n-\t  case 6:\n-\t    dtype = 10;\n-\t    break;\n-\t  case 9:\n-\t    dtype = 11;\n-\t    break;\n-\t  case 15:\n-\t    dtype = 27;\n-\t    break;\n-\t  }\n-      else\n-\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\t  {\n-\t  case 8:\n-\t    dtype = TYPE_UNSIGNED (type) ? 2 : 6;\n-\t    break;\n-\t  case 16:\n-\t    dtype = TYPE_UNSIGNED (type) ? 3 : 7;\n-\t    break;\n-\t  case 32:\n-\t    dtype = TYPE_UNSIGNED (type) ? 4 : 8;\n-\t    break;\n-\t  case 64:\n-\t    dtype = TYPE_UNSIGNED (type) ? 5 : 9;\n-\t    break;\n-\t  case 128:\n-\t    dtype = TYPE_UNSIGNED (type) ? 25 : 26;\n-\t    break;\n-\t  }\n-      break;\n-\n-    case REAL_TYPE:\n-      dtype = GET_MODE_BITSIZE (TYPE_MODE (type)) == 32 ? 52 : 53;\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n-\t  && TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch (tree_to_uhwi (TYPE_DIGITS_VALUE (type)))\n-\t  {\n-\t  case 6:\n-\t    dtype = 12;\n-\t    break;\n-\t  case 9:\n-\t    dtype = 13;\n-\t    break;\n-\t  case 15:\n-\t    dtype = 29;\n-\t  }\n-      else\n-\tdtype = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) == 32 ? 54: 55;\n-      break;\n-\n-    case ARRAY_TYPE:\n-      dtype = 14;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Get the CLASS value.  */\n-  switch (mech)\n-    {\n-    case By_Descriptor_A:\n-      klass = 4;\n-      break;\n-    case By_Descriptor_NCA:\n-      klass = 10;\n-      break;\n-    case By_Descriptor_SB:\n-      klass = 15;\n-      break;\n-    case By_Descriptor:\n-    case By_Descriptor_S:\n-    default:\n-      klass = 1;\n-      break;\n-    }\n-\n-  /* Make the type for a 64-bit descriptor for VMS.  The first six fields\n-     are the same for all types.  */\n-  field_list\n-    = make_descriptor_field (\"MBO\", gnat_type_for_size (16, 1),\n-\t\t\t     record_type, size_int (1), field_list);\n-  field_list\n-    = make_descriptor_field (\"DTYPE\", gnat_type_for_size (8, 1),\n-\t\t\t     record_type, size_int (dtype), field_list);\n-  field_list\n-    = make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1),\n-\t\t\t     record_type, size_int (klass), field_list);\n-  field_list\n-    = make_descriptor_field (\"MBMO\", gnat_type_for_size (32, 1),\n-\t\t\t     record_type, size_int (-1), field_list);\n-  field_list\n-    = make_descriptor_field (\"LENGTH\", gnat_type_for_size (64, 1),\n-\t\t\t     record_type,\n-\t\t\t     size_in_bytes (mech == By_Descriptor_A\n-\t\t\t\t\t    ? inner_type : type),\n-\t\t\t     field_list);\n-\n-  pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n-\n-  field_list\n-    = make_descriptor_field (\"POINTER\", pointer64_type, record_type,\n-\t\t\t     build_unary_op (ADDR_EXPR, pointer64_type,\n-\t\t\t\t\t     build0 (PLACEHOLDER_EXPR, type)),\n-\t\t\t     field_list);\n-\n-  switch (mech)\n-    {\n-    case By_Descriptor:\n-    case By_Descriptor_S:\n-      break;\n-\n-    case By_Descriptor_SB:\n-      field_list\n-\t= make_descriptor_field (\"SB_L1\", gnat_type_for_size (64, 1),\n-\t\t\t\t record_type,\n-\t\t\t\t (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t\t  ? TYPE_MIN_VALUE (TYPE_DOMAIN (type))\n-\t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list);\n-      field_list\n-\t= make_descriptor_field (\"SB_U1\", gnat_type_for_size (64, 1),\n-\t\t\t\t record_type,\n-\t\t\t\t (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t\t  ? TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n-\t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list);\n-      break;\n-\n-    case By_Descriptor_A:\n-    case By_Descriptor_NCA:\n-      field_list\n-\t= make_descriptor_field (\"SCALE\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_zero_node, field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"DIGITS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_zero_node, field_list);\n-\n-      dtype = (mech == By_Descriptor_NCA\n-\t       ? 0\n-\t       /* Set FL_COLUMN, FL_COEFF, and\n-\t\t  FL_BOUNDS.  */\n-\t       : (TREE_CODE (type) == ARRAY_TYPE\n-\t\t  && TYPE_CONVENTION_FORTRAN_P (type)\n-\t\t  ? 224 : 192));\n-      field_list\n-\t= make_descriptor_field (\"AFLAGS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_int (dtype),\n-\t\t\t\t field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"DIMCT\", gnat_type_for_size (8, 1),\n-\t\t\t\t record_type, size_int (ndim), field_list);\n-\n-      field_list\n-\t= make_descriptor_field (\"MBZ\", gnat_type_for_size (32, 1),\n-\t\t\t\t record_type, size_int (0), field_list);\n-      field_list\n-\t= make_descriptor_field (\"ARSIZE\", gnat_type_for_size (64, 1),\n-\t\t\t\t record_type, size_in_bytes (type),\n-\t\t\t\t field_list);\n-\n-      /* Now build a pointer to the 0,0,0... element.  */\n-      tem = build0 (PLACEHOLDER_EXPR, type);\n-      for (i = 0, inner_type = type; i < ndim;\n-\t   i++, inner_type = TREE_TYPE (inner_type))\n-\ttem = build4 (ARRAY_REF, TREE_TYPE (inner_type), tem,\n-\t\t      convert (TYPE_DOMAIN (inner_type), size_zero_node),\n-\t\t      NULL_TREE, NULL_TREE);\n-\n-      field_list\n-\t= make_descriptor_field (\"A0\", pointer64_type, record_type,\n-\t\t\t\t build1 (ADDR_EXPR, pointer64_type, tem),\n-\t\t\t\t field_list);\n-\n-      /* Next come the addressing coefficients.  */\n-      tem = size_one_node;\n-      for (i = 0; i < ndim; i++)\n-\t{\n-\t  char fname[3];\n-\t  tree idx_length\n-\t    = size_binop (MULT_EXPR, tem,\n-\t\t\t  size_binop (PLUS_EXPR,\n-\t\t\t\t      size_binop (MINUS_EXPR,\n-\t\t\t\t\t\t  TYPE_MAX_VALUE (idx_arr[i]),\n-\t\t\t\t\t\t  TYPE_MIN_VALUE (idx_arr[i])),\n-\t\t\t\t      size_int (1)));\n-\n-\t  fname[0] = (mech == By_Descriptor_NCA ? 'S' : 'M');\n-\t  fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record_type, idx_length, field_list);\n-\n-\t  if (mech == By_Descriptor_NCA)\n-\t    tem = idx_length;\n-\t}\n-\n-      /* Finally here are the bounds.  */\n-      for (i = 0; i < ndim; i++)\n-\t{\n-\t  char fname[3];\n-\n-\t  fname[0] = 'L', fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record_type,\n-\t\t\t\t     TYPE_MIN_VALUE (idx_arr[i]), field_list);\n-\n-\t  fname[0] = 'U';\n-\t  field_list\n-\t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record_type,\n-\t\t\t\t     TYPE_MAX_VALUE (idx_arr[i]), field_list);\n-\t}\n-      break;\n-\n-    default:\n-      post_error (\"unsupported descriptor type for &\", gnat_entity);\n-    }\n-\n-  TYPE_NAME (record_type) = create_concat_name (gnat_entity, \"DESC64\");\n-  finish_record_type (record_type, nreverse (field_list), 0, false);\n-  return record_type;\n-}\n-\n-/* Fill in a VMS descriptor of GNU_TYPE for GNU_EXPR and return the result.\n-   GNAT_ACTUAL is the actual parameter for which the descriptor is built.  */\n-\n-tree\n-fill_vms_descriptor (tree gnu_type, tree gnu_expr, Node_Id gnat_actual)\n-{\n-  vec<constructor_elt, va_gc> *v = NULL;\n-  tree field;\n-\n-  gnu_expr = maybe_unconstrained_array (gnu_expr);\n-  gnu_expr = gnat_protect_expr (gnu_expr);\n-  gnat_mark_addressable (gnu_expr);\n-\n-  /* We may need to substitute both GNU_EXPR and a CALL_EXPR to the raise CE\n-     routine in case we have a 32-bit descriptor.  */\n-  gnu_expr = build2 (COMPOUND_EXPR, void_type_node,\n-\t\t     build_call_raise (CE_Range_Check_Failed, gnat_actual,\n-\t\t\t\t       N_Raise_Constraint_Error),\n-\t\t     gnu_expr);\n-\n-  for (field = TYPE_FIELDS (gnu_type); field; field = DECL_CHAIN (field))\n-    {\n-      tree value\n-\t= convert (TREE_TYPE (field),\n-\t\t   SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_INITIAL (field),\n-\t\t\t\t\t\t   gnu_expr));\n-      CONSTRUCTOR_APPEND_ELT (v, field, value);\n-    }\n-\n-  return gnat_build_constructor (gnu_type, v);\n-}\n-\n-/* Convert GNU_EXPR, a pointer to a 64bit VMS descriptor, to GNU_TYPE, a\n-   regular pointer or fat pointer type.  GNAT_SUBPROG is the subprogram to\n-   which the VMS descriptor is passed.  */\n-\n-static tree\n-convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n-{\n-  tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n-  tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n-  /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree klass = DECL_CHAIN (DECL_CHAIN (TYPE_FIELDS (desc_type)));\n-  /* The POINTER field is the 6th field in the descriptor.  */\n-  tree pointer = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (klass)));\n-\n-  /* Retrieve the value of the POINTER field.  */\n-  tree gnu_expr64\n-    = build3 (COMPONENT_REF, TREE_TYPE (pointer), desc, pointer, NULL_TREE);\n-\n-  if (POINTER_TYPE_P (gnu_type))\n-    return convert (gnu_type, gnu_expr64);\n-\n-  else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n-    {\n-      tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n-      tree p_bounds_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n-      tree template_type = TREE_TYPE (p_bounds_type);\n-      tree min_field = TYPE_FIELDS (template_type);\n-      tree max_field = DECL_CHAIN (TYPE_FIELDS (template_type));\n-      tree template_tree, template_addr, aflags, dimct, t, u;\n-      /* See the head comment of build_vms_descriptor.  */\n-      int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n-      tree lfield, ufield;\n-      vec<constructor_elt, va_gc> *v;\n-\n-      /* Convert POINTER to the pointer-to-array type.  */\n-      gnu_expr64 = convert (p_array_type, gnu_expr64);\n-\n-      switch (iklass)\n-\t{\n-\tcase 1:  /* Class S  */\n-\tcase 15: /* Class SB */\n-\t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n-\t  vec_alloc (v, 2);\n-\t  t = DECL_CHAIN (DECL_CHAIN (klass));\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n-\t\t\t\t  convert (TREE_TYPE (min_field),\n-\t\t\t\t\t   integer_one_node));\n-\t  CONSTRUCTOR_APPEND_ELT (v, max_field,\n-\t\t\t\t  convert (TREE_TYPE (max_field), t));\n-\t  template_tree = gnat_build_constructor (template_type, v);\n-\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n-\n-\t  /* For class S, we are done.  */\n-\t  if (iklass == 1)\n-\t    break;\n-\n-\t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n-\t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n-\t  u = build_binary_op (EQ_EXPR, boolean_type_node, t, u);\n-\t  /* If so, there is already a template in the descriptor and\n-\t     it is located right after the POINTER field.  The fields are\n-             64bits so they must be repacked. */\n-\t  t = DECL_CHAIN (pointer);\n-          lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-          lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n-\n-\t  t = DECL_CHAIN (t);\n-          ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-          ufield = convert\n-           (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n-\n-\t  /* Build the template in the form of a constructor. */\n-\t  vec_alloc (v, 2);\n-\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n-\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n-\t\t\t\t  ufield);\n-\t  template_tree = gnat_build_constructor (template_type, v);\n-\n-\t  /* Otherwise use the {1, LENGTH} template we build above.  */\n-\t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n-\t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n-\t\t\t\t \t\t template_tree),\n-\t\t\t\t  template_addr);\n-\t  break;\n-\n-\tcase 4:  /* Class A */\n-\t  /* The AFLAGS field is the 3rd field after the pointer in the\n-             descriptor.  */\n-\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (pointer)));\n-\t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  /* The DIMCT field is the next field in the descriptor after\n-             aflags.  */\n-\t  t = DECL_CHAIN (t);\n-\t  dimct = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n-\t     or FL_COEFF or FL_BOUNDS not set.  */\n-\t  u = build_int_cst (TREE_TYPE (aflags), 192);\n-\t  u = build_binary_op (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t\tdimct,\n-\t\t\t\t\t\tconvert (TREE_TYPE (dimct),\n-\t\t\t\t\t\t\t size_one_node)),\n-\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t\tbuild2 (BIT_AND_EXPR,\n-\t\t\t\t\t\t\tTREE_TYPE (aflags),\n-\t\t\t\t\t\t\taflags, u),\n-\t\t\t\t\t\tu));\n-\t  /* There is already a template in the descriptor and it is located\n-             in block 3.  The fields are 64bits so they must be repacked. */\n-\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN\n-              (t)))));\n-          lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-          lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n-\n-\t  t = DECL_CHAIN (t);\n-          ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-          ufield = convert\n-           (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n-\n-\t  /* Build the template in the form of a constructor. */\n-\t  vec_alloc (v, 2);\n-\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n-\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n-\t\t\t\t  ufield);\n-\t  template_tree = gnat_build_constructor (template_type, v);\n-\t  template_tree = build3 (COND_EXPR, template_type, u,\n-\t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n-\t\t\t\t\t      N_Raise_Constraint_Error),\n-\t\t\t    template_tree);\n-\t  template_addr\n-\t    = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n-\t  break;\n-\n-\tcase 10: /* Class NCA */\n-\tdefault:\n-\t  post_error (\"unsupported descriptor type for &\", gnat_subprog);\n-\t  template_addr = integer_zero_node;\n-\t  break;\n-\t}\n-\n-      /* Build the fat pointer in the form of a constructor.  */\n-      vec_alloc (v, 2);\n-      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr64);\n-      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n-\t\t\t      template_addr);\n-      return gnat_build_constructor (gnu_type, v);\n-    }\n-\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Convert GNU_EXPR, a pointer to a 32bit VMS descriptor, to GNU_TYPE, a\n-   regular pointer or fat pointer type.  GNAT_SUBPROG is the subprogram to\n-   which the VMS descriptor is passed.  */\n-\n-static tree\n-convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n-{\n-  tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n-  tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n-  /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree klass = DECL_CHAIN (DECL_CHAIN (TYPE_FIELDS (desc_type)));\n-  /* The POINTER field is the 4th field in the descriptor.  */\n-  tree pointer = DECL_CHAIN (klass);\n-\n-  /* Retrieve the value of the POINTER field.  */\n-  tree gnu_expr32\n-    = build3 (COMPONENT_REF, TREE_TYPE (pointer), desc, pointer, NULL_TREE);\n-\n-  if (POINTER_TYPE_P (gnu_type))\n-    return convert (gnu_type, gnu_expr32);\n-\n-  else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n-    {\n-      tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n-      tree p_bounds_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n-      tree template_type = TREE_TYPE (p_bounds_type);\n-      tree min_field = TYPE_FIELDS (template_type);\n-      tree max_field = DECL_CHAIN (TYPE_FIELDS (template_type));\n-      tree template_tree, template_addr, aflags, dimct, t, u;\n-      /* See the head comment of build_vms_descriptor.  */\n-      int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n-      vec<constructor_elt, va_gc> *v;\n-\n-      /* Convert POINTER to the pointer-to-array type.  */\n-      gnu_expr32 = convert (p_array_type, gnu_expr32);\n-\n-      switch (iklass)\n-\t{\n-\tcase 1:  /* Class S  */\n-\tcase 15: /* Class SB */\n-\t  /* Build {1, LENGTH} template; LENGTH is the 1st field.  */\n-\t  vec_alloc (v, 2);\n-\t  t = TYPE_FIELDS (desc_type);\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n-\t\t\t\t  convert (TREE_TYPE (min_field),\n-\t\t\t\t\t   integer_one_node));\n-\t  CONSTRUCTOR_APPEND_ELT (v, max_field,\n-\t\t\t\t  convert (TREE_TYPE (max_field), t));\n-\t  template_tree = gnat_build_constructor (template_type, v);\n-\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n-\n-\t  /* For class S, we are done.  */\n-\t  if (iklass == 1)\n-\t    break;\n-\n-\t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n-\t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n-\t  u = build_binary_op (EQ_EXPR, boolean_type_node, t, u);\n-\t  /* If so, there is already a template in the descriptor and\n-\t     it is located right after the POINTER field.  */\n-\t  t = DECL_CHAIN (pointer);\n-\t  template_tree\n-\t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  /* Otherwise use the {1, LENGTH} template we build above.  */\n-\t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n-\t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n-\t\t\t\t \t\t template_tree),\n-\t\t\t\t  template_addr);\n-\t  break;\n-\n-\tcase 4:  /* Class A */\n-\t  /* The AFLAGS field is the 7th field in the descriptor.  */\n-\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (pointer)));\n-\t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  /* The DIMCT field is the 8th field in the descriptor.  */\n-\t  t = DECL_CHAIN (t);\n-\t  dimct = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n-\t     or FL_COEFF or FL_BOUNDS not set.  */\n-\t  u = build_int_cst (TREE_TYPE (aflags), 192);\n-\t  u = build_binary_op (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t\tdimct,\n-\t\t\t\t\t\tconvert (TREE_TYPE (dimct),\n-\t\t\t\t\t\t\t size_one_node)),\n-\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t\tbuild2 (BIT_AND_EXPR,\n-\t\t\t\t\t\t\tTREE_TYPE (aflags),\n-\t\t\t\t\t\t\taflags, u),\n-\t\t\t\t\t\tu));\n-\t  /* There is already a template in the descriptor and it is\n-\t     located at the start of block 3 (12th field).  */\n-\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (t))));\n-\t  template_tree\n-\t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  template_tree = build3 (COND_EXPR, TREE_TYPE (t), u,\n-\t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n-\t\t\t\t\t      N_Raise_Constraint_Error),\n-\t\t\t    template_tree);\n-\t  template_addr\n-\t    = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n-\t  break;\n-\n-\tcase 10: /* Class NCA */\n-\tdefault:\n-\t  post_error (\"unsupported descriptor type for &\", gnat_subprog);\n-\t  template_addr = integer_zero_node;\n-\t  break;\n-\t}\n-\n-      /* Build the fat pointer in the form of a constructor.  */\n-      vec_alloc (v, 2);\n-      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr32);\n-      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n-\t\t\t      template_addr);\n-\n-      return gnat_build_constructor (gnu_type, v);\n-    }\n-\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Convert GNU_EXPR, a pointer to a VMS descriptor, to GNU_TYPE, a regular\n-   pointer or fat pointer type.  GNU_EXPR_ALT_TYPE is the alternate (32-bit)\n-   pointer type of GNU_EXPR.  GNAT_SUBPROG is the subprogram to which the\n-   descriptor is passed.  */\n-\n-tree\n-convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n-\t\t\tEntity_Id gnat_subprog)\n-{\n-  tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n-  tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n-  tree mbo = TYPE_FIELDS (desc_type);\n-  const char *mbostr = IDENTIFIER_POINTER (DECL_NAME (mbo));\n-  tree mbmo = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (mbo)));\n-  tree is64bit, gnu_expr32, gnu_expr64;\n-\n-  /* If the field name is not MBO, it must be 32-bit and no alternate.\n-     Otherwise primary must be 64-bit and alternate 32-bit.  */\n-  if (strcmp (mbostr, \"MBO\") != 0)\n-    {\n-      tree ret = convert_vms_descriptor32 (gnu_type, gnu_expr, gnat_subprog);\n-      return ret;\n-    }\n-\n-  /* Build the test for 64-bit descriptor.  */\n-  mbo = build3 (COMPONENT_REF, TREE_TYPE (mbo), desc, mbo, NULL_TREE);\n-  mbmo = build3 (COMPONENT_REF, TREE_TYPE (mbmo), desc, mbmo, NULL_TREE);\n-  is64bit\n-    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t       build_binary_op (EQ_EXPR, boolean_type_node,\n-\t\t\t\t\tconvert (integer_type_node, mbo),\n-\t\t\t\t\tinteger_one_node),\n-\t\t       build_binary_op (EQ_EXPR, boolean_type_node,\n-\t\t\t\t\tconvert (integer_type_node, mbmo),\n-\t\t\t\t\tinteger_minus_one_node));\n-\n-  /* Build the 2 possible end results.  */\n-  gnu_expr64 = convert_vms_descriptor64 (gnu_type, gnu_expr, gnat_subprog);\n-  gnu_expr = fold_convert (gnu_expr_alt_type, gnu_expr);\n-  gnu_expr32 = convert_vms_descriptor32 (gnu_type, gnu_expr, gnat_subprog);\n-  return build3 (COND_EXPR, gnu_type, is64bit, gnu_expr64, gnu_expr32);\n-}\n-\f\n /* Build a type to be used to represent an aliased object whose nominal type\n    is an unconstrained array.  This consists of a RECORD_TYPE containing a\n    field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an ARRAY_TYPE.\n@@ -4704,9 +3747,9 @@ convert (tree type, tree expr)\n   /* If the input is a biased type, adjust first.  */\n   if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n     return convert (type, fold_build2 (PLUS_EXPR, TREE_TYPE (etype),\n+\t\t\t\t       fold_convert (TREE_TYPE (etype), expr),\n \t\t\t\t       fold_convert (TREE_TYPE (etype),\n-\t\t\t\t\t\t     expr),\n-\t\t\t\t       TYPE_MIN_VALUE (etype)));\n+\t\t\t\t\t\t     TYPE_MIN_VALUE (etype))));\n \n   /* If the input is a justified modular type, we need to extract the actual\n      object before converting it to any other type with the exceptions of an\n@@ -5012,7 +4055,8 @@ convert (tree type, tree expr)\n \treturn fold_convert (type,\n \t\t\t     fold_build2 (MINUS_EXPR, TREE_TYPE (type),\n \t\t\t\t\t  convert (TREE_TYPE (type), expr),\n-\t\t\t\t\t  TYPE_MIN_VALUE (type)));\n+\t\t\t\t\t  convert (TREE_TYPE (type),\n+\t\t\t\t\t\t   TYPE_MIN_VALUE (type))));\n \n       /* ... fall through ... */\n \n@@ -5426,12 +4470,10 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \n   /* If both types types are integral just do a normal conversion.\n      Likewise for a conversion to an unconstrained array.  */\n-  if ((((INTEGRAL_TYPE_P (type)\n-\t && !(code == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (type)))\n+  if (((INTEGRAL_TYPE_P (type)\n \t|| (POINTER_TYPE_P (type) && !TYPE_IS_THIN_POINTER_P (type))\n \t|| (code == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (type)))\n-       && ((INTEGRAL_TYPE_P (etype)\n-\t    && !(ecode == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (etype)))\n+       && (INTEGRAL_TYPE_P (etype)\n \t   || (POINTER_TYPE_P (etype) && !TYPE_IS_THIN_POINTER_P (etype))\n \t   || (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype))))\n       || code == UNCONSTRAINED_ARRAY_TYPE)"}, {"sha": "3e4a0943891094f65f74a4e5bcd6c62b0d873eeb", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb5852081801218c02c934db5aa9852fc284645/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=1eb5852081801218c02c934db5aa9852fc284645", "patch": "@@ -300,10 +300,14 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \t last < first holds.  */\n       if (integer_zerop (length2))\n \t{\n+\t  tree b = get_base_type (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\n \t  length_zero_p = true;\n \n-\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  ub1\n+\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n+\t  lb1\n+\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n \n \t  comparison = fold_build2_loc (loc, LT_EXPR, result_type, ub1, lb1);\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n@@ -319,20 +323,23 @@ compare_arrays (location_t loc, tree result_type, tree a1, tree a2)\n \t just use its length computed from the actual stored bounds.  */\n       else if (TREE_CODE (length2) == INTEGER_CST)\n \t{\n-\t  tree bt;\n+\t  tree b = get_base_type (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \n-\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  ub1\n+\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n+\t  lb1\n+\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1))));\n \t  /* Note that we know that UB2 and LB2 are constant and hence\n \t     cannot contain a PLACEHOLDER_EXPR.  */\n-\t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n-\t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n-\t  bt = get_base_type (TREE_TYPE (ub1));\n+\t  ub2\n+\t    = convert (b, TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2))));\n+\t  lb2\n+\t    = convert (b, TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2))));\n \n \t  comparison\n \t    = fold_build2_loc (loc, EQ_EXPR, result_type,\n-\t\t\t       build_binary_op (MINUS_EXPR, bt, ub1, lb1),\n-\t\t\t       build_binary_op (MINUS_EXPR, bt, ub2, lb2));\n+\t\t\t       build_binary_op (MINUS_EXPR, b, ub1, lb1),\n+\t\t\t       build_binary_op (MINUS_EXPR, b, ub2, lb2));\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, loc);\n@@ -2152,18 +2159,7 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n   tree size_to_malloc\n     = aligning_type ? TYPE_SIZE_UNIT (aligning_type) : data_size;\n \n-  tree malloc_ptr;\n-\n-  /* On VMS, if pointers are 64-bit and the allocator size is 32-bit or\n-     Convention C, allocate 32-bit memory.  */\n-  if (TARGET_ABI_OPEN_VMS\n-      && POINTER_SIZE == 64\n-      && Nkind (gnat_node) == N_Allocator\n-      && (UI_To_Int (Esize (Etype (gnat_node))) == 32\n-          || Convention (Etype (gnat_node)) == Convention_C))\n-    malloc_ptr = build_call_n_expr (malloc32_decl, 1, size_to_malloc);\n-  else\n-    malloc_ptr = build_call_n_expr (malloc_decl, 1, size_to_malloc);\n+  tree malloc_ptr = build_call_n_expr (malloc_decl, 1, size_to_malloc);\n \n   if (aligning_type)\n     {"}]}