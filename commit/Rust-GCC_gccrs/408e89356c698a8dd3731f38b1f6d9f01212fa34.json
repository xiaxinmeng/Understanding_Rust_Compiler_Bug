{"sha": "408e89356c698a8dd3731f38b1f6d9f01212fa34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA4ZTg5MzU2YzY5OGE4ZGQzNzMxZjM4YjFmNmQ5ZjAxMjEyZmEzNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-02-28T05:25:34Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-02-28T05:25:34Z"}, "message": "[PR81611] turn inc-and-use-of-dead-orig into auto-inc\n\nWhen the addressing modes available on the machine don't allow offsets\nin addresses, odds are that post-increments will be represented in\ntrees and RTL as:\n\n  y <= x + 1\n  ... *(x) ...\n  x <= y\n\nso deal with it by turning such RTL as:\n\n  (set y (plus x n))\n  ... (mem x) ...\n\nwithout intervening uses of y into\n\n  (set y x)\n  ... (mem (post_add y n)) ...\n\nso as to create auto-inc addresses that we'd otherwise miss.\n\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/81611\n\t* auto-inc-dec.c (attempt_change): Move dead note from\n\tmem_insn if it's the next use of regno\n\t(find_address): Take address use of reg holding\n\tnon-incremented value.  Add parm to limit search to the named\n\treg only.\n\t(merge_in_block): Attempt to use a mem insn that is the next\n\tuse of the original regno.\n\nFrom-SVN: r258053", "tree": {"sha": "40df4cf8fec16353d624d51f5666f0b4d39adef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40df4cf8fec16353d624d51f5666f0b4d39adef8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/408e89356c698a8dd3731f38b1f6d9f01212fa34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408e89356c698a8dd3731f38b1f6d9f01212fa34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408e89356c698a8dd3731f38b1f6d9f01212fa34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408e89356c698a8dd3731f38b1f6d9f01212fa34/comments", "author": null, "committer": null, "parents": [{"sha": "8cda97ab52eae061d34167a1f786b43a21e7521b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cda97ab52eae061d34167a1f786b43a21e7521b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cda97ab52eae061d34167a1f786b43a21e7521b"}], "stats": {"total": 151, "additions": 141, "deletions": 10}, "files": [{"sha": "8eedfcaaf82781b8f6acccbe8f0ba056da02cf47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408e89356c698a8dd3731f38b1f6d9f01212fa34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408e89356c698a8dd3731f38b1f6d9f01212fa34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=408e89356c698a8dd3731f38b1f6d9f01212fa34", "patch": "@@ -1,3 +1,14 @@\n+2018-02-28  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/81611\n+\t* auto-inc-dec.c (attempt_change): Move dead note from\n+\tmem_insn if it's the next use of regno\n+\t(find_address): Take address use of reg holding\n+\tnon-incremented value.  Add parm to limit search to the named\n+\treg only.\n+\t(merge_in_block): Attempt to use a mem insn that is the next\n+\tuse of the original regno.\n+\n 2018-02-27  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/83871"}, {"sha": "e6dc1c30d716fcfe44b7a09eeb0dfe5fa1c86c3b", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 130, "deletions": 10, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408e89356c698a8dd3731f38b1f6d9f01212fa34/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408e89356c698a8dd3731f38b1f6d9f01212fa34/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=408e89356c698a8dd3731f38b1f6d9f01212fa34", "patch": "@@ -508,7 +508,11 @@ attempt_change (rtx new_addr, rtx inc_reg)\n \t before the memory reference.  */\n       gcc_assert (mov_insn);\n       emit_insn_before (mov_insn, inc_insn.insn);\n-      move_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n+      regno = REGNO (inc_insn.reg0);\n+      if (reg_next_use[regno] == mem_insn.insn)\n+\tmove_dead_notes (mov_insn, mem_insn.insn, inc_insn.reg0);\n+      else\n+\tmove_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n \n       regno = REGNO (inc_insn.reg_res);\n       reg_next_def[regno] = mov_insn;\n@@ -825,13 +829,15 @@ parse_add_or_inc (rtx_insn *insn, bool before_mem)\n \n /* A recursive function that checks all of the mem uses in\n    ADDRESS_OF_X to see if any single one of them is compatible with\n-   what has been found in inc_insn.\n+   what has been found in inc_insn.  To avoid accidental matches, we\n+   will only find MEMs with FINDREG, be it inc_insn.reg_res, be it\n+   inc_insn.reg0.\n \n    -1 is returned for success.  0 is returned if nothing was found and\n    1 is returned for failure. */\n \n static int\n-find_address (rtx *address_of_x)\n+find_address (rtx *address_of_x, rtx findreg)\n {\n   rtx x = *address_of_x;\n   enum rtx_code code = GET_CODE (x);\n@@ -840,17 +846,32 @@ find_address (rtx *address_of_x)\n   int value = 0;\n   int tem;\n \n-  if (code == MEM && rtx_equal_p (XEXP (x, 0), inc_insn.reg_res))\n+  if (code == MEM && findreg == inc_insn.reg_res\n+      && rtx_equal_p (XEXP (x, 0), inc_insn.reg_res))\n     {\n-      /* Match with *reg0.  */\n+      /* Match with *reg_res.  */\n       mem_insn.mem_loc = address_of_x;\n       mem_insn.reg0 = inc_insn.reg_res;\n       mem_insn.reg1_is_const = true;\n       mem_insn.reg1_val = 0;\n       mem_insn.reg1 = GEN_INT (0);\n       return -1;\n     }\n-  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n+  if (code == MEM && inc_insn.reg1_is_const && inc_insn.reg0\n+      && findreg == inc_insn.reg0\n+      && rtx_equal_p (XEXP (x, 0), inc_insn.reg0))\n+    {\n+      /* Match with *reg0, assumed to be equivalent to\n+         *(reg_res - reg1_val); callers must check whether this is the case.  */\n+      mem_insn.mem_loc = address_of_x;\n+      mem_insn.reg0 = inc_insn.reg_res;\n+      mem_insn.reg1_is_const = true;\n+      mem_insn.reg1_val = -inc_insn.reg1_val;\n+      mem_insn.reg1 = GEN_INT (mem_insn.reg1_val);\n+      return -1;\n+    }\n+  if (code == MEM && findreg == inc_insn.reg_res\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n       && rtx_equal_p (XEXP (XEXP (x, 0), 0), inc_insn.reg_res))\n     {\n       rtx b = XEXP (XEXP (x, 0), 1);\n@@ -879,7 +900,7 @@ find_address (rtx *address_of_x)\n     {\n       /* If REG occurs inside a MEM used in a bit-field reference,\n \t that is unacceptable.  */\n-      if (find_address (&XEXP (x, 0)))\n+      if (find_address (&XEXP (x, 0), findreg))\n \treturn 1;\n     }\n \n@@ -891,7 +912,7 @@ find_address (rtx *address_of_x)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  tem = find_address (&XEXP (x, i));\n+\t  tem = find_address (&XEXP (x, i), findreg);\n \t  /* If this is the first use, let it go so the rest of the\n \t     insn can be checked.  */\n \t  if (value == 0)\n@@ -905,7 +926,7 @@ find_address (rtx *address_of_x)\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      tem = find_address (&XVECEXP (x, i, j));\n+\t      tem = find_address (&XVECEXP (x, i, j), findreg);\n \t      /* If this is the first use, let it go so the rest of\n \t\t the insn can be checked.  */\n \t      if (value == 0)\n@@ -1360,7 +1381,106 @@ merge_in_block (int max_reg, basic_block bb)\n \t\t  if (dump_file)\n \t\t    dump_inc_insn (dump_file);\n \n-\t\t  if (ok && find_address (&PATTERN (mem_insn.insn)) == -1)\n+\t\t  if (ok && find_address (&PATTERN (mem_insn.insn),\n+\t\t\t\t\t  inc_insn.reg_res) == -1)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tdump_mem_insn (dump_file);\n+\t\t      if (try_merge ())\n+\t\t\t{\n+\t\t\t  success_in_block++;\n+\t\t\t  insn_is_add_or_inc = false;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      if (insn_is_add_or_inc\n+\t\t  /* find_address will only recognize an address\n+\t\t     with a reg0 that's not reg_res when\n+\t\t     reg1_is_const, so cut it off early if we\n+\t\t     already know it won't match.  */\n+\t\t  && inc_insn.reg1_is_const\n+\t\t  && inc_insn.reg0\n+\t\t  && inc_insn.reg0 != inc_insn.reg_res)\n+\t\t{\n+\t\t  /* If we identified an inc_insn that uses two\n+\t\t     different pseudos, it's of the form\n+\n+\t\t     (set reg_res (plus reg0 reg1))\n+\n+\t\t     where reg1 is a constant (*).\n+\n+\t\t     The next use of reg_res was not idenfied by\n+\t\t     find_address as a mem_insn that we could turn\n+\t\t     into auto-inc, so see if we find a suitable\n+\t\t     MEM in the next use of reg0, as long as it's\n+\t\t     before any subsequent use of reg_res:\n+\n+\t\t     ... (mem (... reg0 ...)) ...\n+\n+\t\t     ... reg_res ...\n+\n+\t\t     In this case, we can turn the plus into a\n+\t\t     copy, and the reg0 in the MEM address into a\n+\t\t     post_inc of reg_res:\n+\n+\t\t     (set reg_res reg0)\n+\n+\t\t     ... (mem (... (post_add reg_res reg1) ...)) ...\n+\n+\t\t     reg_res will then have the correct value at\n+\t\t     subsequent uses, and reg0 will remain\n+\t\t     unchanged.\n+\n+\t\t     (*) We could support non-const reg1, but then\n+\t\t     we'd have to check that reg1 remains\n+\t\t     unchanged all the way to the modified MEM,\n+\t\t     and we'd have to extend find_address to\n+\t\t     represent a non-const negated reg1.  */\n+\t\t  regno = REGNO (inc_insn.reg0);\n+\t\t  rtx_insn *reg0_use = get_next_ref (regno, bb,\n+\t\t\t\t\t\t     reg_next_use);\n+\n+\t\t  /* Give up if the next use of reg0 is after the next\n+\t\t     use of reg_res (same insn is ok; we might have\n+\t\t     found a MEM with reg_res before, and that failed,\n+\t\t     but now we try reg0, which might work), or defs\n+\t\t     of reg_res (same insn is not ok, we'd introduce\n+\t\t     another def in the same insn) or reg0.  */\n+\t\t  if (reg0_use)\n+\t\t    {\n+\t\t      int luid = DF_INSN_LUID (reg0_use);\n+\n+\t\t      /* It might seem pointless to introduce an\n+\t\t\t auto-inc if there's no subsequent use of\n+\t\t\t reg_res (i.e., mem_insn.insn == NULL), but\n+\t\t\t the next use might be in the next iteration\n+\t\t\t of a loop, and it won't hurt if we make the\n+\t\t\t change even if it's not needed.  */\n+\t\t      if (mem_insn.insn\n+\t\t\t  && luid > DF_INSN_LUID (mem_insn.insn))\n+\t\t\treg0_use = NULL;\n+\n+\t\t      rtx_insn *other_insn\n+\t\t\t= get_next_ref (REGNO (inc_insn.reg_res), bb,\n+\t\t\t\t\treg_next_def);\n+\n+\t\t      if (other_insn && luid >= DF_INSN_LUID (other_insn))\n+\t\t\treg0_use = NULL;\n+\n+\t\t      other_insn\n+\t\t\t= get_next_ref (REGNO (inc_insn.reg0), bb,\n+\t\t\t\t\treg_next_def);\n+\n+\t\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n+\t\t\treg0_use = NULL;\n+\t\t    }\n+\n+\t\t  mem_insn.insn = reg0_use;\n+\n+\t\t  if (mem_insn.insn\n+\t\t      && find_address (&PATTERN (mem_insn.insn),\n+\t\t\t\t       inc_insn.reg0) == -1)\n \t\t    {\n \t\t      if (dump_file)\n \t\t\tdump_mem_insn (dump_file);"}]}