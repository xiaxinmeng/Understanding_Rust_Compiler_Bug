{"sha": "8175e9866c9bdd4300ad11d0196c69a65036a9f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3NWU5ODY2YzliZGQ0MzAwYWQxMWQwMTk2YzY5YTY1MDM2YTlmMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-01-16T09:20:34Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-01-16T09:20:34Z"}, "message": "re PR libstdc++/55043 (issue with nesting unordered_map containing unique_ptr into vector)\n\n\tPR libstdc++/55043\n\t* include/std/unordered_map: Include alloc_traits.h\n\t* include/std/unordered_set: Likewise.\n\t* include/bits/alloc_traits.h: Define __is_copy_insertable.\n\t* include/bits/unordered_map.h: Use it.\n\t* include/bits/unordered_set.h: Likewise.\n\t* include/debug/unordered_map.h: Likewise.\n\t* include/debug/unordered_set.h: Likewise.\n\t* include/profile/unordered_map.h: Likewise.\n\t* include/profile/unordered_set.h: Likewise.\n\t* include/bits/hashtable.h: Fix comment typos.\n\t* testsuite/23_containers/unordered_map/55043.cc: New.\n\t* testsuite/23_containers/unordered_multimap/55043.cc: New.\n\t* testsuite/23_containers/unordered_multiset/55043.cc: New.\n\t* testsuite/23_containers/unordered_set/55043.cc: New.\n\nFrom-SVN: r195231", "tree": {"sha": "09d17ad81858e565dc037a69cf4b591e41101256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09d17ad81858e565dc037a69cf4b591e41101256"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8175e9866c9bdd4300ad11d0196c69a65036a9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8175e9866c9bdd4300ad11d0196c69a65036a9f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8175e9866c9bdd4300ad11d0196c69a65036a9f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8175e9866c9bdd4300ad11d0196c69a65036a9f1/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b0a1e0b4371c8c2597a5f310f2a1843832d38da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0a1e0b4371c8c2597a5f310f2a1843832d38da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0a1e0b4371c8c2597a5f310f2a1843832d38da"}], "stats": {"total": 495, "additions": 483, "deletions": 12}, "files": [{"sha": "ac5c10affc868a6838d30aa0f825c028f30e072e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,3 +1,21 @@\n+2013-01-16  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/55043\n+\t* include/std/unordered_map: Include alloc_traits.h\n+\t* include/std/unordered_set: Likewise.\n+\t* include/bits/alloc_traits.h: Define __is_copy_insertable.\n+\t* include/bits/unordered_map.h: Use it.\n+\t* include/bits/unordered_set.h: Likewise.\n+\t* include/debug/unordered_map.h: Likewise.\n+\t* include/debug/unordered_set.h: Likewise.\n+\t* include/profile/unordered_map.h: Likewise.\n+\t* include/profile/unordered_set.h: Likewise.\n+\t* include/bits/hashtable.h: Fix comment typos.\n+\t* testsuite/23_containers/unordered_map/55043.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/55043.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/55043.cc: New.\n+\t* testsuite/23_containers/unordered_set/55043.cc: New.\n+\n 2013-01-03  Janis Johnson  <janisjo@codesourcery.com>\n \n \t* testsuite/lib/gdb-test.exp (gdb_batch_check): Catch error running"}, {"sha": "c6259a1d014c78e97fdc9ad82f5d1a1af8ca8adc", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // Allocator traits -*- C++ -*-\n \n-// Copyright (C) 2011-2012 Free Software Foundation, Inc.\n+// Copyright (C) 2011-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,6 +39,9 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  template<typename _Tp>\n+    class allocator;\n+\n   template<typename _Alloc, typename _Tp>\n     class __alloctr_rebind_helper\n     {\n@@ -506,6 +509,41 @@ _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n       __do_alloc_on_swap(__one, __two, __pocs());\n     }\n \n+  template<typename _Alloc>\n+    class __is_copy_insertable_impl\n+    {\n+      typedef allocator_traits<_Alloc> _Traits;\n+\n+      template<typename _Up, typename\n+\t       = decltype(_Traits::construct(std::declval<_Alloc&>(),\n+\t\t\t\t\t     std::declval<_Up*>(),\n+\t\t\t\t\t     std::declval<const _Up&>()))>\n+\tstatic true_type\n+\t_M_select(int);\n+\n+      template<typename _Up>\n+\tstatic false_type\n+\t_M_select(...);\n+\n+    public:\n+\ttypedef decltype(_M_select<typename _Alloc::value_type>(0)) type;\n+    };\n+\n+  template<typename _Alloc>\n+    struct __is_copy_insertable\n+    : __is_copy_insertable_impl<_Alloc>::type\n+    { };\n+\n+  // std::allocator<_Tp> just requires CopyConstructible\n+  template<typename _Tp>\n+    struct __is_copy_insertable<allocator<_Tp>>\n+    : is_copy_constructible<_Tp>\n+    { };\n+\n+  template<typename _Container>\n+    using __has_copy_insertable_val\n+      = __is_copy_insertable<typename _Container::allocator_type>;\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "49cb4db9723bac2d1df587bc6a525ac6450860f0", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -370,7 +370,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hashtable(_Hashtable&&);\n \n-      // Use delegating construtors.\n+      // Use delegating constructors.\n       explicit\n       _Hashtable(size_type __n = 10,\n \t\t const _H1& __hf = _H1(),\n@@ -914,7 +914,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      // Update, if necessary, bucket pointing to before begin that hasn't move.\n+      // Update, if necessary, bucket pointing to before begin that hasn't moved.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();\n       __ht._M_rehash_policy = _RehashPolicy();"}, {"sha": "0235a99e97054bdce86666d87434bd8094f90b58", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1408,6 +1408,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return !(__x == __y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<_GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t\t_Pred, _Alloc>>\n+    : __has_copy_insertable_val<_GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t\t      _Pred, _Alloc>>\n+    { };\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<_GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t\t     _Pred, _Alloc>>\n+    : __has_copy_insertable_val<_GLIBCXX_STD_C::unordered_multimap<_Key, _Tp,\n+\t\t\t\t\t\t\t\t   _Hash, _Pred,\n+\t\t\t\t\t\t\t\t   _Alloc>>\n+    { };\n+\n } // namespace std\n \n #endif /* _UNORDERED_MAP_H */"}, {"sha": "2ada63dcde681f037c8056243770ee90c063bb66", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // unordered_set implementation -*- C++ -*-\n \n-// Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -1291,6 +1291,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return !(__x == __y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n+    struct is_copy_constructible<_GLIBCXX_STD_C::unordered_set<_Key, _Hash,\n+\t\t\t\t\t\t\t       _Pred, _Alloc>>\n+    : __has_copy_insertable_val<_GLIBCXX_STD_C::unordered_set<_Key, _Hash,\n+\t\t\t\t\t\t\t      _Pred, _Alloc>>\n+    { };\n+\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n+    struct\n+    is_copy_constructible<_GLIBCXX_STD_C::unordered_multiset<_Key, _Hash,\n+\t\t\t\t\t\t\t     _Pred, _Alloc>>\n+    : __has_copy_insertable_val<_GLIBCXX_STD_C::unordered_multiset<_Key, _Hash,\n+\t\t\t\t\t\t\t\t   _Pred,\n+\t\t\t\t\t\t\t\t   _Alloc>>\n+    { };\n+\n } // namespace std\n \n #endif /* _UNORDERED_SET_H */"}, {"sha": "115abb58865b98a9daae46f1b5eafd93e7f6bf88", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,7 +1,6 @@\n // Debugging unordered_map/unordered_multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -939,6 +938,30 @@ namespace __debug\n     { return !(__x == __y); }\n \n } // namespace __debug\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<__debug::unordered_map<_Key, _Tp, _Hash, _Pred,\n+\t\t\t\t\t\t _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_C::unordered_map<_Key, _Tp,\n+\t\t\t\t\t\t\t   _Hash, _Pred,\n+\t\t\t\t\t\t\t   _Alloc> >\n+    { };\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<__debug::unordered_multimap<_Key, _Tp, _Hash, _Pred,\n+\t\t\t\t\t\t      _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp,\n+\t\t\t\t\t\t\t\t_Hash, _Pred,\n+\t\t\t\t\t\t\t\t_Alloc> >\n+    { };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #endif // C++11"}, {"sha": "895c9439f6e0330162a43b196a2f76ac94e2e051", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,7 +1,6 @@\n // Debugging unordered_set/unordered_multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -921,6 +920,27 @@ namespace __debug\n     { return !(__x == __y); }\n \n } // namespace __debug\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n+    struct\n+    is_copy_constructible<__debug::unordered_set<_Key, _Hash, _Pred, _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_C::unordered_set<_Key,\n+\t\t\t\t\t\t\t   _Hash, _Pred,\n+\t\t\t\t\t\t\t   _Alloc> >\n+    { };\n+\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n+    struct\n+    is_copy_constructible<__debug::unordered_multiset<_Key, _Hash, _Pred,\n+\t\t\t\t\t\t      _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_C::unordered_multiset<_Key,\n+\t\t\t\t\t\t\t\t_Hash, _Pred,\n+\t\t\t\t\t\t\t\t_Alloc> >\n+    { };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #endif // C++11"}, {"sha": "5ebcbf60fcb2c0d68222e78df4c3c8971a81c949", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // Profiling unordered_map/unordered_multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -339,11 +339,25 @@ namespace __profile\n \t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { return !(__x == __y); }\n \n+} // namespace __profile\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<__profile::unordered_map<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t   _Pred, _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_BASE >\n+    { };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n #undef _GLIBCXX_BASE\n #undef _GLIBCXX_STD_BASE\n #define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n #define _GLIBCXX_STD_BASE _GLIBCXX_STD_C::_GLIBCXX_BASE\n \n+namespace __profile\n+{\n   /// Class std::unordered_multimap wrapper with performance instrumentation.\n   template<typename _Key, typename _Tp,\n \t   typename _Hash  = std::hash<_Key>,\n@@ -609,6 +623,18 @@ namespace __profile\n     { return !(__x == __y); }\n \n } // namespace __profile\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred,\n+\t   typename _Alloc>\n+    struct\n+    is_copy_constructible<__profile::unordered_multimap<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t\t_Pred, _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_BASE >\n+    { };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #undef _GLIBCXX_BASE"}, {"sha": "ebe1c7d6f124c84da1ccf9f643341e56fe862c31", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // Profiling unordered_set/unordered_multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -305,11 +305,23 @@ namespace __profile\n \t       const unordered_set<_Key, _Hash, _Pred, _Alloc>& __y)\n     { return !(__x == __y); }\n \n+} // namespace __profile\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n+    struct\n+    is_copy_constructible<__profile::unordered_set<_Key, _Hash, _Pred, _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_BASE >\n+    { };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n #undef _GLIBCXX_BASE\n #undef _GLIBCXX_STD_BASE\n #define _GLIBCXX_STD_BASE _GLIBCXX_STD_C::_GLIBCXX_BASE\n #define _GLIBCXX_BASE unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n \n+namespace __profile\n+{\n   /** @brief Unordered_multiset wrapper with performance instrumentation.  */\n   template<typename _Value,\n        typename _Hash  = std::hash<_Value>,\n@@ -568,6 +580,17 @@ namespace __profile\n     { return !(__x == __y); }\n \n } // namespace __profile\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    struct\n+    is_copy_constructible<__profile::unordered_multiset<_Value, _Hash,\n+\t\t\t\t\t\t\t_Pred, _Alloc>>\n+    : is_copy_constructible< _GLIBCXX_STD_BASE >\n+    { };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #undef _GLIBCXX_BASE"}, {"sha": "7c10173f9b1ae79b83eb9878fdb8a511b944f041", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // <unordered_map> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2007-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,6 +41,7 @@\n #include <tuple>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n+#include <bits/alloc_traits.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>"}, {"sha": "cfe91ad3d91126fb39b722da9ae5ff6987a4fd4d", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -1,6 +1,6 @@\n // <unordered_set> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2007-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,6 +41,7 @@\n #include <tuple>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n+#include <bits/alloc_traits.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st\n #include <bits/functional_hash.h>\n #include <bits/hashtable.h>"}, {"sha": "10d36a057982150a1a443a3b994639090e3b5be3", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/55043.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F55043.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F55043.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F55043.cc?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/55043\n+\n+#include <unordered_map>\n+#include <vector>\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) = default;\n+};\n+\n+using hash = std::hash<int>;\n+using equal = std::equal_to<int>;\n+\n+template<typename Alloc>\n+  using test_type = std::unordered_map<int, MoveOnly, hash, equal, Alloc>;\n+\n+void test01()\n+{\n+  typedef test_type<std::allocator<MoveOnly>> uim;\n+  std::vector<uim> v;\n+  v.emplace_back(uim());\n+}\n+\n+// Unordered containers don't use allocator_traits yet so need full\n+// Allocator interface, derive from std::allocator to get it.\n+template<typename T, bool R>\n+struct Alloc : std::allocator<T>\n+{\n+  template<typename U>\n+    struct rebind { typedef Alloc<U, R> other; };\n+\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U, R>&) { }\n+\n+  typedef typename std::conditional<R, T&&, const T&>::type arg_type;\n+\n+  void construct(T* p, arg_type) const\n+  { new((void*)p) T(); }\n+};\n+\n+// verify is_copy_constructible depends on allocator\n+typedef test_type<Alloc<MoveOnly, true>> uim_rval;\n+static_assert(std::is_copy_constructible<uim_rval>::value, \"is not copyable\");\n+\n+typedef test_type<Alloc<MoveOnly, false>> uim_lval;\n+static_assert(std::is_copy_constructible<uim_lval>::value, \"is copyable\");"}, {"sha": "9ae912ef64171cf34a57ac27f0505822c0e1175e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/55043.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F55043.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F55043.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F55043.cc?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/55043\n+\n+#include <unordered_map>\n+#include <vector>\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) = default;\n+};\n+\n+using hash = std::hash<int>;\n+using equal = std::equal_to<int>;\n+\n+template<typename Alloc>\n+  using test_type = std::unordered_multimap<int, MoveOnly, hash, equal, Alloc>;\n+\n+void test01()\n+{\n+  typedef test_type<std::allocator<MoveOnly>> uim;\n+  std::vector<uim> v;\n+  v.emplace_back(uim());\n+}\n+\n+// Unordered containers don't use allocator_traits yet so need full\n+// Allocator interface, derive from std::allocator to get it.\n+template<typename T, bool R>\n+struct Alloc : std::allocator<T>\n+{\n+  template<typename U>\n+    struct rebind { typedef Alloc<U, R> other; };\n+\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U, R>&) { }\n+\n+  typedef typename std::conditional<R, T&&, const T&>::type arg_type;\n+\n+  void construct(T* p, arg_type) const\n+  { new((void*)p) T(); }\n+};\n+\n+// verify is_copy_constructible depends on allocator\n+typedef test_type<Alloc<MoveOnly, true>> uim_rval;\n+static_assert(std::is_copy_constructible<uim_rval>::value, \"is not copyable\");\n+\n+typedef test_type<Alloc<MoveOnly, false>> uim_lval;\n+static_assert(std::is_copy_constructible<uim_lval>::value, \"is copyable\");"}, {"sha": "ebb8cb8ae1d575edcb0a7da886b02c0ebb07ccb8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/55043.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/55043\n+\n+#include <unordered_set>\n+#include <vector>\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) = default;\n+};\n+\n+struct equal {\n+  bool operator()(const MoveOnly&, const MoveOnly) const { return true; }\n+};\n+struct hash {\n+  size_t operator()(const MoveOnly&) const { return 0; }\n+};\n+\n+template<typename Alloc>\n+  using test_type = std::unordered_multiset<MoveOnly, hash, equal, Alloc>;\n+\n+void test01()\n+{\n+  typedef test_type<std::allocator<MoveOnly>> uim;\n+  std::vector<uim> v;\n+  v.emplace_back(uim());\n+}\n+\n+// Unordered containers don't use allocator_traits yet so need full\n+// Allocator interface, derive from std::allocator to get it.\n+template<typename T, bool R>\n+struct Alloc : std::allocator<T>\n+{\n+  template<typename U>\n+    struct rebind { typedef Alloc<U, R> other; };\n+\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U, R>&) { }\n+\n+  typedef typename std::conditional<R, T&&, const T&>::type arg_type;\n+\n+  void construct(T* p, arg_type) const\n+  { new((void*)p) T(); }\n+};\n+\n+// verify is_copy_constructible depends on allocator\n+typedef test_type<Alloc<MoveOnly, true>> uim_rval;\n+static_assert(std::is_copy_constructible<uim_rval>::value, \"is not copyable\");\n+\n+typedef test_type<Alloc<MoveOnly, false>> uim_lval;\n+static_assert(std::is_copy_constructible<uim_lval>::value, \"is copyable\");"}, {"sha": "3b0b973e80da151b150addb497d093cc1796ada1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/55043.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F55043.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8175e9866c9bdd4300ad11d0196c69a65036a9f1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F55043.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F55043.cc?ref=8175e9866c9bdd4300ad11d0196c69a65036a9f1", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/55043\n+\n+#include <unordered_set>\n+#include <vector>\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) = default;\n+};\n+\n+struct equal {\n+  bool operator()(const MoveOnly&, const MoveOnly) const { return true; }\n+};\n+struct hash {\n+  size_t operator()(const MoveOnly&) const { return 0; }\n+};\n+\n+template<typename Alloc>\n+  using test_type = std::unordered_set<MoveOnly, hash, equal, Alloc>;\n+\n+void test01()\n+{\n+  typedef test_type<std::allocator<MoveOnly>> uim;\n+  std::vector<uim> v;\n+  v.emplace_back(uim());\n+}\n+\n+// Unordered containers don't use allocator_traits yet so need full\n+// Allocator interface, derive from std::allocator to get it.\n+template<typename T, bool R>\n+struct Alloc : std::allocator<T>\n+{\n+  template<typename U>\n+    struct rebind { typedef Alloc<U, R> other; };\n+\n+  Alloc() = default;\n+\n+  template<typename U>\n+    Alloc(const Alloc<U, R>&) { }\n+\n+  typedef typename std::conditional<R, T&&, const T&>::type arg_type;\n+\n+  void construct(T* p, arg_type) const\n+  { new((void*)p) T(); }\n+};\n+\n+// verify is_copy_constructible depends on allocator\n+typedef test_type<Alloc<MoveOnly, true>> uim_rval;\n+static_assert(std::is_copy_constructible<uim_rval>::value, \"is not copyable\");\n+\n+typedef test_type<Alloc<MoveOnly, false>> uim_lval;\n+static_assert(std::is_copy_constructible<uim_lval>::value, \"is copyable\");"}]}