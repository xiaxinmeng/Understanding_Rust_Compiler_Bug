{"sha": "a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI2YTAyZDdhN2RkN2FhYjJiYTUwOWQ0MWYyNGVjM2ViYzY0OTI4MA==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-04-02T08:44:39Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-04-02T08:44:39Z"}, "message": "tree-vrp.c (extract_code_and_val_from_cond): Remove.\n\n2008-04-02  Rafael Espindola  <espindola@google.com>\n\n\t* tree-vrp.c (extract_code_and_val_from_cond): Remove.\n\t(register_edge_assert_for_2): Split the cond argument.\n\t(register_edge_assert_for_1): Adjust for the change in\n\tregister_edge_assert_for_2.\n\t(register_edge_assert_for): Split the cond argument.\n\t(find_switch_asserts): Adjust for the change in\n\tregister_edge_assert_for.\n\nFrom-SVN: r133827", "tree": {"sha": "c572f4f86a3d67a34146056fd34bf4bd5c5ea936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c572f4f86a3d67a34146056fd34bf4bd5c5ea936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280/comments", "author": null, "committer": null, "parents": [{"sha": "d925aa70c1727ad1b312557ad29eb13c57058a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d925aa70c1727ad1b312557ad29eb13c57058a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d925aa70c1727ad1b312557ad29eb13c57058a3d"}], "stats": {"total": 111, "additions": 59, "deletions": 52}, "files": [{"sha": "e5faf39261414e3c30377079faf5404d3e95bb48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "patch": "@@ -1,3 +1,13 @@\n+2008-04-02  Rafael Espindola  <espindola@google.com>\n+\n+\t* tree-vrp.c (extract_code_and_val_from_cond): Remove.\n+\t(register_edge_assert_for_2): Split the cond argument.\n+\t(register_edge_assert_for_1): Adjust for the change in\n+\tregister_edge_assert_for_2.\n+\t(register_edge_assert_for): Split the cond argument.\n+\t(find_switch_asserts): Adjust for the change in\n+\tregister_edge_assert_for.\n+\n 2008-04-02  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config.gcc: Add for x86_64-*-mingw* the t-crtfm to tbuild."}, {"sha": "d77653fd4ed63d39f7b862c0f6ba0372cfd09415", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a26a02d7a7dd7aab2ba509d41f24ec3ebc649280/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a26a02d7a7dd7aab2ba509d41f24ec3ebc649280", "patch": "@@ -3681,7 +3681,13 @@ register_new_assert_for (tree name, tree expr,\n   bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));\n }\n \n-/* Helper function for extract_code_and_val_from_cond */\n+/* (COND_OP0 COND_CODE COND_OP1) is a predicate which uses NAME.\n+   Extract a suitable test code and value and store them into *CODE_P and\n+   *VAL_P so the predicate is normalized to NAME *CODE_P *VAL_P.\n+\n+   If no extraction was possible, return FALSE, otherwise return TRUE.\n+\n+   If INVERT is true, then we invert the result stored into *CODE_P.  */\n \n static bool\n extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n@@ -3742,40 +3748,6 @@ extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n   *val_p = val;\n   return true;\n }\n-/* COND is a predicate which uses NAME.  Extract a suitable test code\n-   and value and store them into *CODE_P and *VAL_P so the predicate\n-   is normalized to NAME *CODE_P *VAL_P.\n-\n-   If no extraction was possible, return FALSE, otherwise return TRUE.\n-\n-   If INVERT is true, then we invert the result stored into *CODE_P.  */\n-\n-static bool\n-extract_code_and_val_from_cond (tree name, tree cond, bool invert,\n-\t\t\t\tenum tree_code *code_p, tree *val_p)\n-{\n-  enum tree_code comp_code;\n-  tree val;\n-\n-  /* Predicates may be a single SSA name or NAME OP VAL.  */\n-  if (cond == name)\n-    {\n-      /* If the predicate is a name, it must be NAME, in which\n-\t case we create the predicate NAME == true or\n-\t NAME == false accordingly.  */\n-      comp_code = EQ_EXPR;\n-      val = invert ? boolean_false_node : boolean_true_node;\n-      *code_p = comp_code;\n-      *val_p = val;\n-      return true;\n-    }\n-  else\n-    return extract_code_and_val_from_cond_with_ops (name, TREE_CODE (cond),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 0),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 1),\n-\t\t\t\t\t\t    invert,\n-\t\t\t\t\t\t    code_p, val_p);\n-}\n \n /* Try to register an edge assertion for SSA name NAME on edge E for\n    the condition COND contributing to the conditional jump pointed to by BSI.\n@@ -3784,13 +3756,17 @@ extract_code_and_val_from_cond (tree name, tree cond, bool invert,\n \n static bool\n register_edge_assert_for_2 (tree name, edge e, block_stmt_iterator bsi,\n-\t\t\t    tree cond, bool invert)\n+\t\t\t    enum tree_code cond_code,\n+\t\t\t    tree cond_op0, tree cond_op1, bool invert)\n {\n   tree val;\n   enum tree_code comp_code;\n   bool retval = false;\n \n-  if (!extract_code_and_val_from_cond (name, cond, invert, &comp_code, &val))\n+  if (!extract_code_and_val_from_cond_with_ops (name, cond_code,\n+\t\t\t\t\t\tcond_op0,\n+\t\t\t\t\t\tcond_op1,\n+\t\t\t\t\t\tinvert, &comp_code, &val))\n     return false;\n \n   /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n@@ -3917,6 +3893,7 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n {\n   bool retval = false;\n   tree op_def, rhs, val;\n+  enum tree_code rhs_code;\n \n   /* We only care about SSA_NAMEs.  */\n   if (TREE_CODE (op) != SSA_NAME)\n@@ -3943,6 +3920,7 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n     return retval;\n \n   rhs = GIMPLE_STMT_OPERAND (op_def, 1);\n+  rhs_code = TREE_CODE (rhs);\n \n   if (COMPARISON_CLASS_P (rhs))\n     {\n@@ -3951,9 +3929,11 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op1 = TREE_OPERAND (rhs, 1);\n \n       if (TREE_CODE (op0) == SSA_NAME)\n-        retval |= register_edge_assert_for_2 (op0, e, bsi, rhs, invert);\n+        retval |= register_edge_assert_for_2 (op0, e, bsi, rhs_code, op0, op1,\n+\t\t\t\t\t      invert);\n       if (TREE_CODE (op1) == SSA_NAME)\n-        retval |= register_edge_assert_for_2 (op1, e, bsi, rhs, invert);\n+        retval |= register_edge_assert_for_2 (op1, e, bsi, rhs_code, op0, op1,\n+\t\t\t\t\t      invert);\n     }\n   else if ((code == NE_EXPR\n \t    && (TREE_CODE (rhs) == TRUTH_AND_EXPR\n@@ -3997,7 +3977,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n    Return true if an assertion for NAME could be registered.  */\n \n static bool\n-register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n+register_edge_assert_for (tree name, edge e, block_stmt_iterator si,\n+\t\t\t  enum tree_code cond_code, tree cond_op0,\n+\t\t\t  tree cond_op1)\n {\n   tree val;\n   enum tree_code comp_code;\n@@ -4009,12 +3991,15 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n     return false;\n \n-  if (!extract_code_and_val_from_cond (name, cond, is_else_edge,\n-\t\t\t\t       &comp_code, &val))\n+  if (!extract_code_and_val_from_cond_with_ops (name, cond_code,\n+\t\t\t\t\t\tcond_op0, cond_op1,\n+\t\t\t\t\t\tis_else_edge,\n+\t\t\t\t\t\t&comp_code, &val))\n     return false;\n \n   /* Register ASSERT_EXPRs for name.  */\n-  retval |= register_edge_assert_for_2 (name, e, si, cond, is_else_edge);\n+  retval |= register_edge_assert_for_2 (name, e, si, cond_code, cond_op0,\n+\t\t\t\t\tcond_op1, is_else_edge);\n \n \n   /* If COND is effectively an equality test of an SSA_NAME against\n@@ -4131,8 +4116,17 @@ find_conditional_asserts (basic_block bb, tree last)\n       /* Register the necessary assertions for each operand in the\n \t conditional predicate.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tneed_assert |= register_edge_assert_for (op, e, bsi,\n-\t\t\t\t\t\t COND_EXPR_COND (last));\n+\t{\n+\t  tree cond = COND_EXPR_COND (last);\n+\t  if (op != cond)\n+\t    need_assert |= register_edge_assert_for (op, e, bsi,\n+\t\t\t\t\t\t     TREE_CODE (cond),\n+\t\t\t\t\t\t     TREE_OPERAND (cond, 0),\n+\t\t\t\t\t\t     TREE_OPERAND (cond, 1));\n+\t  else\n+\t    need_assert |= register_edge_assert_for (op, e, bsi, EQ_EXPR, op,\n+\t\t\t\t\t\t     boolean_true_node);\n+\t}\n     }\n \n   /* Finally, indicate that we have found the operands in the\n@@ -4183,7 +4177,7 @@ find_switch_asserts (basic_block bb, tree last)\n {\n   bool need_assert;\n   block_stmt_iterator bsi;\n-  tree op, cond;\n+  tree op;\n   edge e;\n   tree vec = SWITCH_LABELS (last), vec2;\n   size_t n = TREE_VEC_LENGTH (vec);\n@@ -4250,14 +4244,17 @@ find_switch_asserts (basic_block bb, tree last)\n \n       /* Register the necessary assertions for the operand in the\n \t SWITCH_EXPR.  */\n-      cond = build2 (max ? GE_EXPR : EQ_EXPR, boolean_type_node,\n-\t\t     op, fold_convert (TREE_TYPE (op), min));\n-      need_assert |= register_edge_assert_for (op, e, bsi, cond);\n+      need_assert |= register_edge_assert_for (op, e, bsi,\n+\t\t\t\t\t       max ? GE_EXPR : EQ_EXPR,\n+\t\t\t\t\t       op,\n+\t\t\t\t\t       fold_convert (TREE_TYPE (op),\n+\t\t\t\t\t\t\t     min));\n       if (max)\n \t{\n-\t  cond = build2 (LE_EXPR, boolean_type_node,\n-\t\t\t op, fold_convert (TREE_TYPE (op), max));\n-\t  need_assert |= register_edge_assert_for (op, e, bsi, cond);\n+\t  need_assert |= register_edge_assert_for (op, e, bsi, LE_EXPR,\n+\t\t\t\t\t\t   op,\n+\t\t\t\t\t\t   fold_convert (TREE_TYPE (op),\n+\t\t\t\t\t\t\t\t max));\n \t}\n     }\n "}]}