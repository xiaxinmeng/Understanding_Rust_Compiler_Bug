{"sha": "4b2678f8864154a2339001a0ad588c7f611437c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyNjc4Zjg4NjQxNTRhMjMzOTAwMWEwYWQ1ODhjN2Y2MTE0MzdjNw==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-06-18T17:30:41Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-06-18T17:30:41Z"}, "message": "New define insn pattern for epilogue with floating point registers (DFmode) and...\n\nNew define insn pattern for epilogue with floating point registers (DFmode)\nand a new function that emits RTL for this pattern. This function is a\nhelper for epilogue extension. It is used by a later patch.\n\ngcc/\n\n2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n            Sameera Deshpande  <sameera.deshpande@arm.com>\n            Greta Yorsh  <greta.yorsh@arm.com>\n\n        * config/arm/arm.md (vfp_pop_multiple_with_writeback) New\n\tdefine_insn.\n        * config/arm/predicates.md (pop_multiple_fp) New special predicate.\n        * config/arm/arm.c (arm_emit_vfp_multi_reg_pop): New function.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r188740", "tree": {"sha": "2fbecb24dff9d18763579b4db54ee60e68c66f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fbecb24dff9d18763579b4db54ee60e68c66f1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b2678f8864154a2339001a0ad588c7f611437c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2678f8864154a2339001a0ad588c7f611437c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b2678f8864154a2339001a0ad588c7f611437c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2678f8864154a2339001a0ad588c7f611437c7/comments", "author": null, "committer": null, "parents": [{"sha": "3aee198212070736d6a42f3a53f943f61ddc9d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aee198212070736d6a42f3a53f943f61ddc9d4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aee198212070736d6a42f3a53f943f61ddc9d4a"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "f9362b1da165aa08df20dcf3b00c2ed96643777b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b2678f8864154a2339001a0ad588c7f611437c7", "patch": "@@ -1,3 +1,12 @@\n+2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n+            Sameera Deshpande  <sameera.deshpande@arm.com>\n+            Greta Yorsh  <greta.yorsh@arm.com>\n+\n+        * config/arm/arm.md (vfp_pop_multiple_with_writeback) New\n+\tdefine_insn.\n+        * config/arm/predicates.md (pop_multiple_fp) New special predicate.\n+        * config/arm/arm.c (arm_emit_vfp_multi_reg_pop): New function.\n+\n 2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n             Sameera Deshpande  <sameera.deshpande@arm.com>\n             Greta Yorsh  <greta.yorsh@arm.com>"}, {"sha": "02f27d0cb913e6105a8f6a75fa83c943a2411d55", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4b2678f8864154a2339001a0ad588c7f611437c7", "patch": "@@ -16544,6 +16544,76 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n   REG_NOTES (par) = dwarf;\n }\n \n+/* Generate and emit an insn pattern that we will recognize as a pop_multi\n+   of NUM_REGS consecutive VFP regs, starting at FIRST_REG.\n+\n+   Unfortunately, since this insn does not reflect very well the actual\n+   semantics of the operation, we need to annotate the insn for the benefit\n+   of DWARF2 frame unwind information.  */\n+static void\n+arm_emit_vfp_multi_reg_pop (int first_reg, int num_regs, rtx base_reg)\n+{\n+  int i, j;\n+  rtx par;\n+  rtx dwarf = NULL_RTX;\n+  rtx tmp, reg;\n+\n+  gcc_assert (num_regs && num_regs <= 32);\n+\n+    /* Workaround ARM10 VFPr1 bug.  */\n+  if (num_regs == 2 && !arm_arch6)\n+    {\n+      if (first_reg == 15)\n+        first_reg--;\n+\n+      num_regs++;\n+    }\n+\n+  /* We can emit at most 16 D-registers in a single pop_multi instruction, and\n+     there could be up to 32 D-registers to restore.\n+     If there are more than 16 D-registers, make two recursive calls,\n+     each of which emits one pop_multi instruction.  */\n+  if (num_regs > 16)\n+    {\n+      arm_emit_vfp_multi_reg_pop (first_reg, 16, base_reg);\n+      arm_emit_vfp_multi_reg_pop (first_reg + 16, num_regs - 16, base_reg);\n+      return;\n+    }\n+\n+  /* The parallel needs to hold num_regs SETs\n+     and one SET for the stack update.  */\n+  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_regs + 1));\n+\n+  /* Increment the stack pointer, based on there being\n+     num_regs 8-byte registers to restore.  */\n+  tmp = gen_rtx_SET (VOIDmode,\n+                     base_reg,\n+                     plus_constant (Pmode, base_reg, 8 * num_regs));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (par, 0, 0) = tmp;\n+\n+  /* Now show every reg that will be restored, using a SET for each.  */\n+  for (j = 0, i=first_reg; j < num_regs; i += 2)\n+    {\n+      reg = gen_rtx_REG (DFmode, i);\n+\n+      tmp = gen_rtx_SET (VOIDmode,\n+                         reg,\n+                         gen_frame_mem\n+                         (DFmode,\n+                          plus_constant (Pmode, base_reg, 8 * j)));\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, j + 1) = tmp;\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\n+      j++;\n+    }\n+\n+  par = emit_insn (par);\n+  REG_NOTES (par) = dwarf;\n+}\n+\n /* Calculate the size of the return value that is passed in registers.  */\n static unsigned\n arm_size_return_regs (void)"}, {"sha": "bde8580d81d233b2a323912c8ed87e6d8c68386e", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=4b2678f8864154a2339001a0ad588c7f611437c7", "patch": "@@ -10946,6 +10946,41 @@\n   [(set_attr \"type\" \"load1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n+;; Pop for floating point registers (as used in epilogue RTL)\n+(define_insn \"*vfp_pop_multiple_with_writeback\"\n+  [(match_parallel 0 \"pop_multiple_fp\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"+rk\")\n+          (plus:SI (match_dup 1)\n+                   (match_operand:SI 2 \"const_int_operand\" \"I\")))\n+     (set (match_operand:DF 3 \"arm_hard_register_operand\" \"\")\n+          (mem:DF (match_dup 1)))])]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"*\n+  {\n+    int num_regs = XVECLEN (operands[0], 0);\n+    char pattern[100];\n+    rtx op_list[2];\n+    strcpy (pattern, \\\"fldmfdd\\\\t\\\");\n+    strcat (pattern, reg_names[REGNO (SET_DEST (XVECEXP (operands[0], 0, 0)))]);\n+    strcat (pattern, \\\"!, {\\\");\n+    op_list[0] = XEXP (XVECEXP (operands[0], 0, 1), 0);\n+    strcat (pattern, \\\"%P0\\\");\n+    if ((num_regs - 1) > 1)\n+      {\n+        strcat (pattern, \\\"-%P1\\\");\n+        op_list [1] = XEXP (XVECEXP (operands[0], 0, num_regs - 1), 0);\n+      }\n+\n+    strcat (pattern, \\\"}\\\");\n+    output_asm_insn (pattern, op_list);\n+    return \\\"\\\";\n+  }\n+  \"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"conds\" \"unconditional\")\n+   (set_attr \"predicable\" \"no\")]\n+)\n+\n ;; Special patterns for dealing with the constant pool\n \n (define_insn \"align_4\""}, {"sha": "9fd9ad216fc06e56fb5d44b4b6a01033023d59f4", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2678f8864154a2339001a0ad588c7f611437c7/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=4b2678f8864154a2339001a0ad588c7f611437c7", "patch": "@@ -376,6 +376,14 @@\n                                  /*return_pc=*/true);\n })\n \n+(define_special_predicate \"pop_multiple_fp\"\n+  (match_code \"parallel\")\n+{\n+ return ldm_stm_operation_p (op, /*load=*/true, DFmode,\n+                                 /*consecutive=*/true,\n+                                 /*return_pc=*/false);\n+})\n+\n (define_special_predicate \"multi_register_push\"\n   (match_code \"parallel\")\n {"}]}