{"sha": "6426e8aa4150f780b0dfc4bdb244764db8a01e08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQyNmU4YWE0MTUwZjc4MGIwZGZjNGJkYjI0NDc2NGRiOGEwMWUwOA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-03-24T22:03:19Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-03-24T22:03:19Z"}, "message": "Back out previous accidental change.\n\nFrom-SVN: r112362", "tree": {"sha": "66356fc6d6879968cb6236d5f6965dbfb4cf4f85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66356fc6d6879968cb6236d5f6965dbfb4cf4f85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6426e8aa4150f780b0dfc4bdb244764db8a01e08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6426e8aa4150f780b0dfc4bdb244764db8a01e08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6426e8aa4150f780b0dfc4bdb244764db8a01e08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6426e8aa4150f780b0dfc4bdb244764db8a01e08/comments", "author": null, "committer": null, "parents": [{"sha": "895de5a8a986d9a1c5c25d102458215dca6fa225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895de5a8a986d9a1c5c25d102458215dca6fa225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/895de5a8a986d9a1c5c25d102458215dca6fa225"}], "stats": {"total": 54, "additions": 14, "deletions": 40}, "files": [{"sha": "ccfb5df699fb17f8241e926774f36bab75121bab", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6426e8aa4150f780b0dfc4bdb244764db8a01e08/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6426e8aa4150f780b0dfc4bdb244764db8a01e08/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6426e8aa4150f780b0dfc4bdb244764db8a01e08", "patch": "@@ -5326,19 +5326,17 @@ is_c_family (void)\n {\n   unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n-  return (lang == DW_LANG_C || lang == DW_LANG_C89 || lang == DW_LANG_ObjC\n-\t  || lang == DW_LANG_C99\n-\t  || lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus);\n+  return (lang == DW_LANG_C || lang == DW_LANG_C89\n+\t  || lang == DW_LANG_C_plus_plus);\n }\n \n /* Return TRUE if the language is C++.  */\n \n static inline bool\n is_cxx (void)\n {\n-  unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n-  \n-  return lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus;\n+  return (get_AT_unsigned (comp_unit_die, DW_AT_language)\n+\t  == DW_LANG_C_plus_plus);\n }\n \n /* Return TRUE if the language is Fortran.  */\n@@ -9929,23 +9927,6 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n }\n \n-/* Determine whether the evaluation of EXPR references any variables\n-   or functions which aren't otherwise used (and therefore may not be\n-   output).  */\n-static tree\n-reference_to_unused (tree * tp, int * walk_subtrees,\n-\t\t     void * data ATTRIBUTE_UNUSED)\n-{\n-  if (! EXPR_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n-    *walk_subtrees = 0;\n-  \n-  if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)\n-      && ! TREE_ASM_WRITTEN (*tp))\n-    return *tp;\n-  else\n-    return NULL_TREE;\n-}\n-\n /* Generate an RTL constant from a decl initializer INIT with decl type TYPE,\n    for use in a later add_const_value_attribute call.  */\n \n@@ -9972,16 +9953,15 @@ rtl_for_decl_init (tree init, tree type)\n \trtl = gen_rtx_CONST_STRING (VOIDmode,\n \t\t\t\t    ggc_strdup (TREE_STRING_POINTER (init)));\n     }\n-  /* Although DWARF could easily handle other kinds of aggregates, we\n-     have no way to represent such values as RTL constants, so skip\n-     those.  */\n-  else if (AGGREGATE_TYPE_P (type))\n-    ;\n   /* If the initializer is something that we know will expand into an\n-     immediate RTL constant, expand it now.  We must be careful not to\n-     reference variables which won't be output.  */\n-  else if (initializer_constant_valid_p (init, type)\n-\t   && ! walk_tree (&init, reference_to_unused, NULL, NULL))\n+     immediate RTL constant, expand it now.  Expanding anything else\n+     tends to produce unresolved symbols; see debug/5770 and c++/6381.  */\n+  /* Aggregate, vector, and complex types may contain constructors that may\n+     result in code being generated when expand_expr is called, so we can't\n+     handle them here.  Integer and float are useful and safe types to handle\n+     here.  */\n+  else if ((INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type))\n+\t   && initializer_constant_valid_p (init, type) == null_pointer_node)\n     {\n       rtl = expand_expr (init, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n \n@@ -10345,9 +10325,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       add_AT_location_description (die, attr, descr);\n       return;\n     }\n-  /* None of that worked, so it must not really have a location;\n-     try adding a constant value attribute from the DECL_INITIAL.  */\n-  tree_add_const_value_attribute (die, decl);\n }\n \n /* If we don't have a copy of this variable in memory for some reason (such\n@@ -12227,10 +12204,6 @@ gen_compile_unit_die (const char *filename)\n     language = DW_LANG_Pascal83;\n   else if (strcmp (language_string, \"GNU Java\") == 0)\n     language = DW_LANG_Java;\n-  else if (strcmp (language_string, \"GNU Objective-C\") == 0)\n-    language = DW_LANG_ObjC;\n-  else if (strcmp (language_string, \"GNU Objective-C++\") == 0)\n-    language = DW_LANG_ObjC_plus_plus;\n   else\n     language = DW_LANG_C89;\n \n@@ -13341,7 +13314,8 @@ dwarf2out_decl (tree decl)\n \t{\n \t  /* OK, we need to generate one for `bool' so GDB knows what type\n \t     comparisons have.  */\n-\t  if (is_cxx ()\n+\t  if ((get_AT_unsigned (comp_unit_die, DW_AT_language)\n+\t       == DW_LANG_C_plus_plus)\n \t      && TREE_CODE (TREE_TYPE (decl)) == BOOLEAN_TYPE\n \t      && ! DECL_IGNORED_P (decl))\n \t    modified_type_die (TREE_TYPE (decl), 0, 0, NULL);"}]}