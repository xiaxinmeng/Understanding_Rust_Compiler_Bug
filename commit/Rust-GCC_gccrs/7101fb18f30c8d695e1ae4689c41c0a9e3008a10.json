{"sha": "7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwMWZiMThmMzBjOGQ2OTVlMWFlNDY4OWM0MWMwYTllMzAwOGExMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-11T21:52:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-11T21:52:42Z"}, "message": "cselib.c (cselib_invalidate_mem_1): Move too ...\n\n\t* cselib.c (cselib_invalidate_mem_1): Move too ...\n\t(cselib_invalidate_mem): ... here; use new list\n\t(dummy_val, first_containing_mem): New static variables.\n\t(clear_table): Initialize first_containing_mem.\n\t(discard_useless_values):  Compact the containing_mem list.\n\t(add_mem_for_addr): Add to the list.\n\t* cselib.h (cselib_val): Add next_containing_mem.\n\nFrom-SVN: r64191", "tree": {"sha": "599b78f61b4b9d005ee8a2f1af108fa87eb6b1ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/599b78f61b4b9d005ee8a2f1af108fa87eb6b1ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/comments", "author": null, "committer": null, "parents": [{"sha": "e24c3d715a19801f1ce098c55f1a05fa67b75289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24c3d715a19801f1ce098c55f1a05fa67b75289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24c3d715a19801f1ce098c55f1a05fa67b75289"}], "stats": {"total": 145, "additions": 95, "deletions": 50}, "files": [{"sha": "a3ec4c6cb59b11df4011db74ce94b8b8d31a1681", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "patch": "@@ -1,3 +1,13 @@\n+Tue Mar 11 22:48:03 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cselib.c (cselib_invalidate_mem_1): Move too ...\n+\t(cselib_invalidate_mem): ... here; use new list\n+\t(dummy_val, first_containing_mem): New static variables.\n+\t(clear_table): Initialize first_containing_mem.\n+\t(discard_useless_values):  Compact the containing_mem list.\n+\t(add_mem_for_addr): Add to the list.\n+\t* cselib.h (cselib_val): Add next_containing_mem.\n+\n 2003-03-11  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.c (rs6000_override_options): Disable string"}, {"sha": "564afbaaacb4991036e553e19ab785f6caf6eb06", "filename": "gcc/cselib.c", "status": "modified", "additions": 83, "deletions": 50, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "patch": "@@ -63,7 +63,6 @@ static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n-static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n static void cselib_invalidate_mem\tPARAMS ((rtx));\n static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n@@ -128,6 +127,15 @@ static GTY((deletable (\"\"))) struct elt_loc_list *empty_elt_loc_lists;\n /* Set by discard_useless_locs if it deleted the last location of any\n    value.  */\n static int values_became_useless;\n+\n+/* Used as stop element of the containing_mem list so we can check\n+   presence in the list by checking the next pointer.  */\n+static cselib_val dummy_val;\n+\n+/* Used to list all values that contain memory reference. \n+   May or may not contain the useless values - the list is compacted\n+   each time memory is invalidated.  */\n+static cselib_val *first_containing_mem = &dummy_val;\n \f\n \n /* Allocate a struct elt_list and fill in its two elements with the\n@@ -237,6 +245,8 @@ clear_table (clear_all)\n   n_useless_values = 0;\n \n   next_unknown_value = 0;\n+\n+  first_containing_mem = &dummy_val;\n }\n \n /* The equality test for our hash table.  The first argument ENTRY is a table\n@@ -371,6 +381,7 @@ discard_useless_values (x, info)\n static void\n remove_useless_values ()\n {\n+  cselib_val **p, *v;\n   /* First pass: eliminate locations that reference the value.  That in\n      turn can make more values useless.  */\n   do\n@@ -383,6 +394,15 @@ remove_useless_values ()\n   /* Second pass: actually remove the values.  */\n   htab_traverse (hash_table, discard_useless_values, 0);\n \n+  p = &first_containing_mem;\n+  for (v = *p; v != &dummy_val; v = v->next_containing_mem)\n+    if (v->locs)\n+      {\n+\t*p = v;\n+\tp = &(*p)->next_containing_mem;\n+      }\n+  *p = &dummy_val;\n+\n   if (n_useless_values != 0)\n     abort ();\n }\n@@ -706,6 +726,7 @@ new_cselib_val (value, mode)\n   CSELIB_VAL_PTR (e->u.val_rtx) = e;\n   e->addr_list = 0;\n   e->locs = 0;\n+  e->next_containing_mem = 0;\n   return e;\n }\n \n@@ -730,6 +751,11 @@ add_mem_for_addr (addr_elt, mem_elt, x)\n   mem_elt->locs\n     = new_elt_loc_list (mem_elt->locs,\n \t\t\treplace_equiv_address_nv (x, addr_elt->u.val_rtx));\n+  if (mem_elt->next_containing_mem == NULL)\n+    {\n+      mem_elt->next_containing_mem = first_containing_mem;\n+      first_containing_mem = mem_elt;\n+    }\n }\n \n /* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.\n@@ -1078,68 +1104,75 @@ cselib_mem_conflict_p (mem_base, val)\n   return 0;\n }\n \n-/* For the value found in SLOT, walk its locations to determine if any overlap\n-   INFO (which is a MEM rtx).  */\n+/* Invalidate any locations in the table which are changed because of a\n+   store to MEM_RTX.  If this is called because of a non-const call\n+   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n \n-static int\n-cselib_invalidate_mem_1 (slot, info)\n-     void **slot;\n-     void *info;\n+static void\n+cselib_invalidate_mem (mem_rtx)\n+     rtx mem_rtx;\n {\n-  cselib_val *v = (cselib_val *) *slot;\n-  rtx mem_rtx = (rtx) info;\n-  struct elt_loc_list **p = &v->locs;\n-  int had_locs = v->locs != 0;\n+  cselib_val **vp, *v, *next;\n \n-  while (*p)\n+  vp = &first_containing_mem;\n+  for (v = *vp; v != &dummy_val; v = next)\n     {\n-      rtx x = (*p)->loc;\n-      cselib_val *addr;\n-      struct elt_list **mem_chain;\n-\n-      /* MEMs may occur in locations only at the top level; below\n-\t that every MEM or REG is substituted by its VALUE.  */\n-      if (GET_CODE (x) != MEM\n-\t  || ! cselib_mem_conflict_p (mem_rtx, x))\n-\t{\n-\t  p = &(*p)->next;\n-\t  continue;\n-\t}\n+      bool has_mem = false;\n+      struct elt_loc_list **p = &v->locs;\n+      int had_locs = v->locs != 0;\n \n-      /* This one overlaps.  */\n-      /* We must have a mapping from this MEM's address to the\n-\t value (E).  Remove that, too.  */\n-      addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n-      mem_chain = &addr->addr_list;\n-      for (;;)\n+      while (*p)\n \t{\n-\t  if ((*mem_chain)->elt == v)\n+\t  rtx x = (*p)->loc;\n+\t  cselib_val *addr;\n+\t  struct elt_list **mem_chain;\n+\n+\t  /* MEMs may occur in locations only at the top level; below\n+\t     that every MEM or REG is substituted by its VALUE.  */\n+\t  if (GET_CODE (x) != MEM)\n \t    {\n-\t      unchain_one_elt_list (mem_chain);\n-\t      break;\n+\t      p = &(*p)->next;\n+\t      continue;\n+\t    }\n+\t  if (! cselib_mem_conflict_p (mem_rtx, x))\n+\t    {\n+\t      has_mem = true;\n+\t      p = &(*p)->next;\n+\t      continue;\n \t    }\n \n-\t  mem_chain = &(*mem_chain)->next;\n-\t}\n-\n-      unchain_one_elt_loc_list (p);\n-    }\n+\t  /* This one overlaps.  */\n+\t  /* We must have a mapping from this MEM's address to the\n+\t     value (E).  Remove that, too.  */\n+\t  addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n+\t  mem_chain = &addr->addr_list;\n+\t  for (;;)\n+\t    {\n+\t      if ((*mem_chain)->elt == v)\n+\t\t{\n+\t\t  unchain_one_elt_list (mem_chain);\n+\t\t  break;\n+\t\t}\n \n-  if (had_locs && v->locs == 0)\n-    n_useless_values++;\n+\t      mem_chain = &(*mem_chain)->next;\n+\t    }\n \n-  return 1;\n-}\n+\t  unchain_one_elt_loc_list (p);\n+\t}\n \n-/* Invalidate any locations in the table which are changed because of a\n-   store to MEM_RTX.  If this is called because of a non-const call\n-   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n+      if (had_locs && v->locs == 0)\n+\tn_useless_values++;\n \n-static void\n-cselib_invalidate_mem (mem_rtx)\n-     rtx mem_rtx;\n-{\n-  htab_traverse (hash_table, cselib_invalidate_mem_1, mem_rtx);\n+      next = v->next_containing_mem;\n+      if (has_mem)\n+\t{\n+\t  *vp = v;\n+\t  vp = &(*vp)->next_containing_mem;\n+\t}\n+      else\n+\tv->next_containing_mem = NULL;\n+    }\n+  *vp = &dummy_val;\n }\n \n /* Invalidate DEST, which is being assigned to or clobbered.  The second and"}, {"sha": "9cceddbfcbc267a4ebc1e42c7b77a44b90d628b8", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7101fb18f30c8d695e1ae4689c41c0a9e3008a10/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=7101fb18f30c8d695e1ae4689c41c0a9e3008a10", "patch": "@@ -38,6 +38,8 @@ typedef struct cselib_val_struct GTY(())\n   /* If this value is used as an address, points to a list of values that\n      use it as an address in a MEM.  */\n   struct elt_list *addr_list;\n+\n+  struct cselib_val_struct *next_containing_mem;\n } cselib_val;\n \n /* A list of rtl expressions that hold the same value.  */"}]}