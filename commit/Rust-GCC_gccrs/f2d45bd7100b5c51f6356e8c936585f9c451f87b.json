{"sha": "f2d45bd7100b5c51f6356e8c936585f9c451f87b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkNDViZDcxMDBiNWM1MWY2MzU2ZThjOTM2NTg1ZjljNDUxZjg3Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T06:38:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T06:38:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r483", "tree": {"sha": "904c6a165cbb73027625faab87c9a409eacde446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/904c6a165cbb73027625faab87c9a409eacde446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2d45bd7100b5c51f6356e8c936585f9c451f87b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d45bd7100b5c51f6356e8c936585f9c451f87b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d45bd7100b5c51f6356e8c936585f9c451f87b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d45bd7100b5c51f6356e8c936585f9c451f87b/comments", "author": null, "committer": null, "parents": [{"sha": "2aa7ec3746c846618627de446610b303230bef68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa7ec3746c846618627de446610b303230bef68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa7ec3746c846618627de446610b303230bef68"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "4671431c454417006e9dcae6d121158c5b618b50", "filename": "gcc/config/pyr/pyr.md", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d45bd7100b5c51f6356e8c936585f9c451f87b/gcc%2Fconfig%2Fpyr%2Fpyr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d45bd7100b5c51f6356e8c936585f9c451f87b/gcc%2Fconfig%2Fpyr%2Fpyr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.md?ref=f2d45bd7100b5c51f6356e8c936585f9c451f87b", "patch": "@@ -38,7 +38,7 @@\n ;; * Fix true frame pointer omission.\n ;; * Make the jump tables contain branches, not addresses!  This would\n ;;   save us one instruction.\n-;; * Could the compilcated scheme for compares be simplyfied, if we had\n+;; * Could the complicated scheme for compares be simplified, if we had\n ;;   no named cmpqi or cmphi patterns, and instead anonymous patterns for\n ;;   the less-than-word compare cases pyr can handle???\n ;; * The jump insn seems to accept more than just IR addressing.  Would\n@@ -84,6 +84,7 @@\n   rtx br_insn = NEXT_INSN (insn);\n   RTX_CODE br_code;\n \n+  extern int swap_operands;\n   if (GET_CODE (br_insn) != JUMP_INSN)\n     abort();\n   br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n@@ -144,7 +145,7 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(match_operand:SI 0 \"general_operand\" \"r\"))]\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"r\"))]\n   \"\"\n   \"*\n {\n@@ -183,7 +184,7 @@\n \n (define_expand \"tsthi\"\n   [(set (cc0)\n-\t(match_operand:HI 0 \"general_operand\" \"\"))]\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"\"))]\n   \"\"\n   \"\n {\n@@ -200,6 +201,7 @@\n   \"weird_memory_memory (operands[0], operands[1])\"\n   \"*\n {\n+  extern int swap_operands;\n   rtx br_insn = NEXT_INSN (insn);\n \n   if (GET_CODE (br_insn) != JUMP_INSN)\n@@ -253,7 +255,7 @@\n \n (define_expand \"tstqi\"\n   [(set (cc0)\n-\t(match_operand:QI 0 \"general_operand\" \"\"))]\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"\"))]\n   \"\"\n   \"\n {\n@@ -270,6 +272,7 @@\n   \"weird_memory_memory (operands[0], operands[1])\"\n   \"*\n {\n+  extern int swap_operands;\n   rtx br_insn = NEXT_INSN (insn);\n   RTX_CODE br_code;\n \n@@ -678,7 +681,7 @@\n \n ;; If the destination is a memory operand, indexed source operands are\n ;; disallowed.  Big DImode constants are always loaded into a reg pair,\n-;; although offsetable memory addresses really could be dealt with.\n+;; although offsettable memory addresses really could be dealt with.\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n@@ -1203,14 +1206,16 @@\n \t(match_operand:SI 3 \"general_operand\" \"g\"))]\n   \"movdi_possible (operands)\"\n   \"*\n+{\n+  extern int swap_operands;\n   output_asm_insn (\\\"# COMBINE movw %1,%0\\\", operands);\n   output_asm_insn (\\\"# COMBINE movw %3,%2\\\", operands);\n   movdi_possible (operands);\n   if (CONSTANT_P (operands[1]))\n     return (swap_operands) ? \\\"movl %3,%0\\\" : \\\"movl %1,%2\\\";\n \n   return (swap_operands) ? \\\"movl %1,%0\\\" : \\\"movl %3,%2\\\";\n-\")\n+}\")\n \n ;; Optimize certain tests after memory stores.\n \n@@ -1360,6 +1365,12 @@\n   output_asm_insn (\\\"xorw %1,%0\\\", xoperands);\n   return \\\"xorw %2,%0\\\";\n }\")\n+\n+;; My version, modelled after Jonathan Stone's and \"tablejump\" - S.P.\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"jump (%0)\")\n \f\n ;;- Local variables:\n ;;- mode:emacs-lisp"}]}