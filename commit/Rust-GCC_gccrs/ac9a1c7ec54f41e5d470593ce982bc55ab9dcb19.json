{"sha": "ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5YTFjN2VjNTRmNDFlNWQ0NzA1OTNjZTk4MmJjNTVhYjlkY2IxOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-06-16T14:16:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-16T14:16:20Z"}, "message": "Make rtti lazier\n\n\tMake rtti lazier\n\t* rtti.c (enum tinfo_kind): Add TK_DERIVED_TYPES,\n\tTK_VMI_CLASS_TYPES, TK_MAX.  Delete TK_FIXED.\n\t(tinfo_names): New.\n\t(typeid_ok_p): Add quotes to error messages.  Use get_tinfo_desc.\n\t(get_tinfo_decl): Use get_tinfo_desc.\n\t(get_pseudo_ti_init): Likewise. Adjust VMI construction.\n\t(create_pseudo_type_info): Delete.\n\t(get_pseudo_ti_index): Just determine the index.\n\t(get_tinfo_desc): New.  Create all types lazily.\n\t(create_tinfo_types): Just allocate the descriptor array.\n\t(emit_support_tinfos): Use non-inserting type lookup.  Set builtin\n\tlocation.\n\nFrom-SVN: r249258", "tree": {"sha": "bd162154bfe7d92bda57af3891c25aa91ea4baaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd162154bfe7d92bda57af3891c25aa91ea4baaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfe8a528aa35b66146fa7bac8ea0c1a5bc48bb70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe8a528aa35b66146fa7bac8ea0c1a5bc48bb70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe8a528aa35b66146fa7bac8ea0c1a5bc48bb70"}], "stats": {"total": 485, "additions": 254, "deletions": 231}, "files": [{"sha": "7bf7ed1865e333d25db5c92037a56d75b5ea3802", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "patch": "@@ -1,3 +1,19 @@\n+2017-06-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\tMake rtti lazier\n+\t* rtti.c (enum tinfo_kind): Add TK_DERIVED_TYPES,\n+\tTK_VMI_CLASS_TYPES, TK_MAX.  Delete TK_FIXED.\n+\t(tinfo_names): New.\n+\t(typeid_ok_p): Add quotes to error messages.  Use get_tinfo_desc.\n+\t(get_tinfo_decl): Use get_tinfo_desc.\n+\t(get_pseudo_ti_init): Likewise. Adjust VMI construction.\n+\t(create_pseudo_type_info): Delete.\n+\t(get_pseudo_ti_index): Just determine the index.\n+\t(get_tinfo_desc): New.  Create all types lazily.\n+\t(create_tinfo_types): Just allocate the descriptor array.\n+\t(emit_support_tinfos): Use non-inserting type lookup.  Set builtin\n+\tlocation.\n+\n 2017-06-15  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/80560"}, {"sha": "6d0316f9ee3b2670786ea9bdb2fcfd85996c68d1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 238, "deletions": 231, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=ac9a1c7ec54f41e5d470593ce982bc55ab9dcb19", "patch": "@@ -75,16 +75,35 @@ enum tinfo_kind\n {\n   TK_TYPE_INFO_TYPE,    /* abi::__type_info_pseudo */\n   TK_BASE_TYPE,\t\t/* abi::__base_class_type_info */\n-  TK_BUILTIN_TYPE,\t/* abi::__fundamental_type_info */\n+  TK_DERIVED_TYPES,\t/* Start of types derived from abi::__type_info  */\n+  TK_BUILTIN_TYPE = TK_DERIVED_TYPES,\t/* abi::__fundamental_type_info */\n   TK_ARRAY_TYPE,\t/* abi::__array_type_info */\n   TK_FUNCTION_TYPE,\t/* abi::__function_type_info */\n   TK_ENUMERAL_TYPE,\t/* abi::__enum_type_info */\n   TK_POINTER_TYPE,\t/* abi::__pointer_type_info */\n   TK_POINTER_MEMBER_TYPE, /* abi::__pointer_to_member_type_info */\n   TK_CLASS_TYPE,\t/* abi::__class_type_info */\n   TK_SI_CLASS_TYPE,\t/* abi::__si_class_type_info */\n-  TK_FIXED\t\t/* end of fixed descriptors. */\n-  /* ...\t\t   abi::__vmi_type_info<I> */\n+  TK_VMI_CLASS_TYPES,\t/* abi::__vmi_class_type_info<int> */\n+  TK_MAX\n+};\n+\n+/* Names of the tinfo types.  Must be same order as TK enumeration\n+   above.  */\n+\n+static const char *const tinfo_names[TK_MAX] =\n+{\n+  \"__type_info\",\n+  \"__base_class_type_info\",\n+  \"__fundamental_type_info\",\n+  \"__array_type_info\",\n+  \"__function_type_info\",\n+  \"__enum_type_info\",\n+  \"__pointer_type_info\",\n+  \"__pointer_to_member_type_info\",\n+  \"__class_type_info\",\n+  \"__si_class_type_info\",\n+  \"__vmi_class_type_info\"\n };\n \n /* Helper macro to get maximum scalar-width of pointer or of the 'long'-type.\n@@ -115,9 +134,9 @@ static tree generic_initializer (tinfo_s *, tree);\n static tree ptr_initializer (tinfo_s *, tree);\n static tree ptm_initializer (tinfo_s *, tree);\n static tree class_initializer (tinfo_s *, tree, unsigned, ...);\n-static void create_pseudo_type_info (int, const char *, ...);\n static tree get_pseudo_ti_init (tree, unsigned);\n static unsigned get_pseudo_ti_index (tree);\n+static tinfo_s *get_tinfo_desc (unsigned);\n static void create_tinfo_types (void);\n static bool typeinfo_in_lib_p (tree);\n \n@@ -289,30 +308,27 @@ get_tinfo_decl_dynamic (tree exp, tsubst_flags_t complain)\n static bool\n typeid_ok_p (void)\n {\n-  tree pseudo_type_info, type_info_type;\n-\n   if (! flag_rtti)\n     {\n-      error (\"cannot use typeid with -fno-rtti\");\n+      error (\"cannot use %<typeid%> with -fno-rtti\");\n       return false;\n     }\n \n   if (!COMPLETE_TYPE_P (const_type_info_type_node))\n     {\n-      error (\"must #include <typeinfo> before using typeid\");\n+      error (\"must %<#include <typeinfo>%> before using %<typeid%>\");\n       return false;\n     }\n \n-  pseudo_type_info = (*tinfo_descs)[TK_TYPE_INFO_TYPE].type;\n-  type_info_type = TYPE_MAIN_VARIANT (const_type_info_type_node);\n+  tree pseudo = TYPE_MAIN_VARIANT (get_tinfo_desc (TK_TYPE_INFO_TYPE)->type);\n+  tree real = TYPE_MAIN_VARIANT (const_type_info_type_node);\n \n   /* Make sure abi::__type_info_pseudo has the same alias set\n      as std::type_info.  */\n-  if (! TYPE_ALIAS_SET_KNOWN_P (pseudo_type_info))\n-    TYPE_ALIAS_SET (pseudo_type_info) = get_alias_set (type_info_type);\n+  if (! TYPE_ALIAS_SET_KNOWN_P (pseudo))\n+    TYPE_ALIAS_SET (pseudo) = get_alias_set (real);\n   else\n-    gcc_assert (TYPE_ALIAS_SET (pseudo_type_info)\n-\t\t== get_alias_set (type_info_type));\n+    gcc_assert (TYPE_ALIAS_SET (pseudo) == get_alias_set (real));\n \n   return true;\n }\n@@ -428,8 +444,8 @@ get_tinfo_decl (tree type)\n   if (!d)\n     {\n       int ix = get_pseudo_ti_index (type);\n-      tinfo_s *ti = &(*tinfo_descs)[ix];\n-\n+      const tinfo_s *ti = get_tinfo_desc (ix);\n+      \n       d = build_lang_decl (VAR_DECL, name, ti->type);\n       SET_DECL_ASSEMBLER_NAME (d, name);\n       /* Remember the type it is for.  */\n@@ -1105,7 +1121,7 @@ typeinfo_in_lib_p (tree type)\n static tree\n get_pseudo_ti_init (tree type, unsigned tk_index)\n {\n-  tinfo_s *ti = &(*tinfo_descs)[tk_index];\n+  tinfo_s *ti = get_tinfo_desc (tk_index);\n \n   gcc_assert (at_eof);\n   switch (tk_index)\n@@ -1140,22 +1156,18 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \tint hint = ((CLASSTYPE_REPEATED_BASE_P (type) << 0)\n \t\t    | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n \ttree binfo = TYPE_BINFO (type);\n-\tint nbases = BINFO_N_BASE_BINFOS (binfo);\n+\tunsigned nbases = BINFO_N_BASE_BINFOS (binfo);\n \tvec<tree, va_gc> *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \ttree offset_type = LONGPTR_T;\n-\ttree base_inits = NULL_TREE;\n-\tint ix;\n \tvec<constructor_elt, va_gc> *init_vec = NULL;\n-\tconstructor_elt *e;\n \n-\tgcc_assert (tk_index >= TK_FIXED);\n+\tgcc_assert (tk_index - TK_VMI_CLASS_TYPES + 1 == nbases);\n \n \tvec_safe_grow (init_vec, nbases);\n \t/* Generate the base information initializer.  */\n-\tfor (ix = nbases; ix--;)\n+\tfor (unsigned ix = nbases; ix--;)\n \t  {\n \t    tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n-\t    tree base_init;\n \t    int flags = 0;\n \t    tree tinfo;\n \t    tree offset;\n@@ -1185,12 +1197,12 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t    vec_alloc (v, 2);\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tinfo);\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, offset);\n-\t    base_init = build_constructor (init_list_type_node, v);\n-\t    e = &(*init_vec)[ix];\n+\t    tree base_init = build_constructor (init_list_type_node, v);\n+\t    constructor_elt *e = &(*init_vec)[ix];\n \t    e->index = NULL_TREE;\n \t    e->value = base_init;\n \t  }\n-\tbase_inits = build_constructor (init_list_type_node, init_vec);\n+\ttree base_inits = build_constructor (init_list_type_node, init_vec);\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n \tti = &(*tinfo_descs)[tk_index];\n@@ -1202,69 +1214,6 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n     }\n }\n \n-/* Generate the RECORD_TYPE containing the data layout of a type_info\n-   derivative as used by the runtime. This layout must be consistent with\n-   that defined in the runtime support. Also generate the VAR_DECL for the\n-   type's vtable. We explicitly manage the vtable member, and name it for\n-   real type as used in the runtime. The RECORD type has a different name,\n-   to avoid collisions.  Return a TREE_LIST who's TINFO_PSEUDO_TYPE\n-   is the generated type and TINFO_VTABLE_NAME is the name of the\n-   vtable.  We have to delay generating the VAR_DECL of the vtable\n-   until the end of the translation, when we'll have seen the library\n-   definition, if there was one.\n-\n-   REAL_NAME is the runtime's name of the type. Trailing arguments are\n-   additional FIELD_DECL's for the structure. The final argument must be\n-   NULL.  */\n-\n-static void\n-create_pseudo_type_info (int tk, const char *real_name, ...)\n-{\n-  tinfo_s *ti;\n-  tree pseudo_type;\n-  char *pseudo_name;\n-  tree fields;\n-  tree field_decl;\n-  va_list ap;\n-\n-  va_start (ap, real_name);\n-\n-  /* Generate the pseudo type name.  */\n-  pseudo_name = (char *) alloca (strlen (real_name) + 30);\n-  strcpy (pseudo_name, real_name);\n-  strcat (pseudo_name, \"_pseudo\");\n-  if (tk >= TK_FIXED)\n-    sprintf (pseudo_name + strlen (pseudo_name), \"%d\", tk - TK_FIXED);\n-\n-  /* First field is the pseudo type_info base class.  */\n-  fields = build_decl (input_location,\n-\t\t       FIELD_DECL, NULL_TREE,\n-\t\t       (*tinfo_descs)[TK_TYPE_INFO_TYPE].type);\n-\n-  /* Now add the derived fields.  */\n-  while ((field_decl = va_arg (ap, tree)))\n-    {\n-      DECL_CHAIN (field_decl) = fields;\n-      fields = field_decl;\n-    }\n-\n-  /* Create the pseudo type.  */\n-  pseudo_type = make_class_type (RECORD_TYPE);\n-  finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n-  CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n-\n-  ti = &(*tinfo_descs)[tk];\n-  ti->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n-  ti->name = get_identifier (real_name);\n-  ti->vtable = NULL_TREE;\n-\n-  /* Pretend this is public so determine_visibility doesn't give vtables\n-     internal linkage.  */\n-  TREE_PUBLIC (TYPE_MAIN_DECL (ti->type)) = 1;\n-\n-  va_end (ap);\n-}\n-\n /* Return the index of a pseudo type info type node used to describe\n    TYPE.  TYPE must be a complete type (or cv void), except at the end\n    of the translation unit.  */\n@@ -1299,23 +1248,16 @@ get_pseudo_ti_index (tree type)\n     case UNION_TYPE:\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n-\t{\n-\t  ix = TK_POINTER_MEMBER_TYPE;\n-\t  break;\n-\t}\n+\tix = TK_POINTER_MEMBER_TYPE;\n       else if (!COMPLETE_TYPE_P (type))\n \t{\n \t  if (!at_eof)\n \t    cxx_incomplete_type_error (NULL_TREE, type);\n \t  ix = TK_CLASS_TYPE;\n-\t  break;\n \t}\n       else if (!TYPE_BINFO (type)\n \t       || !BINFO_N_BASE_BINFOS (TYPE_BINFO (type)))\n-\t{\n-\t  ix = TK_CLASS_TYPE;\n-\t  break;\n-\t}\n+\tix = TK_CLASS_TYPE;\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n@@ -1327,157 +1269,216 @@ get_pseudo_ti_index (tree type)\n \t      && (*base_accesses)[0] == access_public_node\n \t      && !BINFO_VIRTUAL_P (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n-\t    {\n-\t      /* single non-virtual public.  */\n-\t      ix = TK_SI_CLASS_TYPE;\n-\t      break;\n-\t    }\n+\t    /* single non-virtual public.  */\n+\t    ix = TK_SI_CLASS_TYPE;\n \t  else\n-\t    {\n-\t      tinfo_s *ti;\n-\t      tree array_domain, base_array;\n-\n-\t      ix = TK_FIXED + num_bases;\n-\t      if (vec_safe_length (tinfo_descs) <= ix)\n-\t\t{\n-\t\t  /* too short, extend.  */\n-\t\t  unsigned len = vec_safe_length (tinfo_descs);\n-\n-\t\t  vec_safe_grow (tinfo_descs, ix + 1);\n-\t\t  while (tinfo_descs->iterate (len++, &ti))\n-\t\t    ti->type = ti->vtable = ti->name = NULL_TREE;\n-\t\t}\n-\t      else if ((*tinfo_descs)[ix].type)\n-\t\t/* already created.  */\n-\t\tbreak;\n-\n-\t      /* Create the array of __base_class_type_info entries.  */\n-\t      array_domain = build_index_type (size_int (num_bases - 1));\n-\t      base_array = build_array_type ((*tinfo_descs)[TK_BASE_TYPE].type,\n-\t\t\t\t\t     array_domain);\n-\n-\t      push_abi_namespace ();\n-\t      create_pseudo_type_info\n-\t\t(ix, \"__vmi_class_type_info\",\n-\t\t build_decl (input_location,\n-\t\t\t     FIELD_DECL, NULL_TREE, integer_type_node),\n-\t\t build_decl (input_location,\n-\t\t\t     FIELD_DECL, NULL_TREE, integer_type_node),\n-\t\t build_decl (input_location,\n-\t\t\t     FIELD_DECL, NULL_TREE, base_array),\n-\t\t NULL);\n-\t      pop_abi_namespace ();\n-\t      break;\n-\t    }\n+\t    ix = TK_VMI_CLASS_TYPES + num_bases - 1;\n \t}\n+      break;\n+\n     default:\n       ix = TK_BUILTIN_TYPE;\n       break;\n     }\n   return ix;\n }\n \n-/* Make sure the required builtin types exist for generating the type_info\n-   variable definitions.  */\n+/* Return pointer to tinfo descriptor.  Possibly creating the tinfo\n+   descriptor in the first place.  */\n \n-static void\n-create_tinfo_types (void)\n+static tinfo_s *\n+get_tinfo_desc (unsigned ix)\n {\n-  tinfo_s *ti;\n+  unsigned len = tinfo_descs->length ();\n \n-  gcc_assert (!tinfo_descs);\n+  if (len <= ix)\n+    {\n+      /* too short, extend.  */\n+      len = ix + 1 - len;\n+      vec_safe_reserve (tinfo_descs, len);\n+      tinfo_s elt;\n+      elt.type = elt.vtable = elt.name = NULL_TREE;\n+      while (len--)\n+\ttinfo_descs->quick_push (elt);\n+    }\n \n-  vec_safe_grow (tinfo_descs, TK_FIXED);\n+  tinfo_s *res = &(*tinfo_descs)[ix];\n \n-  push_abi_namespace ();\n+  if (res->type)\n+    return res;\n \n-  /* Create the internal type_info structure. This is used as a base for\n-     the other structures.  */\n-  {\n-    tree field, fields;\n-\n-    field = build_decl (BUILTINS_LOCATION,\n-\t\t\tFIELD_DECL, NULL_TREE, const_ptr_type_node);\n-    fields = field;\n-\n-    field = build_decl (BUILTINS_LOCATION,\n-\t\t\tFIELD_DECL, NULL_TREE, const_string_type_node);\n-    DECL_CHAIN (field) = fields;\n-    fields = field;\n-\n-    ti = &(*tinfo_descs)[TK_TYPE_INFO_TYPE];\n-    ti->type = make_class_type (RECORD_TYPE);\n-    ti->vtable = NULL_TREE;\n-    ti->name = NULL_TREE;\n-    finish_builtin_struct (ti->type, \"__type_info_pseudo\",\n-\t\t\t   fields, NULL_TREE);\n-  }\n+  /* Ok, we have to create it.  This layout must be consistent with\n+     that defined in the runtime support.  We explicitly manage the\n+     vtable member, and name it for real type as used in the runtime.\n+     The RECORD type has a different name, to avoid collisions.  We\n+     have to delay generating the VAR_DECL of the vtable until the end\n+     of the translation, when we'll have seen the library definition,\n+     if there was one.  */\n \n-  /* Fundamental type_info */\n-  create_pseudo_type_info (TK_BUILTIN_TYPE, \"__fundamental_type_info\", NULL);\n+  /* Fields to add, chained in reverse order.  */\n+  tree fields = NULL_TREE;\n \n-  /* Array, function and enum type_info. No additional fields.  */\n-  create_pseudo_type_info (TK_ARRAY_TYPE, \"__array_type_info\", NULL);\n-  create_pseudo_type_info (TK_FUNCTION_TYPE, \"__function_type_info\", NULL);\n-  create_pseudo_type_info (TK_ENUMERAL_TYPE, \"__enum_type_info\", NULL);\n+  if (ix >= TK_DERIVED_TYPES)\n+    {\n+      /* First field is the pseudo type_info base class.  */\n+      tree fld_base = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t\t  get_tinfo_desc (TK_TYPE_INFO_TYPE)->type);\n \n-  /* Class type_info.  No additional fields.  */\n-  create_pseudo_type_info (TK_CLASS_TYPE, \"__class_type_info\", NULL);\n+      DECL_CHAIN (fld_base) = fields;\n+      fields = fld_base;\n+    }\n \n-  /* Single public non-virtual base class. Add pointer to base class.\n-     This is really a descendant of __class_type_info.  */\n-  create_pseudo_type_info (TK_SI_CLASS_TYPE, \"__si_class_type_info\",\n-\t    build_decl (BUILTINS_LOCATION,\n-\t\t\tFIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\t    NULL);\n+  switch (ix)\n+    {\n+    case TK_TYPE_INFO_TYPE:\n+      {\n+\ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, const_ptr_type_node);\n+\tfields = fld_ptr;\n+\n+\ttree fld_str = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, const_string_type_node);\n+\tDECL_CHAIN (fld_str) = fields;\n+\tfields = fld_str;\n+\tbreak;\n+      }\n \n-  /* Base class internal helper. Pointer to base type, offset to base,\n-     flags.  */\n-  {\n-    tree field, fields;\n+    case TK_BASE_TYPE:\n+      {\n+\t/* Base class internal helper. Pointer to base type, offset to\n+\t   base, flags.  */\n+\ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\tDECL_CHAIN (fld_ptr) = fields;\n+\tfields = fld_ptr;\n+\n+\ttree fld_flag = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t    NULL_TREE, LONGPTR_T);\n+\tDECL_CHAIN (fld_flag) = fields;\n+\tfields = fld_flag;\n+\tbreak;\n+      }\n \n-    field = build_decl (BUILTINS_LOCATION,\n-\t\t\tFIELD_DECL, NULL_TREE, type_info_ptr_type);\n-    fields = field;\n+    case TK_BUILTIN_TYPE:\n+      /* Fundamental type_info */\n+      break;\n \n-    field = build_decl (BUILTINS_LOCATION,\n-\t\t\tFIELD_DECL, NULL_TREE, LONGPTR_T);\n-    DECL_CHAIN (field) = fields;\n-    fields = field;\n+    case TK_ARRAY_TYPE:\n+      break;\n \n-    ti = &(*tinfo_descs)[TK_BASE_TYPE];\n+    case TK_FUNCTION_TYPE:\n+      break;\n \n-    ti->type = make_class_type (RECORD_TYPE);\n-    ti->vtable = NULL_TREE;\n-    ti->name = NULL_TREE;\n-    finish_builtin_struct (ti->type, \"__base_class_type_info_pseudo\",\n-\t\t\t   fields, NULL_TREE);\n-  }\n+    case TK_ENUMERAL_TYPE:\n+      break;\n+\n+    case TK_POINTER_TYPE:\n+    case TK_POINTER_MEMBER_TYPE:\n+      {\n+\t/* Pointer type_info. Adds two fields, qualification mask and\n+\t   pointer to the pointed to type.  This is really a\n+\t   descendant of __pbase_type_info.  */\n+\ttree fld_mask = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t    NULL_TREE, integer_type_node);\n+\tDECL_CHAIN (fld_mask) = fields;\n+\tfields = fld_mask;\n+\n+\ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\tDECL_CHAIN (fld_ptr) = fields;\n+\tfields = fld_ptr;\n+\n+\tif (ix == TK_POINTER_MEMBER_TYPE)\n+\t  {\n+\t    /* Add a pointer to the class too.  */\n+\t    tree fld_cls = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\t    DECL_CHAIN (fld_cls) = fields;\n+\t    fields = fld_cls;\n+\t  }\n+\tbreak;\n+      }\n+\n+    case TK_CLASS_TYPE:\n+      /* Class type_info.  No additional fields.  */\n+      break;\n+\n+    case TK_SI_CLASS_TYPE:\n+      {\n+\t/* Single public non-virtual base class. Add pointer to base\n+\t   class.  This is really a descendant of\n+\t   __class_type_info.  */\n+\ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\tDECL_CHAIN (fld_ptr) = fields;\n+\tfields = fld_ptr;\n+\tbreak;\n+      }\n+\n+    default: /* Multiple inheritance.  */\n+      {\n+\tunsigned num_bases = ix - TK_VMI_CLASS_TYPES + 1;\n+\n+\ttree fld_flg = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, integer_type_node);\n+\tDECL_CHAIN (fld_flg) = fields;\n+\tfields = fld_flg;\n+\t\n+\ttree fld_cnt = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, integer_type_node);\n+\tDECL_CHAIN (fld_cnt) = fields;\n+\tfields = fld_cnt;\n+\n+\t/* Create the array of __base_class_type_info entries.  */\n+\ttree domain = build_index_type (size_int (num_bases - 1));\n+\ttree array = build_array_type (get_tinfo_desc (TK_BASE_TYPE)->type,\n+\t\t\t\t       domain);\n+\ttree fld_ary = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t\t   NULL_TREE, array);\n+\tDECL_CHAIN (fld_ary) = fields;\n+\tfields = fld_ary;\n+\tbreak;\n+      }\n+    }\n+\n+  push_abi_namespace ();\n+\n+  /* Generate the pseudo type name.  */\n+  const char *real_name = tinfo_names[ix < TK_VMI_CLASS_TYPES\n+\t\t\t\t      ? ix : unsigned (TK_VMI_CLASS_TYPES)];\n+  size_t name_len = strlen (real_name);\n+  char *pseudo_name = (char *) alloca (name_len + 30);\n+  memcpy (pseudo_name, real_name, name_len);\n+  /* Those >= TK_VMI_CLASS_TYPES need a discriminator, may as well\n+     apply it to all.  See get_peudo_tinfo_index where we make use of\n+     this.  */\n+  sprintf (pseudo_name + name_len, \"_pseudo_%d\", ix);\n \n-  /* Pointer type_info. Adds two fields, qualification mask\n-     and pointer to the pointed to type.  This is really a descendant of\n-     __pbase_type_info.  */\n-  create_pseudo_type_info (TK_POINTER_TYPE, \"__pointer_type_info\",\n-       build_decl (BUILTINS_LOCATION, \n-\t\t   FIELD_DECL, NULL_TREE, integer_type_node),\n-       build_decl (BUILTINS_LOCATION,\n-\t\t   FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-       NULL);\n-\n-  /* Pointer to member data type_info.  Add qualifications flags,\n-     pointer to the member's type info and pointer to the class.\n-     This is really a descendant of __pbase_type_info.  */\n-  create_pseudo_type_info (TK_POINTER_MEMBER_TYPE,\n-       \"__pointer_to_member_type_info\",\n-\tbuild_decl (BUILTINS_LOCATION,\n-\t\t    FIELD_DECL, NULL_TREE, integer_type_node),\n-\tbuild_decl (BUILTINS_LOCATION,\n-\t\t    FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\tbuild_decl (BUILTINS_LOCATION,\n-\t\t    FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\tNULL);\n+  /* Create the pseudo type.  */\n+  tree pseudo_type = make_class_type (RECORD_TYPE);\n+  /* Pass the fields chained in reverse.  */\n+  finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n+  CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n+\n+  res->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n+  res->name = get_identifier (real_name);\n+\n+  /* Pretend this is public so determine_visibility doesn't give vtables\n+     internal linkage.  */\n+  TREE_PUBLIC (TYPE_MAIN_DECL (res->type)) = 1;\n \n   pop_abi_namespace ();\n+  return res;\n+}\n+\n+/* We lazily create the type info types.  */\n+\n+static void\n+create_tinfo_types (void)\n+{\n+  gcc_assert (!tinfo_descs);\n+\n+  vec_alloc (tinfo_descs, TK_MAX + 20);\n }\n \n /* Helper for emit_support_tinfos. Emits the type_info descriptor of\n@@ -1545,18 +1546,23 @@ emit_support_tinfos (void)\n     0\n   };\n   int ix;\n-  tree bltn_type, dtor;\n \n-  push_abi_namespace ();\n-  bltn_type = xref_tag (class_type,\n-\t\t\tget_identifier (\"__fundamental_type_info\"),\n-\t\t\t/*tag_scope=*/ts_current, false);\n-  pop_abi_namespace ();\n+  /* Look for a defined class.  */\n+  tree bltn_type = lookup_qualified_name\n+    (abi_node, get_identifier (\"__fundamental_type_info\"), true, false, false);\n+  if (TREE_CODE (bltn_type) != TYPE_DECL)\n+    return;\n+\n+  bltn_type = TREE_TYPE (bltn_type);\n   if (!COMPLETE_TYPE_P (bltn_type))\n     return;\n-  dtor = CLASSTYPE_DESTRUCTORS (bltn_type);\n+  tree dtor = CLASSTYPE_DESTRUCTORS (bltn_type);\n   if (!dtor || DECL_EXTERNAL (dtor))\n     return;\n+\n+  /* All these are really builtins.  So set the location.  */\n+  location_t saved_loc = input_location;\n+  input_location = BUILTINS_LOCATION;\n   doing_runtime = 1;\n   for (ix = 0; fundamentals[ix]; ix++)\n     emit_support_tinfo_1 (*fundamentals[ix]);\n@@ -1568,6 +1574,7 @@ emit_support_tinfos (void)\n       }\n   for (tree t = registered_builtin_types; t; t = TREE_CHAIN (t))\n     emit_support_tinfo_1 (TREE_VALUE (t));\n+  input_location = saved_loc;\n }\n \n /* Finish a type info decl. DECL_PTR is a pointer to an unemitted\n@@ -1606,7 +1613,7 @@ emit_tinfo_decl (tree decl)\n       TREE_PUBLIC (decl) = 0;\n       DECL_EXTERNAL (decl) = 0;\n       DECL_INTERFACE_KNOWN (decl) = 1;\n-    }\n+    }u\n \n   import_export_decl (decl);\n   if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))"}]}