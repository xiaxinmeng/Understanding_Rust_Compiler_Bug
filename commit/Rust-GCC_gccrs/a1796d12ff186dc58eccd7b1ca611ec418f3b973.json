{"sha": "a1796d12ff186dc58eccd7b1ca611ec418f3b973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE3OTZkMTJmZjE4NmRjNThlY2NkN2IxY2E2MTFlYzQxOGYzYjk3Mw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-04-26T00:23:18Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-04-26T00:23:18Z"}, "message": "re PR libstdc++/10132 (filebuf destructor throws exceptions)\n\n\n2003-04-25  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/10132\n\t* include/std/std_fstream.h (basic_filebuf::is_open): Add throw()\n\texception specifications.\n\t(basic_filebuf::close): Same.\n\t(basic_filebuf::_M_pback_destroy): Same.\n\t(basic_filebuf::_M_destroy_internal_buffer): Same.\n\t(basic_filebuf): Remove __res_type typedef.\n\t* src/fstream.cc: Same.\n\t* include/bits/fstream.tcc\n\t(basic_filebuf::_M_convert_to_external): Simplify.\n\t(basic_filebuf::seekoff): Use has_facet\tbefore use_facet.\n\t(basic_filebuf::close): Add exception specification of throw().\n\t* testsuite/27_io/basic_filebuf/cons: New.\n\t* testsuite/27_io/basic_filebuf/cons/wchar_t: New.\n\t* testsuite/27_io/basic_filebuf/cons/wchar_t/10132-1.cc: New.\n\t* testsuite/27_io/basic_filebuf/seekoff/10132-2.cc: New.\n\t* testsuite/27_io/basic_filebuf/seekpos/10132-3.cc: New.\n\nFrom-SVN: r66091", "tree": {"sha": "d3624a6ec7bac57ca08a828c936cbfda1b391c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3624a6ec7bac57ca08a828c936cbfda1b391c1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1796d12ff186dc58eccd7b1ca611ec418f3b973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1796d12ff186dc58eccd7b1ca611ec418f3b973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1796d12ff186dc58eccd7b1ca611ec418f3b973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1796d12ff186dc58eccd7b1ca611ec418f3b973/comments", "author": null, "committer": null, "parents": [{"sha": "c21bf638a3db2989a8494406e1756db859e13865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21bf638a3db2989a8494406e1756db859e13865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21bf638a3db2989a8494406e1756db859e13865"}], "stats": {"total": 528, "additions": 447, "deletions": 81}, "files": [{"sha": "c0afcf5d0d12ddc03d42aef04392eb935da5dd10", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -1,3 +1,23 @@\n+2003-04-25  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/10132\n+\t* include/std/std_fstream.h (basic_filebuf::is_open): Add throw()\n+\texception specifications.\n+\t(basic_filebuf::close): Same.\n+\t(basic_filebuf::_M_pback_destroy): Same.\n+\t(basic_filebuf::_M_destroy_internal_buffer): Same.\n+\t(basic_filebuf): Remove __res_type typedef.\t\n+\t* src/fstream.cc: Same.\n+\t* include/bits/fstream.tcc\n+\t(basic_filebuf::_M_convert_to_external): Simplify.\n+\t(basic_filebuf::seekoff): Use has_facet\tbefore use_facet.\n+\t(basic_filebuf::close): Add exception specification of throw().\n+\t* testsuite/27_io/basic_filebuf/cons: New.\n+\t* testsuite/27_io/basic_filebuf/cons/wchar_t: New.\t\n+\t* testsuite/27_io/basic_filebuf/cons/wchar_t/10132-1.cc: New.\t\n+\t* testsuite/27_io/basic_filebuf/seekoff/10132-2.cc: New.\n+\t* testsuite/27_io/basic_filebuf/seekpos/10132-3.cc: New.\n+\n 2003-04-25  Benjamin Kosnik  <bkoz@redhat.com>\n \t\n \t* include/bits/locale_classes.h"}, {"sha": "7a8ae3b2d5a4c38a87342e1d5f724bd3c7b46755", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -60,7 +60,7 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     void\n     basic_filebuf<_CharT, _Traits>::\n-    _M_destroy_internal_buffer()\n+    _M_destroy_internal_buffer() throw()\n     {\n       if (_M_buf_allocated)\n \t{\n@@ -114,40 +114,48 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::__filebuf_type* \n     basic_filebuf<_CharT, _Traits>::\n-    close()\n+    close() throw()\n     {\n       __filebuf_type* __ret = NULL;\n       if (this->is_open())\n \t{\n \t  bool __testfail = false;\n-\t  const int_type __eof = traits_type::eof();\n-\t  const bool __testput = this->_M_out_beg < this->_M_out_lim;\n+\t  try\n+\t    {\n+\t      const int_type __eof = traits_type::eof();\n+\t      const bool __testput = this->_M_out_beg < this->_M_out_lim;\n \n-\t  if (__testput \n-\t      && traits_type::eq_int_type(_M_really_overflow(__eof), __eof))\n-\t    __testfail = true;\n+\t      if (__testput \n+\t\t  && traits_type::eq_int_type(_M_really_overflow(__eof), \n+\t\t\t\t\t      __eof))\n+\t\t__testfail = true;\n \n #if 0\n-\t  // XXX not done\n-\t  if (_M_last_overflowed)\n+\t      // XXX not done\n+\t      if (_M_last_overflowed)\n+\t\t{\n+\t\t  _M_output_unshift();\n+\t\t  _M_really_overflow(__eof);\n+\t\t}\n+#endif\n+\t    }\n+\t  catch(...)\n \t    {\n-\t      _M_output_unshift();\n-\t      _M_really_overflow(__eof);\n+\t      __testfail = true;\n \t    }\n-#endif\n-\n+\t      \n \t  // NB: Do this here so that re-opened filebufs will be cool...\n \t  this->_M_mode = ios_base::openmode(0);\n \t  _M_destroy_internal_buffer();\n \t  _M_pback_destroy();\n-\n+\t  \n \t  if (!_M_file.close())\n \t    __testfail = true;\n \n \t  if (!__testfail)\n \t    __ret = this;\n \t}\n-      _M_last_overflowed = false;\t\n+      _M_last_overflowed = false;\n       return __ret;\n     }\n \n@@ -160,8 +168,7 @@ namespace std\n       const bool __testin = this->_M_mode & ios_base::in;\n       const locale __loc = this->getloc();\n       const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);\n-      // Sync with stdio.\n-      const bool __sync = this->_M_buf_size <= 1;\n+      const bool __testsync = this->_M_buf_size <= 1;\n \n       if (__testin && this->is_open())\n \t{\n@@ -170,7 +177,7 @@ namespace std\n \t  // For a stateful encoding (-1) the pending sequence might be just\n \t  // shift and unshift prefixes with no actual character.\n \t  if (__cvt.encoding() >= 0)\n-\t    __ret += _M_file.showmanyc_helper(__sync) / __cvt.max_length();\n+\t    __ret += _M_file.showmanyc_helper(__testsync) / __cvt.max_length();\n \t}\n \n       _M_last_overflowed = false;\t\n@@ -283,15 +290,14 @@ namespace std\n     _M_convert_to_external(_CharT* __ibuf, streamsize __ilen,\n \t\t\t   streamsize& __elen, streamsize& __plen)\n     {\n+      const bool __testsync = this->_M_buf_size <= 1;\n       const locale __loc = this->getloc();\n       const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);\n-      // Sync with stdio.\n-      const bool __sync = this->_M_buf_size <= 1;\n \n       if (__cvt.always_noconv() && __ilen)\n \t{\n-\t  __elen +=\n-\t    _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen, __sync);\n+\t  __elen += _M_file.xsputn(reinterpret_cast<char*>(__ibuf), \n+\t\t\t\t   __ilen, __testsync);\n \t  __plen += __ilen;\n \t}\n       else\n@@ -304,27 +310,30 @@ namespace std\n \t  char* __buf = static_cast<char*>(__builtin_alloca(__blen));\n \t  char* __bend;\n \t  const char_type* __iend;\n-\t  __res_type __r = __cvt.out(_M_state_cur, __ibuf, __ibuf + __ilen, \n-\t\t \t\t     __iend, __buf, __buf + __blen, __bend);\n-\n+\t  codecvt_base::result __r;\n+\t  __r = __cvt.out(_M_state_cur, __ibuf, __ibuf + __ilen,\n+\t\t\t  __iend, __buf, __buf + __blen, __bend);\n+\t  \n \t  if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n \t    __blen = __bend - __buf;\n-\t  // Similarly to the always_noconv case above.\n \t  else if (__r == codecvt_base::noconv)\n \t    {\n+\t      // Same as the always_noconv case above.\n \t      __buf = reinterpret_cast<char*>(__ibuf);\n \t      __blen = __ilen;\n \t    }\n-\t  // Result == error\n-\t  else \n-\t    __blen = 0;\n+\t  else\n+\t    {\n+\t      // Result == error \n+\t      __blen = 0;\n+\t    }\n \t  \n \t  if (__blen)\n \t    {\n-\t      __elen += _M_file.xsputn(__buf, __blen, __sync);\n+\t      __elen += _M_file.xsputn(__buf, __blen, __testsync);\n \t      __plen += __blen;\n \t    }\n-\n+\t  \n \t  // Try once more for partial conversions.\n \t  if (__r == codecvt_base::partial)\n \t    {\n@@ -333,17 +342,9 @@ namespace std\n \t      __r = __cvt.out(_M_state_cur, __iresume, __iresume + __rlen, \n \t\t\t      __iend, __buf, __buf + __blen, __bend);\n \t      if (__r != codecvt_base::error)\n-\t\t__rlen = __bend - __buf;\n-\t      else\n-\t\t{\n-\t\t  __rlen = 0;\n-\t\t  // Signal to the caller (_M_really_overflow) that\n-\t\t  // codecvt::out eventually failed.\n-\t\t  __elen = 0;\t\t  \n-\t\t}\n-\t      if (__rlen)\n \t\t{\n-\t\t  __elen += _M_file.xsputn(__buf, __rlen, __sync);\n+\t\t  __rlen = __bend - __buf;\n+\t\t  __elen += _M_file.xsputn(__buf, __rlen, __testsync);\n \t\t  __plen += __rlen;\n \t\t}\n \t    }\n@@ -358,8 +359,7 @@ namespace std\n       int_type __ret = traits_type::eof();\n       const bool __testput = this->_M_out_beg < this->_M_out_lim;\n       const bool __testunbuffered = _M_file.is_open() && !this->_M_buf_size;\n-      // Sync with stdio.\n-      const bool __sync = this->_M_buf_size <= 1;\n+      const bool __testsync = this->_M_buf_size <= 1;\n \n       if (__testput || __testunbuffered)\n \t{\n@@ -373,7 +373,7 @@ namespace std\n \t  if (_M_filepos && _M_filepos != this->_M_out_beg)\n \t    {\n \t      off_type __off = this->_M_out_beg - _M_filepos;\n-\t      _M_file.seekoff(__off, ios_base::cur, __sync);\n+\t      _M_file.seekoff(__off, ios_base::cur, __testsync);\n \t    }\n \n \t  // Convert internal buffer to external representation, output.\n@@ -394,7 +394,8 @@ namespace std\n \t\t  char_type __pending = traits_type::to_char_type(__c);\n \t\t  _M_convert_to_external(&__pending, 1, __elen, __plen);\n \n-\t\t  // User code must flush when switching modes (thus don't sync).\n+\t\t  // User code must flush when switching modes (thus\n+\t\t  // don't sync).\n \t\t  if (__elen == __plen && __elen)\n \t\t    {\n \t\t      _M_set_indeterminate();\n@@ -446,15 +447,15 @@ namespace std\n       pos_type __ret =  pos_type(off_type(-1)); \n       const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n       const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n-      // Sync with stdio.\n-      const bool __sync = this->_M_buf_size <= 1;\n+      const bool __testsync = this->_M_buf_size <= 1;\n       \n-      // Should probably do has_facet checks here.\n-      int __width = use_facet<__codecvt_type>(this->_M_buf_locale).encoding();\n+      int __width = 0;\n+      if (has_facet<__codecvt_type>(this->_M_buf_locale))\n+\t  __width = use_facet<__codecvt_type>(this->_M_buf_locale).encoding();\n       if (__width < 0)\n \t__width = 0;\n-      const bool __testfail = __off != 0 && __width <= 0;\n-      \n+\n+      const bool __testfail = __off != 0 && __width <= 0;      \n       if (this->is_open() && !__testfail && (__testin || __testout)) \n \t{\n \t  // Ditch any pback buffers to avoid confusion.\n@@ -480,22 +481,22 @@ namespace std\n \t\t__computed_off += this->_M_in_cur - _M_filepos;\n \n \t      // Return pos_type(off_type(-1)) in case of failure.\n-\t      __ret = _M_file.seekoff(__computed_off, __way, __sync, __mode);\n+\t      __ret = _M_file.seekoff(__computed_off, __way, __testsync, \n+\t\t\t\t      __mode);\n \t      _M_set_indeterminate();\n \t    }\n \t  // NB: Need to do this in case _M_file in indeterminate\n \t  // state, ie _M_file._offset == -1\n \t  else\n \t    {\n-\t      pos_type __tmp =\n-\t\t_M_file.seekoff(__off, ios_base::cur,\n-\t\t\t\t__sync, __mode);\n+\t      pos_type __tmp = _M_file.seekoff(__off, ios_base::cur, \n+\t\t\t\t\t       __testsync, __mode);\n \t      if (__tmp >= 0)\n \t\t{\n \t\t  // Seek successful.\n \t\t  __ret = __tmp;\n-\t\t  __ret +=\n-\t\t    std::max(this->_M_out_cur, this->_M_in_cur) - _M_filepos;\n+\t\t  __ret += std::max(this->_M_out_cur, this->_M_in_cur) \n+\t\t           - _M_filepos;\n \t\t}\n \t    }\n \t}"}, {"sha": "3edfe8d9d24adda45fd9fcbf85f6e8c95cd2dcc9", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -81,7 +81,6 @@ namespace std\n       typedef __basic_file<char>\t\t        __file_type;\n       typedef typename traits_type::state_type          __state_type;\n       typedef codecvt<char_type, char, __state_type>    __codecvt_type;\n-      typedef typename __codecvt_type::result \t        __res_type;\n       typedef ctype<char_type>                          __ctype_type;\n       //@}\n \n@@ -171,7 +170,7 @@ namespace std\n       // Assumptions:\n       // The pback buffer has only moved forward.\n       void\n-      _M_pback_destroy()\n+      _M_pback_destroy() throw()\n       {\n \tif (_M_pback_init)\n \t  {\n@@ -218,7 +217,7 @@ namespace std\n        *  @brief  Returns true if the external file is open.\n       */\n       bool\n-      is_open() const { return _M_file.is_open(); }\n+      is_open() const throw() { return _M_file.is_open(); }\n \n       /**\n        *  @brief  Opens an external file.\n@@ -248,7 +247,7 @@ namespace std\n        *  If any operations fail, this function also fails.\n       */\n       __filebuf_type*\n-      close();\n+      close() throw();\n \n     protected:\n       /**\n@@ -265,7 +264,7 @@ namespace std\n        *  @endif\n       */\n       void\n-      _M_destroy_internal_buffer();\n+      _M_destroy_internal_buffer() throw();\n \n       // [27.8.1.4] overridden virtual functions\n       // [documentation is inherited]"}, {"sha": "458e59d94ce1e52027147777fd976c6617353284", "filename": "libstdc++-v3/src/fstream.cc", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffstream.cc?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -43,8 +43,7 @@ namespace std\n       int_type __ret = traits_type::eof();\n       const bool __testin = _M_mode & ios_base::in;\n       const bool __testout = _M_mode & ios_base::out;\n-      // Sync with stdio.\n-      const bool __sync = _M_buf_size <= 1;\n+      const bool __testsync = _M_buf_size <= 1;\n \n       if (__testin)\n \t{\n@@ -72,7 +71,7 @@ namespace std\n \t\t_M_really_overflow();\n \t      else if (_M_in_cur != _M_filepos)\n \t\t_M_file.seekoff(_M_in_cur - _M_filepos,\n-\t\t\t\tios_base::cur, __sync, ios_base::in);\n+\t\t\t\tios_base::cur, __testsync, ios_base::in);\n \t    }\n \n \t  if (__testinit || __testget)\n@@ -81,7 +80,7 @@ namespace std\n \t      streamsize __ilen = 0;\n \n \t      __elen = _M_file.xsgetn(reinterpret_cast<char*>(_M_in_beg), \n-\t\t\t\t      _M_buf_size, __sync);\n+\t\t\t\t      _M_buf_size, __testsync);\n \t      __ilen = __elen;\n \n \t      if (0 < __ilen)\n@@ -92,7 +91,7 @@ namespace std\n \t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n \t\t  if (__bump)\n \t\t    _M_in_cur_move(1);\n-\t\t  else if (__sync)\n+\t\t  else if (__testsync)\n \t\t    {\n \t\t      // If we are synced with stdio, we have to unget the\n \t\t      // character we just read so that the file pointer\n@@ -125,8 +124,7 @@ namespace std\n       int_type __ret = traits_type::eof();\n       const bool __testin = _M_mode & ios_base::in;\n       const bool __testout = _M_mode & ios_base::out;\n-      // Sync with stdio.\n-      const bool __sync = _M_buf_size <= 1;\n+      const bool __testsync = _M_buf_size <= 1;\n \n       if (__testin)\n \t{\n@@ -154,39 +152,39 @@ namespace std\n \t\t_M_really_overflow();\n \t      else if (_M_in_cur != _M_filepos)\n \t\t_M_file.seekoff(_M_in_cur - _M_filepos,\n-\t\t\t\t  ios_base::cur, __sync, ios_base::in);\n+\t\t\t\tios_base::cur, __testsync, ios_base::in);\n \t    }\n \n \t  if (__testinit || __testget)\n \t    {\n-\t      const locale __loc = this->getloc();\n-\t      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc); \n-\n \t      streamsize __elen = 0;\n \t      streamsize __ilen = 0;\n+\t      const locale __loc = this->getloc();\n+\t      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);\n \t      if (__cvt.always_noconv())\n \t\t{\n \t\t  __elen = _M_file.xsgetn(reinterpret_cast<char*>(_M_in_beg), \n-\t\t\t\t\t  _M_buf_size, __sync);\n+\t\t\t\t\t  _M_buf_size, __testsync);\n \t\t  __ilen = __elen;\n \t\t}\n \t      else\n \t\t{\n \t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size));\n-\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size, __sync);\n-\n+\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size, __testsync);\n+\t\t  \n \t\t  const char* __eend;\n \t\t  char_type* __iend;\n-\t\t  __res_type __r = __cvt.in(_M_state_cur, __buf, \n-\t\t\t\t\t    __buf + __elen, __eend, _M_in_beg, \n-\t\t\t\t\t    _M_in_beg + _M_buf_size, __iend);\n+\t\t  codecvt_base::result __r;\n+\t\t  __r = __cvt.in(_M_state_cur, __buf, __buf + __elen, __eend, \n+\t\t\t\t _M_in_beg, _M_in_beg + _M_buf_size, __iend);\n \t\t  if (__r == codecvt_base::ok)\n \t\t    __ilen = __iend - _M_in_beg;\n \t\t  else \n \t\t    {\n \t\t      // Unwind.\n \t\t      __ilen = 0;\n-\t\t      _M_file.seekoff(-__elen, ios_base::cur, __sync, ios_base::in);\n+\t\t      _M_file.seekoff(-__elen, ios_base::cur, __testsync, \n+\t\t\t\t      ios_base::in);\n \t\t    }\n \t\t}\n \n@@ -198,7 +196,7 @@ namespace std\n \t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n \t\t  if (__bump)\n \t\t    _M_in_cur_move(1);\n-\t\t  else if (__sync)\n+\t\t  else if (__testsync)\n \t\t    {\n \t\t      // If we are synced with stdio, we have to unget the\n \t\t      // character we just read so that the file pointer"}, {"sha": "c25e0021532c3effeb31b9f5d24635d3efafa560", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/cons/wchar_t/10132-1.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fcons%2Fwchar_t%2F10132-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fcons%2Fwchar_t%2F10132-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fcons%2Fwchar_t%2F10132-1.cc?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -0,0 +1,54 @@\n+// 2003-04-24 P\ufffdtur Run\ufffdlfsson <peturr02@ru.is>\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <fstream>\n+#include <locale>\n+#include <stdexcept>\n+#include <testsuite_hooks.h>\n+\n+class Cvt : public std::codecvt<wchar_t, char, std::mbstate_t>\n+{\n+protected:\n+  virtual std::codecvt_base::result\n+  do_out(std::mbstate_t&, const wchar_t*, const wchar_t*, const wchar_t*&, \n+\t char*, char*, char*&) const\n+  { throw std::runtime_error(\"codecvt failed\"); }\n+};\n+\n+int main()\n+{\n+  using namespace std;\n+  bool test = true;\n+\n+  locale loc = locale(locale::classic(), new Cvt);\n+  wfilebuf* fb = new wfilebuf;\n+  fb->pubimbue(loc);\n+  fb->open(\"tmp_10132\", ios_base::out);\n+  fb->sputc(L'a');\n+  \n+  try\n+    {\n+      delete fb;\n+    }\n+  catch(exception& obj)\n+    {\n+      VERIFY( false ); \n+    }\n+  return 0;\n+}"}, {"sha": "e1628c4a8844fc6b03d05e892b04fc2a2bb537fb", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/10132-2.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekoff%2F10132-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekoff%2F10132-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekoff%2F10132-2.cc?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -0,0 +1,147 @@\n+// 2003-04-24 bkoz\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.1 - Template class basic_filebuf \n+// NB: This file is for testing basic_filebuf with NO OTHER INCLUDES.\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/10132, add on\n+class gnu_char_type\n+{\n+  unsigned long character;\n+public:\n+  // operator ==\n+  bool\n+  operator==(const gnu_char_type& __lhs) \n+  { return character == __lhs.character; }\n+\n+  // operator <\n+  bool\n+  operator<(const gnu_char_type& __lhs) \n+  { return character < __lhs.character; }\n+\n+  // default ctor\n+  gnu_char_type() { }\n+\n+  // to_char_type\n+  gnu_char_type(const unsigned long& __l) : character(__l) { } \n+\n+  // to_int_type\n+  operator unsigned long() const { return character; }\n+};\n+\n+// char_traits specialization\n+struct gnu_char_traits\n+{\n+  typedef gnu_char_type\tchar_type;\n+  typedef long  \t\tint_type;\n+  typedef long \t\tpos_type;\n+  typedef unsigned long \toff_type;\n+  typedef long   \t\tstate_type;\n+  \n+  static void \n+  assign(char_type& __c1, const char_type& __c2) { }\n+  \n+  static bool \n+  eq(const char_type& __c1, const char_type& __c2) { return true; }\n+  \n+  static bool \n+  lt(const char_type& __c1, const char_type& __c2) { return true; }\n+  \n+  static int \n+  compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+  { return 0; }\n+  \n+  static size_t\n+  length(const char_type* __s) { return 0; }\n+  \n+  static const char_type* \n+  find(const char_type* __s, size_t __n, const char_type& __a)\n+  { return __s; }\n+  \n+  static char_type* \n+  move(char_type* __s1, const char_type* __s2, size_t __n)\n+  { return __s1; }\n+  \n+  static char_type* \n+  copy(char_type* __s1, const char_type* __s2, size_t __n)\n+  { return __s1; }\n+  \n+  static char_type* \n+  assign(char_type* __s, size_t __n, char_type __a)\n+  { return __s; }\n+  \n+  static char_type \n+  to_char_type(const int_type& __c)\n+  { return char_type(); }\n+  \n+  static int_type \n+  to_int_type(const char_type& __c)\n+  { return int_type(); }\n+  \n+  static bool \n+  eq_int_type(const int_type& __c1, const int_type& __c2)\n+  { return true; }\n+  \n+  static int_type \n+  eof()\n+  { return int_type(); }\n+  \n+  static int_type \n+  not_eof(const int_type& __c)\n+  { return int_type(); }\n+};\n+\n+void test07()\n+{\n+  bool test = true;\n+  typedef std::basic_filebuf<gnu_char_type, gnu_char_traits> gnu_filebuf;\n+  \n+  try\n+    { \n+      // Need codecvt facet for width argument in seekoff.\n+      gnu_filebuf obj;\n+      obj.pubseekoff(2, std::ios_base::beg);\n+    }\n+  catch(std::exception& obj)\n+    { \n+      test = false; \n+      VERIFY( test );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_filebuf<gnu_char_type>::int_type\n+  std::basic_filebuf<gnu_char_type>::_S_pback_size;\n+#endif\n+\n+int main() \n+{\n+  test07();\n+  return 0;\n+}\n+\n+\n+\n+// more surf!!!"}, {"sha": "0f1ee2e1d6148d196cf311b5309cf94f00e47583", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/seekpos/10132-3.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekpos%2F10132-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1796d12ff186dc58eccd7b1ca611ec418f3b973/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekpos%2F10132-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fseekpos%2F10132-3.cc?ref=a1796d12ff186dc58eccd7b1ca611ec418f3b973", "patch": "@@ -0,0 +1,147 @@\n+// 2003-04-24 bkoz\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.1 - Template class basic_filebuf \n+// NB: This file is for testing basic_filebuf with NO OTHER INCLUDES.\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/10132, add on\n+class gnu_char_type\n+{\n+  unsigned long character;\n+public:\n+  // operator ==\n+  bool\n+  operator==(const gnu_char_type& __lhs) \n+  { return character == __lhs.character; }\n+\n+  // operator <\n+  bool\n+  operator<(const gnu_char_type& __lhs) \n+  { return character < __lhs.character; }\n+\n+  // default ctor\n+  gnu_char_type() { }\n+\n+  // to_char_type\n+  gnu_char_type(const unsigned long& __l) : character(__l) { } \n+\n+  // to_int_type\n+  operator unsigned long() const { return character; }\n+};\n+\n+// char_traits specialization\n+struct gnu_char_traits\n+{\n+  typedef gnu_char_type\tchar_type;\n+  typedef long  \t\tint_type;\n+  typedef long \t\tpos_type;\n+  typedef unsigned long \toff_type;\n+  typedef long   \t\tstate_type;\n+  \n+  static void \n+  assign(char_type& __c1, const char_type& __c2) { }\n+  \n+  static bool \n+  eq(const char_type& __c1, const char_type& __c2) { return true; }\n+  \n+  static bool \n+  lt(const char_type& __c1, const char_type& __c2) { return true; }\n+  \n+  static int \n+  compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+  { return 0; }\n+  \n+  static size_t\n+  length(const char_type* __s) { return 0; }\n+  \n+  static const char_type* \n+  find(const char_type* __s, size_t __n, const char_type& __a)\n+  { return __s; }\n+  \n+  static char_type* \n+  move(char_type* __s1, const char_type* __s2, size_t __n)\n+  { return __s1; }\n+  \n+  static char_type* \n+  copy(char_type* __s1, const char_type* __s2, size_t __n)\n+  { return __s1; }\n+  \n+  static char_type* \n+  assign(char_type* __s, size_t __n, char_type __a)\n+  { return __s; }\n+  \n+  static char_type \n+  to_char_type(const int_type& __c)\n+  { return char_type(); }\n+  \n+  static int_type \n+  to_int_type(const char_type& __c)\n+  { return int_type(); }\n+  \n+  static bool \n+  eq_int_type(const int_type& __c1, const int_type& __c2)\n+  { return true; }\n+  \n+  static int_type \n+  eof()\n+  { return int_type(); }\n+  \n+  static int_type \n+  not_eof(const int_type& __c)\n+  { return int_type(); }\n+};\n+\n+void test07()\n+{\n+  bool test = true;\n+  typedef std::basic_filebuf<gnu_char_type, gnu_char_traits> gnu_filebuf;\n+  \n+  try\n+    { \n+      // Need codecvt facet for width argument in seekpos.\n+      gnu_filebuf obj;\n+      obj.pubseekpos(0);\n+    }\n+  catch(std::exception& obj)\n+    { \n+      test = false; \n+      VERIFY( test );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_filebuf<gnu_char_type>::int_type\n+  std::basic_filebuf<gnu_char_type>::_S_pback_size;\n+#endif\n+\n+int main() \n+{\n+  test07();\n+  return 0;\n+}\n+\n+\n+\n+// more surf!!!"}]}