{"sha": "648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4YmIxNTkxMmMyMGRjYzFhNjAxYmQwZjdjMzVhOGNkYjI2YmJkZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-27T07:05:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-27T07:05:18Z"}, "message": "calls.c (initialize_argument_information): If an argument has no stack space associated with it...\n\n\t* calls.c (initialize_argument_information): If an argument has no\n\tstack space associated with it, and BLOCK_REG_PADDING is defined,\n\tuse it to decide at which end the argument should be padded.\n\t* function.c (assign_parms): Allocate BLKmode stack slots.\n\t* config/mips/mips-protos.h (mips_pad_arg_upward): Declare.\n\t(mips_pad_reg_upward): Declare.\n\t* config/mips/mips.h (PAD_VARARGS_DOWN): Use FUNCTION_ARG_PADDING.\n\t(CUMULATIVE_ARGS): Remove num_adjusts and adjusts.\n\t(FUNCTION_ARG_PADDING): Use mips_pad_arg_upward.\n\t(BLOCK_REG_PADDING): Use mips_pad_reg_upward.\n\t* config/mips/mips.c (struct mips_arg_info): Remove struct_p.\n\t(mips_expand_call): Remove code for generating structure shifts.\n\t(mips_arg_info): Don't set struct_p.  Don't set fpr_p for non-float\n\ttypes unless using the EABI.\n\t(function_arg_advance): Don't generate shift instructions.\n\t(function_arg): Don't return them.  Don't short-circuit the\n\tcheck for double structure chunks for DFmode arguments.\n\t(mips_pad_arg_upward, mips_pad_reg_upward): New functions.\n\t(mips_expand_prologue): Remove code to emit structure shifts.\n\t* config/mips/irix6-libc-compat.c: Remove workarounds for buggy\n\tstructure passing (inet_ntoa, inet_lnaof, inet_netof).  Update\n\tcomments to say that only structure returns are a problem.\n\nFrom-SVN: r70843", "tree": {"sha": "4fb176f0e3f8d0be12e1b3e8dc88d2e5e55ee7b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fb176f0e3f8d0be12e1b3e8dc88d2e5e55ee7b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/comments", "author": null, "committer": null, "parents": [{"sha": "0c7829a97b309d2290ce83d0d1c2a9e23b9dec2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7829a97b309d2290ce83d0d1c2a9e23b9dec2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c7829a97b309d2290ce83d0d1c2a9e23b9dec2e"}], "stats": {"total": 339, "additions": 122, "deletions": 217}, "files": [{"sha": "ef8624fef175415892af989b9fd0c7d6506db07f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -1,3 +1,28 @@\n+2003-08-27  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* calls.c (initialize_argument_information): If an argument has no\n+\tstack space associated with it, and BLOCK_REG_PADDING is defined,\n+\tuse it to decide at which end the argument should be padded.\n+\t* function.c (assign_parms): Allocate BLKmode stack slots.\n+\t* config/mips/mips-protos.h (mips_pad_arg_upward): Declare.\n+\t(mips_pad_reg_upward): Declare.\n+\t* config/mips/mips.h (PAD_VARARGS_DOWN): Use FUNCTION_ARG_PADDING.\n+\t(CUMULATIVE_ARGS): Remove num_adjusts and adjusts.\n+\t(FUNCTION_ARG_PADDING): Use mips_pad_arg_upward.\n+\t(BLOCK_REG_PADDING): Use mips_pad_reg_upward.\n+\t* config/mips/mips.c (struct mips_arg_info): Remove struct_p.\n+\t(mips_expand_call): Remove code for generating structure shifts.\n+\t(mips_arg_info): Don't set struct_p.  Don't set fpr_p for non-float\n+\ttypes unless using the EABI.\n+\t(function_arg_advance): Don't generate shift instructions.\n+\t(function_arg): Don't return them.  Don't short-circuit the\n+\tcheck for double structure chunks for DFmode arguments.\n+\t(mips_pad_arg_upward, mips_pad_reg_upward): New functions.\n+\t(mips_expand_prologue): Remove code to emit structure shifts.\n+\t* config/mips/irix6-libc-compat.c: Remove workarounds for buggy\n+\tstructure passing (inet_ntoa, inet_lnaof, inet_netof).  Update\n+\tcomments to say that only structure returns are a problem.\n+\n 2003-08-26  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* fixinc/tests/base/string.h, fixinc/tests/base/sys/regset.h:"}, {"sha": "50fa592972a55bfd5ccdad2056b37a00e04b7a0b", "filename": "gcc/calls.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -1238,6 +1238,14 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n #endif\n \t\t\t     args[i].pass_on_stack ? 0 : args[i].partial,\n \t\t\t     fndecl, args_size, &args[i].locate);\n+#ifdef BLOCK_REG_PADDING\n+      else\n+\t/* The argument is passed entirely in registers.  See at which\n+\t   end it should be padded.  */\n+\targs[i].locate.where_pad =\n+\t  BLOCK_REG_PADDING (mode, type,\n+\t\t\t     int_size_in_bytes (type) <= UNITS_PER_WORD);\n+#endif\n \n       /* Update ARGS_SIZE, the total stack space for args so far.  */\n "}, {"sha": "59a148aa865fe45da670bd3789f235fcf3757f03", "filename": "gcc/config/mips/irix6-libc-compat.c", "status": "modified", "additions": 9, "deletions": 75, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -1,4 +1,4 @@\n-/* Compensate for inconsistent structure passing conventions on IRIX 6.  */\n+/* Compensate for inconsistent structure return conventions on IRIX 6.  */\n /* Compile this one with gcc.  */\n /* Copyright (C) 2001  Free Software Foundation, Inc.\n \n@@ -28,7 +28,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* GCC doesn't correctly implement the structure and union passing and return\n+/* GCC doesn't correctly implement the structure and union return\n    conventions of the N32 and N64 ABIs on IRIX 6, as described in the\n    MIPSpro N32 ABI Handbook, ch. 2, Calling Convention Implementations, p.7.\n    The ABI requires that structures (or trailing parts of structures) smaller\n@@ -38,17 +38,15 @@ Boston, MA 02111-1307, USA.  */\n    While GCC is internally consistent, calling routines compiled with a\n    compiler that does implement the documented ABI (like SGIs MIPSpro C\n    compiler) doesn't work.  This is primarily an issue for system libraries\n-   like libc.  Fortunately, there exist only very few routines that take\n-   structure value arguments or return structures by value, so until the\n-   underlying bug is fixed, it is possible to work around it by providing\n-   wrapper functions for the few affected routines that compensate for the\n-   inconsistent alignment.\n+   like libc.  Fortunately, there exist only very few routines that return\n+   structures by value, so until the underlying bug is fixed, it is possible\n+   to work around it by providing wrappers for the few affected routines.\n \n    These wrappers rely on the fact that e.g. libc contains weak versions of\n    those routines, and the real implementation is provided by _-prefixed\n    variants.  So we can provide our own versions, which will only be linked\n    if the application uses any of the affected functions, calling the private\n-   variants after shifting the arguments or results as required.\n+   variants and then shifting the result as required.\n \n    This is a rewrite of code created by Andy Polyakov.  */\n \n@@ -61,60 +59,15 @@ Boston, MA 02111-1307, USA.  */\n \n #if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64\n \n-/* The affected arguments need to be shifted by\n+/* The affected return values need to be shifted by\n \n-\tBITS_PER_WORD - (sizeof (arg) * BITS_PER_UNIT).\n+\tBITS_PER_WORD - (sizeof (value) * BITS_PER_UNIT).\n \n-   Since only 32-bit args and results are involved, the shift count is\n-   always 32.  */\n+   Since only 32-bit results are involved, the shift count is always 32.  */\n #define SHIFT_BITS\t32\n \n-extern machreg_t inet_ntoa (machreg_t);\n-extern machreg_t inet_lnaof (machreg_t);\n-extern machreg_t inet_netof (machreg_t);\n-extern machreg_t inet_makeaddr (machreg_t, machreg_t);\n-\n-extern machreg_t _inet_ntoa (machreg_t);\n-extern machreg_t _inet_lnaof (machreg_t);\n-extern machreg_t _inet_netof (machreg_t);\n extern machreg_t _inet_makeaddr (machreg_t, machreg_t);\n \n-/* <arpa/inet.h> has\n-\n-\tchar *inet_ntoa (struct in_addr);\n-\n-   on both IRIX 6.2 and 6.5, with struct in_addr containing a 32-bit int.  */\n-\n-machreg_t\n-inet_ntoa (machreg_t in)\n-{\n-  return _inet_ntoa (in << SHIFT_BITS);\n-}\n-\n-/* <arpa/inet.h> has\n-\n-\tunsigned long inet_lnaof (struct in_addr);\t\t(IRIX 6.2)\n-\tin_addr_t inet_lnaof (struct in_addr);\t\t\t(IRIX 6.5)\n-\n-   in_addr_t is a 32-bit int.  */\n-\n-machreg_t\n-inet_lnaof (machreg_t in)\n-{\n-  return _inet_lnaof (in << SHIFT_BITS);\n-}\n-\n-/* <arpa/inet.h> has\n-\n-\tunsigned long inet_netof (struct in_addr);\t\t(IRIX 6.2)\n-\tin_addr_t inet_netof (struct in_addr);\t\t\t(IRIX 6.5)  */\n-\n-machreg_t\n-inet_netof (machreg_t in)\n-{\n-  return _inet_netof (in << SHIFT_BITS);\n-}\n-\n /* <arpa/inet.h> has\n \n \tstruct in_addr inet_makeaddr (int, int);\t\t(IRIX 6.2)\n@@ -126,23 +79,4 @@ inet_makeaddr (machreg_t net, machreg_t lna)\n   return _inet_makeaddr (net, lna) >> SHIFT_BITS;\n }\n \n-#if _MIPS_SIM == _ABIN32\n-extern machreg_t semctl (machreg_t, machreg_t, machreg_t, machreg_t);\n-extern machreg_t _semctl (machreg_t, machreg_t, machreg_t, machreg_t);\n-\n-/* <sys/sem.h> has\n-\n-\tint semctl (int, int, int, ...);\n-\n-   where the variadic argument is union semun if used.  union semun contains\n-   an int and two pointers, so the union is already 64 bits wide under the\n-   N64 ABI and alignment is not an issue.  */\n-\n-machreg_t\n-semctl (machreg_t semid, machreg_t semnum, machreg_t cmd, machreg_t arg)\n-{\n-  return _semctl(semid, semnum, cmd, arg << SHIFT_BITS);\n-}\n-#endif /* _ABIN32 */\n-\n #endif /* _ABIN32 || _ABI64 */"}, {"sha": "89a8cb2a4208387e048ec14452fe0123bb8a88f2", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -80,6 +80,8 @@ extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int);\n extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n \t\t\t\t       enum machine_mode, tree, int);\n+extern bool mips_pad_arg_upward (enum machine_mode, tree);\n+extern bool mips_pad_reg_upward (enum machine_mode, tree);\n extern int mips_setup_incoming_varargs (const CUMULATIVE_ARGS *,\n \t\t\t\t\tenum machine_mode, tree, int);\n extern tree mips_build_va_list (void);"}, {"sha": "37fd534302c829ec4a243bdebcb7ba0d0317bee0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 69, "deletions": 115, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -317,9 +317,6 @@ struct machine_function GTY(()) {\n /* Information about a single argument.  */\n struct mips_arg_info\n {\n-  /* True if the argument is a record or union type.  */\n-  bool struct_p;\n-\n   /* True if the argument is passed in a floating-point register, or\n      would have been if we hadn't run out of registers.  */\n   bool fpr_p;\n@@ -3208,8 +3205,6 @@ mips_gen_conditional_trap (rtx *operands)\n void\n mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n {\n-  int i;\n-\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n       /* When generating PIC, try to allow global functions to be\n@@ -3226,16 +3221,6 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n       addr = force_reg (Pmode, addr);\n     }\n \n-  /* In order to pass small structures by value in registers\n-     compatibly with the MIPS compiler, we need to shift the value\n-     into the high part of the register.  Function_arg has encoded\n-     a PARALLEL rtx, holding a vector of adjustments to be made\n-     as the next_arg_reg variable, so we split up the insns,\n-     and emit them separately.  */\n-  if (aux != 0 && GET_CODE (aux) == PARALLEL)\n-    for (i = 0; i < XVECLEN (aux, 0); i++)\n-      emit_insn (XVECEXP (aux, 0, i));\n-\n   if (TARGET_MIPS16\n       && mips16_hard_float\n       && build_mips16_call_stub (result, addr, args_size,\n@@ -3557,34 +3542,27 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   bool even_reg_p;\n   unsigned int num_words, max_regs;\n \n-  info->struct_p = (type != 0\n-\t\t    && (TREE_CODE (type) == RECORD_TYPE\n-\t\t\t|| TREE_CODE (type) == UNION_TYPE\n-\t\t\t|| TREE_CODE (type) == QUAL_UNION_TYPE));\n-\n   /* Decide whether this argument should go in a floating-point register,\n      assuming one is free.  Later code checks for availability.  */\n \n-  info->fpr_p = false;\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE)\n-    {\n-      switch (mips_abi)\n-\t{\n-\tcase ABI_32:\n-\tcase ABI_O64:\n-\t  info->fpr_p = (!cum->gp_reg_found && cum->arg_number < 2);\n-\t  break;\n+  info->fpr_p = (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n \n-\tcase ABI_EABI:\n-\t  info->fpr_p = true;\n-\t  break;\n+  if (info->fpr_p)\n+    switch (mips_abi)\n+      {\n+      case ABI_32:\n+      case ABI_O64:\n+\tinfo->fpr_p = (!cum->gp_reg_found\n+\t\t       && cum->arg_number < 2\n+\t\t       && (type == 0 || FLOAT_TYPE_P (type)));\n+\tbreak;\n \n-\tdefault:\n-\t  info->fpr_p = named;\n-\t  break;\n-\t}\n-    }\n+      case ABI_N32:\n+      case ABI_64:\n+\tinfo->fpr_p = (named && (type == 0 || FLOAT_TYPE_P (type)));\n+\tbreak;\n+      }\n \n   /* Now decide whether the argument must go in an even-numbered register.  */\n \n@@ -3648,36 +3626,6 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   mips_arg_info (cum, mode, type, named, &info);\n \n-  /* The following is a hack in order to pass 1 byte structures\n-     the same way that the MIPS compiler does (namely by passing\n-     the structure in the high byte or half word of the register).\n-     This also makes varargs work.  If we have such a structure,\n-     we save the adjustment RTL, and the call define expands will\n-     emit them.  For the VOIDmode argument (argument after the\n-     last real argument), pass back a parallel vector holding each\n-     of the adjustments.  */\n-\n-  /* ??? This scheme requires everything smaller than the word size to\n-     shifted to the left, but when TARGET_64BIT and ! TARGET_INT64,\n-     that would mean every int needs to be shifted left, which is very\n-     inefficient.  Let's not carry this compatibility to the 64 bit\n-     calling convention for now.  */\n-\n-  if (info.struct_p\n-      && info.reg_words == 1\n-      && info.num_bytes < UNITS_PER_WORD\n-      && !TARGET_64BIT\n-      && mips_abi != ABI_EABI)\n-    {\n-      rtx amount = GEN_INT (BITS_PER_WORD - info.num_bytes * BITS_PER_UNIT);\n-      rtx reg = gen_rtx_REG (word_mode, GP_ARG_FIRST + info.reg_offset);\n-\n-      if (TARGET_64BIT)\n-\tcum->adjust[cum->num_adjusts++] = PATTERN (gen_ashldi3 (reg, reg, amount));\n-      else\n-\tcum->adjust[cum->num_adjusts++] = PATTERN (gen_ashlsi3 (reg, reg, amount));\n-    }\n-\n   if (!info.fpr_p)\n     cum->gp_reg_found = true;\n \n@@ -3708,18 +3656,11 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   /* We will be called with a mode of VOIDmode after the last argument\n      has been seen.  Whatever we return will be passed to the call\n-     insn.  If we need any shifts for small structures, return them in\n-     a PARALLEL; in that case, stuff the mips16 fp_code in as the\n-     mode.  Otherwise, if we need a mips16 fp_code, return a REG\n-     with the code stored as the mode.  */\n+     insn.  If we need a mips16 fp_code, return a REG with the code\n+     stored as the mode.  */\n   if (mode == VOIDmode)\n     {\n-      if (cum->num_adjusts > 0)\n-\treturn gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,\n-\t\t\t\t gen_rtvec_v (cum->num_adjusts,\n-\t\t\t\t\t      (rtx *) cum->adjust));\n-\n-      else if (TARGET_MIPS16 && cum->fp_code != 0)\n+      if (TARGET_MIPS16 && cum->fp_code != 0)\n \treturn gen_rtx_REG ((enum machine_mode) cum->fp_code, 0);\n \n       else\n@@ -3737,8 +3678,7 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && (mips_abi == ABI_N32 || mips_abi == ABI_64)\n       && TYPE_SIZE_UNIT (type)\n       && host_integerp (TYPE_SIZE_UNIT (type), 1)\n-      && named\n-      && mode != DFmode)\n+      && named)\n     {\n       /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n \t structure contains a double in its entirety, then that 64 bit\n@@ -3815,6 +3755,55 @@ function_arg_partial_nregs (const CUMULATIVE_ARGS *cum,\n   mips_arg_info (cum, mode, type, named, &info);\n   return info.stack_words > 0 ? info.reg_words : 0;\n }\n+\n+\n+/* Return true if FUNCTION_ARG_PADDING (MODE, TYPE) should return\n+   upward rather than downward.  In other words, return true if the\n+   first byte of the stack slot has useful data, false if the last\n+   byte does.  */\n+\n+bool\n+mips_pad_arg_upward (enum machine_mode mode, tree type)\n+{\n+  /* On little-endian targets, the first byte of every stack argument\n+     is passed in the first byte of the stack slot.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    return true;\n+\n+  /* Otherwise, integral types are padded downward: the last byte of a\n+     stack argument is passed in the last byte of the stack slot.  */\n+  if (type != 0\n+      ? INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)\n+      : GET_MODE_CLASS (mode) == MODE_INT)\n+    return false;\n+\n+  /* Other types are padded upward for o32, o64, n32 and n64.  */\n+  if (mips_abi != ABI_EABI)\n+    return true;\n+\n+  /* Arguments smaller than a stack slot are padded downward.  */\n+  if (mode != BLKmode)\n+    return (GET_MODE_BITSIZE (mode) >= PARM_BOUNDARY);\n+  else\n+    return (int_size_in_bytes (type) >= (PARM_BOUNDARY / BITS_PER_UNIT));\n+}\n+\n+\n+/* Likewise BLOCK_REG_PADDING (MODE, TYPE, ...).  Return !BYTES_BIG_ENDIAN\n+   if the least significant byte of the register has useful data.  Return\n+   the opposite if the most significant byte does.  */\n+\n+bool\n+mips_pad_reg_upward (enum machine_mode mode, tree type)\n+{\n+  /* No shifting is required for floating-point arguments.  */\n+  if (type != 0 ? FLOAT_TYPE_P (type) : GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return !BYTES_BIG_ENDIAN;\n+\n+  /* Otherwise, apply the same padding to register arguments as we do\n+     to stack arguments.  */\n+  return mips_pad_arg_upward (mode, type);\n+}\n \f\n int\n mips_setup_incoming_varargs (const CUMULATIVE_ARGS *cum,\n@@ -6716,8 +6705,6 @@ mips_expand_prologue (void)\n   tree fndecl = current_function_decl;\n   tree fntype = TREE_TYPE (fndecl);\n   tree fnargs = DECL_ARGUMENTS (fndecl);\n-  rtx next_arg_reg;\n-  int i;\n   tree cur_arg;\n   CUMULATIVE_ARGS args_so_far;\n   rtx reg_18_save = NULL_RTX;\n@@ -6757,39 +6744,6 @@ mips_expand_prologue (void)\n       FUNCTION_ARG_ADVANCE (args_so_far, passed_mode, passed_type, 1);\n     }\n \n-  /* In order to pass small structures by value in registers compatibly with\n-     the MIPS compiler, we need to shift the value into the high part of the\n-     register.  Function_arg has encoded a PARALLEL rtx, holding a vector of\n-     adjustments to be made as the next_arg_reg variable, so we split up the\n-     insns, and emit them separately.  */\n-\n-  next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n-  if (next_arg_reg != 0 && GET_CODE (next_arg_reg) == PARALLEL)\n-    {\n-      rtvec adjust = XVEC (next_arg_reg, 0);\n-      int num = GET_NUM_ELEM (adjust);\n-\n-      for (i = 0; i < num; i++)\n-\t{\n-\t  rtx insn, pattern;\n-\n-\t  pattern = RTVEC_ELT (adjust, i);\n-\t  if (GET_CODE (pattern) != SET\n-\t      || GET_CODE (SET_SRC (pattern)) != ASHIFT)\n-\t    fatal_insn (\"insn is not a shift\", pattern);\n-\t  PUT_CODE (SET_SRC (pattern), ASHIFTRT);\n-\n-\t  insn = emit_insn (pattern);\n-\n-\t  /* Global life information isn't valid at this point, so we\n-\t     can't check whether these shifts are actually used.  Mark\n-\t     them MAYBE_DEAD so that flow2 will remove them, and not\n-\t     complain about dead code in the prologue.  */\n-\t  REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-\t\t\t\t\t       REG_NOTES (insn));\n-\t}\n-    }\n-\n   tsize = compute_frame_size (get_frame_size ());\n \n   /* If we are using the entry pseudo instruction, it will"}, {"sha": "949fc746b01b86cea8b861e3c899b96bd2360af1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -1399,9 +1399,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n \t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n \n \n-/* Force right-alignment for small varargs in 32 bit little_endian mode */\n-\n-#define PAD_VARARGS_DOWN (TARGET_64BIT ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n+#define PAD_VARARGS_DOWN \\\n+  (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n \n /* Arguments declared as 'char' or 'short' in a prototype should be\n    passed as 'int's.  */\n@@ -2295,15 +2294,6 @@ typedef struct mips_args {\n \n   /* True if the function has a prototype.  */\n   int prototype;\n-\n-  /* When a structure does not take up a full register, the argument\n-     should sometimes be shifted left so that it occupies the high part\n-     of the register.  These two fields describe an array of ashl\n-     patterns for doing this.  See function_arg_advance, which creates\n-     the shift patterns, and function_arg, which returns them when given\n-     a VOIDmode argument.  */\n-  unsigned int num_adjusts;\n-  rtx adjust[BIGGEST_MAX_ARGS_IN_REGISTERS];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2361,18 +2351,11 @@ typedef struct mips_args {\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\t\\\n-   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n-       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n-       : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n-\t  && (mips_abi == ABI_32\t\t\t\t\t\\\n-\t      || mips_abi == ABI_O64\t\t\t\t\t\\\n-\t      || mips_abi == ABI_EABI\t\t\t\t\t\\\n-\t      || GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n-      ? downward : upward))\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\\\n+  (mips_pad_arg_upward (MODE, TYPE) ? upward : downward)\n+\n+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST)\t\t\\\n+  (mips_pad_reg_upward (MODE, TYPE) ? upward : downward)\n \n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n   (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\"}, {"sha": "a17ace15d9d00fcd30a373f242c6629ba139ca46", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=648bb15912c20dcc1a601bd0f7c35a8cdb26bbdf", "patch": "@@ -4674,9 +4674,8 @@ assign_parms (tree fndecl)\n \n \t      if (stack_parm == 0)\n \t\t{\n-\t\t  stack_parm\n-\t\t    = assign_stack_local (GET_MODE (entry_parm),\n-\t\t\t\t\t  size_stored, 0);\n+\t\t  stack_parm = assign_stack_local (BLKmode, size_stored, 0);\n+\t\t  PUT_MODE (stack_parm, GET_MODE (entry_parm));\n \t\t  set_mem_attributes (stack_parm, parm, 1);\n \t\t}\n "}]}