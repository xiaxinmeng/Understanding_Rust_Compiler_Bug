{"sha": "8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4OGY5ZmRkZmY0YmJjYmFlM2I3MGZhNDlkMDUzODZhNTZmZGJkMQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-08-12T14:19:33Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-08-12T14:19:33Z"}, "message": "Recompute profile after Graphite.\n\n2009-08-05  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* Makefile.in (graphite.o): Depends on PREDICT_H.\n\t* graphite.c: Include predict.h.\n\t(graphite_finalize): Call tree_estimate_probability.\n\t* predict.c (predict_loops): Do not call scev_initialize and\n\tscev_finalize.\n\t(tree_estimate_probability_bb): New.\n\t(tree_estimate_probability): Do not initialize loops: move that\n\tcode to the driver.  Call tree_estimate_probability_bb.\n\t(tree_estimate_probability_driver): New.\n\t(pass_profile): Use tree_estimate_probability_driver.\n\t* predict.h (tree_estimate_probability): Declared.\n\nFrom-SVN: r150684", "tree": {"sha": "f9a4f9f1f654eb461ed80c62939a929783f0bba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9a4f9f1f654eb461ed80c62939a929783f0bba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d4d0ee2504d5350b1b355366cff7ea095b10fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d4d0ee2504d5350b1b355366cff7ea095b10fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d4d0ee2504d5350b1b355366cff7ea095b10fc"}], "stats": {"total": 241, "additions": 151, "deletions": 90}, "files": [{"sha": "a06a556e81beb463900297d5464c592685c63869", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -1,3 +1,17 @@\n+2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (graphite.o): Depends on PREDICT_H.\n+\t* graphite.c: Include predict.h.\n+\t(graphite_finalize): Call tree_estimate_probability.\n+\t* predict.c (predict_loops): Do not call scev_initialize and\n+\tscev_finalize.\n+\t(tree_estimate_probability_bb): New.\n+\t(tree_estimate_probability): Do not initialize loops: move that\n+\tcode to the driver.  Call tree_estimate_probability_bb.\n+\t(tree_estimate_probability_driver): New.\n+\t(pass_profile): Use tree_estimate_probability_driver.\n+\t* predict.h (tree_estimate_probability): Declared.\n+\n 2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (gloog): Add time to TV_GRAPHITE_CODE_GEN."}, {"sha": "3688216a3c479f082a7a5b07ebd8669f7e8dc218", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -1,3 +1,17 @@\n+2009-08-05  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (graphite.o): Depends on PREDICT_H.\n+\t* graphite.c: Include predict.h.\n+\t(graphite_finalize): Call tree_estimate_probability.\n+\t* predict.c (predict_loops): Do not call scev_initialize and\n+\tscev_finalize.\n+\t(tree_estimate_probability_bb): New.\n+\t(tree_estimate_probability): Do not initialize loops: move that\n+\tcode to the driver.  Call tree_estimate_probability_bb.\n+\t(tree_estimate_probability_driver): New.\n+\t(pass_profile): Use tree_estimate_probability_driver.\n+\t* predict.h (tree_estimate_probability): Declared.\n+\n 2009-08-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (gloog): Add time to TV_GRAPHITE_CODE_GEN."}, {"sha": "3ab17715c24f59f07a626be8e609b1d9dfe78bd0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -2466,7 +2466,7 @@ sese.o: sese.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n-   $(TREE_DATA_REF_H) tree-pass.h graphite.h \\\n+   $(PREDICT_H) $(TREE_DATA_REF_H) tree-pass.h graphite.h \\\n    pointer-set.h value-prof.h graphite-ppl.h sese.h \\\n    graphite-scop-detection.h graphite-clast-to-gimple.h \\\n    graphite-poly.h graphite-sese-to-poly.h"}, {"sha": "819116d3c36b38bd50a9ae2bf86a557fc7a4cf6c", "filename": "gcc/graphite.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"gimple.h\"\n #include \"sese.h\"\n+#include \"predict.h\"\n \n #ifdef HAVE_cloog\n \n@@ -229,7 +230,12 @@ static void\n graphite_finalize (bool need_cfg_cleanup_p)\n {\n   if (need_cfg_cleanup_p)\n-    cleanup_tree_cfg ();\n+    {\n+      cleanup_tree_cfg ();\n+      profile_status = PROFILE_ABSENT;\n+      release_recorded_exits ();\n+      tree_estimate_probability ();\n+    }\n \n   cloog_finalize ();\n   free_original_copy_tables ();"}, {"sha": "6353fb96a56b40251718440c4ee85f2377b1f22f", "filename": "gcc/predict.c", "status": "modified", "additions": 114, "deletions": 88, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -916,8 +916,6 @@ predict_loops (void)\n   loop_iterator li;\n   struct loop *loop;\n \n-  scev_initialize ();\n-\n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n   FOR_EACH_LOOP (li, loop, 0)\n@@ -1040,8 +1038,6 @@ predict_loops (void)\n       /* Free basic blocks from get_loop_body.  */\n       free (bbs);\n     }\n-\n-  scev_finalize ();\n }\n \n /* Attempt to predict probabilities of BB outgoing edges using local\n@@ -1608,16 +1604,96 @@ assert_is_empty (const void *key ATTRIBUTE_UNUSED, void **value,\n }\n #endif\n \n-/* Predict branch probabilities and estimate profile of the tree CFG.  */\n-static unsigned int\n+/* Predict branch probabilities and estimate profile for basic block BB.  */\n+\n+static void\n+tree_estimate_probability_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple last;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      /* Predict early returns to be probable, as we've already taken\n+\t care for error returns and other cases are often used for\n+\t fast paths through function.\n+\n+\t Since we've already removed the return statements, we are\n+\t looking for CFG like:\n+\n+\t if (conditional)\n+\t {\n+\t ..\n+\t goto return_block\n+\t }\n+\t some other blocks\n+\t return_block:\n+\t return_stmt.  */\n+      if (e->dest != bb->next_bb\n+\t  && e->dest != EXIT_BLOCK_PTR\n+\t  && single_succ_p (e->dest)\n+\t  && single_succ_edge (e->dest)->dest == EXIT_BLOCK_PTR\n+\t  && (last = last_stmt (e->dest)) != NULL\n+\t  && gimple_code (last) == GIMPLE_RETURN)\n+\t{\n+\t  edge e1;\n+\t  edge_iterator ei1;\n+\n+\t  if (single_succ_p (bb))\n+\t    {\n+\t      FOR_EACH_EDGE (e1, ei1, bb->preds)\n+\t\tif (!predicted_by_p (e1->src, PRED_NULL_RETURN)\n+\t\t    && !predicted_by_p (e1->src, PRED_CONST_RETURN)\n+\t\t    && !predicted_by_p (e1->src, PRED_NEGATIVE_RETURN))\n+\t\t  predict_edge_def (e1, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n+\t    }\n+\t  else\n+\t    if (!predicted_by_p (e->src, PRED_NULL_RETURN)\n+\t\t&& !predicted_by_p (e->src, PRED_CONST_RETURN)\n+\t\t&& !predicted_by_p (e->src, PRED_NEGATIVE_RETURN))\n+\t      predict_edge_def (e, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n+\t}\n+\n+      /* Look for block we are guarding (ie we dominate it,\n+\t but it doesn't postdominate us).  */\n+      if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n+\t  && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n+\t  && !dominated_by_p (CDI_POST_DOMINATORS, e->src, e->dest))\n+\t{\n+\t  gimple_stmt_iterator bi;\n+\n+\t  /* The call heuristic claims that a guarded function call\n+\t     is improbable.  This is because such calls are often used\n+\t     to signal exceptional situations such as printing error\n+\t     messages.  */\n+\t  for (bi = gsi_start_bb (e->dest); !gsi_end_p (bi);\n+\t       gsi_next (&bi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (bi);\n+\t      if (is_gimple_call (stmt)\n+\t\t  /* Constant and pure calls are hardly used to signalize\n+\t\t     something exceptional.  */\n+\t\t  && gimple_has_side_effects (stmt))\n+\t\t{\n+\t\t  predict_edge_def (e, PRED_CALL, NOT_TAKEN);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  tree_predict_by_opcode (bb);\n+}\n+\n+/* Predict branch probabilities and estimate profile of the tree CFG.\n+   This function can be called from the loop optimizers to recompute\n+   the profile information.  */\n+\n+void\n tree_estimate_probability (void)\n {\n   basic_block bb;\n \n-  loop_optimizer_init (0);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    flow_loops_dump (dump_file, NULL, 0);\n-\n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n   /* We use loop_niter_by_eval, which requires that the loops have\n@@ -1627,89 +1703,14 @@ tree_estimate_probability (void)\n \n   bb_predictions = pointer_map_create ();\n   tree_bb_level_predictions ();\n-\n-  mark_irreducible_loops ();\n   record_loop_exits ();\n+\n   if (number_of_loops () > 1)\n     predict_loops ();\n \n   FOR_EACH_BB (bb)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      gimple last;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  /* Predict early returns to be probable, as we've already taken\n-\t     care for error returns and other cases are often used for\n-\t     fast paths through function. \n-\n-\t     Since we've already removed the return statements, we are\n-\t     looking for CFG like:\n-\n-\t       if (conditional)\n-\t         {\n-\t\t   ..\n-\t\t   goto return_block\n-\t         }\n-\t       some other blocks\n-\t     return_block:\n-\t       return_stmt.  */\n-\t  if (e->dest != bb->next_bb\n-\t      && e->dest != EXIT_BLOCK_PTR\n-\t      && single_succ_p (e->dest)\n-\t      && single_succ_edge (e->dest)->dest == EXIT_BLOCK_PTR\n-\t      && (last = last_stmt (e->dest)) != NULL\n-\t      && gimple_code (last) == GIMPLE_RETURN)\n-\t    {\n-\t      edge e1;\n-\t      edge_iterator ei1;\n-\n-\t      if (single_succ_p (bb))\n-\t\t{\n-\t\t  FOR_EACH_EDGE (e1, ei1, bb->preds)\n-\t\t    if (!predicted_by_p (e1->src, PRED_NULL_RETURN)\n-\t\t\t&& !predicted_by_p (e1->src, PRED_CONST_RETURN)\n-\t\t\t&& !predicted_by_p (e1->src, PRED_NEGATIVE_RETURN))\n-\t\t      predict_edge_def (e1, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n-\t\t}\n-\t       else\n-\t\tif (!predicted_by_p (e->src, PRED_NULL_RETURN)\n-\t\t    && !predicted_by_p (e->src, PRED_CONST_RETURN)\n-\t\t    && !predicted_by_p (e->src, PRED_NEGATIVE_RETURN))\n-\t\t  predict_edge_def (e, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n-\t    }\n+    tree_estimate_probability_bb (bb);\n \n-\t  /* Look for block we are guarding (ie we dominate it,\n-\t     but it doesn't postdominate us).  */\n-\t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n-\t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n-\t      && !dominated_by_p (CDI_POST_DOMINATORS, e->src, e->dest))\n-\t    {\n-\t      gimple_stmt_iterator bi;\n-\n-\t      /* The call heuristic claims that a guarded function call\n-\t\t is improbable.  This is because such calls are often used\n-\t\t to signal exceptional situations such as printing error\n-\t\t messages.  */\n-\t      for (bi = gsi_start_bb (e->dest); !gsi_end_p (bi);\n-\t\t   gsi_next (&bi))\n-\t\t{\n-\t\t  gimple stmt = gsi_stmt (bi);\n-\t\t  if (is_gimple_call (stmt)\n-\t\t      /* Constant and pure calls are hardly used to signalize\n-\t\t\t something exceptional.  */\n-\t\t      && gimple_has_side_effects (stmt))\n-\t\t    {\n-\t\t      predict_edge_def (e, PRED_CALL, NOT_TAKEN);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      tree_predict_by_opcode (bb);\n-    }\n   FOR_EACH_BB (bb)\n     combine_predictions_for_bb (bb);\n \n@@ -1722,6 +1723,31 @@ tree_estimate_probability (void)\n   estimate_bb_frequencies ();\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n+}\n+\n+/* Predict branch probabilities and estimate profile of the tree CFG.\n+   This is the driver function for PASS_PROFILE.  */\n+\n+static unsigned int\n+tree_estimate_probability_driver (void)\n+{\n+  unsigned nb_loops;\n+\n+  loop_optimizer_init (0);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    flow_loops_dump (dump_file, NULL, 0);\n+\n+  mark_irreducible_loops ();\n+\n+  nb_loops = number_of_loops ();\n+  if (nb_loops > 1)\n+    scev_initialize ();\n+\n+  tree_estimate_probability ();\n+\n+  if (nb_loops > 1)\n+    scev_finalize ();\n+\n   loop_optimizer_finalize ();\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     gimple_dump_cfg (dump_file, dump_flags);\n@@ -2203,7 +2229,7 @@ struct gimple_opt_pass pass_profile =\n   GIMPLE_PASS,\n   \"profile\",\t\t\t\t/* name */\n   gate_estimate_probability,\t\t/* gate */\n-  tree_estimate_probability,\t\t/* execute */\n+  tree_estimate_probability_driver,\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */"}, {"sha": "0e040410768f355cdca7d507accf0809622540e7", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=8e88f9fddff4bbcbae3b70fa49d05386a56fdbd1", "patch": "@@ -40,5 +40,6 @@ extern int counts_to_freqs (void);\n extern void estimate_bb_frequencies (void);\n extern const char *predictor_name (enum br_predictor);\n extern tree build_predict_expr (enum br_predictor, enum prediction);\n+extern void tree_estimate_probability (void);\n \n #endif  /* GCC_PREDICT_H */"}]}