{"sha": "b35366ce42d0cc1218679337be0a779c20af35e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1MzY2Y2U0MmQwY2MxMjE4Njc5MzM3YmUwYTc3OWMyMGFmMzVlMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-29T14:14:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-29T14:14:15Z"}, "message": "predict.c (propagate_freq): Clear EXIT_BLOCK_PTR frequency if it is unreachable.\n\n\t* predict.c (propagate_freq): Clear EXIT_BLOCK_PTR frequency if it is\n\tunreachable.\n\t(rebuild_frequencies): New function.\n\t* predict.h (rebuild_frequencies): Declare.\n\t* tree-inline.c (copy_cfg_body): Compute properly count & frequency of\n\tentry block and edge reaching new_entry.\n\t(tree_function_versioning): When doing partial cloning, rebuild frequencies\n\twhen done.\n\t* passes.c (execute_function_todo): Use rebild_frequencies.\n\nFrom-SVN: r161536", "tree": {"sha": "a5ef0708be39861c165f5c5612b671234a8fd8de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5ef0708be39861c165f5c5612b671234a8fd8de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b35366ce42d0cc1218679337be0a779c20af35e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35366ce42d0cc1218679337be0a779c20af35e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35366ce42d0cc1218679337be0a779c20af35e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35366ce42d0cc1218679337be0a779c20af35e0/comments", "author": null, "committer": null, "parents": [{"sha": "50b56694bb665f06ad0a327498bebe45e0bd3d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b56694bb665f06ad0a327498bebe45e0bd3d0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b56694bb665f06ad0a327498bebe45e0bd3d0d"}], "stats": {"total": 131, "additions": 109, "deletions": 22}, "files": [{"sha": "0bfee7cb379913ccc1051f8d0895218205cf4522", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -1,3 +1,15 @@\n+2010-06-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (propagate_freq): Clear EXIT_BLOCK_PTR frequency if it is\n+\tunreachable.\n+\t(rebuild_frequencies): New function.\n+\t* predict.h (rebuild_frequencies): Declare.\n+\t* tree-inline.c (copy_cfg_body): Compute properly count & frequency of\n+\tentry block and edge reaching new_entry.\n+\t(tree_function_versioning): When doing partial cloning, rebuild frequencies\n+\twhen done.\n+\t* passes.c (execute_function_todo): Use rebild_frequencies.\n+\n 2010-06-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-dfa.c (dump_variable): Remove noalias_state dumping."}, {"sha": "8828967d0d8ad3b24493eb138f07e96b2e4e51ca", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -1243,22 +1243,7 @@ execute_function_todo (void *data)\n     }\n \n   if (flags & TODO_rebuild_frequencies)\n-    {\n-      if (profile_status == PROFILE_GUESSED)\n-\t{\n-\t  loop_optimizer_init (0);\n-\t  add_noreturn_fake_exit_edges ();\n-\t  mark_irreducible_loops ();\n-\t  connect_infinite_loops_to_exit ();\n-\t  estimate_bb_frequencies ();\n-\t  remove_fake_exit_edges ();\n-\t  loop_optimizer_finalize ();\n-\t}\n-      else if (profile_status == PROFILE_READ)\n-\tcounts_to_freqs ();\n-      else\n-\tgcc_unreachable ();\n-    }\n+    rebuild_frequencies ();\n \n #if defined ENABLE_CHECKING\n   if (flags & TODO_verify_ssa"}, {"sha": "5d61140e4e679d7ada5058cde521134a6760055d", "filename": "gcc/predict.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -1855,9 +1855,6 @@ propagate_freq (basic_block head, bitmap tovisit)\n       edge_iterator ei;\n       int count = 0;\n \n-       /* The outermost \"loop\" includes the exit block, which we can not\n-\t  look up via BASIC_BLOCK.  Detect this and use EXIT_BLOCK_PTR\n-\t  directly.  Do the same for the entry block.  */\n       bb = BASIC_BLOCK (i);\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1872,6 +1869,9 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t\t     e->src->index, bb->index);\n \t}\n       BLOCK_INFO (bb)->npredecessors = count;\n+      /* When function never returns, we will never process exit block.  */\n+      if (!count && bb == EXIT_BLOCK_PTR)\n+\tbb->count = bb->frequency = 0;\n     }\n \n   memcpy (&BLOCK_INFO (head)->frequency, &real_one, sizeof (real_one));\n@@ -2282,3 +2282,27 @@ struct gimple_opt_pass pass_strip_predict_hints =\n   TODO_ggc_collect | TODO_verify_ssa\t\t\t/* todo_flags_finish */\n  }\n };\n+\n+/* Rebuild function frequencies.  Passes are in general expected to\n+   maintain profile by hand, however in some cases this is not possible:\n+   for example when inlining several functions with loops freuqencies might run\n+   out of scale and thus needs to be recomputed.  */\n+\n+void\n+rebuild_frequencies (void)\n+{\n+  if (profile_status == PROFILE_GUESSED)\n+    {\n+      loop_optimizer_init (0);\n+      add_noreturn_fake_exit_edges ();\n+      mark_irreducible_loops ();\n+      connect_infinite_loops_to_exit ();\n+      estimate_bb_frequencies ();\n+      remove_fake_exit_edges ();\n+      loop_optimizer_finalize ();\n+    }\n+  else if (profile_status == PROFILE_READ)\n+    counts_to_freqs ();\n+  else\n+    gcc_unreachable ();\n+}"}, {"sha": "a0ca3a29071d534b5439b24355751bd6cf2b0277", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -42,5 +42,6 @@ extern const char *predictor_name (enum br_predictor);\n extern tree build_predict_expr (enum br_predictor, enum prediction);\n extern void tree_estimate_probability (void);\n extern void compute_function_frequency (void);\n+extern void rebuild_frequencies (void);\n \n #endif  /* GCC_PREDICT_H */"}, {"sha": "00e5e840404848c5cb6d84da6775394f512ed113", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -1,3 +1,7 @@\n+2010-06-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ipa-split-3.c: New testcase.\n+\n 2010-06-29  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR target/43902"}, {"sha": "05a37f8102782afcbcbc66b67f052a26b2e8e984", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-split-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-3.c?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -0,0 +1,21 @@\n+int baz (void);\n+static int\n+foo (int x)\n+{\n+  if (__builtin_expect (x <= 0, 0))\n+    {\n+      __builtin_printf (\"foo\\n\");\n+      __builtin_printf (\"foo\\n\");\n+      __builtin_printf (\"foo\\n\");\n+      __builtin_abort ();\n+    }\n+  return 6;\n+}\n+\n+int a,b,c;\n+\n+int\n+bar (int x)\n+{\n+  return foo (a) + foo (b) + foo (c);\n+}"}, {"sha": "3ef1cc3832e8c61f61f1cfa72c14da2c5318aa95", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35366ce42d0cc1218679337be0a779c20af35e0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b35366ce42d0cc1218679337be0a779c20af35e0", "patch": "@@ -2159,6 +2159,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   bool need_debug_cleanup = false;\n   gcov_type count_scale;\n   int last;\n+  int incomming_frequency = 0;\n+  gcov_type incomming_count = 0;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n@@ -2169,6 +2171,28 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n \n+  /* If we are inlining just region of the function, make sure to connect new entry\n+     to ENTRY_BLOCK_PTR.  Since new entry can be part of loop, we must compute\n+     frequency and probability of ENTRY_BLOCK_PTR based on the frequencies and\n+     probabilities of edges incomming from nonduplicated region.  */\n+  if (new_entry)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, new_entry->preds)\n+\tif (!e->src->aux)\n+\t  {\n+\t    incomming_frequency += EDGE_FREQUENCY (e);\n+\t    incomming_count += e->count;\n+\t  }\n+      incomming_count = incomming_count * count_scale / REG_BR_PROB_BASE;\n+      incomming_frequency\n+\t= incomming_frequency * frequency_scale / REG_BR_PROB_BASE;\n+      ENTRY_BLOCK_PTR->count = incomming_count;\n+      ENTRY_BLOCK_PTR->frequency = incomming_frequency;\n+    }\n+\n   /* Must have a CFG here at this point.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION\n \t      (DECL_STRUCT_FUNCTION (callee_fndecl)));\n@@ -2204,10 +2228,9 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   if (new_entry)\n     {\n-      edge e;\n-      e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n+      edge e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n       e->probability = REG_BR_PROB_BASE;\n-      e->count = entry_block_map->count;\n+      e->count = incomming_count;\n     }\n \n   if (gimple_in_ssa_p (cfun))\n@@ -5206,6 +5229,23 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   if (id.dst_node->analyzed)\n     cgraph_rebuild_references ();\n   update_ssa (TODO_update_ssa);\n+\n+  /* After partial cloning we need to rescale frequencies, so they are\n+     within proper range in the cloned function.  */\n+  if (new_entry)\n+    {\n+      struct cgraph_edge *e;\n+      rebuild_frequencies ();\n+\n+      new_version_node->count = ENTRY_BLOCK_PTR->count;\n+      for (e = new_version_node->callees; e; e = e->next_callee)\n+\t{\n+\t  basic_block bb = gimple_bb (e->call_stmt);\n+\t  e->frequency = compute_call_stmt_bb_frequency (current_function_decl, bb);\n+\t  e->count = bb->count;\n+\t}\n+    }\n+\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n "}]}