{"sha": "a2041967826c644f860ec12c6f32214b1e3d3899", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwNDE5Njc4MjZjNjQ0Zjg2MGVjMTJjNmYzMjIxNGIxZTNkMzg5OQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-18T15:11:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-18T15:11:31Z"}, "message": "basic-block.h (reg_set_iterator): New.\n\n\t* basic-block.h (reg_set_iterator): New.\n\t(EXECUTE_IF_SET_IN_REG_SET): Make it iterator style.\n\t(EXECUTE_IF_AND_COMPL_IN_REG_SET): Likewise.\n\t(EXECUTE_IF_AND_IN_REG_SET): Likewise.\n\t* caller-save.c (save_call_clobbered_regs): Adjust to the new\n\tstyle.\n\t* cfgcleanup.c (thread_jump): Likewise.\n\t* cfgrtl.c (safe_insert_insn_on_edge): Likewise.\n\t* conflict.c (conflict_graph_compute): Likewise.\n\t* flow.c (verify_local_live_at_start, update_life_info,\n\tinitialize_uninitialized_subregs, propagate_one_insn,\n\tinit_propagate_block_info, free_propagate_block_info,\n\tpropagate_block, dump_regset): Likewise.\n\t* global.c (global_conflicts): Likewise.\n\t* graph.c (start_bb): Likewise.\n\t* local-alloc.c (update_equiv_regs): Likewise.\n\t* loop.c (load_mems): Likewise.\n\t* reload1.c (compute_use_by_pseudos, order_regs_for_reload,\n\tfind_reg, finish_spills): Likewise.\n\t* resource.c (mark_target_live_regs): Likewise.\n\t* sched-deps.c (sched_analyze_insn): Likewise.\n\t* sched-rgn.c (sched-rgn.c): Likewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n\nFrom-SVN: r89226", "tree": {"sha": "e0aded8319864b2cb6fac4df0732bb5ee1995039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0aded8319864b2cb6fac4df0732bb5ee1995039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2041967826c644f860ec12c6f32214b1e3d3899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2041967826c644f860ec12c6f32214b1e3d3899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2041967826c644f860ec12c6f32214b1e3d3899", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2041967826c644f860ec12c6f32214b1e3d3899/comments", "author": null, "committer": null, "parents": [{"sha": "2ddfd02523ee86ac14fd053bee5a7c30f6f1f602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ddfd02523ee86ac14fd053bee5a7c30f6f1f602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ddfd02523ee86ac14fd053bee5a7c30f6f1f602"}], "stats": {"total": 533, "additions": 285, "deletions": 248}, "files": [{"sha": "78896f6d38f4f932b6ea816e7c46957e1a327610", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -1,3 +1,29 @@\n+2004-10-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h (reg_set_iterator): New.\n+\t(EXECUTE_IF_SET_IN_REG_SET): Make it iterator style.\n+\t(EXECUTE_IF_AND_COMPL_IN_REG_SET): Likewise.\n+\t(EXECUTE_IF_AND_IN_REG_SET): Likewise.\n+\t* caller-save.c (save_call_clobbered_regs): Adjust to the new\n+\tstyle.\n+\t* cfgcleanup.c (thread_jump): Likewise.\n+\t* cfgrtl.c (safe_insert_insn_on_edge): Likewise.\n+\t* conflict.c (conflict_graph_compute): Likewise.\n+\t* flow.c (verify_local_live_at_start, update_life_info,\n+\tinitialize_uninitialized_subregs, propagate_one_insn,\n+\tinit_propagate_block_info, free_propagate_block_info,\n+\tpropagate_block, dump_regset): Likewise.\n+\t* global.c (global_conflicts): Likewise.\n+\t* graph.c (start_bb): Likewise.\n+\t* local-alloc.c (update_equiv_regs): Likewise.\n+\t* loop.c (load_mems): Likewise.\n+\t* reload1.c (compute_use_by_pseudos, order_regs_for_reload,\n+\tfind_reg, finish_spills): Likewise.\n+\t* resource.c (mark_target_live_regs): Likewise.\n+\t* sched-deps.c (sched_analyze_insn): Likewise.\n+\t* sched-rgn.c (sched-rgn.c): Likewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n+\n 2004-10-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (addqi_1_slp): Test for incdec_operand"}, {"sha": "d9204964eeb2eafaa5384d85b1f38965c7e1e005", "filename": "gcc/basic-block.h", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -83,46 +83,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n   reg_set_to_hard_reg_set (&TO, FROM);\t\t\t\t\t\\\n } while (0)\n \n+typedef bitmap_iterator reg_set_iterator;\n+\n /* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n    register number and executing CODE for all registers that are set.  */\n-#define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bitmap_iterator bi;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, bi)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  CODE;\t\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    } while (0)\n+#define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, RSI)\t\\\n+  EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, RSI)\n \n /* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n    REGNUM to the register number and executing CODE for all registers that are\n    set in the first regset and not set in the second.  */\n-#define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bitmap_iterator bi;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, bi) \\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  CODE;\t\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    } while (0)\n+#define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET, MIN, REGNUM, RSI)\t\\\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET, MIN, REGNUM, RSI)\n \n /* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n    REGNUM to the register number and executing CODE for all registers that are\n    set in both regsets.  */\n-#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bitmap_iterator bi;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, bi)\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  CODE;\t\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    } while (0)\n+#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, RSI) \\\n+  EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, RSI)\t\\\n \n /* Allocate a register set with oballoc.  */\n #define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)"}, {"sha": "55a825efe4e4fd17ac30456448cb4332e911f547", "filename": "gcc/caller-save.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -410,6 +410,7 @@ save_call_clobbered_regs (void)\n \t    {\n \t      int regno;\n \t      HARD_REG_SET hard_regs_to_save;\n+\t      reg_set_iterator rsi;\n \n \t      /* Use the register life information in CHAIN to compute which\n \t\t regs are live during the call.  */\n@@ -425,22 +426,22 @@ save_call_clobbered_regs (void)\n \t      /* Look through all live pseudos, mark their hard registers\n \t\t and choose proper mode for saving.  */\n \t      EXECUTE_IF_SET_IN_REG_SET\n-\t\t(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno,\n-\t\t {\n-\t\t   int r = reg_renumber[regno];\n-\t\t   int nregs;\n-\t\t   enum machine_mode mode;\n-\n-\t\t   gcc_assert (r >= 0);\n-\t\t   nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n-\t\t   mode = HARD_REGNO_CALLER_SAVE_MODE\n-\t\t     (r, nregs, PSEUDO_REGNO_MODE (regno));\n-\t\t   if (GET_MODE_BITSIZE (mode)\n-\t\t       > GET_MODE_BITSIZE (save_mode[r]))\n-\t\t     save_mode[r] = mode;\n-\t\t   while (nregs-- > 0)\n-\t\t     SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);\n-\t\t });\n+\t\t(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)\n+\t\t{\n+\t\t  int r = reg_renumber[regno];\n+\t\t  int nregs;\n+\t\t  enum machine_mode mode;\n+\n+\t\t  gcc_assert (r >= 0);\n+\t\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t\t  mode = HARD_REGNO_CALLER_SAVE_MODE\n+\t\t    (r, nregs, PSEUDO_REGNO_MODE (regno));\n+\t\t  if (GET_MODE_BITSIZE (mode)\n+\t\t      > GET_MODE_BITSIZE (save_mode[r]))\n+\t\t    save_mode[r] = mode;\n+\t\t  while (nregs-- > 0)\n+\t\t    SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);\n+\t\t}\n \n \t      /* Record all registers set in this call insn.  These don't need\n \t\t to be saved.  N.B. the call insn might set a subreg of a"}, {"sha": "8ac3405242f4a3906d8188756c948cbfcf0021b0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -282,6 +282,7 @@ thread_jump (int mode, edge e, basic_block b)\n   int i;\n   regset nonequal;\n   bool failed = false;\n+  reg_set_iterator rsi;\n \n   if (BB_FLAGS (b) & BB_NONTHREADABLE_BLOCK)\n     return NULL;\n@@ -396,7 +397,8 @@ thread_jump (int mode, edge e, basic_block b)\n   if (mode & CLEANUP_UPDATE_LIFE)\n     AND_REG_SET (nonequal, b->global_live_at_end);\n \n-  EXECUTE_IF_SET_IN_REG_SET (nonequal, 0, i, goto failed_exit;);\n+  EXECUTE_IF_SET_IN_REG_SET (nonequal, 0, i, rsi)\n+    goto failed_exit;\n \n   BITMAP_XFREE (nonequal);\n   cselib_finish ();"}, {"sha": "5361cd9a75fe42a9f43050da6c20315dc8fd552c", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -1465,6 +1465,7 @@ safe_insert_insn_on_edge (rtx insn, edge e)\n   rtx save_regs = NULL_RTX;\n   int regno, noccmode;\n   enum machine_mode mode;\n+  reg_set_iterator rsi;\n \n #ifdef AVOID_CCMODE_COPIES\n   noccmode = true;\n@@ -1478,7 +1479,7 @@ safe_insert_insn_on_edge (rtx insn, edge e)\n   bitmap_operation (killed, killed, e->dest->global_live_at_start,\n \t\t    BITMAP_AND);\n \n-  EXECUTE_IF_SET_IN_REG_SET (killed, 0, regno,\n+  EXECUTE_IF_SET_IN_REG_SET (killed, 0, regno, rsi)\n     {\n       mode = regno < FIRST_PSEUDO_REGISTER\n \t      ? reg_raw_mode[regno]\n@@ -1494,7 +1495,7 @@ safe_insert_insn_on_edge (rtx insn, edge e)\n \t\t\t\t\t\t    gen_reg_rtx (mode),\n \t\t\t\t\t\t    gen_raw_REG (mode, regno)),\n \t\t\t\t   save_regs);\n-    });\n+    }\n \n   if (save_regs)\n     {"}, {"sha": "0347c16f1e8a12aa0d41c203b6c359a74b342407", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -6679,6 +6679,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n   enum reg_class cr_class;\n   int cc_first;\n   int cc_last;\n+  reg_set_iterator rsi;\n \n   /* Make sure we are only dealing with hard registers.  Also honor the\n      -mno-cond-exec switch, and -mno-nested-cond-exec switches if\n@@ -6735,11 +6736,11 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Remove anything live at the beginning of the join block from being\n          available for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (join_bb->global_live_at_start, 0, regno,\n-\t\t\t\t {\n-\t\t\t\t   if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t\t\t     CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n-\t\t\t\t });\n+      EXECUTE_IF_SET_IN_REG_SET (join_bb->global_live_at_start, 0, regno, rsi)\n+\t{\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n+\t}\n     }\n \n   /* Add in all of the blocks in multiple &&/|| blocks to be scanned.  */\n@@ -6779,11 +6780,11 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n       /* Anything live at the beginning of the block is obviously unavailable\n          for allocation.  */\n-      EXECUTE_IF_SET_IN_REG_SET (bb[j]->global_live_at_start, 0, regno,\n-\t\t\t\t {\n-\t\t\t\t   if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t\t\t     CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n-\t\t\t\t });\n+      EXECUTE_IF_SET_IN_REG_SET (bb[j]->global_live_at_start, 0, regno, rsi)\n+\t{\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n+\t}\n \n       /* Loop through the insns in the block.  */\n       for (;;)"}, {"sha": "ca9dd95eb2b55b90158b6c789473d98f59edd988", "filename": "gcc/conflict.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -446,6 +446,8 @@ conflict_graph_compute (regset regs, partition p)\n \t  /* Are we interested in this insn? */\n \t  if (INSN_P (insn))\n \t    {\n+\t      reg_set_iterator rsi;\n+\n \t      /* Determine which regs are set in this insn.  Since\n   \t         we're in SSA form, if a reg is set here it isn't set\n   \t         anywhere else, so this insn is where the reg is born.  */\n@@ -459,20 +461,22 @@ conflict_graph_compute (regset regs, partition p)\n \t      /* For every reg born here, add a conflict with every other\n   \t         reg live coming into this insn.  */\n \t      EXECUTE_IF_SET_IN_REG_SET\n-\t\t(born, FIRST_PSEUDO_REGISTER, born_reg,\n-\t\t {\n-\t\t   EXECUTE_IF_SET_IN_REG_SET\n-\t\t     (live, FIRST_PSEUDO_REGISTER, live_reg,\n-\t\t      {\n-\t\t\t/* Build the conflict graph in terms of canonical\n-\t\t\t   regnos.  */\n-\t\t\tint b = partition_find (p, born_reg);\n-\t\t\tint l = partition_find (p, live_reg);\n-\n-\t\t\tif (b != l)\n-\t\t\t  conflict_graph_add (graph, b, l);\n-\t\t      });\n-\t\t });\n+\t\t(born, FIRST_PSEUDO_REGISTER, born_reg, rsi)\n+\t\t{\n+\t\t  reg_set_iterator rsj;\n+\n+\t\t  EXECUTE_IF_SET_IN_REG_SET\n+\t\t    (live, FIRST_PSEUDO_REGISTER, live_reg, rsj)\n+\t\t    {\n+\t\t      /* Build the conflict graph in terms of canonical\n+\t\t\t regnos.  */\n+\t\t      int b = partition_find (p, born_reg);\n+\t\t      int l = partition_find (p, live_reg);\n+\n+\t\t      if (b != l)\n+\t\t\tconflict_graph_add (graph, b, l);\n+\t\t    }\n+\t\t}\n \n \t      /* Morgan's algorithm checks the operands of the insn\n \t         and adds them to the set of live regs.  Instead, we"}, {"sha": "4ea30a79d3d27a034aed3aafb86f3c5fa5ba9a85", "filename": "gcc/flow.c", "status": "modified", "additions": 57, "deletions": 44, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -521,11 +521,12 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n   else\n     {\n       int i;\n+      reg_set_iterator rsi;\n \n       /* Find the set of changed registers.  */\n       XOR_REG_SET (new_live_at_start, bb->global_live_at_start);\n \n-      EXECUTE_IF_SET_IN_REG_SET (new_live_at_start, 0, i,\n+      EXECUTE_IF_SET_IN_REG_SET (new_live_at_start, 0, i, rsi)\n \t{\n \t  /* No registers should die.  */\n \t  if (REGNO_REG_SET_P (bb->global_live_at_start, i))\n@@ -540,7 +541,7 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t    }\n \t  /* Verify that the now-live register is wider than word_mode.  */\n \t  verify_wide_reg (i, bb);\n-\t});\n+\t}\n     }\n }\n \n@@ -680,13 +681,15 @@ update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags\n \n   if (prop_flags & PROP_REG_INFO)\n     {\n+      reg_set_iterator rsi;\n+\n       /* The only pseudos that are live at the beginning of the function\n \t are those that were not set anywhere in the function.  local-alloc\n \t doesn't know how to handle these correctly, so mark them as not\n \t local to any one basic block.  */\n       EXECUTE_IF_SET_IN_REG_SET (ENTRY_BLOCK_PTR->global_live_at_end,\n-\t\t\t\t FIRST_PSEUDO_REGISTER, i,\n-\t\t\t\t { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n+\t\t\t\t FIRST_PSEUDO_REGISTER, i, rsi)\n+\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n \n       /* We have a problem with any pseudoreg that lives across the setjmp.\n \t ANSI says that if a user variable does not change in value between\n@@ -697,14 +700,14 @@ update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags\n \t that hard reg where this pseudo is dead, thus clobbering the pseudo.\n \t Conclusion: such a pseudo must not go in a hard reg.  */\n       EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp,\n-\t\t\t\t FIRST_PSEUDO_REGISTER, i,\n-\t\t\t\t {\n-\t\t\t\t   if (regno_reg_rtx[i] != 0)\n-\t\t\t\t     {\n-\t\t\t\t       REG_LIVE_LENGTH (i) = -1;\n-\t\t\t\t       REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n-\t\t\t\t     }\n-\t\t\t\t });\n+\t\t\t\t FIRST_PSEUDO_REGISTER, i, rsi)\n+\t{\n+\t  if (regno_reg_rtx[i] != 0)\n+\t    {\n+\t      REG_LIVE_LENGTH (i) = -1;\n+\t      REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t    }\n+\t}\n     }\n   if (reg_deaths)\n     {\n@@ -1369,8 +1372,9 @@ initialize_uninitialized_subregs (void)\n     {\n       basic_block bb = e->dest;\n       regset map = bb->global_live_at_start;\n-      EXECUTE_IF_SET_IN_REG_SET (map,\n-\t\t\t\t FIRST_PSEUDO_REGISTER, reg,\n+      reg_set_iterator rsi;\n+\n+      EXECUTE_IF_SET_IN_REG_SET (map, FIRST_PSEUDO_REGISTER, reg, rsi)\n \t{\n \t  int uid = REGNO_FIRST_UID (reg);\n \t  rtx i;\n@@ -1398,7 +1402,7 @@ initialize_uninitialized_subregs (void)\n \t\t  did_something = 1;\n \t\t}\n \t    }\n-\t});\n+\t}\n     }\n \n   if (did_something)\n@@ -1671,8 +1675,11 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n \t record this for them.  */\n \n       if (CALL_P (insn) && (flags & PROP_REG_INFO))\n-\tEXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i,\n-\t\t\t\t   { REG_N_CALLS_CROSSED (i)++; });\n+\t{\n+\t  reg_set_iterator rsi;\n+\t  EXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i, rsi)\n+\t    REG_N_CALLS_CROSSED (i)++;\n+\t}\n \n       /* Record sets.  Do this even for dead instructions, since they\n \t would have killed the values if they hadn't been deleted.  */\n@@ -1878,6 +1885,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t= gen_rtx_fmt_ee (inv_cond,\n \t\t\t\t  GET_MODE (cond_true), XEXP (cond_true, 0),\n \t\t\t\t  XEXP (cond_true, 1));\n+\t      reg_set_iterator rsi;\n+\n \t      if (GET_CODE (XEXP (set_src, 1)) == PC)\n \t\t{\n \t\t  rtx t = cond_false;\n@@ -1888,25 +1897,24 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t      SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (reg));\n \n \t      /* For each such register, mark it conditionally dead.  */\n-\t      EXECUTE_IF_SET_IN_REG_SET\n-\t\t(diff, 0, i,\n-\t\t {\n-\t\t   struct reg_cond_life_info *rcli;\n-\t\t   rtx cond;\n-\n-\t\t   rcli = xmalloc (sizeof (*rcli));\n-\n-\t\t   if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n-\t\t     cond = cond_false;\n-\t\t   else\n-\t\t     cond = cond_true;\n-\t\t   rcli->condition = cond;\n-\t\t   rcli->stores = const0_rtx;\n-\t\t   rcli->orig_condition = cond;\n-\n-\t\t   splay_tree_insert (pbi->reg_cond_dead, i,\n-\t\t\t\t      (splay_tree_value) rcli);\n-\t\t });\n+\t      EXECUTE_IF_SET_IN_REG_SET (diff, 0, i, rsi)\n+\t\t{\n+\t\t  struct reg_cond_life_info *rcli;\n+\t\t  rtx cond;\n+\n+\t\t  rcli = xmalloc (sizeof (*rcli));\n+\n+\t\t  if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n+\t\t    cond = cond_false;\n+\t\t  else\n+\t\t    cond = cond_true;\n+\t\t  rcli->condition = cond;\n+\t\t  rcli->stores = const0_rtx;\n+\t\t  rcli->orig_condition = cond;\n+\n+\t\t  splay_tree_insert (pbi->reg_cond_dead, i,\n+\t\t\t\t     (splay_tree_value) rcli);\n+\t\t}\n \t    }\n \t}\n \n@@ -1966,11 +1974,13 @@ free_propagate_block_info (struct propagate_block_info *pbi)\n     {\n       int num = pbi->insn_num;\n       int i;\n+      reg_set_iterator rsi;\n \n-      EXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i,\n-\t { REG_LIVE_LENGTH (i) += num - reg_deaths[i];\n-\t   reg_deaths[i] = 0;\n-         });\n+      EXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i, rsi)\n+\t{\n+\t  REG_LIVE_LENGTH (i) += num - reg_deaths[i];\n+\t  reg_deaths[i] = 0;\n+\t}\n     }\n   if (pbi->reg_next_use)\n     free (pbi->reg_next_use);\n@@ -2009,11 +2019,12 @@ propagate_block (basic_block bb, regset live, regset local_set,\n   if (flags & PROP_REG_INFO)\n     {\n       int i;\n+      reg_set_iterator rsi;\n \n       /* Process the regs live at the end of the block.\n \t Mark them as not local to any one basic block.  */\n-      EXECUTE_IF_SET_IN_REG_SET (live, 0, i,\n-\t\t\t\t { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n+      EXECUTE_IF_SET_IN_REG_SET (live, 0, i, rsi)\n+\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n     }\n \n   /* Scan the block an insn at a time from end to beginning.  */\n@@ -4135,19 +4146,21 @@ void\n dump_regset (regset r, FILE *outf)\n {\n   int i;\n+  reg_set_iterator rsi;\n+\n   if (r == NULL)\n     {\n       fputs (\" (nil)\", outf);\n       return;\n     }\n \n-  EXECUTE_IF_SET_IN_REG_SET (r, 0, i,\n+  EXECUTE_IF_SET_IN_REG_SET (r, 0, i, rsi)\n     {\n       fprintf (outf, \" %d\", i);\n       if (i < FIRST_PSEUDO_REGISTER)\n \tfprintf (outf, \" [%s]\",\n \t\t reg_names[i]);\n-    });\n+    }\n }\n \n /* Print a human-readable representation of R on the standard error"}, {"sha": "6892fdc3c6c69ad7b52b61ff474b8cb063612652", "filename": "gcc/global.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -700,20 +700,20 @@ global_conflicts (void)\n       {\n \tregset old = b->global_live_at_start;\n \tint ax = 0;\n+\treg_set_iterator rsi;\n \n \tREG_SET_TO_HARD_REG_SET (hard_regs_live, old);\n-\tEXECUTE_IF_SET_IN_REG_SET (old, FIRST_PSEUDO_REGISTER, i,\n-\t\t\t\t   {\n-\t\t\t\t     int a = reg_allocno[i];\n-\t\t\t\t     if (a >= 0)\n-\t\t\t\t       {\n-\t\t\t\t\t SET_ALLOCNO_LIVE (a);\n-\t\t\t\t\t block_start_allocnos[ax++] = a;\n-\t\t\t\t       }\n-\t\t\t\t     else if ((a = reg_renumber[i]) >= 0)\n-\t\t\t\t       mark_reg_live_nc\n-\t\t\t\t\t (a, PSEUDO_REGNO_MODE (i));\n-\t\t\t\t   });\n+\tEXECUTE_IF_SET_IN_REG_SET (old, FIRST_PSEUDO_REGISTER, i, rsi)\n+\t  {\n+\t    int a = reg_allocno[i];\n+\t    if (a >= 0)\n+\t      {\n+\t\tSET_ALLOCNO_LIVE (a);\n+\t\tblock_start_allocnos[ax++] = a;\n+\t      }\n+\t    else if ((a = reg_renumber[i]) >= 0)\n+\t      mark_reg_live_nc (a, PSEUDO_REGNO_MODE (i));\n+\t  }\n \n \t/* Record that each allocno now live conflicts with each hard reg\n \t   now live."}, {"sha": "e60e2f6799b9ded12e8104e2cfbc4b2bb1b1ca08", "filename": "gcc/graph.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -66,6 +66,10 @@ graph: { title: \\\"%s\\\"\\nfolding: 1\\nhidden: 2\\nnode: { title: \\\"%s.0\\\" }\\n\",\n static void\n start_bb (FILE *fp, int bb)\n {\n+#if 0\n+  reg_set_iterator rsi;\n+#endif\n+\n   switch (graph_dump_format)\n     {\n     case vcg:\n@@ -83,13 +87,12 @@ label: \\\"basic block %d\",\n \n   /* Print the live-at-start register list.  */\n   fputc ('\\n', fp);\n-  EXECUTE_IF_SET_IN_REG_SET (basic_block_live_at_start[bb], 0, i,\n-\t\t\t     {\n-\t\t\t       fprintf (fp, \" %d\", i);\n-\t\t\t       if (i < FIRST_PSEUDO_REGISTER)\n-\t\t\t\t fprintf (fp, \" [%s]\",\n-\t\t\t\t\t  reg_names[i]);\n-\t\t\t     });\n+  EXECUTE_IF_SET_IN_REG_SET (basic_block_live_at_start[bb], 0, i, rsi)\n+    {\n+      fprintf (fp, \" %d\", i);\n+      if (i < FIRST_PSEUDO_REGISTER)\n+\tfprintf (fp, \" [%s]\", reg_names[i]);\n+    }\n #endif\n \n   switch (graph_dump_format)"}, {"sha": "ebda9dd88400925d10d7449e7b6a9c6b4000e771", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -1128,14 +1128,17 @@ update_equiv_regs (void)\n \t    }\n \t}\n       else\n-\tEXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j,\n-\t  {\n-\t    FOR_EACH_BB (bb)\n-\t      {\n-\t        CLEAR_REGNO_REG_SET (bb->global_live_at_start, j);\n-\t        CLEAR_REGNO_REG_SET (bb->global_live_at_end, j);\n-\t      }\n-\t  });\n+\t{\n+\t  reg_set_iterator rsi;\n+\t  EXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j, rsi)\n+\t    {\n+\t      FOR_EACH_BB (bb)\n+\t\t{\n+\t\t  CLEAR_REGNO_REG_SET (bb->global_live_at_start, j);\n+\t\t  CLEAR_REGNO_REG_SET (bb->global_live_at_end, j);\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   /* Clean up.  */"}, {"sha": "a573616d0e1d9dc7ba80929a584501227fc92f8c", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -11242,6 +11242,7 @@ load_mems (const struct loop *loop)\n \t  rtx best = mem;\n \t  int j;\n \t  struct elt_loc_list *const_equiv = 0;\n+\t  reg_set_iterator rsi;\n \n \t  if (e)\n \t    {\n@@ -11320,17 +11321,17 @@ load_mems (const struct loop *loop)\n \t     data flow, and enables {basic,general}_induction_var to find\n \t     more bivs/givs.  */\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&load_copies, FIRST_PSEUDO_REGISTER, j,\n-\t     {\n-\t       try_copy_prop (loop, reg, j);\n-\t     });\n+\t    (&load_copies, FIRST_PSEUDO_REGISTER, j, rsi)\n+\t    {\n+\t      try_copy_prop (loop, reg, j);\n+\t    }\n \t  CLEAR_REG_SET (&load_copies);\n \n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&store_copies, FIRST_PSEUDO_REGISTER, j,\n-\t     {\n-\t       try_swap_copy_prop (loop, reg, j);\n-\t     });\n+\t    (&store_copies, FIRST_PSEUDO_REGISTER, j, rsi)\n+\t    {\n+\t      try_swap_copy_prop (loop, reg, j);\n+\t    }\n \t  CLEAR_REG_SET (&store_copies);\n \t}\n     }"}, {"sha": "e35f1210c0ca3cd9692752c1bb4c020a937b62c4", "filename": "gcc/reload1.c", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -523,28 +523,28 @@ void\n compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n {\n   unsigned int regno;\n+  reg_set_iterator rsi;\n \n-  EXECUTE_IF_SET_IN_REG_SET\n-    (from, FIRST_PSEUDO_REGISTER, regno,\n-     {\n-       int r = reg_renumber[regno];\n-       int nregs;\n-\n-       if (r < 0)\n-\t {\n-\t   /* reload_combine uses the information from\n-\t      BASIC_BLOCK->global_live_at_start, which might still\n-\t      contain registers that have not actually been allocated\n-\t      since they have an equivalence.  */\n-\t   gcc_assert (reload_completed);\n-\t }\n-       else\n-\t {\n-\t   nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n-\t   while (nregs-- > 0)\n-\t     SET_HARD_REG_BIT (*to, r + nregs);\n-\t }\n-     });\n+  EXECUTE_IF_SET_IN_REG_SET (from, FIRST_PSEUDO_REGISTER, regno, rsi)\n+    {\n+      int r = reg_renumber[regno];\n+      int nregs;\n+\n+      if (r < 0)\n+\t{\n+\t  /* reload_combine uses the information from\n+\t     BASIC_BLOCK->global_live_at_start, which might still\n+\t     contain registers that have not actually been allocated\n+\t     since they have an equivalence.  */\n+\t  gcc_assert (reload_completed);\n+\t}\n+      else\n+\t{\n+\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t  while (nregs-- > 0)\n+\t    SET_HARD_REG_BIT (*to, r + nregs);\n+\t}\n+    }\n }\n \n /* Replace all pseudos found in LOC with their corresponding\n@@ -1593,6 +1593,7 @@ order_regs_for_reload (struct insn_chain *chain)\n   int i;\n   HARD_REG_SET used_by_pseudos;\n   HARD_REG_SET used_by_pseudos2;\n+  reg_set_iterator rsi;\n \n   COPY_HARD_REG_SET (bad_spill_regs, fixed_reg_set);\n \n@@ -1613,15 +1614,15 @@ order_regs_for_reload (struct insn_chain *chain)\n   CLEAR_REG_SET (&pseudos_counted);\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       count_pseudo (i);\n-     });\n+    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i, rsi)\n+    {\n+      count_pseudo (i);\n+    }\n   EXECUTE_IF_SET_IN_REG_SET\n-    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       count_pseudo (i);\n-     });\n+    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i, rsi)\n+    {\n+      count_pseudo (i);\n+    }\n   CLEAR_REG_SET (&pseudos_counted);\n }\n \f\n@@ -1667,6 +1668,7 @@ find_reg (struct insn_chain *chain, int order)\n   int k;\n   HARD_REG_SET not_usable;\n   HARD_REG_SET used_by_other_reload;\n+  reg_set_iterator rsi;\n \n   COPY_HARD_REG_SET (not_usable, bad_spill_regs);\n   IOR_HARD_REG_SET (not_usable, bad_spill_regs_global);\n@@ -1735,16 +1737,16 @@ find_reg (struct insn_chain *chain, int order)\n   rl->regno = best_reg;\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n-     {\n-       count_spilled_pseudo (best_reg, rl->nregs, j);\n-     });\n+    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, j, rsi)\n+    {\n+      count_spilled_pseudo (best_reg, rl->nregs, j);\n+    }\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n-     {\n-       count_spilled_pseudo (best_reg, rl->nregs, j);\n-     });\n+    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, j, rsi)\n+    {\n+      count_spilled_pseudo (best_reg, rl->nregs, j);\n+    }\n \n   for (i = 0; i < rl->nregs; i++)\n     {\n@@ -3552,6 +3554,7 @@ finish_spills (int global)\n   struct insn_chain *chain;\n   int something_changed = 0;\n   int i;\n+  reg_set_iterator rsi;\n \n   /* Build the spill_regs array for the function.  */\n   /* If there are some registers still to eliminate and one of the spill regs\n@@ -3578,20 +3581,19 @@ finish_spills (int global)\n     else\n       spill_reg_order[i] = -1;\n \n-  EXECUTE_IF_SET_IN_REG_SET\n-    (&spilled_pseudos, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       /* Record the current hard register the pseudo is allocated to in\n-\t  pseudo_previous_regs so we avoid reallocating it to the same\n-\t  hard reg in a later pass.  */\n-       gcc_assert (reg_renumber[i] >= 0);\n-\n-       SET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n-       /* Mark it as no longer having a hard register home.  */\n-       reg_renumber[i] = -1;\n-       /* We will need to scan everything again.  */\n-       something_changed = 1;\n-     });\n+  EXECUTE_IF_SET_IN_REG_SET (&spilled_pseudos, FIRST_PSEUDO_REGISTER, i, rsi)\n+    {\n+      /* Record the current hard register the pseudo is allocated to in\n+\t pseudo_previous_regs so we avoid reallocating it to the same\n+\t hard reg in a later pass.  */\n+      gcc_assert (reg_renumber[i] >= 0);\n+\n+      SET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n+      /* Mark it as no longer having a hard register home.  */\n+      reg_renumber[i] = -1;\n+      /* We will need to scan everything again.  */\n+      something_changed = 1;\n+    }\n \n   /* Retry global register allocation if possible.  */\n   if (global)\n@@ -3603,17 +3605,17 @@ finish_spills (int global)\n       for (chain = insns_need_reload; chain; chain = chain->next_need_reload)\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i,\n-\t     {\n-\t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n-\t\t\t\t &chain->used_spill_regs);\n-\t     });\n+\t    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i, rsi)\n+\t    {\n+\t      ior_hard_reg_set (pseudo_forbidden_regs + i,\n+\t\t\t\t&chain->used_spill_regs);\n+\t    }\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i,\n-\t     {\n-\t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n-\t\t\t\t &chain->used_spill_regs);\n-\t     });\n+\t    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i, rsi)\n+\t    {\n+\t      ior_hard_reg_set (pseudo_forbidden_regs + i,\n+\t\t\t\t&chain->used_spill_regs);\n+\t    }\n \t}\n \n       /* Retry allocating the spilled pseudos.  For each reg, merge the"}, {"sha": "08e940cd01c5d6a0ff74c3b3f9dc0efd57d1717f", "filename": "gcc/resource.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -971,26 +971,25 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n       unsigned int j;\n       unsigned int regno;\n       rtx start_insn, stop_insn;\n+      reg_set_iterator rsi;\n \n       /* Compute hard regs live at start of block -- this is the real hard regs\n \t marked live, plus live pseudo regs that have been renumbered to\n \t hard regs.  */\n \n       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);\n \n-      EXECUTE_IF_SET_IN_REG_SET\n-\t(regs_live, FIRST_PSEUDO_REGISTER, i,\n-\t {\n-\t   if (reg_renumber[i] >= 0)\n-\t     {\n-\t       regno = reg_renumber[i];\n-\t       for (j = regno;\n-\t\t    j < regno + hard_regno_nregs[regno]\n-\t\t\t\t\t\t[PSEUDO_REGNO_MODE (i)];\n-\t\t    j++)\n-\t\t SET_HARD_REG_BIT (current_live_regs, j);\n-\t     }\n-\t });\n+      EXECUTE_IF_SET_IN_REG_SET (regs_live, FIRST_PSEUDO_REGISTER, i, rsi)\n+\t{\n+\t  if (reg_renumber[i] >= 0)\n+\t    {\n+\t      regno = reg_renumber[i];\n+\t      for (j = regno;\n+\t\t   j < regno + hard_regno_nregs[regno][PSEUDO_REGNO_MODE (i)];\n+\t\t   j++)\n+\t\tSET_HARD_REG_BIT (current_live_regs, j);\n+\t    }\n+\t}\n \n       /* Get starting and ending insn, handling the case where each might\n \t be a SEQUENCE.  */"}, {"sha": "1df1b47facb750a598862458caa1be0a62eaec30", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -822,6 +822,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n   RTX_CODE code = GET_CODE (x);\n   rtx link;\n   int i;\n+  reg_set_iterator rsi;\n \n   if (code == COND_EXEC)\n     {\n@@ -895,14 +896,14 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  (*current_sched_info->compute_jump_reg_dependencies)\n \t    (insn, &deps->reg_conditional_sets, &tmp_uses, &tmp_sets);\n \t  /* Make latency of jump equal to 0 by using anti-dependence.  */\n-\t  EXECUTE_IF_SET_IN_REG_SET (&tmp_uses, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (&tmp_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->sets, REG_DEP_ANTI);\n \t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_ANTI);\n \t      reg_last->uses_length++;\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n-\t    });\n+\t    }\n \t  IOR_REG_SET (reg_pending_sets, &tmp_sets);\n \n \t  CLEAR_REG_SET (&tmp_uses);\n@@ -975,7 +976,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n          real, so we use anti-dependence here.  */\n       if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t{\n-\t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n@@ -985,11 +986,11 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t      add_dependence_list\n \t\t(insn, reg_last->clobbers,\n \t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n-\t    });\n+\t    }\n \t}\n       else\n \t{\n-\t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list_and_free (insn, &reg_last->uses,\n@@ -1002,7 +1003,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n-\t    });\n+\t    }\n \t}\n \n       for (i = 0; i < deps->max_reg; i++)\n@@ -1022,43 +1023,43 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t of the lists.  */\n       if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t{\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->sets, 0);\n \t      add_dependence_list (insn, reg_last->clobbers, 0);\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t      reg_last->uses_length++;\n-\t    });\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i,\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT);\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n \t      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n \t      reg_last->clobbers_length++;\n-\t    });\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT);\n \t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_OUTPUT);\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n \t      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t      SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n-\t    });\n+\t    }\n \t}\n       else\n \t{\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->sets, 0);\n \t      add_dependence_list (insn, reg_last->clobbers, 0);\n \t      reg_last->uses_length++;\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n-\t    });\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i,\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      if (reg_last->uses_length > MAX_PENDING_LIST_LENGTH\n@@ -1081,8 +1082,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t\t}\n \t      reg_last->clobbers_length++;\n \t      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n-\t    });\n-\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list_and_free (insn, &reg_last->sets,\n@@ -1095,7 +1096,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n \t      CLEAR_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n-\t    });\n+\t    }\n \t}\n \n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_uses);\n@@ -1461,6 +1462,7 @@ void\n free_deps (struct deps *deps)\n {\n   int i;\n+  reg_set_iterator rsi;\n \n   free_INSN_LIST_list (&deps->pending_read_insns);\n   free_EXPR_LIST_list (&deps->pending_read_mems);\n@@ -1471,7 +1473,7 @@ free_deps (struct deps *deps)\n   /* Without the EXECUTE_IF_SET, this loop is executed max_reg * nr_regions\n      times.  For a testcase with 42000 regs and 8000 small basic blocks,\n      this loop accounted for nearly 60% (84 sec) of the total -O2 runtime.  */\n-  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i,\n+  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n     {\n       struct deps_reg *reg_last = &deps->reg_last[i];\n       if (reg_last->uses)\n@@ -1480,7 +1482,7 @@ free_deps (struct deps *deps)\n \tfree_INSN_LIST_list (&reg_last->sets);\n       if (reg_last->clobbers)\n \tfree_INSN_LIST_list (&reg_last->clobbers);\n-    });\n+    }\n   CLEAR_REG_SET (&deps->reg_last_in_use);\n   CLEAR_REG_SET (&deps->reg_conditional_sets);\n "}, {"sha": "be1351980df1b6b16c2ca0997c3717905259c91e", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2041967826c644f860ec12c6f32214b1e3d3899/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=a2041967826c644f860ec12c6f32214b1e3d3899", "patch": "@@ -1987,6 +1987,7 @@ propagate_deps (int bb, struct deps *pred_deps)\n     {\n       struct deps *succ_deps;\n       int reg;\n+      reg_set_iterator rsi;\n \n       /* Only bbs \"below\" bb, in the same region, are interesting.  */\n       if (e->dest == EXIT_BLOCK_PTR\n@@ -1997,7 +1998,7 @@ propagate_deps (int bb, struct deps *pred_deps)\n       succ_deps = bb_deps + BLOCK_TO_BB (e->dest->index);\n \n       /* The reg_last lists are inherited by successor.  */\n-      EXECUTE_IF_SET_IN_REG_SET (&pred_deps->reg_last_in_use, 0, reg,\n+      EXECUTE_IF_SET_IN_REG_SET (&pred_deps->reg_last_in_use, 0, reg, rsi)\n \t{\n \t  struct deps_reg *pred_rl = &pred_deps->reg_last[reg];\n \t  struct deps_reg *succ_rl = &succ_deps->reg_last[reg];\n@@ -2008,7 +2009,7 @@ propagate_deps (int bb, struct deps *pred_deps)\n \t\t\t\t\t\tsucc_rl->clobbers);\n \t  succ_rl->uses_length += pred_rl->uses_length;\n \t  succ_rl->clobbers_length += pred_rl->clobbers_length;\n-\t});\n+\t}\n       IOR_REG_SET (&succ_deps->reg_last_in_use, &pred_deps->reg_last_in_use);\n \n       /* Mem read/write lists are inherited by successor.  */"}]}