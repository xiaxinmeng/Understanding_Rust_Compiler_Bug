{"sha": "c7a494c99b4a421f6b80af834adb0d4c703d47a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhNDk0Yzk5YjRhNDIxZjZiODBhZjgzNGFkYjBkNGM3MDNkNDdhNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:22:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:22:50Z"}, "message": "[multiple changes]\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Entry_Call): Check whether a protected\n\toperation is subject to a pragma Eliminate.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elim.ads, exp_ch4.adb: Minor reformatting.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* fe.h (Eliminate_Error_Msg): Remove.\n\nFrom-SVN: r251755", "tree": {"sha": "bc628931a1f77422761b640cd066ff3201bbe5bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc628931a1f77422761b640cd066ff3201bbe5bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a494c99b4a421f6b80af834adb0d4c703d47a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a494c99b4a421f6b80af834adb0d4c703d47a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a494c99b4a421f6b80af834adb0d4c703d47a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a494c99b4a421f6b80af834adb0d4c703d47a5/comments", "author": null, "committer": null, "parents": [{"sha": "3581d5dbf0c6be20e837ea27092b38f5de23c93b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3581d5dbf0c6be20e837ea27092b38f5de23c93b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3581d5dbf0c6be20e837ea27092b38f5de23c93b"}], "stats": {"total": 124, "additions": 68, "deletions": 56}, "files": [{"sha": "f6f19dc3b907d3d1bcb330103a8e277af08b8909", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c7a494c99b4a421f6b80af834adb0d4c703d47a5", "patch": "@@ -1,3 +1,17 @@\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Entry_Call): Check whether a protected\n+\toperation is subject to a pragma Eliminate.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_elim.ads, exp_ch4.adb: Minor reformatting.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h (Eliminate_Error_Msg): Remove.\n+\n+\n 2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc-interface/utils.c (make_packable_type): Update call to"}, {"sha": "fb5727516847b972fbbe09f320e6192118897d25", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c7a494c99b4a421f6b80af834adb0d4c703d47a5", "patch": "@@ -128,10 +128,10 @@ package body Exp_Ch4 is\n    --  Common expansion processing for Boolean operators (And, Or, Xor) for the\n    --  case of array type arguments.\n \n-   procedure Expand_Non_Binary_Modular_Op (N : Node_Id);\n-   --  Generating C code convert non-binary modular arithmetic operations into\n-   --  code that relies on the frontend expansion of operator Mod. No expansion\n-   --  is performed if N is not a non-binary modular operand.\n+   procedure Expand_Nonbinary_Modular_Op (N : Node_Id);\n+   --  When generating C code, convert nonbinary modular arithmetic operations\n+   --  into code that relies on the front-end expansion of operator Mod. No\n+   --  expansion is performed if N is not a nonbinary modular operand.\n \n    procedure Expand_Short_Circuit_Operator (N : Node_Id);\n    --  Common expansion processing for short-circuit boolean operators\n@@ -3962,23 +3962,23 @@ package body Exp_Ch4 is\n       end if;\n    end Expand_Membership_Minimize_Eliminate_Overflow;\n \n-   ----------------------------------\n-   -- Expand_Non_Binary_Modular_Op --\n-   ----------------------------------\n+   ---------------------------------\n+   -- Expand_Nonbinary_Modular_Op --\n+   ---------------------------------\n \n-   procedure Expand_Non_Binary_Modular_Op (N : Node_Id) is\n+   procedure Expand_Nonbinary_Modular_Op (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n \n       procedure Expand_Modular_Addition;\n-      --  Expand the modular addition handling the special case of adding a\n+      --  Expand the modular addition, handling the special case of adding a\n       --  constant.\n \n       procedure Expand_Modular_Op;\n       --  Compute the general rule: (lhs OP rhs) mod Modulus\n \n       procedure Expand_Modular_Subtraction;\n-      --  Expand the modular addition handling the special case of subtracting\n+      --  Expand the modular addition, handling the special case of subtracting\n       --  a constant.\n \n       -----------------------------\n@@ -4048,10 +4048,9 @@ package body Exp_Ch4 is\n          Mod_Expr : constant Node_Id := New_Op_Node (N_Op_Mod, Loc);\n \n       begin\n-         --  Convert non-binary modular type operands into integer or integer\n-         --  values. Thus we avoid never-ending loops expanding them, and we\n-         --  also ensure that the backend never receives non-binary modular\n-         --  type expressions.\n+         --  Convert nonbinary modular type operands into integer values. Thus\n+         --  we avoid never-ending loops expanding them, and we also ensure\n+         --  the back end never receives nonbinary modular type expressions.\n \n          if Nkind_In (Nkind (N), N_Op_And, N_Op_Or) then\n             Set_Left_Opnd (Op_Expr,\n@@ -4138,10 +4137,10 @@ package body Exp_Ch4 is\n          end if;\n       end Expand_Modular_Subtraction;\n \n-   --  Start of processing for Expand_Non_Binary_Modular_Op\n+   --  Start of processing for Expand_Nonbinary_Modular_Op\n \n    begin\n-      --  No action needed if we are not generating C code for a non-binary\n+      --  No action needed if we are not generating C code for a nonbinary\n       --  modular operand.\n \n       if not Modify_Tree_For_C\n@@ -4171,7 +4170,7 @@ package body Exp_Ch4 is\n       end case;\n \n       Analyze_And_Resolve (N, Typ);\n-   end Expand_Non_Binary_Modular_Op;\n+   end Expand_Nonbinary_Modular_Op;\n \n    ------------------------\n    -- Expand_N_Allocator --\n@@ -6112,7 +6111,7 @@ package body Exp_Ch4 is\n             if Is_Tagged_Type (Typ) then\n \n                --  No expansion will be performed for VM targets, as the VM\n-               --  back-ends will handle the membership tests directly.\n+               --  back ends will handle the membership tests directly.\n \n                if Tagged_Type_Expansion then\n                   Tagged_Membership (N, SCIL_Node, New_N);\n@@ -6370,7 +6369,7 @@ package body Exp_Ch4 is\n                                 Right_Opnd => Make_Null (Loc))));\n \n                         --  No expansion will be performed for VM targets, as\n-                        --  the VM back-ends will handle the membership tests\n+                        --  the VM back ends will handle the membership tests\n                         --  directly.\n \n                         if Tagged_Type_Expansion then\n@@ -6736,7 +6735,7 @@ package body Exp_Ch4 is\n    --  is an access to protected subprogram, or a subtype thereof. We represent\n    --  such access values as a record, and so we must replace the occurrence of\n    --  null by the equivalent record (with a null address and a null pointer in\n-   --  it), so that the backend creates the proper value.\n+   --  it), so that the back end creates the proper value.\n \n    procedure Expand_N_Null (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -6856,11 +6855,11 @@ package body Exp_Ch4 is\n \n       Check_Float_Op_Overflow (N);\n \n-      --  Generating C code convert non-binary modular additions into code that\n-      --  relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular additions into code\n+      --  that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Add;\n \n@@ -6887,11 +6886,11 @@ package body Exp_Ch4 is\n          Expand_Intrinsic_Call (N, Entity (N));\n       end if;\n \n-      --  Generating C code convert non-binary modular operators into code that\n-      --  relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular operators into code\n+      --  that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_And;\n \n@@ -7134,11 +7133,11 @@ package body Exp_Ch4 is\n \n       Check_Float_Op_Overflow (N);\n \n-      --  Generating C code convert non-binary modular divisions into code that\n-      --  relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular divisions into code\n+      --  that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Divide;\n \n@@ -7844,7 +7843,7 @@ package body Exp_Ch4 is\n \n          --  Otherwise expand the component by component equality. Note that\n          --  we never use block-bit comparisons for records, because of the\n-         --  problems with gaps. The backend will often be able to recombine\n+         --  problems with gaps. The back end will often be able to recombine\n          --  the separate comparisons that we generate here.\n \n          else\n@@ -8643,11 +8642,11 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Typ);\n       end if;\n \n-      --  Generating C code convert non-binary modular minus into code that\n-      --  relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular minus into code\n+      --  that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Minus;\n \n@@ -9126,11 +9125,11 @@ package body Exp_Ch4 is\n \n       Check_Float_Op_Overflow (N);\n \n-      --  Generating C code convert non-binary modular multiplications into\n-      --  code that relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular multiplications\n+      --  into code that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Multiply;\n \n@@ -9443,11 +9442,11 @@ package body Exp_Ch4 is\n          Expand_Intrinsic_Call (N, Entity (N));\n       end if;\n \n-      --  Generating C code convert non-binary modular operators into code that\n-      --  relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular operators into code\n+      --  that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Or;\n \n@@ -9882,11 +9881,11 @@ package body Exp_Ch4 is\n \n       Check_Float_Op_Overflow (N);\n \n-      --  Generating C code convert non-binary modular subtractions into code\n-      --  that relies on the frontend expansion of operator Mod.\n+      --  When generating C code, convert nonbinary modular subtractions into\n+      --  code that relies on the front-end expansion of operator Mod.\n \n       if Modify_Tree_For_C then\n-         Expand_Non_Binary_Modular_Op (N);\n+         Expand_Nonbinary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Subtract;\n \n@@ -10441,7 +10440,7 @@ package body Exp_Ch4 is\n \n       procedure Make_Temporary_For_Slice;\n       --  Create a named variable for the value of the slice, in cases where\n-      --  the back-end cannot handle it properly, e.g. when packed types or\n+      --  the back end cannot handle it properly, e.g. when packed types or\n       --  unaligned slices are involved.\n \n       -------------------------\n@@ -11808,7 +11807,7 @@ package body Exp_Ch4 is\n    --      and then ...\n    --      and then Lhs.Cmpn = Rhs.Cmpn\n \n-   --  The expression is folded by the back-end for adjacent fields. This\n+   --  The expression is folded by the back end for adjacent fields. This\n    --  function is called for tagged record in only one occasion: for imple-\n    --  menting predefined primitive equality (see Predefined_Primitives_Bodies)\n    --  otherwise the primitive \"=\" is used directly."}, {"sha": "0ab37720a8d0be546ed21b2d6b5b03e52c97f15a", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=c7a494c99b4a421f6b80af834adb0d4c703d47a5", "patch": "@@ -242,12 +242,6 @@ extern Entity_Id  First_Subtype                (Entity_Id);\n extern Boolean    Is_By_Reference_Type         (Entity_Id);\n extern Boolean    Is_Derived_Type              (Entity_Id);\n \n-/* sem_elim: */\n-\n-#define Eliminate_Error_Msg    sem_elim__eliminate_error_msg\n-\n-extern void Eliminate_Error_Msg (Node_Id, Entity_Id);\n-\n /* sem_eval: */\n \n #define Compile_Time_Known_Value\tsem_eval__compile_time_known_value"}, {"sha": "35aadf97b8033cb18abc7cbafbb19e1bd203be0a", "filename": "gcc/ada/sem_elim.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fsem_elim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fsem_elim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.ads?ref=c7a494c99b4a421f6b80af834adb0d4c703d47a5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,9 +60,9 @@ package Sem_Elim is\n    --  error will be posted on N.\n \n    procedure Eliminate_Error_Msg (N : Node_Id; E : Entity_Id);\n-   --  Called by the front-end and back-end on encountering a reference to an\n-   --  eliminated subprogram. N is the node for the reference (such as occurs\n-   --  in a call or attribute), and E is the entity of the subprogram that has\n-   --  been eliminated.\n+   --  Called by the front-end on encountering a reference to an eliminated\n+   --  subprogram. N is the node for the reference (such as occurs in a call,\n+   --  a protected call or an  attribute), and E is the entity of the\n+   --  subprogram that has been eliminated.\n \n end Sem_Elim;"}, {"sha": "79e21e83e1dc551c45bd420c2550ecde0a5340cd", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a494c99b4a421f6b80af834adb0d4c703d47a5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c7a494c99b4a421f6b80af834adb0d4c703d47a5", "patch": "@@ -7519,10 +7519,15 @@ package body Sem_Res is\n \n       if Nkind (Entry_Name) = N_Selected_Component then\n \n-         --  Simple entry call\n+         --  Simple entry or protected operation call\n \n          Nam := Entity (Selector_Name (Entry_Name));\n          Obj := Prefix (Entry_Name);\n+\n+         if Is_Subprogram (Nam) then\n+            Check_For_Eliminated_Subprogram (Entry_Name, Nam);\n+         end if;\n+\n          Was_Over := Is_Overloaded (Selector_Name (Entry_Name));\n \n       else pragma Assert (Nkind (Entry_Name) = N_Indexed_Component);"}]}