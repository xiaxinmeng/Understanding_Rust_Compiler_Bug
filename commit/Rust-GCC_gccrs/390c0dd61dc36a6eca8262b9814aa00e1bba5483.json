{"sha": "390c0dd61dc36a6eca8262b9814aa00e1bba5483", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwYzBkZDYxZGMzNmE2ZWNhODI2MmI5ODE0YWEwMGUxYmJhNTQ4Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-29T14:19:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-29T14:19:07Z"}, "message": "re PR tree-optimization/91257 (Compile-time and memory-hog hog)\n\n2019-07-29  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91257\n\t* tree-ssa-sccvn.h (struct vn_avail): New.\n\t(struct vn_ssa_aux): Add avail member.\n\t* tree-ssa-sccvn.c (class rpo_elim): Remove m_rpo_avail\n\tmember, add m_avail_freelist one.\n\t(rpo_elim::~rpo_elim): Remove.\n\t(rpo_elim::eliminate_avail): Adjust to new avail tracking\n\tdata structure.\n\t(rpo_elim::eliminate_push_avail): Likewise.\n\t(do_unwind): Likewise.\n\t(do_rpo_vn): Likewise.\n\nFrom-SVN: r273877", "tree": {"sha": "47a479d6a59cd0ff44df32697230766852c9b8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47a479d6a59cd0ff44df32697230766852c9b8c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390c0dd61dc36a6eca8262b9814aa00e1bba5483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390c0dd61dc36a6eca8262b9814aa00e1bba5483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390c0dd61dc36a6eca8262b9814aa00e1bba5483", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390c0dd61dc36a6eca8262b9814aa00e1bba5483/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a55d6091230ae8d0d6f6c20dcc55158f6705090e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55d6091230ae8d0d6f6c20dcc55158f6705090e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a55d6091230ae8d0d6f6c20dcc55158f6705090e"}], "stats": {"total": 133, "additions": 77, "deletions": 56}, "files": [{"sha": "7bdb466e09706b020992ab8294137ca1fa1b413c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=390c0dd61dc36a6eca8262b9814aa00e1bba5483", "patch": "@@ -1,3 +1,17 @@\n+2019-07-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91257\n+\t* tree-ssa-sccvn.h (struct vn_avail): New.\n+\t(struct vn_ssa_aux): Add avail member.\n+\t* tree-ssa-sccvn.c (class rpo_elim): Remove m_rpo_avail\n+\tmember, add m_avail_freelist one.\n+\t(rpo_elim::~rpo_elim): Remove.\n+\t(rpo_elim::eliminate_avail): Adjust to new avail tracking\n+\tdata structure.\n+\t(rpo_elim::eliminate_push_avail): Likewise.\n+\t(do_unwind): Likewise.\n+\t(do_rpo_vn): Likewise.\n+\n 2019-07-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91257"}, {"sha": "a2cb237293e4bd427fa0c8a9af29701b78b6d63e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=390c0dd61dc36a6eca8262b9814aa00e1bba5483", "patch": "@@ -2126,36 +2126,17 @@ class rpo_elim : public eliminate_dom_walker\n {\n public:\n   rpo_elim(basic_block entry_)\n-    : eliminate_dom_walker (CDI_DOMINATORS, NULL), entry (entry_) {}\n-  ~rpo_elim();\n+    : eliminate_dom_walker (CDI_DOMINATORS, NULL), entry (entry_),\n+      m_avail_freelist (NULL) {}\n \n   virtual tree eliminate_avail (basic_block, tree op);\n \n   virtual void eliminate_push_avail (basic_block, tree);\n \n   basic_block entry;\n-  /* Instead of having a local availability lattice for each\n-     basic-block and availability at X defined as union of\n-     the local availabilities at X and its dominators we're\n-     turning this upside down and track availability per\n-     value given values are usually made available at very\n-     few points (at least one).\n-     So we have a value -> vec<location, leader> map where\n-     LOCATION is specifying the basic-block LEADER is made\n-     available for VALUE.  We push to this vector in RPO\n-     order thus for iteration we can simply pop the last\n-     entries.\n-     LOCATION is the basic-block index and LEADER is its\n-     SSA name version.  */\n-  /* ???  We'd like to use auto_vec here with embedded storage\n-     but that doesn't play well until we can provide move\n-     constructors and use std::move on hash-table expansion.\n-     So for now this is a bit more expensive than necessary.\n-     We eventually want to switch to a chaining scheme like\n-     for hashtable entries for unwinding which would make\n-     making the vector part of the vn_ssa_aux structure possible.  */\n-  typedef hash_map<tree, vec<std::pair<int, int> > > rpo_avail_t;\n-  rpo_avail_t m_rpo_avail;\n+  /* Freelist of avail entries which are allocated from the vn_ssa_aux\n+     obstack.  */\n+  vn_avail *m_avail_freelist;\n };\n \n /* Global RPO state for access from hooks.  */\n@@ -6197,14 +6178,6 @@ vn_lookup_simplify_result (gimple_match_op *res_op)\n   return res;\n }\n \n-rpo_elim::~rpo_elim ()\n-{\n-  /* Release the avail vectors.  */\n-  for (rpo_avail_t::iterator i = m_rpo_avail.begin ();\n-       i != m_rpo_avail.end (); ++i)\n-    (*i).second.release ();\n-}\n-\n /* Return a leader for OPs value that is valid at BB.  */\n \n tree\n@@ -6220,16 +6193,15 @@ rpo_elim::eliminate_avail (basic_block bb, tree op)\n     {\n       if (SSA_NAME_IS_DEFAULT_DEF (valnum))\n \treturn valnum;\n-      vec<std::pair<int, int> > *av = m_rpo_avail.get (valnum);\n-      if (!av || av->is_empty ())\n+      vn_avail *av = VN_INFO (valnum)->avail;\n+      if (!av)\n \treturn NULL_TREE;\n-      int i = av->length () - 1;\n-      if ((*av)[i].first == bb->index)\n+      if (av->location == bb->index)\n \t/* On tramp3d 90% of the cases are here.  */\n-\treturn ssa_name ((*av)[i].second);\n+\treturn ssa_name (av->leader);\n       do\n \t{\n-\t  basic_block abb = BASIC_BLOCK_FOR_FN (cfun, (*av)[i].first);\n+\t  basic_block abb = BASIC_BLOCK_FOR_FN (cfun, av->location);\n \t  /* ???  During elimination we have to use availability at the\n \t     definition site of a use we try to replace.  This\n \t     is required to not run into inconsistencies because\n@@ -6243,7 +6215,7 @@ rpo_elim::eliminate_avail (basic_block bb, tree op)\n \t     executable.  */\n \t  if (dominated_by_p_w_unex (bb, abb))\n \t    {\n-\t      tree leader = ssa_name ((*av)[i].second);\n+\t      tree leader = ssa_name (av->leader);\n \t      /* Prevent eliminations that break loop-closed SSA.  */\n \t      if (loops_state_satisfies_p (LOOP_CLOSED_SSA)\n \t\t  && ! SSA_NAME_IS_DEFAULT_DEF (leader)\n@@ -6265,8 +6237,9 @@ rpo_elim::eliminate_avail (basic_block bb, tree op)\n \t  /* ???  Can we somehow skip to the immediate dominator\n \t     RPO index (bb_to_rpo)?  Again, maybe not worth, on\n \t     tramp3d the worst number of elements in the vector is 9.  */\n+\t  av = av->next;\n \t}\n-      while (--i >= 0);\n+      while (av);\n     }\n   else if (valnum != VN_TOP)\n     /* valnum is is_gimple_min_invariant.  */\n@@ -6290,15 +6263,19 @@ rpo_elim::eliminate_push_avail (basic_block bb, tree leader)\n       print_generic_expr (dump_file, valnum);\n       fprintf (dump_file, \"\\n\");\n     }\n-  bool existed;\n-  vec<std::pair<int, int> > &av = m_rpo_avail.get_or_insert (valnum, &existed);\n-  if (!existed)\n+  vn_ssa_aux_t value = VN_INFO (valnum);\n+  vn_avail *av;\n+  if (m_avail_freelist)\n     {\n-      new (&av) vec<std::pair<int, int> >;\n-      av = vNULL;\n-      av.reserve_exact (2);\n+      av = m_avail_freelist;\n+      m_avail_freelist = m_avail_freelist->next;\n     }\n-  av.safe_push (std::make_pair (bb->index, SSA_NAME_VERSION (leader)));\n+  else\n+    av = XOBNEW (&vn_ssa_aux_obstack, vn_avail);\n+  av->location = bb->index;\n+  av->leader = SSA_NAME_VERSION (leader);\n+  av->next = value->avail;\n+  value->avail = av;\n }\n \n /* Valueization hook for RPO VN plus required state.  */\n@@ -6780,15 +6757,17 @@ do_unwind (unwind_state *to, int rpo_idx, rpo_elim &avail, int *bb_to_rpo)\n   /* Prune [rpo_idx, ] from avail.  */\n   /* ???  This is O(number-of-values-in-region) which is\n      O(region-size) rather than O(iteration-piece).  */\n-  for (rpo_elim::rpo_avail_t::iterator i\n-       = avail.m_rpo_avail.begin ();\n-       i != avail.m_rpo_avail.end (); ++i)\n+  for (hash_table<vn_ssa_aux_hasher>::iterator i = vn_ssa_aux_hash->begin ();\n+       i != vn_ssa_aux_hash->end (); ++i)\n     {\n-      while (! (*i).second.is_empty ())\n+      while ((*i)->avail)\n \t{\n-\t  if (bb_to_rpo[(*i).second.last ().first] < rpo_idx)\n+\t  if (bb_to_rpo[(*i)->avail->location] < rpo_idx)\n \t    break;\n-\t  (*i).second.pop ();\n+\t  vn_avail *av = (*i)->avail;\n+\t  (*i)->avail = (*i)->avail->next;\n+\t  av->next = avail.m_avail_freelist;\n+\t  avail.m_avail_freelist = av;\n \t}\n     }\n }\n@@ -7184,11 +7163,16 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \tmax_visited = rpo_state[i].visited;\n     }\n   unsigned nvalues = 0, navail = 0;\n-  for (rpo_elim::rpo_avail_t::iterator i = avail.m_rpo_avail.begin ();\n-       i != avail.m_rpo_avail.end (); ++i)\n+  for (hash_table<vn_ssa_aux_hasher>::iterator i = vn_ssa_aux_hash->begin ();\n+       i != vn_ssa_aux_hash->end (); ++i)\n     {\n       nvalues++;\n-      navail += (*i).second.length ();\n+      vn_avail *av = (*i)->avail;\n+      while (av)\n+\t{\n+\t  navail++;\n+\t  av = av->next;\n+\t}\n     }\n   statistics_counter_event (cfun, \"RPO blocks\", n);\n   statistics_counter_event (cfun, \"RPO blocks visited\", nblk);"}, {"sha": "1a5f238958621622a14d209be78f6fdd7e2c53a5", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390c0dd61dc36a6eca8262b9814aa00e1bba5483/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=390c0dd61dc36a6eca8262b9814aa00e1bba5483", "patch": "@@ -193,6 +193,25 @@ vn_constant_eq_with_type (tree c1, tree c2)\n \t  && types_compatible_p (TREE_TYPE (c1), TREE_TYPE (c2)));\n }\n \n+/* Instead of having a local availability lattice for each basic-block\n+   and availability at X defined as union of the local availabilities\n+   at X and its dominators we're turning this upside down and track\n+   availability per value given values are usually made available at very\n+   few points.\n+   So we have a chain of LOCATION, LEADER entries where LOCATION is\n+   specifying the basic-block LEADER is made available for VALUE.\n+   We prepend to this chain in RPO order thus for iteration we can simply\n+   remove the last entries.\n+   LOCATION is the basic-block index and LEADER is its SSA name version.  */\n+struct vn_avail\n+{\n+  vn_avail *next;\n+  /* The basic-block LEADER is made available.  */\n+  int location;\n+  /* The LEADER for the value we are chained on.  */\n+  int leader;\n+};\n+\n typedef struct vn_ssa_aux\n {\n   /* SSA name this vn_ssa_aux is associated with in the lattice.  */\n@@ -202,6 +221,10 @@ typedef struct vn_ssa_aux\n   /* Statements to insert if needs_insertion is true.  */\n   gimple_seq expr;\n \n+  /* AVAIL entries, last in RPO order is first.  This is only tracked\n+     for SSA names also serving as values (NAME == VALNUM).  */\n+  vn_avail *avail;\n+\n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n "}]}