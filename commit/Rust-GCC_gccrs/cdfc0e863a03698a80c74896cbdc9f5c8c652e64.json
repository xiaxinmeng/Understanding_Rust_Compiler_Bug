{"sha": "cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmYzBlODYzYTAzNjk4YTgwYzc0ODk2Y2JkYzlmNWM4YzY1MmU2NA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-08-22T14:52:24Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-08-22T14:52:24Z"}, "message": "[ARM] Cleanup logical DImode operations\n\nCleanup the logical DImode operations since the current implementation is way\ntoo complicated.  Thumb-1, Thumb-2, VFP/Neon and iwMMXt all work differently,\nresulting in a bewildering number of expansions, patterns and splits across\nseveral md files.  All this complexity is counterproductive and results in\ninefficient code.\n\nA much simpler approach is to split these operations early in the expander\nso that optimizations and register allocation are applied on the 32-bit halves.\nCodegeneration is unchanged on Thumb-1 and Arm/Thumb-2 without Neon or iwMMXt\n(which already expand these instructions early).  With Neon these changes save\n~1000 instructions from the PR77308 testcase, mostly by significantly reducing\nregister pressure and spilling.\n\nBootstrap OK on arm-none-linux-gnueabihf --with-cpu=cortex-a57\n\n    gcc/\n\t* config/arm/arm.md (split and/eor/ior): Remove Neon check.\n\t(split not): Add DImode not splitter.\n\t(anddi3): Remove pattern.\n\t(anddi3_insn): Likewise.\n\t(anddi_zesidi_di): Likewise.\n\t(anddi_sesdi_di): Likewise.\n\t(anddi_notdi_di): Likewise.\n\t(anddi_notzesidi_di): Likewise.\n\t(anddi_notsesidi_di): Likewise.\n\t(iordi3): Likewise.\n\t(iordi3_insn): Likewise.\n\t(iordi_zesidi_di): Likewise.\n\t(iordi_sesidi_di): Likewise.\n\t(xordi3): Likewise.\n\t(xordi3_insn): Likewise.\n\t(xordi_sesidi_di): Likewise.\n\t(xordi_zesidi_di): Likewise.\n\t(one_cmpldi2): Likewise.\n\t(one_cmpldi2_insn): Likewise.\n\t* config/arm/constraints.md: Remove De, Df, Dg constraints.\n\t* config/arm/iwmmxt.md (iwmmxt_iordi3): Remove general register\n\talternative.\n\t(iwmmxt_xordi3): Likewise.\n\t(iwmmxt_anddi3): Likewise.\n\t* config/arm/neon.md (orndi3_neon): Remove pattern.\n\t(anddi_notdi_di): Likewise.\n\t* config/arm/predicates.md (arm_anddi_operand_neon): Remove.\n\t(arm_iordi_operand_neon): Likewise.\n\t(arm_xordi_operand_neon): Likewise.\n\t* config/arm/thumb2.md(iordi_notdi_di): Remove pattern.\n\t(iordi_notzesidi_di): Likewise.\n\t(iordi_notdi_zesidi): Likewise.\n\t(iordi_notsesidi_di): Likewise.\n\nFrom-SVN: r274823", "tree": {"sha": "cbf2419858e944cc5860cf9a96861ea3cf17be22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbf2419858e944cc5860cf9a96861ea3cf17be22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/comments", "author": null, "committer": null, "parents": [{"sha": "203ef022c6a0477c33a8cf4a65890e33d0912cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203ef022c6a0477c33a8cf4a65890e33d0912cf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/203ef022c6a0477c33a8cf4a65890e33d0912cf0"}], "stats": {"total": 778, "additions": 65, "deletions": 713}, "files": [{"sha": "e6057c4182458e37dbeaee13133c579a2cedc9eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -1,3 +1,39 @@\n+2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/arm.md (split and/eor/ior): Remove Neon check.\n+\t(split not): Add DImode not splitter.\n+\t(anddi3): Remove pattern.\n+\t(anddi3_insn): Likewise.\n+\t(anddi_zesidi_di): Likewise.\n+\t(anddi_sesdi_di): Likewise.\n+\t(anddi_notdi_di): Likewise.\n+\t(anddi_notzesidi_di): Likewise.\n+\t(anddi_notsesidi_di): Likewise.\n+\t(iordi3): Likewise.\n+\t(iordi3_insn): Likewise.\n+\t(iordi_zesidi_di): Likewise.\n+\t(iordi_sesidi_di): Likewise.\n+\t(xordi3): Likewise.\n+\t(xordi3_insn): Likewise.\n+\t(xordi_sesidi_di): Likewise.\n+\t(xordi_zesidi_di): Likewise.\n+\t(one_cmpldi2): Likewise.\n+\t(one_cmpldi2_insn): Likewise.\n+\t* config/arm/constraints.md: Remove De, Df, Dg constraints.\n+\t* config/arm/iwmmxt.md (iwmmxt_iordi3): Remove general register\n+\talternative.\n+\t(iwmmxt_xordi3): Likewise.\n+\t(iwmmxt_anddi3): Likewise.\n+\t* config/arm/neon.md (orndi3_neon): Remove pattern.\n+\t(anddi_notdi_di): Likewise.\n+\t* config/arm/predicates.md (arm_anddi_operand_neon): Remove.\n+\t(arm_iordi_operand_neon): Likewise.\n+\t(arm_xordi_operand_neon): Likewise.\n+\t* config/arm/thumb2.md(iordi_notdi_di): Remove pattern.\n+\t(iordi_notzesidi_di): Likewise.\n+\t(iordi_notdi_zesidi): Likewise.\n+\t(iordi_notsesidi_di): Likewise.\n+\n 2019-08-22  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (iorsi3_compare0): Add alternative for 16-bit thumb"}, {"sha": "eb5838d24a810ffe5041f5334a61d43a5db193a7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 11, "deletions": 500, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -2198,19 +2198,17 @@\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"\")\n \f\n-;; Boolean and,ior,xor insns\n \n-;; Split up double word logical operations\n-\n-;; Split up simple DImode logical operations.  Simply perform the logical\n+;; Split DImode and, ior, xor operations.  Simply perform the logical\n ;; operation on the upper and lower halves of the registers.\n+;; This is needed for atomic operations in arm_split_atomic_op.\n+;; Avoid splitting IWMMXT instructions.\n (define_split\n   [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n \t(match_operator:DI 6 \"logical_binary_operator\"\n \t  [(match_operand:DI 1 \"s_register_operand\" \"\")\n \t   (match_operand:DI 2 \"s_register_operand\" \"\")]))]\n   \"TARGET_32BIT && reload_completed\n-   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))\n    && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))\"\n   [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))\n    (set (match_dup 3) (match_op_dup:SI 6 [(match_dup 4) (match_dup 5)]))]\n@@ -2225,167 +2223,21 @@\n   }\"\n )\n \n+;; Split DImode not (needed for atomic operations in arm_split_atomic_op).\n+;; Unconditionally split since there is no SIMD DImode NOT pattern.\n (define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(match_operator:DI 6 \"logical_binary_operator\"\n-\t  [(sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t   (match_operand:DI 1 \"s_register_operand\" \"\")]))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))\n-   (set (match_dup 3) (match_op_dup:SI 6\n-\t\t\t[(ashiftrt:SI (match_dup 2) (const_int 31))\n-\t\t\t (match_dup 4)]))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[5] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n-;; The zero extend of operand 2 means we can just copy the high part of\n-;; operand1 into operand0.\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(ior:DI\n-\t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t  (match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && operands[0] != operands[1] && reload_completed\"\n-  [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"\n-  {\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-)\n-\n-;; The zero extend of operand 2 means we can just copy the high part of\n-;; operand1 into operand0.\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(xor:DI\n-\t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t  (match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && operands[0] != operands[1] && reload_completed\"\n-  [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"\n-  {\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-)\n-\n-(define_expand \"anddi3\"\n-  [(set (match_operand:DI         0 \"s_register_operand\")\n-\t(and:DI (match_operand:DI 1 \"s_register_operand\")\n-\t\t(match_operand:DI 2 \"neon_inv_logic_op2\")))]\n-  \"TARGET_32BIT\"\n-  \"\n-  if (!TARGET_NEON && !TARGET_IWMMXT)\n-    {\n-      rtx low  = simplify_gen_binary (AND, SImode,\n-\t\t\t\t      gen_lowpart (SImode, operands[1]),\n-\t\t\t\t      gen_lowpart (SImode, operands[2]));\n-      rtx high = simplify_gen_binary (AND, SImode,\n-\t\t\t\t      gen_highpart (SImode, operands[1]),\n-\t\t\t\t      gen_highpart_mode (SImode, DImode,\n-\t\t\t\t\t\t\t operands[2]));\n-\n-      emit_insn (gen_rtx_SET (gen_lowpart (SImode, operands[0]), low));\n-      emit_insn (gen_rtx_SET (gen_highpart (SImode, operands[0]), high));\n-\n-      DONE;\n-    }\n-  /* Otherwise expand pattern as above.  */\n-  \"\n-)\n-\n-(define_insn_and_split \"*anddi3_insn\"\n-  [(set (match_operand:DI         0 \"s_register_operand\"     \"=w,w ,&r,&r,&r,&r,?w,?w\")\n-        (and:DI (match_operand:DI 1 \"s_register_operand\"     \"%w,0 ,0 ,r ,0 ,r ,w ,0\")\n-                (match_operand:DI 2 \"arm_anddi_operand_neon\" \"w ,DL,r ,r ,De,De,w ,DL\")))]\n-  \"TARGET_32BIT && !TARGET_IWMMXT\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: /* fall through */\n-    case 6: return \"vand\\t%P0, %P1, %P2\";\n-    case 1: /* fall through */\n-    case 7: return neon_output_logic_immediate (\"vand\", &operands[2],\n-                    DImode, 1, VALID_NEON_QREG_MODE (DImode));\n-    case 2:\n-    case 3:\n-    case 4:\n-    case 5: /* fall through */\n-      return \"#\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  \"TARGET_32BIT && !TARGET_IWMMXT && reload_completed\n-   && !(IS_VFP_REGNUM (REGNO (operands[0])))\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))]\n-  \"\n-  {\n-    operands[3] = gen_lowpart (SImode, operands[0]);\n-    operands[5] = gen_highpart (SImode, operands[0]);\n-\n-    operands[4] = simplify_gen_binary (AND, SImode,\n-                                           gen_lowpart (SImode, operands[1]),\n-                                           gen_lowpart (SImode, operands[2]));\n-    operands[6] = simplify_gen_binary (AND, SImode,\n-                                           gen_highpart (SImode, operands[1]),\n-                                           gen_highpart_mode (SImode, DImode, operands[2]));\n-\n-  }\"\n-  [(set_attr \"type\" \"neon_logic,neon_logic,multiple,multiple,\\\n-                     multiple,multiple,neon_logic,neon_logic\")\n-   (set_attr \"arch\" \"neon_for_64bits,neon_for_64bits,*,*,*,*,\n-                     avoid_neon_for_64bits,avoid_neon_for_64bits\")\n-   (set_attr \"length\" \"*,*,8,8,8,8,*,*\")\n-  ]\n-)\n-\n-(define_insn_and_split \"*anddi_zesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (zero_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n+  [(set (match_operand:DI 0 \"s_register_operand\")\n+\t(not:DI (match_operand:DI 1 \"s_register_operand\")))]\n   \"TARGET_32BIT\"\n-  \"#\"\n-  \"TARGET_32BIT && reload_completed\"\n-  ; The zero extend of operand 2 clears the high word of the output\n-  ; operand.\n-  [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3) (const_int 0))]\n+  [(set (match_dup 0) (not:SI (match_dup 1)))\n+   (set (match_dup 2) (not:SI (match_dup 3)))]\n   \"\n   {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[2] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[3] = gen_highpart (SImode, operands[1]);\n     operands[1] = gen_lowpart (SImode, operands[1]);\n   }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*anddi_sesdi_di\"\n-  [(set (match_operand:DI          0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (sign_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI  1 \"s_register_operand\" \"0,r\")))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n )\n \n (define_expand \"andsi3\"\n@@ -2967,105 +2819,6 @@\n    (set_attr \"type\" \"bfm\")]\n )\n \n-; constants for op 2 will never be given to these patterns.\n-(define_insn_and_split \"*anddi_notdi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"s_register_operand\" \"0,r\"))\n-\t\t(match_operand:DI 2 \"s_register_operand\" \"r,0\")))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  \"TARGET_32BIT && reload_completed\n-   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))\n-   && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[5] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*anddi_notzesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (not:DI (zero_extend:DI\n-\t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,?r\")))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   bic%?\\\\t%Q0, %Q1, %2\n-   #\"\n-  ; (not (zero_extend ...)) allows us to just copy the high word from\n-  ; operand1 to operand0.\n-  \"TARGET_32BIT\n-   && reload_completed\n-   && operands[0] != operands[1]\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-  [(set_attr \"length\" \"4,8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*anddi_notdi_zesidi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n-        (and:DI (not:DI (match_operand:DI 2 \"s_register_operand\" \"r\"))\n-                (zero_extend:DI\n-                 (match_operand:SI 1 \"s_register_operand\" \"r\"))))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (const_int 0))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*anddi_notsesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (not:DI (sign_extend:DI\n-\t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (and:SI (not:SI\n-\t\t\t\t(ashiftrt:SI (match_dup 2) (const_int 31)))\n-\t\t\t       (match_dup 4)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn \"andsi_notsi_si\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))\n@@ -3165,101 +2918,6 @@\n    (set_attr \"type\" \"logics_shift_reg\")]\n )\n \n-(define_expand \"iordi3\"\n-  [(set (match_operand:DI         0 \"s_register_operand\")\n-\t(ior:DI (match_operand:DI 1 \"s_register_operand\")\n-\t\t(match_operand:DI 2 \"neon_logic_op2\")))]\n-  \"TARGET_32BIT\"\n-  \"\n-  if (!TARGET_NEON && !TARGET_IWMMXT)\n-    {\n-      rtx low  = simplify_gen_binary (IOR, SImode,\n-\t\t\t\t      gen_lowpart (SImode, operands[1]),\n-\t\t\t\t      gen_lowpart (SImode, operands[2]));\n-      rtx high = simplify_gen_binary (IOR, SImode,\n-\t\t\t\t      gen_highpart (SImode, operands[1]),\n-\t\t\t\t      gen_highpart_mode (SImode, DImode,\n-\t\t\t\t\t\t\t operands[2]));\n-\n-      emit_insn (gen_rtx_SET (gen_lowpart (SImode, operands[0]), low));\n-      emit_insn (gen_rtx_SET (gen_highpart (SImode, operands[0]), high));\n-\n-      DONE;\n-    }\n-  /* Otherwise expand pattern as above.  */\n-  \"\n-)\n-\n-(define_insn_and_split \"*iordi3_insn\"\n-  [(set (match_operand:DI         0 \"s_register_operand\"     \"=w,w ,&r,&r,&r,&r,?w,?w\")\n-\t(ior:DI (match_operand:DI 1 \"s_register_operand\"     \"%w,0 ,0 ,r ,0 ,r ,w ,0\")\n-\t\t(match_operand:DI 2 \"arm_iordi_operand_neon\" \"w ,Dl,r ,r ,Df,Df,w ,Dl\")))]\n-  \"TARGET_32BIT && !TARGET_IWMMXT\"\n-  {\n-  switch (which_alternative)\n-    {\n-    case 0: /* fall through */\n-    case 6: return \"vorr\\t%P0, %P1, %P2\";\n-    case 1: /* fall through */\n-    case 7: return neon_output_logic_immediate (\"vorr\", &operands[2],\n-\t\t     DImode, 0, VALID_NEON_QREG_MODE (DImode));\n-    case 2:\n-    case 3:\n-    case 4:\n-    case 5:\n-      return \"#\";\n-    default: gcc_unreachable ();\n-    }\n-  }\n-  \"TARGET_32BIT && !TARGET_IWMMXT && reload_completed\n-   && !(IS_VFP_REGNUM (REGNO (operands[0])))\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))]\n-  \"\n-  {\n-    operands[3] = gen_lowpart (SImode, operands[0]);\n-    operands[5] = gen_highpart (SImode, operands[0]);\n-\n-    operands[4] = simplify_gen_binary (IOR, SImode,\n-                                           gen_lowpart (SImode, operands[1]),\n-                                           gen_lowpart (SImode, operands[2]));\n-    operands[6] = simplify_gen_binary (IOR, SImode,\n-                                           gen_highpart (SImode, operands[1]),\n-                                           gen_highpart_mode (SImode, DImode, operands[2]));\n-\n-  }\"\n-  [(set_attr \"type\" \"neon_logic,neon_logic,multiple,multiple,multiple,\\\n-                     multiple,neon_logic,neon_logic\")\n-   (set_attr \"length\" \"*,*,8,8,8,8,*,*\")\n-   (set_attr \"arch\" \"neon_for_64bits,neon_for_64bits,*,*,*,*,avoid_neon_for_64bits,avoid_neon_for_64bits\")]\n-)\n-\n-(define_insn \"*iordi_zesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (zero_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,?r\")))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   orr%?\\\\t%Q0, %Q1, %2\n-   #\"\n-  [(set_attr \"length\" \"4,8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"logic_reg,multiple\")]\n-)\n-\n-(define_insn \"*iordi_sesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (sign_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI         0 \"s_register_operand\")\n \t(ior:SI (match_operand:SI 1 \"s_register_operand\")\n@@ -3368,103 +3026,6 @@\n    (set_attr \"type\" \"logics_imm,logics_reg,logics_reg\")]\n )\n \n-(define_expand \"xordi3\"\n-  [(set (match_operand:DI         0 \"s_register_operand\")\n-\t(xor:DI (match_operand:DI 1 \"s_register_operand\")\n-\t\t(match_operand:DI 2 \"arm_xordi_operand\")))]\n-  \"TARGET_32BIT\"\n-  {\n-    /* The iWMMXt pattern for xordi3 accepts only register operands but we want\n-       to reuse this expander for all TARGET_32BIT targets so just force the\n-       constants into a register.  Unlike for the anddi3 and iordi3 there are\n-       no NEON instructions that take an immediate.  */\n-    if (TARGET_IWMMXT && !REG_P (operands[2]))\n-      operands[2] = force_reg (DImode, operands[2]);\n-    if (!TARGET_NEON && !TARGET_IWMMXT)\n-      {\n-\trtx low  = simplify_gen_binary (XOR, SImode,\n-\t\t\t\t\tgen_lowpart (SImode, operands[1]),\n-\t\t\t\t\tgen_lowpart (SImode, operands[2]));\n-\trtx high = simplify_gen_binary (XOR, SImode,\n-\t\t\t\t\tgen_highpart (SImode, operands[1]),\n-\t\t\t\t\tgen_highpart_mode (SImode, DImode,\n-\t\t\t\t\t\t\t   operands[2]));\n-\n-\temit_insn (gen_rtx_SET (gen_lowpart (SImode, operands[0]), low));\n-\temit_insn (gen_rtx_SET (gen_highpart (SImode, operands[0]), high));\n-\n-\tDONE;\n-      }\n-    /* Otherwise expand pattern as above.  */\n-  }\n-)\n-\n-(define_insn_and_split \"*xordi3_insn\"\n-  [(set (match_operand:DI         0 \"s_register_operand\" \"=w,&r,&r,&r,&r,?w\")\n-\t(xor:DI (match_operand:DI 1 \"s_register_operand\" \"%w ,0,r ,0 ,r ,w\")\n-\t\t(match_operand:DI 2 \"arm_xordi_operand\"  \"w ,r ,r ,Dg,Dg,w\")))]\n-  \"TARGET_32BIT && !TARGET_IWMMXT\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 1:\n-    case 2:\n-    case 3:\n-    case 4:  /* fall through */\n-      return \"#\";\n-    case 0: /* fall through */\n-    case 5: return \"veor\\t%P0, %P1, %P2\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  \"TARGET_32BIT && !TARGET_IWMMXT && reload_completed\n-   && !(IS_VFP_REGNUM (REGNO (operands[0])))\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 6))]\n-  \"\n-  {\n-    operands[3] = gen_lowpart (SImode, operands[0]);\n-    operands[5] = gen_highpart (SImode, operands[0]);\n-\n-    operands[4] = simplify_gen_binary (XOR, SImode,\n-                                           gen_lowpart (SImode, operands[1]),\n-                                           gen_lowpart (SImode, operands[2]));\n-    operands[6] = simplify_gen_binary (XOR, SImode,\n-                                           gen_highpart (SImode, operands[1]),\n-                                           gen_highpart_mode (SImode, DImode, operands[2]));\n-\n-  }\"\n-  [(set_attr \"length\" \"*,8,8,8,8,*\")\n-   (set_attr \"type\" \"neon_logic,multiple,multiple,multiple,multiple,neon_logic\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,*,*,*,avoid_neon_for_64bits\")]\n-)\n-\n-(define_insn \"*xordi_zesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(xor:DI (zero_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,?r\")))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   eor%?\\\\t%Q0, %Q1, %2\n-   #\"\n-  [(set_attr \"length\" \"4,8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"logic_reg\")]\n-)\n-\n-(define_insn \"*xordi_sesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(xor:DI (sign_extend:DI\n-\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI         0 \"s_register_operand\")\n \t(xor:SI (match_operand:SI 1 \"s_register_operand\")\n@@ -5054,56 +4615,6 @@\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"\")\n \n-(define_expand \"one_cmpldi2\"\n-  [(set (match_operand:DI 0 \"s_register_operand\")\n-\t(not:DI (match_operand:DI 1 \"s_register_operand\")))]\n-  \"TARGET_32BIT\"\n-  \"\n-  if (!TARGET_NEON && !TARGET_IWMMXT)\n-    {\n-      rtx low  = simplify_gen_unary (NOT, SImode,\n-\t\t\t\t     gen_lowpart (SImode, operands[1]),\n-\t\t\t\t     SImode);\n-      rtx high = simplify_gen_unary (NOT, SImode,\n-\t\t\t\t     gen_highpart_mode (SImode, DImode,\n-\t\t\t\t\t\t\toperands[1]),\n-\t\t\t\t     SImode);\n-\n-      emit_insn (gen_rtx_SET (gen_lowpart (SImode, operands[0]), low));\n-      emit_insn (gen_rtx_SET (gen_highpart (SImode, operands[0]), high));\n-\n-      DONE;\n-    }\n-  /* Otherwise expand pattern as above.  */\n-  \"\n-)\n-\n-(define_insn_and_split \"*one_cmpldi2_insn\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t \"=w,&r,&r,?w\")\n-\t(not:DI (match_operand:DI 1 \"s_register_operand\" \" w, 0, r, w\")))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   vmvn\\t%P0, %P1\n-   #\n-   #\n-   vmvn\\t%P0, %P1\"\n-  \"TARGET_32BIT && reload_completed\n-   && arm_general_register_operand (operands[0], DImode)\"\n-  [(set (match_dup 0) (not:SI (match_dup 1)))\n-   (set (match_dup 2) (not:SI (match_dup 3)))]\n-  \"\n-  {\n-    operands[2] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[3] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-  [(set_attr \"length\" \"*,8,8,*\")\n-   (set_attr \"predicable\" \"no,yes,yes,no\")\n-   (set_attr \"type\" \"neon_move,multiple,multiple,neon_move\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,*,avoid_neon_for_64bits\")]\n-)\n-\n (define_expand \"one_cmplsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\")\n \t(not:SI (match_operand:SI 1 \"s_register_operand\")))]"}, {"sha": "b76de81b85c8ce7a2ca484a750b908b7ca64600a", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -273,24 +273,6 @@\n  (and (match_code \"const_int\")\n       (match_test \"TARGET_32BIT && const_ok_for_dimode_op (ival, PLUS)\")))\n \n-(define_constraint \"De\"\n- \"@internal\n-  In ARM/Thumb-2 state a const_int that can be used by insn anddi.\"\n- (and (match_code \"const_int\")\n-      (match_test \"TARGET_32BIT && const_ok_for_dimode_op (ival, AND)\")))\n-\n-(define_constraint \"Df\"\n- \"@internal\n-  In ARM/Thumb-2 state a const_int that can be used by insn iordi.\"\n- (and (match_code \"const_int\")\n-      (match_test \"TARGET_32BIT && const_ok_for_dimode_op (ival, IOR)\")))\n-\n-(define_constraint \"Dg\"\n- \"@internal\n-  In ARM/Thumb-2 state a const_int that can be used by insn xordi.\"\n- (and (match_code \"const_int\")\n-      (match_test \"TARGET_32BIT && const_ok_for_dimode_op (ival, XOR)\")))\n-\n (define_constraint \"Di\"\n  \"@internal\n   In ARM/Thumb-2 state a const_int or const_double where both the high"}, {"sha": "86158ea4fd278180d5e2321c66c6c2b5e5c460b0", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -55,45 +55,36 @@\n )\n \n (define_insn \"iwmmxt_iordi3\"\n-  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n-        (ior:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n-\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y\")\n+        (ior:DI (match_operand:DI 1 \"register_operand\" \"%y\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"@\n-   wor%?\\\\t%0, %1, %2\n-   #\n-   #\"\n+  \"wor%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"4,8,8\")\n-   (set_attr \"type\" \"wmmx_wor,*,*\")]\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"wmmx_wor\")]\n )\n \n (define_insn \"iwmmxt_xordi3\"\n-  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n-        (xor:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n-\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y\")\n+        (xor:DI (match_operand:DI 1 \"register_operand\" \"%y\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"@\n-   wxor%?\\\\t%0, %1, %2\n-   #\n-   #\"\n+  \"wxor%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"4,8,8\")\n-   (set_attr \"type\" \"wmmx_wxor,*,*\")]\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"wmmx_wxor\")]\n )\n \n (define_insn \"iwmmxt_anddi3\"\n-  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n-        (and:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n-\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y\")\n+        (and:DI (match_operand:DI 1 \"register_operand\" \"%y\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y\")))]\n   \"TARGET_REALLY_IWMMXT\"\n-  \"@\n-   wand%?\\\\t%0, %1, %2\n-   #\n-   #\"\n+  \"wand%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"4,8,8\")\n-   (set_attr \"type\" \"wmmx_wand,*,*\")]\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"wmmx_wand\")]\n )\n \n (define_insn \"iwmmxt_nanddi3\""}, {"sha": "ef73c77abeeaa02947c70ffa435f7bedc431e3be", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -838,46 +838,6 @@\n   [(set_attr \"type\" \"neon_logic<q>\")]\n )\n \n-;; TODO: investigate whether we should disable \n-;; this and bicdi3_neon for the A8 in line with the other\n-;; changes above. \n-(define_insn_and_split \"orndi3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r,?&r\")\n-\t(ior:DI (not:DI (match_operand:DI 2 \"s_register_operand\" \"w,0,0,r\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"w,r,r,0\")))]\n-  \"TARGET_NEON\"\n-  \"@\n-   vorn\\t%P0, %P1, %P2\n-   #\n-   #\n-   #\"\n-  \"reload_completed && \n-   (TARGET_NEON && !(IS_VFP_REGNUM (REGNO (operands[0]))))\"\n-  [(set (match_dup 0) (ior:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (ior:SI (not:SI (match_dup 4)) (match_dup 5)))]\n-  \"\n-  {\n-    if (TARGET_THUMB2)\n-      {\n-        operands[3] = gen_highpart (SImode, operands[0]);\n-        operands[0] = gen_lowpart (SImode, operands[0]);\n-        operands[4] = gen_highpart (SImode, operands[2]);\n-        operands[2] = gen_lowpart (SImode, operands[2]);\n-        operands[5] = gen_highpart (SImode, operands[1]);\n-        operands[1] = gen_lowpart (SImode, operands[1]);\n-      }\n-    else\n-      {\n-        emit_insn (gen_one_cmpldi2 (operands[0], operands[2]));\n-        emit_insn (gen_iordi3 (operands[0], operands[1], operands[0]));\n-        DONE;\n-      }\n-  }\"\n-  [(set_attr \"type\" \"neon_logic,multiple,multiple,multiple\")\n-   (set_attr \"length\" \"*,16,8,8\")\n-   (set_attr \"arch\" \"any,a,t2,t2\")]\n-)\n-\n (define_insn \"bic<mode>3_neon\"\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n \t(and:VDQ (not:VDQ (match_operand:VDQ 2 \"s_register_operand\" \"w\"))\n@@ -887,20 +847,6 @@\n   [(set_attr \"type\" \"neon_logic<q>\")]\n )\n \n-;; Compare to *anddi_notdi_di.\n-(define_insn \"bicdi3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r\")\n-        (and:DI (not:DI (match_operand:DI 2 \"s_register_operand\" \"w,r,0\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"w,0,r\")))]\n-  \"TARGET_NEON\"\n-  \"@\n-   vbic\\t%P0, %P1, %P2\n-   #\n-   #\"\n-  [(set_attr \"type\" \"neon_logic,multiple,multiple\")\n-   (set_attr \"length\" \"*,8,8\")]\n-)\n-\n (define_insn \"xor<mode>3\"\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n \t(xor:VDQ (match_operand:VDQ 1 \"s_register_operand\" \"w\")"}, {"sha": "59dc2e89534a8b85df1197bd7211af43c56fb18c", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -201,23 +201,6 @@\n   (ior (match_operand 0 \"arm_rhs_operand\")\n        (match_operand 0 \"arm_neg_immediate_operand\")))\n \n-(define_predicate \"arm_anddi_operand_neon\"\n-  (ior (match_operand 0 \"s_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"const_ok_for_dimode_op (INTVAL (op), AND)\"))\n-       (match_operand 0 \"neon_inv_logic_op2\")))\n-\n-(define_predicate \"arm_iordi_operand_neon\"\n-  (ior (match_operand 0 \"s_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"const_ok_for_dimode_op (INTVAL (op), IOR)\"))\n-       (match_operand 0 \"neon_logic_op2\")))\n-\n-(define_predicate \"arm_xordi_operand\"\n-  (ior (match_operand 0 \"s_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"const_ok_for_dimode_op (INTVAL (op), XOR)\"))))\n-\n (define_predicate \"arm_adddi_operand\"\n   (ior (match_operand 0 \"s_register_operand\")\n        (and (match_code \"const_int\")"}, {"sha": "6ccc875e2b4e7b8ce256e52da966dfe220c6f5d6", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -1476,103 +1476,6 @@\n    (set_attr \"type\" \"alu_sreg\")]\n )\n \n-; Constants for op 2 will never be given to these patterns.\n-(define_insn_and_split \"*iordi_notdi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"s_register_operand\" \"0,r\"))\n-\t\t(match_operand:DI 2 \"s_register_operand\" \"r,0\")))]\n-  \"TARGET_THUMB2\"\n-  \"#\"\n-  \"TARGET_THUMB2 && reload_completed\"\n-  [(set (match_dup 0) (ior:SI (not:SI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3) (ior:SI (not:SI (match_dup 4)) (match_dup 5)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[5] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"no\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*iordi_notzesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (not:DI (zero_extend:DI\n-\t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,?r\")))]\n-  \"TARGET_THUMB2\"\n-  \"#\"\n-  ; (not (zero_extend...)) means operand0 will always be 0xffffffff\n-  \"TARGET_THUMB2 && reload_completed\"\n-  [(set (match_dup 0) (ior:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (const_int -1))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-  [(set_attr \"length\" \"4,8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"no\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*iordi_notdi_zesidi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (not:DI (match_operand:DI 2 \"s_register_operand\" \"0,?r\"))\n-\t\t(zero_extend:DI\n-\t\t (match_operand:SI 1 \"s_register_operand\" \"r,r\"))))]\n-  \"TARGET_THUMB2\"\n-  \"#\"\n-  \"TARGET_THUMB2 && reload_completed\"\n-  [(set (match_dup 0) (ior:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (not:SI (match_dup 4)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[4] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"no\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"*iordi_notsesidi_di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(ior:DI (not:DI (sign_extend:DI\n-\t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n-  \"TARGET_THUMB2\"\n-  \"#\"\n-  \"TARGET_THUMB2 && reload_completed\"\n-  [(set (match_dup 0) (ior:SI (not:SI (match_dup 2)) (match_dup 1)))\n-   (set (match_dup 3) (ior:SI (not:SI\n-\t\t\t\t(ashiftrt:SI (match_dup 2) (const_int 31)))\n-\t\t\t       (match_dup 4)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"no\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn \"*orsi_notsi_si\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(ior:SI (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))"}]}