{"sha": "12b0d35ec52375da5652d2b8da74083ab700b9d7", "node_id": "C_kwDOANBUbNoAKDEyYjBkMzVlYzUyMzc1ZGE1NjUyZDJiOGRhNzQwODNhYjcwMGI5ZDc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-01-05T19:21:34Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-01-05T19:21:34Z"}, "message": "c++: class-head parsing and CPP_TEMPLATE_ID access [PR108275]\n\nWhen tentatively parsing what is really an elaborated-type-specifier\ncontaining a template-id first as a class-specifier, we may form a\nCPP_TEMPLATE_ID token that later gets reused by the fallback parse if\nthe tentative parse fails.  These special tokens also capture the access\nchecks that have been deferred while parsing the template-id.  But here\nwe form such a token when the access check state is dk_no_check, and so\nthe token captures no access checks.  This effectively bypasses access\nchecking for the template-id during the subsequent parse as an\nelaborated-type-specifier.\n\nThis patch fixes this by using dk_deferred instead of dk_no_check when\nparsing the class name of a class-head.\n\n\tPR c++/108275\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_class_head): Use dk_deferred instead of\n\tdk_no_check when parsing the class name.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/parse/access14.C: New test.", "tree": {"sha": "ecadf0ab0e7a9d7b070a5f23921d475de7f1fcb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecadf0ab0e7a9d7b070a5f23921d475de7f1fcb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12b0d35ec52375da5652d2b8da74083ab700b9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b0d35ec52375da5652d2b8da74083ab700b9d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12b0d35ec52375da5652d2b8da74083ab700b9d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b0d35ec52375da5652d2b8da74083ab700b9d7/comments", "author": null, "committer": null, "parents": [{"sha": "9807c31af91326988d083436483f9577296e1f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9807c31af91326988d083436483f9577296e1f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9807c31af91326988d083436483f9577296e1f9a"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "8b1658decba485f4191a3b9fa39d29b6674decb4", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12b0d35ec52375da5652d2b8da74083ab700b9d7/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12b0d35ec52375da5652d2b8da74083ab700b9d7/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=12b0d35ec52375da5652d2b8da74083ab700b9d7", "patch": "@@ -26559,7 +26559,23 @@ cp_parser_class_head (cp_parser* parser,\n   if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false))\n     qualified_p = true;\n \n-  push_deferring_access_checks (dk_no_check);\n+  /* It is OK to define an inaccessible class; for example:\n+\n+       class A { class B; };\n+       class A::B {};\n+\n+     So we want to ignore access when parsing the class name.\n+     However, we might be tentatively parsing what is really an\n+     elaborated-type-specifier naming a template-id, e.g.\n+\n+       struct C<&D::m> c;\n+\n+     In this case the tentative parse as a class-head will fail, but not\n+     before cp_parser_template_id splices in a CPP_TEMPLATE_ID token.\n+     Since dk_no_check is sticky, we must instead use dk_deferred so that\n+     any such CPP_TEMPLATE_ID token created during this tentative parse\n+     will correctly capture the access checks imposed by the template-id . */\n+  push_deferring_access_checks (dk_deferred);\n \n   /* Determine the name of the class.  Begin by looking for an\n      optional nested-name-specifier.  */\n@@ -26586,11 +26602,6 @@ cp_parser_class_head (cp_parser* parser,\n \t The proposed resolution for Core Issue 180 says that wherever\n \t you see `class T::X' you should treat `X' as a type-name.\n \n-\t It is OK to define an inaccessible class; for example:\n-\n-\t   class A { class B; };\n-\t   class A::B {};\n-\n \t We do not know if we will see a class-name, or a\n \t template-name.  We look for a class-name first, in case the\n \t class-name is a template-id; if we looked for the"}, {"sha": "bdbc7f6ee2ba21f1f9a30e9d7dbed0e55c404879", "filename": "gcc/testsuite/g++.dg/parse/access14.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12b0d35ec52375da5652d2b8da74083ab700b9d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12b0d35ec52375da5652d2b8da74083ab700b9d7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess14.C?ref=12b0d35ec52375da5652d2b8da74083ab700b9d7", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/108275\n+\n+struct A {\n+  int i;\n+private:\n+  int j;\n+};\n+\n+template<int A::* V>\n+struct B {\n+  struct C { };\n+private:\n+  template<int N> struct D { };\n+};\n+\n+struct B<&A::j> b;       // { dg-error \"private\" }\n+struct B<&A::j>::C c;    // { dg-error \"private\" }\n+struct B<&A::i>::D<0> d; // { dg-error \"private\" }"}]}