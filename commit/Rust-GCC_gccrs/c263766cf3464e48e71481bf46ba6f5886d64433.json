{"sha": "c263766cf3464e48e71481bf46ba6f5886d64433", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI2Mzc2NmNmMzQ2NGU0OGU3MTQ4MWJmNDZiYTZmNTg4NmQ2NDQzMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-02-24T23:40:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-02-24T23:40:03Z"}, "message": "toplev.c (dump_file_tbl): Rename from dump_file.\n\n        * toplev.c (dump_file_tbl): Rename from dump_file.\n        * bb-reorder.c, bt-load.c, cfgcleanup.c, cfglayout.c, cfgloopanal.c,\n        cfgloopmanip.c, cfgrtl.c, config/arm/arm.c, config/frv/frv.c,\n        config/i386/i386.c, config/ia64/ia64.c, config/mips/mips.c,\n        config/sh/sh.c, cse.c, flow.c, ifcvt.c, loop-iv.c, loop-unroll.c,\n        loop-unswitch.c, output.h, predict.c, profile.c, ra-build.c,\n        ra-colorize.c, ra-debug.c, ra-rewrite.c, ra.c, regrename.c, reload1.c,\n        toplev.c, tracer.c, value-prof.c, var-tracking.c, web.c:\n        s/rtl_dump_file/dump_file/g.\n\nFrom-SVN: r78399", "tree": {"sha": "d6106abaa59ec697ae2e96cb33c733be39b7abe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6106abaa59ec697ae2e96cb33c733be39b7abe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c263766cf3464e48e71481bf46ba6f5886d64433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c263766cf3464e48e71481bf46ba6f5886d64433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c263766cf3464e48e71481bf46ba6f5886d64433", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c263766cf3464e48e71481bf46ba6f5886d64433/comments", "author": null, "committer": null, "parents": [{"sha": "dba2921d5284680567f321495a89e65c3b06e80e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba2921d5284680567f321495a89e65c3b06e80e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba2921d5284680567f321495a89e65c3b06e80e"}], "stats": {"total": 1566, "additions": 802, "deletions": 764}, "files": [{"sha": "245f2cd6b4634e3956548816823d2567d1c730a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -1,3 +1,15 @@\n+2004-02-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* toplev.c (dump_file_tbl): Rename from dump_file.\n+\t* bb-reorder.c, bt-load.c, cfgcleanup.c, cfglayout.c, cfgloopanal.c,\n+ \tcfgloopmanip.c, cfgrtl.c, config/arm/arm.c, config/frv/frv.c,\n+\tconfig/i386/i386.c, config/ia64/ia64.c, config/mips/mips.c,\n+\tconfig/sh/sh.c, cse.c, flow.c, ifcvt.c, loop-iv.c, loop-unroll.c,\n+\tloop-unswitch.c, output.h, predict.c, profile.c, ra-build.c,\n+\tra-colorize.c, ra-debug.c, ra-rewrite.c, ra.c, regrename.c, reload1.c,\n+\ttoplev.c, tracer.c, value-prof.c, var-tracking.c, web.c:\n+\ts/rtl_dump_file/dump_file/g.\n+\n 2004-02-24  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/spe.md (spe_fix_truncsfsi2): Delete."}, {"sha": "0f8719eb27af1032ce9f4449a2f4979b303a9011", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -185,8 +185,8 @@ find_traces (int *n_traces, struct trace *traces)\n     {\n       gcov_type count_threshold;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"STC - round %d\\n\", i + 1);\n+      if (dump_file)\n+\tfprintf (dump_file, \"STC - round %d\\n\", i + 1);\n \n       if (max_entry_count < INT_MAX / 1000)\n \tcount_threshold = max_entry_count * exec_threshold[i] / 1000;\n@@ -199,18 +199,18 @@ find_traces (int *n_traces, struct trace *traces)\n     }\n   fibheap_delete (heap);\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       for (i = 0; i < *n_traces; i++)\n \t{\n \t  basic_block bb;\n-\t  fprintf (rtl_dump_file, \"Trace %d (round %d):  \", i + 1,\n+\t  fprintf (dump_file, \"Trace %d (round %d):  \", i + 1,\n \t\t   traces[i].round + 1);\n \t  for (bb = traces[i].first; bb != traces[i].last; bb = bb->rbi->next)\n-\t    fprintf (rtl_dump_file, \"%d [%d] \", bb->index, bb->frequency);\n-\t  fprintf (rtl_dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n+\t    fprintf (dump_file, \"%d [%d] \", bb->index, bb->frequency);\n+\t  fprintf (dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n \t}\n-      fflush (rtl_dump_file);\n+      fflush (dump_file);\n     }\n }\n \n@@ -371,8 +371,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       bbd[bb->index].heap = NULL;\n       bbd[bb->index].node = NULL;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Getting bb %d\\n\", bb->index);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Getting bb %d\\n\", bb->index);\n \n       /* If the BB's frequency is too low send BB to the next round.  */\n       if (round < N_ROUNDS - 1\n@@ -383,8 +383,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  bbd[bb->index].heap = new_heap;\n \t  bbd[bb->index].node = fibheap_insert (new_heap, key, bb);\n \n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"  Possible start point of next round: %d (key: %d)\\n\",\n \t\t     bb->index, key);\n \t  continue;\n@@ -408,8 +408,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  mark_bb_visited (bb, *n_traces);\n \t  trace->length++;\n \n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Basic block %d was visited in trace %d\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Basic block %d was visited in trace %d\\n\",\n \t\t     bb->index, *n_traces - 1);\n \n \t  /* Select the successor that will be placed after BB.  */\n@@ -466,9 +466,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  /* E->DEST is already in some heap.  */\n \t\t  if (key != bbd[e->dest->index].node->key)\n \t\t    {\n-\t\t      if (rtl_dump_file)\n+\t\t      if (dump_file)\n \t\t\t{\n-\t\t\t  fprintf (rtl_dump_file,\n+\t\t\t  fprintf (dump_file,\n \t\t\t\t   \"Changing key for bb %d from %ld to %ld.\\n\",\n \t\t\t\t   e->dest->index,\n \t\t\t\t   (long) bbd[e->dest->index].node->key,\n@@ -498,9 +498,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  bbd[e->dest->index].node = fibheap_insert (which_heap,\n \t\t\t\t\t\t\t\tkey, e->dest);\n \n-\t\t  if (rtl_dump_file)\n+\t\t  if (dump_file)\n \t\t    {\n-\t\t      fprintf (rtl_dump_file,\n+\t\t      fprintf (dump_file,\n \t\t\t       \"  Possible start of %s round: %d (key: %ld)\\n\",\n \t\t\t       (which_heap == new_heap) ? \"next\" : \"this\",\n \t\t\t       e->dest->index, (long) key);\n@@ -525,9 +525,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t\t  if (best_edge->dest != ENTRY_BLOCK_PTR->next_bb)\n \t\t\t    {\n-\t\t\t      if (rtl_dump_file)\n+\t\t\t      if (dump_file)\n \t\t\t\t{\n-\t\t\t\t  fprintf (rtl_dump_file,\n+\t\t\t\t  fprintf (dump_file,\n \t\t\t\t\t   \"Rotating loop %d - %d\\n\",\n \t\t\t\t\t   best_edge->dest->index, bb->index);\n \t\t\t\t}\n@@ -596,8 +596,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t&& 2 * e->dest->frequency >= EDGE_FREQUENCY (best_edge))\n \t\t      {\n \t\t\tbest_edge = e;\n-\t\t\tif (rtl_dump_file)\n-\t\t\t  fprintf (rtl_dump_file, \"Selecting BB %d\\n\",\n+\t\t\tif (dump_file)\n+\t\t\t  fprintf (dump_file, \"Selecting BB %d\\n\",\n \t\t\t\t   best_edge->dest->index);\n \t\t\tbreak;\n \t\t      }\n@@ -626,9 +626,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      key = bb_to_key (e->dest);\n \t      if (key != bbd[e->dest->index].node->key)\n \t\t{\n-\t\t  if (rtl_dump_file)\n+\t\t  if (dump_file)\n \t\t    {\n-\t\t      fprintf (rtl_dump_file,\n+\t\t      fprintf (dump_file,\n \t\t\t       \"Changing key for bb %d from %ld to %ld.\\n\",\n \t\t\t       e->dest->index,\n \t\t\t       (long) bbd[e->dest->index].node->key, key);\n@@ -661,8 +661,8 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n     abort ();\n   if (e->dest->rbi->visited)\n     abort ();\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n \t     old_bb->index, new_bb->index);\n   new_bb->rbi->visited = trace;\n@@ -686,9 +686,9 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \t}\n       array_size = new_size;\n \n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n-\t  fprintf (rtl_dump_file,\n+\t  fprintf (dump_file,\n \t\t   \"Growing the dynamic array to %d elements.\\n\",\n \t\t   array_size);\n \t}\n@@ -832,9 +832,9 @@ connect_traces (int n_traces, struct trace *traces)\n \t      best->src->rbi->next = best->dest;\n \t      t2 = bbd[best->src->index].end_of_trace;\n \t      connected[t2] = true;\n-\t      if (rtl_dump_file)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (rtl_dump_file, \"Connection: %d %d\\n\",\n+\t\t  fprintf (dump_file, \"Connection: %d %d\\n\",\n \t\t\t   best->src->index, best->dest->index);\n \t\t}\n \t    }\n@@ -873,9 +873,9 @@ connect_traces (int n_traces, struct trace *traces)\n \n \t  if (best)\n \t    {\n-\t      if (rtl_dump_file)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (rtl_dump_file, \"Connection: %d %d\\n\",\n+\t\t  fprintf (dump_file, \"Connection: %d %d\\n\",\n \t\t\t   best->src->index, best->dest->index);\n \t\t}\n \t      t = bbd[best->dest->index].start_of_trace;\n@@ -950,16 +950,16 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t{\n \t\t  basic_block new_bb;\n \n-\t\t  if (rtl_dump_file)\n+\t\t  if (dump_file)\n \t\t    {\n-\t\t      fprintf (rtl_dump_file, \"Connection: %d %d \",\n+\t\t      fprintf (dump_file, \"Connection: %d %d \",\n \t\t\t       traces[t].last->index, best->dest->index);\n \t\t      if (!next_bb)\n-\t\t\tfputc ('\\n', rtl_dump_file);\n+\t\t\tfputc ('\\n', dump_file);\n \t\t      else if (next_bb == EXIT_BLOCK_PTR)\n-\t\t\tfprintf (rtl_dump_file, \"exit\\n\");\n+\t\t\tfprintf (dump_file, \"exit\\n\");\n \t\t      else\n-\t\t\tfprintf (rtl_dump_file, \"%d\\n\", next_bb->index);\n+\t\t\tfprintf (dump_file, \"%d\\n\", next_bb->index);\n \t\t    }\n \n \t\t  new_bb = copy_bb (best->dest, best, traces[t].last, t);\n@@ -980,15 +980,15 @@ connect_traces (int n_traces, struct trace *traces)\n \t}\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       basic_block bb;\n \n-      fprintf (rtl_dump_file, \"Final order:\\n\");\n+      fprintf (dump_file, \"Final order:\\n\");\n       for (bb = traces[0].first; bb; bb = bb->rbi->next)\n-\tfprintf (rtl_dump_file, \"%d \", bb->index);\n-      fprintf (rtl_dump_file, \"\\n\");\n-      fflush (rtl_dump_file);\n+\tfprintf (dump_file, \"%d \", bb->index);\n+      fprintf (dump_file, \"\\n\");\n+      fflush (dump_file);\n     }\n \n   FREE (connected);\n@@ -1035,9 +1035,9 @@ copy_bb_p (basic_block bb, int code_may_grow)\n   if (size <= max_size)\n     return true;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file,\n+      fprintf (dump_file,\n \t       \"Block %d can't be copied because its size = %d.\\n\",\n \t       bb->index, size);\n     }\n@@ -1108,8 +1108,8 @@ reorder_basic_blocks (void)\n   FREE (traces);\n   FREE (bbd);\n \n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   cfg_layout_finalize ();\n "}, {"sha": "366e678634342ee159b89337c934e86f3f6f0fcd", "filename": "gcc/bt-load.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -319,8 +319,8 @@ add_btr_def (fibheap_t all_btr_defs, basic_block bb, int insn_luid, rtx insn,\n \n   fibheap_insert (all_btr_defs, -this->cost, this);\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n       \"Found target reg definition: sets %u { bb %d, insn %d }%s priority %d\\n\",\n       dest_reg, bb->index, INSN_UID (insn), (this->group ? \"\" : \":not const\"),\n       this->cost);\n@@ -363,13 +363,13 @@ new_btr_user (basic_block bb, int insn_luid, rtx insn)\n   user->n_reaching_defs = 0;\n   user->first_reaching_def = -1;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Uses target reg: { bb %d, insn %d }\",\n+      fprintf (dump_file, \"Uses target reg: { bb %d, insn %d }\",\n \t       bb->index, INSN_UID (insn));\n \n       if (user->use)\n-\tfprintf (rtl_dump_file, \": unambiguous use of reg %d\\n\",\n+\tfprintf (dump_file, \": unambiguous use of reg %d\\n\",\n \t\t REGNO (user->use));\n     }\n \n@@ -383,16 +383,16 @@ dump_hard_reg_set (HARD_REG_SET s)\n   int reg;\n   for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     if (TEST_HARD_REG_BIT (s, reg))\n-      fprintf (rtl_dump_file, \" %d\", reg);\n+      fprintf (dump_file, \" %d\", reg);\n }\n \n /* Write the set of target regs live in block BB to the dump file.  */\n static void\n dump_btrs_live (int bb)\n {\n-  fprintf (rtl_dump_file, \"BB%d live:\", bb);\n+  fprintf (dump_file, \"BB%d live:\", bb);\n   dump_hard_reg_set (btrs_live[bb]);\n-  fprintf (rtl_dump_file, \"\\n\");\n+  fprintf (dump_file, \"\\n\");\n }\n \n /* REGNO is the number of a branch target register that is being used or\n@@ -589,7 +589,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t      SET_HARD_REG_BIT (btrs_live_at_end[i], regno);\n \t}\n \n-      if (rtl_dump_file)\n+      if (dump_file)\n \tdump_btrs_live(i);\n     }\n }\n@@ -710,8 +710,8 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \n \t\t      /* We now know that def reaches user.  */\n \n-\t\t      if (rtl_dump_file)\n-\t\t\tfprintf (rtl_dump_file,\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n \t\t\t  \"Def in insn %d reaches use in insn %d\\n\",\n \t\t\t  uid, insn_uid);\n \n@@ -725,8 +725,8 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t\t  def->has_ambiguous_use = 1;\n \t\t\t  def_array[user->first_reaching_def]\n \t\t\t    ->has_ambiguous_use = 1;\n-\t\t\t  if (rtl_dump_file)\n-\t\t\t    fprintf (rtl_dump_file,\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n \t\t\t\t     \"(use %d has multiple reaching defs)\\n\",\n \t\t\t\t     insn_uid);\n \t\t\t}\n@@ -832,7 +832,7 @@ clear_btr_from_live_range (btr_def def)\n \t {\n \t   CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr);\n \t   CLEAR_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-\t   if (rtl_dump_file)\n+\t   if (dump_file)\n \t     dump_btrs_live (bb);\n \t }\n      });\n@@ -851,7 +851,7 @@ add_btr_to_live_range (btr_def def)\n      {\n        SET_HARD_REG_BIT (btrs_live[bb], def->btr);\n        SET_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-       if (rtl_dump_file)\n+       if (dump_file)\n \t dump_btrs_live (bb);\n      });\n }\n@@ -888,14 +888,14 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \t  IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live_at_end[new_block]);\n \t  IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[head_bb->index]);\n \t}\n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n-\t  fprintf (rtl_dump_file,\n+\t  fprintf (dump_file,\n \t\t   \"Adding end of block %d and rest of %d to live range\\n\",\n \t\t   new_block, head_bb->index);\n-\t  fprintf (rtl_dump_file,\"Now live btrs are \");\n+\t  fprintf (dump_file,\"Now live btrs are \");\n \t  dump_hard_reg_set (*btrs_live_in_range);\n-\t  fprintf (rtl_dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n       for (e = head_bb->pred; e; e = e->pred_next)\n \t*tos++ = e->src;\n@@ -913,13 +913,13 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \t  bitmap_set_bit (live_range, bb->index);\n \t  IOR_HARD_REG_SET (*btrs_live_in_range,\n \t    btrs_live[bb->index]);\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file,\n+\t      fprintf (dump_file,\n \t\t\"Adding block %d to live range\\n\", bb->index);\n-\t      fprintf (rtl_dump_file,\"Now live btrs are \");\n+\t      fprintf (dump_file,\"Now live btrs are \");\n \t      dump_hard_reg_set (*btrs_live_in_range);\n-\t      fprintf (rtl_dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \n \t  for (e = bb->pred; e != NULL; e = e->pred_next)\n@@ -1054,8 +1054,8 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n \t  if (btr != -1)\n \t    {\n \t      /* We can combine them.  */\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Combining def in insn %d with def in insn %d\\n\",\n \t\t\t INSN_UID (other_def->insn), INSN_UID (def->insn));\n \n@@ -1120,8 +1120,8 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   btr_user user;\n   rtx set;\n \n-  if (rtl_dump_file)\n-    fprintf(rtl_dump_file, \"migrating to basic block %d, using reg %d\\n\",\n+  if (dump_file)\n+    fprintf(dump_file, \"migrating to basic block %d, using reg %d\\n\",\n \t    new_def_bb->index, btr);\n \n   clear_btr_from_live_range (def);\n@@ -1164,8 +1164,8 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n \n   regs_ever_live[btr] = 1;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"New pt is insn %d, inserted after insn %d\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"New pt is insn %d, inserted after insn %d\\n\",\n \t     INSN_UID (def->insn), INSN_UID (insp));\n \n   /* Delete the old target register initialization.  */\n@@ -1239,16 +1239,16 @@ migrate_btr_def (btr_def def, int min_cost)\n   btr_user user;\n   int def_latency = 1;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Attempting to migrate pt from insn %d (cost = %d, min_cost = %d) ... \",\n \t     INSN_UID (def->insn), def->cost, min_cost);\n \n   if (!def->group || def->has_ambiguous_use)\n     /* These defs are not migratable.  */\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"it's not migratable\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"it's not migratable\\n\");\n       return 0;\n     }\n \n@@ -1257,8 +1257,8 @@ migrate_btr_def (btr_def def, int min_cost)\n        no need to consider it further.\n     */\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"it's already combined with another pt\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"it's already combined with another pt\\n\");\n       return 0;\n     }\n \n@@ -1298,19 +1298,19 @@ migrate_btr_def (btr_def def, int min_cost)\n \t basic block TRY.  */\n       int try_freq = basic_block_freq (try);\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"trying block %d ...\", try->index);\n+      if (dump_file)\n+\tfprintf (dump_file, \"trying block %d ...\", try->index);\n \n       if (try_freq < def_basic_block_freq\n \t  || (try_freq == def_basic_block_freq && btr_used_near_def))\n \t{\n \t  int btr;\n \t  augment_live_range (live_range, &btrs_live_in_range, def->bb, try);\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file, \"Now btrs live in range are: \");\n+\t      fprintf (dump_file, \"Now btrs live in range are: \");\n \t      dump_hard_reg_set (btrs_live_in_range);\n-\t      fprintf (rtl_dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  btr = choose_btr (btrs_live_in_range);\n \t  if (btr != -1)\n@@ -1326,8 +1326,8 @@ migrate_btr_def (btr_def def, int min_cost)\n \t      /* There are no free target registers available to move\n \t\t this far forward, so give up */\n \t      give_up = 1;\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"giving up because there are no free target registers\\n\");\n \t    }\n \n@@ -1336,8 +1336,8 @@ migrate_btr_def (btr_def def, int min_cost)\n   if (!def_moved)\n     {\n       give_up = 1;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"failed to move\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"failed to move\\n\");\n     }\n   BITMAP_XFREE (live_range);\n   return !give_up;\n@@ -1352,14 +1352,14 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n   int reg;\n \n   gcc_obstack_init (&migrate_btrl_obstack);\n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       int i;\n \n       for (i = 0; i < n_basic_blocks; i++)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n-\t  fprintf(rtl_dump_file,\n+\t  fprintf(dump_file,\n \t    \"Basic block %d: count = \" HOST_WIDEST_INT_PRINT_DEC\n \t    \" loop-depth = %d idom = %d\\n\",\n \t    i, (HOST_WIDEST_INT) bb->count, bb->loop_depth,\n@@ -1391,9 +1391,9 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n       if (migrate_btr_def (def, min_cost))\n \t{\n \t  fibheap_insert (all_btr_defs, -def->cost, (void *) def);\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file,\n+\t      fprintf (dump_file,\n \t\t\"Putting insn %d back on queue with priority %d\\n\",\n \t\tINSN_UID (def->insn), def->cost);\n \t    }"}, {"sha": "f6bf6e743d6f167686cea9ee78bbf276757c2940", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -159,8 +159,8 @@ try_simplify_condjump (basic_block cbranch_block)\n   if (!invert_jump (cbranch_insn, block_label (jump_dest_block), 0))\n     return false;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Simplifying condjump %i around jump %i\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Simplifying condjump %i around jump %i\\n\",\n \t     INSN_UID (cbranch_insn), INSN_UID (BB_END (jump_block)));\n \n   /* Success.  Update the CFG to match.  Note that after this point\n@@ -544,8 +544,8 @@ try_forward_edges (int mode, basic_block b)\n \n       if (counter >= n_basic_blocks)\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Infinite loop in BB %i.\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Infinite loop in BB %i.\\n\",\n \t\t     target->index);\n \t}\n       else if (target == first)\n@@ -562,13 +562,13 @@ try_forward_edges (int mode, basic_block b)\n \t  if (threaded && target != EXIT_BLOCK_PTR)\n \t    {\n \t      notice_new_block (redirect_edge_and_branch_force (e, target));\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Conditionals threaded.\\n\");\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Conditionals threaded.\\n\");\n \t    }\n \t  else if (!redirect_edge_and_branch (e, target))\n \t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Forwarding edge %i->%i to %i failed.\\n\",\n \t\t\t b->index, e->dest->index, target->index);\n \t      continue;\n@@ -693,8 +693,8 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n     reorder_insns_nobb (BB_HEAD (a), BB_END (a), PREV_INSN (BB_HEAD (b)));\n   a->flags |= BB_DIRTY;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Moved block %d before %d and merged.\\n\",\n \t     a->index, b->index);\n \n   /* Swap the records for the two blocks around.  */\n@@ -747,8 +747,8 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n   /* Restore the real end of b.  */\n   BB_END (b) = real_b_end;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Moved block %d after %d and merged.\\n\",\n \t     b->index, a->index);\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n@@ -787,8 +787,8 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       merge_blocks (b, c);\n       update_forwarder_flag (b);\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Merged %d and %d without moving.\\n\",\n \t\t b_index, c_index);\n \n       return b->prev_bb == ENTRY_BLOCK_PTR ? b : b->prev_bb;\n@@ -1201,17 +1201,17 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t     outcomes.  */\n \t  if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n \t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Outcomes of branch in bb %i and %i differs to much (%i %i)\\n\",\n \t\t\t bb1->index, bb2->index, b1->probability, prob2);\n \n \t      return false;\n \t    }\n \t}\n \n-      if (rtl_dump_file && match)\n-\tfprintf (rtl_dump_file, \"Conditionals in bb %i and %i match.\\n\",\n+      if (dump_file && match)\n+\tfprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n \t\t bb1->index, bb2->index);\n \n       return match;\n@@ -1276,8 +1276,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n \n \t\t  match = insns_match_p (mode, BB_END (bb1), BB_END (bb2));\n-\t\t  if (rtl_dump_file && match)\n-\t\t    fprintf (rtl_dump_file,\n+\t\t  if (dump_file && match)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n \t\t\t     bb1->index, bb2->index);\n \n@@ -1448,14 +1448,14 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     redirect_to = src2;\n   else\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Splitting bb %i before %i insns\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Splitting bb %i before %i insns\\n\",\n \t\t src2->index, nmatch);\n       redirect_to = split_block (src2, PREV_INSN (newpos2))->dest;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Cross jumping from bb %i to bb %i; %i common insns\\n\",\n \t     src1->index, src2->index, nmatch);\n \n@@ -1676,8 +1676,8 @@ try_optimize_cfg (int mode)\n \t  changed = false;\n \t  iterations++;\n \n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n \t\t     iterations);\n \n@@ -1691,8 +1691,8 @@ try_optimize_cfg (int mode)\n \t      while (b->pred == NULL)\n \t\t{\n \t\t  c = b->prev_bb;\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file, \"Deleting block %i.\\n\",\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Deleting block %i.\\n\",\n \t\t\t     b->index);\n \n \t\t  delete_basic_block (b);\n@@ -1733,8 +1733,8 @@ try_optimize_cfg (int mode)\n \t\t      reorder_insns_nobb (label, label, bb_note);\n \t\t      BB_HEAD (b) = bb_note;\n \t\t    }\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Deleted label in block %i.\\n\",\n \t\t\t     b->index);\n \t\t}\n \n@@ -1749,8 +1749,8 @@ try_optimize_cfg (int mode)\n \t\t  && (b->succ->flags & EDGE_FALLTHRU)\n \t\t  && n_basic_blocks > 1)\n \t\t{\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Deleting fallthru block %i.\\n\",\n \t\t\t     b->index);\n "}, {"sha": "41d92bbee6cd07bcc61001e152dd915f7324a66c", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -176,8 +176,8 @@ label_for_bb (basic_block bb)\n \n   if (GET_CODE (label) != CODE_LABEL)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\", bb->index);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Emitting label for block %d\\n\", bb->index);\n \n       label = block_label (bb);\n     }\n@@ -775,20 +775,23 @@ fixup_reorder_chain (void)\n \n   /* Put basic_block_info in the new order.  */\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0; bb; bb = bb->rbi->next, index ++)\n+      fprintf (dump_file, \"Reordered sequence:\\n\");\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n+\t   bb;\n+\t   bb = bb->rbi->next, index++)\n \t{\n-\t  fprintf (rtl_dump_file, \" %i \", index);\n+\t  fprintf (dump_file, \" %i \", index);\n \t  if (bb->rbi->original)\n-\t    fprintf (rtl_dump_file, \"duplicate of %i \",\n+\t    fprintf (dump_file, \"duplicate of %i \",\n \t\t     bb->rbi->original->index);\n-\t  else if (forwarder_block_p (bb) && GET_CODE (BB_HEAD (bb)) != CODE_LABEL)\n-\t    fprintf (rtl_dump_file, \"compensation \");\n+\t  else if (forwarder_block_p (bb)\n+\t\t   && GET_CODE (BB_HEAD (bb)) != CODE_LABEL)\n+\t    fprintf (dump_file, \"compensation \");\n \t  else\n-\t    fprintf (rtl_dump_file, \"bb %i \", bb->index);\n-\t  fprintf (rtl_dump_file, \" [%i]\\n\", bb->frequency);\n+\t    fprintf (dump_file, \"bb %i \", bb->index);\n+\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n \t}\n     }\n "}, {"sha": "6ca4cb454c106e773e1cc2d6b27b66cd6f1df8b6", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -906,11 +906,11 @@ count_loop_iterations (struct loop_desc *desc, rtx init, rtx lim)\n \t}\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \";  Number of iterations: \");\n-      print_simple_rtl (rtl_dump_file, exp);\n-      fprintf (rtl_dump_file, \"\\n\");\n+      fprintf (dump_file, \";  Number of iterations: \");\n+      print_simple_rtl (dump_file, exp);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   return exp;\n@@ -946,12 +946,12 @@ test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT iter)\n   exp = simplify_gen_relational (cond, SImode,\n \t\t\t\t GET_MODE (desc->var), exp, desc->lim);\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \";  Conditional to continue loop at \"\n+      fprintf (dump_file, \";  Conditional to continue loop at \"\n \t       HOST_WIDE_INT_PRINT_UNSIGNED \"th iteration: \", iter);\n-      print_simple_rtl (rtl_dump_file, exp);\n-      fprintf (rtl_dump_file, \"\\n\");\n+      print_simple_rtl (dump_file, exp);\n+      fprintf (dump_file, \"\\n\");\n     }\n   return exp;\n }\n@@ -1067,42 +1067,42 @@ simple_loop_p (struct loop *loop, struct loop_desc *desc)\n     }\n   desc->n_branches = n_branches;\n \n-  if (rtl_dump_file && any)\n+  if (dump_file && any)\n     {\n-      fprintf (rtl_dump_file, \"; Simple loop %i\\n\", loop->num);\n+      fprintf (dump_file, \"; Simple loop %i\\n\", loop->num);\n       if (desc->postincr)\n-\tfprintf (rtl_dump_file,\n+\tfprintf (dump_file,\n \t\t \";  does postincrement after loop exit condition\\n\");\n \n-      fprintf (rtl_dump_file, \";  Induction variable:\");\n-      print_simple_rtl (rtl_dump_file, desc->var);\n-      fputc ('\\n', rtl_dump_file);\n+      fprintf (dump_file, \";  Induction variable:\");\n+      print_simple_rtl (dump_file, desc->var);\n+      fputc ('\\n', dump_file);\n \n-      fprintf (rtl_dump_file, \";  Initial values:\");\n-      print_simple_rtl (rtl_dump_file, desc->var_alts);\n-      fputc ('\\n', rtl_dump_file);\n+      fprintf (dump_file, \";  Initial values:\");\n+      print_simple_rtl (dump_file, desc->var_alts);\n+      fputc ('\\n', dump_file);\n \n-      fprintf (rtl_dump_file, \";  Stride:\");\n-      print_simple_rtl (rtl_dump_file, desc->stride);\n-      fputc ('\\n', rtl_dump_file);\n+      fprintf (dump_file, \";  Stride:\");\n+      print_simple_rtl (dump_file, desc->stride);\n+      fputc ('\\n', dump_file);\n \n-      fprintf (rtl_dump_file, \";  Compared with:\");\n-      print_simple_rtl (rtl_dump_file, desc->lim);\n-      fputc ('\\n', rtl_dump_file);\n+      fprintf (dump_file, \";  Compared with:\");\n+      print_simple_rtl (dump_file, desc->lim);\n+      fputc ('\\n', dump_file);\n \n-      fprintf (rtl_dump_file, \";  Alternative values:\");\n-      print_simple_rtl (rtl_dump_file, desc->lim_alts);\n-      fputc ('\\n', rtl_dump_file);\n+      fprintf (dump_file, \";  Alternative values:\");\n+      print_simple_rtl (dump_file, desc->lim_alts);\n+      fputc ('\\n', dump_file);\n \n-      fprintf (rtl_dump_file, \";  Exit condition:\");\n+      fprintf (dump_file, \";  Exit condition:\");\n       if (desc->neg)\n-\tfprintf (rtl_dump_file, \"(negated)\");\n-      fprintf (rtl_dump_file, \"%s\\n\", GET_RTX_NAME (desc->cond));\n+\tfprintf (dump_file, \"(negated)\");\n+      fprintf (dump_file, \"%s\\n\", GET_RTX_NAME (desc->cond));\n \n-      fprintf (rtl_dump_file, \";  Number of branches:\");\n-      fprintf (rtl_dump_file, \"%d\\n\", desc->n_branches);\n+      fprintf (dump_file, \";  Number of branches:\");\n+      fprintf (dump_file, \"%d\\n\", desc->n_branches);\n \n-      fputc ('\\n', rtl_dump_file);\n+      fputc ('\\n', dump_file);\n     }\n \n   free (body);"}, {"sha": "2dc46432aa9de69307f35e989621bb705e2fb8d0", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -1155,8 +1155,8 @@ create_preheader (struct loop *loop, int flags)\n       dummy->succ->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Created preheader block for loop %i\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Created preheader block for loop %i\\n\",\n \t     loop->num);\n \n   return dummy;"}, {"sha": "f35263f14e0ff2e2d71b6d2357c2a9a97d983829", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -687,8 +687,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   /* See if we can create the fallthru edge.  */\n   if (in_cfglayout || can_fallthru (src, target))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n+      if (dump_file)\n+\tfprintf (dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n       fallthru = 1;\n \n       /* Selectively unlink whole insn chain.  */\n@@ -724,8 +724,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     {\n       if (e->dest == target)\n \treturn false;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n \t\t INSN_UID (insn), e->dest->index, target->index);\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n@@ -748,8 +748,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       emit_jump_insn_after (gen_jump (target_label), insn);\n       JUMP_LABEL (BB_END (src)) = target_label;\n       LABEL_NUSES (target_label)++;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Replacing insn %i by jump %i\\n\",\n \t\t INSN_UID (insn), INSN_UID (BB_END (src)));\n \n \n@@ -911,8 +911,8 @@ redirect_branch_edge (edge e, basic_block target)\n \t}\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Edge %i->%i redirected to %i\\n\",\n \t     e->src->index, e->dest->index, target->index);\n \n   if (e->dest != target)\n@@ -2242,8 +2242,8 @@ purge_dead_edges (basic_block bb)\n       if (!bb->succ || !purged)\n \treturn purged;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Purged edges from bb %i\\n\", bb->index);\n \n       if (!optimize)\n \treturn purged;\n@@ -2313,8 +2313,8 @@ purge_dead_edges (basic_block bb)\n   bb->succ->probability = REG_BR_PROB_BASE;\n   bb->succ->count = bb->count;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n \t     bb->index);\n   return purged;\n }\n@@ -2389,8 +2389,8 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->src == ENTRY_BLOCK_PTR\n       && (e->flags & EDGE_FALLTHRU) && !(e->flags & EDGE_COMPLEX))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Redirecting entry edge from bb %i to %i\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Redirecting entry edge from bb %i to %i\\n\",\n \t\t e->src->index, dest->index);\n \n       redirect_edge_succ (e, dest);\n@@ -2408,8 +2408,8 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t  && label_is_jump_target_p (BB_HEAD (e->dest),\n \t\t\t\t     BB_END (src)))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Fallthru edge unified with branch \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Fallthru edge unified with branch \"\n \t\t     \"%i->%i redirected to %i\\n\",\n \t\t     e->src->index, e->dest->index, dest->index);\n \t  e->flags &= ~EDGE_FALLTHRU;\n@@ -2430,8 +2430,8 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t    delete_insn (BB_END (src));\n \t}\n       redirect_edge_succ_nodup (e, dest);\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Fallthru edge %i->%i redirected to %i\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Fallthru edge %i->%i redirected to %i\\n\",\n \t\t e->src->index, e->dest->index, dest->index);\n \n       ret = true;\n@@ -2635,8 +2635,8 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       b->rbi->footer = NULL;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Merged blocks %d and %d.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Merged blocks %d and %d.\\n\",\n \t     a->index, b->index);\n }\n "}, {"sha": "a2ab3d65f82ee4504bde292ab972d6c453d40878", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -7103,8 +7103,8 @@ dump_minipool (rtx scan)\n \t  break;\n \t}\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \";; Emitting minipool after insn %u; address %ld; align %d (bytes)\\n\",\n \t     INSN_UID (scan), (unsigned long) minipool_barrier->address, align64 ? 8 : 4);\n \n@@ -7116,14 +7116,14 @@ dump_minipool (rtx scan)\n     {\n       if (mp->refcount > 0)\n \t{\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file, \n+\t      fprintf (dump_file, \n \t\t       \";;  Offset %u, min %ld, max %ld \",\n \t\t       (unsigned) mp->offset, (unsigned long) mp->min_address,\n \t\t       (unsigned long) mp->max_address);\n-\t      arm_print_value (rtl_dump_file, mp->value);\n-\t      fputc ('\\n', rtl_dump_file);\n+\t      arm_print_value (dump_file, mp->value);\n+\t      fputc ('\\n', dump_file);\n \t    }\n \n \t  switch (mp->fix_size)\n@@ -7344,15 +7344,15 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   if (TARGET_REALLY_IWMMXT && fix->fix_size == 8)\n     fix->forwards -= 4;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file,\n+      fprintf (dump_file,\n \t       \";; %smode fixup for i%d; addr %lu, range (%ld,%ld): \",\n \t       GET_MODE_NAME (mode),\n \t       INSN_UID (insn), (unsigned long) address, \n \t       -1 * (long)fix->backwards, (long)fix->forwards);\n-      arm_print_value (rtl_dump_file, fix->value);\n-      fprintf (rtl_dump_file, \"\\n\");\n+      arm_print_value (dump_file, fix->value);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   /* Add it to the chain of fixes.  */"}, {"sha": "1feb2793f4465569faf4fdcb16e75f131fdd3e4a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -6773,8 +6773,8 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n       rtx insn = BB_HEAD (bb[j]);\n       int regno;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Scanning %s block %d, start %d, end %d\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Scanning %s block %d, start %d, end %d\\n\",\n \t\t (bb[j] == else_bb) ? \"else\" : ((bb[j] == then_bb) ? \"then\" : \"test\"),\n \t\t (int) bb[j]->index,\n \t\t (int) INSN_UID (BB_HEAD (bb[j])),\n@@ -6860,36 +6860,36 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \t  CLEAR_HARD_REG_BIT (tmp_reg->regs, j);\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       int num_gprs = 0;\n-      fprintf (rtl_dump_file, \"Available GPRs: \");\n+      fprintf (dump_file, \"Available GPRs: \");\n \n       for (j = GPR_FIRST; j <= GPR_LAST; j++)\n \tif (TEST_HARD_REG_BIT (tmp_reg->regs, j))\n \t  {\n-\t    fprintf (rtl_dump_file, \" %d [%s]\", j, reg_names[j]);\n+\t    fprintf (dump_file, \" %d [%s]\", j, reg_names[j]);\n \t    if (++num_gprs > GPR_TEMP_NUM+2)\n \t      break;\n \t  }\n \n-      fprintf (rtl_dump_file, \"%s\\nAvailable CRs:  \",\n+      fprintf (dump_file, \"%s\\nAvailable CRs:  \",\n \t       (num_gprs > GPR_TEMP_NUM+2) ? \" ...\" : \"\");\n \n       for (j = CR_FIRST; j <= CR_LAST; j++)\n \tif (TEST_HARD_REG_BIT (tmp_reg->regs, j))\n-\t  fprintf (rtl_dump_file, \" %d [%s]\", j, reg_names[j]);\n+\t  fprintf (dump_file, \" %d [%s]\", j, reg_names[j]);\n \n-      fputs (\"\\n\", rtl_dump_file);\n+      fputs (\"\\n\", dump_file);\n \n       if (ce_info->pass > 1)\n \t{\n-\t  fprintf (rtl_dump_file, \"Modifiable CCs: \");\n+\t  fprintf (dump_file, \"Modifiable CCs: \");\n \t  for (j = CC_FIRST; j <= CC_LAST; j++)\n \t    if (TEST_HARD_REG_BIT (tmp_reg->regs, j))\n-\t      fprintf (rtl_dump_file, \" %d [%s]\", j, reg_names[j]);\n+\t      fprintf (dump_file, \" %d [%s]\", j, reg_names[j]);\n \n-\t  fprintf (rtl_dump_file, \"\\n%d nested COND_EXEC statements\\n\",\n+\t  fprintf (dump_file, \"\\n%d nested COND_EXEC statements\\n\",\n \t\t   frv_ifcvt.num_nested_cond_exec);\n \t}\n     }\n@@ -6946,14 +6946,14 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n   if (! cr)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Could not allocate a CR temporary register\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Could not allocate a CR temporary register\\n\");\n \n       goto fail;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Will use %s for conditional execution, %s for nested comparisons\\n\",\n \t     reg_names[ REGNO (cr)],\n \t     (nested_cc) ? reg_names[ REGNO (nested_cc) ] : \"<none>\");\n@@ -6991,8 +6991,8 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n  fail:\n   *p_true = NULL_RTX;\n   *p_false = NULL_RTX;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Disabling this conditional execution.\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"Disabling this conditional execution.\\n\");\n \n   return;\n }\n@@ -7169,8 +7169,8 @@ frv_ifcvt_load_value (rtx value, rtx insn ATTRIBUTE_UNUSED)\n   /* Have we exhausted the number of registers available?  */\n   if (num_alloc >= GPR_TEMP_NUM)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Too many temporary registers allocated\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Too many temporary registers allocated\\n\");\n \n       return NULL_RTX;\n     }\n@@ -7179,27 +7179,27 @@ frv_ifcvt_load_value (rtx value, rtx insn ATTRIBUTE_UNUSED)\n   reg = frv_alloc_temp_reg (&frv_ifcvt.tmp_reg, GPR_REGS, SImode, TRUE, TRUE);\n   if (! reg)\n     {\n-      if (rtl_dump_file)\n-\tfputs (\"Could not find a scratch register\\n\", rtl_dump_file);\n+      if (dump_file)\n+\tfputs (\"Could not find a scratch register\\n\", dump_file);\n \n       return NULL_RTX;\n     }\n \n   frv_ifcvt.cur_scratch_regs++;\n   frv_ifcvt.scratch_regs[num_alloc] = gen_rtx_SET (VOIDmode, reg, value);\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       if (GET_CODE (value) == CONST_INT)\n-\tfprintf (rtl_dump_file, \"Register %s will hold %ld\\n\",\n+\tfprintf (dump_file, \"Register %s will hold %ld\\n\",\n \t\t reg_names[ REGNO (reg)], (long)INTVAL (value));\n \n       else if (GET_CODE (value) == REG && REGNO (value) == LR_REGNO)\n-\tfprintf (rtl_dump_file, \"Register %s will hold LR\\n\",\n+\tfprintf (dump_file, \"Register %s will hold LR\\n\",\n \t\t reg_names[ REGNO (reg)]);\n \n       else\n-\tfprintf (rtl_dump_file, \"Register %s will hold a saved value\\n\",\n+\tfprintf (dump_file, \"Register %s will hold a saved value\\n\",\n \t\t reg_names[ REGNO (reg)]);\n     }\n "}, {"sha": "b7a0a7156cdb51ced858d7fea26d111a5d5bab31", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -15738,8 +15738,8 @@ ix86_avoid_jump_misspredicts (void)\n     {\n \n       nbytes += min_insn_size (insn);\n-      if (rtl_dump_file)\n-        fprintf(rtl_dump_file, \"Insn %i estimated to %i bytes\\n\",\n+      if (dump_file)\n+        fprintf(dump_file, \"Insn %i estimated to %i bytes\\n\",\n \t\tINSN_UID (insn), min_insn_size (insn));\n       if ((GET_CODE (insn) == JUMP_INSN\n \t   && GET_CODE (PATTERN (insn)) != ADDR_VEC\n@@ -15763,16 +15763,17 @@ ix86_avoid_jump_misspredicts (void)\n \t}\n       if (njumps < 0)\n \tabort ();\n-      if (rtl_dump_file)\n-        fprintf(rtl_dump_file, \"Interval %i to %i has %i bytes\\n\",\n+      if (dump_file)\n+        fprintf (dump_file, \"Interval %i to %i has %i bytes\\n\",\n \t\tINSN_UID (start), INSN_UID (insn), nbytes);\n \n       if (njumps == 3 && isjump && nbytes < 16)\n \t{\n \t  int padsize = 15 - nbytes + min_insn_size (insn);\n \n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Padding insn %i by %i bytes!\\n\", INSN_UID (insn), padsize);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Padding insn %i by %i bytes!\\n\",\n+\t\t     INSN_UID (insn), padsize);\n           emit_insn_before (gen_align (GEN_INT (padsize)), insn);\n \t}\n     }"}, {"sha": "057e985fe45d330f9c603980631682c6897a0740", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -7607,21 +7607,21 @@ ia64_reorg (void)\n \t  _1mfb_ = get_cpu_unit_code (\"1b_1mfb.\");\n \t  _1mlx_ = get_cpu_unit_code (\"1b_1mlx.\");\n \t}\n-      schedule_ebbs (rtl_dump_file);\n+      schedule_ebbs (dump_file);\n       finish_bundle_states ();\n       if (ia64_tune == PROCESSOR_ITANIUM)\n \t{\n \t  free (add_cycles);\n \t  free (clocks);\n \t}\n       free (stops_p);\n-      emit_insn_group_barriers (rtl_dump_file);\n+      emit_insn_group_barriers (dump_file);\n \n       ia64_final_schedule = 0;\n       timevar_pop (TV_SCHED2);\n     }\n   else\n-    emit_all_insn_group_barriers (rtl_dump_file);\n+    emit_all_insn_group_barriers (dump_file);\n \n   /* A call must not be the last instruction in a function, so that the\n      return address is still within the function, so that unwinding works"}, {"sha": "852a8c8ba39bf016c081cb7e080168c0e92a1d55", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -8750,7 +8750,7 @@ mips_reorg (void)\n   else if (TARGET_EXPLICIT_RELOCS)\n     {\n       if (mips_flag_delayed_branch)\n-\tdbr_schedule (get_insns (), rtl_dump_file);\n+\tdbr_schedule (get_insns (), dump_file);\n       mips_avoid_hazards ();\n     }\n }"}, {"sha": "78e5118a8205b35eb3c39ef51b2cfc6ec0f1ee6c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -9480,19 +9480,18 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n-\n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-      life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+      find_basic_blocks (insns, max_reg_num (), dump_file);\n+      life_analysis (insns, dump_file, PROP_FINAL);\n \n       split_all_insns (1);\n \n-      schedule_insns (rtl_dump_file);\n+      schedule_insns (dump_file);\n     }\n \n   sh_reorg ();\n \n   if (optimize > 0 && flag_delayed_branch)\n-      dbr_schedule (insns, rtl_dump_file);\n+      dbr_schedule (insns, dump_file);\n   shorten_branches (insns);\n   final_start_function (insns, file, 1);\n   final (insns, file, 1, 0);"}, {"sha": "2d560e0d408eabe630dbf1626ac9196b4c50c8c3", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -7672,8 +7672,8 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n     }\n   while (ndead != nlastdead);\n \n-  if (rtl_dump_file && ndead)\n-    fprintf (rtl_dump_file, \"Deleted %i trivially dead insns; %i iterations\\n\",\n+  if (dump_file && ndead)\n+    fprintf (dump_file, \"Deleted %i trivially dead insns; %i iterations\\n\",\n \t     ndead, niterations);\n   /* Clean up.  */\n   free (counts);"}, {"sha": "acf375a83cd8f685ffdf282353be93589a7e3e13", "filename": "gcc/flow.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -536,10 +536,10 @@ verify_wide_reg (int regno, basic_block bb)\n       head = NEXT_INSN (head);\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Register %d died unexpectedly.\\n\", regno);\n-      dump_bb (bb, rtl_dump_file, 0);\n+      fprintf (dump_file, \"Register %d died unexpectedly.\\n\", regno);\n+      dump_bb (bb, dump_file, 0);\n     }\n   abort ();\n }\n@@ -556,14 +556,14 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t registers.  The regsets should exactly match.  */\n       if (! REG_SET_EQUAL_P (new_live_at_start, bb->global_live_at_start))\n \t{\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file,\n+\t      fprintf (dump_file,\n \t\t       \"live_at_start mismatch in bb %d, aborting\\nNew:\\n\",\n \t\t       bb->index);\n-\t      debug_bitmap_file (rtl_dump_file, new_live_at_start);\n-\t      fputs (\"Old:\\n\", rtl_dump_file);\n-\t      dump_bb (bb, rtl_dump_file, 0);\n+\t      debug_bitmap_file (dump_file, new_live_at_start);\n+\t      fputs (\"Old:\\n\", dump_file);\n+\t      dump_bb (bb, dump_file, 0);\n \t    }\n \t  abort ();\n \t}\n@@ -580,11 +580,11 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t  /* No registers should die.  */\n \t  if (REGNO_REG_SET_P (bb->global_live_at_start, i))\n \t    {\n-\t      if (rtl_dump_file)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (rtl_dump_file,\n+\t\t  fprintf (dump_file,\n \t\t\t   \"Register %d died unexpectedly.\\n\", i);\n-\t\t  dump_bb (bb, rtl_dump_file, 0);\n+\t\t  dump_bb (bb, dump_file, 0);\n \t\t}\n \t      abort ();\n \t    }\n@@ -766,8 +766,8 @@ update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags\n     }\n   timevar_pop ((extent == UPDATE_LIFE_LOCAL || blocks)\n \t       ? TV_LIFE_UPDATE : TV_LIFE);\n-  if (ndead && rtl_dump_file)\n-    fprintf (rtl_dump_file, \"deleted %i dead insns\\n\", ndead);\n+  if (ndead && dump_file)\n+    fprintf (dump_file, \"deleted %i dead insns\\n\", ndead);\n   return ndead;\n }\n \n@@ -871,8 +871,8 @@ delete_noop_moves (rtx f ATTRIBUTE_UNUSED)\n \t    }\n \t}\n     }\n-  if (nnoops && rtl_dump_file)\n-    fprintf (rtl_dump_file, \"deleted %i noop moves\", nnoops);\n+  if (nnoops && dump_file)\n+    fprintf (dump_file, \"deleted %i noop moves\", nnoops);\n   return nnoops;\n }\n \n@@ -893,8 +893,8 @@ delete_dead_jumptables (void)\n \t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Dead jumptable %i removed\\n\", INSN_UID (insn));\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Dead jumptable %i removed\\n\", INSN_UID (insn));\n \t  delete_insn (NEXT_INSN (insn));\n \t  delete_insn (insn);\n \t  next = NEXT_INSN (next);"}, {"sha": "976098f4326a024504ca4d6943da951746fa1563", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -566,8 +566,8 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n #endif\n \n   /* Conversion succeeded.  */\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d insn%s converted to conditional execution.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"%d insn%s converted to conditional execution.\\n\",\n \t     n_insns, (n_insns == 1) ? \" was\" : \"s were\");\n \n   /* Merge the blocks!  */\n@@ -2273,8 +2273,8 @@ find_if_header (basic_block test_bb, int pass)\n   return NULL;\n \n  success:\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Conversion succeeded on pass %d.\\n\", pass);\n+  if (dump_file)\n+    fprintf (dump_file, \"Conversion succeeded on pass %d.\\n\", pass);\n   return ce_info.test_bb;\n }\n \n@@ -2514,23 +2514,29 @@ find_if_block (struct ce_if_block * ce_info)\n \n   num_possible_if_blocks++;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"\\nIF-THEN%s block found, pass %d, start block %d [insn %d], then %d [%d]\",\n+      fprintf (dump_file,\n+\t       \"\\nIF-THEN%s block found, pass %d, start block %d \"\n+\t       \"[insn %d], then %d [%d]\",\n \t       (else_bb) ? \"-ELSE\" : \"\",\n \t       ce_info->pass,\n-\t       test_bb->index, (BB_HEAD (test_bb)) ? (int)INSN_UID (BB_HEAD (test_bb)) : -1,\n-\t       then_bb->index, (BB_HEAD (then_bb)) ? (int)INSN_UID (BB_HEAD (then_bb)) : -1);\n+\t       test_bb->index,\n+\t       BB_HEAD (test_bb) ? (int)INSN_UID (BB_HEAD (test_bb)) : -1,\n+\t       then_bb->index,\n+\t       BB_HEAD (then_bb) ? (int)INSN_UID (BB_HEAD (then_bb)) : -1);\n \n       if (else_bb)\n-\tfprintf (rtl_dump_file, \", else %d [%d]\",\n-\t\t else_bb->index, (BB_HEAD (else_bb)) ? (int)INSN_UID (BB_HEAD (else_bb)) : -1);\n+\tfprintf (dump_file, \", else %d [%d]\",\n+\t\t else_bb->index,\n+\t\t BB_HEAD (else_bb) ? (int)INSN_UID (BB_HEAD (else_bb)) : -1);\n \n-      fprintf (rtl_dump_file, \", join %d [%d]\",\n-\t       join_bb->index, (BB_HEAD (join_bb)) ? (int)INSN_UID (BB_HEAD (join_bb)) : -1);\n+      fprintf (dump_file, \", join %d [%d]\",\n+\t       join_bb->index,\n+\t       BB_HEAD (join_bb) ? (int)INSN_UID (BB_HEAD (join_bb)) : -1);\n \n       if (ce_info->num_multiple_test_blocks > 0)\n-\tfprintf (rtl_dump_file, \", %d %s block%s last test %d [%d]\",\n+\tfprintf (dump_file, \", %d %s block%s last test %d [%d]\",\n \t\t ce_info->num_multiple_test_blocks,\n \t\t (ce_info->and_and_p) ? \"&&\" : \"||\",\n \t\t (ce_info->num_multiple_test_blocks == 1) ? \"\" : \"s\",\n@@ -2539,7 +2545,7 @@ find_if_block (struct ce_if_block * ce_info)\n \t\t  ? (int)INSN_UID (BB_HEAD (ce_info->last_test_bb))\n \t\t  : -1));\n \n-      fputc ('\\n', rtl_dump_file);\n+      fputc ('\\n', dump_file);\n     }\n \n   /* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we get the\n@@ -2590,9 +2596,9 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   else\n     return FALSE;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"\\nTRAP-IF block found, start %d, trap %d\\n\",\n+      fprintf (dump_file, \"\\nTRAP-IF block found, start %d, trap %d\\n\",\n \t       test_bb->index, trap_bb->index);\n     }\n \n@@ -2794,8 +2800,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   num_possible_if_blocks++;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"\\nIF-CASE-1 found, start %d, then %d\\n\",\n \t     test_bb->index, then_bb->index);\n \n@@ -2873,8 +2879,8 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   num_possible_if_blocks++;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"\\nIF-CASE-2 found, start %d, else %d\\n\",\n \t     test_bb->index, else_bb->index);\n \n@@ -3213,8 +3219,8 @@ if_convert (int x_life_data_ok)\n       pass++;\n \n #ifdef IFCVT_MULTIPLE_DUMPS\n-      if (rtl_dump_file && pass > 1)\n-\tfprintf (rtl_dump_file, \"\\n\\n========== Pass %d ==========\\n\", pass);\n+      if (dump_file && pass > 1)\n+\tfprintf (dump_file, \"\\n\\n========== Pass %d ==========\\n\", pass);\n #endif\n \n       FOR_EACH_BB (bb)\n@@ -3225,21 +3231,21 @@ if_convert (int x_life_data_ok)\n \t}\n \n #ifdef IFCVT_MULTIPLE_DUMPS\n-      if (rtl_dump_file && cond_exec_changed_p)\n-\tprint_rtl_with_bb (rtl_dump_file, get_insns ());\n+      if (dump_file && cond_exec_changed_p)\n+\tprint_rtl_with_bb (dump_file, get_insns ());\n #endif\n     }\n   while (cond_exec_changed_p);\n \n #ifdef IFCVT_MULTIPLE_DUMPS\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n\\n========== no more changes\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\\n========== no more changes\\n\");\n #endif\n \n   free_dominance_info (CDI_POST_DOMINATORS);\n \n-  if (rtl_dump_file)\n-    fflush (rtl_dump_file);\n+  if (dump_file)\n+    fflush (dump_file);\n \n   clear_aux_for_blocks ();\n \n@@ -3258,15 +3264,15 @@ if_convert (int x_life_data_ok)\n     }\n \n   /* Write the final stats.  */\n-  if (rtl_dump_file && num_possible_if_blocks > 0)\n+  if (dump_file && num_possible_if_blocks > 0)\n     {\n-      fprintf (rtl_dump_file,\n+      fprintf (dump_file,\n \t       \"\\n%d possible IF blocks searched.\\n\",\n \t       num_possible_if_blocks);\n-      fprintf (rtl_dump_file,\n+      fprintf (dump_file,\n \t       \"%d IF blocks converted.\\n\",\n \t       num_updated_if_blocks);\n-      fprintf (rtl_dump_file,\n+      fprintf (dump_file,\n \t       \"%d true changes made.\\n\\n\\n\",\n \t       num_true_changes);\n     }"}, {"sha": "277c1eaa09a374065dc57c272e62887b5e2b9476", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -788,11 +788,11 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n   enum machine_mode inner_mode, outer_mode;\n   enum rtx_code extend;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Analysing \");\n-      print_rtl (rtl_dump_file, def);\n-      fprintf (rtl_dump_file, \" for bivness.\\n\");\n+      fprintf (dump_file, \"Analysing \");\n+      print_rtl (dump_file, def);\n+      fprintf (dump_file, \" for bivness.\\n\");\n     }\n     \n   if (!REG_P (def))\n@@ -806,15 +806,15 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n   regno = REGNO (def);\n   if (last_def[regno] == const0_rtx)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"  not simple.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"  not simple.\\n\");\n       return false;\n     }\n \n   if (last_def[regno] && bivs[regno].analysed)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"  already analysed.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"  already analysed.\\n\");\n \n       *iv = bivs[regno];\n       return iv->base != NULL_RTX;\n@@ -849,12 +849,12 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n   iv->delta = outer_step;\n   iv->first_special = inner_mode != outer_mode;\n \n-end:\n-  if (rtl_dump_file)\n+ end:\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"  \");\n-      dump_iv_info (rtl_dump_file, iv);\n-      fprintf (rtl_dump_file, \"\\n\");\n+      fprintf (dump_file, \"  \");\n+      dump_iv_info (dump_file, iv);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   bivs[regno] = *iv;\n@@ -871,12 +871,12 @@ iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n   unsigned regno;\n   bool inv = CONSTANT_P (op);\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Analysing operand \");\n-      print_rtl (rtl_dump_file, op);\n-      fprintf (rtl_dump_file, \" of insn \");\n-      print_rtl_single (rtl_dump_file, insn);\n+      fprintf (dump_file, \"Analysing operand \");\n+      print_rtl (dump_file, op);\n+      fprintf (dump_file, \" of insn \");\n+      print_rtl_single (dump_file, insn);\n     }\n \n   if (GET_CODE (op) == SUBREG)\n@@ -897,8 +897,8 @@ iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n \tinv = true;\n       else if (last_def[regno] == const0_rtx)\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"  not simple.\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  not simple.\\n\");\n \t  return false;\n \t}\n     }\n@@ -907,20 +907,20 @@ iv_analyze_op (rtx insn, rtx op, struct rtx_iv *iv)\n     {\n       iv_constant (iv, op, VOIDmode);\n \n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n-\t  fprintf (rtl_dump_file, \"  \");\n-\t  dump_iv_info (rtl_dump_file, iv);\n-\t  fprintf (rtl_dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"  \");\n+\t  dump_iv_info (dump_file, iv);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n       return true;\n     }\n \n   def_insn = iv_get_reaching_def (insn, op);\n   if (def_insn == const0_rtx)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"  not simple.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"  not simple.\\n\");\n       return false;\n     }\n \n@@ -956,19 +956,19 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n   if (!insn)\n     return iv_analyze_biv (def, iv);\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"Analysing def of \");\n-      print_rtl (rtl_dump_file, def);\n-      fprintf (rtl_dump_file, \" in insn \");\n-      print_rtl_single (rtl_dump_file, insn);\n+      fprintf (dump_file, \"Analysing def of \");\n+      print_rtl (dump_file, def);\n+      fprintf (dump_file, \" in insn \");\n+      print_rtl_single (dump_file, insn);\n     }\n \n   uid = INSN_UID (insn);\n   if (insn_info[uid].iv.analysed)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"  already analysed.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"  already analysed.\\n\");\n       *iv = insn_info[uid].iv;\n       return iv->base != NULL_RTX;\n     }\n@@ -1088,18 +1088,18 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n \n   *iv = iv0;\n \n-end:\n+ end:\n   iv->analysed = true;\n   insn_info[uid].iv = *iv;\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      print_rtl (rtl_dump_file, def);\n-      fprintf (rtl_dump_file, \" in insn \");\n-      print_rtl_single (rtl_dump_file, insn);\n-      fprintf (rtl_dump_file, \"  is \");\n-      dump_iv_info (rtl_dump_file, iv);\n-      fprintf (rtl_dump_file, \"\\n\");\n+      print_rtl (dump_file, def);\n+      fprintf (dump_file, \" in insn \");\n+      print_rtl_single (dump_file, insn);\n+      fprintf (dump_file, \"  is \");\n+      dump_iv_info (dump_file, iv);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   return iv->base != NULL_RTX;\n@@ -2389,43 +2389,43 @@ find_simple_exit (struct loop *loop, struct niter_desc *desc)\n \t}\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       if (desc->simple_p)\n \t{\n-\t  fprintf (rtl_dump_file, \"Loop %d is simple:\\n\", loop->num);\n-\t  fprintf (rtl_dump_file, \"  simple exit %d -> %d\\n\",\n+\t  fprintf (dump_file, \"Loop %d is simple:\\n\", loop->num);\n+\t  fprintf (dump_file, \"  simple exit %d -> %d\\n\",\n \t\t   desc->out_edge->src->index,\n \t\t   desc->out_edge->dest->index);\n \t  if (desc->assumptions)\n \t    {\n-\t      fprintf (rtl_dump_file, \"  assumptions: \");\n-\t      print_rtl (rtl_dump_file, desc->assumptions);\n-\t      fprintf (rtl_dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"  assumptions: \");\n+\t      print_rtl (dump_file, desc->assumptions);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  if (desc->noloop_assumptions)\n \t    {\n-\t      fprintf (rtl_dump_file, \"  does not roll if: \");\n-\t      print_rtl (rtl_dump_file, desc->noloop_assumptions);\n-\t      fprintf (rtl_dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"  does not roll if: \");\n+\t      print_rtl (dump_file, desc->noloop_assumptions);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  if (desc->infinite)\n \t    {\n-\t      fprintf (rtl_dump_file, \"  infinite if: \");\n-\t      print_rtl (rtl_dump_file, desc->infinite);\n-\t      fprintf (rtl_dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"  infinite if: \");\n+\t      print_rtl (dump_file, desc->infinite);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  fprintf (rtl_dump_file, \"  number of iterations: \");\n-\t  print_rtl (rtl_dump_file, desc->niter_expr);\n-      \t  fprintf (rtl_dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"  number of iterations: \");\n+\t  print_rtl (dump_file, desc->niter_expr);\n+      \t  fprintf (dump_file, \"\\n\");\n \n-\t  fprintf (rtl_dump_file, \"  upper bound: \");\n-\t  fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter_max);\n-      \t  fprintf (rtl_dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"  upper bound: \");\n+\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter_max);\n+      \t  fprintf (dump_file, \"\\n\");\n \t}\n       else\n-\tfprintf (rtl_dump_file, \"Loop %d is not simple.\\n\", loop->num);\n+\tfprintf (dump_file, \"Loop %d is not simple.\\n\", loop->num);\n     }\n \n   free (body);"}, {"sha": "74957a76ee4d6f10e3abbd58f96671fc668c291b", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 127, "deletions": 110, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -192,8 +192,9 @@ peel_loops_completely (struct loops *loops, int flags)\n \n       loop->lpt_decision.decision = LPT_NONE;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"\\n;; *** Considering loop %d for complete peeling ***\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"\\n;; *** Considering loop %d for complete peeling ***\\n\",\n \t\t loop->num);\n \n       loop->ninsns = num_loop_insns (loop);\n@@ -237,23 +238,23 @@ decide_unrolling_and_peeling (struct loops *loops, int flags)\n \n       loop->lpt_decision.decision = LPT_NONE;\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"\\n;; *** Considering loop %d ***\\n\", loop->num);\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n;; *** Considering loop %d ***\\n\", loop->num);\n \n       /* Do not peel cold areas.  */\n       if (!maybe_hot_bb_p (loop->header))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Not considering loop, cold area\\n\");\n \t  loop = next;\n \t  continue;\n \t}\n \n       /* Can the loop be manipulated?  */\n       if (!can_duplicate_loop_p (loop))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \";; Not considering loop, cannot duplicate\\n\");\n \t  loop = next;\n \t  continue;\n@@ -262,8 +263,8 @@ decide_unrolling_and_peeling (struct loops *loops, int flags)\n       /* Skip non-innermost loops.  */\n       if (loop->inner)\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \";; Not considering loop, is not innermost\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Not considering loop, is not innermost\\n\");\n \t  loop = next;\n \t  continue;\n \t}\n@@ -293,14 +294,14 @@ decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n {\n   struct niter_desc *desc;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n;; Considering peeling once rolling loop\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Considering peeling once rolling loop\\n\");\n \n   /* Is the loop small enough?  */\n   if ((unsigned) PARAM_VALUE (PARAM_MAX_ONCE_PEELED_INSNS) < loop->ninsns)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -313,14 +314,15 @@ decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n       || !desc->const_iter\n       || desc->niter != 0)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Unable to prove that the loop rolls exactly once\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \";; Unable to prove that the loop rolls exactly once\\n\");\n       return;\n     }\n \n   /* Success.  */\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Decided to peel exactly once rolling loop\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \";; Decided to peel exactly once rolling loop\\n\");\n   loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n }\n \n@@ -331,30 +333,30 @@ decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n   unsigned npeel;\n   struct niter_desc *desc;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n;; Considering peeling completely\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Considering peeling completely\\n\");\n \n   /* Skip non-innermost loops.  */\n   if (loop->inner)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is not innermost\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is not innermost\\n\");\n       return;\n     }\n \n   /* Do not peel cold areas.  */\n   if (!maybe_hot_bb_p (loop->header))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, cold area\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, cold area\\n\");\n       return;\n     }\n \n   /* Can the loop be manipulated?  */\n   if (!can_duplicate_loop_p (loop))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \";; Not considering loop, cannot duplicate\\n\");\n       return;\n     }\n@@ -367,8 +369,8 @@ decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n   /* Is the loop small enough?  */\n   if (!npeel)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -380,25 +382,27 @@ decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n       || desc->assumptions\n       || !desc->const_iter)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Unable to prove that the loop iterates constant times\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \";; Unable to prove that the loop iterates constant times\\n\");\n       return;\n     }\n \n   if (desc->niter > npeel - 1)\n     {\n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n-\t  fprintf (rtl_dump_file, \";; Not peeling loop completely, rolls too much (\");\n-\t  fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter);\n-\t  fprintf (rtl_dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n+\t  fprintf (dump_file,\n+\t\t   \";; Not peeling loop completely, rolls too much (\");\n+\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter);\n+\t  fprintf (dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n \t}\n       return;\n     }\n \n   /* Success.  */\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Decided to peel loop completely\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \";; Decided to peel loop completely\\n\");\n   loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n }\n \n@@ -459,11 +463,12 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n      the loop.  */\n   remove_path (loops, ei);\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n+  if (dump_file)\n+    fprintf (dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n }\n \n-/* Decide whether to unroll LOOP iterating constant number of times and how much.  */\n+/* Decide whether to unroll LOOP iterating constant number of times\n+   and how much.  */\n \n static void\n decide_unroll_constant_iterations (struct loop *loop, int flags)\n@@ -477,14 +482,16 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n       return;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \"\\n;; Considering unrolling loop with constant number of iterations\\n\");\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\n;; Considering unrolling loop with constant \"\n+\t     \"number of iterations\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n   nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n-  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  nunroll_by_av\n+    = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n   if (nunroll > nunroll_by_av)\n     nunroll = nunroll_by_av;\n   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n@@ -493,8 +500,8 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -504,16 +511,17 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n   /* Check number of iterations.  */\n   if (!desc->simple_p || !desc->const_iter || desc->assumptions)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Unable to prove that the loop iterates constant times\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \";; Unable to prove that the loop iterates constant times\\n\");\n       return;\n     }\n \n   /* Check whether the loop rolls enough to consider.  */\n   if (desc->niter < 2 * nunroll)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n       return;\n     }\n \n@@ -546,15 +554,15 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n \t}\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; max_unroll %d (%d copies, initial %d).\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \";; max_unroll %d (%d copies, initial %d).\\n\",\n \t     best_unroll + 1, best_copies, nunroll);\n \n   loop->lpt_decision.decision = LPT_UNROLL_CONSTANT;\n   loop->lpt_decision.times = best_unroll;\n   \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \";; Decided to unroll the constant times rolling loop, %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n@@ -609,8 +617,8 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \t in the first copy, so that the loops that start with test\n \t of exit condition have continuous body after unrolling.  */\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Condition on beginning of loop.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Condition on beginning of loop.\\n\");\n \n       /* Peel exit_mod iterations.  */\n       RESET_BIT (wont_exit, 0);\n@@ -638,8 +646,8 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n       /* Leave exit test in last copy, for the same reason as above if\n \t the loop tests the condition at the end of loop body.  */\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Condition on end of loop.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Condition on end of loop.\\n\");\n \n       /* We know that niter >= max_unroll + 2; so we do not need to care of\n \t case when we would exit before reaching the loop.  So just peel\n@@ -703,8 +711,10 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n     remove_path (loops, remove_edges[i]);\n   free (remove_edges);\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Unrolled loop %d times, constant # of iterations %i insns\\n\",max_unroll, num_loop_insns (loop));\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \";; Unrolled loop %d times, constant # of iterations %i insns\\n\",\n+\t     max_unroll, num_loop_insns (loop));\n }\n \n /* Decide whether to unroll LOOP iterating runtime computable number of times\n@@ -721,9 +731,10 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n       return;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \"\\n;; Considering unrolling loop with runtime computable number of iterations\\n\");\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\n;; Considering unrolling loop with runtime \"\n+\t     \"computable number of iterations\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n@@ -737,8 +748,8 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -748,24 +759,25 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   /* Check simpleness.  */\n   if (!desc->simple_p || desc->assumptions)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \";; Unable to prove that the number of iterations can be counted in runtime\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \";; Unable to prove that the number of iterations \"\n+\t\t \"can be counted in runtime\\n\");\n       return;\n     }\n \n   if (desc->const_iter)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Loop iterates constant times\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Loop iterates constant times\\n\");\n       return;\n     }\n \n   /* If we have profile feedback, check whether the loop rolls.  */\n   if (loop->header->count && expected_loop_iterations (loop) < 2 * nunroll)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n       return;\n     }\n \n@@ -777,9 +789,10 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   loop->lpt_decision.decision = LPT_UNROLL_RUNTIME;\n   loop->lpt_decision.times = i - 1;\n   \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \";; Decided to unroll the runtime computable times rolling loop, %d times.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \";; Decided to unroll the runtime computable \"\n+\t     \"times rolling loop, %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n \n@@ -1013,9 +1026,10 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       desc->niter_max--;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \";; Unrolled loop %d times, counting # of iterations in runtime, %i insns\\n\",\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \";; Unrolled loop %d times, counting # of iterations \"\n+\t     \"in runtime, %i insns\\n\",\n \t     max_unroll, num_loop_insns (loop));\n }\n \n@@ -1032,8 +1046,8 @@ decide_peel_simple (struct loop *loop, int flags)\n       return;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n;; Considering simply peeling loop\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Considering simply peeling loop\\n\");\n \n   /* npeel = number of iterations to peel.  */\n   npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / loop->ninsns;\n@@ -1043,8 +1057,8 @@ decide_peel_simple (struct loop *loop, int flags)\n   /* Skip big loops.  */\n   if (!npeel)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -1054,17 +1068,17 @@ decide_peel_simple (struct loop *loop, int flags)\n   /* Check number of iterations.  */\n   if (desc->simple_p && !desc->assumptions && desc->const_iter)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Loop iterates constant times\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Loop iterates constant times\\n\");\n       return;\n     }\n \n   /* Do not simply peel loops with branches inside -- it increases number\n      of mispredicts.  */\n   if (num_loop_branches (loop) > 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not peeling, contains branches\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not peeling, contains branches\\n\");\n       return;\n     }\n \n@@ -1073,11 +1087,13 @@ decide_peel_simple (struct loop *loop, int flags)\n       unsigned niter = expected_loop_iterations (loop);\n       if (niter + 1 > npeel)\n \t{\n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file, \";; Not peeling loop, rolls too much (\");\n-\t      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) (niter + 1));\n-\t      fprintf (rtl_dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n+\t      fprintf (dump_file, \";; Not peeling loop, rolls too much (\");\n+\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t\t       (HOST_WIDEST_INT) (niter + 1));\n+\t      fprintf (dump_file, \" iterations > %d [maximum peelings])\\n\",\n+\t\t       npeel);\n \t    }\n \t  return;\n \t}\n@@ -1087,8 +1103,8 @@ decide_peel_simple (struct loop *loop, int flags)\n     {\n       /* For now we have no good heuristics to decide whether loop peeling\n          will be effective, so disable it.  */\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \";; Not peeling loop, no evidence it will be profitable\\n\");\n       return;\n     }\n@@ -1097,8 +1113,8 @@ decide_peel_simple (struct loop *loop, int flags)\n   loop->lpt_decision.decision = LPT_PEEL_SIMPLE;\n   loop->lpt_decision.times = npeel;\n       \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Decided to simply peel the loop, %d times.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \";; Decided to simply peel the loop, %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n \n@@ -1150,8 +1166,8 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n \t  free_simple_loop_desc (loop);\n \t}\n     }\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Peeling loop %d times\\n\", npeel);\n+  if (dump_file)\n+    fprintf (dump_file, \";; Peeling loop %d times\\n\", npeel);\n }\n \n /* Decide whether to unroll LOOP stupidly and how much.  */\n@@ -1167,13 +1183,14 @@ decide_unroll_stupid (struct loop *loop, int flags)\n       return;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n;; Considering unrolling loop stupidly\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Considering unrolling loop stupidly\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n   nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n-  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  nunroll_by_av\n+    = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n   if (nunroll > nunroll_by_av)\n     nunroll = nunroll_by_av;\n   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n@@ -1182,8 +1199,8 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not considering loop, is too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n       return;\n     }\n \n@@ -1193,26 +1210,26 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   /* Check simpleness.  */\n   if (desc->simple_p && !desc->assumptions)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; The loop is simple\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; The loop is simple\\n\");\n       return;\n     }\n \n   /* Do not unroll loops with branches inside -- it increases number\n      of mispredicts.  */\n   if (num_loop_branches (loop) > 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unrolling, contains branches\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unrolling, contains branches\\n\");\n       return;\n     }\n \n   /* If we have profile feedback, check whether the loop rolls.  */\n   if (loop->header->count\n       && expected_loop_iterations (loop) < 2 * nunroll)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n       return;\n     }\n \n@@ -1225,8 +1242,8 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   loop->lpt_decision.decision = LPT_UNROLL_STUPID;\n   loop->lpt_decision.times = i - 1;\n       \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \";; Decided to unroll the loop stupidly, %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n@@ -1276,7 +1293,7 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n       desc->simple_p = false;\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Unrolled loop %d times, %i insns\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \";; Unrolled loop %d times, %i insns\\n\",\n \t     nunroll, num_loop_insns (loop));\n }"}, {"sha": "a056841ef8a196dd172d74691a833fd35f6690bf", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -269,48 +269,48 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n   /* Do not unswitch too much.  */\n   if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching anymore, hit max level\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n       return;\n     }\n \n   /* Only unswitch innermost loops.  */\n   if (loop->inner)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching, not innermost loop\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching, not innermost loop\\n\");\n       return;\n     }\n \n   /* We must be able to duplicate loop body.  */\n   if (!can_duplicate_loop_p (loop))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching, can't duplicate loop\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching, can't duplicate loop\\n\");\n       return;\n     }\n \n   /* The loop should not be too large, to limit code growth.  */\n   if (num_loop_insns (loop) > PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching, loop too big\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n       return;\n     }\n \n   /* Do not unswitch in cold areas.  */\n   if (!maybe_hot_bb_p (loop->header))\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching, not hot area\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching, not hot area\\n\");\n       return;\n     }\n \n   /* Nor if the loop usually does not roll.  */\n   if (expected_loop_iterations (loop) < 1)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \";; Not unswitching, loop iterations < 1\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Not unswitching, loop iterations < 1\\n\");\n       return;\n     }\n \n@@ -364,8 +364,8 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n   else\n     rconds = cond_checked;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \";; Unswitching loop\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \";; Unswitching loop\\n\");\n \n   /* Unswitch the loop on this condition.  */\n   nloop = unswitch_loop (loops, loop, bbs[i], cond, cinsn);"}, {"sha": "c4e5bb2f63fe59fdc7beba8623c844e27ae771bc", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -418,7 +418,7 @@ extern int current_function_uses_only_leaf_regs;\n /* Default file in which to dump debug output.  */\n \n #ifdef BUFSIZ\n-extern FILE *rtl_dump_file;\n+extern FILE *dump_file;\n #endif\n \n /* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */"}, {"sha": "bed0384cd2452b9dce7b1022513496dbbd42638d", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -260,29 +260,29 @@ dump_prediction (enum br_predictor predictor, int probability,\n {\n   edge e = bb->succ;\n \n-  if (!rtl_dump_file)\n+  if (!dump_file)\n     return;\n \n   while (e && (e->flags & EDGE_FALLTHRU))\n     e = e->succ_next;\n \n-  fprintf (rtl_dump_file, \"  %s heuristics%s: %.1f%%\",\n+  fprintf (dump_file, \"  %s heuristics%s: %.1f%%\",\n \t   predictor_info[predictor].name,\n \t   used ? \"\" : \" (ignored)\", probability * 100.0 / REG_BR_PROB_BASE);\n \n   if (bb->count)\n     {\n-      fprintf (rtl_dump_file, \"  exec \");\n-      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n+      fprintf (dump_file, \"  exec \");\n+      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n       if (e)\n \t{\n-\t  fprintf (rtl_dump_file, \" hit \");\n-\t  fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, e->count);\n-\t  fprintf (rtl_dump_file, \" (%.1f%%)\", e->count * 100.0 / bb->count);\n+\t  fprintf (dump_file, \" hit \");\n+\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, e->count);\n+\t  fprintf (dump_file, \" (%.1f%%)\", e->count * 100.0 / bb->count);\n \t}\n     }\n \n-  fprintf (rtl_dump_file, \"\\n\");\n+  fprintf (dump_file, \"\\n\");\n }\n \n /* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n@@ -301,8 +301,8 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n   bool first_match = false;\n   bool found = false;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Predictions for insn %i bb %i\\n\", INSN_UID (insn),\n+  if (dump_file)\n+    fprintf (dump_file, \"Predictions for insn %i bb %i\\n\", INSN_UID (insn),\n \t     bb->index);\n \n   /* We implement \"first match\" heuristics and use probability guessed\n@@ -915,8 +915,8 @@ propagate_freq (struct loop *loop)\n \t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n \t      count++;\n \t    else if (BLOCK_INFO (e->src)->tovisit\n-\t\t     && rtl_dump_file && !EDGE_INFO (e)->back_edge)\n-\t      fprintf (rtl_dump_file,\n+\t\t     && dump_file && !EDGE_INFO (e)->back_edge)\n+\t      fprintf (dump_file,\n \t\t       \"Irreducible region hit, ignoring edge to %i->%i\\n\",\n \t\t       e->src->index, bb->index);\n \t  BLOCK_INFO (bb)->npredecessors = count;"}, {"sha": "238a2e264c22db8be4201a1e0ff12312cb942935", "filename": "gcc/profile.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -151,8 +151,8 @@ instrument_edges (struct edge_list *el)\n \n \t      if (e->flags & EDGE_ABNORMAL)\n \t\tabort ();\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Edge %d to %d instrumented%s\\n\",\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Edge %d to %d instrumented%s\\n\",\n \t\t\t e->src->index, e->dest->index,\n \t\t\t EDGE_CRITICAL_P (e) ? \" (and split)\" : \"\");\n \t      edge_profile = gen_edge_profiler (num_instr_edges++);\n@@ -163,8 +163,8 @@ instrument_edges (struct edge_list *el)\n     }\n \n   total_num_blocks_created += num_edges;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n+  if (dump_file)\n+    fprintf (dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n   return num_instr_edges;\n }\n \n@@ -255,8 +255,8 @@ get_exec_counts (void)\n   if (!counts)\n     return NULL;\n \n-  if (rtl_dump_file && profile_info)\n-    fprintf(rtl_dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n+  if (dump_file && profile_info)\n+    fprintf(dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n \t    profile_info->runs, (unsigned) profile_info->sum_max);\n \n   return counts;\n@@ -343,18 +343,18 @@ compute_branch_probabilities (void)\n \t    EDGE_INFO (e)->count_valid = 1;\n \t    BB_INFO (bb)->succ_count--;\n \t    BB_INFO (e->dest)->pred_count--;\n-\t    if (rtl_dump_file)\n+\t    if (dump_file)\n \t      {\n-\t\tfprintf (rtl_dump_file, \"\\nRead edge from %i to %i, count:\",\n+\t\tfprintf (dump_file, \"\\nRead edge from %i to %i, count:\",\n \t\t\t bb->index, e->dest->index);\n-\t\tfprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t\tfprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t\t\t (HOST_WIDEST_INT) e->count);\n \t      }\n \t  }\n     }\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n%d edge counts read\\n\", num_edges);\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n%d edge counts read\\n\", num_edges);\n \n   /* For every block in the file,\n      - if every exit/entrance edge has a known count, then set the block count\n@@ -466,12 +466,12 @@ compute_branch_probabilities (void)\n \t    }\n \t}\n     }\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   total_num_passes += passes;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n+  if (dump_file)\n+    fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n \n   /* If the graph has been correctly solved, every block will have a\n      succ and pred count of zero.  */\n@@ -600,14 +600,14 @@ compute_branch_probabilities (void)\n \t}\n     }\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"%d branches\\n\", num_branches);\n-      fprintf (rtl_dump_file, \"%d branches never executed\\n\",\n+      fprintf (dump_file, \"%d branches\\n\", num_branches);\n+      fprintf (dump_file, \"%d branches never executed\\n\",\n \t       num_never_executed);\n       if (num_branches)\n \tfor (i = 0; i < 10; i++)\n-\t  fprintf (rtl_dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t  fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n \t\t   (hist_br_prob[i] + hist_br_prob[19-i]) * 100 / num_branches,\n \t\t   5 * i, 5 * i + 5);\n \n@@ -616,8 +616,8 @@ compute_branch_probabilities (void)\n       for (i = 0; i < 20; i++)\n \ttotal_hist_br_prob[i] += hist_br_prob[i];\n \n-      fputc ('\\n', rtl_dump_file);\n-      fputc ('\\n', rtl_dump_file);\n+      fputc ('\\n', dump_file);\n+      fputc ('\\n', dump_file);\n     }\n \n   free_aux_for_blocks ();\n@@ -752,15 +752,15 @@ branch_prob (void)\n \n       if (need_exit_edge && !have_exit_edge)\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Adding fake exit edge to bb %i\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Adding fake exit edge to bb %i\\n\",\n \t\t     bb->index);\n \t  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t}\n       if (need_entry_edge && !have_entry_edge)\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Adding fake entry edge to bb %i\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Adding fake entry edge to bb %i\\n\",\n \t\t     bb->index);\n \t  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n \t}\n@@ -817,16 +817,16 @@ branch_prob (void)\n     }\n \n   total_num_blocks += n_basic_blocks + 2;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d basic blocks\\n\", n_basic_blocks);\n+  if (dump_file)\n+    fprintf (dump_file, \"%d basic blocks\\n\", n_basic_blocks);\n \n   total_num_edges += num_edges;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d edges\\n\", num_edges);\n+  if (dump_file)\n+    fprintf (dump_file, \"%d edges\\n\", num_edges);\n \n   total_num_edges_ignored += ignored_edges;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d ignored edges\\n\", ignored_edges);\n+  if (dump_file)\n+    fprintf (dump_file, \"%d ignored edges\\n\", ignored_edges);\n \n   /* Write the data from which gcov can reconstruct the basic block\n      graph.  */\n@@ -993,8 +993,8 @@ branch_prob (void)\n   /* Re-merge split basic blocks and the mess introduced by\n      insert_insn_on_edge.  */\n   cleanup_cfg (profile_arc_flag ? CLEANUP_EXPENSIVE : 0);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   free_edge_list (el);\n }\n@@ -1066,8 +1066,8 @@ find_spanning_tree (struct edge_list *el)\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Abnormal edge %d to %d put to tree\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Abnormal edge %d to %d put to tree\\n\",\n \t\t     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n@@ -1081,8 +1081,8 @@ find_spanning_tree (struct edge_list *el)\n       if (EDGE_CRITICAL_P (e) && !EDGE_INFO (e)->ignore\n \t  && find_group (e->src) != find_group (e->dest))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Critical edge %d to %d put to tree\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Critical edge %d to %d put to tree\\n\",\n \t\t     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n@@ -1096,8 +1096,8 @@ find_spanning_tree (struct edge_list *el)\n       if (!EDGE_INFO (e)->ignore\n \t  && find_group (e->src) != find_group (e->dest))\n \t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"Normal edge %d to %d put to tree\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Normal edge %d to %d put to tree\\n\",\n \t\t     e->src->index, e->dest->index);\n \t  EDGE_INFO (e)->on_tree = 1;\n \t  union_groups (e->src, e->dest);\n@@ -1134,34 +1134,34 @@ init_branch_prob (void)\n void\n end_branch_prob (void)\n {\n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"\\n\");\n-      fprintf (rtl_dump_file, \"Total number of blocks: %d\\n\",\n+      fprintf (dump_file, \"\\n\");\n+      fprintf (dump_file, \"Total number of blocks: %d\\n\",\n \t       total_num_blocks);\n-      fprintf (rtl_dump_file, \"Total number of edges: %d\\n\", total_num_edges);\n-      fprintf (rtl_dump_file, \"Total number of ignored edges: %d\\n\",\n+      fprintf (dump_file, \"Total number of edges: %d\\n\", total_num_edges);\n+      fprintf (dump_file, \"Total number of ignored edges: %d\\n\",\n \t       total_num_edges_ignored);\n-      fprintf (rtl_dump_file, \"Total number of instrumented edges: %d\\n\",\n+      fprintf (dump_file, \"Total number of instrumented edges: %d\\n\",\n \t       total_num_edges_instrumented);\n-      fprintf (rtl_dump_file, \"Total number of blocks created: %d\\n\",\n+      fprintf (dump_file, \"Total number of blocks created: %d\\n\",\n \t       total_num_blocks_created);\n-      fprintf (rtl_dump_file, \"Total number of graph solution passes: %d\\n\",\n+      fprintf (dump_file, \"Total number of graph solution passes: %d\\n\",\n \t       total_num_passes);\n       if (total_num_times_called != 0)\n-\tfprintf (rtl_dump_file, \"Average number of graph solution passes: %d\\n\",\n+\tfprintf (dump_file, \"Average number of graph solution passes: %d\\n\",\n \t\t (total_num_passes + (total_num_times_called  >> 1))\n \t\t / total_num_times_called);\n-      fprintf (rtl_dump_file, \"Total number of branches: %d\\n\",\n+      fprintf (dump_file, \"Total number of branches: %d\\n\",\n \t       total_num_branches);\n-      fprintf (rtl_dump_file, \"Total number of branches never executed: %d\\n\",\n+      fprintf (dump_file, \"Total number of branches never executed: %d\\n\",\n \t       total_num_never_executed);\n       if (total_num_branches)\n \t{\n \t  int i;\n \n \t  for (i = 0; i < 10; i++)\n-\t    fprintf (rtl_dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t    fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n \t\t     (total_hist_br_prob[i] + total_hist_br_prob[19-i]) * 100\n \t\t     / total_num_branches, 5*i, 5*i+5);\n \t}"}, {"sha": "505a1f4c39fe3bcf26f9c89db694ece3ba0a763a", "filename": "gcc/ra-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -2944,7 +2944,7 @@ handle_asm_insn (struct df *df, rtx insn)\n \t      record_conflict (web, hardreg2web[c]);\n #endif\n \t}\n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n \t  int c;\n \t  ra_debug_msg (DUMP_ASM, \" ASM constrain Web %d conflicts with:\", web->id);"}, {"sha": "dc073fe72717b206756b346d17b43359bba6fc7b", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -2608,7 +2608,7 @@ check_uncoalesced_moves (void)\n void\n ra_colorize_graph (struct df *df)\n {\n-  if (rtl_dump_file)\n+  if (dump_file)\n     dump_igraph (df);\n   build_worklists (df);\n "}, {"sha": "633f37524c278b0ba6d990e719add53bfb49a94e", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -54,8 +54,8 @@ ra_debug_msg (unsigned int level, const char *format, ...)\n   va_list ap;\n   \n   va_start (ap, format);\n-  if ((debug_new_regalloc & level) != 0 && rtl_dump_file != NULL)\n-    vfprintf (rtl_dump_file, format, ap);\n+  if ((debug_new_regalloc & level) != 0 && dump_file != NULL)\n+    vfprintf (dump_file, format, ap);\n   va_end (ap);\n }\n \n@@ -643,7 +643,7 @@ dump_igraph (struct df *df ATTRIBUTE_UNUSED)\n   int num = 0;\n   int num2;\n   unsigned int i;\n-  if (!rtl_dump_file || (debug_new_regalloc & (DUMP_IGRAPH | DUMP_WEBS)) == 0)\n+  if (!dump_file || (debug_new_regalloc & (DUMP_IGRAPH | DUMP_WEBS)) == 0)\n     return;\n   ra_debug_msg (DUMP_IGRAPH, \"conflicts:\\n  \");\n   for (def1 = 0; def1 < num_webs; def1++)\n@@ -726,7 +726,7 @@ dump_igraph_machine (void)\n {\n   unsigned int i;\n \n-  if (!rtl_dump_file || (debug_new_regalloc & DUMP_IGRAPH_M) == 0)\n+  if (!dump_file || (debug_new_regalloc & DUMP_IGRAPH_M) == 0)\n     return;\n   ra_debug_msg (DUMP_IGRAPH_M, \"g %d %d\\n\", num_webs - num_subwebs,\n \t     FIRST_PSEUDO_REGISTER);\n@@ -786,7 +786,7 @@ dump_constraints (void)\n {\n   rtx insn;\n   int i;\n-  if (!rtl_dump_file || (debug_new_regalloc & DUMP_CONSTRAINTS) == 0)\n+  if (!dump_file || (debug_new_regalloc & DUMP_CONSTRAINTS) == 0)\n     return;\n   for (i = FIRST_PSEUDO_REGISTER; i < ra_max_regno; i++)\n     if (regno_reg_rtx[i] && GET_CODE (regno_reg_rtx[i]) == REG)\n@@ -839,7 +839,7 @@ dump_graph_cost (unsigned int level, const char *msg)\n {\n   unsigned int i;\n   unsigned HOST_WIDE_INT cost;\n-  if (!rtl_dump_file || (debug_new_regalloc & level) == 0)\n+  if (!dump_file || (debug_new_regalloc & level) == 0)\n     return;\n \n   cost = 0;\n@@ -861,7 +861,7 @@ dump_ra (struct df *df ATTRIBUTE_UNUSED)\n {\n   struct web *web;\n   struct dlist *d;\n-  if (!rtl_dump_file || (debug_new_regalloc & DUMP_RESULTS) == 0)\n+  if (!dump_file || (debug_new_regalloc & DUMP_RESULTS) == 0)\n     return;\n \n   ra_debug_msg (DUMP_RESULTS, \"\\nColored:\\n\");"}, {"sha": "6c6a53d27b61810b4ff4a153dd6da8079d4feaef", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -1534,10 +1534,10 @@ detect_web_parts_to_rebuild (void)\n \t\t      BITMAP_AND_COMPL);\n   live_at_end += 2;\n \n-  if (rtl_dump_file && (debug_new_regalloc & DUMP_REBUILD) != 0)\n+  if (dump_file && (debug_new_regalloc & DUMP_REBUILD) != 0)\n     {\n       ra_debug_msg (DUMP_REBUILD, \"need to check these uses:\\n\");\n-      dump_sbitmap_file (rtl_dump_file, last_check_uses);\n+      dump_sbitmap_file (dump_file, last_check_uses);\n     }\n   sbitmap_free (already_webs);\n   BITMAP_XFREE (uses_as_bitmap);"}, {"sha": "773d79a6a7f2a4448e0498093708d9541ee81bd3", "filename": "gcc/ra.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -647,7 +647,7 @@ void\n reg_alloc (void)\n {\n   int changed;\n-  FILE *ra_dump_file = rtl_dump_file;\n+  FILE *ra_dump_file = dump_file;\n   rtx last = get_last_insn ();\n \n   if (! INSN_P (last))\n@@ -691,16 +691,16 @@ reg_alloc (void)\n \t      break;\n       case 6: debug_new_regalloc = DUMP_VALIDIFY; break;\n     }\n-  if (!rtl_dump_file)\n+  if (!dump_file)\n     debug_new_regalloc = 0;\n \n   /* Run regclass first, so we know the preferred and alternate classes\n      for each pseudo.  Deactivate emitting of debug info, if it's not\n      explicitly requested.  */\n   if ((debug_new_regalloc & DUMP_REGCLASS) == 0)\n-    rtl_dump_file = NULL;\n-  regclass (get_insns (), max_reg_num (), rtl_dump_file);\n-  rtl_dump_file = ra_dump_file;\n+    dump_file = NULL;\n+  regclass (get_insns (), max_reg_num (), dump_file);\n+  dump_file = ra_dump_file;\n \n   /* We don't use those NOTEs, and as we anyway change all registers,\n      they only make problems later.  */\n@@ -758,10 +758,10 @@ reg_alloc (void)\n       if ((debug_new_regalloc & DUMP_DF) != 0)\n \t{\n \t  rtx insn;\n-\t  df_dump (df, DF_HARD_REGS, rtl_dump_file);\n+\t  df_dump (df, DF_HARD_REGS, dump_file);\n \t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n             if (INSN_P (insn))\n-\t      df_insn_debug_regno (df, insn, rtl_dump_file);\n+\t      df_insn_debug_regno (df, insn, dump_file);\n \t}\n       check_df (df);\n \n@@ -795,7 +795,7 @@ reg_alloc (void)\n \t     therefore repeat some things, including some initialization\n \t     of global data structures.  */\n \t  if ((debug_new_regalloc & DUMP_REGCLASS) == 0)\n-\t    rtl_dump_file = NULL;\n+\t    dump_file = NULL;\n \t  /* We have new pseudos (the stackwebs).  */\n \t  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n \t  /* And new insns.  */\n@@ -806,8 +806,8 @@ reg_alloc (void)\n \t  reg_scan_update (get_insns (), NULL, max_regno);\n \t  max_regno = max_reg_num ();\n \t  /* And they need useful classes too.  */\n-\t  regclass (get_insns (), max_reg_num (), rtl_dump_file);\n-\t  rtl_dump_file = ra_dump_file;\n+\t  regclass (get_insns (), max_reg_num (), dump_file);\n+\t  dump_file = ra_dump_file;\n \n \t  /* Remember the number of defs and uses, so we can distinguish\n \t     new from old refs in the next pass.  */\n@@ -819,8 +819,8 @@ reg_alloc (void)\n       dump_ra (df);\n       if (changed && (debug_new_regalloc & DUMP_RTL) != 0)\n \t{\n-\t  ra_print_rtl_with_bb (rtl_dump_file, get_insns ());\n-\t  fflush (rtl_dump_file);\n+\t  ra_print_rtl_with_bb (dump_file, get_insns ());\n+\t  fflush (dump_file);\n \t}\n \n       /* Reset the web lists.  */\n@@ -838,15 +838,15 @@ reg_alloc (void)\n   ra_debug_msg (DUMP_COSTS, \"ticks for build-phase: %ld\\n\", ticks_build);\n   ra_debug_msg (DUMP_COSTS, \"ticks for rebuild-phase: %ld\\n\", ticks_rebuild);\n   if ((debug_new_regalloc & (DUMP_FINAL_RTL | DUMP_RTL)) != 0)\n-    ra_print_rtl_with_bb (rtl_dump_file, get_insns ());\n+    ra_print_rtl_with_bb (dump_file, get_insns ());\n \n   /* We might have new pseudos, so allocate the info arrays for them.  */\n   if ((debug_new_regalloc & DUMP_SM) == 0)\n-    rtl_dump_file = NULL;\n+    dump_file = NULL;\n   no_new_pseudos = 0;\n   allocate_reg_info (max_reg_num (), FALSE, FALSE);\n   no_new_pseudos = 1;\n-  rtl_dump_file = ra_dump_file;\n+  dump_file = ra_dump_file;\n \n   /* Some spill insns could've been inserted after trapping calls, i.e.\n      at the end of a basic block, which really ends at that call.\n@@ -855,14 +855,14 @@ reg_alloc (void)\n \n   /* Cleanup the flow graph.  */\n   if ((debug_new_regalloc & DUMP_LAST_FLOW) == 0)\n-    rtl_dump_file = NULL;\n-  life_analysis (get_insns (), rtl_dump_file,\n+    dump_file = NULL;\n+  life_analysis (get_insns (), dump_file,\n \t\t PROP_DEATH_NOTES | PROP_LOG_LINKS  | PROP_REG_INFO);\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   recompute_reg_usage (get_insns (), TRUE);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n-  rtl_dump_file = ra_dump_file;\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  dump_file = ra_dump_file;\n \n   /* update_equiv_regs() can't be called after register allocation.\n      It might delete some pseudos, and insert other insns setting\n@@ -882,16 +882,16 @@ reg_alloc (void)\n   remove_suspicious_death_notes ();\n \n   if ((debug_new_regalloc & DUMP_LAST_RTL) != 0)\n-    ra_print_rtl_with_bb (rtl_dump_file, get_insns ());\n-  dump_static_insn_cost (rtl_dump_file,\n+    ra_print_rtl_with_bb (dump_file, get_insns ());\n+  dump_static_insn_cost (dump_file,\n \t\t\t \"after allocation/spilling, before reload\", NULL);\n \n   /* Allocate the reg_equiv_memory_loc array for reload.  */\n   reg_equiv_memory_loc = xcalloc (max_regno, sizeof (rtx));\n   /* And possibly initialize it.  */\n   allocate_initial_values (reg_equiv_memory_loc);\n   /* And one last regclass pass just before reload.  */\n-  regclass (get_insns (), max_reg_num (), rtl_dump_file);\n+  regclass (get_insns (), max_reg_num (), dump_file);\n }\n \n /*"}, {"sha": "0623e9d53803197700eda2cbd1de6c30260274bd", "filename": "gcc/regrename.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -204,12 +204,12 @@ regrename_optimize (void)\n \n       CLEAR_HARD_REG_SET (unavailable);\n \n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", bb->index);\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n \n       all_chains = build_def_use (bb);\n \n-      if (rtl_dump_file)\n+      if (dump_file)\n \tdump_def_use_chain (all_chains);\n \n       CLEAR_HARD_REG_SET (unavailable);\n@@ -327,36 +327,36 @@ regrename_optimize (void)\n \t\t}\n \t    }\n \n-\t  if (rtl_dump_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (rtl_dump_file, \"Register %s in insn %d\",\n+\t      fprintf (dump_file, \"Register %s in insn %d\",\n \t\t       reg_names[reg], INSN_UID (last->insn));\n \t      if (last->need_caller_save_reg)\n-\t\tfprintf (rtl_dump_file, \" crosses a call\");\n+\t\tfprintf (dump_file, \" crosses a call\");\n \t    }\n \n \t  if (best_new_reg == reg)\n \t    {\n \t      tick[reg] = ++this_tick;\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"; no available better choice\\n\");\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"; no available better choice\\n\");\n \t      continue;\n \t    }\n \n \t  do_replace (this, best_new_reg);\n \t  tick[best_new_reg] = ++this_tick;\n \n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n \t}\n \n       obstack_free (&rename_obstack, first_obj);\n     }\n \n   obstack_free (&rename_obstack, NULL);\n \n-  if (rtl_dump_file)\n-    fputc ('\\n', rtl_dump_file);\n+  if (dump_file)\n+    fputc ('\\n', dump_file);\n \n   count_or_remove_death_notes (NULL, 1);\n   update_life_info (NULL, UPDATE_LIFE_LOCAL,\n@@ -479,16 +479,16 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n \t\t{\n \t\t  this->next_chain = closed_chains;\n \t\t  closed_chains = this;\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Closing chain %s at insn %d (%s)\\n\",\n \t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Discarding chain %s at insn %d (%s)\\n\",\n \t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n@@ -963,7 +963,7 @@ build_def_use (basic_block bb)\n   return closed_chains;\n }\n \n-/* Dump all def/use chains in CHAINS to RTL_DUMP_FILE.  They are\n+/* Dump all def/use chains in CHAINS to DUMP_FILE.  They are\n    printed in reverse order as that's how we build them.  */\n \n static void\n@@ -974,14 +974,14 @@ dump_def_use_chain (struct du_chain *chains)\n       struct du_chain *this = chains;\n       int r = REGNO (*this->loc);\n       int nregs = hard_regno_nregs[r][GET_MODE (*this->loc)];\n-      fprintf (rtl_dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n+      fprintf (dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n       while (this)\n \t{\n-\t  fprintf (rtl_dump_file, \" %d [%s]\", INSN_UID (this->insn),\n+\t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this->insn),\n \t\t   reg_class_names[this->class]);\n \t  this = this->next_use;\n \t}\n-      fprintf (rtl_dump_file, \"\\n\");\n+      fprintf (dump_file, \"\\n\");\n       chains = chains->next_chain;\n     }\n }\n@@ -1367,8 +1367,8 @@ replace_oldest_value_reg (rtx *loc, enum reg_class class, rtx insn,\n   rtx new = find_oldest_value_reg (class, *loc, vd);\n   if (new)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"insn %u: replaced reg %u with %u\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"insn %u: replaced reg %u with %u\\n\",\n \t\t INSN_UID (insn), REGNO (*loc), REGNO (new));\n \n       *loc = new;\n@@ -1612,8 +1612,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t      new = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n \t      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n \t\t{\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n \t\t\t     INSN_UID (insn), regno, REGNO (new));\n \t\t  changed = true;\n@@ -1633,8 +1633,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\t    {\n \t\t      ORIGINAL_REGNO (new) = ORIGINAL_REGNO (src);\n \t\t      REG_ATTRS (new) = REG_ATTRS (src);\n-\t\t      if (rtl_dump_file)\n-\t\t\tfprintf (rtl_dump_file,\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n \t\t\t\t \"insn %u: replaced reg %u with %u\\n\",\n \t\t\t\t INSN_UID (insn), regno, REGNO (new));\n \t\t      changed = true;\n@@ -1756,8 +1756,8 @@ copyprop_hardreg_forward (void)\n \n   if (need_refresh)\n     {\n-      if (rtl_dump_file)\n-\tfputs (\"\\n\\n\", rtl_dump_file);\n+      if (dump_file)\n+\tfputs (\"\\n\\n\", dump_file);\n \n       /* ??? Irritatingly, delete_noop_moves does not take a set of blocks\n \t to scan, so we have to do a life update with no initial set of"}, {"sha": "1f21e4800a6eb0832116fc909bd8b51b7298edba", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -1720,8 +1720,8 @@ find_reg (struct insn_chain *chain, int order)\n   if (best_reg == -1)\n     return 0;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n+  if (dump_file)\n+    fprintf (dump_file, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n \n   rl->nregs = hard_regno_nregs[best_reg][rl->mode];\n   rl->regno = best_reg;\n@@ -1783,8 +1783,8 @@ find_reload_regs (struct insn_chain *chain)\n \n   CLEAR_HARD_REG_SET (used_spill_regs_local);\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n+  if (dump_file)\n+    fprintf (dump_file, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n \n   qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n@@ -3699,12 +3699,12 @@ finish_spills (int global)\n \n       alter_reg (i, reg_old_renumber[i]);\n       reg_old_renumber[i] = regno;\n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n \t  if (regno == -1)\n-\t    fprintf (rtl_dump_file, \" Register %d now on stack.\\n\\n\", i);\n+\t    fprintf (dump_file, \" Register %d now on stack.\\n\\n\", i);\n \t  else\n-\t    fprintf (rtl_dump_file, \" Register %d now in %d.\\n\\n\",\n+\t    fprintf (dump_file, \" Register %d now in %d.\\n\\n\",\n \t\t     i, reg_renumber[i]);\n \t}\n     }\n@@ -6944,10 +6944,10 @@ emit_reload_insns (struct insn_chain *chain)\n   other_operand_reload_insns = 0;\n \n   /* Dump reloads into the dump file.  */\n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n-      fprintf (rtl_dump_file, \"\\nReloads for insn # %d\\n\", INSN_UID (insn));\n-      debug_reload_to_stream (rtl_dump_file);\n+      fprintf (dump_file, \"\\nReloads for insn # %d\\n\", INSN_UID (insn));\n+      debug_reload_to_stream (dump_file);\n     }\n \n   /* Now output the instructions to copy the data into and out of the"}, {"sha": "d99c3bfccdd66baa8cb97b964aeca77dc9179284", "filename": "gcc/toplev.c", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -306,7 +306,7 @@ enum dump_file_index\n \t\"         JK   O Q     WXY \"\n */\n \n-static struct dump_file_info dump_file[DFI_MAX] =\n+static struct dump_file_info dump_file_tbl[DFI_MAX] =\n {\n   { \"cgraph\",\t'U', 0, 0, 0 },\n   { \"rtl\",\t'r', 0, 0, 0 },\n@@ -1208,7 +1208,7 @@ int warn_return_type;\n \n FILE *asm_out_file;\n FILE *aux_info_file;\n-FILE *rtl_dump_file = NULL;\n+FILE *dump_file = NULL;\n FILE *cgraph_dump_file = NULL;\n \n /* The current working directory of a translation.  It's generally the\n@@ -1479,42 +1479,42 @@ open_dump_file (enum dump_file_index index, tree decl)\n   const char *open_arg;\n   char seq[16];\n \n-  if (! dump_file[index].enabled)\n+  if (! dump_file_tbl[index].enabled)\n     return 0;\n \n   timevar_push (TV_DUMP);\n-  if (rtl_dump_file != NULL)\n-    fclose (rtl_dump_file);\n+  if (dump_file != NULL)\n+    fclose (dump_file);\n \n   sprintf (seq, DUMPFILE_FORMAT, index);\n \n-  if (! dump_file[index].initialized)\n+  if (! dump_file_tbl[index].initialized)\n     {\n       /* If we've not initialized the files, do so now.  */\n       if (graph_dump_format != no_graph\n-\t  && dump_file[index].graph_dump_p)\n+\t  && dump_file_tbl[index].graph_dump_p)\n \t{\n-\t  dump_name = concat (seq, dump_file[index].extension, NULL);\n+\t  dump_name = concat (seq, dump_file_tbl[index].extension, NULL);\n \t  clean_graph_dump_file (dump_base_name, dump_name);\n \t  free (dump_name);\n \t}\n-      dump_file[index].initialized = 1;\n+      dump_file_tbl[index].initialized = 1;\n       open_arg = \"w\";\n     }\n   else\n     open_arg = \"a\";\n \n   dump_name = concat (dump_base_name, seq,\n-\t\t      dump_file[index].extension, NULL);\n+\t\t      dump_file_tbl[index].extension, NULL);\n \n-  rtl_dump_file = fopen (dump_name, open_arg);\n-  if (rtl_dump_file == NULL)\n+  dump_file = fopen (dump_name, open_arg);\n+  if (dump_file == NULL)\n     fatal_error (\"can't open %s: %m\", dump_name);\n \n   free (dump_name);\n \n   if (decl)\n-    fprintf (rtl_dump_file, \"\\n;; Function %s%s\\n\\n\",\n+    fprintf (dump_file, \"\\n;; Function %s%s\\n\\n\",\n \t     (*lang_hooks.decl_printable_name) (decl, 2),\n \t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n \t     ? \" (hot)\"\n@@ -1533,30 +1533,30 @@ close_dump_file (enum dump_file_index index,\n \t\t void (*func) (FILE *, rtx),\n \t\t rtx insns)\n {\n-  if (! rtl_dump_file)\n+  if (! dump_file)\n     return;\n \n   timevar_push (TV_DUMP);\n   if (insns\n       && graph_dump_format != no_graph\n-      && dump_file[index].graph_dump_p)\n+      && dump_file_tbl[index].graph_dump_p)\n     {\n       char seq[16];\n       char *suffix;\n \n       sprintf (seq, DUMPFILE_FORMAT, index);\n-      suffix = concat (seq, dump_file[index].extension, NULL);\n+      suffix = concat (seq, dump_file_tbl[index].extension, NULL);\n       print_rtl_graph_with_bb (dump_base_name, suffix, insns);\n       free (suffix);\n     }\n \n   if (func && insns)\n-    func (rtl_dump_file, insns);\n+    func (dump_file, insns);\n \n-  fflush (rtl_dump_file);\n-  fclose (rtl_dump_file);\n+  fflush (dump_file);\n+  fclose (dump_file);\n \n-  rtl_dump_file = NULL;\n+  dump_file = NULL;\n   timevar_pop (TV_DUMP);\n }\n \n@@ -1899,7 +1899,7 @@ compile_file (void)\n   if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n     {\n       timevar_push (TV_DUMP);\n-      dump_combine_total_stats (rtl_dump_file);\n+      dump_combine_total_stats (dump_file);\n       close_dump_file (DFI_combine, NULL, NULL_RTX);\n       timevar_pop (TV_DUMP);\n     }\n@@ -2073,7 +2073,7 @@ rest_of_handle_delay_slots (tree decl, rtx insns)\n   timevar_push (TV_DBR_SCHED);\n   open_dump_file (DFI_dbr, decl);\n \n-  dbr_schedule (insns, rtl_dump_file);\n+  dbr_schedule (insns, dump_file);\n \n   close_dump_file (DFI_dbr, print_rtl, insns);\n   timevar_pop (TV_DBR_SCHED);\n@@ -2108,7 +2108,7 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n   timevar_push (TV_REG_STACK);\n   open_dump_file (DFI_stack, decl);\n \n-  if (reg_to_stack (insns, rtl_dump_file) && optimize)\n+  if (reg_to_stack (insns, dump_file) && optimize)\n     {\n       if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n \t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n@@ -2166,7 +2166,7 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n   reg_alloc ();\n \n   timevar_pop (TV_LOCAL_ALLOC);\n-  if (dump_file[DFI_lreg].enabled)\n+  if (dump_file_tbl[DFI_lreg].enabled)\n     {\n       timevar_push (TV_DUMP);\n \n@@ -2183,11 +2183,11 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n \n   timevar_pop (TV_GLOBAL_ALLOC);\n \n-  if (dump_file[DFI_greg].enabled)\n+  if (dump_file_tbl[DFI_greg].enabled)\n     {\n       timevar_push (TV_DUMP);\n \n-      dump_global_regs (rtl_dump_file);\n+      dump_global_regs (dump_file);\n \n       close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n       timevar_pop (TV_DUMP);\n@@ -2217,7 +2217,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n \n   allocate_initial_values (reg_equiv_memory_loc);\n \n-  regclass (insns, max_reg_num (), rtl_dump_file);\n+  regclass (insns, max_reg_num (), dump_file);\n   rebuild_notes = local_alloc ();\n \n   timevar_pop (TV_LOCAL_ALLOC);\n@@ -2235,12 +2235,12 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n       timevar_pop (TV_JUMP);\n     }\n \n-  if (dump_file[DFI_lreg].enabled)\n+  if (dump_file_tbl[DFI_lreg].enabled)\n     {\n       timevar_push (TV_DUMP);\n \n-      dump_flow_info (rtl_dump_file);\n-      dump_local_alloc (rtl_dump_file);\n+      dump_flow_info (dump_file);\n+      dump_local_alloc (dump_file);\n \n       close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n       timevar_pop (TV_DUMP);\n@@ -2255,7 +2255,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n      pass fixing up any insns that are invalid.  */\n \n   if (optimize)\n-    failure = global_alloc (rtl_dump_file);\n+    failure = global_alloc (dump_file);\n   else\n     {\n       build_insn_chain (insns);\n@@ -2264,11 +2264,11 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n \n   timevar_pop (TV_GLOBAL_ALLOC);\n \n-  if (dump_file[DFI_greg].enabled)\n+  if (dump_file_tbl[DFI_greg].enabled)\n     {\n       timevar_push (TV_DUMP);\n \n-      dump_global_regs (rtl_dump_file);\n+      dump_global_regs (dump_file);\n \n       close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n       timevar_pop (TV_DUMP);\n@@ -2341,7 +2341,7 @@ rest_of_handle_sched (tree decl, rtx insns)\n       /* Do control and data sched analysis,\n \t and write some of the results to dump file.  */\n \n-      schedule_insns (rtl_dump_file);\n+      schedule_insns (dump_file);\n \n       close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n     }\n@@ -2364,14 +2364,14 @@ rest_of_handle_sched2 (tree decl, rtx insns)\n \n   if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n     {\n-      schedule_ebbs (rtl_dump_file);\n+      schedule_ebbs (dump_file);\n       /* No liveness updating code yet, but it should be easy to do.\n \t reg-stack recompute the liveness when needed for now.  */\n       count_or_remove_death_notes (NULL, 1);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n     }\n   else\n-    schedule_insns (rtl_dump_file);\n+    schedule_insns (dump_file);\n \n   close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n   timevar_pop (TV_SCHED2);\n@@ -2388,7 +2388,7 @@ rest_of_handle_regmove (tree decl, rtx insns)\n   timevar_push (TV_REGMOVE);\n   open_dump_file (DFI_regmove, decl);\n \n-  regmove_optimize (insns, max_reg_num (), rtl_dump_file);\n+  regmove_optimize (insns, max_reg_num (), dump_file);\n \n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n   close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n@@ -2402,8 +2402,8 @@ static void\n rest_of_handle_tracer (tree decl, rtx insns)\n {\n   open_dump_file (DFI_tracer, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   tracer ();\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   reg_scan (insns, max_reg_num (), 0);\n@@ -2418,8 +2418,8 @@ rest_of_handle_if_conversion (tree decl, rtx insns)\n   if (flag_if_conversion)\n     {\n       timevar_push (TV_IFCVT);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n+      if (dump_file)\n+\tdump_flow_info (dump_file);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n       reg_scan (insns, max_reg_num (), 0);\n       if_convert (0);\n@@ -2478,8 +2478,8 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n      block.  The loop infrastructure does the real job for us.  */\n   flow_loops_find (&loops, LOOP_TREE);\n \n-  if (rtl_dump_file)\n-    flow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n+  if (dump_file)\n+    flow_loops_dump (&loops, dump_file, NULL, 0);\n \n   /* Estimate using heuristics if no profiling info is available.  */\n   if (flag_guess_branch_prob)\n@@ -2511,8 +2511,8 @@ static void\n rest_of_handle_cfg (tree decl, rtx insns)\n {\n   open_dump_file (DFI_cfg, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE\n \t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n@@ -2561,7 +2561,7 @@ rest_of_handle_sibling_calls (rtx insns)\n   free_bb_for_insn ();\n   find_exception_handler_labels ();\n   rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n \n   /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n      notes before simplifying cfg and we must do lowering after sibcall\n@@ -2587,7 +2587,7 @@ rest_of_handle_jump_bypass (tree decl, rtx insns)\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   reg_scan (insns, max_reg_num (), 1);\n \n-  if (bypass_jumps (rtl_dump_file))\n+  if (bypass_jumps (dump_file))\n     {\n       rebuild_jump_labels (insns);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n@@ -2674,7 +2674,7 @@ rest_of_handle_inlining (tree decl)\n     {\n       if (DECL_STRUCT_FUNCTION (decl)\n \t  && DECL_STRUCT_FUNCTION (decl)->saved_for_inline)\n-\tfprintf (rtl_dump_file, \";; (integrable)\\n\\n\");\n+\tfprintf (dump_file, \";; (integrable)\\n\\n\");\n       close_dump_file (DFI_rtl, print_rtl, insns);\n     }\n \n@@ -2726,7 +2726,7 @@ rest_of_handle_inlining (tree decl)\n \t  optimize = 0;\n \t  rebuild_jump_labels (insns);\n \t  find_exception_handler_labels ();\n-\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  find_basic_blocks (insns, max_reg_num (), dump_file);\n \t  cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n \t  optimize = saved_optimize;\n \n@@ -2758,8 +2758,8 @@ static void\n rest_of_handle_null_pointer (tree decl, rtx insns)\n {\n   open_dump_file (DFI_null, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   if (delete_null_pointer_checks (insns))\n     cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n@@ -2807,7 +2807,7 @@ rest_of_handle_life (tree decl, rtx insns)\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n-  life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+  life_analysis (insns, dump_file, PROP_FINAL);\n   if (optimize)\n     cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n \t\t | CLEANUP_LOG_LINKS\n@@ -2850,13 +2850,13 @@ rest_of_handle_cse (tree decl, rtx insns)\n   int tem;\n \n   open_dump_file (DFI_cse, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   timevar_push (TV_CSE);\n \n   reg_scan (insns, max_reg_num (), 1);\n \n-  tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+  tem = cse_main (insns, max_reg_num (), 0, dump_file);\n   if (tem)\n     rebuild_jump_labels (insns);\n   if (purge_all_dead_edges (0))\n@@ -2882,7 +2882,7 @@ rest_of_handle_cse (tree decl, rtx insns)\n \n   /* The second pass of jump optimization is likely to have\n      removed a bunch more instructions.  */\n-  renumber_insns (rtl_dump_file);\n+  renumber_insns (dump_file);\n \n   timevar_pop (TV_CSE);\n   close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n@@ -2896,10 +2896,10 @@ rest_of_handle_cse2 (tree decl, rtx insns)\n \n   timevar_push (TV_CSE2);\n   open_dump_file (DFI_cse2, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   /* CFG is no longer maintained up-to-date.  */\n-  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n+  tem = cse_main (insns, max_reg_num (), 1, dump_file);\n \n   /* Run a pass to eliminate duplicated assignments to condition code\n      registers.  We have to run this after bypass_jumps, because it\n@@ -2933,7 +2933,7 @@ rest_of_handle_gcse (tree decl, rtx insns)\n   timevar_push (TV_GCSE);\n   open_dump_file (DFI_gcse, decl);\n \n-  tem = gcse_main (insns, rtl_dump_file);\n+  tem = gcse_main (insns, dump_file);\n   rebuild_jump_labels (insns);\n   delete_trivially_dead_insns (insns, max_reg_num ());\n \n@@ -2951,7 +2951,7 @@ rest_of_handle_gcse (tree decl, rtx insns)\n     {\n       timevar_push (TV_CSE);\n       reg_scan (insns, max_reg_num (), 1);\n-      tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+      tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n       purge_all_dead_edges (0);\n       delete_trivially_dead_insns (insns, max_reg_num ());\n       timevar_pop (TV_CSE);\n@@ -2972,7 +2972,7 @@ rest_of_handle_gcse (tree decl, rtx insns)\n \t{\n \t  timevar_push (TV_CSE);\n \t  reg_scan (insns, max_reg_num (), 1);\n-\t  tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+\t  tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n \t  purge_all_dead_edges (0);\n \t  delete_trivially_dead_insns (insns, max_reg_num ());\n \t  timevar_pop (TV_CSE);\n@@ -3015,7 +3015,7 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n       cleanup_barriers ();\n \n       /* We only want to perform unrolling once.  */\n-      loop_optimize (insns, rtl_dump_file, do_unroll);\n+      loop_optimize (insns, dump_file, do_unroll);\n       do_unroll = 0;\n \n       /* The first call to loop_optimize makes some instructions\n@@ -3029,13 +3029,13 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n       reg_scan (insns, max_reg_num (), 1);\n     }\n   cleanup_barriers ();\n-  loop_optimize (insns, rtl_dump_file, do_unroll | LOOP_BCT | do_prefetch);\n+  loop_optimize (insns, dump_file, do_unroll | LOOP_BCT | do_prefetch);\n \n   /* Loop can create trivially dead instructions.  */\n   delete_trivially_dead_insns (insns, max_reg_num ());\n   close_dump_file (DFI_loop, print_rtl, insns);\n   timevar_pop (TV_LOOP);\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n \n   ggc_collect ();\n }\n@@ -3051,13 +3051,13 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n \n   timevar_push (TV_LOOP);\n   open_dump_file (DFI_loop2, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   /* Initialize structures for layout changes.  */\n   cfg_layout_initialize ();\n \n-  loops = loop_optimizer_init (rtl_dump_file);\n+  loops = loop_optimizer_init (dump_file);\n \n   if (loops)\n     {\n@@ -3071,7 +3071,7 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n \t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n \t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n \n-      loop_optimizer_finalize (loops, rtl_dump_file);\n+      loop_optimizer_finalize (loops, dump_file);\n     }\n \n   /* Finalize layout changes.  */\n@@ -3083,8 +3083,8 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   delete_trivially_dead_insns (insns, max_reg_num ());\n   reg_scan (insns, max_reg_num (), 0);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_LOOP);\n   ggc_collect ();\n@@ -3181,7 +3181,7 @@ rest_of_compilation (tree decl)\n   insns = get_insns ();\n   rebuild_jump_labels (insns);\n   find_exception_handler_labels ();\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n \n   delete_unreachable_blocks ();\n \n@@ -3263,18 +3263,18 @@ rest_of_compilation (tree decl)\n \n   reg_scan (insns, max_reg_num (), 0);\n   rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n   delete_trivially_dead_insns (insns, max_reg_num ());\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n   if (optimize)\n     {\n       free_bb_for_insn ();\n       copy_loop_headers (insns);\n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      find_basic_blocks (insns, max_reg_num (), dump_file);\n     }\n   purge_line_number_notes (insns);\n \n@@ -3298,7 +3298,7 @@ rest_of_compilation (tree decl)\n      future passes, allocate arrays whose dimensions involve the\n      maximum instruction UID, so if we can reduce the maximum UID\n      we'll save big on memory.  */\n-  renumber_insns (rtl_dump_file);\n+  renumber_insns (dump_file);\n   timevar_pop (TV_JUMP);\n \n   close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n@@ -3471,7 +3471,7 @@ rest_of_compilation (tree decl)\n \n   if (optimize)\n     {\n-      life_analysis (insns, rtl_dump_file, PROP_POSTRELOAD);\n+      life_analysis (insns, dump_file, PROP_POSTRELOAD);\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n \t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n \n@@ -3498,7 +3498,7 @@ rest_of_compilation (tree decl)\n       timevar_push (TV_PEEPHOLE2);\n       open_dump_file (DFI_peephole2, decl);\n \n-      peephole2_optimize (rtl_dump_file);\n+      peephole2_optimize (dump_file);\n \n       close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n       timevar_pop (TV_PEEPHOLE2);\n@@ -3767,7 +3767,7 @@ decode_d_option (const char *arg)\n       {\n       case 'a':\n \tfor (i = 0; i < (int) DFI_MAX; ++i)\n-\t  dump_file[i].enabled = 1;\n+\t  dump_file_tbl[i].enabled = 1;\n \tbreak;\n       case 'A':\n \tflag_debug_asm = 1;\n@@ -3798,9 +3798,9 @@ decode_d_option (const char *arg)\n       default:\n \tmatched = 0;\n \tfor (i = 0; i < (int) DFI_MAX; ++i)\n-\t  if (c == dump_file[i].debug_switch)\n+\t  if (c == dump_file_tbl[i].debug_switch)\n \t    {\n-\t      dump_file[i].enabled = 1;\n+\t      dump_file_tbl[i].enabled = 1;\n \t      matched = 1;\n \t    }\n \n@@ -4596,13 +4596,13 @@ finalize (void)\n       int i;\n \n       for (i = 0; i < (int) DFI_MAX; ++i)\n-\tif (dump_file[i].initialized && dump_file[i].graph_dump_p)\n+\tif (dump_file_tbl[i].initialized && dump_file_tbl[i].graph_dump_p)\n \t  {\n \t    char seq[16];\n \t    char *suffix;\n \n \t    sprintf (seq, DUMPFILE_FORMAT, i);\n-\t    suffix = concat (seq, dump_file[i].extension, NULL);\n+\t    suffix = concat (seq, dump_file_tbl[i].extension, NULL);\n \t    finish_graph_dump_file (dump_base_name, suffix);\n \t    free (suffix);\n \t  }\n@@ -4650,15 +4650,15 @@ do_compile (void)\n \t  if (flag_unit_at_a_time)\n \t    {\n \t      open_dump_file (DFI_cgraph, NULL);\n-\t      cgraph_dump_file = rtl_dump_file;\n-\t      rtl_dump_file = NULL;\n+\t      cgraph_dump_file = dump_file;\n+\t      dump_file = NULL;\n \t    }\n \n \t  compile_file ();\n \n \t  if (flag_unit_at_a_time)\n \t    {\n-\t      rtl_dump_file = cgraph_dump_file;\n+\t      dump_file = cgraph_dump_file;\n \t      cgraph_dump_file = NULL;\n               close_dump_file (DFI_cgraph, NULL, NULL_RTX);\n \t    }"}, {"sha": "b1d6768eeea53ac1f3bad60b583cb32580ebfbcb", "filename": "gcc/tracer.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -157,21 +157,21 @@ find_trace (basic_block bb, basic_block *trace)\n   int i = 0;\n   edge e;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Trace seed %i [%i]\", bb->index, bb->frequency);\n+  if (dump_file)\n+    fprintf (dump_file, \"Trace seed %i [%i]\", bb->index, bb->frequency);\n \n   while ((e = find_best_predecessor (bb)) != NULL)\n     {\n       basic_block bb2 = e->src;\n       if (seen (bb2) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t  || find_best_successor (bb2) != e)\n \tbreak;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+      if (dump_file)\n+\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->frequency);\n       bb = bb2;\n     }\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \" forward %i [%i]\", bb->index, bb->frequency);\n+  if (dump_file)\n+    fprintf (dump_file, \" forward %i [%i]\", bb->index, bb->frequency);\n   trace[i++] = bb;\n \n   /* Follow the trace in forward direction.  */\n@@ -181,12 +181,12 @@ find_trace (basic_block bb, basic_block *trace)\n       if (seen (bb) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t  || find_best_predecessor (bb) != e)\n \tbreak;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+      if (dump_file)\n+\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->frequency);\n       trace[i++] = bb;\n     }\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n   return i;\n }\n \n@@ -287,8 +287,8 @@ tail_duplicate (void)\n \t      blocks[old->index] =\n \t\tfibheap_insert (heap, -old->frequency, old);\n \n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Duplicated %i as %i [%i]\\n\",\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Duplicated %i as %i [%i]\\n\",\n \t\t\t old->index, bb2->index, bb2->frequency);\n \t    }\n \t  bb->rbi->next = bb2;\n@@ -298,12 +298,12 @@ tail_duplicate (void)\n \t  if (ignore_bb_p (bb))\n \t    break;\n \t}\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \" covered now %.1f\\n\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \" covered now %.1f\\n\\n\",\n \t\t traced_insns * 100.0 / weighted_insns);\n     }\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Duplicated %i insns (%i%%)\\n\", nduplicated,\n+  if (dump_file)\n+    fprintf (dump_file, \"Duplicated %i insns (%i%%)\\n\", nduplicated,\n \t     nduplicated * 100 / ninsns);\n \n   free (blocks);\n@@ -366,12 +366,12 @@ tracer (void)\n \n   cfg_layout_initialize ();\n   mark_dfs_back_edges ();\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   tail_duplicate ();\n   layout_superblocks ();\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n   cfg_layout_finalize ();\n \n   /* Merge basic blocks in duplicated traces.  */"}, {"sha": "9ee78d459eb12af9198f0b0e424eb8af8d99449d", "filename": "gcc/value-prof.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -190,8 +190,8 @@ find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n       switch ((*values)[i].type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Interval counter for insn %d, range %d -- %d.\\n\",\n \t\t     INSN_UID ((*values)[i].insn),\n \t\t     (*values)[i].hdata.intvl.int_start,\n@@ -203,25 +203,25 @@ find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Pow2 counter for insn %d.\\n\",\n \t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = GET_MODE_BITSIZE ((*values)[i].mode) +\n \t\t  ((*values)[i].hdata.pow2.may_be_other ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Single value counter for insn %d.\\n\",\n \t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = 3;\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Constant delta counter for insn %d.\\n\",\n \t\t     INSN_UID ((*values)[i].insn));\n \t  (*values)[i].n_counters = 4;\n@@ -334,11 +334,11 @@ value_profile_transformations (void)\n       if (!maybe_hot_bb_p (BLOCK_FOR_INSN (insn)))\n \tcontinue;\n \n-      if (rtl_dump_file)\n+      if (dump_file)\n \t{\n-\t  fprintf (rtl_dump_file, \"Trying transformations on insn %d\\n\",\n+\t  fprintf (dump_file, \"Trying transformations on insn %d\\n\",\n \t\t   INSN_UID (insn));\n-\t  print_rtl_single (rtl_dump_file, insn);\n+\t  print_rtl_single (dump_file, insn);\n \t}\n \n       /* Transformations:  */\n@@ -452,8 +452,8 @@ divmod_fixed_value_transform (rtx insn)\n   if (!rtx_equal_p (op2, value) || 2 * count < all)\n     return false;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Div/mod by constant transformation on insn %d\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Div/mod by constant transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n@@ -568,8 +568,8 @@ mod_pow2_value_transform (rtx insn)\n   if (count < wrong_values)\n     return false;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Mod power of 2 transformation on insn %d\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Mod power of 2 transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n@@ -694,8 +694,8 @@ mod_subtract_transform (rtx insn)\n   if (i == 2)\n     return false;\n \n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Mod subtract transformation on insn %d\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Mod subtract transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));"}, {"sha": "38983ec0524b69d817e8d3f185df32193fa94545", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -1689,11 +1689,11 @@ dump_attrs_list (attrs list)\n {\n   for (; list; list = list->next)\n     {\n-      print_mem_expr (rtl_dump_file, list->decl);\n-      fprintf (rtl_dump_file, \"+\");\n-      fprintf (rtl_dump_file, HOST_WIDE_INT_PRINT_DEC, list->offset);\n+      print_mem_expr (dump_file, list->decl);\n+      fprintf (dump_file, \"+\");\n+      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC, list->offset);\n     }\n-  fprintf (rtl_dump_file, \"\\n\");\n+  fprintf (dump_file, \"\\n\");\n }\n \n /* Print the information about variable *SLOT to dump file.  */\n@@ -1705,16 +1705,16 @@ dump_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n   int i;\n   location_chain node;\n \n-  fprintf (rtl_dump_file, \"  name: %s\\n\",\n+  fprintf (dump_file, \"  name: %s\\n\",\n \t   IDENTIFIER_POINTER (DECL_NAME (var->decl)));\n   for (i = 0; i < var->n_var_parts; i++)\n     {\n-      fprintf (rtl_dump_file, \"    offset %ld\\n\",\n+      fprintf (dump_file, \"    offset %ld\\n\",\n \t       (long) var->var_part[i].offset);\n       for (node = var->var_part[i].loc_chain; node; node = node->next)\n \t{\n-\t  fprintf (rtl_dump_file, \"      \");\n-\t  print_rtl_single (rtl_dump_file, node->loc);\n+\t  fprintf (dump_file, \"      \");\n+\t  print_rtl_single (dump_file, node->loc);\n \t}\n     }\n \n@@ -1729,7 +1729,7 @@ dump_vars (htab_t vars)\n {\n   if (htab_elements (vars) > 0)\n     {\n-      fprintf (rtl_dump_file, \"Variables:\\n\");\n+      fprintf (dump_file, \"Variables:\\n\");\n       htab_traverse (vars, dump_variable, NULL);\n     }\n }\n@@ -1741,19 +1741,19 @@ dump_dataflow_set (dataflow_set *set)\n {\n   int i;\n \n-  fprintf (rtl_dump_file, \"Stack adjustment: \");\n-  fprintf (rtl_dump_file, HOST_WIDE_INT_PRINT_DEC, set->stack_adjust);\n-  fprintf (rtl_dump_file, \"\\n\");\n+  fprintf (dump_file, \"Stack adjustment: \");\n+  fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC, set->stack_adjust);\n+  fprintf (dump_file, \"\\n\");\n   for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (set->regs[i])\n \t{\n-\t  fprintf (rtl_dump_file, \"Reg %d:\", i);\n+\t  fprintf (dump_file, \"Reg %d:\", i);\n \t  dump_attrs_list (set->regs[i]);\n \t}\n     }\n   dump_vars (set->vars);\n-  fprintf (rtl_dump_file, \"\\n\");\n+  fprintf (dump_file, \"\\n\");\n }\n \n /* Print the IN and OUT sets for each basic block to dump file.  */\n@@ -1765,10 +1765,10 @@ dump_dataflow_sets (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      fprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", bb->index);\n-      fprintf (rtl_dump_file, \"IN:\\n\");\n+      fprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n+      fprintf (dump_file, \"IN:\\n\");\n       dump_dataflow_set (&VTI (bb)->in);\n-      fprintf (rtl_dump_file, \"OUT:\\n\");\n+      fprintf (dump_file, \"OUT:\\n\");\n       dump_dataflow_set (&VTI (bb)->out);\n     }\n }\n@@ -2627,10 +2627,10 @@ variable_tracking_main (void)\n   vt_find_locations ();\n   vt_emit_notes ();\n \n-  if (rtl_dump_file)\n+  if (dump_file)\n     {\n       dump_dataflow_sets ();\n-      dump_flow_info (rtl_dump_file);\n+      dump_flow_info (dump_file);\n     }\n \n   vt_finalize ();"}, {"sha": "f27376b9b5d52e0c47a8d30b9a1e4cf671cc85aa", "filename": "gcc/web.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c263766cf3464e48e71481bf46ba6f5886d64433/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=c263766cf3464e48e71481bf46ba6f5886d64433", "patch": "@@ -191,16 +191,16 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used,\n   else if (REG_USERVAR_P (reg) && 0/*&& !flag_messy_debugging*/)\n     {\n       newreg = reg;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"New web forced to keep reg=%i (user variable)\\n\",\n \t\t REGNO (reg));\n     }\n   else if (use_addressof [REGNO (reg)])\n     {\n       newreg = reg;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"New web forced to keep reg=%i (address taken)\\n\",\n \t\t REGNO (reg));\n     }\n@@ -212,8 +212,8 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used,\n       REG_LOOP_TEST_P (newreg) = REG_LOOP_TEST_P (reg);\n       RTX_UNCHANGING_P (newreg) = RTX_UNCHANGING_P (reg);\n       REG_ATTRS (newreg) = REG_ATTRS (reg);\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Web oldreg=%i newreg=%i\\n\", REGNO (reg),\n+      if (dump_file)\n+\tfprintf (dump_file, \"Web oldreg=%i newreg=%i\\n\", REGNO (reg),\n \t\t REGNO (newreg));\n     }\n \n@@ -231,8 +231,8 @@ replace_ref (struct ref *ref, rtx reg)\n \n   if (oldreg == reg)\n     return;\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Updating insn %i (%i->%i)\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Updating insn %i (%i->%i)\\n\",\n \t     INSN_UID (DF_REF_INSN (ref)), REGNO (oldreg), REGNO (reg)); \n   *loc = reg;\n }\n@@ -274,8 +274,8 @@ web_main (void)\n   used = (char *) xcalloc (max, sizeof (char));\n   use_addressof = (char *) xcalloc (max, sizeof (char));\n \n-  if (rtl_dump_file)\n-    df_dump (df, DF_UD_CHAIN | DF_DU_CHAIN, rtl_dump_file);\n+  if (dump_file)\n+    df_dump (df, DF_UD_CHAIN | DF_DU_CHAIN, dump_file);\n \n   /* Produce the web.  */\n   for (i = 0; i < df->n_uses; i++)"}]}