{"sha": "323dd4255203479d8c456b85513db4f8e0041d04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzZGQ0MjU1MjAzNDc5ZDhjNDU2Yjg1NTEzZGI0ZjhlMDA0MWQwNA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-10-19T22:13:42Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-10-28T19:25:51Z"}, "message": "c++: Member template function lookup failure [PR94799]\n\nMy earlier patch for this PR, r11-86, broke pybind11.  That patch\nchanged cp_parser_class_name to also consider the object expression\nscope (parser->context->object_type) to fix parsing of\n\n  p->template A<T>::foo(); // consider p's scope too\n\nHere we reject\n\n  b.operator typename B<T>::type();\n\nbecause 'typename_p' in cp_parser_class_name uses 'scope', which means\nthat 'typename_p' will be true for the example above.  Then we create\na TYPENAME_TYPE via make_typename_type, which fails when tsubsting it;\nthe code basically created 'typename B::B' and then we complain that there\nis no member named 'B' in 'A<int>'.  So, when deciding if we should\ncreate a TYPENAME_TYPE, don't consider the object_type scope, like we\ndid pre-r11-86.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94799\n\t* parser.c (cp_parser_class_name): Use parser->scope when\n\tsetting typename_p.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94799\n\t* g++.dg/template/lookup16.C: New test.", "tree": {"sha": "97ae87500e1c9b433833060be3b20272e028ff4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97ae87500e1c9b433833060be3b20272e028ff4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/323dd4255203479d8c456b85513db4f8e0041d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323dd4255203479d8c456b85513db4f8e0041d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/323dd4255203479d8c456b85513db4f8e0041d04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323dd4255203479d8c456b85513db4f8e0041d04/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43cb72263fb3b7b97a74fb38d71364a1d5cf0448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43cb72263fb3b7b97a74fb38d71364a1d5cf0448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43cb72263fb3b7b97a74fb38d71364a1d5cf0448"}], "stats": {"total": 36, "additions": 29, "deletions": 7}, "files": [{"sha": "234079559b9b6854322c1394591c01e592ca601d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/323dd4255203479d8c456b85513db4f8e0041d04/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/323dd4255203479d8c456b85513db4f8e0041d04/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=323dd4255203479d8c456b85513db4f8e0041d04", "patch": "@@ -23794,13 +23794,10 @@ cp_parser_class_name (cp_parser *parser,\n \t\t      bool enum_ok)\n {\n   tree decl;\n-  tree scope;\n-  bool typename_p;\n-  cp_token *token;\n   tree identifier = NULL_TREE;\n \n   /* All class-names start with an identifier.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n   if (token->type != CPP_NAME && token->type != CPP_TEMPLATE_ID)\n     {\n       cp_parser_error (parser, \"expected class-name\");\n@@ -23816,14 +23813,16 @@ cp_parser_class_name (cp_parser *parser,\n \n       where we first want to look up A<T>::a in the class of the object\n       expression, as per [basic.lookup.classref].  */\n-  scope = parser->scope ? parser->scope : parser->context->object_type;\n+  tree scope = parser->scope ? parser->scope : parser->context->object_type;\n   if (scope == error_mark_node)\n     return error_mark_node;\n \n   /* Any name names a type if we're following the `typename' keyword\n      in a qualified name where the enclosing scope is type-dependent.  */\n-  typename_p = (typename_keyword_p && scope && TYPE_P (scope)\n-\t\t&& dependent_type_p (scope));\n+  const bool typename_p = (typename_keyword_p\n+\t\t\t   && parser->scope\n+\t\t\t   && TYPE_P (parser->scope)\n+\t\t\t   && dependent_type_p (parser->scope));\n   /* Handle the common case (an identifier, but not a template-id)\n      efficiently.  */\n   if (token->type == CPP_NAME"}, {"sha": "5b34c08282cbb2a76b6bd5919ad8de2cfdefefe5", "filename": "gcc/testsuite/g++.dg/template/lookup16.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/323dd4255203479d8c456b85513db4f8e0041d04/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/323dd4255203479d8c456b85513db4f8e0041d04/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup16.C?ref=323dd4255203479d8c456b85513db4f8e0041d04", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/94799\n+// { dg-do compile { target c++11 } }\n+\n+template <typename> struct A {\n+  typedef int type;\n+  operator int();\n+};\n+\n+template <typename T> using B = A<T>;\n+\n+template <typename T> typename B<T>::type foo(B<T> b)\n+{\n+  auto r1 = b.operator typename A<T>::type();\n+  auto r2 = b.operator typename A<T>::template A<T>::type();\n+  auto r3 = b.operator typename B<T>::type();\n+  auto r4 = b.operator typename B<T>::template A<T>::type();\n+  return r1 + r2 + r3 + r4;\n+}\n+\n+void bar()\n+{\n+  foo(A<int>());\n+}"}]}