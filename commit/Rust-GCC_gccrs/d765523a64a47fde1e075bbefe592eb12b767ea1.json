{"sha": "d765523a64a47fde1e075bbefe592eb12b767ea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2NTUyM2E2NGE0N2ZkZTFlMDc1YmJlZmU1OTJlYjEyYjc2N2VhMQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-04-01T07:11:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-01T07:11:35Z"}, "message": "dependency.c (gfc_dep_compare_expr): Strip parentheses and unary plus operators when comparing expressions.\n\n\n\t* dependency.c (gfc_dep_compare_expr): Strip parentheses and unary\n\tplus operators when comparing expressions.  Handle comparisons of\n\tthe form \"X+C vs. X\", \"X vs. X+C\", \"X-C vs. X\" and \"X vs. X-C\" where\n\tC is an integer constant.  Handle comparisons of the form \"P+Q vs.\n\tR+S\" and \"P-Q vs. R-S\".  Handle comparisons of integral extensions\n\tspecially (increasing functions) so extend(A) > extend(B), when A>B.\n\t(gfc_check_element_vs_element): Move test later, so that we ignore\n\tthe fact that \"A < B\" or \"A > B\" when A or B contains a forall index.\n\n\t* gfortran.dg/dependency_14.f90: New test case.\n\t* gfortran.dg/dependency_15.f90: Likewise.\n\t* gfortran.dg/dependency_16.f90: Likewise.\n\nFrom-SVN: r112605", "tree": {"sha": "819193295047cb2228169bf880780bbaf6997cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/819193295047cb2228169bf880780bbaf6997cd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d765523a64a47fde1e075bbefe592eb12b767ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d765523a64a47fde1e075bbefe592eb12b767ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d765523a64a47fde1e075bbefe592eb12b767ea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d765523a64a47fde1e075bbefe592eb12b767ea1/comments", "author": null, "committer": null, "parents": [{"sha": "b7974b3af53c0aab02b198c0b5320de93a9fc422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7974b3af53c0aab02b198c0b5320de93a9fc422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7974b3af53c0aab02b198c0b5320de93a9fc422"}], "stats": {"total": 198, "additions": 184, "deletions": 14}, "files": [{"sha": "c6bed7875ffa5546de11df53e0fdff7a2a4fe3fe", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -1,3 +1,14 @@\n+2006-04-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* dependency.c (gfc_dep_compare_expr): Strip parentheses and unary\n+\tplus operators when comparing expressions.  Handle comparisons of\n+\tthe form \"X+C vs. X\", \"X vs. X+C\", \"X-C vs. X\" and \"X vs. X-C\" where\n+\tC is an integer constant.  Handle comparisons of the form \"P+Q vs.\n+\tR+S\" and \"P-Q vs. R-S\".  Handle comparisons of integral extensions\n+\tspecially (increasing functions) so extend(A) > extend(B), when A>B.\n+\t(gfc_check_element_vs_element): Move test later, so that we ignore\n+\tthe fact that \"A < B\" or \"A > B\" when A or B contains a forall index.\n+\n 2006-03-31  Asher Langton  <langton2@llnl.gov>\n \n \tPR fortran/25358"}, {"sha": "c3762bdc4d8b8de0094d4f6a4b403fc82ec5fa3a", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 131, "deletions": 14, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -72,8 +72,112 @@ gfc_expr_is_one (gfc_expr * expr, int def)\n int\n gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n {\n+  gfc_actual_arglist *args1;\n+  gfc_actual_arglist *args2;\n   int i;\n \n+  if (e1->expr_type == EXPR_OP\n+      && (e1->value.op.operator == INTRINSIC_UPLUS\n+          || e1->value.op.operator == INTRINSIC_PARENTHESES))\n+    return gfc_dep_compare_expr (e1->value.op.op1, e2);\n+  if (e2->expr_type == EXPR_OP\n+      && (e2->value.op.operator == INTRINSIC_UPLUS\n+          || e2->value.op.operator == INTRINSIC_PARENTHESES))\n+    return gfc_dep_compare_expr (e1, e2->value.op.op1);\n+\n+  if (e1->expr_type == EXPR_OP\n+      && e1->value.op.operator == INTRINSIC_PLUS)\n+    {\n+      /* Compare X+C vs. X.  */\n+      if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n+\t  && e1->value.op.op2->ts.type == BT_INTEGER\n+\t  && gfc_dep_compare_expr (e1->value.op.op1, e2) == 0)\n+\treturn mpz_sgn (e1->value.op.op2->value.integer);\n+\n+      /* Compare P+Q vs. R+S.  */\n+      if (e2->expr_type == EXPR_OP\n+\t  && e2->value.op.operator == INTRINSIC_PLUS)\n+\t{\n+\t  int l, r;\n+\n+\t  l = gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op1);\n+\t  r = gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op2);\n+\t  if (l == 0 && r == 0)\n+\t    return 0;\n+\t  if (l == 0 && r != -2)\n+\t    return r;\n+\t  if (l != -2 && r == 0)\n+\t    return l;\n+\t  if (l == 1 && r == 1)\n+\t    return 1;\n+\t  if (l == -1 && r == -1)\n+\t    return -1;\n+\n+\t  l = gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op2);\n+\t  r = gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op1);\n+\t  if (l == 0 && r == 0)\n+\t    return 0;\n+\t  if (l == 0 && r != -2)\n+\t    return r;\n+\t  if (l != -2 && r == 0)\n+\t    return l;\n+\t  if (l == 1 && r == 1)\n+\t    return 1;\n+\t  if (l == -1 && r == -1)\n+\t    return -1;\n+\t}\n+    }\n+\n+  /* Compare X vs. X+C.  */\n+  if (e2->expr_type == EXPR_OP\n+      && e2->value.op.operator == INTRINSIC_PLUS)\n+    {\n+      if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n+\t  && e2->value.op.op2->ts.type == BT_INTEGER\n+\t  && gfc_dep_compare_expr (e1, e2->value.op.op1) == 0)\n+\treturn -mpz_sgn (e2->value.op.op2->value.integer);\n+    }\n+\n+  /* Compare X-C vs. X.  */\n+  if (e1->expr_type == EXPR_OP\n+      && e1->value.op.operator == INTRINSIC_MINUS)\n+    {\n+      if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n+\t  && e1->value.op.op2->ts.type == BT_INTEGER\n+\t  && gfc_dep_compare_expr (e1->value.op.op1, e2) == 0)\n+\treturn -mpz_sgn (e1->value.op.op2->value.integer);\n+\n+      /* Compare P-Q vs. R-S.  */\n+      if (e2->expr_type == EXPR_OP\n+\t  && e2->value.op.operator == INTRINSIC_MINUS)\n+\t{\n+\t  int l, r;\n+\n+\t  l = gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op1);\n+\t  r = gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op2);\n+\t  if (l == 0 && r == 0)\n+\t    return 0;\n+\t  if (l != -2 && r == 0)\n+\t    return l;\n+\t  if (l == 0 && r != -2)\n+\t    return -r;\n+\t  if (l == 1 && r == -1)\n+\t    return 1;\n+\t  if (l == -1 && r == 1)\n+\t    return -1;\n+\t}\n+    }\n+\n+  /* Compare X vs. X-C.  */\n+  if (e2->expr_type == EXPR_OP\n+      && e2->value.op.operator == INTRINSIC_MINUS)\n+    {\n+      if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n+\t  && e2->value.op.op2->ts.type == BT_INTEGER\n+\t  && gfc_dep_compare_expr (e1, e2->value.op.op1) == 0)\n+\treturn mpz_sgn (e2->value.op.op2->value.integer);\n+    }\n+\n   if (e1->expr_type != e2->expr_type)\n     return -2;\n \n@@ -119,12 +223,29 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n \t  || e1->value.function.isym != e2->value.function.isym)\n \treturn -2;\n \n+      args1 = e1->value.function.actual;\n+      args2 = e2->value.function.actual;\n+\n       /* We should list the \"constant\" intrinsic functions.  Those\n \t without side-effects that provide equal results given equal\n \t argument lists.  */\n       switch (e1->value.function.isym->generic_id)\n \t{\n \tcase GFC_ISYM_CONVERSION:\n+\t  /* Handle integer extensions specially, as __convert_i4_i8\n+\t     is not only \"constant\" but also \"unary\" and \"increasing\".  */\n+\t  if (args1 && !args1->next\n+\t      && args2 && !args2->next\n+\t      && e1->ts.type == BT_INTEGER\n+\t      && args1->expr->ts.type == BT_INTEGER\n+\t      && e1->ts.kind > args1->expr->ts.kind\n+\t      && e2->ts.type == e1->ts.type\n+\t      && e2->ts.kind == e1->ts.kind\n+\t      && args2->expr->ts.type == args1->expr->ts.type\n+\t      && args2->expr->ts.kind == args2->expr->ts.kind)\n+\t    return gfc_dep_compare_expr (args1->expr, args2->expr);\n+\t  break;\n+\n \tcase GFC_ISYM_REAL:\n \tcase GFC_ISYM_LOGICAL:\n \tcase GFC_ISYM_DBLE:\n@@ -135,18 +256,14 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n \t}\n \n       /* Compare the argument lists for equality.  */\n-      {\n-\tgfc_actual_arglist *args1 = e1->value.function.actual;\n-\tgfc_actual_arglist *args2 = e2->value.function.actual;\n-\twhile (args1 && args2)\n-\t  {\n-\t    if (gfc_dep_compare_expr (args1->expr, args2->expr) != 0)\n-\t      return -2;\n-\t    args1 = args1->next;\n-\t    args2 = args2->next;\n-\t  }\n-\treturn (args1 || args2) ? -2 : 0;\n-      }\n+      while (args1 && args2)\n+\t{\n+\t  if (gfc_dep_compare_expr (args1->expr, args2->expr) != 0)\n+\t    return -2;\n+\t  args1 = args1->next;\n+\t  args2 = args2->next;\n+\t}\n+      return (args1 || args2) ? -2 : 0;\n       \n     default:\n       return -2;\n@@ -904,8 +1021,6 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n   i = gfc_dep_compare_expr (r_start, l_start);\n   if (i == 0)\n     return GFC_DEP_EQUAL;\n-  if (i != -2)\n-    return GFC_DEP_NODEP;\n \n   /* Treat two scalar variables as potentially equal.  This allows\n      us to prove that a(i,:) and a(j,:) have no dependency.  See\n@@ -920,6 +1035,8 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n       || contains_forall_index_p (l_start))\n     return GFC_DEP_OVERLAP;\n \n+  if (i != -2)\n+    return GFC_DEP_NODEP;\n   return GFC_DEP_EQUAL;\n }\n "}, {"sha": "6901373486866b79331675df2edcf3f1fe040df6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -1,3 +1,9 @@\n+2006-04-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/dependency_14.f90: New test case.\n+\t* gfortran.dg/dependency_15.f90: Likewise.\n+\t* gfortran.dg/dependency_16.f90: Likewise.\n+\n 2006-03-31  Asher Langton  <langton2@llnl.gov>\n \n \tPR fortran/25358"}, {"sha": "71e962c15dc880ceebc1cd17daf2a0480dba7a8e", "filename": "gcc/testsuite/gfortran.dg/dependency_14.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_14.f90?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine foo(a,i)\n+  integer, dimension (4,4) :: a\n+  integer :: i\n+\n+  where (a(i,1:3) .ne. 0)\n+    a(i+1,2:4) = 1\n+  endwhere\n+end subroutine\n+! { dg-final { scan-tree-dump-times \"malloc\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "36eb3a4642309ca8fb0200a91e79f3d45bcd5461", "filename": "gcc/testsuite/gfortran.dg/dependency_15.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_15.f90?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine foo(a,i)\n+  integer, dimension (4,4) :: a\n+  integer :: i\n+\n+  where (a(i,1:3) .ne. 0)\n+    a(i-1,2:4) = 1\n+  endwhere\n+end subroutine\n+! { dg-final { scan-tree-dump-times \"malloc\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "b669771b898b1c52efa8411444b73b2c4167a0d3", "filename": "gcc/testsuite/gfortran.dg/dependency_16.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d765523a64a47fde1e075bbefe592eb12b767ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_16.f90?ref=d765523a64a47fde1e075bbefe592eb12b767ea1", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine foo(a,i)\n+  integer, dimension (4,4) :: a\n+  integer :: i\n+\n+  where (a(i+1,1:3) .ne. 0)\n+    a(i+2,2:4) = 1\n+  endwhere\n+end subroutine\n+! { dg-final { scan-tree-dump-times \"malloc\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}