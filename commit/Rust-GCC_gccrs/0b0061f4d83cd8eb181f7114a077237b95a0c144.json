{"sha": "0b0061f4d83cd8eb181f7114a077237b95a0c144", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIwMDYxZjRkODNjZDhlYjE4MWY3MTE0YTA3NzIzN2I5NWEwYzE0NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-11-19T16:49:37Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-11-19T16:49:37Z"}, "message": "vect: Add a \u201cvery cheap\u201d cost model\n\nCurrently we have three vector cost models: cheap, dynamic and\nunlimited.  -O2 -ftree-vectorize uses \u201ccheap\u201d by default, but that's\nstill relatively aggressive about peeling and aliasing checks,\nand can lead to significant code size growth.\n\nThis patch adds an even more conservative choice, which for lack of\nimagination I've called \u201cvery cheap\u201d.  It only allows vectorisation\nif the vector code entirely replaces the scalar code.  It also\nrequires one iteration of the vector loop to pay for itself,\nregardless of how often the loop iterates.  (If the vector loop\nneeds multiple iterations to be beneficial then things are\nprobably too close to call, and the conservative thing would\nbe to stick with the scalar code.)\n\nThe idea is that this should be suitable for -O2, although the patch\ndoesn't change any defaults itself.\n\nI tested this by building and running a bunch of workloads for SVE,\nwith three options:\n\n  (1) -O2\n  (2) -O2 -ftree-vectorize -fvect-cost-model=very-cheap\n  (3) -O2 -ftree-vectorize [-fvect-cost-model=cheap]\n\nAll three builds used the default -msve-vector-bits=scalable and\nran with the minimum vector length of 128 bits, which should give\na worst-case bound for the performance impact.\n\nThe workloads included a mixture of microbenchmarks and full\napplications.  Because it's quite an eclectic mix, there's not\nmuch point giving exact figures.  The aim was more to get a general\nimpression.\n\nCode size growth with (2) was much lower than with (3).  Only a\nhandful of tests increased by more than 5%, and all of them were\nmicrobenchmarks.\n\nIn terms of performance, (2) was significantly faster than (1)\non microbenchmarks (as expected) but also on some full apps.\nAgain, performance only regressed on a handful of tests.\n\nAs expected, the performance of (3) vs. (1) and (3) vs. (2) is more\nof a mixed bag.  There are several significant improvements with (3)\nover (2), but also some (smaller) regressions.  That seems to be in\nline with -O2 -ftree-vectorize being a kind of -O2.5.\n\nThe patch reorders vect_cost_model so that values are in order\nof increasing aggressiveness, which makes it possible to use\nrange checks.  The value 0 still represents \u201cunlimited\u201d,\nso \u201cif (flag_vect_cost_model)\u201d is still a meaningful check.\n\ngcc/\n\t* doc/invoke.texi (-fvect-cost-model): Add a very-cheap model.\n\t* common.opt (fvect-cost-model=): Add very-cheap as a possible option.\n\t(fsimd-cost-model=): Likewise.\n\t(vect_cost_model): Add very-cheap.\n\t* flag-types.h (vect_cost_model): Add VECT_COST_MODEL_VERY_CHEAP.\n\tPut the values in order of increasing aggressiveness.\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Use\n\trange checks when comparing against VECT_COST_MODEL_CHEAP.\n\t(vect_prune_runtime_alias_test_list): Do not allow any alias\n\tchecks for the very-cheap cost model.\n\t* tree-vect-loop.c (vect_analyze_loop_costing): Do not allow\n\tany peeling for the very-cheap cost model.  Also require one\n\titeration of the vector loop to pay for itself.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-cost-model-1.c: New test.\n\t* gcc.dg/vect/vect-cost-model-2.c: Likewise.\n\t* gcc.dg/vect/vect-cost-model-3.c: Likewise.\n\t* gcc.dg/vect/vect-cost-model-4.c: Likewise.\n\t* gcc.dg/vect/vect-cost-model-5.c: Likewise.\n\t* gcc.dg/vect/vect-cost-model-6.c: Likewise.", "tree": {"sha": "d1811c99a79cc35549621ad8542c892ed87ec107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1811c99a79cc35549621ad8542c892ed87ec107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b0061f4d83cd8eb181f7114a077237b95a0c144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b0061f4d83cd8eb181f7114a077237b95a0c144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b0061f4d83cd8eb181f7114a077237b95a0c144", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b0061f4d83cd8eb181f7114a077237b95a0c144/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6a43158d2e5b26616716c50badedd3400c6bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6a43158d2e5b26616716c50badedd3400c6bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6a43158d2e5b26616716c50badedd3400c6bea"}], "stats": {"total": 133, "additions": 123, "deletions": 10}, "files": [{"sha": "ca8a26907997f1c27dfbf2795e19a486dd1c8c75", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -3020,11 +3020,11 @@ Enable basic block vectorization (SLP) on trees.\n \n fvect-cost-model=\n Common Joined RejectNegative Enum(vect_cost_model) Var(flag_vect_cost_model) Init(VECT_COST_MODEL_DEFAULT) Optimization\n--fvect-cost-model=[unlimited|dynamic|cheap]\tSpecifies the cost model for vectorization.\n+-fvect-cost-model=[unlimited|dynamic|cheap|very-cheap]\tSpecifies the cost model for vectorization.\n \n fsimd-cost-model=\n Common Joined RejectNegative Enum(vect_cost_model) Var(flag_simd_cost_model) Init(VECT_COST_MODEL_UNLIMITED) Optimization\n--fsimd-cost-model=[unlimited|dynamic|cheap]\tSpecifies the vectorization cost model for code marked with a simd directive.\n+-fsimd-cost-model=[unlimited|dynamic|cheap|very-cheap]\tSpecifies the vectorization cost model for code marked with a simd directive.\n \n Enum\n Name(vect_cost_model) Type(enum vect_cost_model) UnknownError(unknown vectorizer cost model %qs)\n@@ -3038,6 +3038,9 @@ Enum(vect_cost_model) String(dynamic) Value(VECT_COST_MODEL_DYNAMIC)\n EnumValue\n Enum(vect_cost_model) String(cheap) Value(VECT_COST_MODEL_CHEAP)\n \n+EnumValue\n+Enum(vect_cost_model) String(very-cheap) Value(VECT_COST_MODEL_VERY_CHEAP)\n+\n fvect-cost-model\n Common Alias(fvect-cost-model=,dynamic,unlimited)\n Enables the dynamic vectorizer cost model.  Preserved for backward compatibility."}, {"sha": "07232c6b33dcbbbfb953098bcce1d2cfc8a984a6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -11440,15 +11440,23 @@ and @option{-fauto-profile}.\n @item -fvect-cost-model=@var{model}\n @opindex fvect-cost-model\n Alter the cost model used for vectorization.  The @var{model} argument\n-should be one of @samp{unlimited}, @samp{dynamic} or @samp{cheap}.\n+should be one of @samp{unlimited}, @samp{dynamic}, @samp{cheap} or\n+@samp{very-cheap}.\n With the @samp{unlimited} model the vectorized code-path is assumed\n to be profitable while with the @samp{dynamic} model a runtime check\n guards the vectorized code-path to enable it only for iteration\n counts that will likely execute faster than when executing the original\n scalar loop.  The @samp{cheap} model disables vectorization of\n loops where doing so would be cost prohibitive for example due to\n required runtime checks for data dependence or alignment but otherwise\n-is equal to the @samp{dynamic} model.\n+is equal to the @samp{dynamic} model.  The @samp{very-cheap} model only\n+allows vectorization if the vector code would entirely replace the\n+scalar code that is being vectorized.  For example, if each iteration\n+of a vectorized loop would only be able to handle exactly four iterations\n+of the scalar loop, the @samp{very-cheap} model would only allow\n+vectorization if the scalar iteration count is known to be a multiple\n+of four.\n+\n The default cost model depends on other optimization flags and is\n either @samp{dynamic} or @samp{cheap}.\n "}, {"sha": "0dbab19943c66cdaa9192793586472f9ae378acc", "filename": "gcc/flag-types.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -232,12 +232,14 @@ enum scalar_storage_order_kind {\n   SSO_LITTLE_ENDIAN\n };\n \n-/* Vectorizer cost-model.  */\n+/* Vectorizer cost-model.  Except for DEFAULT, the values are ordered from\n+   the most conservative to the least conservative.  */\n enum vect_cost_model {\n+  VECT_COST_MODEL_VERY_CHEAP = -3,\n+  VECT_COST_MODEL_CHEAP = -2,\n+  VECT_COST_MODEL_DYNAMIC = -1,\n   VECT_COST_MODEL_UNLIMITED = 0,\n-  VECT_COST_MODEL_CHEAP = 1,\n-  VECT_COST_MODEL_DYNAMIC = 2,\n-  VECT_COST_MODEL_DEFAULT = 3\n+  VECT_COST_MODEL_DEFAULT = 1\n };\n \n /* Different instrumentation modes.  */"}, {"sha": "0737da5d67189460f8cf44c20b9cb46819dd0f27", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-1.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=cheap\" } */\n+\n+void\n+f (int *x, int *y)\n+{\n+  for (unsigned int i = 0; i < 1024; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} vect { target vect_int } } } */"}, {"sha": "fa9bdb607b2b193928a29e1e692f554f0fe7bcfb", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-2.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=very-cheap\" } */\n+\n+void\n+f (int *x, int *y)\n+{\n+  for (unsigned int i = 0; i < 1024; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-not {LOOP VECTORIZED} vect { target vect_int } } } */"}, {"sha": "d7c6cfd204909e3ce5f7010edd10ee0f8997ffe9", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-3.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=cheap\" } */\n+\n+void\n+f (int *restrict x, int *restrict y)\n+{\n+  for (unsigned int i = 0; i < 1024; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} vect { target vect_int } } } */"}, {"sha": "bb018ad99fe38387c4b1bfdef069057505ea969d", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-4.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=very-cheap\" } */\n+\n+int x[1024], y[1024];\n+\n+void\n+f (void)\n+{\n+  for (unsigned int i = 0; i < 1024; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} vect { target vect_int } } } */"}, {"sha": "536ec0a3cdaa7cf1ef868b1d4b69d026afd3d902", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-5.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=cheap\" } */\n+\n+void\n+f (int *restrict x, int *restrict y)\n+{\n+  for (unsigned int i = 0; i < 1023; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} vect { target vect_int } } } */"}, {"sha": "552febb5feebdfc4432de7871e0e2bd43fae4704", "filename": "gcc/testsuite/gcc.dg/vect/vect-cost-model-6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cost-model-6.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -ftree-vectorize -fvect-cost-model=very-cheap\" } */\n+\n+void\n+f (int *restrict x, int *restrict y)\n+{\n+  for (unsigned int i = 0; i < 1023; ++i)\n+    x[i] += y[i];\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} vect { target { vect_int && vect_partial_vectors_usage_2 } } } } */\n+/* { dg-final { scan-tree-dump-not {LOOP VECTORIZED} vect { target { vect_int && { ! vect_partial_vectors_usage_2 } } } } } */"}, {"sha": "18e36c89d1475dbe1fe92ff757f21839e5db9d59", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -2161,7 +2161,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         {\n           unsigned max_allowed_peel\n \t    = param_vect_max_peeling_for_alignment;\n-\t  if (flag_vect_cost_model == VECT_COST_MODEL_CHEAP)\n+\t  if (flag_vect_cost_model <= VECT_COST_MODEL_CHEAP)\n \t    max_allowed_peel = 0;\n           if (max_allowed_peel != (unsigned)-1)\n             {\n@@ -2259,7 +2259,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   do_versioning\n     = (optimize_loop_nest_for_speed_p (loop)\n        && !loop->inner /* FORNOW */\n-       && flag_vect_cost_model != VECT_COST_MODEL_CHEAP);\n+       && flag_vect_cost_model > VECT_COST_MODEL_CHEAP);\n \n   if (do_versioning)\n     {\n@@ -3682,6 +3682,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   unsigned int count = (comp_alias_ddrs.length ()\n \t\t\t+ check_unequal_addrs.length ());\n \n+  if (count && flag_vect_cost_model == VECT_COST_MODEL_VERY_CHEAP)\n+    return opt_result::failure_at\n+      (vect_location, \"would need a runtime alias check\\n\");\n+\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"improved number of alias checks from %d to %d\\n\","}, {"sha": "48dfb4df00e338c036c4f440658c5be9638566f6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b0061f4d83cd8eb181f7114a077237b95a0c144/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0b0061f4d83cd8eb181f7114a077237b95a0c144", "patch": "@@ -1827,6 +1827,19 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n \t}\n     }\n \n+  /* If using the \"very cheap\" model. reject cases in which we'd keep\n+     a copy of the scalar code (even if we might be able to vectorize it).  */\n+  if (flag_vect_cost_model == VECT_COST_MODEL_VERY_CHEAP\n+      && (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+\t  || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n+\t  || LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"some scalar iterations would need to be peeled\\n\");\n+      return 0;\n+    }\n+\n   int min_profitable_iters, min_profitable_estimate;\n   vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n \t\t\t\t      &min_profitable_estimate);\n@@ -1885,6 +1898,20 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n       min_profitable_estimate = min_profitable_iters;\n     }\n \n+  /* If the vector loop needs multiple iterations to be beneficial then\n+     things are probably too close to call, and the conservative thing\n+     would be to stick with the scalar code.  */\n+  if (flag_vect_cost_model == VECT_COST_MODEL_VERY_CHEAP\n+      && min_profitable_estimate > (int) vect_vf_for_cost (loop_vinfo))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"one iteration of the vector loop would be\"\n+\t\t\t \" more expensive than the equivalent number of\"\n+\t\t\t \" iterations of the scalar loop\\n\");\n+      return 0;\n+    }\n+\n   HOST_WIDE_INT estimated_niter;\n \n   /* If we are vectorizing an epilogue then we know the maximum number of"}]}