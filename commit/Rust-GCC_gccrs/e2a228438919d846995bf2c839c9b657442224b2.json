{"sha": "e2a228438919d846995bf2c839c9b657442224b2", "node_id": "C_kwDOANBUbNoAKGUyYTIyODQzODkxOWQ4NDY5OTViZjJjODM5YzliNjU3NDQyMjI0YjI", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-10-05T17:25:27Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-10-05T17:25:27Z"}, "message": "Fortran: Add OpenMP's assume(s) directives\n\nlibgomp/ChangeLog:\n\n\t* libgomp.texi (OpenMP 5.1 Impl. Status): Mark 'assume' as 'Y'.\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.cc (show_omp_assumes): New.\n\t(show_omp_clauses, show_namespace): Call it.\n\t(show_omp_node, show_code_node): Handle OpenMP ASSUME.\n\t* gfortran.h (enum gfc_statement): Add ST_OMP_ASSUME,\n\tST_OMP_END_ASSUME, ST_OMP_ASSUMES and ST_NOTHING.\n\t(gfc_exec_op): Add EXEC_OMP_ASSUME.\n\t(gfc_omp_assumptions): New struct.\n\t(gfc_get_omp_assumptions): New XCNEW #define.\n\t(gfc_omp_clauses, gfc_namespace): Add assume member.\n\t(gfc_resolve_omp_assumptions): New prototype.\n\t* match.h (gfc_match_omp_assume, gfc_match_omp_assumes): New.\n\t* openmp.cc (omp_code_to_statement): Forward declare.\n\t(enum gfc_omp_directive_kind, struct gfc_omp_directive): New.\n\t(gfc_free_omp_clauses): Free assume member and its struct data.\n\t(enum omp_mask2): Add OMP_CLAUSE_ASSUMPTIONS.\n\t(gfc_omp_absent_contains_clause): New.\n\t(gfc_match_omp_clauses): Call it; optionally use passed\n\tomp_clauses argument.\n\t(omp_verify_merge_absent_contains, gfc_match_omp_assume,\n\t gfc_match_omp_assumes, gfc_resolve_omp_assumptions): New.\n\t(resolve_omp_clauses): Call the latter.\n\t(gfc_resolve_omp_directive, omp_code_to_statement): Handle\n\tEXEC_OMP_ASSUME.\n\t* parse.cc (decode_omp_directive): Parse OpenMP ASSUME(S).\n\t(next_statement, parse_executable, parse_omp_structured_block):\n\tHandle ST_OMP_ASSUME.\n\t(case_omp_decl): Add ST_OMP_ASSUMES.\n\t(gfc_ascii_statement): Handle Assumes, optional return\n\tstring without '!$OMP '/'!$ACC ' prefix.\n\t* parse.h (gfc_ascii_statement): Add optional bool arg to prototype.\n\t* resolve.cc (gfc_resolve_blocks, gfc_resolve_code): Add\n\tEXEC_OMP_ASSUME.\n\t(gfc_resolve): Resolve ASSUMES directive.\n\t* symbol.cc (gfc_free_namespace): Free omp_assumes member.\n\t* st.cc (gfc_free_statement): Handle EXEC_OMP_ASSUME.\n\t* trans-openmp.cc (gfc_trans_omp_directive): Likewise.\n\t* trans.cc (trans_code): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/assume-1.f90: New test.\n\t* gfortran.dg/gomp/assume-2.f90: New test.\n\t* gfortran.dg/gomp/assumes-1.f90: New test.\n\t* gfortran.dg/gomp/assumes-2.f90: New test.", "tree": {"sha": "d59e3bbd9deac97e29608c043b6ebed9f0b1ba81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d59e3bbd9deac97e29608c043b6ebed9f0b1ba81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2a228438919d846995bf2c839c9b657442224b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a228438919d846995bf2c839c9b657442224b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a228438919d846995bf2c839c9b657442224b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a228438919d846995bf2c839c9b657442224b2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49192c41de94b2746cd33366134b6aeaefa6ca2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49192c41de94b2746cd33366134b6aeaefa6ca2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49192c41de94b2746cd33366134b6aeaefa6ca2a"}], "stats": {"total": 673, "additions": 665, "deletions": 8}, "files": [{"sha": "2f042ab5142233bfe3720c147a75ae2b61151fdb", "filename": "gcc/fortran/dump-parse-tree.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fdump-parse-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fdump-parse-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"constructor.h\"\n #include \"version.h\"\n+#include \"parse.h\"  /* For gfc_ascii_statement.  */\n \n /* Keep track of indentation for symbol tree dumps.  */\n static int show_level = 0;\n@@ -1458,6 +1459,34 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n   gfc_current_ns = ns_curr;\n }\n \n+static void\n+show_omp_assumes (gfc_omp_assumptions *assume)\n+{\n+  for (int i = 0; i < assume->n_absent; i++)\n+    {\n+      fputs (\" ABSENT (\", dumpfile);\n+      fputs (gfc_ascii_statement (assume->absent[i], true), dumpfile);\n+      fputc (')', dumpfile);\n+    }\n+  for (int i = 0; i < assume->n_contains; i++)\n+    {\n+      fputs (\" CONTAINS (\", dumpfile);\n+      fputs (gfc_ascii_statement (assume->contains[i], true), dumpfile);\n+      fputc (')', dumpfile);\n+    }\n+  for (gfc_expr_list *el = assume->holds; el; el = el->next)\n+    {\n+      fputs (\" HOLDS (\", dumpfile);\n+      show_expr (el->expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (assume->no_openmp)\n+    fputs (\" NO_OPENMP\", dumpfile);\n+  if (assume->no_openmp_routines)\n+    fputs (\" NO_OPENMP_ROUTINES\", dumpfile);\n+  if (assume->no_parallelism)\n+    fputs (\" NO_PARALLELISM\", dumpfile);\n+}\n \n /* Show OpenMP or OpenACC clauses.  */\n \n@@ -1998,6 +2027,8 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       show_expr (omp_clauses->message);\n       fputc (')', dumpfile);\n     }\n+  if (omp_clauses->assume)\n+    show_omp_assumes (omp_clauses->assume);\n }\n \n /* Show a single OpenMP or OpenACC directive node and everything underneath it\n@@ -2027,6 +2058,7 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OACC_CACHE: name = \"CACHE\"; is_oacc = true; break;\n     case EXEC_OACC_ENTER_DATA: name = \"ENTER DATA\"; is_oacc = true; break;\n     case EXEC_OACC_EXIT_DATA: name = \"EXIT DATA\"; is_oacc = true; break;\n+    case EXEC_OMP_ASSUME: name = \"ASSUME\"; break;\n     case EXEC_OMP_ATOMIC: name = \"ATOMIC\"; break;\n     case EXEC_OMP_BARRIER: name = \"BARRIER\"; break;\n     case EXEC_OMP_CANCEL: name = \"CANCEL\"; break;\n@@ -2128,6 +2160,7 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OACC_CACHE:\n     case EXEC_OACC_ENTER_DATA:\n     case EXEC_OACC_EXIT_DATA:\n+    case EXEC_OMP_ASSUME:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_DISTRIBUTE:\n@@ -3353,6 +3386,7 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OACC_CACHE:\n     case EXEC_OACC_ENTER_DATA:\n     case EXEC_OACC_EXIT_DATA:\n+    case EXEC_OMP_ASSUME:\n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n@@ -3531,6 +3565,13 @@ show_namespace (gfc_namespace *ns)\n \t}\n     }\n \n+  if (ns->omp_assumes)\n+    {\n+      show_indent ();\n+      fprintf (dumpfile, \"!$OMP ASSUMES\");\n+      show_omp_assumes (ns->omp_assumes);\n+    }\n+\n   fputc ('\\n', dumpfile);\n   show_indent ();\n   fputs (\"code:\", dumpfile);"}, {"sha": "608dda4bf550828e28598cb573d964c75349f441", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -316,7 +316,9 @@ enum gfc_statement\n   ST_OMP_END_PARALLEL_MASKED_TASKLOOP_SIMD, ST_OMP_MASKED_TASKLOOP,\n   ST_OMP_END_MASKED_TASKLOOP, ST_OMP_MASKED_TASKLOOP_SIMD,\n   ST_OMP_END_MASKED_TASKLOOP_SIMD, ST_OMP_SCOPE, ST_OMP_END_SCOPE,\n-  ST_OMP_ERROR, ST_NONE\n+  ST_OMP_ERROR, ST_OMP_ASSUME, ST_OMP_END_ASSUME, ST_OMP_ASSUMES,\n+  /* Note: gfc_match_omp_nothing returns ST_NONE. */\n+  ST_OMP_NOTHING, ST_NONE\n };\n \n /* Types of interfaces that we can have.  Assignment interfaces are\n@@ -1506,6 +1508,18 @@ enum gfc_omp_bind_type\n   OMP_BIND_THREAD\n };\n \n+typedef struct gfc_omp_assumptions\n+{\n+  int n_absent, n_contains;\n+  enum gfc_statement *absent, *contains;\n+  gfc_expr_list *holds;\n+  bool no_openmp:1, no_openmp_routines:1, no_parallelism:1;\n+}\n+gfc_omp_assumptions;\n+\n+#define gfc_get_omp_assumptions() XCNEW (gfc_omp_assumptions)\n+\n+\n typedef struct gfc_omp_clauses\n {\n   gfc_omp_namelist *lists[OMP_LIST_NUM];\n@@ -1529,6 +1543,7 @@ typedef struct gfc_omp_clauses\n   struct gfc_expr *if_exprs[OMP_IF_LAST];\n   struct gfc_expr *dist_chunk_size;\n   struct gfc_expr *message;\n+  struct gfc_omp_assumptions *assume;\n   const char *critical_name;\n   enum gfc_omp_default_sharing default_sharing;\n   enum gfc_omp_atomic_op atomic_op;\n@@ -2145,6 +2160,9 @@ typedef struct gfc_namespace\n   /* Linked list of !$omp declare variant constructs.  */\n   struct gfc_omp_declare_variant *omp_declare_variant;\n \n+  /* OpenMP assumptions.  */\n+  struct gfc_omp_assumptions *omp_assumes;\n+\n   /* A hash set for the gfc expressions that have already\n      been finalized in this namespace.  */\n \n@@ -2913,7 +2931,7 @@ enum gfc_exec_op\n   EXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n-  EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n+  EXEC_OMP_ASSUME, EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n   EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,\n   EXEC_OMP_TASKYIELD, EXEC_OMP_CANCEL, EXEC_OMP_CANCELLATION_POINT,\n   EXEC_OMP_TASKGROUP, EXEC_OMP_SIMD, EXEC_OMP_DO_SIMD,\n@@ -3576,6 +3594,7 @@ void gfc_free_omp_declare_simd (gfc_omp_declare_simd *);\n void gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *);\n void gfc_free_omp_udr (gfc_omp_udr *);\n gfc_omp_udr *gfc_omp_udr_find (gfc_symtree *, gfc_typespec *);\n+void gfc_resolve_omp_assumptions (gfc_omp_assumptions *);\n void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);\n void gfc_resolve_do_iterator (gfc_code *, gfc_symbol *, bool);\n void gfc_resolve_omp_local_vars (gfc_namespace *);"}, {"sha": "2a805815d9caffaa35a3c6fafb0dcf58da9b6018", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -149,6 +149,8 @@ match gfc_match_oacc_routine (void);\n \n /* OpenMP directive matchers.  */\n match gfc_match_omp_eos_error (void);\n+match gfc_match_omp_assume (void);\n+match gfc_match_omp_assumes (void);\n match gfc_match_omp_atomic (void);\n match gfc_match_omp_barrier (void);\n match gfc_match_omp_cancel (void);"}, {"sha": "653c43f79ffb1aeac0c0f1f2f7263c200096746d", "filename": "gcc/fortran/openmp.cc", "status": "modified", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fopenmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fopenmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -29,6 +29,86 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"gomp-constants.h\"\n #include \"target-memory.h\"  /* For gfc_encode_character.  */\n+#include \"bitmap.h\"\n+\n+\n+static gfc_statement omp_code_to_statement (gfc_code *);\n+\n+enum gfc_omp_directive_kind {\n+  GFC_OMP_DIR_DECLARATIVE,\n+  GFC_OMP_DIR_EXECUTABLE,\n+  GFC_OMP_DIR_INFORMATIONAL,\n+  GFC_OMP_DIR_META,\n+  GFC_OMP_DIR_SUBSIDIARY,\n+  GFC_OMP_DIR_UTILITY\n+};\n+\n+struct gfc_omp_directive {\n+  const char *name;\n+  enum gfc_omp_directive_kind kind;\n+  gfc_statement st;\n+};\n+\n+/* Alphabetically sorted OpenMP clauses, except that longer strings are before\n+   substrings; excludes combined/composite directives. See note for \"ordered\"\n+   and \"nothing\".  */\n+\n+static const struct gfc_omp_directive gfc_omp_directives[] = {\n+  /* {\"allocate\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_ALLOCATE}, */\n+  /* {\"allocators\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_ALLOCATORS}, */\n+  {\"assumes\", GFC_OMP_DIR_INFORMATIONAL, ST_OMP_ASSUMES},\n+  {\"assume\", GFC_OMP_DIR_INFORMATIONAL, ST_OMP_ASSUME},\n+  {\"atomic\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_ATOMIC},\n+  {\"barrier\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_BARRIER},\n+  {\"cancellation point\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_CANCELLATION_POINT},\n+  {\"cancel\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_CANCEL},\n+  {\"critical\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_CRITICAL},\n+  /* {\"declare mapper\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_DECLARE_MAPPER}, */\n+  {\"declare reduction\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_DECLARE_REDUCTION},\n+  {\"declare simd\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_DECLARE_SIMD},\n+  {\"declare target\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_DECLARE_TARGET},\n+  {\"declare variant\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_DECLARE_VARIANT},\n+  {\"depobj\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_DEPOBJ},\n+  /* {\"dispatch\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_DISPATCH}, */\n+  {\"distribute\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_DISTRIBUTE},\n+  {\"do\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_DO},\n+  /* \"error\" becomes GFC_OMP_DIR_EXECUTABLE with at(execution) */\n+  {\"error\", GFC_OMP_DIR_UTILITY, ST_OMP_ERROR},\n+  {\"flush\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_FLUSH},\n+  /* {\"interop\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_INTEROP}, */\n+  {\"loop\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_LOOP},\n+  {\"masked\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_MASKED},\n+  /* {\"metadirective\", GFC_OMP_DIR_META, ST_OMP_METADIRECTIVE}, */\n+  /* Note: gfc_match_omp_nothing returns ST_NONE.  */\n+  {\"nothing\", GFC_OMP_DIR_UTILITY, ST_OMP_NOTHING},\n+  /* Special case; for now map to the first one.\n+     ordered-blockassoc = ST_OMP_ORDERED\n+     ordered-standalone = ST_OMP_ORDERED_DEPEND + depend/doacross.  */\n+  {\"ordered\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_ORDERED},\n+  {\"parallel\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_PARALLEL},\n+  {\"requires\", GFC_OMP_DIR_INFORMATIONAL, ST_OMP_REQUIRES},\n+  {\"scan\", GFC_OMP_DIR_SUBSIDIARY, ST_OMP_SCAN},\n+  {\"scope\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_SCOPE},\n+  {\"sections\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_SECTIONS},\n+  {\"section\", GFC_OMP_DIR_SUBSIDIARY, ST_OMP_SECTION},\n+  {\"simd\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_SIMD},\n+  {\"single\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_SINGLE},\n+  {\"target data\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TARGET_DATA},\n+  {\"target enter data\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TARGET_ENTER_DATA},\n+  {\"target exit data\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TARGET_EXIT_DATA},\n+  {\"target update\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TARGET_UPDATE},\n+  {\"target\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TARGET},\n+  {\"taskloop\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TASKLOOP},\n+  {\"taskwait\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TASKWAIT},\n+  {\"taskyield\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TASKYIELD},\n+  {\"task\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TASK},\n+  {\"teams\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TEAMS},\n+  {\"threadprivate\", GFC_OMP_DIR_DECLARATIVE, ST_OMP_THREADPRIVATE},\n+  /* {\"tile\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_TILE}, */\n+  /* {\"unroll\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_UNROLL}, */\n+  {\"workshare\", GFC_OMP_DIR_EXECUTABLE, ST_OMP_WORKSHARE},\n+};\n+\n \n /* Match an end of OpenMP directive.  End of OpenMP directive is optional\n    whitespace, followed by '\\n' or comment '!'.  */\n@@ -111,6 +191,13 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr_list (c->wait_list);\n   gfc_free_expr_list (c->tile_list);\n   free (CONST_CAST (char *, c->critical_name));\n+  if (c->assume)\n+    {\n+      free (c->assume->absent);\n+      free (c->assume->contains);\n+      gfc_free_expr_list (c->assume->holds);\n+      free (c->assume);\n+    }\n   free (c);\n }\n \n@@ -992,6 +1079,7 @@ enum omp_mask2\n   OMP_CLAUSE_HAS_DEVICE_ADDR,  /* OpenMP 5.1  */\n   OMP_CLAUSE_ENTER, /* OpenMP 5.2 */\n   OMP_CLAUSE_DOACROSS, /* OpenMP 5.2 */\n+  OMP_CLAUSE_ASSUMPTIONS, /* OpenMP 5.1. */\n   /* This must come last.  */\n   OMP_MASK2_LAST\n };\n@@ -1407,6 +1495,173 @@ gfc_match_omp_clause_reduction (char pc, gfc_omp_clauses *c, bool openacc,\n   return MATCH_YES;\n }\n \n+static match\n+gfc_omp_absent_contains_clause (gfc_omp_assumptions **assume, bool is_absent)\n+{\n+  if (*assume == NULL)\n+    *assume = gfc_get_omp_assumptions ();\n+  do\n+    {\n+      gfc_statement st = ST_NONE;\n+      gfc_gobble_whitespace ();\n+      locus old_loc = gfc_current_locus;\n+      char c = gfc_peek_ascii_char ();\n+      enum gfc_omp_directive_kind kind\n+\t= GFC_OMP_DIR_DECLARATIVE; /* Silence warning. */\n+      for (size_t i = 0; i < ARRAY_SIZE (gfc_omp_directives); i++)\n+\t{\n+\t  if (gfc_omp_directives[i].name[0] > c)\n+\t    break;\n+\t  if (gfc_omp_directives[i].name[0] != c)\n+\t    continue;\n+\t  if (gfc_match (gfc_omp_directives[i].name) == MATCH_YES)\n+\t    {\n+\t      st = gfc_omp_directives[i].st;\n+\t      kind = gfc_omp_directives[i].kind;\n+\t    }\n+\t}\n+      gfc_gobble_whitespace ();\n+      c = gfc_peek_ascii_char ();\n+      if (st == ST_NONE || (c != ',' && c != ')'))\n+\t{\n+\t  if (st == ST_NONE)\n+\t    gfc_error (\"Unknown directive at %L\", &old_loc);\n+\t  else\n+\t    gfc_error (\"Invalid combined or composit directive at %L\",\n+\t\t       &old_loc);\n+\t  return MATCH_ERROR;\n+\t}\n+      if (kind == GFC_OMP_DIR_DECLARATIVE\n+\t  || kind == GFC_OMP_DIR_INFORMATIONAL\n+\t  || kind == GFC_OMP_DIR_META)\n+\t{\n+\t  gfc_error (\"Invalid %qs directive at %L in %s clause: declarative, \"\n+\t\t     \"informational and meta directives not permitted\",\n+\t\t     gfc_ascii_statement (st, true), &old_loc,\n+\t\t     is_absent ? \"ABSENT\" : \"CONTAINS\");\n+\t  return MATCH_ERROR;\n+\t}\n+      if (is_absent)\n+\t{\n+\t  /* Use exponential allocation; equivalent to pow2p(x). */\n+\t  int i = (*assume)->n_absent;\n+\t  int size = ((i == 0) ? 4\n+\t\t      : pow2p_hwi (i) == 1 ? i*2 : 0);\n+\t  if (size != 0)\n+\t    (*assume)->absent = XRESIZEVEC (gfc_statement,\n+\t\t\t\t\t    (*assume)->absent, size);\n+\t  (*assume)->absent[(*assume)->n_absent++] = st;\n+\t}\n+      else\n+\t{\n+\t  int i = (*assume)->n_contains;\n+\t  int size = ((i == 0) ? 4\n+\t\t      : pow2p_hwi (i) == 1 ? i*2 : 0);\n+\t  if (size != 0)\n+\t    (*assume)->contains = XRESIZEVEC (gfc_statement,\n+\t\t\t\t\t      (*assume)->contains, size);\n+\t  (*assume)->contains[(*assume)->n_contains++] = st;\n+\t}\n+      gfc_gobble_whitespace ();\n+      if (gfc_match(\",\") == MATCH_YES)\n+\tcontinue;\n+      if (gfc_match(\")\") == MATCH_YES)\n+\tbreak;\n+      gfc_error (\"Expected %<,%> or %<)%> at %C\");\n+      return MATCH_ERROR;\n+    }\n+  while (true);\n+\n+  return MATCH_YES;\n+}\n+\n+/* Check 'check' argument for duplicated statements in absent and/or contains\n+   clauses. If 'merge', merge them from check to 'merge'.  */\n+\n+static match\n+omp_verify_merge_absent_contains (gfc_statement st, gfc_omp_assumptions *check,\n+\t\t\t\t  gfc_omp_assumptions *merge, locus *loc)\n+{\n+  if (check == NULL)\n+    return MATCH_YES;\n+  bitmap_head absent_head, contains_head;\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&absent_head, &bitmap_default_obstack);\n+  bitmap_initialize (&contains_head, &bitmap_default_obstack);\n+\n+  match m = MATCH_YES;\n+  for (int i = 0; i < check->n_absent; i++)\n+    if (!bitmap_set_bit (&absent_head, check->absent[i]))\n+      {\n+\tgfc_error (\"%qs directive mentioned multiple times in %s clause in %s \"\n+\t\t   \"directive at %L\",\n+\t\t   gfc_ascii_statement (check->absent[i], true),\n+\t\t   \"ABSENT\", gfc_ascii_statement (st), loc);\n+\tm = MATCH_ERROR;\n+      }\n+  for (int i = 0; i < check->n_contains; i++)\n+    {\n+      if (!bitmap_set_bit (&contains_head, check->contains[i]))\n+\t{\n+\t  gfc_error (\"%qs directive mentioned multiple times in %s clause in %s \"\n+\t\t     \"directive at %L\",\n+\t\t     gfc_ascii_statement (check->contains[i], true),\n+\t\t     \"CONTAINS\", gfc_ascii_statement (st), loc);\n+\t  m = MATCH_ERROR;\n+\t}\n+      if (bitmap_bit_p (&absent_head, check->contains[i]))\n+\t{\n+\t  gfc_error (\"%qs directive mentioned both times in ABSENT and CONTAINS \"\n+\t\t     \"clauses in %s directive at %L\",\n+\t\t     gfc_ascii_statement (check->absent[i], true),\n+\t\t     gfc_ascii_statement (st), loc);\n+\t  m = MATCH_ERROR;\n+\t}\n+    }\n+\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  if (merge == NULL)\n+    return MATCH_YES;\n+  if (merge->absent == NULL && check->absent)\n+    {\n+      merge->n_absent = check->n_absent;\n+      merge->absent = check->absent;\n+      check->absent = NULL;\n+    }\n+  else if (merge->absent && check->absent)\n+    {\n+      check->absent = XRESIZEVEC (gfc_statement, check->absent,\n+\t\t\t\t  merge->n_absent + check->n_absent);\n+      for (int i = 0; i < merge->n_absent; i++)\n+\tif (!bitmap_bit_p (&absent_head, merge->absent[i]))\n+\t  check->absent[check->n_absent++] = merge->absent[i];\n+      free (merge->absent);\n+      merge->absent = check->absent;\n+      merge->n_absent = check->n_absent;\n+      check->absent = NULL;\n+    }\n+  if (merge->contains == NULL && check->contains)\n+    {\n+      merge->n_contains = check->n_contains;\n+      merge->contains = check->contains;\n+      check->contains = NULL;\n+    }\n+  else if (merge->contains && check->contains)\n+    {\n+      check->contains = XRESIZEVEC (gfc_statement, check->contains,\n+\t\t\t\t    merge->n_contains + check->n_contains);\n+      for (int i = 0; i < merge->n_contains; i++)\n+\tif (!bitmap_bit_p (&contains_head, merge->contains[i]))\n+\t  check->contains[check->n_contains++] = merge->contains[i];\n+      free (merge->contains);\n+      merge->contains = check->contains;\n+      merge->n_contains = check->n_contains;\n+      check->contains = NULL;\n+    }\n+  return MATCH_YES;\n+}\n+\n \n /* Match with duplicate check. Matches 'name'. If expr != NULL, it\n    then matches '(expr)', otherwise, if open_parens is true,\n@@ -1511,6 +1766,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \tcase 'a':\n \t  end_colon = false;\n \t  head = NULL;\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && gfc_match (\"absent ( \") == MATCH_YES)\n+\t    {\n+\t      if (gfc_omp_absent_contains_clause (&c->assume, true)\n+\t\t  != MATCH_YES)\n+\t\tgoto error;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_ALIGNED)\n \t      && gfc_match_omp_variable_list (\"aligned (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_ALIGNED],\n@@ -1743,6 +2006,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && gfc_match (\"contains ( \") == MATCH_YES)\n+\t    {\n+\t      if (gfc_omp_absent_contains_clause (&c->assume, false)\n+\t\t  != MATCH_YES)\n+\t\tgoto error;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_COPY)\n \t      && gfc_match (\"copy ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n@@ -2277,6 +2548,20 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tgoto error;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && gfc_match (\"holds ( \") == MATCH_YES)\n+\t    {\n+\t      gfc_expr *e;\n+\t      if (gfc_match (\"%e )\", &e) != MATCH_YES)\n+\t\tgoto error;\n+\t      if (c->assume == NULL)\n+\t\tc->assume = gfc_get_omp_assumptions ();\n+\t      gfc_expr_list *el = XCNEW (gfc_expr_list);\n+\t      el->expr = e;\n+\t      el->next = c->assume->holds;\n+\t      c->assume->holds = el;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_HOST_SELF)\n \t      && gfc_match (\"host ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n@@ -2664,6 +2949,41 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t\t\t\t   OMP_MAP_IF_PRESENT, true,\n \t\t\t\t\t   allow_derived))\n \t    continue;\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && (m = gfc_match_dupl_check (!c->assume\n+\t\t\t\t\t    || !c->assume->no_openmp_routines,\n+\t\t\t\t\t    \"no_openmp_routines\")) == MATCH_YES)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (c->assume == NULL)\n+\t\tc->assume = gfc_get_omp_assumptions ();\n+\t      c->assume->no_openmp_routines = needs_space = true;\n+\t      continue;\n+\t    }\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && (m = gfc_match_dupl_check (!c->assume || !c->assume->no_openmp,\n+\t\t\t\t\t    \"no_openmp\")) == MATCH_YES)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (c->assume == NULL)\n+\t\tc->assume = gfc_get_omp_assumptions ();\n+\t      c->assume->no_openmp = needs_space = true;\n+\t      continue;\n+\t    }\n+\t  if ((mask & OMP_CLAUSE_ASSUMPTIONS)\n+\t      && (m = gfc_match_dupl_check (!c->assume\n+\t\t\t\t\t    || !c->assume->no_parallelism,\n+\t\t\t\t\t    \"no_parallelism\")) == MATCH_YES)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (c->assume == NULL)\n+\t\tc->assume = gfc_get_omp_assumptions ();\n+\t      c->assume->no_parallelism = needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_NOGROUP)\n \t      && (m = gfc_match_dupl_check (!c->nogroup, \"nogroup\"))\n \t\t != MATCH_NO)\n@@ -3941,6 +4261,69 @@ match_omp (gfc_exec_op op, const omp_mask mask)\n }\n \n \n+match\n+gfc_match_omp_assume (void)\n+{\n+  gfc_omp_clauses *c;\n+  locus loc = gfc_current_locus;\n+  if ((gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_ASSUMPTIONS))\n+       != MATCH_YES)\n+      || (omp_verify_merge_absent_contains (ST_OMP_ASSUME, c->assume, NULL,\n+\t\t\t\t\t    &loc) != MATCH_YES))\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_ASSUME;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_assumes (void)\n+{\n+  gfc_omp_clauses *c;\n+  locus loc = gfc_current_locus;\n+  if (!gfc_current_ns->proc_name\n+      || (gfc_current_ns->proc_name->attr.flavor != FL_MODULE\n+\t  && !gfc_current_ns->proc_name->attr.subroutine\n+\t  && !gfc_current_ns->proc_name->attr.function))\n+    {\n+      gfc_error (\"!$OMP ASSUMES at %C must be in the specification part of a \"\n+\t\t \"subprogram or module\");\n+      return MATCH_ERROR;\n+    }\n+  if ((gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_ASSUMPTIONS))\n+       != MATCH_YES)\n+      || (omp_verify_merge_absent_contains (ST_OMP_ASSUMES, c->assume,\n+\t\t\t\t\t    gfc_current_ns->omp_assumes, &loc)\n+\t  != MATCH_YES))\n+    return MATCH_ERROR;\n+  if (gfc_current_ns->omp_assumes == NULL)\n+    {\n+      gfc_current_ns->omp_assumes = c->assume;\n+      c->assume = NULL;\n+    }\n+  else if (gfc_current_ns->omp_assumes && c->assume)\n+    {\n+      gfc_current_ns->omp_assumes->no_openmp |= c->assume->no_openmp;\n+      gfc_current_ns->omp_assumes->no_openmp_routines\n+\t|= c->assume->no_openmp_routines;\n+      gfc_current_ns->omp_assumes->no_parallelism |= c->assume->no_parallelism;\n+      if (gfc_current_ns->omp_assumes->holds && c->assume->holds)\n+\t{\n+\t  gfc_expr_list *el = gfc_current_ns->omp_assumes->holds;\n+\t  for ( ; el->next ; el = el->next)\n+\t    ;\n+\t  el->next = c->assume->holds;\n+\t}\n+      else if (c->assume->holds)\n+\tgfc_current_ns->omp_assumes->holds = c->assume->holds;\n+      c->assume->holds = NULL;\n+    }\n+  gfc_free_omp_clauses (c);\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_critical (void)\n {\n@@ -6505,6 +6888,20 @@ resolve_omp_udr_clause (gfc_omp_namelist *n, gfc_namespace *ns,\n   return copy;\n }\n \n+\n+/* Resolve ASSUME's and ASSUMES' assumption clauses.  Note that absent/contains\n+   is handled during parse time in omp_verify_merge_absent_contains.   */\n+\n+void\n+gfc_resolve_omp_assumptions (gfc_omp_assumptions *assume)\n+{\n+  for (gfc_expr_list *el = assume->holds; el; el = el->next)\n+    if (!gfc_resolve_expr (el->expr) || el->expr->ts.type != BT_LOGICAL)\n+\tgfc_error (\"HOLDS expression at %L must be a logical expression\",\n+\t\t   &el->expr->where);\n+}\n+\n+\n /* OpenMP directive resolving routines.  */\n \n static void\n@@ -7888,6 +8285,9 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \tgfc_error (\"%<DETACH%> clause at %L must not be used together with \"\n \t\t   \"%<MERGEABLE%> clause\", &omp_clauses->detach->where);\n     }\n+\n+  if (omp_clauses->assume)\n+    gfc_resolve_omp_assumptions (omp_clauses->assume);\n }\n \n \n@@ -9116,6 +9516,8 @@ omp_code_to_statement (gfc_code *code)\n       return ST_OMP_DO;\n     case EXEC_OMP_LOOP:\n       return ST_OMP_LOOP;\n+    case EXEC_OMP_ASSUME:\n+      return ST_OMP_ASSUME;\n     case EXEC_OMP_ATOMIC:\n       return ST_OMP_ATOMIC;\n     case EXEC_OMP_BARRIER:\n@@ -9635,6 +10037,7 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns)\n     case EXEC_OMP_TEAMS_LOOP:\n       resolve_omp_do (code);\n       break;\n+    case EXEC_OMP_ASSUME:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_ERROR:\n     case EXEC_OMP_MASKED:"}, {"sha": "f04fd13cc696598ade396634e026bf2dd1e5a3b7", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -885,6 +885,8 @@ decode_omp_directive (void)\n   switch (c)\n     {\n     case 'a':\n+      matcho (\"assumes\", gfc_match_omp_assumes, ST_OMP_ASSUMES);\n+      matchs (\"assume\", gfc_match_omp_assume, ST_OMP_ASSUME);\n       matcho (\"atomic\", gfc_match_omp_atomic, ST_OMP_ATOMIC);\n       break;\n     case 'b':\n@@ -913,6 +915,7 @@ decode_omp_directive (void)\n       break;\n     case 'e':\n       matcho (\"error\", gfc_match_omp_error, ST_OMP_ERROR);\n+      matchs (\"end assume\", gfc_match_omp_eos_error, ST_OMP_END_ASSUME);\n       matcho (\"end atomic\", gfc_match_omp_eos_error, ST_OMP_END_ATOMIC);\n       matcho (\"end critical\", gfc_match_omp_end_critical, ST_OMP_END_CRITICAL);\n       matchs (\"end distribute parallel do simd\", gfc_match_omp_eos_error,\n@@ -1716,6 +1719,7 @@ next_statement (void)\n   case ST_OMP_TARGET_SIMD: case ST_OMP_TASKLOOP: case ST_OMP_TASKLOOP_SIMD: \\\n   case ST_OMP_LOOP: case ST_OMP_PARALLEL_LOOP: case ST_OMP_TEAMS_LOOP: \\\n   case ST_OMP_TARGET_PARALLEL_LOOP: case ST_OMP_TARGET_TEAMS_LOOP: \\\n+  case ST_OMP_ASSUME: \\\n   case ST_CRITICAL: \\\n   case ST_OACC_PARALLEL_LOOP: case ST_OACC_PARALLEL: case ST_OACC_KERNELS: \\\n   case ST_OACC_DATA: case ST_OACC_HOST_DATA: case ST_OACC_LOOP: \\\n@@ -1733,7 +1737,7 @@ next_statement (void)\n \n #define case_omp_decl case ST_OMP_THREADPRIVATE: case ST_OMP_DECLARE_SIMD: \\\n   case ST_OMP_DECLARE_TARGET: case ST_OMP_DECLARE_REDUCTION: \\\n-  case ST_OMP_DECLARE_VARIANT: \\\n+  case ST_OMP_DECLARE_VARIANT: case ST_OMP_ASSUMES: \\\n   case ST_OMP_REQUIRES: case ST_OACC_ROUTINE: case ST_OACC_DECLARE\n \n /* Block end statements.  Errors associated with interchanging these\n@@ -1925,10 +1929,11 @@ gfc_enclosing_unit (gfc_compile_state * result)\n }\n \n \n-/* Translate a statement enum to a string.  */\n+/* Translate a statement enum to a string.  If strip_sentinel is true,\n+   the !$OMP/!$ACC sentinel is excluded.  */\n \n const char *\n-gfc_ascii_statement (gfc_statement st)\n+gfc_ascii_statement (gfc_statement st, bool strip_sentinel)\n {\n   const char *p;\n \n@@ -2353,6 +2358,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OACC_END_ATOMIC:\n       p = \"!$ACC END ATOMIC\";\n       break;\n+    case ST_OMP_ASSUME:\n+      p = \"!$OMP ASSUME\";\n+      break;\n+    case ST_OMP_ASSUMES:\n+      p = \"!$OMP ASSUMES\";\n+      break;\n     case ST_OMP_ATOMIC:\n       p = \"!$OMP ATOMIC\";\n       break;\n@@ -2401,6 +2412,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_DO_SIMD:\n       p = \"!$OMP DO SIMD\";\n       break;\n+    case ST_OMP_END_ASSUME:\n+      p = \"!$OMP END ASSUME\";\n+      break;\n     case ST_OMP_END_ATOMIC:\n       p = \"!$OMP END ATOMIC\";\n       break;\n@@ -2600,6 +2614,10 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_ORDERED_DEPEND:\n       p = \"!$OMP ORDERED\";\n       break;\n+    case ST_OMP_NOTHING:\n+      /* Note: gfc_match_omp_nothing returns ST_NONE. */\n+      p = \"!$OMP NOTHING\";\n+      break;\n     case ST_OMP_PARALLEL:\n       p = \"!$OMP PARALLEL\";\n       break;\n@@ -2751,6 +2769,8 @@ gfc_ascii_statement (gfc_statement st)\n       gfc_internal_error (\"gfc_ascii_statement(): Bad statement code\");\n     }\n \n+  if (strip_sentinel && p[0] == '!')\n+    return p + strlen (\"!$OMP \");\n   return p;\n }\n \n@@ -5518,6 +5538,9 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n \n   switch (omp_st)\n     {\n+    case ST_OMP_ASSUME:\n+      omp_end_st = ST_OMP_END_ASSUME;\n+      break;\n     case ST_OMP_PARALLEL:\n       omp_end_st = ST_OMP_END_PARALLEL;\n       break;\n@@ -5651,6 +5674,7 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n \t\t  parse_forall_block ();\n \t\t  break;\n \n+\t\tcase ST_OMP_ASSUME:\n \t\tcase ST_OMP_PARALLEL:\n \t\tcase ST_OMP_PARALLEL_MASKED:\n \t\tcase ST_OMP_PARALLEL_MASTER:\n@@ -5874,6 +5898,7 @@ parse_executable (gfc_statement st)\n \t  parse_oacc_structured_block (st);\n \t  break;\n \n+\tcase ST_OMP_ASSUME:\n \tcase ST_OMP_PARALLEL:\n \tcase ST_OMP_PARALLEL_MASKED:\n \tcase ST_OMP_PARALLEL_MASTER:"}, {"sha": "013aeaedc03027a6deed01daa54d2ac3608ef451", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -66,7 +66,7 @@ extern gfc_state_data *gfc_state_stack;\n int gfc_check_do_variable (gfc_symtree *);\n bool gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n-const char *gfc_ascii_statement (gfc_statement);\n+const char *gfc_ascii_statement (gfc_statement, bool strip_sentinel = false) ;\n match gfc_match_enum (void);\n match gfc_match_enumerator_def (void);\n void gfc_free_enum_history (void);"}, {"sha": "d133bc2d0340d1dd3617c51f647f915f303dde98", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -10902,6 +10902,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OACC_ENTER_DATA:\n \tcase EXEC_OACC_EXIT_DATA:\n \tcase EXEC_OACC_ROUTINE:\n+\tcase EXEC_OMP_ASSUME:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_DISTRIBUTE:\n \tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n@@ -12376,6 +12377,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  gfc_resolve_oacc_directive (code, ns);\n \t  break;\n \n+\tcase EXEC_OMP_ASSUME:\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_BARRIER:\n \tcase EXEC_OMP_CANCEL:\n@@ -17651,6 +17653,9 @@ gfc_resolve (gfc_namespace *ns)\n   component_assignment_level = 0;\n   resolve_codes (ns);\n \n+  if (ns->omp_assumes)\n+    gfc_resolve_omp_assumptions (ns->omp_assumes);\n+\n   gfc_current_ns = old_ns;\n   cs_base = old_cs_base;\n   ns->resolved = 1;"}, {"sha": "3c8ca66554d27e4af17474d8965460da3680023e", "filename": "gcc/fortran/st.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -214,6 +214,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OACC_ENTER_DATA:\n     case EXEC_OACC_EXIT_DATA:\n     case EXEC_OACC_ROUTINE:\n+    case EXEC_OMP_ASSUME:\n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:"}, {"sha": "6050359d5210fbe5f0dfd786ee9617099d2e3803", "filename": "gcc/fortran/symbol.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fsymbol.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Fsymbol.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -4071,7 +4071,13 @@ gfc_free_namespace (gfc_namespace *&ns)\n       f = f->next;\n       free (current);\n     }\n-\n+  if (ns->omp_assumes)\n+    {\n+      free (ns->omp_assumes->absent);\n+      free (ns->omp_assumes->contains);\n+      gfc_free_expr_list (ns->omp_assumes->holds);\n+      free (ns->omp_assumes);\n+    }\n   p = ns->contained;\n   free (ns);\n   ns = NULL;"}, {"sha": "21053694f819e6c8cef09f57f1106dd42486065f", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -7487,6 +7487,8 @@ gfc_trans_omp_directive (gfc_code *code)\n {\n   switch (code->op)\n     {\n+    case EXEC_OMP_ASSUME:\n+      return gfc_trans_omp_code (code->block->next, true);\n     case EXEC_OMP_ATOMIC:\n       return gfc_trans_omp_atomic (code);\n     case EXEC_OMP_BARRIER:"}, {"sha": "8a64882ea9e427f99107cd25fec0779583220134", "filename": "gcc/fortran/trans.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ffortran%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.cc?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -2174,6 +2174,7 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_dt_end (code);\n \t  break;\n \n+\tcase EXEC_OMP_ASSUME:\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_BARRIER:\n \tcase EXEC_OMP_CANCEL:"}, {"sha": "8bd5c7230518d12433eae9f371bdab67f833832e", "filename": "gcc/testsuite/gfortran.dg/gomp/assume-1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-1.f90?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -0,0 +1,24 @@\n+subroutine foo (i, a)\n+  implicit none\n+  integer, value :: i\n+  integer :: a(:)\n+  integer :: j\n+\n+  j = 7\n+  !$omp assume no_openmp, absent (target, teams) holds (i < 32) holds (i < 32_2)\n+  !$omp end assume\n+\n+  !$omp assume no_openmp_routines, contains (simd)\n+  block\n+    !$omp simd\n+    do j = 1, i\n+      a(i) = j\n+    end do\n+  end block\n+\n+  !$omp assume no_parallelism, contains (error)\n+  if (i >= 32) then\n+    !$omp error at (execution) message (\"Should not happen\")\n+  end if\n+  !$omp end assume\n+end"}, {"sha": "ca3e04dfe95b63c6265f8c04d9b49f17c040124b", "filename": "gcc/testsuite/gfortran.dg/gomp/assume-2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassume-2.f90?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -0,0 +1,27 @@\n+subroutine foo (i, a)\n+  implicit none\n+  integer, value :: i\n+  integer :: a(:)\n+  integer :: j\n+\n+  j = 7\n+  !$omp assume no_openmp, absent (target, teams,target) holds (i < 32) holds (i < 32_2)  ! { dg-error \"'TARGET' directive mentioned multiple times in ABSENT clause in !.OMP ASSUME directive\" }\n+!  !$omp end assume  - silence: 'Unexpected !$OMP END ASSUME statement'\n+\n+  !$omp assume no_openmp_routines, contains (simd) contains ( simd )  ! { dg-error \"'SIMD' directive mentioned multiple times in CONTAINS clause in !.OMP ASSUME directive\" }\n+  block\n+    !$omp simd\n+    do j = 1, i\n+      a(i) = j\n+    end do\n+  end block\n+\n+  !$omp assume no_parallelism, contains (error) absent (error)  ! { dg-error \"'ERROR' directive mentioned both times in ABSENT and CONTAINS clauses in !.OMP ASSUME directive\" }\n+  if (i >= 32) then\n+    !$omp error at (execution) message (\"Should not happen\")\n+  end if\n+!  !$omp end assume  - silence: 'Unexpected !$OMP END ASSUME statement'\n+\n+  !$omp assume holds (1.0)  ! { dg-error \"HOLDS expression at .1. must be a logical expression\" }\n+  !$omp end assume\n+end"}, {"sha": "3d468dc1c812dcd2c615517c88f7debf466903cb", "filename": "gcc/testsuite/gfortran.dg/gomp/assumes-1.f90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-1.f90?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -0,0 +1,82 @@\n+! All of the following (up to PROGRAM) are okay:\n+!\n+subroutine sub\n+  interface\n+    subroutine sub_iterface()\n+      !$omp assumes no_openmp_routines absent(simd) !  OK inferface of an external subroutine/subprogram\n+    end\n+  end interface\n+  !$omp assumes no_openmp_routines absent(simd) !  OK external subroutine/subprogram\n+contains\n+  subroutine inner_sub\n+     !$omp assumes no_parallelism absent(teams) ! OK internal subroutine/subprogram\n+  end\n+end\n+\n+integer function func ()\n+  !$omp assumes no_openmp_routines absent(simd) !  OK external function/subprogram\n+  interface\n+    integer function func_iterface()\n+      !$omp assumes no_openmp_routines absent(simd) !  OK inferface of an external function/subprogram\n+    end\n+  end interface\n+  func = 0\n+contains\n+  integer function inner_func()\n+     !$omp assumes no_parallelism absent(teams) ! OK internal function/subprogram\n+     inner_sub2 = 0\n+  end\n+end\n+\n+module m\n+  integer ::x \n+  !$omp assumes contains(target) holds(x > 0.0)\n+\n+    interface\n+      subroutine mod_mod_sub_iterface()\n+        !$omp assumes no_openmp_routines absent(simd) !  OK inferface of an external subroutine/subprogram\n+      end\n+      integer function mod_mod_func_iterface()\n+        !$omp assumes no_openmp_routines absent(error) !  OK inferface of an external subroutine/subprogram\n+      end\n+    end interface\n+\n+contains\n+  subroutine mod_sub\n+    interface\n+      subroutine mod_sub_iterface()\n+        !$omp assumes no_openmp_routines absent(simd) !  OK inferface of an external subroutine/subprogram\n+      end\n+    end interface\n+    !$omp assumes no_openmp_routines absent(simd) !  OK module subroutine/subprogram\n+  contains\n+    subroutine mod_inner_sub\n+       !$omp assumes no_parallelism absent(teams) ! OK internal subroutine/subprogram\n+    end\n+  end\n+\n+  integer function mod_func ()\n+    !$omp assumes no_openmp_routines absent(simd) !  OK module function/subprogram\n+    interface\n+      integer function mod_func_iterface()\n+        !$omp assumes no_openmp_routines absent(simd) !  OK inferface of an external function/subprogram\n+      end\n+    end interface\n+    mod_func = 0\n+  contains\n+    integer function mod_inner_func()\n+       !$omp assumes no_parallelism absent(teams) ! OK internal function/subprogram\n+       mod_inner_sub2 = 0\n+    end\n+  end\n+end module m\n+\n+\n+! PROGRAM - invalid as:\n+!  main program is a program unit that is not a subprogram\n+!$omp assumes no_openmp absent(simd)  ! { dg-error \"must be in the specification part of a subprogram or module\" }\n+  block\n+    ! invalid: block\n+    !$omp assumes no_openmp absent(target)  ! { dg-error \"must be in the specification part of a subprogram or module\" }\n+  end block\n+end"}, {"sha": "729c9737a1c0cee9467d15ae5f0148e4fca86085", "filename": "gcc/testsuite/gfortran.dg/gomp/assumes-2.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassumes-2.f90?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -0,0 +1,19 @@\n+module m\n+  integer ::x \n+! Nonsense but OpenMP-semantically valid:\n+  !$omp assumes contains(target) holds(x > 0.0)\n+  !$omp assumes absent(target)\n+  !$omp assumes holds(0.0)\n+! { dg-error \"HOLDS expression at .1. must be a logical expression\" \"\" { target *-*-* } .-1 }\n+end module\n+\n+module m2\n+interface\n+  subroutine foo\n+    !$omp assumes contains(target) contains(teams,target) ! { dg-error \"'TARGET' directive mentioned multiple times in CONTAINS clause in !.OMP ASSUMES directive\" }\n+    !$omp assumes absent(declare target) ! { dg-error \"Invalid 'DECLARE TARGET' directive at .1. in ABSENT clause: declarative, informational and meta directives not permitted\" }\n+    !$omp assumes absent(parallel) absent(do,simd,parallel,distribute) ! { dg-error \"'PARALLEL' directive mentioned multiple times in ABSENT clause in !.OMP ASSUMES directive\" }\n+    !$omp assumes contains(barrier,atomic) absent(cancel,simd,atomic,distribute) ! { dg-error \"'SIMD' directive mentioned both times in ABSENT and CONTAINS clauses in !.OMP ASSUMES directive\" }\n+  end subroutine foo\n+end interface\n+end module m2"}, {"sha": "d8c798cf7a19cebbc5b5b038cf458a886a345881", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a228438919d846995bf2c839c9b657442224b2/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a228438919d846995bf2c839c9b657442224b2/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=e2a228438919d846995bf2c839c9b657442224b2", "patch": "@@ -287,7 +287,7 @@ The OpenMP 4.5 specification is fully supported.\n       @code{append_args} @tab N @tab\n @item @code{dispatch} construct @tab N @tab\n @item device-specific ICV settings with environment variables @tab Y @tab\n-@item @code{assume} directive @tab P @tab Only C/C++\n+@item @code{assume} directive @tab Y @tab\n @item @code{nothing} directive @tab Y @tab\n @item @code{error} directive @tab Y @tab\n @item @code{masked} construct @tab Y @tab"}]}