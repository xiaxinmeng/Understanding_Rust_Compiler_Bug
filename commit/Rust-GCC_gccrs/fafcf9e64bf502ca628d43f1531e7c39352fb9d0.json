{"sha": "fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmY2Y5ZTY0YmY1MDJjYTYyOGQ0M2YxNTMxZTdjMzkzNTJmYjlkMA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:04:27Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:04:27Z"}, "message": "trans-expr.c (gfc_conv_procedure_call): Handle temporaries for arguments to elemental calls.\n\n\t* trans-expr.c (gfc_conv_procedure_call): Handle temporaries for\n\targuments to elemental calls.\n\t* trans-stmt.c (replace_ss): New function.\n\t(gfc_conv_elemental_dependencies): Remove temporary loop handling.\n\tCreate a new ss for the temporary and replace the original one with it.\n\tRemove fake array references. Recalculate all offsets.\n\nFrom-SVN: r180906", "tree": {"sha": "1d0b5a5f72a77f5f5e42cc5384c58957b7098b71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d0b5a5f72a77f5f5e42cc5384c58957b7098b71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/comments", "author": null, "committer": null, "parents": [{"sha": "121c82c9ac5c8af04d480de4b2449fbdb5e2beae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121c82c9ac5c8af04d480de4b2449fbdb5e2beae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121c82c9ac5c8af04d480de4b2449fbdb5e2beae"}], "stats": {"total": 134, "additions": 67, "deletions": 67}, "files": [{"sha": "0cebe5fee67c9b498c4282be6ec358ba3e7b963d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "patch": "@@ -1,3 +1,12 @@\n+2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-expr.c (gfc_conv_procedure_call): Handle temporaries for\n+\targuments to elemental calls.\n+\t* trans-stmt.c (replace_ss): New function.\n+\t(gfc_conv_elemental_dependencies): Remove temporary loop handling.\n+\tCreate a new ss for the temporary and replace the original one with it.\n+\tRemove fake array references. Recalculate all offsets.\n+\n 2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.h (gfc_free_ss, gfc_set_delta): New prototypes."}, {"sha": "cf9f0f7cdb96ce80f59deda27434d5c6857bde52", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "patch": "@@ -2997,8 +2997,19 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  /* An elemental function inside a scalarized loop.  */\n \t  gfc_init_se (&parmse, se);\n-\t  gfc_conv_expr_reference (&parmse, e);\n \t  parm_kind = ELEMENTAL;\n+\n+\t  if (se->ss->dimen > 0\n+\t      && se->ss->info->data.array.ref == NULL)\n+\t    {\n+\t      gfc_conv_tmp_array_ref (&parmse);\n+\t      if (e->ts.type == BT_CHARACTER)\n+\t\tgfc_conv_string_parameter (&parmse);\n+\t      else\n+\t\tparmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n+\t    }\n+\t  else\n+\t    gfc_conv_expr_reference (&parmse, e);\n \t}\n       else\n \t{"}, {"sha": "0d793f96858c71bc176fecef5bc1c63198bb8107", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 46, "deletions": 66, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafcf9e64bf502ca628d43f1531e7c39352fb9d0/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fafcf9e64bf502ca628d43f1531e7c39352fb9d0", "patch": "@@ -178,6 +178,41 @@ gfc_trans_entry (gfc_code * code)\n }\n \n \n+/* Replace a gfc_ss structure by another both in the gfc_se struct\n+   and the gfc_loopinfo struct.  This is used in gfc_conv_elemental_dependencies\n+   to replace a variable ss by the corresponding temporary.  */\n+\n+static void\n+replace_ss (gfc_se *se, gfc_ss *old_ss, gfc_ss *new_ss)\n+{\n+  gfc_ss **sess, **loopss;\n+\n+  /* The old_ss is a ss for a single variable.  */\n+  gcc_assert (old_ss->info->type == GFC_SS_SECTION);\n+\n+  for (sess = &(se->ss); *sess != gfc_ss_terminator; sess = &((*sess)->next))\n+    if (*sess == old_ss)\n+      break;\n+  gcc_assert (*sess != gfc_ss_terminator);\n+\n+  *sess = new_ss;\n+  new_ss->next = old_ss->next;\n+\n+\n+  for (loopss = &(se->loop->ss); *loopss != gfc_ss_terminator;\n+       loopss = &((*loopss)->loop_chain))\n+    if (*loopss == old_ss)\n+      break;\n+  gcc_assert (*loopss != gfc_ss_terminator);\n+\n+  *loopss = new_ss;\n+  new_ss->loop_chain = old_ss->loop_chain;\n+  new_ss->loop = old_ss->loop;\n+\n+  gfc_free_ss (old_ss);\n+}\n+\n+\n /* Check for dependencies between INTENT(IN) and INTENT(OUT) arguments of\n    elemental subroutines.  Make temporaries for output arguments if any such\n    dependencies are found.  Output arguments are chosen because internal_unpack\n@@ -190,15 +225,10 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n   gfc_actual_arglist *arg0;\n   gfc_expr *e;\n   gfc_formal_arglist *formal;\n-  gfc_loopinfo tmp_loop;\n   gfc_se parmse;\n   gfc_ss *ss;\n-  gfc_array_info *info;\n   gfc_symbol *fsym;\n-  gfc_ref *ref;\n-  int n;\n   tree data;\n-  tree offset;\n   tree size;\n   tree tmp;\n \n@@ -217,14 +247,9 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \tcontinue;\n \n       /* Obtain the info structure for the current argument.  */ \n-      info = NULL;\n       for (ss = loopse->ss; ss && ss != gfc_ss_terminator; ss = ss->next)\n-\t{\n-\t  if (ss->info->expr != e)\n-\t    continue;\n-\t  info = &ss->info->data.array;\n+\tif (ss->info->expr == e)\n \t  break;\n-\t}\n \n       /* If there is a dependency, create a temporary and use it\n \t instead of the variable.  */\n@@ -237,49 +262,17 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t{\n \t  tree initial, temptype;\n \t  stmtblock_t temp_post;\n+\t  gfc_ss *tmp_ss;\n \n-\t  /* Make a local loopinfo for the temporary creation, so that\n-\t     none of the other ss->info's have to be renormalized.  */\n-\t  gfc_init_loopinfo (&tmp_loop);\n-\t  tmp_loop.dimen = ss->dimen;\n-\t  for (n = 0; n < ss->dimen; n++)\n-\t    {\n-\t      tmp_loop.to[n] = loopse->loop->to[n];\n-\t      tmp_loop.from[n] = loopse->loop->from[n];\n-\t      tmp_loop.order[n] = loopse->loop->order[n];\n-\t    }\n+\t  tmp_ss = gfc_get_array_ss (gfc_ss_terminator, NULL, ss->dimen,\n+\t\t\t\t     GFC_SS_SECTION);\n+\t  gfc_mark_ss_chain_used (tmp_ss, 1);\n+\t  tmp_ss->info->expr = ss->info->expr;\n+\t  replace_ss (loopse, ss, tmp_ss);\n \n \t  /* Obtain the argument descriptor for unpacking.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  parmse.want_pointer = 1;\n-\n-\t  /* The scalarizer introduces some specific peculiarities when\n-\t     handling elemental subroutines; the stride can be needed up to\n-\t     the dim_array - 1, rather than dim_loop - 1 to calculate\n-\t     offsets outside the loop.  For this reason, we make sure that\n-\t     the descriptor has the dimensionality of the array by converting\n-\t     trailing elements into ranges with end = start.  */\n-\t  for (ref = e->ref; ref; ref = ref->next)\n-\t    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n-\t      break;\n-\n-\t  if (ref)\n-\t    {\n-\t      bool seen_range = false;\n-\t      for (n = 0; n < ref->u.ar.dimen; n++)\n-\t\t{\n-\t\t  if (ref->u.ar.dimen_type[n] == DIMEN_RANGE)\n-\t\t    seen_range = true;\n-\n-\t\t  if (!seen_range\n-\t\t\t|| ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n-\t\t    continue;\n-\n-\t\t  ref->u.ar.end[n] = gfc_copy_expr (ref->u.ar.start[n]);\n-\t\t  ref->u.ar.dimen_type[n] = DIMEN_RANGE;\n-\t\t}\n-\t    }\n-\n \t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \n@@ -309,28 +302,15 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  size = gfc_create_var (gfc_array_index_type, NULL);\n \t  data = gfc_create_var (pvoid_type_node, NULL);\n \t  gfc_init_block (&temp_post);\n-\t  ss->loop = &tmp_loop;\n-\t  tmp = gfc_trans_create_temp_array (&se->pre, &temp_post, ss,\n+\t  tmp = gfc_trans_create_temp_array (&se->pre, &temp_post, tmp_ss,\n \t\t\t\t\t     temptype, initial, false, true,\n \t\t\t\t\t     false, &arg->expr->where);\n \t  gfc_add_modify (&se->pre, size, tmp);\n-\t  tmp = fold_convert (pvoid_type_node, info->data);\n+\t  tmp = fold_convert (pvoid_type_node, tmp_ss->info->data.array.data);\n \t  gfc_add_modify (&se->pre, data, tmp);\n \n-\t  /* Calculate the offset for the temporary.  */\n-\t  offset = gfc_index_zero_node;\n-\t  for (n = 0; n < ss->dimen; n++)\n-\t    {\n-\t      tmp = gfc_conv_descriptor_stride_get (info->descriptor,\n-\t\t\t\t\t\t    gfc_rank_cst[n]);\n-\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t     gfc_array_index_type,\n-\t\t\t\t     loopse->loop->from[n], tmp);\n-\t      offset = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t\tgfc_array_index_type, offset, tmp);\n-\t    }\n-\t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n-\t  gfc_add_modify (&se->pre, info->offset, offset);\n+\t  /* Update other ss' delta.  */\n+\t  gfc_set_delta (loopse->loop);\n \n \t  /* Copy the result back using unpack.  */\n \t  tmp = build_call_expr_loc (input_location,"}]}