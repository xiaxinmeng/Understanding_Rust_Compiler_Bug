{"sha": "fa780794692994d63febf4fb187567e245cdd4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3ODA3OTQ2OTI5OTRkNjNmZWJmNGZiMTg3NTY3ZTI0NWNkZDRlZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:16:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:16:00Z"}, "message": "poly_int: vectorizable_live_operation\n\nThis patch makes vectorizable_live_operation cope with variable-length\nvectors.  For now we just handle cases in which we can tell at compile\ntime which vector contains the final result.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vectorizable_live_operation): Treat the number\n\tof units as polynomial.  Punt if we can't tell at compile time\n\twhich vector contains the final result.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256135", "tree": {"sha": "8a3bf3a7503059b5b9cce1acbb405ddca7c5717f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a3bf3a7503059b5b9cce1acbb405ddca7c5717f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa780794692994d63febf4fb187567e245cdd4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa780794692994d63febf4fb187567e245cdd4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa780794692994d63febf4fb187567e245cdd4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa780794692994d63febf4fb187567e245cdd4ee/comments", "author": null, "committer": null, "parents": [{"sha": "9fb9293aca4ddbe4d11a334befaa7847b279ed39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb9293aca4ddbe4d11a334befaa7847b279ed39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb9293aca4ddbe4d11a334befaa7847b279ed39"}], "stats": {"total": 48, "additions": 35, "deletions": 13}, "files": [{"sha": "2a62a33dbadd50e024333a6c4085e790122c0498", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa780794692994d63febf4fb187567e245cdd4ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa780794692994d63febf4fb187567e245cdd4ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa780794692994d63febf4fb187567e245cdd4ee", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-loop.c (vectorizable_live_operation): Treat the number\n+\tof units as polynomial.  Punt if we can't tell at compile time\n+\twhich vector contains the final result.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "397fc2502bbec99c447a3849fd4ea4e79581a045", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa780794692994d63febf4fb187567e245cdd4ee/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa780794692994d63febf4fb187567e245cdd4ee/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=fa780794692994d63febf4fb187567e245cdd4ee", "patch": "@@ -7201,10 +7201,12 @@ vectorizable_live_operation (gimple *stmt,\n   imm_use_iterator imm_iter;\n   tree lhs, lhs_type, bitsize, vec_bitsize;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   gimple *use_stmt;\n   auto_vec<tree> vec_oprnds;\n+  int vec_entry = 0;\n+  poly_uint64 vec_index = 0;\n \n   gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n \n@@ -7233,6 +7235,30 @@ vectorizable_live_operation (gimple *stmt,\n   else\n     ncopies = vect_get_num_copies (loop_vinfo, vectype);\n \n+  if (slp_node)\n+    {\n+      gcc_assert (slp_index >= 0);\n+\n+      int num_scalar = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\n+      /* Get the last occurrence of the scalar index from the concatenation of\n+\t all the slp vectors. Calculate which slp vector it is and the index\n+\t within.  */\n+      poly_uint64 pos = (num_vec * nunits) - num_scalar + slp_index;\n+\n+      /* Calculate which vector contains the result, and which lane of\n+\t that vector we need.  */\n+      if (!can_div_trunc_p (pos, nunits, &vec_entry, &vec_index))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Cannot determine which vector holds the\"\n+\t\t\t     \" final result.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (!vec_stmt)\n     /* No transformation required.  */\n     return true;\n@@ -7254,18 +7280,6 @@ vectorizable_live_operation (gimple *stmt,\n   tree vec_lhs, bitstart;\n   if (slp_node)\n     {\n-      gcc_assert (slp_index >= 0);\n-\n-      int num_scalar = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n-      int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-\n-      /* Get the last occurrence of the scalar index from the concatenation of\n-\t all the slp vectors. Calculate which slp vector it is and the index\n-\t within.  */\n-      int pos = (num_vec * nunits) - num_scalar + slp_index;\n-      int vec_entry = pos / nunits;\n-      int vec_index = pos % nunits;\n-\n       /* Get the correct slp vectorized stmt.  */\n       vec_lhs = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[vec_entry]);\n "}]}