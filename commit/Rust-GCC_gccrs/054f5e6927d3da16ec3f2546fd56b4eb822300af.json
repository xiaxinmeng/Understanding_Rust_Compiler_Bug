{"sha": "054f5e6927d3da16ec3f2546fd56b4eb822300af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0ZjVlNjkyN2QzZGExNmVjM2YyNTQ2ZmQ1NmI0ZWI4MjIzMDBhZg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-08-24T22:19:27Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-08-24T22:19:27Z"}, "message": "ggc-page.c (alloc_page): If HAVE_MMAP_ANYWHERE and we're asked for one page...\n\n\t* ggc-page.c (alloc_page): If HAVE_MMAP_ANYWHERE and we're\n\tasked for one page, allocate GGC_QUIRE_SIZE of them and put\n\tthe extras on the free list.\n\t(release_pages): Clean up.\n\t(ggc_set_mark): Don't adjust G.allocated here...\n\t(sweep_pages): ... do it here.\n\nFrom-SVN: r35961", "tree": {"sha": "0a08e0e534dca3356dacd704e44b3733f45c39c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a08e0e534dca3356dacd704e44b3733f45c39c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/054f5e6927d3da16ec3f2546fd56b4eb822300af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054f5e6927d3da16ec3f2546fd56b4eb822300af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054f5e6927d3da16ec3f2546fd56b4eb822300af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054f5e6927d3da16ec3f2546fd56b4eb822300af/comments", "author": null, "committer": null, "parents": [{"sha": "3d7428b8f616cb0cd457fd7cf32e1488ff6cd2de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7428b8f616cb0cd457fd7cf32e1488ff6cd2de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7428b8f616cb0cd457fd7cf32e1488ff6cd2de"}], "stats": {"total": 99, "additions": 67, "deletions": 32}, "files": [{"sha": "12e4661372c8aba6898bd87e1569f315be638654", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054f5e6927d3da16ec3f2546fd56b4eb822300af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054f5e6927d3da16ec3f2546fd56b4eb822300af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=054f5e6927d3da16ec3f2546fd56b4eb822300af", "patch": "@@ -1,3 +1,16 @@\n+2000-08-24  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* ggc-page.c (alloc_page): If HAVE_MMAP_ANYWHERE and we're  \n+\tasked for one page, allocate GGC_QUIRE_SIZE of them and put\n+\tthe extras on the free list.\n+\t(release_pages): Clean up.\n+\t(ggc_set_mark): Don't adjust G.allocated here...\n+\t(sweep_pages): ... do it here.\n+\n+2000-08-24  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (read_include_file): Rearrange initializations.\n+\n 2000-08-24  Richard Henderson  <rth@cygnus.com>\n \n \t* stmt.c (expand_asm_operands): Treat EXTRA_CONSTRAINT like g or X."}, {"sha": "b395aaaf92e2d11944990ca50ead72bd147e7b0a", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054f5e6927d3da16ec3f2546fd56b4eb822300af/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054f5e6927d3da16ec3f2546fd56b4eb822300af/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=054f5e6927d3da16ec3f2546fd56b4eb822300af", "patch": "@@ -264,6 +264,10 @@ static struct globals\n    test from triggering too often when the heap is small.  */\n #define GGC_MIN_LAST_ALLOCATED (4 * 1024 * 1024)\n \n+/* Allocate pages in chunks of this size, to throttle calls to mmap.\n+   The first page is used, the rest go onto the free list.  */\n+#define GGC_QUIRE_SIZE 16\n+\n \f\n static int ggc_allocated_p PARAMS ((const void *));\n static page_entry *lookup_page_table_entry PARAMS ((const void *));\n@@ -481,11 +485,31 @@ alloc_page (order)\n       else\n \tfree (p);\n     }\n-  else\n+#ifdef HAVE_MMAP_ANYWHERE\n+  else if (entry_size == G.pagesize)\n     {\n-      /* Actually allocate the memory.  */\n-      page = alloc_anon (NULL, entry_size);\n+      /* We want just one page.  Allocate a bunch of them and put the\n+\t extras on the freelist.  (Can only do this optimization with\n+\t mmap for backing store.)  */\n+      struct page_entry *e, *f = G.free_pages;\n+      int i;\n+\n+      page = alloc_anon (NULL, entry_size * GGC_QUIRE_SIZE);\n+      /* This loop counts down so that the chain will be in ascending\n+\t memory order.  */\n+      for (i = GGC_QUIRE_SIZE - 1; i >= 1; i--)\n+\t{\n+\t  e = (struct page_entry *) xcalloc (1, sizeof (struct page_entry));\n+\t  e->bytes = entry_size;\n+\t  e->page = page + i*entry_size;\n+\t  e->next = f;\n+\t  f = e;\n+\t}\n+      G.free_pages = f;\n     }\n+#endif\n+  else\n+    page = alloc_anon (NULL, entry_size);\n \n   if (entry == NULL)\n     entry = (struct page_entry *) xcalloc (1, page_entry_size);\n@@ -534,45 +558,38 @@ free_page (entry)\n static void\n release_pages ()\n {\n-#ifdef HAVE_MMAP_ANYWHERE\n   page_entry *p, *next;\n+\n+#ifdef HAVE_MMAP_ANYWHERE\n   char *start;\n   size_t len;\n \n+  /* Gather up adjacent pages so they are unmapped together.  */\n   p = G.free_pages;\n-  if (p == NULL)\n-    return;\n-\n-  next = p->next;\n-  start = p->page;\n-  len = p->bytes;\n-  free (p);\n-  p = next;\n \n   while (p)\n     {\n+      start = p->page;\n       next = p->next;\n-      /* Gather up adjacent pages so they are unmapped together.  */\n-      if (p->page == start + len)\n-\tlen += p->bytes;\n-      else\n-\t{\n-\t  munmap (start, len);\n-\t  G.bytes_mapped -= len;\n-\t  start = p->page;\n-\t  len = p->bytes;\n-\t}\n+      len = p->bytes;\n       free (p);\n       p = next;\n-    }\n \n-  munmap (start, len);\n-  G.bytes_mapped -= len;\n+      while (p && p->page == start + len)\n+\t{\n+\t  next = p->next;\n+\t  len += p->bytes;\n+\t  free (p);\n+\t  p = next;\n+\t}\n+\n+      munmap (start, len);\n+      G.bytes_mapped -= len;\n+    }\n #else\n #ifdef HAVE_VALLOC\n-  page_entry *p, *next;\n \n-  for (p = G.free_pages; p ; p = next)\n+  for (p = G.free_pages; p; p = next)\n     {\n       next = p->next;\n       free (p->page);\n@@ -755,8 +772,6 @@ ggc_set_mark (p)\n   entry->in_use_p[word] |= mask;\n   entry->num_free_objects -= 1;\n \n-  G.allocated += (size_t) 1 << entry->order;\n-\n   if (GGC_DEBUG_LEVEL >= 4)\n     fprintf (G.debug_file, \"Marking %p\\n\", p);\n \n@@ -972,6 +987,7 @@ sweep_pages ()\n       page_entry * const last = G.page_tails[order];\n \n       size_t num_objects = OBJECTS_PER_PAGE (order);\n+      size_t live_objects;\n       page_entry *p, *previous;\n       int done;\n \t\n@@ -987,13 +1003,19 @@ sweep_pages ()\n \t  /* Loop until all entries have been examined.  */\n \t  done = (p == last);\n \n+\t  /* Add all live objects on this page to the count of\n+             allocated memory.  */\n+\t  live_objects = num_objects - p->num_free_objects;\n+\n+\t  G.allocated += ((size_t) 1 << order) * live_objects;\n+\n \t  /* Only objects on pages in the topmost context should get\n \t     collected.  */\n \t  if (p->context_depth < G.context_depth)\n \t    ;\n \n \t  /* Remove the page if it's empty.  */\n-\t  else if (p->num_free_objects == num_objects)\n+\t  else if (live_objects == 0)\n \t    {\n \t      if (! previous)\n \t\tG.pages[order] = next;\n@@ -1112,8 +1134,8 @@ ggc_collect ()\n   if (!quiet_flag)\n     fprintf (stderr, \" {GC %luk -> \", (unsigned long) G.allocated / 1024);\n \n-  /* Zero the total allocated bytes.  We'll reaccumulate this while\n-     marking.  */\n+  /* Zero the total allocated bytes.  This will be recalculated in the\n+     sweep phase.  */\n   G.allocated = 0;\n \n   /* Release the pages we freed the last time we collected, but didn't "}]}