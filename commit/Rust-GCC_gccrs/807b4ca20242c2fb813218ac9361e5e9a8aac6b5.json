{"sha": "807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3YjRjYTIwMjQyYzJmYjgxMzIxOGFjOTM2MWU1ZTlhOGFhYzZiNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-22T10:52:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-22T10:52:55Z"}, "message": "[multiple changes]\n\n2013-04-22  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Contract_Case): New routine.\n\t(Analyze_Pragma): Aspect/pragma Contract_Cases can\n\tnow be associated with a library level subprogram.\n\tAdd circuitry to detect illegal uses of aspect/pragma Contract_Cases\n\tin a subprogram body.\n\t(Chain_Contract_Cases): Rename formal parameter Subp_Decl to\n\tSubp_Id. Remove local constant Subp. The entity of the subprogram\n\tis now obtained via the formal paramter.\n\n2013-04-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): Do not set\n\tIs_Constr_Subt_For_Unc_Aliased on the subtype of the expression,\n\tif the expression is a source entity.\n\nFrom-SVN: r198134", "tree": {"sha": "e8fcd7a4ca8a7847c965e0dce84d007545751346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8fcd7a4ca8a7847c965e0dce84d007545751346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/comments", "author": null, "committer": null, "parents": [{"sha": "b2c3b5375fb4f3e5ede60e3edf4e11b60b29dc5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c3b5375fb4f3e5ede60e3edf4e11b60b29dc5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c3b5375fb4f3e5ede60e3edf4e11b60b29dc5a"}], "stats": {"total": 236, "additions": 156, "deletions": 80}, "files": [{"sha": "616d2497e074e185a0baf376291e66e37da1750a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "patch": "@@ -1,3 +1,20 @@\n+2013-04-22  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Contract_Case): New routine.\n+\t(Analyze_Pragma): Aspect/pragma Contract_Cases can\n+\tnow be associated with a library level subprogram.\n+\tAdd circuitry to detect illegal uses of aspect/pragma Contract_Cases\n+\tin a subprogram body.\n+\t(Chain_Contract_Cases): Rename formal parameter Subp_Decl to\n+\tSubp_Id. Remove local constant Subp. The entity of the subprogram\n+\tis now obtained via the formal paramter.\n+\n+2013-04-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Do not set\n+\tIs_Constr_Subt_For_Unc_Aliased on the subtype of the expression,\n+\tif the expression is a source entity.\n+\n 2013-04-22  Yannick Moy  <moy@adacore.com>\n \n \t* exp_prag.adb, sinfo.ads, sem_prag.ads: Minor correction of typos in"}, {"sha": "3bc0e42fd98439e550ada0e0cae277f96ea6b96a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "patch": "@@ -3404,7 +3404,14 @@ package body Sem_Ch3 is\n \n             Set_Is_Constr_Subt_For_U_Nominal (Act_T);\n \n-            if Aliased_Present (N) then\n+            --  If the expression is a source entity its type is defined\n+            --  elsewhere. Otherwise it is a just-created subtype, and the\n+            --  back-end may need to create a template for it.\n+\n+            if Aliased_Present (N)\n+              and then (not Is_Entity_Name (E)\n+                 or else not Comes_From_Source (E))\n+            then\n                Set_Is_Constr_Subt_For_UN_Aliased (Act_T);\n             end if;\n "}, {"sha": "64bc2e78c7815ef2ff38df2ab2ac12202f5fb515", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 131, "deletions": 79, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/807b4ca20242c2fb813218ac9361e5e9a8aac6b5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=807b4ca20242c2fb813218ac9361e5e9a8aac6b5", "patch": "@@ -8628,33 +8628,82 @@ package body Sem_Prag is\n          --  CONSEQUENCE ::= boolean_EXPRESSION\n \n          when Pragma_Contract_Cases => Contract_Cases : declare\n-            procedure Chain_Contract_Cases (Subp_Decl : Node_Id);\n+            Others_Seen : Boolean := False;\n+\n+            procedure Analyze_Contract_Case (Contract_Case : Node_Id);\n+            --  Verify the legality of a single contract case\n+\n+            procedure Chain_Contract_Cases (Subp_Id : Entity_Id);\n             --  Chain pragma Contract_Cases to the contract of a subprogram.\n-            --  Subp_Decl is the declaration of the subprogram.\n+            --  Subp_Id is the related subprogram.\n+\n+            ---------------------------\n+            -- Analyze_Contract_Case --\n+            ---------------------------\n+\n+            procedure Analyze_Contract_Case (Contract_Case : Node_Id) is\n+               Case_Guard  : Node_Id;\n+               Extra_Guard : Node_Id;\n+\n+            begin\n+               if Nkind (Contract_Case) = N_Component_Association then\n+                  Case_Guard := First (Choices (Contract_Case));\n+\n+                  --  Each contract case must have exactly on case guard\n+\n+                  Extra_Guard := Next (Case_Guard);\n+\n+                  if Present (Extra_Guard) then\n+                     Error_Pragma_Arg\n+                       (\"contract case may have only one case guard\",\n+                        Extra_Guard);\n+                  end if;\n+\n+                  --  Check the placement of \"others\" (if available)\n+\n+                  if Nkind (Case_Guard) = N_Others_Choice then\n+                     if Others_Seen then\n+                        Error_Pragma_Arg\n+                          (\"only one others choice allowed in pragma %\",\n+                           Case_Guard);\n+                     else\n+                        Others_Seen := True;\n+                     end if;\n+\n+                  elsif Others_Seen then\n+                     Error_Pragma_Arg\n+                       (\"others must be the last choice in pragma %\", N);\n+                  end if;\n+\n+               --  The contract case is malformed\n+\n+               else\n+                  Error_Pragma_Arg\n+                    (\"wrong syntax in contract case\", Contract_Case);\n+               end if;\n+            end Analyze_Contract_Case;\n \n             --------------------------\n             -- Chain_Contract_Cases --\n             --------------------------\n \n-            procedure Chain_Contract_Cases (Subp_Decl : Node_Id) is\n-               Subp : constant Entity_Id :=\n-                        Defining_Unit_Name (Specification (Subp_Decl));\n-               CTC  : Node_Id;\n+            procedure Chain_Contract_Cases (Subp_Id : Entity_Id) is\n+               CTC : Node_Id;\n \n             begin\n-               Check_Duplicate_Pragma (Subp);\n-               CTC := Spec_CTC_List (Contract (Subp));\n+               Check_Duplicate_Pragma (Subp_Id);\n+               CTC := Spec_CTC_List (Contract (Subp_Id));\n                while Present (CTC) loop\n                   if Chars (Pragma_Identifier (CTC)) = Pname then\n                      Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc := Sloc (CTC);\n+                     Error_Msg_Sloc   := Sloc (CTC);\n \n                      if From_Aspect_Specification (CTC) then\n                         Error_Msg_NE\n-                          (\"aspect% for & previously given#\", N, Subp);\n+                          (\"aspect% for & previously given#\", N, Subp_Id);\n                      else\n                         Error_Msg_NE\n-                          (\"pragma% for & duplicates pragma#\", N, Subp);\n+                          (\"pragma% for & duplicates pragma#\", N, Subp_Id);\n                      end if;\n \n                      raise Pragma_Exit;\n@@ -8665,18 +8714,18 @@ package body Sem_Prag is\n \n                --  Prepend pragma Contract_Cases to the contract\n \n-               Set_Next_Pragma (N, Spec_CTC_List (Contract (Subp)));\n-               Set_Spec_CTC_List (Contract (Subp), N);\n+               Set_Next_Pragma (N, Spec_CTC_List (Contract (Subp_Id)));\n+               Set_Spec_CTC_List (Contract (Subp_Id), N);\n             end Chain_Contract_Cases;\n \n             --  Local variables\n \n-            Case_Guard    : Node_Id;\n+            Context       : constant Node_Id := Parent (N);\n+            All_Cases     : Node_Id;\n             Decl          : Node_Id;\n-            Extra         : Node_Id;\n-            Others_Seen   : Boolean := False;\n             Contract_Case : Node_Id;\n             Subp_Decl     : Node_Id;\n+            Subp_Id       : Entity_Id;\n \n          --  Start of processing for Contract_Cases\n \n@@ -8698,91 +8747,94 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n             end if;\n \n-            --  Pragma Contract_Cases must be associated with a subprogram\n+            --  Aspect/pragma Contract_Cases may be associated with a library\n+            --  level subprogram.\n \n-            Decl := N;\n-            while Present (Prev (Decl)) loop\n-               Decl := Prev (Decl);\n+            if Nkind (Context) = N_Compilation_Unit_Aux then\n+               Subp_Decl := Unit (Parent (Context));\n \n-               if Nkind (Decl) in N_Generic_Declaration then\n-                  Subp_Decl := Decl;\n-               else\n-                  Subp_Decl := Original_Node (Decl);\n+               if not Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n+                                           N_Subprogram_Declaration)\n+               then\n+                  Pragma_Misplaced;\n                end if;\n \n-               --  Skip prior pragmas\n+               Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n \n-               if Nkind (Subp_Decl) = N_Pragma then\n-                  null;\n-\n-               --  Skip internally generated code\n-\n-               elsif not Comes_From_Source (Subp_Decl) then\n-                  null;\n-\n-               --  We have found the related subprogram\n+            --  The aspect/pragma appears in a subprogram body. The placement\n+            --  is legal when the body acts as a spec.\n \n-               elsif Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n-                                          N_Subprogram_Declaration)\n-               then\n-                  exit;\n+            elsif Nkind (Context) = N_Subprogram_Body then\n+               Subp_Id := Defining_Unit_Name (Specification (Context));\n \n-               else\n-                  Pragma_Misplaced;\n+               if Ekind (Subp_Id) = E_Subprogram_Body then\n+                  Error_Pragma\n+                    (\"pragma % may not appear in a subprogram body that acts \"\n+                     & \"as completion\");\n                end if;\n-            end loop;\n \n-            --  All contract cases must appear as an aggregate\n+            --  Nested subprogram case, the aspect/pragma must apply to the\n+            --  subprogram spec.\n \n-            if Nkind (Expression (Arg1)) /= N_Aggregate then\n-               Error_Pragma (\"wrong syntax for pragma %\");\n-               return;\n-            end if;\n+            else\n+               Decl := N;\n+               while Present (Prev (Decl)) loop\n+                  Decl := Prev (Decl);\n \n-            --  Verify the legality of individual contract cases\n+                  if Nkind (Decl) in N_Generic_Declaration then\n+                     Subp_Decl := Decl;\n+                  else\n+                     Subp_Decl := Original_Node (Decl);\n+                  end if;\n \n-            Contract_Case :=\n-              First (Component_Associations (Expression (Arg1)));\n-            while Present (Contract_Case) loop\n-               if Nkind (Contract_Case) /= N_Component_Association then\n-                  Error_Pragma_Arg\n-                    (\"wrong syntax in contract case\", Contract_Case);\n-                  return;\n-               end if;\n+                  --  Skip prior pragmas\n \n-               Case_Guard := First (Choices (Contract_Case));\n+                  if Nkind (Subp_Decl) = N_Pragma then\n+                     null;\n \n-               --  Each contract case must have exactly on case guard\n+                  --  Skip internally generated code\n \n-               Extra := Next (Case_Guard);\n-               if Present (Extra) then\n-                  Error_Pragma_Arg\n-                    (\"contract case may have only one case guard\", Extra);\n-                  return;\n-               end if;\n+                  elsif not Comes_From_Source (Subp_Decl) then\n+                     null;\n \n-               --  Check the placement of \"others\" (if available)\n+                  --  We have found the related subprogram\n+\n+                  elsif Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n+                                             N_Subprogram_Declaration)\n+                  then\n+                     exit;\n \n-               if Nkind (Case_Guard) = N_Others_Choice then\n-                  if Others_Seen then\n-                     Error_Pragma_Arg\n-                       (\"only one others choice allowed in pragma %\",\n-                        Case_Guard);\n-                     return;\n                   else\n-                     Others_Seen := True;\n+                     Pragma_Misplaced;\n                   end if;\n+               end loop;\n \n-               elsif Others_Seen then\n-                  Error_Pragma_Arg\n-                    (\"others must be the last choice in pragma %\", N);\n-                  return;\n-               end if;\n+               Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n+            end if;\n \n-               Next (Contract_Case);\n-            end loop;\n+            All_Cases := Expression (Arg1);\n+\n+            --  Multiple contract cases appear in aggregate form\n+\n+            if Nkind (All_Cases) = N_Aggregate then\n+               if No (Component_Associations (All_Cases)) then\n+                  Error_Pragma (\"wrong syntax for pragma %\");\n+\n+               --  Individual contract cases appear as component associations\n+\n+               else\n+                  Contract_Case := First (Component_Associations (All_Cases));\n+                  while Present (Contract_Case) loop\n+                     Analyze_Contract_Case (Contract_Case);\n+\n+                     Next (Contract_Case);\n+                  end loop;\n+               end if;\n+            else\n+               Error_Pragma (\"wrong syntax for pragma %\");\n+            end if;\n \n-            Chain_Contract_Cases (Subp_Decl);\n+            Chain_Contract_Cases (Subp_Id);\n          end Contract_Cases;\n \n          ----------------"}]}