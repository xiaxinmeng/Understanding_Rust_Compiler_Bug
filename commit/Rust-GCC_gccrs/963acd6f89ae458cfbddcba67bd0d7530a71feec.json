{"sha": "963acd6f89ae458cfbddcba67bd0d7530a71feec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYzYWNkNmY4OWFlNDU4Y2ZiZGRjYmE2N2JkMGQ3NTMwYTcxZmVlYw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-01-22T13:57:01Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-01-22T13:57:01Z"}, "message": "re PR tree-optimization/26854 (Inordinate compile times on large routines)\n\n2008-01-22  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/26854\n\tPR rtl-optimization/34400\n\tPR rtl-optimization/34884\n\t* ddg.c (create_ddg_dep_from_intra_loop_link): Use\n\tDF_RD->gen.\n\t* df.h (df_changeable_flags.DF_RD_NO_TRIM): Deleted\n\t(df_rd_bb_info.expanded_lr_out): Deleted\n\t* loop_invariant.c (find_defs): Deleted DF_RD_NO_TRIM flag.\n\t* loop_iv.c (iv_analysis_loop_init): Ditto.  * df-problems.c\n\t(df_rd_free_bb_info, df_rd_alloc, df_rd_confluence_n,\n\tdf_rd_bb_local_compute, df_rd_transfer_function, df_rd_free):\n\tRemoved code to allocate, initialize or free expanded_lr_out.\n\t(df_rd_bb_local_compute_process_def): Restructured to make more\n\tunderstandable.\n\t(df_rd_confluence_n): Removed code to no apply invalidate_by_call\n\tsets if the sets are being trimmed.\n\nFrom-SVN: r131719", "tree": {"sha": "ebfe2c3b0f60689e131c3a7a378e9b4a90660f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebfe2c3b0f60689e131c3a7a378e9b4a90660f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/963acd6f89ae458cfbddcba67bd0d7530a71feec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963acd6f89ae458cfbddcba67bd0d7530a71feec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/963acd6f89ae458cfbddcba67bd0d7530a71feec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963acd6f89ae458cfbddcba67bd0d7530a71feec/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "115e6e5572d2fe0fddf7ed3bba2fa692461e8a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115e6e5572d2fe0fddf7ed3bba2fa692461e8a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115e6e5572d2fe0fddf7ed3bba2fa692461e8a0a"}], "stats": {"total": 200, "additions": 77, "deletions": 123}, "files": [{"sha": "639b0fbedcd3b80969c49b2e0d4091a4f7cba75d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -1,3 +1,22 @@\n+2008-01-22  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/26854\n+\tPR rtl-optimization/34400\n+\tPR rtl-optimization/34884\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): Use\n+\tDF_RD->gen.\n+\t* df.h (df_changeable_flags.DF_RD_NO_TRIM): Deleted\n+\t(df_rd_bb_info.expanded_lr_out): Deleted\n+\t* loop_invariant.c (find_defs): Deleted DF_RD_NO_TRIM flag.\n+\t* loop_iv.c (iv_analysis_loop_init): Ditto.  * df-problems.c\n+\t(df_rd_free_bb_info, df_rd_alloc, df_rd_confluence_n,\n+\tdf_rd_bb_local_compute, df_rd_transfer_function, df_rd_free):\n+\tRemoved code to allocate, initialize or free expanded_lr_out.\n+\t(df_rd_bb_local_compute_process_def): Restructured to make more\n+\tunderstandable.\n+\t(df_rd_confluence_n): Removed code to no apply invalidate_by_call\n+\tsets if the sets are being trimmed.\n+\n 2008-01-22  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/32287"}, {"sha": "14b18745823752615eeeb264eaf23121f3f83f59", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -184,13 +184,12 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n         {\n           int regno = REGNO (SET_DEST (set));\n           struct df_ref *first_def;\n-          struct df_ref *last_def;\n+          struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n \n           first_def = df_bb_regno_first_def_find (g->bb, regno);\n           gcc_assert (first_def);\n \n-          last_def = df_bb_regno_last_def_find (g->bb, regno);\n-          if (first_def == last_def)\n+          if (bitmap_bit_p (bb_info->gen, first_def->id))\n             return;\n         }\n     }"}, {"sha": "46aa9e03f4c07df2ce0ae5d72b9408eb4e13ae29", "filename": "gcc/df-problems.c", "status": "modified", "additions": 49, "deletions": 76, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -245,8 +245,6 @@ df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n   struct df_rd_bb_info *bb_info = (struct df_rd_bb_info *) vbb_info;\n   if (bb_info)\n     {\n-      if (bb_info->expanded_lr_out)\n-\tBITMAP_FREE (bb_info->expanded_lr_out);\n       BITMAP_FREE (bb_info->kill);\n       BITMAP_FREE (bb_info->sparse_kill);\n       BITMAP_FREE (bb_info->gen);\n@@ -300,8 +298,6 @@ df_rd_alloc (bitmap all_blocks)\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       if (bb_info)\n \t{ \n-\t  if (bb_info->expanded_lr_out)\n-\t    bitmap_clear (bb_info->expanded_lr_out);\n \t  bitmap_clear (bb_info->kill);\n \t  bitmap_clear (bb_info->sparse_kill);\n \t  bitmap_clear (bb_info->gen);\n@@ -310,10 +306,6 @@ df_rd_alloc (bitmap all_blocks)\n \t{ \n \t  bb_info = (struct df_rd_bb_info *) pool_alloc (df_rd->block_pool);\n \t  df_rd_set_bb_info (bb_index, bb_info);\n-\t  if (df->changeable_flags & DF_RD_NO_TRIM)\n-\t    bb_info->expanded_lr_out = NULL;\n-\t  else\n-\t    bb_info->expanded_lr_out = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->sparse_kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t  bb_info->gen = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n@@ -328,53 +320,56 @@ df_rd_alloc (bitmap all_blocks)\n /* Process a list of DEFs for df_rd_bb_local_compute.  */\n \n static void\n-df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n+df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n \t\t\t\t    struct df_ref **def_rec,\n \t\t\t\t    enum df_ref_flags top_flag)\n {\n-  for (; *def_rec; def_rec++)\n+  while (*def_rec)\n     {\n       struct df_ref *def = *def_rec;\n-      unsigned int regno = DF_REF_REGNO (def);\n-\n-      /* This makes sure we do the artificial defs in the right order\n-\t since they are all in the same list.  */\n-      if (top_flag != (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n-\tcontinue;\n-\n-      /* Skip over the hard regs if we do not care about them.  */\n-      if ((df->changeable_flags & DF_NO_HARD_REGS) && \n-\t  (regno < FIRST_PSEUDO_REGISTER))\n-\tcontinue;\n-\n-      /* Only the last def(s) for a regno in the block has any\n-\t effect.  */ \n-      if (bitmap_bit_p (seen_in_block, regno))\n-\tcontinue;\n-\n-      /* The first def for regno in insn gets to knock out the\n-\t defs from other instructions.  */\n-      if ((!bitmap_bit_p (seen_in_insn, regno))\n-\t  /* If the def is to only part of the reg, it does\n-\t     not kill the other defs that reach here.  */\n-\t  && (!(DF_REF_FLAGS (def) & \n-\t\t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))))\n+      if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n+\t  unsigned int regno = DF_REF_REGNO (def);\n \t  unsigned int begin = DF_DEFS_BEGIN (regno);\n \t  unsigned int n_defs = DF_DEFS_COUNT (regno);\n-\t  if (n_defs > DF_SPARSE_THRESHOLD)\n-\t    bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t  else\n-\t    bitmap_set_range (bb_info->kill, begin, n_defs);\n-\t  bitmap_clear_range(bb_info->gen, begin, n_defs);\n+\t  \n+\t  if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n+\t      || (regno >= FIRST_PSEUDO_REGISTER))\n+\t    {\n+\t      /* Only the last def(s) for a regno in the block has any\n+\t\t effect.  */ \n+\t      if (!bitmap_bit_p (seen_in_block, regno))\n+\t\t{\n+\t\t  /* The first def for regno in insn gets to knock out the\n+\t\t     defs from other instructions.  */\n+\t\t  if ((!bitmap_bit_p (seen_in_insn, regno))\n+\t\t      /* If the def is to only part of the reg, it does\n+\t\t\t not kill the other defs that reach here.  */\n+\t\t      && (!(DF_REF_FLAGS (def) & \n+\t\t\t    (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))))\n+\t\t    {\n+\t\t      if (n_defs > DF_SPARSE_THRESHOLD)\n+\t\t\t{\n+\t\t\t  bitmap_set_bit (bb_info->sparse_kill, regno);\n+\t\t\t  bitmap_clear_range(bb_info->gen, begin, n_defs);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  bitmap_set_range (bb_info->kill, begin, n_defs);\n+\t\t\t  bitmap_clear_range (bb_info->gen, begin, n_defs);\n+\t\t\t}\n+\t\t    }\n+\t\t  \n+\t\t  bitmap_set_bit (seen_in_insn, regno);\n+\t\t  /* All defs for regno in the instruction may be put into\n+\t\t     the gen set.  */\n+\t\t  if (!(DF_REF_FLAGS (def) \n+\t\t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n+\t\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n+\t\t}\n+\t    }\n \t}\n-      \n-      bitmap_set_bit (seen_in_insn, regno);\n-      /* All defs for regno in the instruction may be put into\n-\t the gen set.  */\n-      if (!(DF_REF_FLAGS (def) \n-\t    & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n-\tbitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n+      def_rec++;\n     }\n }\n \n@@ -385,28 +380,14 @@ df_rd_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n-  struct df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n   rtx insn;\n \n   bitmap_clear (seen_in_block);\n   bitmap_clear (seen_in_insn);\n \n-  if (!(df->changeable_flags & DF_RD_NO_TRIM))\n-    {\n-      unsigned int regno;\n-      bitmap_iterator bi;\n-      int first_reg = (df->changeable_flags & DF_NO_HARD_REGS) ? FIRST_PSEUDO_REGISTER : 0;\n-      EXECUTE_IF_SET_IN_BITMAP (lr_bb_info->out, first_reg, regno, bi)\n-\t{\n-\t  unsigned int begin = DF_DEFS_BEGIN (regno);\n-\t  unsigned int n_defs = DF_DEFS_COUNT (regno);\n-\t  bitmap_set_range (bb_info->expanded_lr_out, begin, n_defs);\n-\t}\n-    }\n-\n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_rd_bb_local_compute_process_def (bb_info,\n+    df_rd_bb_local_compute_process_def (bb_info, \n \t\t\t\t\tdf_get_artificial_defs (bb_index),\n \t\t\t\t\t0);\n \n@@ -504,18 +485,15 @@ df_rd_confluence_n (edge e)\n   if (e->flags & EDGE_FAKE) \n     return;\n \n-  /* If we are trimming the solution, the invalidated_by_call code in\n-     the lr problem makes this unnecessary.  However, if we do not\n-     trim, we must take this into account.  */\n-  if ((df->changeable_flags & DF_RD_NO_TRIM) && e->flags & EDGE_EH)\n+  if (e->flags & EDGE_EH)\n     {\n       struct df_rd_problem_data *problem_data\n \t= (struct df_rd_problem_data *) df_rd->problem_data;\n       bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n       bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap tmp = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n+      bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n \n       bitmap_copy (tmp, op2);\n       bitmap_and_compl_into (tmp, dense_invalidated);\n@@ -547,13 +525,13 @@ df_rd_transfer_function (int bb_index)\n   bitmap gen = bb_info->gen;\n   bitmap kill = bb_info->kill;\n   bitmap sparse_kill = bb_info->sparse_kill;\n-  bool changed = false;\n \n-  if ((df->changeable_flags & DF_RD_NO_TRIM) && bitmap_empty_p (sparse_kill))\n-    changed = bitmap_ior_and_compl (out, gen, in, kill);\n+  if (bitmap_empty_p (sparse_kill))\n+    return  bitmap_ior_and_compl (out, gen, in, kill);\n   else \n     {\n       struct df_rd_problem_data *problem_data;\n+      bool changed = false;\n       bitmap tmp;\n \n       /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n@@ -570,19 +548,16 @@ df_rd_transfer_function (int bb_index)\n \t}\n       bitmap_and_compl_into (tmp, kill);\n       bitmap_ior_into (tmp, gen);\n-      if (!(df->changeable_flags & DF_RD_NO_TRIM))\n-\tbitmap_and_into (tmp, bb_info->expanded_lr_out);\n       changed = !bitmap_equal_p (tmp, out);\n       if (changed)\n \t{\n \t  BITMAP_FREE (out);\n \t  bb_info->out = tmp;\n \t}\n       else \n-\tBITMAP_FREE (tmp);\n+\t  BITMAP_FREE (tmp);\n+      return changed;\n     }\n-\n-  return changed;\n }\n \n \n@@ -602,8 +577,6 @@ df_rd_free (void)\n \t  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (i);\n \t  if (bb_info)\n \t    {\n-\t      if (bb_info->expanded_lr_out)\n-\t\tBITMAP_FREE (bb_info->expanded_lr_out);\n \t      BITMAP_FREE (bb_info->kill);\n \t      BITMAP_FREE (bb_info->sparse_kill);\n \t      BITMAP_FREE (bb_info->gen);"}, {"sha": "8beadc98d4c88ac85910d0e77db11c2b9c985c58", "filename": "gcc/df.h", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -405,27 +405,20 @@ enum df_changeable_flags\n   DF_LR_RUN_DCE           = 1 << 0, /* Run DCE.  */\n   DF_NO_HARD_REGS         = 1 << 1, /* Skip hard registers in RD and CHAIN Building.  */\n \n-  /* Do not trim the solution using the LR result.  This can make the\n-     solution take much longer and take more memory.  This is\n-     necessary for the loop optimizations, but has a very small time\n-     and space penalty because the loop optimizations process only a\n-     single loop at a time.  Any pass that looks at the entire\n-     function should not set this flag.  */\n-  DF_RD_NO_TRIM           = 1 << 2,\n-  DF_EQ_NOTES             = 1 << 3, /* Build chains with uses present in EQUIV/EQUAL notes. */\n-  DF_NO_REGS_EVER_LIVE    = 1 << 4, /* Do not compute the regs_ever_live.  */\n+  DF_EQ_NOTES             = 1 << 2, /* Build chains with uses present in EQUIV/EQUAL notes. */\n+  DF_NO_REGS_EVER_LIVE    = 1 << 3, /* Do not compute the regs_ever_live.  */\n \n   /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n   return immediately.  This is used by passes that know how to update\n   the scanning them selves.  */\n-  DF_NO_INSN_RESCAN       = 1 << 5,\n+  DF_NO_INSN_RESCAN       = 1 << 4,\n \n   /* Cause df_insn_rescan df_notes_rescan and df_insn_delete, to\n   return after marking the insn for later processing.  This allows all\n   rescans to be batched.  */\n-  DF_DEFER_INSN_RESCAN    = 1 << 6,\n+  DF_DEFER_INSN_RESCAN    = 1 << 5,\n \n-  DF_VERIFY_SCHEDULED     = 1 << 7\n+  DF_VERIFY_SCHEDULED     = 1 << 6\n };\n \n /* Two of these structures are inline in df, one for the uses and one\n@@ -719,37 +712,9 @@ struct df_rd_bb_info\n   /* Local sets to describe the basic blocks.   */\n   bitmap kill;  \n   bitmap sparse_kill;\n+  bitmap gen;   /* The set of defs generated in this block.  */\n \n-  /* Expanded version of the DF_LT->out bitmap to match the positions\n-     of gen, in and out here.  Only allocated if DF_RD_NO_TRIM is\n-     false.  */\n-  bitmap expanded_lr_out;\n-\n-  /* The set of defs generated in this block.  This is not set unless\n-     the def reaches the end of the block.  */\n-  bitmap gen;\n-\n-  /* The results of the dataflow problem.  \n-\n-     If DF_RD_NO_TRIM is not set, these sets are SOMEWHAT trimmed by\n-     the output of the DF_LR problem.  The out set is precisely\n-     trimmed during propagation which means that the result is also\n-     trimmed when the propagation terminates.  The in set is not\n-     explicitly trimmed, because this is expensive (adding about 5% to\n-     the cost of a bootstrap).  However since the out sets are trimmed\n-     and the in sets are built from the out of the pred, the in set is\n-     MOSTLY trimmed.\n-\n-     The counter case happens at a branch where the variable V is in\n-     DF_LR->in the true branch but not the false branch.  If V is\n-     defined before the branch, RD will propagate that into the\n-     DF_RD_in sets of both branches.  When the block is processed, the\n-     DF_RD->out set will have V trimmed out of it but it will still be\n-     left in DF_RD->in.  \n-\n-     If this not a problem for the current optimizers since they were\n-     designed before any trimming was available.  This can be fixed by\n-     checking the DF_LR->in set directly.  */\n+  /* The results of the dataflow problem.  */\n   bitmap in;    /* At the top of the block.  */\n   bitmap out;   /* At the bottom of the block.  */\n };"}, {"sha": "ba1f2888b009677bdaf01e91171d67395bcfea86", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -639,7 +639,6 @@ find_defs (struct loop *loop, basic_block *body)\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n-  df_set_flags (DF_RD_NO_TRIM);\n   df_set_blocks (blocks);\n   df_analyze ();\n "}, {"sha": "b7b1cd32ec0a76e72f6ca426becb54ac138e562a", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963acd6f89ae458cfbddcba67bd0d7530a71feec/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=963acd6f89ae458cfbddcba67bd0d7530a71feec", "patch": "@@ -278,7 +278,6 @@ iv_analysis_loop_init (struct loop *loop)\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n-  df_set_flags (DF_RD_NO_TRIM);\n   df_set_blocks (blocks);\n   df_analyze ();\n   if (dump_file)"}]}