{"sha": "d198b59ab12557edbafc2bba595f855caccfc6ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5OGI1OWFiMTI1NTdlZGJhZmMyYmJhNTk1Zjg1NWNhY2NmYzZlYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-29T15:31:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-29T15:31:39Z"}, "message": "[multiple changes]\n\n2005-04-29  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR fortran/13082\n\tPR fortran/18824\n\t* trans-expr.c (gfc_conv_variable): Handle return values in functions\n\twith alternate entry points.\n\t* resolve.c (resolve_entries): Remove unnecessary string termination\n\tafter snprintf.  Set result of entry master.\n\tIf all entries have the same type, set entry master's type\n\tto that common type, otherwise set mixed_entry_master attribute.\n\t* trans-types.c (gfc_get_mixed_entry_union): New function.\n\t(gfc_get_function_type): Use it for mixed_entry_master functions.\n\t* gfortran.h (symbol_attribute): Add mixed_entry_master bit.\n\t* decl.c (gfc_match_entry): Set entry->result properly for\n\tfunction ENTRY.\n\t* trans-decl.c (gfc_get_symbol_decl): For entry_master, skip over\n\t__entry argument.\n\t(build_entry_thunks): Handle return values in entry thunks.\n\tClear BT_CHARACTER's ts.cl->backend_decl, so that it is not\n\tshared between multiple contexts.\n\t(gfc_get_fake_result_decl): Use DECL_ARGUMENTS from\n\tcurrent_function_decl instead of sym->backend_decl.  Skip over\n\tentry master's entry id argument.  For mixed_entry_master entries or\n\ttheir results, return a COMPONENT_REF of the fake result.\n\t(gfc_trans_deferred_vars): Don't warn about missing return value if\n\tat least one entry point uses RESULT.\n\t(gfc_generate_function_code): For entry master returning\n\tCHARACTER, copy ts.cl->backend_decl to all entry result syms.\n\t* trans-array.c (gfc_trans_dummy_array_bias): Don't consider return\n\tvalues optional just because they are in entry master.\n\n\t* gfortran.dg/entry_4.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_1.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_2.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_3.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_4.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_5.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_6.f90: New test.\n\t* gfortran.fortran-torture/execute/entry_7.f90: New test.\n\n2005-04-29  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n\n\t* gfortran.fortran-torture/execute/entry_8.f90: New test.\n\nFrom-SVN: r98993", "tree": {"sha": "d2859b3b62d8719bdc1d462cb30cdea8235bea87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2859b3b62d8719bdc1d462cb30cdea8235bea87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d198b59ab12557edbafc2bba595f855caccfc6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d198b59ab12557edbafc2bba595f855caccfc6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d198b59ab12557edbafc2bba595f855caccfc6ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d198b59ab12557edbafc2bba595f855caccfc6ec/comments", "author": null, "committer": null, "parents": [{"sha": "be12e697e42187347dffea36e37db82cf04d37a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be12e697e42187347dffea36e37db82cf04d37a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be12e697e42187347dffea36e37db82cf04d37a5"}], "stats": {"total": 917, "additions": 889, "deletions": 28}, "files": [{"sha": "be24ec7658f60d0239ab43e75b6dafd027edf8ad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -1,3 +1,34 @@\n+2005-04-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/13082\n+\tPR fortran/18824\n+\t* trans-expr.c (gfc_conv_variable): Handle return values in functions\n+\twith alternate entry points.\n+\t* resolve.c (resolve_entries): Remove unnecessary string termination\n+\tafter snprintf.  Set result of entry master.\n+\tIf all entries have the same type, set entry master's type\n+\tto that common type, otherwise set mixed_entry_master attribute.\n+\t* trans-types.c (gfc_get_mixed_entry_union): New function.\n+\t(gfc_get_function_type): Use it for mixed_entry_master functions.\n+\t* gfortran.h (symbol_attribute): Add mixed_entry_master bit.\n+\t* decl.c (gfc_match_entry): Set entry->result properly for\n+\tfunction ENTRY.\n+\t* trans-decl.c (gfc_get_symbol_decl): For entry_master, skip over\n+\t__entry argument.\n+\t(build_entry_thunks): Handle return values in entry thunks.\n+\tClear BT_CHARACTER's ts.cl->backend_decl, so that it is not\n+\tshared between multiple contexts.\n+\t(gfc_get_fake_result_decl): Use DECL_ARGUMENTS from\n+\tcurrent_function_decl instead of sym->backend_decl.  Skip over\n+\tentry master's entry id argument.  For mixed_entry_master entries or\n+\ttheir results, return a COMPONENT_REF of the fake result.\n+\t(gfc_trans_deferred_vars): Don't warn about missing return value if\n+\tat least one entry point uses RESULT.\n+\t(gfc_generate_function_code): For entry master returning\n+\tCHARACTER, copy ts.cl->backend_decl to all entry result syms.\n+\t* trans-array.c (gfc_trans_dummy_array_bias): Don't consider return\n+\tvalues optional just because they are in entry master.\n+\n 2005-04-29  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.h (gfc_namespace): Add seen_implicit_none field,"}, {"sha": "2b763d296ab329864a6ca81d99c62c63c1ce6bfd", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -2407,8 +2407,7 @@ gfc_match_entry (void)\n \t      || gfc_add_function (&entry->attr, entry->name, NULL) == FAILURE)\n \t    return MATCH_ERROR;\n \n-\t  entry->result = proc->result;\n-\n+\t  entry->result = entry;\n \t}\n       else\n \t{\n@@ -2423,6 +2422,8 @@ gfc_match_entry (void)\n \t      || gfc_add_function (&entry->attr, result->name,\n \t\t\t\t   NULL) == FAILURE)\n \t    return MATCH_ERROR;\n+\n+\t  entry->result = result;\n \t}\n \n       if (proc->attr.recursive && result == NULL)"}, {"sha": "641e492ba648a8c56ce1f3534a974cb43ace8b88", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -431,6 +431,9 @@ typedef struct\n   /* Set if this is the master function for a procedure with multiple\n      entry points.  */\n   unsigned entry_master:1;\n+  /* Set if this is the master function for a function with multiple\n+     entry points where characteristics of the entry points differ.  */\n+  unsigned mixed_entry_master:1;\n \n   /* Set if a function must always be referenced by an explicit interface.  */\n   unsigned always_explicit:1;"}, {"sha": "9b097fe9a15b379d61df2112893a5489d3fb2786", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -360,7 +360,6 @@ resolve_entries (gfc_namespace * ns)\n      out what is going on.  */\n   snprintf (name, GFC_MAX_SYMBOL_LEN, \"master.%d.%s\",\n \t    master_count++, ns->proc_name->name);\n-  name[GFC_MAX_SYMBOL_LEN] = '\\0';\n   gfc_get_ha_symbol (name, &proc);\n   gcc_assert (proc != NULL);\n \n@@ -369,8 +368,88 @@ resolve_entries (gfc_namespace * ns)\n     gfc_add_subroutine (&proc->attr, proc->name, NULL);\n   else\n     {\n+      gfc_symbol *sym;\n+      gfc_typespec *ts, *fts;\n+\n       gfc_add_function (&proc->attr, proc->name, NULL);\n-      gfc_internal_error (\"TODO: Functions with alternate entry points\");\n+      proc->result = proc;\n+      fts = &ns->entries->sym->result->ts;\n+      if (fts->type == BT_UNKNOWN)\n+\tfts = gfc_get_default_type (ns->entries->sym->result, NULL);\n+      for (el = ns->entries->next; el; el = el->next)\n+\t{\n+\t  ts = &el->sym->result->ts;\n+\t  if (ts->type == BT_UNKNOWN)\n+\t    ts = gfc_get_default_type (el->sym->result, NULL);\n+\t  if (! gfc_compare_types (ts, fts)\n+\t      || (el->sym->result->attr.dimension\n+\t\t  != ns->entries->sym->result->attr.dimension)\n+\t      || (el->sym->result->attr.pointer\n+\t\t  != ns->entries->sym->result->attr.pointer))\n+\t    break;\n+\t}\n+\n+      if (el == NULL)\n+\t{\n+\t  sym = ns->entries->sym->result;\n+\t  /* All result types the same.  */\n+\t  proc->ts = *fts;\n+\t  if (sym->attr.dimension)\n+\t    gfc_set_array_spec (proc, gfc_copy_array_spec (sym->as), NULL);\n+\t  if (sym->attr.pointer)\n+\t    gfc_add_pointer (&proc->attr, NULL);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise the result will be passed through an union by\n+\t     reference.  */\n+\t  proc->attr.mixed_entry_master = 1;\n+\t  for (el = ns->entries; el; el = el->next)\n+\t    {\n+\t      sym = el->sym->result;\n+\t      if (sym->attr.dimension)\n+\t\tgfc_error (\"%s result %s can't be an array in FUNCTION %s at %L\",\n+\t\t\t   el == ns->entries ? \"FUNCTION\" : \"ENTRY\", sym->name,\n+\t\t\t   ns->entries->sym->name, &sym->declared_at);\n+\t      else if (sym->attr.pointer)\n+\t\tgfc_error (\"%s result %s can't be a POINTER in FUNCTION %s at %L\",\n+\t\t\t   el == ns->entries ? \"FUNCTION\" : \"ENTRY\", sym->name,\n+\t\t\t   ns->entries->sym->name, &sym->declared_at);\n+\t      else\n+\t\t{\n+\t\t  ts = &sym->ts;\n+\t\t  if (ts->type == BT_UNKNOWN)\n+\t\t    ts = gfc_get_default_type (sym, NULL);\n+\t\t  switch (ts->type)\n+\t\t    {\n+\t\t    case BT_INTEGER:\n+\t\t      if (ts->kind == gfc_default_integer_kind)\n+\t\t\tsym = NULL;\n+\t\t      break;\n+\t\t    case BT_REAL:\n+\t\t      if (ts->kind == gfc_default_real_kind\n+\t\t\t  || ts->kind == gfc_default_double_kind)\n+\t\t\tsym = NULL;\n+\t\t      break;\n+\t\t    case BT_COMPLEX:\n+\t\t      if (ts->kind == gfc_default_complex_kind)\n+\t\t\tsym = NULL;\n+\t\t      break;\n+\t\t    case BT_LOGICAL:\n+\t\t      if (ts->kind == gfc_default_logical_kind)\n+\t\t\tsym = NULL;\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t  if (sym)\n+\t\t    gfc_error (\"%s result %s can't be of type %s in FUNCTION %s at %L\",\n+\t\t\t       el == ns->entries ? \"FUNCTION\" : \"ENTRY\", sym->name,\n+\t\t\t       gfc_typename (ts), ns->entries->sym->name,\n+\t\t\t       &sym->declared_at);\n+\t\t}\n+\t    }\n+\t}\n     }\n   proc->attr.access = ACCESS_PRIVATE;\n   proc->attr.entry_master = 1;"}, {"sha": "87e37ea63088e0d878e92f4967ef73f02c6d08cf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -3373,7 +3373,9 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   /* Only do the entry/initialization code if the arg is present.  */\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-  optional_arg = sym->attr.optional || sym->ns->proc_name->attr.entry_master;\n+  optional_arg = (sym->attr.optional\n+\t\t  || (sym->ns->proc_name->attr.entry_master\n+\t\t      && sym->attr.dummy));\n   if (optional_arg)\n     {\n       tmp = gfc_conv_expr_present (sym);"}, {"sha": "d5075b9067a96af8a383def790bf732504e2d5a2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 124, "deletions": 13, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -736,6 +736,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t{\n \t  sym->backend_decl =\n \t    DECL_ARGUMENTS (sym->ns->proc_name->backend_decl);\n+\t  /* For entry master function skip over the __entry\n+\t     argument.  */\n+\t  if (sym->ns->proc_name->attr.entry_master)\n+\t    sym->backend_decl = TREE_CHAIN (sym->backend_decl);\n \t}\n \n       /* Dummy variables should already have been created.  */\n@@ -1371,12 +1375,24 @@ build_entry_thunks (gfc_namespace * ns)\n       args = tree_cons (NULL_TREE, tmp, NULL_TREE);\n       string_args = NULL_TREE;\n \n-      /* TODO: Pass return by reference parameters.  */\n-      if (ns->proc_name->attr.function)\n-\tgfc_todo_error (\"Functons with multiple entry points\");\n-      \n+      if (thunk_sym->attr.function)\n+\t{\n+\t  if (gfc_return_by_reference (ns->proc_name))\n+\t    {\n+\t      tree ref = DECL_ARGUMENTS (current_function_decl);\n+\t      args = tree_cons (NULL_TREE, ref, args);\n+\t      if (ns->proc_name->ts.type == BT_CHARACTER)\n+\t\targs = tree_cons (NULL_TREE, TREE_CHAIN (ref),\n+\t\t\t\t  args);\n+\t    }\n+\t}\n+\n       for (formal = ns->proc_name->formal; formal; formal = formal->next)\n \t{\n+\t  /* Ignore alternate returns.  */\n+\t  if (formal->sym == NULL)\n+\t    continue;\n+\n \t  /* We don't have a clever way of identifying arguments, so resort to\n \t     a brute-force search.  */\n \t  for (thunk_formal = thunk_sym->formal;\n@@ -1415,7 +1431,47 @@ build_entry_thunks (gfc_namespace * ns)\n       args = chainon (args, nreverse (string_args));\n       tmp = ns->proc_name->backend_decl;\n       tmp = gfc_build_function_call (tmp, args);\n-      /* TODO: function return value.  */\n+      if (ns->proc_name->attr.mixed_entry_master)\n+\t{\n+\t  tree union_decl, field;\n+\t  tree master_type = TREE_TYPE (ns->proc_name->backend_decl);\n+\n+\t  union_decl = build_decl (VAR_DECL, get_identifier (\"__result\"),\n+\t\t\t\t   TREE_TYPE (master_type));\n+\t  DECL_ARTIFICIAL (union_decl) = 1;\n+\t  DECL_EXTERNAL (union_decl) = 0;\n+\t  TREE_PUBLIC (union_decl) = 0;\n+\t  TREE_USED (union_decl) = 1;\n+\t  layout_decl (union_decl, 0);\n+\t  pushdecl (union_decl);\n+\n+\t  DECL_CONTEXT (union_decl) = current_function_decl;\n+\t  tmp = build2 (MODIFY_EXPR,\n+\t\t\tTREE_TYPE (union_decl),\n+\t\t\tunion_decl, tmp);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\n+\t  for (field = TYPE_FIELDS (TREE_TYPE (union_decl));\n+\t       field; field = TREE_CHAIN (field))\n+\t    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)),\n+\t\tthunk_sym->result->name) == 0)\n+\t      break;\n+\t  gcc_assert (field != NULL_TREE);\n+\t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), union_decl, field,\n+\t\t\tNULL_TREE);\n+\t  tmp = build2 (MODIFY_EXPR,\n+\t\t\tTREE_TYPE (DECL_RESULT (current_function_decl)),\n+\t\t\tDECL_RESULT (current_function_decl), tmp);\n+\t  tmp = build1_v (RETURN_EXPR, tmp);\n+\t}\n+      else if (TREE_TYPE (DECL_RESULT (current_function_decl))\n+\t       != void_type_node)\n+\t{\n+\t  tmp = build2 (MODIFY_EXPR,\n+\t\t\tTREE_TYPE (DECL_RESULT (current_function_decl)),\n+\t\t\tDECL_RESULT (current_function_decl), tmp);\n+\t  tmp = build1_v (RETURN_EXPR, tmp);\n+\t}\n       gfc_add_expr_to_block (&body, tmp);\n \n       /* Finish off this function and send it for code generation.  */\n@@ -1444,10 +1500,19 @@ build_entry_thunks (gfc_namespace * ns)\n \t points and the master function.  Clear them so that they are\n \t recreated for each function.  */\n       for (formal = thunk_sym->formal; formal; formal = formal->next)\n+\tif (formal->sym != NULL)  /* Ignore alternate returns.  */\n+\t  {\n+\t    formal->sym->backend_decl = NULL_TREE;\n+\t    if (formal->sym->ts.type == BT_CHARACTER)\n+\t      formal->sym->ts.cl->backend_decl = NULL_TREE;\n+\t  }\n+\n+      if (thunk_sym->attr.function)\n \t{\n-\t  formal->sym->backend_decl = NULL_TREE;\n-\t  if (formal->sym->ts.type == BT_CHARACTER)\n-\t    formal->sym->ts.cl->backend_decl = NULL_TREE;\n+\t  if (thunk_sym->ts.type == BT_CHARACTER)\n+\t    thunk_sym->ts.cl->backend_decl = NULL_TREE;\n+\t  if (thunk_sym->result->ts.type == BT_CHARACTER)\n+\t    thunk_sym->result->ts.cl->backend_decl = NULL_TREE;\n \t}\n     }\n \n@@ -1482,6 +1547,29 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \n   char name[GFC_MAX_SYMBOL_LEN + 10];\n \n+  if (sym\n+      && sym->ns->proc_name->backend_decl == current_function_decl\n+      && sym->ns->proc_name->attr.mixed_entry_master\n+      && sym != sym->ns->proc_name)\n+    {\n+      decl = gfc_get_fake_result_decl (sym->ns->proc_name);\n+      if (decl)\n+\t{\n+\t  tree field;\n+\n+\t  for (field = TYPE_FIELDS (TREE_TYPE (decl));\n+\t       field; field = TREE_CHAIN (field))\n+\t    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)),\n+\t\tsym->name) == 0)\n+\t      break;\n+\n+\t  gcc_assert (field != NULL_TREE);\n+\t  decl = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field,\n+\t\t\t NULL_TREE);\n+\t}\n+      return decl;\n+    }\n+\n   if (current_fake_result_decl != NULL_TREE)\n     return current_fake_result_decl;\n \n@@ -1499,7 +1587,11 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \n   if (gfc_return_by_reference (sym))\n     {\n-      decl = DECL_ARGUMENTS (sym->backend_decl);\n+      decl = DECL_ARGUMENTS (current_function_decl);\n+\n+      if (sym->ns->proc_name->backend_decl == current_function_decl\n+\t  && sym->ns->proc_name->attr.entry_master)\n+\tdecl = TREE_CHAIN (decl);\n \n       TREE_USED (decl) = 1;\n       if (sym->as)\n@@ -1916,11 +2008,17 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n     {\n       if (!current_fake_result_decl)\n \t{\n-\t  warning (0, \"Function does not return a value\");\n-\t  return fnbody;\n+\t  gfc_entry_list *el = NULL;\n+\t  if (proc_sym->attr.entry_master)\n+\t    {\n+\t      for (el = proc_sym->ns->entries; el; el = el->next)\n+\t\tif (el->sym != el->sym->result)\n+\t\t  break;\n+\t    }\n+\t  if (el == NULL)\n+\t    warning (0, \"Function does not return a value\");\n \t}\n-\n-      if (proc_sym->as)\n+      else if (proc_sym->as)\n \t{\n \t  fnbody = gfc_trans_dummy_array_bias (proc_sym,\n \t\t\t\t\t       current_fake_result_decl,\n@@ -2206,6 +2304,19 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   gfc_generate_contained_functions (ns);\n \n+  if (ns->entries && ns->proc_name->ts.type == BT_CHARACTER)\n+    {\n+      /* Copy length backend_decls to all entry point result\n+\t symbols.  */\n+      gfc_entry_list *el;\n+      tree backend_decl;\n+\n+      gfc_conv_const_charlen (ns->proc_name->ts.cl);\n+      backend_decl = ns->proc_name->result->ts.cl->backend_decl;\n+      for (el = ns->entries; el; el = el->next)\n+\tel->sym->result->ts.cl->backend_decl = backend_decl;\n+    }\n+\n   /* Translate COMMON blocks.  */\n   gfc_trans_common (ns);\n "}, {"sha": "caf3d754a2382267c63ab7ba29ce8bfe7d7b2df2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -309,11 +309,43 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n     }\n   else\n     {\n+      tree se_expr = NULL_TREE;\n+\n       se->expr = gfc_get_symbol_decl (sym);\n \n+      /* Special case for assigning the return value of a function.\n+\t Self recursive functions must have an explicit return value.  */\n+      if (se->expr == current_function_decl && sym->attr.function\n+\t  && (sym->result == sym))\n+\tse_expr = gfc_get_fake_result_decl (sym);\n+\n+      /* Similarly for alternate entry points.  */\n+      else if (sym->attr.function && sym->attr.entry\n+\t       && (sym->result == sym)\n+\t       && sym->ns->proc_name->backend_decl == current_function_decl)\n+\t{\n+\t  gfc_entry_list *el = NULL;\n+\n+\t  for (el = sym->ns->entries; el; el = el->next)\n+\t    if (sym == el->sym)\n+\t      {\n+\t\tse_expr = gfc_get_fake_result_decl (sym);\n+\t\tbreak;\n+\t      }\n+\t}\n+\n+      else if (sym->attr.result\n+\t       && sym->ns->proc_name->backend_decl == current_function_decl\n+\t       && sym->ns->proc_name->attr.entry_master\n+\t       && !gfc_return_by_reference (sym->ns->proc_name))\n+\tse_expr = gfc_get_fake_result_decl (sym);\n+\n+      if (se_expr)\n+\tse->expr = se_expr;\n+\n       /* Procedure actual arguments.  */\n-      if (sym->attr.flavor == FL_PROCEDURE\n-\t  && se->expr != current_function_decl)\n+      else if (sym->attr.flavor == FL_PROCEDURE\n+\t       && se->expr != current_function_decl)\n \t{\n \t  gcc_assert (se->want_pointer);\n \t  if (!sym->attr.dummy)\n@@ -324,14 +356,6 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  return;\n \t}\n \n-      /* Special case for assigning the return value of a function.\n-         Self recursive functions must have an explicit return value.  */\n-      if (se->expr == current_function_decl && sym->attr.function\n-\t  && (sym->result == sym))\n-\t{\n-\t  se->expr = gfc_get_fake_result_decl (sym);\n-\t}\n-\n       /* Dereference scalar dummy variables.  */\n       if (sym->attr.dummy\n \t  && sym->ts.type != BT_CHARACTER"}, {"sha": "d63917ad8a2b2b36dd8a77e6d86009c26305a043", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -1469,6 +1469,50 @@ gfc_return_by_reference (gfc_symbol * sym)\n   return 0;\n }\n \f\n+static tree\n+gfc_get_mixed_entry_union (gfc_namespace *ns)\n+{\n+  tree type;\n+  tree decl;\n+  tree fieldlist;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_entry_list *el, *el2;\n+\n+  gcc_assert (ns->proc_name->attr.mixed_entry_master);\n+  gcc_assert (memcmp (ns->proc_name->name, \"master.\", 7) == 0);\n+\n+  snprintf (name, GFC_MAX_SYMBOL_LEN, \"munion.%s\", ns->proc_name->name + 7);\n+\n+  /* Build the type node.  */\n+  type = make_node (UNION_TYPE);\n+\n+  TYPE_NAME (type) = get_identifier (name);\n+  fieldlist = NULL;\n+\n+  for (el = ns->entries; el; el = el->next)\n+    {\n+      /* Search for duplicates.  */\n+      for (el2 = ns->entries; el2 != el; el2 = el2->next)\n+\tif (el2->sym->result == el->sym->result)\n+\t  break;\n+\n+      if (el == el2)\n+\t{\n+\t  decl = build_decl (FIELD_DECL,\n+\t\t\t     get_identifier (el->sym->result->name),\n+\t\t\t     gfc_sym_type (el->sym->result));\n+\t  DECL_CONTEXT (decl) = type;\n+\t  fieldlist = chainon (fieldlist, decl);\n+\t}\n+    }\n+\n+  /* Finish off the type.  */\n+  TYPE_FIELDS (type) = fieldlist;\n+\n+  gfc_finish_type (type);\n+  return type;\n+}\n+\f\n tree\n gfc_get_function_type (gfc_symbol * sym)\n {\n@@ -1571,6 +1615,8 @@ gfc_get_function_type (gfc_symbol * sym)\n     type = integer_type_node;\n   else if (!sym->attr.function || gfc_return_by_reference (sym))\n     type = void_type_node;\n+  else if (sym->attr.mixed_entry_master)\n+    type = gfc_get_mixed_entry_union (sym->ns);\n   else\n     type = gfc_sym_type (sym);\n "}, {"sha": "fda642096468864f0189398ea3bde3a5b0372dfc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -1,3 +1,20 @@\n+2005-04-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/13082\n+\tPR fortran/18824\n+\t* gfortran.dg/entry_4.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_1.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_2.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_3.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_4.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_5.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_6.f90: New test.\n+\t* gfortran.fortran-torture/execute/entry_7.f90: New test.\n+\n+2005-04-29  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* gfortran.fortran-torture/execute/entry_8.f90: New test.\n+\n 2005-04-29  Paul Brook   <paul@codesourcery.com>\n \n \t* gfortran.dg/entry_3.f90: New test."}, {"sha": "edc07fbefd3393be7d47b0d402f1077f6127ce90", "filename": "gcc/testsuite/gfortran.dg/entry_4.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_4.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile { target i?86-*-* x86_64-*-* } }\n+function f1 () result (r)\t\t! { dg-error \"can't be a POINTER\" }\n+integer, pointer :: r\n+real e1\n+allocate (r)\n+r = 6\n+return\n+entry e1 ()\n+e1 = 12\n+entry e1a ()\n+e1a = 13\n+end function\n+function f2 ()\n+integer, dimension (2, 7, 6) :: e2\t! { dg-error \"can't be an array\" }\n+f2 = 6\n+return\n+entry e2 ()\n+e2 (:, :, :) = 2\n+end function\n+integer*8 function f3 ()\t\t! { dg-error \"can't be of type\" }\n+complex*16 e3\t\t\t\t! { dg-error \"can't be of type\" }\n+f3 = 1\n+return\n+entry e3 ()\n+e3 = 2\n+entry e3a ()\n+e3a = 3\n+end function"}, {"sha": "bef8a98dfd92daabfe52cfee2e3091b78d09a2a2", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_1.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_1.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,74 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points match\n+\n+\tfunction f1 (a)\n+\tinteger a, b, f1, e1\n+\tf1 = 15 + a\n+\treturn\n+\tentry e1 (b)\n+\te1 = 42 + b\n+\tend function\n+\tfunction f2 ()\n+\treal f2, e2\n+\tentry e2 ()\n+\te2 = 45\n+\tend function\n+\tfunction f3 ()\n+\tdouble precision a, b, f3, e3\n+\tentry e3 ()\n+\tf3 = 47\n+\tend function\n+\tfunction f4 (a) result (r)\n+\tdouble precision a, b, r, s\n+\tr = 15 + a\n+\treturn\n+\tentry e4 (b) result (s)\n+\ts = 42 + b\n+\tend function\n+\tfunction f5 () result (r)\n+\tinteger r, s\n+\tentry e5 () result (s)\n+\tr = 45\n+\tend function\n+\tfunction f6 () result (r)\n+\treal r, s\n+\tentry e6 () result (s)\n+\ts = 47\n+\tend function\n+\tfunction f7 ()\n+\tentry e7 ()\n+\te7 = 163\n+\tend function\n+\tfunction f8 () result (r)\n+\tentry e8 ()\n+\te8 = 115\n+\tend function\n+\tfunction f9 ()\n+\tentry e9 () result (r)\n+\tr = 119\n+\tend function\n+\n+\tprogram entrytest\n+\tinteger f1, e1, f5, e5\n+\treal f2, e2, f6, e6, f7, e7, f8, e8, f9, e9\n+\tdouble precision f3, e3, f4, e4, d\n+\tif (f1 (6) .ne. 21) call abort ()\n+\tif (e1 (7) .ne. 49) call abort ()\n+\tif (f2 () .ne. 45) call abort ()\n+\tif (e2 () .ne. 45) call abort ()\n+\tif (f3 () .ne. 47) call abort ()\n+\tif (e3 () .ne. 47) call abort ()\n+\td = 17\n+\tif (f4 (d) .ne. 32) call abort ()\n+\tif (e4 (d) .ne. 59) call abort ()\n+\tif (f5 () .ne. 45) call abort ()\n+\tif (e5 () .ne. 45) call abort ()\n+\tif (f6 () .ne. 47) call abort ()\n+\tif (e6 () .ne. 47) call abort ()\n+\tif (f7 () .ne. 163) call abort ()\n+\tif (e7 () .ne. 163) call abort ()\n+\tif (f8 () .ne. 115) call abort ()\n+\tif (e8 () .ne. 115) call abort ()\n+\tif (f9 () .ne. 119) call abort ()\n+\tif (e9 () .ne. 119) call abort ()\n+\tend"}, {"sha": "5db39db6a9dca754a2fe9af4711cd7e0fe07d6bc", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_2.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_2.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,51 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points match\n+\n+\tcharacter*(*) function f1 (str, i, j)\n+\tcharacter str*(*), e1*(*), e2*(*)\n+\tinteger i, j\n+\tf1 = str (i:j)\n+\treturn\n+\tentry e1 (str, i, j)\n+\ti = i + 1\n+\tentry e2 (str, i, j)\n+\tj = j - 1\n+\te2 = str (i:j)\n+\tend function\n+\n+\tcharacter*5 function f3 ()\n+\tcharacter e3*(*), e4*(*)\n+\tinteger i\n+\tf3 = 'ABCDE'\n+\treturn\n+\tentry e3 (i)\n+\tentry e4 (i)\n+\tif (i .gt. 0) then\n+\t  e3 = 'abcde'\n+\telse\n+\t  e4 = 'UVWXY'\n+\tendif\n+\tend function\n+\n+\tprogram entrytest\n+\tcharacter f1*16, e1*16, e2*16, str*16, ret*16\n+\tcharacter f3*5, e3*5, e4*5\n+\tinteger i, j\n+\tstr = 'ABCDEFGHIJ'\n+\ti = 2\n+\tj = 6\n+\tret = f1 (str, i, j)\n+\tif ((i .ne. 2) .or. (j .ne. 6)) call abort ()\n+\tif (ret .ne. 'BCDEF') call abort ()\n+\tret = e1 (str, i, j)\n+\tif ((i .ne. 3) .or. (j .ne. 5)) call abort ()\n+\tif (ret .ne. 'CDE') call abort ()\n+\tret = e2 (str, i, j)\n+\tif ((i .ne. 3) .or. (j .ne. 4)) call abort ()\n+\tif (ret .ne. 'CD') call abort ()\n+\tif (f3 () .ne. 'ABCDE') call abort ()\n+\tif (e3 (1) .ne. 'abcde') call abort ()\n+\tif (e4 (1) .ne. 'abcde') call abort ()\n+\tif (e3 (0) .ne. 'UVWXY') call abort ()\n+\tif (e4 (0) .ne. 'UVWXY') call abort ()\n+\tend program"}, {"sha": "7174fa878caa7fe75f7fe15874e8028cb3988fe7", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_3.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_3.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,40 @@\n+\tsubroutine f1 (n, *, i)\n+\tinteger n, i\n+\tif (i .ne. 42) call abort ()\n+\tentry e1 (n, *)\n+\tif (n .eq. 1) return 1\n+\tif (n .eq. 2) return\n+\treturn\n+\tentry e2 (n, i, *, *, *)\n+\tif (i .ne. 46) call abort ()\n+\tif (n .ge. 4) return\n+\treturn n\n+\tentry e3 (n, i)\n+\tif ((i .ne. 48) .or. (n .ne. 61)) call abort ()\n+\tend subroutine\n+\n+\tprogram alt_return\n+\timplicit none\n+\n+\tcall f1 (1, *10, 42)\n+20\tcontinue\n+\tcall abort ()\n+10\tcontinue\n+\tcall f1 (2, *20, 42)\n+\tcall f1 (3, *20, 42)\n+\tcall e1 (2, *20)\n+\tcall e1 (1, *30)\n+\tcall abort ()\n+30\tcontinue\n+\tcall e2 (1, 46, *40, *20, *20)\n+\tcall abort ()\n+40\tcontinue\n+\tcall e2 (2, 46, *20, *50, *20)\n+\tcall abort ()\n+50\tcontinue\n+\tcall e2 (3, 46, *20, *20, *60)\n+\tcall abort ()\n+60\tcontinue\n+\tcall e2 (4, 46, *20, *20, *20)\n+\tcall e3 (61, 48)\n+\tend program"}, {"sha": "f74440c13a70e1145f37888cf64b8d1d4eb2754d", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_4.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_4.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,64 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points don't match\n+\n+\tinteger function f1 (a)\n+\tinteger a, b\n+\tdouble precision e1\n+\tf1 = 15 + a\n+\treturn\n+\tentry e1 (b)\n+\te1 = 42 + b\n+\tend function\n+\tcomplex function f2 (a)\n+\tinteger a\n+\tlogical e2\n+\tentry e2 (a)\n+\tif (a .gt. 0) then\n+\t  e2 = a .lt. 46\n+\telse\n+\t  f2 = 45\n+\tendif\n+\tend function\n+\tfunction f3 (a) result (r)\n+\tinteger a, b\n+\treal r\n+\tlogical s\n+\tcomplex c\n+\tr = 15 + a\n+\treturn\n+\tentry e3 (b) result (s)\n+\ts = b .eq. 42\n+\treturn\n+\tentry g3 (b) result (c)\n+\tc = b + 11\n+\tend function\n+\tfunction f4 (a) result (r)\n+\tlogical r\n+\tinteger a, s\n+\tdouble precision t\n+\tentry e4 (a) result (s)\n+\tentry g4 (a) result (t)\n+\tr = a .lt. 0\n+\tif (a .eq. 0) s = 16 + a\n+\tif (a .gt. 0) t = 17 + a\n+\tend function\n+\n+\tprogram entrytest\n+\tinteger f1, e4\n+\treal f3\n+\tdouble precision e1, g4\n+\tlogical e2, e3, f4\n+\tcomplex f2, g3\n+\tif (f1 (6) .ne. 21) call abort ()\n+\tif (e1 (7) .ne. 49) call abort ()\n+\tif (f2 (0) .ne. 45) call abort ()\n+\tif (.not. e2 (45)) call abort ()\n+\tif (e2 (46)) call abort ()\n+\tif (f3 (17) .ne. 32) call abort ()\n+\tif (.not. e3 (42)) call abort ()\n+\tif (e3 (41)) call abort ()\n+\tif (g3 (12) .ne. 23) call abort ()\n+\tif (.not. f4 (-5)) call abort ()\n+\tif (e4 (0) .ne. 16) call abort ()\n+\tif (g4 (2) .ne. 19) call abort ()\n+\tend"}, {"sha": "2fd927f4eb39702b723484e00d166f7a457048e0", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_5.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_5.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,51 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points match\n+\n+\tfunction f1 (str, i, j) result (r)\n+\tcharacter str*(*), r1*(*), r2*(*), r*(*)\n+\tinteger i, j\n+\tr = str (i:j)\n+\treturn\n+\tentry e1 (str, i, j) result (r1)\n+\ti = i + 1\n+\tentry e2 (str, i, j) result (r2)\n+\tj = j - 1\n+\tr2 = str (i:j)\n+\tend function\n+\n+\tfunction f3 () result (r)\n+\tcharacter r3*5, r4*5, r*5\n+\tinteger i\n+\tr = 'ABCDE'\n+\treturn\n+\tentry e3 (i) result (r3)\n+\tentry e4 (i) result (r4)\n+\tif (i .gt. 0) then\n+\t  r3 = 'abcde'\n+\telse\n+\t  r4 = 'UVWXY'\n+\tendif\n+\tend function\n+\n+\tprogram entrytest\n+\tcharacter f1*16, e1*16, e2*16, str*16, ret*16\n+\tcharacter f3*5, e3*5, e4*5\n+\tinteger i, j\n+\tstr = 'ABCDEFGHIJ'\n+\ti = 2\n+\tj = 6\n+\tret = f1 (str, i, j)\n+\tif ((i .ne. 2) .or. (j .ne. 6)) call abort ()\n+\tif (ret .ne. 'BCDEF') call abort ()\n+\tret = e1 (str, i, j)\n+\tif ((i .ne. 3) .or. (j .ne. 5)) call abort ()\n+\tif (ret .ne. 'CDE') call abort ()\n+\tret = e2 (str, i, j)\n+\tif ((i .ne. 3) .or. (j .ne. 4)) call abort ()\n+\tif (ret .ne. 'CD') call abort ()\n+\tif (f3 () .ne. 'ABCDE') call abort ()\n+\tif (e3 (1) .ne. 'abcde') call abort ()\n+\tif (e4 (1) .ne. 'abcde') call abort ()\n+\tif (e3 (0) .ne. 'UVWXY') call abort ()\n+\tif (e4 (0) .ne. 'UVWXY') call abort ()\n+\tend program"}, {"sha": "a75c513a1c076026c411aa89294f08e975027427", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_6.f90", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_6.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,109 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points match\n+\n+\tfunction f1 (a)\n+\tinteger, dimension (2, 2) :: a, b, f1, e1\n+\tf1 (:, :) = 15 + a (1, 1)\n+\treturn\n+\tentry e1 (b)\n+\te1 (:, :) = 42 + b (1, 1)\n+\tend function\n+\tfunction f2 ()\n+\treal, dimension (2, 2) :: f2, e2\n+\tentry e2 ()\n+\te2 (:, :) = 45\n+\tend function\n+\tfunction f3 ()\n+\tdouble precision, dimension (2, 2) :: a, b, f3, e3\n+\tentry e3 ()\n+\tf3 (:, :) = 47\n+\tend function\n+\tfunction f4 (a) result (r)\n+\tdouble precision, dimension (2, 2) :: a, b, r, s\n+\tr (:, :) = 15 + a (1, 1)\n+\treturn\n+\tentry e4 (b) result (s)\n+\ts (:, :) = 42 + b (1, 1)\n+\tend function\n+\tfunction f5 () result (r)\n+\tinteger, dimension (2, 2) :: r, s\n+\tentry e5 () result (s)\n+\tr (:, :) = 45\n+\tend function\n+\tfunction f6 () result (r)\n+\treal, dimension (2, 2) :: r, s\n+\tentry e6 () result (s)\n+\ts (:, :) = 47\n+\tend function\n+\n+\tprogram entrytest\n+\tinterface\n+\tfunction f1 (a)\n+\tinteger, dimension (2, 2) :: a, f1\n+\tend function\n+\tfunction e1 (b)\n+\tinteger, dimension (2, 2) :: b, e1\n+\tend function\n+\tfunction f2 ()\n+\treal, dimension (2, 2) :: f2\n+\tend function\n+\tfunction e2 ()\n+\treal, dimension (2, 2) :: e2\n+\tend function\n+\tfunction f3 ()\n+\tdouble precision, dimension (2, 2) :: f3\n+\tend function\n+\tfunction e3 ()\n+\tdouble precision, dimension (2, 2) :: e3\n+\tend function\n+\tfunction f4 (a)\n+ \tdouble precision, dimension (2, 2) :: a, f4\n+\tend function\n+\tfunction e4 (b)\n+ \tdouble precision, dimension (2, 2) :: b, e4\n+\tend function\n+\tfunction f5 ()\n+\tinteger, dimension (2, 2) :: f5\n+\tend function\n+\tfunction e5 ()\n+\tinteger, dimension (2, 2) :: e5\n+\tend function\n+\tfunction f6 ()\n+\treal, dimension (2, 2) :: f6\n+\tend function\n+\tfunction e6 ()\n+\treal, dimension (2, 2) :: e6\n+\tend function\n+\tend interface\n+\tinteger, dimension (2, 2) :: i, j\n+\treal, dimension (2, 2) :: r\n+\tdouble precision, dimension (2, 2) :: d, e\n+\ti (:, :) = 6\n+\tj = f1 (i)\n+\tif (any (j .ne. 21)) call abort ()\n+\ti (:, :) = 7\n+\tj = e1 (i)\n+\tj (:, :) = 49\n+\tif (any (j .ne. 49)) call abort ()\n+\tr = f2 ()\n+\tif (any (r .ne. 45)) call abort ()\n+\tr = e2 ()\n+\tif (any (r .ne. 45)) call abort ()\n+\te = f3 ()\n+\tif (any (e .ne. 47)) call abort ()\n+\te = e3 ()\n+\tif (any (e .ne. 47)) call abort ()\n+\td (:, :) = 17\n+\te = f4 (d)\n+\tif (any (e .ne. 32)) call abort ()\n+\te = e4 (d)\n+\tif (any (e .ne. 59)) call abort ()\n+\tj = f5 ()\n+\tif (any (j .ne. 45)) call abort ()\n+\tj = e5 ()\n+\tif (any (j .ne. 45)) call abort ()\n+\tr = f6 ()\n+\tif (any (r .ne. 47)) call abort ()\n+\tr = e6 ()\n+\tif (any (r .ne. 47)) call abort ()\n+\tend"}, {"sha": "28a8a3f7838e7a88954973b9bcc4806d4538aec0", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_7.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_7.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,106 @@\n+! Test alternate entry points for functions when the result types\n+! of all entry points match\n+\n+\tfunction f1 (a)\n+\tinteger a, b\n+\tinteger, pointer :: f1, e1\n+\tallocate (f1)\n+\tf1 = 15 + a\n+\treturn\n+\tentry e1 (b)\n+\tallocate (e1)\n+\te1 = 42 + b\n+\tend function\n+\tfunction f2 ()\n+\treal, pointer :: f2, e2\n+\tentry e2 ()\n+\tallocate (e2)\n+\te2 = 45\n+\tend function\n+\tfunction f3 ()\n+\tdouble precision, pointer :: f3, e3\n+\tentry e3 ()\n+\tallocate (f3)\n+\tf3 = 47\n+\tend function\n+\tfunction f4 (a) result (r)\n+\tdouble precision a, b\n+\tdouble precision, pointer :: r, s\n+\tallocate (r)\n+\tr = 15 + a\n+\treturn\n+\tentry e4 (b) result (s)\n+\tallocate (s)\n+\ts = 42 + b\n+\tend function\n+\tfunction f5 () result (r)\n+\tinteger, pointer :: r, s\n+\tentry e5 () result (s)\n+\tallocate (r)\n+\tr = 45\n+\tend function\n+\tfunction f6 () result (r)\n+\treal, pointer :: r, s\n+\tentry e6 () result (s)\n+\tallocate (s)\n+\ts = 47\n+\tend function\n+\n+\tprogram entrytest\n+\tinterface\n+\tfunction f1 (a)\n+\tinteger a\n+\tinteger, pointer :: f1\n+\tend function\n+\tfunction e1 (b)\n+\tinteger b\n+\tinteger, pointer :: e1\n+\tend function\n+\tfunction f2 ()\n+\treal, pointer :: f2\n+\tend function\n+\tfunction e2 ()\n+\treal, pointer :: e2\n+\tend function\n+\tfunction f3 ()\n+\tdouble precision, pointer :: f3\n+\tend function\n+\tfunction e3 ()\n+\tdouble precision, pointer :: e3\n+\tend function\n+\tfunction f4 (a)\n+\tdouble precision a\n+\tdouble precision, pointer :: f4\n+\tend function\n+\tfunction e4 (b)\n+\tdouble precision b\n+\tdouble precision, pointer :: e4\n+\tend function\n+\tfunction f5 ()\n+\tinteger, pointer :: f5\n+\tend function\n+\tfunction e5 ()\n+\tinteger, pointer :: e5\n+\tend function\n+\tfunction f6 ()\n+\treal, pointer :: f6\n+\tend function\n+\tfunction e6 ()\n+\treal, pointer :: e6\n+\tend function\n+\tend interface\n+\tdouble precision d\n+\tif (f1 (6) .ne. 21) call abort ()\n+\tif (e1 (7) .ne. 49) call abort ()\n+\tif (f2 () .ne. 45) call abort ()\n+\tif (e2 () .ne. 45) call abort ()\n+\tif (f3 () .ne. 47) call abort ()\n+\tif (e3 () .ne. 47) call abort ()\n+\td = 17\n+\tif (f4 (d) .ne. 32) call abort ()\n+\tif (e4 (d) .ne. 59) call abort ()\n+\tif (f5 () .ne. 45) call abort ()\n+\tif (e5 () .ne. 45) call abort ()\n+\tif (f6 () .ne. 47) call abort ()\n+\tif (e6 () .ne. 47) call abort ()\n+\tend"}, {"sha": "c68d75af7689ae98ccec821beb973487bb94da8a", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/entry_8.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d198b59ab12557edbafc2bba595f855caccfc6ec/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fentry_8.f90?ref=d198b59ab12557edbafc2bba595f855caccfc6ec", "patch": "@@ -0,0 +1,24 @@\n+module entry_8_m\n+type t\n+  integer i\n+  real x (5)\n+end type t\n+end module entry_8_m\n+\n+function f (i)\n+  use entry_8_m\n+  type (t) :: f,g\n+  f % i = i\n+  return\n+  entry g (x)\n+  g%x = x\n+end function f\n+\n+use entry_8_m\n+type (t) :: f, g, res\n+\n+res = f (42)\n+if (res%i /= 42) call abort ()\n+res = g (1.)\n+if (any (res%x /= 1.)) call abort ()\n+end"}]}