{"sha": "af60e4bd4b69f39173a8347aa2dcdaa40227ec67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2MGU0YmQ0YjY5ZjM5MTczYTgzNDdhYTJkY2RhYTQwMjI3ZWM2Nw==", "commit": {"author": {"name": "Matthias Kretz", "email": "kretz@kde.org", "date": "2021-02-03T15:49:30Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-02-03T15:49:30Z"}, "message": "libstdc++: Improve test codegen for interpreting assembly\n\nIn many failure cases it is helpful to inspect the instructions leading\nup to the test failure. After this change the location is easier to find\nand the branch after failure is easier to find.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/experimental/simd/tests/bits/verify.h (verify): Add\n\tinstruction pointer data member. Ensure that the `if (m_failed)`\n\tbranch is always inlined into the calling code. The body of the\n\tconditional can still be a function call. Move the get_ip call\n\tinto the verify ctor to simplify the ctor calls.\n\t(COMPARE): Don't mention the use of all_of for reduction of a\n\tsimd_mask. It only distracts from the real issue.", "tree": {"sha": "3afef1b971a4e9f36a0b69733d9de943061dd61a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3afef1b971a4e9f36a0b69733d9de943061dd61a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af60e4bd4b69f39173a8347aa2dcdaa40227ec67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af60e4bd4b69f39173a8347aa2dcdaa40227ec67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af60e4bd4b69f39173a8347aa2dcdaa40227ec67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af60e4bd4b69f39173a8347aa2dcdaa40227ec67/comments", "author": {"login": "mattkretz", "id": 3306474, "node_id": "MDQ6VXNlcjMzMDY0NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3306474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattkretz", "html_url": "https://github.com/mattkretz", "followers_url": "https://api.github.com/users/mattkretz/followers", "following_url": "https://api.github.com/users/mattkretz/following{/other_user}", "gists_url": "https://api.github.com/users/mattkretz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattkretz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattkretz/subscriptions", "organizations_url": "https://api.github.com/users/mattkretz/orgs", "repos_url": "https://api.github.com/users/mattkretz/repos", "events_url": "https://api.github.com/users/mattkretz/events{/privacy}", "received_events_url": "https://api.github.com/users/mattkretz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f7ad986515580265f4315a6036ef3b49eb6be47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7ad986515580265f4315a6036ef3b49eb6be47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7ad986515580265f4315a6036ef3b49eb6be47"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "82016c66802953222782f251adaedb628c80a710", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af60e4bd4b69f39173a8347aa2dcdaa40227ec67/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af60e4bd4b69f39173a8347aa2dcdaa40227ec67/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h?ref=af60e4bd4b69f39173a8347aa2dcdaa40227ec67", "patch": "@@ -60,6 +60,7 @@ template <class T>\n class verify\n {\n   const bool m_failed = false;\n+  size_t m_ip = 0;\n \n   template <typename T,\n \t    typename = decltype(std::declval<std::stringstream&>()\n@@ -129,20 +130,21 @@ class verify\n \n public:\n   template <typename... Ts>\n-    verify(bool ok, size_t ip, const char* file, const int line,\n+    [[gnu::always_inline]]\n+    verify(bool ok, const char* file, const int line,\n \t   const char* func, const char* cond, const Ts&... extra_info)\n-    : m_failed(!ok)\n+    : m_failed(!ok), m_ip(get_ip())\n     {\n       if (m_failed)\n-\t{\n+\t[&] {\n \t  __builtin_fprintf(stderr, \"%s:%d: (%s):\\nInstruction Pointer: %x\\n\"\n \t\t\t\t    \"Assertion '%s' failed.\\n\",\n-\t\t\t    file, line, func, ip, cond);\n+\t\t\t    file, line, func, m_ip, cond);\n \t  (print(extra_info, int()), ...);\n-\t}\n+\t}();\n     }\n \n-  ~verify()\n+  [[gnu::always_inline]] ~verify()\n   {\n     if (m_failed)\n       {\n@@ -152,26 +154,27 @@ class verify\n   }\n \n   template <typename T>\n+    [[gnu::always_inline]]\n     const verify&\n     operator<<(const T& x) const\n     {\n       if (m_failed)\n-\t{\n-\t  print(x, int());\n-\t}\n+\tprint(x, int());\n       return *this;\n     }\n \n   template <typename... Ts>\n+    [[gnu::always_inline]]\n     const verify&\n     on_failure(const Ts&... xs) const\n     {\n       if (m_failed)\n-\t(print(xs, int()), ...);\n+\t[&] { (print(xs, int()), ...); }();\n       return *this;\n     }\n \n-  [[gnu::always_inline]] static inline size_t\n+  [[gnu::always_inline]] static inline\n+  size_t\n   get_ip()\n   {\n     size_t _ip = 0;\n@@ -220,34 +223,31 @@ template <typename T>\n \n #define COMPARE(_a, _b)                                                        \\\n   [&](auto&& _aa, auto&& _bb) {                                                \\\n-    return verify(std::experimental::all_of(_aa == _bb), verify::get_ip(),     \\\n-\t\t  __FILE__, __LINE__, __PRETTY_FUNCTION__,                     \\\n-\t\t  \"all_of(\" #_a \" == \" #_b \")\", #_a \" = \", _aa,                \\\n+    return verify(std::experimental::all_of(_aa == _bb), __FILE__, __LINE__,   \\\n+\t\t  __PRETTY_FUNCTION__, #_a \" == \" #_b, #_a \" = \", _aa,         \\\n \t\t  \"\\n\" #_b \" = \", _bb);                                        \\\n   }(force_fp_truncation(_a), force_fp_truncation(_b))\n #else\n #define COMPARE(_a, _b)                                                        \\\n   [&](auto&& _aa, auto&& _bb) {                                                \\\n-    return verify(std::experimental::all_of(_aa == _bb), verify::get_ip(),     \\\n-\t\t  __FILE__, __LINE__, __PRETTY_FUNCTION__,                     \\\n-\t\t  \"all_of(\" #_a \" == \" #_b \")\", #_a \" = \", _aa,                \\\n+    return verify(std::experimental::all_of(_aa == _bb), __FILE__, __LINE__,   \\\n+\t\t  __PRETTY_FUNCTION__, #_a \" == \" #_b, #_a \" = \", _aa,         \\\n \t\t  \"\\n\" #_b \" = \", _bb);                                        \\\n   }((_a), (_b))\n #endif\n \n #define VERIFY(_test)                                                          \\\n-  verify(_test, verify::get_ip(), __FILE__, __LINE__, __PRETTY_FUNCTION__,     \\\n-\t #_test)\n+  verify(_test, __FILE__, __LINE__, __PRETTY_FUNCTION__, #_test)\n \n   // ulp_distance_signed can raise FP exceptions and thus must be conditionally\n   // executed\n #define ULP_COMPARE(_a, _b, _allowed_distance)                                 \\\n   [&](auto&& _aa, auto&& _bb) {                                                \\\n     const bool success = std::experimental::all_of(                            \\\n       vir::test::ulp_distance(_aa, _bb) <= (_allowed_distance));               \\\n-    return verify(success, verify::get_ip(), __FILE__, __LINE__,               \\\n-\t\t  __PRETTY_FUNCTION__, \"all_of(\" #_a \" ~~ \" #_b \")\",           \\\n-\t\t  #_a \" = \", _aa, \"\\n\" #_b \" = \", _bb, \"\\ndistance = \",        \\\n+    return verify(success, __FILE__, __LINE__, __PRETTY_FUNCTION__,            \\\n+\t\t  #_a \" ~~ \" #_b, #_a \" = \", _aa, \"\\n\" #_b \" = \", _bb,         \\\n+\t\t  \"\\ndistance = \",                                             \\\n \t\t  success ? 0 : vir::test::ulp_distance_signed(_aa, _bb));     \\\n   }((_a), (_b))\n "}]}