{"sha": "b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxZTJkNWU3NmE2YmNjNzFmNDViMTIyZThiNTUzOGRkYjdlYmY0Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T07:58:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T07:58:21Z"}, "message": "Get rid of useless temporary for call to pure function\n\nThis avoids creating a useless temporary for a call to a pure function with\ngood properties by using the RSO.\n\ngcc/ada/\n\t* gcc-interface/trans.c (is_array_of_scalar_type): New predicate.\n\t(find_decls_r): New function.\n\t(return_slot_opt_for_pure_call_p): New predicate.\n\t(Call_to_gnu): Do not create a temporary for the return value if the\n\tparent node is an aggregate.  If there is a target, try to apply the\n\treturn slot optimization to regular calls to pure functions returning\n\tan array of scalar type.", "tree": {"sha": "9b04e5b2651d3616fb939816ba80474e456e94de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b04e5b2651d3616fb939816ba80474e456e94de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c/comments", "author": null, "committer": null, "parents": [{"sha": "852dd866e2faba95cb407c98d31a48b6aae66677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dd866e2faba95cb407c98d31a48b6aae66677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852dd866e2faba95cb407c98d31a48b6aae66677"}], "stats": {"total": 94, "additions": 85, "deletions": 9}, "files": [{"sha": "07f5e81ab3527b6c722cb4aaafaae4e2e2b1c838", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "patch": "@@ -4377,6 +4377,69 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n   return gnu_temp;\n }\n \n+/* Return true if TYPE is an array of scalar type.  */\n+\n+static bool\n+is_array_of_scalar_type (tree type)\n+{\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    return false;\n+\n+  type = TREE_TYPE (type);\n+\n+  return !AGGREGATE_TYPE_P (type) && !POINTER_TYPE_P (type);\n+}\n+\n+/* Helper function for walk_tree, used by return_slot_opt_for_pure_call_p.  */\n+\n+static tree\n+find_decls_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  bitmap decls = (bitmap) data;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  else if (DECL_P (*tp))\n+    bitmap_set_bit (decls, DECL_UID (*tp));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return whether the assignment TARGET = CALL can be subject to the return\n+   slot optimization, under the assumption that the called function be pure\n+   in the Ada sense and return an array of scalar type.  */\n+\n+static bool\n+return_slot_opt_for_pure_call_p (tree target, tree call)\n+{\n+  /* Check that the target is a DECL.  */\n+  if (!DECL_P (target))\n+    return false;\n+\n+  const bitmap decls = BITMAP_GGC_ALLOC ();\n+  call_expr_arg_iterator iter;\n+  tree arg;\n+\n+  /* Check that all the arguments have either a scalar type (we assume that\n+     this means by-copy passing mechanism) or array of scalar type.  */\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+    {\n+      tree arg_type = TREE_TYPE (arg);\n+      if (TREE_CODE (arg_type) == REFERENCE_TYPE)\n+\targ_type = TREE_TYPE (arg_type);\n+\n+      if (is_array_of_scalar_type (arg_type))\n+\twalk_tree_without_duplicates (&arg, find_decls_r, decls);\n+\n+      else if (AGGREGATE_TYPE_P (arg_type) || POINTER_TYPE_P (arg_type))\n+\treturn false;\n+    }\n+\n+  /* Check that the target is not referenced by the non-scalar arguments.  */\n+  return !bitmap_bit_p (decls, DECL_UID (target));\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n@@ -4501,15 +4564,16 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  because we need to preserve the return value before copying back the\n \t  parameters.\n \n-       2. There is no target and the call is made for neither an object, nor a\n-\t  renaming declaration, nor a return statement, nor an allocator, and\n-\t  the return type has variable size because in this case the gimplifier\n-\t  cannot create the temporary, or more generally is an aggregate type,\n-\t  because the gimplifier would create the temporary in the outermost\n-\t  scope instead of locally.  But there is an exception for an allocator\n-\t  of an unconstrained record type with default discriminant because we\n-\t  allocate the actual size in this case, unlike the other 3 cases, so\n-\t  we need a temporary to fetch the discriminant and we create it here.\n+       2. There is no target and the call is made for neither the declaration\n+\t  of an object (regular or renaming), nor a return statement, nor an\n+\t  allocator, nor an aggregate, and the return type has variable size\n+\t  because in this case the gimplifier cannot create the temporary, or\n+\t  more generally is an aggregate type, because the gimplifier would\n+\t  create the temporary in the outermost scope instead of locally here.\n+\t  But there is an exception for an allocator of unconstrained record\n+\t  type with default discriminant because we allocate the actual size\n+\t  in this case, unlike in the other cases, so we need a temporary to\n+\t  fetch the discriminant and we create it here.\n \n        3. There is a target and it is a slice or an array with fixed size,\n \t  and the return type has variable size, because the gimplifier\n@@ -4535,6 +4599,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      && (!(Nkind (Parent (gnat_node)) == N_Qualified_Expression\n \t\t    && Nkind (Parent (Parent (gnat_node))) == N_Allocator)\n \t\t  || type_is_padding_self_referential (gnu_result_type))\n+\t      && Nkind (Parent (gnat_node)) != N_Aggregate\n \t      && AGGREGATE_TYPE_P (gnu_result_type)\n \t      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))\n \t  || (gnu_target\n@@ -5153,6 +5218,17 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t     That's what has been done historically.  */\n \t  if (return_type_with_variable_size_p (gnu_result_type))\n \t    op_code = INIT_EXPR;\n+\n+\t  /* If this is a call to a pure function returning an array of scalar\n+\t     type, try to apply the return slot optimization.  */\n+\t  else if ((TYPE_READONLY (gnu_subprog_type)\n+\t\t    || TYPE_RESTRICT (gnu_subprog_type))\n+\t\t   && is_array_of_scalar_type (gnu_result_type)\n+\t\t   && TYPE_MODE (gnu_result_type) == BLKmode\n+\t\t   && aggregate_value_p (gnu_result_type, gnu_subprog_type)\n+\t\t   && return_slot_opt_for_pure_call_p (gnu_target, gnu_call))\n+\t    op_code = INIT_EXPR;\n+\n \t  else\n \t    op_code = MODIFY_EXPR;\n "}]}