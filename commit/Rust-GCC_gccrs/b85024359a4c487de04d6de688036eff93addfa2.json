{"sha": "b85024359a4c487de04d6de688036eff93addfa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1MDI0MzU5YTRjNDg3ZGUwNGQ2ZGU2ODgwMzZlZmY5M2FkZGZhMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-23T21:53:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-23T21:53:14Z"}, "message": "re PR fortran/13465 (Data statement for large arrays compiles verrrry slllowwwly and shows quadratic behaviour.)\n\n        PR 13465\n        * data.c (find_con_by_offset): Search ordered list; handle\n        elements with repeat counts.\n        (gfc_assign_data_value_range): New.\n        * gfortran.h (struct gfc_data_value): Make repeat unsigned.\n        (gfc_assign_data_value_range): Declare.\n        * match.c (top_val_list): Extract repeat count into a temporary.\n        * resolve.c (values): Make left unsigned.\n        (next_data_value): Don't decrement left.\n        (check_data_variable): Use gfc_assign_data_value_range.\n\nFrom-SVN: r86443", "tree": {"sha": "2b929849a4b3cd5fcb35dec69633cf9d3c308c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b929849a4b3cd5fcb35dec69633cf9d3c308c77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b85024359a4c487de04d6de688036eff93addfa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85024359a4c487de04d6de688036eff93addfa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85024359a4c487de04d6de688036eff93addfa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85024359a4c487de04d6de688036eff93addfa2/comments", "author": null, "committer": null, "parents": [{"sha": "9a870e6c4c561ad318a320c2bcc9618c7f600865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a870e6c4c561ad318a320c2bcc9618c7f600865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a870e6c4c561ad318a320c2bcc9618c7f600865"}], "stats": {"total": 265, "additions": 240, "deletions": 25}, "files": [{"sha": "a7535db9cce236eab5b97839dbea64c5712e0287", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b85024359a4c487de04d6de688036eff93addfa2", "patch": "@@ -1,3 +1,16 @@\n+2004-08-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 13465\n+        * data.c (find_con_by_offset): Search ordered list; handle\n+        elements with repeat counts.\n+        (gfc_assign_data_value_range): New.\n+        * gfortran.h (struct gfc_data_value): Make repeat unsigned.\n+        (gfc_assign_data_value_range): Declare.\n+        * match.c (top_val_list): Extract repeat count into a temporary.\n+        * resolve.c (values): Make left unsigned.\n+        (next_data_value): Don't decrement left.\n+        (check_data_variable): Use gfc_assign_data_value_range.\n+\n 2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-const.c, trans-decl.c, trans-expr.c: Spelling fixes."}, {"sha": "2999af2a8607877aa15ed3442586b0b6bab1c75f", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 174, "deletions": 6, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=b85024359a4c487de04d6de688036eff93addfa2", "patch": "@@ -82,12 +82,40 @@ get_array_index (gfc_array_ref * ar, mpz_t * offset)\n static gfc_constructor *\n find_con_by_offset (mpz_t offset, gfc_constructor *con)\n {\n+  mpz_t tmp;\n+  gfc_constructor *ret = NULL;\n+\n+  mpz_init (tmp);\n+\n   for (; con; con = con->next)\n     {\n-      if (mpz_cmp (offset, con->n.offset) == 0)\n-        return con;\n+      int cmp = mpz_cmp (offset, con->n.offset);\n+\n+      /* We retain a sorted list, so if we're too large, we're done.  */\n+      if (cmp < 0)\n+\tbreak;\n+\n+      /* Yaye for exact matches.  */\n+      if (cmp == 0)\n+\t{\n+          ret = con;\n+\t  break;\n+\t}\n+\n+      /* If the constructor element is a range, match any element.  */\n+      if (mpz_cmp_ui (con->repeat, 1) > 0)\n+\t{\n+\t  mpz_add (tmp, con->n.offset, con->repeat);\n+\t  if (mpz_cmp (offset, tmp) < 0)\n+\t    {\n+\t      ret = con;\n+\t      break;\n+\t    }\n+\t}\n     }\n-  return NULL;\n+\n+  mpz_clear (tmp);\n+  return ret;\n }\n \n \n@@ -236,7 +264,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t  if (con == NULL)\n \t    {\n \t      /* Create a new constructor.  */\n-\t      con = gfc_get_constructor();\n+\t      con = gfc_get_constructor ();\n \t      mpz_set (con->n.offset, offset);\n \t      gfc_insert_constructor (expr, con);\n \t    }\n@@ -272,7 +300,6 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t  abort ();\n \t}\n \n-      \n       if (init == NULL)\n \t{\n \t  /* Point the container at the new expression.  */\n@@ -295,7 +322,6 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n       expr = gfc_copy_expr (rvalue);\n       if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n \tgfc_convert_type (expr, &lvalue->ts, 0);\n-\n     }\n \n   if (last_con == NULL)\n@@ -304,6 +330,148 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n     last_con->expr = expr;\n }\n \n+/* Similarly, but initialize REPEAT consectutive values in LVALUE the same\n+   value in RVALUE.  For the nonce, LVALUE must refer to a full array, not\n+   an array section.  */\n+\n+void\n+gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n+\t\t\t     mpz_t index, mpz_t repeat)\n+{\n+  gfc_ref *ref;\n+  gfc_expr *init, *expr;\n+  gfc_constructor *con, *last_con;\n+  gfc_symbol *symbol;\n+  gfc_typespec *last_ts;\n+  mpz_t offset;\n+\n+  symbol = lvalue->symtree->n.sym;\n+  init = symbol->value;\n+  last_ts = &symbol->ts;\n+  last_con = NULL;\n+  mpz_init_set_si (offset, 0);\n+\n+  /* Find/create the parent expressions for subobject references.  */\n+  for (ref = lvalue->ref; ref; ref = ref->next)\n+    {\n+      /* Use the existing initializer expression if it exists.\n+\t Otherwise create a new one.  */\n+      if (init == NULL)\n+\texpr = gfc_get_expr ();\n+      else\n+\texpr = init;\n+\n+      /* Find or create this element.  */\n+      switch (ref->type)\n+\t{\n+\tcase REF_ARRAY:\n+\t  if (init == NULL)\n+\t    {\n+\t      /* The element typespec will be the same as the array\n+\t\t typespec.  */\n+\t      expr->ts = *last_ts;\n+\t      /* Setup the expression to hold the constructor.  */\n+\t      expr->expr_type = EXPR_ARRAY;\n+\t      expr->rank = ref->u.ar.as->rank;\n+\t    }\n+\t  else\n+\t    assert (expr->expr_type == EXPR_ARRAY);\n+\n+\t  if (ref->u.ar.type == AR_ELEMENT)\n+\t    {\n+\t      get_array_index (&ref->u.ar, &offset);\n+\n+\t      /* This had better not be the bottom of the reference.\n+\t\t We can still get to a full array via a component.  */\n+\t      assert (ref->next != NULL);\n+\t    }\n+\t  else\n+\t    {\n+\t      mpz_set (offset, index);\n+\n+\t      /* We're at a full array or an array section.  This means\n+\t\t that we've better have found a full array, and that we're\n+\t\t at the bottom of the reference.  */\n+\t      assert (ref->u.ar.type == AR_FULL);\n+\t      assert (ref->next == NULL);\n+\t    }\n+\n+\t  /* Find the same element in the existing constructor.  */\n+\t  con = expr->value.constructor;\n+\t  con = find_con_by_offset (offset, con);\n+\n+\t  /* Create a new constructor.  */\n+\t  if (con == NULL)\n+\t    {\n+\t      con = gfc_get_constructor ();\n+\t      mpz_set (con->n.offset, offset);\n+\t      if (ref->next == NULL)\n+\t\tmpz_set (con->repeat, repeat);\n+\t      gfc_insert_constructor (expr, con);\n+\t    }\n+\t  else\n+\t    assert (ref->next != NULL);\n+\t  break;\n+\n+\tcase REF_COMPONENT:\n+\t  if (init == NULL)\n+\t    {\n+\t      /* Setup the expression to hold the constructor.  */\n+\t      expr->expr_type = EXPR_STRUCTURE;\n+\t      expr->ts.type = BT_DERIVED;\n+\t      expr->ts.derived = ref->u.c.sym;\n+\t    }\n+\t  else\n+\t    assert (expr->expr_type == EXPR_STRUCTURE);\n+\t  last_ts = &ref->u.c.component->ts;\n+\n+\t  /* Find the same element in the existing constructor.  */\n+\t  con = expr->value.constructor;\n+\t  con = find_con_by_component (ref->u.c.component, con);\n+\n+\t  if (con == NULL)\n+\t    {\n+\t      /* Create a new constructor.  */\n+\t      con = gfc_get_constructor ();\n+\t      con->n.component = ref->u.c.component;\n+\t      con->next = expr->value.constructor;\n+\t      expr->value.constructor = con;\n+\t    }\n+\n+\t  /* Since we're only intending to initialize arrays here,\n+\t     there better be an inner reference.  */\n+\t  assert (ref->next != NULL);\n+\t  break;\n+\n+\tcase REF_SUBSTRING:\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      if (init == NULL)\n+\t{\n+\t  /* Point the container at the new expression.  */\n+\t  if (last_con == NULL)\n+\t    symbol->value = expr;\n+\t  else\n+\t    last_con->expr = expr;\n+\t}\n+      init = con->expr;\n+      last_con = con;\n+    }\n+\n+  /* We should never be overwriting an existing initializer.  */\n+  assert (!init);\n+\n+  expr = gfc_copy_expr (rvalue);\n+  if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n+    gfc_convert_type (expr, &lvalue->ts, 0);\n+\n+  if (last_con == NULL)\n+    symbol->value = expr;\n+  else\n+    last_con->expr = expr;\n+}\n \n /* Modify the index of array section and re-calculate the array offset.  */\n "}, {"sha": "e33a0aac7108c8c1f890fcbf490b8ed4010fd4a4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b85024359a4c487de04d6de688036eff93addfa2", "patch": "@@ -1304,9 +1304,8 @@ gfc_data_variable;\n \n typedef struct gfc_data_value\n {\n-  int repeat;\n+  unsigned int repeat;\n   gfc_expr *expr;\n-\n   struct gfc_data_value *next;\n }\n gfc_data_value;\n@@ -1402,6 +1401,7 @@ extern iterator_stack *iter_stack;\n void gfc_formalize_init_value (gfc_symbol *);\n void gfc_get_section_index (gfc_array_ref *, mpz_t *, mpz_t *);\n void gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t);\n+void gfc_assign_data_value_range (gfc_expr *, gfc_expr *, mpz_t, mpz_t);\n void gfc_advance_section (mpz_t *, gfc_array_ref *, mpz_t *);\n \n /* scanner.c */"}, {"sha": "a42fd7f66ab2e1011821ed7ce760fb8deab50d89", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b85024359a4c487de04d6de688036eff93addfa2", "patch": "@@ -2894,13 +2894,15 @@ top_val_list (gfc_data * data)\n \t}\n       else\n \t{\n-\t  msg = gfc_extract_int (expr, &tail->repeat);\n+\t  signed int tmp;\n+\t  msg = gfc_extract_int (expr, &tmp);\n \t  gfc_free_expr (expr);\n \t  if (msg != NULL)\n \t    {\n \t      gfc_error (msg);\n \t      return MATCH_ERROR;\n \t    }\n+\t  tail->repeat = tmp;\n \n \t  m = match_data_constant (&tail->expr);\n \t  if (m == MATCH_NO)"}, {"sha": "dfca4abff013a611d10b5920bbe5967644517f4d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b85024359a4c487de04d6de688036eff93addfa2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b85024359a4c487de04d6de688036eff93addfa2", "patch": "@@ -4037,7 +4037,7 @@ resolve_symbol (gfc_symbol * sym)\n static struct\n {\n   gfc_data_value *vnode;\n-  int left;\n+  unsigned int left;\n }\n values;\n \n@@ -4047,7 +4047,6 @@ values;\n static try\n next_data_value (void)\n {\n-\n   while (values.left == 0)\n     {\n       if (values.vnode->next == NULL)\n@@ -4057,7 +4056,6 @@ next_data_value (void)\n       values.left = values.vnode->repeat;\n     }\n \n-  values.left--;\n   return SUCCESS;\n }\n \n@@ -4086,7 +4084,10 @@ check_data_variable (gfc_data_variable * var, locus * where)\n     gfc_internal_error (\"check_data_variable(): Bad expression\");\n \n   if (e->rank == 0)\n-    mpz_init_set_ui (size, 1);\n+    {\n+      mpz_init_set_ui (size, 1);\n+      ref = NULL;\n+    }\n   else\n     {\n       ref = e->ref;\n@@ -4145,19 +4146,54 @@ check_data_variable (gfc_data_variable * var, locus * where)\n       if (t == FAILURE)\n \tbreak;\n \n+      /* If we have more than one element left in the repeat count,\n+\t and we have more than one element left in the target variable,\n+\t then create a range assignment.  */\n+      /* ??? Only done for full arrays for now, since array sections\n+\t seem tricky.  */\n+      if (mark == AR_FULL && ref && ref->next == NULL\n+\t  && values.left > 1 && mpz_cmp_ui (size, 1) > 0)\n+\t{\n+\t  mpz_t range;\n+\n+\t  if (mpz_cmp_ui (size, values.left) >= 0)\n+\t    {\n+\t      mpz_init_set_ui (range, values.left);\n+\t      mpz_sub_ui (size, size, values.left);\n+\t      values.left = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      mpz_init_set (range, size);\n+\t      values.left -= mpz_get_ui (size);\n+\t      mpz_set_ui (size, 0);\n+\t    }\n+\n+\t  gfc_assign_data_value_range (var->expr, values.vnode->expr,\n+\t\t\t\t       offset, range);\n+\n+\t  mpz_add (offset, offset, range);\n+\t  mpz_clear (range);\n+\t}\n+\n       /* Assign initial value to symbol.  */\n-      gfc_assign_data_value (var->expr, values.vnode->expr, offset);\n+      else\n+\t{\n+\t  values.left -= 1;\n+\t  mpz_sub_ui (size, size, 1);\n \n-      if (mark == AR_FULL)\n-        mpz_add_ui (offset, offset, 1);\n+\t  gfc_assign_data_value (var->expr, values.vnode->expr, offset);\n \n-      /* Modify the array section indexes and recalculate the offset for\n-         next element.  */\n-      else if (mark == AR_SECTION)\n-        gfc_advance_section (section_index, ar, &offset);\n+\t  if (mark == AR_FULL)\n+\t    mpz_add_ui (offset, offset, 1);\n \n-      mpz_sub_ui (size, size, 1);\n+\t  /* Modify the array section indexes and recalculate the offset\n+\t     for next element.  */\n+\t  else if (mark == AR_SECTION)\n+\t    gfc_advance_section (section_index, ar, &offset);\n+\t}\n     }\n+\n   if (mark == AR_SECTION)\n     {\n       for (i = 0; i < ar->dimen; i++)\n@@ -4253,7 +4289,6 @@ traverse_data_var (gfc_data_variable * var, locus * where)\n static try\n resolve_data_variables (gfc_data_variable * d)\n {\n-\n   for (; d; d = d->next)\n     {\n       if (d->list == NULL)\n@@ -4287,7 +4322,6 @@ resolve_data_variables (gfc_data_variable * d)\n static void\n resolve_data (gfc_data * d)\n {\n-\n   if (resolve_data_variables (d->var) == FAILURE)\n     return;\n \n@@ -4312,7 +4346,6 @@ resolve_data (gfc_data * d)\n int\n gfc_impure_variable (gfc_symbol * sym)\n {\n-\n   if (sym->attr.use_assoc || sym->attr.in_common)\n     return 1;\n \n@@ -4606,4 +4639,3 @@ gfc_resolve (gfc_namespace * ns)\n \n   gfc_current_ns = old_ns;\n }\n-"}]}