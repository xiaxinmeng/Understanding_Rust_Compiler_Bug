{"sha": "f1777882848782d544dc535999a9a29ab2a33cc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3Nzc4ODI4NDg3ODJkNTQ0ZGM1MzU5OTlhOWEyOWFiMmEzM2NjOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-21T07:29:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-21T07:29:36Z"}, "message": "arm.c: Convert to ISO-C.\n\n\t* config/arm/arm.c: Convert to ISO-C.\n\t* config/avr/avr.h: Likewise.\n\t* config/fr30/fr30.c: Likewise.\n\t* config/ip2k/ip2k.c: Likewise.\n\t* config/mn10300/mn10300.c: Likewise.\n\nFrom-SVN: r74901", "tree": {"sha": "88919d9cb6722c9bed03039c39da59e96ab1501b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88919d9cb6722c9bed03039c39da59e96ab1501b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1777882848782d544dc535999a9a29ab2a33cc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1777882848782d544dc535999a9a29ab2a33cc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1777882848782d544dc535999a9a29ab2a33cc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1777882848782d544dc535999a9a29ab2a33cc9/comments", "author": null, "committer": null, "parents": [{"sha": "5785c0ed5dd49c1d2218b36827e05ecb866beacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785c0ed5dd49c1d2218b36827e05ecb866beacf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5785c0ed5dd49c1d2218b36827e05ecb866beacf"}], "stats": {"total": 461, "additions": 135, "deletions": 326}, "files": [{"sha": "e87af7551d7abacf1a90da6d7cf809769780cadb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -1,3 +1,11 @@\n+2003-12-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/arm/arm.c: Convert to ISO-C.\n+\t* config/avr/avr.h: Likewise.\n+\t* config/fr30/fr30.c: Likewise.\n+\t* config/ip2k/ip2k.c: Likewise.\n+\t* config/mn10300/mn10300.c: Likewise.\n+\n 2003-12-20  Andrew Pinski  <pinskia@gcc.gnu.org>\n             Matt Thomas  <matt@3am-software.com>\n "}, {"sha": "936f3e8551f55d7169fd8f8e629f66d07c395726", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -13008,7 +13008,7 @@ aof_globalize_label (FILE *stream, const char *name)\n }\n \n static void\n-aof_file_start ()\n+aof_file_start (void)\n {\n   fputs (\"__r0\\tRN\\t0\\n\", asm_out_file);\n   fputs (\"__a1\\tRN\\t0\\n\", asm_out_file);"}, {"sha": "547e927f52fa24f68fadb1d6cabe3496245a3842", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -1644,7 +1644,7 @@ do {\t\t\t\t\t\t\t\t\t    \\\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t      \\\n \t\t\t\t\t\t\t\t\t      \\\n void\t\t\t\t\t\t\t\t\t      \\\n-progmem_section ()\t\t\t\t\t\t\t      \\\n+progmem_section (void)\t\t\t\t\t\t\t      \\\n {\t\t\t\t\t\t\t\t\t      \\\n   if (in_section != in_progmem)\t\t\t\t\t\t      \\\n     {\t\t\t\t\t\t\t\t\t      \\"}, {"sha": "c702d0bbe280fd93d7ffa10d548040d0c12a99f9", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 25, "deletions": 63, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -154,9 +154,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    for the current function.  As a side effect it fills in the \n    current_frame_info structure, if the data is available.  */\n unsigned int\n-fr30_compute_frame_size (from_reg, to_reg)\n-     int from_reg;\n-     int to_reg;\n+fr30_compute_frame_size (int from_reg, int to_reg)\n {\n   int \t\tregno;\n   unsigned int \treturn_value;\n@@ -219,7 +217,7 @@ fr30_compute_frame_size (from_reg, to_reg)\n    insn to prevent such scheduling.  */\n \n void\n-fr30_expand_prologue ()\n+fr30_expand_prologue (void)\n {\n   int regno;\n   rtx insn;\n@@ -347,7 +345,7 @@ fr30_expand_prologue ()\n    In some cases, it might be necessary to emit a barrier instruction as the\n    first insn to prevent such scheduling.  */\n void\n-fr30_expand_epilogue ()\n+fr30_expand_epilogue (void)\n {\n   int regno;\n \n@@ -406,11 +404,10 @@ fr30_expand_epilogue ()\n    ARG_REGS_USED_SO_FAR has *not* been updated for the last named argument\n    which has type TYPE and mode MODE, and we rely on this fact.  */\n void\n-fr30_setup_incoming_varargs (arg_regs_used_so_far, int_mode, type, pretend_size)\n-     CUMULATIVE_ARGS arg_regs_used_so_far;\n-     int             int_mode;\n-     tree            type ATTRIBUTE_UNUSED;\n-     int *           pretend_size;\n+fr30_setup_incoming_varargs (CUMULATIVE_ARGS arg_regs_used_so_far,\n+\t\t\t     int int_mode,\n+\t\t\t     tree type ATTRIBUTE_UNUSED,\n+\t\t\t     int *pretend_size)\n {\n   enum machine_mode mode = (enum machine_mode)int_mode;\n   int               size;\n@@ -440,9 +437,7 @@ fr30_setup_incoming_varargs (arg_regs_used_so_far, int_mode, type, pretend_size)\n /* Print a memory address as an operand to reference that memory location.  */\n \n void\n-fr30_print_operand_address (stream, address)\n-     FILE * stream;\n-     rtx    address;\n+fr30_print_operand_address (FILE *stream, rtx address)\n {\n   switch (GET_CODE (address))\n     {\n@@ -461,10 +456,7 @@ fr30_print_operand_address (stream, address)\n /* Print an operand.  */\n \n void\n-fr30_print_operand (file, x, code)\n-     FILE * file;\n-     rtx    x;\n-     int    code;\n+fr30_print_operand (FILE *file, rtx x, int code)\n {\n   rtx x0;\n   \n@@ -665,9 +657,7 @@ fr30_print_operand (file, x, code)\n /* Compute the number of word sized registers needed to hold a\n    function argument of mode INT_MODE and tree type TYPE.  */\n int\n-fr30_num_arg_regs (int_mode, type)\n-     int int_mode;\n-     tree type;\n+fr30_num_arg_regs (int int_mode, tree type)\n {\n   enum machine_mode mode = (enum machine_mode) int_mode;\n   int size;\n@@ -692,11 +682,8 @@ fr30_num_arg_regs (int_mode, type)\n    parameters to the function.  */\n \n int\n-fr30_function_arg_partial_nregs (cum, int_mode, type, named)\n-     CUMULATIVE_ARGS cum;\n-     int int_mode;\n-     tree type;\n-     int named;\n+fr30_function_arg_partial_nregs (CUMULATIVE_ARGS cum, int int_mode,\n+\t\t\t\t tree type, int named)\n {\n   /* Unnamed arguments, ie those that are prototyped as ...\n      are always passed on the stack.\n@@ -718,9 +705,7 @@ fr30_function_arg_partial_nregs (cum, int_mode, type, named)\n }\n \n static rtx\n-fr30_pass_by_reference (valist, type)\n-     tree valist;\n-     tree type;\n+fr30_pass_by_reference (tree valist, tree type)\n {\n   tree type_ptr;\n   tree type_ptr_ptr;\n@@ -739,9 +724,7 @@ fr30_pass_by_reference (valist, type)\n }\n \n static rtx\n-fr30_pass_by_value (valist, type)\n-     tree valist;\n-     tree type;\n+fr30_pass_by_value (tree valist, tree type)\n {\n   HOST_WIDE_INT size = int_size_in_bytes (type);\n   HOST_WIDE_INT rsize;\n@@ -775,9 +758,7 @@ fr30_pass_by_value (valist, type)\n /* Implement `va_arg'.  */\n \n rtx\n-fr30_va_arg (valist, type)\n-     tree valist;\n-     tree type;\n+fr30_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size;\n   \n@@ -803,9 +784,7 @@ fr30_va_arg (valist, type)\n /* Returns true if OPERAND is an integer value suitable for use in\n    an ADDSP instruction.  */\n int\n-stack_add_operand (operand, mode)\n-     rtx operand;\n-     Mmode mode ATTRIBUTE_UNUSED;\n+stack_add_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED)\n {\n   return\n     (GET_CODE (operand) == CONST_INT\n@@ -817,9 +796,7 @@ stack_add_operand (operand, mode)\n /* Returns true if OPERAND is an integer value suitable for use in\n    an ADD por ADD2 instruction, or if it is a register.  */\n int\n-add_immediate_operand (operand, mode)\n-     rtx operand;\n-     Mmode mode ATTRIBUTE_UNUSED;\n+add_immediate_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED)\n {\n   return\n     (GET_CODE (operand) == REG\n@@ -830,9 +807,7 @@ add_immediate_operand (operand, mode)\n \n /* Returns true if OPERAND is hard register in the range 8 - 15.  */\n int\n-high_register_operand (operand, mode)\n-     rtx operand;\n-     Mmode mode ATTRIBUTE_UNUSED;\n+high_register_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED)\n {\n   return\n     (GET_CODE (operand) == REG\n@@ -842,9 +817,7 @@ high_register_operand (operand, mode)\n \n /* Returns true if OPERAND is hard register in the range 0 - 7.  */\n int\n-low_register_operand (operand, mode)\n-     rtx operand;\n-     Mmode mode ATTRIBUTE_UNUSED;\n+low_register_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED)\n {\n   return\n     (GET_CODE (operand) == REG\n@@ -853,9 +826,7 @@ low_register_operand (operand, mode)\n \n /* Returns true if OPERAND is suitable for use in a CALL insn.  */\n int\n-call_operand (operand, mode)\n-     rtx operand;\n-     Mmode mode ATTRIBUTE_UNUSED;\n+call_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (operand) == MEM\n \t  && (GET_CODE (XEXP (operand, 0)) == SYMBOL_REF\n@@ -864,9 +835,7 @@ call_operand (operand, mode)\n \n /* Returns TRUE if OP is a valid operand of a DImode operation.  */\n int\n-di_operand (op, mode)\n-     rtx op;\n-     Mmode mode;\n+di_operand (rtx op, Mmode mode)\n {\n   if (register_operand (op, mode))\n     return TRUE;\n@@ -893,9 +862,7 @@ di_operand (op, mode)\n \n /* Returns TRUE if OP is a DImode register or MEM.  */\n int\n-nonimmediate_di_operand (op, mode)\n-     rtx op;\n-     Mmode mode;\n+nonimmediate_di_operand (rtx op, Mmode mode)\n {\n   if (register_operand (op, mode))\n     return TRUE;\n@@ -915,10 +882,7 @@ nonimmediate_di_operand (op, mode)\n /* Returns true iff all the registers in the operands array\n    are in descending or ascending order.  */\n int\n-fr30_check_multiple_regs (operands, num_operands, descending)\n-     rtx * operands;\n-     int   num_operands;\n-     int   descending;\n+fr30_check_multiple_regs (rtx *operands, int num_operands, int descending)\n {\n   if (descending)\n     {\n@@ -955,8 +919,7 @@ fr30_check_multiple_regs (operands, num_operands, descending)\n }\n \n int\n-fr30_const_double_is_zero (operand)\n-     rtx operand;\n+fr30_const_double_is_zero (rtx operand)\n {\n   REAL_VALUE_TYPE d;\n \n@@ -979,8 +942,7 @@ fr30_const_double_is_zero (operand)\n    before we can use it.  */\n \n rtx\n-fr30_move_double (operands)\n-     rtx * operands;\n+fr30_move_double (rtx * operands)\n {\n   rtx src  = operands[1];\n   rtx dest = operands[0];"}, {"sha": "b8a9eedef34618475f99a936210fcce1bbc2f554", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 63, "deletions": 171, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -143,8 +143,7 @@ int ip2k_reorg_merge_qimode = 0;\n /* Set up local allocation order.  */\n \n void\n-ip2k_init_local_alloc (rao)\n-     int * rao;\n+ip2k_init_local_alloc (int *rao)\n {\n   static const int alloc_order[] = REG_ALLOC_ORDER;\n \n@@ -159,10 +158,7 @@ ip2k_init_local_alloc (rao)\n    SIZE is the number of bytes of arguments passed on the stack.  */\n \n int\n-ip2k_return_pops_args (fundecl, funtype, size)\n-     tree fundecl ATTRIBUTE_UNUSED;\n-     tree funtype;\n-     int size;\n+ip2k_return_pops_args (tree fundecl ATTRIBUTE_UNUSED, tree funtype, int size)\n {\n   if (TREE_CODE (funtype) == IDENTIFIER_NODE)\n     return size;\n@@ -177,8 +173,7 @@ ip2k_return_pops_args (fundecl, funtype, size)\n /* Return nonzero if FUNC is a naked function.  */\n \n static int\n-ip2k_naked_function_p (func)\n-     tree func;\n+ip2k_naked_function_p (tree func)\n {\n   tree a;\n \n@@ -191,9 +186,7 @@ ip2k_naked_function_p (func)\n \n /* Output function prologue.  */\n void\n-function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+function_prologue (FILE *file, HOST_WIDE_INT size)\n {\n   int leaf_func_p;\n   int main_p;\n@@ -314,9 +307,7 @@ function_prologue (file, size)\n \n /* Output function epilogue.  */\n void\n-function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+function_epilogue (FILE *file, HOST_WIDE_INT size)\n {\n   int leaf_func_p;\n   int reg,savelimit;\n@@ -550,9 +541,7 @@ function_epilogue (file, size)\n \tSTACK ALLOCATION\n \t\t<------ SP ($6:$7)  */\n int\n-ip2k_init_elim_offset (from, to)\n-     int from;\n-     int to;\n+ip2k_init_elim_offset (int from, int to)\n {\n   int leaf_func_p = leaf_function_p ();\n   int no_saved_pc = leaf_func_p\n@@ -597,10 +586,7 @@ ip2k_init_elim_offset (from, to)\n    machine for a memory operand of mode MODE.  */\n \n int\n-legitimate_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   int off;\n \n@@ -689,8 +675,7 @@ legitimate_address_p (mode, x, strict)\n \n /* Is ADDR mode dependent?  */\n int\n-ip2k_mode_dependent_address (addr)\n-     rtx addr;\n+ip2k_mode_dependent_address (rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -712,11 +697,8 @@ ip2k_mode_dependent_address (addr)\n    memory address for an operand of mode MODE.  */\n \n rtx\n-legitimize_address (x, oldx, mode, scratch)\n-     rtx x;\n-     rtx oldx ATTRIBUTE_UNUSED;\n-     rtx scratch;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED, rtx scratch)\n {\n   rtx reg;\n \n@@ -747,8 +729,7 @@ legitimize_address (x, oldx, mode, scratch)\n    data and stack variables reside in data memory.  Only code is believed\n    to be in PRAM or FLASH.  */\n int\n-is_regfile_address (x)\n-     rtx x;\n+is_regfile_address (rtx x)\n {\n   while (1)\n     switch (GET_CODE (x))\n@@ -775,9 +756,7 @@ is_regfile_address (x)\n /* Output ADDR to FILE as address.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -848,10 +827,7 @@ print_operand_address (file, addr)\n /* Output X as assembler operand to file FILE.  */\n      \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   int abcd = 0;\n   unsigned long value;\n@@ -1101,9 +1077,7 @@ print_operand (file, x, code)\n \f\n /* Remember the operands for the compare.  */\n const char *\n-ip2k_set_compare (x, y)\n-     rtx x;\n-     rtx y;\n+ip2k_set_compare (rtx x, rtx y)\n {\n   ip2k_compare_operands[0] = x;\n   ip2k_compare_operands[1] = y;\n@@ -1112,10 +1086,7 @@ ip2k_set_compare (x, y)\n \n /* Emit the code for sCOND instructions.  */\n const char *\n-ip2k_gen_sCOND (insn, code, dest)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     enum rtx_code code;\n-     rtx dest;\n+ip2k_gen_sCOND (rtx insn ATTRIBUTE_UNUSED, enum rtx_code code, rtx dest)\n {\n #define operands ip2k_compare_operands\n   enum machine_mode mode;\n@@ -1326,10 +1297,7 @@ ip2k_gen_sCOND (insn, code, dest)\n }\n \n const char *\n-ip2k_gen_signed_comp_branch (insn, code, label)\n-     rtx insn;\n-     enum rtx_code code;\n-     rtx label;\n+ip2k_gen_signed_comp_branch (rtx insn, enum rtx_code code, rtx label)\n {\n #define operands ip2k_compare_operands\n   enum machine_mode mode;\n@@ -1675,10 +1643,7 @@ ip2k_gen_signed_comp_branch (insn, code, label)\n }\n \n const char *\n-ip2k_gen_unsigned_comp_branch (insn, code, label)\n-     rtx insn;\n-     enum rtx_code code;\n-     rtx label;\n+ip2k_gen_unsigned_comp_branch (rtx insn, enum rtx_code code, rtx label)\n {\n #define operands ip2k_compare_operands\n   enum machine_mode mode;\n@@ -3043,9 +3008,7 @@ ip2k_gen_unsigned_comp_branch (insn, code, label)\n /* Output rtx VALUE as .byte to file FILE.  */\n \n void\n-asm_output_char(file, value)\n-     FILE *file;\n-     rtx value;\n+asm_output_char (FILE *file, rtx value)\n {\n   fprintf (file, \"\\t.byte \");\n   output_addr_const (file, value);\n@@ -3056,9 +3019,7 @@ asm_output_char(file, value)\n /* Output VALUE as .byte to file FILE.  */\n \n void\n-asm_output_byte (file,value)\n-     FILE *file;\n-     int value;\n+asm_output_byte (FILE *file, int value)\n {\n   fprintf (file, \"\\t.byte 0x%x\\n\",value & 0xff);\n }\n@@ -3067,9 +3028,7 @@ asm_output_byte (file,value)\n /* Output rtx VALUE as .word to file FILE.  */\n \n void\n-asm_output_short (file, value)\n-     FILE *file;\n-     rtx value;\n+asm_output_short (FILE *file, rtx value)\n {\n   fprintf (file, \"\\t.word \");\n   output_addr_const (file, (value));\n@@ -3080,9 +3039,7 @@ asm_output_short (file, value)\n /* Output real N to file FILE.  */\n \n void\n-asm_output_float (file, n)\n-     FILE *file;\n-     REAL_VALUE_TYPE n;\n+asm_output_float (FILE *file, REAL_VALUE_TYPE n)\n {\n   long val;\n   char dstr[100];\n@@ -3096,9 +3053,7 @@ asm_output_float (file, n)\n /* Sets section name for declaration DECL.  */\n   \n void\n-unique_section (decl, reloc)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n+unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n {\n   int len;\n   const char *name;\n@@ -3131,11 +3086,8 @@ unique_section (decl, reloc)\n /* Output section name to file FILE.  */\n \n void\n-asm_output_section_name(file, decl, name, reloc)\n-     FILE *file;\n-     tree decl ATTRIBUTE_UNUSED;\n-     const char *name;\n-     int reloc ATTRIBUTE_UNUSED;\n+asm_output_section_name (FILE *file, tree decl ATTRIBUTE_UNUSED,\n+\t\t\t const char *name, int reloc ATTRIBUTE_UNUSED)\n {\n   fprintf (file, \".section %s\\n\", name);\n }\n@@ -3145,8 +3097,7 @@ asm_output_section_name(file, decl, name, reloc)\n    because registers of CLASS are needed for spill registers.  */\n \n enum reg_class\n-class_likely_spilled_p(c)\n-     int c;\n+class_likely_spilled_p (int c)\n {\n   return (c == IP_REGS\n \t  || c == IPL_REGS\n@@ -3176,12 +3127,10 @@ const struct attribute_spec ip2k_attribute_table[] =\n /* Handle a \"progmem\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-ip2k_handle_progmem_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+ip2k_handle_progmem_attribute (tree *node, tree name,\n+\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t       bool *no_add_attrs)\n {\n   if (DECL_P (*node))\n     {\n@@ -3220,12 +3169,10 @@ ip2k_handle_progmem_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-ip2k_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+ip2k_handle_fndecl_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -3244,10 +3191,7 @@ ip2k_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-ip2k_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+ip2k_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n   int extra_cost = 0;\n@@ -3380,8 +3324,7 @@ ip2k_rtx_costs (x, code, outer_code, total)\n /* Calculate the cost of a memory address.  */\n \n static int\n-ip2k_address_cost (x)\n-     rtx x;\n+ip2k_address_cost (rtx x)\n {\n   switch (legitimate_address_p (VOIDmode, x, 0))\n     {\n@@ -4160,9 +4103,7 @@ mdr_try_move_dp_reload (first_insn)\n    a fixed constant, offset.  If it definitely can then returns nonzero.  */\n \n static int\n-ip2k_check_can_adjust_stack_ref (x, offset)\n-     rtx x;\n-     int offset;\n+ip2k_check_can_adjust_stack_ref (rtx x, int offset)\n {\n   if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n       || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n@@ -4208,9 +4149,7 @@ ip2k_check_can_adjust_stack_ref (x, offset)\n    a fixed offset.  */\n \n static void\n-ip2k_adjust_stack_ref (x, offset)\n-     rtx *x;\n-     int offset;\n+ip2k_adjust_stack_ref (rtx *x, int offset)\n {\n   if (GET_RTX_CLASS (GET_CODE (*x)) == '2'\n       || GET_RTX_CLASS (GET_CODE (*x)) == 'c')\n@@ -4699,9 +4638,7 @@ mdr_try_propagate_clr (first_insn)\n    nonzero if we definitely don't have such a memory ref.  */\n \n static int\n-ip2k_xexp_not_uses_reg_for_mem (x, regno)\n-     rtx x;\n-     unsigned int regno;\n+ip2k_xexp_not_uses_reg_for_mem (rtx x, unsigned int regno)\n {\n   if (regno & 1)\n     regno &= 0xfffffffe;\n@@ -5316,7 +5253,7 @@ mdr_try_wreg_elim (first_insn)\n    making the subsequent runs continue to win.  */\n \n static void\n-ip2k_reorg ()\n+ip2k_reorg (void)\n {\n #ifdef IP2K_MD_REORG_PASS\n   rtx first_insn, insn, set;\n@@ -5518,8 +5455,7 @@ ip2k_init_libfuncs (void)\n /* Returns a bit position if mask contains only a single bit.  Returns -1 if\n    there were zero or more than one set bits.  */\n int\n-find_one_set_bit_p (mask)\n-     HOST_WIDE_INT mask;\n+find_one_set_bit_p (HOST_WIDE_INT mask)\n {\n   int i;\n   unsigned HOST_WIDE_INT n = mask;\n@@ -5540,8 +5476,7 @@ find_one_set_bit_p (mask)\n /* Returns a bit position if mask contains only a single clear bit.\n    Returns -1 if there were zero or more than one clear bits.  */\n int\n-find_one_clear_bit_p (mask)\n-     HOST_WIDE_INT mask;\n+find_one_clear_bit_p (HOST_WIDE_INT mask)\n {\n   int i;\n   unsigned HOST_WIDE_INT n = mask;\n@@ -5568,10 +5503,8 @@ find_one_clear_bit_p (mask)\n    and OPERANDS[5].  */\n \n void\n-ip2k_split_words (nmode, omode, operands)\n-     enum machine_mode nmode;\n-     enum machine_mode omode;\n-     rtx *operands;\n+ip2k_split_words (enum machine_mode nmode, enum machine_mode omode,\n+\t\t  rtx *operands)\n {\n   rtx dl, dh;\t\t\t/* src/dest pieces.  */\n   rtx sl, sh;\n@@ -5759,9 +5692,7 @@ ip2k_split_words (nmode, omode, operands)\n \n /* Get the low half of an operand.  */\n rtx\n-ip2k_get_low_half (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_get_low_half (rtx x, enum machine_mode mode)\n {\n   switch (GET_CODE (x))\n     {\n@@ -5860,9 +5791,7 @@ ip2k_get_low_half (x, mode)\n \n /* Get the high half of an operand.  */\n rtx\n-ip2k_get_high_half (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_get_high_half (rtx x, enum machine_mode mode)\n {\n   switch (GET_CODE (x))\n     {\n@@ -5962,9 +5891,7 @@ ip2k_get_high_half (x, mode)\n    or REG_FP.  */\n \n int\n-ip2k_address_uses_reg_p (x, r)\n-     rtx x;\n-     unsigned int r;\n+ip2k_address_uses_reg_p (rtx x, unsigned int r)\n {\n   if (GET_CODE (x) != MEM)\n     return 0;\n@@ -6011,10 +5938,7 @@ ip2k_address_uses_reg_p (x, r)\n    that it doesn't then we return TRUE otherwise we assume FALSE.  */\n \n int\n-ip2k_xexp_not_uses_reg_p (x, r, rsz)\n-     rtx x;\n-     unsigned int r;\n-     int rsz;\n+ip2k_xexp_not_uses_reg_p (rtx x, unsigned int r, int rsz)\n {\n   switch (GET_CODE (x))\n     {\n@@ -6047,10 +5971,7 @@ ip2k_xexp_not_uses_reg_p (x, r, rsz)\n    that it doesn't then we return TRUE otherwise we assume FALSE.  */\n \n int\n-ip2k_composite_xexp_not_uses_reg_p (x, r, rsz)\n-     rtx x;\n-     unsigned int r;\n-     int rsz;\n+ip2k_composite_xexp_not_uses_reg_p (rtx x, unsigned int r, int rsz)\n {\n   if (GET_RTX_CLASS (GET_CODE (x)) == 'b')\n     return (ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 0), r, rsz)\n@@ -6074,8 +5995,7 @@ ip2k_composite_xexp_not_uses_reg_p (x, r, rsz)\n    it doesn't then we return TRUE otherwise we assume FALSE.  */\n \n int\n-ip2k_composite_xexp_not_uses_cc0_p (x)\n-     rtx x;\n+ip2k_composite_xexp_not_uses_cc0_p (rtx x)\n {\n   if (GET_RTX_CLASS (GET_CODE (x)) == 'b')\n     return (ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 0))\n@@ -6096,27 +6016,21 @@ ip2k_composite_xexp_not_uses_cc0_p (x)\n }\n \n int\n-ip2k_split_dest_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_split_dest_operand (rtx x, enum machine_mode mode)\n {\n   return nonimmediate_operand (x, mode) || push_operand (x, mode);\n }\n \n int\n-ip2k_nonptr_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_nonptr_operand (rtx x, enum machine_mode mode)\n {\n   return register_operand (x, mode) && !ip2k_ptr_operand (x, mode);\n }\n \n /* Is X a reference to IP or DP or SP?  */\n \n int\n-ip2k_ptr_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_ptr_operand (rtx x, enum machine_mode mode)\n \n {\n   if (GET_CODE (x) == SUBREG)\n@@ -6130,18 +6044,14 @@ ip2k_ptr_operand (x, mode)\n }\n \n int\n-ip2k_sp_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ip2k_sp_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n {\n   return REG_P (x) && REGNO (x) == REG_SP;\n }\n \n int\n-ip2k_ip_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_ip_operand (rtx x, enum machine_mode mode)\n \n {\n   if (GET_CODE (x) != MEM)\n@@ -6163,9 +6073,7 @@ ip2k_ip_operand (x, mode)\n \n /* Is X a memory address suitable for SP or DP relative addressing?  */\n int\n-ip2k_short_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_short_operand (rtx x, enum machine_mode mode)\n {\n   int r;\n   unsigned int offs = 0;\n@@ -6211,9 +6119,7 @@ ip2k_short_operand (x, mode)\n }\n \n int\n-ip2k_nonsp_reg_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ip2k_nonsp_reg_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -6222,9 +6128,7 @@ ip2k_nonsp_reg_operand (x, mode)\n }\n \n int\n-ip2k_gen_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ip2k_gen_operand (rtx x, enum machine_mode mode)\n {\n   return ip2k_short_operand (x, mode)\n     || (GET_CODE (x) == SUBREG\n@@ -6233,9 +6137,7 @@ ip2k_gen_operand (x, mode)\n }\n \n int\n-ip2k_extra_constraint (x, c)\n-     rtx x;\n-     int c;\n+ip2k_extra_constraint (rtx x, int c)\n { \n   switch (c)\n     {\n@@ -6254,28 +6156,22 @@ ip2k_extra_constraint (x, c)\n }\n \n int\n-ip2k_unary_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ip2k_unary_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n \t  && GET_RTX_CLASS (GET_CODE (op)) == '1');\n }\n \n int\n-ip2k_binary_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ip2k_binary_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n \t  && (GET_RTX_CLASS (GET_CODE (op)) == 'c'\n \t      || GET_RTX_CLASS (GET_CODE (op)) == '2'));\n }\n \n int\n-ip2k_symbol_ref_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+ip2k_symbol_ref_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   /* We define an IP2k symbol ref to be either a direct reference or one\n      with a constant offset.  */\n@@ -6286,18 +6182,14 @@ ip2k_symbol_ref_operand (op, mode)\n }\n \n int\n-ip2k_signed_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ip2k_signed_comparison_operator (rtx op, enum machine_mode mode)\n {\n   return (comparison_operator (op, mode)\n     && signed_condition (GET_CODE (op)) == GET_CODE (op));\n }\n \n int\n-ip2k_unsigned_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ip2k_unsigned_comparison_operator (rtx op, enum machine_mode mode)\n {\n   return (comparison_operator (op, mode)\n           && unsigned_condition (GET_CODE (op)) == GET_CODE (op));"}, {"sha": "2e8fcdad9e31fb88c20451de4a3a798a0c11e988", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 37, "deletions": 90, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1777882848782d544dc535999a9a29ab2a33cc9/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f1777882848782d544dc535999a9a29ab2a33cc9", "patch": "@@ -92,7 +92,7 @@ static void mn10300_encode_section_info (tree, rtx, int);\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n static void\n-mn10300_file_start ()\n+mn10300_file_start (void)\n {\n   default_file_start ();\n \n@@ -107,10 +107,7 @@ mn10300_file_start ()\n    FILE.  */\n \n void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -437,9 +434,7 @@ print_operand (file, x, code)\n /* Output assembly language output for the address ADDR to FILE.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -477,7 +472,7 @@ print_operand_address (file, addr)\n \n /* Count the number of FP registers that have to be saved.  */\n static int\n-fp_regs_to_save ()\n+fp_regs_to_save (void)\n {\n   int i, n = 0;\n \n@@ -498,9 +493,7 @@ fp_regs_to_save ()\n    bits 14 to 17 must have the same value. */\n \n void\n-mn10300_print_reg_list (file, mask)\n-     FILE *file;\n-     int mask;\n+mn10300_print_reg_list (FILE *file, int mask)\n {\n   int need_comma;\n   int i;\n@@ -531,7 +524,7 @@ mn10300_print_reg_list (file, mask)\n }\n \n int\n-can_use_return_insn ()\n+can_use_return_insn (void)\n {\n   /* size includes the fixed stack space needed for function calls.  */\n   int size = get_frame_size () + current_function_outgoing_args_size;\n@@ -558,7 +551,7 @@ can_use_return_insn ()\n    all of them will be included in the mask if any one of them is used. */\n \n int\n-mn10300_get_live_callee_saved_regs ()\n+mn10300_get_live_callee_saved_regs (void)\n {\n   int mask;\n   int i;\n@@ -593,8 +586,7 @@ mn10300_get_live_callee_saved_regs ()\n \t      (reg:SI R1))) */\n \n void\n-mn10300_gen_multiple_store (mask)\n-     int mask;\n+mn10300_gen_multiple_store (int mask)\n {\n   if (mask != 0)\n     {\n@@ -642,7 +634,7 @@ mn10300_gen_multiple_store (mask)\n }\n \n void\n-expand_prologue ()\n+expand_prologue (void)\n {\n   HOST_WIDE_INT size;\n \n@@ -917,7 +909,7 @@ expand_prologue ()\n }\n \n void\n-expand_epilogue ()\n+expand_epilogue (void)\n {\n   HOST_WIDE_INT size;\n \n@@ -1155,9 +1147,7 @@ expand_epilogue ()\n /* Update the condition code from the insn.  */\n \n void\n-notice_update_cc (body, insn)\n-     rtx body;\n-     rtx insn;\n+notice_update_cc (rtx body, rtx insn)\n {\n   switch (get_attr_cc (insn))\n     {\n@@ -1220,9 +1210,7 @@ notice_update_cc (body, insn)\n    registers it saves.  Return 0 otherwise.  */\n \n int\n-store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count;\n   int mask;\n@@ -1298,9 +1286,7 @@ store_multiple_operation (op, mode)\n /* Return true if OP is a valid call operand.  */\n \n int\n-call_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_address_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic)\n     return (EXTRA_CONSTRAINT (op, 'S') || GET_CODE (op) == REG);\n@@ -1313,10 +1299,7 @@ call_address_operand (op, mode)\n \n    We might be able to simplify this.  */\n enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n+secondary_reload_class (enum reg_class class, enum machine_mode mode, rtx in)\n {\n   /* Memory loads less than a full word wide can't have an\n      address or stack pointer destination.  They must use\n@@ -1372,8 +1355,7 @@ secondary_reload_class (class, mode, in)\n }\n \n int\n-initial_offset (from, to)\n-     int from, to;\n+initial_offset (int from, int to)\n {\n   /* The difference between the argument pointer and the frame pointer\n      is the size of the callee register save area.  */\n@@ -1426,7 +1408,7 @@ initial_offset (from, to)\n /* Flush the argument registers to the stack for a stdarg function;\n    return the new argument pointer.  */\n rtx\n-mn10300_builtin_saveregs ()\n+mn10300_builtin_saveregs (void)\n {\n   rtx offset, mem;\n   tree fntype = TREE_TYPE (current_function_decl);\n@@ -1456,17 +1438,14 @@ mn10300_builtin_saveregs ()\n }\n \n void\n-mn10300_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+mn10300_va_start (tree valist, rtx nextarg)\n {\n   nextarg = expand_builtin_saveregs ();\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \n rtx\n-mn10300_va_arg (valist, type)\n-     tree valist, type;\n+mn10300_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT align, rsize;\n   tree t, ptr, pptr;\n@@ -1505,11 +1484,8 @@ mn10300_va_arg (valist, type)\n    from a function.  If the result is 0, the argument is pushed.  */\n \n rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t      tree type, int named ATTRIBUTE_UNUSED)\n {\n   rtx result = 0;\n   int size, align;\n@@ -1558,11 +1534,8 @@ function_arg (cum, mode, type, named)\n    in registers and partially in memory.  */\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n {\n   int size, align;\n \n@@ -1599,8 +1572,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n \n /* Output a tst insn.  */\n const char *\n-output_tst (operand, insn)\n-     rtx operand, insn;\n+output_tst (rtx operand, rtx insn)\n {\n   rtx temp;\n   int past_call = 0;\n@@ -1689,9 +1661,7 @@ output_tst (operand, insn)\n }\n \n int\n-impossible_plus_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+impossible_plus_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != PLUS)\n     return 0;\n@@ -1707,9 +1677,7 @@ impossible_plus_operand (op, mode)\n    for the btst insn which may examine memory or a register (the memory\n    variant only allows an unsigned 8 bit integer).  */\n int\n-const_8bit_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_8bit_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) >= 0\n@@ -1718,19 +1686,15 @@ const_8bit_operand (op, mode)\n \n /* Return true if the operand is the 1.0f constant.  */\n int\n-const_1f_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_1f_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (op == CONST1_RTX (SFmode));\n }\n \n /* Similarly, but when using a zero_extract pattern for a btst where\n    the source operand might end up in memory.  */\n int\n-mask_ok_for_mem_btst (len, bit)\n-     int len;\n-     int bit;\n+mask_ok_for_mem_btst (int len, int bit)\n {\n   unsigned int mask = 0;\n \n@@ -1752,9 +1716,7 @@ mask_ok_for_mem_btst (len, bit)\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n int\n-symbolic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1787,10 +1749,8 @@ symbolic_operand (op, mode)\n    But on a few ports with segmented architectures and indexed addressing\n    (mn10300, hppa) it is used to rewrite certain problematical addresses.  */\n rtx\n-legitimize_address (x, oldx, mode)\n-     rtx x;\n-     rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic && ! legitimate_pic_operand_p (x))\n     x = legitimize_pic_address (oldx, NULL_RTX);\n@@ -1828,9 +1788,7 @@ legitimize_address (x, oldx, mode)\n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n    @GOTOFF in `reg'. */\n rtx\n-legitimize_pic_address (orig, reg)\n-     rtx orig;\n-     rtx reg;\n+legitimize_pic_address (rtx orig, rtx reg)\n {\n   if (GET_CODE (orig) == LABEL_REF\n       || (GET_CODE (orig) == SYMBOL_REF\n@@ -1857,8 +1815,7 @@ legitimize_pic_address (orig, reg)\n /* Return zero if X references a SYMBOL_REF or LABEL_REF whose symbol\n    isn't protected by a PIC unspec; nonzero otherwise.  */\n int\n-legitimate_pic_operand_p (x)\n-     rtx x;\n+legitimate_pic_operand_p (rtx x)\n {\n   register const char *fmt;\n   register int i;\n@@ -1895,9 +1852,7 @@ legitimate_pic_operand_p (x)\n }\n \n static int\n-mn10300_address_cost_1 (x, unsig)\n-     rtx x;\n-     int *unsig;\n+mn10300_address_cost_1 (rtx x, int *unsig)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1976,18 +1931,14 @@ mn10300_address_cost_1 (x, unsig)\n }\n \n static int\n-mn10300_address_cost (x)\n-     rtx x;\n+mn10300_address_cost (rtx x)\n {\n   int s = 0;\n   return mn10300_address_cost_1 (x, &s);\n }\n \n static bool\n-mn10300_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+mn10300_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -2039,8 +1990,7 @@ mn10300_rtx_costs (x, code, outer_code, total)\n    movdf and movdi.  */\n \n bool\n-mn10300_wide_const_load_uses_clr (operands)\n-     rtx operands[2];\n+mn10300_wide_const_load_uses_clr (rtx operands[2])\n {\n   long val[2];\n \n@@ -2085,10 +2035,7 @@ mn10300_wide_const_load_uses_clr (operands)\n    may access it using GOTOFF instead of GOT.  */\n \n static void\n-mn10300_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+mn10300_encode_section_info (tree decl, rtx rtl, int first)\n {\n   rtx symbol;\n "}]}