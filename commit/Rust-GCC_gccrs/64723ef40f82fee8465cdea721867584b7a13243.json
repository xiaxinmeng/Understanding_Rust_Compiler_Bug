{"sha": "64723ef40f82fee8465cdea721867584b7a13243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ3MjNlZjQwZjgyZmVlODQ2NWNkZWE3MjE4Njc1ODRiN2ExMzI0Mw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2017-07-05T12:34:36Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2017-07-05T12:34:36Z"}, "message": "re PR target/81305 ([avr] avrtiny uses LDS for SREG in ISR routines which is out of range of LDS.)\n\ngcc/\n\tPR target/81305\n\t* testsuite/gcc.target/avr/isr-test.h: New file.\n\nFrom-SVN: r249996", "tree": {"sha": "abe5cd4e4ed245f046e4b1fc55500a50154b1298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abe5cd4e4ed245f046e4b1fc55500a50154b1298"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64723ef40f82fee8465cdea721867584b7a13243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64723ef40f82fee8465cdea721867584b7a13243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64723ef40f82fee8465cdea721867584b7a13243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64723ef40f82fee8465cdea721867584b7a13243/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c4feb2d1a0b504f24bb340b2406983955248abd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c4feb2d1a0b504f24bb340b2406983955248abd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c4feb2d1a0b504f24bb340b2406983955248abd"}], "stats": {"total": 287, "additions": 287, "deletions": 0}, "files": [{"sha": "b977a6d952b3e625b38dcc933243c711a3bbb541", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64723ef40f82fee8465cdea721867584b7a13243/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64723ef40f82fee8465cdea721867584b7a13243/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64723ef40f82fee8465cdea721867584b7a13243", "patch": "@@ -1,3 +1,8 @@\n+2017-07-05  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/81305\n+\t* testsuite/gcc.target/avr/isr-test.h: New file.\n+\n 2017-07-05  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/81305"}, {"sha": "2d2babe215093e18e41d4bdf73044c7e747b4411", "filename": "gcc/testsuite/gcc.target/avr/isr-test.h", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64723ef40f82fee8465cdea721867584b7a13243/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64723ef40f82fee8465cdea721867584b7a13243/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h?ref=64723ef40f82fee8465cdea721867584b7a13243", "patch": "@@ -0,0 +1,282 @@\n+#ifndef ISR_TEST_H\n+#define ISR_TEST_H\n+\n+#include <string.h>\n+\n+#define ISR(N,...)                                                      \\\n+__attribute__ ((used, externally_visible , ## __VA_ARGS__))             \\\n+    void __vector_##N (void);                                           \\\n+    void __vector_##N (void)\n+\n+#define SFR(ADDR) (*(unsigned char volatile*) (__AVR_SFR_OFFSET__ + (ADDR)))\n+#define CORE_SFRS SFR (0x38)\n+#define SREG      SFR (0x3F)\n+#define SPL       SFR (0x3D)\n+#define EIND      SFR (0x3C)\n+#define RAMPZ     SFR (0x3B)\n+#define RAMPY     SFR (0x3A)\n+#define RAMPX     SFR (0x39)\n+#define RAMPD     SFR (0x38)\n+\n+#ifdef __AVR_HAVE_JMP_CALL__\n+#define VEC_SIZE 4\n+#else\n+#define VEC_SIZE 2\n+#endif\n+\n+#ifdef __AVR_TINY__\n+#define FIRST_REG 16\n+#else\n+#define FIRST_REG 0\n+#endif\n+\n+#define CR \"\\n\\t\"\n+\n+typedef struct\n+{\n+  unsigned char sfrs[8];\n+  unsigned char gprs[32 - FIRST_REG];\n+} regs_t;\n+\n+regs_t reginfo1, reginfo2;\n+\n+__attribute__((noinline))\n+static void clear_reginfo (void)\n+{\n+  memset (reginfo1.sfrs, 0, sizeof (reginfo1.sfrs));\n+  memset (reginfo2.sfrs, 0, sizeof (reginfo2.sfrs));\n+}\n+\n+__attribute__((noinline))\n+static void compare_reginfo (unsigned long gpr_ignore)\n+{\n+  signed char regno;\n+  const unsigned char *preg1 = &reginfo1.gprs[0];\n+  const unsigned char *preg2 = &reginfo2.gprs[0];\n+\n+  if (memcmp (&reginfo1, &reginfo2, 8))\n+    __builtin_abort();\n+\n+  gpr_ignore >>= FIRST_REG;\n+\n+    for (regno = FIRST_REG; regno < 32;\n+       regno++, preg1++, preg2++, gpr_ignore >>= 1)\n+    {\n+      if (gpr_ignore & 1)\n+        continue;\n+\n+      if (*preg1 != *preg2)\n+        {\n+          static signed char volatile failed_regno;\n+          failed_regno = regno;\n+          __builtin_abort();\n+        }\n+    }\n+}\n+\n+/* STore GPR */\n+#define ST(regno,M)                                     \\\n+  CR \"sts %[\" #M \"]+8-%[first]+\" #regno \", r\" #regno\n+\n+/* STore SFR */\n+#define ST_SFR(sfr, n_sfr, M)                   \\\n+  CR \"in __tmp_reg__,%i[s_\" #sfr \"]\"            \\\n+  CR \"sts %[\" #M \"]+\" #n_sfr \", __tmp_reg__\"\n+\n+/* Named asm OPerand for SFR */\n+#define OP_SFR(sfr)                             \\\n+  , [s_ ## sfr] \"n\" (&(sfr))\n+\n+/* Write funny value to SFR */\n+#define XX_SFR(sfr)                             \\\n+  CR \"dec r31 $ out %i[s_\" #sfr \"], r31\"\n+\n+/* Write 0 to SFR */\n+#define OO_SFR(sfr)                             \\\n+  CR \"out %i[s_\" #sfr \"], __zero_reg__\"\n+\n+/* Macros for SREG */\n+#define ST_SREG(M) ST_SFR (SREG,0,M)\n+#define OP_SREG    OP_SFR (SREG)\n+#define XX_SREG    XX_SFR (SREG)\n+\n+/* Macros for EIND */\n+#if defined __AVR_HAVE_EIJMP_EICALL__\n+#define ST_EIND(M) ST_SFR (EIND,1,M)\n+#define OP_EIND    OP_SFR (EIND)\n+#else\n+#define ST_EIND(M) /* empty */\n+#define OP_EIND    /* empty */\n+#endif\n+\n+/* Macros for RAMPX */\n+#if defined (__AVR_HAVE_RAMPX__)\n+#define ST_RAMPX(M) ST_SFR (RAMPX,2,M)\n+#define OP_RAMPX    OP_SFR (RAMPX)\n+#define XX_RAMPX    XX_SFR (RAMPX)\n+#define OO_RAMPX    OO_SFR (RAMPX)\n+#else\n+#define ST_RAMPX(M) /* empty */\n+#define OP_RAMPX    /* empty */\n+#define XX_RAMPX    /* empty */\n+#define OO_RAMPX    /* empty */\n+#endif\n+\n+/* Macros for RAMPY */\n+#if defined (__AVR_HAVE_RAMPY__)\n+#define ST_RAMPY(M) ST_SFR (RAMPY,3,M)\n+#define OP_RAMPY    OP_SFR (RAMPY)\n+#define XX_RAMPY    XX_SFR (RAMPY)\n+#define OO_RAMPY    OO_SFR (RAMPY)\n+#else\n+#define ST_RAMPY(M) /* empty */\n+#define OP_RAMPY    /* empty */\n+#define XX_RAMPY    /* empty */\n+#define OO_RAMPY    /* empty */\n+#endif\n+\n+/* Macros for RAMPZ */\n+#if defined (__AVR_HAVE_RAMPZ__)\n+#define ST_RAMPZ(M) ST_SFR (RAMPZ,4,M)\n+#define OP_RAMPZ    OP_SFR (RAMPZ)\n+#define XX_RAMPZ    XX_SFR (RAMPZ)\n+#define OO_RAMPZ    OO_SFR (RAMPZ)\n+#else\n+#define ST_RAMPZ(M) /* empty */\n+#define OP_RAMPZ    /* empty */\n+#define XX_RAMPZ    /* empty */\n+#define OO_RAMPZ    /* empty */\n+#endif\n+\n+/* Macros for RAMPD */\n+#if defined (__AVR_HAVE_RAMPD__)\n+#define ST_RAMPD(M) ST_SFR (RAMPD,5,M)\n+#define OP_RAMPD    OP_SFR (RAMPD)\n+#else\n+#define ST_RAMPD(M) /* empty */\n+#define OP_RAMPD    /* empty */\n+#endif\n+\n+/* Macros for all GPRs */\n+#if defined __AVR_TINY__\n+#define ST_REGS_LO(M) /* empty */\n+#else\n+#define ST_REGS_LO(M)                           \\\n+  ST(0,M)   ST(1,M)   ST(2,M)   ST(3,M)         \\\n+  ST(4,M)   ST(5,M)   ST(6,M)   ST(7,M)         \\\n+  ST(8,M)   ST(9,M)   ST(10,M)  ST(11,M)        \\\n+  ST(12,M)  ST(13,M)  ST(14,M)  ST(15,M)\n+#endif /* AVR_TINY */\n+\n+#define ST_REGS_HI(M)                           \\\n+  ST(16,M)    ST(17,M)    ST(18,M)    ST(19,M)  \\\n+  ST(20,M)    ST(21,M)    ST(22,M)    ST(23,M)  \\\n+  ST(24,M)    ST(25,M)    ST(26,M)    ST(27,M)  \\\n+  ST(28,M)    ST(29,M)    ST(30,M)    ST(31,M)\n+\n+__attribute__((used,naked,noinline,noclone))\n+static void host_store1 (void)\n+{\n+  __asm __volatile__\n+  (\"nop\"\n+   CR \".global do_stores_before\"\n+   CR \".type   do_stores_before,@function\"\n+   CR \"do_stores_before:\"\n+   /* Funny values to some SFRs */\n+   CR \"ldi r31, 1 + 'Z'\"\n+   XX_RAMPZ\n+   XX_RAMPY\n+   XX_RAMPX\n+   CR \"dec __zero_reg__\"\n+   CR \"clr r31\"\n+   XX_SREG\n+   /* Must set I-flag due to RETI of ISR */\n+   CR \"sei\"\n+   /* Store core regs before ISR */\n+   ST_RAMPX (mem1)\n+   ST_RAMPY (mem1)\n+   ST_RAMPZ (mem1)\n+   ST_RAMPD (mem1)\n+   ST_EIND  (mem1)\n+   ST_SREG  (mem1)\n+   CR \"ldi r31, 0xaa\"\n+   CR \"mov __tmp_reg__, r31\"\n+   CR \"ldi r31, 31\"\n+   ST_REGS_LO (mem1)\n+   ST_REGS_HI (mem1)\n+   CR \"ret\"\n+   : /* No outputs */\n+   : [mem1] \"i\" (&reginfo1), [first] \"n\" (FIRST_REG)\n+   OP_RAMPX\n+   OP_RAMPY\n+   OP_RAMPZ\n+   OP_RAMPD\n+   OP_EIND\n+   OP_SREG\n+   : \"memory\", \"r31\");\n+}\n+\n+__attribute__((used,naked,noinline,noclone))\n+static void host_store2 (void)\n+{\n+  __asm __volatile__\n+  (\"nop\"\n+   CR \".global do_stores_after\"\n+   CR \".type   do_stores_after,@function\"\n+   CR \"do_stores_after:\"\n+   /* Store core regs after ISR */\n+   ST_REGS_LO (mem2)\n+   ST_REGS_HI (mem2)\n+   ST_RAMPX (mem2)\n+   ST_RAMPY (mem2)\n+   ST_RAMPZ (mem2)\n+   ST_RAMPD (mem2)\n+   ST_EIND  (mem2)\n+   ST_SREG  (mem2)\n+   /* Undo funny values */\n+   CR \"clr __zero_reg__\"\n+   OO_RAMPX\n+   OO_RAMPY\n+   OO_RAMPZ\n+   CR \"ret\"\n+   : /* No outputs */\n+   : [mem2] \"i\" (&reginfo2), [first] \"n\" (FIRST_REG)\n+   OP_RAMPX\n+   OP_RAMPY\n+   OP_RAMPZ\n+   OP_RAMPD\n+   OP_EIND\n+   OP_SREG\n+   : \"memory\");\n+}\n+\n+#define MK_CALL_ISR(vecno)                      \\\n+  __asm __volatile__                            \\\n+  (/* Funny values to some SFRs */              \\\n+   /* Must set I-flag due to RETI of ISR */     \\\n+   /* Store core regs before ISR */             \\\n+   CR \"%~call do_stores_before\"                 \\\n+   /* Execute ISR */                            \\\n+   CR \"%~call __vectors + %[vect]\"              \\\n+   /* Store core regs after ISR */              \\\n+   /* Undo funny values */                      \\\n+   CR \"%~call do_stores_after\"                  \\\n+   : /* No outputs */                           \\\n+   : [vect] \"i\" (VEC_SIZE * (vecno))            \\\n+   , \"i\" (host_store1)                          \\\n+   , \"i\" (host_store2)                          \\\n+   : \"memory\", \"r31\")\n+\n+\n+#define MK_RUN_ISR(N, IGMSK)                    \\\n+                                                \\\n+__attribute__((noinline,noclone))               \\\n+void run_isr_ ## N (void)                       \\\n+{                                               \\\n+  clear_reginfo();                              \\\n+  MK_CALL_ISR (N);                              \\\n+  compare_reginfo (IGMSK);                      \\\n+}\n+\n+#endif /* ISR_TEST_H */\n+"}]}