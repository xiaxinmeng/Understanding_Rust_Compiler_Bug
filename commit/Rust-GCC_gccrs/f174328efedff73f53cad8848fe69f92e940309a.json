{"sha": "f174328efedff73f53cad8848fe69f92e940309a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3NDMyOGVmZWRmZjczZjUzY2FkODg0OGZlNjlmOTJlOTQwMzA5YQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2017-09-05T16:39:24Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2017-09-05T16:39:24Z"}, "message": "i386: Avoid stack realignment if possible\n\nix86_finalize_stack_frame_flags has been extended to eliminate frame\npointer when the new stack frame isn't needed with and without\n-maccumulate-outgoing-args as well as -fomit-frame-pointer.  Since stack\naccess with larger alignment may be optimized out, to decide if stack\nrealignment is needed, we need to not only check for stack frame access,\nbut also verify the alignment of stack frame access.  Since alignment of\nmemory access via arg_pointer is set up by caller, not by callee, we\nshould find the maximum stack alignment from the stack frame access\ninstructions via stack pointer and frame pointrer to avoid stack\nrealignment when stack alignment needed is less than incoming stack\nboundary.\n\ngcc/\n\n\tPR target/59501\n\tPR target/81624\n\tPR target/81769\n\t* config/i386/i386.c (ix86_finalize_stack_frame_flags): Don't\n\trealign stack if stack alignment needed is less than incoming\n\tstack boundary.\n\ngcc/testsuite/\n\n\tPR target/59501\n\tPR target/81624\n\tPR target/81769\n\t* gcc.target/i386/pr59501-4a.c: Remove xfail.\n\t* gcc.target/i386/pr81769-1a.c: New test.\n\t* gcc.target/i386/pr81769-1b.c: Likewise.\n\t* gcc.target/i386/pr81769-2.c: Likewise.\n\nFrom-SVN: r251718", "tree": {"sha": "706d0c95cf17f85e96d477d27f667d470ee40466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/706d0c95cf17f85e96d477d27f667d470ee40466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f174328efedff73f53cad8848fe69f92e940309a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f174328efedff73f53cad8848fe69f92e940309a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f174328efedff73f53cad8848fe69f92e940309a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f174328efedff73f53cad8848fe69f92e940309a/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c253525edd51a027b7db30e077a6643a78544b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c253525edd51a027b7db30e077a6643a78544b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c253525edd51a027b7db30e077a6643a78544b0c"}], "stats": {"total": 213, "additions": 157, "deletions": 56}, "files": [{"sha": "fa34e13bc4e65bbd183f0622183e57a591071214", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -1,3 +1,12 @@\n+2017-09-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/59501\n+\tPR target/81624\n+\tPR target/81769\n+\t* config/i386/i386.c (ix86_finalize_stack_frame_flags): Don't\n+\trealign stack if stack alignment needed is less than incoming\n+\tstack boundary.\n+\n 2017-09-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/82072"}, {"sha": "74064510c631e79ba6caab31f7985edd84ff59bf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -14303,6 +14303,11 @@ ix86_finalize_stack_frame_flags (void)\n       add_to_hard_reg_set (&set_up_by_prologue, Pmode, ARG_POINTER_REGNUM);\n       add_to_hard_reg_set (&set_up_by_prologue, Pmode,\n \t\t\t   HARD_FRAME_POINTER_REGNUM);\n+\n+      /* The preferred stack alignment is the minimum stack alignment.  */\n+      unsigned int stack_alignment = crtl->preferred_stack_boundary;\n+      bool require_stack_frame = false;\n+\n       FOR_EACH_BB_FN (bb, cfun)\n         {\n           rtx_insn *insn;\n@@ -14311,79 +14316,107 @@ ix86_finalize_stack_frame_flags (void)\n \t\t&& requires_stack_frame_p (insn, prologue_used,\n \t\t\t\t\t   set_up_by_prologue))\n \t      {\n-\t\tif (crtl->stack_realign_needed != stack_realign)\n-\t\t  recompute_frame_layout_p = true;\n-\t\tcrtl->stack_realign_needed = stack_realign;\n-\t\tcrtl->stack_realign_finalized = true;\n-\t\tif (recompute_frame_layout_p)\n-\t\t  ix86_compute_frame_layout ();\n-\t\treturn;\n+\t\trequire_stack_frame = true;\n+\n+\t\tif (stack_realign)\n+\t\t  {\n+\t\t    /* Find the maximum stack alignment.  */\n+\t\t    subrtx_iterator::array_type array;\n+\t\t    FOR_EACH_SUBRTX (iter, array, PATTERN (insn), ALL)\n+\t\t      if (MEM_P (*iter)\n+\t\t\t  && (reg_mentioned_p (stack_pointer_rtx,\n+\t\t\t\t\t       *iter)\n+\t\t\t      || reg_mentioned_p (frame_pointer_rtx,\n+\t\t\t\t\t\t  *iter)))\n+\t\t\t{\n+\t\t\t  unsigned int alignment = MEM_ALIGN (*iter);\n+\t\t\t  if (alignment > stack_alignment)\n+\t\t\t    stack_alignment = alignment;\n+\t\t\t}\n+\t\t  }\n \t      }\n \t}\n \n-      /* If drap has been set, but it actually isn't live at the start\n-\t of the function, there is no reason to set it up.  */\n-      if (crtl->drap_reg)\n+      if (require_stack_frame)\n \t{\n-\t  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n-\t  if (! REGNO_REG_SET_P (DF_LR_IN (bb), REGNO (crtl->drap_reg)))\n+\t  /* Stack frame is required.  If stack alignment needed is less\n+\t     than incoming stack boundary, don't realign stack.  */\n+\t  stack_realign = incoming_stack_boundary < stack_alignment;\n+\t  if (!stack_realign)\n \t    {\n-\t      crtl->drap_reg = NULL_RTX;\n-\t      crtl->need_drap = false;\n+\t      crtl->max_used_stack_slot_alignment\n+\t\t= incoming_stack_boundary;\n+\t      crtl->stack_alignment_needed\n+\t\t= incoming_stack_boundary;\n \t    }\n \t}\n       else\n-\tcfun->machine->no_drap_save_restore = true;\n-\n-      frame_pointer_needed = false;\n-      stack_realign = false;\n-      crtl->max_used_stack_slot_alignment = incoming_stack_boundary;\n-      crtl->stack_alignment_needed = incoming_stack_boundary;\n-      crtl->stack_alignment_estimated = incoming_stack_boundary;\n-      if (crtl->preferred_stack_boundary > incoming_stack_boundary)\n-\tcrtl->preferred_stack_boundary = incoming_stack_boundary;\n-      df_finish_pass (true);\n-      df_scan_alloc (NULL);\n-      df_scan_blocks ();\n-      df_compute_regs_ever_live (true);\n-      df_analyze ();\n-\n-      if (flag_var_tracking)\n \t{\n-\t  /* Since frame pointer is no longer available, replace it with\n-\t     stack pointer - UNITS_PER_WORD in debug insns.  */\n-\t  df_ref ref, next;\n-\t  for (ref = DF_REG_USE_CHAIN (HARD_FRAME_POINTER_REGNUM);\n-\t       ref; ref = next)\n+\t  /* If drap has been set, but it actually isn't live at the\n+\t     start of the function, there is no reason to set it up.  */\n+\t  if (crtl->drap_reg)\n \t    {\n-\t      rtx_insn *insn = DF_REF_INSN (ref);\n-\t      /* Make sure the next ref is for a different instruction,\n-\t\t so that we're not affected by the rescan.  */\n-\t      next = DF_REF_NEXT_REG (ref);\n-\t      while (next && DF_REF_INSN (next) == insn)\n-\t\tnext = DF_REF_NEXT_REG (next);\n-\n-\t      if (DEBUG_INSN_P (insn))\n+\t      basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n+\t      if (! REGNO_REG_SET_P (DF_LR_IN (bb),\n+\t\t\t\t     REGNO (crtl->drap_reg)))\n+\t\t{\n+\t\t  crtl->drap_reg = NULL_RTX;\n+\t\t  crtl->need_drap = false;\n+\t\t}\n+\t    }\n+\t  else\n+\t    cfun->machine->no_drap_save_restore = true;\n+\n+\t  frame_pointer_needed = false;\n+\t  stack_realign = false;\n+\t  crtl->max_used_stack_slot_alignment = incoming_stack_boundary;\n+\t  crtl->stack_alignment_needed = incoming_stack_boundary;\n+\t  crtl->stack_alignment_estimated = incoming_stack_boundary;\n+\t  if (crtl->preferred_stack_boundary > incoming_stack_boundary)\n+\t    crtl->preferred_stack_boundary = incoming_stack_boundary;\n+\t  df_finish_pass (true);\n+\t  df_scan_alloc (NULL);\n+\t  df_scan_blocks ();\n+\t  df_compute_regs_ever_live (true);\n+\t  df_analyze ();\n+\n+\t  if (flag_var_tracking)\n+\t    {\n+\t      /* Since frame pointer is no longer available, replace it with\n+\t\t stack pointer - UNITS_PER_WORD in debug insns.  */\n+\t      df_ref ref, next;\n+\t      for (ref = DF_REG_USE_CHAIN (HARD_FRAME_POINTER_REGNUM);\n+\t\t   ref; ref = next)\n \t\t{\n-\t\t  bool changed = false;\n-\t\t  for (; ref != next; ref = DF_REF_NEXT_REG (ref))\n+\t\t  rtx_insn *insn = DF_REF_INSN (ref);\n+\t\t  /* Make sure the next ref is for a different instruction,\n+\t\t     so that we're not affected by the rescan.  */\n+\t\t  next = DF_REF_NEXT_REG (ref);\n+\t\t  while (next && DF_REF_INSN (next) == insn)\n+\t\t    next = DF_REF_NEXT_REG (next);\n+\n+\t\t  if (DEBUG_INSN_P (insn))\n \t\t    {\n-\t\t      rtx *loc = DF_REF_LOC (ref);\n-\t\t      if (*loc == hard_frame_pointer_rtx)\n+\t\t      bool changed = false;\n+\t\t      for (; ref != next; ref = DF_REF_NEXT_REG (ref))\n \t\t\t{\n-\t\t\t  *loc = plus_constant (Pmode,\n-\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t-UNITS_PER_WORD);\n-\t\t\t  changed = true;\n+\t\t\t  rtx *loc = DF_REF_LOC (ref);\n+\t\t\t  if (*loc == hard_frame_pointer_rtx)\n+\t\t\t    {\n+\t\t\t      *loc = plus_constant (Pmode,\n+\t\t\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t\t\t    -UNITS_PER_WORD);\n+\t\t\t      changed = true;\n+\t\t\t    }\n \t\t\t}\n+\t\t      if (changed)\n+\t\t\tdf_insn_rescan (insn);\n \t\t    }\n-\t\t  if (changed)\n-\t\t    df_insn_rescan (insn);\n \t\t}\n \t    }\n-\t}\n \n-      recompute_frame_layout_p = true;\n+\t  recompute_frame_layout_p = true;\n+\t}\n     }\n \n   if (crtl->stack_realign_needed != stack_realign)"}, {"sha": "a34c6923a0e1b5a7b471017e2cb14d047967c803", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -1,3 +1,13 @@\n+2017-09-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/59501\n+\tPR target/81624\n+\tPR target/81769\n+\t* gcc.target/i386/pr59501-4a.c: Remove xfail.\n+\t* gcc.target/i386/pr81769-1a.c: New test.\n+\t* gcc.target/i386/pr81769-1b.c: Likewise.\n+\t* gcc.target/i386/pr81769-2.c: Likewise.\n+\n 2017-09-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/82072"}, {"sha": "908c7f457b6deef3dab0ed23bee7a15fcf84edc0", "filename": "gcc/testsuite/gcc.target/i386/pr59501-4a.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59501-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59501-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59501-4a.c?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -5,4 +5,4 @@\n #include \"pr59501-3a.c\"\n \n /* Verify no dynamic realignment is performed.  */\n-/* { dg-final { scan-assembler-not \"and\\[^\\n\\r]*sp\" { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not \"and\\[^\\n\\r]*sp\" } } */"}, {"sha": "8ebe7292184c2cae9869e97f9ca84860d92b768b", "filename": "gcc/testsuite/gcc.target/i386/pr81769-1a.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1a.c?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mavx\" } */\n+\n+typedef int v8si __attribute__ ((vector_size (32)));\n+typedef unsigned long long int u64 __attribute__ ((aligned(64)));\n+\n+\n+void\n+#ifndef __x86_64__\n+__attribute__((regparm(3)))\n+#endif\n+foo (u64 *idx, v8si *out_start, v8si *regions)\n+{\n+  if (*idx < 20 ) {\n+    v8si base = regions[*idx];\n+    *out_start = base;\n+  }\n+}\n+\n+/* Verify no dynamic realignment is performed.  */\n+/* { dg-final { scan-assembler-not \"and\\[^\\n\\r]*sp\" } } */"}, {"sha": "6505a5f0074d526874bb3db6218ef0bbb8e3a8bb", "filename": "gcc/testsuite/gcc.target/i386/pr81769-1b.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-1b.c?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mavx -fno-omit-frame-pointer\" } */\n+\n+#include \"pr81769-1a.c\"\n+\n+/* Verify no dynamic realignment is performed.  */\n+/* { dg-final { scan-assembler-not \"and\\[^\\n\\r]*sp\" } } */"}, {"sha": "e020db20227bbe6215c67416a31998bcb25bc39b", "filename": "gcc/testsuite/gcc.target/i386/pr81769-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f174328efedff73f53cad8848fe69f92e940309a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr81769-2.c?ref=f174328efedff73f53cad8848fe69f92e940309a", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mavx -fno-omit-frame-pointer\" } */\n+\n+typedef unsigned long long int u64 __attribute__ ((aligned(64)));\n+\n+void\n+#ifndef __x86_64__\n+__attribute__((regparm(3)))\n+#endif\n+foo (u64 *idx, unsigned int *out_start, unsigned int *out_end,\n+     unsigned int *regions)\n+{\n+  if (*idx < 20 ) {\n+    unsigned int base = regions[*idx];\n+    *out_start = base;\n+    *out_end = base;\n+  }\n+}\n+\n+/* Verify no dynamic realignment is performed.  */\n+/* { dg-final { scan-assembler-not \"and\\[^\\n\\r]*sp\" } } */"}]}