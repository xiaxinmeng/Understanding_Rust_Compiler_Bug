{"sha": "872d5034baa1007606d405e37937908602fbbe51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcyZDUwMzRiYWExMDA3NjA2ZDQwNWUzNzkzNzkwODYwMmZiYmU1MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-19T17:17:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-19T17:17:21Z"}, "message": "tree.c (verify_type_variant): Fix #undef.\n\n\n\t* tree.c (verify_type_variant): Fix #undef.\n\t(gimple_canonical_types_compatible_p): Move here from lto.c\n\t(verify_type): Verify TYPE_CANONICAL compatibility.\n\t* tree.h (gimple_canonical_types_compatible_p): Declare.\n\n\t* lto.c (gimple_canonical_types_compatible_p): Move to tree.c\n\nFrom-SVN: r223391", "tree": {"sha": "f1b24ad9ea6616fd264f62330b85522955708226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1b24ad9ea6616fd264f62330b85522955708226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/872d5034baa1007606d405e37937908602fbbe51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872d5034baa1007606d405e37937908602fbbe51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/872d5034baa1007606d405e37937908602fbbe51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872d5034baa1007606d405e37937908602fbbe51/comments", "author": null, "committer": null, "parents": [{"sha": "41b37d5ec1064decf497f1ce4657582f4b4807c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b37d5ec1064decf497f1ce4657582f4b4807c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41b37d5ec1064decf497f1ce4657582f4b4807c8"}], "stats": {"total": 462, "additions": 259, "deletions": 203}, "files": [{"sha": "8c8a52680186ae4f4427d943bcb24ea770dccf70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872d5034baa1007606d405e37937908602fbbe51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872d5034baa1007606d405e37937908602fbbe51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=872d5034baa1007606d405e37937908602fbbe51", "patch": "@@ -1,3 +1,10 @@\n+2015-05-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (verify_type_variant): Fix #undef.\n+\t(gimple_canonical_types_compatible_p): Move here from lto.c\n+\t(verify_type): Verify TYPE_CANONICAL compatibility.\n+\t* tree.h (gimple_canonical_types_compatible_p): Declare.\n+\n 2015-05-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/66199"}, {"sha": "335bd545fe06fc586805377d03b6fbf38e514eea", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872d5034baa1007606d405e37937908602fbbe51/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872d5034baa1007606d405e37937908602fbbe51/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=872d5034baa1007606d405e37937908602fbbe51", "patch": "@@ -1,3 +1,7 @@\n+2015-05-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (gimple_canonical_types_compatible_p): Move to tree.c\n+\n 2015-05-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (warn_type_compatibility_p): Break out from ...;"}, {"sha": "26697443010a2ead00d49532e10fac232a4a29d2", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872d5034baa1007606d405e37937908602fbbe51/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872d5034baa1007606d405e37937908602fbbe51/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=872d5034baa1007606d405e37937908602fbbe51", "patch": "@@ -441,208 +441,6 @@ gimple_canonical_type_hash (const void *p)\n }\n \n \n-/* The TYPE_CANONICAL merging machinery.  It should closely resemble\n-   the middle-end types_compatible_p function.  It needs to avoid\n-   claiming types are different for types that should be treated\n-   the same with respect to TBAA.  Canonical types are also used\n-   for IL consistency checks via the useless_type_conversion_p\n-   predicate which does not handle all type kinds itself but falls\n-   back to pointer-comparison of TYPE_CANONICAL for aggregates\n-   for example.  */\n-\n-/* Return true iff T1 and T2 are structurally identical for what\n-   TBAA is concerned.  */\n-\n-static bool\n-gimple_canonical_types_compatible_p (tree t1, tree t2)\n-{\n-  /* Before starting to set up the SCC machinery handle simple cases.  */\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-    return true;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  /* Qualifiers do not matter for canonical type comparison purposes.  */\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different mode.  */\n-  if (TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Non-aggregate types can be handled cheaply.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* For canonical type comparisons we do not want to build SCCs\n-\t so we cannot compare pointed-to types.  But we can, for now,\n-\t require the same pointed-to type kind and match what\n-\t useless_type_conversion_p would do.  */\n-      if (POINTER_TYPE_P (t1))\n-\t{\n-\t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n-\t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n-\t    return false;\n-\n-\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n-\t    return false;\n-\t}\n-\n-      /* Tail-recurse to components.  */\n-      if (TREE_CODE (t1) == VECTOR_TYPE\n-\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n-\treturn gimple_canonical_types_compatible_p (TREE_TYPE (t1),\n-\t\t\t\t\t\t    TREE_TYPE (t2));\n-\n-      return true;\n-    }\n-\n-  /* Do type-specific comparisons.  */\n-  switch (TREE_CODE (t1))\n-    {\n-    case ARRAY_TYPE:\n-      /* Array types are the same if the element types are the same and\n-\t the number of elements are the same.  */\n-      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n-\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n-\treturn false;\n-      else\n-\t{\n-\t  tree i1 = TYPE_DOMAIN (t1);\n-\t  tree i2 = TYPE_DOMAIN (t2);\n-\n-\t  /* For an incomplete external array, the type domain can be\n- \t     NULL_TREE.  Check this condition also.  */\n-\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n-\t    return true;\n-\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n-\t    return false;\n-\t  else\n-\t    {\n-\t      tree min1 = TYPE_MIN_VALUE (i1);\n-\t      tree min2 = TYPE_MIN_VALUE (i2);\n-\t      tree max1 = TYPE_MAX_VALUE (i1);\n-\t      tree max2 = TYPE_MAX_VALUE (i2);\n-\n-\t      /* The minimum/maximum values have to be the same.  */\n-\t      if ((min1 == min2\n-\t\t   || (min1 && min2\n-\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n-\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n-\t\t           || operand_equal_p (min1, min2, 0))))\n-\t\t  && (max1 == max2\n-\t\t      || (max1 && max2\n-\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n-\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n-\t\t\t      || operand_equal_p (max1, max2, 0)))))\n-\t\treturn true;\n-\t      else\n-\t\treturn false;\n-\t    }\n-\t}\n-\n-    case METHOD_TYPE:\n-    case FUNCTION_TYPE:\n-      /* Function types are the same if the return type and arguments types\n-\t are the same.  */\n-      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\treturn false;\n-\n-      if (!comp_type_attributes (t1, t2))\n-\treturn false;\n-\n-      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n-\treturn true;\n-      else\n-\t{\n-\t  tree parms1, parms2;\n-\n-\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n-\t       parms1 && parms2;\n-\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n-\t    {\n-\t      if (!gimple_canonical_types_compatible_p\n-\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n-\t\treturn false;\n-\t    }\n-\n-\t  if (parms1 || parms2)\n-\t    return false;\n-\n-\t  return true;\n-\t}\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      {\n-\ttree f1, f2;\n-\n-\t/* For aggregate types, all the fields must be the same.  */\n-\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t     f1 || f2;\n-\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t  {\n-\t    /* Skip non-fields.  */\n-\t    while (f1 && TREE_CODE (f1) != FIELD_DECL)\n-\t      f1 = TREE_CHAIN (f1);\n-\t    while (f2 && TREE_CODE (f2) != FIELD_DECL)\n-\t      f2 = TREE_CHAIN (f2);\n-\t    if (!f1 || !f2)\n-\t      break;\n-\t    /* The fields must have the same name, offset and type.  */\n-\t    if (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n-\t\t|| !gimple_compare_field_offset (f1, f2)\n-\t\t|| !gimple_canonical_types_compatible_p\n-\t\t      (TREE_TYPE (f1), TREE_TYPE (f2)))\n-\t      return false;\n-\t  }\n-\n-\t/* If one aggregate has more fields than the other, they\n-\t   are not the same.  */\n-\tif (f1 || f2)\n-\t  return false;\n-\n-\treturn true;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n \n /* Returns nonzero if P1 and P2 are equal.  */\n "}, {"sha": "0ab965f3c94b26acdb7cea46e9a8779c36d8a415", "filename": "gcc/tree.c", "status": "modified", "additions": 246, "deletions": 1, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872d5034baa1007606d405e37937908602fbbe51/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872d5034baa1007606d405e37937908602fbbe51/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=872d5034baa1007606d405e37937908602fbbe51", "patch": "@@ -12687,10 +12687,225 @@ verify_type_variant (const_tree t, tree tv)\n       return false;\n     }\n   return true;\n-#undef verify_type_variant\n+#undef verify_variant_match\n }\n \n \n+/* The TYPE_CANONICAL merging machinery.  It should closely resemble\n+   the middle-end types_compatible_p function.  It needs to avoid\n+   claiming types are different for types that should be treated\n+   the same with respect to TBAA.  Canonical types are also used\n+   for IL consistency checks via the useless_type_conversion_p\n+   predicate which does not handle all type kinds itself but falls\n+   back to pointer-comparison of TYPE_CANONICAL for aggregates\n+   for example.  */\n+\n+/* Return true iff T1 and T2 are structurally identical for what\n+   TBAA is concerned.  \n+   This function is used both by lto.c canonical type merging and by the\n+   verifier.  If TRUST_TYPE_CANONICAL we do not look into structure of types\n+   that have TYPE_CANONICAL defined and assume them equivalent.  */\n+\n+bool\n+gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n+\t\t\t\t     bool trust_type_canonical)\n+{\n+  /* Before starting to set up the SCC machinery handle simple cases.  */\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  if (TYPE_CANONICAL (t1) && TYPE_CANONICAL (t2)\n+      && trust_type_canonical)\n+    return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Qualifiers do not matter for canonical type comparison purposes.  */\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n+    return true;\n+\n+  /* Can't be the same type if they have different mode.  */\n+  if (TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n+  /* Non-aggregate types can be handled cheaply.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\treturn false;\n+\n+      /* For canonical type comparisons we do not want to build SCCs\n+\t so we cannot compare pointed-to types.  But we can, for now,\n+\t require the same pointed-to type kind and match what\n+\t useless_type_conversion_p would do.  */\n+      if (POINTER_TYPE_P (t1))\n+\t{\n+\t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n+\t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n+\t    return false;\n+\n+\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n+\t    return false;\n+\t}\n+\n+      /* Tail-recurse to components.  */\n+      if (TREE_CODE (t1) == VECTOR_TYPE\n+\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n+\treturn gimple_canonical_types_compatible_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t    TREE_TYPE (t2),\n+\t\t\t\t\t\t    trust_type_canonical);\n+\n+      return true;\n+    }\n+\n+  /* Do type-specific comparisons.  */\n+  switch (TREE_CODE (t1))\n+    {\n+    case ARRAY_TYPE:\n+      /* Array types are the same if the element types are the same and\n+\t the number of elements are the same.  */\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t\ttrust_type_canonical)\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n+\treturn false;\n+      else\n+\t{\n+\t  tree i1 = TYPE_DOMAIN (t1);\n+\t  tree i2 = TYPE_DOMAIN (t2);\n+\n+\t  /* For an incomplete external array, the type domain can be\n+ \t     NULL_TREE.  Check this condition also.  */\n+\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n+\t    return true;\n+\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n+\t    return false;\n+\t  else\n+\t    {\n+\t      tree min1 = TYPE_MIN_VALUE (i1);\n+\t      tree min2 = TYPE_MIN_VALUE (i2);\n+\t      tree max1 = TYPE_MAX_VALUE (i1);\n+\t      tree max2 = TYPE_MAX_VALUE (i2);\n+\n+\t      /* The minimum/maximum values have to be the same.  */\n+\t      if ((min1 == min2\n+\t\t   || (min1 && min2\n+\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n+\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n+\t\t           || operand_equal_p (min1, min2, 0))))\n+\t\t  && (max1 == max2\n+\t\t      || (max1 && max2\n+\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n+\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n+\t\t\t      || operand_equal_p (max1, max2, 0)))))\n+\t\treturn true;\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+      /* Function types are the same if the return type and arguments types\n+\t are the same.  */\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t\ttrust_type_canonical))\n+\treturn false;\n+\n+      if (!comp_type_attributes (t1, t2))\n+\treturn false;\n+\n+      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\treturn true;\n+      else\n+\t{\n+\t  tree parms1, parms2;\n+\n+\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t       parms1 && parms2;\n+\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n+\t    {\n+\t      if (!gimple_canonical_types_compatible_p\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2),\n+\t\t      trust_type_canonical))\n+\t\treturn false;\n+\t    }\n+\n+\t  if (parms1 || parms2)\n+\t    return false;\n+\n+\t  return true;\n+\t}\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree f1, f2;\n+\n+\t/* For aggregate types, all the fields must be the same.  */\n+\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t     f1 || f2;\n+\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t  {\n+\t    /* Skip non-fields.  */\n+\t    while (f1 && TREE_CODE (f1) != FIELD_DECL)\n+\t      f1 = TREE_CHAIN (f1);\n+\t    while (f2 && TREE_CODE (f2) != FIELD_DECL)\n+\t      f2 = TREE_CHAIN (f2);\n+\t    if (!f1 || !f2)\n+\t      break;\n+\t    /* The fields must have the same name, offset and type.  */\n+\t    if (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n+\t\t|| !gimple_compare_field_offset (f1, f2)\n+\t\t|| !gimple_canonical_types_compatible_p\n+\t\t      (TREE_TYPE (f1), TREE_TYPE (f2),\n+\t\t       trust_type_canonical))\n+\t      return false;\n+\t  }\n+\n+\t/* If one aggregate has more fields than the other, they\n+\t   are not the same.  */\n+\tif (f1 || f2)\n+\t  return false;\n+\n+\treturn true;\n+      }\n+\n+    default:\n+      /* Consider all types with language specific trees in them mutually\n+\t compatible.  This is executed only from verify_type and false\n+         positives can be tolerated.  */\n+      gcc_assert (!in_lto_p);\n+      return true;\n+    }\n+}\n+\n /* Verify type T.  */\n \n void\n@@ -12712,6 +12927,36 @@ verify_type (const_tree t)\n   else if (t != mv && !verify_type_variant (t, mv))\n     error_found = true;\n \n+  tree ct = TYPE_CANONICAL (t);\n+  if (!ct)\n+    ;\n+  else if (TYPE_CANONICAL (t) != ct)\n+    {\n+      error (\"TYPE_CANONICAL has different TYPE_CANONICAL\");\n+      debug_tree (ct);\n+      error_found = true;\n+    }\n+  /* Method and function types can not be used to address memory and thus\n+     TYPE_CANONICAL really matters only for determining useless conversions.\n+\n+     FIXME: C++ FE does not agree with gimple_canonical_types_compatible_p\n+     here.  gimple_canonical_types_compatible_p calls comp_type_attributes\n+     while for C++ FE the attributes does not make difference.  */\n+  else if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n+    ;\n+  else if (t != ct\n+\t   /* FIXME: gimple_canonical_types_compatible_p can not compare types\n+\t      with variably sized arrays because their sizes possibly\n+\t      gimplified to different variables.  */\n+\t   && !variably_modified_type_p (ct, NULL)\n+\t   && !gimple_canonical_types_compatible_p (t, ct, false))\n+    {\n+      error (\"TYPE_CANONICAL is not compatible\");\n+      debug_tree (ct);\n+      error_found = true;\n+    }\n+\n+\n   /* Check various uses of TYPE_MINVAL.  */\n   if (RECORD_OR_UNION_TYPE_P (t))\n     {"}, {"sha": "2bac6988bcf8aa6e8ad5c125988199ad6d32c8fb", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872d5034baa1007606d405e37937908602fbbe51/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872d5034baa1007606d405e37937908602fbbe51/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=872d5034baa1007606d405e37937908602fbbe51", "patch": "@@ -4569,6 +4569,8 @@ extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n extern void DEBUG_FUNCTION verify_type (const_tree t);\n+extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n+\t\t\t\t\t\t bool trust_type_canonical = true);\n \n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);"}]}