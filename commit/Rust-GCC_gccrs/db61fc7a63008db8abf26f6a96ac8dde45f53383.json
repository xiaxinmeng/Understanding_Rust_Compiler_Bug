{"sha": "db61fc7a63008db8abf26f6a96ac8dde45f53383", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI2MWZjN2E2MzAwOGRiOGFiZjI2ZjZhOTZhYzhkZGU0NWY1MzM4Mw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-02T16:20:43Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-02T16:20:43Z"}, "message": "tree-ssa-loop-ivopts.c (get_computation_aff_1): New.\n\n\t* tree-ssa-loop-ivopts.c (get_computation_aff_1): New.\n\t(get_computation_aff): Reorder parameters.  Use get_computation_aff_1.\n\t(get_computation_at, rewrite_use_address): Update use of\n\tget_computation_aff.\n\nFrom-SVN: r247518", "tree": {"sha": "e4a82030f1a7884e9d6370c60f681a33156b8638", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4a82030f1a7884e9d6370c60f681a33156b8638"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db61fc7a63008db8abf26f6a96ac8dde45f53383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db61fc7a63008db8abf26f6a96ac8dde45f53383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db61fc7a63008db8abf26f6a96ac8dde45f53383", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db61fc7a63008db8abf26f6a96ac8dde45f53383/comments", "author": null, "committer": null, "parents": [{"sha": "c7da0e818fee3d260a1d86d9371e508666f1e137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7da0e818fee3d260a1d86d9371e508666f1e137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7da0e818fee3d260a1d86d9371e508666f1e137"}], "stats": {"total": 80, "additions": 51, "deletions": 29}, "files": [{"sha": "be69bec06d92aa86b26ad602d65252f82a666fef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61fc7a63008db8abf26f6a96ac8dde45f53383/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61fc7a63008db8abf26f6a96ac8dde45f53383/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db61fc7a63008db8abf26f6a96ac8dde45f53383", "patch": "@@ -1,3 +1,10 @@\n+2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (get_computation_aff_1): New.\n+\t(get_computation_aff): Reorder parameters.  Use get_computation_aff_1.\n+\t(get_computation_at, rewrite_use_address): Update use of\n+\tget_computation_aff.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (get_computation_at): Reorder parameters."}, {"sha": "90392cebcf347c360eb562999ca99da51a9673ef", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db61fc7a63008db8abf26f6a96ac8dde45f53383/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db61fc7a63008db8abf26f6a96ac8dde45f53383/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=db61fc7a63008db8abf26f6a96ac8dde45f53383", "patch": "@@ -3711,29 +3711,26 @@ determine_common_wider_type (tree *a, tree *b)\n }\n \n /* Determines the expression by that USE is expressed from induction variable\n-   CAND at statement AT in LOOP.  The expression is stored in a decomposed\n-   form into AFF.  Returns false if USE cannot be expressed using CAND.  */\n+   CAND at statement AT in LOOP.  The expression is stored in two parts in a\n+   decomposed form.  The invariant part is stored in AFF_INV; while variant\n+   part in AFF_VAR.  Store ratio of CAND.step over USE.step in PRAT if it's\n+   non-null.  Returns false if USE cannot be expressed using CAND.  */\n \n static bool\n-get_computation_aff (struct loop *loop,\n-\t\t     struct iv_use *use, struct iv_cand *cand, gimple *at,\n-\t\t     struct aff_tree *aff)\n-{\n-  tree ubase = use->iv->base;\n-  tree ustep = use->iv->step;\n-  tree cbase = cand->iv->base;\n-  tree cstep = cand->iv->step, cstep_common;\n+get_computation_aff_1 (struct loop *loop, gimple *at, struct iv_use *use,\n+\t\t       struct iv_cand *cand, struct aff_tree *aff_inv,\n+\t\t       struct aff_tree *aff_var, widest_int *prat = NULL)\n+{\n+  tree ubase = use->iv->base, ustep = use->iv->step;\n+  tree cbase = cand->iv->base, cstep = cand->iv->step;\n+  tree common_type, uutype, var, cstep_common;\n   tree utype = TREE_TYPE (ubase), ctype = TREE_TYPE (cbase);\n-  tree common_type, var;\n-  tree uutype;\n-  aff_tree cbase_aff, var_aff;\n+  aff_tree aff_cbase;\n   widest_int rat;\n \n+  /* We must have a precision to express the values of use.  */\n   if (TYPE_PRECISION (utype) > TYPE_PRECISION (ctype))\n-    {\n-      /* We do not have a precision to express the values of use.  */\n-      return false;\n-    }\n+    return false;\n \n   var = var_at_stmt (loop, cand, at);\n   uutype = unsigned_type_for (utype);\n@@ -3763,8 +3760,8 @@ get_computation_aff (struct loop *loop,\n \t      cstep = inner_step;\n \t    }\n \t}\n-      cstep = fold_convert (uutype, cstep);\n       cbase = fold_convert (uutype, cbase);\n+      cstep = fold_convert (uutype, cstep);\n       var = fold_convert (uutype, var);\n     }\n \n@@ -3783,6 +3780,9 @@ get_computation_aff (struct loop *loop,\n   else if (!constant_multiple_of (ustep, cstep, &rat))\n     return false;\n \n+  if (prat)\n+    *prat = rat;\n+\n   /* In case both UBASE and CBASE are shortened to UUTYPE from some common\n      type, we achieve better folding by computing their difference in this\n      wider type, and cast the result to UUTYPE.  We do not need to worry about\n@@ -3791,9 +3791,9 @@ get_computation_aff (struct loop *loop,\n   common_type = determine_common_wider_type (&ubase, &cbase);\n \n   /* use = ubase - ratio * cbase + ratio * var.  */\n-  tree_to_aff_combination (ubase, common_type, aff);\n-  tree_to_aff_combination (cbase, common_type, &cbase_aff);\n-  tree_to_aff_combination (var, uutype, &var_aff);\n+  tree_to_aff_combination (ubase, common_type, aff_inv);\n+  tree_to_aff_combination (cbase, common_type, &aff_cbase);\n+  tree_to_aff_combination (var, uutype, aff_var);\n \n   /* We need to shift the value if we are after the increment.  */\n   if (stmt_after_increment (loop, cand, at))\n@@ -3806,17 +3806,32 @@ get_computation_aff (struct loop *loop,\n \tcstep_common = cstep;\n \n       tree_to_aff_combination (cstep_common, common_type, &cstep_aff);\n-      aff_combination_add (&cbase_aff, &cstep_aff);\n+      aff_combination_add (&aff_cbase, &cstep_aff);\n     }\n \n-  aff_combination_scale (&cbase_aff, -rat);\n-  aff_combination_add (aff, &cbase_aff);\n+  aff_combination_scale (&aff_cbase, -rat);\n+  aff_combination_add (aff_inv, &aff_cbase);\n   if (common_type != uutype)\n-    aff_combination_convert (aff, uutype);\n+    aff_combination_convert (aff_inv, uutype);\n \n-  aff_combination_scale (&var_aff, rat);\n-  aff_combination_add (aff, &var_aff);\n+  aff_combination_scale (aff_var, rat);\n+  return true;\n+}\n+\n+/* Determines the expression by that USE is expressed from induction variable\n+   CAND at statement AT in LOOP.  The expression is stored in a decomposed\n+   form into AFF.  Returns false if USE cannot be expressed using CAND.  */\n+\n+static bool\n+get_computation_aff (struct loop *loop, gimple *at, struct iv_use *use,\n+\t\t     struct iv_cand *cand, struct aff_tree *aff)\n+{\n+  aff_tree aff_var;\n+\n+  if (!get_computation_aff_1 (loop, at, use, cand, aff, &aff_var))\n+    return false;\n \n+  aff_combination_add (aff, &aff_var);\n   return true;\n }\n \n@@ -3852,7 +3867,7 @@ get_computation_at (struct loop *loop, gimple *at,\n   aff_tree aff;\n   tree type = get_use_type (use);\n \n-  if (!get_computation_aff (loop, use, cand, at, &aff))\n+  if (!get_computation_aff (loop, at, use, cand, &aff))\n     return NULL_TREE;\n   unshare_aff_combination (&aff);\n   return fold_convert (type, aff_combination_to_tree (&aff));\n@@ -7336,7 +7351,7 @@ rewrite_use_address (struct ivopts_data *data,\n   bool ok;\n \n   adjust_iv_update_pos (cand, use);\n-  ok = get_computation_aff (data->current_loop, use, cand, use->stmt, &aff);\n+  ok = get_computation_aff (data->current_loop, use->stmt, use, cand, &aff);\n   gcc_assert (ok);\n   unshare_aff_combination (&aff);\n "}]}