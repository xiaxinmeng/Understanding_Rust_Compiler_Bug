{"sha": "5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5MGExODY2OGZlZjhkNTFlNWIzZmU5ZjY5MTIzZjUzY2JkOGYyNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T06:09:53Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-26T06:09:53Z"}, "message": "Add support for iterative dataflow to ipa-modref-tree.h\n\nTrack if insert and merge operations changed anything in the summary.\n\ngcc/ChangeLog:\n\n2020-09-26  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.h (modref_ref_node::insert_access): Track if something\n\tchanged.\n\t(modref_base_node::insert_ref): Likewise (and add a new optional\n\targument)\n\t(modref_tree::insert): Likewise.\n\t(modref_tree::merge): Rewrite", "tree": {"sha": "f75bd7e33541a15c627779c361eca5e84faf1095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f75bd7e33541a15c627779c361eca5e84faf1095"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25/comments", "author": null, "committer": null, "parents": [{"sha": "d4a906e7b51f3fc31f3328810f45ae4cf2e7bbc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a906e7b51f3fc31f3328810f45ae4cf2e7bbc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4a906e7b51f3fc31f3328810f45ae4cf2e7bbc3"}], "stats": {"total": 192, "additions": 124, "deletions": 68}, "files": [{"sha": "abf3fc18b052ab672027221515ebaa18a4879222", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 124, "deletions": 68, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a90a18668fef8d51e5b3fe9f69123f53cbd8f25/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=5a90a18668fef8d51e5b3fe9f69123f53cbd8f25", "patch": "@@ -88,17 +88,18 @@ struct GTY((user)) modref_ref_node\n   }\n \n   /* Insert access with OFFSET and SIZE.\n-     Collapse tree if it has more than MAX_ACCESSES entries.  */\n-  void insert_access (modref_access_node a, size_t max_accesses)\n+     Collapse tree if it has more than MAX_ACCESSES entries.\n+     Return true if record was changed.  */\n+  bool insert_access (modref_access_node a, size_t max_accesses)\n   {\n     /* If this base->ref pair has no access information, bail out.  */\n     if (every_access)\n-      return;\n+      return false;\n \n     /* Otherwise, insert a node for the ref of the access under the base.  */\n     modref_access_node *access_node = search (a);\n     if (access_node)\n-      return;\n+      return false;\n \n     /* If this base->ref pair has too many accesses stored, we will clear\n        all accesses and bail out.  */\n@@ -109,9 +110,10 @@ struct GTY((user)) modref_ref_node\n \t  fprintf (dump_file,\n \t\t   \"--param param=modref-max-accesses limit reached\\n\");\n \tcollapse ();\n-\treturn;\n+\treturn true;\n       }\n     vec_safe_push (accesses, a);\n+    return true;\n   }\n };\n \n@@ -139,8 +141,11 @@ struct GTY((user)) modref_base_node\n     return NULL;\n   }\n \n-  /* Insert REF; collapse tree if there are more than MAX_REFS.  */\n-  modref_ref_node <T> *insert_ref (T ref, size_t max_refs)\n+  /* Insert REF; collapse tree if there are more than MAX_REFS.\n+     Return inserted ref and if CHANGED is non-null set it to true if\n+     something changed.  */\n+  modref_ref_node <T> *insert_ref (T ref, size_t max_refs,\n+\t\t\t\t   bool *changed = NULL)\n   {\n     modref_ref_node <T> *ref_node;\n \n@@ -153,6 +158,9 @@ struct GTY((user)) modref_base_node\n     if (ref_node)\n       return ref_node;\n \n+    if (changed)\n+      *changed = true;\n+\n     /* Collapse the node if too full already.  */\n     if (refs && refs->length () >= max_refs)\n       {\n@@ -204,7 +212,11 @@ struct GTY((user)) modref_tree\n     max_accesses (max_accesses),\n     every_base (false) {}\n \n-  modref_base_node <T> *insert_base (T base)\n+  /* Insert BASE; collapse tree if there are more than MAX_REFS.\n+     Return inserted base and if CHANGED is non-null set it to true if\n+     something changed.  */\n+\n+  modref_base_node <T> *insert_base (T base, bool *changed = NULL)\n   {\n     modref_base_node <T> *base_node;\n \n@@ -217,6 +229,9 @@ struct GTY((user)) modref_tree\n     if (base_node)\n       return base_node;\n \n+    if (changed)\n+      *changed = true;\n+\n     /* Collapse the node if too full already.  */\n     if (bases && bases->length () >= max_bases)\n       {\n@@ -232,43 +247,72 @@ struct GTY((user)) modref_tree\n     return base_node;\n   }\n \n-  /* Insert memory access to the tree.\t*/\n-  void insert (T base, T ref, modref_access_node a)\n+  /* Insert memory access to the tree.\n+     Return true if something changed.  */\n+  bool insert (T base, T ref, modref_access_node a)\n   {\n+    if (every_base)\n+      return false;\n+\n+    bool changed = false;\n+\n     /* No useful information tracked; collapse everything.  */\n     if (!base && !ref && !a.useful_p ())\n       {\n \tcollapse ();\n-\treturn;\n+\treturn true;\n       }\n \n-    modref_base_node <T> *base_node = insert_base (base);\n-    if (!base_node)\n-      return;\n-    gcc_assert (search (base) != NULL);\n+    modref_base_node <T> *base_node = insert_base (base, &changed);\n+    if (!base_node || base_node->every_ref)\n+      return changed;\n+    gcc_checking_assert (search (base) != NULL);\n+\n+    /* No useful ref info tracked; collapse base.  */\n+    if (!ref && !a.useful_p ())\n+      {\n+\tbase_node->collapse ();\n+\treturn true;\n+      }\n \n-    modref_ref_node <T> *ref_node = base_node->insert_ref (ref, max_refs);\n+    modref_ref_node <T> *ref_node = base_node->insert_ref (ref, max_refs,\n+\t\t\t\t\t\t\t   &changed);\n \n-    /* No useful ref information and no useful base; collapse everyting.  */\n-    if (!base && base_node->every_ref)\n+    /* If we failed to insert ref, just see if there is a cleanup possible.  */\n+    if (!ref_node)\n       {\n-\tcollapse ();\n-\treturn;\n+\t/* No useful ref information and no useful base; collapse everyting.  */\n+\tif (!base && base_node->every_ref)\n+\t  {\n+\t    collapse ();\n+\t    gcc_checking_assert (changed);\n+\t  }\n+\telse if (changed)\n+\t  cleanup ();\n       }\n-    if (ref_node)\n+    else\n       {\n-\t/* No useful ref and access; collapse ref.  */\n-\tif (!ref && !a.useful_p ())\n-\t  ref_node->collapse ();\n-\telse\n+\tif (ref_node->every_access)\n+\t  return changed;\n+\tchanged |= ref_node->insert_access (a, max_accesses);\n+\t/* See if we failed to add useful access.  */\n+\tif (ref_node->every_access)\n \t  {\n-\t    ref_node->insert_access (a, max_accesses);\n-\t    /* If ref has collapses and there is no useful base; collapse\n-\t       everything.  */\n-\t    if (!base && !ref && ref_node->every_access)\n-\t      collapse ();\n+\t    /* Collapse everything if there is no useful base and ref.  */\n+\t    if (!base && !ref)\n+\t      {\n+\t\tcollapse ();\n+\t\tgcc_checking_assert (changed);\n+\t      }\n+\t    /* Collapse base if there is no useful ref.  */\n+\t    else if (!ref)\n+\t      {\n+\t\tbase_node->collapse ();\n+\t\tgcc_checking_assert (changed);\n+\t      }\n \t  }\n       }\n+    return changed;\n   }\n \n  /* Remove tree branches that are not useful (i.e. they will allways pass).  */\n@@ -317,62 +361,74 @@ struct GTY((user)) modref_tree\n \n   /* Merge OTHER into the tree.\n      PARM_MAP, if non-NULL, maps parm indexes of callee to caller.  -2 is used\n-     to signalize that parameter is local and does not need to be tracked.  */\n-  void merge (modref_tree <T> *other, vec <int> *parm_map)\n+     to signalize that parameter is local and does not need to be tracked.\n+     Return true if something has changed.  */\n+  bool merge (modref_tree <T> *other, vec <int> *parm_map)\n   {\n-    if (!other)\n-      return;\n+    if (!other || every_base)\n+      return false;\n     if (other->every_base)\n       {\n \tcollapse ();\n-\treturn;\n+\treturn true;\n       }\n \n+    bool changed = false;\n     size_t i, j, k;\n     modref_base_node <T> *base_node, *my_base_node;\n-    modref_ref_node <T> *ref_node, *my_ref_node;\n+    modref_ref_node <T> *ref_node;\n     modref_access_node *access_node;\n-    FOR_EACH_VEC_SAFE_ELT (other->bases, i, base_node)\n+    bool release = false;\n+\n+    /* For self-recursive functions we may end up merging summary into itself;\n+       produce copy first so we do not modify summary under our own hands.  */\n+    if (other == this)\n       {\n-\tmy_base_node = insert_base (base_node->base);\n-\tif (!my_base_node)\n-\t  continue;\n+\trelease = true;\n+\tother = modref_tree<T>::create_ggc (max_bases, max_refs, max_accesses);\n+\tother->copy_from (this);\n+      }\n \n+    FOR_EACH_VEC_SAFE_ELT (other->bases, i, base_node)\n+      {\n \tif (base_node->every_ref)\n \t  {\n-\t    my_base_node->collapse ();\n-\t    continue;\n-\t  }\n-\n-\tFOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n-\t  {\n-\t    my_ref_node = my_base_node->insert_ref (ref_node->ref, max_refs);\n-\t    if (!my_ref_node)\n-\t      continue;\n-\n-\t    if (ref_node->every_access)\n+\t    my_base_node = insert_base (base_node->base, &changed);\n+\t    if (my_base_node && !my_base_node->every_ref)\n \t      {\n-\t\tmy_ref_node->collapse ();\n-\t\tcontinue;\n+\t\tmy_base_node->collapse ();\n+\t\tcleanup ();\n+\t\tchanged = true;\n \t      }\n-\t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t      {\n-\t\tmodref_access_node a = *access_node;\n-\t\tif (a.parm_index != -1 && parm_map)\n+\t  }\n+\telse\n+\t  FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t    {\n+\t      if (ref_node->every_access)\n+\t\t{\n+\t\t  modref_access_node a = {-1};\n+\t\t  changed |= insert (base_node->base, ref_node->ref, a);\n+\t\t}\n+\t      else\n+\t\tFOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n \t\t  {\n-\t\t    if (a.parm_index >= (int)parm_map->length ())\n-\t\t      a.parm_index = -1;\n-\t\t    else if ((*parm_map) [a.parm_index] == -2)\n-\t\t      continue;\n-\t\t    else\n-\t\t      a.parm_index = (*parm_map) [a.parm_index];\n+\t\t    modref_access_node a = *access_node;\n+\t\t    if (a.parm_index != -1 && parm_map)\n+\t\t      {\n+\t\t\tif (a.parm_index >= (int)parm_map->length ())\n+\t\t\t  a.parm_index = -1;\n+\t\t\telse if ((*parm_map) [a.parm_index] == -2)\n+\t\t\t  continue;\n+\t\t\telse\n+\t\t\t  a.parm_index = (*parm_map) [a.parm_index];\n+\t\t      }\n+\t\t    changed |= insert (base_node->base, ref_node->ref, a);\n \t\t  }\n-\t\tmy_ref_node->insert_access (a, max_accesses);\n-\t      }\n-\t  }\n+\t    }\n       }\n-    if (parm_map)\n-      cleanup ();\n+    if (release)\n+      ggc_delete (other);\n+    return changed;\n   }\n \n   /* Copy OTHER to THIS.  */"}]}