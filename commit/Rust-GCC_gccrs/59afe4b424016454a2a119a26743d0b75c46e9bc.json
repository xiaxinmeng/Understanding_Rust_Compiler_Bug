{"sha": "59afe4b424016454a2a119a26743d0b75c46e9bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlhZmU0YjQyNDAxNjQ1NGEyYTExOWEyNjc0M2QwYjc1YzQ2ZTliYw==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-04-10T08:35:39Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-04-10T08:35:39Z"}, "message": "[multiple changes]\n\n2005-04-10  Thomas Koenig <Thomas.Koenig@online.de>\n\n        PR libfortran/17992\n        PR libfortran/19568\n        PR libfortran/19595\n        PR libfortran/20005\n        PR libfortran/20092\n        PR libfortran/20131\n        PR libfortran/20138\n        PR libfortran/20661\n        PR libfortran/20744\n        * io/transfer.c (top level): eor_condition: New static variable.\n        (read_sf): Remove unnecessary zeroing of buffer (there is enough\n        information in its length).\n        Return a string of length 0 (to be padded by caller) if EOR was\n        seen previously.\n        Remove erroneous special casing of EOR for standard input.\n        Set eor_condition for non-advancing I/O if an end of line was\n        detected.\n        Increment ioparm.size if necessary.\n        (formatted_transfer):  Skip the function if there is an EOR condition.\n        (data_transfer_init):  Initialize eor_condition to zero (false).\n        (next_record_r):  Clear sf_seen_eor if a \\n has been seen already.\n        (finalize_transfer):  If there is an EOR condition, raise the error.\n\n2005-04-10   Thomas Koenig  <Thomas.Koenig@online.de>\n\n        * eor_handling_1.f90: New test case.\n        * eor_handling_2.f90: New test case.\n        * eor_handling_3.f90: New test case.\n        * eor_handling_4.f90: New test case.\n        * eor_handling_5.f90: New test case.\n        * noadv_size.f90: New test case.\n        * pad_no.f90: New test case.\n\nFrom-SVN: r97943", "tree": {"sha": "c9a0285e6fdb6b7376373f67ac64eea33c65e9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a0285e6fdb6b7376373f67ac64eea33c65e9fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59afe4b424016454a2a119a26743d0b75c46e9bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59afe4b424016454a2a119a26743d0b75c46e9bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59afe4b424016454a2a119a26743d0b75c46e9bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59afe4b424016454a2a119a26743d0b75c46e9bc/comments", "author": null, "committer": null, "parents": [{"sha": "ecf9c079e2cf0d25a88746512fa491018a056c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf9c079e2cf0d25a88746512fa491018a056c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecf9c079e2cf0d25a88746512fa491018a056c24"}], "stats": {"total": 182, "additions": 174, "deletions": 8}, "files": [{"sha": "a55aec878465bbfdfa777820fb92ecb80df029bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -1,3 +1,13 @@\n+2005-04-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\t* eor_handling_1.f90: New test case.\n+\t* eor_handling_2.f90: New test case.\n+\t* eor_handling_3.f90: New test case.\n+\t* eor_handling_4.f90: New test case.\n+\t* eor_handling_5.f90: New test case.\n+\t* noadv_size.f90: New test case.\n+\t* pad_no.f90: New test case.\n+\n 2005-04-10  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.c-torture/execute/20050410-1.c: New test."}, {"sha": "241f8a0fe4e078056f9e58d429f6374519a346b3", "filename": "gcc/testsuite/gfortran.dg/eor_handling_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_1.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! PR 17992:  Reading an empty file should yield zero with pad='YES'\n+! (which is the default).\n+! Test case supplied by milan@cmm.ki.si.\n+program main\n+  open(77,status='scratch')\n+  write(77,'(A)') '',''\n+  rewind(77)\n+  i = 42\n+  j = 42\n+  read(77,'(/2i2)') i,j\n+  if (i /= 0 .or. j /= 0) call abort\n+  close(77)\n+end program main"}, {"sha": "5eb62f8a894b40515634ace5795b026f7e575da2", "filename": "gcc/testsuite/gfortran.dg/eor_handling_2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_2.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 19568:  Don't read across end of line when the format is longer\n+!            than the line length and pad='yes' (default)\n+program main\n+  character(len=1) c1(10),c2(10)\n+  open(77,status='scratch')\n+  write(77,'(A)') 'Line 1','Line 2','Line 3'\n+  rewind(77)\n+  read(77,'(10A1)'), c1\n+  read(77,'(10A1)'), c2\n+  if (c1(1) /= 'L' .or. c2(1) /= 'L') call abort\n+  close(77)\n+end program main"}, {"sha": "4225e867a85f17923f258d378530995f9bc943e1", "filename": "gcc/testsuite/gfortran.dg/eor_handling_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_3.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 19595:  Handle end-of-record condition with pad=yes (default)\n+program main\n+  integer i1, i2\n+  open(77,status='scratch')\n+  write (77,'(A)') '123','456'\n+  rewind(77)\n+  read(77,'(2I2)',advance='no',eor=100) i1,i2\n+  call abort\n+100 continue\n+  if (i1 /= 12 .or. i2 /= 3) call abort\n+  close(77)\n+end program main"}, {"sha": "300c10b820aafd0bd4faae078a050e14feb92c60", "filename": "gcc/testsuite/gfortran.dg/eor_handling_4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_4.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! PR 20092, 20131:  Handle end-of-record condition with pad=yes (default)\n+! for standard input.  This test case only really tests  anything if,\n+! by changing unit 5, you get to manipulate the standard input.\n+program main\n+  character(len=1) a(80)\n+  close(5)\n+  open(5,status=\"scratch\")\n+  write(5,'(A)') 'one', 'two', 's'\n+  rewind(5)\n+  do i=1,4\n+     read(5,'(80a1)') a\n+     if (a(1) == 's') goto 100\n+  end do\n+  call abort\n+100 continue\n+end program main"}, {"sha": "c116fb7bdeaf371da34a205096ce48101ddb94b6", "filename": "gcc/testsuite/gfortran.dg/eor_handling_5.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feor_handling_5.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! PR 20661: Handle non-advancing I/O with iostat\n+! Test case by Walt Brainerd, The Fortran Company\n+\n+program fc002\n+   character(len=1) :: c\n+   integer :: k,k2\n+   character(len=*), parameter :: f=\"(a)\"\n+   open(11,status=\"scratch\", iostat=k)\n+   if (k /= 0) call abort\n+   write(11,f) \"x\"\n+   rewind (11)\n+   read(11, f, advance=\"no\", iostat=k) c\n+   if (k /= 0) call abort\n+   read(11, f, advance=\"no\", iostat=k) c\n+   if (k >= 0) call abort\n+   read(11, f, advance=\"no\", iostat=k2) c\n+   if (k2 >= 0 .or. k == k2) call abort\n+end program fc002"}, {"sha": "a3a88b18ca722808264621e781d385166cdc7456", "filename": "gcc/testsuite/gfortran.dg/noadv_size.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fnoadv_size.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fnoadv_size.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnoadv_size.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! PR 20774: Handle size parameter for non-advancing I/O correctly\n+program main\n+  open(77,status='scratch')\n+  write(77,'(A)') '123'\n+  rewind(77)\n+  read(77,'(2I2)',advance='no',iostat=k,size=n) i1,i2\n+  if (k >=0) call abort\n+  if (n /= 3) call abort\n+  if (i1 /= 12 .or. i2 /= 3) call abort\n+end program main"}, {"sha": "c023adec815e87c116055be88641545f0fd0f5a9", "filename": "gcc/testsuite/gfortran.dg/pad_no.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpad_no.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fpad_no.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpad_no.f90?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! Test correct operation for pad='no'.\n+program main\n+  character(len=1) line(2)\n+  line = 'x'\n+  open(77,status='scratch',pad='no')\n+  write(77,'(A)') 'a','b'\n+  rewind(77)\n+  read(77,'(2A)',iostat=i) line(1)\n+  if (line(1) /= 'a' .or. line(2) /= 'x') call abort\n+  rewind(77)\n+  line = 'y'\n+  read(77,'(2A)',iostat=i,advance='no') line\n+  if (line(1) /= 'a' .or. line(2) /= 'y') call abort\n+end program main"}, {"sha": "fcb4ff3ae88307f7415e3b43a150977e36a277ac", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -1,3 +1,28 @@\n+2005-04-10  Thomas Koenig <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/17992\n+\tPR libfortran/19568\n+\tPR libfortran/19595\n+\tPR libfortran/20005\n+\tPR libfortran/20092\n+\tPR libfortran/20131\n+\tPR libfortran/20138\n+\tPR libfortran/20661\n+\tPR libfortran/20744\n+\t* io/transfer.c (top level): eor_condition: New static variable.\n+\t(read_sf): Remove unnecessary zeroing of buffer (there is enough\n+\tinformation in its length).\n+\tReturn a string of length 0 (to be padded by caller) if EOR was\n+\tseen previously.\n+\tRemove erroneous special casing of EOR for standard input.\n+\tSet eor_condition for non-advancing I/O if an end of line was\n+\tdetected.\n+\tIncrement ioparm.size if necessary.\n+\t(formatted_transfer):  Skip the function if there is an EOR condition.\n+\t(data_transfer_init):  Initialize eor_condition to zero (false).\n+\t(next_record_r):  Clear sf_seen_eor if a \\n has been seen already.\n+\t(finalize_transfer):  If there is an EOR condition, raise the error.\n+\n 2005-04-09  Bud Davis  <bdavis@gfortran.org>\n             Steven G. Kargl <kargls@comcast.net>\n "}, {"sha": "77e943964d8a022c19eefc5ef439ca960de5953c", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59afe4b424016454a2a119a26743d0b75c46e9bc/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59afe4b424016454a2a119a26743d0b75c46e9bc/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=59afe4b424016454a2a119a26743d0b75c46e9bc", "patch": "@@ -79,6 +79,7 @@ export_proto(transfer_complex);\n \n gfc_unit *current_unit = NULL;\n static int sf_seen_eor = 0;\n+static int eor_condition = 0;\n \n char scratch[SCRATCH_SIZE] = { };\n static char *line_buffer = NULL;\n@@ -150,7 +151,13 @@ read_sf (int *length)\n   else\n     p = base = data;\n \n-  memset(base,'\\0',*length);\n+  /* If we have seen an eor previously, return a length of 0.  The\n+     caller is responsible for correctly padding the input field.  */\n+  if (sf_seen_eor)\n+    {\n+      *length = 0;\n+      return base;\n+    }\n \n   current_unit->bytes_left = options.default_recl;\n   readlen = 1;\n@@ -179,13 +186,16 @@ read_sf (int *length)\n \n       if (readlen < 1 || *q == '\\n' || *q == '\\r')\n \t{\n-\t  /* ??? What is this for?  */\n-          if (current_unit->unit_number == options.stdin_unit)\n-            {\n-              if (n <= 0)\n-                continue;\n-            }\n \t  /* Unexpected end of line.  */\n+\n+\t  /* If we see an EOR during non-advancing I/O, we need to skip\n+\t     the rest of the I/O statement.  Set the corresponding flag.  */\n+\t  if (advance_status == ADVANCE_NO)\n+\t    eor_condition = 1;\n+\n+\t  /* Without padding, terminate the I/O statement without assigning\n+\t     the value.  With padding, the value still needs to be assigned,\n+\t     so we can just continue with a short read.  */\n \t  if (current_unit->flags.pad == PAD_NO)\n \t    {\n \t      generate_error (ERROR_EOR, NULL);\n@@ -204,6 +214,9 @@ read_sf (int *length)\n     }\n   while (n < *length);\n \n+  if (ioparm.size != NULL)\n+    *ioparm.size += *length;\n+\n   return base;\n }\n \n@@ -434,6 +447,11 @@ formatted_transfer (bt type, void *p, int len)\n   if (type == BT_COMPLEX)\n     type = BT_REAL;\n \n+  /* If there's an EOR condition, we simulate finalizing the transfer\n+     by doing nothing.  */\n+  if (eor_condition)\n+    return;\n+\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n@@ -1121,6 +1139,7 @@ data_transfer_init (int read_flag)\n   g.first_item = 1;\n   g.item_count = 0;\n   sf_seen_eor = 0;\n+  eor_condition = 0;\n \n   pre_position ();\n \n@@ -1236,7 +1255,10 @@ next_record_r (int done)\n       length = 1;\n       /* sf_read has already terminated input because of an '\\n'  */\n       if (sf_seen_eor) \n-         break;\n+\t{\n+\t  sf_seen_eor=0;\n+\t  break;\n+\t}\n \n       do\n         {\n@@ -1402,6 +1424,13 @@ next_record (int done)\n static void\n finalize_transfer (void)\n {\n+\n+  if (eor_condition)\n+    {\n+      generate_error (ERROR_EOR, NULL);\n+      return;\n+    }\n+\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n "}]}