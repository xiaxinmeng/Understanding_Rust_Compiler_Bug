{"sha": "e65a757989102018f314bc3d1548f10c104bd305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1YTc1Nzk4OTEwMjAxOGYzMTRiYzNkMTU0OGYxMGMxMDRiZDMwNQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-02-06T17:40:58Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-02-06T17:40:58Z"}, "message": "Add missing function comments.\n\n2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-dependences.c (lexicographically_gt_p): Add comments.\n\t(build_lexicographically_gt_constraint): Same.\n\t(dependence_polyhedron_1): Same.\n\t(dependence_polyhedron): Same.\n\nFrom-SVN: r156543", "tree": {"sha": "d46826408a5b7850a128e0a431b5408ac18ff717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d46826408a5b7850a128e0a431b5408ac18ff717"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e65a757989102018f314bc3d1548f10c104bd305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65a757989102018f314bc3d1548f10c104bd305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65a757989102018f314bc3d1548f10c104bd305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65a757989102018f314bc3d1548f10c104bd305/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cbd4c5e848e97666ca4703aff9ea1c36881f39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbd4c5e848e97666ca4703aff9ea1c36881f39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbd4c5e848e97666ca4703aff9ea1c36881f39a"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "8d26291c69696b60831987e099bbcd65451643be", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65a757989102018f314bc3d1548f10c104bd305/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65a757989102018f314bc3d1548f10c104bd305/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=e65a757989102018f314bc3d1548f10c104bd305", "patch": "@@ -1,3 +1,10 @@\n+2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c (lexicographically_gt_p): Add comments.\n+\t(build_lexicographically_gt_constraint): Same.\n+\t(dependence_polyhedron_1): Same.\n+\t(dependence_polyhedron): Same.\n+\n 2010-01-20  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-dependences.c (build_pairwise_scheduling_equality): Removed."}, {"sha": "e096cba7e264567de17b75d8c28b569db57572a4", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65a757989102018f314bc3d1548f10c104bd305/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65a757989102018f314bc3d1548f10c104bd305/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=e65a757989102018f314bc3d1548f10c104bd305", "patch": "@@ -262,8 +262,13 @@ build_pairwise_scheduling (graphite_dim_t dim,\n   return res;\n }\n \n-/* Returns true when adding the lexicographical constraints at level I\n-   to the RES dependence polyhedron returns an empty polyhedron.  */\n+/* Returns true when adding to the RES dependence polyhedron the\n+   lexicographical constraint: \"DIM compared to DIM + OFFSET\" returns\n+   an empty polyhedron.  The comparison depends on DIRECTION as: if\n+   DIRECTION is equal to -1, the first dimension DIM to be compared\n+   comes before the second dimension DIM + OFFSET, equal to 0 when DIM\n+   and DIM + OFFSET are equal, and DIRECTION is set to 1 when DIM\n+   comes after DIM + OFFSET.  */\n \n static bool\n lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n@@ -284,13 +289,21 @@ lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n   return !empty_p;\n }\n \n-/* Build the precedence constraints for the lexicographical comparison\n-   of time vectors RES following the lexicographical order.  */\n+/* Add to a non empty polyhedron RES the precedence constraints for\n+   the lexicographical comparison of time vectors in RES following the\n+   lexicographical order.  DIM is the dimension of the polyhedron RES.\n+   TDIM is the number of loops common to the two statements that are\n+   compared lexicographically, i.e. the number of loops containing\n+   both statements.  OFFSET is the number of dimensions needed to\n+   represent the first statement, i.e. dimT1 + dimI1 in the layout of\n+   the RES polyhedron: T1|I1|T2|I2|S1|S2|G.  DIRECTION is equal to 1\n+   when statement 1 is after statement 2, equal to -1 when statement 1\n+   is before statement 2.  */\n \n static void\n build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n \t\t\t\t       graphite_dim_t dim,\n-\t\t\t\t       graphite_dim_t tdim1,\n+\t\t\t\t       graphite_dim_t tdim,\n \t\t\t\t       graphite_dim_t offset,\n \t\t\t\t       int direction)\n {\n@@ -299,19 +312,21 @@ build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res\n   if (lexicographically_gt_p (*res, dim, offset, direction, 0))\n     return;\n \n-  for (i = 0; i < tdim1 - 1; i++)\n+  for (i = 0; i < tdim - 1; i++)\n     {\n       ppl_Pointset_Powerset_C_Polyhedron_t sceq;\n \n+      /* All the dimensions up to I are equal, ...  */\n       sceq = build_pairwise_scheduling (dim, i, offset, 0);\n       ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, sceq);\n       ppl_delete_Pointset_Powerset_C_Polyhedron (sceq);\n \n+      /* ... and at depth I+1 they are not equal anymore.  */\n       if (lexicographically_gt_p (*res, dim, offset, direction, i + 1))\n \treturn;\n     }\n \n-  if (i == tdim1 - 1)\n+  if (i == tdim - 1)\n     {\n       ppl_delete_Pointset_Powerset_C_Polyhedron (*res);\n       ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (res, dim, 1);\n@@ -327,14 +342,22 @@ build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res\n    | T1 and T2 the scattering dimensions for PDR1 and PDR2\n    | I1 and I2 the iteration domains\n    | S1 and S2 the subscripts\n-   | G the global parameters.  */\n+   | G the global parameters.\n+\n+   SCAT1 and SCAT2 are the scattering polyhedra for PDR1 and PDR2.\n+   When ORIGINAL_SCATTERING_P is true, then the scattering polyhedra\n+   SCAT1 and SCAT2 correspond to the original scattering of the\n+   program, otherwise they correspond to the transformed scattering.\n+\n+   DIRECTION is equal to 1 when statement 1 is after statement 2,\n+   equal to -1 when statement 1 is before statement 2.  */\n \n static poly_ddr_p\n dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n \t\t         ppl_Pointset_Powerset_C_Polyhedron_t d1,\n \t\t         ppl_Pointset_Powerset_C_Polyhedron_t d2,\n \t\t         poly_dr_p pdr1, poly_dr_p pdr2,\n-\t                 ppl_Polyhedron_t s1, ppl_Polyhedron_t s2,\n+\t                 ppl_Polyhedron_t scat1, ppl_Polyhedron_t scat2,\n \t\t         int direction,\n \t\t         bool original_scattering_p)\n {\n@@ -361,8 +384,8 @@ dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n     (&context, SCOP_CONTEXT (scop));\n   ppl_insert_dimensions_pointset (context, 0, dim - gdim);\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc1, s1);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc2, s2);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc1, scat1);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc2, scat2);\n \n   id1 = map_into_dep_poly (dim, gdim, d1, ddim1, tdim1);\n   id2 = map_into_dep_poly (dim, gdim, d2, ddim2, tdim1 + ddim1 + tdim2);\n@@ -405,14 +428,22 @@ dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n }\n \n /* Build the dependence polyhedron for data references PDR1 and PDR2.\n-   If possible use already cached information.  */\n+   If possible use already cached information.\n+\n+   SCAT1 and SCAT2 are the scattering polyhedra for PDR1 and PDR2.\n+   When ORIGINAL_SCATTERING_P is true, then the scattering polyhedra\n+   SCAT1 and SCAT2 correspond to the original scattering of the\n+   program, otherwise they correspond to the transformed scattering.\n+\n+   DIRECTION is equal to 1 when statement 1 is after statement 2,\n+   equal to -1 when statement 1 is before statement 2.  */\n \n static poly_ddr_p\n dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n \t\t       ppl_Pointset_Powerset_C_Polyhedron_t d1,\n \t\t       ppl_Pointset_Powerset_C_Polyhedron_t d2,\n \t\t       poly_dr_p pdr1, poly_dr_p pdr2,\n-\t               ppl_Polyhedron_t s1, ppl_Polyhedron_t s2,\n+\t               ppl_Polyhedron_t scat1, ppl_Polyhedron_t scat2,\n \t\t       int direction,\n \t\t       bool original_scattering_p)\n {\n@@ -433,7 +464,7 @@ dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n     }\n \n   res = dependence_polyhedron_1 (pbb1, pbb2, d1, d2, pdr1, pdr2,\n-                                 s1, s2, direction, original_scattering_p);\n+                                 scat1, scat2, direction, original_scattering_p);\n \n   if (original_scattering_p)\n     *x = res;"}]}