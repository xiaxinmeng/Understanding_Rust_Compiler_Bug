{"sha": "fbeead55e03711fb39429ab564a0d8a0b43e9a74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlZWFkNTVlMDM3MTFmYjM5NDI5YWI1NjRhMGQ4YTBiNDNlOWE3NA==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-09-13T02:57:34Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-09-13T06:28:59Z"}, "message": "rs6000: Add load density heuristic\n\nWe noticed that SPEC2017 503.bwaves_r run time degrades by\nabout 8% on P8 and P9 if we enabled vectorization at O2\nfast-math (with cheap vect cost model).  Comparing to Ofast,\ncompiler doesn't do the loop interchange on the innermost\nloop, it's not profitable to vectorize it then.\n\nAs Richi's comments [1], this follows the similar idea to\nover price the vector construction fed by VMAT_ELEMENTWISE\nor VMAT_STRIDED_SLP.  Instead of adding the extra cost on\nvector construction costing immediately, it firstly records\nhow many loads and vectorized statements in the given loop,\nlater in rs6000_density_test (called by finish_cost) it\ncomputes the load density ratio against all vectorized\nstatements, and check with the corresponding thresholds\nDENSITY_LOAD_NUM_THRESHOLD and DENSITY_LOAD_PCT_THRESHOLD,\ndo the actual extra pricing if both thresholds are exceeded.\n\nNote that this new load density heuristic check is based on\nsome fields in target cost which are updated as needed when\nscanning each add_stmt_cost entry, it's independent of the\ncurrent function rs6000_density_test which requires to scan\nnon_vect stmts.  Since it's checking the load stmts count\nvs. all vectorized stmts, it's kind of density, so I put\nit in function rs6000_density_test.  With the same reason to\nkeep it independent, I didn't put it as an else arm of the\ncurrent existing density threshold check hunk or before this\nhunk.\n\nIn the investigation of -1.04% degradation from 526.blender_r\non Power8, I noticed that the extra penalized cost 320 on one\nsingle vector construction for mode V16QI is much exaggerated,\nwhich makes the final body cost unreliable, so this patch adds\none maximum bound for the extra penalized cost for each vector\nconstruction statement.\n\nFull SPEC2017 performance evaluation on Power8/Power9 with\noption combinations:\n  * -O2 -ftree-vectorize {,-fvect-cost-model=very-cheap}\n    {,-ffast-math}\n  * {-O3, -Ofast} {,-funroll-loops}\nbwaves_r degradations on P8/P9 have been fixed, nothing else\nremarkable was observed.  Power10 -Ofast -funroll-loops run\nshows it's neutral, while -O2 -ftree-vectorize run shows the\nbwaves_r degradation is fixed expectedly.\n\n[1] https://gcc.gnu.org/pipermail/gcc-patches/2021-May/570076.html\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.c (struct rs6000_cost_data): New members\n\tnstmts, nloads and extra_ctor_cost.\n\t(rs6000_density_test): Add load density related heuristics.  Do\n\textra costing on vector construction statements if need.\n\t(rs6000_init_cost): Init new members.\n\t(rs6000_update_target_cost_per_stmt): New function.\n\t(rs6000_add_stmt_cost): Factor vect_nonmem hunk out to function\n\trs6000_update_target_cost_per_stmt and call it.", "tree": {"sha": "01c080d21327ce2dfb2c9d14a7c2b304726b801c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c080d21327ce2dfb2c9d14a7c2b304726b801c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbeead55e03711fb39429ab564a0d8a0b43e9a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbeead55e03711fb39429ab564a0d8a0b43e9a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbeead55e03711fb39429ab564a0d8a0b43e9a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbeead55e03711fb39429ab564a0d8a0b43e9a74/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b70e2541fec8751d287b24b9e3681a41e420d4c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70e2541fec8751d287b24b9e3681a41e420d4c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b70e2541fec8751d287b24b9e3681a41e420d4c4"}], "stats": {"total": 125, "additions": 116, "deletions": 9}, "files": [{"sha": "25709375635e08ae97b4c179f3c74919484e2006", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 116, "deletions": 9, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbeead55e03711fb39429ab564a0d8a0b43e9a74/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbeead55e03711fb39429ab564a0d8a0b43e9a74/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fbeead55e03711fb39429ab564a0d8a0b43e9a74", "patch": "@@ -5266,6 +5266,12 @@ struct rs6000_cost_data\n {\n   struct loop *loop_info;\n   unsigned cost[3];\n+  /* Total number of vectorized stmts (loop only).  */\n+  unsigned nstmts;\n+  /* Total number of loads (loop only).  */\n+  unsigned nloads;\n+  /* Possible extra penalized cost on vector construction (loop only).  */\n+  unsigned extra_ctor_cost;\n   /* For each vectorized loop, this var holds TRUE iff a non-memory vector\n      instruction is needed by the vectorization.  */\n   bool vect_nonmem;\n@@ -5327,9 +5333,48 @@ rs6000_density_test (rs6000_cost_data *data)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"density %d%%, cost %d exceeds threshold, penalizing \"\n-\t\t\t \"loop body cost by %d%%\", density_pct,\n+\t\t\t \"loop body cost by %d%%\\n\", density_pct,\n \t\t\t vec_cost + not_vec_cost, DENSITY_PENALTY);\n     }\n+\n+  /* Check whether we need to penalize the body cost to account\n+     for excess strided or elementwise loads.  */\n+  if (data->extra_ctor_cost > 0)\n+    {\n+      /* Threshold for load stmts percentage in all vectorized stmts.  */\n+      const int DENSITY_LOAD_PCT_THRESHOLD = 45;\n+      /* Threshold for total number of load stmts.  */\n+      const int DENSITY_LOAD_NUM_THRESHOLD = 20;\n+\n+      gcc_assert (data->nloads <= data->nstmts);\n+      unsigned int load_pct = (data->nloads * 100) / data->nstmts;\n+\n+      /* It's likely to be bounded by latency and execution resources\n+\t from many scalar loads which are strided or elementwise loads\n+\t into a vector if both conditions below are found:\n+\t   1. there are many loads, it's easy to result in a long wait\n+\t      for load units;\n+\t   2. load has a big proportion of all vectorized statements,\n+\t      it's not easy to schedule other statements to spread among\n+\t      the loads.\n+\t One typical case is the innermost loop of the hotspot of SPEC2017\n+\t 503.bwaves_r without loop interchange.  */\n+      if (data->nloads > DENSITY_LOAD_NUM_THRESHOLD\n+\t  && load_pct > DENSITY_LOAD_PCT_THRESHOLD)\n+\t{\n+\t  data->cost[vect_body] += data->extra_ctor_cost;\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Found %u loads and \"\n+\t\t\t     \"load pct. %u%% exceed \"\n+\t\t\t     \"the threshold, \"\n+\t\t\t     \"penalizing loop body \"\n+\t\t\t     \"cost by extra cost %u \"\n+\t\t\t     \"for ctor.\\n\",\n+\t\t\t     data->nloads, load_pct,\n+\t\t\t     data->extra_ctor_cost);\n+\t}\n+    }\n }\n \n /* Implement targetm.vectorize.init_cost.  */\n@@ -5343,6 +5388,9 @@ rs6000_init_cost (struct loop *loop_info, bool costing_for_scalar)\n   data->cost[vect_body]     = 0;\n   data->cost[vect_epilogue] = 0;\n   data->vect_nonmem = false;\n+  data->nstmts = 0;\n+  data->nloads = 0;\n+  data->extra_ctor_cost = 0;\n   data->costing_for_scalar = costing_for_scalar;\n   return data;\n }\n@@ -5370,6 +5418,70 @@ rs6000_adjust_vect_cost_per_stmt (enum vect_cost_for_stmt kind,\n   return 0;\n }\n \n+/* Helper function for add_stmt_cost.  Check each statement cost\n+   entry, gather information and update the target_cost fields\n+   accordingly.  */\n+static void\n+rs6000_update_target_cost_per_stmt (rs6000_cost_data *data,\n+\t\t\t\t    enum vect_cost_for_stmt kind,\n+\t\t\t\t    struct _stmt_vec_info *stmt_info,\n+\t\t\t\t    enum vect_cost_model_location where,\n+\t\t\t\t    int stmt_cost,\n+\t\t\t\t    unsigned int orig_count)\n+{\n+\n+  /* Check whether we're doing something other than just a copy loop.\n+     Not all such loops may be profitably vectorized; see\n+     rs6000_finish_cost.  */\n+  if (kind == vec_to_scalar\n+      || kind == vec_perm\n+      || kind == vec_promote_demote\n+      || kind == vec_construct\n+      || kind == scalar_to_vec\n+      || (where == vect_body && kind == vector_stmt))\n+    data->vect_nonmem = true;\n+\n+  /* Gather some information when we are costing the vectorized instruction\n+     for the statements located in a loop body.  */\n+  if (!data->costing_for_scalar && data->loop_info && where == vect_body)\n+    {\n+      data->nstmts += orig_count;\n+\n+      if (kind == scalar_load || kind == vector_load\n+\t  || kind == unaligned_load || kind == vector_gather_load)\n+\tdata->nloads += orig_count;\n+\n+      /* Power processors do not currently have instructions for strided\n+\t and elementwise loads, and instead we must generate multiple\n+\t scalar loads.  This leads to undercounting of the cost.  We\n+\t account for this by scaling the construction cost by the number\n+\t of elements involved, and saving this as extra cost that we may\n+\t or may not need to apply.  When finalizing the cost of the loop,\n+\t the extra penalty is applied when the load density heuristics\n+\t are satisfied.  */\n+      if (kind == vec_construct && stmt_info\n+\t  && STMT_VINFO_TYPE (stmt_info) == load_vec_info_type\n+\t  && (STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_ELEMENTWISE\n+\t      || STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_STRIDED_SLP))\n+\t{\n+\t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t  unsigned int nunits = vect_nunits_for_cost (vectype);\n+\t  unsigned int extra_cost = nunits * stmt_cost;\n+\t  /* As function rs6000_builtin_vectorization_cost shows, we have\n+\t     priced much on V16QI/V8HI vector construction as their units,\n+\t     if we penalize them with nunits * stmt_cost, it can result in\n+\t     an unreliable body cost, eg: for V16QI on Power8, stmt_cost\n+\t     is 20 and nunits is 16, the extra cost is 320 which looks\n+\t     much exaggerated.  So let's use one maximum bound for the\n+\t     extra penalized cost for vector construction here.  */\n+\t  const unsigned int MAX_PENALIZED_COST_FOR_CTOR = 12;\n+\t  if (extra_cost > MAX_PENALIZED_COST_FOR_CTOR)\n+\t    extra_cost = MAX_PENALIZED_COST_FOR_CTOR;\n+\t  data->extra_ctor_cost += extra_cost;\n+\t}\n+    }\n+}\n+\n /* Implement targetm.vectorize.add_stmt_cost.  */\n \n static unsigned\n@@ -5389,6 +5501,7 @@ rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n       /* Statements in an inner loop relative to the loop being\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n+      unsigned int orig_count = count;\n       if (where == vect_body && stmt_info\n \t  && stmt_in_inner_loop_p (vinfo, stmt_info))\n \t{\n@@ -5400,14 +5513,8 @@ rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n       retval = (unsigned) (count * stmt_cost);\n       cost_data->cost[where] += retval;\n \n-      /* Check whether we're doing something other than just a copy loop.\n-\t Not all such loops may be profitably vectorized; see\n-\t rs6000_finish_cost.  */\n-      if ((kind == vec_to_scalar || kind == vec_perm\n-\t   || kind == vec_promote_demote || kind == vec_construct\n-\t   || kind == scalar_to_vec)\n-\t  || (where == vect_body && kind == vector_stmt))\n-\tcost_data->vect_nonmem = true;\n+      rs6000_update_target_cost_per_stmt (cost_data, kind, stmt_info, where,\n+\t\t\t\t\t  stmt_cost, orig_count);\n     }\n \n   return retval;"}]}