{"sha": "fc6a28d7633ddd7c734b759f4d60233b70bf1770", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2YTI4ZDc2MzNkZGQ3YzczNGI3NTlmNGQ2MDIzM2I3MGJmMTc3MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-11-29T20:10:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-11-29T20:10:18Z"}, "message": "re PR c++/18368 (C++ error message regression)\n\n\tPR c++/18368\n\t* parser.c (cp_parser_check_for_definition_in_return_type): Take\n\tthe defined type as a parameter, and inform the user about the\n\tpossibility of a missing semicolon.\n\t(cp_parser_explicit_instantiation): Adjust call to\n\tcp_parser_check_for_definition_in_return_type.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\n\tPR c++/18674\n\t* cp-tree.def (TYPENAME_TYPE): Remove discussion of implicit\n\ttypename from comments.\n\t* cp-tree.h (TYPENAME_IS_ENUM_P): New macro.\n\t(TYPENAME_IS_CLASS_P): Likewise.\n\t(make_typename_type): Change prototype.\n\t* decl.c (struct_typename_info): New type.\n\t(typename_compare): Expect the second argument to be a\n\ttypename_info, not a tree.\n\t(build_typename_type): Add tag_type parameter.  Do not create a\n\tnew type until necessary.\n\t(make_typename_type): Add tag_type parameter.\n\t* error.c (TYPENAME_TYPE): Print tags other than \"typename\" if\n\tappropriate.\n\t* friend.c (make_friend_class): Adjust call to make_typename_type.\n\t* parser.c (cp_parser_make_typename_type): Likewise.\n\t(cp_parser_primary_expression): Adjust call to\n\tcp_parser_lookup_name.\n\t(cp_parser_unqualified_id): Adjust calls to cp_parser_class_name.\n\t(cp_parser_class_or_namespace_name): Likewise.\n\t(cp_parser_postfix_expression): Adjust calls to\n\tmake_typename_type.\n\t(cp_parser_mem_initializer_id): Adjust calls to\n\tcp_parser_class_name.\n\t(cp_parser_type_parameter): Adjust calls to cp_parser_lookup_name.\n\t(cp_parser_template_name): Likewise.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_type_name): Adjust call to cp_parser_class_name.\n\t(cp_parser_elaborated_type_specifier): Adjust calls to\n\tmake_typename_type and cp_parser_lookup_name.\n\t(cp_parser_namespace_name): Likewise.\n\t(cp_parser_class_name): Replace type_p parameter with tag_type.\n\tAdjust calls to make_typename_type and cp_parser_lookup_name.\n\t(cp_parser_class_head): Adjust calls to cp_parser_class_name.\n\t(cp_parser_base_specifier): Likewise.\n\t(cp_parser_lookup_name): Replace is_type parameter with tag_type.\n\tAdjust calls to make_typename_type and lookup_qualified_name.\n\t(cp_parser_lookup_name_simple): Adjust call to\n\tcp_parser_lookup_name.\n\t(cp_parser_constructor_declarator_p): Adjust call to\n\tcp_parser_class_name.\n\t* pt.c (convert_template_argument): Adjust all to\n\tmake_typename_type.\n\t(tsubst_decl): Do not pre-substitute the type of the declaration.\n\t(tsubst): Hand off declarations more quickly.  Adjust call to\n\tmake_typename_type.\n\n\tPR c++/18512\n\t* parser.c (cp_parser_postfix_dot_deref_expression): Robustify.\n\n\tPR c++/18674\n\t* g++.old-deja/g++.brendan/crash16.C: Adjust error messages.\n\t* g++.old-deja/g++.law/ctors5.C: Likewise.\n\t* g++.old-deja/g++.other/crash25.C: Likewise.\n\n\tPR c++/18674\n\t* g++.dg/template/error16.C: New test.\n\n\tPR c++/18512\n\t* g++.dg/template/crash29.C: New test.\n\nFrom-SVN: r91483", "tree": {"sha": "3136f9512ba6b63b67d1999c006891472812416e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3136f9512ba6b63b67d1999c006891472812416e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc6a28d7633ddd7c734b759f4d60233b70bf1770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6a28d7633ddd7c734b759f4d60233b70bf1770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6a28d7633ddd7c734b759f4d60233b70bf1770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6a28d7633ddd7c734b759f4d60233b70bf1770/comments", "author": null, "committer": null, "parents": [{"sha": "b7034e060b24bd94c51cb563db1cd18c30eb1fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7034e060b24bd94c51cb563db1cd18c30eb1fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7034e060b24bd94c51cb563db1cd18c30eb1fd6"}], "stats": {"total": 495, "additions": 339, "deletions": 156}, "files": [{"sha": "449be96ceeae83533bc8fa6b156a9ac1fd3167f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -1,3 +1,64 @@\n+2004-11-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18368\n+\t* parser.c (cp_parser_check_for_definition_in_return_type): Take\n+\tthe defined type as a parameter, and inform the user about the\n+\tpossibility of a missing semicolon.\n+\t(cp_parser_explicit_instantiation): Adjust call to\n+\tcp_parser_check_for_definition_in_return_type.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\n+\tPR c++/18674\n+\t* cp-tree.def (TYPENAME_TYPE): Remove discussion of implicit\n+\ttypename from comments.\n+\t* cp-tree.h (TYPENAME_IS_ENUM_P): New macro.\n+\t(TYPENAME_IS_CLASS_P): Likewise.\n+\t(make_typename_type): Change prototype.\n+\t* decl.c (struct_typename_info): New type.\n+\t(typename_compare): Expect the second argument to be a\n+\ttypename_info, not a tree.\n+\t(build_typename_type): Add tag_type parameter.  Do not create a\n+\tnew type until necessary.\n+\t(make_typename_type): Add tag_type parameter.\n+\t* error.c (TYPENAME_TYPE): Print tags other than \"typename\" if\n+\tappropriate.\n+\t* friend.c (make_friend_class): Adjust call to make_typename_type.\n+\t* parser.c (cp_parser_make_typename_type): Likewise.\n+\t(cp_parser_primary_expression): Adjust call to\n+\tcp_parser_lookup_name.\n+\t(cp_parser_unqualified_id): Adjust calls to cp_parser_class_name.\n+\t(cp_parser_class_or_namespace_name): Likewise.\n+\t(cp_parser_postfix_expression): Adjust calls to\n+\tmake_typename_type.\n+\t(cp_parser_mem_initializer_id): Adjust calls to\n+\tcp_parser_class_name.\n+\t(cp_parser_type_parameter): Adjust calls to cp_parser_lookup_name.\n+\t(cp_parser_template_name): Likewise.\n+\t(cp_parser_template_argument): Likewise.\n+\t(cp_parser_type_name): Adjust call to cp_parser_class_name.\n+\t(cp_parser_elaborated_type_specifier): Adjust calls to\n+\tmake_typename_type and cp_parser_lookup_name.\n+\t(cp_parser_namespace_name): Likewise.\n+\t(cp_parser_class_name): Replace type_p parameter with tag_type.\n+\tAdjust calls to make_typename_type and cp_parser_lookup_name.\n+\t(cp_parser_class_head): Adjust calls to cp_parser_class_name.\n+\t(cp_parser_base_specifier): Likewise.\n+\t(cp_parser_lookup_name): Replace is_type parameter with tag_type.\n+\tAdjust calls to make_typename_type and lookup_qualified_name.\n+\t(cp_parser_lookup_name_simple): Adjust call to\n+\tcp_parser_lookup_name.\n+\t(cp_parser_constructor_declarator_p): Adjust call to\n+\tcp_parser_class_name.\n+\t* pt.c (convert_template_argument): Adjust all to\n+\tmake_typename_type.\n+\t(tsubst_decl): Do not pre-substitute the type of the declaration.\n+\t(tsubst): Hand off declarations more quickly.  Adjust call to\n+\tmake_typename_type. \n+\n+\tPR c++/18512\n+\t* parser.c (cp_parser_postfix_dot_deref_expression): Robustify.\n+\n 2004-11-29  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \tPR c/7544"}, {"sha": "a01ed7666f3213c739bab6fe302bb6faa7e8d05f", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -182,9 +182,7 @@ DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n /* A type designated by `typename T::t'.  TYPE_CONTEXT is `T',\n    TYPE_NAME is an IDENTIFIER_NODE for `t'.  If the type was named via\n    template-id, TYPENAME_TYPE_FULLNAME will hold the TEMPLATE_ID_EXPR.\n-   If TREE_TYPE is present, this type was generated by the implicit\n-   typename extension, and the TREE_TYPE is a _TYPE from a baseclass\n-   of `T'.  */\n+   TREE_TYPE is always NULL.  */\n DEFTREECODE (TYPENAME_TYPE, \"typename_type\", tcc_type, 0)\n \n /* For template template argument of the form `T::template C'."}, {"sha": "ecc09cd3b5a10394b5327fe90b4f3e77d21f76bc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -47,13 +47,15 @@ struct diagnostic_context;\n       STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n       EXPR_STMT_STMT_EXPR_RESULT (in EXPR_STMT)\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n+      TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       DECL_INITIALIZED_P (in VAR_DECL)\n+      TYPENAME_IS_CLASS_P (in TYPENAME_TYPE)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -2254,6 +2256,15 @@ struct lang_decl GTY(())\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n #define TYPENAME_TYPE_FULLNAME(NODE) (TYPENAME_TYPE_CHECK (NODE))->type.values\n \n+/* True if a TYPENAME_TYPE was declared as an \"enum\".  */\n+#define TYPENAME_IS_ENUM_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (TYPENAME_TYPE_CHECK (NODE)))\n+\n+/* True if a TYPENAME_TYPE was declared as a \"class\", \"struct\", or\n+   \"union\".  */\n+#define TYPENAME_IS_CLASS_P(NODE) \\\n+  (TREE_LANG_FLAG_1 (TYPENAME_TYPE_CHECK (NODE)))\n+\n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) TREE_LANG_FLAG_0 (INTEGER_CST_CHECK (NODE))\n@@ -3718,7 +3729,7 @@ extern tree declare_local_label                 (tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n-extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree make_typename_type\t\t\t(tree, tree, enum tag_types, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tree, tsubst_flags_t);\n extern tree check_for_out_of_scope_variable     (tree);\n extern tree build_library_fn\t\t\t(tree, tree);"}, {"sha": "92f294f0884dfd060593802a677fee3546a42221", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 62, "deletions": 45, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -121,7 +121,6 @@ static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n static tree next_initializable_field (tree);\n static tree reshape_init (tree, tree *);\n-static tree build_typename_type (tree, tree, tree);\n \n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n tree error_mark_list;\n@@ -2538,83 +2537,101 @@ typename_hash (const void* k)\n   return hash;\n }\n \n+typedef struct typename_info {\n+  tree scope;\n+  tree name;\n+  tree template_id;\n+  bool enum_p;\n+  bool class_p;\n+} typename_info;\n+\n /* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */\n \n static int\n typename_compare (const void * k1, const void * k2)\n {\n   tree t1;\n-  tree t2;\n-  tree d1;\n-  tree d2;\n+  const typename_info *t2;\n \n   t1 = (tree) k1;\n-  t2 = (tree) k2;\n-  d1 = TYPE_NAME (t1);\n-  d2 = TYPE_NAME (t2);\n+  t2 = (const typename_info *) k2;\n \n-  return (DECL_NAME (d1) == DECL_NAME (d2)\n-\t  && TYPE_CONTEXT (t1) == TYPE_CONTEXT (t2)\n-\t  && ((TREE_TYPE (t1) != NULL_TREE)\n-\t      == (TREE_TYPE (t2) != NULL_TREE))\n-\t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  && TYPENAME_TYPE_FULLNAME (t1) == TYPENAME_TYPE_FULLNAME (t2));\n+  return (DECL_NAME (TYPE_NAME (t1)) == t2->name\n+\t  && TYPE_CONTEXT (t1) == t2->scope\n+\t  && TYPENAME_TYPE_FULLNAME (t1) == t2->template_id\n+\t  && TYPENAME_IS_ENUM_P (t1) == t2->enum_p\n+\t  && TYPENAME_IS_CLASS_P (t1) == t2->class_p);\n }\n \n /* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is\n-   the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE\n-   is non-NULL, this type is being created by the implicit typename\n-   extension, and BASE_TYPE is a type named `t' in some base class of\n-   `T' which depends on template parameters.\n-\n+   the type of `T', NAME is the IDENTIFIER_NODE for `t'.\n+ \n    Returns the new TYPENAME_TYPE.  */\n \n static GTY ((param_is (union tree_node))) htab_t typename_htab;\n \n static tree\n-build_typename_type (tree context, tree name, tree fullname)\n+build_typename_type (tree context, tree name, tree fullname,\n+\t\t     enum tag_types tag_type)\n {\n   tree t;\n   tree d;\n+  typename_info ti;\n   void **e;\n+  hashval_t hash;\n \n   if (typename_htab == NULL)\n-    {\n-      typename_htab = htab_create_ggc (61, &typename_hash,\n-\t\t\t\t       &typename_compare, NULL);\n-    }\n-\n-  /* Build the TYPENAME_TYPE.  */\n-  t = make_aggr_type (TYPENAME_TYPE);\n-  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n-  TYPENAME_TYPE_FULLNAME (t) = fullname;\n-\n-  /* Build the corresponding TYPE_DECL.  */\n-  d = build_decl (TYPE_DECL, name, t);\n-  TYPE_NAME (TREE_TYPE (d)) = d;\n-  TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n-  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n-  DECL_ARTIFICIAL (d) = 1;\n+    typename_htab = htab_create_ggc (61, &typename_hash,\n+\t\t\t\t     &typename_compare, NULL);\n+\n+  ti.scope = FROB_CONTEXT (context); \n+  ti.name = name;\n+  ti.template_id = fullname;\n+  ti.enum_p = tag_type == enum_type;\n+  ti.class_p = (tag_type == class_type\n+\t\t|| tag_type == record_type\n+\t\t|| tag_type == union_type);\n+  hash =  (htab_hash_pointer (ti.scope)\n+\t   ^ htab_hash_pointer (ti.name));\n \n   /* See if we already have this type.  */\n-  e = htab_find_slot (typename_htab, t, INSERT);\n+  e = htab_find_slot_with_hash (typename_htab, &ti, hash, INSERT);\n   if (*e)\n     t = (tree) *e;\n   else\n-    *e = t;\n+    {\n+      /* Build the TYPENAME_TYPE.  */\n+      t = make_aggr_type (TYPENAME_TYPE);\n+      TYPE_CONTEXT (t) = ti.scope;\n+      TYPENAME_TYPE_FULLNAME (t) = ti.template_id;\n+      TYPENAME_IS_ENUM_P (t) = ti.enum_p;\n+      TYPENAME_IS_CLASS_P (t) = ti.class_p;\n+      \n+      /* Build the corresponding TYPE_DECL.  */\n+      d = build_decl (TYPE_DECL, name, t);\n+      TYPE_NAME (TREE_TYPE (d)) = d;\n+      TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n+      DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+      DECL_ARTIFICIAL (d) = 1;\n \n+      /* Store it in the hash table.  */\n+      *e = t;\n+    }\n+      \n   return t;\n }\n \n-/* Resolve `typename CONTEXT::NAME'.  Returns an appropriate type,\n-   unless an error occurs, in which case error_mark_node is returned.\n-   If we locate a non-artificial TYPE_DECL and TF_KEEP_TYPE_DECL is\n-   set, we return that, rather than the _TYPE it corresponds to, in\n-   other cases we look through the type decl.  If TF_ERROR is set,\n-   complain about errors, otherwise be quiet.  */\n+/* Resolve `typename CONTEXT::NAME'.  TAG_TYPE indicates the tag\n+   provided to name the type.  Returns an appropriate type, unless an\n+   error occurs, in which case error_mark_node is returned.  If we\n+   locate a non-artificial TYPE_DECL and TF_KEEP_TYPE_DECL is set, we\n+   return that, rather than the _TYPE it corresponds to, in other\n+   cases we look through the type decl.  If TF_ERROR is set, complain\n+   about errors, otherwise be quiet.  */\n \n tree\n-make_typename_type (tree context, tree name, tsubst_flags_t complain)\n+make_typename_type (tree context, tree name, enum tag_types tag_type,\n+\t\t    tsubst_flags_t complain)\n {\n   tree fullname;\n \n@@ -2728,7 +2745,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n-  return build_typename_type (context, name, fullname);\n+  return build_typename_type (context, name, fullname, tag_type);\n }\n \n /* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name"}, {"sha": "ffdade0251abb997d16aee817c70cac6f602c7f6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -348,7 +348,10 @@ dump_type (tree t, int flags)\n     }\n     case TYPENAME_TYPE:\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      pp_cxx_identifier (cxx_pp, \"typename\");\n+      pp_cxx_identifier (cxx_pp, \n+\t\t\t TYPENAME_IS_ENUM_P (t) ? \"enum\" \n+\t\t\t : TYPENAME_IS_CLASS_P (t) ? \"class\"\n+\t\t\t : \"typename\");\n       dump_typename (t, flags);\n       break;\n "}, {"sha": "8203dbb3b6f66eab27aae95098e00f37730ea1c6", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -300,7 +300,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t\t\t\t\t\t tf_error);\n \t      else\n \t\tfriend_type\n-\t\t  = make_typename_type (ctype, name, tf_error);\n+\t\t  = make_typename_type (ctype, name, class_type, tf_error);\n \t    }\n \t  else\n \t    {"}, {"sha": "ebcf852c20c8f0e12ba735e3510f5b58757a0519", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 108, "deletions": 76, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -1514,7 +1514,7 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n-  (cp_parser *, bool, bool, bool, bool, bool, bool);\n+  (cp_parser *, bool, bool, enum tag_types, bool, bool, bool);\n static tree cp_parser_class_specifier\n   (cp_parser *);\n static tree cp_parser_class_head\n@@ -1623,7 +1623,7 @@ static void cp_parser_label_declaration\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, bool, bool, bool, bool, bool *);\n+  (cp_parser *, tree, enum tag_types, bool, bool, bool, bool *);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n@@ -1713,7 +1713,7 @@ static bool cp_parser_simulate_error\n static void cp_parser_check_type_definition\n   (cp_parser *);\n static void cp_parser_check_for_definition_in_return_type\n-  (cp_declarator *, int);\n+  (cp_declarator *, tree);\n static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree);\n static bool cp_parser_non_integral_constant_expression\n@@ -1861,14 +1861,14 @@ cp_parser_check_type_definition (cp_parser* parser)\n     error (\"%s\", parser->type_definition_forbidden_message);\n }\n \n-/* This function is called when a declaration is parsed.  If\n-   DECLARATOR is a function declarator and DECLARES_CLASS_OR_ENUM\n-   indicates that a type was defined in the decl-specifiers for DECL,\n-   then an error is issued.  */\n+/* This function is called when the DECLARATOR is processed.  The TYPE\n+   was a type definied in the decl-specifiers.  If it is invalid to\n+   define a type in the decl-specifiers for DECLARATOR, an error is\n+   issued.  */\n \n static void\n cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n-\t\t\t\t\t       int declares_class_or_enum)\n+\t\t\t\t\t       tree type)\n {\n   /* [dcl.fct] forbids type definitions in return types.\n      Unfortunately, it's not easy to know whether or not we are\n@@ -1879,9 +1879,12 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n \t     || declarator->kind == cdk_ptrmem))\n     declarator = declarator->declarator;\n   if (declarator\n-      && declarator->kind == cdk_function\n-      && declares_class_or_enum & 2)\n-    error (\"new types may not be defined in a return type\");\n+      && declarator->kind == cdk_function)\n+    {\n+      error (\"new types may not be defined in a return type\");\n+      inform (\"(perhaps a semicolon is missing after the definition of %qT)\",\n+\t      type);\n+    }\n }\n \n /* A type-specifier (TYPE) has been parsed which cannot be followed by\n@@ -2295,12 +2298,13 @@ cp_parser_make_typename_type (cp_parser *parser, tree scope, tree id)\n   tree result;\n   if (TREE_CODE (id) == IDENTIFIER_NODE)\n     {\n-      result = make_typename_type (scope, id, /*complain=*/0);\n+      result = make_typename_type (scope, id, typename_type,\n+\t\t\t\t   /*complain=*/0);\n       if (result == error_mark_node)\n \tcp_parser_diagnose_invalid_type_name (parser, scope, id);\n       return result;\n     }\n-  return make_typename_type (scope, id, tf_error);\n+  return make_typename_type (scope, id, typename_type, tf_error);\n }\n \n \n@@ -2831,7 +2835,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    bool ambiguous_p;\n \n \t    decl = cp_parser_lookup_name (parser, id_expression,\n-\t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  none_type,\n \t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n@@ -3164,7 +3168,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    type_decl = cp_parser_class_name (parser,\n \t\t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t\t      /*type_p=*/false,\n+\t\t\t\t\t      none_type,\n \t\t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t\t      declarator_p);\n@@ -3182,7 +3186,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t      = cp_parser_class_name (parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t      /*type_p=*/false,\n+\t\t\t\t      none_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n@@ -3200,7 +3204,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t      = cp_parser_class_name (parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t      /*type_p=*/false,\n+\t\t\t\t      none_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n@@ -3215,7 +3219,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t  = cp_parser_class_name (parser,\n \t\t\t\t  /*typename_keyword_p=*/false,\n \t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  /*type_p=*/false,\n+\t\t\t\t  none_type,\n \t\t\t\t  /*check_dependency=*/false,\n \t\t\t\t  /*class_head_p=*/false,\n \t\t\t\t  declarator_p);\n@@ -3579,7 +3583,7 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   scope = cp_parser_class_name (parser,\n \t\t\t\ttypename_keyword_p,\n \t\t\t\ttemplate_keyword_p,\n-\t\t\t\ttype_p,\n+\t\t\t\ttype_p ? class_type : none_type,\n \t\t\t\tcheck_dependency_p,\n \t\t\t\t/*class_head_p=*/false,\n \t\t\t\tis_declaration);\n@@ -3815,6 +3819,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t   functional cast is being performed.  */\n \telse\n \t  type = make_typename_type (parser->scope, id,\n+\t\t\t\t     typename_type,\n \t\t\t\t     /*complain=*/1);\n \n \tpostfix_expression = cp_parser_functional_cast (parser, type);\n@@ -4275,18 +4280,28 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       if (parser->scope)\n \t*idk = CP_ID_KIND_QUALIFIED;\n \n-      if (name != error_mark_node && !BASELINK_P (name) && parser->scope)\n+      /* If the name is a template-id that names a type, we will get a\n+\t TYPE_DECL here.  That is invalid code.  */\n+      if (TREE_CODE (name) == TYPE_DECL)\n \t{\n-\t  name = build_nt (SCOPE_REF, parser->scope, name);\n-\t  parser->scope = NULL_TREE;\n-\t  parser->qualifying_scope = NULL_TREE;\n-\t  parser->object_scope = NULL_TREE;\n+\t  error (\"invalid use of %qD\", name);\n+\t  postfix_expression = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  if (name != error_mark_node && !BASELINK_P (name) && parser->scope)\n+\t    {\n+\t      name = build_nt (SCOPE_REF, parser->scope, name);\n+\t      parser->scope = NULL_TREE;\n+\t      parser->qualifying_scope = NULL_TREE;\n+\t      parser->object_scope = NULL_TREE;\n+\t    }\n+\t  if (scope && name && BASELINK_P (name))\n+\t    adjust_result_of_qualified_name_lookup\n+\t      (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n+\t  postfix_expression\n+\t    = finish_class_member_access_expr (postfix_expression, name);\n \t}\n-      if (scope && name && BASELINK_P (name))\n-\tadjust_result_of_qualified_name_lookup\n-\t  (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n-      postfix_expression\n-\t= finish_class_member_access_expr (postfix_expression, name);\n     }\n \n   /* We no longer need to look up names in the scope of the object on\n@@ -7659,7 +7674,7 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n     return cp_parser_class_name (parser,\n \t\t\t\t /*typename_keyword_p=*/true,\n \t\t\t\t /*template_keyword_p=*/template_p,\n-\t\t\t\t /*type_p=*/false,\n+\t\t\t\t none_type,\n \t\t\t\t /*check_dependency_p=*/true,\n \t\t\t\t /*class_head_p=*/false,\n \t\t\t\t /*is_declaration=*/true);\n@@ -7669,7 +7684,7 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   id = cp_parser_class_name (parser,\n \t\t\t     /*typename_keyword_p=*/true,\n \t\t\t     /*template_keyword_p=*/false,\n-\t\t\t     /*type_p=*/false,\n+\t\t\t     none_type,\n \t\t\t     /*check_dependency_p=*/true,\n \t\t\t     /*class_head_p=*/false,\n \t\t\t     /*is_declaration=*/true);\n@@ -8223,11 +8238,11 @@ cp_parser_type_parameter (cp_parser* parser)\n \t      /* Look up the name.  */\n \t      default_argument\n \t\t= cp_parser_lookup_name (parser, default_argument,\n-\t\t\t\t\t/*is_type=*/false,\n-\t\t\t\t\t/*is_template=*/is_template,\n-\t\t\t\t\t/*is_namespace=*/false,\n-\t\t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t\t/*ambiguous_p=*/NULL);\n+\t\t\t\t\t none_type,\n+\t\t\t\t\t /*is_template=*/is_template,\n+\t\t\t\t\t /*is_namespace=*/false,\n+\t\t\t\t\t /*check_dependency=*/true,\n+\t\t\t\t\t /*ambiguous_p=*/NULL);\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n@@ -8578,7 +8593,7 @@ cp_parser_template_name (cp_parser* parser,\n \n   /* Look up the name.  */\n   decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t/*is_type=*/false,\n+\t\t\t\tnone_type,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p,\n@@ -8769,7 +8784,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t at this point in that case.  */\n       if (TREE_CODE (argument) != TYPE_DECL)\n \targument = cp_parser_lookup_name (parser, argument,\n-\t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  none_type,\n \t\t\t\t\t  /*is_template=*/template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n@@ -8971,8 +8986,9 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t/*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t/*parenthesized_p=*/NULL,\n \t\t\t\t/*member_p=*/false);\n-      cp_parser_check_for_definition_in_return_type (declarator,\n-\t\t\t\t\t\t     declares_class_or_enum);\n+      if (declares_class_or_enum & 2)\n+\tcp_parser_check_for_definition_in_return_type (declarator,\n+\t\t\t\t\t\t       decl_specifiers.type);\n       if (declarator != cp_error_declarator)\n \t{\n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n@@ -9460,7 +9476,7 @@ cp_parser_type_name (cp_parser* parser)\n   type_decl = cp_parser_class_name (parser,\n \t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t    /*template_keyword_p=*/false,\n-\t\t\t\t    /*type_p=*/false,\n+\t\t\t\t    none_type,\n \t\t\t\t    /*check_dependency_p=*/true,\n \t\t\t\t    /*class_head_p=*/false,\n \t\t\t\t    /*is_declaration=*/false);\n@@ -9612,6 +9628,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n \t       && tag_type == typename_type)\n \ttype = make_typename_type (parser->scope, decl,\n+\t\t\t\t   typename_type,\n \t\t\t\t   /*complain=*/1);\n       else\n \ttype = TREE_TYPE (decl);\n@@ -9641,7 +9658,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t     types, so we set IS_TYPE to TRUE when calling\n \t     cp_parser_lookup_name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t\t/*is_type=*/true,\n+\t\t\t\t\ttag_type,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true,\n@@ -9929,7 +9946,7 @@ cp_parser_namespace_name (cp_parser* parser)\n      function if the token after the name is the scope resolution\n      operator.)  */\n   namespace_decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  none_type,\n \t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n \t\t\t\t\t  /*check_dependency=*/true,\n@@ -10416,8 +10433,9 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (declarator == cp_error_declarator)\n     return error_mark_node;\n \n-  cp_parser_check_for_definition_in_return_type (declarator,\n-\t\t\t\t\t\t declares_class_or_enum);\n+  if (declares_class_or_enum & 2)\n+    cp_parser_check_for_definition_in_return_type (declarator,\n+\t\t\t\t\t\t   decl_specifiers->type);\n \n   /* Figure out what scope the entity declared by the DECLARATOR is\n      located in.  `grokdeclarator' sometimes changes the scope, so\n@@ -12100,19 +12118,18 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n    to indicate that names looked up in dependent types should be\n    assumed to be types.  TEMPLATE_KEYWORD_P is true iff the `template'\n    keyword has been used to indicate that the name that appears next\n-   is a template.  TYPE_P is true iff the next name should be treated\n-   as class-name, even if it is declared to be some other kind of name\n-   as well.  If CHECK_DEPENDENCY_P is FALSE, names are looked up in\n-   dependent scopes.  If CLASS_HEAD_P is TRUE, this class is the class\n-   being defined in a class-head.\n+   is a template.  TAG_TYPE indicates the explicit tag given before\n+   the type name, if any.  If CHECK_DEPENDENCY_P is FALSE, names are\n+   looked up in dependent scopes.  If CLASS_HEAD_P is TRUE, this class\n+   is the class being defined in a class-head.\n \n    Returns the TYPE_DECL representing the class.  */\n \n static tree\n cp_parser_class_name (cp_parser *parser,\n \t\t      bool typename_keyword_p,\n \t\t      bool template_keyword_p,\n-\t\t      bool type_p,\n+\t\t      enum tag_types tag_type,\n \t\t      bool check_dependency_p,\n \t\t      bool class_head_p,\n \t\t      bool is_declaration)\n@@ -12168,10 +12185,10 @@ cp_parser_class_name (cp_parser *parser,\n \t     resolution operator, object, function, and enumerator\n \t     names are ignored.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n-\t    type_p = true;\n+\t    tag_type = typename_type;\n \t  /* Look up the name.  */\n \t  decl = cp_parser_lookup_name (parser, identifier,\n-\t\t\t\t\ttype_p,\n+\t\t\t\t\ttag_type,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p,\n@@ -12193,7 +12210,7 @@ cp_parser_class_name (cp_parser *parser,\n   /* If this is a typename, create a TYPENAME_TYPE.  */\n   if (typename_p && decl != error_mark_node)\n     {\n-      decl = make_typename_type (scope, decl, /*complain=*/1);\n+      decl = make_typename_type (scope, decl, typename_type, /*complain=*/1);\n       if (decl != error_mark_node)\n \tdecl = TYPE_NAME (decl);\n     }\n@@ -12212,7 +12229,7 @@ cp_parser_class_name (cp_parser *parser,\n        standard does not seem to be definitive, but there is no other\n        valid interpretation of the following `::'.  Therefore, those\n        names are considered class-names.  */\n-    decl = TYPE_NAME (make_typename_type (scope, decl, tf_error));\n+    decl = TYPE_NAME (make_typename_type (scope, decl, tag_type, tf_error));\n   else if (decl == error_mark_node\n \t   || TREE_CODE (decl) != TYPE_DECL\n \t   || !IS_AGGR_TYPE (TREE_TYPE (decl)))\n@@ -12500,7 +12517,7 @@ cp_parser_class_head (cp_parser* parser,\n       type = cp_parser_class_name (parser,\n \t\t\t\t   /*typename_keyword_p=*/false,\n \t\t\t\t   /*template_keyword_p=*/false,\n-\t\t\t\t   /*type_p=*/true,\n+\t\t\t\t   class_type,\n \t\t\t\t   /*check_dependency_p=*/false,\n \t\t\t\t   /*class_head_p=*/true,\n \t\t\t\t   /*is_declaration=*/false);\n@@ -13058,8 +13075,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  return;\n \t\t}\n \n-\t      cp_parser_check_for_definition_in_return_type\n-\t\t(declarator, declares_class_or_enum);\n+\t      if (declares_class_or_enum & 2)\n+\t\tcp_parser_check_for_definition_in_return_type\n+\t\t  (declarator, decl_specifiers.type);\n \n \t      /* Look for an asm-specification.  */\n \t      asm_specification = cp_parser_asm_specification_opt (parser);\n@@ -13414,7 +13432,7 @@ cp_parser_base_specifier (cp_parser* parser)\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/true,\n \t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/true,\n+\t\t\t\t       typename_type,\n \t\t\t\t       /*is_declaration=*/true);\n   /* If the base class is given by a qualified name, assume that names\n      we see are type names or templates, as appropriate.  */\n@@ -13425,7 +13443,7 @@ cp_parser_base_specifier (cp_parser* parser)\n   type = cp_parser_class_name (parser,\n \t\t\t       class_scope_p,\n \t\t\t       template_p,\n-\t\t\t       /*type_p=*/true,\n+\t\t\t       typename_type,\n \t\t\t       /*check_dependency_p=*/true,\n \t\t\t       /*class_head_p=*/false,\n \t\t\t       /*is_declaration=*/true);\n@@ -14049,8 +14067,9 @@ cp_parser_label_declaration (cp_parser* parser)\n    If there was no entity with the indicated NAME, the ERROR_MARK_NODE\n    is returned.\n \n-   If IS_TYPE is TRUE, bindings that do not refer to types are\n-   ignored.\n+   If TAG_TYPE is not NONE_TYPE, it inidcates an explicit type keyword\n+   (e.g., \"struct\") that was used.  In that case bindings that do not\n+   refer to types are ignored.\n \n    If IS_TEMPLATE is TRUE, bindings that do not refer to templates are\n    ignored.\n@@ -14066,7 +14085,8 @@ cp_parser_label_declaration (cp_parser* parser)\n \n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name,\n-\t\t       bool is_type, bool is_template, bool is_namespace,\n+\t\t       enum tag_types tag_type,\n+\t\t       bool is_template, bool is_namespace,\n \t\t       bool check_dependency,\n \t\t       bool *ambiguous_p)\n {\n@@ -14144,13 +14164,21 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       if ((check_dependency || !CLASS_TYPE_P (parser->scope))\n \t   && dependent_p)\n \t{\n-\t  if (is_type)\n-\t    /* The resolution to Core Issue 180 says that `struct A::B'\n-\t       should be considered a type-name, even if `A' is\n-\t       dependent.  */\n-\t    decl = TYPE_NAME (make_typename_type (parser->scope,\n-\t\t\t\t\t\t  name,\n-\t\t\t\t\t\t  /*complain=*/1));\n+\t  if (tag_type)\n+\t    {\n+\t      tree type;\n+\n+\t      /* The resolution to Core Issue 180 says that `struct\n+\t\t A::B' should be considered a type-name, even if `A'\n+\t\t is dependent.  */\n+\t      type = make_typename_type (parser->scope, name, tag_type,\n+\t\t\t\t\t /*complain=*/1);\n+\t      if (tag_type == enum_type)\n+\t\tTYPENAME_IS_ENUM_P (type) = 1;\n+\t      else if (tag_type != typename_type)\n+\t\tTYPENAME_IS_CLASS_P (type) = 1;\n+\t      decl = TYPE_NAME (type);\n+\t    }\n \t  else if (is_template)\n \t    decl = make_unbound_class_template (parser->scope,\n \t\t\t\t\t\tname, NULL_TREE,\n@@ -14173,7 +14201,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n-\t  decl = lookup_qualified_name (parser->scope, name, is_type,\n+\t  decl = lookup_qualified_name (parser->scope, name, \n+\t\t\t\t\ttag_type != none_type, \n \t\t\t\t\t/*complain=*/true);\n \t  if (pop_p)\n \t    pop_scope (parser->scope);\n@@ -14193,9 +14222,11 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t   parse, those errors are valid.  */\n \tobject_decl = lookup_member (object_type,\n \t\t\t\t     name,\n-\t\t\t\t     /*protect=*/0, is_type);\n+\t\t\t\t     /*protect=*/0, \n+\t\t\t\t     tag_type != none_type);\n       /* Look it up in the enclosing context, too.  */\n-      decl = lookup_name_real (name, is_type, /*nonclass=*/0,\n+      decl = lookup_name_real (name, tag_type != none_type, \n+\t\t\t       /*nonclass=*/0,\n \t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->object_scope = object_type;\n@@ -14205,7 +14236,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     }\n   else\n     {\n-      decl = lookup_name_real (name, is_type, /*nonclass=*/0,\n+      decl = lookup_name_real (name, tag_type != none_type, \n+\t\t\t       /*nonclass=*/0,\n \t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->qualifying_scope = NULL_TREE;\n@@ -14261,7 +14293,7 @@ static tree\n cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n {\n   return cp_parser_lookup_name (parser, name,\n-\t\t\t\t/*is_type=*/false,\n+\t\t\t\tnone_type,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true,\n@@ -14519,7 +14551,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n       type_decl = cp_parser_class_name (parser,\n \t\t\t\t\t/*typename_keyword_p=*/false,\n \t\t\t\t\t/*template_keyword_p=*/false,\n-\t\t\t\t\t/*type_p=*/false,\n+\t\t\t\t\tnone_type,\n \t\t\t\t\t/*check_dependency_p=*/false,\n \t\t\t\t\t/*class_head_p=*/false,\n \t\t\t\t\t/*is_declaration=*/false);"}, {"sha": "34e86c8e09a32e7424479c3e78275443f5c75907", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -140,7 +140,6 @@ static tree most_specialized (tree, tree, tree);\n static tree most_specialized_class (tree, tree);\n static int template_class_depth_real (tree, int);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n-static tree tsubst_decl (tree, tree, tree, tsubst_flags_t);\n static tree tsubst_arg_types (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n static void check_specialization_scope (void);\n@@ -3833,6 +3832,7 @@ convert_template_argument (tree parm,\n       \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n+\t\t\t\ttypename_type,\n \t\t\t\tcomplain & tf_error);\n       is_type = 1;\n     }\n@@ -6140,13 +6140,12 @@ tsubst_default_arguments (tree fn)\n \t\t\t\t\t\t    TREE_PURPOSE (arg));\n }\n \n-/* Substitute the ARGS into the T, which is a _DECL.  TYPE is the\n-   (already computed) substitution of ARGS into TREE_TYPE (T), if\n-   appropriate.  Return the result of the substitution.  Issue error\n-   and warning messages under control of COMPLAIN.  */\n+/* Substitute the ARGS into the T, which is a _DECL.  Return the\n+   result of the substitution.  Issue error and warning messages under\n+   control of COMPLAIN.  */\n \n static tree\n-tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n+tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n {\n   location_t saved_loc;\n   tree r = NULL_TREE;\n@@ -6267,6 +6266,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \ttree argvec = NULL_TREE;\n \ttree *friends;\n \ttree gen_tmpl;\n+\ttree type;\n \tint member;\n \tint args_depth;\n \tint parms_depth;\n@@ -6376,7 +6376,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t    member = 0;\n \t    ctx = DECL_CONTEXT (t);\n \t  }\n-\ttype = tsubst (type, args, complain, in_decl);\n+\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tif (type == error_mark_node)\n \t  return error_mark_node;\n \n@@ -6485,10 +6485,13 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \n     case PARM_DECL:\n       {\n+\ttree type;\n+\n \tr = copy_node (t);\n \tif (DECL_TEMPLATE_PARM_P (t))\n \t  SET_DECL_TEMPLATE_PARM_P (r);\n \n+\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n@@ -6513,7 +6516,12 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \n     case FIELD_DECL:\n       {\n+\ttree type;\n+\n \tr = copy_decl (t);\n+\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\tif (type == error_mark_node)\n+\t  return error_mark_node;\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n@@ -6541,28 +6549,32 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n       break;\n \n     case TYPE_DECL:\n-      if (TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n-\t  || t == TYPE_MAIN_DECL (TREE_TYPE (t)))\n-\t{\n-\t  /* If this is the canonical decl, we don't have to mess with\n-             instantiations, and often we can't (for typename, template\n-\t     type parms and such).  Note that TYPE_NAME is not correct for\n-\t     the above test if we've copied the type for a typedef.  */\n-\t  r = TYPE_NAME (type);\n-\t  break;\n-\t}\n-\n-      /* Fall through.  */\n-\n     case VAR_DECL:\n       {\n \ttree argvec = NULL_TREE;\n \ttree gen_tmpl = NULL_TREE;\n \ttree spec;\n \ttree tmpl = NULL_TREE;\n \ttree ctx;\n+\ttree type = NULL_TREE;\n \tint local_p;\n \n+\tif (TREE_CODE (t) == TYPE_DECL)\n+\t  {\n+\t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t    if (TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n+\t\t|| t == TYPE_MAIN_DECL (TREE_TYPE (t)))\n+\t      {\n+\t\t/* If this is the canonical decl, we don't have to\n+\t\t   mess with instantiations, and often we can't (for\n+\t\t   typename, template type parms and such).  Note that\n+\t\t   TYPE_NAME is not correct for the above test if\n+\t\t   we've copied the type for a typedef.  */\n+\t\tr = TYPE_NAME (type);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t\n \t/* Assume this is a non-local variable.  */\n \tlocal_p = 0;\n \n@@ -6600,6 +6612,9 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \tr = copy_decl (t);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n+\t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t    if (type == error_mark_node)\n+\t      return error_mark_node;\n \t    type = complete_type (type);\n \t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (r)\n \t      = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (t);\n@@ -6885,26 +6900,25 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       || TREE_CODE (t) == NAMESPACE_DECL)\n     return t;\n \n+  if (DECL_P (t))\n+    return tsubst_decl (t, args, complain);\n+\n   if (TREE_CODE (t) == IDENTIFIER_NODE)\n     type = IDENTIFIER_TYPE_VALUE (t);\n   else\n     type = TREE_TYPE (t);\n \n   gcc_assert (type != unknown_type_node);\n \n-  if (type && TREE_CODE (t) != FUNCTION_DECL\n+  if (type\n       && TREE_CODE (t) != TYPENAME_TYPE\n-      && TREE_CODE (t) != TEMPLATE_DECL\n       && TREE_CODE (t) != IDENTIFIER_NODE\n       && TREE_CODE (t) != FUNCTION_TYPE\n       && TREE_CODE (t) != METHOD_TYPE)\n     type = tsubst (type, args, complain, in_decl);\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (DECL_P (t))\n-    return tsubst_decl (t, args, type, complain);\n-\n   switch (TREE_CODE (t))\n     {\n     case RECORD_TYPE:\n@@ -7364,7 +7378,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      }\n \t  }\n \n-\tf = make_typename_type (ctx, f,\n+\tf = make_typename_type (ctx, f, typename_type,\n \t\t\t\t(complain & tf_error) | tf_keep_type_decl);\n \tif (f == error_mark_node)\n \t  return f;\n@@ -7374,6 +7388,16 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n  \t    f = TREE_TYPE (f);\n  \t  }\n  \t\n+\tif (TREE_CODE (f) != TYPENAME_TYPE)\n+\t  {\n+\t    if (TYPENAME_IS_ENUM_P (t) && TREE_CODE (f) != ENUMERAL_TYPE)\n+\t      error (\"%qT resolves to %qT, which is not an enumeration type\", \n+\t\t     t, f);\n+\t    else if (TYPENAME_IS_CLASS_P (t) && !CLASS_TYPE_P (f))\n+\t      error (\"%qT resolves to %qT, which is is not a class type\", \n+\t\t     t, f);\n+\t  }\n+\n  \treturn cp_build_qualified_type_real\n  \t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n       }"}, {"sha": "7a806bb3765a92c19a8d8bf857ebc71c0cd76789", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -1,3 +1,16 @@\n+2004-11-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18674\n+\t* g++.old-deja/g++.brendan/crash16.C: Adjust error messages.\n+\t* g++.old-deja/g++.law/ctors5.C: Likewise.\n+\t* g++.old-deja/g++.other/crash25.C: Likewise.\n+\n+\tPR c++/18674\n+\t* g++.dg/template/error16.C: New test.\n+\t\n+\tPR c++/18512\n+\t* g++.dg/template/crash29.C: New test.\n+\n 2004-11-29  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/18712"}, {"sha": "55953ed80100d559c5ff6f870f71313dc8e548cd", "filename": "gcc/testsuite/g++.dg/template/crash29.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash29.C?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/18512\n+\n+template <int> struct A {};\n+\n+struct B : A<0>\n+{\n+  void foo() { this->A<0>; } // { dg-error \"\" }\n+};"}, {"sha": "0da024bc665228cdb7dd46c5d1f8c1689158b334", "filename": "gcc/testsuite/g++.dg/template/error16.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror16.C?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/18674\n+\n+template <typename I>\n+static void g() {\n+  enum I::t a; // { dg-error \"\" }\n+  (void) a;\n+}\n+\n+struct B {\n+  typedef int t;\n+};\n+\n+void h()\n+{\n+  g<B>();\n+}"}, {"sha": "8fec8d1132fa7d78272104da91a0cfaa83bd8909", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash16.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash16.C?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -6,7 +6,7 @@ public:\n       Graph(void) {}; // { dg-error \"previously defined here\" }\n }\n \n-Graph::Graph(void)    // { dg-error \"return type|redefinition\" }\n+Graph::Graph(void)    // { dg-error \"return type|redefinition|semicolon\" }\n {    N = 10;\n }\n "}, {"sha": "334b59781b1f59afced35d344c24bdccd242206c", "filename": "gcc/testsuite/g++.old-deja/g++.law/ctors5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fctors5.C?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -20,7 +20,7 @@ class Y\n   public:\n     Y();\n }\n-X::X( int xi ) // { dg-error \"return type|X::X\" }\n+X::X( int xi ) // { dg-error \"return type|X::X|semicolon\" }\n {\n     x = xi;\n }"}, {"sha": "b8417e8512e8d9e754e7bc4fd561805bcfc86089", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash25.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6a28d7633ddd7c734b759f4d60233b70bf1770/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C?ref=fc6a28d7633ddd7c734b759f4d60233b70bf1770", "patch": "@@ -7,7 +7,7 @@ public:\n   virtual ~X();\n }\n \n-X::x()\t// { dg-error \"return type|member function\" }\n+X::x()\t// { dg-error \"return type|member function|semicolon\" }\n {\n }\n "}]}