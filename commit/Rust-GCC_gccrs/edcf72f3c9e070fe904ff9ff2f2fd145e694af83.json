{"sha": "edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRjZjcyZjNjOWUwNzBmZTkwNGZmOWZmMmYyZmQxNDVlNjk0YWY4Mw==", "commit": {"author": {"name": "Ilya Enkovich", "email": "ilya.enkovich@intel.com", "date": "2014-11-17T13:45:55Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2014-11-17T13:45:55Z"}, "message": "tree-core.h (built_in_class): Add builtin codes to be used by Pointer Bounds Checker for instrumented builtin...\n\n\t* tree-core.h (built_in_class): Add builtin codes to be used\n\tby Pointer Bounds Checker for instrumented builtin functions.\n\t* tree-streamer-in.c: Include ipa-chkp.h.\n\t(streamer_get_builtin_tree): Created instrumented decl if\n\trequired.\n\t* ipa-chkp.h (chkp_maybe_clone_builtin_fndecl): New.\n\t* ipa-chkp.c (chkp_build_instrumented_fndecl): Support builtin\n\tfunction decls.\n\t(chkp_maybe_clone_builtin_fndecl): New.\n\t(chkp_maybe_create_clone): Support builtin function decls.\n\t(chkp_versioning): Clone builtin functions.\n\t* tree-chkp.c (chkp_instrument_normal_builtin): New.\n\t(chkp_add_bounds_to_call_stmt): Support builtin functions.\n\t(chkp_replace_function_pointer): Likewise.\n\t* builtins.c (expand_builtin_memcpy_args): New.\n\t(expand_builtin_memcpy): Call expand_builtin_memcpy_args.\n\t(expand_builtin_memcpy_with_bounds): New.\n\t(expand_builtin_mempcpy_with_bounds): New.\n\t(expand_builtin_mempcpy_args): Add orig_exp arg. Support\n\tBUILT_IN_CHKP_MEMCPY_NOBND_NOCHK\n\t(expand_builtin_memset_with_bounds): New.\n\t(expand_builtin_memset_args): Support BUILT_IN_CHKP_MEMSET_NOBND_NOCHK.\n\t(expand_builtin_with_bounds): New.\n\t* builtins.h (expand_builtin_with_bounds): New.\n\t* expr.c (expand_expr_real_1): Support instrumented builtin calls.\n\nFrom-SVN: r217655", "tree": {"sha": "bc2f2a46968faabdbe890355b0f2b9b151a106bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc2f2a46968faabdbe890355b0f2b9b151a106bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5134529b25c1fd448e6589876a84d0095a5ffc35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5134529b25c1fd448e6589876a84d0095a5ffc35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5134529b25c1fd448e6589876a84d0095a5ffc35"}], "stats": {"total": 546, "additions": 457, "deletions": 89}, "files": [{"sha": "123166c95629c6ce32bfe9f6964bca6381aee20b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -1,3 +1,31 @@\n+2014-11-17  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\n+\t* tree-core.h (built_in_class): Add builtin codes to be used\n+\tby Pointer Bounds Checker for instrumented builtin functions.\n+\t* tree-streamer-in.c: Include ipa-chkp.h.\n+\t(streamer_get_builtin_tree): Created instrumented decl if\n+\trequired.\n+\t* ipa-chkp.h (chkp_maybe_clone_builtin_fndecl): New.\n+\t* ipa-chkp.c (chkp_build_instrumented_fndecl): Support builtin\n+\tfunction decls.\n+\t(chkp_maybe_clone_builtin_fndecl): New.\n+\t(chkp_maybe_create_clone): Support builtin function decls.\n+\t(chkp_versioning): Clone builtin functions.\n+\t* tree-chkp.c (chkp_instrument_normal_builtin): New.\n+\t(chkp_add_bounds_to_call_stmt): Support builtin functions.\n+\t(chkp_replace_function_pointer): Likewise.\n+\t* builtins.c (expand_builtin_memcpy_args): New.\n+\t(expand_builtin_memcpy): Call expand_builtin_memcpy_args.\n+\t(expand_builtin_memcpy_with_bounds): New.\n+\t(expand_builtin_mempcpy_with_bounds): New.\n+\t(expand_builtin_mempcpy_args): Add orig_exp arg. Support\n+\tBUILT_IN_CHKP_MEMCPY_NOBND_NOCHK\n+\t(expand_builtin_memset_with_bounds): New.\n+\t(expand_builtin_memset_args): Support BUILT_IN_CHKP_MEMSET_NOBND_NOCHK.\n+\t(expand_builtin_with_bounds): New.\n+\t* builtins.h (expand_builtin_with_bounds): New.\n+\t* expr.c (expand_expr_real_1): Support instrumented builtin calls.\n+\n 2014-11-17  Dodji Seketeli  <dodji@redhat.com>\n \n \t* gimple.h (gimple_set_visited, gimple_visited_p)"}, {"sha": "7ec2d5f8e8c61be692b5489825834a8ec3c0510c", "filename": "gcc/builtins.c", "status": "modified", "additions": 239, "deletions": 68, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -132,15 +132,19 @@ static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memcpy (tree, rtx);\n+static rtx expand_builtin_memcpy_with_bounds (tree, rtx);\n+static rtx expand_builtin_memcpy_args (tree, tree, tree, rtx, tree);\n static rtx expand_builtin_mempcpy (tree, rtx, machine_mode);\n+static rtx expand_builtin_mempcpy_with_bounds (tree, rtx, machine_mode);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n-\t\t\t\t\tmachine_mode, int);\n+\t\t\t\t\tmachine_mode, int, tree);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_strncpy (tree, rtx);\n static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memset (tree, rtx, machine_mode);\n+static rtx expand_builtin_memset_with_bounds (tree, rtx, machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n static rtx expand_builtin_strlen (tree, rtx, machine_mode);\n@@ -3175,6 +3179,81 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n+/* Helper function to do the actual work for expand_builtin_memcpy.  */\n+\n+static rtx\n+expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n+{\n+  const char *src_str;\n+  unsigned int src_align = get_pointer_alignment (src);\n+  unsigned int dest_align = get_pointer_alignment (dest);\n+  rtx dest_mem, src_mem, dest_addr, len_rtx;\n+  HOST_WIDE_INT expected_size = -1;\n+  unsigned int expected_align = 0;\n+  unsigned HOST_WIDE_INT min_size;\n+  unsigned HOST_WIDE_INT max_size;\n+  unsigned HOST_WIDE_INT probable_max_size;\n+\n+  /* If DEST is not a pointer type, call the normal function.  */\n+  if (dest_align == 0)\n+    return NULL_RTX;\n+\n+  /* If either SRC is not a pointer type, don't do this\n+     operation in-line.  */\n+  if (src_align == 0)\n+    return NULL_RTX;\n+\n+  if (currently_expanding_gimple_stmt)\n+    stringop_block_profile (currently_expanding_gimple_stmt,\n+\t\t\t    &expected_align, &expected_size);\n+\n+  if (expected_align < dest_align)\n+    expected_align = dest_align;\n+  dest_mem = get_memory_rtx (dest, len);\n+  set_mem_align (dest_mem, dest_align);\n+  len_rtx = expand_normal (len);\n+  determine_block_size (len, len_rtx, &min_size, &max_size,\n+\t\t\t&probable_max_size);\n+  src_str = c_getstr (src);\n+\n+  /* If SRC is a string constant and block move would be done\n+     by pieces, we can avoid loading the string from memory\n+     and only stored the computed constants.  */\n+  if (src_str\n+      && CONST_INT_P (len_rtx)\n+      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+      && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t      dest_align, false))\n+    {\n+      dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t  builtin_memcpy_read_str,\n+\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  dest_align, false, 0);\n+      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n+      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+      return dest_mem;\n+    }\n+\n+  src_mem = get_memory_rtx (src, len);\n+  set_mem_align (src_mem, src_align);\n+\n+  /* Copy word part most expediently.  */\n+  dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n+\t\t\t\t     CALL_EXPR_TAILCALL (exp)\n+\t\t\t\t     ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n+\t\t\t\t     expected_align, expected_size,\n+\t\t\t\t     min_size, max_size, probable_max_size);\n+\n+  if (dest_addr == 0)\n+    {\n+      dest_addr = force_operand (XEXP (dest_mem, 0), target);\n+      dest_addr = convert_memory_address (ptr_mode, dest_addr);\n+    }\n+\n+  return dest_addr;\n+}\n+\n /* Expand a call EXP to the memcpy builtin.\n    Return NULL_RTX if we failed, the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n@@ -3191,73 +3270,38 @@ expand_builtin_memcpy (tree exp, rtx target)\n       tree dest = CALL_EXPR_ARG (exp, 0);\n       tree src = CALL_EXPR_ARG (exp, 1);\n       tree len = CALL_EXPR_ARG (exp, 2);\n-      const char *src_str;\n-      unsigned int src_align = get_pointer_alignment (src);\n-      unsigned int dest_align = get_pointer_alignment (dest);\n-      rtx dest_mem, src_mem, dest_addr, len_rtx;\n-      HOST_WIDE_INT expected_size = -1;\n-      unsigned int expected_align = 0;\n-      unsigned HOST_WIDE_INT min_size;\n-      unsigned HOST_WIDE_INT max_size;\n-      unsigned HOST_WIDE_INT probable_max_size;\n-\n-      /* If DEST is not a pointer type, call the normal function.  */\n-      if (dest_align == 0)\n-\treturn NULL_RTX;\n-\n-      /* If either SRC is not a pointer type, don't do this\n-\t operation in-line.  */\n-      if (src_align == 0)\n-\treturn NULL_RTX;\n-\n-      if (currently_expanding_gimple_stmt)\n-        stringop_block_profile (currently_expanding_gimple_stmt,\n-\t\t\t\t&expected_align, &expected_size);\n-\n-      if (expected_align < dest_align)\n-\texpected_align = dest_align;\n-      dest_mem = get_memory_rtx (dest, len);\n-      set_mem_align (dest_mem, dest_align);\n-      len_rtx = expand_normal (len);\n-      determine_block_size (len, len_rtx, &min_size, &max_size,\n-\t\t\t    &probable_max_size);\n-      src_str = c_getstr (src);\n-\n-      /* If SRC is a string constant and block move would be done\n-\t by pieces, we can avoid loading the string from memory\n-\t and only stored the computed constants.  */\n-      if (src_str\n-\t  && CONST_INT_P (len_rtx)\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n-\t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t\t  CONST_CAST (char *, src_str),\n-\t\t\t\t  dest_align, false))\n-\t{\n-\t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n-\t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      CONST_CAST (char *, src_str),\n-\t\t\t\t      dest_align, false, 0);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), target);\n-\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-\t  return dest_mem;\n-\t}\n+      return expand_builtin_memcpy_args (dest, src, len, target, exp);\n+    }\n+}\n \n-      src_mem = get_memory_rtx (src, len);\n-      set_mem_align (src_mem, src_align);\n+/* Expand an instrumented call EXP to the memcpy builtin.\n+   Return NULL_RTX if we failed, the caller should emit a normal call,\n+   otherwise try to get the result in TARGET, if convenient (and in\n+   mode MODE if that's convenient).  */\n \n-      /* Copy word part most expediently.  */\n-      dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n-\t\t\t\t         CALL_EXPR_TAILCALL (exp)\n-\t\t\t\t         ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n-\t\t\t\t\t expected_align, expected_size,\n-\t\t\t\t\t min_size, max_size, probable_max_size);\n+static rtx\n+expand_builtin_memcpy_with_bounds (tree exp, rtx target)\n+{\n+  if (!validate_arglist (exp,\n+\t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n+\t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n+\t\t\t INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+  else\n+    {\n+      tree dest = CALL_EXPR_ARG (exp, 0);\n+      tree src = CALL_EXPR_ARG (exp, 2);\n+      tree len = CALL_EXPR_ARG (exp, 4);\n+      rtx res = expand_builtin_memcpy_args (dest, src, len, target, exp);\n \n-      if (dest_addr == 0)\n+      /* Return src bounds with the result.  */\n+      if (res)\n \t{\n-\t  dest_addr = force_operand (XEXP (dest_mem, 0), target);\n-\t  dest_addr = convert_memory_address (ptr_mode, dest_addr);\n+\t  rtx bnd = force_reg (BNDmode,\n+\t\t\t       expand_normal (CALL_EXPR_ARG (exp, 1)));\n+\t  res = chkp_join_splitted_slot (res, bnd);\n \t}\n-      return dest_addr;\n+      return res;\n     }\n }\n \n@@ -3281,7 +3325,40 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n       tree src = CALL_EXPR_ARG (exp, 1);\n       tree len = CALL_EXPR_ARG (exp, 2);\n       return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t\t  target, mode, /*endp=*/ 1);\n+\t\t\t\t\t  target, mode, /*endp=*/ 1,\n+\t\t\t\t\t  exp);\n+    }\n+}\n+\n+/* Expand an instrumented call EXP to the mempcpy builtin.\n+   Return NULL_RTX if we failed, the caller should emit a normal call,\n+   otherwise try to get the result in TARGET, if convenient (and in\n+   mode MODE if that's convenient).  */\n+\n+static rtx\n+expand_builtin_mempcpy_with_bounds (tree exp, rtx target, machine_mode mode)\n+{\n+  if (!validate_arglist (exp,\n+\t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n+\t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n+\t\t\t INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+  else\n+    {\n+      tree dest = CALL_EXPR_ARG (exp, 0);\n+      tree src = CALL_EXPR_ARG (exp, 2);\n+      tree len = CALL_EXPR_ARG (exp, 4);\n+      rtx res = expand_builtin_mempcpy_args (dest, src, len, target,\n+\t\t\t\t\t     mode, 1, exp);\n+\n+      /* Return src bounds with the result.  */\n+      if (res)\n+\t{\n+\t  rtx bnd = force_reg (BNDmode,\n+\t\t\t       expand_normal (CALL_EXPR_ARG (exp, 1)));\n+\t  res = chkp_join_splitted_slot (res, bnd);\n+\t}\n+      return res;\n     }\n }\n \n@@ -3293,10 +3370,23 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n \n static rtx\n expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n-\t\t\t     rtx target, machine_mode mode, int endp)\n+\t\t\t     rtx target, machine_mode mode, int endp,\n+\t\t\t     tree orig_exp)\n {\n+  tree fndecl = get_callee_fndecl (orig_exp);\n+\n     /* If return value is ignored, transform mempcpy into memcpy.  */\n-  if (target == const0_rtx && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n+  if (target == const0_rtx\n+      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP\n+      && builtin_decl_implicit_p (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP))\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP);\n+      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n+\t\t\t\t\t   dest, src, len);\n+      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+    }\n+  else if (target == const0_rtx\n+\t   && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n     {\n       tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n       tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n@@ -3481,7 +3571,8 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n- \t\t\t\t\t target, mode, /*endp=*/2);\n+\t\t\t\t\t target, mode, /*endp=*/2,\n+\t\t\t\t\t exp);\n \n       if (ret)\n \treturn ret;\n@@ -3647,6 +3738,36 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n     }\n }\n \n+/* Expand expression EXP, which is an instrumented call to the memset builtin.\n+   Return NULL_RTX if we failed the caller should emit a normal call, otherwise\n+   try to get the result in TARGET, if convenient (and in mode MODE if that's\n+   convenient).  */\n+\n+static rtx\n+expand_builtin_memset_with_bounds (tree exp, rtx target, machine_mode mode)\n+{\n+  if (!validate_arglist (exp,\n+\t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n+\t\t\t INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+  else\n+    {\n+      tree dest = CALL_EXPR_ARG (exp, 0);\n+      tree val = CALL_EXPR_ARG (exp, 2);\n+      tree len = CALL_EXPR_ARG (exp, 3);\n+      rtx res = expand_builtin_memset_args (dest, val, len, target, mode, exp);\n+\n+      /* Return src bounds with the result.  */\n+      if (res)\n+\t{\n+\t  rtx bnd = force_reg (BNDmode,\n+\t\t\t       expand_normal (CALL_EXPR_ARG (exp, 1)));\n+\t  res = chkp_join_splitted_slot (res, bnd);\n+\t}\n+      return res;\n+    }\n+}\n+\n /* Helper function to do the actual work for expand_builtin_memset.  The\n    arguments to the builtin_memset call DEST, VAL, and LEN are broken out\n    so that this can also be called without constructing an actual CALL_EXPR.\n@@ -3775,7 +3896,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n  do_libcall:\n   fndecl = get_callee_fndecl (orig_exp);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n-  if (fcode == BUILT_IN_MEMSET)\n+  if (fcode == BUILT_IN_MEMSET\n+      || fcode == BUILT_IN_CHKP_MEMSET_NOBND_NOCHK_CHKP)\n     fn = build_call_nofold_loc (EXPR_LOCATION (orig_exp), fndecl, 3,\n \t\t\t\tdest, val, len);\n   else if (fcode == BUILT_IN_BZERO)\n@@ -5848,6 +5970,8 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \t}\n     }\n \n+  /* expand_builtin_with_bounds is supposed to be used for\n+     instrumented builtin calls.  */\n   gcc_assert (!CALL_WITH_BOUNDS_P (exp));\n \n   switch (fcode)\n@@ -6908,6 +7032,53 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n   return expand_call (exp, target, ignore);\n }\n \n+/* Similar to expand_builtin but is used for instrumented calls.  */\n+\n+rtx\n+expand_builtin_with_bounds (tree exp, rtx target,\n+\t\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t\t    machine_mode mode, int ignore)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  gcc_assert (CALL_WITH_BOUNDS_P (exp));\n+\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n+    return targetm.expand_builtin (exp, target, subtarget, mode, ignore);\n+\n+  gcc_assert (fcode > BEGIN_CHKP_BUILTINS\n+\t      && fcode < END_CHKP_BUILTINS);\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP:\n+      target = expand_builtin_memcpy_with_bounds (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP:\n+      target = expand_builtin_mempcpy_with_bounds (exp, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_CHKP_MEMSET_NOBND_NOCHK_CHKP:\n+      target = expand_builtin_memset_with_bounds (exp, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* The switch statement above can drop through to cause the function\n+     to be called normally.  */\n+  return expand_call (exp, target, ignore);\n+ }\n+\n /* Determine whether a tree node represents a call to a built-in\n    function.  If the tree T is a call to a built-in function with\n    the right number of arguments of the appropriate types, return"}, {"sha": "44bc5dfb2e1260f20a7f855287f9b65c051b8884", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -69,6 +69,7 @@ extern tree std_canonical_va_list_type (tree);\n extern void std_expand_builtin_va_start (tree, rtx);\n extern void expand_builtin_trap (void);\n extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n+extern rtx expand_builtin_with_bounds (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_expect (location_t, tree, tree, tree);\n extern tree fold_fma (location_t, tree, tree, tree, tree);"}, {"sha": "c7621b0e9c851dca270b8b055a5219006dd47aae", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -10462,7 +10462,11 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tif (fndecl && DECL_BUILT_IN (fndecl))\n \t  {\n \t    gcc_assert (DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_FRONTEND);\n-\t    return expand_builtin (exp, target, subtarget, tmode, ignore);\n+\t    if (CALL_WITH_BOUNDS_P (exp))\n+\t      return expand_builtin_with_bounds (exp, target, subtarget,\n+\t\t\t\t\t\t tmode, ignore);\n+\t    else\n+\t      return expand_builtin (exp, target, subtarget, tmode, ignore);\n \t  }\n       }\n       return expand_call (exp, target, ignore);"}, {"sha": "46b2139758aaf2e918bfe73b484856a942f49c2c", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -129,6 +129,16 @@ chkp_build_instrumented_fndecl (tree fndecl)\n      make own copy.  */\n   DECL_ATTRIBUTES (new_decl) = copy_list (DECL_ATTRIBUTES (fndecl));\n \n+  /* Change builtin function code.  */\n+  if (DECL_BUILT_IN (new_decl))\n+    {\n+      gcc_assert (DECL_BUILT_IN_CLASS (new_decl) == BUILT_IN_NORMAL);\n+      gcc_assert (DECL_FUNCTION_CODE (new_decl) < BEGIN_CHKP_BUILTINS);\n+      DECL_FUNCTION_CODE (new_decl)\n+\t= (enum built_in_function)(DECL_FUNCTION_CODE (new_decl)\n+\t\t\t\t   + BEGIN_CHKP_BUILTINS + 1);\n+    }\n+\n   return new_decl;\n }\n \n@@ -354,6 +364,33 @@ chkp_add_bounds_params_to_function (tree fndecl)\n     chkp_copy_function_type_adding_bounds (TREE_TYPE (fndecl));\n }\n \n+/* Return an instrumentation clone for builtin function\n+   FNDECL.  Create one if needed.  */\n+\n+tree\n+chkp_maybe_clone_builtin_fndecl (tree fndecl)\n+{\n+  tree clone;\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  gcc_assert (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t      && fcode < BEGIN_CHKP_BUILTINS);\n+\n+  fcode = (enum built_in_function) (fcode + BEGIN_CHKP_BUILTINS + 1);\n+  clone = builtin_decl_explicit (fcode);\n+  if (clone)\n+    return clone;\n+\n+  clone = chkp_build_instrumented_fndecl (fndecl);\n+  chkp_add_bounds_params_to_function (clone);\n+\n+  gcc_assert (DECL_FUNCTION_CODE (clone) == fcode);\n+\n+  set_builtin_decl (fcode, clone, false);\n+\n+  return clone;\n+}\n+\n /* Return clone created for instrumentation of NODE or NULL.  */\n \n cgraph_node *\n@@ -364,6 +401,54 @@ chkp_maybe_create_clone (tree fndecl)\n \n   gcc_assert (!node->instrumentation_clone);\n \n+  if (DECL_BUILT_IN (fndecl)\n+      && (DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL\n+\t  || DECL_FUNCTION_CODE (fndecl) >= BEGIN_CHKP_BUILTINS))\n+    return NULL;\n+\n+  clone = node->instrumented_version;\n+\n+  /* Some instrumented builtin function calls may be optimized and\n+     cgraph nodes may be removed as unreachable.  Later optimizations\n+     may generate new calls to removed functions and in this case\n+     we have to recreate cgraph node.  FUNCTION_DECL for instrumented\n+     builtin still exists and should be reused in such case.  */\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && fndecl == builtin_decl_explicit (DECL_FUNCTION_CODE (fndecl))\n+      && !clone)\n+    {\n+      enum built_in_function fncode = DECL_FUNCTION_CODE (fndecl);\n+      tree new_decl;\n+\n+      fncode = (enum built_in_function) (fncode + BEGIN_CHKP_BUILTINS + 1);\n+      new_decl = builtin_decl_explicit (fncode);\n+\n+      /* We've actually already created an instrumented clone once.\n+\t Restore it.  */\n+      if (new_decl)\n+\t{\n+\t  clone = cgraph_node::get (new_decl);\n+\n+\t  if (!clone)\n+\t    {\n+\t      gcc_assert (!gimple_has_body_p (fndecl));\n+\t      clone = cgraph_node::get_create (new_decl);\n+\t      clone->externally_visible = node->externally_visible;\n+\t      clone->local = node->local;\n+\t      clone->address_taken = node->address_taken;\n+\t      clone->thunk = node->thunk;\n+\t      clone->alias = node->alias;\n+\t      clone->weakref = node->weakref;\n+\t      clone->cpp_implicit_alias = node->cpp_implicit_alias;\n+\t      clone->orig_decl = fndecl;\n+\t      clone->instrumentation_clone = true;\n+\t    }\n+\n+\t  clone->instrumented_version = node;\n+\t  node->instrumented_version = clone;\n+\t}\n+    }\n+\n   if (!clone)\n     {\n       tree new_decl = chkp_build_instrumented_fndecl (fndecl);\n@@ -408,6 +493,15 @@ chkp_maybe_create_clone (tree fndecl)\n \t actually copies args list from the original decl.  */\n       chkp_add_bounds_params_to_function (new_decl);\n \n+      /* Remember builtin fndecl.  */\n+      if (DECL_BUILT_IN_CLASS (clone->decl) == BUILT_IN_NORMAL\n+\t  && fndecl == builtin_decl_explicit (DECL_FUNCTION_CODE (fndecl)))\n+\t{\n+\t  gcc_assert (!builtin_decl_explicit (DECL_FUNCTION_CODE (clone->decl)));\n+\t  set_builtin_decl (DECL_FUNCTION_CODE (clone->decl),\n+\t\t\t    clone->decl, false);\n+\t}\n+\n       /* Clones have the same comdat group as originals.  */\n       if (node->same_comdat_group\n \t  || DECL_ONE_ONLY (node->decl))\n@@ -487,8 +581,9 @@ chkp_versioning (void)\n \t  && (!flag_chkp_instrument_marked_only\n \t      || lookup_attribute (\"bnd_instrument\",\n \t\t\t\t   DECL_ATTRIBUTES (node->decl)))\n-\t  /* No builtins instrumentation for now.  */\n-\t  && DECL_BUILT_IN_CLASS (node->decl) == NOT_BUILT_IN)\n+\t  && (!DECL_BUILT_IN (node->decl)\n+\t      || (DECL_BUILT_IN_CLASS (node->decl) == BUILT_IN_NORMAL\n+\t\t  && DECL_FUNCTION_CODE (node->decl) < BEGIN_CHKP_BUILTINS)))\n \tchkp_maybe_create_clone (node->decl);\n     }\n "}, {"sha": "b2d03ad194ac037149a2baa7afc9bf613fa082c8", "filename": "gcc/ipa-chkp.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fipa-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Fipa-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.h?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_IPA_CHKP_H\n \n extern tree chkp_copy_function_type_adding_bounds (tree orig_type);\n+extern tree chkp_maybe_clone_builtin_fndecl (tree fndecl);\n extern cgraph_node *chkp_maybe_create_clone (tree fndecl);\n \n #endif /* GCC_IPA_CHKP_H */"}, {"sha": "0fb78ccf0765cf7e39d4e7ee5b41a0430e10ee7b", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -1586,6 +1586,50 @@ chkp_find_bound_slots (const_tree type, bitmap res)\n   chkp_find_bound_slots_1 (type, res, 0);\n }\n \n+/* Return 1 if call to FNDECL should be instrumented\n+   and 0 otherwise.  */\n+\n+static bool\n+chkp_instrument_normal_builtin (tree fndecl)\n+{\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_STRLEN:\n+    case BUILT_IN_STRCPY:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STRCAT:\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_BZERO:\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET_CHK:\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STRNCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRCAT_CHK:\n+    case BUILT_IN_STRNCAT_CHK:\n+    case BUILT_IN_MALLOC:\n+    case BUILT_IN_CALLOC:\n+    case BUILT_IN_REALLOC:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Add bound arguments to call statement pointed by GSI.\n    Also performs a replacement of user checker builtins calls\n    with internal ones.  */\n@@ -1619,7 +1663,7 @@ chkp_add_bounds_to_call_stmt (gimple_stmt_iterator *gsi)\n       && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_OBJECT_SIZE)\n     return;\n \n-  /* Donothing for calls to legacy functions.  */\n+  /* Do nothing for calls to legacy functions.  */\n   if (fndecl\n       && lookup_attribute (\"bnd_legacy\", DECL_ATTRIBUTES (fndecl)))\n     return;\n@@ -1686,11 +1730,20 @@ chkp_add_bounds_to_call_stmt (gimple_stmt_iterator *gsi)\n   if (!flag_chkp_instrument_calls)\n     return;\n \n-  /* Avoid instrumented builtin functions for now.  Due to IPA\n-     it also means we have to avoid instrumentation of indirect\n-     calls.  */\n-  if (fndecl && DECL_BUILT_IN_CLASS (fndecl) != NOT_BUILT_IN)\n-    return;\n+  /* We instrument only some subset of builtins.  We also instrument\n+     builtin calls to be inlined.  */\n+  if (fndecl\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && !chkp_instrument_normal_builtin (fndecl))\n+    {\n+      if (!lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fndecl)))\n+\treturn;\n+\n+      struct cgraph_node *clone = chkp_maybe_create_clone (fndecl);\n+      if (!clone\n+\t  || !gimple_has_body_p (clone->decl))\n+\treturn;\n+    }\n \n   /* If function decl is available then use it for\n      formal arguments list.  Otherwise use function type.  */\n@@ -1764,14 +1817,6 @@ chkp_add_bounds_to_call_stmt (gimple_stmt_iterator *gsi)\n     }\n   new_args.release ();\n \n-  /* If we call built-in function and pass no bounds then\n-     we do not need to change anything.  */\n-  if (new_call == call\n-      && fndecl\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && fndecl == builtin_decl_explicit (DECL_FUNCTION_CODE (fndecl)))\n-      return;\n-\n   /* For direct calls fndecl is replaced with instrumented version.  */\n   if (fndecl)\n     {\n@@ -3905,15 +3950,21 @@ chkp_replace_function_pointer (tree *op, int *walk_subtrees,\n {\n   if (TREE_CODE (*op) == FUNCTION_DECL\n       && !lookup_attribute (\"bnd_legacy\", DECL_ATTRIBUTES (*op))\n-      /* Do not replace builtins for now.  */\n-      && DECL_BUILT_IN_CLASS (*op) == NOT_BUILT_IN)\n+      && (DECL_BUILT_IN_CLASS (*op) == NOT_BUILT_IN\n+\t  /* For builtins we replace pointers only for selected\n+\t     function and functions having definitions.  */\n+\t  || (DECL_BUILT_IN_CLASS (*op) == BUILT_IN_NORMAL\n+\t      && (chkp_instrument_normal_builtin (*op)\n+\t\t  || gimple_has_body_p (*op)))))\n     {\n       struct cgraph_node *node = cgraph_node::get_create (*op);\n+      struct cgraph_node *clone = NULL;\n \n       if (!node->instrumentation_clone)\n-\tchkp_maybe_create_clone (*op);\n+\tclone = chkp_maybe_create_clone (*op);\n \n-      *op = node->instrumented_version->decl;\n+      if (clone)\n+\t*op = clone->decl;\n       *walk_subtrees = 0;\n     }\n "}, {"sha": "fe3fbb4e38996a600f7e8aa70017cb5d4999846a", "filename": "gcc/tree-core.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -168,6 +168,14 @@ enum built_in_class {\n enum built_in_function {\n #include \"builtins.def\"\n \n+  BEGIN_CHKP_BUILTINS,\n+\n+#undef DEF_BUILTIN\n+#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM, COND) ENUM##_CHKP,\n+#include \"builtins.def\"\n+\n+  END_CHKP_BUILTINS,\n+\n   /* Complex division routines in libgcc.  These are done via builtins\n      because emit_library_call_value can't handle complex values.  */\n   BUILT_IN_COMPLEX_MUL_MIN,"}, {"sha": "fba60483f5e7313a76c31746702ec677a5379b8b", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edcf72f3c9e070fe904ff9ff2f2fd145e694af83/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=edcf72f3c9e070fe904ff9ff2f2fd145e694af83", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"streamer-hooks.h\"\n #include \"lto-streamer.h\"\n #include \"builtins.h\"\n+#include \"ipa-chkp.h\"\n \n /* Read a STRING_CST from the string table in DATA_IN using input\n    block IB.  */\n@@ -1113,6 +1114,14 @@ streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n       if (fcode >= END_BUILTINS)\n \tfatal_error (\"machine independent builtin code out of range\");\n       result = builtin_decl_explicit (fcode);\n+      if (!result\n+\t  && fcode > BEGIN_CHKP_BUILTINS\n+\t  && fcode < END_CHKP_BUILTINS)\n+\t{\n+\t  fcode = (enum built_in_function) (fcode - BEGIN_CHKP_BUILTINS - 1);\n+\t  result = builtin_decl_explicit (fcode);\n+\t  result = chkp_maybe_clone_builtin_fndecl (result);\n+\t}\n       gcc_assert (result);\n     }\n   else if (fclass == BUILT_IN_MD)"}]}