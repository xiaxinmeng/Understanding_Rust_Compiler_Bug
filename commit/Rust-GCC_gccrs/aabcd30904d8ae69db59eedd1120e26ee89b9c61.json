{"sha": "aabcd30904d8ae69db59eedd1120e26ee89b9c61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiY2QzMDkwNGQ4YWU2OWRiNTllZWRkMTEyMGUyNmVlODliOWM2MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-01T03:42:55Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-01T03:42:55Z"}, "message": "cgraphunit.c, [...]: Fix comment typos.\n\n\t* cgraphunit.c, dbxout.c, flow.c, gcse.c, gimplify.c,\n\tlambda-code.c, loop.c, machmode.def, mips-tfile.c,\n\tmodulo-sched.c, passes.c, postreload-gcse.c, tree-eh.c,\n\ttree-ssa-ccp.c, varasm.c, config/frv/frv.c, config/frv/frv.h,\n\tconfig/frv/frv.md, config/i386/i386.c, config/i386/i386.h,\n\tconfig/i386/i386.md, config/rs6000/predicates.md,\n\tconfig/rs6000/rs6000.c, config/s390/fixdfdi.h,\n\tconfig/s390/s390.c, config/stormy16/stormy16.c,\n\tconfig/stormy16/stormy16.md, config/vax/vax.md: Fix comment\n\ttypos.\n\nFrom-SVN: r97362", "tree": {"sha": "782893b0afb24d21b87a6216e40df5e5f887e02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/782893b0afb24d21b87a6216e40df5e5f887e02f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aabcd30904d8ae69db59eedd1120e26ee89b9c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabcd30904d8ae69db59eedd1120e26ee89b9c61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabcd30904d8ae69db59eedd1120e26ee89b9c61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabcd30904d8ae69db59eedd1120e26ee89b9c61/comments", "author": null, "committer": null, "parents": [{"sha": "59cffcf69a5026fc54a38479c93f8ea961db8ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59cffcf69a5026fc54a38479c93f8ea961db8ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59cffcf69a5026fc54a38479c93f8ea961db8ecd"}], "stats": {"total": 95, "additions": 54, "deletions": 41}, "files": [{"sha": "3ecfbe8211b1c70ce82b5d1ca16566e1ceab0cd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1,3 +1,16 @@\n+2005-04-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cgraphunit.c, dbxout.c, flow.c, gcse.c, gimplify.c,\n+\tlambda-code.c, loop.c, machmode.def, mips-tfile.c,\n+\tmodulo-sched.c, passes.c, postreload-gcse.c, tree-eh.c,\n+\ttree-ssa-ccp.c, varasm.c, config/frv/frv.c, config/frv/frv.h,\n+\tconfig/frv/frv.md, config/i386/i386.c, config/i386/i386.h,\n+\tconfig/i386/i386.md, config/rs6000/predicates.md,\n+\tconfig/rs6000/rs6000.c, config/s390/fixdfdi.h,\n+\tconfig/s390/s390.c, config/stormy16/stormy16.c,\n+\tconfig/stormy16/stormy16.md, config/vax/vax.md: Fix comment\n+\ttypos.\n+\n 2005-04-01  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/17855"}, {"sha": "528b7da9736b7860515b8f24cd6ab2864cfed6ec", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -282,8 +282,8 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n-/* Walk the decls we marked as neccesary and see if they reference new variables\n-   or functions and add them into the worklists.  */\n+/* Walk the decls we marked as necessary and see if they reference new\n+   variables or functions and add them into the worklists.  */\n static bool\n cgraph_varpool_analyze_pending_decls (void)\n {\n@@ -307,10 +307,10 @@ cgraph_varpool_analyze_pending_decls (void)\n }\n \n /* Optimization of function bodies might've rendered some variables as\n-   unnecesary so we want to avoid these from being compiled.\n+   unnecessary so we want to avoid these from being compiled.\n \n    This is done by prunning the queue and keeping only the variables that\n-   really appear needed (ie thery are either externally visible or referenced\n+   really appear needed (ie they are either externally visible or referenced\n    by compiled function). Re-doing the reachability analysis on variables\n    brings back the remaining variables referenced by these.  */\n static void\n@@ -772,7 +772,7 @@ cgraph_finalize_compilation_unit (void)\n {\n   struct cgraph_node *node;\n   /* Keep track of already processed nodes when called multiple times for\n-     intermodule optmization.  */\n+     intermodule optimization.  */\n   static struct cgraph_node *first_analyzed;\n \n   finish_aliases_1 ();"}, {"sha": "b75826c4daf52be85079ab06354a05e58ca72717", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -781,7 +781,7 @@ frv_override_options (void)\n \n    You should not use this macro to change options that are not\n    machine-specific.  These should uniformly selected by the same optimization\n-   level on all supported machines.  Use this macro to enable machbine-specific\n+   level on all supported machines.  Use this macro to enable machine-specific\n    optimizations.\n \n    *Do not examine `write_symbols' in this macro!* The debugging options are"}, {"sha": "a80d534f3bf03a1d0701ff31f68f8229690b5a1d", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -351,7 +351,7 @@\n \n    You should not use this macro to change options that are not\n    machine-specific.  These should uniformly selected by the same optimization\n-   level on all supported machines.  Use this macro to enable machbine-specific\n+   level on all supported machines.  Use this macro to enable machine-specific\n    optimizations.\n \n    *Do not examine `write_symbols' in this macro!* The debugging options are"}, {"sha": "a81bc8b940eb62a68be1796f3e4723e0d19c5ce7", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1206,7 +1206,7 @@\n        (eq_attr \"type\" \"sqrt_single\"))\n   \"(f1|f0) + fr550_float\")\n \n-;; Synthetic units for enforcing media issue restructions.  Certain types\n+;; Synthetic units for enforcing media issue restrictions.  Certain types\n ;; of insn in M2 conflict with certain types in M0:\n ;;\n ;;\t\t\t     M2\n@@ -5913,7 +5913,7 @@\n ;; Called after register allocation to add any instructions needed for the\n ;; epilogue.  Using an epilogue insn is favored compared to putting all of the\n ;; instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n-;; to intermix instructions with the restires of the caller saved registers.\n+;; to intermix instructions with the restores of the caller saved registers.\n ;; In some cases, it might be necessary to emit a barrier instruction as the\n ;; first insn to prevent such scheduling.\n (define_expand \"epilogue\""}, {"sha": "80f4b0c1433bc84d9b725530e5652cd003729508", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -4112,7 +4112,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   /* During reload iteration the amount of registers saved can change.\n      Recompute the value as needed.  Do not recompute when amount of registers\n-     didn't change as reload does mutiple calls to the function and does not\n+     didn't change as reload does multiple calls to the function and does not\n      expect the decision to change within single iteration.  */\n   if (!optimize_size\n       && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n@@ -6030,7 +6030,7 @@ i386_output_dwarf_dtprel (FILE *file, int size, rtx x)\n }\n \n /* In the name of slightly smaller debug output, and to cater to\n-   general assembler losage, recognize PIC+GOTOFF and turn it back\n+   general assembler lossage, recognize PIC+GOTOFF and turn it back\n    into a direct symbol reference.  */\n \n static rtx\n@@ -6137,8 +6137,8 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n       suffix = \"g\";\n       break;\n     case GTU:\n-      /* ??? Use \"nbe\" instead of \"a\" for fcmov losage on some assemblers.\n-\t Those same assemblers have the same but opposite losage on cmov.  */\n+      /* ??? Use \"nbe\" instead of \"a\" for fcmov lossage on some assemblers.\n+\t Those same assemblers have the same but opposite lossage on cmov.  */\n       if (mode != CCmode)\n \tabort ();\n       suffix = fp ? \"nbe\" : \"a\";"}, {"sha": "559ea82b47da45c68432d9e0ee27c0c87e10fb82", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1183,7 +1183,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    This is computed in `reload', in reload1.c.  */\n #define FRAME_POINTER_REQUIRED  ix86_frame_pointer_required ()\n \n-/* Override this in other tm.h files to cope with various OS losage\n+/* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n #define SUBTARGET_FRAME_POINTER_REQUIRED 0"}, {"sha": "5fc7fab2dd19331b6df8328d283b22331690b10e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -19357,7 +19357,7 @@\n     abort ();\n \n   /* Use 3dNOW prefetch in case we are asking for write prefetch not\n-     suported by SSE counterpart or the SSE prefetch is not available\n+     supported by SSE counterpart or the SSE prefetch is not available\n      (K6 machines).  Otherwise use SSE prefetch as it allows specifying\n      of locality.  */\n   if (TARGET_3DNOW && (!TARGET_PREFETCH_SSE || rw))"}, {"sha": "6c41870cc8068d7d38f8f01ea41e5dd8771fc5af", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -593,7 +593,7 @@\n   (match_code \"symbol_ref,const,label_ref\"))\n \n ;; Return 1 if op is a simple reference that can be loaded via the GOT,\n-;; exclusing labels involving addition.\n+;; excluding labels involving addition.\n (define_predicate \"got_no_const_operand\"\n   (match_code \"symbol_ref,label_ref\"))\n "}, {"sha": "8d07d8f36e20da0ed5c686e1c0eece4af1d00da6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -227,7 +227,7 @@ const char *rs6000_debug_name;\n int rs6000_debug_stack;\t\t/* debug stack applications */\n int rs6000_debug_arg;\t\t/* debug argument handling */\n \n-/* Value is TRUE if register/mode pair is accepatable.  */\n+/* Value is TRUE if register/mode pair is acceptable.  */\n bool rs6000_hard_regno_mode_ok_p[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n \n /* Opaque types.  */\n@@ -15249,7 +15249,7 @@ static bool\n rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost,\n \t\t\t     int distance)\n {\n-  /* If the flag is not enbled - no dependence is considered costly;\n+  /* If the flag is not enabled - no dependence is considered costly;\n      allow all dependent insns in the same group.\n      This is the most aggressive option.  */\n   if (rs6000_sched_costly_dep == no_dep_costly)"}, {"sha": "74c9c68f6b2a1b011d6116e47c18e8eebbe5ef29", "filename": "gcc/config/s390/fixdfdi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -55,7 +55,7 @@ __fixunsdfdi (double a1)\n \n     dl1.d = a1;\n \n-    /* +/- 0, denormalized, negativ */\n+    /* +/- 0, denormalized, negative */\n \n     if (!EXPD (dl1) || SIGND(dl1))\n       return 0;\n@@ -199,7 +199,7 @@ __fixunssfdi (float a1)\n \n     fl1.f = a1;\n \n-    /* +/- 0, denormalized, negativ */\n+    /* +/- 0, denormalized, negative */\n \n     if (!EXP (fl1) || SIGN(fl1))\n       return 0;"}, {"sha": "90919e36d5305025b447bb7eae4138b74ab1eff3", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -4130,7 +4130,7 @@ s390_output_dwarf_dtprel (FILE *file, int size, rtx x)\n }\n \n /* In the name of slightly smaller debug output, and to cater to\n-   general assembler losage, recognize various UNSPEC sequences\n+   general assembler lossage, recognize various UNSPEC sequences\n    and turn them back into a direct symbol reference.  */\n \n static rtx"}, {"sha": "2ac5aa7a0782cd76346d0ffc1f1d9e8daec5f357", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -2658,7 +2658,7 @@ combine_bnp (rtx insn)\n \n       if (and)\n \t{\n-\t  /* Some mis-optimisations by GCC can generate a RIGHT-SHIFT\n+\t  /* Some mis-optimizations by GCC can generate a RIGHT-SHIFT\n \t     followed by an AND like this:\n \n                (parallel [(set (reg:HI r7) (lshiftrt:HI (reg:HI r7) (const_int 3)))"}, {"sha": "858adc06c097ddc4153b06be9001c2fccd8a591b", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1104,7 +1104,7 @@\n ;; the epilogue.  Using an epilogue insn is favored compared to putting\n ;; all of the instructions in the TARGET_ASM_FUNCTION_EPILOGUE macro,\n ;; since it allows the scheduler to intermix instructions with the\n-;; restires of the caller saved registers.  In some cases, it might be\n+;; restores of the caller saved registers.  In some cases, it might be\n ;; necessary to emit a barrier instruction as the first insn to\n ;; prevent such scheduling.\n (define_expand \"epilogue\""}, {"sha": "c9817de6161219879e3af95e65e04596e8934ddb", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -37,7 +37,7 @@\n   ]\n )\n \n-;; Integer modes supported on VAX, withd a mapping from machine mode\n+;; Integer modes supported on VAX, with a mapping from machine mode\n ;; to mnemonic suffix.  DImode is always a special case.\n (define_mode_macro VAXint [QI HI SI])\n (define_mode_attr  isfx [(QI \"b\") (HI \"w\") (SI \"l\")])"}, {"sha": "c645edbeec2d00346c656032664c0dd76dfe72c2", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -2360,7 +2360,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n     DBXOUT_DECR_NESTING_AND_RETURN (0);\n \n   /* If we are to generate only the symbols actually used then such\n-     symbol nodees are flagged with TREE_USED.  Ignore any that\n+     symbol nodes are flagged with TREE_USED.  Ignore any that\n      aren't flaged as TREE_USED.  */\n \n   if (flag_debug_only_used_symbols"}, {"sha": "bdd72d30f4ffac0354dd685251f1ab0260c18027", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -273,7 +273,7 @@ static int ndead;\n    (remember, we are walking backward).  This can be computed as current\n    pbi->insn_num - reg_deaths[regno].\n    At the end of processing each basic block, the remaining live registers\n-   are inspected and liferanges are increased same way so liverange of global\n+   are inspected and live ranges are increased same way so liverange of global\n    registers are computed correctly.\n   \n    The array is maintained clear for dead registers, so it can be safely reused"}, {"sha": "02a179e08a02ad2cb2e4419b9b17d577c333d705", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -3260,7 +3260,7 @@ cprop (int alter_jumps)\n    settle for the condition variable in the jump instruction being integral.\n    We prefer to be able to record the value of a user variable, rather than\n    the value of a temporary used in a condition.  This could be solved by\n-   recording the value of *every* register scaned by canonicalize_condition,\n+   recording the value of *every* register scanned by canonicalize_condition,\n    but this would require some code reorganization.  */\n \n rtx"}, {"sha": "23713df01defc1ed52d015644540cac8713058f4", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -4428,7 +4428,7 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n {\n   /* We don't do anything if the value isn't there, is constant, or contains\n      A PLACEHOLDER_EXPR.  We also don't want to do anything if it's already\n-     a VAR_DECL.  If it's a VAR_DECL from another function, the gimplfier\n+     a VAR_DECL.  If it's a VAR_DECL from another function, the gimplifier\n      will want to replace it with a new variable, but that will cause problems\n      if this type is from outside the function.  It's OK to have that here.  */\n   if (*expr_p == NULL_TREE || TREE_CONSTANT (*expr_p)"}, {"sha": "66745b6cb253adbea01fab8080e1bee205429bf4", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -489,7 +489,7 @@ lcm (int a, int b)\n }\n \n /* Perform Fourier-Motzkin elimination to calculate the bounds of the\n-   auxillary nest.\n+   auxiliary nest.\n    Fourier-Motzkin is a way of reducing systems of linear inequalities so that\n    it is easy to calculate the answer and bounds.\n    A sketch of how it works:\n@@ -800,7 +800,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n /* Compute the loop bounds for the target space, using the bounds of\n    the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.  \n    The target space loop bounds are computed by multiplying the triangular\n-   matrix H by the auxillary nest, to get the new loop bounds.  The sign of\n+   matrix H by the auxiliary nest, to get the new loop bounds.  The sign of\n    the loop steps (positive or negative) is then used to swap the bounds if\n    the loop counts downwards.\n    Return the target loopnest.  */\n@@ -1057,8 +1057,8 @@ lambda_compute_step_signs (lambda_trans_matrix trans, lambda_vector stepsigns)\n    2. Composing the dense base with the specified transformation (TRANS)\n    3. Decomposing the combined transformation into a lower triangular portion,\n    and a unimodular portion. \n-   4. Computing the auxillary nest using the unimodular portion.\n-   5. Computing the target nest using the auxillary nest and the lower\n+   4. Computing the auxiliary nest using the unimodular portion.\n+   5. Computing the target nest using the auxiliary nest and the lower\n    triangular portion.  */ \n \n lambda_loopnest"}, {"sha": "8a32d2f99b0f467cd07b7bef272e97529bb323a0", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -8904,7 +8904,7 @@ combine_givs (struct loop_regs *regs, struct iv_class *bl)\n       /* If a DEST_REG GIV is used only once, do not allow it to combine\n \t with anything, for in doing so we will gain nothing that cannot\n \t be had by simply letting the GIV with which we would have combined\n-\t to be reduced on its own.  The losage shows up in particular with\n+\t to be reduced on its own.  The lossage shows up in particular with\n \t DEST_ADDR targets on hosts with reg+reg addressing, though it can\n \t be seen elsewhere as well.  */\n       if (g1->giv_type == DEST_REG"}, {"sha": "fca7a6a4be9282fdd689b29c2277ea34b538aa38", "filename": "gcc/machmode.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    A CLASS argument must be one of the constants defined in\n    mode-classes.def, less the leading MODE_ prefix; some statements\n-   that take CLASS arguments have restructions on which classes are\n+   that take CLASS arguments have restrictions on which classes are\n    acceptable.  For instance, INT.\n \n    A MODE argument must be the printable name of a machine mode,"}, {"sha": "2f2982753e079dabd777cc453e1dc7d83963a9d1", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1746,7 +1746,7 @@ add_string (varray_t *vp, shash_t **hash_tbl, const char *start,\n \n \f\n /* Add a local symbol.  The symbol string starts at STR_START and the\n-   first byte after it is makred by STR_END_P1.  The symbol has type\n+   first byte after it is marked by STR_END_P1.  The symbol has type\n    TYPE and storage class STORAGE and value VALUE.  INDX is an index\n    to local/aux. symbols.  */\n "}, {"sha": "950313eae46076a713dc40d69c2c788b60dd6385", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -455,7 +455,7 @@ calculate_maxii (ddg_ptr g)\n    true-dependence of distance 1): SCHED_TIME (def) < SCHED_TIME (use) and\n    if so generate a register move.   The number of such moves is equal to:\n               SCHED_TIME (use) - SCHED_TIME (def)       { 0 broken\n-   nreg_moves = ----------------------------------- + 1 - {   dependecnce.\n+   nreg_moves = ----------------------------------- + 1 - {   dependence.\n                             ii                          { 1 if not.\n */\n static void"}, {"sha": "f98fbf8db7f08d0f77b3ea4aadae5cf14d730614", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -252,7 +252,7 @@ rest_of_decl_compilation (tree decl,\n       timevar_pop (TV_SYMOUT);\n     }\n \n-  /* Let cgraph know about the existance of variables.  */\n+  /* Let cgraph know about the existence of variables.  */\n   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     cgraph_varpool_node (decl);\n }"}, {"sha": "681572172f838f2d67fb38d1d8a1f966de6311ba", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -300,7 +300,7 @@ hash_expr_for_htab (const void *expp)\n   return exp->hash;\n }\n \n-/* Callbach for hashtab.\n+/* Callback for hashtab.\n    Return nonzero if exp1 is equivalent to exp2.  */\n \n static int"}, {"sha": "ab945ff97017de4c4e763babf3b69717d0fef6af", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -50,7 +50,7 @@ using_eh_for_cleanups (void)\n /* Misc functions used in this file.  */\n \n /* Compare and hash for any structure which begins with a canonical\n-   pointer.  Assumes all pointers are interchangable, which is sort\n+   pointer.  Assumes all pointers are interchangeable, which is sort\n    of already assumed by gcc elsewhere IIRC.  */\n \n static int"}, {"sha": "5c07938799131a538ab38b251e23d703c1aff275", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -1582,7 +1582,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n       /* We can get here for out-of-range string constant accesses, \n \t such as \"_\"[3].  Bail out of the entire substitution search\n \t and arrange for the entire statement to be replaced by a\n-\t call to __builtin_trap.  In all likelyhood this will all be\n+\t call to __builtin_trap.  In all likelihood this will all be\n \t constant-folded away, but in the meantime we can't leave with\n \t something that get_expr_operands can't understand.  */\n "}, {"sha": "b567c38cbc643476a799106fde60d2eb9da1726b", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabcd30904d8ae69db59eedd1120e26ee89b9c61/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=aabcd30904d8ae69db59eedd1120e26ee89b9c61", "patch": "@@ -4421,7 +4421,7 @@ globalize_decl (tree decl)\n \n /* We have to be able to tell cgraph about the needed-ness of the target\n    of an alias.  This requires that the decl have been defined.  Aliases\n-   that preceed their definition have to be queued for later processing.  */\n+   that precede their definition have to be queued for later processing.  */\n \n struct alias_pair GTY(())\n {"}]}