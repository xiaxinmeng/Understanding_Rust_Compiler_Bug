{"sha": "a61c98cf7f4a669439b1a430d035c4748dcf632a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxYzk4Y2Y3ZjRhNjY5NDM5YjFhNDMwZDAzNWM0NzQ4ZGNmNjMyYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T11:42:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-07T11:42:21Z"}, "message": "(push_reload, find_reloads): Treat (subreg (pseudo)) and (subreg (mem)) the same.\n\n(push_reload, find_reloads): Treat (subreg (pseudo)) and (subreg (mem))\nthe same.\nIf we have (subreg:M1 (mem:M2 ...) ...), never do anything special if M1\nand M2 are the same size.\n\nFrom-SVN: r5097", "tree": {"sha": "13707ad46919d3ad5f93da66288c2b68820c9503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13707ad46919d3ad5f93da66288c2b68820c9503"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61c98cf7f4a669439b1a430d035c4748dcf632a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c98cf7f4a669439b1a430d035c4748dcf632a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61c98cf7f4a669439b1a430d035c4748dcf632a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c98cf7f4a669439b1a430d035c4748dcf632a/comments", "author": null, "committer": null, "parents": [{"sha": "126424267ee2159d3ddee776d7b63addea3528bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/126424267ee2159d3ddee776d7b63addea3528bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/126424267ee2159d3ddee776d7b63addea3528bd"}], "stats": {"total": 62, "additions": 38, "deletions": 24}, "files": [{"sha": "92038ea27f1fb34b6e0aac59d988c1935e50e8a0", "filename": "gcc/reload.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c98cf7f4a669439b1a430d035c4748dcf632a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c98cf7f4a669439b1a430d035c4748dcf632a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a61c98cf7f4a669439b1a430d035c4748dcf632a", "patch": "@@ -612,12 +612,14 @@ push_reload (in, out, inloc, outloc, class,\n \tout = gen_rtx (MEM, GET_MODE (out), XEXP (XEXP (out, 0), 0));\n     }\n \n-  /* If we are reloading a (SUBREG (MEM ...) ...) or (SUBREG constant ...),\n-     really reload just the inside expression in its own mode.\n-     If we have (SUBREG:M1 (REG:M2 ...) ...) with M1 wider than M2 and the\n-     register is a pseudo, this will become the same as the above case.\n+  /* If we are reloading a (SUBREG constant ...), really reload just the\n+     inside expression in its own mode.\n+     If we have (SUBREG:M1 (MEM:M2 ...) ...) (or an inner REG that is still\n+     a pseudo and hence will become a MEM) with M1 wider than M2 and the\n+     register is a pseudo, also reload the inside expression.\n      For machines that extend byte loads, do this for any SUBREG of a pseudo\n-     where both M1 and M2 are a word or smaller.\n+     where both M1 and M2 are a word or smaller unless they are the same\n+     size.\n      Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n      either M1 is not valid for R or M2 is wider than a word but we only\n      need one word to store an M2-sized quantity in R.\n@@ -634,19 +636,23 @@ push_reload (in, out, inloc, outloc, class,\n      reload but the SUBREG does.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n-      && (GET_CODE (SUBREG_REG (in)) != REG\n+      && (CONSTANT_P (SUBREG_REG (in))\n \t  || strict_low\n-\t  || (GET_CODE (SUBREG_REG (in)) == REG\n-\t      && REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER\n+\t  || (((GET_CODE (SUBREG_REG (in)) == REG\n+\t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n+\t       || GET_CODE (SUBREG_REG (in)) == MEM)\n #if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n \t      && GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) <= UNITS_PER_WORD\n+\t      && (GET_MODE_SIZE (inmode)\n+\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n #else\n \t      && (GET_MODE_SIZE (inmode)\n \t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n #endif\n \t      )\n-\t  || (REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n+\t  || (GET_CODE (SUBREG_REG (in)) == REG\n+\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n \t      && (out == 0 || SUBREG_WORD (in) == 0)\n@@ -713,13 +719,16 @@ push_reload (in, out, inloc, outloc, class,\n      (except in the case of STRICT_LOW_PART,\n      and in that case the constraint should label it input-output.)  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n-      && (GET_CODE (SUBREG_REG (out)) != REG\n+      && (CONSTANT_P (SUBREG_REG (out))\n \t  || strict_low\n-\t  || (GET_CODE (SUBREG_REG (out)) == REG\n-\t      && REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER\n+\t  || (((GET_CODE (SUBREG_REG (out)) == REG\n+\t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n+\t       || GET_CODE (SUBREG_REG (out)) == MEM)\n #if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n \t      && GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n \t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) <= UNITS_PER_WORD\n+\t      && (GET_MODE_SIZE (outmode)\n+\t\t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n #else\n \t      && (GET_MODE_SIZE (outmode)\n \t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n@@ -2540,25 +2549,30 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    {\n \t      offset += SUBREG_WORD (operand);\n \t      operand = SUBREG_REG (operand);\n-\t      /* Force reload if this is not a register or if there may may\n-\t\t be a problem accessing the register in the outer mode.  */\n-\t      if (GET_CODE (operand) != REG\n+\t      /* Force reload if this is a constant or if there may may\n+\t\t be a problem accessing OPERAND in the outer mode.  */\n+\t      if (CONSTANT_P (operand)\n #if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n \t\t  /* If we have a SUBREG where both the inner and outer\n-\t\t     modes are different but no wider than a word, combine.c\n-\t\t     has made assumptions about the behavior of the machine\n-\t\t     in such register access.  If the data is, in fact, in\n-\t\t     memory we must always load using the size assumed to\n-\t\t     be in the register and let the insn do the different-sized\n-\t\t     accesses.  */\n-\t\t  || (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t     modes are different size but no wider than a word,\n+\t\t     combine.c has made assumptions about the behavior of\n+\t\t     the machine in such register access.  If the data is,\n+\t\t     in fact, in memory we must always load using the size\n+\t\t     assumed to be in the register and let the insn do the\n+\t\t     different-sized accesses.  */\n+\t\t  || ((GET_CODE (operand) == MEM\n+\t\t       || (GET_CODE (operand)== REG\n+\t\t\t   && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n \t\t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t\t      && GET_MODE_SIZE (GET_MODE (operand)) <= UNITS_PER_WORD)\n+\t\t      && GET_MODE_SIZE (GET_MODE (operand)) <= UNITS_PER_WORD\n+\t\t      && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t  != GET_MODE_SIZE (GET_MODE (operand))))\n #endif\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n \t\t     or which would handle that mode in the wrong number of\n \t\t     registers for subregging to work.  */\n-\t\t  || (REGNO (operand) < FIRST_PSEUDO_REGISTER\n+\t\t  || (GET_CODE (operand) == REG\n+\t\t      && REGNO (operand) < FIRST_PSEUDO_REGISTER\n \t\t      && ((GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n \t\t\t   && (GET_MODE_SIZE (GET_MODE (operand))\n \t\t\t       > UNITS_PER_WORD)"}]}