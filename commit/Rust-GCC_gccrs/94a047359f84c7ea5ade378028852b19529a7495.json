{"sha": "94a047359f84c7ea5ade378028852b19529a7495", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRhMDQ3MzU5Zjg0YzdlYTVhZGUzNzgwMjg4NTJiMTk1MjlhNzQ5NQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-08-27T17:19:54Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-08-27T17:19:54Z"}, "message": "Fix float128-call.c test for power8 IEEE 128 and power10.\n\nI built a compiler on a little endian power8 system where the default long\ndouble was IEEE 128-bit instead of IBM 128-bit.  I discovered that on\npower8, we would generate a lxvd2x and xxpermdi to deal with the endianess\ninstead of the Altivec lxv.\n\nIn addition, I noticed the constant that was being loaded (1.0q) could be\nloaded by the lxvkq instruction.\n\nI rewrote the test to handle all forms of vector load and store that can\nbe generated.\n\n2021-08-27  Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/testsuite/\n\t* gcc.target/powerpc/float128-call.c: Fix test for IEEE 128-bit\n\tlong double and power10.", "tree": {"sha": "843072ecf397fb3c8e11f648441c52637c29503f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/843072ecf397fb3c8e11f648441c52637c29503f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94a047359f84c7ea5ade378028852b19529a7495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a047359f84c7ea5ade378028852b19529a7495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a047359f84c7ea5ade378028852b19529a7495", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a047359f84c7ea5ade378028852b19529a7495/comments", "author": null, "committer": null, "parents": [{"sha": "66526c6a1c01b6110eaeda94ecc885177c636605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66526c6a1c01b6110eaeda94ecc885177c636605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66526c6a1c01b6110eaeda94ecc885177c636605"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "44b242b5dc6399d9f7d512d2f54fc9a0a9c8c6e5", "filename": "gcc/testsuite/gcc.target/powerpc/float128-call.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a047359f84c7ea5ade378028852b19529a7495/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a047359f84c7ea5ade378028852b19529a7495/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c?ref=94a047359f84c7ea5ade378028852b19529a7495", "patch": "@@ -6,22 +6,33 @@\n #error \"-mfloat128 is not supported.\"\n #endif\n \n+/* Pick a constant to load that cannot be generated by the power10 lxvkq\n+   instruction.  */\n #ifdef __LONG_DOUBLE_IEEE128__\n #define TYPE long double\n-#define ONE  1.0L\n+#define TEN  10.0L\n \n #else\n #define TYPE __float128\n-#define ONE  1.0Q\n+#define TEN  10.0Q\n #endif\n \n /* Test to make sure vector registers are used for passing IEEE 128-bit\n    floating point values and returning them. Also make sure the 'q' suffix is\n-   handled.  */\n-TYPE one (void) { return ONE; }\n+   handled for __float128.  */\n+TYPE one (void) { return TEN; }\n void store (TYPE a, TYPE *p) { *p = a; }\n \n-/* { dg-final { scan-assembler {\\mlxvd2x 34\\M} {target be} } } */\n-/* { dg-final { scan-assembler {\\mstxvd2x 34\\M} {target be} } } */\n-/* { dg-final { scan-assembler {\\mlvx 2\\M} {target le} } }  */\n-/* { dg-final { scan-assembler {\\mstvx 2\\M} {target le} } } */\n+/* This regexp captures the different vector load/stores that can be generated:\n+\n+\tlxvd2x\t-- big endian power7/power8, little endian power8\n+\tlvx\t-- Altivec\n+\tlxv\t-- power9\n+\tplxv\t-- power10\n+\tlxvx\t-- X-form variant.\n+\tstxvd2x\t-- big endian power7/power8, little endian power8\n+\tstvx\t-- Altivec\n+\tstxvx\t-- power9/power10.  */\n+\n+/* { dg-final { scan-assembler {\\mlxvd2x 34\\M|\\mlvx 2\\M|\\mp?lxvx? 34\\M} } } */\n+/* { dg-final { scan-assembler {\\mstxvd2x 34\\M|\\mstvx 2\\M|\\mstxvx 34\\M} } } */"}]}