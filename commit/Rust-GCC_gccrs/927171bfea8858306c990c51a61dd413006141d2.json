{"sha": "927171bfea8858306c990c51a61dd413006141d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3MTcxYmZlYTg4NTgzMDZjOTkwYzUxYTYxZGQ0MTMwMDYxNDFkMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T08:12:11Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T08:12:11Z"}, "message": "re PR fortran/33566 (fortran : wrong rank of derived type parameters array components)\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33566\n\t* primary.c (gfc_match_rvalue): Make all expressions with array\n\treferences to structure parameters into variable expressions.\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33566\n\t* gfortran.dg/derived_comp_array_ref_5.f90: New test.\n\nFrom-SVN: r128951", "tree": {"sha": "409ec613fdef50ca2d2baae1ac3e2c1c7c53f2d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/409ec613fdef50ca2d2baae1ac3e2c1c7c53f2d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/927171bfea8858306c990c51a61dd413006141d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927171bfea8858306c990c51a61dd413006141d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927171bfea8858306c990c51a61dd413006141d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927171bfea8858306c990c51a61dd413006141d2/comments", "author": null, "committer": null, "parents": [{"sha": "d383707213c835c7f50ad778229e2428fa402863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d383707213c835c7f50ad778229e2428fa402863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d383707213c835c7f50ad778229e2428fa402863"}], "stats": {"total": 60, "additions": 53, "deletions": 7}, "files": [{"sha": "49dec96c757d5de329364e64a8a277e810ce8918", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=927171bfea8858306c990c51a61dd413006141d2", "patch": "@@ -1,3 +1,9 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33566\n+\t* primary.c (gfc_match_rvalue): Make all expressions with array\n+\treferences to structure parameters into variable expressions.\n+\n 2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33554"}, {"sha": "d5e4b64d26ed32ec1f26e96a77562d113551bc18", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=927171bfea8858306c990c51a61dd413006141d2", "patch": "@@ -2148,18 +2148,17 @@ gfc_match_rvalue (gfc_expr **result)\n       if (sym->ts.is_c_interop || sym->ts.is_iso_c)\n \tbreak;\n \n-      /* Variable array references to use associated derived type\n-\t parameters cause all sorts of headaches in simplification.\n-\t For this reason, we write the parameter to the module and\n-\t treat them as variable references.  */  \n-      if (sym->value && sym->ts.type == BT_DERIVED\n-\t    && sym->attr.use_assoc && e->ref)\n+      /* Variable array references to derived type parameters cause\n+\t all sorts of headaches in simplification. Treating such\n+\t expressions as variable works just fine for all array\n+\t references.  */\n+      if (sym->value && sym->ts.type == BT_DERIVED && e->ref)\n \t{\n \t  for (ref = e->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_ARRAY)\n \t      break;\n \n-\t  if (ref == NULL)\n+\t  if (ref == NULL || ref->u.ar.type == AR_FULL)\n \t    break;\n \n \t  ref = e->ref;"}, {"sha": "cb8dabb126cea501a91cf1692f8a80eab13e36fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=927171bfea8858306c990c51a61dd413006141d2", "patch": "@@ -1,3 +1,8 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33566\n+\t* gfortran.dg/derived_comp_array_ref_5.f90: New test.\n+\n 2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33554"}, {"sha": "3b0c279441f4fd63c8857b86115fff11a114d276", "filename": "gcc/testsuite/gfortran.dg/derived_comp_array_ref_5.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927171bfea8858306c990c51a61dd413006141d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_5.f90?ref=927171bfea8858306c990c51a61dd413006141d2", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! Tests the fix for PR33566, in which the first variable array ref\n+! to v1 would cause an incompatible ranks error and the second an ICE.\n+!\n+! Contributed by Mikael Morin <mikael.morin@tele2.fr>\n+!\n+      program test_vec\n+\n+      implicit none\n+\n+\n+      integer :: i\n+      real    :: x\n+\n+      type vec3\n+        real, dimension(3) :: coords\n+      end type vec3\n+\n+      type(vec3),parameter :: v1 = vec3((/ 1.0, 2.0, 3.0 /))\n+      type(vec3)           :: v2\n+\n+      v2 = vec3((/ 1.0, 2.0, 3.0 /))\n+\n+\n+      x = v1%coords(1)\n+\n+      do i=1,3\n+        x = v1%coords(i)  ! used to fail\n+        x = v2%coords(i)\n+      end do\n+\n+      i = 2\n+\n+      v2 = vec3 (v1%coords ((/i+1, i, i-1/))) ! also broken\n+\n+      end program test_vec"}]}