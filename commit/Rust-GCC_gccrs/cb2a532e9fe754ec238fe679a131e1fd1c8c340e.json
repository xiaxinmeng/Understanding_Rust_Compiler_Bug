{"sha": "cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyYTUzMmU5ZmU3NTRlYzIzOGZlNjc5YTEzMWUxZmQxYzhjMzQwZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-06-18T01:35:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-06-18T01:35:47Z"}, "message": "simd-1.c: New.\n\n\n2002-06-16  Aldy Hernandez  <aldyh@redhat.com>\n\n\t* gcc.c-torture/execute/simd-1.c: New.\n\n\t* gcc.dg/simd-1.c: New.\n\n\t* doc/extend.texi (Vector Extensions): Document that we can\n\tspecify simd types not specifically supported by the hardware.\n\tDocument that simd types can be used as function arguments.\n\tDocument that signness does make a difference in SIMD types.\n\tMisc cleanups and revisions to the \"vector extensions\" section.\n\n\t* simplify-rtx.c (simplify_subreg): Simplify subregs of vector\n\tconstants.\n\n\t* expr.c (vector_mode_valid_p): New.\n\n\t* expr.h: Add vector_mode_valid_p.\n\n\t* defaults.h (VECTOR_MODE_SUPPORTED_P): Set default.\n\n\t* emit-rtl.c (immed_double_const): Do not abort on vectors.\n\n\t* c-common.c (type_for_mode): Always build vector nodes regardless\n\tof VECTOR_MODE_SUPPORTED_P.\n\t(handle_mode_attribute): Error if we can't emulate a nonexisting\n\tvector mode.\n\t(handle_vector_size_attribute): Same.\n\n\t* optabs.c (expand_binop): Open-code vector operations.\n\t(expand_unop): Open-code vector unops.\n\t(expand_vector_binop): New.\n\t(expand_vector_unop): New.\n\n\t* c-typeck.c (build_binary_op): Allow vectors in binops.\n\tAllow vectors in conditional operatiors.\n\t(build_unary_op): Allow vectors in unary minus.\n\n\t* config/rs6000/rs6000.h (ALTIVEC_VECTOR_MODE): Conditionalize on\n\tTARGET_ALTIVEC.\n\nFrom-SVN: r54727", "tree": {"sha": "73deecdababef51a80958fcc5dee4038fb6bac71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73deecdababef51a80958fcc5dee4038fb6bac71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/comments", "author": null, "committer": null, "parents": [{"sha": "147d5f6f769614edda4de1f400fc603496da5170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147d5f6f769614edda4de1f400fc603496da5170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147d5f6f769614edda4de1f400fc603496da5170"}], "stats": {"total": 482, "additions": 417, "deletions": 65}, "files": [{"sha": "b477fe78f165a3553918e95841bfd752d305b58c", "filename": "gcc/c-common.c", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -1602,38 +1602,33 @@ c_common_type_for_mode (mode, unsignedp)\n   if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n     return build_pointer_type (integer_type_node);\n \n-#ifdef VECTOR_MODE_SUPPORTED_P\n-  if (VECTOR_MODE_SUPPORTED_P (mode))\n-    {\n-      switch (mode)\n-\t{\n-\tcase V16QImode:\n-\t  return unsignedp ? unsigned_V16QI_type_node : V16QI_type_node;\n-\tcase V8HImode:\n-\t  return unsignedp ? unsigned_V8HI_type_node : V8HI_type_node;\n-\tcase V4SImode:\n-\t  return unsignedp ? unsigned_V4SI_type_node : V4SI_type_node;\n-\tcase V2DImode:\n-\t  return unsignedp ? unsigned_V2DI_type_node : V2DI_type_node;\n-\tcase V2SImode:\n-\t  return unsignedp ? unsigned_V2SI_type_node : V2SI_type_node;\n-\tcase V4HImode:\n-\t  return unsignedp ? unsigned_V4HI_type_node : V4HI_type_node;\n-\tcase V8QImode:\n-\t  return unsignedp ? unsigned_V8QI_type_node : V8QI_type_node;\n-\tcase V16SFmode:\n-\t  return V16SF_type_node;\n-\tcase V4SFmode:\n-\t  return V4SF_type_node;\n-\tcase V2SFmode:\n-\t  return V2SF_type_node;\n-\tcase V2DFmode:\n-\t  return V2DF_type_node;\n-\tdefault:\n-\t  break;\n-\t}\n+  switch (mode)\n+    {\n+    case V16QImode:\n+      return unsignedp ? unsigned_V16QI_type_node : V16QI_type_node;\n+    case V8HImode:\n+      return unsignedp ? unsigned_V8HI_type_node : V8HI_type_node;\n+    case V4SImode:\n+      return unsignedp ? unsigned_V4SI_type_node : V4SI_type_node;\n+    case V2DImode:\n+      return unsignedp ? unsigned_V2DI_type_node : V2DI_type_node;\n+    case V2SImode:\n+      return unsignedp ? unsigned_V2SI_type_node : V2SI_type_node;\n+    case V4HImode:\n+      return unsignedp ? unsigned_V4HI_type_node : V4HI_type_node;\n+    case V8QImode:\n+      return unsignedp ? unsigned_V8QI_type_node : V8QI_type_node;\n+    case V16SFmode:\n+      return V16SF_type_node;\n+    case V4SFmode:\n+      return V4SF_type_node;\n+    case V2SFmode:\n+      return V2SF_type_node;\n+    case V2DFmode:\n+      return V2DF_type_node;\n+    default:\n+      break;\n     }\n-#endif\n \n   return 0;\n }\n@@ -5058,8 +5053,20 @@ handle_mode_attribute (node, name, args, flags, no_add_attrs)\n \t\t     (mode, TREE_UNSIGNED (type))))\n \terror (\"no data type for mode `%s'\", p);\n       else\n-\t*node = typefm;\n-        /* No need to layout the type here.  The caller should do this.  */\n+\t{\n+\t  /* If this is a vector, make sure we either have hardware\n+\t     support, or we can emulate it.  */\n+\t  if ((GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+\t       || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t      && !vector_mode_valid_p (mode))\n+\t    {\n+\t      error (\"unable to emulate '%s'\", GET_MODE_NAME (mode));\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  *node = typefm;\n+\t  /* No need to layout the type here.  The caller should do this.  */\n+\t}\n     }\n \n   return NULL_TREE;\n@@ -5604,6 +5611,16 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n \n       new_type = build_type_copy (new_type);\n \n+      /* If this is a vector, make sure we either have hardware\n+         support, or we can emulate it.  */\n+      if ((GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+\t   || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t  && !vector_mode_valid_p (mode))\n+\t{\n+\t  error (\"unable to emulate '%s'\", GET_MODE_NAME (mode));\n+\t  return NULL_TREE;\n+\t}\n+\n       /* Set the debug information here, because this is the only\n \t place where we know the underlying type for a vector made\n \t with vector_size.  For debugging purposes we pretend a vector"}, {"sha": "d26f87780f31f854c33f7e0614ebab3ad8d613a8", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -2046,9 +2046,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \twarning (\"division by zero\");\n \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n-\t   || code0 == COMPLEX_TYPE)\n+\t   || code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t      || code1 == COMPLEX_TYPE))\n+\t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n@@ -2197,9 +2197,11 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t but don't convert the args to int!  */\n       build_type = integer_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n-\t   || code0 == COMPLEX_TYPE)\n+\t   || code0 == COMPLEX_TYPE\n+\t   || code0 == VECTOR_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t      || code1 == COMPLEX_TYPE))\n+\t      || code1 == COMPLEX_TYPE\n+\t      || code1 == VECTOR_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -2342,9 +2344,11 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       break;\n     }\n \n-  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n+       || code0 == VECTOR_TYPE)\n       &&\n-      (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n+      (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n+       || code1 == VECTOR_TYPE))\n     {\n       int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n \n@@ -2763,7 +2767,8 @@ build_unary_op (code, xarg, flag)\n \n     case NEGATE_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n-\t    || typecode == COMPLEX_TYPE))\n+\t    || typecode == COMPLEX_TYPE\n+\t    || typecode == VECTOR_TYPE))\n \t{\n \t  error (\"wrong type argument to unary minus\");\n \t  return error_mark_node;\n@@ -4079,7 +4084,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n   else if ((codel == INTEGER_TYPE || codel == REAL_TYPE \n \t    || codel == ENUMERAL_TYPE || codel == COMPLEX_TYPE\n \t    || codel == BOOLEAN_TYPE)\n-\t   && (coder == INTEGER_TYPE || coder == REAL_TYPE \n+\t   && (coder == INTEGER_TYPE || coder == REAL_TYPE\n \t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE\n \t       || coder == BOOLEAN_TYPE))\n     return convert_and_check (type, rhs);"}, {"sha": "91aca6c5d51af67c71731b07dd197357a7608ab2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -817,10 +817,11 @@ extern int rs6000_default_long_calls;\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n #define ALTIVEC_VECTOR_MODE(MODE)\t\\\n-\t((MODE) == V16QImode\t\t\\\n-\t || (MODE) == V8HImode\t\t\\\n-\t || (MODE) == V4SFmode\t\t\\\n-\t || (MODE) == V4SImode)\n+        (TARGET_ALTIVEC &&\t\t\\\n+\t ((MODE) == V16QImode\t\t\\\n+\t  || (MODE) == V8HImode\t\t\\\n+\t  || (MODE) == V4SFmode\t\t\\\n+\t  || (MODE) == V4SImode))\n \n /* Define this macro to be nonzero if the port is prepared to handle\n    insns involving vector mode MODE.  At the very least, it must have"}, {"sha": "3bbf231c2f07d94d7bb531003327bb6183d9563c", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -513,6 +513,10 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \"text.unlikely\"\n #endif\n \n+#ifndef VECTOR_MODE_SUPPORTED_P\n+#define VECTOR_MODE_SUPPORTED_P(MODE) 0\n+#endif\n+\n /* Determine whether __cxa_atexit, rather than atexit, is used to\n    register C++ destructors for local statics and global objects. */\n #ifndef DEFAULT_USE_CXA_ATEXIT"}, {"sha": "1da05ad423d1f25db8e2e0f1a19b018cf262935c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -4373,28 +4373,52 @@ A floating point value, as wide as a SI mode integer, usually 32 bits.\n A floating point value, as wide as a DI mode integer, usually 64 bits.\n @end table\n \n-Not all base types or combinations are always valid; which modes can be used\n-is determined by the target machine.  For example, if targetting the i386 MMX\n-extensions, only @code{V8QI}, @code{V4HI} and @code{V2SI} are allowed modes.\n-\n There are no @code{V1xx} vector modes - they would be identical to the\n corresponding base mode.\n \n-There is no distinction between signed and unsigned vector modes.  This\n-distinction is made by the operations that perform on the vectors, not\n-by the data type.\n-\n-The types defined in this manner are somewhat special, they cannot be\n-used with most normal C operations (i.e., a vector addition can @emph{not}\n-be represented by a normal addition of two vector type variables).  You\n-can declare only variables and use them in function calls and returns, as\n-well as in assignments and some casts.  It is possible to cast from one\n-vector type to another, provided they are of the same size (in fact, you\n-can also cast vectors to and from other datatypes of the same size).\n-\n-A port that supports vector operations provides a set of built-in functions\n-that can be used to operate on vectors.  For example, a function to add two\n-vectors and multiply the result by a third could look like this:\n+Specifying a combination that is not valid for the current architecture\n+will cause gcc to synthesize the instructions using a narrower mode.\n+For example, if you specify a variable of type @code{V4SI} and your\n+architecture does not allow for this specific SIMD type, gcc will\n+produce code that uses 4 @code{SIs}.\n+\n+The types defined in this manner can be used with a subset of normal C\n+operations.  Currently, gcc will allow using the following operators on\n+these types: @code{+, -, *, /, unary minus}@.\n+\n+The operations behave like C++ @code{valarrays}.  Addition is defined as\n+the addition of the corresponding elements of the operands.  For\n+example, in the code below, each of the 4 elements in @var{a} will be\n+added to the corresponding 4 elements in @var{b} and the resulting\n+vector will be stored in @var{c}.\n+\n+@example\n+typedef int v4si __attribute__ ((mode(V4SI)));\n+\n+v4si a, b, c;\n+\n+c = a + b;\n+@end example\n+\n+Subtraction, multiplication, and division operate in a similar manner.\n+Likewise, the result of using the unary minus operator on a vector type\n+is a vector whose elements are the negative value of the corresponding\n+elements in the operand.\n+\n+You can declare variables and use them in function calls and returns, as\n+well as in assignments and some casts.  You can specify a vector type as\n+a return type for a function.  Vector types can also be used as function\n+arguments.  It is possible to cast from one vector type to another,\n+provided they are of the same size (in fact, you can also cast vectors\n+to and from other datatypes of the same size).\n+\n+You cannot operate between vectors of different lengths or different\n+signness without a cast.\n+\n+A port that supports hardware vector operations, usually provides a set\n+of built-in functions that can be used to operate on vectors.  For\n+example, a function to add two vectors and multiply the result by a\n+third could look like this:\n \n @example\n v4si f (v4si a, v4si b, v4si c)"}, {"sha": "77697aef7e4697fc3201b47a9922502da9f7db4d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -421,7 +421,10 @@ immed_double_const (i0, i1, mode)\n     {\n       int width;\n       if (GET_MODE_CLASS (mode) != MODE_INT\n-\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n+\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT\n+\t  /* We can get a 0 for an error mark.  */\n+\t  && GET_MODE_CLASS (mode) != MODE_VECTOR_INT\n+\t  && GET_MODE_CLASS (mode) != MODE_VECTOR_FLOAT)\n \tabort ();\n \n       /* We clear out all bits that don't belong in MODE, unless they and"}, {"sha": "779bf8797559effda71d78f27a8666b630b83f9c", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -10791,4 +10791,34 @@ try_tablejump (index_type, index_expr, minval, range,\n   return 1;\n }\n \n+/* Nonzero if the mode is a valid vector mode for this architecture.\n+   This returns nonzero even if there is no hardware support for the\n+   vector mode, but we can emulate with narrower modes.  */\n+\n+int\n+vector_mode_valid_p (mode)\n+     enum machine_mode mode;\n+{\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum machine_mode innermode;\n+\n+  /* Doh!  What's going on?  */\n+  if (class != MODE_VECTOR_INT\n+      && class != MODE_VECTOR_FLOAT)\n+    return 0;\n+\n+  /* Hardware support.  Woo hoo!  */\n+  if (VECTOR_MODE_SUPPORTED_P (mode))\n+    return 1;\n+\n+  innermode = GET_MODE_INNER (mode);\n+\n+  /* We should probably return 1 if requesting V4DI and we have no DI,\n+     but we have V2DI, but this is probably very unlikely.  */\n+\n+  /* If we have support for the inner mode, we can safely emulate it.\n+     We may not have V2DI, but me can emulate with a pair of DIs.  */\n+  return mov_optab->handlers[innermode].insn_code != CODE_FOR_nothing;\n+}\n+\n #include \"gt-expr.h\""}, {"sha": "b829d9b638191882fa3f6d4df400c9c23d0767f8", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -786,3 +786,5 @@ extern void do_jump_by_parts_greater_rtx\tPARAMS ((enum machine_mode,\n extern void mark_seen_cases\t\t\tPARAMS ((tree, unsigned char *,\n \t\t\t\t\t\t\t HOST_WIDE_INT, int));\n #endif\n+\n+extern int vector_mode_valid_p\t\tPARAMS ((enum machine_mode));"}, {"sha": "61990e3eb08799cddee8ea5cf3a9cc5f879c07d7", "filename": "gcc/optabs.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -120,6 +120,11 @@ static void emit_cmp_and_jump_insn_1 PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t    enum rtx_code, int, rtx));\n static void prepare_float_lib_cmp PARAMS ((rtx *, rtx *, enum rtx_code *,\n \t\t\t\t\t enum machine_mode *, int *));\n+static rtx expand_vector_binop PARAMS ((enum machine_mode, optab,\n+\t\t\t\t\trtx, rtx, rtx, int,\n+\t\t\t\t\tenum optab_methods));\n+static rtx expand_vector_unop PARAMS ((enum machine_mode, optab, rtx, rtx,\n+\t\t\t\t       int));\n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n@@ -1531,6 +1536,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       delete_insns_since (last);\n     }\n \n+  /* Open-code the vector operations if we have no hardware support\n+     for them.  */\n+  if (class == MODE_VECTOR_INT || class == MODE_VECTOR_FLOAT)\n+    return expand_vector_binop (mode, binoptab, op0, op1, target,\n+\t\t\t\tunsignedp, methods);\n+\n   /* We need to open-code the complex type operations: '+, -, * and /' */\n \n   /* At this point we allow operations between two similar complex\n@@ -1900,6 +1911,125 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   delete_insns_since (entry_last);\n   return 0;\n }\n+\n+/* Like expand_binop, but for open-coding vectors binops.  */\n+\n+static rtx\n+expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n+     enum machine_mode mode;\n+     optab binoptab;\n+     rtx op0, op1;\n+     rtx target;\n+     int unsignedp;\n+     enum optab_methods methods;\n+{\n+  enum machine_mode submode;\n+  int elts, i;\n+  rtx t, a, b, res, seq;\n+  enum mode_class class;\n+\n+  class = GET_MODE_CLASS (mode);\n+\n+  submode = GET_MODE_INNER (mode);\n+  elts = GET_MODE_NUNITS (mode);\n+\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  start_sequence ();\n+\n+  /* FIXME: Optimally, we should try to do this in narrower vector\n+     modes if available.  E.g. When trying V8SI, try V4SI, else\n+     V2SI, else decay into SI.  */\n+\n+  switch (binoptab->code)\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      for (i = 0; i < elts; ++i)\n+\t{\n+\t  t = simplify_gen_subreg (submode, target, mode,\n+\t\t\t\t   i * UNITS_PER_WORD);\n+\t  a = simplify_gen_subreg (submode, op0, mode,\n+\t\t\t\t   i * UNITS_PER_WORD);\n+\t  b = simplify_gen_subreg (submode, op1, mode,\n+\t\t\t\t   i * UNITS_PER_WORD);\n+\n+\t  if (binoptab->code == DIV)\n+\t    {\n+\t      if (class == MODE_VECTOR_FLOAT)\n+\t\tres = expand_binop (submode, binoptab, a, b, t,\n+\t\t\t\t    unsignedp, methods);\n+\t      else\n+\t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n+\t\t\t\t     a, b, t, unsignedp);\n+\t    }\n+\t  else\n+\t    res = expand_binop (submode, binoptab, a, b, t,\n+\t\t\t\tunsignedp, methods);\n+\n+\t  if (res == 0)\n+\t    break;\n+\n+\t  emit_move_insn (t, res);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+\n+  return target;\n+}\n+\n+/* Like expand_unop but for open-coding vector unops.  */\n+\n+static rtx\n+expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n+     enum machine_mode mode;\n+     optab unoptab;\n+     rtx op0;\n+     rtx target;\n+     int unsignedp;\n+{\n+  enum machine_mode submode;\n+  int elts, i;\n+  rtx t, a, res, seq;\n+\n+  submode = GET_MODE_INNER (mode);\n+  elts = GET_MODE_NUNITS (mode);\n+\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  start_sequence ();\n+\n+  /* FIXME: Optimally, we should try to do this in narrower vector\n+     modes if available.  E.g. When trying V8SI, try V4SI, else\n+     V2SI, else decay into SI.  */\n+\n+  for (i = 0; i < elts; ++i)\n+    {\n+      t = simplify_gen_subreg (submode, target, mode, i * UNITS_PER_WORD);\n+      a = simplify_gen_subreg (submode, op0, mode, i * UNITS_PER_WORD);\n+\n+      res = expand_unop (submode, unoptab, a, t, unsignedp);\n+\n+      emit_move_insn (t, res);\n+    }\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn (seq);\n+\n+  return target;\n+}\n \f\n /* Expand a binary operator which has both signed and unsigned forms.\n    UOPTAB is the optab for unsigned operations, and SOPTAB is for\n@@ -2324,6 +2454,9 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       return target;\n     }\n \n+  if (class == MODE_VECTOR_FLOAT || class == MODE_VECTOR_INT)\n+    return expand_vector_unop (mode, unoptab, op0, target, unsignedp);\n+\n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)"}, {"sha": "cdc604336546d121be0006a6ed300b21b8251059", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -2268,6 +2268,24 @@ simplify_subreg (outermode, op, innermode, byte)\n   if (outermode == innermode && !byte)\n     return op;\n \n+  /* Simplify subregs of vector constants.  */\n+  if (GET_CODE (op) == CONST_VECTOR)\n+    {\n+      int offset = byte / UNITS_PER_WORD;\n+      rtx elt;\n+\n+      /* This shouldn't happen, but let's not do anything stupid.  */\n+      if (GET_MODE_INNER (innermode) != outermode)\n+\treturn NULL_RTX;\n+\n+      elt = CONST_VECTOR_ELT (op, offset);\n+\n+      /* ?? We probably don't need this copy_rtx because constants\n+\t can be shared.  ?? */\n+\n+      return copy_rtx (elt);\n+    }\n+\n   /* Attempt to simplify constant to non-SUBREG expression.  */\n   if (CONSTANT_P (op))\n     {"}, {"sha": "cb503e457d844e58231bcd494e5ebc79c75f308a", "filename": "gcc/testsuite/gcc.c-torture/execute/simd-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fsimd-1.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -0,0 +1,54 @@\n+/* Origin: Aldy Hernandez <aldyh@redhat.com>\n+\n+   Purpose: Test generic SIMD support.  This test should work\n+   regardless of if the target has SIMD instructions.\n+*/\n+\n+typedef int __attribute__((mode(V4SI))) vecint;\n+\n+vecint i = { 150, 100, 150, 200 };\n+vecint j = { 10, 13, 20, 30 };\n+vecint k;\n+\n+union {\n+  vecint v;\n+  int i[4];\n+} res;\n+\n+/* This should go away once we can use == and != on vector types.  */\n+void\n+verify (int a1, int a2, int a3, int a4,\n+\tint b1, int b2, int b3, int b4)\n+{\n+  if (a1 != b1\n+      || a2 != b2\n+      || a3 != b3\n+      || a4 != b4)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  k = i + j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 160, 113, 170, 230);\n+\n+  k = i * j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 1500, 1300, 3000, 6000);\n+\n+  k = i / j;\n+  res.v = k;\n+\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3], 15, 7, 7, 6);\n+\n+  k = -i;\n+  res.v = k;\n+  verify (res.i[0], res.i[1], res.i[2], res.i[3],\n+\t  -150, -100, -150, -200);\n+\n+  exit (0);\n+}"}, {"sha": "fff6292d1a0c68062ff634d737eabc9d1bc7d46b", "filename": "gcc/testsuite/gcc.dg/simd-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2a532e9fe754ec238fe679a131e1fd1c8c340e/gcc%2Ftestsuite%2Fgcc.dg%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimd-1.c?ref=cb2a532e9fe754ec238fe679a131e1fd1c8c340e", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+/* Origin: Aldy Hernandez <aldyh@redhat.com>.  */\n+/* Purpose: Program to test generic SIMD support.  */\n+\n+typedef int __attribute__((mode(V4SI))) v4si;\n+typedef int __attribute__((mode(V8HI))) v8hi;\n+typedef int __attribute__((mode(V2SI))) v2si;\n+typedef unsigned int __attribute__((mode(V4SI))) uv4si;\n+\n+v4si a, b;\n+v2si c, d;\n+v8hi e;\n+uv4si f;\n+\n+int foo __attribute__((mode(DI)));\n+int foo1 __attribute__((mode(SI)));\n+int foo2 __attribute__((mode(V4HI)));\n+\n+void\n+hanneke ()\n+{\n+  /* Assignment.  */\n+  a = b;\n+\n+  /* Assignment of different types.  */\n+  b = c; /* { dg-error \"incompatible types in assignment\" } */\n+  d = a; /* { dg-error \"incompatible types in assignment\" } */\n+\n+  /* Casting between SIMDs of the same size.  */\n+  e = (typeof (e)) a;\n+\n+  /* Different signed SIMD assignment.  */\n+  f = a; /* { dg-error \"incompatible types in assignment\" } */\n+\n+  /* Casted different signed SIMD assignment.  */\n+  f = (uv4si) a;\n+\n+  /* Assignment between scalar and SIMD of different size.  */\n+  foo = a; /* { dg-error \"incompatible types in assignment\" } */\n+\n+  /* Casted assignment between scalar and SIMD of same size.  */\n+  foo = (typeof (foo)) foo2;\n+\n+  /* Casted assignment between scalar and SIMD of different size.  */\n+  foo1 = (typeof (foo1)) foo2; /* { dg-error \"can't convert between vector values of different size\" } */\n+\n+  /* Operators on compatible SIMD types.  */\n+  a += b + b;\n+  a -= b;\n+  a *= b;\n+  a /= b;\n+  a = -b;\n+\n+  /* Operators on incompatible SIMD types.  */\n+  a = b + c; /* { dg-error \"can't convert between vector values of different size\" } */\n+  a = b - c; /* { dg-error \"can't convert between vector values of different size\" } */\n+  a = b * c; /* { dg-error \"can't convert between vector values of different size\" } */\n+  a = b / c; /* { dg-error \"can't convert between vector values of different size\" } */\n+}"}]}