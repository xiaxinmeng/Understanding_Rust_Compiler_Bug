{"sha": "26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZkYTc5ZjVkMTAyNDA0ZWRmYmJkZjRiOGZlNWViY2RjMzNjMzhmMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-11-20T19:51:53Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-11-20T19:51:53Z"}, "message": "vec.h (class vec_prefix): Change into struct.\n\n\t* vec.h (class vec_prefix): Change into struct.\n\tRename field alloc_PRIVATE_ back to alloc_.\n\tRename field num_PRIVATE_ to num_.\n\tUpdate all users.\n\t(class vec<T, A, vl_embed>): Rename field pfx_PRIVATE_ to vecpfx_.\n\tRename field data_PRIVATE_ to vecdata_.\n\tUpdate all users.\n\t(class vec<T, A, vl_ptr>): Make every field public.\n\tRename field vec_PRIVATE_ back to vec_.\n\tUpdate all users.\n\nFrom-SVN: r193675", "tree": {"sha": "e25061f9178c7c00c5930ed9b45323f527a4da79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e25061f9178c7c00c5930ed9b45323f527a4da79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e98fc6de681cb80aa973b349a3e6b477fcbf8a02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98fc6de681cb80aa973b349a3e6b477fcbf8a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98fc6de681cb80aa973b349a3e6b477fcbf8a02"}], "stats": {"total": 219, "additions": 118, "deletions": 101}, "files": [{"sha": "02781ba37191d609a2126a13d230070f0bcf5cbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "patch": "@@ -1,3 +1,16 @@\n+2012-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* vec.h (class vec_prefix): Change into struct.\n+\tRename field alloc_PRIVATE_ back to alloc_.\n+\tRename field num_PRIVATE_ to num_.\n+\tUpdate all users.\n+\t(class vec<T, A, vl_embed>): Rename field pfx_PRIVATE_ to vecpfx_.\n+\tRename field data_PRIVATE_ to vecdata_.\n+\tUpdate all users.\n+\t(class vec<T, A, vl_ptr>): Make every field public.\n+\tRename field vec_PRIVATE_ back to vec_.\n+\tUpdate all users.\n+\n 2012-11-20  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR middle-end/55403"}, {"sha": "28ca74f8374132d63cee97dcaf2583bb89e6273d", "filename": "gcc/vec.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "patch": "@@ -121,8 +121,8 @@ vec_descriptor (const char *name, int line, const char *function)\n /* Account the overhead.  */\n \n void\n-vec_prefix::register_overhead_PRIVATE_ (size_t size, const char *name, int line,\n-\t\t\t                const char *function)\n+vec_prefix::register_overhead (size_t size, const char *name, int line,\n+\t\t\t       const char *function)\n {\n   struct vec_descriptor *loc = vec_descriptor (name, line, function);\n   struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n@@ -148,7 +148,7 @@ vec_prefix::register_overhead_PRIVATE_ (size_t size, const char *name, int line,\n /* Notice that the memory allocated for the vector has been freed.  */\n \n void\n-vec_prefix::release_overhead_PRIVATE_ (void)\n+vec_prefix::release_overhead (void)\n {\n   PTR *slot = htab_find_slot_with_hash (ptr_hash, this,\n \t\t\t\t\thtab_hash_pointer (this),\n@@ -165,16 +165,16 @@ vec_prefix::release_overhead_PRIVATE_ (void)\n    exponentially.  PFX is the control data for the vector.  */\n \n unsigned\n-vec_prefix::calculate_allocation_PRIVATE_ (vec_prefix *pfx, unsigned reserve,\n-\t\t\t\t\t   bool exact)\n+vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve,\n+\t\t\t\t  bool exact)\n {\n   unsigned alloc = 0;\n   unsigned num = 0;\n \n   if (pfx)\n     {\n-      alloc = pfx->alloc_PRIVATE_;\n-      num = pfx->num_PRIVATE_;\n+      alloc = pfx->alloc_;\n+      num = pfx->num_;\n     }\n   else if (!reserve)\n     /* If there's no vector, and we've not requested anything, then we"}, {"sha": "b8e6270149fff5a356be97e096a1913d653f824c", "filename": "gcc/vec.h", "status": "modified", "additions": 98, "deletions": 94, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=26da79f5d102404edfbbdf4b8fe5ebcdc33c38f1", "patch": "@@ -214,15 +214,15 @@ extern void dump_vec_loc_statistics (void);\n /* Control data for vectors.  This contains the number of allocated\n    and used slots inside a vector.  */\n \n-class vec_prefix\n+struct vec_prefix\n {\n   /* FIXME - These fields should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-public:\n+\n   /* Memory allocation support routines in vec.c.  */\n-  void register_overhead_PRIVATE_ (size_t, const char *, int, const char *);\n-  void release_overhead_PRIVATE_ (void);\n-  static unsigned calculate_allocation_PRIVATE_ (vec_prefix *, unsigned, bool);\n+  void register_overhead (size_t, const char *, int, const char *);\n+  void release_overhead (void);\n+  static unsigned calculate_allocation (vec_prefix *, unsigned, bool);\n \n   /* Note that vec_prefix should be a base class for vec, but we use\n      offsetof() on vector fields of tree structures (e.g.,\n@@ -238,8 +238,8 @@ class vec_prefix\n   friend struct va_heap;\n   friend struct va_stack;\n \n-  unsigned alloc_PRIVATE_;\n-  unsigned num_PRIVATE_;\n+  unsigned alloc_;\n+  unsigned num_;\n };\n \n template<typename, typename, typename> class vec;\n@@ -287,24 +287,24 @@ inline void\n va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n \t\t  MEM_STAT_DECL)\n {\n-  unsigned alloc = vec_prefix::calculate_allocation_PRIVATE_ (\n-\t  v ? &v->pfx_PRIVATE_ : 0, reserve, exact);\n+  unsigned alloc\n+    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);\n   if (!alloc)\n     {\n       release (v);\n       return;\n     }\n \n   if (GATHER_STATISTICS && v)\n-    v->pfx_PRIVATE_.release_overhead_PRIVATE_ ();\n+    v->vecpfx_.release_overhead ();\n \n   size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);\n   unsigned nelem = v ? v->length () : 0;\n   v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));\n   v->embedded_init (alloc, nelem);\n \n   if (GATHER_STATISTICS)\n-    v->pfx_PRIVATE_.register_overhead_PRIVATE_ (size FINAL_PASS_MEM_STAT);\n+    v->vecpfx_.register_overhead (size FINAL_PASS_MEM_STAT);\n }\n \n \n@@ -318,7 +318,7 @@ va_heap::release (vec<T, va_heap, vl_embed> *&v)\n     return;\n \n   if (GATHER_STATISTICS)\n-    v->pfx_PRIVATE_.release_overhead_PRIVATE_ ();\n+    v->vecpfx_.release_overhead ();\n   ::free (v);\n   v = NULL;\n }\n@@ -354,8 +354,8 @@ void\n va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact\n \t\tMEM_STAT_DECL)\n {\n-  unsigned alloc = vec_prefix::calculate_allocation_PRIVATE_ (\n-\t  v ? &v->pfx_PRIVATE_ : 0, reserve, exact);\n+  unsigned alloc\n+    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);\n   if (!alloc)\n     {\n       ::ggc_free (v);\n@@ -423,9 +423,9 @@ void\n va_stack::alloc (vec<T, va_stack, vl_ptr> &v, unsigned nelems,\n \t\t vec<T, va_stack, vl_embed> *space)\n {\n-  v.vec_PRIVATE_ = space;\n-  register_stack_vec (static_cast<void *> (v.vec_PRIVATE_));\n-  v.vec_PRIVATE_->embedded_init (nelems, 0);\n+  v.vec_ = space;\n+  register_stack_vec (static_cast<void *> (v.vec_));\n+  v.vec_->embedded_init (nelems, 0);\n }\n \n \n@@ -452,16 +452,16 @@ va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n     }\n \n   /* Move VEC_ to the heap.  */\n-  nelems += v->pfx_PRIVATE_.num_PRIVATE_;\n+  nelems += v->vecpfx_.num_;\n   vec<T, va_stack, vl_embed> *oldvec = v;\n   v = NULL;\n   va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,\n \t\t    exact);\n   if (v && oldvec)\n     {\n-      v->pfx_PRIVATE_.num_PRIVATE_ = oldvec->length ();\n-      memcpy (v->data_PRIVATE_,\n-\t      oldvec->data_PRIVATE_,\n+      v->vecpfx_.num_ = oldvec->length ();\n+      memcpy (v->vecdata_,\n+\t      oldvec->vecdata_,\n \t      oldvec->length () * sizeof (T));\n     }\n }\n@@ -541,11 +541,11 @@ template<typename T, typename A>\n class GTY((user)) vec<T, A, vl_embed>\n {\n public:\n-  unsigned allocated (void) const { return pfx_PRIVATE_.alloc_PRIVATE_; }\n-  unsigned length (void) const { return pfx_PRIVATE_.num_PRIVATE_; }\n-  bool is_empty (void) const { return pfx_PRIVATE_.num_PRIVATE_ == 0; }\n-  T *address (void) { return data_PRIVATE_; }\n-  const T *address (void) const { return data_PRIVATE_; }\n+  unsigned allocated (void) const { return vecpfx_.alloc_; }\n+  unsigned length (void) const { return vecpfx_.num_; }\n+  bool is_empty (void) const { return vecpfx_.num_ == 0; }\n+  T *address (void) { return vecdata_; }\n+  const T *address (void) const { return vecdata_; }\n   const T &operator[] (unsigned) const;\n   T &operator[] (unsigned);\n   T &last (void);\n@@ -580,8 +580,8 @@ class GTY((user)) vec<T, A, vl_embed>\n \n   /* FIXME - These fields should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-  vec_prefix pfx_PRIVATE_;\n-  T data_PRIVATE_[1];\n+  vec_prefix vecpfx_;\n+  T vecdata_[1];\n };\n \n \n@@ -793,16 +793,16 @@ template<typename T, typename A>\n inline const T &\n vec<T, A, vl_embed>::operator[] (unsigned ix) const\n {\n-  gcc_checking_assert (ix < pfx_PRIVATE_.num_PRIVATE_);\n-  return data_PRIVATE_[ix];\n+  gcc_checking_assert (ix < vecpfx_.num_);\n+  return vecdata_[ix];\n }\n \n template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::operator[] (unsigned ix)\n {\n-  gcc_checking_assert (ix < pfx_PRIVATE_.num_PRIVATE_);\n-  return data_PRIVATE_[ix];\n+  gcc_checking_assert (ix < vecpfx_.num_);\n+  return vecdata_[ix];\n }\n \n \n@@ -812,8 +812,8 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::last (void)\n {\n-  gcc_checking_assert (pfx_PRIVATE_.num_PRIVATE_ > 0);\n-  return (*this)[pfx_PRIVATE_.num_PRIVATE_ - 1];\n+  gcc_checking_assert (vecpfx_.num_ > 0);\n+  return (*this)[vecpfx_.num_ - 1];\n }\n \n \n@@ -827,7 +827,7 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::space (unsigned nelems) const\n {\n-  return pfx_PRIVATE_.alloc_PRIVATE_ - pfx_PRIVATE_.num_PRIVATE_ >= nelems;\n+  return vecpfx_.alloc_ - vecpfx_.num_ >= nelems;\n }\n \n \n@@ -842,9 +842,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const\n {\n-  if (ix < pfx_PRIVATE_.num_PRIVATE_)\n+  if (ix < vecpfx_.num_)\n     {\n-      *ptr = data_PRIVATE_[ix];\n+      *ptr = vecdata_[ix];\n       return true;\n     }\n   else\n@@ -868,9 +868,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T **ptr) const\n {\n-  if (ix < pfx_PRIVATE_.num_PRIVATE_)\n+  if (ix < vecpfx_.num_)\n     {\n-      *ptr = CONST_CAST (T *, &data_PRIVATE_[ix]);\n+      *ptr = CONST_CAST (T *, &vecdata_[ix]);\n       return true;\n     }\n   else\n@@ -893,7 +893,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      memcpy (new_vec->address(), data_PRIVATE_, sizeof (T) * len);\n+      memcpy (new_vec->address(), vecdata_, sizeof (T) * len);\n     }\n   return new_vec;\n }\n@@ -911,7 +911,7 @@ vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> &src)\n     {\n       gcc_checking_assert (space (len));\n       memcpy (address() + length(), src.address(), len * sizeof (T));\n-      pfx_PRIVATE_.num_PRIVATE_ += len;\n+      vecpfx_.num_ += len;\n     }\n }\n \n@@ -933,7 +933,7 @@ inline T *\n vec<T, A, vl_embed>::quick_push (const T &obj)\n {\n   gcc_checking_assert (space (1));\n-  T *slot = &data_PRIVATE_[pfx_PRIVATE_.num_PRIVATE_++];\n+  T *slot = &vecdata_[vecpfx_.num_++];\n   *slot = obj;\n   return slot;\n }\n@@ -946,7 +946,7 @@ inline T &\n vec<T, A, vl_embed>::pop (void)\n {\n   gcc_checking_assert (length () > 0);\n-  return data_PRIVATE_[--pfx_PRIVATE_.num_PRIVATE_];\n+  return vecdata_[--vecpfx_.num_];\n }\n \n \n@@ -958,7 +958,7 @@ inline void\n vec<T, A, vl_embed>::truncate (unsigned size)\n {\n   gcc_checking_assert (length () >= size);\n-  pfx_PRIVATE_.num_PRIVATE_ = size;\n+  vecpfx_.num_ = size;\n }\n \n \n@@ -971,8 +971,8 @@ vec<T, A, vl_embed>::quick_insert (unsigned ix, const T &obj)\n {\n   gcc_checking_assert (length () < allocated ());\n   gcc_checking_assert (ix <= length ());\n-  T *slot = &data_PRIVATE_[ix];\n-  memmove (slot + 1, slot, (pfx_PRIVATE_.num_PRIVATE_++ - ix) * sizeof (T));\n+  T *slot = &vecdata_[ix];\n+  memmove (slot + 1, slot, (vecpfx_.num_++ - ix) * sizeof (T));\n   *slot = obj;\n }\n \n@@ -986,8 +986,8 @@ inline void\n vec<T, A, vl_embed>::ordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length());\n-  T *slot = &data_PRIVATE_[ix];\n-  memmove (slot, slot + 1, (--pfx_PRIVATE_.num_PRIVATE_ - ix) * sizeof (T));\n+  T *slot = &vecdata_[ix];\n+  memmove (slot, slot + 1, (--vecpfx_.num_ - ix) * sizeof (T));\n }\n \n \n@@ -999,7 +999,7 @@ inline void\n vec<T, A, vl_embed>::unordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length());\n-  data_PRIVATE_[ix] = data_PRIVATE_[--pfx_PRIVATE_.num_PRIVATE_];\n+  vecdata_[ix] = vecdata_[--vecpfx_.num_];\n }\n \n \n@@ -1011,9 +1011,9 @@ inline void\n vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)\n {\n   gcc_checking_assert (ix + len <= length());\n-  T *slot = &data_PRIVATE_[ix];\n-  pfx_PRIVATE_.num_PRIVATE_ -= len;\n-  memmove (slot, slot + len, (pfx_PRIVATE_.num_PRIVATE_ - ix) * sizeof (T));\n+  T *slot = &vecdata_[ix];\n+  vecpfx_.num_ -= len;\n+  memmove (slot, slot + len, (vecpfx_.num_ - ix) * sizeof (T));\n }\n \n \n@@ -1077,7 +1077,7 @@ inline size_t\n vec<T, A, vl_embed>::embedded_size (unsigned alloc)\n {\n   typedef vec<T, A, vl_embed> vec_embedded;\n-  return offsetof (vec_embedded, data_PRIVATE_) + alloc * sizeof (T);\n+  return offsetof (vec_embedded, vecdata_) + alloc * sizeof (T);\n }\n \n \n@@ -1088,8 +1088,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)\n {\n-  pfx_PRIVATE_.alloc_PRIVATE_ = alloc;\n-  pfx_PRIVATE_.num_PRIVATE_ = num;\n+  vecpfx_.alloc_ = alloc;\n+  vecpfx_.num_ = num;\n }\n \n \n@@ -1100,8 +1100,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (length () <= len && len <= pfx_PRIVATE_.alloc_PRIVATE_);\n-  pfx_PRIVATE_.num_PRIVATE_ = len;\n+  gcc_checking_assert (length () <= len && len <= vecpfx_.alloc_);\n+  vecpfx_.num_ = len;\n }\n \n \n@@ -1206,22 +1206,22 @@ class vec<T, A, vl_ptr>\n \n   /* Vector operations.  */\n   bool exists (void) const\n-  { return vec_PRIVATE_ != NULL; }\n+  { return vec_ != NULL; }\n \n   bool is_empty (void) const\n-  { return vec_PRIVATE_ ? vec_PRIVATE_->is_empty() : true; }\n+  { return vec_ ? vec_->is_empty() : true; }\n \n   unsigned length (void) const\n-  { return vec_PRIVATE_ ? vec_PRIVATE_->length() : 0; }\n+  { return vec_ ? vec_->length() : 0; }\n \n   T *address (void)\n-  { return vec_PRIVATE_ ? vec_PRIVATE_->data_PRIVATE_ : NULL; }\n+  { return vec_ ? vec_->vecdata_ : NULL; }\n \n   const T *address (void) const\n-  { return vec_PRIVATE_ ? vec_PRIVATE_->data_PRIVATE_ : NULL; }\n+  { return vec_ ? vec_->vecdata_ : NULL; }\n \n   const T &operator[] (unsigned ix) const\n-  { return (*vec_PRIVATE_)[ix]; }\n+  { return (*vec_)[ix]; }\n \n   bool operator!=(const vec &other) const\n   { return !(*this == other); }\n@@ -1230,13 +1230,13 @@ class vec<T, A, vl_ptr>\n   { return address() == other.address(); }\n \n   T &operator[] (unsigned ix)\n-  { return (*vec_PRIVATE_)[ix]; }\n+  { return (*vec_)[ix]; }\n \n   T &last (void)\n-  { return vec_PRIVATE_->last(); }\n+  { return vec_->last(); }\n \n   bool space (int nelems) const\n-  { return vec_PRIVATE_ ? vec_PRIVATE_->space (nelems) : nelems == 0; }\n+  { return vec_ ? vec_->space (nelems) : nelems == 0; }\n \n   bool iterate (unsigned ix, T *p) const;\n   bool iterate (unsigned ix, T **p) const;\n@@ -1267,7 +1267,7 @@ class vec<T, A, vl_ptr>\n \n   /* FIXME - This field should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-  vec<T, A, vl_embed> *vec_PRIVATE_;\n+  vec<T, A, vl_embed> *vec_;\n };\n \n \n@@ -1370,8 +1370,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n {\n-  if (vec_PRIVATE_)\n-    return vec_PRIVATE_->iterate (ix, ptr);\n+  if (vec_)\n+    return vec_->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1393,8 +1393,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const\n {\n-  if (vec_PRIVATE_)\n-    return vec_PRIVATE_->iterate (ix, ptr);\n+  if (vec_)\n+    return vec_->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1434,7 +1434,7 @@ vec<T, A, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n {\n   vec<T, A, vl_ptr> new_vec = vec<T, A, vl_ptr>();\n   if (length ())\n-    new_vec.vec_PRIVATE_ = vec_PRIVATE_->copy ();\n+    new_vec.vec_ = vec_->copy ();\n   return new_vec;\n }\n \n@@ -1454,7 +1454,7 @@ vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n {\n   bool extend = nelems ? !space (nelems) : false;\n   if (extend)\n-    A::reserve (vec_PRIVATE_, nelems, exact PASS_MEM_STAT);\n+    A::reserve (vec_, nelems, exact PASS_MEM_STAT);\n   return extend;\n }\n \n@@ -1481,7 +1481,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n {\n-  vec_PRIVATE_ = NULL;\n+  vec_ = NULL;\n   if (nelems > 0)\n     reserve_exact (nelems PASS_MEM_STAT);\n }\n@@ -1493,8 +1493,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::release (void)\n {\n-  if (vec_PRIVATE_)\n-    A::release (vec_PRIVATE_);\n+  if (vec_)\n+    A::release (vec_);\n }\n \n \n@@ -1507,8 +1507,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)\n {\n-  if (src.vec_PRIVATE_)\n-    vec_PRIVATE_->splice (*(src.vec_PRIVATE_));\n+  if (src.vec_)\n+    vec_->splice (*(src.vec_));\n }\n \n \n@@ -1537,7 +1537,7 @@ template<typename T, typename A>\n inline T *\n vec<T, A, vl_ptr>::quick_push (const T &obj)\n {\n-  return vec_PRIVATE_->quick_push (obj);\n+  return vec_->quick_push (obj);\n }\n \n \n@@ -1560,7 +1560,7 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_ptr>::pop (void)\n {\n-  return vec_PRIVATE_->pop ();\n+  return vec_->pop ();\n }\n \n \n@@ -1571,8 +1571,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::truncate (unsigned size)\n {\n-  if (vec_PRIVATE_)\n-    vec_PRIVATE_->truncate (size);\n+  if (vec_)\n+    vec_->truncate (size);\n   else\n     gcc_checking_assert (size == 0);\n }\n@@ -1589,7 +1589,7 @@ vec<T, A, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n   unsigned oldlen = length ();\n   gcc_checking_assert (oldlen <= len);\n   reserve_exact (len - oldlen PASS_MEM_STAT);\n-  vec_PRIVATE_->quick_grow (len);\n+  vec_->quick_grow (len);\n }\n \n \n@@ -1614,8 +1614,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (vec_PRIVATE_);\n-  vec_PRIVATE_->quick_grow (len);\n+  gcc_checking_assert (vec_);\n+  vec_->quick_grow (len);\n }\n \n \n@@ -1627,8 +1627,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)\n {\n-  gcc_checking_assert (vec_PRIVATE_);\n-  vec_PRIVATE_->quick_grow_cleared (len);\n+  gcc_checking_assert (vec_);\n+  vec_->quick_grow_cleared (len);\n }\n \n \n@@ -1639,7 +1639,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n {\n-  vec_PRIVATE_->quick_insert (ix, obj);\n+  vec_->quick_insert (ix, obj);\n }\n \n \n@@ -1663,7 +1663,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::ordered_remove (unsigned ix)\n {\n-  vec_PRIVATE_->ordered_remove (ix);\n+  vec_->ordered_remove (ix);\n }\n \n \n@@ -1674,7 +1674,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::unordered_remove (unsigned ix)\n {\n-  vec_PRIVATE_->unordered_remove (ix);\n+  vec_->unordered_remove (ix);\n }\n \n \n@@ -1685,7 +1685,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)\n {\n-  vec_PRIVATE_->block_remove (ix, len);\n+  vec_->block_remove (ix, len);\n }\n \n \n@@ -1696,8 +1696,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n {\n-  if (vec_PRIVATE_)\n-    vec_PRIVATE_->qsort (cmp);\n+  if (vec_)\n+    vec_->qsort (cmp);\n }\n \n \n@@ -1711,7 +1711,11 @@ inline unsigned\n vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n     const\n {\n-  return vec_PRIVATE_ ? vec_PRIVATE_->lower_bound (obj, lessthan) : 0;\n+  return vec_ ? vec_->lower_bound (obj, lessthan) : 0;\n }\n \n+#if (GCC_VERSION >= 3000)\n+# pragma GCC poison vec_ vecpfx_ vecdata_\n+#endif\n+\n #endif // GCC_VEC_H"}]}