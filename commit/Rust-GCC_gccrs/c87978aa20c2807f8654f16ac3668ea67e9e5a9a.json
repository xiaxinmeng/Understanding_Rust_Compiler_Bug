{"sha": "c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3OTc4YWEyMGMyODA3Zjg2NTRmMTZhYzM2NjhlYTY3ZTllNWE5YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-05-09T17:27:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-05-09T17:27:37Z"}, "message": "typeck.c (get_member_function_from_ptrfunc): Reorganize.\n\n        * typeck.c (get_member_function_from_ptrfunc): Reorganize.\n        Use subtraction rather than a bitmask to get the index.\n        * cvt.c (cp_convert_to_pointer): Bail on an error_mark_node.\n\n        * pt.c (tsubst_expr) [ASM_STMT]: Copy ASM_INPUT_P.\n\nFrom-SVN: r53335", "tree": {"sha": "8de79106bf22e9d38596fd2528e50ab966541607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8de79106bf22e9d38596fd2528e50ab966541607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff431459927172204c448438bf7de202480a9d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff431459927172204c448438bf7de202480a9d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff431459927172204c448438bf7de202480a9d87"}], "stats": {"total": 135, "additions": 67, "deletions": 68}, "files": [{"sha": "aa6dff611da95baf9633b64e260d55d7527f999f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "patch": "@@ -1,3 +1,11 @@\n+2002-05-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Reorganize.\n+\tUse subtraction rather than a bitmask to get the index.\n+\t* cvt.c (cp_convert_to_pointer): Bail on an error_mark_node.\n+\n+\t* pt.c (tsubst_expr) [ASM_STMT]: Copy ASM_INPUT_P.\n+\n 2002-05-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* Make-lang.in (decl2.o): Update."}, {"sha": "fc57dd3d7446a12f13525e7948a3f959189155c2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "patch": "@@ -130,6 +130,9 @@ cp_convert_to_pointer (type, expr, force)\n       intype = TREE_TYPE (expr);\n     }\n \n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n   form = TREE_CODE (intype);\n \n   if (POINTER_TYPE_P (intype))"}, {"sha": "c4e119e10cb18c216c36b5aeeda11c3e14367b4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "patch": "@@ -7541,12 +7541,13 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case ASM_STMT:\n       prep_stmt (t);\n-      finish_asm_stmt (ASM_CV_QUAL (t),\n-\t\t       tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n-\t\t       tsubst_expr (ASM_OUTPUTS (t), args, complain, in_decl),\n-\t\t       tsubst_expr (ASM_INPUTS (t), args, complain, in_decl), \n-\t\t       tsubst_expr (ASM_CLOBBERS (t), args, complain,\n-\t\t\t\t    in_decl));\n+      tmp = finish_asm_stmt\n+\t(ASM_CV_QUAL (t),\n+\t tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n+\t tsubst_expr (ASM_OUTPUTS (t), args, complain, in_decl),\n+\t tsubst_expr (ASM_INPUTS (t), args, complain, in_decl), \n+\t tsubst_expr (ASM_CLOBBERS (t), args, complain, in_decl));\n+      ASM_INPUT_P (tmp) = ASM_INPUT_P (t);\n       break;\n \n     case TRY_BLOCK:"}, {"sha": "329bc3300ca1a3fd3e1d1c43228924a4f9d4ce2a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87978aa20c2807f8654f16ac3668ea67e9e5a9a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c87978aa20c2807f8654f16ac3668ea67e9e5a9a", "patch": "@@ -2821,7 +2821,14 @@ build_x_function_call (function, params, decl)\n }\n \n /* Resolve a pointer to member function.  INSTANCE is the object\n-   instance to use, if the member points to a virtual member.  */\n+   instance to use, if the member points to a virtual member.\n+\n+   This used to avoid checking for virtual functions if basetype\n+   has no virtual functions, according to an earlier ANSI draft.\n+   With the final ISO C++ rules, such an optimization is\n+   incorrect: A pointer to a derived member can be static_cast\n+   to pointer-to-base-member, as long as the dynamic object\n+   later has the right member. */\n \n tree\n get_member_function_from_ptrfunc (instance_ptrptr, function)\n@@ -2833,21 +2840,26 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n-      tree fntype, idx, e1, delta, delta2, e2, e3, vtbl;\n-      tree instance, basetype;\n-      tree mask;\n+      tree idx, delta, e1, e2, e3, vtbl, basetype;\n+      tree fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n \n       tree instance_ptr = *instance_ptrptr;\n-\n-      if (instance_ptr == error_mark_node\n-\t  && TREE_CODE (function) == PTRMEM_CST)\n+      if (instance_ptr == error_mark_node)\n \t{\n-\t  /* Extracting the function address from a pmf is only\n-\t     allowed with -Wno-pmf-conversions. It only works for\n-\t     pmf constants. */\n-\t  e1 = build_addr_func (PTRMEM_CST_MEMBER (function));\n-\t  e1 = convert (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function)), e1);\n-\t  return e1;\n+\t  if (TREE_CODE (function) == PTRMEM_CST)\n+\t    {\n+\t      /* Extracting the function address from a pmf is only\n+\t\t allowed with -Wno-pmf-conversions. It only works for\n+\t\t pmf constants. */\n+\t      e1 = build_addr_func (PTRMEM_CST_MEMBER (function));\n+\t      e1 = convert (fntype, e1);\n+\t      return e1;\n+\t    }\n+\t  else\n+\t    {\n+\t      error (\"object missing in use of `%E'\", function);\n+\t      return error_mark_node;\n+\t    }\n \t}\n \n       if (TREE_SIDE_EFFECTS (instance_ptr))\n@@ -2856,64 +2868,47 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       if (TREE_SIDE_EFFECTS (function))\n \tfunction = save_expr (function);\n \n-      fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n-      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n-\n-      /* Convert down to the right base, before using the instance. */\n-      instance = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)), basetype,\n-\t\t\t      ba_check, NULL);\n-      instance = build_base_path (PLUS_EXPR, instance_ptr, instance, 1);\n-      if (instance == error_mark_node && instance_ptr != error_mark_node)\n-\treturn instance;\n-\n+      /* Start by extracting all the information from the PMF itself.  */\n       e3 = PFN_FROM_PTRMEMFUNC (function);\n-\n-      vtbl = build1 (NOP_EXPR, build_pointer_type (ptr_type_node), instance);\n-      TREE_CONSTANT (vtbl) = TREE_CONSTANT (instance);\n-      \n-      delta = cp_convert (ptrdiff_type_node,\n-\t\t\t  build_component_ref (function, delta_identifier,\n-\t\t\t\t\t       NULL_TREE, 0));\n-\n-      /* This used to avoid checking for virtual functions if basetype\n-\t has no virtual functions, according to an earlier ANSI draft.\n-\t With the final ISO C++ rules, such an optimization is\n-\t incorrect: A pointer to a derived member can be static_cast\n-\t to pointer-to-base-member, as long as the dynamic object\n-\t later has the right member. */\n-\n+      delta = build_component_ref (function, delta_identifier, NULL_TREE, 0);\n       idx = build1 (NOP_EXPR, vtable_index_type, e3);\n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  /* Mask out the virtual bit from the index.  */\n \t  e1 = cp_build_binary_op (BIT_AND_EXPR, idx, integer_one_node);\n-\t  mask = build1 (NOP_EXPR, vtable_index_type, build_int_2 (~1, ~0));\n-\t  idx = cp_build_binary_op (BIT_AND_EXPR, idx, mask);\n+\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node);\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n-\t\t\t\t   delta, integer_one_node);\n-\t  delta = cp_build_binary_op (RSHIFT_EXPR,\n-\t\t\t\t      build1 (NOP_EXPR, vtable_index_type,\n-\t\t\t\t\t      delta),\n-\t\t\t\t      integer_one_node);\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR, delta, integer_one_node);\n+\t  delta = cp_build_binary_op (RSHIFT_EXPR, delta, integer_one_node);\n \t  break;\n \n \tdefault:\n \t  abort ();\n \t}\n \n-      /* DELTA2 is the amount by which to adjust the `this' pointer\n-\t to find the vtbl.  */\n-      delta2 = delta;\n-      vtbl = build\n-\t(PLUS_EXPR,\n-\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n-\t vtbl, cp_convert (ptrdiff_type_node, delta2));\n+      /* Convert down to the right base before using the instance.  First\n+         use the type... */\n+      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n+      basetype = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)),\n+\t\t\t      basetype, ba_check, NULL);\n+      instance_ptr = build_base_path (PLUS_EXPR, instance_ptr, basetype, 1);\n+      if (instance_ptr == error_mark_node)\n+\treturn error_mark_node;\n+      /* ...and then the delta in the PMF.  */\n+      instance_ptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n+\t\t\t    instance_ptr, delta);\n+\n+      /* Hand back the adjusted 'this' argument to our caller.  */\n+      *instance_ptrptr = instance_ptr;\n+\n+      /* Next extract the vtable pointer from the object.  */\n+      vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n+\t\t     instance_ptr);\n       vtbl = build_indirect_ref (vtbl, NULL);\n \n+      /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold (build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx));\n       e2 = build_indirect_ref (e2, NULL);\n \n@@ -2932,14 +2927,6 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \te1 = build (COMPOUND_EXPR, TREE_TYPE (e1),\n \t\t    instance_ptr, e1);\n \n-      *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n-\t\t\t\tinstance_ptr, delta);\n-\n-      if (instance_ptr == error_mark_node\n-\t  && TREE_CODE (e1) != ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (e1, 0)) != FUNCTION_DECL)\n-\terror (\"object missing in `%E'\", function);\n-\n       function = e1;\n     }\n   return function;"}]}