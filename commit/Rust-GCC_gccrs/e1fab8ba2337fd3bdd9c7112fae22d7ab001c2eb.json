{"sha": "e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmYWI4YmEyMzM3ZmQzYmRkOWM3MTEyZmFlMjJkN2FiMDAxYzJlYg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-28T01:18:13Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-28T01:18:13Z"}, "message": "sh-common.c: Remove SH5 support.\n\ngcc/\n\t* common/config/sh/sh-common.c: Remove SH5 support.\n\t* config/sh/constraints.md: Likewise.\n\t* config/sh/config/sh/elf.h: Likewise.\n\t* config/sh/linux.h: Likewise.\n\t* config/sh/netbsd-elf.h: Likewise.\n\t* config/sh/predicates.md: Likewise.\n\t* config/sh/sh-c.c: Likewise.\n\t* config/sh/sh-protos.h: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/sh.h: Likewise.\n\t* config/sh/sh.md: Likewise.\n\t* config/sh/sh.opt: Likewise.\n\t* config/sh/sync.md: Likewise.\n\t* config/sh/sh64.h: Delete.\n\t* config/sh/shmedia.h: Likewise.\n\t* config/sh/shmedia.md: Likewise.\n\t* config/sh/sshmedia.h: Likewise.\n\t* config/sh/t-netbsd-sh5-64: Likewise.\n\t* config/sh/t-sh64: Likewise.\n\t* config/sh/ushmedia.h: Likewise.\n\nFrom-SVN: r235544", "tree": {"sha": "d7075bfe28e92723a49e9389d7d1dd4146f719ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7075bfe28e92723a49e9389d7d1dd4146f719ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/comments", "author": null, "committer": null, "parents": [{"sha": "50e017d06c06e30b050bea7a3c3ba5c951734c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e017d06c06e30b050bea7a3c3ba5c951734c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e017d06c06e30b050bea7a3c3ba5c951734c07"}], "stats": {"total": 11557, "additions": 424, "deletions": 11133}, "files": [{"sha": "4f30dd3587f4bf243bfd476ccf18d1d49548641b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -1,3 +1,26 @@\n+2016-04-28  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* common/config/sh/sh-common.c: Remove SH5 support.\n+\t* config/sh/constraints.md: Likewise.\n+\t* config/sh/config/sh/elf.h: Likewise.\n+\t* config/sh/linux.h: Likewise.\n+\t* config/sh/netbsd-elf.h: Likewise.\n+\t* config/sh/predicates.md: Likewise.\n+\t* config/sh/sh-c.c: Likewise.\n+\t* config/sh/sh-protos.h: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\t* config/sh/sh.opt: Likewise.\n+\t* config/sh/sync.md: Likewise.\n+\t* config/sh/sh64.h: Delete.\n+\t* config/sh/shmedia.h: Likewise.\n+\t* config/sh/shmedia.md: Likewise.\n+\t* config/sh/sshmedia.h: Likewise.\n+\t* config/sh/t-netbsd-sh5-64: Likewise.\n+\t* config/sh/t-sh64: Likewise.\n+\t* config/sh/ushmedia.h: Likewise.\n+\n 2016-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (sign_extend to memory peephole2s): Use"}, {"sha": "ee6e4c9d89b772f4beb30672953c34c30df8c11c", "filename": "gcc/common/config/sh/sh-common.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -148,36 +148,6 @@ sh_handle_option (struct gcc_options *opts,\n \t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH4A_SINGLE_ONLY;\n       return true;\n \n-    case OPT_m5_32media:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_32MEDIA;\n-      return true;\n-\n-    case OPT_m5_32media_nofpu:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_32MEDIA_NOFPU;\n-      return true;\n-\n-    case OPT_m5_64media:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_64MEDIA;\n-      return true;\n-\n-    case OPT_m5_64media_nofpu:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_64MEDIA_NOFPU;\n-      return true;\n-\n-    case OPT_m5_compact:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_COMPACT;\n-      return true;\n-\n-    case OPT_m5_compact_nofpu:\n-      opts->x_target_flags\n-\t= (opts->x_target_flags & ~MASK_ARCH) | SELECT_SH5_COMPACT_NOFPU;\n-      return true;\n-\n     default:\n       return true;\n     }"}, {"sha": "644a0f0c69783dc2da03580423158e0a9ccfb052", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -26,15 +26,12 @@\n ;;       fldi0 / fldi0 cases\n ;; Cxx: Constants other than only CONST_INT\n ;;  Ccl: call site label\n-;;  Css: signed 16-bit constant, literal or symbolic\n-;;  Csu: unsigned 16-bit constant, literal or symbolic\n ;;  Csy: label or symbol\n ;;  Cpg: non-explicit constants that can be directly loaded into a general\n ;;       purpose register in PIC code.  Like 's' except we don't allow\n ;;       PIC_ADDR_P\n ;; IJKLMNOP: CONT_INT constants\n ;;  Ixx: signed xx bit\n-;;  J16: 0xffffffff00000000 | 0x00000000ffffffff\n ;;  Jmb: 0x000000FF\n ;;  Jmw: 0x0000FFFF\n ;;  Jhb: 0x80000000\n@@ -105,23 +102,13 @@\n   \"R0 register.\")\n \n ;; Integer constraints\n-(define_constraint \"I06\"\n-  \"A signed 6-bit constant, as used in SHmedia beqi, bnei and xori.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -32 && ival <= 31\")))\n-\n (define_constraint \"I08\"\n   \"A signed 8-bit constant, as used in add, sub, etc.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= -128 && ival <= 127\")))\n \n-(define_constraint \"I10\"\n-  \"A signed 10-bit constant, as used in SHmedia andi, ori.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -512 && ival <= 511\")))\n-\n (define_constraint \"I16\"\n-  \"A signed 16-bit constant, as used in SHmedia movi.\"\n+  \"A signed 16-bit constant.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= -32768 && ival <= 32767\")))\n \n@@ -138,11 +125,6 @@\n        (match_test \"(ival & 255) == 0\")\n        (match_test \"TARGET_SH2A\")))\n \n-(define_constraint \"J16\"\n-  \"0xffffffff00000000 or 0x00000000ffffffff.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_J16 (ival)\")))\n-\n (define_constraint \"Jmb\"\n   \"Low byte mask constant 0x000000FF\"\n   (and (match_code \"const_int\")\n@@ -190,11 +172,6 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 8191\")))\n \n-(define_constraint \"K16\"\n-  \"An unsigned 16-bit constant, as used in SHmedia shori.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 65535\")))\n- \n (define_constraint \"P27\"\n   \"A constant for shift operand 1,2,8 or 16.\"\n   (and (match_code \"const_int\")\n@@ -239,18 +216,6 @@\n   (and (match_code \"unspec\")\n        (match_test \"XINT (op, 1) == UNSPEC_CALLER\")))\n \n-(define_constraint \"Css\"\n-  \"A signed 16-bit constant, literal or symbolic.\"\n-  (and (match_code \"const\")\n-       (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n-       (match_test \"XINT (XEXP (op, 0), 1) == UNSPEC_EXTRACT_S16\")))\n-\n-(define_constraint \"Csu\"\n-  \"An unsigned 16-bit constant, literal or symbolic.\"\n-  (and (match_code \"const\")\n-       (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n-       (match_test \"XINT (XEXP (op, 0), 1) == UNSPEC_EXTRACT_U16\")))\n-\n (define_constraint \"Csy\"\n   \"A label or a symbol.\"\n   (ior (match_test \"NON_PIC_REFERENCE_P (op)\")"}, {"sha": "ad2713fcf553a2d673c18eb8bf503baa4e6a2818", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n #undef WCHAR_TYPE\n-/* #define WCHAR_TYPE (TARGET_SH5 ? \"int\" : \"long int\")  */\n #define WCHAR_TYPE SH_ELF_WCHAR_TYPE\n    \n #undef WCHAR_TYPE_SIZE\n@@ -44,10 +43,10 @@ along with GCC; see the file COPYING3.  If not see\n #define LOCAL_LABEL_PREFIX \".\"\n \n #undef SIZE_TYPE\n-#define SIZE_TYPE (TARGET_SH5 ? \"long unsigned int\" : \"unsigned int\")\n+#define SIZE_TYPE (\"unsigned int\")\n \n #undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE (TARGET_SH5 ? \"long int\" : \"int\")\n+#define PTRDIFF_TYPE (\"int\")\n \n /* Pass -ml and -mrelax to the assembler and linker.  */\n #undef ASM_SPEC"}, {"sha": "09e966b9e498bb813beabdf787b9098ddc1bdf8e", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -81,32 +81,6 @@ along with GCC; see the file COPYING3.  If not see\n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_SHMEDIA)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tpt\\t1f,tr1\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\taddi.l\\tr15,-8,r15\\n\");\t\t\t\\\n-\tfprintf (STREAM, \"\\tst.l\\tr15,0,r18\\n\");\t\t\t\\\n-\tif (flag_pic)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    const char *gofs = \"(datalabel _GLOBAL_OFFSET_TABLE_-(0f-.))\"; \\\n-\t    fprintf (STREAM, \"\\tmovi\\t((%s>>16)&0xffff),r21\\n\", gofs);\t\\\n-\t    fprintf (STREAM, \"\\tshori\\t(%s & 0xffff),r21\\n\", gofs);\t\\\n-\t    fprintf (STREAM, \"0:\\tptrel/u\\tr21,tr0\\n\");\t\t\t\\\n-\t    fprintf (STREAM, \"\\tmovi\\t((mcount@GOTPLT)&0xffff),r22\\n\");\t\\\n-\t    fprintf (STREAM, \"\\tgettr\\ttr0,r21\\n\");\t\t\t\\\n-\t    fprintf (STREAM, \"\\tadd.l\\tr21,r22,r21\\n\");\t\t\t\\\n-\t    fprintf (STREAM, \"\\tld.l\\tr21,0,r21\\n\");\t\t\t\\\n-\t    fprintf (STREAM, \"\\tptabs\\tr21,tr0\\n\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (STREAM, \"\\tpt\\tmcount,tr0\\n\");\t\t\t\\\n-\tfprintf (STREAM, \"\\tgettr\\ttr1,r18\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"\\tblink\\ttr0,r63\\n\");\t\t\t\t\\\n-\tfprintf (STREAM, \"1:\\tld.l\\tr15,0,r18\\n\");\t\t\t\\\n-\tfprintf (STREAM, \"\\taddi.l\\tr15,8,r15\\n\");\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n \tif (flag_pic)\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    fprintf (STREAM, \"\\tmov.l\\t3f,r1\\n\");\t\t\t\\\n@@ -130,7 +104,6 @@ along with GCC; see the file COPYING3.  If not see\n \telse\t\t\t\t\t\t\t\t\\\n \t  fprintf (STREAM, \"1:\\t.long\\tmcount\\n\");\t\t\t\\\n \tfprintf (STREAM, \"2:\\tlds.l\\t@r15+,pr\\n\");\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* For SH3 and SH4, we use a slot of the unwind frame which correspond\n@@ -142,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n    so as to return itself for 16.  */\n #undef DBX_REGISTER_NUMBER\n #define DBX_REGISTER_NUMBER(REGNO) \\\n-  ((! TARGET_SH5 && (REGNO) == 16) ? 16 : SH_DBX_REGISTER_NUMBER (REGNO))\n+  (((REGNO) == 16) ? 16 : SH_DBX_REGISTER_NUMBER (REGNO))\n \n /* Since libgcc is compiled with -fpic for this target, we can't use\n    __sdivsi3_1 as the division strategy for -O0 and -Os.  */"}, {"sha": "e6580186110253e74b8aeece6d077ca9e5acd933", "filename": "gcc/config/sh/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -67,13 +67,6 @@ along with GCC; see the file COPYING3.  If not see\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_SHMEDIA32 || TARGET_SHMEDIA64)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* FIXME */\t\t\t\t\t\t\t\\\n-\tsorry (\"unimplemented-shmedia profiling\");\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n         fprintf((STREAM), \"\\tmov.l\\t%sLP%d,r1\\n\",\t\t\t\\\n                 LOCAL_LABEL_PREFIX, (LABELNO));\t\t\t\t\\\n         fprintf((STREAM), \"\\tmova\\t%sLP%dr,r0\\n\",\t\t\t\\\n@@ -84,7 +77,6 @@ do\t\t\t\t\t\t\t\t\t\\\n         fprintf((STREAM), \"%sLP%d:\\t.long\\t__mcount\\n\",\t\t\t\\\n                 LOCAL_LABEL_PREFIX, (LABELNO));\t\t\t\t\\\n         fprintf((STREAM), \"%sLP%dr:\\n\", LOCAL_LABEL_PREFIX, (LABELNO));\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n "}, {"sha": "e0502138e312b0793ffe594f43d1ff4201f76d5f", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 11, "deletions": 481, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -17,70 +17,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; TODO: Add a comment here.\n-(define_predicate \"trapping_target_operand\"\n-  (match_code \"if_then_else\")\n-{\n-  rtx cond, mem, res, tar, and_expr;\n-\n-  if (GET_MODE (op) != PDImode)\n-    return 0;\n-  cond = XEXP (op, 0);\n-  mem = XEXP (op, 1);\n-  res = XEXP (op, 2);\n-  if (!MEM_P (mem)\n-      || (GET_CODE (res) != SIGN_EXTEND && GET_CODE (res) != TRUNCATE))\n-    return 0;\n-  tar = XEXP (res, 0);\n-  if (!rtx_equal_p (XEXP (mem, 0), tar)\n-      || GET_MODE (tar) != Pmode)\n-    return 0;\n-  if (GET_CODE (cond) == CONST)\n-    {\n-      cond = XEXP (cond, 0);\n-      if (!satisfies_constraint_Csy (tar))\n-\treturn 0;\n-      if (GET_CODE (tar) == CONST)\n-\ttar = XEXP (tar, 0);\n-    }\n-  else if (!arith_reg_operand (tar, VOIDmode)\n-\t   && ! satisfies_constraint_Csy (tar))\n-    return 0;\n-  if (GET_CODE (cond) != EQ)\n-    return 0;\n-  and_expr = XEXP (cond, 0);\n-  return (GET_CODE (and_expr) == AND\n-\t  && rtx_equal_p (XEXP (and_expr, 0), tar)\n-\t  && CONST_INT_P (XEXP (and_expr, 1))\n-\t  && CONST_INT_P (XEXP (cond, 1))\n-\t  && INTVAL (XEXP (and_expr, 1)) == 3\n-\t  && INTVAL (XEXP (cond, 1)) == 3);\n-})\n-\n-;; A logical operand that can be used in an shmedia and insn.\n-(define_predicate \"and_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  if (logical_operand (op, mode))\n-    return 1;\n-\n-  /* Check mshflo.l / mshflhi.l opportunities.  */\n-  if (TARGET_SHMEDIA\n-      && mode == DImode\n-      && satisfies_constraint_J16 (op))\n-    return 1;\n-\n-  return 0;\n-})\n-\n-;; Like arith_reg_dest, but this predicate is defined with\n-;; define_special_predicate, not define_predicate.\n-(define_special_predicate \"any_arith_reg_dest\"\n-  (match_code \"subreg,reg\")\n-{\n-  return arith_reg_dest (op, mode);\n-})\n-\n ;; Like register_operand, but this predicate is defined with\n ;; define_special_predicate, not define_predicate.\n (define_special_predicate \"any_register_operand\"\n@@ -93,35 +29,7 @@\n (define_predicate \"arith_operand\"\n   (match_code \"subreg,reg,const_int,truncate\")\n {\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (TARGET_SHMEDIA)\n-    {\n-      /* FIXME: We should be checking whether the CONST_INT fits in a\n-\t signed 16-bit here, but this causes reload_cse to crash when\n-\t attempting to transform a sequence of two 64-bit sets of the\n-\t same register from literal constants into a set and an add,\n-\t when the difference is too wide for an add.  */\n-      if (CONST_INT_P (op)\n-\t  || satisfies_constraint_Css (op))\n-\treturn 1;\n-      else if (GET_CODE (op) == TRUNCATE\n-\t       && REG_P (XEXP (op, 0))\n-\t       && ! system_reg_operand (XEXP (op, 0), VOIDmode)\n-\t       && (mode == VOIDmode || mode == GET_MODE (op))\n-\t       && (GET_MODE_SIZE (GET_MODE (op))\n-\t\t   < GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n-\t       && (! FP_REGISTER_P (REGNO (XEXP (op, 0)))\n-\t\t   || GET_MODE_SIZE (GET_MODE (op)) == 4))\n-\treturn register_operand (XEXP (op, 0), VOIDmode);\n-      else\n-\treturn 0;\n-    }\n-  else if (satisfies_constraint_I08 (op))\n-    return 1;\n-\n-  return 0;\n+  return arith_reg_operand (op, mode) || satisfies_constraint_I08 (op);\n })\n \n ;; Like above, but for DImode destinations: forbid paradoxical DImode\n@@ -130,10 +38,6 @@\n (define_predicate \"arith_reg_dest\"\n   (match_code \"subreg,reg\")\n {\n-  if (mode == DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n-      && TARGET_SHMEDIA)\n-    return 0;\n   return arith_reg_operand (op, mode);\n })\n \n@@ -160,11 +64,7 @@\n   /* Allow a no-op sign extension - compare LOAD_EXTEND_OP.\n      We allow SImode here, as not using an FP register is just a matter of\n      proper register allocation.  */\n-  if (TARGET_SHMEDIA\n-      && GET_MODE (op) == DImode && GET_CODE (op) == SIGN_EXTEND\n-      && GET_MODE (XEXP (op, 0)) == SImode\n-      && GET_CODE (XEXP (op, 0)) != SUBREG)\n-    return register_operand (XEXP (op, 0), VOIDmode);\n+\n #if 0 /* Can't do this because of PROMOTE_MODE for unsigned vars.  */\n   if (GET_MODE (op) == SImode && GET_CODE (op) == SIGN_EXTEND\n       && GET_MODE (XEXP (op, 0)) == HImode\n@@ -236,47 +136,6 @@\n        (ior (match_test \"INTVAL (op) == 255\")\n \t    (match_test \"INTVAL (op) == 65535\"))))\n \n-;; Returns 1 if OP is a floating point operator with two operands.\n-(define_predicate \"binary_float_operator\"\n-  (and (match_code \"plus,minus,mult,div\")\n-       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; Returns 1 if OP is a logical operator with two operands.\n-(define_predicate \"binary_logical_operator\"\n-  (and (match_code \"and,ior,xor\")\n-       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; Return 1 if OP is an address suitable for a cache manipulation operation.\n-;; MODE has the meaning as in address_operand.\n-(define_special_predicate \"cache_address_operand\"\n-  (match_code \"plus,reg\")\n-{\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      if (!REG_P (XEXP (op, 0)))\n-\treturn 0;\n-      if (!CONST_INT_P (XEXP (op, 1))\n-\t  || (INTVAL (XEXP (op, 1)) & 31))\n-\treturn 0;\n-    }\n-  else if (!REG_P (op))\n-    return 0;\n-  return address_operand (op, mode);\n-})\n-\n-;; Returns 1 if OP is a valid source operand for shmedia cmpgt / cmpgtu.\n-(define_predicate \"cmp_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  if (satisfies_constraint_N (op))\n-    return 1;\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-})\n-\n ;; Returns true if OP is an operand that can be used as the first operand in\n ;; the cstoresi4 expander pattern.\n (define_predicate \"cmpsi_operand\"\n@@ -289,53 +148,6 @@\n   return arith_operand (op, mode);\n })\n \n-;; Returns true if OP is a comutative float operator.\n-;; This predicate is currently unused.\n-;;(define_predicate \"commutative_float_operator\"\n-;;  (and (match_code \"plus,mult\")\n-;;       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; Returns true if OP is a equal or not equal operator.\n-(define_predicate \"equality_comparison_operator\"\n-  (match_code \"eq,ne\"))\n-\n-;; Returns true if OP is an arithmetic operand that is zero extended during\n-;; an operation.\n-(define_predicate \"extend_reg_operand\"\n-  (match_code \"subreg,reg,truncate\")\n-{\n-  return (GET_CODE (op) == TRUNCATE\n-\t  ? arith_operand\n-\t  : arith_reg_operand) (op, mode);\n-})\n-\n-;; Like extend_reg_operand, but also allow a constant 0.\n-(define_predicate \"extend_reg_or_0_operand\"\n-  (match_code \"subreg,reg,truncate,const_int\")\n-{\n-  return (GET_CODE (op) == TRUNCATE\n-\t  ? arith_operand\n-\t  : arith_reg_or_0_operand) (op, mode);\n-})\n-\n-;; Like arith_reg_operand, but this predicate does not accept SIGN_EXTEND.\n-(define_predicate \"ext_dest_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  return arith_reg_operand (op, mode);\n-})\n-\n-;; Returns true if OP can be used as a destination register for shmedia floating\n-;; point to integer conversions.\n-(define_predicate \"fp_arith_reg_dest\"\n-  (match_code \"subreg,reg\")\n-{\n-  if (mode == DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8)\n-    return 0;\n-  return fp_arith_reg_operand (op, mode);\n-})\n-\n ;; Returns true if OP is a floating point register that can be used in floating\n ;; point arithmetic operations.\n (define_predicate \"fp_arith_reg_operand\"\n@@ -390,12 +202,9 @@\n (define_predicate \"fpul_operand\"\n   (match_code \"reg\")\n {\n-  if (TARGET_SHMEDIA)\n-    return fp_arith_reg_operand (op, mode);\n-\n-  return (REG_P (op)\n-\t  && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t  && GET_MODE (op) == mode);\n+  return REG_P (op)\n+\t && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t && GET_MODE (op) == mode;\n })\n \n ;; Returns true if OP is a valid fpul input operand for the fsca insn.\n@@ -467,10 +276,7 @@\n \n ;; Returns 1 if the operand can be used in a zero_extend.\n (define_predicate \"zero_extend_operand\"\n-  (ior (and (match_test \"TARGET_SHMEDIA\")\n-\t    (match_operand 0 \"general_extend_operand\"))\n-       (and (match_test \"! TARGET_SHMEDIA\")\n-\t    (match_operand 0 \"arith_reg_operand\"))))\n+  (match_operand 0 \"arith_reg_operand\"))\n \n ;; Returns 1 if OP can be source of a simple move operation. Same as\n ;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as\n@@ -523,10 +329,6 @@\n       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);\n       rtx x = XEXP (mem_rtx, 0);\n \n-      if (! ALLOW_INDEXED_ADDRESS\n-\t  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))\n-\treturn false;\n-\n       if (GET_CODE (x) == PLUS)\n \t{\n \t  rtx y = XEXP (x, 0);\n@@ -571,15 +373,6 @@\n \t  return true;\n     }\n \n-  if (TARGET_SHMEDIA\n-      && (GET_CODE (op) == PARALLEL || GET_CODE (op) == CONST_VECTOR)\n-      && sh_rep_vec (op, mode))\n-    return 1;\n-  if (TARGET_SHMEDIA && 1\n-      && GET_CODE (op) == SUBREG && GET_MODE (op) == mode\n-      && SUBREG_REG (op) == const0_rtx && subreg_lowpart_p (op))\n-    /* FIXME */ abort (); /* return 1; */\n-\n   return general_operand (op, mode);\n })\n \n@@ -615,21 +408,13 @@\n   /* Only pre dec allowed.  */\n   if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC)\n     return 0;\n-  if (mode == DImode && TARGET_SHMEDIA && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n-      && ! (reload_in_progress || reload_completed))\n-    return 0;\n \n   if (mode == GET_MODE (op)\n       && (MEM_P (op) || (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))))\n     {\n       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);\n       rtx x = XEXP (mem_rtx, 0);\n \n-      if (! ALLOW_INDEXED_ADDRESS\n-\t  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))\n-\treturn false;\n-\n       if (GET_CODE (x) == PLUS)\n \t{\n \t  rtx y = XEXP (x, 0);\n@@ -677,22 +462,6 @@\n   return general_operand (op, mode);\n })\n \n-;; Returns 1 if OP is a POST_INC on stack pointer register.\n-(define_predicate \"sh_no_delay_pop_operand\"\n-  (match_code \"mem\")\n-{\n-  rtx inside;\n-  inside = XEXP (op, 0);\n-\n-  if (GET_CODE (op) == MEM && GET_MODE (op) == SImode \n-      && GET_CODE (inside) == POST_INC \n-      && GET_CODE (XEXP (inside, 0)) == REG\n-      && REGNO (XEXP (inside, 0)) == SP_REG)\n-    return 1;\n-\n-  return 0;\n-})\n-\n ;; Returns 1 if OP is a MEM that can be source of a simple move operation.\n (define_predicate \"unaligned_load_operand\"\n   (match_code \"mem\")\n@@ -741,65 +510,11 @@\n \t && sh_legitimate_index_p (mode, XEXP (plus0_rtx, 1), TARGET_SH2A, true);\n })\n \n-;; Returns true if OP is some kind of greater comparision.\n-(define_predicate \"greater_comparison_operator\"\n-  (match_code \"gt,ge,gtu,geu\"))\n-\n-;; Returns true if OP is an operand suitable for shmedia reload_inqi and\n-;; reload_inhi insns.\n-(define_predicate \"inqhi_operand\"\n-  (match_code \"truncate\")\n-{\n-  if (GET_CODE (op) != TRUNCATE || mode != GET_MODE (op))\n-    return 0;\n-  op = XEXP (op, 0);\n-  /* Can't use true_regnum here because copy_cost wants to know about\n-     SECONDARY_INPUT_RELOAD_CLASS.  */\n-  return REG_P (op) && FP_REGISTER_P (REGNO (op));\n-})\n-\n-;; Returns true if OP is a general purpose integer register.\n-;; This predicate is currently unused.\n-;;(define_special_predicate \"int_gpr_dest\"\n-;;  (match_code \"subreg,reg\")\n-;;{\n-;;  machine_mode op_mode = GET_MODE (op);\n-;;\n-;;  if (GET_MODE_CLASS (op_mode) != MODE_INT\n-;;      || GET_MODE_SIZE (op_mode) >= UNITS_PER_WORD)\n-;;    return 0;\n-;;  if (! reload_completed)\n-;;    return 0;\n-;;  return true_regnum (op) <= LAST_GENERAL_REG;\n-;;})\n-\n-;; Returns true if OP is some kind of less comparison.\n-(define_predicate \"less_comparison_operator\"\n-  (match_code \"lt,le,ltu,leu\"))\n-\n ;; Returns 1 if OP is a valid source operand for a logical operation.\n (define_predicate \"logical_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (TARGET_SHMEDIA)\n-    {\n-      if (satisfies_constraint_I10 (op))\n-\treturn 1;\n-      else\n-\treturn 0;\n-    }\n-  else if (satisfies_constraint_K08 (op))\n-    return 1;\n-\n-  return 0;\n+  return arith_reg_operand (op, mode) || satisfies_constraint_K08 (op);\n })\n \n ;; Returns true if OP is a valid constant source operand for a logical\n@@ -813,70 +528,20 @@\n (define_predicate \"logical_and_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n-  if (logical_operand (op, mode))\n-    return 1;\n-\n-  if (! TARGET_SHMEDIA\n-      && (satisfies_constraint_Jmb (op) || satisfies_constraint_Jmw (op)))\n-    return 1;\n-\n-  return 0;\n+  return logical_operand (op, mode) || satisfies_constraint_Jmb (op)\n+\t || satisfies_constraint_Jmw (op);\n })\n \n ;; Returns true if OP is a logical operator.\n (define_predicate \"logical_operator\"\n   (match_code \"and,ior,xor\"))\n \n-;; Like arith_reg_operand, but for register source operands of narrow\n-;; logical SHMEDIA operations: forbid subregs of DImode / TImode regs.\n (define_predicate \"logical_reg_operand\"\n   (match_code \"subreg,reg\")\n {\n-  if (TARGET_SHMEDIA\n-      && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4\n-      && mode != DImode)\n-    return 0;\n   return arith_reg_operand (op, mode);\n })\n \n-;; Returns true if OP is a valid bit offset value for the shmedia mextr insns.\n-(define_predicate \"mextr_bit_offset\"\n-  (match_code \"const_int\")\n-{\n-  HOST_WIDE_INT i;\n-\n-  if (!CONST_INT_P (op))\n-    return 0;\n-  i = INTVAL (op);\n-  return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n-})\n-\n-;; Returns true if OP is a constant -1, 0 or an zero extended register that\n-;; can be used as an operator in the *subsi3_media insn.\n-(define_predicate \"minuend_operand\"\n-  (match_code \"subreg,reg,truncate,const_int\")\n-{\n-  return op == constm1_rtx || extend_reg_or_0_operand (op, mode);\n-})\n-\n-;; Returns true if OP is a noncommutative floating point operator.\n-;; This predicate is currently unused.\n-;;(define_predicate \"noncommutative_float_operator\"\n-;;  (and (match_code \"minus,div\")\n-;;       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; UNORDERED is only supported on SHMEDIA.\n-\n-(define_predicate \"sh_float_comparison_operator\"\n-  (ior (match_operand 0 \"ordered_comparison_operator\")\n-       (and (match_test \"TARGET_SHMEDIA\")\n-\t    (match_code \"unordered\"))))\n-\n-(define_predicate \"shmedia_cbranch_comparison_operator\"\n-  (ior (match_operand 0 \"equality_comparison_operator\")\n-       (match_operand 0 \"greater_comparison_operator\")))\n-\n ;; Returns true if OP is a constant vector.\n (define_predicate \"sh_const_vec\"\n   (match_code \"const_vector\")\n@@ -927,16 +592,6 @@\n   return 1;\n })\n \n-;; Like register_operand, but take into account that SHMEDIA can use\n-;; the constant zero like a general register.\n-(define_predicate \"sh_register_operand\"\n-  (match_code \"reg,subreg,const_int,const_double\")\n-{\n-  if (op == CONST0_RTX (mode) && TARGET_SHMEDIA)\n-    return 1;\n-  return register_operand (op, mode);\n-})\n-\n ;; Returns true if OP is a vector which is composed of one element that is\n ;; repeated.\n (define_predicate \"sh_rep_vec\"\n@@ -972,38 +627,8 @@\n {\n   /* Allow T_REG as shift count for dynamic shifts, although it is not\n      really possible.  It will then be copied to a general purpose reg.  */\n-  if (! TARGET_SHMEDIA)\n-    return const_int_operand (op, mode) || arith_reg_operand (op, mode)\n-\t   || (TARGET_DYNSHIFT && t_reg_operand (op, mode));\n-\n-  return (CONSTANT_P (op)\n-\t  ? (CONST_INT_P (op)\n-\t     ? (unsigned) INTVAL (op) < GET_MODE_BITSIZE (mode)\n-\t     : nonmemory_operand (op, mode))\n-\t  : shift_count_reg_operand (op, mode));\n-})\n-\n-;; Returns true if OP is a valid shift count operand in a register which can\n-;; be used by shmedia shift insns.\n-(define_predicate \"shift_count_reg_operand\"\n-  (match_code \"subreg,reg,zero_extend,sign_extend\")\n-{\n-  if ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n-       || (GET_CODE (op) == SUBREG && SUBREG_BYTE (op) == 0))\n-      && (mode == VOIDmode || mode == GET_MODE (op))\n-      && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n-      && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT)\n-    {\n-      mode = VOIDmode;\n-      do\n-\top = XEXP (op, 0);\n-      while ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n-\t      || GET_CODE (op) == TRUNCATE)\n-\t     && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n-\t     && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT);\n-\n-    }\n-  return arith_reg_operand (op, mode);\n+  return const_int_operand (op, mode) || arith_reg_operand (op, mode)\n+\t || (TARGET_DYNSHIFT && t_reg_operand (op, mode));\n })\n \n ;; Predicates for matching operands that are constant shift\n@@ -1029,105 +654,10 @@\n        (ior (match_test \"! satisfies_constraint_P27 (op)\")\n \t    (match_test \"satisfies_constraint_M (op)\"))))\n \n-;; Returns true if OP is some kind of a shift operator.\n-(define_predicate \"shift_operator\"\n-  (match_code \"ashift,ashiftrt,lshiftrt\"))\n-\n ;; Returns true if OP is a symbol reference.\n (define_predicate \"symbol_ref_operand\"\n   (match_code \"symbol_ref\"))\n \n-;; Same as target_reg_operand, except that label_refs and symbol_refs\n-;; are accepted before reload.\n-(define_special_predicate \"target_operand\"\n-  (match_code \"subreg,reg,label_ref,symbol_ref,const,unspec\")\n-{\n-  if (mode != VOIDmode && mode != Pmode)\n-    return 0;\n-\n-  if ((GET_MODE (op) == Pmode || GET_MODE (op) == VOIDmode)\n-      && satisfies_constraint_Csy (op))\n-    return ! reload_completed;\n-\n-  return target_reg_operand (op, mode);\n-})\n-\n-;; A predicate that accepts pseudos and branch target registers.\n-(define_special_predicate \"target_reg_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  if (mode == VOIDmode\n-     ? GET_MODE (op) != Pmode && GET_MODE (op) != PDImode\n-     : mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = XEXP (op, 0);\n-\n-  if (!REG_P (op))\n-    return 0;\n-\n-  /* We must protect ourselves from matching pseudos that are virtual\n-     register, because they will eventually be replaced with hardware\n-     registers that aren't branch-target registers.  */\n-  if (REGNO (op) > LAST_VIRTUAL_REGISTER\n-      || TARGET_REGISTER_P (REGNO (op)))\n-    return 1;\n-\n-  return 0;\n-})\n-\n-;; Returns true if OP is a valid operand for the shmedia mperm.w insn.\n-(define_special_predicate \"trunc_hi_operand\"\n-  (match_code \"subreg,reg,truncate\")\n-{\n-  machine_mode op_mode = GET_MODE (op);\n-\n-  if (op_mode != SImode && op_mode != DImode\n-      && op_mode != V4HImode && op_mode != V2SImode)\n-    return 0;\n-  return extend_reg_operand (op, mode);\n-})\n-\n-;; Returns true if OP is an address suitable for an unaligned access\n-;; instruction.\n-(define_special_predicate \"ua_address_operand\"\n-  (match_code \"subreg,reg,plus\")\n-{\n-  if (GET_CODE (op) == PLUS\n-      && (! satisfies_constraint_I06 (XEXP (op, 1))))\n-    return 0;\n-  return address_operand (op, QImode);\n-})\n-\n-;; Returns true if OP is a valid offset for an unaligned memory address.\n-(define_predicate \"ua_offset\"\n-  (match_code \"const_int\")\n-{\n-  return satisfies_constraint_I06 (op);\n-})\n-\n-;; Returns true if OP is a floating point operator with one operand.\n-(define_predicate \"unary_float_operator\"\n-  (and (match_code \"abs,neg,sqrt\")\n-       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; Return 1 if OP is a valid source operand for xor.\n-(define_predicate \"xor_operand\"\n-  (match_code \"subreg,reg,const_int\")\n-{\n-  if (CONST_INT_P (op))\n-    return (TARGET_SHMEDIA\n-\t    ? (satisfies_constraint_I06 (op)\n-\t       || (!can_create_pseudo_p () && INTVAL (op) == 0xff))\n-\t    : satisfies_constraint_K08 (op));\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-})\n-\n (define_predicate \"bitwise_memory_operand\"\n   (match_code \"mem\")\n {"}, {"sha": "b854a69c8ce756d4adc6ae3f16c083c4a2ed7754", "filename": "gcc/config/sh/sh-c.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-c.c?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -119,15 +119,6 @@ sh_cpu_cpp_builtins (cpp_reader* pfile)\n \t\t      : TARGET_FPU_ANY ? \"__SH4_SINGLE_ONLY__\"\n \t\t      : \"__SH4_NOFPU__\");\n       break;\n-    case PROCESSOR_SH5:\n-      {\n-\tbuiltin_define_with_value (\"__SH5__\",\n-\t\t\t\t   TARGET_SHMEDIA64 ? \"64\" : \"32\", 0);\n-\tbuiltin_define_with_value (\"__SHMEDIA__\",\n-\t\t\t\t   TARGET_SHMEDIA ? \"1\" : \"0\", 0);\n-\tif (! TARGET_FPU_DOUBLE)\n-\t  builtin_define (\"__SH4_NOFPU__\");\n-      }\n     }\n   if (TARGET_FPU_ANY)\n     builtin_define (\"__SH_FPU_ANY__\");"}, {"sha": "537ab390797c4bf2b138ddea56f413ba5c3393a5", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -124,7 +124,6 @@ extern enum rtx_code prepare_cbranch_operands (rtx *, machine_mode mode,\n extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);\n extern bool expand_cbranchdi4 (rtx *operands, enum rtx_code comparison);\n extern void sh_emit_scc_to_t (enum rtx_code, rtx, rtx);\n-extern rtx sh_emit_cheap_store_flag (machine_mode, enum rtx_code, rtx, rtx);\n extern void sh_emit_compare_and_branch (rtx *, machine_mode);\n extern void sh_emit_compare_and_set (rtx *, machine_mode);\n extern bool sh_ashlsi_clobbers_t_reg_p (rtx);\n@@ -140,7 +139,6 @@ extern bool gen_shl_and (rtx, rtx, rtx, rtx);\n extern int shl_sext_kind (rtx, rtx, int *);\n extern int shl_sext_length (rtx);\n extern bool gen_shl_sext (rtx, rtx, rtx, rtx);\n-extern rtx gen_datalabel_ref (rtx);\n extern int regs_used (rtx, int);\n extern void fixup_addr_diff_vecs (rtx_insn *);\n extern int get_dest_uid (rtx, int);\n@@ -149,8 +147,6 @@ extern enum tls_model tls_symbolic_operand (rtx, machine_mode);\n extern bool system_reg_operand (rtx, machine_mode);\n extern bool reg_unused_after (rtx, rtx_insn *);\n extern int sh_insn_length_adjustment (rtx_insn *);\n-extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n-extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern bool sh_expand_t_scc (rtx *);\n extern rtx sh_gen_truncate (machine_mode, rtx, int);\n extern bool sh_vector_mode_supported_p (machine_mode);"}, {"sha": "e6680afe07055f0e81759182a79f1c167ed5ed4f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 111, "deletions": 2092, "changes": 2203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb"}, {"sha": "03035274f449fbe2a5bef41072353dcbe80058e8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 88, "deletions": 430, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -74,28 +74,10 @@ extern int code_for_indirect_jump_scratch;\n    FPU is disabled (which makes it compatible with SH4al-dsp).  */\n #define TARGET_SH4A_FP (TARGET_SH4A && TARGET_FPU_ANY)\n \n-/* Nonzero if we should generate code using the SHcompact instruction\n-   set and 32-bit ABI.  */\n-#define TARGET_SHCOMPACT (TARGET_SH5 && TARGET_SH1)\n-\n-/* Nonzero if we should generate code using the SHmedia instruction\n-   set and ABI.  */\n-#define TARGET_SHMEDIA (TARGET_SH5 && ! TARGET_SH1)\n-\n-/* Nonzero if we should generate code using the SHmedia ISA and 32-bit\n-   ABI.  */\n-#define TARGET_SHMEDIA32 (TARGET_SH5 && ! TARGET_SH1 && TARGET_SH_E)\n-\n-/* Nonzero if we should generate code using the SHmedia ISA and 64-bit\n-   ABI.  */\n-#define TARGET_SHMEDIA64 (TARGET_SH5 && ! TARGET_SH1 && ! TARGET_SH_E)\n-\n-/* Nonzero if we should generate code using SHmedia FPU instructions.  */\n-#define TARGET_SHMEDIA_FPU (TARGET_SHMEDIA && TARGET_FPU_DOUBLE)\n \n /* This is not used by the SH2E calling convention  */\n #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \\\n-  (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 \\\n+  (TARGET_SH1 && ! TARGET_SH2E \\\n    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))\n \n #ifndef TARGET_CPU_DEFAULT\n@@ -108,19 +90,6 @@ extern int code_for_indirect_jump_scratch;\n #define SUPPORT_SH2A_SINGLE 1\n #endif\n \n-#define TARGET_DIVIDE_INV \\\n-  (sh_div_strategy == SH_DIV_INV || sh_div_strategy == SH_DIV_INV_MINLAT \\\n-   || sh_div_strategy == SH_DIV_INV20U || sh_div_strategy == SH_DIV_INV20L \\\n-   || sh_div_strategy == SH_DIV_INV_CALL \\\n-   || sh_div_strategy == SH_DIV_INV_CALL2 || sh_div_strategy == SH_DIV_INV_FP)\n-#define TARGET_DIVIDE_FP (sh_div_strategy == SH_DIV_FP)\n-#define TARGET_DIVIDE_INV_FP (sh_div_strategy == SH_DIV_INV_FP)\n-#define TARGET_DIVIDE_CALL2 (sh_div_strategy == SH_DIV_CALL2)\n-#define TARGET_DIVIDE_INV_MINLAT (sh_div_strategy == SH_DIV_INV_MINLAT)\n-#define TARGET_DIVIDE_INV20U (sh_div_strategy == SH_DIV_INV20U)\n-#define TARGET_DIVIDE_INV20L (sh_div_strategy == SH_DIV_INV20L)\n-#define TARGET_DIVIDE_INV_CALL (sh_div_strategy == SH_DIV_INV_CALL)\n-#define TARGET_DIVIDE_INV_CALL2 (sh_div_strategy == SH_DIV_INV_CALL2)\n #define TARGET_DIVIDE_CALL_DIV1 (sh_div_strategy == SH_DIV_CALL_DIV1)\n #define TARGET_DIVIDE_CALL_FP (sh_div_strategy == SH_DIV_CALL_FP)\n #define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE)\n@@ -151,12 +120,6 @@ extern int code_for_indirect_jump_scratch;\n #define SELECT_SH4A_SINGLE_ONLY  (MASK_SH4A | SELECT_SH4_SINGLE_ONLY)\n #define SELECT_SH4A\t\t (MASK_SH4A | SELECT_SH4)\n #define SELECT_SH4A_SINGLE\t (MASK_SH4A | SELECT_SH4_SINGLE)\n-#define SELECT_SH5_64MEDIA\t (MASK_SH5 | MASK_SH4)\n-#define SELECT_SH5_64MEDIA_NOFPU (MASK_SH5)\n-#define SELECT_SH5_32MEDIA\t (MASK_SH5 | MASK_SH4 | MASK_SH_E)\n-#define SELECT_SH5_32MEDIA_NOFPU (MASK_SH5 | MASK_SH_E)\n-#define SELECT_SH5_COMPACT\t (MASK_SH5 | MASK_SH4 | SELECT_SH3E)\n-#define SELECT_SH5_COMPACT_NOFPU (MASK_SH5 | SELECT_SH3)\n \n #if SUPPORT_SH1\n #define SUPPORT_SH2 1\n@@ -192,25 +155,10 @@ extern int code_for_indirect_jump_scratch;\n #define SUPPORT_SH4A_SINGLE 1\n #endif\n \n-#if SUPPORT_SH5_COMPAT\n-#define SUPPORT_SH5_32MEDIA 1\n-#endif\n-\n-#if SUPPORT_SH5_COMPACT_NOFPU\n-#define SUPPORT_SH5_32MEDIA_NOFPU 1\n-#endif\n-\n-#define SUPPORT_ANY_SH5_32MEDIA \\\n-  (SUPPORT_SH5_32MEDIA || SUPPORT_SH5_32MEDIA_NOFPU)\n-#define SUPPORT_ANY_SH5_64MEDIA \\\n-  (SUPPORT_SH5_64MEDIA || SUPPORT_SH5_64MEDIA_NOFPU)\n-#define SUPPORT_ANY_SH5 \\\n-  (SUPPORT_ANY_SH5_32MEDIA || SUPPORT_ANY_SH5_64MEDIA)\n-\n /* Reset all target-selection flags.  */\n #define MASK_ARCH (MASK_SH1 | MASK_SH2 | MASK_SH3 | MASK_SH_E | MASK_SH4 \\\n \t\t   | MASK_HARD_SH2A | MASK_HARD_SH2A_DOUBLE | MASK_SH4A \\\n-\t\t   | MASK_HARD_SH4 | MASK_FPU_SINGLE | MASK_SH5 \\\n+\t\t   | MASK_HARD_SH4 | MASK_FPU_SINGLE \\\n \t\t   | MASK_FPU_SINGLE_ONLY)\n \n /* This defaults us to big-endian.  */\n@@ -286,10 +234,7 @@ extern int code_for_indirect_jump_scratch;\n %{m2a-single:--isa=sh2a} \\\n %{m2a-single-only:--isa=sh2a} \\\n %{m2a-nofpu:--isa=sh2a-nofpu} \\\n-%{m5-compact*:--isa=SHcompact} \\\n-%{m5-32media*:--isa=SHmedia --abi=32} \\\n-%{m5-64media*:--isa=SHmedia --abi=64} \\\n-%{m4al:-dsp} %{mcut2-workaround:-cut2-workaround}\"\n+%{m4al:-dsp}\"\n \n #define ASM_SPEC SH_ASM_SPEC\n \n@@ -307,7 +252,7 @@ extern int code_for_indirect_jump_scratch;\n #if TARGET_CPU_DEFAULT & MASK_HARD_SH4 && !(TARGET_CPU_DEFAULT & MASK_SH_E)\n #define SUBTARGET_ASM_ISA_SPEC \"%{!m1:%{!m2:%{!m3*:%{m4-nofpu|!m4*:%{!m5:-isa=sh4-nofpu}}}}}\"\n #else\n-/* If there were an -isa option for sh5-nofpu then it would also go here. */\n+\n #define SUBTARGET_ASM_ISA_SPEC \\\n  \"%{m4-nofpu:-isa=sh4-nofpu} \" ASM_ISA_DEFAULT_SPEC\n #endif\n@@ -325,24 +270,8 @@ extern int code_for_indirect_jump_scratch;\n #define LINK_EMUL_PREFIX \"sh%{ml:l}\"\n #endif\n \n-#if TARGET_CPU_DEFAULT & MASK_SH5\n-#if TARGET_CPU_DEFAULT & MASK_SH_E\n-#define LINK_DEFAULT_CPU_EMUL \"32\"\n-#if TARGET_CPU_DEFAULT & MASK_SH1\n-#define ASM_ISA_SPEC_DEFAULT \"--isa=SHcompact\"\n-#else\n-#define ASM_ISA_SPEC_DEFAULT \"--isa=SHmedia --abi=32\"\n-#endif /* MASK_SH1 */\n-#else /* !MASK_SH_E */\n-#define LINK_DEFAULT_CPU_EMUL \"64\"\n-#define ASM_ISA_SPEC_DEFAULT \"--isa=SHmedia --abi=64\"\n-#endif /* MASK_SH_E */\n-#define ASM_ISA_DEFAULT_SPEC \\\n-\" %{!m1:%{!m2*:%{!m3*:%{!m4*:%{!m5*:\" ASM_ISA_SPEC_DEFAULT \"}}}}}\"\n-#else /* !MASK_SH5 */\n #define LINK_DEFAULT_CPU_EMUL \"\"\n #define ASM_ISA_DEFAULT_SPEC \"\"\n-#endif /* MASK_SH5 */\n \n #define SUBTARGET_LINK_EMUL_SUFFIX \"%{mfdpic:_fd}\"\n #define SUBTARGET_LINK_SPEC \"\"\n@@ -352,9 +281,7 @@ extern int code_for_indirect_jump_scratch;\n \n #define SH_LINK_SPEC \"\\\n -m %(link_emul_prefix)\\\n-%{m5-compact*|m5-32media*:32}\\\n-%{m5-64media*:64}\\\n-%{!m1:%{!m2:%{!m3*:%{!m4*:%{!m5*:%(link_default_cpu_emul)}}}}}\\\n+%{!m1:%{!m2:%{!m3*:%{!m4*:%(link_default_cpu_emul)}}}}\\\n %(subtarget_link_emul_suffix) \\\n %{mrelax:-relax} %(subtarget_link_spec)\"\n \n@@ -419,7 +346,7 @@ enum sh_divide_strategy_e {\n extern enum sh_divide_strategy_e sh_div_strategy;\n \n #ifndef SH_DIV_STRATEGY_DEFAULT\n-#define SH_DIV_STRATEGY_DEFAULT SH_DIV_CALL\n+#define SH_DIV_STRATEGY_DEFAULT SH_DIV_CALL_DIV1\n #endif\n \n #define SUBTARGET_OVERRIDE_OPTIONS (void) 0\n@@ -450,7 +377,7 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n #define INT_TYPE_SIZE 32\n \n /* Width in bits of a `long'.  */\n-#define LONG_TYPE_SIZE (TARGET_SHMEDIA64 ? 64 : 32)\n+#define LONG_TYPE_SIZE (32)\n \n /* Width in bits of a `long long'.  */\n #define LONG_LONG_TYPE_SIZE 64\n@@ -459,7 +386,7 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n #define LONG_DOUBLE_TYPE_SIZE 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t(TARGET_SHMEDIA ? 8 : 4)\n+#define UNITS_PER_WORD\t(4)\n #define MIN_UNITS_PER_WORD 4\n \n /* Scaling factor for Dwarf data offsets for CFI information.\n@@ -471,28 +398,27 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE  (TARGET_SHMEDIA64 ? 64 : 32)\n+#define POINTER_SIZE  (32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY  \t(TARGET_SH5 ? 64 : 32)\n+#define PARM_BOUNDARY  \t(32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY  BIGGEST_ALIGNMENT\n \n /* The log (base 2) of the cache line size, in bytes.  Processors prior to\n    SH2 have no actual cache, but they fetch code in chunks of 4 bytes.\n    The SH2/3 have 16 byte cache lines, and the SH4 has a 32 byte cache line */\n-#define CACHE_LOG ((TARGET_HARD_SH4 || TARGET_SH5) ? 5 : TARGET_SH2 ? 4 : 2)\n+#define CACHE_LOG (TARGET_HARD_SH4 ? 5 : TARGET_SH2 ? 4 : 2)\n \n /* ABI given & required minimum allocation boundary (in *bits*) for the\n    code of a function.  */\n-#define FUNCTION_BOUNDARY (16 << TARGET_SHMEDIA)\n+#define FUNCTION_BOUNDARY (16)\n \n /* On SH5, the lowest bit is used to indicate SHmedia functions, so\n    the vbit must go into the delta field of\n    pointers-to-member-functions.  */\n-#define TARGET_PTRMEMFUNC_VBIT_LOCATION \\\n-  (TARGET_SH5 ? ptrmemfunc_vbit_in_delta : ptrmemfunc_vbit_in_pfn)\n+#define TARGET_PTRMEMFUNC_VBIT_LOCATION (ptrmemfunc_vbit_in_pfn)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY  32\n@@ -501,7 +427,7 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n #define BIGGEST_ALIGNMENT  (TARGET_ALIGN_DOUBLE ? 64 : 32)\n \n /* The best alignment to use in cases where we have a choice.  */\n-#define FASTEST_ALIGNMENT (TARGET_SH5 ? 64 : 32)\n+#define FASTEST_ALIGNMENT (32)\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\\\n@@ -555,11 +481,11 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n #define ADDR_VEC_ALIGN(ADDR_VEC) 2\n \n /* The base two logarithm of the known minimum alignment of an insn length.  */\n-#define INSN_LENGTH_ALIGNMENT(A_INSN)\t\t\t\t\t\\\n-  (NONJUMP_INSN_P (A_INSN)\t\t\t\t\t\t\\\n-   ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n-   : JUMP_P (A_INSN) || CALL_P (A_INSN)\t\t\t\t\t\\\n-   ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n+#define INSN_LENGTH_ALIGNMENT(A_INSN)\t\t\\\n+  (NONJUMP_INSN_P (A_INSN)\t\t\t\\\n+   ? 1\t\t\t\t\t\t\\\n+   : JUMP_P (A_INSN) || CALL_P (A_INSN)\t\t\\\n+   ? 1\t\t\t\t\t\t\\\n    : CACHE_LOG)\n \f\n /* Standard register usage.  */\n@@ -680,14 +606,13 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n /* There are many other relevant definitions in sh.md's md_constants.  */\n \n #define FIRST_GENERAL_REG R0_REG\n-#define LAST_GENERAL_REG (FIRST_GENERAL_REG + (TARGET_SHMEDIA ? 63 : 15))\n+#define LAST_GENERAL_REG (FIRST_GENERAL_REG + (15))\n #define FIRST_FP_REG DR0_REG\n-#define LAST_FP_REG  (FIRST_FP_REG + \\\n-\t\t      (TARGET_SHMEDIA_FPU ? 63 : TARGET_SH2E ? 15 : -1))\n+#define LAST_FP_REG  (FIRST_FP_REG + (TARGET_SH2E ? 15 : -1))\n #define FIRST_XD_REG XD0_REG\n #define LAST_XD_REG  (FIRST_XD_REG + ((TARGET_SH4 && TARGET_FMOVD) ? 7 : -1))\n #define FIRST_TARGET_REG TR0_REG\n-#define LAST_TARGET_REG  (FIRST_TARGET_REG + (TARGET_SHMEDIA ? 7 : -1))\n+#define LAST_TARGET_REG  (FIRST_TARGET_REG + (-1))\n \n /* Registers that can be accessed through bank0 or bank1 depending on sr.md.  */\n #define FIRST_BANKED_REG R0_REG\n@@ -727,14 +652,9 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define TARGET_REGISTER_P(REGNO) \\\n   ((int) (REGNO) >= FIRST_TARGET_REG && (int) (REGNO) <= LAST_TARGET_REG)\n \n-#define SHMEDIA_REGISTER_P(REGNO) \\\n-  (GENERAL_REGISTER_P (REGNO) || FP_REGISTER_P (REGNO) \\\n-   || TARGET_REGISTER_P (REGNO))\n-\n-/* This is to be used in TARGET_CONDITIONAL_REGISTER_USAGE, to mark\n-   registers that should be fixed.  */\n #define VALID_REGISTER_P(REGNO) \\\n-  (SHMEDIA_REGISTER_P (REGNO) || XD_REGISTER_P (REGNO) \\\n+  (GENERAL_REGISTER_P (REGNO) || FP_REGISTER_P (REGNO) \\\n+   || XD_REGISTER_P (REGNO) \\\n    || (REGNO) == AP_REG || (REGNO) == RAP_REG \\\n    || (REGNO) == FRAME_POINTER_REGNUM \\\n    || (TARGET_SH1 && (SPECIAL_REGISTER_P (REGNO) || (REGNO) == PR_REG)) \\\n@@ -743,11 +663,8 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n /* The mode that should be generally used to store a register by\n    itself in the stack, or to load it back.  */\n #define REGISTER_NATURAL_MODE(REGNO) \\\n-  (FP_REGISTER_P (REGNO) ? SFmode \\\n-   : XD_REGISTER_P (REGNO) ? DFmode \\\n-   : TARGET_SHMEDIA && ! HARD_REGNO_CALL_PART_CLOBBERED ((REGNO), DImode) \\\n-   ? DImode \\\n-   : SImode)\n+  (FP_REGISTER_P (REGNO) ? SFmode : XD_REGISTER_P (REGNO) ? DFmode : SImode)\n+\n \n #define FIRST_PSEUDO_REGISTER 156\n \n@@ -868,18 +785,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   1,      1,      0,      0,\t\t\t\t\t\t\\\n }\n \n-/* Only the lower 32-bits of R10-R14 are guaranteed to be preserved\n-   across SHcompact function calls.  We can't tell whether a called\n-   function is SHmedia or SHcompact, so we assume it may be when\n-   compiling SHmedia code with the 32-bit ABI, since that's the only\n-   ABI that can be linked with SHcompact code.  */\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO,MODE) \\\n-  (TARGET_SHMEDIA32 \\\n-   && GET_MODE_SIZE (MODE) > 4 \\\n-   && (((REGNO) >= FIRST_GENERAL_REG + 10 \\\n-\t&& (REGNO) <= FIRST_GENERAL_REG + 15) \\\n-       || TARGET_REGISTER_P (REGNO) \\\n-       || (REGNO) == PR_MEDIA_REG))\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO,MODE) (false)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -890,8 +796,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n    (XD_REGISTER_P (REGNO) \\\n     ? ((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD - 1)) / (2*UNITS_PER_WORD)) \\\n-    : (TARGET_SHMEDIA && FP_REGISTER_P (REGNO)) \\\n-    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD/2 - 1) / (UNITS_PER_WORD/2)) \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n@@ -907,13 +811,8 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    floating-point mode.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   ((MODE1) == (MODE2) \\\n-   || (TARGET_SHMEDIA \\\n-       && GET_MODE_SIZE (MODE1) == GET_MODE_SIZE (MODE2) \\\n-       && INTEGRAL_MODE_P (MODE1) && INTEGRAL_MODE_P (MODE2)) \\\n    || (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2) \\\n-       && (TARGET_SHMEDIA ? ((GET_MODE_SIZE (MODE1) <= 4) \\\n-\t\t\t      && (GET_MODE_SIZE (MODE2) <= 4)) \\\n-\t\t\t  : ((MODE1) != SFmode && (MODE2) != SFmode))))\n+       && (((MODE1) != SFmode && (MODE2) != SFmode))))\n \n /* Specify the modes required to caller save a given hard regno.  */\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\\\n@@ -993,19 +892,13 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define ARG_POINTER_REGNUM\tAP_REG\n \n /* Register in which the static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM\t(TARGET_SH5 ? 1 : 3)\n+#define STATIC_CHAIN_REGNUM\t(3)\n \n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the TARGET_RETURN_IN_MEMORY\n    target hook.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-#define SHMEDIA_REGS_STACK_ADJUST() \\\n-  (TARGET_SHCOMPACT && crtl->saves_all_registers \\\n-   ? (8 * (/* r28-r35 */ 8 + /* r44-r59 */ 16 + /* tr5-tr7 */ 3) \\\n-      + (TARGET_FPU_ANY ? 4 * (/* fr36 - fr63 */ 28) : 0)) \\\n-   : 0)\n-\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -1177,20 +1070,13 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    145,146,147,148,149,152,153,154,155  }\n \n /* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS \\\n-  (!ALLOW_INDEXED_ADDRESS ? NO_REGS : TARGET_SHMEDIA ? GENERAL_REGS : R0_REGS)\n-#define BASE_REG_CLASS\t GENERAL_REGS\n+#define INDEX_REG_CLASS R0_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n \f\n /* Defines for sh.md and constraints.md.  */\n \n #define CONST_OK_FOR_I08(VALUE) (((HOST_WIDE_INT)(VALUE))>= -128 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 127)\n-#define CONST_OK_FOR_I16(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -32768 \\\n-\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 32767)\n-\n-#define CONST_OK_FOR_J16(VALUE) \\\n-  ((HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) 0xffffffff) \\\n-   || (HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) (HOST_WIDE_INT_M1U << 32)))\n \n #define CONST_OK_FOR_K08(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 255)\n@@ -1204,10 +1090,7 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    If TARGET_SHMEDIA, we need two FP registers per word.\n    Otherwise we will need at most one register per word.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n-    (TARGET_SHMEDIA \\\n-     && TEST_HARD_REG_BIT (reg_class_contents[CLASS], FIRST_FP_REG) \\\n-     ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD/2 - 1) / (UNITS_PER_WORD/2) \\\n-     : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.\n@@ -1222,17 +1105,17 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    These macros are used only in other macro definitions below.  */\n #define NPARM_REGS(MODE) \\\n   (TARGET_FPU_ANY && (MODE) == SFmode \\\n-   ? (TARGET_SH5 ? 12 : 8) \\\n+   ? 8 \\\n    : (TARGET_SH4 || TARGET_SH2A_DOUBLE) \\\n      && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n \t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n-   ? (TARGET_SH5 ? 12 : 8) \\\n-   : (TARGET_SH5 ? 8 : 4))\n+   ? 8 \\\n+   : 4)\n \n-#define FIRST_PARM_REG (FIRST_GENERAL_REG + (TARGET_SH5 ? 2 : 4))\n-#define FIRST_RET_REG  (FIRST_GENERAL_REG + (TARGET_SH5 ? 2 : 0))\n+#define FIRST_PARM_REG (FIRST_GENERAL_REG + 4)\n+#define FIRST_RET_REG  (FIRST_GENERAL_REG + 0)\n \n-#define FIRST_FP_PARM_REG (FIRST_FP_REG + (TARGET_SH5 ? 0 : 4))\n+#define FIRST_FP_PARM_REG (FIRST_FP_REG + 4)\n #define FIRST_FP_RET_REG FIRST_FP_REG\n \n /* Define this if pushing a word on the stack\n@@ -1261,10 +1144,8 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* Value is the number of bytes of arguments automatically popped when\n    calling a subroutine.\n-   CUM is the accumulated argument list.\n-\n-   On SHcompact, the call trampoline pops arguments off the stack.  */\n-#define CALL_POPS_ARGS(CUM) (TARGET_SHCOMPACT ? (CUM).stack_regs * 8 : 0)\n+   CUM is the accumulated argument list.  */\n+#define CALL_POPS_ARGS(CUM) (0)\n \n /* Some subroutine macros specific to this machine.  */\n \n@@ -1337,93 +1218,19 @@ struct sh_args {\n      by reference.  */\n     int byref;\n \n-  /* call_cookie is a bitmask used by call expanders, as well as\n-     function prologue and epilogues, to allow SHcompact to comply\n-     with the SH5 32-bit ABI, that requires 64-bit registers to be\n-     used even though only the lower 32-bit half is visible in\n-     SHcompact mode.  The strategy is to call SHmedia trampolines.\n-\n-     The alternatives for each of the argument-passing registers are\n-     (a) leave it unchanged; (b) pop it off the stack; (c) load its\n-     contents from the address in it; (d) add 8 to it, storing the\n-     result in the next register, then (c); (e) copy it from some\n-     floating-point register,\n-\n-     Regarding copies from floating-point registers, r2 may only be\n-     copied from dr0.  r3 may be copied from dr0 or dr2.  r4 maybe\n-     copied from dr0, dr2 or dr4.  r5 maybe copied from dr0, dr2,\n-     dr4 or dr6.  r6 may be copied from dr0, dr2, dr4, dr6 or dr8.\n-     r7 through to r9 may be copied from dr0, dr2, dr4, dr8, dr8 or\n-     dr10.\n-\n-     The bit mask is structured as follows:\n-\n-     - 1 bit to tell whether to set up a return trampoline.\n-\n-     - 3 bits to count the number consecutive registers to pop off the\n-       stack.\n-\n-     - 4 bits for each of r9, r8, r7 and r6.\n-\n-     - 3 bits for each of r5, r4, r3 and r2.\n-\n-     - 3 bits set to 0 (the most significant ones)\n-\n-        3           2            1           0\n-       1098 7654 3210 9876 5432 1098 7654 3210\n-       FLPF LPFL PFLP FFLP FFLP FFLP FFLP SSST\n-       2223 3344 4555 6666 7777 8888 9999 SSS-\n-\n-     - If F is set, the register must be copied from an FP register,\n-       whose number is encoded in the remaining bits.\n-\n-     - Else, if L is set, the register must be loaded from the address\n-       contained in it.  If the P bit is *not* set, the address of the\n-       following dword should be computed first, and stored in the\n-       following register.\n-\n-     - Else, if P is set, the register alone should be popped off the\n-       stack.\n-\n-     - After all this processing, the number of registers represented\n-       in SSS will be popped off the stack.  This is an optimization\n-       for pushing/popping consecutive registers, typically used for\n-       varargs and large arguments partially passed in registers.\n-\n-     - If T is set, a return trampoline will be set up for 64-bit\n-     return values to be split into 2 32-bit registers.  */\n-    long call_cookie;\n-\n   /* This is set to nonzero when the call in question must use the Renesas ABI,\n      even without the -mrenesas option.  */\n     int renesas_abi;\n };\n \n-#define CALL_COOKIE_RET_TRAMP_SHIFT 0\n-#define CALL_COOKIE_RET_TRAMP(VAL) ((VAL) << CALL_COOKIE_RET_TRAMP_SHIFT)\n-#define CALL_COOKIE_STACKSEQ_SHIFT 1\n-#define CALL_COOKIE_STACKSEQ(VAL) ((VAL) << CALL_COOKIE_STACKSEQ_SHIFT)\n-#define CALL_COOKIE_STACKSEQ_GET(COOKIE) \\\n-  (((COOKIE) >> CALL_COOKIE_STACKSEQ_SHIFT) & 7)\n-#define CALL_COOKIE_INT_REG_SHIFT(REG) \\\n-  (4 * (7 - (REG)) + (((REG) <= 2) ? ((REG) - 2) : 1) + 3)\n-#define CALL_COOKIE_INT_REG(REG, VAL) \\\n-  ((VAL) << CALL_COOKIE_INT_REG_SHIFT (REG))\n-#define CALL_COOKIE_INT_REG_GET(COOKIE, REG) \\\n-  (((COOKIE) >> CALL_COOKIE_INT_REG_SHIFT (REG)) & ((REG) < 4 ? 7 : 15))\n-\n #define CUMULATIVE_ARGS  struct sh_args\n \n #define GET_SH_ARG_CLASS(MODE) \\\n   ((TARGET_FPU_ANY && (MODE) == SFmode) \\\n    ? SH_ARG_FLOAT \\\n-   /* There's no mention of complex float types in the SH5 ABI, so we\n-      should presumably handle them as aggregate types.  */ \\\n-   : TARGET_SH5 && GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n-   ? SH_ARG_INT \\\n    : TARGET_FPU_DOUBLE && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n \t\t\t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n-   ? SH_ARG_FLOAT : SH_ARG_INT)\n+     ? SH_ARG_FLOAT : SH_ARG_INT)\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -1458,78 +1265,11 @@ struct sh_args {\n    foo (float a, __complex float b); a: fr5 b.real: fr4 b.imag: fr7  */\n #define FUNCTION_ARG_SCmode_WART 1\n \n-/* If an argument of size 5, 6 or 7 bytes is to be passed in a 64-bit\n-   register in SHcompact mode, it must be padded in the most\n-   significant end.  This means that passing it by reference wouldn't\n-   pad properly on a big-endian machine.  In this particular case, we\n-   pass this argument on the stack, in a way that the call trampoline\n-   will load its value into the appropriate register.  */\n-#define SHCOMPACT_FORCE_ON_STACK(MODE,TYPE) \\\n-  ((MODE) == BLKmode \\\n-   && TARGET_SHCOMPACT \\\n-   && TARGET_BIG_ENDIAN \\\n-   && int_size_in_bytes (TYPE) > 4 \\\n-   && int_size_in_bytes (TYPE) < 8)\n-\n /* Minimum alignment for an argument to be passed by callee-copy\n    reference.  We need such arguments to be aligned to 8 byte\n    boundaries, because they'll be loaded using quad loads.  */\n #define SH_MIN_ALIGN_FOR_CALLEE_COPY (8 * BITS_PER_UNIT)\n \n-/* The SH5 ABI requires floating-point arguments to be passed to\n-   functions without a prototype in both an FP register and a regular\n-   register or the stack.  When passing the argument in both FP and\n-   general-purpose registers, list the FP register first.  */\n-#define SH5_PROTOTYPELESS_FLOAT_ARG(CUM,MODE) \\\n-  (gen_rtx_PARALLEL\t\t\t\t\t\t\t\\\n-   ((MODE),\t\t\t\t\t\t\t\t\\\n-    gen_rtvec (2,\t\t\t\t\t\t\t\\\n-\t       gen_rtx_EXPR_LIST\t\t\t\t\t\\\n-\t       (VOIDmode,\t\t\t\t\t\t\\\n-\t\t((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode) \\\n-\t\t ? gen_rtx_REG ((MODE), FIRST_FP_PARM_REG\t\t\\\n-\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_FLOAT])\t\\\n-\t\t : NULL_RTX),\t\t\t\t\t\t\\\n-\t\tconst0_rtx),\t\t\t\t\t\t\\\n-\t       gen_rtx_EXPR_LIST\t\t\t\t\t\\\n-\t       (VOIDmode,\t\t\t\t\t\t\\\n-\t\t((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode) \\\n-\t\t ? gen_rtx_REG ((MODE), FIRST_PARM_REG\t\t\t\\\n-\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_INT])\t\\\n-\t\t : gen_rtx_REG ((MODE), FIRST_FP_PARM_REG\t\t\\\n-\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_FLOAT])), \\\n-\t\tconst0_rtx))))\n-\n-/* The SH5 ABI requires regular registers or stack slots to be\n-   reserved for floating-point arguments.  Registers are taken care of\n-   in FUNCTION_ARG_ADVANCE, but stack slots must be reserved here.\n-   Unfortunately, there's no way to just reserve a stack slot, so\n-   we'll end up needlessly storing a copy of the argument in the\n-   stack.  For incoming arguments, however, the PARALLEL will be\n-   optimized to the register-only form, and the value in the stack\n-   slot won't be used at all.  */\n-#define SH5_PROTOTYPED_FLOAT_ARG(CUM,MODE,REG) \\\n-  ((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\t\\\n-   ? gen_rtx_REG ((MODE), (REG))\t\t\t\t\t\\\n-   : gen_rtx_PARALLEL ((MODE),\t\t\t\t\t\t\\\n-\t\t       gen_rtvec (2,\t\t\t\t\t\\\n-\t\t\t\t  gen_rtx_EXPR_LIST\t\t\t\\\n-\t\t\t\t  (VOIDmode, NULL_RTX,\t\t\t\\\n-\t\t\t\t   const0_rtx),\t\t\t\t\\\n-\t\t\t\t  gen_rtx_EXPR_LIST\t\t\t\\\n-\t\t\t\t  (VOIDmode, gen_rtx_REG ((MODE),\t\\\n-\t\t\t\t\t\t\t  (REG)),\t\\\n-\t\t\t\t   const0_rtx))))\n-\n-#define SH5_WOULD_BE_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  (TARGET_SH5\t\t\t\t\t\t\t\\\n-   && ((MODE) == BLKmode || (MODE) == TImode || (MODE) == CDImode \\\n-       || (MODE) == DCmode) \\\n-   && ((CUM).arg_count[(int) SH_ARG_INT]\t\t\t\\\n-       + (((MODE) == BLKmode ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t\t     : GET_MODE_SIZE (MODE))\t\t\\\n-\t  + 7) / 8) > NPARM_REGS (SImode))\n-\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.  */\n \n@@ -1539,19 +1279,10 @@ struct sh_args {\n    from the trapa instruction.  */\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf((STREAM), \"\\tmovi\\t33,r0\\n\");\t\t\t\\\n-      fprintf((STREAM), \"\\ttrapa\\tr0\\n\");\t\t\t\\\n-      asm_fprintf((STREAM), \"\\t.long\\t%LLP%d\\n\", (LABELNO));\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf((STREAM), \"\\t.align\\t2\\n\");\t\t\t\\\n-      fprintf((STREAM), \"\\ttrapa\\t#33\\n\");\t\t\t\\\n-      fprintf((STREAM), \"\\t.align\\t2\\n\");\t\t\t\\\n-      asm_fprintf((STREAM), \"\\t.long\\t%LLP%d\\n\", (LABELNO));\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+  fprintf((STREAM), \"\\t.align\\t2\\n\");\t\t\t\t\\\n+  fprintf((STREAM), \"\\ttrapa\\t#33\\n\");\t\t\t\t\\\n+  fprintf((STREAM), \"\\t.align\\t2\\n\");\t\t\t\t\\\n+  asm_fprintf((STREAM), \"\\t.long\\t%LLP%d\\n\", (LABELNO));\t\\\n }\n \n /* Define this macro if the code for function profiling should come\n@@ -1575,14 +1306,13 @@ struct sh_args {\n    6 000c 00000000 \tl2:\t.long   function  */\n \n /* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE \\\n-  (TARGET_SHMEDIA64 ? 40 : TARGET_SH5 ? 24 : TARGET_FDPIC ? 32 : 16)\n+#define TRAMPOLINE_SIZE (TARGET_FDPIC ? 32 : 16)\n \n /* Alignment required for a trampoline in bits.  */\n #define TRAMPOLINE_ALIGNMENT \\\n   ((CACHE_LOG < 3 \\\n-    || (optimize_size && ! (TARGET_HARD_SH4 || TARGET_SH5))) ? 32 \\\n-   : TARGET_SHMEDIA ? 256 : 64)\n+    || (optimize_size && ! (TARGET_HARD_SH4))) ? 32 \\\n+   : 64)\n \n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.\n@@ -1596,8 +1326,7 @@ struct sh_args {\n    prologue.  This RTL is either a REG, indicating that the return\n    value is saved in REG, or a MEM representing a location in\n    the stack.  */\n-#define INCOMING_RETURN_ADDR_RTX \\\n-  gen_rtx_REG (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, PR_REG)\n \f\n /* Addressing modes, and classification of registers for them.  */\n #define HAVE_POST_INCREMENT  TARGET_SH1\n@@ -1627,10 +1356,7 @@ struct sh_args {\n   (GENERAL_OR_AP_REGISTER_P (REGNO) \\\n    || GENERAL_OR_AP_REGISTER_P (reg_renumber[(REGNO)]))\n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  (TARGET_SHMEDIA \\\n-   ? (GENERAL_REGISTER_P (REGNO) \\\n-      || GENERAL_REGISTER_P ((unsigned) reg_renumber[(REGNO)])) \\\n-   : (REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)\n+  ((REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)\n \n /* True if SYMBOL + OFFSET constants must refer to something within\n    SYMBOL's section.  */\n@@ -1655,14 +1381,12 @@ struct sh_args {\n \n /* Nonzero if X is a reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n-  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X))\t\\\n-    : REGNO (X) == R0_REG)\t\t\t\t\\\n+  ((REGNO (X) == R0_REG)\t\t\t\t\\\n    || (!STRICT && REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n /* Nonzero if X/OFFSET is a reg that can be used as an index.  */\n #define SUBREG_OK_FOR_INDEX_P(X, OFFSET, STRICT)\t\\\n-  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X))\t\\\n-    : REGNO (X) == R0_REG && OFFSET == 0)\t\t\\\n+  ((REGNO (X) == R0_REG && OFFSET == 0)\t\t\t\\\n    || (!STRICT && REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n /* Macros for extra constraints.  */\n@@ -1683,13 +1407,6 @@ struct sh_args {\n \t   && !PIC_ADDR_P (OP)\t\t\t\t\t\t\\\n \t   && GET_CODE (OP) != LABEL_REF)))\n \n-/* Check whether OP is a datalabel unspec.  */\n-#define DATALABEL_REF_NO_CONST_P(OP) \\\n-  (GET_CODE (OP) == UNSPEC \\\n-   && XINT ((OP), 1) == UNSPEC_DATALABEL \\\n-   && XVECLEN ((OP), 0) == 1 \\\n-   && GET_CODE (XVECEXP ((OP), 0, 0)) == LABEL_REF)\n-\n #define GOT_ENTRY_P(OP) \\\n   (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n    && XINT (XEXP ((OP), 0), 1) == UNSPEC_GOT)\n@@ -1721,24 +1438,16 @@ struct sh_args {\n   (GET_CODE (OP) == LABEL_REF || GET_CODE (OP) == SYMBOL_REF \\\n    || (GET_CODE (OP) == CONST \\\n        && (GET_CODE (XEXP ((OP), 0)) == LABEL_REF \\\n-\t   || GET_CODE (XEXP ((OP), 0)) == SYMBOL_REF \\\n-\t   || DATALABEL_REF_NO_CONST_P (XEXP ((OP), 0)))) \\\n+\t   || GET_CODE (XEXP ((OP), 0)) == SYMBOL_REF)) \\\n    || (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == PLUS \\\n        && (GET_CODE (XEXP (XEXP ((OP), 0), 0)) == SYMBOL_REF \\\n-\t   || GET_CODE (XEXP (XEXP ((OP), 0), 0)) == LABEL_REF \\\n-\t   || DATALABEL_REF_NO_CONST_P (XEXP (XEXP ((OP), 0), 0))) \\\n+\t   || GET_CODE (XEXP (XEXP ((OP), 0), 0)) == LABEL_REF) \\\n        && CONST_INT_P (XEXP (XEXP ((OP), 0), 1))))\n \n #define PIC_REFERENCE_P(OP) \\\n   (GOT_ENTRY_P (OP) || GOTPLT_ENTRY_P (OP) \\\n    || GOTOFF_P (OP) || PIC_ADDR_P (OP))\n \n-#define MOVI_SHORI_BASE_OPERAND_P(OP) \\\n-  (flag_pic \\\n-   ? (GOT_ENTRY_P (OP) || GOTPLT_ENTRY_P (OP)  || GOTOFF_P (OP) \\\n-      || PCREL_SYMOFF_P (OP)) \\\n-   : NON_PIC_REFERENCE_P (OP))\n-\f\n #define MAYBE_BASE_REGISTER_RTX_P(X, STRICT)\t\t\t\\\n   ((REG_P (X) && REG_OK_FOR_BASE_P (X, STRICT))\t\\\n    || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n@@ -1766,8 +1475,6 @@ struct sh_args {\n #define INDEX_REGISTER_RTX_P(X) MAYBE_INDEX_REGISTER_RTX_P(X, false)\n #endif\n \n-#define ALLOW_INDEXED_ADDRESS \\\n-  ((!TARGET_SHMEDIA32 && !TARGET_SHCOMPACT) || TARGET_ALLOW_INDEXED_ADDRESS)\n \f\n /* A C compound statement that attempts to replace X, which is an address\n    that needs reloading, with a valid memory address for an operand of\n@@ -1808,10 +1515,10 @@ struct sh_args {\n #define DEFAULT_SIGNED_CHAR  1\n \n /* The type of size_t unsigned int.  */\n-#define SIZE_TYPE (TARGET_SH5 ? \"long unsigned int\" : \"unsigned int\")\n+#define SIZE_TYPE (\"unsigned int\")\n \n #undef  PTRDIFF_TYPE\n-#define PTRDIFF_TYPE (TARGET_SH5 ? \"long int\" : \"int\")\n+#define PTRDIFF_TYPE (\"int\")\n \n #define WCHAR_TYPE \"short unsigned int\"\n #define WCHAR_TYPE_SIZE 16\n@@ -1820,15 +1527,15 @@ struct sh_args {\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX (TARGET_SHMEDIA ? 8 : 4)\n+#define MOVE_MAX (4)\n \n /* Maximum value possibly taken by MOVE_MAX.  Must be defined whenever\n    MOVE_MAX is not a compile-time constant.  */\n #define MAX_MOVE_MAX 8\n \n /* Max number of bytes we want move_by_pieces to be able to copy\n    efficiently.  */\n-#define MOVE_MAX_PIECES (TARGET_SH4 || TARGET_SHMEDIA ? 8 : 4)\n+#define MOVE_MAX_PIECES (TARGET_SH4 ? 8 : 4)\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n@@ -1841,9 +1548,7 @@ struct sh_args {\n    For SHmedia, we can truncate to QImode easier using zero extension.\n    FP registers can load SImode values, but don't implicitly sign-extend\n    them to DImode.  */\n-#define LOAD_EXTEND_OP(MODE) \\\n- (((MODE) == QImode  && TARGET_SHMEDIA) ? ZERO_EXTEND \\\n-  : (MODE) != SImode ? SIGN_EXTEND : UNKNOWN)\n+#define LOAD_EXTEND_OP(MODE) ((MODE) != SImode ? SIGN_EXTEND : UNKNOWN)\n \n /* Define if loading short immediate values into registers sign extends.  */\n #define SHORT_IMMEDIATES_SIGN_EXTEND 1\n@@ -1878,9 +1583,7 @@ struct sh_args {\n #define SHIFT_COUNT_TRUNCATED (0)\n \n /* All integers have the same format so truncation is easy.  */\n-/* But SHmedia must sign-extend DImode when truncating to SImode.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) \\\n- (!TARGET_SHMEDIA || (INPREC) < 64 || (OUTPREC) >= 64)\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) (true)\n \n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd.\n@@ -1889,7 +1592,7 @@ struct sh_args {\n /*#define NO_FUNCTION_CSE 1*/\n \n /* The machine modes of pointers and functions.  */\n-#define Pmode  (TARGET_SHMEDIA64 ? DImode : SImode)\n+#define Pmode  (SImode)\n #define FUNCTION_MODE  Pmode\n \n /* The multiply insn on the SH1 and the divide insns on the SH1 and SH2\n@@ -1929,8 +1632,7 @@ struct sh_args {\n \t((! nonpic_symbol_mentioned_p (X)\t\t\t\\\n \t  && (GET_CODE (X) != SYMBOL_REF\t\t\t\\\n \t      || ! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n-\t      || ! nonpic_symbol_mentioned_p (get_pool_constant (X)))) \\\n-\t || (TARGET_SHMEDIA && GET_CODE (X) == LABEL_REF))\n+\t      || ! nonpic_symbol_mentioned_p (get_pool_constant (X)))))\n \n #define SYMBOLIC_CONST_P(X)\t\\\n ((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF)\t\\\n@@ -1944,7 +1646,7 @@ struct sh_args {\n    register information here is not used for SFmode.  */\n #define REGCLASS_HAS_GENERAL_REG(CLASS) \\\n   ((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS || (CLASS) == NON_SP_REGS \\\n-    || (! TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\n+    || ((CLASS) == SIBCALL_REGS))\n \n #define REGCLASS_HAS_FP_REG(CLASS) \\\n   ((CLASS) == FP0_REGS || (CLASS) == FP_REGS \\\n@@ -1971,19 +1673,13 @@ struct sh_args {\n #define SET_ASM_OP\t\t\"\\t.set\\t\"\n \n /* How to change between sections.  */\n-#define TEXT_SECTION_ASM_OP\t(TARGET_SHMEDIA32 \\\n-\t\t\t\t? \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\" \\\n-\t\t\t\t: \"\\t.text\")\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\n #define DATA_SECTION_ASM_OP\t\"\\t.data\"\n \n #if defined CRT_BEGIN || defined CRT_END\n /* Arrange for TEXT_SECTION_ASM_OP to be a compile-time constant.  */\n-# undef TEXT_SECTION_ASM_OP\n-# if __SHMEDIA__ == 1 && __SH5__ == 32\n-#  define TEXT_SECTION_ASM_OP \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\"\n-# else\n-#  define TEXT_SECTION_ASM_OP \"\\t.text\"\n-# endif\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n #endif\n \n #ifndef BSS_SECTION_ASM_OP\n@@ -2027,24 +1723,12 @@ struct sh_args {\n \n #define ASM_OUTPUT_REG_PUSH(file, v) \\\n {\t\t\t\t\t\t\t\\\n-  if (TARGET_SHMEDIA)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf ((file), \"\\taddi.l\\tr15,-8,r15\\n\");\t\\\n-      fprintf ((file), \"\\tst.q\\tr15,0,r%d\\n\", (v));\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf ((file), \"\\tmov.l\\tr%d,@-r15\\n\", (v));\t\\\n+  fprintf ((file), \"\\tmov.l\\tr%d,@-r15\\n\", (v));\t\\\n }\n \n #define ASM_OUTPUT_REG_POP(file, v) \\\n {\t\t\t\t\t\t\t\\\n-  if (TARGET_SHMEDIA)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf ((file), \"\\tld.q\\tr15,0,r%d\\n\", (v));\t\\\n-      fprintf ((file), \"\\taddi.l\\tr15,8,r15\\n\");\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf ((file), \"\\tmov.l\\t@r15+,r%d\\n\", (v));\t\\\n+  fprintf ((file), \"\\tmov.l\\t@r15+,r%d\\n\", (v));\t\\\n }\n \n /* DBX register number for a given compiler register number.  */\n@@ -2064,43 +1748,39 @@ struct sh_args {\n #define SH_DBX_REGISTER_NUMBER(REGNO) \\\n   (IN_RANGE ((REGNO), \\\n \t     (unsigned HOST_WIDE_INT) FIRST_GENERAL_REG, \\\n-\t     FIRST_GENERAL_REG + (TARGET_SH5 ? 63U :15U)) \\\n+\t     FIRST_GENERAL_REG + 15U) \\\n    ? ((unsigned) (REGNO) - FIRST_GENERAL_REG) \\\n    : ((int) (REGNO) >= FIRST_FP_REG \\\n      && ((int) (REGNO) \\\n-\t <= (FIRST_FP_REG + \\\n-\t     ((TARGET_SH5 && TARGET_FPU_ANY) ? 63 : TARGET_SH2E ? 15 : -1)))) \\\n-   ? ((unsigned) (REGNO) - FIRST_FP_REG \\\n-      + (TARGET_SH5 ? 77 : 25)) \\\n+\t <= (FIRST_FP_REG + (TARGET_SH2E ? 15 : -1)))) \\\n+   ? ((unsigned) (REGNO) - FIRST_FP_REG + 25) \\\n    : XD_REGISTER_P (REGNO) \\\n-   ? ((unsigned) (REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87)) \\\n+   ? ((unsigned) (REGNO) - FIRST_XD_REG + 87) \\\n    : TARGET_REGISTER_P (REGNO) \\\n    ? ((unsigned) (REGNO) - FIRST_TARGET_REG + 68) \\\n    : (REGNO) == PR_REG \\\n-   ? (TARGET_SH5 ? 18 : 17) \\\n+   ? (17) \\\n    : (REGNO) == PR_MEDIA_REG \\\n-   ? (TARGET_SH5 ? 18 : (unsigned) -1) \\\n+   ? ((unsigned) -1) \\\n    : (REGNO) == GBR_REG \\\n-   ? (TARGET_SH5 ? 238 : 18) \\\n+   ? (18) \\\n    : (REGNO) == MACH_REG \\\n-   ? (TARGET_SH5 ? 239 : 20) \\\n+   ? (20) \\\n    : (REGNO) == MACL_REG \\\n-   ? (TARGET_SH5 ? 240 : 21) \\\n+   ? (21) \\\n    : (REGNO) == T_REG \\\n-   ? (TARGET_SH5 ? 242 : 22) \\\n+   ? (22) \\\n    : (REGNO) == FPUL_REG \\\n-   ? (TARGET_SH5 ? 244 : 23) \\\n+   ? (23) \\\n    : (REGNO) == FPSCR_REG \\\n-   ? (TARGET_SH5 ? 243 : 24) \\\n+   ? (24) \\\n    : (unsigned) -1)\n \n /* This is how to output a reference to a symbol_ref.  On SH5,\n    references to non-code symbols must be preceded by `datalabel'.  */\n #define ASM_OUTPUT_SYMBOL_REF(FILE,SYM)\t\t\t\\\n   do \t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      if (TARGET_SH5 && !SYMBOL_REF_FUNCTION_P (SYM))\t\\\n-\tfputs (\"datalabel \", (FILE));\t\t\t\\\n       assemble_name ((FILE), XSTR ((SYM), 0));\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n@@ -2123,30 +1803,12 @@ struct sh_args {\n   switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n     case SImode:\t\t\t\t\t\t\t\\\n-      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-datalabel %LL%d\\n\",\t\\\n-\t\t       (VALUE), (REL));\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     case HImode:\t\t\t\t\t\t\t\\\n-      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-datalabel %LL%d\\n\",\t\\\n-\t\t       (VALUE), (REL));\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     case QImode:\t\t\t\t\t\t\t\\\n-      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-datalabel %LL%d\\n\",\t\\\n-\t\t       (VALUE), (REL));\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     default:\t\t\t\t\t\t\t\t\\\n@@ -2188,8 +1850,7 @@ enum processor_type {\n   PROCESSOR_SH3,\n   PROCESSOR_SH3E,\n   PROCESSOR_SH4,\n-  PROCESSOR_SH4A,\n-  PROCESSOR_SH5\n+  PROCESSOR_SH4A\n };\n \n #define sh_cpu_attr ((enum attr_cpu)sh_cpu)\n@@ -2240,10 +1901,9 @@ extern int current_function_interrupt;\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n       && GET_MODE_SIZE (MODE) < 4/* ! UNITS_PER_WORD */)\\\n     (UNSIGNEDP) = ((MODE) == SImode ? 0 : (UNSIGNEDP)),\t\\\n-    (MODE) = (TARGET_SH1 ? SImode \\\n-\t      : TARGET_SHMEDIA32 ? SImode : DImode);\n+    (MODE) = (TARGET_SH1 ? SImode : DImode);\n \n-#define MAX_FIXED_MODE_SIZE (TARGET_SH5 ? 128 : 64)\n+#define MAX_FIXED_MODE_SIZE (64)\n \n /* Better to allocate once the maximum space for outgoing args in the\n    prologue rather than duplicate around each call.  */\n@@ -2264,11 +1924,9 @@ extern int current_function_interrupt;\n #define EPILOGUE_USES(REGNO) ((TARGET_SH2E || TARGET_SH4) \\\n \t\t\t      && (REGNO) == FPSCR_REG)\n \n-#define DWARF_FRAME_RETURN_COLUMN \\\n-  (TARGET_SH5 ? DWARF_FRAME_REGNUM (PR_MEDIA_REG) : DWARF_FRAME_REGNUM (PR_REG))\n+#define DWARF_FRAME_RETURN_COLUMN (DWARF_FRAME_REGNUM (PR_REG))\n \n-#define EH_RETURN_DATA_REGNO(N)\t\\\n-  ((N) < 4 ? (N) + (TARGET_SH5 ? 2U : 4U) : INVALID_REGNUM)\n+#define EH_RETURN_DATA_REGNO(N)\t((N) < 4 ? (N) + 4U : INVALID_REGNUM)\n \n #define EH_RETURN_STACKADJ_REGNO STATIC_CHAIN_REGNUM\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, EH_RETURN_STACKADJ_REGNO)\n@@ -2280,7 +1938,7 @@ extern int current_function_interrupt;\n     ? ((GLOBAL) ? DW_EH_PE_indirect | DW_EH_PE_datarel : DW_EH_PE_pcrel) \\\n     : ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \\\n        | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr))) \\\n-   | ((CODE) ? 0 : (TARGET_SHMEDIA64 ? DW_EH_PE_sdata8 : DW_EH_PE_sdata4)))\n+   | ((CODE) ? 0 : DW_EH_PE_sdata4))\n \n /* Handle special EH pointer encodings.  Absolute, pc-relative, and\n    indirect are handled automatically.  */\n@@ -2306,7 +1964,7 @@ extern int current_function_interrupt;\n       } \\\n   } while (0)\n \n-#if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__\n+#if (defined CRT_BEGIN || defined CRT_END)\n /* SH constant pool breaks the devices in crtstuff.c to control section\n    in where code resides.  We have to write it as asm code.  */\n #define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n@@ -2318,6 +1976,6 @@ extern int current_function_interrupt;\n 0:\t.p2align 2\\n\\\n 1:\t.long\t\" USER_LABEL_PREFIX #FUNC \" - 0b\\n\\\n 2:\\n\" TEXT_SECTION_ASM_OP);\n-#endif /* (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__ */\n+#endif /* (defined CRT_BEGIN || defined CRT_END) */\n \n #endif /* ! GCC_SH_H */"}, {"sha": "0e70ea2d9f27b7928233e7ffb8b8fd65b817a5b8", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 184, "deletions": 6628, "changes": 6812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb"}, {"sha": "a6b63dca6fa3b0a360ef66f11fc2e5f7074e4b8d", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -37,9 +37,6 @@ Mask(HARD_SH2A_DOUBLE)\n ;; Set if compiling for SH4 hardware (to be used for insn costs etc.)\n Mask(HARD_SH4)\n \n-;; Set if we should generate code for a SH5 CPU (either ISA).\n-Mask(SH5)\n-\n ;; Set if we should save all target registers.\n Mask(SAVE_ALL_TARGET_REGS)\n \n@@ -180,30 +177,6 @@ m4al\n Target RejectNegative Condition(SUPPORT_SH4AL)\n Generate SH4al-dsp code.\n \n-m5-32media\n-Target RejectNegative Condition(SUPPORT_SH5_32MEDIA)\n-Generate 32-bit SHmedia code.\n-\n-m5-32media-nofpu\n-Target RejectNegative Condition(SUPPORT_SH5_32MEDIA_NOFPU)\n-Generate 32-bit FPU-less SHmedia code.\n-\n-m5-64media\n-Target RejectNegative Condition(SUPPORT_SH5_64MEDIA)\n-Generate 64-bit SHmedia code.\n-\n-m5-64media-nofpu\n-Target RejectNegative Condition(SUPPORT_SH5_64MEDIA_NOFPU)\n-Generate 64-bit FPU-less SHmedia code.\n-\n-m5-compact\n-Target RejectNegative Condition(SUPPORT_SH5_32MEDIA)\n-Generate SHcompact code.\n-\n-m5-compact-nofpu\n-Target RejectNegative Condition(SUPPORT_SH5_32MEDIA_NOFPU)\n-Generate FPU-less SHcompact code.\n-\n maccumulate-outgoing-args\n Target Report Var(TARGET_ACCUMULATE_OUTGOING_ARGS) Init(1)\n Reserve space for outgoing arguments in the function prologue.\n@@ -244,17 +217,13 @@ mcbranch-force-delay-slot\n Target Report RejectNegative Var(TARGET_CBRANCH_FORCE_DELAY_SLOT) Init(0)\n Force the usage of delay slots for conditional branches.\n \n-mcut2-workaround\n-Target RejectNegative Var(TARGET_SH5_CUT2_WORKAROUND)\n-Enable SH5 cut2 workaround.\n-\n mdalign\n Target Report RejectNegative Mask(ALIGN_DOUBLE)\n Align doubles at 64-bit boundaries.\n \n mdiv=\n Target RejectNegative Joined Var(sh_div_str) Init(\"\")\n-Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table.\n+Division strategy, one of: call-div1, call-fp, call-table.\n \n mdivsi3_libfunc=\n Target RejectNegative Joined Var(sh_divsi3_libfunc) Init(\"\")\n@@ -272,10 +241,6 @@ mfixed-range=\n Target RejectNegative Joined Var(sh_fixed_range_str)\n Specify range of registers to make fixed.\n \n-mgettrcost=\n-Target RejectNegative Joined UInteger Var(sh_gettrcost) Init(-1)\n-Cost to assume for gettr insn.\n-\n mhitachi\n Target Report RejectNegative Mask(HITACHI)\n Follow Renesas (formerly Hitachi) / SuperH calling conventions.\n@@ -284,10 +249,6 @@ mieee\n Target Var(TARGET_IEEE)\n Increase the IEEE compliance for floating-point comparisons.\n \n-mindexed-addressing\n-Target Report Mask(ALLOW_INDEXED_ADDRESS) Condition(SUPPORT_ANY_SH5_32MEDIA)\n-Enable the use of the indexed addressing mode for SHmedia32/SHcompact.\n-\n minline-ic_invalidate\n Target Report Var(TARGET_INLINE_IC_INVALIDATE)\n inline code to invalidate instruction cache entries after setting up nested function trampolines.\n@@ -318,10 +279,6 @@ mprefergot\n Target Report RejectNegative Mask(PREFERGOT)\n Emit function-calls using global offset table when generating PIC.\n \n-mpt-fixed\n-Target Report Mask(PT_FIXED) Condition(SUPPORT_ANY_SH5)\n-Assume pt* instructions won't trap\n-\n mrelax\n Target Report RejectNegative Mask(RELAX)\n Shorten address references during linking."}, {"sha": "45e5a5cb499adf63453004bf270d905b221b8e30", "filename": "gcc/config/sh/sh64.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fsh64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fsh64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh64.h?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,22 +0,0 @@\n-/* Definitions of target machine for GNU compiler for SuperH SH 5.\n-   Copyright (C) 2000-2016 Free Software Foundation, Inc.\n-   Contributed by Alexandre Oliva <aoliva@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#undef SH_ELF_WCHAR_TYPE\n-#define SH_ELF_WCHAR_TYPE \"int\""}, {"sha": "6337441a8bd65877b03a1e9e9c983d90bb4f4a9c", "filename": "gcc/config/sh/shmedia.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fshmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fshmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fshmedia.h?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,30 +0,0 @@\n-/* Copyright (C) 2000-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _SHMEDIA_H\n-#define _SHMEDIA_H\n-\n-#include <ushmedia.h>\n-#include <sshmedia.h>\n-\n-#endif"}, {"sha": "f226113b59c1b203dd32f2989a96f4edcbb81ff5", "filename": "gcc/config/sh/shmedia.md", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fshmedia.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fshmedia.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fshmedia.md?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,94 +0,0 @@\n-;; DFA scheduling description for SH-5 SHmedia instructions.\n-;; Copyright (C) 2004-2016 Free Software Foundation, Inc.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; This is just a conversion of the old model using define_function_unit.\n-\n-;; When executing SHmedia code, the SH-5 is a fairly straightforward\n-;; single-issue machine.  It has four pipelines, the branch unit (br),\n-;; the integer and multimedia unit (imu), the load/store unit (lsu), and\n-;; the floating point unit (fpu).\n-\n-(define_automaton \"sh5inst_pipe, sh5fpu_pipe\")\n-\n-(define_cpu_unit \"sh5issue\" \"sh5inst_pipe\")\n-\n-(define_cpu_unit \"sh5fds\" \"sh5fpu_pipe\")\n-\n-;; Every instruction on SH-5 occupies the issue resource for at least one\n-;; cycle.\n-(define_insn_reservation \"shmedia1\" 1\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"!pt_media,ptabs_media,invalidate_line_media,dmpy_media,load_media,fload_media,fcmp_media,fmove_media,fparith_media,dfparith_media,fpconv_media,dfpconv_media,dfmul_media,store_media,fstore_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media\"))\n-  \"sh5issue\")\n-\n-;; Specify the various types of instruction which have latency > 1\n-(define_insn_reservation \"shmedia2\" 2\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"mcmp_media\"))\n-  \"sh5issue\")\n-\n-(define_insn_reservation \"shmedia3\" 3\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"dmpy_media,load_media,fcmp_media,mac_media\"))\n-  \"sh5issue\")\n-;; but see sh_adjust_cost for mac_media exception.\n-\n-(define_insn_reservation \"shmedia4\" 4\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"fload_media,fmove_media\"))\n-  \"sh5issue\")\n-\n-(define_insn_reservation \"shmedia_d2mpy\" 4\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"d2mpy_media\"))\n-  \"sh5issue*2\")\n-\n-(define_insn_reservation \"shmedia5\" 5\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"pt_media,ptabs_media\"))\n-  \"sh5issue\")\n-\n-(define_insn_reservation \"shmedia6\" 6\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"fparith_media,dfparith_media,fpconv_media,dfpconv_media\"))\n-  \"sh5issue\")\n-\n-(define_insn_reservation \"shmedia_invalidate\" 7\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"invalidate_line_media\"))\n-  \"sh5issue*7\")\n-\n-(define_insn_reservation \"shmedia_dfmul\" 9\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfmul_media\"))\n-  \"sh5issue*4\")\n-\n-(define_insn_reservation \"shmedia_atrans\" 10\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"atrans_media\"))\n-  \"sh5issue*5\")\n-\n-;; Floating-point divide and square-root occupy an additional resource,\n-;; which is not internally pipelined.  However, other instructions\n-;; can continue to issue.\n-(define_insn_reservation \"shmedia_fdiv\" 19\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"fdiv_media\"))\n-  \"sh5issue+sh5fds,sh5fds*18\")\n-\n-(define_insn_reservation \"shmedia_dfdiv\" 35\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfdiv_media\"))\n-  \"sh5issue+sh5fds,sh5fds*34\")"}, {"sha": "546ec3d211afc6a2b651b21019d3a916e272f257", "filename": "gcc/config/sh/sshmedia.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fsshmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fsshmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsshmedia.h?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,78 +0,0 @@\n-/* Copyright (C) 2000-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* sshmedia.h: Intrinsics corresponding to SHmedia instructions that\n-   may only be executed in privileged mode.  */\n-\n-#ifndef _SSHMEDIA_H\n-#define _SSHMEDIA_H\n-\n-#if __SHMEDIA__\n-__inline__ static unsigned long long sh_media_GETCON (unsigned int k)\n-  __attribute__((always_inline));\n-\n-__inline__ static\n-unsigned long long\n-sh_media_GETCON (unsigned int k)\n-{\n-  unsigned long long res;\n-  __asm__ __volatile__ (\"getcon\tcr%1, %0\" : \"=r\" (res) : \"n\" (k));\n-  return res;\n-}\n-\n-__inline__ static void sh_media_PUTCON (unsigned long long mm, unsigned int k)\n-  __attribute__((always_inline));\n-\n-__inline__ static\n-void\n-sh_media_PUTCON (unsigned long long mm, unsigned int k)\n-{\n-  __asm__ __volatile__ (\"putcon\t%0, cr%1\" : : \"r\" (mm), \"n\" (k));\n-}\n-\n-__inline__ static\n-unsigned long long\n-sh_media_GETCFG (unsigned long long mm, int s)\n-{\n-  unsigned long long res;\n-  __asm__ __volatile__ (\"getcfg\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"n\" (s));\n-  return res;\n-}\n-\n-__inline__ static\n-void\n-sh_media_PUTCFG (unsigned long long mm, int s, unsigned long long mw)\n-{\n-  __asm__ __volatile__ (\"putcfg\t%0, %1, %2\" : : \"r\" (mm), \"n\" (s), \"r\" (mw));\n-}\n-\n-__inline__ static\n-void\n-sh_media_SLEEP (void)\n-{\n-  __asm__ __volatile__ (\"sleep\");\n-}\n-#endif\n-\n-#endif"}, {"sha": "93007f94c9b5b9b28c2f173aa57b0d03f7be1c39", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=e1fab8ba2337fd3bdd9c7112fae22d7ab001c2eb", "patch": "@@ -2131,7 +2131,7 @@\n   [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool result output\n    (match_operand:QI 1 \"memory_operand\" \"\")\t\t;; memory\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n-  \"(TARGET_ATOMIC_ANY || TARGET_ENABLE_TAS) && !TARGET_SHMEDIA\"\n+  \"TARGET_ATOMIC_ANY || TARGET_ENABLE_TAS\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n \n@@ -2168,7 +2168,7 @@\n \t       (const_int 0)))\n    (set (mem:QI (match_dup 0))\n \t(unspec:QI [(const_int 128)] UNSPEC_ATOMIC))]\n-  \"TARGET_ENABLE_TAS && !TARGET_SHMEDIA\"\n+  \"TARGET_ENABLE_TAS\"\n   \"tas.b\t@%0\"\n   [(set_attr \"insn_class\" \"co_group\")])\n "}, {"sha": "8fc6bd1ea1826139c912f012c46f092306bce2dd", "filename": "gcc/config/sh/t-netbsd-sh5-64", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Ft-netbsd-sh5-64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Ft-netbsd-sh5-64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-netbsd-sh5-64?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1 +0,0 @@\n-MULTILIB_DIRNAMES= $(MULTILIB_RAW_DIRNAMES:/media64=)"}, {"sha": "3423b285cea66cd3a841e4c6d735669d11595e15", "filename": "gcc/config/sh/t-sh64", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Ft-sh64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Ft-sh64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh64?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,22 +0,0 @@\n-# Copyright (C) 2002-2016 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-MULTILIB_CPU_DIRS= $(ML_sh1) $(ML_sh2e) $(ML_sh2) $(ML_sh3e) $(ML_sh3) $(ML_sh4_nofpu) $(ML_sh4_single_only) $(ML_sh4_single) $(ML_sh4) $(ML_sh5_32media:m5-32media/=media32) $(ML_sh5_32media_nofpu:m5-32media-nofpu/=nofpu/media32) $(ML_sh5_compact:m5-compact/=compact) $(ML_sh5_compact_nofpu:m5-compact-nofpu/=nofpu/compact) $(ML_sh5_64media:m5-64media/=media64) $(ML_sh5_64media_nofpu:m5-64media-nofpu/=nofpu/media64)\n-\n-MULTILIB_RAW_DIRNAMES= $(MULTILIB_ENDIAN:/mb= mb) $(MULTILIB_CPU_DIRS:/=)\n-MULTILIB_DIRNAMES= $(MULTILIB_RAW_DIRNAMES)"}, {"sha": "4be53afc6f1f3ed8037c971acc500864651595b6", "filename": "gcc/config/sh/ushmedia.h", "status": "removed", "additions": 0, "deletions": 1091, "changes": 1091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fushmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e017d06c06e30b050bea7a3c3ba5c951734c07/gcc%2Fconfig%2Fsh%2Fushmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fushmedia.h?ref=50e017d06c06e30b050bea7a3c3ba5c951734c07", "patch": "@@ -1,1091 +0,0 @@\n-/* Copyright (C) 2000-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* ushmedia.h: Intrinsics corresponding to SHmedia instructions that\n-   may be executed in both user and privileged mode.  */\n-\n-#ifndef _USHMEDIA_H\n-#define _USHMEDIA_H\n-\n-#if __SHMEDIA__\n-#if ! __SH4_NO_FPU\n-typedef float __GCC_FV __attribute__ ((vector_size (4 * sizeof (float))));\n-typedef float __GCC_MTRX __attribute__ ((vector_size (16 * sizeof (float))));\n-#endif\n-\n-static __inline unsigned long long\n-sh_media_MABS_L (unsigned long long mm)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_absv2si2 ((v2si) mm);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MABS_W (unsigned long long mm)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_absv4hi2 ((v4hi) mm);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MADD_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_addv2si3 ((v2si) mm, (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MADD_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_addv4hi3 ((v4hi) mm, (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MADDS_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_ssaddv2si3 ((v2si) mm, (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MADDS_UB (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_usaddv8qi3 ((v8qi) mm, (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MADDS_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_ssaddv4hi3 ((v4hi) mm, (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPEQ_B (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPEQ_B ((v8qi) mm,\n-\t\t\t\t\t\t\t   (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPEQ_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPEQ_L ((v2si) mm,\n-\t\t\t\t\t\t\t   (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPEQ_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPEQ_W ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPGT_UB (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPGT_UB ((v8qi) mm,\n-\t\t\t\t\t\t\t   (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPGT_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPGT_L ((v2si) mm,\n-\t\t\t\t\t\t\t   (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCMPGT_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCMPGT_W ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-#define sh_media_MCMV __builtin_sh_media_MCMV\n-\n-static __inline unsigned long long\n-sh_media_MCNVS_LW (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCNVS_LW ((v2si) mm,\n-\t\t\t\t\t\t\t   (uv2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCNVS_WB (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCNVS_WB ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MCNVS_WUB (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MCNVS_WUB ((v4hi) mm,\n-\t\t\t\t\t\t\t    (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR1 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR1 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR2 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR2 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR3 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR3 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR4 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR4 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR5 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR5 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR6 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR6 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MEXTR7 (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MEXTR7 ((v8qi) mm,\n-\t\t\t\t\t\t\t (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMACFX_WL (unsigned long long mm, unsigned long long mn,\n-\t\t    unsigned long long mw)\n-{\n-  typedef float v2hi __attribute__ ((mode(V2HI)));\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));\n-\n-  long mm_l = (long) mm;\n-  long mn_l = (long) mn;\n-\n-  return ((unsigned long long)\n-    __builtin_sh_media_MMACFX_WL ((v2hi) mm_l, (v2hi) mn_l,\n-\t\t\t\t  (uv2si) mw));\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMACNFX_WL (unsigned long long mm, unsigned long long mn,\n-\t\t     unsigned long long mw)\n-{\n-  typedef float v2hi __attribute__ ((mode(V2HI)));\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));\n-\n-  long mm_l = (long) mm;\n-  long mn_l = (long) mn;\n-\n-  return ((unsigned long long)\n-    __builtin_sh_media_MMACNFX_WL ((v2hi) mm_l, (v2hi) mn_l,\n-\t\t\t\t   (uv2si) mw));\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMUL_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_mulv2si3 ((v2si) mm, (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMUL_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_mulv4hi3 ((v4hi) mm, (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULFX_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MMULFX_L ((v2si) mm,\n-\t\t\t\t\t\t\t   (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULFX_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MMULFX_W ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULFXRP_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MMULFXRP_W ((v4hi) mm,\n-\t\t\t\t\t\t\t     (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULHI_WL (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MMULHI_WL ((v4hi) mm,\n-\t\t\t\t\t\t\t    (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULLO_WL (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MMULLO_WL ((v4hi) mm,\n-\t\t\t\t\t\t\t    (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MMULSUM_WQ (unsigned long long mm, unsigned long long mn,\n-\t\t     unsigned long long mw)\n-{\n-  typedef unsigned int uv4hi __attribute__ ((mode(V4HI)));\n-\n-  return __builtin_sh_media_MMULSUM_WQ ((uv4hi) mm, (uv4hi) mn, mw);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MPERM_W (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MPERM_W ((v4hi) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSAD_UBQ (unsigned long long mm, unsigned long long mn,\n-\t\t   unsigned long long mw)\n-{\n-  typedef unsigned int uv8qi __attribute__ ((mode(V8QI)));\n-\n-  return __builtin_sh_media_MSAD_UBQ ((uv8qi) mm, (uv8qi) mn, mw);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHALDS_L (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHALDS_L ((v2si) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHALDS_W (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHALDS_W ((v4hi) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHARD_L (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_ashrv2si3 ((v2si) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHARD_W (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_ashrv4hi3 ((v4hi) mm, mn);\n-}\n-\n-#define sh_media_MSHARDS_Q __builtin_sh_media_MSHARDS_Q\n-\n-static __inline unsigned long long\n-sh_media_MSHFHI_B (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFHI_B ((v8qi) mm,\n-\t\t\t\t\t\t\t   (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHFHI_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFHI_L ((v2si) mm,\n-\t\t\t\t\t\t\t   (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHFHI_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFHI_W ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHFLO_B (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFLO_B ((v8qi) mm,\n-\t\t\t\t\t\t\t   (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHFLO_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFLO_L ((v2si) mm,\n-\t\t\t\t\t\t\t   (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHFLO_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sh_media_MSHFLO_W ((v4hi) mm,\n-\t\t\t\t\t\t\t   (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHLLD_L (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_ashlv2si3 ((v2si) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHLLD_W (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_ashlv4hi3 ((v4hi) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHLRD_L (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_lshrv2si3 ((v2si) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSHLRD_W (unsigned long long mm, unsigned int mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_lshrv4hi3 ((v4hi) mm, mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSUB_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_subv2si3 ((v2si) mm, (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSUB_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_subv4hi3 ((v4hi) mm, (v4hi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSUBS_L (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v2si __attribute__ ((mode(V2SI)));\n-\n-  return (unsigned long long) __builtin_sssubv2si3 ((v2si) mm, (v2si) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSUBS_UB (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_ussubv8qi3 ((v8qi) mm, (v8qi) mn);\n-}\n-\n-static __inline unsigned long long\n-sh_media_MSUBS_W (unsigned long long mm, unsigned long long mn)\n-{\n-  typedef float v4hi __attribute__ ((mode(V4HI)));\n-\n-  return (unsigned long long) __builtin_sssubv4hi3 ((v4hi) mm, (v4hi) mn);\n-}\n-\n-#if ! __SH4_NOFPU__\n-/* Floating-point Intrinsics */\n-\n-#define sh_media_FABS_D __builtin_fabs\n-#define sh_media_FABS_S __builtin_fabsf\n-#define sh_media_FCMPUN_D __builtin_isunordered\n-#define sh_media_FCMPUN_S __builtin_isunordered\n-\n-static __inline float sh_media_FCOSA_S (float fg)\n-{\n-  union { int i; float f; } u;\n-\n-  u.f = fg;\n-  return __builtin_sh_media_FCOSA_S (u.i);\n-}\n-\n-static __inline float\n-sh_media_FGETSCR (void)\n-{ \n-  float f;\n-\n-  __asm volatile (\"fgetscr %0\" : \"=f\" (f));\n-  return f;\n-}\n-\n-static __inline float\n-sh_media_FIPR_S (const void *fvg, const void *fvh)\n-{\n-  typedef float v4sf __attribute__ ((mode(V4SF)));\n-  v4sf vg = *(v4sf*) fvg;\n-  v4sf vh = *(v4sf*) fvh;\n-\n-  return __builtin_sh_media_FIPR_S (vg, vh);\n-}\n-\n-#if 0\n-/* This gives different results for -O0  */\n-static __inline float\n-sh_media_FMAC_S (float fg, float fh, float fq)\n-{\n-  return fg * fh + fq;\n-}\n-#else\n-\n-#define sh_media_FMAC_S __builtin_sh_media_FMAC_S\n-#endif\n-\n-static __inline long long\n-sh_media_FMOV_DQ (double dg)\n-{\n-  union { long long l; double d; } u;\n-\n-  u.d = dg;\n-  return u.l;\n-}\n-\n-static __inline float\n-sh_media_FMOV_LS (int mm)\n-{\n-  union { int i; float f; } u;\n-\n-  u.i = mm;\n-  return u.f;\n-}\n-\n-static __inline double\n-sh_media_FMOV_QD (long long mm)\n-{\n-  union { long long l; double d; } u;\n-\n-  u.l = mm;\n-  return u.d;\n-}\n-\n-static __inline int\n-sh_media_FMOV_SL (float fg)\n-{\n-  union { int i; float f; } u;\n-\n-  u.f = fg;\n-  return u.i;\n-}\n-\n-static __inline void\n-sh_media_FPUTSCR (float fg)\n-{ \n-  __asm volatile (\"fputscr %0\" : : \"f\" (fg));\n-}\n-\n-static __inline float sh_media_FSINA_S (float fg)\n-{\n-  union { int i; float f; } u;\n-\n-  u.f = fg;\n-  return __builtin_sh_media_FSINA_S (u.i);\n-}\n-\n-/* Can't use __builtin_sqrt / __builtin_sqrtf because they still implement\n-   error handling unless -ffast-math is used.  */\n-#define sh_media_FSQRT_D __builtin_sh_media_FSQRT_D\n-#define sh_media_FSQRT_S __builtin_sh_media_FSQRT_S\n-#define sh_media_FSRRA_S __builtin_sh_media_FSRRA_S\n-\n-static __inline void\n-sh_media_FTRV_S (const void *mtrxg, const void *fvh, void *fvf)\n-{\n-  typedef float v16sf __attribute__ ((mode(V16SF)));\n-  typedef float v4sf __attribute__ ((mode(V4SF)));\n-  v16sf mtrx = *(v16sf*) mtrxg;\n-  v4sf vh = *(v4sf*) fvh;\n-\n-  *(v4sf*) fvf = __builtin_sh_media_FTRV_S (mtrx, vh);\n-}\n-#endif /* ! __SH4_NOFPU__ */\n-\n-/* Not implemented here: Control and Configuration intrinsics.  */\n-/* Misaligned Access Support intrinsics */\n-\n-static __inline unsigned long long\n-sh_media_LDHI_L (void *p, int s)\n-{\n-  return __builtin_sh_media_LDHI_L ((char *)p + s);\n-}\n-\n-static __inline unsigned long long\n-sh_media_LDHI_Q (void *p, int s)\n-{\n-  return __builtin_sh_media_LDHI_Q ((char *)p + s);\n-}\n-\n-static __inline unsigned long long\n-sh_media_LDLO_L (void *p, int s)\n-{\n-  return __builtin_sh_media_LDLO_L ((char *)p + s);\n-}\n-\n-static __inline unsigned long long\n-sh_media_LDLO_Q (void *p, int s)\n-{\n-  return __builtin_sh_media_LDLO_Q ((char *)p + s);\n-}\n-\n-static __inline void\n-sh_media_STHI_L (void *p, int s, unsigned int mw)\n-{\n-  __builtin_sh_media_STHI_L ((char*)p + s, mw);\n-}\n-\n-static __inline void\n-sh_media_STHI_Q (void *p, int s, unsigned long long mw)\n-{\n-  __builtin_sh_media_STHI_Q ((char*)p + s, mw);\n-}\n-\n-static __inline void\n-sh_media_STLO_L (void *p, int s, unsigned int mw)\n-{\n-  __builtin_sh_media_STLO_L ((char*)p + s, mw);\n-}\n-\n-static __inline void\n-sh_media_STLO_Q (void *p, int s, unsigned long long mw)\n-{\n-  __builtin_sh_media_STLO_Q ((char*)p + s, mw);\n-}\n-\n-/* Miscellaneous intrinsics */\n-\n-#define sh_media_NSB __builtin_sh_media_NSB\n-\n-static __inline unsigned long long\n-sh_media_BYTEREV (unsigned long long mm)\n-{\n-  typedef float v8qi __attribute__ ((mode(V8QI)));\n-\n-  return (unsigned long long) __builtin_sh_media_BYTEREV ((v8qi) mm);\n-}\n-\n-__inline__ static unsigned long long\n-sh_media_CMVEQ (unsigned long long mm, unsigned long long mn, unsigned long long mw) __attribute__ ((always_inline));\n-\n-__inline__ static unsigned long long\n-sh_media_CMVEQ (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n-{\n-  return mm == 0 ? mn : mw;\n-}\n-\n-__inline__ static unsigned long long\n-sh_media_CMVNE (unsigned long long mm, unsigned long long mn, unsigned long long mw) __attribute__ ((always_inline));\n-\n-__inline__ static unsigned long long\n-sh_media_CMVNE (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n-{\n-  return mm != 0 ? mn : mw;\n-}\n-\n-static __inline long long\n-sh_media_ADDZ_L (unsigned int mm, unsigned int mn)\n-{\n-  return mm + mn;\n-}\n-\n-/* NOP and Synchronization intrinsics not implemented here.  */\n-\n-static __inline__ void sh_media_PREFO(void *mm, int s)\n-{\n-  __builtin_sh_media_PREFO (mm + s, 0, 0);\n-}\n-\n-/* Event Handling intrinsics not implemented here.  */\n-\n-/* Old asm stuff */\n-\n-static __inline__\n-void\n-sh_media_NOP (void)\n-{\n-  __asm__ (\"nop\" : :);\n-}\n-\n-__inline__ static\n-unsigned long long\n-sh_media_SWAP_Q (void *mm, long long mn, unsigned long long mw)\n-{\n-  unsigned long long res;\n-  unsigned long long *addr = (unsigned long long *)((char *)mm + mn);\n-  __asm__ (\"swap.q\t%m1, %0\" : \"=r\" (res), \"+o\" (*addr) : \"0\" (mw));\n-  return res;\n-}\n-\n-__inline__ static\n-void     \n-sh_media_SYNCI (void)\n-{\n-  __asm__ __volatile__ (\"synci\");\n-}\n-\n-__inline__ static\n-void     \n-sh_media_SYNCO (void)\n-{\n-  __asm__ __volatile__ (\"synco\");\n-}\n-\n-__inline__ static\n-void\n-sh_media_ALLOCO (void *mm, int s)\n-{\n-  __builtin_sh_media_ALLOCO (mm + s);\n-}\n-\n-__inline__ static\n-void\n-sh_media_ICBI (void *mm, int s)\n-{\n-  __asm__ __volatile__ (\"icbi\t%m0\" : : \"o\" (((char*)mm)[s]));\n-}\n-\n-__inline__ static\n-void\n-sh_media_OCBI (void *mm, int s)\n-{\n-  __asm__ __volatile__ (\"ocbi\t%m0\" : : \"o\" (((char*)mm)[s]));\n-}\n-\n-__inline__ static\n-void\n-sh_media_OCBP (void *mm, int s)\n-{\n-  __asm__ __volatile__ (\"ocbp\t%m0\" : : \"o\" (((char*)mm)[s]));\n-}\n-\n-__inline__ static\n-void\n-sh_media_OCBWB (void *mm, int s)\n-{\n-  __asm__ __volatile__ (\"ocbwb\t%m0\" : : \"o\" (((char*)mm)[s]));\n-}\n-\n-__inline__ static\n-void\n-sh_media_PREFI (void *mm, int s)\n-{\n-  __asm__ __volatile__ (\"prefi\t%m0\" : : \"o\" (((char*)mm)[s]));\n-}\n-\n-__inline__ static\n-void\n-sh_media_BRK (void)\n-{\n-  __asm__ __volatile__ (\"brk\");\n-}\n-\n-__inline__ static\n-void\n-sh_media_TRAPA (unsigned long long mm)\n-{\n-  __asm__ __volatile__ (\"trapa\t%%0\" : : \"r\" (mm));\n-}\n-\n-__inline__ static\n-short         \n-sh_media_unaligned_LD_W (void *p)\n-{\n-#if __LITTLE_ENDIAN__\n-  return (((unsigned char *)p)[0]\n-\t  | (((short)((__signed__ char *)p)[1]) << 8));\n-#else\n-  return ((((short)((__signed__ char *)p)[0]) << 8)\n-\t  | ((unsigned char *)p)[1]);\n-#endif\n-}\n-\n-__inline__ static\n-unsigned short\n-sh_media_unaligned_LD_UW (void *p)\n-{\n-  unsigned char *addr = p;\n-#if __LITTLE_ENDIAN__\n-  return sh_media_MSHFLO_B (addr[0], addr[1]);\n-#else\n-  return sh_media_MSHFLO_B (addr[1], addr[0]);\n-#endif\n-}\n-\n-/* We don't use the sh_media_LD* functions here because that turned out\n-   to impede constant propagation of the offsets into the ldhi / ldlo\n-   instructions.  */\n-__inline__ static\n-int           \n-sh_media_unaligned_LD_L (void *p)\n-{\n-#if __LITTLE_ENDIAN__\n-  return (__builtin_sh_media_LDHI_L ((char *)p + 3)\n-\t  | __builtin_sh_media_LDLO_L (p));\n-#else\n-  return (__builtin_sh_media_LDLO_L ((char *)p + 3)\n-\t  | __builtin_sh_media_LDHI_L (p));\n-#endif\n-}\n-\n-__inline__ static\n-long long     \n-sh_media_unaligned_LD_Q (void *p)\n-{\n-#if __LITTLE_ENDIAN__\n-  return (__builtin_sh_media_LDHI_Q ((char *)p + 7)\n-\t  | __builtin_sh_media_LDLO_Q (p));\n-#else\n-  return (__builtin_sh_media_LDLO_Q ((char *)p + 7)\n-\t  | __builtin_sh_media_LDHI_Q (p));\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_unaligned_ST_W (void *p, unsigned int k)\n-{\n-  char *addr = p;\n-#if __LITTLE_ENDIAN__\n-  addr[0] = k;\n-  addr[1] = k >> 8;\n-#else\n-  addr[1] = k;\n-  addr[0] = k >> 8;\n-#endif\n-}\n-\n-/* We don't use the sh_media_ST* functions here because that turned out\n-   to impede constant propagation of the offsets into the ldhi / ldlo\n-   instructions.  */\n-__inline__ static\n-void\n-sh_media_unaligned_ST_L (void *p, unsigned int k)\n-{\n-#if __LITTLE_ENDIAN__\n-  __builtin_sh_media_STHI_L (p + 3, k);\n-  __builtin_sh_media_STLO_L (p, k);\n-#else\n-  __builtin_sh_media_STLO_L (p + 3, k);\n-  __builtin_sh_media_STHI_L (p, k);\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_unaligned_ST_Q (void *p, unsigned long long k)\n-{\n-#if __LITTLE_ENDIAN__\n-  __builtin_sh_media_STHI_Q (p + 7, k);\n-  __builtin_sh_media_STLO_Q (p, k);\n-#else\n-  __builtin_sh_media_STLO_Q (p + 7, k);\n-  __builtin_sh_media_STHI_Q (p, k);\n-#endif\n-}\n-\n-#if ! __SH4_NOFPU__\n-__inline__ static\n-void\n-sh_media_FVCOPY_S (const void *fvg, void *fvf)\n-{\n-  const __GCC_FV *g = fvg;\n-  __GCC_FV *f = fvf;\n-  *f = *g;\n-}\n-\n-__inline__ static\n-void\n-sh_media_FVADD_S (const void *fvg, const void *fvh, void *fvf)\n-{\n-  const float *g = fvg, *h = fvh;\n-  float *f = fvf;\n-#if 1\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    f[i] = g[i] + h[i];\n-#else\n-  f[0] = g[0] + h[0];\n-  f[1] = g[1] + h[1];\n-  f[2] = g[2] + h[2];\n-  f[3] = g[3] + h[3];\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FVSUB_S (const void *fvg, const void *fvh, void *fvf)\n-{\n-  const float *g = fvg, *h = fvh;\n-  float *f = fvf;\n-#if 1\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    f[i] = g[i] - h[i];\n-#else\n-  f[0] = g[0] - h[0];\n-  f[1] = g[1] - h[1];\n-  f[2] = g[2] - h[2];\n-  f[3] = g[3] - h[3];\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXCOPY_S (const void *mtrxg, void *mtrxf)\n-{\n-  const __GCC_MTRX *g = mtrxg;\n-  __GCC_MTRX *f = mtrxf;\n-  *f = *g;\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXADD_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n-{\n-  const __GCC_FV *g = mtrxg, *h = mtrxh;\n-  __GCC_FV *f = mtrxf;\n-#if 1\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    sh_media_FVADD_S (&g[i], &h[i], &f[i]);\n-#else\n-  sh_media_FVADD_S (&g[0], &h[0], &f[0]);\n-  sh_media_FVADD_S (&g[1], &h[1], &f[1]);\n-  sh_media_FVADD_S (&g[2], &h[2], &f[2]);\n-  sh_media_FVADD_S (&g[3], &h[3], &f[3]);\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXSUB_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n-{\n-  const __GCC_FV *g = mtrxg, *h = mtrxh;\n-  __GCC_FV *f = mtrxf;\n-#if 1\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    sh_media_FVSUB_S (&g[i], &h[i], &f[i]);\n-#else\n-  sh_media_FVSUB_S (&g[0], &h[0], &f[0]);\n-  sh_media_FVSUB_S (&g[1], &h[1], &f[1]);\n-  sh_media_FVSUB_S (&g[2], &h[2], &f[2]);\n-  sh_media_FVSUB_S (&g[3], &h[3], &f[3]);\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FTRVADD_S (const void *mtrxg, const void *fvh, const void *fvi,\n-\t\t    void *fvf)\n-{\n-  sh_media_FTRV_S (mtrxg, fvh, fvf);\n-  sh_media_FVADD_S (fvf, fvi, fvf);\n-}\n-\n-__inline__ static\n-void\n-sh_media_FTRVSUB_S (const void *mtrxg, const void *fvh, const void *fvi,\n-\t\t    void *fvf)\n-{\n-  sh_media_FTRV_S (mtrxg, fvh, fvf);\n-  sh_media_FVSUB_S (fvf, fvi, fvf);\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXMUL_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n-{\n-  const __GCC_FV *g = mtrxg;\n-  __GCC_FV *f = mtrxf;\n-#if 1\n-  int j;\n-\n-  for (j = 0; j < 4; j++)\n-    sh_media_FTRV_S (mtrxh, &g[j], &f[j]);\n-#else\n-  sh_media_FTRV_S (mtrxh, &g[0], &f[0]);\n-  sh_media_FTRV_S (mtrxh, &g[1], &f[1]);\n-  sh_media_FTRV_S (mtrxh, &g[2], &f[2]);\n-  sh_media_FTRV_S (mtrxh, &g[3], &f[3]);\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh,\n-\t\t\tconst void *mtrxi, void *mtrxf)\n-{\n-  const __GCC_FV *g = mtrxg, *i = mtrxi;\n-  __GCC_FV *f = mtrxf;\n-#if 1\n-  int j;\n-\n-  for (j = 0; j < 4; j++)\n-    sh_media_FTRVADD_S (mtrxh, &g[j], &i[j], &f[j]);\n-#else\n-  sh_media_FTRVADD_S (mtrxh, &g[0], &i[0], &f[0]);\n-  sh_media_FTRVADD_S (mtrxh, &g[1], &i[1], &f[1]);\n-  sh_media_FTRVADD_S (mtrxh, &g[2], &i[2], &f[2]);\n-  sh_media_FTRVADD_S (mtrxh, &g[3], &i[3], &f[3]);\n-#endif\n-}\n-\n-__inline__ static\n-void\n-sh_media_FMTRXMULSUB_S (const void *mtrxg, const void *mtrxh,\n-\t\t\tconst void *mtrxi, void *mtrxf)\n-{\n-  const __GCC_FV *g = mtrxg, *i = mtrxi;\n-  __GCC_FV *f = mtrxf;\n-#if 1\n-  int j;\n-\n-  for (j = 0; j < 4; j++)\n-    sh_media_FTRVSUB_S (mtrxh, &g[j], &i[j], &f[j]);\n-#else\n-  sh_media_FTRVSUB_S (mtrxh, &g[0], &i[0], &f[0]);\n-  sh_media_FTRVSUB_S (mtrxh, &g[1], &i[1], &f[1]);\n-  sh_media_FTRVSUB_S (mtrxh, &g[2], &i[2], &f[2]);\n-  sh_media_FTRVSUB_S (mtrxh, &g[3], &i[3], &f[3]);\n-#endif\n-}\n-#endif /* ! __SH4_NOFPU__ */\n-\n-#endif /* __SHMEDIA__ */\n-\n-#endif /* _USHMEDIA_H */"}]}