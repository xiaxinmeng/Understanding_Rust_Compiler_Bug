{"sha": "c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjMDlhZjhlZjBmZTY2NzFjNzczM2Q0ZDY3YmI3M2VjZjEwZmMxYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-08T14:11:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-08T14:11:28Z"}, "message": "c++: Handle CONSTRUCTORs without indexes in find_array_ctor_elt [PR93549]\n\nMy change\n* typeck2.c (store_init_value): Don't call cp_fully_fold_init on\ninitializers of automatic non-constexpr variables in constexpr\nfunctions.\n-  value = cp_fully_fold_init (value);\n+  /* Don't fold initializers of automatic variables in constexpr functions,\n+     that might fold away something that needs to be diagnosed at constexpr\n+     evaluation time.  */\n+  if (!current_function_decl\n+      || !DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n+      || TREE_STATIC (decl))\n+    value = cp_fully_fold_init (value);\nfrom the constexpr new change apparently broke the following testcase.\nWhen handling COND_EXPR, we build_vector_from_val, however as the argument we\npass to it is not an INTEGER_CST/REAL_CST, but that wrapped in a\nNON_LVALUE_EXPR location wrapper, we end up with a CONSTRUCTOR and as it is\nmiddle-end that builds it, it doesn't bother with indexes.  The\ncp_fully_fold_init call used to fold it into VECTOR_CST in the past, but as\nwe intentionally don't invoke it anymore as it might fold away something\nthat needs to be diagnosed during constexpr evaluation, we end up evaluating\nARRAY_REF into the index-less CONSTRUCTOR.  The following patch fixes the\nICE by teaching find_array_ctor_elt to handle CONSTRUCTORs without indexes\n(that itself could be still very efficient) and CONSTRUCTORs with some\nindexes present and others missing (the rules are that if the index on the\nfirst element is missing, then it is the array's lowest index (in C/C++ 0)\nand if other indexes are missing, they are the index of the previous element\n+ 1).\n\nHere is a new version, which assumes CONSTRUCTORs with all or none indexes\nand for CONSTRUCTORs without indexes performs the verification for\nflag_checking directly in find_array_ctor_elt.  For CONSTRUCTORs with\nindexes, it doesn't do the verification of all elts, because some CONSTRUCTORs\ncan be large, and it \"verifies\" only what it really needs - if all elts\ntouched during the binary search have indexes, that is actually all we care\nabout because we are sure we found the right elt.  It is just if we see a\nmissing index we need assurance that all are missing to be able to directly\naccess it.\n\nThe assumption then simplifies the patch, for no index CONSTRUCTORs we can\nuse direct access like for CONSTRUCTORs where last elt index is equal to the\nelt position.  If we append right after the last elt, we just should clear\nthe index so that we don't violate the assumption, and if we need a gap\nbetween the elts and the elt to be added, we need to add indexes.\n\n2020-02-08  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/93549\n\t* constexpr.c (find_array_ctor_elt): If last element has no index,\n\tfor flag_checking verify all elts have no index.  If i is within the\n\telts, return it directly, if it is right after the last elt, append\n\tif NULL index, otherwise force indexes on all elts.\n\t(cxx_eval_store_expression): Allow cep->index to be NULL.\n\n\t* g++.dg/ext/constexpr-pr93549.C: New test.", "tree": {"sha": "82bcd2bf3fb4696d4cced2dab55ae70fa91f35b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82bcd2bf3fb4696d4cced2dab55ae70fa91f35b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ab8c4321b2dc940bb706a7432a530e26f0df1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ab8c4321b2dc940bb706a7432a530e26f0df1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ab8c4321b2dc940bb706a7432a530e26f0df1a"}], "stats": {"total": 71, "additions": 68, "deletions": 3}, "files": [{"sha": "9205b200cd6e38c02bd2dc818ce75d6c31289af1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "patch": "@@ -1,3 +1,12 @@\n+2020-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/93549\n+\t* constexpr.c (find_array_ctor_elt): If last element has no index,\n+\tfor flag_checking verify all elts have no index.  If i is within the\n+\telts, return it directly, if it is right after the last elt, append\n+\tif NULL index, otherwise force indexes on all elts.\n+\t(cxx_eval_store_expression): Allow cep->index to be NULL.\n+\n 2020-02-07  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/92947 - Paren init of aggregates in unevaluated context."}, {"sha": "aa47ded52c0b958c264853bdd78df9b294f5c76a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "patch": "@@ -3028,8 +3028,32 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert)\n   if (end > 0)\n     {\n       tree cindex = (*elts)[end - 1].index;\n-      if (TREE_CODE (cindex) == INTEGER_CST\n-\t  && compare_tree_int (cindex, end - 1) == 0)\n+      if (cindex == NULL_TREE)\n+\t{\n+\t  /* Verify that if the last index is missing, all indexes\n+\t     are missing.  */\n+\t  if (flag_checking)\n+\t    for (unsigned int j = 0; j < len - 1; ++j)\n+\t      gcc_assert ((*elts)[j].index == NULL_TREE);\n+\t  if (i < end)\n+\t    return i;\n+\t  else\n+\t    {\n+\t      begin = end;\n+\t      if (i == end)\n+\t\t/* If the element is to be added right at the end,\n+\t\t   make sure it is added with cleared index too.  */\n+\t\tdindex = NULL_TREE;\n+\t      else if (insert)\n+\t\t/* Otherwise, in order not to break the assumption\n+\t\t   that CONSTRUCTOR either has all indexes or none,\n+\t\t   we need to add indexes to all elements.  */\n+\t\tfor (unsigned int j = 0; j < len; ++j)\n+\t\t  (*elts)[j].index = build_int_cst (TREE_TYPE (dindex), j);\n+\t    }\n+\t}\n+      else if (TREE_CODE (cindex) == INTEGER_CST\n+\t       && compare_tree_int (cindex, end - 1) == 0)\n \t{\n \t  if (i < end)\n \t    return i;\n@@ -4551,7 +4575,8 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t    = find_array_ctor_elt (*valp, index, /*insert*/true);\n \t  gcc_assert (i >= 0);\n \t  cep = CONSTRUCTOR_ELT (*valp, i);\n-\t  gcc_assert (TREE_CODE (cep->index) != RANGE_EXPR);\n+\t  gcc_assert (cep->index == NULL_TREE\n+\t\t      || TREE_CODE (cep->index) != RANGE_EXPR);\n \t}\n       else\n \t{"}, {"sha": "cfe4197c751c48e2e3ed36a77f7360e8e95d2c3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "patch": "@@ -1,3 +1,8 @@\n+2020-02-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/93549\n+\t* g++.dg/ext/constexpr-pr93549.C: New test.\n+\n 2020-02-08  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "eaa232dc5253701b21c8748a9c4dd966cf4c5ede", "filename": "gcc/testsuite/g++.dg/ext/constexpr-pr93549.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-pr93549.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-pr93549.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-pr93549.C?ref=c7c09af8ef0fe6671c7733d4d67bb73ecf10fc1b", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/93549\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-O2 -Wno-psabi -w\" }\n+\n+struct simd {\n+  using shortx8 [[gnu::vector_size(16)]] = short;\n+  shortx8 data;\n+  constexpr simd (short x) : data{x, x, x, x, x, x, x, x} {}\n+  constexpr friend unsigned operator== (simd lhs, simd rhs)\n+  {\n+    shortx8 tmp = lhs.data == rhs.data;\n+    using ushort = unsigned short;\n+    auto bools = tmp ? ushort(1) : ushort(0);\n+    unsigned bits = 0;\n+    for (int i = 0; i < 8; ++i)\n+      bits |= bools[i] << i;\n+    return bits;\n+  }\n+};\n+\n+auto\n+foo ()\n+{\n+  constexpr auto tmp = simd(1) == simd(2);\n+  return tmp;\n+}"}]}