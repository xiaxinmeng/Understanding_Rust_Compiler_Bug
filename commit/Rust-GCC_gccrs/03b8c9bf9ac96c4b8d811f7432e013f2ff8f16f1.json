{"sha": "03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiOGM5YmY5YWM5NmM0YjhkODExZjc0MzJlMDEzZjJmZjhmMTZmMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-08-25T02:27:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-08-25T02:27:27Z"}, "message": "pt.c (tsubst_default_argument): Indicate where the default argument is being instantiated for.\n\n\t* pt.c (tsubst_default_argument): Indicate where the default\n\targument is being instantiated for.\n\t(tsubst_expr): Restore previous location.\n\t(tsubst_copy_and_build): Set and restore location.\n\t* call.c (build_new_method_call_1): Remember location of call.\n\t* semantics.c (finish_call_expr): Here too.\n\t* parser.c (cp_parser_omp_for_loop): Remember the location of the\n\tincrement expression.\n\nFrom-SVN: r190662", "tree": {"sha": "8aef523db50ce06fe138170b3676cd1a3c09bc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aef523db50ce06fe138170b3676cd1a3c09bc8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b21deb041a6cedc0cfa3414b46eba3b54966776f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b21deb041a6cedc0cfa3414b46eba3b54966776f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b21deb041a6cedc0cfa3414b46eba3b54966776f"}], "stats": {"total": 278, "additions": 159, "deletions": 119}, "files": [{"sha": "7bb48ac36f3576aa3afec93d66e85951dc55d720", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -1,5 +1,14 @@\n 2012-08-24  Jason Merrill  <jason@redhat.com>\n \n+\t* pt.c (tsubst_default_argument): Indicate where the default\n+\targument is being instantiated for.\n+\t(tsubst_expr): Restore previous location.\n+\t(tsubst_copy_and_build): Set and restore location.\n+\t* call.c (build_new_method_call_1): Remember location of call.\n+\t* semantics.c (finish_call_expr): Here too.\n+\t* parser.c (cp_parser_omp_for_loop): Remember the location of the\n+\tincrement expression.\n+\n \t* pt.c (resolve_overloaded_unification): Use coerce_template_parms\n \tinstead of get_bindings.\n \t(resolve_nondeduced_context): Likewise."}, {"sha": "148ef8f0f9d1629ebe9030951285295a9cda8e11", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -7537,6 +7537,7 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n \t       build_min (COMPONENT_REF, TREE_TYPE (CALL_EXPR_FN (call)),\n \t\t\t  orig_instance, orig_fns, NULL_TREE),\n \t       orig_args));\n+      SET_EXPR_LOCATION (call, input_location);\n       call = convert_from_reference (call);\n       if (cast_to_void)\n \tcall = build_nop (void_type_node, call);"}, {"sha": "0f897c96f070ee5a6678ada7c9344258c716118a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -26603,6 +26603,8 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t    incr = cp_parser_omp_for_incr (parser, real_decl);\n \t  else\n \t    incr = cp_parser_expression (parser, false, NULL);\n+\t  if (CAN_HAVE_LOCATION_P (incr) && !EXPR_HAS_LOCATION (incr))\n+\t    SET_EXPR_LOCATION (incr, input_location);\n \t}\n \n       if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))"}, {"sha": "6c9d143fdab597ea15c82388991b03d6d33184b2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 117, "deletions": 94, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -9609,6 +9609,7 @@ tsubst_default_argument (tree fn, tree type, tree arg)\n {\n   tree saved_class_ptr = NULL_TREE;\n   tree saved_class_ref = NULL_TREE;\n+  int errs = errorcount + sorrycount;\n \n   /* This can happen in invalid code.  */\n   if (TREE_CODE (arg) == DEFAULT_ARG)\n@@ -9656,6 +9657,10 @@ tsubst_default_argument (tree fn, tree type, tree arg)\n       cp_function_chain->x_current_class_ref = saved_class_ref;\n     }\n \n+  if (errorcount+sorrycount > errs)\n+    inform (input_location,\n+\t    \"  when instantiating default argument for call to %D\", fn);\n+\n   /* Make sure the default argument is reasonable.  */\n   arg = check_default_argument (type, arg);\n \n@@ -12496,15 +12501,19 @@ static tree\n tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t     bool integral_constant_expression_p)\n {\n+#define RETURN(EXP) do { r = (EXP); goto out; } while(0)\n #define RECUR(NODE)\t\t\t\t\\\n   tsubst_expr ((NODE), args, complain, in_decl,\t\\\n \t       integral_constant_expression_p)\n \n   tree stmt, tmp;\n+  tree r;\n+  location_t loc;\n \n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n+  loc = input_location;\n   if (EXPR_HAS_LOCATION (t))\n     input_location = EXPR_LOCATION (t);\n   if (STATEMENT_CODE_P (TREE_CODE (t)))\n@@ -13016,42 +13025,46 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n             stmt = build_transaction_expr (EXPR_LOCATION (t),\n \t\t\t\t\t   RECUR (TRANSACTION_EXPR_BODY (t)),\n \t\t\t\t\t   flags, NULL_TREE);\n-            return stmt;\n+            RETURN (stmt);\n           }\n       }\n       break;\n \n     case MUST_NOT_THROW_EXPR:\n-      return build_must_not_throw_expr (RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t\tRECUR (MUST_NOT_THROW_COND (t)));\n+      RETURN (build_must_not_throw_expr (RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\t\tRECUR (MUST_NOT_THROW_COND (t))));\n \n     case EXPR_PACK_EXPANSION:\n       error (\"invalid use of pack expansion expression\");\n-      return error_mark_node;\n+      RETURN (error_mark_node);\n \n     case NONTYPE_ARGUMENT_PACK:\n       error (\"use %<...%> to expand argument pack\");\n-      return error_mark_node;\n+      RETURN (error_mark_node);\n \n     case COMPOUND_EXPR:\n       tmp = RECUR (TREE_OPERAND (t, 0));\n       if (tmp == NULL_TREE)\n \t/* If the first operand was a statement, we're done with it.  */\n-\treturn RECUR (TREE_OPERAND (t, 1));\n-      return build_x_compound_expr (EXPR_LOCATION (t), tmp,\n+\tRETURN (RECUR (TREE_OPERAND (t, 1)));\n+      RETURN (build_x_compound_expr (EXPR_LOCATION (t), tmp,\n \t\t\t\t    RECUR (TREE_OPERAND (t, 1)),\n-\t\t\t\t    complain);\n+\t\t\t\t    complain));\n \n     default:\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n \n-      return tsubst_copy_and_build (t, args, complain, in_decl,\n+      RETURN (tsubst_copy_and_build (t, args, complain, in_decl,\n \t\t\t\t    /*function_p=*/false,\n-\t\t\t\t    integral_constant_expression_p);\n+\t\t\t\t    integral_constant_expression_p));\n     }\n \n-  return NULL_TREE;\n+  RETURN (NULL_TREE);\n+ out:\n+  input_location = loc;\n+  return r;\n #undef RECUR\n+#undef RETURN\n }\n \n /* T is a postfix-expression that is not being used in a function\n@@ -13084,16 +13097,22 @@ tsubst_copy_and_build (tree t,\n \t\t       bool function_p,\n \t\t       bool integral_constant_expression_p)\n {\n+#define RETURN(EXP) do { retval = (EXP); goto out; } while(0)\n #define RECUR(NODE)\t\t\t\t\t\t\\\n   tsubst_copy_and_build (NODE, args, complain, in_decl, \t\\\n \t\t\t /*function_p=*/false,\t\t\t\\\n \t\t\t integral_constant_expression_p)\n \n-  tree op1;\n+  tree retval, op1;\n+  location_t loc;\n \n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n+  loc = input_location;\n+  if (EXPR_HAS_LOCATION (t))\n+    input_location = EXPR_LOCATION (t);\n+\n   switch (TREE_CODE (t))\n     {\n     case USING_DECL:\n@@ -13139,7 +13158,7 @@ tsubst_copy_and_build (tree t,\n \t      unqualified_name_lookup_error (decl);\n \t    decl = error_mark_node;\n \t  }\n-\treturn decl;\n+\tRETURN (decl);\n       }\n \n     case TEMPLATE_ID_EXPR:\n@@ -13161,10 +13180,10 @@ tsubst_copy_and_build (tree t,\n \ttempl = lookup_template_function (templ, targs);\n \n \tif (object)\n-\t  return build3 (COMPONENT_REF, TREE_TYPE (templ),\n-\t\t\t object, templ, NULL_TREE);\n+\t  RETURN (build3 (COMPONENT_REF, TREE_TYPE (templ),\n+\t\t\t object, templ, NULL_TREE));\n \telse\n-\t  return baselink_for_fns (templ);\n+\t  RETURN (baselink_for_fns (templ));\n       }\n \n     case INDIRECT_REF:\n@@ -13181,13 +13200,13 @@ tsubst_copy_and_build (tree t,\n \t  }\n \telse\n \t  r = build_x_indirect_ref (input_location, r, RO_UNARY_STAR, complain);\n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case NOP_EXPR:\n-      return build_nop\n+      RETURN (build_nop\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n+\t RECUR (TREE_OPERAND (t, 0))));\n \n     case IMPLICIT_CONV_EXPR:\n       {\n@@ -13196,15 +13215,15 @@ tsubst_copy_and_build (tree t,\n \tint flags = LOOKUP_IMPLICIT;\n \tif (IMPLICIT_CONV_EXPR_DIRECT_INIT (t))\n \t  flags = LOOKUP_NORMAL;\n-\treturn perform_implicit_conversion_flags (type, expr, complain,\n-\t\t\t\t\t\t  flags);\n+\tRETURN (perform_implicit_conversion_flags (type, expr, complain,\n+\t\t\t\t\t\t  flags));\n       }\n \n     case CONVERT_EXPR:\n-      return build1\n+      RETURN (build1\n \t(CONVERT_EXPR,\n \t tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n+\t RECUR (TREE_OPERAND (t, 0))));\n \n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n@@ -13222,7 +13241,7 @@ tsubst_copy_and_build (tree t,\n             if (complain & tf_error)\n               error (\"a cast to a type other than an integral or \"\n                      \"enumeration type cannot appear in a constant-expression\");\n-\t    return error_mark_node; \n+\t    RETURN (error_mark_node);\n \t  }\n \n \top = RECUR (TREE_OPERAND (t, 0));\n@@ -13250,14 +13269,14 @@ tsubst_copy_and_build (tree t,\n \t  }\n \t--c_inhibit_evaluation_warnings;\n \n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n-      return build_x_unary_op (input_location, TREE_CODE (t), op1, complain);\n+      RETURN (build_x_unary_op (input_location, TREE_CODE (t), op1, complain));\n \n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n@@ -13268,25 +13287,25 @@ tsubst_copy_and_build (tree t,\n     case UNARY_PLUS_EXPR:  /* Unary + */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      return build_x_unary_op (input_location, TREE_CODE (t),\n-\t\t\t       RECUR (TREE_OPERAND (t, 0)), complain);\n+      RETURN (build_x_unary_op (input_location, TREE_CODE (t),\n+\t\t\t       RECUR (TREE_OPERAND (t, 0)), complain));\n \n     case FIX_TRUNC_EXPR:\n-      return cp_build_unary_op (FIX_TRUNC_EXPR, RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t0, complain);\n+      RETURN (cp_build_unary_op (FIX_TRUNC_EXPR, RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\t0, complain));\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n       if (TREE_CODE (op1) == LABEL_DECL)\n-\treturn finish_label_address_expr (DECL_NAME (op1),\n-\t\t\t\t\t  EXPR_LOCATION (op1));\n+\tRETURN (finish_label_address_expr (DECL_NAME (op1),\n+\t\t\t\t\t  EXPR_LOCATION (op1)));\n       if (TREE_CODE (op1) == SCOPE_REF)\n \top1 = tsubst_qualified_id (op1, args, complain, in_decl,\n \t\t\t\t   /*done=*/true, /*address_p=*/true);\n       else\n \top1 = tsubst_non_call_postfix_expression (op1, args, complain,\n \t\t\t\t\t\t  in_decl);\n-      return build_x_unary_op (input_location, ADDR_EXPR, op1, complain);\n+      RETURN (build_x_unary_op (input_location, ADDR_EXPR, op1, complain));\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -13341,21 +13360,21 @@ tsubst_copy_and_build (tree t,\n \n \t--c_inhibit_evaluation_warnings;\n \n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case SCOPE_REF:\n-      return tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n-\t\t\t\t  /*address_p=*/false);\n+      RETURN (tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n+\t\t\t\t  /*address_p=*/false));\n     case ARRAY_REF:\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n-      return build_x_array_ref (EXPR_LOCATION (t), op1,\n-\t\t\t\tRECUR (TREE_OPERAND (t, 1)), complain);\n+      RETURN (build_x_array_ref (EXPR_LOCATION (t), op1,\n+\t\t\t\tRECUR (TREE_OPERAND (t, 1)), complain));\n \n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n-\treturn tsubst_copy (t, args, complain, in_decl);\n+\tRETURN (tsubst_copy (t, args, complain, in_decl));\n       /* Fall through */\n       \n     case ALIGNOF_EXPR:\n@@ -13379,11 +13398,11 @@ tsubst_copy_and_build (tree t,\n \t  --c_inhibit_evaluation_warnings;\n \t}\n       if (TYPE_P (op1))\n-\treturn cxx_sizeof_or_alignof_type (op1, TREE_CODE (t), \n-                                           complain & tf_error);\n+\tRETURN (cxx_sizeof_or_alignof_type (op1, TREE_CODE (t),\n+                                           complain & tf_error));\n       else\n-\treturn cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t), \n-                                           complain & tf_error);\n+\tRETURN (cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t),\n+                                           complain & tf_error));\n \n     case AT_ENCODE_EXPR:\n       {\n@@ -13395,7 +13414,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t     /*integral_constant_expression_p=*/false);\n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n-\treturn objc_build_encode_expr (op1);\n+\tRETURN (objc_build_encode_expr (op1));\n       }\n \n     case NOEXCEPT_EXPR:\n@@ -13407,7 +13426,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t   /*integral_constant_expression_p=*/false);\n       --cp_unevaluated_operand;\n       --c_inhibit_evaluation_warnings;\n-      return finish_noexcept_expr (op1, complain);\n+      RETURN (finish_noexcept_expr (op1, complain));\n \n     case MODOP_EXPR:\n       {\n@@ -13425,7 +13444,7 @@ tsubst_copy_and_build (tree t,\n \t   here.  */\n \tif (TREE_NO_WARNING (t))\n \t  TREE_NO_WARNING (r) = TREE_NO_WARNING (t);\n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case ARROW_EXPR:\n@@ -13434,7 +13453,7 @@ tsubst_copy_and_build (tree t,\n       /* Remember that there was a reference to this entity.  */\n       if (DECL_P (op1))\n \tmark_used (op1);\n-      return build_x_arrow (input_location, op1, complain);\n+      RETURN (build_x_arrow (input_location, op1, complain));\n \n     case NEW_EXPR:\n       {\n@@ -13485,22 +13504,22 @@ tsubst_copy_and_build (tree t,\n \tif (init_vec != NULL)\n \t  release_tree_vector (init_vec);\n \n-\treturn ret;\n+\tRETURN (ret);\n       }\n \n     case DELETE_EXPR:\n-     return delete_sanity\n+     RETURN (delete_sanity\n        (RECUR (TREE_OPERAND (t, 0)),\n \tRECUR (TREE_OPERAND (t, 1)),\n \tDELETE_EXPR_USE_VEC (t),\n \tDELETE_EXPR_USE_GLOBAL (t),\n-\tcomplain);\n+\tcomplain));\n \n     case COMPOUND_EXPR:\n-      return build_x_compound_expr (EXPR_LOCATION (t),\n+      RETURN (build_x_compound_expr (EXPR_LOCATION (t),\n \t\t\t\t    RECUR (TREE_OPERAND (t, 0)),\n \t\t\t\t    RECUR (TREE_OPERAND (t, 1)),\n-                                    complain);\n+                                    complain));\n \n     case CALL_EXPR:\n       {\n@@ -13622,7 +13641,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t    (function, args, complain, in_decl, true,\n \t\t\t     integral_constant_expression_p));\n \t\tif (unq == error_mark_node)\n-\t\t  return error_mark_node;\n+\t\t  RETURN (error_mark_node);\n \n \t\tif (unq != function)\n \t\t  {\n@@ -13664,7 +13683,7 @@ tsubst_copy_and_build (tree t,\n \t      {\n \t\tunqualified_name_lookup_error (function);\n \t\trelease_tree_vector (call_args);\n-\t\treturn error_mark_node;\n+\t\tRETURN (error_mark_node);\n \t      }\n \t  }\n \n@@ -13707,7 +13726,7 @@ tsubst_copy_and_build (tree t,\n \n \trelease_tree_vector (call_args);\n \n-\treturn ret;\n+\tRETURN (ret);\n       }\n \n     case COND_EXPR:\n@@ -13738,22 +13757,22 @@ tsubst_copy_and_build (tree t,\n \t    exp2 = RECUR (TREE_OPERAND (t, 2));\n \t  }\n \n-\treturn build_x_conditional_expr (EXPR_LOCATION (t),\n-\t\t\t\t\t cond, exp1, exp2, complain);\n+\tRETURN (build_x_conditional_expr (EXPR_LOCATION (t),\n+\t\t\t\t\t cond, exp1, exp2, complain));\n       }\n \n     case PSEUDO_DTOR_EXPR:\n-      return finish_pseudo_destructor_expr\n+      RETURN (finish_pseudo_destructor_expr\n \t(RECUR (TREE_OPERAND (t, 0)),\n \t RECUR (TREE_OPERAND (t, 1)),\n-\t tsubst (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t tsubst (TREE_OPERAND (t, 2), args, complain, in_decl)));\n \n     case TREE_LIST:\n       {\n \ttree purpose, value, chain;\n \n \tif (t == void_list_node)\n-\t  return t;\n+\t  RETURN (t);\n \n         if ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))\n             || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))\n@@ -13789,14 +13808,14 @@ tsubst_copy_and_build (tree t,\n             else\n               {\n                 /* Since we only performed a partial substitution into\n-                   the argument pack, we only return a single list\n+                   the argument pack, we only RETURN (a single list\n                    node.  */\n                 if (purposevec == TREE_PURPOSE (t)\n                     && valuevec == TREE_VALUE (t)\n                     && chain == TREE_CHAIN (t))\n-                  return t;\n+                  RETURN (t);\n \n-                return tree_cons (purposevec, valuevec, chain);\n+                RETURN (tree_cons (purposevec, valuevec, chain));\n               }\n             \n             /* Convert the argument vectors into a TREE_LIST */\n@@ -13815,7 +13834,7 @@ tsubst_copy_and_build (tree t,\n                 chain = tree_cons (purpose, value, chain);\n               }\n \n-            return chain;\n+            RETURN (chain);\n           }\n \n \tpurpose = TREE_PURPOSE (t);\n@@ -13830,8 +13849,8 @@ tsubst_copy_and_build (tree t,\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n-\t  return t;\n-\treturn tree_cons (purpose, value, chain);\n+\t  RETURN (t);\n+\tRETURN (tree_cons (purpose, value, chain));\n       }\n \n     case COMPONENT_REF:\n@@ -13855,7 +13874,7 @@ tsubst_copy_and_build (tree t,\n \telse\n \t  member = tsubst_copy (member, args, complain, in_decl);\n \tif (member == error_mark_node)\n-\t  return error_mark_node;\n+\t  RETURN (error_mark_node);\n \n \tif (type_dependent_expression_p (object))\n \t  /* We can't do much here.  */;\n@@ -13875,7 +13894,7 @@ tsubst_copy_and_build (tree t,\n \t\t  {\n \t\t    dtor = TREE_OPERAND (dtor, 0);\n \t\t    if (TYPE_P (dtor))\n-\t\t      return finish_pseudo_destructor_expr (object, s, dtor);\n+\t\t      RETURN (finish_pseudo_destructor_expr (object, s, dtor));\n \t\t  }\n \t      }\n \t  }\n@@ -13903,7 +13922,7 @@ tsubst_copy_and_build (tree t,\n \t      {\n \t\tqualified_name_lookup_error (scope, tmpl, member,\n \t\t\t\t\t     input_location);\n-\t\treturn error_mark_node;\n+\t\tRETURN (error_mark_node);\n \t      }\n \t  }\n \telse if (TREE_CODE (member) == SCOPE_REF\n@@ -13919,19 +13938,19 @@ tsubst_copy_and_build (tree t,\n \t\t  error (\"%qD is not a class or namespace\",\n \t\t\t TREE_OPERAND (member, 0));\n \t      }\n-\t    return error_mark_node;\n+\t    RETURN (error_mark_node);\n \t  }\n \telse if (TREE_CODE (member) == FIELD_DECL)\n-\t  return finish_non_static_data_member (member, object, NULL_TREE);\n+\t  RETURN (finish_non_static_data_member (member, object, NULL_TREE));\n \n-\treturn finish_class_member_access_expr (object, member,\n+\tRETURN (finish_class_member_access_expr (object, member,\n \t\t\t\t\t\t/*template_p=*/false,\n-\t\t\t\t\t\tcomplain);\n+\t\t\t\t\t\tcomplain));\n       }\n \n     case THROW_EXPR:\n-      return build_throw\n-\t(RECUR (TREE_OPERAND (t, 0)));\n+      RETURN (build_throw\n+\t(RECUR (TREE_OPERAND (t, 0))));\n \n     case CONSTRUCTOR:\n       {\n@@ -13945,11 +13964,11 @@ tsubst_copy_and_build (tree t,\n \ttree r;\n \n \tif (type == error_mark_node)\n-\t  return error_mark_node;\n+\t  RETURN (error_mark_node);\n \n \t/* digest_init will do the wrong thing if we let it.  */\n \tif (type && TYPE_PTRMEMFUNC_P (type))\n-\t  return t;\n+\t  RETURN (t);\n \n \t/* We do not want to process the index of aggregate\n \t   initializers as they are identifier nodes which will be\n@@ -14011,10 +14030,10 @@ tsubst_copy_and_build (tree t,\n \tCONSTRUCTOR_IS_DIRECT_INIT (r) = CONSTRUCTOR_IS_DIRECT_INIT (t);\n \n \tif (TREE_HAS_CONSTRUCTOR (t))\n-\t  return finish_compound_literal (type, r, complain);\n+\t  RETURN (finish_compound_literal (type, r, complain));\n \n \tTREE_TYPE (r) = type;\n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case TYPEID_EXPR:\n@@ -14023,18 +14042,18 @@ tsubst_copy_and_build (tree t,\n \tif (TYPE_P (operand_0))\n \t  {\n \t    operand_0 = tsubst (operand_0, args, complain, in_decl);\n-\t    return get_typeid (operand_0);\n+\t    RETURN (get_typeid (operand_0));\n \t  }\n \telse\n \t  {\n \t    operand_0 = RECUR (operand_0);\n-\t    return build_typeid (operand_0);\n+\t    RETURN (build_typeid (operand_0));\n \t  }\n       }\n \n     case VAR_DECL:\n       if (!args)\n-\treturn t;\n+\tRETURN (t);\n       /* Fall through */\n \n     case PARM_DECL:\n@@ -14045,16 +14064,16 @@ tsubst_copy_and_build (tree t,\n \t  /* If the original type was a reference, we'll be wrapped in\n \t     the appropriate INDIRECT_REF.  */\n \t  r = convert_from_reference (r);\n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case VA_ARG_EXPR:\n-      return build_x_va_arg (EXPR_LOCATION (t),\n+      RETURN (build_x_va_arg (EXPR_LOCATION (t),\n \t\t\t     RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl));\n+\t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl)));\n \n     case OFFSETOF_EXPR:\n-      return finish_offsetof (RECUR (TREE_OPERAND (t, 0)));\n+      RETURN (finish_offsetof (RECUR (TREE_OPERAND (t, 0))));\n \n     case TRAIT_EXPR:\n       {\n@@ -14065,7 +14084,7 @@ tsubst_copy_and_build (tree t,\n \tif (type2)\n \t  type2 = tsubst_copy (type2, args, complain, in_decl);\n \t\n-\treturn finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2);\n+\tRETURN (finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2));\n       }\n \n     case STMT_EXPR:\n@@ -14084,7 +14103,7 @@ tsubst_copy_and_build (tree t,\n \tif (empty_expr_stmt_p (stmt_expr))\n \t  stmt_expr = void_zero_node;\n \n-\treturn stmt_expr;\n+\tRETURN (stmt_expr);\n       }\n \n     case LAMBDA_EXPR:\n@@ -14121,7 +14140,7 @@ tsubst_copy_and_build (tree t,\n \tLAMBDA_EXPR_CAPTURE_LIST (r)\n \t  = RECUR (LAMBDA_EXPR_CAPTURE_LIST (t));\n \n-\treturn build_lambda_object (r);\n+\tRETURN (build_lambda_object (r));\n       }\n \n     case TARGET_EXPR:\n@@ -14131,12 +14150,12 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree r = get_target_expr (RECUR (TARGET_EXPR_INITIAL (t)));\n \tTREE_CONSTANT (r) = true;\n-\treturn r;\n+\tRETURN (r);\n       }\n \n     case TRANSACTION_EXPR:\n-      return tsubst_expr(t, args, complain, in_decl,\n-\t     integral_constant_expression_p);\n+      RETURN (tsubst_expr(t, args, complain, in_decl,\n+\t     integral_constant_expression_p));\n \n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */\n@@ -14145,12 +14164,16 @@ tsubst_copy_and_build (tree t,\n \t  = objcp_tsubst_copy_and_build (t, args, complain,\n \t\t\t\t\t in_decl, /*function_p=*/false);\n \tif (subst)\n-\t  return subst;\n+\t  RETURN (subst);\n       }\n-      return tsubst_copy (t, args, complain, in_decl);\n+      RETURN (tsubst_copy (t, args, complain, in_decl));\n     }\n \n #undef RECUR\n+#undef RETURN\n+ out:\n+  input_location = loc;\n+  return retval;\n }\n \n /* Verify that the instantiated ARGS are valid. For type arguments,"}, {"sha": "4faca9147161a5cbc5e9d9ca73ea4f053d95fb8e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -2062,6 +2062,7 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n \t      && type_dependent_expression_p (current_class_ref)))\n \t{\n \t  result = build_nt_call_vec (fn, *args);\n+\t  SET_EXPR_LOCATION (result, EXPR_LOC_OR_HERE (fn));\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  if (cfun)\n \t    {"}, {"sha": "00457357b2b7ca66a019b7bb7f2c603454d767e5", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype28.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype28.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -8,8 +8,8 @@ template <class F, int N>\n void ft (F f, typename enable_if<N!=0, int>::type) {}\n \n template< class F, int N >\n-decltype(ft<F, N-1> (F(), 0))\n-ft (F f, typename enable_if<N==0, int>::type) {} // { dg-error \"depth\" }\n+decltype(ft<F, N-1> (F(), 0))\t// { dg-error \"depth\" }\n+ft (F f, typename enable_if<N==0, int>::type) {}\n \n int main() {\n   ft<struct a*, 2> (0, 0);\t// { dg-message \"from here\" }"}, {"sha": "a64bb65a476ff35e39014c8eab026c95fdfb387c", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype29.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype29.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -9,8 +9,8 @@ typename enable_if<x==0,int>::type\n ft() {}\n \n template<class F, int N>\n-decltype (ft<F> (F()))\n-ft() {}\t\t\t\t// { dg-error \"depth\" }\n+decltype (ft<F> (F()))\t\t// { dg-error \"depth\" }\n+ft() {}\n \n int main() {\n     ft<struct a*, 0>();\t\t// { dg-error \"no match|wrong number\" }"}, {"sha": "6cb637bb2ddd3f7500348a94738b12440f703992", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype32.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype32.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -2,8 +2,8 @@\n // { dg-options -std=c++0x }\n \n template <typename T>\n-auto make_array(const T& il) ->\t// { dg-error \"not declared\" }\n-decltype(make_array(il))\n+auto make_array(const T& il) ->\n+decltype(make_array(il))\t// { dg-error \"not declared\" }\n { }\n \n int main()"}, {"sha": "0ffcb3bcbae6de592d608b67aa44b368de59fce9", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-deduce.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-deduce.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-deduce.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-deduce.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -24,3 +24,5 @@ int main()\n {\n   g({1});\t\t\t// { dg-warning \"deduc\" }\n }\n+\n+// { dg-prune-output \"-fno-deduce-init-list\" }"}, {"sha": "b335ea2be99b49636e7507f426292be890a3a5d8", "filename": "gcc/testsuite/g++.dg/cpp0x/overload2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload2.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -10,15 +10,15 @@ template <class T> decltype(g1(T())) f1()\n { return g1(T()); }\n int i1 = f1<int>();\t    // OK, g1(int) was declared before the first f1\n \n-template <class T> decltype(g2(T())) f2();\n+template <class T> decltype(g2(T())) f2(); // { dg-error \"g2. was not declared\" }\n int g2(int);\n-template <class T> decltype(g2(T())) f2() // { dg-error \"g2. was not declared\" }\n+template <class T> decltype(g2(T())) f2()\n { return g2(T()); }\n int i2 = f2<int>();\t\t\t  // { dg-error \"no match\" }\n \n int g3();\n-template <class T> decltype(g3(T())) f3();\n+template <class T> decltype(g3(T())) f3(); // { dg-error \"too many arguments\" }\n int g3(int);\n-template <class T> decltype(g3(T())) f3() // { dg-error \"too many arguments\" }\n+template <class T> decltype(g3(T())) f3()\n { return g3(T()); }\n int i3 = f3<int>();\t\t\t  // { dg-error \"no match\" }"}, {"sha": "f974d82b144299762ed8a5e87a63a19533a33606", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae24.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae24.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -19,8 +19,8 @@ struct Bind\n     R f();\n \n     template<typename R\n-      = decltype( val<const F>()( ) )>\n-    R f() const;\t\t// { dg-error \"no match\" }\n+      = decltype( val<const F>()( ) )> // { dg-error \"no match\" }\n+    R f() const;\n };\n \n int main()"}, {"sha": "966ad96306def3126cace6ed292c6b60ca00791a", "filename": "gcc/testsuite/g++.dg/gomp/for-19.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-19.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -8,7 +8,7 @@ template <typename T>\n void\n f1 (void)\n {\n-#pragma omp for\t\t// { dg-error \"forbids incrementing a pointer of type\" }\n+#pragma omp for\n   for (void *q = (void *)p; q < (void *) (p + 4); q++)\t// { dg-error \"forbids incrementing a pointer of type\" }\n     ;\n }"}, {"sha": "fcbb43b7bf274d4ccc2a76e66508d10a29b77ea8", "filename": "gcc/testsuite/g++.dg/overload/defarg1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fdefarg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fdefarg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fdefarg1.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -1,11 +1,11 @@\n // PR c++/5247\n \n template<typename T>\n-int foo (T t, int = foo(T()));\n+int foo (T t, int = foo(T()));\t// { dg-error \"recursive\" }\n \n struct A { };\n \n int main()\n {\n-  foo(A());\t\t\t// { dg-error \"default argument\" }\n+  foo(A());\t\t\t// { dg-message \"default argument\" }\n }"}, {"sha": "6b67d8dfe10b68f3a794537717c53e100c9d2dbb", "filename": "gcc/testsuite/g++.dg/parse/crash40.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash40.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -26,7 +26,7 @@ template<bool> struct S {\n   S(unsigned int = BBB::foo()->AAA::get()); /* { dg-error \"is not a base of\" } */\n };\n template<bool> struct SS {\n-  SS(unsigned int = BBB::foo()->get());\n+  SS(unsigned int = BBB::foo()->get()); /* { dg-error \"within this context\" } */\n };\n \n void bar()\n@@ -38,5 +38,5 @@ void bar()\n   i.C::foo<0>(); /* { dg-error \"which is of non-class type\" } */\n \n   S<false> s; /* { dg-error \"default argument\" } */\n-  SS<false> ss; /* { dg-error \"within this context\" } */\n+  SS<false> ss;\n }"}, {"sha": "b6f49a19e5808e7ad878f3daea4012914bead69c", "filename": "gcc/testsuite/g++.dg/template/crash108.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -1,5 +1,5 @@\n // PR c++/50861\n \n-template<class T> struct A {A(int b=k(0));}; // { dg-error \"arguments\" }\n-void f(int k){A<int> a;} // // { dg-error \"parameter|declared\" }\n+template<class T> struct A {A(int b=k(0));}; // { dg-error \"parameter|arguments\" }\n+void f(int k){A<int> a;} // // { dg-error \"declared\" }\n // { dg-message \"note\" \"note\" { target *-*-* } 3 }"}, {"sha": "f4cdaf9d9bd5dc47a0e4e279928cfb4223cc646f", "filename": "gcc/testsuite/g++.dg/template/crash89.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash89.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash89.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash89.C?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -1,8 +1,10 @@\n // PR c++/34397\n \n-template<typename T, int = T()[0]> struct A // { dg-error \"subscripted|template\" }\n+template<typename T, int = T()[0]> struct A // { dg-error \"subscripted\" }\n {\n   typedef A<T> B;\n };\n \n A<int> a; // { dg-error \"declaration\" }\n+\n+// { dg-prune-output \"template argument 2 is invalid\" }"}, {"sha": "4534d1d9b9c55d0d4f5c0bb4a9d113386d6a1f6e", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -30,10 +30,10 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1206 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1219 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1233 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1247 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1207 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1221 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1235 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1249 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n "}, {"sha": "e5916c2b118ad3bdb75634364d3f251228a7c40e", "filename": "libstdc++-v3/testsuite/20_util/ratio/cons/cons_overflow_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc?ref=03b8c9bf9ac96c4b8d811f7432e013f2ff8f16f1", "patch": "@@ -51,5 +51,5 @@ test04()\n // { dg-error \"required from here\" \"\" { target *-*-* } 46 }\n // { dg-error \"denominator cannot be zero\" \"\" { target *-*-* } 265 }\n // { dg-error \"out of range\" \"\" { target *-*-* } 266 }\n-// { dg-error \"overflow in constant expression\" \"\" { target *-*-* } 62 }\n+// { dg-error \"overflow in constant expression\" \"\" { target *-*-* } 61 }\n // { dg-prune-output \"not a member\" }"}]}