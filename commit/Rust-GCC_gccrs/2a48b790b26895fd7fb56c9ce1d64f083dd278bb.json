{"sha": "2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE0OGI3OTBiMjY4OTVmZDdmYjU2YzljZTFkNjRmMDgzZGQyNzhiYg==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2007-07-18T18:51:21Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2007-07-18T18:51:21Z"}, "message": "xtensa-config.h (XCHAL_HAVE_THREADPTR): New.\n\ninclude/\n\t* xtensa-config.h (XCHAL_HAVE_THREADPTR): New.\n\t(XCHAL_HAVE_RELEASE_SYNC, XCHAL_HAVE_S32C1I): New.\ngcc/\n\t* config/xtensa/xtensa.c (xtensa_expand_mask_and_shift): New.\n\t(struct alignment_context, init_alignment_context): New.\n\t(xtensa_expand_compare_and_swap, xtensa_expand_atomic): New.\n\t* config/xtensa/xtensa.h (XCHAL_HAVE_RELEASE_SYNC): Add default.\n\t(XCHAL_HAVE_S32C1I): Likewise.\n\t(TARGET_RELEASE_SYNC, TARGET_S32C1I): New.\n\t* config/xtensa/xtensa.md (UNSPECV_MEMW): New constant.\n\t(UNSPECV_S32RI, UNSPECV_S32C1I): Likewise.\n\t(ATOMIC, HQI): New macros.\n\t(memory_barrier, *memory_barrier): New.\n\t(sync_lock_releasesi): New.\n\t(sync_compare_and_swapsi, sync_compare_and_swap<mode>): New.\n\t(sync_lock_test_and_set<mode>): New.\n\t(sync_<atomic><mode>): New.\n\t(sync_old_<atomic><mode>, sync_new_<atomic><mode>): New.\n\t* config/xtensa/xtensa-protos.h (xtensa_expand_compare_and_swap): New.\n\t(xtensa_expand_atomic): New.\ngcc/testsuite/\t\n\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n\tEnable for xtensa.\n\t(check_effective_target_sync_char_short): Likewise.\n\nFrom-SVN: r126728", "tree": {"sha": "491a671d2873d5b092054d056294c21999ed9248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/491a671d2873d5b092054d056294c21999ed9248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/comments", "author": null, "committer": null, "parents": [{"sha": "8a91c45bbfb3d5c99560ab89dc1dc55a1add8719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a91c45bbfb3d5c99560ab89dc1dc55a1add8719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a91c45bbfb3d5c99560ab89dc1dc55a1add8719"}], "stats": {"total": 438, "additions": 435, "deletions": 3}, "files": [{"sha": "484d9b522ecb5c293f6e70d6430a442835810bbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -1,3 +1,23 @@\n+2007-07-18  Bob Wilson  <bob.wilson@acm.org>\n+\t\n+\t* config/xtensa/xtensa.c (xtensa_expand_mask_and_shift): New.\n+\t(struct alignment_context, init_alignment_context): New.\n+\t(xtensa_expand_compare_and_swap, xtensa_expand_atomic): New.\n+\t* config/xtensa/xtensa.h (XCHAL_HAVE_RELEASE_SYNC): Add default.\n+\t(XCHAL_HAVE_S32C1I): Likewise.\n+\t(TARGET_RELEASE_SYNC, TARGET_S32C1I): New.\n+\t* config/xtensa/xtensa.md (UNSPECV_MEMW): New constant.\n+\t(UNSPECV_S32RI, UNSPECV_S32C1I): Likewise.\n+\t(ATOMIC, HQI): New macros.\n+\t(memory_barrier, *memory_barrier): New.\n+\t(sync_lock_releasesi): New.\n+\t(sync_compare_and_swapsi, sync_compare_and_swap<mode>): New.\n+\t(sync_lock_test_and_set<mode>): New.\n+\t(sync_<atomic><mode>): New.\n+\t(sync_old_<atomic><mode>, sync_new_<atomic><mode>): New.\n+\t* config/xtensa/xtensa-protos.h (xtensa_expand_compare_and_swap): New.\n+\t(xtensa_expand_atomic): New.\n+\t\n 2007-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR target/30652"}, {"sha": "27b0a48ba895b36984fb5180d3dfa19f1f1aa350", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -47,6 +47,8 @@ extern void xtensa_split_operand_pair (rtx *, enum machine_mode);\n extern int xtensa_emit_move_sequence (rtx *, enum machine_mode);\n extern rtx xtensa_copy_incoming_a7 (rtx);\n extern void xtensa_expand_nonlocal_goto (rtx *);\n+extern void xtensa_expand_compare_and_swap (rtx, rtx, rtx, rtx);\n+extern void xtensa_expand_atomic (enum rtx_code, rtx, rtx, rtx, bool);\n extern void xtensa_emit_loop_end (rtx, rtx *);\n extern char *xtensa_emit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_bit_branch (bool, bool, rtx *);"}, {"sha": "4d21b65677f1125de3f18b9a46686e2256572f92", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -1198,6 +1198,263 @@ xtensa_init_machine_status (void)\n }\n \n \n+/* Shift VAL of mode MODE left by COUNT bits.  */\n+\n+static inline rtx\n+xtensa_expand_mask_and_shift (rtx val, enum machine_mode mode, rtx count)\n+{\n+  val = expand_simple_binop (SImode, AND, val, GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+  return expand_simple_binop (SImode, ASHIFT, val, count,\n+\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+}\n+\n+\n+/* Structure to hold the initial parameters for a compare_and_swap operation\n+   in HImode and QImode.  */\n+\n+struct alignment_context\n+{\n+  rtx memsi;\t  /* SI aligned memory location.  */\n+  rtx shift;\t  /* Bit offset with regard to lsb.  */\n+  rtx modemask;\t  /* Mask of the HQImode shifted by SHIFT bits.  */\n+  rtx modemaski;  /* ~modemask */\n+};\n+\n+\n+/* Initialize structure AC for word access to HI and QI mode memory.  */\n+\n+static void\n+init_alignment_context (struct alignment_context *ac, rtx mem)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx byteoffset = NULL_RTX;\n+  bool aligned = (MEM_ALIGN (mem) >= GET_MODE_BITSIZE (SImode));\n+\n+  if (aligned)\n+    ac->memsi = adjust_address (mem, SImode, 0); /* Memory is aligned.  */\n+  else\n+    {\n+      /* Alignment is unknown.  */\n+      rtx addr, align;\n+\n+      /* Force the address into a register.  */\n+      addr = force_reg (Pmode, XEXP (mem, 0));\n+\n+      /* Align it to SImode.  */\n+      align = expand_simple_binop (Pmode, AND, addr,\n+\t\t\t\t   GEN_INT (-GET_MODE_SIZE (SImode)),\n+\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+      /* Generate MEM.  */\n+      ac->memsi = gen_rtx_MEM (SImode, align);\n+      MEM_VOLATILE_P (ac->memsi) = MEM_VOLATILE_P (mem);\n+      set_mem_alias_set (ac->memsi, ALIAS_SET_MEMORY_BARRIER);\n+      set_mem_align (ac->memsi, GET_MODE_BITSIZE (SImode));\n+\n+      byteoffset = expand_simple_binop (Pmode, AND, addr,\n+\t\t\t\t\tGEN_INT (GET_MODE_SIZE (SImode) - 1),\n+\t\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT);\n+    }\n+\n+  /* Calculate shiftcount.  */\n+  if (TARGET_BIG_ENDIAN)\n+    {\n+      ac->shift = GEN_INT (GET_MODE_SIZE (SImode) - GET_MODE_SIZE (mode));\n+      if (!aligned)\n+\tac->shift = expand_simple_binop (SImode, MINUS, ac->shift, byteoffset,\n+\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+    }\n+  else\n+    {\n+      if (aligned)\n+\tac->shift = NULL_RTX;\n+      else\n+\tac->shift = byteoffset;\n+    }\n+\n+  if (ac->shift != NULL_RTX)\n+    {\n+      /* Shift is the byte count, but we need the bitcount.  */\n+      ac->shift = expand_simple_binop (SImode, MULT, ac->shift,\n+\t\t\t\t       GEN_INT (BITS_PER_UNIT),\n+\t\t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+      ac->modemask = expand_simple_binop (SImode, ASHIFT,\n+\t\t\t\t\t  GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t\t\t  ac->shift,\n+\t\t\t\t\t  NULL_RTX, 1, OPTAB_DIRECT);\n+    }\n+  else\n+    ac->modemask = GEN_INT (GET_MODE_MASK (mode));\n+\n+  ac->modemaski = expand_simple_unop (SImode, NOT, ac->modemask, NULL_RTX, 1);\n+}\n+\n+\n+/* Expand an atomic compare and swap operation for HImode and QImode.\n+   MEM is the memory location, CMP the old value to compare MEM with\n+   and NEW the value to set if CMP == MEM.  */\n+\n+void\n+xtensa_expand_compare_and_swap (rtx target, rtx mem, rtx cmp, rtx new)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  struct alignment_context ac;\n+  rtx tmp, cmpv, newv, val;\n+  rtx oldval = gen_reg_rtx (SImode);\n+  rtx res = gen_reg_rtx (SImode);\n+  rtx csloop = gen_label_rtx ();\n+  rtx csend = gen_label_rtx ();\n+\n+  init_alignment_context (&ac, mem);\n+\n+  if (ac.shift != NULL_RTX)\n+    {\n+      cmp = xtensa_expand_mask_and_shift (cmp, mode, ac.shift);\n+      new = xtensa_expand_mask_and_shift (new, mode, ac.shift);\n+    }\n+\n+  /* Load the surrounding word into VAL with the MEM value masked out.  */\n+  val = force_reg (SImode, expand_simple_binop (SImode, AND, ac.memsi,\n+\t\t\t\t\t\tac.modemaski, NULL_RTX, 1,\n+\t\t\t\t\t\tOPTAB_DIRECT));\n+  emit_label (csloop);\n+\n+  /* Patch CMP and NEW into VAL at correct position.  */\n+  cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,\n+\t\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT));\n+  newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new, val,\n+\t\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT));\n+\n+  /* Jump to end if we're done.  */\n+  emit_insn (gen_sync_compare_and_swapsi (res, ac.memsi, cmpv, newv));\n+  emit_cmp_and_jump_insns (res, cmpv, EQ, const0_rtx, SImode, true, csend);\n+\n+  /* Check for changes outside mode.  */\n+  emit_move_insn (oldval, val);\n+  tmp = expand_simple_binop (SImode, AND, res, ac.modemaski,\n+\t\t\t     val, 1, OPTAB_DIRECT);\n+  if (tmp != val)\n+    emit_move_insn (val, tmp);\n+\n+  /* Loop internal if so.  */\n+  emit_cmp_and_jump_insns (oldval, val, NE, const0_rtx, SImode, true, csloop);\n+\n+  emit_label (csend);\n+\n+  /* Return the correct part of the bitfield.  */\n+  convert_move (target,\n+\t\t(ac.shift == NULL_RTX ? res\n+\t\t : expand_simple_binop (SImode, LSHIFTRT, res, ac.shift,\n+\t\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT)),\n+\t\t1);\n+}\n+\n+\n+/* Expand an atomic operation CODE of mode MODE (either HImode or QImode --\n+   the default expansion works fine for SImode).  MEM is the memory location\n+   and VAL the value to play with.  If AFTER is true then store the value\n+   MEM holds after the operation, if AFTER is false then store the value MEM\n+   holds before the operation.  If TARGET is zero then discard that value, else\n+   store it to TARGET.  */\n+\n+void\n+xtensa_expand_atomic (enum rtx_code code, rtx target, rtx mem, rtx val,\n+\t\t      bool after)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  struct alignment_context ac;\n+  rtx csloop = gen_label_rtx ();\n+  rtx cmp, tmp;\n+  rtx old = gen_reg_rtx (SImode);\n+  rtx new = gen_reg_rtx (SImode);\n+  rtx orig = NULL_RTX;\n+\n+  init_alignment_context (&ac, mem);\n+\n+  /* Prepare values before the compare-and-swap loop.  */\n+  if (ac.shift != NULL_RTX)\n+    val = xtensa_expand_mask_and_shift (val, mode, ac.shift);\n+  switch (code)\n+    {\n+    case PLUS:\n+    case MINUS:\n+      orig = gen_reg_rtx (SImode);\n+      convert_move (orig, val, 1);\n+      break;\n+\n+    case SET:\n+    case IOR:\n+    case XOR:\n+      break;\n+\n+    case MULT: /* NAND */\n+    case AND:\n+      /* val = \"11..1<val>11..1\" */\n+      val = expand_simple_binop (SImode, XOR, val, ac.modemaski,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Load full word.  Subsequent loads are performed by S32C1I.  */\n+  cmp = force_reg (SImode, ac.memsi);\n+\n+  emit_label (csloop);\n+  emit_move_insn (old, cmp);\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+    case MINUS:\n+      val = expand_simple_binop (SImode, code, old, orig,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      val = expand_simple_binop (SImode, AND, val, ac.modemask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* FALLTHRU */\n+    case SET:\n+      tmp = expand_simple_binop (SImode, AND, old, ac.modemaski,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      tmp = expand_simple_binop (SImode, IOR, tmp, val,\n+\t\t\t\t new, 1, OPTAB_DIRECT);\n+      break;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      tmp = expand_simple_binop (SImode, code, old, val,\n+\t\t\t\t new, 1, OPTAB_DIRECT);\n+      break;\n+\n+    case MULT: /* NAND */\n+      tmp = expand_simple_binop (SImode, XOR, old, ac.modemask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      tmp = expand_simple_binop (SImode, AND, tmp, val,\n+\t\t\t\t new, 1, OPTAB_DIRECT);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (tmp != new)\n+    emit_move_insn (new, tmp);\n+  emit_insn (gen_sync_compare_and_swapsi (cmp, ac.memsi, old, new));\n+  emit_cmp_and_jump_insns (cmp, old, NE, const0_rtx, SImode, true, csloop);\n+\n+  if (target)\n+    {\n+      tmp = (after ? new : cmp);\n+      convert_move (target,\n+\t\t    (ac.shift == NULL_RTX ? tmp\n+\t\t     : expand_simple_binop (SImode, LSHIFTRT, tmp, ac.shift,\n+\t\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT)),\n+\t\t    1);\n+    }\n+}\n+\n+\n void\n xtensa_setup_frame_addresses (void)\n {"}, {"sha": "e85dc26aafde384eed0379f0421c91f77f3ce6c2", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -47,6 +47,12 @@ extern unsigned xtensa_current_frame_size;\n #ifndef XCHAL_HAVE_MUL32_HIGH\n #define XCHAL_HAVE_MUL32_HIGH 0\n #endif\n+#ifndef XCHAL_HAVE_RELEASE_SYNC\n+#define XCHAL_HAVE_RELEASE_SYNC 0\n+#endif\n+#ifndef XCHAL_HAVE_S32C1I\n+#define XCHAL_HAVE_S32C1I 0\n+#endif\n #define TARGET_BIG_ENDIAN\tXCHAL_HAVE_BE\n #define TARGET_DENSITY\t\tXCHAL_HAVE_DENSITY\n #define TARGET_MAC16\t\tXCHAL_HAVE_MAC16\n@@ -65,6 +71,8 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_HARD_FLOAT_RSQRT\tXCHAL_HAVE_FP_RSQRT\n #define TARGET_ABS\t\tXCHAL_HAVE_ABS\n #define TARGET_ADDX\t\tXCHAL_HAVE_ADDX\n+#define TARGET_RELEASE_SYNC\tXCHAL_HAVE_RELEASE_SYNC\n+#define TARGET_S32C1I\t\tXCHAL_HAVE_S32C1I\n \n #define TARGET_DEFAULT (\t\t\t\t\t\t\\\n   (XCHAL_HAVE_L32R\t? 0 : MASK_CONST16))"}, {"sha": "f2d218da895e434caff4f9646871454a602e5943", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -30,8 +30,12 @@\n   (UNSPEC_NOP\t\t2)\n   (UNSPEC_PLT\t\t3)\n   (UNSPEC_RET_ADDR\t4)\n+\n   (UNSPECV_SET_FP\t1)\n   (UNSPECV_ENTRY\t2)\n+  (UNSPECV_MEMW\t\t3)\n+  (UNSPECV_S32RI\t4)\n+  (UNSPECV_S32C1I\t5)\n ])\n \n ;; This code macro allows signed and unsigned widening multiplications\n@@ -63,6 +67,15 @@\n ;; This code macro is for floating-point comparisons.\n (define_code_macro any_scc_sf [eq lt le])\n \n+;; These macros allow to combine most atomic operations.\n+(define_code_macro ATOMIC [and ior xor plus minus mult])\n+(define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n+\t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n+\n+;; These mode macros allow the HI and QI patterns to be defined from\n+;; the same template.\n+(define_mode_macro HQI [HI QI])\n+\n \f\n ;; Attributes.\n \n@@ -1687,3 +1700,113 @@ srli\\t%3, %3, 30\\;slli\\t%0, %1, 2\\;ssai\\t2\\;src\\t%0, %3, %0\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"3\")])\n+\n+\f\n+;; Atomic operations\n+\n+(define_expand \"memory_barrier\"\n+  [(set (mem:BLK (match_dup 0))\n+\t(unspec_volatile:BLK [(mem:BLK (match_dup 0))] UNSPECV_MEMW))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (SImode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_insn \"*memory_barrier\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec_volatile:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPECV_MEMW))]\n+  \"\"\n+  \"memw\"\n+  [(set_attr \"type\"\t\"unknown\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+;; sync_lock_release is only implemented for SImode.\n+;; For other modes, just use the default of a store with a memory_barrier.\n+(define_insn \"sync_lock_releasesi\"\n+  [(set (match_operand:SI 0 \"mem_operand\" \"=U\")\n+\t(unspec_volatile:SI\n+\t  [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t  UNSPECV_S32RI))]\n+  \"TARGET_RELEASE_SYNC\"\n+  \"s32ri\\t%1, %0\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"sync_compare_and_swapsi\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t  (match_operand:SI 1 \"mem_operand\" \"+U\"))\n+     (set (match_dup 1)\n+\t  (unspec_volatile:SI\n+\t    [(match_dup 1)\n+\t     (match_operand:SI 2 \"register_operand\" \"r\")\n+\t     (match_operand:SI 3 \"register_operand\" \"0\")]\n+\t    UNSPECV_S32C1I))])]\n+  \"TARGET_S32C1I\"\n+  \"wsr\\t%2, SCOMPARE1\\;s32c1i\\t%3, %1\"\n+  [(set_attr \"type\"\t\"multi\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"6\")])\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(parallel\n+    [(set (match_operand:HQI 0 \"register_operand\" \"\")\n+\t  (match_operand:HQI 1 \"mem_operand\" \"\"))\n+     (set (match_dup 1)\n+\t  (unspec_volatile:HQI\n+\t    [(match_dup 1)\n+\t     (match_operand:HQI 2 \"register_operand\" \"\")\n+\t     (match_operand:HQI 3 \"register_operand\" \"\")]\n+\t    UNSPECV_S32C1I))])]\n+  \"TARGET_S32C1I\"\n+{\n+  xtensa_expand_compare_and_swap (operands[0], operands[1],\n+\t\t\t\t  operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(match_operand:HQI 0 \"register_operand\")\n+   (match_operand:HQI 1 \"memory_operand\")\n+   (match_operand:HQI 2 \"register_operand\")]\n+  \"TARGET_S32C1I\"\n+{\n+  xtensa_expand_atomic (SET, operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n+(define_expand \"sync_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"memory_operand\")\n+\t(ATOMIC:HQI (match_dup 0)\n+\t\t    (match_operand:HQI 1 \"register_operand\")))]\n+  \"TARGET_S32C1I\"\n+{\n+  xtensa_expand_atomic (<CODE>, NULL_RTX, operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"sync_old_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"register_operand\")\n+\t(match_operand:HQI 1 \"memory_operand\"))\n+   (set (match_dup 1)\n+\t(ATOMIC:HQI (match_dup 1)\n+\t\t    (match_operand:HQI 2 \"register_operand\")))]\n+  \"TARGET_S32C1I\"\n+{\n+  xtensa_expand_atomic (<CODE>, operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n+(define_expand \"sync_new_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"register_operand\")\n+\t(ATOMIC:HQI (match_operand:HQI 1 \"memory_operand\")\n+\t\t    (match_operand:HQI 2 \"register_operand\"))) \n+   (set (match_dup 1) (ATOMIC:HQI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_S32C1I\"\n+{\n+  xtensa_expand_atomic (<CODE>, operands[0], operands[1], operands[2], true);\n+  DONE;\n+})"}, {"sha": "72564be48eb013a3835a502f2cf6c1b093bde277", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -1,3 +1,9 @@\n+2007-07-18  Bob Wilson  <bob.wilson@acm.org>\n+\t\n+\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n+\tEnable for xtensa.\n+\t(check_effective_target_sync_char_short): Likewise.\n+\t\n 2007-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/pr28796-2.c: Add more cases."}, {"sha": "c52a050829f4feed02e1747f0d699d2ced9629ab", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -2188,7 +2188,8 @@ proc check_effective_target_sync_int_long { } {\n \t     || [istarget s390*-*-*] \n \t     || [istarget powerpc*-*-*]\n \t     || [istarget sparc64-*-*]\n-\t     || [istarget sparcv9-*-*] } {\n+\t     || [istarget sparcv9-*-*]\n+\t     || [istarget xtensa-*-*] } {\n            set et_sync_int_long_saved 1\n         }\n     }\n@@ -2215,7 +2216,8 @@ proc check_effective_target_sync_char_short { } {\n \t     || [istarget s390*-*-*] \n \t     || [istarget powerpc*-*-*]\n \t     || [istarget sparc64-*-*]\n-\t     || [istarget sparcv9-*-*] } {\n+\t     || [istarget sparcv9-*-*]\n+\t     || [istarget xtensa-*-*] } {\n            set et_sync_char_short_saved 1\n         }\n     }"}, {"sha": "fe03cb2fd773f30cada7c3475e9f9662a389396d", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -1,3 +1,8 @@\n+2007-07-18  Bob Wilson  <bob.wilson@acm.org>\n+\t\n+\t* xtensa-config.h (XCHAL_HAVE_THREADPTR): New.\n+\t(XCHAL_HAVE_RELEASE_SYNC, XCHAL_HAVE_S32C1I): New.\n+\t\n 2007-07-17  Nick Clifton  <nickc@redhat.com>\n \n \t* COPYING3: New file.  Contains version 3 of the GNU General"}, {"sha": "2aca5feda05af45c2da720c5727e8ec4eed6ff68", "filename": "include/xtensa-config.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/include%2Fxtensa-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a48b790b26895fd7fb56c9ce1d64f083dd278bb/include%2Fxtensa-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fxtensa-config.h?ref=2a48b790b26895fd7fb56c9ce1d64f083dd278bb", "patch": "@@ -1,5 +1,5 @@\n /* Xtensa configuration settings.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n@@ -73,6 +73,15 @@\n #undef XCHAL_HAVE_LOOPS\n #define XCHAL_HAVE_LOOPS\t\t1\n \n+#undef XCHAL_HAVE_THREADPTR\n+#define XCHAL_HAVE_THREADPTR\t\t1\n+\n+#undef XCHAL_HAVE_RELEASE_SYNC\n+#define XCHAL_HAVE_RELEASE_SYNC\t\t0\n+\n+#undef XCHAL_HAVE_S32C1I\n+#define XCHAL_HAVE_S32C1I\t\t0\n+\n #undef XCHAL_HAVE_BOOLEANS\n #define XCHAL_HAVE_BOOLEANS\t\t0\n "}]}