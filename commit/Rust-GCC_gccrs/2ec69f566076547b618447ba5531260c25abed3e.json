{"sha": "2ec69f566076547b618447ba5531260c25abed3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjNjlmNTY2MDc2NTQ3YjYxODQ0N2JhNTUzMTI2MGMyNWFiZWQzZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-10-12T18:04:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-10-12T18:04:51Z"}, "message": "PR c++/77742 - -Waligned-new and placement new.\n\n\t* init.c (build_new_1): Don't -Waligned-new about placement new.\n\t(malloc_alignment): New.  Consider MALLOC_ABI_ALIGNMENT.\n\t* decl.c (cxx_init_decl_processing): New.\n\nFrom-SVN: r241073", "tree": {"sha": "b0b884a556e7cf9e1c8d1c48712cc88cdddf5671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b884a556e7cf9e1c8d1c48712cc88cdddf5671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ec69f566076547b618447ba5531260c25abed3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec69f566076547b618447ba5531260c25abed3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec69f566076547b618447ba5531260c25abed3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec69f566076547b618447ba5531260c25abed3e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa8e596366cabd3c91822aee91987879a2eb58fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8e596366cabd3c91822aee91987879a2eb58fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8e596366cabd3c91822aee91987879a2eb58fd"}], "stats": {"total": 66, "additions": 50, "deletions": 16}, "files": [{"sha": "b01e196667d281b8ea56b7d35a0bfb5c531e2619", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,3 +1,10 @@\n+2016-10-11  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/77742\n+\t* init.c (build_new_1): Don't -Waligned-new about placement new.\n+\t(malloc_alignment): New.  Consider MALLOC_ABI_ALIGNMENT.\n+\t* decl.c (cxx_init_decl_processing): New.\n+\n 2016-10-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/77890"}, {"sha": "88cae04e69b44fa66d186ab9075162e54f00cdad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -5953,6 +5953,7 @@ extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree throw_bad_array_new_length\t\t(void);\n extern bool type_has_new_extended_alignment\t(tree);\n+extern unsigned malloc_alignment\t\t(void);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n                                                  tsubst_flags_t);"}, {"sha": "62408931900c5e3c13cf532beda72642fe531fbf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -4082,7 +4082,7 @@ cxx_init_decl_processing (void)\n   if (aligned_new_threshold == -1)\n     aligned_new_threshold = (cxx_dialect >= cxx1z) ? 1 : 0;\n   if (aligned_new_threshold == 1)\n-    aligned_new_threshold = max_align_t_align () / BITS_PER_UNIT;\n+    aligned_new_threshold = malloc_alignment () / BITS_PER_UNIT;\n \n   {\n     tree newattrs, extvisattr;"}, {"sha": "455995a58d7d5aefe93123a4cf8e21898bb3b2ce", "filename": "gcc/cp/init.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -2589,6 +2589,16 @@ type_has_new_extended_alignment (tree t)\n \t  && TYPE_ALIGN_UNIT (t) > (unsigned)aligned_new_threshold);\n }\n \n+/* Return the alignment we expect malloc to guarantee.  This should just be\n+   MALLOC_ABI_ALIGNMENT, but that macro defaults to only BITS_PER_WORD for some\n+   reason, so don't let the threshold be smaller than max_align_t_align.  */\n+\n+unsigned\n+malloc_alignment ()\n+{\n+  return MAX (max_align_t_align(), MALLOC_ABI_ALIGNMENT);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -2974,8 +2984,23 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   gcc_assert (alloc_fn != NULL_TREE);\n \n+  /* Now, check to see if this function is actually a placement\n+     allocation function.  This can happen even when PLACEMENT is NULL\n+     because we might have something like:\n+\n+       struct S { void* operator new (size_t, int i = 0); };\n+\n+     A call to `new S' will get this allocation function, even though\n+     there is no explicit placement argument.  If there is more than\n+     one argument, or there are variable arguments, then this is a\n+     placement allocation function.  */\n+  placement_allocation_fn_p\n+    = (type_num_arguments (TREE_TYPE (alloc_fn)) > 1\n+       || varargs_function_p (alloc_fn));\n+\n   if (warn_aligned_new\n-      && TYPE_ALIGN (elt_type) > max_align_t_align ()\n+      && !placement_allocation_fn_p\n+      && TYPE_ALIGN (elt_type) > malloc_alignment ()\n       && (warn_aligned_new > 1\n \t  || CP_DECL_CONTEXT (alloc_fn) == global_namespace)\n       && !aligned_allocation_fn_p (alloc_fn))\n@@ -3033,20 +3058,6 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   while (TREE_CODE (alloc_call) == COMPOUND_EXPR)\n     alloc_call = TREE_OPERAND (alloc_call, 1);\n \n-  /* Now, check to see if this function is actually a placement\n-     allocation function.  This can happen even when PLACEMENT is NULL\n-     because we might have something like:\n-\n-       struct S { void* operator new (size_t, int i = 0); };\n-\n-     A call to `new S' will get this allocation function, even though\n-     there is no explicit placement argument.  If there is more than\n-     one argument, or there are variable arguments, then this is a\n-     placement allocation function.  */\n-  placement_allocation_fn_p\n-    = (type_num_arguments (TREE_TYPE (alloc_fn)) > 1\n-       || varargs_function_p (alloc_fn));\n-\n   /* Preevaluate the placement args so that we don't reevaluate them for a\n      placement delete.  */\n   if (placement_allocation_fn_p)"}, {"sha": "e12db9b9fad93057ca846eddccd808946b34c7e2", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new7.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new7.C?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/77742\n+// { dg-options \"-Wall -std=c++1z\" }\n+\n+#include <new>\n+\n+struct X\n+{\n+  alignas(2*__STDCPP_DEFAULT_NEW_ALIGNMENT__) int i;\n+};\n+\n+int main()\n+{\n+  alignas(alignof(X)) char buf[sizeof(X)];\n+  ::new((void*)buf) X{1};\n+}"}]}