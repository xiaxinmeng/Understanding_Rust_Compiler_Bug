{"sha": "6e45f57bf38ac4ca36f085a27729ebc25856333e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0NWY1N2JmMzhhYzRjYTM2ZjA4NWEyNzcyOWViYzI1ODU2MzMzZQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-09-08T14:33:03Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-09-08T14:33:03Z"}, "message": "array.c: Don't include assert.h.\n\n\t* array.c: Don't include assert.h.\n\t* data.c: Don't include assert.h.  Replace assert and abort with\n\tgcc_assert and gcc_unreachable.\n\t* dependency.c: Ditto.\n\t* f95-lang.c: Ditto.\n\t* iresolve.c: Ditto.\n\t* resolve.c: Ditto.\n\t* simplify.c: Ditto.\n\t* symbol.c: Ditto.\n\t* trans-array.c: Ditto.\n\t* trans-common.c: Ditto.\n\t* trans-const.c: Ditto.\n\t* trans-decl.c: Ditto.\n\t* trans-expr.c: Ditto.\n\t* trans-intrinsic.c: Ditto.\n\t* trans-io.c: Ditto.\n\t* trans-stmt.c: Ditto.\n\t* trans-types.c: Ditto.\n\t* trans.c: Ditto.\n\nFrom-SVN: r87187", "tree": {"sha": "a38df818a0e3b820f84fcfd17398ee161742aa6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a38df818a0e3b820f84fcfd17398ee161742aa6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e45f57bf38ac4ca36f085a27729ebc25856333e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e45f57bf38ac4ca36f085a27729ebc25856333e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e45f57bf38ac4ca36f085a27729ebc25856333e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e45f57bf38ac4ca36f085a27729ebc25856333e/comments", "author": null, "committer": null, "parents": [{"sha": "c3462823c6c68ed4da8ec202ecae00b08708b28d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3462823c6c68ed4da8ec202ecae00b08708b28d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3462823c6c68ed4da8ec202ecae00b08708b28d"}], "stats": {"total": 782, "additions": 381, "deletions": 401}, "files": [{"sha": "3153282dabf1abb6faa9ce134f724dc8014e4aff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -1,3 +1,25 @@\n+2004-09-08  Paul Brook  <paul@codesourcery.com>\n+\n+\t* array.c: Don't include assert.h.\n+\t* data.c: Don't include assert.h.  Replace assert and abort with\n+\tgcc_assert and gcc_unreachable.\n+\t* dependency.c: Ditto.\n+\t* f95-lang.c: Ditto.\n+\t* iresolve.c: Ditto.\n+\t* resolve.c: Ditto.\n+\t* simplify.c: Ditto.\n+\t* symbol.c: Ditto.\n+\t* trans-array.c: Ditto.\n+\t* trans-common.c: Ditto.\n+\t* trans-const.c: Ditto.\n+\t* trans-decl.c: Ditto.\n+\t* trans-expr.c: Ditto.\n+\t* trans-intrinsic.c: Ditto.\n+\t* trans-io.c: Ditto.\n+\t* trans-stmt.c: Ditto.\n+\t* trans-types.c: Ditto.\n+\t* trans.c: Ditto.\n+\n 2004-09-07  Per Bothner  <per@bothner.com>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "37747a62c83c9df7138c5b5174eb875c3622721c", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -24,7 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"match.h\"\n \n #include <string.h>\n-#include <assert.h>\n \n /* This parameter is the size of the largest array constructor that we\n    will expand to an array constructor without iterators."}, {"sha": "ceb6f3186678a1e6fe07f0ed1444fb3e994a0c91", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -35,7 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330,Boston, MA\n \n #include \"config.h\"\n #include \"gfortran.h\"\n-#include \"assert.h\"\n \n static void formalize_init_expr (gfc_expr *);\n \n@@ -168,7 +167,7 @@ create_character_intializer (gfc_expr * init, gfc_typespec * ts,\n \n   if (ref)\n     {\n-      assert (ref->type == REF_SUBSTRING);\n+      gcc_assert (ref->type == REF_SUBSTRING);\n \n       /* Only set a substring of the destination.  Fortran substring bounds\n          are one-based [start, end], we want zero based [start, end).  */\n@@ -225,7 +224,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n       if (ref->type == REF_SUBSTRING)\n \t{\n \t  /* A substring should always br the last subobject reference.  */\n-\t  assert (ref->next == NULL);\n+\t  gcc_assert (ref->next == NULL);\n \t  break;\n \t}\n \n@@ -250,7 +249,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t      expr->rank = ref->u.ar.as->rank;\n \t    }\n \t  else\n-\t    assert (expr->expr_type == EXPR_ARRAY);\n+\t    gcc_assert (expr->expr_type == EXPR_ARRAY);\n \n \t  if (ref->u.ar.type == AR_ELEMENT)\n \t    get_array_index (&ref->u.ar, &offset);\n@@ -279,7 +278,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t      expr->ts.derived = ref->u.c.sym;\n \t    }\n \t  else\n-\t    assert (expr->expr_type == EXPR_STRUCTURE);\n+\t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n \t  last_ts = &ref->u.c.component->ts;\n \n \t  /* Find the same element in the existing constructor.  */\n@@ -297,7 +296,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (init == NULL)\n@@ -317,7 +316,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n   else\n     {\n       /* We should never be overwriting an existing initializer.  */\n-      assert (!init);\n+      gcc_assert (!init);\n \n       expr = gfc_copy_expr (rvalue);\n       if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n@@ -375,15 +374,15 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \t      expr->rank = ref->u.ar.as->rank;\n \t    }\n \t  else\n-\t    assert (expr->expr_type == EXPR_ARRAY);\n+\t    gcc_assert (expr->expr_type == EXPR_ARRAY);\n \n \t  if (ref->u.ar.type == AR_ELEMENT)\n \t    {\n \t      get_array_index (&ref->u.ar, &offset);\n \n \t      /* This had better not be the bottom of the reference.\n \t\t We can still get to a full array via a component.  */\n-\t      assert (ref->next != NULL);\n+\t      gcc_assert (ref->next != NULL);\n \t    }\n \t  else\n \t    {\n@@ -392,8 +391,8 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \t      /* We're at a full array or an array section.  This means\n \t\t that we've better have found a full array, and that we're\n \t\t at the bottom of the reference.  */\n-\t      assert (ref->u.ar.type == AR_FULL);\n-\t      assert (ref->next == NULL);\n+\t      gcc_assert (ref->u.ar.type == AR_FULL);\n+\t      gcc_assert (ref->next == NULL);\n \t    }\n \n \t  /* Find the same element in the existing constructor.  */\n@@ -410,7 +409,7 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \t      gfc_insert_constructor (expr, con);\n \t    }\n \t  else\n-\t    assert (ref->next != NULL);\n+\t    gcc_assert (ref->next != NULL);\n \t  break;\n \n \tcase REF_COMPONENT:\n@@ -422,7 +421,7 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \t      expr->ts.derived = ref->u.c.sym;\n \t    }\n \t  else\n-\t    assert (expr->expr_type == EXPR_STRUCTURE);\n+\t    gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n \t  last_ts = &ref->u.c.component->ts;\n \n \t  /* Find the same element in the existing constructor.  */\n@@ -440,12 +439,12 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \n \t  /* Since we're only intending to initialize arrays here,\n \t     there better be an inner reference.  */\n-\t  assert (ref->next != NULL);\n+\t  gcc_assert (ref->next != NULL);\n \t  break;\n \n \tcase REF_SUBSTRING:\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (init == NULL)\n@@ -461,7 +460,7 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n     }\n \n   /* We should never be overwriting an existing initializer.  */\n-  assert (!init);\n+  gcc_assert (!init);\n \n   expr = gfc_copy_expr (rvalue);\n   if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n@@ -599,7 +598,7 @@ formalize_structure_cons (gfc_expr * expr)\n \t  tail = tail->next;\n \t}\n     }\n-  assert (c == NULL);\n+  gcc_assert (c == NULL);\n   expr->value.constructor = head;\n }\n \n@@ -683,7 +682,7 @@ gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)\n \t  gfc_internal_error (\"TODO: Vector sections in data statements\");\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       mpz_sub (tmp, ar->as->upper[i]->value.integer, "}, {"sha": "28b786f5bb3cd83889e92c711127b6a9f38d479d", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -28,7 +28,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"gfortran.h\"\n #include \"dependency.h\"\n-#include <assert.h>\n \n /* static declarations */\n /* Enums  */\n@@ -55,7 +54,7 @@ gfc_dependency;\n int\n gfc_expr_is_one (gfc_expr * expr, int def)\n {\n-  assert (expr != NULL);\n+  gcc_assert (expr != NULL);\n \n   if (expr->expr_type != EXPR_CONSTANT)\n     return def;\n@@ -115,9 +114,9 @@ gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n   int i;\n \n   /* TODO: More sophisticated range comparison.  */\n-  assert (ar1 && ar2);\n+  gcc_assert (ar1 && ar2);\n \n-  assert (ar1->dimen_type[n] == ar2->dimen_type[n]);\n+  gcc_assert (ar1->dimen_type[n] == ar2->dimen_type[n]);\n \n   e1 = ar1->stride[n];\n   e2 = ar2->stride[n];\n@@ -190,9 +189,9 @@ gfc_check_fncall_dependency (gfc_expr * dest, gfc_expr * fncall)\n   gfc_expr *expr;\n   int n;\n \n-  assert (dest->expr_type == EXPR_VARIABLE\n+  gcc_assert (dest->expr_type == EXPR_VARIABLE\n \t  && fncall->expr_type == EXPR_FUNCTION);\n-  assert (fncall->rank > 0);\n+  gcc_assert (fncall->rank > 0);\n \n   for (actual = fncall->value.function.actual; actual; actual = actual->next)\n     {\n@@ -214,7 +213,7 @@ gfc_check_fncall_dependency (gfc_expr * dest, gfc_expr * fncall)\n \t\t  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n \t\t    break;\n \t\t}\n-\t      assert (ref);\n+\t      gcc_assert (ref);\n \t      /* AR_FULL can't contain vector subscripts.  */\n \t      if (ref->u.ar.type == AR_SECTION)\n \t\t{\n@@ -264,7 +263,7 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n   int n;\n   gfc_actual_arglist *actual;\n \n-  assert (expr1->expr_type == EXPR_VARIABLE);\n+  gcc_assert (expr1->expr_type == EXPR_VARIABLE);\n \n   /* TODO: -fassume-no-pointer-aliasing */\n   if (expr1->symtree->n.sym->attr.pointer)\n@@ -604,7 +603,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n       /* We're resolving from the same base symbol, so both refs should be\n          the same type.  We traverse the reference chain intil we find ranges\n \t that are not equal.  */\n-      assert (lref->type == rref->type);\n+      gcc_assert (lref->type == rref->type);\n       switch (lref->type)\n \t{\n \tcase REF_COMPONENT:\n@@ -638,7 +637,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t\tthis_dep = gfc_check_element_vs_section (rref, lref, n);\n \t      else \n \t\t{\n-\t\t  assert (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n+\t\t  gcc_assert (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t          && lref->u.ar.dimen_type[n] == DIMEN_ELEMENT);\n \t\t  this_dep = gfc_check_element_vs_element (rref, lref, n);\n \t\t}\n@@ -662,14 +661,14 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       lref = lref->next;\n       rref = rref->next;\n     }\n \n   /* If we haven't seen any array refs then something went wrong.  */\n-  assert (fin_dep != GFC_DEP_ERROR);\n+  gcc_assert (fin_dep != GFC_DEP_ERROR);\n \n   if (fin_dep < GFC_DEP_OVERLAP)\n     return 0;"}, {"sha": "69b22dfc2e78a068ad4e71c2b2c5fd7ffe2210c1", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -49,7 +49,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n \n-#include <assert.h>\n #include <stdio.h>\n \n /* Language-dependent contents of an identifier.  */"}, {"sha": "713d81f20fff85f03385acde92c4662097b56be2", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -31,7 +31,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include <string.h>\n #include <stdarg.h>\n-#include <assert.h>\n \n #include \"gfortran.h\"\n #include \"intrinsic.h\""}, {"sha": "ec808a392b6c4e341573b659a545c555c5afed60", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -22,7 +22,6 @@ Software Foundation, 59 Temple Place - Suite 330,Boston, MA\n #include \"config.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"  /* For gfc_compare_expr().  */\n-#include <assert.h>\n #include <string.h>\n \n /* Stack to push the current if we descend into a block during\n@@ -345,7 +344,7 @@ resolve_entries (gfc_namespace * ns)\n     return;\n \n   /* If this isn't a procedure something has gone horribly wrong.   */\n-  assert (ns->proc_name->attr.flavor == FL_PROCEDURE);\n+  gcc_assert (ns->proc_name->attr.flavor == FL_PROCEDURE);\n   \n   /* Remember the current namespace.  */\n   old_ns = gfc_current_ns;\n@@ -375,7 +374,7 @@ resolve_entries (gfc_namespace * ns)\n \t    master_count++, ns->proc_name->name);\n   name[GFC_MAX_SYMBOL_LEN] = '\\0';\n   gfc_get_ha_symbol (name, &proc);\n-  assert (proc != NULL);\n+  gcc_assert (proc != NULL);\n \n   gfc_add_procedure (&proc->attr, PROC_INTERNAL, NULL);\n   if (ns->proc_name->attr.subroutine)\n@@ -3224,7 +3223,7 @@ gfc_find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      assert (expr->symtree->n.sym);\n+      gcc_assert (expr->symtree->n.sym);\n \n       /* A scalar assignment  */\n       if (!expr->ref)\n@@ -3296,7 +3295,7 @@ gfc_find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n       if (expr->ref)\n         {\n           tmp = expr->ref;\n-          assert(expr->ref->type == REF_SUBSTRING);\n+          gcc_assert (expr->ref->type == REF_SUBSTRING);\n           if (gfc_find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n             return SUCCESS;\n           if (gfc_find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n@@ -3791,7 +3790,7 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \t  break;\n \n \tcase EXEC_IOLENGTH:\n-\t  assert(code->ext.inquire != NULL);\n+\t  gcc_assert (code->ext.inquire != NULL);\n \t  if (gfc_resolve_inquire (code->ext.inquire) == FAILURE)\n \t    break;\n \n@@ -4159,7 +4158,7 @@ check_data_variable (gfc_data_variable * var, locus * where)\n \t    continue;\n \t  break;\n \t}\n-      assert (ref);\n+      gcc_assert (ref);\n \n       /* Set marks asscording to the reference pattern.  */\n       switch (ref->u.ar.type)\n@@ -4176,7 +4175,7 @@ check_data_variable (gfc_data_variable * var, locus * where)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n \n       if (gfc_array_size (e, &size) == FAILURE)"}, {"sha": "61ef50bdbcb861b63a8c476a163b10cda84ccd74", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -828,7 +828,7 @@ gfc_simplify_digits (gfc_expr * x)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return gfc_int_expr (digits);\n@@ -1115,7 +1115,7 @@ gfc_simplify_huge (gfc_expr * e)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return result;\n@@ -2477,7 +2477,7 @@ gfc_simplify_radix (gfc_expr * e)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   result = gfc_int_expr (i);\n@@ -2508,7 +2508,7 @@ gfc_simplify_range (gfc_expr * e)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   result = gfc_int_expr (j);"}, {"sha": "d1443bde077dc17eb00ce6e4142a9d82b7c0bf88", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -25,7 +25,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <string.h>\n #include <stdio.h>\n #include <stdlib.h>\n-#include <assert.h>\n \n #include \"gfortran.h\"\n #include \"parse.h\"\n@@ -2206,7 +2205,7 @@ gfc_free_namespace (gfc_namespace * ns)\n   ns->refs--;\n   if (ns->refs > 0)\n     return;\n-  assert (ns->refs == 0);\n+  gcc_assert (ns->refs == 0);\n \n   gfc_free_statements (ns->code);\n "}, {"sha": "a8e6dcfeefdaa955f55b2ec9e46cca4ae02eb445", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -86,7 +86,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"real.h\"\n #include \"flags.h\"\n-#include <assert.h>\n #include <gmp.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n@@ -181,11 +180,11 @@ gfc_conv_descriptor_data (tree desc)\n   tree type;\n \n   type = TREE_TYPE (desc);\n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = TYPE_FIELDS (type);\n-  assert (DATA_FIELD == 0);\n-  assert (field != NULL_TREE\n+  gcc_assert (DATA_FIELD == 0);\n+  gcc_assert (field != NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == ARRAY_TYPE);\n \n@@ -199,10 +198,10 @@ gfc_conv_descriptor_offset (tree desc)\n   tree field;\n \n   type = TREE_TYPE (desc);\n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n-  assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n   return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n@@ -214,10 +213,10 @@ gfc_conv_descriptor_dtype (tree desc)\n   tree type;\n \n   type = TREE_TYPE (desc);\n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n-  assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n   return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n@@ -230,10 +229,10 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n   tree tmp;\n \n   type = TREE_TYPE (desc);\n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = gfc_advance_chain (TYPE_FIELDS (type), DIMENSION_FIELD);\n-  assert (field != NULL_TREE\n+  gcc_assert (field != NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n@@ -251,7 +250,7 @@ gfc_conv_descriptor_stride (tree desc, tree dim)\n   tmp = gfc_conv_descriptor_dimension (desc, dim);\n   field = TYPE_FIELDS (TREE_TYPE (tmp));\n   field = gfc_advance_chain (field, STRIDE_SUBFIELD);\n-  assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n   tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n@@ -266,7 +265,7 @@ gfc_conv_descriptor_lbound (tree desc, tree dim)\n   tmp = gfc_conv_descriptor_dimension (desc, dim);\n   field = TYPE_FIELDS (TREE_TYPE (tmp));\n   field = gfc_advance_chain (field, LBOUND_SUBFIELD);\n-  assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n   tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n@@ -281,7 +280,7 @@ gfc_conv_descriptor_ubound (tree desc, tree dim)\n   tmp = gfc_conv_descriptor_dimension (desc, dim);\n   field = TYPE_FIELDS (TREE_TYPE (tmp));\n   field = gfc_advance_chain (field, UBOUND_SUBFIELD);\n-  assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n   tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n@@ -296,8 +295,8 @@ gfc_build_null_descriptor (tree type)\n   tree field;\n   tree tmp;\n \n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n-  assert (DATA_FIELD == 0);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (DATA_FIELD == 0);\n   field = TYPE_FIELDS (type);\n \n   /* Set a NULL data pointer.  */\n@@ -345,7 +344,7 @@ gfc_free_ss_chain (gfc_ss * ss)\n \n   while (ss != gfc_ss_terminator)\n     {\n-      assert (ss != NULL);\n+      gcc_assert (ss != NULL);\n       next = ss->next;\n       gfc_free_ss (ss);\n       ss = next;\n@@ -390,7 +389,7 @@ gfc_cleanup_loop (gfc_loopinfo * loop)\n   ss = loop->ss;\n   while (ss != gfc_ss_terminator)\n     {\n-      assert (ss != NULL);\n+      gcc_assert (ss != NULL);\n       next = ss->loop_chain;\n       gfc_free_ss (ss);\n       ss = next;\n@@ -416,7 +415,7 @@ gfc_add_ss_to_loop (gfc_loopinfo * loop, gfc_ss * head)\n       else\n \tss->loop_chain = ss->next;\n     }\n-  assert (ss == gfc_ss_terminator);\n+  gcc_assert (ss == gfc_ss_terminator);\n   loop->ss = head;\n }\n \n@@ -428,7 +427,7 @@ gfc_trans_static_array_pointer (gfc_symbol * sym)\n {\n   tree type;\n \n-  assert (TREE_STATIC (sym->backend_decl));\n+  gcc_assert (TREE_STATIC (sym->backend_decl));\n   /* Just zero the data member.  */\n   type = TREE_TYPE (sym->backend_decl);\n   DECL_INITIAL (sym->backend_decl) =gfc_build_null_descriptor (type);\n@@ -492,7 +491,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \t  else if (gfc_index_integer_kind == 8)\n \t    tmp = gfor_fndecl_internal_malloc64;\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  tmp = gfc_build_function_call (tmp, args);\n \t  tmp = convert (TREE_TYPE (data), tmp);\n \t  gfc_add_modify_expr (&loop->pre, data, tmp);\n@@ -537,13 +536,13 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n   int n;\n   int dim;\n \n-  assert (info->dimen > 0);\n+  gcc_assert (info->dimen > 0);\n   /* Set the lower bound to zero.  */\n   for (dim = 0; dim < info->dimen; dim++)\n     {\n       n = loop->order[dim];\n       if (n < loop->temp_dim)\n-\tassert (integer_zerop (loop->from[n]));\n+\tgcc_assert (integer_zerop (loop->from[n]));\n       else\n \t{\n \t  /* Callee allocated arrays may not have a known bound yet.  */\n@@ -640,7 +639,7 @@ gfc_put_offset_into_var (stmtblock_t * pblock, tree * poffset,\n {\n   /* We should have already created the offset variable.  We cannot\n      create it here because we may be in an inner scope.  */\n-  assert (*offsetvar != NULL_TREE);\n+  gcc_assert (*offsetvar != NULL_TREE);\n   gfc_add_modify_expr (pblock, *offsetvar, *poffset);\n   *poffset = *offsetvar;\n   TREE_USED (*offsetvar) = 1;\n@@ -717,7 +716,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n \n   /* Walk the array expression.  */\n   ss = gfc_walk_expr (expr);\n-  assert (ss != gfc_ss_terminator);\n+  gcc_assert (ss != gfc_ss_terminator);\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -737,7 +736,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n     gfc_todo_error (\"character arrays in constructors\");\n \n   gfc_trans_array_ctor_element (&body, pointer, *poffset, &se, expr);\n-  assert (se.ss == gfc_ss_terminator);\n+  gcc_assert (se.ss == gfc_ss_terminator);\n \n   /* Increment the offset.  */\n   tmp = build2 (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n@@ -1145,12 +1144,12 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n   if (TREE_USED (offsetvar))\n     pushdecl (offsetvar);\n   else\n-    assert (INTEGER_CST_P (offset));\n+    gcc_assert (INTEGER_CST_P (offset));\n #if 0\n   /* Disable bound checking for now because it's probably broken.  */\n   if (flag_bounds_check)\n     {\n-      abort ();\n+      gcc_unreachable ();\n     }\n #endif\n }\n@@ -1168,11 +1167,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \n   /* TODO: This can generate bad code if there are ordering dependencies.\n      eg. a callee allocated function and an unknown size constructor.  */\n-  assert (ss != NULL);\n+  gcc_assert (ss != NULL);\n \n   for (; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n-      assert (ss);\n+      gcc_assert (ss);\n \n       switch (ss->type)\n \t{\n@@ -1246,7 +1245,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n           break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -1262,7 +1261,7 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n   tree tmp;\n \n   /* Get the descriptor for the array to be scalarized.  */\n-  assert (ss->expr->expr_type == EXPR_VARIABLE);\n+  gcc_assert (ss->expr->expr_type == EXPR_VARIABLE);\n   gfc_init_se (&se, NULL);\n   se.descriptor_only = 1;\n   gfc_conv_expr_lhs (&se, ss->expr);\n@@ -1449,7 +1448,7 @@ gfc_conv_array_index_ref (gfc_se * se, tree pointer, tree * indices,\n   tmp = gfc_build_array_ref (array, index);\n \n   /* Check we've used the correct number of dimensions.  */\n-  assert (TREE_CODE (TREE_TYPE (tmp)) != ARRAY_TYPE);\n+  gcc_assert (TREE_CODE (TREE_TYPE (tmp)) != ARRAY_TYPE);\n \n   se->expr = tmp;\n }\n@@ -1494,7 +1493,7 @@ gfc_conv_vector_array_index (gfc_se * se, tree index, gfc_ss * ss)\n   gfc_ss_info *info;\n   int n;\n \n-  assert (ss && ss->type == GFC_SS_VECTOR);\n+  gcc_assert (ss && ss->type == GFC_SS_VECTOR);\n \n   /* Save the descriptor.  */\n   descsave = se->expr;\n@@ -1507,7 +1506,7 @@ gfc_conv_vector_array_index (gfc_se * se, tree index, gfc_ss * ss)\n       switch (ar->dimen_type[n])\n \t{\n \tcase DIMEN_ELEMENT:\n-\t  assert (info->subscript[n] != gfc_ss_terminator\n+\t  gcc_assert (info->subscript[n] != gfc_ss_terminator\n \t\t  && info->subscript[n]->type == GFC_SS_SCALAR);\n \t  indices[n] = info->subscript[n]->data.scalar.expr;\n \t  break;\n@@ -1524,7 +1523,7 @@ gfc_conv_vector_array_index (gfc_se * se, tree index, gfc_ss * ss)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   /* Get the index from the vector.  */\n@@ -1549,12 +1548,12 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n   /* Get the index into the array for this dimension.  */\n   if (ar)\n     {\n-      assert (ar->type != AR_ELEMENT);\n+      gcc_assert (ar->type != AR_ELEMENT);\n       if (ar->dimen_type[dim] == DIMEN_ELEMENT)\n \t{\n-\t  assert (i == -1);\n+\t  gcc_assert (i == -1);\n \t  /* Elemental dimension.  */\n-\t  assert (info->subscript[dim]\n+\t  gcc_assert (info->subscript[dim]\n \t\t  && info->subscript[dim]->type == GFC_SS_SCALAR);\n \t  /* We've already translated this value outside the loop.  */\n \t  index = info->subscript[dim]->data.scalar.expr;\n@@ -1565,7 +1564,7 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       else\n \t{\n \t  /* Scalarized dimension.  */\n-\t  assert (info && se->loop);\n+\t  gcc_assert (info && se->loop);\n \n           /* Multiply the loop variable by the stride and dela.  */\n \t  index = se->loop->loopvar[i];\n@@ -1584,13 +1583,13 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t\t\t\t\t     dim);\n \t    }\n \t  else\n-\t    assert (ar->dimen_type[dim] == DIMEN_RANGE);\n+\t    gcc_assert (ar->dimen_type[dim] == DIMEN_RANGE);\n \t}\n     }\n   else\n     {\n       /* Temporary array or derived type component.  */\n-      assert (se->loop);\n+      gcc_assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n       if (!integer_zerop (info->delta[i]))\n \tindex = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n@@ -1832,7 +1831,7 @@ gfc_start_scalarized_body (gfc_loopinfo * loop, stmtblock_t * pbody)\n   int n;\n   int flags;\n \n-  assert (!loop->array_parameter);\n+  gcc_assert (!loop->array_parameter);\n \n   for (dim = loop->dimen - 1; dim >= 0; dim--)\n     {\n@@ -2000,19 +1999,19 @@ gfc_conv_section_upper_bound (gfc_ss * ss, int n, stmtblock_t * pblock)\n   tree bound;\n   gfc_se se;\n \n-  assert (ss->type == GFC_SS_SECTION);\n+  gcc_assert (ss->type == GFC_SS_SECTION);\n \n   /* For vector array subscripts we want the size of the vector.  */\n   dim = ss->data.info.dim[n];\n   vecss = ss;\n   while (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n     {\n       vecss = vecss->data.info.subscript[dim];\n-      assert (vecss && vecss->type == GFC_SS_VECTOR);\n+      gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n       dim = vecss->data.info.dim[0];\n     }\n \n-  assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n+  gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n   end = vecss->data.info.ref->u.ar.end[dim];\n   desc = vecss->data.info.descriptor;\n \n@@ -2056,14 +2055,14 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n   while (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n     {\n       vecss = vecss->data.info.subscript[dim];\n-      assert (vecss && vecss->type == GFC_SS_VECTOR);\n+      gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n       /* Get the descriptors for the vector subscripts as well.  */\n       if (!vecss->data.info.descriptor)\n \tgfc_conv_ss_descriptor (&loop->pre, vecss, !loop->array_parameter);\n       dim = vecss->data.info.dim[0];\n     }\n \n-  assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n+  gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n   start = vecss->data.info.ref->u.ar.start[dim];\n   stride = vecss->data.info.ref->u.ar.stride[dim];\n   desc = vecss->data.info.descriptor;\n@@ -2199,10 +2198,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t     == DIMEN_VECTOR)\n \t\t{\n \t\t  vecss = vecss->data.info.subscript[dim];\n-\t\t  assert (vecss && vecss->type == GFC_SS_VECTOR);\n+\t\t  gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n \t\t  dim = vecss->data.info.dim[0];\n \t\t}\n-\t      assert (vecss->data.info.ref->u.ar.dimen_type[dim]\n+\t      gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim]\n \t\t      == DIMEN_RANGE);\n \t      desc = vecss->data.info.descriptor;\n \n@@ -2359,7 +2358,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \t      dim = 0;\n \t      for (n = 0; n < loop->dimen; n++)\n \t\t{\n-\t\t  assert (loop->order[n] == n);\n+\t\t  gcc_assert (loop->order[n] == n);\n \t\t  if (depends[n])\n \t\t  loop->order[dim++] = n;\n \t\t}\n@@ -2370,7 +2369,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \t\t  loop->order[dim++] = n;\n \t\t}\n \n-\t      assert (dim == loop->dimen);\n+\t      gcc_assert (dim == loop->dimen);\n \t      break;\n \t    }\n #endif\n@@ -2433,7 +2432,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t      /* An unknown size constructor will always be rank one.\n \t\t Higher rank constructors will either have known shape,\n \t\t or still be wrapped in a call to reshape.  */\n-\t      assert (loop->dimen == 1);\n+\t      gcc_assert (loop->dimen == 1);\n \t      /* Try to figure out the size of the constructor.  */\n \t      /* TODO: avoid this by making the frontend set the shape.  */\n \t      gfc_get_array_cons_size (&i, ss->expr->value.constructor);\n@@ -2519,8 +2518,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  switch (loopspec[n]->type)\n \t    {\n \t    case GFC_SS_CONSTRUCTOR:\n-\t      assert (info->dimen == 1);\n-      \t      assert (loop->to[n]);\n+\t      gcc_assert (info->dimen == 1);\n+      \t      gcc_assert (loop->to[n]);\n \t      break;\n \n \t    case GFC_SS_SECTION:\n@@ -2530,11 +2529,11 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \n             case GFC_SS_FUNCTION:\n \t      /* The loop bound will be set when we generate the call.  */\n-              assert (loop->to[n] == NULL_TREE);\n+              gcc_assert (loop->to[n] == NULL_TREE);\n               break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -2567,7 +2566,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n   /* If we want a temporary then create it.  */\n   if (loop->temp_ss != NULL)\n     {\n-      assert (loop->temp_ss->type == GFC_SS_TEMP);\n+      gcc_assert (loop->temp_ss->type == GFC_SS_TEMP);\n       tmp = loop->temp_ss->data.temp.type;\n       len = loop->temp_ss->string_length;\n       n = loop->temp_ss->data.temp.dimen;\n@@ -2676,7 +2675,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \tse.expr = gfc_index_one_node;\n       else\n \t{\n-\t  assert (lower[n]);\n+\t  gcc_assert (lower[n]);\n           if (ubound)\n             {\n \t      gfc_conv_expr_type (&se, lower[n], gfc_array_index_type);\n@@ -2701,7 +2700,7 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n-      assert (ubound);\n+      gcc_assert (ubound);\n       gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n       gfc_add_block_to_block (pblock, &se.pre);\n \n@@ -2760,7 +2759,7 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n       break;\n \n     case AR_FULL:\n-      assert (ref->u.ar.as->type == AS_EXPLICIT);\n+      gcc_assert (ref->u.ar.as->type == AS_EXPLICIT);\n \n       lower = ref->u.ar.as->lower;\n       upper = ref->u.ar.as->upper;\n@@ -2772,7 +2771,7 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n       break;\n     }\n \n@@ -2789,7 +2788,7 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n   else if (TYPE_PRECISION (gfc_array_index_type) == 64)\n     allocate = gfor_fndecl_allocate64;\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   tmp = gfc_chainon_list (NULL_TREE, pointer);\n   tmp = gfc_chainon_list (tmp, size);\n@@ -2862,7 +2861,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \tgfc_conv_structure (&se, expr, 1);\n \n       tmp = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-      assert (tmp && INTEGER_CST_P (tmp));\n+      gcc_assert (tmp && INTEGER_CST_P (tmp));\n       hi = TREE_INT_CST_HIGH (tmp);\n       lo = TREE_INT_CST_LOW (tmp);\n       lo++;\n@@ -2938,15 +2937,15 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \t      break;\n \n \t    default:\n-\t      abort();\n+\t      gcc_unreachable ();\n \t    }\n         }\n       /* We created the list in reverse order.  */\n       list = nreverse (list);\n       break;\n \n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n \n   /* Create a constructor from the list of elements.  */\n@@ -3042,14 +3041,14 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   tree offset;\n   bool onstack;\n \n-  assert (!(sym->attr.pointer || sym->attr.allocatable));\n+  gcc_assert (!(sym->attr.pointer || sym->attr.allocatable));\n \n   /* Do nothing for USEd variables.  */\n   if (sym->attr.use_assoc)\n     return fnbody;\n \n   type = TREE_TYPE (decl);\n-  assert (GFC_ARRAY_TYPE_P (type));\n+  gcc_assert (GFC_ARRAY_TYPE_P (type));\n   onstack = TREE_CODE (type) != POINTER_TYPE;\n \n   gfc_start_block (&block);\n@@ -3074,9 +3073,9 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   type = TREE_TYPE (type);\n \n-  assert (!sym->attr.use_assoc);\n-  assert (!TREE_STATIC (decl));\n-  assert (!sym->module[0]);\n+  gcc_assert (!sym->attr.use_assoc);\n+  gcc_assert (!TREE_STATIC (decl));\n+  gcc_assert (!sym->module[0]);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n@@ -3097,7 +3096,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   else if (gfc_index_integer_kind == 8)\n     fndecl = gfor_fndecl_internal_malloc64;\n   else\n-    abort ();\n+    gcc_unreachable ();\n   tmp = gfc_build_function_call (fndecl, tmp);\n   tmp = fold (convert (TREE_TYPE (decl), tmp));\n   gfc_add_modify_expr (&block, decl, tmp);\n@@ -3108,7 +3107,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n \n   /* Automatic arrays should not have initializers.  */\n-  assert (!sym->value);\n+  gcc_assert (!sym->value);\n \n   gfc_add_expr_to_block (&block, fnbody);\n \n@@ -3140,7 +3139,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   /* Descriptor type.  */\n   parm = sym->backend_decl;\n   type = TREE_TYPE (parm);\n-  assert (GFC_ARRAY_TYPE_P (type));\n+  gcc_assert (GFC_ARRAY_TYPE_P (type));\n \n   gfc_start_block (&block);\n \n@@ -3223,7 +3222,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   /* Descriptor type.  */\n   type = TREE_TYPE (tmpdesc);\n-  assert (GFC_ARRAY_TYPE_P (type));\n+  gcc_assert (GFC_ARRAY_TYPE_P (type));\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n   dumdesc = gfc_build_indirect_ref (dumdesc);\n   gfc_start_block (&block);\n@@ -3272,7 +3271,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n     }\n   else\n     {\n-      assert (integer_onep (GFC_TYPE_ARRAY_STRIDE (type, 0)));\n+      gcc_assert (integer_onep (GFC_TYPE_ARRAY_STRIDE (type, 0)));\n       /* A library call to repack the array if neccessary.  */\n       tmp = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n       tmp = gfc_chainon_list (NULL_TREE, tmp);\n@@ -3488,7 +3487,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   int full;\n   gfc_ss *vss;\n \n-  assert (ss != gfc_ss_terminator);\n+  gcc_assert (ss != gfc_ss_terminator);\n \n   /* TODO: Pass constant array constructors without a temporary.  */\n   /* Special case things we know we can pass easily.  */\n@@ -3503,7 +3502,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       while (secss != gfc_ss_terminator && secss->type != GFC_SS_SECTION)\n \tsecss = secss->next;\n \n-      assert (secss != gfc_ss_terminator);\n+      gcc_assert (secss != gfc_ss_terminator);\n \n       need_tmp = 0;\n       for (n = 0; n < secss->data.info.dimen; n++)\n@@ -3529,7 +3528,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tfull = 0;\n       else\n \t{\n-\t  assert (info->ref->u.ar.type == AR_SECTION);\n+\t  gcc_assert (info->ref->u.ar.type == AR_SECTION);\n \n \t  full = 1;\n \t  for (n = 0; n < info->ref->u.ar.dimen; n++)\n@@ -3582,7 +3581,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       if (se->direct_byref)\n \t{\n-\t  assert (secss != gfc_ss_terminator);\n+\t  gcc_assert (secss != gfc_ss_terminator);\n \n \t  /* For pointer assignments pass the descriptor directly.  */\n \t  se->ss = secss;\n@@ -3623,7 +3622,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   if (!need_tmp)\n     loop.array_parameter = 1;\n   else\n-    assert (se->want_pointer && !se->direct_byref);\n+    gcc_assert (se->want_pointer && !se->direct_byref);\n \n   /* Setup the scalarizing loops and bounds.  */\n   gfc_conv_ss_startstride (&loop);\n@@ -3685,7 +3684,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[0]);\n       gfc_add_modify_expr (&loop.pre, tmp, gfc_index_zero_node);\n \n-      assert (is_gimple_lvalue (desc));\n+      gcc_assert (is_gimple_lvalue (desc));\n       se->expr = gfc_build_addr_expr (NULL, desc);\n     }\n   else if (expr->expr_type == EXPR_FUNCTION)\n@@ -3720,7 +3719,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tse->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n \n       desc = info->descriptor;\n-      assert (secss && secss != gfc_ss_terminator);\n+      gcc_assert (secss && secss != gfc_ss_terminator);\n       if (se->direct_byref)\n \t{\n \t  /* For pointer assignments we fill in the destination.  */\n@@ -3764,14 +3763,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Work out the offset.  */\n \t  if (info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n-\t      assert (info->subscript[n]\n+\t      gcc_assert (info->subscript[n]\n \t\t      && info->subscript[n]->type == GFC_SS_SCALAR);\n \t      start = info->subscript[n]->data.scalar.expr;\n \t    }\n \t  else\n \t    {\n \t      /* Check we haven't somehow got out of sync.  */\n-\t      assert (info->dim[dim] == n);\n+\t      gcc_assert (info->dim[dim] == n);\n \n \t      /* Evaluate and remember the start of the section.  */\n \t      start = info->start[dim];\n@@ -3791,7 +3790,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \n \t  /* Vector subscripts need copying and are handled elsewhere.  */\n-\t  assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n+\t  gcc_assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n \n \t  /* Set the new lower bound.  */\n \t  from = loop.from[dim];\n@@ -3973,7 +3972,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \n   gfc_init_block (&fnblock);\n \n-  assert (TREE_CODE (sym->backend_decl) == VAR_DECL);\n+  gcc_assert (TREE_CODE (sym->backend_decl) == VAR_DECL);\n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n     gfc_trans_init_string_length (sym->ts.cl, &fnblock);\n@@ -3999,7 +3998,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n \n   /* Get the descriptor type.  */\n   type = TREE_TYPE (sym->backend_decl);\n-  assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   /* NULLIFY the data pointer.  */\n   tmp = gfc_conv_descriptor_data (descriptor);\n@@ -4083,9 +4082,9 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t      newss->data.info.dim[n] = n;\n \t      ar->dimen_type[n] = DIMEN_RANGE;\n \n-\t      assert (ar->start[n] == NULL);\n-\t      assert (ar->end[n] == NULL);\n-\t      assert (ar->stride[n] == NULL);\n+\t      gcc_assert (ar->start[n] == NULL);\n+\t      gcc_assert (ar->end[n] == NULL);\n+\t      gcc_assert (ar->stride[n] == NULL);\n \t    }\n \t  return newss;\n \n@@ -4108,7 +4107,7 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t\t{\n \t\tcase DIMEN_ELEMENT:\n \t\t  /* Add SS for elemental (scalar) subscripts.  */\n-\t\t  assert (ar->start[n]);\n+\t\t  gcc_assert (ar->start[n]);\n \t\t  indexss = gfc_get_ss ();\n \t\t  indexss->type = GFC_SS_SCALAR;\n \t\t  indexss->expr = ar->start[n];\n@@ -4149,17 +4148,17 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \n \t\tdefault:\n \t\t  /* We should know what sort of section it is by now.  */\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t    }\n \t  /* We should have at least one non-elemental dimension.  */\n-\t  assert (newss->data.info.dimen > 0);\n+\t  gcc_assert (newss->data.info.dimen > 0);\n \t  return head;\n \t  break;\n \n \tdefault:\n \t  /* We should know what sort of section it is by now.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n     }\n@@ -4203,14 +4202,14 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n       while (head && head->next != ss)\n \thead = head->next;\n       /* Check we haven't somehow broken the chain.  */\n-      assert (head);\n+      gcc_assert (head);\n       newss->next = ss;\n       head->next = newss;\n       newss->expr = expr->op1;\n     }\n   else\t\t\t\t/* head2 == head */\n     {\n-      assert (head2 == head);\n+      gcc_assert (head2 == head);\n       /* Second operand is scalar.  */\n       newss->next = head2;\n       head2 = newss;\n@@ -4229,13 +4228,14 @@ gfc_reverse_ss (gfc_ss * ss)\n   gfc_ss *next;\n   gfc_ss *head;\n \n-  assert (ss != NULL);\n+  gcc_assert (ss != NULL);\n \n   head = gfc_ss_terminator;\n   while (ss != gfc_ss_terminator)\n     {\n       next = ss->next;\n-      assert (next != NULL);\t/* Check we didn't somehow break the chain.  */\n+      /* Check we didn't somehow break the chain.  */\n+      gcc_assert (next != NULL);\n       ss->next = head;\n       head = ss;\n       ss = next;"}, {"sha": "f692f3eee22e8cddb34367f0cc03df694e5dc01a", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -103,7 +103,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n-#include <assert.h>\n \n \n /* Holds a single variable in a equivalence set.  */\n@@ -414,7 +413,7 @@ create_common (gfc_common_head *com)\n               offset = s->offset + s->length;\n             }\n         }\n-      assert (list);\n+      gcc_assert (list);\n       ctor = build1 (CONSTRUCTOR, union_type, nreverse(list));\n       TREE_CONSTANT (ctor) = 1;\n       TREE_INVARIANT (ctor) = 1;\n@@ -423,7 +422,7 @@ create_common (gfc_common_head *com)\n \n #ifdef ENABLE_CHECKING\n       for (tmp = CONSTRUCTOR_ELTS (ctor); tmp; tmp = TREE_CHAIN (tmp))\n-\tassert (TREE_CODE (TREE_PURPOSE (tmp)) == FIELD_DECL);\n+\tgcc_assert (TREE_CODE (TREE_PURPOSE (tmp)) == FIELD_DECL);\n #endif\n     }\n "}, {"sha": "e3c58507ca09b0ececdf6ed7526353df6282d0f9", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -30,7 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"real.h\"\n #include <gmp.h>\n-#include <assert.h>\n #include <math.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n@@ -70,7 +69,7 @@ gfc_build_const (tree type, tree intval)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return val;\n }\n@@ -102,10 +101,10 @@ gfc_conv_string_init (tree length, gfc_expr * expr)\n   int slen;\n   tree str;\n \n-  assert (expr->expr_type == EXPR_CONSTANT);\n-  assert (expr->ts.type == BT_CHARACTER && expr->ts.kind == 1);\n-  assert (INTEGER_CST_P (length));\n-  assert (TREE_INT_CST_HIGH (length) == 0);\n+  gcc_assert (expr->expr_type == EXPR_CONSTANT);\n+  gcc_assert (expr->ts.type == BT_CHARACTER && expr->ts.kind == 1);\n+  gcc_assert (INTEGER_CST_P (length));\n+  gcc_assert (TREE_INT_CST_HIGH (length) == 0);\n \n   len = TREE_INT_CST_LOW (length);\n   slen = expr->value.character.length;\n@@ -191,7 +190,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n       /* We assume that all numbers are in range for its type, and that\n \t we never create a type larger than 2*HWI, which is the largest\n \t that the middle-end can handle.  */\n-      assert (count == 1 || count == 2);\n+      gcc_assert (count == 1 || count == 2);\n \n       low = words[0];\n       high = words[1];\n@@ -228,7 +227,7 @@ gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n       if (gfc_real_kinds[n].kind == kind)\n \tbreak;\n     }\n-  assert (gfc_real_kinds[n].kind);\n+  gcc_assert (gfc_real_kinds[n].kind);\n \n   n = MAX (abs (gfc_real_kinds[n].min_exponent),\n \t   abs (gfc_real_kinds[n].max_exponent));\n@@ -292,7 +291,7 @@ gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n tree\n gfc_conv_constant_to_tree (gfc_expr * expr)\n {\n-  assert (expr->expr_type == EXPR_CONSTANT);\n+  gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n   switch (expr->ts.type)\n     {\n@@ -332,13 +331,13 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n void\n gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n {\n-  assert (expr->expr_type == EXPR_CONSTANT);\n+  gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n   if (se->ss != NULL)\n     {\n-      assert (se->ss != gfc_ss_terminator);\n-      assert (se->ss->type == GFC_SS_SCALAR);\n-      assert (se->ss->expr == expr);\n+      gcc_assert (se->ss != gfc_ss_terminator);\n+      gcc_assert (se->ss->type == GFC_SS_SCALAR);\n+      gcc_assert (se->ss->expr == expr);\n \n       se->expr = se->ss->data.scalar.expr;\n       se->string_length = se->ss->string_length;"}, {"sha": "de319c70993418ad6ddac4b3d71c9e98aafe023f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -35,7 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"errors.h\"\n #include \"flags.h\"\n #include \"cgraph.h\"\n-#include <assert.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n@@ -131,7 +130,7 @@ tree gfor_fndecl_sr_kind;\n static void\n gfc_add_decl_to_parent_function (tree decl)\n {\n-  assert (decl);\n+  gcc_assert (decl);\n   DECL_CONTEXT (decl) = DECL_CONTEXT (current_function_decl);\n   DECL_NONLOCAL (decl) = 1;\n   TREE_CHAIN (decl) = saved_parent_function_decls;\n@@ -141,7 +140,7 @@ gfc_add_decl_to_parent_function (tree decl)\n void\n gfc_add_decl_to_function (tree decl)\n {\n-  assert (decl);\n+  gcc_assert (decl);\n   TREE_USED (decl) = 1;\n   DECL_CONTEXT (decl) = current_function_decl;\n   TREE_CHAIN (decl) = saved_function_decls;\n@@ -242,7 +241,7 @@ gfc_get_label_decl (gfc_st_label * lp)\n       tree label_decl;\n \n       /* Validate the label declaration from the front end.  */\n-      assert (lp != NULL && lp->value <= MAX_LABEL_VALUE);\n+      gcc_assert (lp != NULL && lp->value <= MAX_LABEL_VALUE);\n \n       /* Build a mangled name for the label.  */\n       sprintf (label_name, \"__label_%.6d\", lp->value);\n@@ -330,13 +329,13 @@ static void\n gfc_finish_decl (tree decl, tree init)\n {\n   if (TREE_CODE (decl) == PARM_DECL)\n-    assert (init == NULL_TREE);\n+    gcc_assert (init == NULL_TREE);\n   /* Remember that PARM_DECL doesn't have a DECL_INITIAL field per se\n      -- it overlaps DECL_ARG_TYPE.  */\n   else if (init == NULL_TREE)\n-    assert (DECL_INITIAL (decl) == NULL_TREE);\n+    gcc_assert (DECL_INITIAL (decl) == NULL_TREE);\n   else\n-    assert (DECL_INITIAL (decl) == error_mark_node);\n+    gcc_assert (DECL_INITIAL (decl) == error_mark_node);\n \n   if (init != NULL_TREE)\n     {\n@@ -414,7 +413,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   else if (sym->module[0] && !sym->attr.result)\n     {\n       /* TODO: Don't set sym->module for result variables.  */\n-      assert (current_function_decl == NULL_TREE);\n+      gcc_assert (current_function_decl == NULL_TREE);\n       /* This is the declaration of a module variable.  */\n       TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n@@ -510,7 +509,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n     return;\n \n-  assert (GFC_ARRAY_TYPE_P (type));\n+  gcc_assert (GFC_ARRAY_TYPE_P (type));\n   nest = (sym->ns->proc_name->backend_decl != current_function_decl)\n \t && !sym->attr.contained;\n \n@@ -562,7 +561,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n     gfc_defer_symbol_init (sym);\n \n   type = TREE_TYPE (dummy);\n-  assert (TREE_CODE (dummy) == PARM_DECL\n+  gcc_assert (TREE_CODE (dummy) == PARM_DECL\n \t  && POINTER_TYPE_P (type));\n \n   /* Do we know the element size?  */\n@@ -573,7 +572,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n     {\n       /* For descriptorless arrays with known element size the actual\n          argument is sufficient.  */\n-      assert (GFC_ARRAY_TYPE_P (type));\n+      gcc_assert (GFC_ARRAY_TYPE_P (type));\n       gfc_build_qualified_array (dummy, sym);\n       return dummy;\n     }\n@@ -630,7 +629,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n \n   /* We should never get deferred shape arrays here.  We used to because of\n      frontend bugs.  */\n-  assert (sym->as->type != AS_DEFERRED);\n+  gcc_assert (sym->as->type != AS_DEFERRED);\n \n   switch (packed)\n     {\n@@ -670,7 +669,7 @@ gfc_create_string_length (gfc_symbol * sym)\n {\n   tree length;\n \n-  assert (sym->ts.cl);\n+  gcc_assert (sym->ts.cl);\n   gfc_conv_const_charlen (sym->ts.cl);\n   \n   if (sym->ts.cl->backend_decl == NULL_TREE)\n@@ -702,7 +701,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   tree length = NULL_TREE;\n   int byref;\n \n-  assert (sym->attr.referenced);\n+  gcc_assert (sym->attr.referenced);\n \n   if (sym->ns && sym->ns->proc_name->attr.function)\n     byref = gfc_return_by_reference (sym->ns->proc_name);\n@@ -720,7 +719,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t}\n \n       /* Dummy variables should already have been created.  */\n-      assert (sym->backend_decl);\n+      gcc_assert (sym->backend_decl);\n \n       /* Create a character length variable.  */\n       if (sym->ts.type == BT_CHARACTER)\n@@ -825,7 +824,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (name));\n \t    }\n \t  gfc_finish_var_decl (length, sym);\n-\t  assert (!sym->value);\n+\t  gcc_assert (!sym->value);\n \t}\n     }\n   sym->backend_decl = decl;\n@@ -888,7 +887,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   /* We should never be creating external decls for alternate entry points.\n      The procedure may be an alternate entry point, but we don't want/need\n      to know that.  */\n-  assert (!(sym->attr.entry || sym->attr.entry_master));\n+  gcc_assert (!(sym->attr.entry || sym->attr.entry_master));\n \n   if (sym->attr.intrinsic)\n     {\n@@ -897,21 +896,21 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \t at the first argument.  We pass NULL for the second argument\n \t otherwise things like AINT get confused.  */\n       isym = gfc_find_function (sym->name);\n-      assert (isym->resolve.f0 != NULL);\n+      gcc_assert (isym->resolve.f0 != NULL);\n \n       memset (&e, 0, sizeof (e));\n       e.expr_type = EXPR_FUNCTION;\n \n       memset (&argexpr, 0, sizeof (argexpr));\n-      assert (isym->formal);\n+      gcc_assert (isym->formal);\n       argexpr.ts = isym->formal->ts;\n \n       if (isym->formal->next == NULL)\n \tisym->resolve.f1 (&e, &argexpr);\n       else\n \t{\n \t  /* All specific intrinsics take one or two arguments.  */\n-\t  assert (isym->formal->next->next == NULL);\n+\t  gcc_assert (isym->formal->next->next == NULL);\n \t  isym->resolve.f2 (&e, &argexpr, NULL);\n \t}\n       sprintf (s, \"specific%s\", e.value.function.name);\n@@ -988,15 +987,15 @@ build_function_decl (gfc_symbol * sym)\n   tree result_decl;\n   gfc_formal_arglist *f;\n \n-  assert (!sym->backend_decl);\n-  assert (!sym->attr.external);\n+  gcc_assert (!sym->backend_decl);\n+  gcc_assert (!sym->attr.external);\n \n   /* Set the line and filename.  sym->declared_at seems to point to the\n      last statement for subroutines, but it'll do for now.  */\n   gfc_set_backend_locus (&sym->declared_at);\n \n   /* Allow only one nesting level.  Allow public declarations.  */\n-  assert (current_function_decl == NULL_TREE\n+  gcc_assert (current_function_decl == NULL_TREE\n \t  || DECL_CONTEXT (current_function_decl) == NULL_TREE);\n \n   type = gfc_get_function_type (sym);\n@@ -1147,7 +1146,7 @@ create_function_arglist (gfc_symbol * sym)\n \n \t  /* Length of character result.  */\n \t  type = TREE_VALUE (typelist);\n-\t  assert (type == gfc_charlen_type_node);\n+\t  gcc_assert (type == gfc_charlen_type_node);\n \n \t  length = build_decl (PARM_DECL,\n \t\t\t       get_identifier (\".__result\"),\n@@ -1157,7 +1156,7 @@ create_function_arglist (gfc_symbol * sym)\n \t      sym->ts.cl->backend_decl = length;\n \t      TREE_USED (length) = 1;\n \t    }\n-\t  assert (TREE_CODE (length) == PARM_DECL);\n+\t  gcc_assert (TREE_CODE (length) == PARM_DECL);\n \t  arglist = chainon (arglist, length);\n \t  typelist = TREE_CHAIN (typelist);\n \t  DECL_CONTEXT (length) = fndecl;\n@@ -1209,7 +1208,7 @@ create_function_arglist (gfc_symbol * sym)\n \n       parm = f->sym->backend_decl;\n       type = TREE_VALUE (typelist);\n-      assert (type == gfc_charlen_type_node);\n+      gcc_assert (type == gfc_charlen_type_node);\n \n       strcpy (&name[1], f->sym->name);\n       name[0] = '_';\n@@ -1252,7 +1251,7 @@ create_function_arglist (gfc_symbol * sym)\n       typelist = TREE_CHAIN (typelist);\n     }\n \n-  assert (TREE_VALUE (typelist) == void_type_node);\n+  gcc_assert (TREE_VALUE (typelist) == void_type_node);\n   DECL_ARGUMENTS (fndecl) = arglist;\n }\n \n@@ -1344,7 +1343,7 @@ build_entry_thunks (gfc_namespace * ns)\n   locus old_loc;\n \n   /* This should always be a toplevel function.  */\n-  assert (current_function_decl == NULL_TREE);\n+  gcc_assert (current_function_decl == NULL_TREE);\n \n   gfc_get_backend_locus (&old_loc);\n   for (el = ns->entries; el; el = el->next)\n@@ -1538,7 +1537,7 @@ gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n   int n;\n \n   /* Library functions must be declared with global scope.  */\n-  assert (current_function_decl == NULL_TREE);\n+  gcc_assert (current_function_decl == NULL_TREE);\n \n   va_start (p, nargs);\n \n@@ -1873,8 +1872,8 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n   tree decl;\n   tree tmp;\n \n-  assert (sym->backend_decl);\n-  assert (sym->ts.cl && sym->ts.cl->length);\n+  gcc_assert (sym->backend_decl);\n+  gcc_assert (sym->ts.cl && sym->ts.cl->length);\n \n   gfc_start_block (&body);\n \n@@ -1959,15 +1958,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n \t    case AS_ASSUMED_SIZE:\n \t      /* Must be a dummy parameter.  */\n-\t      assert (sym->attr.dummy);\n+\t      gcc_assert (sym->attr.dummy);\n \n \t      /* We should always pass assumed size arrays the g77 way.  */\n \t      fnbody = gfc_trans_g77_array (sym, fnbody);\n               break;\n \n \t    case AS_ASSUMED_SHAPE:\n \t      /* Must be a dummy parameter.  */\n-\t      assert (sym->attr.dummy);\n+\t      gcc_assert (sym->attr.dummy);\n \n \t      fnbody = gfc_trans_dummy_array_bias (sym, sym->backend_decl,\n \t\t\t\t\t\t   fnbody);\n@@ -1978,7 +1977,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       else if (sym->ts.type == BT_CHARACTER)\n@@ -1992,7 +1991,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t  gfc_set_backend_locus (&loc);\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   return fnbody;\n@@ -2059,7 +2058,7 @@ gfc_generate_module_vars (gfc_namespace * ns)\n   module_namespace = ns;\n \n   /* Check if the frontend left the namespace in a reasonable state.  */\n-  assert (ns->proc_name && !ns->proc_name->tlink);\n+  gcc_assert (ns->proc_name && !ns->proc_name->tlink);\n \n   /* Generate COMMON blocks.  */\n   gfc_trans_common (ns);\n@@ -2181,7 +2180,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   sym = ns->proc_name;\n \n   /* Check that the frontend isn't still using this.  */\n-  assert (sym->tlink == NULL);\n+  gcc_assert (sym->tlink == NULL);\n   sym->tlink = sym;\n \n   /* Create the declaration for functions with global scope.  */\n@@ -2322,8 +2321,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n void\n gfc_generate_constructors (void)\n {\n-  if (gfc_static_ctors != NULL_TREE)\n-    abort ();\n+  gcc_assert (gfc_static_ctors == NULL_TREE);\n #if 0\n   tree fnname;\n   tree type;"}, {"sha": "52d6969c4f6d3858e89915d61c4ba504efebb2e1", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 58, "deletions": 67, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -34,7 +34,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-gimple.h\"\n #include \"flags.h\"\n #include <gmp.h>\n-#include <assert.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n@@ -84,14 +83,14 @@ gfc_advance_se_ss_chain (gfc_se * se)\n {\n   gfc_se *p;\n \n-  assert (se != NULL && se->ss != NULL && se->ss != gfc_ss_terminator);\n+  gcc_assert (se != NULL && se->ss != NULL && se->ss != gfc_ss_terminator);\n \n   p = se;\n   /* Walk down the parent chain.  */\n   while (p != NULL)\n     {\n       /* Simple consistency check.  */\n-      assert (p->parent == NULL || p->parent->ss == p->ss);\n+      gcc_assert (p->parent == NULL || p->parent->ss == p->ss);\n \n       p->ss = p->ss->next;\n \n@@ -125,14 +124,14 @@ gfc_conv_expr_present (gfc_symbol * sym)\n {\n   tree decl;\n \n-  assert (sym->attr.dummy && sym->attr.optional);\n+  gcc_assert (sym->attr.dummy && sym->attr.optional);\n \n   decl = gfc_get_symbol_decl (sym);\n   if (TREE_CODE (decl) != PARM_DECL)\n     {\n       /* Array parameters use a temporary descriptor, we want the real\n          parameter.  */\n-      assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n              || GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n@@ -219,10 +218,10 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n   c = ref->u.c.component;\n \n-  assert (c->backend_decl);\n+  gcc_assert (c->backend_decl);\n \n   field = c->backend_decl;\n-  assert (TREE_CODE (field) == FIELD_DECL);\n+  gcc_assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n   tmp = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n \n@@ -232,7 +231,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n     {\n       tmp = c->ts.cl->backend_decl;\n       /* Components must always be constant length.  */\n-      assert (tmp && INTEGER_CST_P (tmp));\n+      gcc_assert (tmp && INTEGER_CST_P (tmp));\n       se->string_length = tmp;\n     }\n \n@@ -254,8 +253,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n   if (se->ss != NULL)\n     {\n       /* Check that something hasn't gone horribly wrong.  */\n-      assert (se->ss != gfc_ss_terminator);\n-      assert (se->ss->expr == expr);\n+      gcc_assert (se->ss != gfc_ss_terminator);\n+      gcc_assert (se->ss->expr == expr);\n \n       /* A scalarized term.  We already know the descriptor.  */\n       se->expr = se->ss->data.info.descriptor;\n@@ -270,10 +269,10 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       if (sym->attr.flavor == FL_PROCEDURE\n \t  && se->expr != current_function_decl)\n \t{\n-\t  assert (se->want_pointer);\n+\t  gcc_assert (se->want_pointer);\n \t  if (!sym->attr.dummy)\n \t    {\n-\t      assert (TREE_CODE (se->expr) == FUNCTION_DECL);\n+\t      gcc_assert (TREE_CODE (se->expr) == FUNCTION_DECL);\n \t      se->expr = gfc_build_addr_expr (NULL, se->expr);\n \t    }\n \t  return;\n@@ -309,7 +308,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       se->string_length = sym->ts.cl->backend_decl;\n-      assert (se->string_length);\n+      gcc_assert (se->string_length);\n     }\n \n   while (ref)\n@@ -340,7 +339,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t  break;\n \t}\n       ref = ref->next;\n@@ -367,7 +366,7 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n   gfc_se operand;\n   tree type;\n \n-  assert (expr->ts.type != BT_CHARACTER);\n+  gcc_assert (expr->ts.type != BT_CHARACTER);\n   /* Initialize the operand.  */\n   gfc_init_se (&operand, se);\n   gfc_conv_expr_val (&operand, expr->op1);\n@@ -597,7 +596,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       switch (kind)\n \t{\n@@ -606,7 +605,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  if (expr->op1->ts.type == BT_INTEGER)\n \t    lse.expr = convert (gfc_int4_type_node, lse.expr);\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  /* Fall through.  */\n \n \tcase 4:\n@@ -618,7 +617,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n       \n       switch (expr->op1->ts.type)\n@@ -636,7 +635,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n  \t}\n       break;\n \n@@ -650,7 +649,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  fndecl = built_in_decls[BUILT_IN_POW];\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -664,12 +663,12 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  fndecl = gfor_fndecl_math_cpow;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n       break;\n     }\n \n@@ -688,8 +687,7 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n   tree tmp;\n   tree args;\n \n-  if (TREE_TYPE (len) != gfc_charlen_type_node)\n-    abort ();\n+  gcc_assert (TREE_TYPE (len) == gfc_charlen_type_node);\n \n   if (gfc_can_put_var_on_stack (len))\n     {\n@@ -736,7 +734,7 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   tree args;\n   tree tmp;\n \n-  assert (expr->op1->ts.type == BT_CHARACTER\n+  gcc_assert (expr->op1->ts.type == BT_CHARACTER\n \t  && expr->op2->ts.type == BT_CHARACTER);\n \n   gfc_init_se (&lse, se);\n@@ -899,16 +897,15 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n     case INTRINSIC_USER:\n     case INTRINSIC_ASSIGN:\n       /* These should be converted into function calls by the frontend.  */\n-      abort ();\n-      return;\n+      gcc_unreachable ();\n \n     default:\n       fatal_error (\"Unknown intrinsic op\");\n       return;\n     }\n \n   /* The only exception to this is **, which is handled separately anyway.  */\n-  assert (expr->op1->ts.type == expr->op2->ts.type);\n+  gcc_assert (expr->op1->ts.type == expr->op2->ts.type);\n \n   if (checkstring && expr->op1->ts.type != BT_CHARACTER)\n     checkstring = 0;\n@@ -967,7 +964,7 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n   if (sym->attr.dummy)\n     {\n       tmp = gfc_get_symbol_decl (sym);\n-      assert (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n+      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (tmp))) == FUNCTION_TYPE);\n \n       se->expr = tmp;\n@@ -978,7 +975,7 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n \tsym->backend_decl = gfc_get_extern_function_decl (sym);\n \n       tmp = sym->backend_decl;\n-      assert (TREE_CODE (tmp) == FUNCTION_DECL);\n+      gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n       se->expr = gfc_build_addr_expr (NULL, tmp);\n     }\n }\n@@ -1013,12 +1010,12 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     {\n       if (!sym->attr.elemental)\n \t{\n-\t  assert (se->ss->type == GFC_SS_FUNCTION);\n+\t  gcc_assert (se->ss->type == GFC_SS_FUNCTION);\n           if (se->ss->useflags)\n             {\n-              assert (gfc_return_by_reference (sym)\n+              gcc_assert (gfc_return_by_reference (sym)\n                       && sym->result->attr.dimension);\n-              assert (se->loop != NULL);\n+              gcc_assert (se->loop != NULL);\n \n               /* Access the previously obtained result.  */\n               gfc_conv_tmp_array_ref (se);\n@@ -1038,7 +1035,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \targlist = gfc_chainon_list (arglist, se->expr);\n       else if (sym->result->attr.dimension)\n \t{\n-\t  assert (se->loop && se->ss);\n+\t  gcc_assert (se->loop && se->ss);\n \t  /* Set the type of the array.  */\n \t  tmp = gfc_typenode_for_spec (&sym->ts);\n \t  info->dimen = se->loop->dimen;\n@@ -1057,7 +1054,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n-\t  assert (sym->ts.cl && sym->ts.cl->length\n+\t  gcc_assert (sym->ts.cl && sym->ts.cl->length\n \t\t  && sym->ts.cl->length->expr_type == EXPR_CONSTANT);\n \t  len = gfc_conv_mpz_to_tree\n \t    (sym->ts.cl->length->value.integer, sym->ts.cl->length->ts.kind);\n@@ -1071,7 +1068,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t      convert (gfc_charlen_type_node, len));\n \t}\n       else      /* TODO: derived type function return values.  */\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   formal = sym->formal;\n@@ -1214,7 +1211,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      se->string_length = len;\n \t    }\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n }\n@@ -1273,7 +1270,7 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n     {\n       /* Each dummy shall be specified, explicitly or implicitly, to be\n          scalar.  */\n-      assert (fargs->sym->attr.dimension == 0);\n+      gcc_assert (fargs->sym->attr.dimension == 0);\n       fsym = fargs->sym;\n \n       /* Create a temporary to hold the value.  */\n@@ -1285,7 +1282,7 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n \t  /* Copy string arguments.  */\n           tree arglen;\n \n-          assert (fsym->ts.cl && fsym->ts.cl->length\n+          gcc_assert (fsym->ts.cl && fsym->ts.cl->length\n                   && fsym->ts.cl->length->expr_type == EXPR_CONSTANT);\n \n           arglen = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n@@ -1380,8 +1377,8 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n {\n-  assert (se->ss != NULL && se->ss != gfc_ss_terminator);\n-  assert (se->ss->expr == expr && se->ss->type == GFC_SS_CONSTRUCTOR);\n+  gcc_assert (se->ss != NULL && se->ss != gfc_ss_terminator);\n+  gcc_assert (se->ss->expr == expr && se->ss->type == GFC_SS_CONSTRUCTOR);\n \n   gfc_conv_tmp_array_ref (se);\n   gfc_advance_se_ss_chain (se);\n@@ -1513,8 +1510,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n   tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts.type);\n   gfc_add_expr_to_block (&body, tmp);\n \n-  if (rse.ss != gfc_ss_terminator)\n-    abort ();\n+  gcc_assert (rse.ss == gfc_ss_terminator);\n \n   /* Generate the copying loops.  */\n   gfc_trans_scalarizing_loops (&loop, &body);\n@@ -1648,8 +1644,8 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n   tree type;\n   tree tmp;\n \n-  assert (se->ss == NULL);\n-  assert (expr->expr_type == EXPR_STRUCTURE);\n+  gcc_assert (se->ss == NULL);\n+  gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   if (!init)\n@@ -1699,7 +1695,7 @@ gfc_conv_substring_expr (gfc_se * se, gfc_expr * expr)\n \n   ref = expr->ref;\n \n-  assert(ref->type == REF_SUBSTRING);\n+  gcc_assert (ref->type == REF_SUBSTRING);\n \n   se->expr = gfc_build_string_const(expr->value.character.length,\n                                     expr->value.character.string);\n@@ -1761,7 +1757,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n       break;\n     }\n }\n@@ -1772,15 +1768,15 @@ gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr)\n   gfc_conv_expr (se, expr);\n   /* AFAICS all numeric lvalues have empty post chains.  If not we need to\n      figure out a way of rewriting an lvalue so that it has no post chain.  */\n-  assert (expr->ts.type != BT_CHARACTER || !se->post.head);\n+  gcc_assert (expr->ts.type != BT_CHARACTER || !se->post.head);\n }\n \n void\n gfc_conv_expr_val (gfc_se * se, gfc_expr * expr)\n {\n   tree val;\n \n-  assert (expr->ts.type != BT_CHARACTER);\n+  gcc_assert (expr->ts.type != BT_CHARACTER);\n   gfc_conv_expr (se, expr);\n   if (se->post.head)\n     {\n@@ -1885,7 +1881,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       /* Scalar pointers.  */\n       lse.want_pointer = 1;\n       gfc_conv_expr (&lse, expr1);\n-      assert (rss == gfc_ss_terminator);\n+      gcc_assert (rss == gfc_ss_terminator);\n       gfc_init_se (&rse, NULL);\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n@@ -1936,12 +1932,12 @@ gfc_conv_string_parameter (gfc_se * se)\n   type = TREE_TYPE (se->expr);\n   if (TYPE_STRING_FLAG (type))\n     {\n-      assert (TREE_CODE (se->expr) != INDIRECT_REF);\n+      gcc_assert (TREE_CODE (se->expr) != INDIRECT_REF);\n       se->expr = gfc_build_addr_expr (pchar_type_node, se->expr);\n     }\n \n-  assert (POINTER_TYPE_P (TREE_TYPE (se->expr)));\n-  assert (se->string_length\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (se->expr)));\n+  gcc_assert (se->string_length\n \t  && TREE_CODE (TREE_TYPE (se->string_length)) == INTEGER_TYPE);\n }\n \n@@ -1958,7 +1954,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n \n   if (type == BT_CHARACTER)\n     {\n-      assert (lse->string_length != NULL_TREE\n+      gcc_assert (lse->string_length != NULL_TREE\n \t      && rse->string_length != NULL_TREE);\n \n       gfc_conv_string_parameter (lse);\n@@ -2010,12 +2006,12 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic\n      functions.  */\n-  assert (expr2->value.function.isym\n+  gcc_assert (expr2->value.function.isym\n \t  || (gfc_return_by_reference (expr2->symtree->n.sym)\n \t      && expr2->symtree->n.sym->result->attr.dimension));\n \n   ss = gfc_walk_expr (expr1);\n-  assert (ss != gfc_ss_terminator);\n+  gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n   se.want_pointer = 1;\n@@ -2024,7 +2020,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n   se.direct_byref = 1;\n   se.ss = gfc_walk_expr (expr2);\n-  assert (se.ss != gfc_ss_terminator);\n+  gcc_assert (se.ss != gfc_ss_terminator);\n   gfc_conv_function_expr (&se, expr2);\n   gfc_add_block_to_block (&se.pre, &se.post);\n \n@@ -2075,7 +2071,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t     && lss_section->type != GFC_SS_SECTION)\n \tlss_section = lss_section->next;\n \n-      assert (lss_section != gfc_ss_terminator);\n+      gcc_assert (lss_section != gfc_ss_terminator);\n \n       /* Initialize the scalarizer.  */\n       gfc_init_loopinfo (&loop);\n@@ -2146,10 +2142,8 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     }\n   else\n     {\n-      if (lse.ss != gfc_ss_terminator)\n-\tabort ();\n-      if (rse.ss != gfc_ss_terminator)\n-\tabort ();\n+      gcc_assert (lse.ss == gfc_ss_terminator\n+\t\t  && rse.ss == gfc_ss_terminator);\n \n       if (loop.temp_ss != NULL)\n \t{\n@@ -2168,11 +2162,8 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gfc_advance_se_ss_chain (&rse);\n \t  gfc_conv_expr (&lse, expr1);\n \n-\t  if (lse.ss != gfc_ss_terminator)\n-\t    abort ();\n-\n-\t  if (rse.ss != gfc_ss_terminator)\n-\t    abort ();\n+\t  gcc_assert (lse.ss == gfc_ss_terminator\n+\t\t      && rse.ss == gfc_ss_terminator);\n \n \t  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n \t  gfc_add_expr_to_block (&body, tmp);"}, {"sha": "e986b5c1a0a73e0900556a6506644fd5b264d48f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -33,7 +33,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"tree-gimple.h\"\n #include \"flags.h\"\n-#include <assert.h>\n #include \"gfortran.h\"\n #include \"arith.h\"\n #include \"intrinsic.h\"\n@@ -197,7 +196,7 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n \n   /* Evaluate the argument.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  assert (expr->value.function.actual->expr);\n+  gcc_assert (expr->value.function.actual->expr);\n   arg = gfc_conv_intrinsic_function_args (se, expr);\n   arg = TREE_VALUE (arg);\n \n@@ -354,7 +353,7 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, int op)\n     }\n \n   /* Evaluate the argument.  */\n-  assert (expr->value.function.actual->expr);\n+  gcc_assert (expr->value.function.actual->expr);\n   arg = gfc_conv_intrinsic_function_args (se, expr);\n \n   /* Use a builtin function if one exists.  */\n@@ -402,7 +401,7 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Evaluate the argument.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  assert (expr->value.function.actual->expr);\n+  gcc_assert (expr->value.function.actual->expr);\n   arg = gfc_conv_intrinsic_function_args (se, expr);\n   arg = TREE_VALUE (arg);\n \n@@ -499,13 +498,12 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \t  pdecl = &m->real8_decl;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else if (ts->type == BT_COMPLEX)\n     {\n-      if (!m->complex_available)\n-\tabort ();\n+      gcc_assert (m->complex_available);\n \n       switch (ts->kind)\n \t{\n@@ -516,19 +514,18 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \t  pdecl = &m->complex8_decl;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   if (*pdecl)\n     return *pdecl;\n \n   if (m->libm_name)\n     {\n-      if (ts->kind != 4 && ts->kind != 8)\n-\tabort ();\n+      gcc_assert (ts->kind == 4 || ts->kind == 8);\n       snprintf (name, sizeof (name), \"%s%s%s\", \n \t\tts->type == BT_COMPLEX ? \"c\" : \"\",\n \t\tm->name,\n@@ -615,7 +612,7 @@ gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n       fndecl = gfor_fndecl_math_exponent8;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   se->expr = gfc_build_function_call (fndecl, args);\n@@ -645,9 +642,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   if (se->ss)\n     {\n       /* Create an implicit second parameter from the loop variable.  */\n-      assert (!arg2->expr);\n-      assert (se->loop->dimen == 1);\n-      assert (se->ss->expr == expr);\n+      gcc_assert (!arg2->expr);\n+      gcc_assert (se->loop->dimen == 1);\n+      gcc_assert (se->ss->expr == expr);\n       gfc_advance_se_ss_chain (se);\n       bound = se->loop->loopvar[0];\n       bound = fold (build2 (MINUS_EXPR, gfc_array_index_type, bound,\n@@ -656,7 +653,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   else\n     {\n       /* use the passed argument.  */\n-      assert (arg->next->expr);\n+      gcc_assert (arg->next->expr);\n       gfc_init_se (&argse, NULL);\n       gfc_conv_expr_type (&argse, arg->next->expr, gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n@@ -669,7 +666,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n   /* Get a descriptor for the first parameter.  */\n   ss = gfc_walk_expr (arg->expr);\n-  assert (ss != gfc_ss_terminator);\n+  gcc_assert (ss != gfc_ss_terminator);\n   argse.want_pointer = 0;\n   gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n@@ -679,9 +676,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   if (INTEGER_CST_P (bound))\n     {\n-      assert (TREE_INT_CST_HIGH (bound) == 0);\n+      gcc_assert (TREE_INT_CST_HIGH (bound) == 0);\n       i = TREE_INT_CST_LOW (bound);\n-      assert (i >= 0 && i < GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)));\n+      gcc_assert (i >= 0 && i < GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)));\n     }\n   else\n     {\n@@ -716,7 +713,7 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n   int n;\n \n   args = gfc_conv_intrinsic_function_args (se, expr);\n-  assert (args && TREE_CHAIN (args) == NULL_TREE);\n+  gcc_assert (args && TREE_CHAIN (args) == NULL_TREE);\n   val = TREE_VALUE (args);\n \n   switch (expr->value.function.actual->expr->ts.type)\n@@ -736,13 +733,13 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n \t  n = BUILT_IN_CABS;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       se->expr = fold (gfc_build_function_call (built_in_decls[n], args));\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -833,7 +830,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (modulo)\n@@ -909,7 +906,7 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t  tmp = built_in_decls[BUILT_IN_COPYSIGN];\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       se->expr = fold (gfc_build_function_call (tmp, arg));\n       return;\n@@ -936,7 +933,7 @@ gfc_conv_intrinsic_present (gfc_se * se, gfc_expr * expr)\n   gfc_expr *arg;\n \n   arg = expr->value.function.actual->expr;\n-  assert (arg->expr_type == EXPR_VARIABLE);\n+  gcc_assert (arg->expr_type == EXPR_VARIABLE);\n   se->expr = gfc_conv_expr_present (arg->symtree->n.sym);\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n }\n@@ -976,7 +973,7 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   arg = TREE_VALUE (arg);\n \n   /* We currently don't support character types != 1.  */\n-  assert (expr->ts.kind == 1);\n+  gcc_assert (expr->ts.kind == 1);\n   type = gfc_character1_type_node;\n   var = gfc_create_var (type, \"char\");\n \n@@ -1058,7 +1055,7 @@ gfc_get_symbol_for_expr (gfc_expr * expr)\n   gfc_symbol *sym;\n \n   /* TODO: Add symbols for intrinsic function to the global namespace.  */\n-  assert (strlen (expr->value.function.name) <= GFC_MAX_SYMBOL_LEN - 5);\n+  gcc_assert (strlen (expr->value.function.name) <= GFC_MAX_SYMBOL_LEN - 5);\n   sym = gfc_new_symbol (expr->value.function.name, NULL);\n \n   sym->ts = expr->ts;\n@@ -1086,12 +1083,12 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n {\n   gfc_symbol *sym;\n \n-  assert (!se->ss || se->ss->expr == expr);\n+  gcc_assert (!se->ss || se->ss->expr == expr);\n \n   if (se->ss)\n-    assert (expr->rank > 0);\n+    gcc_assert (expr->rank > 0);\n   else\n-    assert (expr->rank == 0);\n+    gcc_assert (expr->rank == 0);\n \n   sym = gfc_get_symbol_for_expr (expr);\n   gfc_conv_function_call (se, sym, expr->value.function.actual);\n@@ -1150,7 +1147,7 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Walk the arguments.  */\n   arrayss = gfc_walk_expr (actual->expr);\n-  assert (arrayss != gfc_ss_terminator);\n+  gcc_assert (arrayss != gfc_ss_terminator);\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -1235,7 +1232,7 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n \n   /* Walk the arguments.  */\n   arrayss = gfc_walk_expr (actual->expr);\n-  assert (arrayss != gfc_ss_terminator);\n+  gcc_assert (arrayss != gfc_ss_terminator);\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -1310,15 +1307,15 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   actual = expr->value.function.actual;\n   arrayexpr = actual->expr;\n   arrayss = gfc_walk_expr (arrayexpr);\n-  assert (arrayss != gfc_ss_terminator);\n+  gcc_assert (arrayss != gfc_ss_terminator);\n \n   actual = actual->next->next;\n-  assert (actual);\n+  gcc_assert (actual);\n   maskexpr = actual->expr;\n   if (maskexpr)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n-      assert (maskss != gfc_ss_terminator);\n+      gcc_assert (maskss != gfc_ss_terminator);\n     }\n   else\n     maskss = NULL;\n@@ -1419,15 +1416,15 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   actual = expr->value.function.actual;\n   arrayexpr = actual->expr;\n   arrayss = gfc_walk_expr (arrayexpr);\n-  assert (arrayss != gfc_ss_terminator);\n+  gcc_assert (arrayss != gfc_ss_terminator);\n \n   actual = actual->next->next;\n-  assert (actual);\n+  gcc_assert (actual);\n   maskexpr = actual->expr;\n   if (maskexpr)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n-      assert (maskss != gfc_ss_terminator);\n+      gcc_assert (maskss != gfc_ss_terminator);\n     }\n   else\n     maskss = NULL;\n@@ -1446,7 +1443,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Most negative(+HUGE) for maxval, most negative (-HUGE) for minval.  */\n@@ -1464,7 +1461,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_ss_startstride (&loop);\n   gfc_conv_loop_setup (&loop);\n \n-  assert (loop.dimen == 1);\n+  gcc_assert (loop.dimen == 1);\n \n   /* Initialize the position to the first element.  If the array has zero\n      size we need to return zero.  Otherwise use the first element of the\n@@ -1586,7 +1583,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Most negative(-HUGE) for maxval, most positive (-HUGE) for minval.  */\n@@ -1598,15 +1595,15 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   actual = expr->value.function.actual;\n   arrayexpr = actual->expr;\n   arrayss = gfc_walk_expr (arrayexpr);\n-  assert (arrayss != gfc_ss_terminator);\n+  gcc_assert (arrayss != gfc_ss_terminator);\n \n   actual = actual->next->next;\n-  assert (actual);\n+  gcc_assert (actual);\n   maskexpr = actual->expr;\n   if (maskexpr)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n-      assert (maskss != gfc_ss_terminator);\n+      gcc_assert (maskss != gfc_ss_terminator);\n     }\n   else\n     maskss = NULL;\n@@ -1847,7 +1844,7 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \t  tmp = gfor_fndecl_math_ishftc8;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       se->expr = gfc_build_function_call (tmp, arg);\n       return;\n@@ -1884,7 +1881,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n   gfc_se argse;\n   gfc_expr *arg;\n \n-  assert (!se->ss);\n+  gcc_assert (!se->ss);\n \n   arg = expr->value.function.actual->expr;\n \n@@ -1910,7 +1907,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n \t      decl = gfc_get_fake_result_decl (sym);\n \n \t    len = sym->ts.cl->backend_decl;\n-\t    assert (len);\n+\t    gcc_assert (len);\n \t  }\n \telse\n \t  {\n@@ -1979,7 +1976,7 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n   arg = TREE_VALUE (TREE_CHAIN (arg));\n-  assert (POINTER_TYPE_P (TREE_TYPE (arg)));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (arg)));\n   arg = build1 (NOP_EXPR, pchar_type_node, arg);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n@@ -2041,7 +2038,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   actual = expr->value.function.actual;\n \n   ss = gfc_walk_expr (actual->expr);\n-  assert (ss != gfc_ss_terminator);\n+  gcc_assert (ss != gfc_ss_terminator);\n   argse.want_pointer = 1;\n   gfc_conv_expr_descriptor (&argse, actual->expr, ss);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n@@ -2119,7 +2116,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   tree ptr;\n   gfc_ss *ss;\n \n-  assert (!se->ss);\n+  gcc_assert (!se->ss);\n \n   /* Get a pointer to the source.  */\n   arg = expr->value.function.actual;\n@@ -2228,7 +2225,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       if (ss1 == gfc_ss_terminator)\n         {\n           /* A pointer to a scalar.  */\n-          assert (ss2 == gfc_ss_terminator);\n+          gcc_assert (ss2 == gfc_ss_terminator);\n           arg1se.want_pointer = 1;\n           gfc_conv_expr (&arg1se, arg1->expr);\n           arg2se.want_pointer = 1;\n@@ -2239,7 +2236,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       else\n         {\n           /* A pointer to an array, call library function _gfor_associated.  */\n-          assert (ss2 != gfc_ss_terminator);\n+          gcc_assert (ss2 != gfc_ss_terminator);\n           args = NULL_TREE;\n           arg1se.want_pointer = 1;\n           gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n@@ -2339,7 +2336,7 @@ void prepare_arg_info (gfc_se * se, gfc_expr * expr,\n    if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n      gfc_todo_error (\"Non-IEEE floating format\");\n     \n-   assert (expr->expr_type == EXPR_FUNCTION);\n+   gcc_assert (expr->expr_type == EXPR_FUNCTION);\n \n    arg = gfc_conv_intrinsic_function_args (se, expr);\n    arg = TREE_VALUE (arg);\n@@ -2404,7 +2401,7 @@ call_builtin_clz (tree result_type, tree op0)\n   else if (op0_mode == TYPE_MODE (long_long_integer_type_node))\n     fn = built_in_decls[BUILT_IN_CLZLL];\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   parms = tree_cons (NULL, op0, NULL);\n   call = gfc_build_function_call (fn, parms);\n@@ -2671,7 +2668,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n   switch (expr->value.function.isym->generic_id)\n     {\n     case GFC_ISYM_NONE:\n-      abort ();\n+      gcc_unreachable ();\n \n     case GFC_ISYM_REPEAT:\n       gfc_conv_intrinsic_repeat (se, expr);\n@@ -2981,8 +2978,7 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n       break;\n \n     default:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3015,7 +3011,7 @@ gfc_walk_intrinsic_libfunc (gfc_ss * ss, gfc_expr * expr)\n {\n   gfc_ss *newss;\n \n-  assert (expr->rank > 0);\n+  gcc_assert (expr->rank > 0);\n \n   newss = gfc_get_ss ();\n   newss->type = GFC_SS_FUNCTION;\n@@ -3034,8 +3030,8 @@ gfc_walk_intrinsic_libfunc (gfc_ss * ss, gfc_expr * expr)\n int\n gfc_is_intrinsic_libcall (gfc_expr * expr)\n {\n-  assert (expr->expr_type == EXPR_FUNCTION && expr->value.function.isym);\n-  assert (expr->rank > 0);\n+  gcc_assert (expr->expr_type == EXPR_FUNCTION && expr->value.function.isym);\n+  gcc_assert (expr->rank > 0);\n \n   switch (expr->value.function.isym->generic_id)\n     {\n@@ -3073,7 +3069,7 @@ gfc_ss *\n gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n \t\t\t     gfc_intrinsic_sym * isym)\n {\n-  assert (isym);\n+  gcc_assert (isym);\n \n   if (isym->elemental)\n     return gfc_walk_elemental_function_args (ss, expr, GFC_SS_SCALAR);"}, {"sha": "66d25b22db3e40977a0376c18e8fe92a14625480", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -29,7 +29,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n-#include <assert.h>\n #include <gmp.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n@@ -867,7 +866,7 @@ transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_exp\n   tree tmp, args, arg2;\n   tree expr;\n \n-  assert (POINTER_TYPE_P (TREE_TYPE (addr_expr)));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (addr_expr)));\n \n   if (ts->type == BT_DERIVED)\n     {\n@@ -877,7 +876,7 @@ transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_exp\n       for (c = ts->derived->components; c; c = c->next)\n         {\n           tree field = c->backend_decl;\n-          assert (field && TREE_CODE (field) == FIELD_DECL);\n+          gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n           tmp = build3 (COMPONENT_REF, TREE_TYPE (field), \n \t\t\texpr, field, NULL_TREE);\n \n@@ -913,7 +912,7 @@ transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_exp\n \n     case BT_CHARACTER:\n       expr = gfc_build_indirect_ref (addr_expr);\n-      assert (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE);\n+      gcc_assert (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE);\n       args = gfc_chainon_list (args,\n                                TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (expr))));\n       tmp = gfc_build_function_call (iocall_set_nml_val_char, args);\n@@ -958,7 +957,7 @@ build_dt (tree * function, gfc_code * code)\n   set_error_locus (&block, &code->loc);\n   dt = code->ext.dt;\n \n-  assert (dt != NULL);\n+  gcc_assert (dt != NULL);\n \n   if (dt->io_unit)\n     {\n@@ -1061,8 +1060,8 @@ gfc_trans_iolength (gfc_code * code)\n   inq = code->ext.inquire;\n \n   /* First check that preconditions are met.  */\n-  assert(inq != NULL);\n-  assert(inq->iolength != NULL);\n+  gcc_assert (inq != NULL);\n+  gcc_assert (inq->iolength != NULL);\n \n   /* Connect to the iolength variable.  */\n   if (inq->iolength)\n@@ -1125,15 +1124,15 @@ gfc_trans_dt_end (gfc_code * code)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   tmp = gfc_build_function_call (function, NULL);\n   gfc_add_expr_to_block (&block, tmp);\n \n   if (last_dt != IOLENGTH)\n     {\n-      assert(code->ext.dt != NULL);\n+      gcc_assert (code->ext.dt != NULL);\n       io_result (&block, code->ext.dt->err,\n \t\t code->ext.dt->end, code->ext.dt->eor);\n     }\n@@ -1189,14 +1188,14 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n       for (c = ts->derived->components; c; c = c->next)\n \t{\n \t  field = c->backend_decl;\n-\t  assert (field && TREE_CODE (field) == FIELD_DECL);\n+\t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n \n \t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), expr, field,\n \t\t\tNULL_TREE);\n \n \t  if (c->ts.type == BT_CHARACTER)\n \t    {\n-\t      assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n+\t      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n \t      se->string_length =\n \t\tTYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n \t    }\n@@ -1272,7 +1271,7 @@ gfc_trans_transfer (gfc_code * code)\n     tmp = gfc_finish_block (&body);\n   else\n     {\n-      assert (se.ss == gfc_ss_terminator);\n+      gcc_assert (se.ss == gfc_ss_terminator);\n       gfc_trans_scalarizing_loops (&loop, &body);\n \n       gfc_add_block_to_block (&loop.pre, &loop.post);"}, {"sha": "7c63c9985e744a2d9fc9f4d6346bf2e852eedc9d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -30,7 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n-#include <assert.h>\n #include <gmp.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n@@ -199,7 +198,7 @@ gfc_trans_call (gfc_code * code)\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n \n-  assert (code->resolved_sym);\n+  gcc_assert (code->resolved_sym);\n   has_alternate_specifier = 0;\n \n   /* Translate the call.  */\n@@ -214,7 +213,7 @@ gfc_trans_call (gfc_code * code)\n       gfc_code *select_code;\n       gfc_symbol *sym;\n       select_code = code->next;\n-      assert(select_code->op == EXEC_SELECT);\n+      gcc_assert(select_code->op == EXEC_SELECT);\n       sym = select_code->expr->symtree->n.sym;\n       se.expr = convert (gfc_typenode_for_spec (&sym->ts), se.expr);\n       gfc_add_modify_expr (&se.pre, sym->backend_decl, se.expr);\n@@ -1169,7 +1168,7 @@ gfc_trans_character_select (gfc_code *code)\n tree\n gfc_trans_select (gfc_code * code)\n {\n-  assert (code && code->expr);\n+  gcc_assert (code && code->expr);\n \n   /* Empty SELECT constructs are legal.  */\n   if (code->block == NULL)\n@@ -1367,7 +1366,7 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n   type = build_array_type (elem_type, type);\n   if (gfc_can_put_var_on_stack (bytesize))\n     {\n-      assert (INTEGER_CST_P (size));\n+      gcc_assert (INTEGER_CST_P (size));\n       tmpvar = gfc_create_var (type, \"temp\");\n       *pdata = NULL_TREE;\n     }\n@@ -1382,7 +1381,7 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n       else if (gfc_index_integer_kind == 8)\n \ttmp = gfor_fndecl_internal_malloc64;\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       tmp = gfc_build_function_call (tmp, args);\n       tmp = convert (TREE_TYPE (tmpvar), tmp);\n       gfc_add_modify_expr (pblock, tmpvar, tmp);\n@@ -2389,8 +2388,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n           break;\n \n \tdefault:\n-\t  abort ();\n-\t  break;\n+\t  gcc_unreachable ();\n \t}\n \n       c = c->next;\n@@ -2614,7 +2612,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n \n   /* In each where-assign-stmt, the mask-expr and the variable being\n      defined shall be arrays of the same shape.  */\n-  assert (lss != gfc_ss_terminator);\n+  gcc_assert (lss != gfc_ss_terminator);\n \n   /* The assignment needs scalarization.  */\n   lss_section = lss;\n@@ -2624,7 +2622,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n          && lss_section->type != GFC_SS_SECTION)\n     lss_section = lss_section->next;\n \n-  assert (lss_section != gfc_ss_terminator);\n+  gcc_assert (lss_section != gfc_ss_terminator);\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -2717,10 +2715,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n     }\n   else\n     {\n-      if (lse.ss != gfc_ss_terminator)\n-        abort ();\n-      if (rse.ss != gfc_ss_terminator)\n-        abort ();\n+      gcc_assert (lse.ss == gfc_ss_terminator\n+\t\t  && rse.ss == gfc_ss_terminator);\n \n       if (loop.temp_ss != NULL)\n         {\n@@ -2744,11 +2740,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n           gfc_advance_se_ss_chain (&rse);\n           gfc_conv_expr (&lse, expr1);\n \n-          if (lse.ss != gfc_ss_terminator)\n-            abort ();\n-\n-          if (rse.ss != gfc_ss_terminator)\n-            abort ();\n+          gcc_assert (lse.ss == gfc_ss_terminator\n+\t\t      && rse.ss == gfc_ss_terminator);\n \n           /* Form the mask expression according to the mask tree list.  */\n           index = count2;\n@@ -2923,7 +2916,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n               break;\n \n             default:\n-              abort ();\n+              gcc_unreachable ();\n             }\n \n          /* The next statement within the same where-body-construct.  */\n@@ -3051,7 +3044,7 @@ gfc_trans_allocate (gfc_code * code)\n       /* Find the last reference in the chain.  */\n       while (ref && ref->next != NULL)\n \t{\n-\t  assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT);\n+\t  gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT);\n \t  ref = ref->next;\n \t}\n \n@@ -3122,7 +3115,7 @@ gfc_trans_deallocate (gfc_code * code)\n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n       expr = al->expr;\n-      assert (expr->expr_type == EXPR_VARIABLE);\n+      gcc_assert (expr->expr_type == EXPR_VARIABLE);\n \n       gfc_init_se (&se, NULL);\n       gfc_start_block (&se.pre);"}, {"sha": "a33e717ceb98886c47d309cb211cdd3cfc0f6304", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -35,7 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n #include \"real.h\"\n-#include <assert.h>\n \f\n \n #if (GFC_MAX_DIMENSIONS < 10)\n@@ -114,8 +113,7 @@ gfc_init_kinds (void)\n       if (bitsize > 2*HOST_BITS_PER_WIDE_INT)\n \tcontinue;\n \n-      if (i_index == MAX_INT_KINDS)\n-\tabort ();\n+      gcc_assert (i_index != MAX_INT_KINDS);\n \n       /* Let the kind equal the bit size divided by 8.  This insulates the\n \t programmer from the underlying byte size.  */\n@@ -170,11 +168,9 @@ gfc_init_kinds (void)\n \tsaw_r16 = true;\n \n       /* Careful we don't stumble a wierd internal mode.  */\n-      if (r_index > 0 && gfc_real_kinds[r_index-1].kind == kind)\n-\tabort ();\n+      gcc_assert (r_index <= 0 || gfc_real_kinds[r_index-1].kind != kind);\n       /* Or have too many modes for the allocated space.  */\n-      if (r_index == MAX_REAL_KINDS)\n-\tabort ();\n+      gcc_assert (r_index != MAX_REAL_KINDS);\n \n       gfc_real_kinds[r_index].kind = kind;\n       gfc_real_kinds[r_index].radix = fmt->b;\n@@ -442,7 +438,7 @@ c_size_t_size (void)\n     return LONG_TYPE_SIZE;\n   if (strcmp (SIZE_TYPE, \"short unsigned int\") == 0)\n     return SHORT_TYPE_SIZE;\n-  abort ();\n+  gcc_unreachable ();\n #else\n   return LONG_TYPE_SIZE;\n #endif\n@@ -614,8 +610,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n   switch (spec->type)\n     {\n     case BT_UNKNOWN:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n \n     case BT_INTEGER:\n       basetype = gfc_get_int_type (spec->kind);\n@@ -642,8 +637,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       break;\n \n     default:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n   return basetype;\n }\n@@ -670,18 +664,18 @@ gfc_get_element_type (tree type)\n     {\n       if (TREE_CODE (type) == POINTER_TYPE)\n         type = TREE_TYPE (type);\n-      assert (TREE_CODE (type) == ARRAY_TYPE);\n+      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n       element = TREE_TYPE (type);\n     }\n   else\n     {\n-      assert (GFC_DESCRIPTOR_TYPE_P (type));\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n       element = TREE_TYPE (TYPE_FIELDS (type));\n \n-      assert (TREE_CODE (element) == POINTER_TYPE);\n+      gcc_assert (TREE_CODE (element) == POINTER_TYPE);\n       element = TREE_TYPE (element);\n \n-      assert (TREE_CODE (element) == ARRAY_TYPE);\n+      gcc_assert (TREE_CODE (element) == ARRAY_TYPE);\n       element = TREE_TYPE (element);\n     }\n \n@@ -763,7 +757,7 @@ gfc_get_element_type (tree type)\n int\n gfc_is_nodesc_array (gfc_symbol * sym)\n {\n-  assert (sym->attr.dimension);\n+  gcc_assert (sym->attr.dimension);\n \n   /* We only want local arrays.  */\n   if (sym->attr.pointer || sym->attr.allocatable)\n@@ -783,7 +777,7 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n   if (sym->attr.pointer || sym->attr.allocatable)\n     return 0;\n \n-  assert (sym->as->type == AS_EXPLICIT);\n+  gcc_assert (sym->as->type == AS_EXPLICIT);\n \n   return 1;\n }\n@@ -900,7 +894,7 @@ gfc_get_dtype (tree type, int rank)\n       return gfc_index_zero_node;\n     }\n \n-  assert (rank <= GFC_DTYPE_RANK_MASK);\n+  gcc_assert (rank <= GFC_DTYPE_RANK_MASK);\n   size = TYPE_SIZE_UNIT (type);\n \n   i = rank | (n << GFC_DTYPE_TYPE_SHIFT);\n@@ -1155,7 +1149,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \t  stride =\n \t    fold (build2 (MULT_EXPR, gfc_array_index_type, tmp, stride));\n \t  /* Check the folding worked.  */\n-\t  assert (INTEGER_CST_P (stride));\n+\t  gcc_assert (INTEGER_CST_P (stride));\n \t}\n       else\n \tstride = NULL_TREE;\n@@ -1347,7 +1341,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n   tree typenode, field, field_type, fieldlist;\n   gfc_component *c;\n \n-  assert (derived && derived->attr.flavor == FL_DERIVED);\n+  gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n@@ -1392,7 +1386,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t    {\n \t      /* Evaluate the string length.  */\n \t      gfc_conv_const_charlen (c->ts.cl);\n-\t      assert (c->ts.cl->backend_decl);\n+\t      gcc_assert (c->ts.cl->backend_decl);\n \t    }\n \n \t  field_type = gfc_typenode_for_spec (&c->ts);\n@@ -1420,7 +1414,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n       DECL_PACKED (field) |= TYPE_PACKED (typenode);\n \n-      assert (!c->backend_decl);\n+      gcc_assert (!c->backend_decl);\n       c->backend_decl = field;\n     }\n \n@@ -1441,7 +1435,7 @@ gfc_return_by_reference (gfc_symbol * sym)\n   if (!sym->attr.function)\n     return 0;\n \n-  assert (sym->attr.function);\n+  gcc_assert (sym->attr.function);\n \n   if (sym->result)\n     sym = sym->result;\n@@ -1467,7 +1461,7 @@ gfc_get_function_type (gfc_symbol * sym)\n   int alternate_return;\n \n   /* Make sure this symbol is a function or a subroutine.  */\n-  assert (sym->attr.flavor == FL_PROCEDURE);\n+  gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n \n   if (sym->backend_decl)\n     return TREE_TYPE (sym->backend_decl);"}, {"sha": "7526c02f2ae8c0247239bca8607f82b2f381dffb", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e45f57bf38ac4ca36f085a27729ebc25856333e/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=6e45f57bf38ac4ca36f085a27729ebc25856333e", "patch": "@@ -30,7 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"defaults.h\"\n #include \"real.h\"\n #include <gmp.h>\n-#include <assert.h>\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-stmt.h\"\n@@ -56,7 +55,7 @@ gfc_advance_chain (tree t, int n)\n {\n   for (; n > 0; n--)\n     {\n-      assert (t != NULL_TREE);\n+      gcc_assert (t != NULL_TREE);\n       t = TREE_CHAIN (t);\n     }\n   return t;\n@@ -151,9 +150,8 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n      for scalar assignments.  We should probably have something\n      similar for aggregates, but right now removing that check just\n      breaks everything.  */\n-  if (TREE_TYPE (rhs) != TREE_TYPE (lhs)\n-      && !AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n-    abort ();\n+  gcc_assert (TREE_TYPE (rhs) == TREE_TYPE (lhs)\n+\t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n   tmp = fold (build2_v (MODIFY_EXPR, lhs, rhs));\n@@ -197,7 +195,7 @@ gfc_merge_block_scope (stmtblock_t * block)\n   tree decl;\n   tree next;\n \n-  assert (block->has_scope);\n+  gcc_assert (block->has_scope);\n   block->has_scope = 0;\n \n   /* Remember the decls in this scope.  */\n@@ -292,8 +290,7 @@ tree\n gfc_build_indirect_ref (tree t)\n {\n   tree type = TREE_TYPE (t);\n-  if (!POINTER_TYPE_P (type))\n-    abort ();\n+  gcc_assert (POINTER_TYPE_P (type));\n   type = TREE_TYPE (type);\n \n   if (TREE_CODE (t) == ADDR_EXPR)\n@@ -309,8 +306,7 @@ tree\n gfc_build_array_ref (tree base, tree offset)\n {\n   tree type = TREE_TYPE (base);\n-  if (TREE_CODE (type) != ARRAY_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n   type = TREE_TYPE (type);\n \n   if (DECL_P (base))\n@@ -356,7 +352,7 @@ gfc_trans_runtime_check (tree cond, tree msg, stmtblock_t * pblock)\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n \n-  assert (TREE_CODE (msg) == STRING_CST);\n+  gcc_assert (TREE_CODE (msg) == STRING_CST);\n \n   TREE_USED (msg) = 1;\n \n@@ -396,7 +392,7 @@ gfc_trans_runtime_check (tree cond, tree msg, stmtblock_t * pblock)\n void\n gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n {\n-  assert (block);\n+  gcc_assert (block);\n \n   if (expr == NULL_TREE || IS_EMPTY_STMT (expr))\n     return;\n@@ -427,8 +423,8 @@ gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n void\n gfc_add_block_to_block (stmtblock_t * block, stmtblock_t * append)\n {\n-  assert (append);\n-  assert (!append->has_scope);\n+  gcc_assert (append);\n+  gcc_assert (!append->has_scope);\n \n   gfc_add_expr_to_block (block, append->head);\n   append->head = NULL_TREE;"}]}