{"sha": "a670a9bb5477d63b47091347da53551d639bb8ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY3MGE5YmI1NDc3ZDYzYjQ3MDkxMzQ3ZGE1MzU1MWQ2MzliYjhlZQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2014-04-27T23:48:47Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2014-04-27T23:48:47Z"}, "message": "regex_automaton.h (_NFA<>::_M_insert_repeat): Add _S_opcode_repeat support to distingush a loop from _S_opcode_alternative.\n\n2014-04-27  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_automaton.h (_NFA<>::_M_insert_repeat):\n\tAdd _S_opcode_repeat support to distingush a loop from\n\t_S_opcode_alternative.\n\t* include/bits/regex_automaton.tcc (_State_base::_M_print,\n\t_State_base::_M_dot, _NFA<>::_M_eliminate_dummy,\n\t_StateSeq<>::_M_clone): Likewise.\n\t* include/bits/regex_compiler.tcc (_Compiler<>::_M_quantifier):\n\tLikewise.\n\t* include/bits/regex_executor.tcc (_Executor<>::_M_dfs): Likewise.\n\t* include/bits/regex_scanner.tcc (_Scanner<>::_M_eat_escape_ecma):\n\tUglify local variable __i.\n\t* include/bits/regex_compiler.h (_BracketMatcher<>::_M_make_cache):\n\tUse size_t instead of int to compare with vector::size().\n\n2014-04-27  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex_executor.h: Add _M_rep_count to track how\n\tmany times this repeat node are visited.\n\t* include/bits/regex_executor.tcc (_Executor<>::_M_rep_once_more,\n\t_Executor<>::_M_dfs): Use _M_rep_count to prevent entering\n\tinfinite loop.\n\n2014-04-27  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.tcc (__regex_algo_impl<>): Remove\n\t_GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT and use\n\t_GLIBCXX_REGEX_USE_THOMPSON_NFA instead.\n\t* include/bits/regex_automaton.h: Remove quantifier counting variable.\n\t* include/bits/regex_automaton.tcc (_State_base::_M_dot):\n\tAdjust debug NFA dump.\n\nFrom-SVN: r209844", "tree": {"sha": "8a3a023c2a1551b5c04a205a24a524fc3a5d6b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a3a023c2a1551b5c04a205a24a524fc3a5d6b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a670a9bb5477d63b47091347da53551d639bb8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a670a9bb5477d63b47091347da53551d639bb8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a670a9bb5477d63b47091347da53551d639bb8ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a670a9bb5477d63b47091347da53551d639bb8ee/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c"}], "stats": {"total": 276, "additions": 175, "deletions": 101}, "files": [{"sha": "6cc371c5d9d1e88280a73ec9c6b7994c454d45e6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -1,3 +1,36 @@\n+2014-04-27  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_automaton.h (_NFA<>::_M_insert_repeat):\n+\tAdd _S_opcode_repeat support to distingush a loop from\n+\t_S_opcode_alternative.\n+\t* include/bits/regex_automaton.tcc (_State_base::_M_print,\n+\t_State_base::_M_dot, _NFA<>::_M_eliminate_dummy,\n+\t_StateSeq<>::_M_clone): Likewise.\n+\t* include/bits/regex_compiler.tcc (_Compiler<>::_M_quantifier):\n+\tLikewise.\n+\t* include/bits/regex_executor.tcc (_Executor<>::_M_dfs): Likewise.\n+\t* include/bits/regex_scanner.tcc (_Scanner<>::_M_eat_escape_ecma):\n+\tUglify local variable __i.\n+\t* include/bits/regex_compiler.h (_BracketMatcher<>::_M_make_cache):\n+\tUse size_t instead of int to compare with vector::size().\n+\n+2014-04-27  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex_executor.h: Add _M_rep_count to track how\n+\tmany times this repeat node are visited.\n+\t* include/bits/regex_executor.tcc (_Executor<>::_M_rep_once_more,\n+\t_Executor<>::_M_dfs): Use _M_rep_count to prevent entering\n+\tinfinite loop.\n+\n+2014-04-27  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.tcc (__regex_algo_impl<>): Remove\n+\t_GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT and use\n+\t_GLIBCXX_REGEX_USE_THOMPSON_NFA instead.\n+\t* include/bits/regex_automaton.h: Remove quantifier counting variable.\n+\t* include/bits/regex_automaton.tcc (_State_base::_M_dot):\n+\tAdjust debug NFA dump.\n+\n 2014-04-25  Lars Gullik Bj\u00f8nnes  <larsbj@gullik.org>\n \n \tPR libstdc++/60710"}, {"sha": "0d737a0b74b3b2ad5ca989c799d9bc04b31fe7e6", "filename": "libstdc++-v3/include/bits/regex.tcc", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -28,12 +28,12 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// See below __regex_algo_impl to get what this is talking about. The default\n-// value 1 indicated a conservative optimization without giving up worst case\n-// performance.\n-#ifndef _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT\n-#define _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT 1\n-#endif\n+// A non-standard switch to let the user pick the matching algorithm.\n+// If _GLIBCXX_REGEX_USE_THOMPSON_NFA is defined, the thompson NFA\n+// algorithm will be used. This algorithm is not enabled by default,\n+// and cannot be used if the regex contains back-references, but has better\n+// (polynomial instead of exponential) worst case performace.\n+// See __regex_algo_impl below.\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -66,24 +66,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       for (auto& __it : __res)\n \t__it.matched = false;\n \n-      // This function decide which executor to use under given circumstances.\n-      // The _S_auto policy now is the following: if a NFA has no\n-      // back-references and has more than _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT\n-      // quantifiers (*, +, ?), the BFS executor will be used, other wise\n-      // DFS executor. This is because DFS executor has a exponential upper\n-      // bound, but better best-case performace. Meanwhile, BFS executor can\n-      // effectively prevent from exponential-long time matching (which must\n-      // contains many quantifiers), but it's slower in average.\n-      //\n-      // For simple regex, BFS executor could be 2 or more times slower than\n-      // DFS executor.\n-      //\n-      // Of course, BFS executor cannot handle back-references.\n+      // __policy is used by testsuites so that they can use Thompson NFA\n+      // without defining a macro. Users should define\n+      // _GLIBCXX_REGEX_USE_THOMPSON_NFA if they need to use this approach.\n       bool __ret;\n       if (!__re._M_automaton->_M_has_backref\n-\t  && (__policy == _RegexExecutorPolicy::_S_alternate\n-\t      || __re._M_automaton->_M_quant_count\n-\t\t> _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT))\n+#ifndef _GLIBCXX_REGEX_USE_THOMPSON_NFA\n+\t  && __policy == _RegexExecutorPolicy::_S_alternate\n+#endif\n+\t  )\n \t{\n \t  _Executor<_BiIter, _Alloc, _TraitsT, false>\n \t    __executor(__s, __e, __m, __re, __flags);"}, {"sha": "1b0da1453e955f2d7d296888c120b2b61c25f102", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -52,6 +52,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n       _S_opcode_unknown,\n       _S_opcode_alternative,\n+      _S_opcode_repeat,\n       _S_opcode_backref,\n       _S_opcode_line_begin_assertion,\n       _S_opcode_line_end_assertion,\n@@ -74,9 +75,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       size_t _M_backref_index;  // for _S_opcode_backref\n       struct\n       {\n-\t// for _S_opcode_alternative.\n-\t_StateIdT  _M_quant_index;\n-\t// for _S_opcode_alternative or _S_opcode_subexpr_lookahead\n+\t// for _S_opcode_alternative, _S_opcode_repeat and\n+\t// _S_opcode_subexpr_lookahead\n \t_StateIdT  _M_alt;\n \t// for _S_opcode_word_boundary or _S_opcode_subexpr_lookahead or\n \t// quantifiers (ungreedy if set true)\n@@ -120,7 +120,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     explicit\n     _NFA_base(_FlagT __f)\n     : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n-    _M_quant_count(0), _M_has_backref(false)\n+    _M_has_backref(false)\n     { }\n \n     _NFA_base(_NFA_base&&) = default;\n@@ -145,7 +145,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _FlagT                    _M_flags;\n     _StateIdT                 _M_start_state;\n     _SizeT                    _M_subexpr_count;\n-    _SizeT                    _M_quant_count;\n     bool                      _M_has_backref;\n   };\n \n@@ -175,7 +174,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_StateT __tmp(_S_opcode_alternative);\n \t// It labels every quantifier to make greedy comparison easier in BFS\n \t// approach.\n-\t__tmp._M_quant_index = this->_M_quant_count++;\n+\t__tmp._M_next = __next;\n+\t__tmp._M_alt = __alt;\n+\treturn _M_insert_state(std::move(__tmp));\n+      }\n+\n+      _StateIdT\n+      _M_insert_repeat(_StateIdT __next, _StateIdT __alt, bool __neg)\n+      {\n+\t_StateT __tmp(_S_opcode_repeat);\n+\t// It labels every quantifier to make greedy comparison easier in BFS\n+\t// approach.\n \t__tmp._M_next = __next;\n \t__tmp._M_alt = __alt;\n \t__tmp._M_neg = __neg;"}, {"sha": "e0ac3f94ceb77ca8f4febc8eef4a6654703f2479", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -41,6 +41,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     switch (_M_opcode)\n     {\n       case _S_opcode_alternative:\n+      case _S_opcode_repeat:\n \tostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n \tbreak;\n       case _S_opcode_subexpr_begin:\n@@ -72,11 +73,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     switch (_M_opcode)\n     {\n       case _S_opcode_alternative:\n+      case _S_opcode_repeat:\n \t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n \t       << __id << \" -> \" << _M_next\n-\t       << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+\t       << \" [label=\\\"next\\\", tailport=\\\"s\\\"];\\n\"\n \t       << __id << \" -> \" << _M_alt\n-\t       << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n+\t       << \" [label=\\\"alt\\\", tailport=\\\"n\\\"];\\n\";\n \tbreak;\n       case _S_opcode_backref:\n \t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n@@ -174,6 +176,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t == _S_opcode_dummy)\n \t    __it._M_next = (*this)[__it._M_next]._M_next;\n \t  if (__it._M_opcode == _S_opcode_alternative\n+\t      || __it._M_opcode == _S_opcode_repeat\n \t      || __it._M_opcode == _S_opcode_subexpr_lookahead)\n \t    while (__it._M_alt >= 0 && (*this)[__it._M_alt]._M_opcode\n \t\t   == _S_opcode_dummy)\n@@ -198,6 +201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  auto __id = _M_nfa._M_insert_state(__dup);\n \t  __m[__u] = __id;\n \t  if (__dup._M_opcode == _S_opcode_alternative\n+\t      || __dup._M_opcode == _S_opcode_repeat\n \t      || __dup._M_opcode == _S_opcode_subexpr_lookahead)\n \t    if (__dup._M_alt != _S_invalid_state_id && __m[__dup._M_alt] == -1)\n \t      __stack.push(__dup._M_alt);\n@@ -217,6 +221,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __ref._M_next = __m[__ref._M_next];\n \t    }\n \t  if (__ref._M_opcode == _S_opcode_alternative\n+\t      || __ref._M_opcode == _S_opcode_repeat\n \t      || __ref._M_opcode == _S_opcode_subexpr_lookahead)\n \t    if (__ref._M_alt != _S_invalid_state_id)\n \t      {"}, {"sha": "d7e21624e3702150c4658a126a4b0d8241f98a02", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -421,7 +421,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_make_cache(true_type)\n       {\n-\tfor (int __i = 0; __i < _M_cache.size(); __i++)\n+\tfor (size_t __i = 0; __i < _M_cache.size(); __i++)\n \t  _M_cache[static_cast<_UnsignedCharT>(__i)] =\n \t    _M_apply(__i, false_type());\n       }"}, {"sha": "3cf9e457ccd7c5844d69c33cf4c63a52e9d079a1", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -188,26 +188,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  __init();\n \t  auto __e = _M_pop();\n-\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t      __e._M_start, __neg));\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_repeat(_S_invalid_state_id,\n+\t\t\t\t\t\t\t __e._M_start, __neg));\n \t  __e._M_append(__r);\n \t  _M_stack.push(__r);\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_closure1))\n \t{\n \t  __init();\n \t  auto __e = _M_pop();\n-\t  __e._M_append(_M_nfa._M_insert_alt(_S_invalid_state_id, __e._M_start,\n-\t\t\t\t\t     __neg));\n+\t  __e._M_append(_M_nfa._M_insert_repeat(_S_invalid_state_id,\n+\t\t\t\t\t\t__e._M_start, __neg));\n \t  _M_stack.push(__e);\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_opt))\n \t{\n \t  __init();\n \t  auto __e = _M_pop();\n \t  auto __end = _M_nfa._M_insert_dummy();\n-\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t      __e._M_start, __neg));\n+\t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_repeat(_S_invalid_state_id,\n+\t\t\t\t\t\t\t __e._M_start, __neg));\n \t  __e._M_append(__end);\n \t  __r._M_append(__end);\n \t  _M_stack.push(__r);\n@@ -244,8 +244,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    {\n \t      auto __tmp = __r._M_clone();\n \t      _StateSeqT __s(_M_nfa,\n-\t\t\t     _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t  __tmp._M_start, __neg));\n+\t\t\t     _M_nfa._M_insert_repeat(_S_invalid_state_id,\n+\t\t\t\t\t\t     __tmp._M_start, __neg));\n \t      __tmp._M_append(__s);\n \t      __e._M_append(__s);\n \t    }\n@@ -261,8 +261,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      for (long __i = 0; __i < __n; ++__i)\n \t\t{\n \t\t  auto __tmp = __r._M_clone();\n-\t\t  auto __alt = _M_nfa._M_insert_alt(__tmp._M_start,\n-\t\t\t\t\t\t    __end, __neg);\n+\t\t  auto __alt = _M_nfa._M_insert_repeat(__tmp._M_start,\n+\t\t\t\t\t\t       __end, __neg);\n \t\t  __stack.push(__alt);\n \t\t  __e._M_append(_StateSeqT(_M_nfa, __alt, __tmp._M_end));\n \t\t}"}, {"sha": "c110b88a3f492ce6c184b15246c6046e87501975", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -73,6 +73,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_results(__results),\n       _M_match_queue(__dfs_mode ? nullptr\n \t\t     : new vector<pair<_StateIdT, _ResultsVec>>()),\n+      _M_rep_count(_M_nfa.size()),\n       _M_visited(__dfs_mode ? nullptr : new vector<bool>(_M_nfa.size())),\n       _M_flags((__flags & regex_constants::match_prev_avail)\n \t       ? (__flags\n@@ -102,6 +103,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_search();\n \n     private:\n+      template<bool __match_mode>\n+\tvoid\n+\t_M_rep_once_more(_StateIdT);\n+\n       template<bool __match_mode>\n \tvoid\n \t_M_dfs(_StateIdT __start);\n@@ -149,9 +154,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ResultsVec&                                          _M_results;\n       // Used in BFS, saving states that need to be considered for the next\n       // character.\n-      std::unique_ptr<vector<pair<_StateIdT, _ResultsVec>>> _M_match_queue;\n+      unique_ptr<vector<pair<_StateIdT, _ResultsVec>>>      _M_match_queue;\n       // Used in BFS, indicating that which state is already visited.\n-      std::unique_ptr<vector<bool>>                         _M_visited;\n+      vector<pair<_BiIter, int>>                            _M_rep_count;\n+      unique_ptr<vector<bool>>                              _M_visited;\n       _FlagT                                                _M_flags;\n       // To record current solution.\n       _StateIdT                                             _M_start_state;"}, {"sha": "7f8993382c86654b387efc5e061d8bd153905e90", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -161,7 +161,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  // TODO: Use a function vector to dispatch, instead of using switch-case.\n+  // __rep_count records how many times (__rep_count.second)\n+  // this node is visited under certain input iterator\n+  // (__rep_count.first). This prevent the executor from entering\n+  // infinite loop by refusing to continue when it's already been\n+  // visited more than twice. It's `twice` instead of `once` because\n+  // we need to spare one more time for potential group capture.\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+  template<bool __match_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_rep_once_more(_StateIdT __i)\n+    {\n+      const auto& __state = _M_nfa[__i];\n+      auto& __rep_count = _M_rep_count[__i];\n+      if (__rep_count.second == 0 || __rep_count.first != _M_current)\n+\t{\n+\t  auto __back = __rep_count;\n+\t  __rep_count.first = _M_current;\n+\t  __rep_count.second = 1;\n+\t  _M_dfs<__match_mode>(__state._M_alt);\n+\t  __rep_count = __back;\n+\t}\n+      else\n+\t{\n+\t  if (__rep_count.second < 2)\n+\t    {\n+\t      __rep_count.second++;\n+\t      _M_dfs<__match_mode>(__state._M_alt);\n+\t      __rep_count.second--;\n+\t    }\n+\t}\n+    };\n+\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n     bool __dfs_mode>\n   template<bool __match_mode>\n@@ -184,69 +216,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// of this quantifier\". Executing _M_next first or _M_alt first don't\n \t// mean the same thing, and we need to choose the correct order under\n \t// given greedy mode.\n-\tcase _S_opcode_alternative:\n-\t  // Greedy.\n-\t  if (!__state._M_neg)\n-\t    {\n-\t      // \"Once more\" is preferred in greedy mode.\n-\t      _M_dfs<__match_mode>(__state._M_alt);\n-\t      // If it's DFS executor and already accepted, we're done.\n-\t      if (!__dfs_mode || !_M_has_sol)\n-\t\t_M_dfs<__match_mode>(__state._M_next);\n-\t    }\n-\t  else // Non-greedy mode\n-\t    {\n-\t      if (__dfs_mode)\n-\t\t{\n-\t\t  // vice-versa.\n+\tcase _S_opcode_repeat:\n+\t  {\n+\t    // Greedy.\n+\t    if (!__state._M_neg)\n+\t      {\n+\t\t_M_rep_once_more<__match_mode>(__i);\n+\t\t// If it's DFS executor and already accepted, we're done.\n+\t\tif (!__dfs_mode || !_M_has_sol)\n \t\t  _M_dfs<__match_mode>(__state._M_next);\n-\t\t  if (!_M_has_sol)\n-\t\t    _M_dfs<__match_mode>(__state._M_alt);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // DON'T attempt anything, because there's already another\n-\t\t  // state with higher priority accepted. This state cannot be\n-\t\t  // better by attempting its next node.\n-\t\t  if (!_M_has_sol)\n-\t\t    {\n-\t\t      _M_dfs<__match_mode>(__state._M_next);\n-\t\t      // DON'T attempt anything if it's already accepted. An\n-\t\t      // accepted state *must* be better than a solution that\n-\t\t      // matches a non-greedy quantifier one more time.\n-\t\t      if (!_M_has_sol)\n-\t\t\t_M_dfs<__match_mode>(__state._M_alt);\n-\t\t    }\n-\t\t}\n+\t      }\n+\t    else // Non-greedy mode\n+\t      {\n+\t\tif (__dfs_mode)\n+\t\t  {\n+\t\t    // vice-versa.\n+\t\t    _M_dfs<__match_mode>(__state._M_next);\n+\t\t    if (!_M_has_sol)\n+\t\t      _M_rep_once_more<__match_mode>(__i);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    // DON'T attempt anything, because there's already another\n+\t\t    // state with higher priority accepted. This state cannot be\n+\t\t    // better by attempting its next node.\n+\t\t    if (!_M_has_sol)\n+\t\t      {\n+\t\t\t_M_dfs<__match_mode>(__state._M_next);\n+\t\t\t// DON'T attempt anything if it's already accepted. An\n+\t\t\t// accepted state *must* be better than a solution that\n+\t\t\t// matches a non-greedy quantifier one more time.\n+\t\t\tif (!_M_has_sol)\n+\t\t\t  _M_rep_once_more<__match_mode>(__i);\n+\t\t      }\n+\t\t  }\n+\t      }\n \t    }\n \t  break;\n \tcase _S_opcode_subexpr_begin:\n-\t  // If there's nothing changed since last visit, do NOT continue.\n-\t  // This prevents the executor from get into infinite loop when using\n-\t  // \"()*\" to match \"\".\n-\t  if (!_M_cur_results[__state._M_subexpr].matched\n-\t      || _M_cur_results[__state._M_subexpr].first != _M_current)\n-\t    {\n-\t      auto& __res = _M_cur_results[__state._M_subexpr];\n-\t      auto __back = __res.first;\n-\t      __res.first = _M_current;\n-\t      _M_dfs<__match_mode>(__state._M_next);\n-\t      __res.first = __back;\n-\t    }\n+\t  {\n+\t    auto& __res = _M_cur_results[__state._M_subexpr];\n+\t    auto __back = __res.first;\n+\t    __res.first = _M_current;\n+\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    __res.first = __back;\n+\t  }\n \t  break;\n \tcase _S_opcode_subexpr_end:\n-\t  if (_M_cur_results[__state._M_subexpr].second != _M_current\n-\t      || _M_cur_results[__state._M_subexpr].matched != true)\n-\t    {\n-\t      auto& __res = _M_cur_results[__state._M_subexpr];\n-\t      auto __back = __res;\n-\t      __res.second = _M_current;\n-\t      __res.matched = true;\n-\t      _M_dfs<__match_mode>(__state._M_next);\n-\t      __res = __back;\n-\t    }\n-\t  else\n+\t  {\n+\t    auto& __res = _M_cur_results[__state._M_subexpr];\n+\t    auto __back = __res;\n+\t    __res.second = _M_current;\n+\t    __res.matched = true;\n \t    _M_dfs<__match_mode>(__state._M_next);\n+\t    __res = __back;\n+\t  }\n \t  break;\n \tcase _S_opcode_line_begin_assertion:\n \t  if (_M_at_begin())\n@@ -339,6 +363,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  }\n \t    }\n \t  break;\n+\tcase _S_opcode_alternative:\n+\t  _M_dfs<__match_mode>(__state._M_alt);\n+\t  if (!__dfs_mode || !_M_has_sol)\n+\t    _M_dfs<__match_mode>(__state._M_next);\n+\t  break;\n \tdefault:\n \t  _GLIBCXX_DEBUG_ASSERT(false);\n \t}"}, {"sha": "f501ff6c2cbae976fbf203d9f249f73b34efc08e", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -335,7 +335,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else if (__c == 'x' || __c == 'u')\n \t{\n \t  _M_value.erase();\n-\t  for (int i = 0; i < (__c == 'x' ? 2 : 4); i++)\n+\t  for (int __i = 0; __i < (__c == 'x' ? 2 : 4); __i++)\n \t    {\n \t      if (_M_current == _M_end\n \t\t  || !_M_ctype.is(_CtypeT::xdigit, *_M_current))"}, {"sha": "c33d1b6189402fad7b461672a0aab0a36c34b6df", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/emptygroup.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Femptygroup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a670a9bb5477d63b47091347da53551d639bb8ee/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Femptygroup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Femptygroup.cc?ref=a670a9bb5477d63b47091347da53551d639bb8ee", "patch": "@@ -50,6 +50,7 @@ test01()\n     const char s[] = \"\";\n     VERIFY( regex_match_debug(s, m, re) );\n   }\n+  VERIFY(regex_match_debug(\"\", regex(\"(?:)*\")));\n }\n \n int"}]}