{"sha": "e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkZTI5ZjQ2NzdlODFlNzFjNjBlYjJiOWYyNDdlYWExMmVhMTM1Mw==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-06-10T18:20:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-09T12:35:30Z"}, "message": "[Ada] Add -gnatX support for casing on discriminated values\n\ngcc/ada/\n\n\t* exp_ch5.adb (Expand_General_Case_Statement): Add new function\n\tElse_Statements to handle the case of invalid data analogously\n\tto how it is handled when casing on a discrete value.\n\t* sem_case.adb (Has_Static_Discriminant_Constraint): A new\n\tBoolean-valued function.\n\t(Composite_Case_Ops.Scalar_Part_Count): Include discriminants\n\twhen traversing components.\n\t(Composite_Case_Ops.Choice_Analysis.Traverse_Discrete_Parts):\n\tInclude discriminants when traversing components; the component\n\trange for a constrained discriminant is a single value.\n\t(Composite_Case_Ops.Choice_Analysis.Parse_Choice): Eliminate\n\tDone variable and modify how Next_Part is computed so that it is\n\talways correct (as opposed to being incorrect when Done is\n\tTrue).  This includes changes in Update_Result (a local\n\tprocedure).  Add new local procedure\n\tUpdate_Result_For_Box_Component and call it not just for box\n\tcomponents but also for \"missing\" components (components\n\tassociated with an inactive variant).\n\t(Check_Choices.Check_Composite_Case_Selector.Check_Component_Subtype):\n\tInstead of disallowing all discriminated component types, allow\n\tthose that are unconstrained or statically constrained. Check\n\tdiscriminant subtypes along with other component subtypes.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Update\n\tdocumentation to reflect current implementation status.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "04c6b5510d3874e81262d11aee1181f6fa79e8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c6b5510d3874e81262d11aee1181f6fa79e8d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "765ca22b1792b613d2801b6d2ef9986e18bba3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765ca22b1792b613d2801b6d2ef9986e18bba3ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765ca22b1792b613d2801b6d2ef9986e18bba3ab"}], "stats": {"total": 334, "additions": 241, "deletions": 93}, "files": [{"sha": "6c81ca7db6160e65b339d8d7a1437186a23b4755", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "patch": "@@ -2237,8 +2237,7 @@ of GNAT specific extensions are recognized as follows:\n   some restrictions (described below). Aggregate syntax is used for choices\n   of such a case statement; however, in cases where a \"normal\" aggregate would\n   require a discrete value, a discrete subtype may be used instead; box\n-  notation can also be used to match all values (but currently only\n-  for discrete subcomponents).\n+  notation can also be used to match all values.\n \n   Consider this example:\n \n@@ -2269,10 +2268,10 @@ of GNAT specific extensions are recognized as follows:\n   set shall be a proper subset of the second (and the later alternative\n   will not be executed if the earlier alternative \"matches\"). All possible\n   values of the composite type shall be covered. The composite type of the\n-  selector shall be a nonlimited untagged undiscriminated record type, all\n-  of whose subcomponent subtypes are either static discrete subtypes or\n-  record types that meet the same restrictions. Support for arrays is\n-  planned, but not yet implemented.\n+  selector shall be a nonlimited untagged (but possibly discriminated)\n+  record type, all of whose subcomponent subtypes are either static discrete\n+  subtypes or record types that meet the same restrictions. Support for arrays\n+  is planned, but not yet implemented.\n \n   In addition, pattern bindings are supported. This is a mechanism\n   for binding a name to a component of a matching value for use within"}, {"sha": "8ac9662902567293ebf8cbd9b305c326332c3147", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "patch": "@@ -3641,16 +3641,37 @@ package body Exp_Ch5 is\n             return Result;\n          end Elsif_Parts;\n \n+         function Else_Statements return List_Id;\n+         --  Returns a \"raise Constraint_Error\" statement if\n+         --  exception propagate is permitted and No_List otherwise.\n+\n+         ---------------------\n+         -- Else_Statements --\n+         ---------------------\n+\n+         function Else_Statements return List_Id is\n+         begin\n+            if Restriction_Active (No_Exception_Propagation) then\n+               return No_List;\n+            else\n+               return New_List (Make_Raise_Constraint_Error (Loc,\n+                                  Reason => CE_Invalid_Data));\n+            end if;\n+         end Else_Statements;\n+\n+         --  Local constants\n+\n          If_Stmt : constant Node_Id :=\n            Make_If_Statement (Loc,\n               Condition       => Top_Level_Pattern_Match_Condition (First_Alt),\n               Then_Statements => Statements (First_Alt),\n-              Elsif_Parts     => Elsif_Parts);\n-         --  Do we want an implicit \"else raise Program_Error\" here???\n-         --  Perhaps only if Exception-related restrictions are not in effect.\n+              Elsif_Parts     => Elsif_Parts,\n+              Else_Statements => Else_Statements);\n \n          Declarations : constant List_Id := New_List (Selector_Decl);\n \n+      --  Start of processing for Expand_General_Case_Statment\n+\n       begin\n          if Present (Choice_Index_Decl) then\n             Append_To (Declarations, Choice_Index_Decl);"}, {"sha": "349586edeadb7320b121005e9953b861c38d7ab7", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "patch": "@@ -3665,8 +3665,7 @@ The selector for a case statement may be of a composite type, subject to\n some restrictions (described below). Aggregate syntax is used for choices\n of such a case statement; however, in cases where a \u201cnormal\u201d aggregate would\n require a discrete value, a discrete subtype may be used instead; box\n-notation can also be used to match all values (but currently only\n-for discrete subcomponents).\n+notation can also be used to match all values.\n \n Consider this example:\n \n@@ -3697,10 +3696,10 @@ overlaps the corresponding set of a later alternative, then the first\n set shall be a proper subset of the second (and the later alternative\n will not be executed if the earlier alternative \u201cmatches\u201d). All possible\n values of the composite type shall be covered. The composite type of the\n-selector shall be a nonlimited untagged undiscriminated record type, all\n-of whose subcomponent subtypes are either static discrete subtypes or\n-record types that meet the same restrictions. Support for arrays is\n-planned, but not yet implemented.\n+selector shall be a nonlimited untagged (but possibly discriminated)\n+record type, all of whose subcomponent subtypes are either static discrete\n+subtypes or record types that meet the same restrictions. Support for arrays\n+is planned, but not yet implemented.\n \n In addition, pattern bindings are supported. This is a mechanism\n for binding a name to a component of a matching value for use within"}, {"sha": "7d08da5af64c610e3bfd085c233d88ecbe8694ce", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 207, "deletions": 78, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de29f4677e81e71c60eb2b9f247eaa12ea1353/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=e4de29f4677e81e71c60eb2b9f247eaa12ea1353", "patch": "@@ -27,6 +27,7 @@ with Atree;          use Atree;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n+with Elists;         use Elists;\n with Errout;         use Errout;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n@@ -90,13 +91,18 @@ package body Sem_Case is\n    --\n    --  Bounds_Type is the type whose range must be covered by the alternatives\n    --\n-   --  Subtyp is the subtype of the expression. If its bounds are non-static\n+   --  Subtyp is the subtype of the expression. If its bounds are nonstatic\n    --  the alternatives must cover its base type.\n \n    function Choice_Image (Value : Uint; Ctype : Entity_Id) return Name_Id;\n    --  Given a Pos value of enumeration type Ctype, returns the name\n    --  ID of an appropriate string to be used in error message output.\n \n+   function Has_Static_Discriminant_Constraint\n+     (Subtyp : Entity_Id) return Boolean;\n+   --  Returns True if the given subtype is subject to a discriminant\n+   --  constraint and at least one of the constraint values is nonstatic.\n+\n    package Composite_Case_Ops is\n \n       function Scalar_Part_Count (Subtyp : Entity_Id) return Nat;\n@@ -255,9 +261,9 @@ package body Sem_Case is\n       --  is posted at location C. Caller sets Error_Msg_Sloc for xx.\n \n       procedure Explain_Non_Static_Bound;\n-      --  Called when we find a non-static bound, requiring the base type to\n+      --  Called when we find a nonstatic bound, requiring the base type to\n       --  be covered. Provides where possible a helpful explanation of why the\n-      --  bounds are non-static, since this is not always obvious.\n+      --  bounds are nonstatic, since this is not always obvious.\n \n       function Lt_Choice (C1, C2 : Natural) return Boolean;\n       --  Comparison routine for comparing Choice_Table entries. Use the lower\n@@ -734,7 +740,7 @@ package body Sem_Case is\n                  (\"bounds of & are not static, \"\n                   & \"alternatives must cover base type!\", Expr, Expr);\n \n-            --  If this is a case statement, the expression may be non-static\n+            --  If this is a case statement, the expression may be nonstatic\n             --  or else the subtype may be at fault.\n \n             elsif Is_Entity_Name (Expr) then\n@@ -1124,14 +1130,14 @@ package body Sem_Case is\n             return Static_Array_Length (Subtyp)\n               * Scalar_Part_Count (Component_Type (Subtyp));\n          elsif Is_Record_Type (Subtyp) then\n-            pragma Assert (not Has_Discriminants (Subtyp));\n             declare\n                Result : Nat := 0;\n-               Comp : Entity_Id := First_Component (Subtyp);\n+               Comp : Entity_Id := First_Component_Or_Discriminant\n+                                     (Base_Type (Subtyp));\n             begin\n                while Present (Comp) loop\n                   Result := Result + Scalar_Part_Count (Etype (Comp));\n-                  Next_Component (Comp);\n+                  Next_Component_Or_Discriminant (Comp);\n                end loop;\n                return Result;\n             end;\n@@ -1218,22 +1224,55 @@ package body Sem_Case is\n                      Traverse_Discrete_Parts (Component_Type (Subtyp));\n                   end loop;\n                elsif Is_Record_Type (Subtyp) then\n-                  pragma Assert (not Has_Discriminants (Subtyp));\n-                  declare\n-                     Comp : Entity_Id := First_Component (Subtyp);\n-                  begin\n-                     while Present (Comp) loop\n-                        Traverse_Discrete_Parts (Etype (Comp));\n-                        Next_Component (Comp);\n-                     end loop;\n-                  end;\n+                  if Has_Static_Discriminant_Constraint (Subtyp) then\n+\n+                     --  The component range for a constrained discriminant\n+                     --  is a single value.\n+                     declare\n+                        Dc_Elmt : Elmt_Id :=\n+                          First_Elmt (Discriminant_Constraint (Subtyp));\n+                        Dc_Value : Uint;\n+                     begin\n+                        while Present (Dc_Elmt) loop\n+                           Dc_Value := Expr_Value (Node (Dc_Elmt));\n+                           Update_Result ((Low  => Dc_Value,\n+                                           High => Dc_Value));\n+\n+                           Next_Elmt (Dc_Elmt);\n+                        end loop;\n+                     end;\n+\n+                     --  Generate ranges for nondiscriminant components.\n+                     declare\n+                        Comp : Entity_Id := First_Component\n+                                              (Base_Type (Subtyp));\n+                     begin\n+                        while Present (Comp) loop\n+                           Traverse_Discrete_Parts (Etype (Comp));\n+                           Next_Component (Comp);\n+                        end loop;\n+                     end;\n+                  else\n+                     --  Generate ranges for all components\n+                     declare\n+                        Comp : Entity_Id :=\n+                          First_Component_Or_Discriminant\n+                            (Base_Type (Subtyp));\n+                     begin\n+                        while Present (Comp) loop\n+                           Traverse_Discrete_Parts (Etype (Comp));\n+                           Next_Component_Or_Discriminant (Comp);\n+                        end loop;\n+                     end;\n+                  end if;\n                else\n                   Error_Msg_N\n                     (\"case selector type having a non-discrete non-record\"\n                      & \"  non-array subcomponent type not implemented\",\n                      Expression (Case_Statement));\n                end if;\n             end Traverse_Discrete_Parts;\n+\n          begin\n             Traverse_Discrete_Parts (Etype (Expression (Case_Statement)));\n             pragma Assert (Done or else Serious_Errors_Detected > 0);\n@@ -1338,32 +1377,45 @@ package body Sem_Case is\n          is\n             Result    : Choice_Range_Info (Is_Others => False);\n             Ranges    : Composite_Range_Info renames Result.Ranges;\n-            Next_Part : Part_Id := 1;\n-            Done      : Boolean := False;\n+            Next_Part : Part_Id'Base range 1 .. Part_Id'Last + 1 := 1;\n+\n+            procedure Traverse_Choice (Expr : Node_Id);\n+            --  Traverse a legal choice expression, looking for\n+            --  values/ranges of discrete parts. Call Update_Result\n+            --  for each.\n \n             procedure Update_Result (Discrete_Range : Discrete_Range_Info);\n             --  Initialize first remaining uninitialized element of Ranges.\n-            --  Also set Next_Part and Done.\n+            --  Also set Next_Part.\n+\n+            procedure Update_Result_For_Full_Coverage (Comp_Type  : Entity_Id);\n+            --  For each scalar part of the given component type, call\n+            --  Update_Result with the full range for that scalar part.\n+            --  This is used for both box components in aggregates and\n+            --  for any inactive-variant components that do not appear in\n+            --  a given aggregate.\n \n             -------------------\n             -- Update_Result --\n             -------------------\n \n             procedure Update_Result (Discrete_Range : Discrete_Range_Info) is\n             begin\n-               pragma Assert (not Done);\n                Ranges (Next_Part) := Discrete_Range;\n-               if Next_Part = Part_Id'Last then\n-                  Done := True;\n-               else\n-                  Next_Part := Next_Part + 1;\n-               end if;\n+               Next_Part := Next_Part + 1;\n             end Update_Result;\n \n-            procedure Traverse_Choice (Expr : Node_Id);\n-            --  Traverse a legal choice expression, looking for\n-            --  values/ranges of discrete parts. Call Update_Result\n-            --  for each.\n+            -------------------------------------\n+            -- Update_Result_For_Full_Coverage --\n+            -------------------------------------\n+\n+            procedure Update_Result_For_Full_Coverage (Comp_Type : Entity_Id)\n+            is\n+            begin\n+               for Counter in 1 .. Scalar_Part_Count (Comp_Type) loop\n+                  Update_Result (Component_Bounds (Next_Part));\n+               end loop;\n+            end Update_Result_For_Full_Coverage;\n \n             ---------------------\n             -- Traverse_Choice --\n@@ -1388,52 +1440,89 @@ package body Sem_Case is\n                      Refresh_Binding_Info (Aggr => Expr);\n \n                      declare\n-                        Comp : Node_Id :=\n+                        Comp_Assoc : Node_Id :=\n                           First (Component_Associations (Expr));\n-                        --  Ok to assume that components are in order here?\n+                        --  Aggregate has been normalized (components in\n+                        --  order, only one component per choice, etc.).\n+\n+                        Comp_From_Type : Node_Id :=\n+                          First_Component_Or_Discriminant\n+                            (Base_Type (Etype (Expr)));\n+\n+                        Saved_Next_Part : constant Part_Id := Next_Part;\n                      begin\n-                        while Present (Comp) loop\n-                           pragma Assert (List_Length (Choices (Comp)) = 1);\n-                           if Box_Present (Comp) then\n-                              declare\n-                                 Comp_Type : constant Entity_Id :=\n-                                   Etype (First (Choices (Comp)));\n-                              begin\n-                                 if Is_Discrete_Type (Comp_Type) then\n-                                    declare\n-                                       Low  : constant Node_Id :=\n-                                         Type_Low_Bound (Comp_Type);\n-                                       High : constant Node_Id :=\n-                                         Type_High_Bound (Comp_Type);\n-                                    begin\n-                                       Update_Result\n-                                         ((Low  => Expr_Value (Low),\n-                                           High => Expr_Value (High)));\n-                                    end;\n-                                 else\n-                                    --  Need to recursively traverse type\n-                                    --  here, calling Update_Result for\n-                                    --  each discrete subcomponent.\n+                        while Present (Comp_Assoc) loop\n+                           pragma Assert\n+                             (List_Length (Choices (Comp_Assoc)) = 1);\n \n-                                    Error_Msg_N\n-                                      (\"box values for nondiscrete pattern \"\n-                                       & \"subcomponents unimplemented\", Comp);\n+                           declare\n+                              Comp : constant Node_Id :=\n+                                Entity (First (Choices (Comp_Assoc)));\n+                              Comp_Seen : Boolean := False;\n+                           begin\n+                              loop\n+                                 if Original_Record_Component (Comp) =\n+                                   Original_Record_Component (Comp_From_Type)\n+                                 then\n+                                    Comp_Seen := True;\n+                                 else\n+                                    --  We have an aggregate of a type that\n+                                    --  has a variant part (or has a\n+                                    --  subcomponent type that has a variant\n+                                    --  part) and we have to deal with a\n+                                    --  component that is present in the type\n+                                    --  but not in the aggregate (because the\n+                                    --  component is in an inactive variant).\n+                                    --\n+                                    Update_Result_For_Full_Coverage\n+                                      (Comp_Type => Etype (Comp_From_Type));\n                                  end if;\n-                              end;\n+\n+                                 Comp_From_Type :=\n+                                   Next_Component_Or_Discriminant\n+                                     (Comp_From_Type);\n+\n+                                 exit when Comp_Seen;\n+                              end loop;\n+                           end;\n+\n+                           if Box_Present (Comp_Assoc) then\n+                              --  Box matches all values\n+                              Update_Result_For_Full_Coverage\n+                                (Etype (First (Choices (Comp_Assoc))));\n                            else\n-                              Traverse_Choice (Expression (Comp));\n+                              Traverse_Choice (Expression (Comp_Assoc));\n                            end if;\n \n-                           if Binding_Chars (Comp) /= No_Name\n+                           if Binding_Chars (Comp_Assoc) /= No_Name\n                            then\n                               Case_Bindings.Note_Binding\n-                                (Comp_Assoc => Comp,\n+                                (Comp_Assoc => Comp_Assoc,\n                                  Choice     => Choice,\n                                  Alt        => Alt);\n                            end if;\n \n-                           Next (Comp);\n+                           Next (Comp_Assoc);\n                         end loop;\n+\n+                        while Present (Comp_From_Type) loop\n+                           --  Deal with any trailing inactive-variant\n+                           --  components.\n+                           --\n+                           --  See earlier commment about calling\n+                           --  Update_Result_For_Full_Coverage for such\n+                           --  components.\n+\n+                           Update_Result_For_Full_Coverage\n+                             (Comp_Type => Etype (Comp_From_Type));\n+\n+                           Comp_From_Type :=\n+                             Next_Component_Or_Discriminant (Comp_From_Type);\n+                        end loop;\n+\n+                        pragma Assert\n+                          (Nat (Next_Part - Saved_Next_Part)\n+                           = Scalar_Part_Count (Etype (Expr)));\n                      end;\n                   elsif Is_Array_Type (Etype (Expr)) then\n                      if Is_Non_Empty_List (Component_Associations (Expr)) then\n@@ -1477,14 +1566,16 @@ package body Sem_Case is\n                end if;\n             end Traverse_Choice;\n \n+         --  Start of processing for Parse_Choice\n+\n          begin\n             if Nkind (Choice) = N_Others_Choice then\n                return (Is_Others => True);\n             end if;\n             Traverse_Choice (Choice);\n \n             --  Avoid returning uninitialized garbage in error case\n-            if not Done then\n+            if Next_Part /= Part_Id'Last + 1 then\n                pragma Assert (Serious_Errors_Detected > 0);\n                Result.Ranges := (others => (Low => Uint_1, High => Uint_0));\n             end if;\n@@ -2936,20 +3027,34 @@ package body Sem_Case is\n                   end if;\n                   Check_Component_Subtype (Component_Type (Subtyp));\n                elsif Is_Record_Type (Subtyp) then\n-                  if Has_Discriminants (Subtyp) then\n-                     Error_Msg_N\n-                        (\"type of case selector (or subcomponent thereof) \" &\n-                         \"is discriminated\", N);\n-                  else\n-                     declare\n-                        Comp : Entity_Id := First_Component (Subtyp);\n-                     begin\n-                        while Present (Comp) loop\n-                           Check_Component_Subtype (Etype (Comp));\n-                           Next_Component (Comp);\n-                        end loop;\n-                     end;\n+\n+                  if Has_Discriminants (Subtyp)\n+                    and then Is_Constrained (Subtyp)\n+                    and then not Has_Static_Discriminant_Constraint (Subtyp)\n+                  then\n+                     --  We are only disallowing nonstatic constraints for\n+                     --  subcomponent subtypes, not for the subtype of the\n+                     --  expression we are casing on. This test could be\n+                     --  implemented via an Is_Recursive_Call parameter if\n+                     --  that seems preferable.\n+\n+                     if Subtyp /= Check_Choices.Subtyp then\n+                        Error_Msg_N\n+                          (\"constrained discriminated subtype of case \" &\n+                           \"selector subcomponent has nonstatic \" &\n+                           \"constraint\", N);\n+                     end if;\n                   end if;\n+\n+                  declare\n+                     Comp : Entity_Id :=\n+                       First_Component_Or_Discriminant (Base_Type (Subtyp));\n+                  begin\n+                     while Present (Comp) loop\n+                        Check_Component_Subtype (Etype (Comp));\n+                        Next_Component_Or_Discriminant (Comp);\n+                     end loop;\n+                  end;\n                else\n                   Error_Msg_N\n                     (\"type of case selector (or subcomponent thereof) is \" &\n@@ -3058,7 +3163,7 @@ package body Sem_Case is\n          --  bounds of its base type to determine the values covered by the\n          --  discrete choices.\n \n-         --  In Ada 2012, if the subtype has a non-static predicate the full\n+         --  In Ada 2012, if the subtype has a nonstatic predicate the full\n          --  range of the base type must be covered as well.\n \n          if Is_OK_Static_Subtype (Subtyp) then\n@@ -3075,7 +3180,7 @@ package body Sem_Case is\n          end if;\n \n          --  Obtain static bounds of type, unless this is a generic formal\n-         --  discrete type for which all choices will be non-static.\n+         --  discrete type for which all choices will be nonstatic.\n \n          if not Is_Generic_Type (Root_Type (Bounds_Type))\n            or else Ekind (Bounds_Type) /= E_Enumeration_Type\n@@ -3137,7 +3242,7 @@ package body Sem_Case is\n \n                         if Has_Predicates (E) then\n \n-                           --  Use of non-static predicate is an error\n+                           --  Use of nonstatic predicate is an error\n \n                            if not Is_Discrete_Type (E)\n                              or else not Has_Static_Predicate (E)\n@@ -3298,6 +3403,30 @@ package body Sem_Case is\n \n    end Generic_Check_Choices;\n \n+   -----------------------------------------\n+   --  Has_Static_Discriminant_Constraint --\n+   -----------------------------------------\n+\n+   function Has_Static_Discriminant_Constraint\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+   begin\n+      if Has_Discriminants (Subtyp) and then Is_Constrained (Subtyp) then\n+         declare\n+            DC_Elmt : Elmt_Id := First_Elmt (Discriminant_Constraint (Subtyp));\n+         begin\n+            while Present (DC_Elmt) loop\n+               if not All_Composite_Constraints_Static (Node (DC_Elmt)) then\n+                  return False;\n+               end if;\n+               Next_Elmt (DC_Elmt);\n+            end loop;\n+            return True;\n+         end;\n+      end if;\n+      return False;\n+   end Has_Static_Discriminant_Constraint;\n+\n    ----------------------------\n    -- Is_Case_Choice_Pattern --\n    ----------------------------"}]}