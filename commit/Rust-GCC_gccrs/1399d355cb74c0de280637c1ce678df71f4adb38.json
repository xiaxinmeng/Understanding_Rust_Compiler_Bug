{"sha": "1399d355cb74c0de280637c1ce678df71f4adb38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM5OWQzNTVjYjc0YzBkZTI4MDYzN2MxY2U2NzhkZjcxZjRhZGIzOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:50:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:50:23Z"}, "message": "[multiple changes]\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Add_Task_Actuals_To_Build_In_Place_Call): New\n\tparameter Chain to be used in the allocator case.\n\t(Make_Build_In_Place_Call_In_Allocator): If the allocated object\n\thas tasks, wrap the code in a block that will activate them,\n\tincluding the usual finalization code to kill them off in case\n\tof exception or abort.\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* treepr.adb, treepr.ads; Reorganize documentation for new pp routines\n\tRemove renamings (don't work for gdb).\n\t(par): New synonym for p (avoid gdb ambiguities).\n\t* inline.adb, sem_ch6.adb, sem_ch13.adb: Minor reformatting.\n\nFrom-SVN: r213249", "tree": {"sha": "890c32d034ce28a24f841058ac0bf3012117e047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/890c32d034ce28a24f841058ac0bf3012117e047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1399d355cb74c0de280637c1ce678df71f4adb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1399d355cb74c0de280637c1ce678df71f4adb38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1399d355cb74c0de280637c1ce678df71f4adb38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1399d355cb74c0de280637c1ce678df71f4adb38/comments", "author": null, "committer": null, "parents": [{"sha": "6be44a9ab06b3df25281100bdc7a3d55fe8f7778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be44a9ab06b3df25281100bdc7a3d55fe8f7778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be44a9ab06b3df25281100bdc7a3d55fe8f7778"}], "stats": {"total": 343, "additions": 222, "deletions": 121}, "files": [{"sha": "1d457eb784f145fa4a667716e2bc36e381c0d445", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -1,3 +1,19 @@\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Task_Actuals_To_Build_In_Place_Call): New\n+\tparameter Chain to be used in the allocator case.\n+\t(Make_Build_In_Place_Call_In_Allocator): If the allocated object\n+\thas tasks, wrap the code in a block that will activate them,\n+\tincluding the usual finalization code to kill them off in case\n+\tof exception or abort.\n+\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* treepr.adb, treepr.ads; Reorganize documentation for new pp routines\n+\tRemove renamings (don't work for gdb).\n+\t(par): New synonym for p (avoid gdb ambiguities).\n+\t* inline.adb, sem_ch6.adb, sem_ch13.adb: Minor reformatting.\n+\n 2014-07-30  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch9.ads, sem_prag.adb, exp_ch4.adb, sem_ch13.adb: Minor comment"}, {"sha": "d059de3c67f415141a7eb9c4b44e7e213e81a16c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 140, "deletions": 89, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -125,17 +125,20 @@ package body Exp_Ch6 is\n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Master_Actual : Node_Id);\n+      Master_Actual : Node_Id;\n+      Chain         : Node_Id := Empty);\n    --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type\n    --  contains tasks, add two actual parameters: the master, and a pointer to\n    --  the caller's activation chain. Master_Actual is the actual parameter\n    --  expression to pass for the master. In most cases, this is the current\n    --  master (_master). The two exceptions are: If the function call is the\n    --  initialization expression for an allocator, we pass the master of the\n    --  access type. If the function call is the initialization expression for a\n-   --  return object, we pass along the master passed in by the caller. The\n-   --  activation chain to pass is always the local one. Note: Master_Actual\n-   --  can be Empty, but only if there are no tasks.\n+   --  return object, we pass along the master passed in by the caller. In most\n+   --  contexts, the activation chain to pass is the local one, which is\n+   --  indicated by No (Chain). However, in an allocator, the caller passes in\n+   --  the activation Chain. Note: Master_Actual can be Empty, but only if\n+   --  there are no tasks.\n \n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n@@ -506,7 +509,8 @@ package body Exp_Ch6 is\n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Master_Actual : Node_Id)\n+      Master_Actual : Node_Id;\n+      Chain         : Node_Id := Empty)\n    is\n       Loc           : constant Source_Ptr := Sloc (Function_Call);\n       Result_Subt   : constant Entity_Id :=\n@@ -554,10 +558,20 @@ package body Exp_Ch6 is\n \n       --  Create the actual which is a pointer to the current activation chain\n \n-      Chain_Actual :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => Make_Identifier (Loc, Name_uChain),\n-          Attribute_Name => Name_Unrestricted_Access);\n+      if No (Chain) then\n+         Chain_Actual :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Make_Identifier (Loc, Name_uChain),\n+             Attribute_Name => Name_Unrestricted_Access);\n+\n+      --  Allocator case; make a reference to the Chain passed in by the caller\n+\n+      else\n+         Chain_Actual :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Chain, Loc),\n+             Attribute_Name => Name_Unrestricted_Access);\n+      end if;\n \n       Analyze_And_Resolve (Chain_Actual, Etype (Chain_Formal));\n \n@@ -8499,10 +8513,16 @@ package body Exp_Ch6 is\n       Acc_Type          : constant Entity_Id := Etype (Allocator);\n       Loc               : Source_Ptr;\n       Func_Call         : Node_Id := Function_Call;\n+      Ref_Func_Call     : Node_Id;\n       Function_Id       : Entity_Id;\n       Result_Subt       : Entity_Id;\n       New_Allocator     : Node_Id;\n-      Return_Obj_Access : Entity_Id;\n+      Return_Obj_Access : Entity_Id; -- temp for function result\n+      Temp_Init         : Node_Id; -- initial value of Return_Obj_Access\n+      Alloc_Form        : BIP_Allocation_Form;\n+      Pool              : Node_Id; -- nonnull if Alloc_Form = User_Storage_Pool\n+      Return_Obj_Actual : Node_Id; -- the temp.all, in caller-allocates case\n+      Chain             : Entity_Id; -- activation chain, in case of tasks\n \n    begin\n       --  Step past qualification or unchecked conversion (the latter can occur\n@@ -8541,14 +8561,16 @@ package body Exp_Ch6 is\n \n       Result_Subt := Available_View (Etype (Function_Id));\n \n-      --  Check whether return type includes tasks. This may not have been done\n-      --  previously, if the type was a limited view.\n+      --  Create a temp for the function result. In the caller-allocates case,\n+      --  this will be initialized to the result of a new uninitialized\n+      --  allocator. Note: we do not use Allocator as the Related_Node of\n+      --  Return_Obj_Access in call to Make_Temporary below as this would\n+      --  create a sort of infinite \"recursion\".\n \n-      if Has_Task (Result_Subt) then\n-         Build_Activation_Chain_Entity (Allocator);\n-      end if;\n+      Return_Obj_Access := Make_Temporary (Loc, 'R');\n+      Set_Etype (Return_Obj_Access, Acc_Type);\n \n-      --  When the result subtype is constrained, the return object must be\n+      --  When the result subtype is constrained, the return object is\n       --  allocated on the caller side, and access to it is passed to the\n       --  function.\n \n@@ -8580,57 +8602,29 @@ package body Exp_Ch6 is\n \n          Rewrite (Allocator, New_Allocator);\n \n-         --  Create a new access object and initialize it to the result of the\n-         --  new uninitialized allocator. Note: we do not use Allocator as the\n-         --  Related_Node of Return_Obj_Access in call to Make_Temporary below\n-         --  as this would create a sort of infinite \"recursion\".\n+         --  Initial value of the temp is the result of the uninitialized\n+         --  allocator\n \n-         Return_Obj_Access := Make_Temporary (Loc, 'R');\n-         Set_Etype (Return_Obj_Access, Acc_Type);\n+         Temp_Init := Relocate_Node (Allocator);\n \n-         Insert_Action (Allocator,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Return_Obj_Access,\n-             Object_Definition   => New_Occurrence_Of (Acc_Type, Loc),\n-             Expression          => Relocate_Node (Allocator)));\n+         --  Indicate that caller allocates, and pass in the return object\n \n-         --  When the function has a controlling result, an allocation-form\n-         --  parameter must be passed indicating that the caller is allocating\n-         --  the result object. This is needed because such a function can be\n-         --  called as a dispatching operation and must be treated similarly\n-         --  to functions with unconstrained result subtypes.\n-\n-         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n-\n-         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Acc_Type);\n-\n-         Add_Task_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n-\n-         --  Add an implicit actual to the function call that provides access\n-         --  to the allocated object. An unchecked conversion to the (specific)\n-         --  result subtype of the function is inserted to handle cases where\n-         --  the access type of the allocator has a class-wide designated type.\n-\n-         Add_Access_Actual_To_Build_In_Place_Call\n-           (Func_Call,\n-            Function_Id,\n-            Make_Unchecked_Type_Conversion (Loc,\n-              Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n-              Expression   =>\n-                Make_Explicit_Dereference (Loc,\n-                  Prefix => New_Occurrence_Of (Return_Obj_Access, Loc))));\n+         Alloc_Form := Caller_Allocation;\n+         Pool := Make_Null (No_Location);\n+         Return_Obj_Actual :=\n+           Make_Unchecked_Type_Conversion (Loc,\n+             Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n+             Expression   =>\n+               Make_Explicit_Dereference (Loc,\n+                 Prefix => New_Occurrence_Of (Return_Obj_Access, Loc)));\n \n       --  When the result subtype is unconstrained, the function itself must\n       --  perform the allocation of the return object, so we pass parameters\n-      --  indicating that. We don't yet handle the case where the allocation\n-      --  must be done in a user-defined storage pool, which will require\n-      --  passing another actual or two to provide allocation/deallocation\n-      --  operations. ???\n+      --  indicating that.\n \n       else\n+         Temp_Init := Empty;\n+\n          --  Case of a user-defined storage pool. Pass an allocation parameter\n          --  indicating that the function should allocate its result in the\n          --  pool, and pass the pool. Use 'Unrestricted_Access because the\n@@ -8639,36 +8633,103 @@ package body Exp_Ch6 is\n          if VM_Target = No_VM\n            and then Present (Associated_Storage_Pool (Acc_Type))\n          then\n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => User_Storage_Pool,\n-               Pool_Actual =>\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         =>\n-                     New_Occurrence_Of\n-                       (Associated_Storage_Pool (Acc_Type), Loc),\n-                   Attribute_Name => Name_Unrestricted_Access));\n+            Alloc_Form := User_Storage_Pool;\n+            Pool :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  New_Occurrence_Of\n+                    (Associated_Storage_Pool (Acc_Type), Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n \n          --  No user-defined pool; pass an allocation parameter indicating that\n          --  the function should allocate its result on the heap.\n \n          else\n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+            Alloc_Form := Global_Heap;\n+            Pool := Make_Null (No_Location);\n          end if;\n \n-         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Acc_Type);\n-\n-         Add_Task_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n-\n          --  The caller does not provide the return object in this case, so we\n          --  have to pass null for the object access actual.\n \n-         Add_Access_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Return_Object => Empty);\n+         Return_Obj_Actual := Empty;\n       end if;\n \n+      --  Declare the temp object\n+\n+      Insert_Action (Allocator,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Return_Obj_Access,\n+          Object_Definition   => New_Occurrence_Of (Acc_Type, Loc),\n+          Expression          => Temp_Init));\n+\n+      Ref_Func_Call := Make_Reference (Loc, Func_Call);\n+\n+      --  Ada 2005 (AI-251): If the type of the allocator is an interface\n+      --  then generate an implicit conversion to force displacement of the\n+      --  \"this\" pointer.\n+\n+      if Is_Interface (Designated_Type (Acc_Type)) then\n+         Rewrite\n+           (Ref_Func_Call,\n+            OK_Convert_To (Acc_Type, Ref_Func_Call));\n+      end if;\n+\n+      declare\n+         Assign : constant Node_Id :=\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Occurrence_Of (Return_Obj_Access, Loc),\n+             Expression => Ref_Func_Call);\n+         --  Assign the result of the function call into the temp. In the\n+         --  caller-allocates case, this is overwriting the temp with its\n+         --  initial value, which has no effect. In the callee-allocates case,\n+         --  this is setting the temp to point to the object allocated by the\n+         --  callee.\n+\n+         Actions : List_Id;\n+         --  Actions to be inserted. If there are no tasks, this is just the\n+         --  assignment statement. If the allocated object has tasks, we need\n+         --  to wrap the assignment in a block that activates them. The\n+         --  activation chain of that block must be passed to the function,\n+         --  rather than some outer chain.\n+      begin\n+         if Has_Task (Result_Subt) then\n+            Actions := New_List;\n+            Build_Task_Allocate_Block_With_Init_Stmts\n+              (Actions, Allocator, Init_Stmts => New_List (Assign));\n+            Chain := Activation_Chain_Entity (Last (Actions));\n+         else\n+            Actions := New_List (Assign);\n+            Chain   := Empty;\n+         end if;\n+\n+         Insert_Actions (Allocator, Actions);\n+      end;\n+\n+      --  When the function has a controlling result, an allocation-form\n+      --  parameter must be passed indicating that the caller is allocating\n+      --  the result object. This is needed because such a function can be\n+      --  called as a dispatching operation and must be treated similarly\n+      --  to functions with unconstrained result subtypes.\n+\n+      Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Alloc_Form, Pool_Actual => Pool);\n+\n+      Add_Finalization_Master_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Acc_Type);\n+\n+      Add_Task_Actuals_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type),\n+         Chain => Chain);\n+\n+      --  Add an implicit actual to the function call that provides access\n+      --  to the allocated object. An unchecked conversion to the (specific)\n+      --  result subtype of the function is inserted to handle cases where\n+      --  the access type of the allocator has a class-wide designated type.\n+\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Return_Obj_Actual);\n+\n       --  If the build-in-place function call returns a controlled object,\n       --  the finalization master will require a reference to routine\n       --  Finalize_Address of the designated type. Setting this attribute\n@@ -8696,19 +8757,9 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  Finally, replace the allocator node with a reference to the result\n-      --  of the function call itself (which will effectively be an access\n-      --  to the object created by the allocator).\n+      --  Finally, replace the allocator node with a reference to the temp\n \n-      Rewrite (Allocator, Make_Reference (Loc, Relocate_Node (Function_Call)));\n-\n-      --  Ada 2005 (AI-251): If the type of the allocator is an interface then\n-      --  generate an implicit conversion to force displacement of the \"this\"\n-      --  pointer.\n-\n-      if Is_Interface (Designated_Type (Acc_Type)) then\n-         Rewrite (Allocator, Convert_To (Acc_Type, Relocate_Node (Allocator)));\n-      end if;\n+      Rewrite (Allocator, New_Occurrence_Of (Return_Obj_Access, Loc));\n \n       Analyze_And_Resolve (Allocator, Acc_Type);\n    end Make_Build_In_Place_Call_In_Allocator;"}, {"sha": "e5ec8d5df04de77b4fcc6e0aec371b71dc4df46c", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -1490,12 +1490,11 @@ package body Inline is\n \n       function Has_Some_Contract (Id : Entity_Id) return Boolean is\n          Items : constant Node_Id := Contract (Id);\n-\n       begin\n          return Present (Items)\n-           and then (Present (Pre_Post_Conditions (Items))\n-                      or else Present (Contract_Test_Cases (Items))\n-                      or else Present (Classifications (Items)));\n+           and then (Present (Pre_Post_Conditions (Items)) or else\n+                     Present (Contract_Test_Cases (Items)) or else\n+                     Present (Classifications     (Items)));\n       end Has_Some_Contract;\n \n       --------------------------\n@@ -1559,6 +1558,10 @@ package body Inline is\n          Id := Body_Id;\n       end if;\n \n+      --  General note. The following comments clearly say what cannot be\n+      --  inlined, but they do not give any clue on the motivation for the\n+      --  exclusion. It would be good to document the motivations ???\n+\n       --  Do not inline unit-level subprograms\n \n       if Nkind (Parent (Id)) = N_Defining_Program_Unit_Name then\n@@ -1588,6 +1591,8 @@ package body Inline is\n       then\n          return False;\n \n+      --  Do not inline generic subprogram instances\n+\n       elsif Is_Generic_Instance (Spec_Id) then\n          return False;\n "}, {"sha": "a0262230cdd743b23f8c044cb1c0388b8d710fe2", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -2013,7 +2013,6 @@ package body Sem_Ch13 is\n \n                      declare\n                         Discard : Entity_Id;\n-                        pragma Warnings (Off, Discard);\n                      begin\n                         if Restricted_Profile then\n                            Discard := RTE (RE_Activate_Restricted_Tasks);"}, {"sha": "f7d79f969afb87727898f9176f447814bfa786f8", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -2169,7 +2169,7 @@ package body Sem_Ch6 is\n \n       function Body_Has_Contract return Boolean;\n       --  Check whether unanalyzed body has an aspect or pragma that may\n-      --  generate a SPARK contrac.\n+      --  generate a SPARK contract.\n \n       procedure Check_Anonymous_Return;\n       --  Ada 2005: if a function returns an access type that denotes a task,\n@@ -2363,13 +2363,13 @@ package body Sem_Ch6 is\n             while Present (A_Spec) loop\n                A := Get_Aspect_Id (Chars (Identifier (A_Spec)));\n \n-               if A = Aspect_Contract_Cases\n-                 or else A = Aspect_Depends\n-                 or else A = Aspect_Global\n-                 or else A = Aspect_Pre\n-                 or else A = Aspect_Precondition\n-                 or else A = Aspect_Post\n-                 or else A = Aspect_Postcondition\n+               if A = Aspect_Contract_Cases or else\n+                  A = Aspect_Depends        or else\n+                  A = Aspect_Global         or else\n+                  A = Aspect_Pre            or else\n+                  A = Aspect_Precondition   or else\n+                  A = Aspect_Post           or else\n+                  A = Aspect_Postcondition\n                then\n                   return True;\n                end if;\n@@ -2378,21 +2378,21 @@ package body Sem_Ch6 is\n             end loop;\n          end if;\n \n-         --  Check for pragmas that may generate a contract.\n+         --  Check for pragmas that may generate a contract\n \n          if Present (Decls) then\n             Decl := First (Decls);\n             while Present (Decl) loop\n                if Nkind (Decl) = N_Pragma then\n                   P_Id := Get_Pragma_Id (Pragma_Name (Decl));\n \n-                  if P_Id = Pragma_Contract_Cases\n-                    or else P_Id = Pragma_Depends\n-                    or else P_Id = Pragma_Global\n-                    or else P_Id = Pragma_Pre\n-                    or else P_Id = Pragma_Precondition\n-                    or else P_Id = Pragma_Post\n-                    or else P_Id = Pragma_Postcondition\n+                  if P_Id = Pragma_Contract_Cases or else\n+                     P_Id = Pragma_Depends        or else\n+                     P_Id = Pragma_Global         or else\n+                     P_Id = Pragma_Pre            or else\n+                     P_Id = Pragma_Precondition   or else\n+                     P_Id = Pragma_Post           or else\n+                     P_Id = Pragma_Postcondition\n                   then\n                      return True;\n                   end if;"}, {"sha": "964d39ccfb22554cd41122b8b4672f9fd0860473", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -236,6 +236,18 @@ package body Treepr is\n       end case;\n    end p;\n \n+   ---------\n+   -- par --\n+   ---------\n+\n+   function par (N : Union_Id) return Node_Or_Entity_Id renames p;\n+\n+   --------\n+   -- pe --\n+   --------\n+\n+   procedure pe (N : Union_Id) renames pn;\n+\n    --------\n    -- pl --\n    --------\n@@ -314,6 +326,18 @@ package body Treepr is\n       end case;\n    end pn;\n \n+   --------\n+   -- pp --\n+   --------\n+\n+   procedure pp (N : Union_Id) renames pn;\n+\n+   ---------\n+   -- ppp --\n+   ---------\n+\n+   procedure ppp (N : Union_Id) renames pt;\n+\n    ----------------\n    -- Print_Char --\n    ----------------"}, {"sha": "6ba58d6b2b26a0c05e145841f6dad573f7108a88", "filename": "gcc/ada/treepr.ads", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Ftreepr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399d355cb74c0de280637c1ce678df71f4adb38/gcc%2Fada%2Ftreepr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.ads?ref=1399d355cb74c0de280637c1ce678df71f4adb38", "patch": "@@ -60,22 +60,33 @@ package Treepr is\n    --  Prints the subtree consisting of the given element list and all its\n    --  referenced descendants.\n \n-   --  The following debugging procedures are intended to be called from gdb\n+   --  The following debugging procedures are intended to be called from gdb.\n+   --  Note that in several cases there are synonyms which represent historical\n+   --  development, and we keep them because some people are used to them!\n \n-   function p (N : Union_Id) return Node_Or_Entity_Id;\n+   function p   (N : Union_Id) return Node_Or_Entity_Id;\n+   function par (N : Union_Id) return Node_Or_Entity_Id;\n    pragma Export (Ada, p);\n-   --  Returns parent of a list or node (depending on the value of N). If N\n+   pragma Export (Ada, par);\n+   --  Return parent of a list or node (depending on the value of N). If N\n    --  is neither a list nor a node id, then prints a message to that effect\n    --  and returns Empty.\n \n    procedure pn (N : Union_Id);\n-   --  Prints a node, node list, uint, or anything else that falls under\n+   procedure pp (N : Union_Id);\n+   procedure pe (N : Union_Id);\n+   pragma Export (Ada, pn);\n+   pragma Export (Ada, pp);\n+   pragma Export (Ada, pe);\n+   --  Print a node, node list, uint, or anything else that falls under\n    --  the definition of Union_Id. Historically this was only for printing\n    --  nodes, hence the name.\n \n-   procedure pt (N : Union_Id);\n+   procedure pt  (N : Union_Id);\n+   procedure ppp (N : Union_Id);\n    pragma Export (Ada, pt);\n-   --  Same as pn, except prints subtrees. For Nodes, it is exactly the same\n+   pragma Export (Ada, ppp);\n+   --  Same as pn/pp, except prints subtrees. For Nodes, it is exactly the same\n    --  as Print_Node_Subtree. For Elists it is the same as Print_Elist_Subtree.\n    --  For Lists, it is the same as Print_Tree_List. If given anything other\n    --  than a Node, List, or Elist, same effect as pn.\n@@ -87,9 +98,4 @@ package Treepr is\n    --  on the left and add a minus sign. This just saves some typing in the\n    --  debugger.\n \n-   procedure pe  (N : Union_Id) renames pt;\n-   procedure pp  (N : Union_Id) renames pn;\n-   procedure ppp (N : Union_Id) renames pt;\n-   --  Synonyms retained for historical reasons\n-\n end Treepr;"}]}