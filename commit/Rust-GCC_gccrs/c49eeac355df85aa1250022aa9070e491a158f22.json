{"sha": "c49eeac355df85aa1250022aa9070e491a158f22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5ZWVhYzM1NWRmODVhYTEyNTAwMjJhYTkwNzBlNDkxYTE1OGYyMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-12T11:59:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-12T11:59:32Z"}, "message": "tree-vrp.h (value_range_base::symbolic_p, [...]): Move from value_range.\n\n2018-11-12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.h (value_range_base::symbolic_p,\n\tvalue_range_base::constant_p, value_range_base::zero_p,\n\tvalue_range_base::singleton_p): Move from value_range.\n\t(value_range::dump): Add.\n\t* gimple-ssa-evrp-analyze.c\n\t(evrp_range_analyzer::record_ranges_from_phis): Use set_varying.\n\t* ipa-cp.c (ipcp_vr_lattice::print): Use dump_value_range.\n\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n\tUse set_varying.\n\t* tree-vrp.c (value_range::symbolic_p): Move to value_range_base.\n\t(value_range::constant_p): Likewise.\n\t(value_range::singleton_p): Likewise.\n\t(value_range_base::dump): Add.\n\t(set_value_range_to_undefined): Remove.\n\t(set_value_range_to_varying): Likewise.\n\t(range_int_cst_p): Take value_range_base argument.\n\t(range_int_cst_singleton_p): Likewise.\n\t(value_range_constant_singleton): Likewise.\n\t(vrp_set_zero_nonzero_bits): Likewise.\n\t(extract_range_from_multiplicative_op): Use set_varying.\n\t(extract_range_from_binary_expr_1): Likewise. Use set_undefined.\n\t(extract_range_from_unary_expr): Likewise.\n\t(dump_value_range_base): Change to overload of dump_value_range.\n\t(vrp_prop::vrp_initialize): Use set_varying and set_undefined.\n\t(vrp_prop::visit_stmt): Likewise.\n\t(value_range::intersect_helper): Likewise.\n\t(value_range::union_helper): Likewise.\n\t(determine_value_range_1): Likewise.\n\nFrom-SVN: r266028", "tree": {"sha": "43f8a48a66677e82b78b09705006724d94256ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f8a48a66677e82b78b09705006724d94256ac0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c49eeac355df85aa1250022aa9070e491a158f22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49eeac355df85aa1250022aa9070e491a158f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49eeac355df85aa1250022aa9070e491a158f22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49eeac355df85aa1250022aa9070e491a158f22/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bdfac905dab78abf4ae4d652919fefc3b669eb52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfac905dab78abf4ae4d652919fefc3b669eb52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdfac905dab78abf4ae4d652919fefc3b669eb52"}], "stats": {"total": 276, "additions": 153, "deletions": 123}, "files": [{"sha": "47571e4390a06e799d51713571f7bdb211c1777c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -1,3 +1,34 @@\n+2018-11-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.h (value_range_base::symbolic_p,\n+\tvalue_range_base::constant_p, value_range_base::zero_p,\n+\tvalue_range_base::singleton_p): Move from value_range.\n+\t(value_range::dump): Add.\n+\t* gimple-ssa-evrp-analyze.c\n+\t(evrp_range_analyzer::record_ranges_from_phis): Use set_varying.\n+\t* ipa-cp.c (ipcp_vr_lattice::print): Use dump_value_range.\n+\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n+\tUse set_varying.\n+\t* tree-vrp.c (value_range::symbolic_p): Move to value_range_base.\n+\t(value_range::constant_p): Likewise.\n+\t(value_range::singleton_p): Likewise.\n+\t(value_range_base::dump): Add.\n+\t(set_value_range_to_undefined): Remove.\n+\t(set_value_range_to_varying): Likewise.\n+\t(range_int_cst_p): Take value_range_base argument.\n+\t(range_int_cst_singleton_p): Likewise.\n+\t(value_range_constant_singleton): Likewise.\n+\t(vrp_set_zero_nonzero_bits): Likewise.\n+\t(extract_range_from_multiplicative_op): Use set_varying.\n+\t(extract_range_from_binary_expr_1): Likewise. Use set_undefined.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(dump_value_range_base): Change to overload of dump_value_range.\n+\t(vrp_prop::vrp_initialize): Use set_varying and set_undefined.\n+\t(vrp_prop::visit_stmt): Likewise.\n+\t(value_range::intersect_helper): Likewise.\n+\t(value_range::union_helper): Likewise.\n+\t(determine_value_range_1): Likewise.\n+\n 2018-11-12  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (set_value_range_to_nonnull): Clear equiv."}, {"sha": "1cd13dda7b69b19f2d116e0b97cca2c70fd519a8", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -252,7 +252,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \tvr_values->extract_range_from_phi_node (phi, &vr_result);\n       else\n \t{\n-\t  set_value_range_to_varying (&vr_result);\n+\t  vr_result.set_varying ();\n \t  /* When we have an unvisited executable predecessor we can't\n \t     use PHI arg ranges which may be still UNDEFINED but have\n \t     to use VARYING for them.  But we can still resort to"}, {"sha": "882c8975ff4c3f670a23b2e7add3fb1ab95f3ceb", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -522,7 +522,7 @@ ipcp_bits_lattice::print (FILE *f)\n void\n ipcp_vr_lattice::print (FILE * f)\n {\n-  dump_value_range_base (f, &m_vr);\n+  dump_value_range (f, &m_vr);\n }\n \n /* Print all ipcp_lattices of all functions to F.  */"}, {"sha": "3494ee90b586e38a012d147e2e5499e62f308b9a", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -183,7 +183,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n \t    set_value_range_to_value (new_vr, src,  NULL);\n \t  else\n-\t    set_value_range_to_varying (new_vr);\n+\t    new_vr->set_varying ();\n \n \t  /* This is a temporary range for DST, so push it.  */\n \t  evrp_range_analyzer->push_value_range (dst, new_vr);"}, {"sha": "f5e0d03099edfeccde59f3268c4c557b66aec000", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 62, "deletions": 69, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -237,7 +237,7 @@ value_range::operator!= (const value_range &other) const\n /* Return TRUE if this is a symbolic range.  */\n \n bool\n-value_range::symbolic_p () const\n+value_range_base::symbolic_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n@@ -251,7 +251,7 @@ value_range::symbolic_p () const\n    constants would be represented as [-MIN, +MAX].  */\n \n bool\n-value_range::constant_p () const\n+value_range_base::constant_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n@@ -336,7 +336,7 @@ value_range::equiv_add (const_tree var,\n    So, [&x, &x] counts as a singleton.  */\n \n bool\n-value_range::singleton_p (tree *result) const\n+value_range_base::singleton_p (tree *result) const\n {\n   if (m_kind == VR_RANGE\n       && vrp_operand_equal_p (min (), max ())\n@@ -417,6 +417,13 @@ value_range::dump (FILE *file) const\n     }\n }\n \n+void\n+value_range_base::dump () const\n+{\n+  dump_value_range (stderr, this);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n void\n value_range::dump () const\n {\n@@ -591,22 +598,6 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n   return vr_type;\n }\n \n-/* Set value range VR to VR_UNDEFINED.  */\n-\n-static inline void\n-set_value_range_to_undefined (value_range *vr)\n-{\n-  vr->set_undefined ();\n-}\n-\n-/* Set value range VR to VR_VARYING.  */\n-\n-void\n-set_value_range_to_varying (value_range *vr)\n-{\n-  vr->set_varying ();\n-}\n-\n /* Set value range VR to {T, MIN, MAX, EQUIV}.  */\n \n void\n@@ -823,7 +814,7 @@ range_is_nonnull (const value_range *vr)\n    a singleton.  */\n \n bool\n-range_int_cst_p (const value_range *vr)\n+range_int_cst_p (const value_range_base *vr)\n {\n   return (vr->kind () == VR_RANGE\n \t  && TREE_CODE (vr->min ()) == INTEGER_CST\n@@ -833,7 +824,7 @@ range_int_cst_p (const value_range *vr)\n /* Return true if VR is a INTEGER_CST singleton.  */\n \n bool\n-range_int_cst_singleton_p (const value_range *vr)\n+range_int_cst_singleton_p (const value_range_base *vr)\n {\n   return (range_int_cst_p (vr)\n \t  && tree_int_cst_equal (vr->min (), vr->max ()));\n@@ -1164,7 +1155,7 @@ range_includes_zero_p (const value_range_base *vr)\n    is not the best name.  */\n \n tree\n-value_range_constant_singleton (const value_range *vr)\n+value_range_constant_singleton (const value_range_base *vr)\n {\n   tree result = NULL;\n   if (vr->singleton_p (&result))\n@@ -1181,7 +1172,7 @@ value_range_constant_singleton (const value_range *vr)\n \n bool\n vrp_set_zero_nonzero_bits (const tree expr_type,\n-\t\t\t   const value_range *vr,\n+\t\t\t   const value_range_base *vr,\n \t\t\t   wide_int *may_be_nonzero,\n \t\t\t   wide_int *must_be_nonzero)\n {\n@@ -1301,7 +1292,7 @@ extract_range_from_multiplicative_op (value_range *vr,\n \t\t\t      wide_int_to_tree (type, res_lb),\n \t\t\t      wide_int_to_tree (type, res_ub), NULL);\n   else\n-    set_value_range_to_varying (vr);\n+    vr->set_varying ();\n }\n \n /* If BOUND will include a symbolic bound, adjust it accordingly,\n@@ -1510,7 +1501,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   if (!INTEGRAL_TYPE_P (expr_type)\n       && !POINTER_TYPE_P (expr_type))\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n@@ -1534,24 +1525,24 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       && code != BIT_IOR_EXPR\n       && code != BIT_XOR_EXPR)\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n   /* If both ranges are UNDEFINED, so is the result.  */\n   if (vr0.undefined_p () && vr1.undefined_p ())\n     {\n-      set_value_range_to_undefined (vr);\n+      vr->set_undefined ();\n       return;\n     }\n   /* If one of the ranges is UNDEFINED drop it to VARYING for the following\n      code.  At some point we may want to special-case operations that\n      have UNDEFINED result for all or some value-ranges of the not UNDEFINED\n      operand.  */\n   else if (vr0.undefined_p ())\n-    set_value_range_to_varying (&vr0);\n+    vr0.set_varying ();\n   else if (vr1.undefined_p ())\n-    set_value_range_to_varying (&vr1);\n+    vr1.set_varying ();\n \n   /* We get imprecise results from ranges_from_anti_range when\n      code is EXACT_DIV_EXPR.  We could mask out bits in the resulting\n@@ -1622,7 +1613,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  || vr0.symbolic_p ()\n \t  || vr1.symbolic_p ()))\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n@@ -1640,7 +1631,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n \t    set_value_range_to_null (vr, expr_type);\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t}\n       else if (code == POINTER_PLUS_EXPR)\n \t{\n@@ -1652,7 +1643,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n \t    set_value_range_to_null (vr, expr_type);\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t}\n       else if (code == BIT_AND_EXPR)\n \t{\n@@ -1663,10 +1654,10 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  else if (range_is_null (&vr0) || range_is_null (&vr1))\n \t    set_value_range_to_null (vr, expr_type);\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t}\n       else\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n \n       return;\n     }\n@@ -1737,7 +1728,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  if (((bool)min_ovf && sym_min_op0 != sym_min_op1)\n \t      || ((bool)max_ovf && sym_max_op0 != sym_max_op1))\n \t    {\n-\t      set_value_range_to_varying (vr);\n+\t      vr->set_varying ();\n \t      return;\n \t    }\n \n@@ -1748,7 +1739,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t\t\t\t wmin, wmax, min_ovf, max_ovf);\n \t  if (type == VR_VARYING)\n \t    {\n-\t      set_value_range_to_varying (vr);\n+\t      vr->set_varying ();\n \t      return;\n \t    }\n \n@@ -1774,7 +1765,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t     a single range or anti-range as the above is\n \t\t [-INF+1, +INF(OVF)] intersected with ~[5, 5]\n \t     but one could use a scheme similar to equivalences for this. */\n-\t  set_value_range_to_varying (vr);\n+\t  vr->set_varying ();\n \t  return;\n \t}\n     }\n@@ -1791,15 +1782,15 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \tvr->update (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n \t\t    wide_int_to_tree (expr_type, wmax));\n       else\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n       return;\n     }\n   else if (code == MULT_EXPR)\n     {\n       if (!range_int_cst_p (&vr0)\n \t  || !range_int_cst_p (&vr1))\n \t{\n-\t  set_value_range_to_varying (vr);\n+\t  vr->set_varying ();\n \t  return;\n \t}\n       extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n@@ -1845,7 +1836,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t}\n \t    }\n \t}\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n   else if (code == TRUNC_DIV_EXPR\n@@ -1861,7 +1852,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       /* Special case explicit division by zero as undefined.  */\n       if (range_is_null (&vr1))\n \t{\n-\t  set_value_range_to_undefined (vr);\n+\t  vr->set_undefined ();\n \t  return;\n \t}\n \n@@ -1882,7 +1873,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t\t       TYPE_OVERFLOW_UNDEFINED (expr_type),\n \t\t\t       extra_range_p, extra_min, extra_max))\n \t{\n-\t  set_value_range_to_varying (vr);\n+\t  vr->set_undefined ();\n \t  return;\n \t}\n       set_value_range (vr, VR_RANGE,\n@@ -1902,7 +1893,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     {\n       if (range_is_null (&vr1))\n \t{\n-\t  set_value_range_to_undefined (vr);\n+\t  vr->set_undefined ();\n \t  return;\n \t}\n       wide_int wmin, wmax, tmp;\n@@ -1943,7 +1934,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      set_value_range (vr, VR_RANGE, min, max, NULL);\n \t    }\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t  return;\n \t}\n       else if (code == BIT_IOR_EXPR)\n@@ -1961,7 +1952,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      set_value_range (vr, VR_RANGE, min, max, NULL);\n \t    }\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t  return;\n \t}\n       else if (code == BIT_XOR_EXPR)\n@@ -1977,7 +1968,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      set_value_range (vr, VR_RANGE, min, max, NULL);\n \t    }\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t  return;\n \t}\n     }\n@@ -1991,7 +1982,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       || max == NULL_TREE\n       || TREE_OVERFLOW_P (max))\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n@@ -2000,7 +1991,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n      Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n   if (vrp_val_is_min (min) && vrp_val_is_max (max))\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n@@ -2010,7 +2001,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       /* If the new range has its limits swapped around (MIN > MAX),\n \t then the operation caused one of them to wrap around, mark\n \t the new range VARYING.  */\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n     }\n   else\n     set_value_range (vr, type, min, max, NULL);\n@@ -2036,14 +2027,14 @@ extract_range_from_unary_expr (value_range *vr,\n       || !(INTEGRAL_TYPE_P (type)\n \t   || POINTER_TYPE_P (type)))\n     {\n-      set_value_range_to_varying (vr);\n+      vr->set_varying ();\n       return;\n     }\n \n   /* If VR0 is UNDEFINED, so is the result.  */\n   if (vr0.undefined_p ())\n     {\n-      set_value_range_to_undefined (vr);\n+      vr->set_undefined ();\n       return;\n     }\n \n@@ -2109,7 +2100,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t  else if (range_is_null (&vr0))\n \t    set_value_range_to_null (vr, type);\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t  return;\n \t}\n \n@@ -2144,7 +2135,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t  vr->set_and_canonicalize (VR_RANGE, min, max, NULL);\n \t}\n       else\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n       return;\n     }\n   else if (code == ABS_EXPR)\n@@ -2158,23 +2149,17 @@ extract_range_from_unary_expr (value_range *vr,\n \t\t\t wide_int_to_tree (type, wmin),\n \t\t\t wide_int_to_tree (type, wmax), NULL);\n       else\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n       return;\n     }\n \n   /* For unhandled operations fall back to varying.  */\n-  set_value_range_to_varying (vr);\n+  vr->set_varying ();\n   return;\n }\n \n /* Debugging dumps.  */\n \n-void dump_value_range (FILE *, const value_range *);\n-void debug_value_range (const value_range *);\n-void dump_all_value_ranges (FILE *);\n-void dump_vr_equiv (FILE *, bitmap);\n-void debug_vr_equiv (bitmap);\n-\n void\n dump_value_range (FILE *file, const value_range *vr)\n {\n@@ -2185,7 +2170,7 @@ dump_value_range (FILE *file, const value_range *vr)\n }\n \n void\n-dump_value_range_base (FILE *file, const value_range_base *vr)\n+dump_value_range (FILE *file, const value_range_base *vr)\n {\n   if (!vr)\n     fprintf (file, \"[]\");\n@@ -2195,10 +2180,18 @@ dump_value_range_base (FILE *file, const value_range_base *vr)\n \n /* Dump value range VR to stderr.  */\n \n+DEBUG_FUNCTION void\n+debug_value_range (const value_range_base *vr)\n+{\n+  dump_value_range (stderr, vr);\n+}\n+\n+/* Dump value range VR to stderr.  */\n+\n DEBUG_FUNCTION void\n debug_value_range (const value_range *vr)\n {\n-  vr->dump ();\n+  dump_value_range (stderr, vr);\n }\n \n \n@@ -5161,7 +5154,7 @@ vrp_prop::vrp_initialize ()\n \t  if (!stmt_interesting_for_vrp (phi))\n \t    {\n \t      tree lhs = PHI_RESULT (phi);\n-\t      set_value_range_to_varying (get_value_range (lhs));\n+\t      get_value_range (lhs)->set_varying ();\n \t      prop_set_simulate_again (phi, false);\n \t    }\n \t  else\n@@ -5356,7 +5349,7 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t    use_operand_p use_p;\n \t    enum ssa_prop_result res = SSA_PROP_VARYING;\n \n-\t    set_value_range_to_varying (get_value_range (lhs));\n+\t    get_value_range (lhs)->set_varying ();\n \n \t    FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n \t      {\n@@ -6027,7 +6020,7 @@ value_range::intersect_helper (value_range *vr0, const value_range *vr1)\n     return;\n   if (vr1->undefined_p ())\n     {\n-      set_value_range_to_undefined (vr0);\n+      vr0->set_undefined ();\n       return;\n     }\n \n@@ -6171,7 +6164,7 @@ value_range::union_helper (value_range *vr0, const value_range *vr1)\n \n   if (vr1->varying_p ())\n     {\n-      set_value_range_to_varying (vr0);\n+      vr0->set_varying ();\n       return;\n     }\n \n@@ -6199,7 +6192,7 @@ value_range::union_helper (value_range *vr0, const value_range *vr1)\n \t  return;\n \t}\n \n-      set_value_range_to_varying (vr0);\n+      vr0->set_varying ();\n       return;\n     }\n   vr0->set_and_canonicalize (vr0->kind (), vr0->min (), vr0->max (),\n@@ -6908,7 +6901,7 @@ determine_value_range_1 (value_range *vr, tree expr)\n \tset_value_range (vr, kind, wide_int_to_tree (TREE_TYPE (expr), min),\n \t\t\t wide_int_to_tree (TREE_TYPE (expr), max), NULL);\n       else\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n     }\n }\n "}, {"sha": "8130cb85f278dbf1e761f5a7157779c11eb3e2d7", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -49,22 +49,26 @@ class GTY((for_user)) value_range_base\n   tree max () const;\n \n   /* Types of value ranges.  */\n+  bool symbolic_p () const;\n+  bool constant_p () const;\n   bool undefined_p () const;\n   bool varying_p () const;\n+  void set_varying ();\n+  void set_undefined ();\n \n   void union_ (const value_range_base *);\n \n   bool ignore_equivs_equal_p (const value_range_base &) const;\n \n-  void set_varying ();\n-  void set_undefined ();\n-\n   /* Misc methods.  */\n   tree type () const;\n   bool may_contain_p (tree) const;\n   void set_and_canonicalize (enum value_range_kind, tree, tree);\n+  bool zero_p () const;\n+  bool singleton_p (tree *result = NULL) const;\n \n   void dump (FILE *) const;\n+  void dump () const;\n \n protected:\n   void set (value_range_kind, tree, tree);\n@@ -100,8 +104,6 @@ class GTY((user)) value_range : public value_range_base\n   void union_ (const value_range *);\n \n   /* Types of value ranges.  */\n-  bool symbolic_p () const;\n-  bool constant_p () const;\n   void set_undefined ();\n   void set_varying ();\n \n@@ -111,8 +113,6 @@ class GTY((user)) value_range : public value_range_base\n   void equiv_add (const_tree, const value_range *, bitmap_obstack * = NULL);\n \n   /* Misc methods.  */\n-  bool zero_p () const;\n-  bool singleton_p (tree *result = NULL) const;\n   void deep_copy (const value_range *);\n   void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap);\n   void dump (FILE *) const;\n@@ -194,24 +194,15 @@ value_range_base::undefined_p () const\n /* Return TRUE if range is the constant zero.  */\n \n inline bool\n-value_range::zero_p () const\n+value_range_base::zero_p () const\n {\n   return (m_kind == VR_RANGE\n \t  && integer_zerop (m_min)\n \t  && integer_zerop (m_max));\n }\n \n extern void dump_value_range (FILE *, const value_range *);\n-extern void dump_value_range_base (FILE *, const value_range_base *);\n-extern void extract_range_from_unary_expr (value_range *vr,\n-\t\t\t\t\t   enum tree_code code,\n-\t\t\t\t\t   tree type,\n-\t\t\t\t\t   const value_range *vr0_,\n-\t\t\t\t\t   tree op0_type);\n-\n-extern bool vrp_operand_equal_p (const_tree, const_tree);\n-extern enum value_range_kind intersect_range_with_nonzero_bits\n-  (enum value_range_kind, wide_int *, wide_int *, const wide_int &, signop);\n+extern void dump_value_range (FILE *, const value_range_base *);\n \n struct assert_info\n {\n@@ -231,36 +222,51 @@ struct assert_info\n extern void register_edge_assert_for (tree, edge, enum tree_code,\n \t\t\t\t      tree, tree, vec<assert_info> &);\n extern bool stmt_interesting_for_vrp (gimple *);\n-extern void set_value_range_to_varying (value_range *);\n extern bool range_includes_zero_p (const value_range_base *);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n extern void set_value_range_to_nonnull (value_range *, tree);\n+extern void set_value_range_to_null (value_range *, tree);\n extern void set_value_range (value_range *, enum value_range_kind, tree,\n \t\t\t     tree, bitmap);\n+extern void set_value_range_to_value (value_range *, tree, bitmap);\n+\n extern bool vrp_bitmap_equal_p (const_bitmap, const_bitmap);\n-extern tree value_range_constant_singleton (const value_range *);\n+\n+extern tree value_range_constant_singleton (const value_range_base *);\n+extern bool range_int_cst_p (const value_range_base *);\n+extern bool range_int_cst_singleton_p (const value_range_base *);\n+\n extern int compare_values (tree, tree);\n extern int compare_values_warnv (tree, tree, bool *);\n+extern int operand_less_p (tree, tree);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n-extern void set_value_range_to_value (value_range *, tree, bitmap);\n+extern int value_inside_range (tree, tree, tree);\n+\n+extern tree vrp_val_min (const_tree);\n+extern tree vrp_val_max (const_tree);\n+\n+extern void extract_range_from_unary_expr (value_range *vr,\n+\t\t\t\t\t   enum tree_code code,\n+\t\t\t\t\t   tree type,\n+\t\t\t\t\t   const value_range *vr0_,\n+\t\t\t\t\t   tree op0_type);\n extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n \t\t\t\t\t      tree, const value_range *,\n \t\t\t\t\t      const value_range *);\n-extern tree vrp_val_min (const_tree);\n-extern tree vrp_val_max (const_tree);\n-extern void set_value_range_to_null (value_range *, tree);\n-extern bool range_int_cst_p (const value_range *);\n-extern int operand_less_p (tree, tree);\n+\n+extern bool vrp_operand_equal_p (const_tree, const_tree);\n+extern enum value_range_kind intersect_range_with_nonzero_bits\n+  (enum value_range_kind, wide_int *, wide_int *, const wide_int &, signop);\n+extern bool vrp_set_zero_nonzero_bits (const tree, const value_range_base *,\n+\t\t\t\t       wide_int *, wide_int *);\n+\n extern bool find_case_label_range (gswitch *, tree, tree, size_t *, size_t *);\n extern bool find_case_label_index (gswitch *, size_t, tree, size_t *);\n-extern bool vrp_set_zero_nonzero_bits (const tree, const value_range *,\n-\t\t\t\t       wide_int *, wide_int *);\n extern bool overflow_comparison_p (tree_code, tree, tree, bool, tree *);\n-extern bool range_int_cst_singleton_p (const value_range *);\n-extern int value_inside_range (tree, tree, tree);\n extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n+\n #endif /* GCC_TREE_VRP_H */"}, {"sha": "1ffb9f6c92c80f715277eeb687402b4ee0a9740c", "filename": "gcc/vr-values.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49eeac355df85aa1250022aa9070e491a158f22/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=c49eeac355df85aa1250022aa9070e491a158f22", "patch": "@@ -64,7 +64,7 @@ static inline void\n set_value_range_to_truthvalue (value_range *vr, tree type)\n {\n   if (TYPE_PRECISION (type) == 1)\n-    set_value_range_to_varying (vr);\n+    vr->set_varying ();\n   else\n     vr->update (VR_RANGE, build_int_cst (type, 0), build_int_cst (type, 1));\n }\n@@ -126,7 +126,7 @@ vr_values::get_value_range (const_tree var)\n \t\tvr->set_varying ();\n \t    }\n \t  else\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t}\n       else if (TREE_CODE (sym) == RESULT_DECL\n \t       && DECL_BY_REFERENCE (sym))\n@@ -148,7 +148,7 @@ vr_values::set_defs_to_varying (gimple *stmt)\n       value_range *vr = get_value_range (def);\n       /* Avoid writing to vr_const_varying get_value_range may return.  */\n       if (!vr->varying_p ())\n-\tset_value_range_to_varying (vr);\n+\tvr->set_varying ();\n     }\n }\n \n@@ -192,8 +192,8 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n \t called.  */\n       if (new_vr->undefined_p ())\n \t{\n-\t  set_value_range_to_varying (old_vr);\n-\t  set_value_range_to_varying (new_vr);\n+\t  old_vr->set_varying ();\n+\t  new_vr->set_varying ();\n \t  return true;\n \t}\n       else\n@@ -387,7 +387,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n   if ((POINTER_TYPE_P (type) && cond_code != NE_EXPR && cond_code != EQ_EXPR)\n       || limit == var)\n     {\n-      set_value_range_to_varying (vr_p);\n+      vr_p->set_varying ();\n       return;\n     }\n \n@@ -547,7 +547,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t all should be optimized away above us.  */\n       if (cond_code == LT_EXPR\n \t  && compare_values (max, min) == 0)\n-\tset_value_range_to_varying (vr_p);\n+\tvr_p->set_varying ();\n       else\n \t{\n \t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n@@ -587,7 +587,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t all should be optimized away above us.  */\n       if (cond_code == GT_EXPR\n \t  && compare_values (min, max) == 0)\n-\tset_value_range_to_varying (vr_p);\n+\tvr_p->set_varying ();\n       else\n \t{\n \t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n@@ -694,14 +694,14 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n-    set_value_range_to_varying (&vr0);\n+    vr0.set_varying ();\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n     set_value_range_to_value (&vr1, op1, NULL);\n   else\n-    set_value_range_to_varying (&vr1);\n+    vr1.set_varying ();\n \n   /* If one argument is varying, we can sometimes still deduce a\n      range for the output: any + [3, +INF] is in [MIN+3, +INF].  */\n@@ -839,7 +839,7 @@ vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n-    set_value_range_to_varying (&vr0);\n+    vr0.set_varying ();\n \n   ::extract_range_from_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n }\n@@ -860,7 +860,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n-    set_value_range_to_varying (&vr0);\n+    vr0.set_varying ();\n \n   tree op1 = gimple_assign_rhs3 (stmt);\n   value_range vr1;\n@@ -869,7 +869,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n   else if (is_gimple_min_invariant (op1))\n     set_value_range_to_value (&vr1, op1, NULL);\n   else\n-    set_value_range_to_varying (&vr1);\n+    vr1.set_varying ();\n \n   /* The resulting value range is the union of the operand ranges */\n   vr->deep_copy (&vr0);\n@@ -921,14 +921,14 @@ vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n   else if (TREE_CODE (op0) == INTEGER_CST)\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n-    set_value_range_to_varying (&vr0);\n+    vr0.set_varying ();\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *get_value_range (op1);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n     set_value_range_to_value (&vr1, op1, NULL);\n   else\n-    set_value_range_to_varying (&vr1);\n+    vr1.set_varying ();\n \n   tree vr0min = vr0.min (), vr0max = vr0.max ();\n   tree vr1min = vr1.min (), vr1max = vr1.max ();\n@@ -1256,7 +1256,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t  if (vr->kind () == VR_RANGE\n \t      && (vr->min () == vr->max ()\n \t\t  || operand_equal_p (vr->min (), vr->max (), 0)))\n-\t    set_value_range_to_varying (vr);\n+\t    vr->set_varying ();\n \t  return;\n \t}\n     }\n@@ -1314,7 +1314,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t\t\t\t\t  NULL);\n \t\t      else if (TYPE_PRECISION (type) == 1\n \t\t\t       && !TYPE_UNSIGNED (type))\n-\t\t\tset_value_range_to_varying (vr);\n+\t\t\tvr->set_varying ();\n \t\t      else\n \t\t\tset_value_range (vr, VR_RANGE, build_int_cst (type, 0),\n \t\t\t\t\t build_int_cst (type, 1), NULL);\n@@ -1356,7 +1356,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n   else if (vrp_stmt_computes_nonzero (stmt))\n     set_value_range_to_nonnull (vr, type);\n   else\n-    set_value_range_to_varying (vr);\n+    vr->set_varying ();\n }\n \n \n@@ -1392,7 +1392,7 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n \t   && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n     set_value_range_to_value (vr, gimple_assign_rhs1 (stmt), NULL);\n   else\n-    set_value_range_to_varying (vr);\n+    vr->set_varying ();\n \n   if (vr->varying_p ())\n     extract_range_basic (vr, stmt);\n@@ -2875,7 +2875,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n   goto update_range;\n \n varying:\n-  set_value_range_to_varying (vr_result);\n+  vr_result->set_varying ();\n \n scev_check:\n   /* If this is a loop PHI node SCEV may known more about its value-range.\n@@ -2896,7 +2896,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t   || compare_values (vr_result->min (), vr_result->max ()) > 0))\n     ;\n   else\n-    set_value_range_to_varying (vr_result);\n+    vr_result->set_varying ();\n \n   /* If the new range is different than the previous value, keep\n      iterating.  */"}]}