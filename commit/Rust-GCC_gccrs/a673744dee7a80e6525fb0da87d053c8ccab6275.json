{"sha": "a673744dee7a80e6525fb0da87d053c8ccab6275", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY3Mzc0NGRlZTdhODBlNjUyNWZiMGRhODdkMDUzYzhjY2FiNjI3NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-13T09:42:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-13T11:35:11Z"}, "message": "Remove STMT_VINFO_SAME_ALIGN_REFS\n\nThis makes the only consumer of STMT_VINFO_SAME_ALIGN_REFS, the\nloop peeling for alignment code, use locally computed data and\nthen removes STMT_VINFO_SAME_ALIGN_REFS and its computation.\n\nIt also adjusts the auto_vec<> move CTOR/assignment so you\ncan write\n\n  auto_vec<..> foo = bar.copy ();\n\nand have foo own the generated copy.\n\n2020-10-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97382\n\t* tree-vectorizer.h (_stmt_vec_info::same_align_refs): Remove.\n\t(STMT_VINFO_SAME_ALIGN_REFS): Likewise.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Do not\n\tallocate STMT_VINFO_SAME_ALIGN_REFS.\n\t(vec_info::free_stmt_vec_info): Do not release\n\tSTMT_VINFO_SAME_ALIGN_REFS.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n\tDo not compute self and read-read dependences.\n\t(vect_dr_aligned_if_related_peeled_dr_is): New helper.\n\t(vect_dr_aligned_if_peeled_dr_is): Likewise.\n\t(vect_update_misalignment_for_peel): Use it instead of\n\titerating over STMT_VINFO_SAME_ALIGN_REFS.\n\t(dr_align_group_sort_cmp): New function.\n\t(vect_enhance_data_refs_alignment): Count the number of\n\tsame aligned refs here and elide uses of STMT_VINFO_SAME_ALIGN_REFS.\n\t(vect_find_same_alignment_drs): Remove.\n\t(vect_analyze_data_refs_alignment): Do not call it.\n\t* vec.h (auto_vec<T, 0>::auto_vec): Adjust CTOR to take\n\ta vec<>&&, assert it isn't using auto storage.\n\t(auto_vec& operator=): Apply a similar change.\n\n\t* gcc.dg/vect/no-vfa-vect-dv-2.c: Remove same align dump\n\tscanning.\n\t* gcc.dg/vect/vect-103.c: Likewise.\n\t* gcc.dg/vect/vect-91.c: Likewise.\n\t* gfortran.dg/vect/vect-4.f90: Likewise.", "tree": {"sha": "e7a3608db67dfd55be77428841e045d71cc940b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7a3608db67dfd55be77428841e045d71cc940b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a673744dee7a80e6525fb0da87d053c8ccab6275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a673744dee7a80e6525fb0da87d053c8ccab6275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a673744dee7a80e6525fb0da87d053c8ccab6275", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a673744dee7a80e6525fb0da87d053c8ccab6275/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35103c6d8e3ee24a2497888bb1f7ef37327ace2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35103c6d8e3ee24a2497888bb1f7ef37327ace2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35103c6d8e3ee24a2497888bb1f7ef37327ace2b"}], "stats": {"total": 253, "additions": 143, "deletions": 110}, "files": [{"sha": "8cc69ab22c5ab7cc193eeba1aa50365db640b254", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-vect-dv-2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-vect-dv-2.c?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -75,5 +75,3 @@ int main ()\n \n /* The initialization induction loop (with aligned access) is also vectorized.  */\n /* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */"}, {"sha": "d03562f7cddd0890e3e159fbdc7c5d629b54d58c", "filename": "gcc/testsuite/gcc.dg/vect/vect-103.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -58,5 +58,3 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment\" 1 \"vect\" } } */\n-"}, {"sha": "8983c7da8703620f6c849bf3dcc4bfe73ac4d0e5", "filename": "gcc/testsuite/gcc.dg/vect/vect-91.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -68,6 +68,4 @@ main3 ()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { xfail vect_no_int_add } } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 3 \"vect\" { target { { vect_aligned_arrays } && {! vect_sizes_32B_16B} } } } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" { target { {! vect_aligned_arrays } && {vect_sizes_32B_16B} } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */"}, {"sha": "9c067c69cf3eae7bbd9be0f11c70db12b737d394", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -13,4 +13,3 @@ SUBROUTINE SAXPY(X, Y, A)\n END\n \n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } \n-! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" } }"}, {"sha": "4abd27e4c70c707e12514c8775485b7ddb47943f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 139, "deletions": 94, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -589,12 +589,11 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n       LOOP_VINFO_DDRS (loop_vinfo)\n \t.create (LOOP_VINFO_DATAREFS (loop_vinfo).length ()\n \t\t * LOOP_VINFO_DATAREFS (loop_vinfo).length ());\n-      /* We need read-read dependences to compute\n-\t STMT_VINFO_SAME_ALIGN_REFS.  */\n+      /* We do not need read-read dependences.  */\n       bool res = compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n \t\t\t\t\t  &LOOP_VINFO_DDRS (loop_vinfo),\n \t\t\t\t\t  LOOP_VINFO_LOOP_NEST (loop_vinfo),\n-\t\t\t\t\t  true);\n+\t\t\t\t\t  false);\n       gcc_assert (res);\n     }\n \n@@ -1130,6 +1129,45 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n   return;\n }\n \n+/* Return whether DR_INFO, which is related to DR_PEEL_INFO in\n+   that it only differs in DR_INIT, is aligned if DR_PEEL_INFO\n+   is made aligned via peeling.  */\n+\n+static bool\n+vect_dr_aligned_if_related_peeled_dr_is (dr_vec_info *dr_info,\n+\t\t\t\t\t dr_vec_info *dr_peel_info)\n+{\n+  if (multiple_p (DR_TARGET_ALIGNMENT (dr_peel_info),\n+\t\t  DR_TARGET_ALIGNMENT (dr_info)))\n+    {\n+      poly_offset_int diff\n+\t= (wi::to_poly_offset (DR_INIT (dr_peel_info->dr))\n+\t   - wi::to_poly_offset (DR_INIT (dr_info->dr)));\n+      if (known_eq (diff, 0)\n+\t  || multiple_p (diff, DR_TARGET_ALIGNMENT (dr_info)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return whether DR_INFO is aligned if DR_PEEL_INFO is made\n+   aligned via peeling.  */\n+\n+static bool\n+vect_dr_aligned_if_peeled_dr_is (dr_vec_info *dr_info,\n+\t\t\t\t dr_vec_info *dr_peel_info)\n+{\n+  if (!operand_equal_p (DR_BASE_ADDRESS (dr_info->dr),\n+\t\t\tDR_BASE_ADDRESS (dr_peel_info->dr), 0)\n+      || !operand_equal_p (DR_OFFSET (dr_info->dr),\n+\t\t\t   DR_OFFSET (dr_peel_info->dr), 0)\n+      || !operand_equal_p (DR_STEP (dr_info->dr),\n+\t\t\t   DR_STEP (dr_peel_info->dr), 0))\n+    return false;\n+\n+  return vect_dr_aligned_if_related_peeled_dr_is (dr_info, dr_peel_info);\n+}\n+\n /* Function vect_update_misalignment_for_peel.\n    Sets DR_INFO's misalignment\n    - to 0 if it has the same alignment as DR_PEEL_INFO,\n@@ -1146,18 +1184,10 @@ static void\n vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n \t\t\t\t   dr_vec_info *dr_peel_info, int npeel)\n {\n-  unsigned int i;\n-  vec<dr_p> same_aligned_drs;\n-  struct data_reference *current_dr;\n-  stmt_vec_info peel_stmt_info = dr_peel_info->stmt;\n-\n   /* It can be assumed that if dr_info has the same alignment as dr_peel,\n      it is aligned in the vector loop.  */\n-  same_aligned_drs = STMT_VINFO_SAME_ALIGN_REFS (peel_stmt_info);\n-  FOR_EACH_VEC_ELT (same_aligned_drs, i, current_dr)\n+  if (vect_dr_aligned_if_peeled_dr_is (dr_info, dr_peel_info))\n     {\n-      if (current_dr != dr_info->dr)\n-        continue;\n       gcc_assert (!known_alignment_for_access_p (dr_info)\n \t\t  || !known_alignment_for_access_p (dr_peel_info)\n \t\t  || (DR_MISALIGNMENT (dr_info)\n@@ -1572,6 +1602,43 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n   return true;\n }\n \n+/* Compare two data-references DRA and DRB to group them into chunks\n+   with related alignment.  */\n+\n+static int\n+dr_align_group_sort_cmp (const void *dra_, const void *drb_)\n+{\n+  data_reference_p dra = *(data_reference_p *)const_cast<void *>(dra_);\n+  data_reference_p drb = *(data_reference_p *)const_cast<void *>(drb_);\n+  int cmp;\n+\n+  /* Stabilize sort.  */\n+  if (dra == drb)\n+    return 0;\n+\n+  /* Ordering of DRs according to base.  */\n+  cmp = data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n+\t\t\t       DR_BASE_ADDRESS (drb));\n+  if (cmp != 0)\n+    return cmp;\n+\n+  /* And according to DR_OFFSET.  */\n+  cmp = data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb));\n+  if (cmp != 0)\n+    return cmp;\n+\n+  /* And after step.  */\n+  cmp = data_ref_compare_tree (DR_STEP (dra), DR_STEP (drb));\n+  if (cmp != 0)\n+    return cmp;\n+\n+  /* Then sort after DR_INIT.  In case of identical DRs sort after stmt UID.  */\n+  cmp = data_ref_compare_tree (DR_INIT (dra), DR_INIT (drb));\n+  if (cmp == 0)\n+    return gimple_uid (DR_STMT (dra)) < gimple_uid (DR_STMT (drb)) ? -1 : 1;\n+  return cmp;\n+}\n+\n /* Function vect_enhance_data_refs_alignment\n \n    This pass will use loop versioning and loop peeling in order to enhance\n@@ -1666,7 +1733,6 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n opt_result\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n   dr_vec_info *first_store = NULL;\n@@ -1680,7 +1746,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool one_misalignment_unknown = false;\n   bool one_dr_unsupportable = false;\n   dr_vec_info *unsupportable_dr_info = NULL;\n-  unsigned int mis, same_align_drs_max = 0;\n+  unsigned int mis, dr0_same_align_drs = 0, first_store_same_align_drs = 0;\n   hash_table<peel_info_hasher> peeling_htab (1);\n \n   DUMP_VECT_SCOPE (\"vect_enhance_data_refs_alignment\");\n@@ -1689,6 +1755,54 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).truncate (0);\n   LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) = 0;\n \n+  if (LOOP_VINFO_DATAREFS (loop_vinfo).is_empty ())\n+    return opt_result::success ();\n+\n+  /* Sort the vector of datarefs so DRs that have the same or dependent\n+     alignment are next to each other.  */\n+  auto_vec<data_reference_p> datarefs\n+    = LOOP_VINFO_DATAREFS (loop_vinfo).copy ();\n+  datarefs.qsort (dr_align_group_sort_cmp);\n+\n+  /* Compute the number of DRs that become aligned when we peel\n+     a dataref so it becomes aligned.  */\n+  auto_vec<unsigned> n_same_align_refs (datarefs.length ());\n+  n_same_align_refs.quick_grow_cleared (datarefs.length ());\n+  unsigned i0;\n+  for (i0 = 0; i0 < datarefs.length (); ++i0)\n+    if (DR_BASE_ADDRESS (datarefs[i0]))\n+      break;\n+  for (i = i0 + 1; i <= datarefs.length (); ++i)\n+    {\n+      if (i == datarefs.length ()\n+\t  || !operand_equal_p (DR_BASE_ADDRESS (datarefs[i0]),\n+\t\t\t       DR_BASE_ADDRESS (datarefs[i]), 0)\n+\t  || !operand_equal_p (DR_OFFSET (datarefs[i0]),\n+\t\t\t       DR_OFFSET (datarefs[i]), 0)\n+\t  || !operand_equal_p (DR_STEP (datarefs[i0]),\n+\t\t\t       DR_STEP (datarefs[i]), 0))\n+\t{\n+\t  /* The subgroup [i0, i-1] now only differs in DR_INIT and\n+\t     possibly DR_TARGET_ALIGNMENT.  Still the whole subgroup\n+\t     will get known misalignment if we align one of the refs\n+\t     with the largest DR_TARGET_ALIGNMENT.  */\n+\t  for (unsigned j = i0; j < i; ++j)\n+\t    {\n+\t      dr_vec_info *dr_infoj = loop_vinfo->lookup_dr (datarefs[j]);\n+\t      for (unsigned k = i0; k < i; ++k)\n+\t\t{\n+\t\t  if (k == j)\n+\t\t    continue;\n+\t\t  dr_vec_info *dr_infok = loop_vinfo->lookup_dr (datarefs[k]);\n+\t\t  if (vect_dr_aligned_if_related_peeled_dr_is (dr_infok,\n+\t\t\t\t\t\t\t       dr_infoj))\n+\t\t    n_same_align_refs[j]++;\n+\t\t}\n+\t    }\n+\t  i0 = i;\n+\t}\n+    }\n+\n   /* While cost model enhancements are expected in the future, the high level\n      view of the code at this time is as follows:\n \n@@ -1790,18 +1904,17 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  peeling for data-ref that has the maximum number of data-refs\n                  with the same alignment, unless the target prefers to align\n                  stores over load.  */\n-\t      unsigned same_align_drs\n-\t\t= STMT_VINFO_SAME_ALIGN_REFS (stmt_info).length ();\n+\t      unsigned same_align_drs = n_same_align_refs[i];\n \t      if (!dr0_info\n-\t\t  || same_align_drs_max < same_align_drs)\n+\t\t  || dr0_same_align_drs < same_align_drs)\n \t\t{\n-\t\t  same_align_drs_max = same_align_drs;\n+\t\t  dr0_same_align_drs = same_align_drs;\n \t\t  dr0_info = dr_info;\n \t\t}\n \t      /* For data-refs with the same number of related\n \t\t accesses prefer the one where the misalign\n \t\t computation will be invariant in the outermost loop.  */\n-\t      else if (same_align_drs_max == same_align_drs)\n+\t      else if (dr0_same_align_drs == same_align_drs)\n \t\t{\n \t\t  class loop *ivloop0, *ivloop;\n \t\t  ivloop0 = outermost_invariant_loop_for_expr\n@@ -1825,7 +1938,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      }\n \n \t      if (!first_store && DR_IS_WRITE (dr))\n-\t\tfirst_store = dr_info;\n+\t\t{\n+\t\t  first_store = dr_info;\n+\t\t  first_store_same_align_drs = same_align_drs;\n+\t\t}\n             }\n         }\n       else\n@@ -1895,6 +2011,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      && load_outside_cost > store_outside_cost))\n \t{\n \t  dr0_info = first_store;\n+\t  dr0_same_align_drs = first_store_same_align_drs;\n \t  peel_for_unknown_alignment.inside_cost = store_inside_cost;\n \t  peel_for_unknown_alignment.outside_cost = store_outside_cost;\n \t}\n@@ -1917,8 +2034,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       prologue_cost_vec.release ();\n       epilogue_cost_vec.release ();\n \n-      peel_for_unknown_alignment.peel_info.count = 1\n-\t+ STMT_VINFO_SAME_ALIGN_REFS (dr0_info->stmt).length ();\n+      peel_for_unknown_alignment.peel_info.count = dr0_same_align_drs + 1;\n     }\n \n   peel_for_unknown_alignment.peel_info.npeel = 0;\n@@ -2270,69 +2386,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_find_same_alignment_drs.\n-\n-   Update group and alignment relations in VINFO according to the chosen\n-   vectorization factor.  */\n-\n-static void\n-vect_find_same_alignment_drs (vec_info *vinfo, data_dependence_relation *ddr)\n-{\n-  struct data_reference *dra = DDR_A (ddr);\n-  struct data_reference *drb = DDR_B (ddr);\n-  dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n-  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n-  stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n-  stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n-\n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-    return;\n-\n-  if (dra == drb)\n-    return;\n-\n-  if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n-      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n-    return;\n-\n-  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n-      || !operand_equal_p (DR_OFFSET (dra), DR_OFFSET (drb), 0)\n-      || !operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n-    return;\n-\n-  /* Two references with distance zero have the same alignment.  */\n-  poly_offset_int diff = (wi::to_poly_offset (DR_INIT (dra))\n-\t\t\t  - wi::to_poly_offset (DR_INIT (drb)));\n-  if (maybe_ne (diff, 0))\n-    {\n-      /* Get the wider of the two alignments.  */\n-      poly_uint64 align_a =\n-\texact_div (vect_calculate_target_alignment (dr_info_a),\n-\t\t   BITS_PER_UNIT);\n-      poly_uint64 align_b =\n-\texact_div (vect_calculate_target_alignment (dr_info_b),\n-\t\t   BITS_PER_UNIT);\n-      unsigned HOST_WIDE_INT align_a_c, align_b_c;\n-      if (!align_a.is_constant (&align_a_c)\n-\t  || !align_b.is_constant (&align_b_c))\n-\treturn;\n-\n-      unsigned HOST_WIDE_INT max_align = MAX (align_a_c, align_b_c);\n-\n-      /* Require the gap to be a multiple of the larger vector alignment.  */\n-      if (!multiple_p (diff, max_align))\n-\treturn;\n-    }\n-\n-  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a).safe_push (drb);\n-  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b).safe_push (dra);\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"accesses have the same alignment: %T and %T\\n\",\n-\t\t     DR_REF (dra), DR_REF (drb));\n-}\n-\n-\n /* Function vect_analyze_data_refs_alignment\n \n    Analyze the alignment of the data-references in the loop.\n@@ -2343,17 +2396,9 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   DUMP_VECT_SCOPE (\"vect_analyze_data_refs_alignment\");\n \n-  /* Mark groups of data references with same alignment using\n-     data dependence information.  */\n-  vec<ddr_p> ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n-  struct data_dependence_relation *ddr;\n-  unsigned int i;\n-\n-  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    vect_find_same_alignment_drs (loop_vinfo, ddr);\n-\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n+  unsigned int i;\n \n   vect_record_base_alignments (loop_vinfo);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)"}, {"sha": "778177a583b45f13dd92284e26a3bdb710d8d6de", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -690,7 +690,6 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_internal_def;\n \n-  STMT_VINFO_SAME_ALIGN_REFS (res).create (0);\n   STMT_SLP_TYPE (res) = loop_vect;\n \n   /* This is really \"uninitialized\" until vect_compute_data_ref_alignment.  */\n@@ -746,7 +745,6 @@ vec_info::free_stmt_vec_info (stmt_vec_info stmt_info)\n \trelease_ssa_name (lhs);\n     }\n \n-  STMT_VINFO_SAME_ALIGN_REFS (stmt_info).release ();\n   STMT_VINFO_SIMD_CLONE_INFO (stmt_info).release ();\n   STMT_VINFO_VEC_STMTS (stmt_info).release ();\n   free (stmt_info);"}, {"sha": "b56073c4ee329e2fa21c764d306dd67b8327b2eb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -1058,10 +1058,6 @@ class _stmt_vec_info {\n      pattern statement.  */\n   gimple_seq pattern_def_seq;\n \n-  /* List of datarefs that are known to have the same alignment as the dataref\n-     of this stmt.  */\n-  vec<dr_p> same_align_refs;\n-\n   /* Selected SIMD clone's function info.  First vector element\n      is SIMD clone's function decl, followed by a pair of trees (base + step)\n      for linear arguments (pair of NULLs for other arguments).  */\n@@ -1251,7 +1247,6 @@ struct gather_scatter_info {\n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n #define STMT_VINFO_PATTERN_DEF_SEQ(S)      (S)->pattern_def_seq\n-#define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n #define STMT_VINFO_SIMD_CLONE_INFO(S)\t   (S)->simd_clone_info\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n #define STMT_VINFO_GROUPED_ACCESS(S) \\"}, {"sha": "3ad26972a62fd4b026956a6429ff69aed5d17b93", "filename": "gcc/vec.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a673744dee7a80e6525fb0da87d053c8ccab6275/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=a673744dee7a80e6525fb0da87d053c8ccab6275", "patch": "@@ -1541,13 +1541,15 @@ class auto_vec<T, 0> : public vec<T, va_heap>\n   auto_vec (size_t n) { this->create (n); }\n   ~auto_vec () { this->release (); }\n \n-  auto_vec (auto_vec&& r)\n+  auto_vec (vec<T, va_heap>&& r)\n     {\n+      gcc_assert (!r.using_auto_storage ());\n       this->m_vec = r.m_vec;\n       r.m_vec = NULL;\n     }\n-  auto_vec& operator= (auto_vec&& r)\n+  auto_vec& operator= (vec<T, va_heap>&& r)\n     {\n+      gcc_assert (!r.using_auto_storage ());\n       this->release ();\n       this->m_vec = r.m_vec;\n       r.m_vec = NULL;"}]}