{"sha": "cd14f288ddf246d40f109aa7999b99a44739cd99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QxNGYyODhkZGYyNDZkNDBmMTA5YWE3OTk5Yjk5YTQ0NzM5Y2Q5OQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-02T20:29:32Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-02T20:53:51Z"}, "message": "coroutines: Update lambda capture handling to n4849.\n\nIn the absence of specific comment on the handling of closures I'd\nimplemented something more than was intended (extending the lifetime\nof lambda capture-by-copy vars to the duration of the coro).\n\nAfter discussion at WG21 in February and by email, the correct handling\nis to treat the closure \"this\" pointer the same way as for a regular one,\nand thus it is the user's responsibility to ensure that the lambda capture\nobject has suitable lifetime for the coroutine.  It is noted that users\nfrequently get this wrong, so it would be a good thing to revisit for C++23.\n\nThis patch removes the additional copying behaviour for lambda capture-by-\ncopy vars.\n\ngcc/cp/ChangeLog:\n\n2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (struct local_var_info): Adjust to remove the\n\treference to the captured var, and just to note that this is a\n\tlambda capture proxy.\n\t(transform_local_var_uses): Handle lambda captures specially.\n\t(struct param_frame_data): Add a visited set.\n\t(register_param_uses): Also check for param uses in lambda\n\tcapture proxies.\n\t(struct local_vars_frame_data): Remove captures list.\n\t(register_local_var_uses): Handle lambda capture proxies by\n\tnoting and bypassing them.\n\t(morph_fn_to_coro): Update to remove lifetime extension of\n\tlambda capture-by-copy vars.\n\ngcc/testsuite/ChangeLog:\n\n2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n\t    Jun Ma <JunMa@linux.alibaba.com>\n\n\t* g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C:\n\t* g++.dg/coroutines/torture/lambda-09-init-captures.C: New test.\n\t* g++.dg/coroutines/torture/lambda-10-mutable.C: New test.", "tree": {"sha": "0f41a5b640068a00e9dcf962dcfe4f2861e1c3f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f41a5b640068a00e9dcf962dcfe4f2861e1c3f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd14f288ddf246d40f109aa7999b99a44739cd99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd14f288ddf246d40f109aa7999b99a44739cd99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd14f288ddf246d40f109aa7999b99a44739cd99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd14f288ddf246d40f109aa7999b99a44739cd99/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80cbe2d8d46c8518dca2d781c8ee4d02c5ba1ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80cbe2d8d46c8518dca2d781c8ee4d02c5ba1ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80cbe2d8d46c8518dca2d781c8ee4d02c5ba1ed"}], "stats": {"total": 303, "additions": 193, "deletions": 110}, "files": [{"sha": "bfe8d7949b25dac3d3523247b040df292f7b4d61", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -1,3 +1,18 @@\n+2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (struct local_var_info): Adjust to remove the\n+\treference to the captured var, and just to note that this is a\n+\tlambda capture proxy.\n+\t(transform_local_var_uses): Handle lambda captures specially.\n+\t(struct param_frame_data): Add a visited set.\n+\t(register_param_uses): Also check for param uses in lambda\n+\tcapture proxies.\n+\t(struct local_vars_frame_data): Remove captures list.\n+\t(register_local_var_uses): Handle lambda capture proxies by\n+\tnoting and bypassing them.\n+\t(morph_fn_to_coro): Update to remove lifetime extension of\n+\tlambda capture-by-copy vars.\n+\n 2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* coroutines.cc (build_co_await): Do not build frame"}, {"sha": "303e6e83d54d86a24be5ba8dbfe8aec96801c46f", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 66, "deletions": 108, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -1783,7 +1783,7 @@ struct local_var_info\n   tree field_id;\n   tree field_idx;\n   tree frame_type;\n-  tree captured;\n+  bool is_lambda_capture;\n   location_t def_loc;\n };\n \n@@ -1828,6 +1828,14 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  cp_walk_tree (&DECL_SIZE_UNIT (lvar), transform_local_var_uses, d,\n \t\t\tNULL);\n \n+\t/* For capture proxies, this could include the decl value expr.  */\n+\tif (local_var.is_lambda_capture)\n+\t  {\n+\t    tree ve = DECL_VALUE_EXPR (lvar);\n+\t    cp_walk_tree (&ve, transform_local_var_uses, d, NULL);\n+\t    continue; /* No frame entry for this.  */\n+\t  }\n+\n \t  /* TODO: implement selective generation of fields when vars are\n \t     known not-used.  */\n \t  if (local_var.field_id == NULL_TREE)\n@@ -1842,19 +1850,34 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  local_var.field_idx = fld_idx;\n \t}\n       cp_walk_tree (&BIND_EXPR_BODY (*stmt), transform_local_var_uses, d, NULL);\n+\n       /* Now we have processed and removed references to the original vars,\n-\t we can drop those from the bind.  */\n+\t we can drop those from the bind - leaving capture proxies alone.  */\n       for (tree *pvar = &BIND_EXPR_VARS (*stmt); *pvar != NULL;)\n \t{\n \t  bool existed;\n \t  local_var_info &local_var\n \t    = lvd->local_var_uses->get_or_insert (*pvar, &existed);\n \t  gcc_checking_assert (existed);\n \n+\t  /* Leave lambda closure captures alone, we replace the *this\n+\t     pointer with the frame version and let the normal process\n+\t     deal with the rest.  */\n+\t  if (local_var.is_lambda_capture)\n+\t    {\n+\t      pvar = &DECL_CHAIN (*pvar);\n+\t      continue;\n+\t    }\n+\n+\t  /* It's not used, but we can let the optimizer deal with that.  */\n \t  if (local_var.field_id == NULL_TREE)\n-\t    pvar = &DECL_CHAIN (*pvar); /* Wasn't used.  */\n+\t    {\n+\t      pvar = &DECL_CHAIN (*pvar);\n+\t      continue;\n+\t    }\n \n-\t  *pvar = DECL_CHAIN (*pvar); /* discard this one, we replaced it.  */\n+\t  /* Discard this one, we replaced it.  */\n+\t  *pvar = DECL_CHAIN (*pvar);\n \t}\n \n       *do_subtree = 0; /* We've done the body already.  */\n@@ -1884,6 +1907,9 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   if (local_var_i == NULL)\n     return NULL_TREE;\n \n+  if (local_var_i->is_lambda_capture)\n+    return NULL_TREE;\n+\n   /* This is our revised 'local' i.e. a frame slot.  */\n   tree revised = local_var_i->field_idx;\n   gcc_checking_assert (DECL_CONTEXT (var_decl) == lvd->context);\n@@ -2877,6 +2903,7 @@ struct param_frame_data\n {\n   tree *field_list;\n   hash_map<tree, param_info> *param_uses;\n+  hash_set<tree *> *visited;\n   location_t loc;\n   bool param_seen;\n };\n@@ -2886,9 +2913,20 @@ register_param_uses (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n {\n   param_frame_data *data = (param_frame_data *) d;\n \n+  /* For lambda closure content, we have to look specifically.  */\n+  if (TREE_CODE (*stmt) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (*stmt))\n+    {\n+      tree t = DECL_VALUE_EXPR (*stmt);\n+      return cp_walk_tree (&t, register_param_uses, d, NULL);\n+    }\n+\n   if (TREE_CODE (*stmt) != PARM_DECL)\n     return NULL_TREE;\n \n+  /* If we already saw the containing expression, then we're done.  */\n+  if (data->visited->add (stmt))\n+    return NULL_TREE;\n+\n   bool existed;\n   param_info &parm = data->param_uses->get_or_insert (*stmt, &existed);\n   gcc_checking_assert (existed);\n@@ -2911,7 +2949,6 @@ struct local_vars_frame_data\n {\n   tree *field_list;\n   hash_map<tree, local_var_info> *local_var_uses;\n-  vec<local_var_info> *captures;\n   unsigned int nest_depth, bind_indx;\n   location_t loc;\n   bool saw_capture;\n@@ -2940,45 +2977,33 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  local_var_info &local_var\n \t    = lvd->local_var_uses->get_or_insert (lvar, &existed);\n \t  gcc_checking_assert (!existed);\n+\t  local_var.def_loc = DECL_SOURCE_LOCATION (lvar);\n \t  tree lvtype = TREE_TYPE (lvar);\n-\t  tree lvname = DECL_NAME (lvar);\n-\t  bool captured = is_normal_capture_proxy (lvar);\n+\t  local_var.frame_type = lvtype;\n+\t  local_var.field_idx = local_var.field_id = NULL_TREE;\n+\t  lvd->local_var_seen = true;\n+\t  /* If this var is a lambda capture proxy, we want to leave it alone,\n+\t     and later rewrite the DECL_VALUE_EXPR to indirect through the\n+\t     frame copy of the pointer to the lambda closure object.  */\n+\t  local_var.is_lambda_capture = is_capture_proxy (lvar);\n+\t  if (local_var.is_lambda_capture)\n+\t    continue;\n+\n \t  /* Make names depth+index unique, so that we can support nested\n \t     scopes with identically named locals.  */\n+\t  tree lvname = DECL_NAME (lvar);\n \t  char *buf;\n-\t  size_t namsize = sizeof (\"__lv...\") + 18;\n-\t  const char *nm = (captured ? \"cp\" : \"lv\");\n \t  if (lvname != NULL_TREE)\n-\t    {\n-\t      namsize += IDENTIFIER_LENGTH (lvname);\n-\t      buf = (char *) alloca (namsize);\n-\t      snprintf (buf, namsize, \"__%s.%u.%u.%s\", nm, lvd->bind_indx,\n-\t\t\tlvd->nest_depth, IDENTIFIER_POINTER (lvname));\n-\t    }\n+\t    buf = xasprintf (\"__lv.%u.%u.%s\", lvd->bind_indx, lvd->nest_depth,\n+\t\t\t     IDENTIFIER_POINTER (lvname));\n \t  else\n-\t    {\n-\t      namsize += 10; /* 'D' followed by an unsigned.  */\n-\t      buf = (char *) alloca (namsize);\n-\t      snprintf (buf, namsize, \"__%s.%u.%u.D%u\", nm, lvd->bind_indx,\n-\t\t\tlvd->nest_depth, DECL_UID (lvar));\n-\t    }\n+\t    buf = xasprintf (\"__lv.%u.%u.D%u\", lvd->bind_indx, lvd->nest_depth,\n+\t\t\t     DECL_UID (lvar));\n \t  /* TODO: Figure out if we should build a local type that has any\n \t     excess alignment or size from the original decl.  */\n \t  local_var.field_id\n \t    = coro_make_frame_entry (lvd->field_list, buf, lvtype, lvd->loc);\n-\t  local_var.def_loc = DECL_SOURCE_LOCATION (lvar);\n-\t  local_var.frame_type = lvtype;\n-\t  local_var.field_idx = NULL_TREE;\n-\t  if (captured)\n-\t    {\n-\t      gcc_checking_assert (DECL_INITIAL (lvar) == NULL_TREE);\n-\t      local_var.captured = lvar;\n-\t      lvd->captures->safe_push (local_var);\n-\t      lvd->saw_capture = true;\n-\t    }\n-\t  else\n-\t    local_var.captured = NULL;\n-\t  lvd->local_var_seen = true;\n+\t  free (buf);\n \t  /* We don't walk any of the local var sub-trees, they won't contain\n \t     any bind exprs.  */\n \t}\n@@ -3032,7 +3057,6 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   short __resume_at;\n   handle_type self_handle;\n   (maybe) parameter copies.\n-  (maybe) lambda capture copies.\n   coro1::suspend_never_prt __is;\n   (maybe) handle_type i_hand;\n   coro1::suspend_always_prt __fs;\n@@ -3064,7 +3088,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   location_t fn_start = DECL_SOURCE_LOCATION (orig);\n   gcc_rich_location fn_start_loc (fn_start);\n \n-  /* Initial processing of the captured body.\n+  /* Initial processing of the function-body.\n      If we have no expressions or just an error then punt.  */\n   tree body_start = expr_first (fnbody);\n   if (body_start == NULL_TREE || body_start == error_mark_node)\n@@ -3223,10 +3247,12 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  free (buf);\n \t}\n \n-      param_frame_data param_data\n-\t= {&field_list, param_uses, fn_start, false};\n       /* We want to record every instance of param's use, so don't include\n-\t a 'visited' hash_set.  */\n+\t a 'visited' hash_set on the tree walk, but only record a containing\n+\t expression once.  */\n+      hash_set<tree *> visited;\n+      param_frame_data param_data\n+\t= {&field_list, param_uses, &visited, fn_start, false};\n       cp_walk_tree (&fnbody, register_param_uses, &param_data, NULL);\n     }\n \n@@ -3277,10 +3303,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* 4. Now make space for local vars, this is conservative again, and we\n      would expect to delete unused entries later.  */\n   hash_map<tree, local_var_info> local_var_uses;\n-  auto_vec<local_var_info> captures;\n-\n   local_vars_frame_data local_vars_data\n-    = {&field_list, &local_var_uses, &captures, 0, 0, fn_start, false, false};\n+    = {&field_list, &local_var_uses, 0, 0, fn_start, false, false};\n   cp_walk_tree (&fnbody, register_local_var_uses, &local_vars_data, NULL);\n \n   /* Tie off the struct for now, so that we can build offsets to the\n@@ -3302,16 +3326,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree coro_fp = build_lang_decl (VAR_DECL, get_identifier (\"coro.frameptr\"),\n \t\t\t\t  coro_frame_ptr);\n   tree varlist = coro_fp;\n-  local_var_info *cap;\n-  if (!captures.is_empty())\n-    for (int ix = 0; captures.iterate (ix, &cap); ix++)\n-      {\n-\tif (cap->field_id == NULL_TREE)\n-\t  continue;\n-\ttree t = cap->captured;\n-\tDECL_CHAIN (t) = varlist;\n-\tvarlist = t;\n-      }\n \n   /* Collected the scope vars we need ... only one for now. */\n   BIND_EXPR_VARS (ramp_bind) = nreverse (varlist);\n@@ -3668,62 +3682,6 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       add_stmt (r);\n     }\n \n-  vec<tree, va_gc> *captures_dtor_list = NULL;\n-  while (!captures.is_empty())\n-    {\n-      local_var_info cap = captures.pop();\n-      if (cap.field_id == NULL_TREE)\n-\tcontinue;\n-\n-      tree fld_ref = lookup_member (coro_frame_type, cap.field_id,\n-\t\t\t\t    /*protect=*/1, /*want_type=*/0,\n-\t\t\t\t    tf_warning_or_error);\n-      tree fld_idx\n-\t= build_class_member_access_expr (deref_fp, fld_ref, NULL_TREE,\n-\t\t\t\t\t  false, tf_warning_or_error);\n-\n-      tree cap_type = cap.frame_type;\n-\n-      /* When we have a reference, we do not want to change the referenced\n-\t item, but actually to set the reference to the proxy var.  */\n-      if (REFERENCE_REF_P (fld_idx))\n-\tfld_idx = TREE_OPERAND (fld_idx, 0);\n-\n-      if (TYPE_NEEDS_CONSTRUCTING (cap_type))\n-\t{\n-\t  vec<tree, va_gc> *p_in;\n-\t      if (TYPE_REF_P (cap_type)\n-\t\t  && (CLASSTYPE_LAZY_MOVE_CTOR (cap_type)\n-\t\t      || CLASSTYPE_LAZY_MOVE_ASSIGN (cap_type)\n-\t\t      || classtype_has_move_assign_or_move_ctor_p\n-\t\t\t    (cap_type, /*user_declared=*/true)))\n-\t    p_in = make_tree_vector_single (rvalue (cap.captured));\n-\t  else\n-\t    p_in = make_tree_vector_single (cap.captured);\n-\t  /* Construct in place or move as relevant.  */\n-\t  r = build_special_member_call (fld_idx, complete_ctor_identifier,\n-\t\t\t\t\t &p_in, cap_type, LOOKUP_NORMAL,\n-\t\t\t\t\t tf_warning_or_error);\n-\t  release_tree_vector (p_in);\n-\t  if (captures_dtor_list == NULL)\n-\t    captures_dtor_list = make_tree_vector ();\n-\t  vec_safe_push (captures_dtor_list, cap.field_id);\n-\t}\n-      else\n-\t{\n-\t  if (!same_type_p (cap_type, TREE_TYPE (cap.captured)))\n-\t    r = build1_loc (DECL_SOURCE_LOCATION (cap.captured), CONVERT_EXPR,\n-\t\t\t    cap_type, cap.captured);\n-\t  else\n-\t    r = cap.captured;\n-\t  r = build_modify_expr (fn_start, fld_idx, cap_type,\n-\t\t\t\t INIT_EXPR, DECL_SOURCE_LOCATION (cap.captured),\n-\t\t\t\t r, TREE_TYPE (r));\n-\t}\n-      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-      add_stmt (r);\n-    }\n-\n   /* Set up a new bind context for the GRO.  */\n   tree gro_context_bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n   /* Make and connect the scope blocks.  */"}, {"sha": "af29e81a0b62d3b4e72ee94bdab739edaa802fd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -1,3 +1,10 @@\n+2020-03-02  Iain Sandoe  <iain@sandoe.co.uk>\n+\t    Jun Ma <JunMa@linux.alibaba.com>\n+\n+\t* g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C:\n+\t* g++.dg/coroutines/torture/lambda-09-init-captures.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-10-mutable.C: New test.\n+\n 2020-03-02  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/93997"}, {"sha": "9bb76d246c3b60e722332336a5b29d9f676d41c9", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -18,7 +18,7 @@ class foo\n       auto l = [=](T y) -> coro1\n       {\n \tT x = y;\n-\tco_return co_await x + local;\n+\tco_return co_await x + y + local;\n       };\n       return l;\n     }\n@@ -43,7 +43,7 @@ int main ()\n \n   /* Now we should have the co_returned value.  */\n   int y = x.handle.promise().get_value();\n-  if ( y != 20 )\n+  if ( y != 37 )\n     {\n       PRINTF (\"main: wrong result (%d).\", y);\n       abort ();"}, {"sha": "920d6eaac82b944a7a3e132f2194bdc32442916e", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-09-init-captures.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-09-init-captures.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-09-init-captures.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-09-init-captures.C?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -0,0 +1,55 @@\n+//  { dg-do run }\n+\n+// lambda with initialized captures\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  int a_copy = 20;\n+\n+  auto f = [&a_ref = a_copy, a_copy = a_copy + 10]() -> coro1\n+  {\n+    a_ref += 20;\n+    co_return a_ref + a_copy;\n+  };\n+\n+  {\n+    coro1 A = f ();\n+    A.handle.resume();\n+    if (a_copy != 40)\n+      {\n+        PRINT (\"main: [a_copy = 40]\");\n+\tabort ();\n+      }\n+  \n+    int y = A.handle.promise().get_value();\n+    if (y != 70)\n+      {\n+\tPRINTF (\"main: A co-ret = %d, should be 70\\n\", y);\n+\tabort ();\n+      }\n+  }\n+\n+  a_copy = 5;\n+\n+  coro1 B = f ();\n+  B.handle.resume();\n+  if (a_copy != 25)\n+    {\n+      PRINT (\"main: [a_copy = 25]\");\n+      abort ();\n+    }\n+\n+  int y = B.handle.promise().get_value();\n+  if (y != 55)\n+    {\n+      PRINTF (\"main: B co-ret = %d, should be 55\\n\", y);\n+      abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "a10816ccd8452bf947f90c9920868118052a0d16", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-10-mutable.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-10-mutable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd14f288ddf246d40f109aa7999b99a44739cd99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-10-mutable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-10-mutable.C?ref=cd14f288ddf246d40f109aa7999b99a44739cd99", "patch": "@@ -0,0 +1,48 @@\n+//  { dg-do run }\n+\n+// lambda with mutable closure object.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Creates a coro lambda with a mutable closure and\n+   suspend-always initial suspend.  */\n+\n+auto make_co_lambda ()\n+{\n+  return [i = 1] () mutable -> coro1 { co_return i++; };\n+}\n+\n+/* We make this behave sequentially for the purposes of testing.  */\n+int main()\n+{\n+  auto co_l = make_co_lambda ();\n+  auto v1 = co_l ();\n+  auto v2 = co_l ();\n+  auto v3 = co_l ();\n+\n+  v3.handle.resume();\n+  v2.handle.resume();\n+  v1.handle.resume();\n+\n+  int res1 = v1.handle.promise().get_value ();\n+  int res2 = v2.handle.promise().get_value ();\n+  int res3 = v3.handle.promise().get_value ();\n+  PRINTF (\"main: co-lambda %d, %d, %d\\n\",res1, res2, res3);\n+  if ( res1 != 3 || res2 != 2 || res3 != 1)\n+    {\n+      PRINT (\"main: bad return value.\");\n+      abort ();\n+    }\n+\n+  if (!v1.handle.done() || !v2.handle.done() || !v3.handle.done())\n+    {\n+      PRINT (\"main: apparently something was not done...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: done.\");\n+}\n+"}]}