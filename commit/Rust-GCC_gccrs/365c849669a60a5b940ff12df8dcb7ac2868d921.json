{"sha": "365c849669a60a5b940ff12df8dcb7ac2868d921", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY1Yzg0OTY2OWE2MGE1Yjk0MGZmMTJkZjhkY2I3YWMyODY4ZDkyMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-02-18T11:52:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-18T11:52:58Z"}, "message": "exp_attr.adb: Minor reformatting.\n\n2014-02-18  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb: Minor reformatting.\n\t* exp_ch4.ads, exp_ch4.adb (Expand_N_Reference): New procedure.\n\t* exp_util.adb (Remove_Side_Effects): Add conditional expressions\n\tas another case where we don't generate N_Reference nodes for\n\tprimitive types.\n\t* expander.adb (Expand): Add call to Expand_N_Reference.\n\nFrom-SVN: r207841", "tree": {"sha": "a937c244223d54363a5eb3caa31abe41c55442f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a937c244223d54363a5eb3caa31abe41c55442f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/365c849669a60a5b940ff12df8dcb7ac2868d921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/365c849669a60a5b940ff12df8dcb7ac2868d921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/365c849669a60a5b940ff12df8dcb7ac2868d921", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/365c849669a60a5b940ff12df8dcb7ac2868d921/comments", "author": null, "committer": null, "parents": [{"sha": "20afe6403b216d1f0a2cc9e119efbac514acb533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20afe6403b216d1f0a2cc9e119efbac514acb533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20afe6403b216d1f0a2cc9e119efbac514acb533"}], "stats": {"total": 116, "additions": 100, "deletions": 16}, "files": [{"sha": "4f71051439ed69505643bce014a43e96d5809427", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -1,3 +1,12 @@\n+2014-02-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb: Minor reformatting.\n+\t* exp_ch4.ads, exp_ch4.adb (Expand_N_Reference): New procedure.\n+\t* exp_util.adb (Remove_Side_Effects): Add conditional expressions\n+\tas another case where we don't generate N_Reference nodes for\n+\tprimitive types.\n+\t* expander.adb (Expand): Add call to Expand_N_Reference.\n+\n 2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Refined_Pragma): Remove"}, {"sha": "7a55d8b6c671f10adab1b55ec07640a5cc4aadcf", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -1132,20 +1132,20 @@ package body Exp_Attr is\n             --  copies from being created when the unchecked conversion\n             --  is expanded (which would happen in Remove_Side_Effects\n             --  if Expand_N_Unchecked_Conversion were allowed to call\n-            --  Force_Evaluation). The copy could violate Ada semantics\n-            --  in cases such as an actual that is an out parameter.\n-            --  Note that this approach is also used in exp_ch7 for calls\n-            --  to controlled type operations to prevent problems with\n-            --  actuals wrapped in unchecked conversions.\n+            --  Force_Evaluation). The copy could violate Ada semantics in\n+            --  cases such as an actual that is an out parameter. Note that\n+            --  this approach is also used in exp_ch7 for calls to controlled\n+            --  type operations to prevent problems with actuals wrapped in\n+            --  unchecked conversions.\n \n             if Is_Untagged_Derivation (Etype (Expression (Item))) then\n                Set_Assignment_OK (Item);\n             end if;\n          end if;\n \n-         --  The stream operation to call maybe a renaming created by\n-         --  an attribute definition clause, and may not be frozen yet.\n-         --  Ensure that it has the necessary extra formals.\n+         --  The stream operation to call may be a renaming created by an\n+         --  attribute definition clause, and may not be frozen yet. Ensure\n+         --  that it has the necessary extra formals.\n \n          if not Is_Frozen (Pname) then\n             Create_Extra_Formals (Pname);"}, {"sha": "30951ed50110c5d877c0f20552fac9b198071ac9", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -9225,6 +9225,65 @@ package body Exp_Ch4 is\n       Analyze_And_Resolve (N, Standard_Boolean);\n    end Expand_N_Quantified_Expression;\n \n+   ------------------------\n+   -- Expand_N_Reference --\n+   ------------------------\n+\n+   --  It is a little unclear why we generate references to expression values,\n+   --  but we definitely do! At the very least in Modify_Tree_For_C, we need to\n+   --  get rid of such constructs. We do this by expanding:\n+\n+   --    expression'Reference\n+\n+   --  into\n+\n+   --    Tnn : constant typ := expression;\n+   --    ...\n+   --    Tnn'Reference\n+\n+   procedure Expand_N_Reference (N : Node_Id) is\n+   begin\n+      --  No problem if Modify_Tree_For_C not set, the existing back ends will\n+      --  correctly handle P'Reference where P is a general expression.\n+\n+      if not Modify_Tree_For_C then\n+         return;\n+\n+      --  No problem if we have an entity name since we can take its address\n+\n+      elsif Is_Entity_Name (Prefix (N)) then\n+         return;\n+\n+      --  Can't go copying limited types\n+\n+      elsif Is_Limited_Record (Etype (Prefix (N)))\n+        or else Is_Limited_Composite (Etype (Prefix (N)))\n+      then\n+         return;\n+\n+      --  Here is the case where we do the transformation discussed above\n+\n+      else\n+         declare\n+            Loc  : constant Source_Ptr := Sloc (N);\n+            Expr : constant Node_Id    := Prefix (N);\n+            Typ  : constant Entity_Id  := Etype (N);\n+            Tnn  : constant Entity_Id  := Make_Temporary (Loc, 'T', Expr);\n+         begin\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Tnn,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (Etype (Expr), Loc),\n+                Expression          => Expr));\n+            Rewrite (N,\n+              Make_Reference (Loc,\n+                Prefix => New_Occurrence_Of (Tnn, Loc)));\n+            Analyze_And_Resolve (N, Typ);\n+         end;\n+      end if;\n+   end Expand_N_Reference;\n+\n    ---------------------------------\n    -- Expand_N_Selected_Component --\n    ---------------------------------"}, {"sha": "99ed8618267c5001f766ad1ec073cd702b11b688", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,6 +68,7 @@ package Exp_Ch4 is\n    procedure Expand_N_Or_Else                     (N : Node_Id);\n    procedure Expand_N_Qualified_Expression        (N : Node_Id);\n    procedure Expand_N_Quantified_Expression       (N : Node_Id);\n+   procedure Expand_N_Reference                   (N : Node_Id);\n    procedure Expand_N_Selected_Component          (N : Node_Id);\n    procedure Expand_N_Slice                       (N : Node_Id);\n    procedure Expand_N_Type_Conversion             (N : Node_Id);"}, {"sha": "cea3dabe8d41eeea739592c0631babed729b5eee", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -6972,17 +6972,28 @@ package body Exp_Util is\n       Scope_Suppress.Suppress := (others => True);\n \n       --  If it is a scalar type and we need to capture the value, just make\n-      --  a copy. Likewise for a function call, an attribute reference, an\n-      --  allocator, or an operator. And if we have a volatile reference and\n-      --  Name_Req is not set (see comments above for Side_Effect_Free).\n+      --  a copy. Likewise for a function call, an attribute reference, a\n+      --  conditional expression, an allocator, or an operator. And if we have\n+      --  a volatile reference and Name_Req is not set (see comments above for\n+      --  Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)\n+\n+        --  Note: this test is rather mysterious??? Why can't we just test ONLY\n+        --  Is_Elementary_Type and be done with it. If we try that approach, we\n+        --  get some failures (infinite recursions) from the Duplicate_Subexpr\n+        --  call at the end of Checks.Apply_Predicate_Check. To be\n+        --  investigated ???\n+\n         and then (Variable_Ref\n-                   or else Nkind_In (Exp, N_Function_Call,\n-                                          N_Attribute_Reference,\n-                                          N_Allocator)\n+                   or else Nkind_In (Exp, N_Attribute_Reference,\n+                                          N_Allocator,\n+                                          N_Case_Expression,\n+                                          N_If_Expression,\n+                                          N_Function_Call)\n                    or else Nkind (Exp) in N_Op\n-                   or else (not Name_Req and then Is_Volatile_Reference (Exp)))\n+                   or else (not Name_Req\n+                             and then Is_Volatile_Reference (Exp)))\n       then\n          Def_Id := Make_Temporary (Loc, 'R', Exp);\n          Set_Etype (Def_Id, Exp_Type);\n@@ -7230,6 +7241,7 @@ package body Exp_Util is\n          E := Exp;\n          if Nkind (E) = N_Explicit_Dereference then\n             New_Exp := Relocate_Node (Prefix (E));\n+\n          else\n             E := Relocate_Node (E);\n "}, {"sha": "2afa4b540b5590a6f1f2c58856364b7ddabef238", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/365c849669a60a5b940ff12df8dcb7ac2868d921/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=365c849669a60a5b940ff12df8dcb7ac2868d921", "patch": "@@ -411,6 +411,9 @@ package body Expander is\n                   when N_Record_Representation_Clause =>\n                      Expand_N_Record_Representation_Clause (N);\n \n+                  when N_Reference =>\n+                     Expand_N_Reference (N);\n+\n                   when N_Requeue_Statement =>\n                      Expand_N_Requeue_Statement (N);\n "}]}