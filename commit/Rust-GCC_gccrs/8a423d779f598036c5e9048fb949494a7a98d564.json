{"sha": "8a423d779f598036c5e9048fb949494a7a98d564", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0MjNkNzc5ZjU5ODAzNmM1ZTkwNDhmYjk0OTQ5NGE3YTk4ZDU2NA==", "commit": {"author": {"name": "Jesse Rosenstock", "email": "jmr@ugcs.caltech.edu", "date": "2002-11-11T07:36:41Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-11-11T07:36:41Z"}, "message": "ISO_8859_1.java, [...]: New files.\n\n2002-11-11  Jesse Rosenstock  <jmr@ugcs.caltech.edu>\n\n\t* gnu/java/nio/charset/ISO_8859_1.java,\n\tgnu/java/nio/charset/Provider.java,\n\tgnu/java/nio/charset/US_ASCII.java,\n\tgnu/java/nio/charset/UTF_16.java,\n\tgnu/java/nio/charset/UTF_16BE.java,\n\tgnu/java/nio/charset/UTF_16Decoder.java,\n\tgnu/java/nio/charset/UTF_16Encoder.java,\n\tgnu/java/nio/charset/UTF_16LE.java,\n\tgnu/java/nio/charset/UTF_8.java: New files.\n\t* Makefile.am ():\n\tAdded new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r59013", "tree": {"sha": "ff604598749b5c8d280139c1d1f78191270f1841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff604598749b5c8d280139c1d1f78191270f1841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a423d779f598036c5e9048fb949494a7a98d564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a423d779f598036c5e9048fb949494a7a98d564", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a423d779f598036c5e9048fb949494a7a98d564", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a423d779f598036c5e9048fb949494a7a98d564/comments", "author": null, "committer": null, "parents": [{"sha": "ac7bc6bb2f59e4445e6f4469f558a40a913edbe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7bc6bb2f59e4445e6f4469f558a40a913edbe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7bc6bb2f59e4445e6f4469f558a40a913edbe1"}], "stats": {"total": 1245, "additions": 1245, "deletions": 0}, "files": [{"sha": "0732a5629da273d5cafbd42715dc0dd7ff4cbd05", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -1,3 +1,18 @@\n+2002-11-11  Jesse Rosenstock  <jmr@ugcs.caltech.edu>\n+\n+\t* gnu/java/nio/charset/ISO_8859_1.java,\n+\tgnu/java/nio/charset/Provider.java,\n+\tgnu/java/nio/charset/US_ASCII.java,\n+\tgnu/java/nio/charset/UTF_16.java,\n+\tgnu/java/nio/charset/UTF_16BE.java,\n+\tgnu/java/nio/charset/UTF_16Decoder.java,\n+\tgnu/java/nio/charset/UTF_16Encoder.java,\n+\tgnu/java/nio/charset/UTF_16LE.java,\n+\tgnu/java/nio/charset/UTF_8.java: New files.\n+\t* Makefile.am ():\n+\tAdded new files.\n+\t* Makefile.in: Regenerated.\n+\t\n 2002-11-11  Michael Koch <konqueror@gmx.de>\n \n \t* java/nio/charset/CharacterCodingException.java:"}, {"sha": "f29fa26030067e2f4bc310451a6ca0eb60e9c9c9", "filename": "libjava/gnu/java/nio/charset/ISO_8859_1.java", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FISO_8859_1.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FISO_8859_1.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FISO_8859_1.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,132 @@\n+/* ISO_8859_1.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * ISO-8859-1 charset.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class ISO_8859_1 extends Charset\n+{\n+  ISO_8859_1 ()\n+  {\n+    super (\"ISO-8859-1\", new String[]{\"ISO-LATIN-1\"});\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII || cs instanceof ISO_8859_1;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new Decoder (this);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new Encoder (this);\n+  }\n+\n+  private static final class Decoder extends CharsetDecoder\n+  {\n+    private Decoder (Charset cs)\n+    {\n+      super (cs, 1.0f, 1.0f);\n+    }\n+\n+    protected CoderResult decodeLoop (ByteBuffer in, CharBuffer out)\n+    {\n+      // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+      while (in.hasRemaining ())\n+      {\n+        byte b = in.get ();\n+\n+        if (!out.hasRemaining ())\n+          {\n+            in.position (in.position () - 1);\n+            return CoderResult.OVERFLOW;\n+          }\n+\n+        out.put ((char) (b & 0xFF));\n+      }\n+\n+      return CoderResult.UNDERFLOW;\n+    }\n+  }\n+\n+  private static final class Encoder extends CharsetEncoder\n+  {\n+    private Encoder (Charset cs)\n+    {\n+      super (cs, 1.0f, 1.0f);\n+    }\n+\n+    protected CoderResult encodeLoop (CharBuffer in, ByteBuffer out)\n+    {\n+      // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+      while (in.hasRemaining ())\n+      {\n+        char c = in.get ();\n+\n+        if (c > 0xFF)\n+          {\n+            in.position (in.position () - 1);\n+            return CoderResult.unmappableForLength (1);\n+          }\n+        if (!out.hasRemaining ())\n+          {\n+            in.position (in.position () - 1);\n+            return CoderResult.OVERFLOW;\n+          }\n+\n+        out.put ((byte) c);\n+      }\n+\n+      return CoderResult.UNDERFLOW;\n+    }\n+  }\n+}"}, {"sha": "13f637113e599a2a4c96bfe9dd912efc20b3cad0", "filename": "libjava/gnu/java/nio/charset/Provider.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FProvider.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,135 @@\n+/* Provider.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.spi.CharsetProvider;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * Charset provider for the required charsets.  Used by\n+ * {@link Charset#charsetForName} and * {@link Charset#availableCharsets}.\n+ *\n+ * @author Jesse Rosenstock\n+ * @see Charset\n+ */\n+public final class Provider extends CharsetProvider\n+{\n+  private static Provider singleton;\n+\n+  static\n+  {\n+    synchronized (Provider.class)\n+      {\n+        singleton = null;\n+      }\n+  }\n+\n+  /**\n+   * Map from charset name to charset canonical name.\n+   */\n+  private final HashMap canonicalNames;\n+\n+  /**\n+   * Map from canonical name to Charset.\n+   * TODO: We may want to use soft references.  We would then need to keep\n+   * track of the class name to regenerate the object.\n+   */\n+  private final HashMap charsets;\n+\n+  private Provider ()\n+  {\n+    // FIXME: We might need to make the name comparison case insensitive.\n+    // Verify this with the Sun JDK.\n+    canonicalNames = new HashMap ();\n+    charsets = new HashMap ();\n+\n+    // US-ASCII aka ISO646-US\n+    addCharset (new US_ASCII ());\n+\n+    // ISO-8859-1 aka ISO-LATIN-1\n+    addCharset (new ISO_8859_1 ());\n+\n+    // UTF-8\n+    addCharset (new UTF_8 ());\n+\n+    // UTF-16BE\n+    addCharset (new UTF_16BE ());\n+\n+    // UTF-16LE\n+    addCharset (new UTF_16LE ());\n+\n+    // UTF-16\n+    addCharset (new UTF_16 ());\n+  }\n+\n+  public Iterator charsets ()\n+  {\n+    return Collections.unmodifiableCollection (charsets.values ())\n+                      .iterator ();\n+  }\n+\n+  public Charset charsetForName (String charsetName)\n+  {\n+    return (Charset) charsets.get (canonicalize (charsetName));\n+  }\n+\n+  private Object canonicalize (String charsetName)\n+  {\n+    Object o = canonicalNames.get (charsetName);\n+    return o == null ? charsetName : o;\n+  }\n+\n+  private void addCharset (Charset cs)\n+  {\n+    String canonicalName = cs.name ();\n+    charsets.put (canonicalName, cs);\n+\n+    for (Iterator i = cs.aliases ().iterator (); i.hasNext (); )\n+      canonicalNames.put (i.next (), canonicalName);\n+  }\n+\n+  public static synchronized Provider provider ()\n+  {\n+    if (singleton == null)\n+      singleton = new Provider ();\n+    return singleton;\n+  }\n+}"}, {"sha": "a1ff25104025d3d5a45f40a059cea10e5b141e33", "filename": "libjava/gnu/java/nio/charset/US_ASCII.java", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUS_ASCII.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUS_ASCII.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUS_ASCII.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,137 @@\n+/* US_ASCII.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * US-ASCII charset.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class US_ASCII extends Charset\n+{\n+  US_ASCII ()\n+  {\n+    super (\"US-ASCII\", new String[]{\"ISO646-US\"});\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new Decoder (this);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new Encoder (this);\n+  }\n+\n+  private static final class Decoder extends CharsetDecoder\n+  {\n+    private Decoder (Charset cs)\n+    {\n+      super (cs, 1.0f, 1.0f);\n+    }\n+\n+    protected CoderResult decodeLoop (ByteBuffer in, CharBuffer out)\n+    {\n+      // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+      while (in.hasRemaining ())\n+        {\n+          byte b = in.get ();\n+\n+          if (b < 0)\n+            {\n+              in.position (in.position () - 1);\n+              return CoderResult.malformedForLength (1);\n+            }\n+          if (!out.hasRemaining ())\n+            {\n+              in.position (in.position () - 1);\n+              return CoderResult.OVERFLOW;\n+            }\n+\n+          out.put ((char) b);\n+        }\n+\n+      return CoderResult.UNDERFLOW;\n+    }\n+  }\n+\n+  private static final class Encoder extends CharsetEncoder\n+  {\n+    private Encoder (Charset cs)\n+    {\n+      super (cs, 1.0f, 1.0f);\n+    }\n+\n+    protected CoderResult encodeLoop (CharBuffer in, ByteBuffer out)\n+    {\n+      // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+      while (in.hasRemaining ())\n+      {\n+        char c = in.get ();\n+\n+        if (c > Byte.MAX_VALUE)\n+          {\n+            in.position (in.position () - 1);\n+            return CoderResult.unmappableForLength (1);\n+          }\n+        if (!out.hasRemaining ())\n+          {\n+            in.position (in.position () - 1);\n+            return CoderResult.OVERFLOW;\n+          }\n+\n+        out.put ((byte) c);\n+      }\n+\n+      return CoderResult.UNDERFLOW;\n+    }\n+  }\n+}"}, {"sha": "18c9be7f4b2db8b2cbea3570a9e28bc42f54ff91", "filename": "libjava/gnu/java/nio/charset/UTF_16.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,75 @@\n+/* UTF_16.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * UTF-16 charset.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_16 extends Charset\n+{\n+  UTF_16 ()\n+  {\n+    super (\"UTF-16\", null);\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII || cs instanceof ISO_8859_1\n+      || cs instanceof UTF_8 || cs instanceof UTF_16BE\n+      || cs instanceof UTF_16LE || cs instanceof UTF_16;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new UTF_16Decoder (this, UTF_16Decoder.UNKNOWN_ENDIAN);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new UTF_16Encoder (this, UTF_16Encoder.BIG_ENDIAN, false);\n+  }\n+}"}, {"sha": "6fb28cdf830faf7ee088da75f4faf6e966ba473a", "filename": "libjava/gnu/java/nio/charset/UTF_16BE.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16BE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16BE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16BE.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,75 @@\n+/* UTF_16BE.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * UTF-16BE charset.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_16BE extends Charset\n+{\n+  UTF_16BE ()\n+  {\n+    super (\"UTF-16BE\", null);\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII || cs instanceof ISO_8859_1\n+      || cs instanceof UTF_8 || cs instanceof UTF_16BE\n+      || cs instanceof UTF_16LE || cs instanceof UTF_16;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new UTF_16Decoder (this, UTF_16Decoder.BIG_ENDIAN);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new UTF_16Encoder (this, UTF_16Encoder.BIG_ENDIAN, true);\n+  }\n+}"}, {"sha": "c8e474d5741de1a56a6f428fd852bf8e047fc55d", "filename": "libjava/gnu/java/nio/charset/UTF_16Decoder.java", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Decoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Decoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Decoder.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,169 @@\n+/* UTF_16Decoder.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * Decoder for UTF-16, UTF-15LE, and UTF-16BE.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_16Decoder extends CharsetDecoder\n+{\n+  // byte orders\n+  static final int BIG_ENDIAN = 0;\n+  static final int LITTLE_ENDIAN = 1;\n+  static final int UNKNOWN_ENDIAN = 2;\n+\n+  private static final char BYTE_ORDER_MARK = '\\uFEFF';\n+  private static final char REVERSED_BYTE_ORDER_MARK = '\\uFFFE';\n+\n+  private final int originalByteOrder;\n+  private int byteOrder;\n+\n+  UTF_16Decoder (Charset cs, int byteOrder)\n+  {\n+    super (cs, 0.5f, 1.0f);\n+    this.originalByteOrder = byteOrder;\n+    this.byteOrder = byteOrder;\n+  }\n+\n+  protected CoderResult decodeLoop (ByteBuffer in, CharBuffer out)\n+  {\n+    // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+\n+    int inPos = in.position ();\n+    try\n+      {\n+        while (in.remaining () >= 2)\n+          {\n+            byte b1 = in.get ();\n+            byte b2 = in.get ();\n+\n+            // handle byte order mark\n+            if (byteOrder == UNKNOWN_ENDIAN)\n+              {\n+                char c = (char) ((b1 << 8) | b2);\n+                if (c == BYTE_ORDER_MARK)\n+                  {\n+                    byteOrder = BIG_ENDIAN;\n+                    inPos += 2;\n+                    continue;\n+                  }\n+                else if (c == REVERSED_BYTE_ORDER_MARK)\n+                  {\n+                    byteOrder = LITTLE_ENDIAN;\n+                    inPos += 2;\n+                    continue;\n+                  }\n+                else\n+                  {\n+                    // assume big endian, do not consume bytes,\n+                    // continue with normal processing\n+                    byteOrder = BIG_ENDIAN;\n+                  }\n+              }\n+\n+            char c = byteOrder == BIG_ENDIAN ? (char) ((b1 << 8) | b2)\n+                                             : (char) ((b2 << 8) | b1);\n+\n+            if (0xD800 <= c && c <= 0xDFFF)\n+              {\n+                // c is a surrogate\n+                \n+                // make sure c is a high surrogate\n+                if (c > 0xDBFF)\n+                  return CoderResult.malformedForLength (2);\n+                if (in.remaining () < 2)\n+                  return CoderResult.UNDERFLOW;\n+                byte b3 = in.get ();\n+                byte b4 = in.get ();\n+                char d = byteOrder == BIG_ENDIAN ? (char) ((b3 << 8) | b4)\n+                                                 : (char) ((b4 << 8) | b3);\n+                // make sure d is a low surrogate\n+                if (d < 0xDC00 || d > 0xDFFF)\n+                  return CoderResult.malformedForLength (2);\n+                out.put (c);\n+                out.put (d);\n+                inPos += 4;\n+              }\n+            else\n+              {\n+                if (!out.hasRemaining ())\n+                  return CoderResult.UNDERFLOW;\n+                out.put (c);\n+                inPos += 2;\n+              }\n+          }\n+\n+        return CoderResult.UNDERFLOW;\n+      }\n+    finally\n+      {\n+        in.position (inPos);\n+      }\n+  }\n+\n+  /**\n+   * Writes <code>c</code> to <code>out</code> in the byte order\n+   * specified by <code>byteOrder</code>.\n+   **/\n+  private void put (ByteBuffer out, char c)\n+  {\n+    if (byteOrder == BIG_ENDIAN)\n+      {\n+        out.put ((byte) (c >> 8));\n+        out.put ((byte) (c & 0xFF));\n+      }\n+    else\n+      {\n+        out.put ((byte) (c & 0xFF));\n+        out.put ((byte) (c >> 8));\n+      }\n+  }\n+\n+  protected void implReset ()\n+  {\n+    byteOrder = originalByteOrder;\n+  }\n+}"}, {"sha": "b0cb9ed8ce117f7490cf6600e230b59336256d17", "filename": "libjava/gnu/java/nio/charset/UTF_16Encoder.java", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Encoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Encoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16Encoder.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,153 @@\n+/* UTF_16Encoder.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * Encoder for UTF-16, UTF-15LE, and UTF-16BE.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_16Encoder extends CharsetEncoder\n+{\n+  // byte orders\n+  static final int BIG_ENDIAN = 0;\n+  static final int LITTLE_ENDIAN = 1;\n+\n+  private static final char BYTE_ORDER_MARK = '\\uFEFF';\n+\n+  private final int byteOrder;\n+  private final boolean useByteOrderMark;\n+  private boolean needsByteOrderMark;\n+\n+  UTF_16Encoder (Charset cs, int byteOrder, boolean useByteOrderMark)\n+  {\n+    super (cs, 2.0f,\n+           useByteOrderMark ? 4.0f : 2.0f,\n+           byteOrder == BIG_ENDIAN\n+             ? new byte[] { (byte) 0xFF, (byte) 0xFD }\n+             : new byte[] { (byte) 0xFD, (byte) 0xFF });\n+    this.byteOrder = byteOrder;\n+    this.useByteOrderMark = useByteOrderMark;\n+    this.needsByteOrderMark = useByteOrderMark;\n+  }\n+\n+  protected CoderResult encodeLoop (CharBuffer in, ByteBuffer out)\n+  {\n+    // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+\n+    if (needsByteOrderMark)\n+      {\n+        if (out.remaining () < 2)\n+          return CoderResult.OVERFLOW;\n+        put (out, BYTE_ORDER_MARK);\n+        needsByteOrderMark = false;\n+      }\n+\n+    int inPos = in.position ();\n+    try\n+      {\n+        while (in.hasRemaining ())\n+          {\n+            char c = in.get ();\n+\n+            if (0xD800 <= c && c <= 0xDFFF)\n+              {\n+                // c is a surrogate\n+\n+                // make sure c is a high surrogate\n+                if (c > 0xDBFF)\n+                  return CoderResult.malformedForLength (1);\n+                if (in.remaining () < 1)\n+                  return CoderResult.UNDERFLOW;\n+                char d = in.get ();\n+                // make sure d is a low surrogate\n+                if (d < 0xDC00 || d > 0xDFFF)\n+                  return CoderResult.malformedForLength (1);\n+                put (out, c);\n+                put (out, d);\n+                inPos += 2;\n+              }\n+            else\n+              {\n+                if (out.remaining () < 2)\n+                  return CoderResult.OVERFLOW;\n+                put (out, c);\n+                inPos++;\n+              }\n+          }\n+\n+        return CoderResult.UNDERFLOW;\n+      }\n+    finally\n+      {\n+        in.position (inPos);\n+      }\n+  }\n+\n+  /**\n+   * Writes <code>c</code> to <code>out</code> in the byte order\n+   * specified by <code>byteOrder</code>.\n+   **/\n+  private void put (ByteBuffer out, char c)\n+  {\n+    if (byteOrder == BIG_ENDIAN)\n+      {\n+        out.put ((byte) (c >> 8));\n+        out.put ((byte) (c & 0xFF));\n+      }\n+    else\n+      {\n+        out.put ((byte) (c & 0xFF));\n+        out.put ((byte) (c >> 8));\n+      }\n+  }\n+\n+  protected void implReset ()\n+  {\n+    needsByteOrderMark = useByteOrderMark;\n+  }\n+\n+  // TODO: override canEncode(char) and canEncode(CharSequence)\n+  // for performance\n+}"}, {"sha": "b914ae072733121e0d59eddc0faa12eeb8057e06", "filename": "libjava/gnu/java/nio/charset/UTF_16LE.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16LE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16LE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_16LE.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,75 @@\n+/* UTF_16LE.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * UTF-16LE charset.\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_16LE extends Charset\n+{\n+  UTF_16LE ()\n+  {\n+    super (\"UTF-16LE\", null);\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII || cs instanceof ISO_8859_1\n+      || cs instanceof UTF_8 || cs instanceof UTF_16BE\n+      || cs instanceof UTF_16LE || cs instanceof UTF_16;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new UTF_16Decoder (this, UTF_16Decoder.LITTLE_ENDIAN);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new UTF_16Encoder (this, UTF_16Encoder.LITTLE_ENDIAN, true);\n+  }\n+}"}, {"sha": "aa623b2f2cfddf35f8e9b9def1ee8af20a2d501d", "filename": "libjava/gnu/java/nio/charset/UTF_8.java", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_8.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a423d779f598036c5e9048fb949494a7a98d564/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_8.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fcharset%2FUTF_8.java?ref=8a423d779f598036c5e9048fb949494a7a98d564", "patch": "@@ -0,0 +1,279 @@\n+/* UTF_8.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+\n+/**\n+ * UTF-8 charset.\n+ * \n+ * <p> UTF-8 references:\n+ * <ul>\n+ *   <li> <a href=\"http://ietf.org/rfc/rfc2279.txt\">RFC 2279</a>\n+ *   <li> The <a href=\"http://www.unicode.org/unicode/standard/standard.html\">\n+ *     Unicode standard</a> and \n+ *     <a href=\"http://www.unicode.org/versions/corrigendum1.html\">\n+ *      Corrigendum</a>\n+ * </ul>\n+ *\n+ * @author Jesse Rosenstock\n+ */\n+final class UTF_8 extends Charset\n+{\n+  UTF_8 ()\n+  {\n+    super (\"UTF-8\", null);\n+  }\n+\n+  public boolean contains (Charset cs)\n+  {\n+    return cs instanceof US_ASCII || cs instanceof ISO_8859_1\n+      || cs instanceof UTF_8 || cs instanceof UTF_16BE\n+      || cs instanceof UTF_16LE || cs instanceof UTF_16;\n+  }\n+\n+  public CharsetDecoder newDecoder ()\n+  {\n+    return new Decoder (this);\n+  }\n+\n+  public CharsetEncoder newEncoder ()\n+  {\n+    return new Encoder (this);\n+  }\n+\n+  private static final class Decoder extends CharsetDecoder\n+  {\n+    private Decoder (Charset cs)\n+    {\n+      super (cs, 1.0f, 1.0f);\n+    }\n+\n+    protected CoderResult decodeLoop (ByteBuffer in, CharBuffer out)\n+    {\n+      // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+      int inPos = 0;\n+      try\n+        {\n+          while (in.hasRemaining ())\n+            {\n+              char c;\n+              byte b1 = in.get ();\n+              int highNibble = (b1 >> 4) & 0xF;\n+\n+              switch (highNibble)\n+                {\n+                  case 0: case 1: case 2: case 3:\n+                  case 4: case 5: case 6: case 7:\n+                    if (out.remaining () < 1)\n+                      return CoderResult.OVERFLOW;\n+                    out.put ((char) b1);\n+                    inPos++;\n+                    break;\n+\n+                  case 0xC: case 0xD:\n+                    byte b2;\n+                    if (in.remaining () < 1)\n+                      return CoderResult.UNDERFLOW;\n+                    if (out.remaining () < 1)\n+                      return CoderResult.OVERFLOW;\n+                    if (!isContinuation (b2 = in.get ()))\n+                      return CoderResult.malformedForLength (1);\n+                    c = (char) (((b1 & 0x1F) << 6) | (b2 & 0x3F));\n+                    // check that we had the shortest encoding\n+                    if (c <= 0x7F)\n+                      return CoderResult.malformedForLength (2);\n+                    out.put (c);\n+                    inPos += 2;\n+                    break;\n+\n+                  case 0xE:\n+                    byte b3;\n+                    if (in.remaining () < 2)\n+                      return CoderResult.UNDERFLOW;\n+                    if (out.remaining () < 1)\n+                      return CoderResult.OVERFLOW;\n+                    if (!isContinuation (b2 = in.get ()))\n+                      return CoderResult.malformedForLength (1);\n+                    if (!isContinuation (b3 = in.get ()))\n+                      return CoderResult.malformedForLength (1);\n+                    c = (char) (((b1 & 0x0F) << 12)\n+                                | ((b2 & 0x3F) << 6)\n+                                | (b3 & 0x3F));\n+                    // check that we had the shortest encoding\n+                    if (c <= 0x7FF)\n+                      return CoderResult.malformedForLength (3);\n+                    out.put (c);\n+                    inPos += 3;\n+                    break;\n+\n+                  default:\n+                    return CoderResult.malformedForLength (1);\n+                }\n+            }\n+\n+          return CoderResult.UNDERFLOW;\n+        }\n+      finally\n+        {\n+          // In case we did a get(), then encountered an error, reset the\n+          // position to before the error.  If there was no error, this\n+          // will benignly reset the position to the value it already has.\n+          in.position (inPos);\n+        }\n+    }\n+\n+    private static boolean isContinuation (byte b)\n+    {\n+      return (b & 0xC0) == 0x80;\n+    }\n+  }\n+\n+  private static final class Encoder extends CharsetEncoder\n+  {\n+    private Encoder (Charset cs)\n+    {\n+      // According to\n+      // http://www-106.ibm.com/developerworks/unicode/library/utfencodingforms/index.html\n+      //   On average, English takes slightly over one unit per code point.\n+      //   Most Latin-script languages take about 1.1 bytes. Greek, Russian,\n+      //   Arabic and Hebrew take about 1.7 bytes, and most others (including\n+      //   Japanese, Chinese, Korean and Hindi) take about 3 bytes.\n+      // We assume we will be dealing with latin scripts, and use 1.1 \n+      // for averageBytesPerChar.\n+      super (cs, 1.1f, 4.0f);\n+    }\n+\n+    protected CoderResult encodeLoop (CharBuffer in, ByteBuffer out)\n+    {\n+      int inPos = 0;\n+      try\n+        {\n+          // TODO: Optimize this in the case in.hasArray() / out.hasArray()\n+          while (in.hasRemaining ())\n+          {\n+            int remaining = out.remaining ();\n+            char c = in.get ();\n+\n+            // UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n+            // 0000 0000-0000 007F   0xxxxxxx\n+            // 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n+            // 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n+\n+            //        Scalar Value          UTF-16                byte 1     byte 2     byte 3     byte 4\n+            //        0000 0000 0xxx xxxx   0000 0000 0xxx xxxx   0xxx xxxx\n+            //        0000 0yyy yyxx xxxx   0000 0yyy yyxx xxxx   110y yyyy  10xx xxxx\n+            //        zzzz yyyy yyxx xxxx   zzzz yyyy yyxx xxxx   1110 zzzz  10yy yyyy  10xx xxxx\n+            // u uuuu zzzz yyyy yyxx xxxx   1101 10ww wwzz zzyy   1111 0uuu  10uu zzzz  10yy yyyy  10xx xxxx\n+            //                            + 1101 11yy yyxx xxxx\n+            // Note: uuuuu = wwww + 1\n+\n+            if (c <= 0x7F)\n+              {\n+                if (remaining < 1)\n+                  return CoderResult.OVERFLOW;\n+                out.put ((byte) c);\n+                inPos++;\n+              }\n+            else if (c <= 0x7FF)\n+              {\n+                if (remaining < 2)\n+                  return CoderResult.OVERFLOW;\n+                out.put ((byte) (0xC0 | (c >> 6)));\n+                out.put ((byte) (0x80 | (c & 0x3F)));\n+                inPos++;\n+              }\n+            else if (0xD800 <= c && c <= 0xDFFF)\n+              {\n+                if (remaining < 4)\n+                  return CoderResult.OVERFLOW;\n+\n+                // we got a low surrogate without a preciding high one\n+                if (c > 0xDBFF)\n+                  return CoderResult.malformedForLength (1);\n+\n+                // high surrogates\n+                if (!in.hasRemaining ())\n+                  return CoderResult.UNDERFLOW;\n+\n+                char d = in.get ();\n+\n+                // make sure d is a low surrogate\n+                if (d < 0xDC00 || d > 0xDFFF)\n+                  return CoderResult.malformedForLength (1);\n+\n+                // make the 32 bit value\n+                // int value2 = (c - 0xD800) * 0x400 + (d - 0xDC00) + 0x10000;\n+                int value = (((c & 0x3FF) << 10) | (d & 0x3FF)) + 0x10000;\n+                // assert value == value2;\n+                out.put ((byte) (0xF0 | (value >> 18)));\n+                out.put ((byte) (0x80 | ((value >> 12) & 0x3F)));\n+                out.put ((byte) (0x80 | ((value >>  6) & 0x3F)));\n+                out.put ((byte) (0x80 | ((value      ) & 0x3F)));\n+                \n+                inPos += 2;\n+              }\n+            else\n+              {\n+                if (remaining < 3)\n+                  return CoderResult.OVERFLOW;\n+\n+                out.put ((byte) (0xE0 | (c >> 12)));\n+                out.put ((byte) (0x80 | ((c >> 6) & 0x3F)));\n+                out.put ((byte) (0x80 | (c & 0x3F)));\n+                inPos++;\n+              }\n+          }\n+\n+          return CoderResult.UNDERFLOW;\n+        }\n+      finally\n+        {\n+          // In case we did a get(), then encountered an error, reset the\n+          // position to before the error.  If there was no error, this\n+          // will benignly reset the position to the value it already has.\n+          in.position (inPos);\n+        }\n+    }\n+  }\n+}"}]}