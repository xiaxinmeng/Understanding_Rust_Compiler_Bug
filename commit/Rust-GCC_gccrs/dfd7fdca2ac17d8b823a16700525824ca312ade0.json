{"sha": "dfd7fdca2ac17d8b823a16700525824ca312ade0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkN2ZkY2EyYWMxN2Q4YjgyM2ExNjcwMDUyNTgyNGNhMzEyYWRlMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-12-19T15:08:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-12-19T15:08:21Z"}, "message": "C++: more location wrapper nodes (PR c++/43064, PR c++/43486)\n\nThis is v6 of the patch, as posted to:\n  https://gcc.gnu.org/ml/gcc-patches/2018-12/msg01331.html\n\n\nThe C++ frontend gained various location wrapper nodes in r256448 (GCC 8).\nThat patch:\n  https://gcc.gnu.org/ml/gcc-patches/2018-01/msg00799.html\nadded wrapper nodes around all nodes with !CAN_HAVE_LOCATION_P for:\n\n* arguments at callsites, and for\n\n* typeid, alignof, sizeof, and offsetof.\n\nThis is a followup to that patch, adding many more location wrappers\nto the C++ frontend.  It adds location wrappers for nodes with\n!CAN_HAVE_LOCATION_P to:\n\n* all literal nodes (in cp_parser_primary_expression)\n\n* all id-expression nodes (in finish_id_expression), except within a\n  decltype.\n\n* all mem-initializer nodes within a mem-initializer-list\n  (in cp_parser_mem_initializer)\n\nHowever, the patch also adds some suppressions: regions in the parser\nfor which wrapper nodes will not be created:\n\n* within a template-parameter-list or template-argument-list (in\n  cp_parser_template_parameter_list and cp_parser_template_argument_list\n  respectively), to avoid encoding the spelling location of the nodes\n  in types.  For example, \"array<10>\" and \"array<10>\" are the same type,\n  despite the fact that the two different \"10\" tokens are spelled in\n  different locations in the source.\n\n* within a gnu-style attribute (none of are handlers are set up to cope\n  with location wrappers yet)\n\n* within various OpenMP clauses\n\nThe patch enables various improvements to locations for bad\ninitializations, for -Wchar-subscripts, and enables various other\nimprovements in the followup patch.\n\nFor example, given the followup buggy mem-initializer:\n\nclass X {\n  X() : bad(42),\n        good(42)\n  { }\n  void* bad;\n  int good;\n};\n\npreviously, our diagnostic was on the final close parenthesis of the\nmem-initializer-list, leaving it unclear where the problem is:\n\nt.cc: In constructor 'X::X()':\nt.cc:3:16: error: invalid conversion from 'int' to 'void*' [-fpermissive]\n    3 |         good(42)\n      |                ^\n      |                |\n      |                int\n\nwhereas with the patch we highlight which expression is bogus:\n\nt.cc: In constructor 'X::X()':\nt.cc:2:13: error: invalid conversion from 'int' to 'void*' [-fpermissive]\n    2 |   X() : bad(42),\n      |             ^~\n      |             |\n      |             int\n\nSimilarly, the diagnostic for this bogus initialization:\n\ni.cc:1:44: error: initializer-string for array of chars is too long [-fpermissive]\n    1 | char test[3][4] = { \"ok\", \"too long\", \"ok\" };\n      |                                            ^\n\nis improved by the patch so that it indicates which string is too long:\n\ni.cc:1:27: error: initializer-string for array of chars is too long [-fpermissive]\n    1 | char test[3][4] = { \"ok\", \"too long\", \"ok\" };\n      |                           ^~~~~~~~~~\n\n\ngcc/c-family/ChangeLog:\n\tPR c++/43064\n\tPR c++/43486\n\t* c-common.c (unsafe_conversion_p): Fold any location wrapper.\n\t(verify_tree): Handle location wrappers.\n\t(c_common_truthvalue_conversion): Strip any location wrapper.\n\tHandle CONST_DECL.\n\t(fold_offsetof): Strip any location wrapper.\n\t(complete_array_type): Likewise for initial_value.\n\t(convert_vector_to_array_for_subscript): Call fold_for_warn on the\n\tindex before checking for INTEGER_CST.\n\t* c-pretty-print.c (c_pretty_printer::primary_expression): Don't\n\tprint parentheses around location wrappers.\n\t* c-warn.c (warn_logical_operator): Call fold_for_warn on op_right\n\tbefore checking for INTEGER_CST.\n\t(warn_tautological_bitwise_comparison): Call\n\ttree_strip_any_location_wrapper on lhs, rhs, and bitop's operand\n\tbefore checking for INTEGER_CST.\n\t(readonly_error): Strip any location wrapper.\n\t(warn_array_subscript_with_type_char): Strip location wrappers\n\tbefore checking for INTEGER_CST.  Use the location of the index if\n\tavailable.\n\ngcc/ChangeLog:\n\tPR c++/43064\n\tPR c++/43486\n\t* convert.c: Include \"selftest.h\".\n\t(preserve_any_location_wrapper): New function.\n\t(convert_to_pointer_maybe_fold): Update to handle location\n\twrappers.\n\t(convert_to_real_maybe_fold): Likewise.\n\t(convert_to_integer_1): Strip expr when using TREE_OVERFLOW.\n\tHandle location wrappers when checking for INTEGER_CST.\n\t(convert_to_integer_maybe_fold): Update to handle location\n\twrappers.\n\t(convert_to_complex_maybe_fold): Likewise.\n\t(selftest::test_convert_to_integer_maybe_fold): New functions.\n\t(selftest::convert_c_tests): New function.\n\t* convert.h (preserve_any_location_wrapper): New decl.\n\t* fold-const.c (size_binop_loc): Strip location wrappers when\n\tusing TREE_OVERFLOW.\n\t(operand_equal_p): Strip any location wrappers.\n\t(integer_valued_real_p): Strip any location wrapper.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::convert_c_tests.\n\t* selftest.h (selftest::convert_c_tests): New decl.\n\t* tree.c (build_complex): Assert that REAL and IMAG are constants.\n\t(integer_zerop): Look through location wrappers.\n\t(integer_onep): Likewise.\n\t(integer_each_onep): Likewise.\n\t(integer_all_onesp): Likewise.\n\t(integer_minus_onep): Likewise.\n\t(integer_pow2p): Likewise.\n\t(integer_nonzerop): Likewise.\n\t(integer_truep): Likewise.\n\t(fixed_zerop): Likewise.\n\t(real_zerop): Likewise.\n\t(real_onep): Likewise.\n\t(real_minus_onep): Likewise.\n\t(tree_int_cst_equal): Likewise.\n\t(simple_cst_equal): Treat location wrappers with non-equal source\n\tlocations as being unequal.\n\t(uniform_integer_cst_p): Look through location wrappers.\n\t(maybe_wrap_with_location): Don't create wrappers if any\n\tauto_suppress_location_wrappers are active.\n\t(suppress_location_wrappers): New variable.\n\t(selftest::test_predicates): New test.\n\t(selftest::tree_c_tests): Call it.\n\t* tree.h (CONSTANT_CLASS_OR_WRAPPER_P): New macro.\n\t(suppress_location_wrappers): New decl.\n\t(class auto_suppress_location_wrappers): New class.\n\ngcc/cp/ChangeLog:\n\tPR c++/43064\n\tPR c++/43486\n\t* call.c (build_conditional_expr_1): Strip location wrappers when\n\tchecking for CONST_DECL.\n\t(conversion_null_warnings): Use location of \"expr\" if available.\n\t* class.c (fixed_type_or_null): Handle location wrappers.\n\t* constexpr.c (potential_constant_expression_1): Likewise.\n\t* cvt.c (ignore_overflows): Strip location wrappers when\n\tchecking for INTEGER_CST, and re-wrap the result if present.\n\t(ocp_convert): Call fold_for_warn before checking for INTEGER_CST.\n\t* decl.c (reshape_init_r): Strip any location wrapper.\n\t(undeduced_auto_decl): Likewise.\n\t* expr.c (mark_discarded_use): Likewise for expr.\n\t* init.c (build_aggr_init): Likewise before checking init for\n\tDECL_P.\n\t(warn_placement_new_too_small): Call fold_for_warn on adj before\n\tchecking for CONSTANT_CLASS_P, and on nelts.  Strip any location\n\twrapper from op0 and on oper before checking for VAR_P.\n\t* parser.c (cp_parser_primary_expression): Call\n\tmaybe_add_location_wrapper on numeric and string literals.\n\t(cp_parser_postfix_expression): Strip any location wrapper when\n\tchecking for DECL_IS_BUILTIN_CONSTANT_P.\n\t(cp_parser_unary_expression): Ensure that folding of NEGATE_EXPR\n\taround a constant happens in the presence of location wrappers and\n\treturns a wrapped result.\n\t(cp_parser_has_attribute_expression): Strip any location wrapper\n\tfrom \"oper\".\n\t(cp_parser_binary_expression): Strip any location wrapper when\n\tchecking for DECL_P on the lhs.\n\t(cp_parser_decltype): Strip any location wrapper from result of\n\tcp_parser_decltype_expr.\n\t(cp_parser_mem_initializer): Add location wrappers to the\n\tparenthesized expression list.\n\t(cp_parser_template_parameter_list): Don't create wrapper nodes\n\twithin a template-parameter-list.\n\t(cp_parser_template_argument_list): Don't create wrapper nodes\n\twithin a template-argument-list.\n\t(cp_parser_parameter_declaration): Strip location wrappers from\n\tdefault arguments.\n\t(cp_parser_gnu_attribute_list): Don't create wrapper nodes.\n\t(cp_parser_std_attribute_spec_seq): Likewise.\n\t(cp_parser_omp_all_clauses): Don't create wrapper nodes within\n\tOpenMP clauses.\n\t(cp_parser_omp_for_loop): Likewise.\n\t(cp_parser_omp_declare_reduction_exprs): Likewise.\n\t* pt.c (convert_nontype_argument_function): Strip location\n\twrappers from fn_no_ptr before checking for FUNCTION_DECL.\n\t(tsubst_default_argument): Move note about which callsite led to\n\tinstantiation to after the check_default_argument call.\n\t(do_auto_deduction): Likewise from init before checking for\n\tDECL_P.\n\t* semantics.c (force_paren_expr): Likewise from expr before\n\tchecking for DECL_P.\n\t(finish_parenthesized_expr): Likewise from expr before\n\tchecking for STRING_CST.\n\t(perform_koenig_lookup): Likewise from fn.\n\t(finish_call_expr): Likewise.\n\t(finish_id_expression): Rename to...\n\t(finish_id_expression_1): ...this, calling\n\tmaybe_add_location_wrapper on the result.\n\t(capture_decltype): Use lookup_name_real rather than value_member\n\twhen looking up decl within the capture-list.\n\t* tree.c (cp_stabilize_reference): Strip any location wrapper.\n\t(builtin_valid_in_constant_expr_p): Likewise.\n\t(strip_typedefs_expr): Strip any location wrapper before checking\n\tfor decls or constants.\n\t(is_overloaded_fn): Likewise.\n\t(maybe_get_fns): Likewise.\n\t(selftest::test_lvalue_kind): Verify lvalue_p.\n\t* typeck.c (cxx_sizeof_expr): Strip any location wrapper.\n\t(cxx_alignof_expr): Likewise.\n\t(is_bitfield_expr_with_lowered_type): Handle location wrappers.\n\t(cp_build_array_ref): Call maybe_constant_value on \"idx\".\n\t(cp_build_binary_op): Strip location wrapper from first_arg before\n\tchecking for PARM_DECL.  Likewise for op1 before checking for\n\tINTEGER_CST in two places.  Likewise for orig_op0 and orig_op1\n\twhen checking for STRING_CST.\n\t(cp_build_addr_expr_1): Likewise for arg when checking for\n\tFUNCTION_DECL.\n\t(cp_build_modify_expr): Likewise for newrhs when checking for\n\tSTRING_CST.\n\t(convert_for_assignment): Don't strip location wrappers when\n\tstripping NON_LVALUE_EXPR.\n\t(maybe_warn_about_returning_address_of_local): Strip location\n\twrapper from whats_returned before checking for DECL_P.\n\t(can_do_nrvo_p): Strip location wrapper from retval.\n\t(treat_lvalue_as_rvalue_p): Likewise.\n\t(check_return_expr): Likewise.\n\t* typeck2.c (cxx_incomplete_type_diagnostic): Strip location\n\twrapper from value before checking for VAR_P or PARM_DECL.\n\t(digest_init_r): Strip location wrapper from init.  When\n\tcopying \"init\", also copy the wrapped node.\n\ngcc/objc/ChangeLog:\n\tPR c++/43064\n\tPR c++/43486\n\t* objc-act.c (objc_maybe_build_component_ref): Strip any location\n\twrapper before checking for UOBJC_SUPER_decl and self_decl.\n\t(objc_finish_message_expr): Strip any location wrapper.\n\t(gen_declaration): Strip location wrappers from \"w\".\n\ngcc/testsuite/ChangeLog:\n\tPR c++/43064\n\tPR c++/43486\n\t* c-c++-common/pr51712.c (valid2): Mark xfail as passing on C++.\n\t* g++.dg/cpp0x/constexpr-47969.C: Update column of expected error.\n\t* g++.dg/cpp0x/constexpr-ex2.C: Likewise.\n\t* g++.dg/cpp0x/scoped_enum2.C: Likewise.\n\t* g++.dg/cpp1z/decomp48.C: Update expected location of warning\n\tfor named local variables to use that of the local variable.\n\t* g++.dg/ext/vla1.C: Update column.\n\t* g++.dg/init/array43.C: Update expected column to be that of the\n\tinitializer.\n\t* g++.dg/init/initializer-string-too-long.C: New test.\n\t* g++.dg/init/new44.C: Add \"-ftrack-macro-expansion=0\".\n\t* g++.dg/init/pr43064-1.C: New test.\n\t* g++.dg/init/pr43064-2.C: New test.\n\t* g++.dg/init/pr43064-3.C: New test.\n\t* g++.dg/other/fold1.C: Update column of expected error.\n\t* g++.dg/parse/crash36.C: Likewise.\n\t* g++.dg/plugin/diagnostic-test-expressions-1.C: Add negative\n\tinteger and float expressions.\n\t* g++.dg/template/defarg6.C: Move expected error to the default\n\targument; add expected message about where instantiated.\n\t* g++.dg/wrappers/Wparentheses.C: New test.\n\t* g++.old-deja/g++.bugs/900402_02.C: Update column of expected\n\terror.\n\nFrom-SVN: r267272", "tree": {"sha": "2bf4bf940ff4bc674f358d0968d5560dbdb0ed76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bf4bf940ff4bc674f358d0968d5560dbdb0ed76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfd7fdca2ac17d8b823a16700525824ca312ade0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd7fdca2ac17d8b823a16700525824ca312ade0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd7fdca2ac17d8b823a16700525824ca312ade0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd7fdca2ac17d8b823a16700525824ca312ade0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a0317e70007d6558e53a2ba5b104ff09b2e9642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0317e70007d6558e53a2ba5b104ff09b2e9642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0317e70007d6558e53a2ba5b104ff09b2e9642"}], "stats": {"total": 1523, "additions": 1309, "deletions": 214}, "files": [{"sha": "4784244002b62887e3696baafeeec687ede7da95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,3 +1,53 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43064\n+\tPR c++/43486\n+\t* convert.c: Include \"selftest.h\".\n+\t(preserve_any_location_wrapper): New function.\n+\t(convert_to_pointer_maybe_fold): Update to handle location\n+\twrappers.\n+\t(convert_to_real_maybe_fold): Likewise.\n+\t(convert_to_integer_1): Strip expr when using TREE_OVERFLOW.\n+\tHandle location wrappers when checking for INTEGER_CST.\n+\t(convert_to_integer_maybe_fold): Update to handle location\n+\twrappers.\n+\t(convert_to_complex_maybe_fold): Likewise.\n+\t(selftest::test_convert_to_integer_maybe_fold): New functions.\n+\t(selftest::convert_c_tests): New function.\n+\t* convert.h (preserve_any_location_wrapper): New decl.\n+\t* fold-const.c (size_binop_loc): Strip location wrappers when\n+\tusing TREE_OVERFLOW.\n+\t(operand_equal_p): Strip any location wrappers.\n+\t(integer_valued_real_p): Strip any location wrapper.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::convert_c_tests.\n+\t* selftest.h (selftest::convert_c_tests): New decl.\n+\t* tree.c (build_complex): Assert that REAL and IMAG are constants.\n+\t(integer_zerop): Look through location wrappers.\n+\t(integer_onep): Likewise.\n+\t(integer_each_onep): Likewise.\n+\t(integer_all_onesp): Likewise.\n+\t(integer_minus_onep): Likewise.\n+\t(integer_pow2p): Likewise.\n+\t(integer_nonzerop): Likewise.\n+\t(integer_truep): Likewise.\n+\t(fixed_zerop): Likewise.\n+\t(real_zerop): Likewise.\n+\t(real_onep): Likewise.\n+\t(real_minus_onep): Likewise.\n+\t(tree_int_cst_equal): Likewise.\n+\t(simple_cst_equal): Treat location wrappers with non-equal source\n+\tlocations as being unequal.\n+\t(uniform_integer_cst_p): Look through location wrappers.\n+\t(maybe_wrap_with_location): Don't create wrappers if any\n+\tauto_suppress_location_wrappers are active.\n+\t(suppress_location_wrappers): New variable.\n+\t(selftest::test_predicates): New test.\n+\t(selftest::tree_c_tests): Call it.\n+\t* tree.h (CONSTANT_CLASS_OR_WRAPPER_P): New macro.\n+\t(suppress_location_wrappers): New decl.\n+\t(class auto_suppress_location_wrappers): New class.\n+\n 2018-12-19  Paul A. Clarke  <pc@us.ibm.com>\n \n \t* config/rs6000/tmmintrin.h (_mm_hadds_epi16): Vector lanes swapped."}, {"sha": "eb148bb25e76c6231c8839981f6e3e3ea73fa624", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,3 +1,27 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43064\n+\tPR c++/43486\n+\t* c-common.c (unsafe_conversion_p): Fold any location wrapper.\n+\t(verify_tree): Handle location wrappers.\n+\t(c_common_truthvalue_conversion): Strip any location wrapper.\n+\tHandle CONST_DECL.\n+\t(fold_offsetof): Strip any location wrapper.\n+\t(complete_array_type): Likewise for initial_value.\n+\t(convert_vector_to_array_for_subscript): Call fold_for_warn on the\n+\tindex before checking for INTEGER_CST.\n+\t* c-pretty-print.c (c_pretty_printer::primary_expression): Don't\n+\tprint parentheses around location wrappers.\n+\t* c-warn.c (warn_logical_operator): Call fold_for_warn on op_right\n+\tbefore checking for INTEGER_CST.\n+\t(warn_tautological_bitwise_comparison): Call\n+\ttree_strip_any_location_wrapper on lhs, rhs, and bitop's operand\n+\tbefore checking for INTEGER_CST.\n+\t(readonly_error): Strip any location wrapper.\n+\t(warn_array_subscript_with_type_char): Strip location wrappers\n+\tbefore checking for INTEGER_CST.  Use the location of the index if\n+\tavailable.\n+\n 2018-12-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/88136 - -Wdeprecated-copy false positives"}, {"sha": "2282515a1925a8019c02e9c1e7da0cccd9af53d0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1250,6 +1250,8 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n \n     loc = expansion_point_location_if_in_system_header (loc);\n \n+  expr = fold_for_warn (expr);\n+\n   if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n     {\n       /* If type is complex, we are interested in compatibility with\n@@ -1947,6 +1949,13 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       writer = 0;\n       goto restart;\n \n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (x))\n+\t{\n+\t  x = TREE_OPERAND (x, 0);\n+\t  goto restart;\n+\t}\n+      gcc_fallthrough ();\n     default:\n       /* For other expressions, simply recurse on their operands.\n \t Manual tail recursion for unary expressions.\n@@ -3241,6 +3250,7 @@ decl_with_nonnull_addr_p (const_tree expr)\n tree\n c_common_truthvalue_conversion (location_t location, tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n   switch (TREE_CODE (expr))\n     {\n     case EQ_EXPR:   case NE_EXPR:   case UNEQ_EXPR: case LTGT_EXPR:\n@@ -3460,6 +3470,14 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t}\n       break;\n \n+    case CONST_DECL:\n+      {\n+\ttree folded_expr = fold_for_warn (expr);\n+\tif (folded_expr != expr)\n+\t  return c_common_truthvalue_conversion (location, folded_expr);\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -6279,6 +6297,7 @@ fold_offsetof (tree expr, tree type, enum tree_code ctx)\n \treturn base;\n \n       t = TREE_OPERAND (expr, 1);\n+      STRIP_ANY_LOCATION_WRAPPER (t);\n \n       /* Check if the offset goes beyond the upper bound of the array.  */\n       if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) >= 0)\n@@ -6357,6 +6376,8 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   maxindex = size_zero_node;\n   if (initial_value)\n     {\n+      STRIP_ANY_LOCATION_WRAPPER (initial_value);\n+\n       if (TREE_CODE (initial_value) == STRING_CST)\n \t{\n \t  int eltsize\n@@ -7906,6 +7927,7 @@ convert_vector_to_array_for_subscript (location_t loc,\n \n       ret = !lvalue_p (*vecp);\n \n+      index = fold_for_warn (index);\n       if (TREE_CODE (index) == INTEGER_CST)\n         if (!tree_fits_uhwi_p (index)\n \t    || maybe_ge (tree_to_uhwi (index), TYPE_VECTOR_SUBPARTS (type)))"}, {"sha": "5a55440778c4a67445450647f3886bf2330ddfcd", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1260,9 +1260,14 @@ c_pretty_printer::primary_expression (tree e)\n \n     default:\n       /* FIXME:  Make sure we won't get into an infinite loop.  */\n-      pp_c_left_paren (this);\n-      expression (e);\n-      pp_c_right_paren (this);\n+      if (location_wrapper_p (e))\n+\texpression (e);\n+      else\n+\t{\n+\t  pp_c_left_paren (this);\n+\t  expression (e);\n+\t  pp_c_right_paren (this);\n+\t}\n       break;\n     }\n }"}, {"sha": "4c0bdf96d4c368068dfa189ff7ae187c3c8f0a5e", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -208,19 +208,22 @@ warn_logical_operator (location_t location, enum tree_code code, tree type,\n   if (!truth_value_p (code_left)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op_left))\n       && !CONSTANT_CLASS_P (op_left)\n-      && !TREE_NO_WARNING (op_left)\n-      && TREE_CODE (op_right) == INTEGER_CST\n-      && !integer_zerop (op_right)\n-      && !integer_onep (op_right))\n+      && !TREE_NO_WARNING (op_left))\n     {\n-      if (or_op)\n-\twarning_at (location, OPT_Wlogical_op, \"logical %<or%>\"\n-\t\t    \" applied to non-boolean constant\");\n-      else\n-\twarning_at (location, OPT_Wlogical_op, \"logical %<and%>\"\n-\t\t    \" applied to non-boolean constant\");\n-      TREE_NO_WARNING (op_left) = true;\n-      return;\n+      tree folded_op_right = fold_for_warn (op_right);\n+      if (TREE_CODE (folded_op_right) == INTEGER_CST\n+\t  && !integer_zerop (folded_op_right)\n+\t  && !integer_onep (folded_op_right))\n+\t{\n+\t  if (or_op)\n+\t    warning_at (location, OPT_Wlogical_op, \"logical %<or%>\"\n+\t\t\t\" applied to non-boolean constant\");\n+\t  else\n+\t    warning_at (location, OPT_Wlogical_op, \"logical %<and%>\"\n+\t\t\t\" applied to non-boolean constant\");\n+\t  TREE_NO_WARNING (op_left) = true;\n+\t  return;\n+\t}\n     }\n \n   /* We do not warn for constants because they are typical of macro\n@@ -340,24 +343,30 @@ warn_tautological_bitwise_comparison (location_t loc, tree_code code,\n   /* Extract the operands from e.g. (x & 8) == 4.  */\n   tree bitop;\n   tree cst;\n+  tree stripped_lhs = tree_strip_any_location_wrapper (lhs);\n+  tree stripped_rhs = tree_strip_any_location_wrapper (rhs);\n   if ((TREE_CODE (lhs) == BIT_AND_EXPR\n        || TREE_CODE (lhs) == BIT_IOR_EXPR)\n-      && TREE_CODE (rhs) == INTEGER_CST)\n-    bitop = lhs, cst = rhs;\n+      && TREE_CODE (stripped_rhs) == INTEGER_CST)\n+    bitop = lhs, cst = stripped_rhs;\n   else if ((TREE_CODE (rhs) == BIT_AND_EXPR\n \t    || TREE_CODE (rhs) == BIT_IOR_EXPR)\n-\t   && TREE_CODE (lhs) == INTEGER_CST)\n-    bitop = rhs, cst = lhs;\n+\t   && TREE_CODE (stripped_lhs) == INTEGER_CST)\n+    bitop = rhs, cst = stripped_lhs;\n   else\n     return;\n \n   tree bitopcst;\n-  if (TREE_CODE (TREE_OPERAND (bitop, 0)) == INTEGER_CST)\n-    bitopcst = TREE_OPERAND (bitop, 0);\n-  else if (TREE_CODE (TREE_OPERAND (bitop, 1)) == INTEGER_CST)\n-    bitopcst = TREE_OPERAND (bitop, 1);\n-  else\n-    return;\n+  tree bitop_op0 = fold_for_warn (TREE_OPERAND (bitop, 0));\n+  if (TREE_CODE (bitop_op0) == INTEGER_CST)\n+    bitopcst = bitop_op0;\n+  else {\n+    tree bitop_op1 = fold_for_warn (TREE_OPERAND (bitop, 1));\n+    if (TREE_CODE (bitop_op1) == INTEGER_CST)\n+      bitopcst = bitop_op1;\n+    else\n+      return;\n+  }\n \n   /* Note that the two operands are from before the usual integer\n      conversions, so their types might not be the same.\n@@ -1529,6 +1538,7 @@ readonly_error (location_t loc, tree arg, enum lvalue_use use)\n {\n   gcc_assert (use == lv_assign || use == lv_increment || use == lv_decrement\n \t      || use == lv_asm);\n+  STRIP_ANY_LOCATION_WRAPPER (arg);\n   /* Using this macro rather than (for example) arrays of messages\n      ensures that all the format strings are checked at compile\n      time.  */\n@@ -1669,15 +1679,22 @@ invalid_indirection_error (location_t loc, tree type, ref_operator errstring)\n    warn for unsigned char since that type is safe.  Don't warn for\n    signed char because anyone who uses that must have done so\n    deliberately. Furthermore, we reduce the false positive load by\n-   warning only for non-constant value of type char.  */\n+   warning only for non-constant value of type char.\n+   LOC is the location of the subscripting expression.  */\n \n void\n warn_array_subscript_with_type_char (location_t loc, tree index)\n {\n-  if (TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node\n-      && TREE_CODE (index) != INTEGER_CST)\n-    warning_at (loc, OPT_Wchar_subscripts,\n-\t\t\"array subscript has type %<char%>\");\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node)\n+    {\n+      /* If INDEX has a location, use it; otherwise use LOC (the location\n+\t of the subscripting expression as a whole).  */\n+      loc = EXPR_LOC_OR_LOC (index, loc);\n+      STRIP_ANY_LOCATION_WRAPPER (index);\n+      if (TREE_CODE (index) != INTEGER_CST)\n+\twarning_at (loc, OPT_Wchar_subscripts,\n+\t\t    \"array subscript has type %<char%>\");\n+    }\n }\n \n /* Implement -Wparentheses for the unexpected C precedence rules, to"}, {"sha": "028497fdf27d16ef4576559b667119007baf0d82", "filename": "gcc/convert.c", "status": "modified", "additions": 125, "deletions": 10, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"selftest.h\"\n \n #define maybe_fold_build1_loc(FOLD_P, LOC, CODE, TYPE, EXPR) \\\n   ((FOLD_P) ? fold_build1_loc (LOC, CODE, TYPE, EXPR)\t     \\\n@@ -98,6 +99,25 @@ convert_to_pointer_1 (tree type, tree expr, bool fold_p)\n     }\n }\n \n+/* Subroutine of the various convert_to_*_maybe_fold routines.\n+\n+   If a location wrapper has been folded to a constant (presumably of\n+   a different type), re-wrap the new constant with a location wrapper.  */\n+\n+tree\n+preserve_any_location_wrapper (tree result, tree orig_expr)\n+{\n+  if (CONSTANT_CLASS_P (result) && location_wrapper_p (orig_expr))\n+    {\n+      if (result == TREE_OPERAND (orig_expr, 0))\n+\treturn orig_expr;\n+      else\n+\treturn maybe_wrap_with_location (result, EXPR_LOCATION (orig_expr));\n+    }\n+\n+  return result;\n+}\n+\n /* A wrapper around convert_to_pointer_1 that always folds the\n    expression.  */\n \n@@ -108,12 +128,15 @@ convert_to_pointer (tree type, tree expr)\n }\n \n /* A wrapper around convert_to_pointer_1 that only folds the\n-   expression if DOFOLD, or if it is CONSTANT_CLASS_P.  */\n+   expression if DOFOLD, or if it is CONSTANT_CLASS_OR_WRAPPER_P.  */\n \n tree\n convert_to_pointer_maybe_fold (tree type, tree expr, bool dofold)\n {\n-  return convert_to_pointer_1 (type, expr, dofold || CONSTANT_CLASS_P (expr));\n+  tree result\n+    = convert_to_pointer_1 (type, expr,\n+\t\t\t    dofold || CONSTANT_CLASS_OR_WRAPPER_P (expr));\n+  return preserve_any_location_wrapper (result, expr);\n }\n \n /* Convert EXPR to some floating-point type TYPE.\n@@ -408,12 +431,15 @@ convert_to_real (tree type, tree expr)\n }\n \n /* A wrapper around convert_to_real_1 that only folds the\n-   expression if DOFOLD, or if it is CONSTANT_CLASS_P.  */\n+   expression if DOFOLD, or if it is CONSTANT_CLASS_OR_WRAPPER_P.  */\n \n tree\n convert_to_real_maybe_fold (tree type, tree expr, bool dofold)\n {\n-  return convert_to_real_1 (type, expr, dofold || CONSTANT_CLASS_P (expr));\n+  tree result\n+    = convert_to_real_1 (type, expr,\n+\t\t\t dofold || CONSTANT_CLASS_OR_WRAPPER_P (expr));\n+  return preserve_any_location_wrapper (result, expr);\n }\n \n /* Try to narrow EX_FORM ARG0 ARG1 in narrowed arg types producing a\n@@ -679,7 +705,8 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n     {\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      if (integer_zerop (expr) && !TREE_OVERFLOW (expr))\n+      if (integer_zerop (expr)\n+\t  && !TREE_OVERFLOW (tree_strip_any_location_wrapper (expr)))\n \treturn build_int_cst (type, 0);\n \n       /* Convert to an unsigned integer of the correct width first, and from\n@@ -959,7 +986,7 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \n       /* When parsing long initializers, we might end up with a lot of casts.\n \t Shortcut this.  */\n-      if (TREE_CODE (expr) == INTEGER_CST)\n+      if (TREE_CODE (tree_strip_any_location_wrapper (expr)) == INTEGER_CST)\n \treturn fold_convert (type, expr);\n       return build1 (CONVERT_EXPR, type, expr);\n \n@@ -1017,12 +1044,15 @@ convert_to_integer (tree type, tree expr)\n }\n \n /* A wrapper around convert_to_complex_1 that only folds the\n-   expression if DOFOLD, or if it is CONSTANT_CLASS_P.  */\n+   expression if DOFOLD, or if it is CONSTANT_CLASS_OR_WRAPPER_P.  */\n \n tree\n convert_to_integer_maybe_fold (tree type, tree expr, bool dofold)\n {\n-  return convert_to_integer_1 (type, expr, dofold || CONSTANT_CLASS_P (expr));\n+  tree result\n+    = convert_to_integer_1 (type, expr,\n+\t\t\t    dofold || CONSTANT_CLASS_OR_WRAPPER_P (expr));\n+  return preserve_any_location_wrapper (result, expr);\n }\n \n /* Convert EXPR to the complex type TYPE in the usual ways.  If FOLD_P is\n@@ -1101,12 +1131,15 @@ convert_to_complex (tree type, tree expr)\n }\n \n /* A wrapper around convert_to_complex_1 that only folds the\n-   expression if DOFOLD, or if it is CONSTANT_CLASS_P.  */\n+   expression if DOFOLD, or if it is CONSTANT_CLASS_OR_WRAPPER_P.  */\n \n tree\n convert_to_complex_maybe_fold (tree type, tree expr, bool dofold)\n {\n-  return convert_to_complex_1 (type, expr, dofold || CONSTANT_CLASS_P (expr));\n+  tree result\n+    = convert_to_complex_1 (type, expr,\n+\t\t\t    dofold || CONSTANT_CLASS_OR_WRAPPER_P (expr));\n+  return preserve_any_location_wrapper (result, expr);\n }\n \n /* Convert EXPR to the vector type TYPE in the usual ways.  */\n@@ -1171,3 +1204,85 @@ convert_to_fixed (tree type, tree expr)\n       return error_mark_node;\n     }\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for conversions.  */\n+\n+static void\n+test_convert_to_integer_maybe_fold (tree orig_type, tree new_type)\n+{\n+  /* Calling convert_to_integer_maybe_fold on an INTEGER_CST.  */\n+\n+  tree orig_cst = build_int_cst (orig_type, 42);\n+\n+  /* Verify that convert_to_integer_maybe_fold on a constant returns a new\n+     constant of the new type, unless the types are the same, in which\n+     case verify it's a no-op.  */\n+  {\n+    tree result = convert_to_integer_maybe_fold (new_type,\n+\t\t\t\t\t\t orig_cst, false);\n+    if (orig_type != new_type)\n+      {\n+\tASSERT_EQ (TREE_TYPE (result), new_type);\n+\tASSERT_EQ (TREE_CODE (result), INTEGER_CST);\n+      }\n+    else\n+      ASSERT_EQ (result, orig_cst);\n+  }\n+\n+  /* Calling convert_to_integer_maybe_fold on a location wrapper around\n+     an INTEGER_CST.\n+\n+     Verify that convert_to_integer_maybe_fold on a location wrapper\n+     around a constant returns a new location wrapper around an equivalent\n+     constant, both of the new type, unless the types are the same,\n+     in which case the original wrapper should be returned.   */\n+  {\n+    const location_t loc = BUILTINS_LOCATION;\n+    tree wrapped_orig_cst = maybe_wrap_with_location (orig_cst, loc);\n+    tree result\n+      = convert_to_integer_maybe_fold (new_type, wrapped_orig_cst, false);\n+    ASSERT_EQ (TREE_TYPE (result), new_type);\n+    ASSERT_EQ (EXPR_LOCATION (result), loc);\n+    ASSERT_TRUE (location_wrapper_p (result));\n+    ASSERT_EQ (TREE_TYPE (TREE_OPERAND (result, 0)), new_type);\n+    ASSERT_EQ (TREE_CODE (TREE_OPERAND (result, 0)), INTEGER_CST);\n+\n+    if (orig_type == new_type)\n+      ASSERT_EQ (result, wrapped_orig_cst);\n+  }\n+}\n+\n+/* Verify that convert_to_integer_maybe_fold preserves locations.  */\n+\n+static void\n+test_convert_to_integer_maybe_fold ()\n+{\n+  /* char -> long.  */\n+  test_convert_to_integer_maybe_fold (char_type_node, long_integer_type_node);\n+\n+  /* char -> char.  */\n+  test_convert_to_integer_maybe_fold (char_type_node, char_type_node);\n+\n+  /* long -> char.  */\n+  test_convert_to_integer_maybe_fold (char_type_node, long_integer_type_node);\n+\n+  /* long -> long.  */\n+  test_convert_to_integer_maybe_fold (long_integer_type_node,\n+\t\t\t\t      long_integer_type_node);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+convert_c_tests ()\n+{\n+  test_convert_to_integer_maybe_fold ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "f3334f973ee0cdbbfc4f797f64a625fea61f96db", "filename": "gcc/convert.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -40,4 +40,6 @@ extern inline tree convert_to_real_nofold (tree t, tree x)\n extern inline tree convert_to_complex_nofold (tree t, tree x)\n { return convert_to_complex_maybe_fold (t, x, false); }\n \n+extern tree preserve_any_location_wrapper (tree result, tree orig_expr);\n+\n #endif /* GCC_CONVERT_H */"}, {"sha": "0ebc36692863ba4e3edd5c9ff20b72afe977d9dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,3 +1,98 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43064\n+\tPR c++/43486\n+\t* call.c (build_conditional_expr_1): Strip location wrappers when\n+\tchecking for CONST_DECL.\n+\t(conversion_null_warnings): Use location of \"expr\" if available.\n+\t* class.c (fixed_type_or_null): Handle location wrappers.\n+\t* constexpr.c (potential_constant_expression_1): Likewise.\n+\t* cvt.c (ignore_overflows): Strip location wrappers when\n+\tchecking for INTEGER_CST, and re-wrap the result if present.\n+\t(ocp_convert): Call fold_for_warn before checking for INTEGER_CST.\n+\t* decl.c (reshape_init_r): Strip any location wrapper.\n+\t(undeduced_auto_decl): Likewise.\n+\t* expr.c (mark_discarded_use): Likewise for expr.\n+\t* init.c (build_aggr_init): Likewise before checking init for\n+\tDECL_P.\n+\t(warn_placement_new_too_small): Call fold_for_warn on adj before\n+\tchecking for CONSTANT_CLASS_P, and on nelts.  Strip any location\n+\twrapper from op0 and on oper before checking for VAR_P.\n+\t* parser.c (cp_parser_primary_expression): Call\n+\tmaybe_add_location_wrapper on numeric and string literals.\n+\t(cp_parser_postfix_expression): Strip any location wrapper when\n+\tchecking for DECL_IS_BUILTIN_CONSTANT_P.\n+\t(cp_parser_unary_expression): Ensure that folding of NEGATE_EXPR\n+\taround a constant happens in the presence of location wrappers and\n+\treturns a wrapped result.\n+\t(cp_parser_has_attribute_expression): Strip any location wrapper\n+\tfrom \"oper\".\n+\t(cp_parser_binary_expression): Strip any location wrapper when\n+\tchecking for DECL_P on the lhs.\n+\t(cp_parser_decltype): Strip any location wrapper from result of\n+\tcp_parser_decltype_expr.\n+\t(cp_parser_mem_initializer): Add location wrappers to the\n+\tparenthesized expression list.\n+\t(cp_parser_template_parameter_list): Don't create wrapper nodes\n+\twithin a template-parameter-list.\n+\t(cp_parser_template_argument_list): Don't create wrapper nodes\n+\twithin a template-argument-list.\n+\t(cp_parser_parameter_declaration): Strip location wrappers from\n+\tdefault arguments.\n+\t(cp_parser_gnu_attribute_list): Don't create wrapper nodes.\n+\t(cp_parser_std_attribute_spec_seq): Likewise.\n+\t(cp_parser_omp_all_clauses): Don't create wrapper nodes within\n+\tOpenMP clauses.\n+\t(cp_parser_omp_for_loop): Likewise.\n+\t(cp_parser_omp_declare_reduction_exprs): Likewise.\n+\t* pt.c (convert_nontype_argument_function): Strip location\n+\twrappers from fn_no_ptr before checking for FUNCTION_DECL.\n+\t(tsubst_default_argument): Move note about which callsite led to\n+\tinstantiation to after the check_default_argument call.\n+\t(do_auto_deduction): Likewise from init before checking for\n+\tDECL_P.\n+\t* semantics.c (force_paren_expr): Likewise from expr before\n+\tchecking for DECL_P.\n+\t(finish_parenthesized_expr): Likewise from expr before\n+\tchecking for STRING_CST.\n+\t(perform_koenig_lookup): Likewise from fn.\n+\t(finish_call_expr): Likewise.\n+\t(finish_id_expression): Rename to...\n+\t(finish_id_expression_1): ...this, calling\n+\tmaybe_add_location_wrapper on the result.\n+\t(capture_decltype): Use lookup_name_real rather than value_member\n+\twhen looking up decl within the capture-list.\n+\t* tree.c (cp_stabilize_reference): Strip any location wrapper.\n+\t(builtin_valid_in_constant_expr_p): Likewise.\n+\t(strip_typedefs_expr): Strip any location wrapper before checking\n+\tfor decls or constants.\n+\t(is_overloaded_fn): Likewise.\n+\t(maybe_get_fns): Likewise.\n+\t(selftest::test_lvalue_kind): Verify lvalue_p.\n+\t* typeck.c (cxx_sizeof_expr): Strip any location wrapper.\n+\t(cxx_alignof_expr): Likewise.\n+\t(is_bitfield_expr_with_lowered_type): Handle location wrappers.\n+\t(cp_build_array_ref): Call maybe_constant_value on \"idx\".\n+\t(cp_build_binary_op): Strip location wrapper from first_arg before\n+\tchecking for PARM_DECL.  Likewise for op1 before checking for\n+\tINTEGER_CST in two places.  Likewise for orig_op0 and orig_op1\n+\twhen checking for STRING_CST.\n+\t(cp_build_addr_expr_1): Likewise for arg when checking for\n+\tFUNCTION_DECL.\n+\t(cp_build_modify_expr): Likewise for newrhs when checking for\n+\tSTRING_CST.\n+\t(convert_for_assignment): Don't strip location wrappers when\n+\tstripping NON_LVALUE_EXPR.\n+\t(maybe_warn_about_returning_address_of_local): Strip location\n+\twrapper from whats_returned before checking for DECL_P.\n+\t(can_do_nrvo_p): Strip location wrapper from retval.\n+\t(treat_lvalue_as_rvalue_p): Likewise.\n+\t(check_return_expr): Likewise.\n+\t* typeck2.c (cxx_incomplete_type_diagnostic): Strip location\n+\twrapper from value before checking for VAR_P or PARM_DECL.\n+\t(digest_init_r): Strip location wrapper from init.  When\n+\tcopying \"init\", also copy the wrapped node.\n+\n 2018-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/87934"}, {"sha": "ef3a02ce01ba50a82555c66d9f370dea7934c892", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -5347,9 +5347,12 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n         {\n-\t  if (TREE_CODE (orig_arg2) == CONST_DECL\n-\t      && TREE_CODE (orig_arg3) == CONST_DECL\n-\t      && DECL_CONTEXT (orig_arg2) == DECL_CONTEXT (orig_arg3))\n+\t  tree stripped_orig_arg2 = tree_strip_any_location_wrapper (orig_arg2);\n+\t  tree stripped_orig_arg3 = tree_strip_any_location_wrapper (orig_arg3);\n+\t  if (TREE_CODE (stripped_orig_arg2) == CONST_DECL\n+\t      && TREE_CODE (stripped_orig_arg3) == CONST_DECL\n+\t      && (DECL_CONTEXT (stripped_orig_arg2)\n+\t\t  == DECL_CONTEXT (stripped_orig_arg3)))\n \t    /* Two enumerators from the same enumeration can have different\n \t       types when the enumeration is still being defined.  */;\n           else if (complain & tf_warning)"}, {"sha": "5d6e12f2578081762a582ff4941a1a3c40603e7c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -7388,6 +7388,14 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t}\n       return NULL_TREE;\n \n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (instance))\n+\treturn RECUR (TREE_OPERAND (instance, 0));\n+      else\n+\t/* TODO: Recursion may be correct for some non-location-wrapper\n+\t   uses of VIEW_CONVERT_EXPR.  */\n+\treturn NULL_TREE;\n+\n     default:\n       return NULL_TREE;\n     }"}, {"sha": "15a30fdcdd0de0bad7c13586068bea3c69f6761a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -5762,13 +5762,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t may change to something more specific to type-punning (DR 1312).  */\n       {\n         tree from = TREE_OPERAND (t, 0);\n-\tif (INDIRECT_TYPE_P (TREE_TYPE (t))\n-\t    && TREE_CODE (from) == INTEGER_CST\n-\t    && !integer_zerop (from))\n+\tif (location_wrapper_p (t))\n+\t  return (RECUR (from, want_rval));\n+\tif (INDIRECT_TYPE_P (TREE_TYPE (t)))\n \t  {\n-\t    if (flags & tf_error)\n-\t      error_at (loc, \"reinterpret_cast from integer to pointer\");\n-\t    return false;\n+\t    STRIP_ANY_LOCATION_WRAPPER (from);\n+\t    if (TREE_CODE (from) == INTEGER_CST\n+\t\t&& !integer_zerop (from))\n+\t      {\n+\t\tif (flags & tf_error)\n+\t\t  error_at (loc, \"reinterpret_cast from integer to pointer\");\n+\t\treturn false;\n+\t      }\n \t  }\n         return (RECUR (from, TREE_CODE (t) != VIEW_CONVERT_EXPR));\n       }"}, {"sha": "f758f2d9bc8f500ae1c728ef59422a7c84180d80", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -582,15 +582,20 @@ force_rvalue (tree expr, tsubst_flags_t complain)\n static tree\n ignore_overflows (tree expr, tree orig)\n {\n-  if (TREE_CODE (expr) == INTEGER_CST\n-      && TREE_CODE (orig) == INTEGER_CST\n-      && TREE_OVERFLOW (expr) != TREE_OVERFLOW (orig))\n+  tree stripped_expr = tree_strip_any_location_wrapper (expr);\n+  tree stripped_orig = tree_strip_any_location_wrapper (orig);\n+\n+  if (TREE_CODE (stripped_expr) == INTEGER_CST\n+      && TREE_CODE (stripped_orig) == INTEGER_CST\n+      && TREE_OVERFLOW (stripped_expr) != TREE_OVERFLOW (stripped_orig))\n     {\n-      gcc_assert (!TREE_OVERFLOW (orig));\n+      gcc_assert (!TREE_OVERFLOW (stripped_orig));\n       /* Ensure constant sharing.  */\n-      expr = wide_int_to_tree (TREE_TYPE (expr), wi::to_wide (expr));\n+      stripped_expr = wide_int_to_tree (TREE_TYPE (stripped_expr),\n+\t\t\t\t\twi::to_wide (stripped_expr));\n     }\n-  return expr;\n+\n+  return preserve_any_location_wrapper (stripped_expr, expr);\n }\n \n /* Fold away simple conversions, but make sure TREE_OVERFLOW is set\n@@ -800,10 +805,11 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t     the original value is within the range of the enumeration\n \t     values. Otherwise, the resulting enumeration value is\n \t     unspecified.  */\n+\t  tree val = fold_for_warn (e);\n \t  if ((complain & tf_warning)\n-\t      && TREE_CODE (e) == INTEGER_CST\n+\t      && TREE_CODE (val) == INTEGER_CST\n \t      && ENUM_UNDERLYING_TYPE (type)\n-\t      && !int_fits_type_p (e, ENUM_UNDERLYING_TYPE (type)))\n+\t      && !int_fits_type_p (val, ENUM_UNDERLYING_TYPE (type)))\n \t    warning_at (loc, OPT_Wconversion, \n \t\t\t\"the result of the conversion is unspecified because \"\n \t\t\t\"%qE is outside the range of type %qT\","}, {"sha": "056bf19268467555968bc78b48ff1368ba8fded4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -6010,14 +6010,16 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n       && has_designator_problem (d, complain))\n     return error_mark_node;\n \n+  tree stripped_init = tree_strip_any_location_wrapper (init);\n+\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n       /* A complex type can be initialized from one or two initializers,\n \t but braces are not elided.  */\n       d->cur++;\n-      if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+      if (BRACE_ENCLOSED_INITIALIZER_P (stripped_init))\n \t{\n-\t  if (CONSTRUCTOR_NELTS (init) > 2)\n+\t  if (CONSTRUCTOR_NELTS (stripped_init) > 2)\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"too many initializers for %qT\", type);\n@@ -6047,16 +6049,16 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t We need to check for BRACE_ENCLOSED_INITIALIZER_P here because\n \t of g++.old-deja/g++.mike/p7626.C: a pointer-to-member constant is\n \t a CONSTRUCTOR (with a record type).  */\n-      if (TREE_CODE (init) == CONSTRUCTOR\n+      if (TREE_CODE (stripped_init) == CONSTRUCTOR\n \t  /* Don't complain about a capture-init.  */\n-\t  && !CONSTRUCTOR_IS_DIRECT_INIT (init)\n-\t  && BRACE_ENCLOSED_INITIALIZER_P (init))  /* p7626.C */\n+\t  && !CONSTRUCTOR_IS_DIRECT_INIT (stripped_init)\n+\t  && BRACE_ENCLOSED_INITIALIZER_P (stripped_init))  /* p7626.C */\n \t{\n \t  if (SCALAR_TYPE_P (type))\n \t    {\n \t      if (cxx_dialect < cxx11\n \t\t  /* Isn't value-initialization.  */\n-\t\t  || CONSTRUCTOR_NELTS (init) > 0)\n+\t\t  || CONSTRUCTOR_NELTS (stripped_init) > 0)\n \t\t{\n \t\t  if (complain & tf_error)\n \t\t    error (\"braces around scalar initializer for type %qT\",\n@@ -6116,20 +6118,22 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n       && char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type))))\n     {\n       tree str_init = init;\n+      tree stripped_str_init = stripped_init;\n \n       /* Strip one level of braces if and only if they enclose a single\n \t element (as allowed by [dcl.init.string]).  */\n       if (!first_initializer_p\n-\t  && TREE_CODE (str_init) == CONSTRUCTOR\n-\t  && CONSTRUCTOR_NELTS (str_init) == 1)\n+\t  && TREE_CODE (stripped_str_init) == CONSTRUCTOR\n+\t  && CONSTRUCTOR_NELTS (stripped_str_init) == 1)\n \t{\n-\t  str_init = (*CONSTRUCTOR_ELTS (str_init))[0].value;\n+\t  str_init = (*CONSTRUCTOR_ELTS (stripped_str_init))[0].value;\n+\t  stripped_str_init = tree_strip_any_location_wrapper (str_init);\n \t}\n \n       /* If it's a string literal, then it's the initializer for the array\n \t as a whole. Otherwise, continue with normal initialization for\n \t array types (one value per array element).  */\n-      if (TREE_CODE (str_init) == STRING_CST)\n+      if (TREE_CODE (stripped_str_init) == STRING_CST)\n \t{\n \t  if (has_designator_problem (d, complain))\n \t    return error_mark_node;\n@@ -6144,24 +6148,24 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n      which reshape_init exists).  */\n   if (!first_initializer_p)\n     {\n-      if (TREE_CODE (init) == CONSTRUCTOR)\n+      if (TREE_CODE (stripped_init) == CONSTRUCTOR)\n \t{\n \t  if (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))\n \t    /* There is no need to reshape pointer-to-member function\n \t       initializers, as they are always constructed correctly\n \t       by the front end.  */\n            ;\n-\t  else if (COMPOUND_LITERAL_P (init))\n+\t  else if (COMPOUND_LITERAL_P (stripped_init))\n \t  /* For a nested compound literal, there is no need to reshape since\n \t     brace elision is not allowed. Even if we decided to allow it,\n \t     we should add a call to reshape_init in finish_compound_literal,\n \t     before calling digest_init, so changing this code would still\n \t     not be necessary.  */\n-\t    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));\n+\t    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (stripped_init));\n \t  else\n \t    {\n \t      ++d->cur;\n-\t      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n+\t      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (stripped_init));\n \t      return reshape_init (type, init, complain);\n \t    }\n \t}\n@@ -16593,6 +16597,7 @@ undeduced_auto_decl (tree decl)\n {\n   if (cxx_dialect < cxx11)\n     return false;\n+  STRIP_ANY_LOCATION_WRAPPER (decl);\n   return ((VAR_OR_FUNCTION_DECL_P (decl)\n \t   || TREE_CODE (decl) == TEMPLATE_DECL)\n \t  && type_uses_auto (TREE_TYPE (decl)));"}, {"sha": "8163866e4ae2b0ce05a0d7882e179d81ab67fa67", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -263,6 +263,8 @@ mark_discarded_use (tree expr)\n   if (expr == NULL_TREE)\n     return expr;\n \n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case COND_EXPR:"}, {"sha": "5538eebf3e1d52f6a5bb6583b92920d677d5a536", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1756,7 +1756,8 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n \t{\n \t  from_array = 1;\n \t  init = mark_rvalue_use (init);\n-\t  if (init && DECL_P (init)\n+\t  if (init\n+\t      && DECL_P (tree_strip_any_location_wrapper (init))\n \t      && !(flags & LOOKUP_ONLYCONVERTING))\n \t    {\n \t      /* Wrap the initializer in a CONSTRUCTOR so that build_vec_init\n@@ -2604,6 +2605,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t Otherwise, use the size of the entire array as an optimistic\n \t estimate (this may lead to false negatives).  */\n       tree adj = TREE_OPERAND (oper, 1);\n+      adj = fold_for_warn (adj);\n       if (CONSTANT_CLASS_P (adj))\n \tadjust += wi::to_offset (convert (ssizetype, adj));\n       else\n@@ -2667,11 +2669,13 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \n       tree op0 = oper;\n       while (TREE_CODE (op0 = TREE_OPERAND (op0, 0)) == COMPONENT_REF);\n+      STRIP_ANY_LOCATION_WRAPPER (op0);\n       if (VAR_P (op0))\n \tvar_decl = op0;\n       oper = TREE_OPERAND (oper, 1);\n     }\n \n+  STRIP_ANY_LOCATION_WRAPPER (oper);\n   tree opertype = TREE_TYPE (oper);\n   if ((addr_expr || !INDIRECT_TYPE_P (opertype))\n       && (VAR_P (oper)\n@@ -2762,6 +2766,9 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t others.  */\n       offset_int bytes_need;\n \n+      if (nelts)\n+\tnelts = fold_for_warn (nelts);\n+\n       if (CONSTANT_CLASS_P (size))\n \tbytes_need = wi::to_offset (size);\n       else if (nelts && CONSTANT_CLASS_P (nelts))"}, {"sha": "c0552b5be910897ed9d789d35931ce275b16afed", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -5232,7 +5232,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  if (!cast_p)\n \t    cp_parser_non_integral_constant_expression (parser, NIC_FLOAT);\n \t}\n-      return cp_expr (token->u.value, token->location);\n+      return (cp_expr (token->u.value, token->location)\n+\t      .maybe_add_location_wrapper ());\n \n     case CPP_CHAR_USERDEF:\n     case CPP_CHAR16_USERDEF:\n@@ -5254,9 +5255,10 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */\n-      return cp_parser_string_literal (parser,\n-\t\t\t\t       parser->translate_strings_p,\n-\t\t\t\t       true);\n+      return (cp_parser_string_literal (parser,\n+\t\t\t\t\tparser->translate_strings_p,\n+\t\t\t\t\ttrue)\n+\t      .maybe_add_location_wrapper ());\n \n     case CPP_OPEN_PAREN:\n       /* If we see `( { ' then we are looking at the beginning of\n@@ -7169,8 +7171,10 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n             is_member_access = false;\n \n+\t    tree stripped_expression\n+\t      = tree_strip_any_location_wrapper (postfix_expression);\n \t    is_builtin_constant_p\n-\t      = DECL_IS_BUILTIN_CONSTANT_P (postfix_expression);\n+\t      = DECL_IS_BUILTIN_CONSTANT_P (stripped_expression);\n \t    if (is_builtin_constant_p)\n \t      {\n \t\t/* The whole point of __builtin_constant_p is to allow\n@@ -8363,18 +8367,22 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \tcase NEGATE_EXPR:\n \t  /* Immediately fold negation of a constant, unless the constant is 0\n \t     (since -0 == 0) or it would overflow.  */\n-\t  if (unary_operator == NEGATE_EXPR && op_ttype == CPP_NUMBER\n-\t      && CONSTANT_CLASS_P (cast_expression)\n-\t      && !integer_zerop (cast_expression)\n-\t      && !TREE_OVERFLOW (cast_expression))\n+\t  if (unary_operator == NEGATE_EXPR && op_ttype == CPP_NUMBER)\n \t    {\n-\t      tree folded = fold_build1 (unary_operator,\n-\t\t\t\t\t TREE_TYPE (cast_expression),\n-\t\t\t\t\t cast_expression);\n-\t      if (CONSTANT_CLASS_P (folded) && !TREE_OVERFLOW (folded))\n+\t      tree stripped_expr\n+\t\t= tree_strip_any_location_wrapper (cast_expression);\n+\t      if (CONSTANT_CLASS_P (stripped_expr)\n+\t\t  && !integer_zerop (stripped_expr)\n+\t\t  && !TREE_OVERFLOW (stripped_expr))\n \t\t{\n-\t\t  expression = cp_expr (folded, loc);\n-\t\t  break;\n+\t\t  tree folded = fold_build1 (unary_operator,\n+\t\t\t\t\t     TREE_TYPE (stripped_expr),\n+\t\t\t\t\t     stripped_expr);\n+\t\t  if (CONSTANT_CLASS_P (folded) && !TREE_OVERFLOW (folded))\n+\t\t    {\n+\t\t      expression = maybe_wrap_with_location (folded, loc);\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n \t  /* Fall through.  */\n@@ -8489,6 +8497,8 @@ cp_parser_has_attribute_expression (cp_parser *parser)\n   if (!oper || oper == error_mark_node)\n     oper = cp_parser_unary_expression (parser);\n \n+  STRIP_ANY_LOCATION_WRAPPER (oper);\n+\n   /* Go back to evaluating expressions.  */\n   --cp_unevaluated_operand;\n   --c_inhibit_evaluation_warnings;\n@@ -9508,7 +9518,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t      || (TREE_CODE (TREE_TYPE (TREE_OPERAND (current.lhs, 0)))\n \t\t\t  != BOOLEAN_TYPE))))\n \t  /* Avoid warning for !!b == y where b is boolean.  */\n-\t  && (!DECL_P (current.lhs)\n+\t  && (!DECL_P (tree_strip_any_location_wrapper (current.lhs))\n \t      || TREE_TYPE (current.lhs) == NULL_TREE\n \t      || TREE_CODE (TREE_TYPE (current.lhs)) != BOOLEAN_TYPE))\n \twarn_logical_not_parentheses (current.loc, current.tree_type,\n@@ -14546,6 +14556,7 @@ cp_parser_decltype (cp_parser *parser)\n       ++c_inhibit_evaluation_warnings;\n \n       expr = cp_parser_decltype_expr (parser, id_expression_or_member_access_p);\n+      STRIP_ANY_LOCATION_WRAPPER (expr);\n \n       /* Go back to evaluating expressions.  */\n       --cp_unevaluated_operand;\n@@ -14923,7 +14934,9 @@ cp_parser_mem_initializer (cp_parser* parser)\n       vec = cp_parser_parenthesized_expression_list (parser, non_attr,\n \t\t\t\t\t\t     /*cast_p=*/false,\n \t\t\t\t\t\t     /*allow_expansion_p=*/true,\n-\t\t\t\t\t\t     /*non_constant_p=*/NULL);\n+\t\t\t\t\t\t     /*non_constant_p=*/NULL,\n+\t\t\t\t\t\t     /*close_paren_loc=*/NULL,\n+\t\t\t\t\t\t     /*wrap_locations_p=*/true);\n       if (vec == NULL)\n \treturn error_mark_node;\n       expression_list = build_tree_list_vec (vec);\n@@ -15464,6 +15477,11 @@ cp_parser_template_parameter_list (cp_parser* parser)\n {\n   tree parameter_list = NULL_TREE;\n \n+  /* Don't create wrapper nodes within a template-parameter-list,\n+     since we don't want to have different types based on the\n+     spelling location of constants and decls within them.  */\n+  auto_suppress_location_wrappers sentinel;\n+\n   begin_template_parm_list ();\n \n   /* The loop below parses the template parms.  We first need to know\n@@ -16636,6 +16654,9 @@ cp_parser_template_argument_list (cp_parser* parser)\n   bool saved_ice_p;\n   bool saved_non_ice_p;\n \n+  /* Don't create location wrapper nodes within a template-argument-list.  */\n+  auto_suppress_location_wrappers sentinel;\n+\n   saved_in_template_argument_list_p = parser->in_template_argument_list_p;\n   parser->in_template_argument_list_p = true;\n   /* Even if the template-id appears in an integral\n@@ -22313,6 +22334,9 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   else\n     default_argument = NULL_TREE;\n \n+  if (default_argument)\n+    STRIP_ANY_LOCATION_WRAPPER (default_argument);\n+\n   /* Generate a location for the parameter, ranging from the start of the\n      initial token to the end of the final token (using input_location for\n      the latter, set up by cp_lexer_set_source_position_from_token when\n@@ -25661,6 +25685,10 @@ cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n   tree attribute_list = NULL_TREE;\n   bool save_translate_strings_p = parser->translate_strings_p;\n \n+  /* Don't create wrapper nodes within attributes: the\n+     handlers don't know how to handle them.  */\n+  auto_suppress_location_wrappers sentinel;\n+\n   parser->translate_strings_p = false;\n   while (true)\n     {\n@@ -26106,6 +26134,10 @@ cp_parser_std_attribute_spec_seq (cp_parser *parser)\n   tree attr_specs = NULL_TREE;\n   tree attr_last = NULL_TREE;\n \n+  /* Don't create wrapper nodes within attributes: the\n+     handlers don't know how to handle them.  */\n+  auto_suppress_location_wrappers sentinel;\n+\n   while (true)\n     {\n       tree attr_spec = cp_parser_std_attribute_spec (parser);\n@@ -34880,6 +34912,9 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n   bool first = true;\n   cp_token *token = NULL;\n \n+  /* Don't create location wrapper nodes within OpenMP clauses.  */\n+  auto_suppress_location_wrappers sentinel;\n+\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n       pragma_omp_clause c_kind;\n@@ -36597,6 +36632,10 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n \n+      /* Don't create location wrapper nodes within an OpenMP \"for\"\n+\t statement.  */\n+      auto_suppress_location_wrappers sentinel;\n+\n       matching_parens parens;\n       if (!parens.require_open (parser))\n \treturn NULL;\n@@ -39168,6 +39207,8 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n       else\n \t{\n \t  cp_parser_parse_tentatively (parser);\n+\t  /* Don't create location wrapper nodes here.  */\n+\t  auto_suppress_location_wrappers sentinel;\n \t  tree fn_name = cp_parser_id_expression (parser, /*template_p=*/false,\n \t\t\t\t\t\t  /*check_dependency_p=*/true,\n \t\t\t\t\t\t  /*template_p=*/NULL,"}, {"sha": "d4ac034671ae392eaee49d2d548446d72e72fb1a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -6196,6 +6196,7 @@ convert_nontype_argument_function (tree type, tree expr,\n      -- the address of an object or function with external [C++11: or\n         internal] linkage.  */\n \n+  STRIP_ANY_LOCATION_WRAPPER (fn_no_ptr);\n   if (TREE_CODE (fn_no_ptr) != FUNCTION_DECL)\n     {\n       if (complain & tf_error)\n@@ -12756,14 +12757,14 @@ tsubst_default_argument (tree fn, int parmnum, tree type, tree arg,\n \n   finish_lambda_scope ();\n \n+  /* Make sure the default argument is reasonable.  */\n+  arg = check_default_argument (type, arg, complain);\n+\n   if (errorcount+sorrycount > errs\n       && (complain & tf_warning_or_error))\n     inform (input_location,\n \t    \"  when instantiating default argument for call to %qD\", fn);\n \n-  /* Make sure the default argument is reasonable.  */\n-  arg = check_default_argument (type, arg, complain);\n-\n   pop_access_scope (fn);\n   pop_from_top_level ();\n \n@@ -27224,7 +27225,8 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t\t\t\t\t complain);\n   else if (AUTO_IS_DECLTYPE (auto_node))\n     {\n-      bool id = (DECL_P (init)\n+      tree stripped_init = tree_strip_any_location_wrapper (init);\n+      bool id = (DECL_P (stripped_init)\n \t\t || ((TREE_CODE (init) == COMPONENT_REF\n \t\t      || TREE_CODE (init) == SCOPE_REF)\n \t\t     && !REF_PARENTHESIZED_P (init)));"}, {"sha": "0865076493d5c9f478de1cc28e5ad51584b0aa69", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1742,7 +1742,8 @@ force_paren_expr (tree expr)\n   if (cp_unevaluated_operand)\n     return expr;\n \n-  if (!DECL_P (expr) && TREE_CODE (expr) != COMPONENT_REF\n+  if (!DECL_P (tree_strip_any_location_wrapper (expr))\n+      && TREE_CODE (expr) != COMPONENT_REF\n       && TREE_CODE (expr) != SCOPE_REF)\n     return expr;\n \n@@ -1805,8 +1806,9 @@ finish_parenthesized_expr (cp_expr expr)\n        enclosed in parentheses.  */\n     PTRMEM_OK_P (expr) = 0;\n \n-  if (TREE_CODE (expr) == STRING_CST)\n-    PAREN_STRING_LITERAL_P (expr) = 1;\n+  tree stripped_expr = tree_strip_any_location_wrapper (expr);\n+  if (TREE_CODE (stripped_expr) == STRING_CST)\n+    PAREN_STRING_LITERAL_P (stripped_expr) = 1;\n \n   expr = cp_expr (force_paren_expr (expr), expr.get_location ());\n \n@@ -2299,19 +2301,22 @@ empty_expr_stmt_p (tree expr_stmt)\n   return false;\n }\n \n-/* Perform Koenig lookup.  FN is the postfix-expression representing\n+/* Perform Koenig lookup.  FN_EXPR is the postfix-expression representing\n    the function (or functions) to call; ARGS are the arguments to the\n    call.  Returns the functions to be considered by overload resolution.  */\n \n cp_expr\n-perform_koenig_lookup (cp_expr fn, vec<tree, va_gc> *args,\n+perform_koenig_lookup (cp_expr fn_expr, vec<tree, va_gc> *args,\n \t\t       tsubst_flags_t complain)\n {\n   tree identifier = NULL_TREE;\n   tree functions = NULL_TREE;\n   tree tmpl_args = NULL_TREE;\n   bool template_id = false;\n-  location_t loc = fn.get_location ();\n+  location_t loc = fn_expr.get_location ();\n+  tree fn = fn_expr.get_value ();\n+\n+  STRIP_ANY_LOCATION_WRAPPER (fn);\n \n   if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n     {\n@@ -2351,7 +2356,7 @@ perform_koenig_lookup (cp_expr fn, vec<tree, va_gc> *args,\n   if (fn && template_id && fn != error_mark_node)\n     fn = build2 (TEMPLATE_ID_EXPR, unknown_type_node, fn, tmpl_args);\n   \n-  return fn;\n+  return cp_expr (fn, loc);\n }\n \n /* Generate an expression for `FN (ARGS)'.  This may change the\n@@ -2382,6 +2387,8 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n      it so that we can tell this is a call to a known function.  */\n   fn = maybe_undo_parenthesized_ref (fn);\n \n+  STRIP_ANY_LOCATION_WRAPPER (fn);\n+\n   orig_fn = fn;\n \n   if (processing_template_decl)\n@@ -3523,20 +3530,20 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n    the use of \"this\" explicit.\n \n    Upon return, *IDK will be filled in appropriately.  */\n-cp_expr\n-finish_id_expression (tree id_expression,\n-\t\t      tree decl,\n-\t\t      tree scope,\n-\t\t      cp_id_kind *idk,\n-\t\t      bool integral_constant_expression_p,\n-\t\t      bool allow_non_integral_constant_expression_p,\n-\t\t      bool *non_integral_constant_expression_p,\n-\t\t      bool template_p,\n-\t\t      bool done,\n-\t\t      bool address_p,\n-\t\t      bool template_arg_p,\n-\t\t      const char **error_msg,\n-\t\t      location_t location)\n+static cp_expr\n+finish_id_expression_1 (tree id_expression,\n+\t\t\ttree decl,\n+\t\t\ttree scope,\n+\t\t\tcp_id_kind *idk,\n+\t\t\tbool integral_constant_expression_p,\n+\t\t\tbool allow_non_integral_constant_expression_p,\n+\t\t\tbool *non_integral_constant_expression_p,\n+\t\t\tbool template_p,\n+\t\t\tbool done,\n+\t\t\tbool address_p,\n+\t\t\tbool template_arg_p,\n+\t\t\tconst char **error_msg,\n+\t\t\tlocation_t location)\n {\n   decl = strip_using_decl (decl);\n \n@@ -3841,6 +3848,34 @@ finish_id_expression (tree id_expression,\n   return cp_expr (decl, location);\n }\n \n+/* As per finish_id_expression_1, but adding a wrapper node\n+   around the result if needed to express LOCATION.  */\n+\n+cp_expr\n+finish_id_expression (tree id_expression,\n+\t\t      tree decl,\n+\t\t      tree scope,\n+\t\t      cp_id_kind *idk,\n+\t\t      bool integral_constant_expression_p,\n+\t\t      bool allow_non_integral_constant_expression_p,\n+\t\t      bool *non_integral_constant_expression_p,\n+\t\t      bool template_p,\n+\t\t      bool done,\n+\t\t      bool address_p,\n+\t\t      bool template_arg_p,\n+\t\t      const char **error_msg,\n+\t\t      location_t location)\n+{\n+  cp_expr result\n+    = finish_id_expression_1 (id_expression, decl, scope, idk,\n+\t\t\t      integral_constant_expression_p,\n+\t\t\t      allow_non_integral_constant_expression_p,\n+\t\t\t      non_integral_constant_expression_p,\n+\t\t\t      template_p, done, address_p, template_arg_p,\n+\t\t\t      error_msg, location);\n+  return result.maybe_add_location_wrapper ();\n+}\n+\n /* Implement the __typeof keyword: Return the type of EXPR, suitable for\n    use as a type-specifier.  */\n \n@@ -9766,12 +9801,12 @@ static tree\n capture_decltype (tree decl)\n {\n   tree lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n-  /* FIXME do lookup instead of list walk? */\n-  tree cap = value_member (decl, LAMBDA_EXPR_CAPTURE_LIST (lam));\n+  tree cap = lookup_name_real (DECL_NAME (decl), /*type*/0, /*nonclass*/1,\n+\t\t\t       /*block_p=*/true, /*ns*/0, LOOKUP_HIDDEN);\n   tree type;\n \n-  if (cap)\n-    type = TREE_TYPE (TREE_PURPOSE (cap));\n+  if (cap && is_capture_proxy (cap))\n+    type = TREE_TYPE (cap);\n   else\n     switch (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam))\n       {"}, {"sha": "aac3ecede8de75e1bcd99f6aeee294c187f89959", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -377,6 +377,7 @@ bitfield_p (const_tree ref)\n tree\n cp_stabilize_reference (tree ref)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (ref);\n   switch (TREE_CODE (ref))\n     {\n     case NON_DEPENDENT_EXPR:\n@@ -421,6 +422,7 @@ cp_stabilize_reference (tree ref)\n bool\n builtin_valid_in_constant_expr_p (const_tree decl)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (decl);\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     /* Not a function.  */\n     return false;\n@@ -1715,6 +1717,8 @@ strip_typedefs_expr (tree t, bool *remove_attributes)\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n+  STRIP_ANY_LOCATION_WRAPPER (t);\n+\n   if (DECL_P (t) || CONSTANT_CLASS_P (t))\n     return t;\n \n@@ -2369,6 +2373,8 @@ lookup_maybe_add (tree fns, tree lookup, bool deduping)\n int\n is_overloaded_fn (tree x)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (x);\n+\n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (x) == OFFSET_REF\n       || TREE_CODE (x) == COMPONENT_REF)\n@@ -2417,6 +2423,8 @@ really_overloaded_fn (tree x)\n tree\n maybe_get_fns (tree from)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (from);\n+\n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (from) == OFFSET_REF\n       || TREE_CODE (from) == COMPONENT_REF)\n@@ -5527,6 +5535,14 @@ test_lvalue_kind ()\n   ASSERT_EQ (clk_rvalueref, lvalue_kind (rvalue_ref_of_parm));\n   tree rvalue_ref_of_wrapped_parm = move (wrapped_parm);\n   ASSERT_EQ (clk_rvalueref, lvalue_kind (rvalue_ref_of_wrapped_parm));\n+\n+  /* Verify lvalue_p.  */\n+  ASSERT_FALSE (lvalue_p (int_cst));\n+  ASSERT_FALSE (lvalue_p (wrapped_int_cst));\n+  ASSERT_TRUE (lvalue_p (parm));\n+  ASSERT_TRUE (lvalue_p (wrapped_parm));\n+  ASSERT_FALSE (lvalue_p (rvalue_ref_of_parm));\n+  ASSERT_FALSE (lvalue_p (rvalue_ref_of_wrapped_parm));\n }\n \n /* Run all of the selftests within this file.  */"}, {"sha": "519510dd8b04c3f931f12084614cbca73551f08b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 69, "deletions": 36, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1682,6 +1682,8 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n       return e;\n     }\n \n+  STRIP_ANY_LOCATION_WRAPPER (e);\n+\n   /* To get the size of a static data member declared as an array of\n      unknown bound, we need to instantiate it.  */\n   if (VAR_P (e)\n@@ -1754,6 +1756,8 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n       return e;\n     }\n \n+  STRIP_ANY_LOCATION_WRAPPER (e);\n+\n   e = mark_type_use (e);\n \n   if (VAR_P (e))\n@@ -1944,6 +1948,12 @@ is_bitfield_expr_with_lowered_type (const_tree exp)\n \t\t\t\t\t\t   (CONST_CAST_TREE (exp)));\n       return NULL_TREE;\n \n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (exp))\n+\treturn is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 0));\n+      else\n+\treturn NULL_TREE;\n+\n     CASE_CONVERT:\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (exp, 0)))\n \t  == TYPE_MAIN_VARIANT (TREE_TYPE (exp)))\n@@ -3415,6 +3425,8 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t pointer arithmetic.)  */\n       idx = cp_perform_integral_promotions (idx, complain);\n \n+      idx = maybe_constant_value (idx);\n+\n       /* An array that is indexed by a non-constant\n \t cannot be stored in a register; we must be able to do\n \t address arithmetic on its address.\n@@ -4561,20 +4573,23 @@ cp_build_binary_op (location_t location,\n \t    type0 = TREE_TYPE (type0);\n \t  if (!TYPE_P (type1))\n \t    type1 = TREE_TYPE (type1);\n-\t  if (INDIRECT_TYPE_P (type0) && same_type_p (TREE_TYPE (type0), type1)\n-\t      && !(TREE_CODE (first_arg) == PARM_DECL\n-\t\t   && DECL_ARRAY_PARAMETER_P (first_arg)\n-\t\t   && warn_sizeof_array_argument)\n-\t      && (complain & tf_warning))\n+\t  if (INDIRECT_TYPE_P (type0) && same_type_p (TREE_TYPE (type0), type1))\n \t    {\n-\t      auto_diagnostic_group d;\n-\t      if (warning_at (location, OPT_Wsizeof_pointer_div,\n-\t\t\t\t\"division %<sizeof (%T) / sizeof (%T)%> does \"\n-\t\t\t\t\"not compute the number of array elements\",\n-\t\t\t    type0, type1))\n-\t\tif (DECL_P (first_arg))\n-\t\t  inform (DECL_SOURCE_LOCATION (first_arg),\n-\t\t\t    \"first %<sizeof%> operand was declared here\");\n+\t      STRIP_ANY_LOCATION_WRAPPER (first_arg);\n+\t      if (!(TREE_CODE (first_arg) == PARM_DECL\n+\t\t    && DECL_ARRAY_PARAMETER_P (first_arg)\n+\t\t    && warn_sizeof_array_argument)\n+\t\t  && (complain & tf_warning))\n+\t\t{\n+\t\t  auto_diagnostic_group d;\n+\t\t  if (warning_at (location, OPT_Wsizeof_pointer_div,\n+\t\t\t\t  \"division %<sizeof (%T) / sizeof (%T)%> does \"\n+\t\t\t\t  \"not compute the number of array elements\",\n+\t\t\t\t  type0, type1))\n+\t\t    if (DECL_P (first_arg))\n+\t\t      inform (DECL_SOURCE_LOCATION (first_arg),\n+\t\t\t      \"first %<sizeof%> operand was declared here\");\n+\t\t}\n \t    }\n \t}\n \n@@ -4596,15 +4611,18 @@ cp_build_binary_op (location_t location,\n \t  if (!(tcode0 == INTEGER_TYPE && tcode1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n \t  else\n-\t    /* When dividing two signed integers, we have to promote to int.\n-\t       unless we divide by a constant != -1.  Note that default\n-\t       conversion will have been performed on the operands at this\n-\t       point, so we have to dig out the original type to find out if\n-\t       it was unsigned.  */\n-\t    shorten = ((TREE_CODE (op0) == NOP_EXPR\n-\t\t\t&& TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n-\t\t       || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t   && ! integer_all_onesp (op1)));\n+\t    {\n+\t      /* When dividing two signed integers, we have to promote to int.\n+\t\t unless we divide by a constant != -1.  Note that default\n+\t\t conversion will have been performed on the operands at this\n+\t\t point, so we have to dig out the original type to find out if\n+\t\t it was unsigned.  */\n+\t      tree stripped_op1 = tree_strip_any_location_wrapper (op1);\n+\t      shorten = ((TREE_CODE (op0) == NOP_EXPR\n+\t\t\t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n+\t\t\t || (TREE_CODE (stripped_op1) == INTEGER_CST\n+\t\t\t     && ! integer_all_onesp (stripped_op1)));\n+\t    }\n \n \t  common = 1;\n \t}\n@@ -4638,10 +4656,11 @@ cp_build_binary_op (location_t location,\n \t     on some targets, since the modulo instruction is undefined if the\n \t     quotient can't be represented in the computation mode.  We shorten\n \t     only if unsigned or if dividing by something we know != -1.  */\n+\t  tree stripped_op1 = tree_strip_any_location_wrapper (op1);\n \t  shorten = ((TREE_CODE (op0) == NOP_EXPR\n \t\t      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n-\t\t     || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t && ! integer_all_onesp (op1)));\n+\t\t     || (TREE_CODE (stripped_op1) == INTEGER_CST\n+\t\t\t && ! integer_all_onesp (stripped_op1)));\n \t  common = 1;\n \t}\n       break;\n@@ -4842,13 +4861,17 @@ cp_build_binary_op (location_t location,\n \t  && (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1)))\n \twarning (OPT_Wfloat_equal,\n \t\t \"comparing floating point with == or != is unsafe\");\n-      if ((complain & tf_warning)\n-\t  && ((TREE_CODE (orig_op0) == STRING_CST\n+      if (complain & tf_warning)\n+\t{\n+\t  tree stripped_orig_op0 = tree_strip_any_location_wrapper (orig_op0);\n+\t  tree stripped_orig_op1 = tree_strip_any_location_wrapper (orig_op1);\n+\t  if ((TREE_CODE (stripped_orig_op0) == STRING_CST\n \t       && !integer_zerop (cp_fully_fold (op1)))\n-\t      || (TREE_CODE (orig_op1) == STRING_CST\n-\t\t  && !integer_zerop (cp_fully_fold (op0)))))\n-\twarning (OPT_Waddress, \"comparison with string literal results \"\n-\t\t\t       \"in unspecified behavior\");\n+\t      || (TREE_CODE (stripped_orig_op1) == STRING_CST\n+\t\t  && !integer_zerop (cp_fully_fold (op0))))\n+\t    warning (OPT_Waddress, \"comparison with string literal results \"\n+\t\t     \"in unspecified behavior\");\n+\t}\n \n       build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n@@ -6080,8 +6103,9 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n      so we can just form an ADDR_EXPR with the correct type.  */\n   if (processing_template_decl || TREE_CODE (arg) != COMPONENT_REF)\n     {\n-      if (TREE_CODE (arg) == FUNCTION_DECL\n-\t  && !mark_used (arg, complain) && !(complain & tf_error))\n+      tree stripped_arg = tree_strip_any_location_wrapper (arg);\n+      if (TREE_CODE (stripped_arg) == FUNCTION_DECL\n+\t  && !mark_used (stripped_arg, complain) && !(complain & tf_error))\n \treturn error_mark_node;\n       val = build_address (arg);\n       if (TREE_CODE (arg) == OFFSET_REF)\n@@ -8304,7 +8328,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n       /* C++11 8.5/17: \"If the destination type is an array of characters,\n \t an array of char16_t, an array of char32_t, or an array of wchar_t,\n \t and the initializer is a string literal...\".  */\n-      else if (TREE_CODE (newrhs) == STRING_CST\n+      else if ((TREE_CODE (tree_strip_any_location_wrapper (newrhs))\n+\t\t== STRING_CST)\n \t       && char_type_p (TREE_TYPE (TYPE_MAIN_VARIANT (lhstype)))\n \t       && modifycode == INIT_EXPR)\n \t{\n@@ -8823,9 +8848,10 @@ convert_for_assignment (tree type, tree rhs,\n   enum tree_code coder;\n \n   location_t rhs_loc = EXPR_LOC_OR_LOC (rhs, input_location);\n-\n-  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-  if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n+  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue,\n+     but preserve location wrappers.  */\n+  if (TREE_CODE (rhs) == NON_LVALUE_EXPR\n+      && !location_wrapper_p (rhs))\n     rhs = TREE_OPERAND (rhs, 0);\n \n   /* Handle [dcl.init.list] direct-list-initialization from\n@@ -9199,6 +9225,8 @@ maybe_warn_about_returning_address_of_local (tree retval)\n       return true;\n     }\n \n+  STRIP_ANY_LOCATION_WRAPPER (whats_returned);\n+\n   if (DECL_P (whats_returned)\n       && DECL_NAME (whats_returned)\n       && DECL_FUNCTION_SCOPE_P (whats_returned)\n@@ -9300,6 +9328,8 @@ is_std_move_p (tree fn)\n static bool\n can_do_nrvo_p (tree retval, tree functype)\n {\n+  if (retval)\n+    STRIP_ANY_LOCATION_WRAPPER (retval);\n   tree result = DECL_RESULT (current_function_decl);\n   return (retval != NULL_TREE\n \t  && !processing_template_decl\n@@ -9326,6 +9356,7 @@ can_do_nrvo_p (tree retval, tree functype)\n bool\n treat_lvalue_as_rvalue_p (tree retval, bool parm_ok)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (retval);\n   return ((cxx_dialect != cxx98)\n \t  && ((VAR_P (retval) && !DECL_HAS_VALUE_EXPR_P (retval))\n \t      || (parm_ok && TREE_CODE (retval) == PARM_DECL))\n@@ -9619,6 +9650,8 @@ check_return_expr (tree retval, bool *no_warning)\n      this restriction, anyway.  (jason 2000-11-19)\n \n      See finish_function and finalize_nrv for the rest of this optimization.  */\n+  if (retval)\n+    STRIP_ANY_LOCATION_WRAPPER (retval);\n \n   bool named_return_value_okay_p = can_do_nrvo_p (retval, functype);\n   if (fn_returns_value_p && flag_elide_constructors)"}, {"sha": "c1fa4a94843de3f879c1a73444bae7f84e4c7127", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -460,14 +460,19 @@ cxx_incomplete_type_diagnostic (location_t loc, const_tree value,\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n-  if (value != 0 && (VAR_P (value)\n-\t\t     || TREE_CODE (value) == PARM_DECL\n-\t\t     || TREE_CODE (value) == FIELD_DECL))\n+  if (value)\n     {\n-      complained = emit_diagnostic (diag_kind, DECL_SOURCE_LOCATION (value), 0,\n-\t\t\t\t    \"%qD has incomplete type\", value);\n-      is_decl = true;\n-    } \n+      STRIP_ANY_LOCATION_WRAPPER (value);\n+\n+      if (VAR_P (value)\n+\t  || TREE_CODE (value) == PARM_DECL\n+\t  || TREE_CODE (value) == FIELD_DECL)\n+\t{\n+\t  complained = emit_diagnostic (diag_kind, DECL_SOURCE_LOCATION (value), 0,\n+\t\t\t\t\t\"%qD has incomplete type\", value);\n+\t  is_decl = true;\n+\t}\n+    }\n  retry:\n   /* We must print an error message.  Be clever about what it says.  */\n \n@@ -1052,6 +1057,8 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \n   location_t loc = cp_expr_loc_or_loc (init, input_location);\n \n+  tree stripped_init = tree_strip_any_location_wrapper (init);\n+\n   /* Initialization of an array of chars from a string constant. The initializer\n      can be optionally enclosed in braces, but reshape_init has already removed\n      them if they were present.  */\n@@ -1065,7 +1072,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n \t  /*&& init */\n-\t  && TREE_CODE (init) == STRING_CST)\n+\t  && TREE_CODE (stripped_init) == STRING_CST)\n \t{\n \t  tree char_type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n \n@@ -1113,6 +1120,14 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t    {\n \t      init = copy_node (init);\n \t      TREE_TYPE (init) = type;\n+\t      /* If we have a location wrapper, then also copy the wrapped\n+\t\t node, and update the copy's type.  */\n+\t      if (location_wrapper_p (init))\n+\t\t{\n+\t\t  stripped_init = copy_node (stripped_init);\n+\t\t  TREE_OPERAND (init, 0) = stripped_init;\n+\t\t  TREE_TYPE (stripped_init) = type;\n+\t\t}\n \t    }\n \t  if (TYPE_DOMAIN (type) && TREE_CONSTANT (TYPE_SIZE (type)))\n \t    {\n@@ -1123,12 +1138,13 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t\t because it's ok to ignore the terminating null char that is\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n-\t      if (size < TREE_STRING_LENGTH (init))\n+\t      if (size < TREE_STRING_LENGTH (stripped_init))\n \t\t{\n \t\t  permerror (loc, \"initializer-string for array \"\n \t\t\t     \"of chars is too long\");\n \n-\t\t  init = build_string (size, TREE_STRING_POINTER (init));\n+\t\t  init = build_string (size,\n+\t\t\t\t       TREE_STRING_POINTER (stripped_init));\n \t\t  TREE_TYPE (init) = type;\n \t\t}\n \t    }\n@@ -1137,7 +1153,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n     }\n \n   /* Handle scalar types (including conversions) and references.  */\n-  if ((code != COMPLEX_TYPE || BRACE_ENCLOSED_INITIALIZER_P (init))\n+  if ((code != COMPLEX_TYPE || BRACE_ENCLOSED_INITIALIZER_P (stripped_init))\n       && (SCALAR_TYPE_P (type) || code == REFERENCE_TYPE))\n     {\n       if (nested)\n@@ -1162,23 +1178,23 @@ digest_init_r (tree type, tree init, int nested, int flags,\n      the object is initialized from that element.\"  */\n   if (flag_checking\n       && cxx_dialect >= cxx11\n-      && BRACE_ENCLOSED_INITIALIZER_P (init)\n-      && CONSTRUCTOR_NELTS (init) == 1\n+      && BRACE_ENCLOSED_INITIALIZER_P (stripped_init)\n+      && CONSTRUCTOR_NELTS (stripped_init) == 1\n       && ((CLASS_TYPE_P (type) && !CLASSTYPE_NON_AGGREGATE (type))\n \t  || VECTOR_TYPE_P (type)))\n     {\n-      tree elt = CONSTRUCTOR_ELT (init, 0)->value;\n+      tree elt = CONSTRUCTOR_ELT (stripped_init, 0)->value;\n       if (reference_related_p (type, TREE_TYPE (elt)))\n \t/* We should have fixed this in reshape_init.  */\n \tgcc_unreachable ();\n     }\n \n-  if (BRACE_ENCLOSED_INITIALIZER_P (init)\n+  if (BRACE_ENCLOSED_INITIALIZER_P (stripped_init)\n       && !TYPE_NON_AGGREGATE_CLASS (type))\n-    return process_init_constructor (type, init, nested, complain);\n+    return process_init_constructor (type, stripped_init, nested, complain);\n   else\n     {\n-      if (COMPOUND_LITERAL_P (init) && code == ARRAY_TYPE)\n+      if (COMPOUND_LITERAL_P (stripped_init) && code == ARRAY_TYPE)\n \t{\n \t  if (complain & tf_error)\n \t    error_at (loc, \"cannot initialize aggregate of type %qT with \"\n@@ -1188,12 +1204,12 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t}\n \n       if (code == ARRAY_TYPE\n-\t  && !BRACE_ENCLOSED_INITIALIZER_P (init))\n+\t  && !BRACE_ENCLOSED_INITIALIZER_P (stripped_init))\n \t{\n \t  /* Allow the result of build_array_copy and of\n \t     build_value_init_noctor.  */\n-\t  if ((TREE_CODE (init) == VEC_INIT_EXPR\n-\t       || TREE_CODE (init) == CONSTRUCTOR)\n+\t  if ((TREE_CODE (stripped_init) == VEC_INIT_EXPR\n+\t       || TREE_CODE (stripped_init) == CONSTRUCTOR)\n \t      && (same_type_ignoring_top_level_qualifiers_p\n \t\t  (type, TREE_TYPE (init))))\n \t    return init;"}, {"sha": "1851a3dc39884a3d83d8b1b4afc4d31e6c195d17", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1911,19 +1911,23 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n       /* And some specific cases even faster than that.  */\n       if (code == PLUS_EXPR)\n \t{\n-\t  if (integer_zerop (arg0) && !TREE_OVERFLOW (arg0))\n+\t  if (integer_zerop (arg0)\n+\t      && !TREE_OVERFLOW (tree_strip_any_location_wrapper (arg0)))\n \t    return arg1;\n-\t  if (integer_zerop (arg1) && !TREE_OVERFLOW (arg1))\n+\t  if (integer_zerop (arg1)\n+\t      && !TREE_OVERFLOW (tree_strip_any_location_wrapper (arg1)))\n \t    return arg0;\n \t}\n       else if (code == MINUS_EXPR)\n \t{\n-\t  if (integer_zerop (arg1) && !TREE_OVERFLOW (arg1))\n+\t  if (integer_zerop (arg1)\n+\t      && !TREE_OVERFLOW (tree_strip_any_location_wrapper (arg1)))\n \t    return arg0;\n \t}\n       else if (code == MULT_EXPR)\n \t{\n-\t  if (integer_onep (arg0) && !TREE_OVERFLOW (arg0))\n+\t  if (integer_onep (arg0)\n+\t      && !TREE_OVERFLOW (tree_strip_any_location_wrapper (arg0)))\n \t    return arg1;\n \t}\n \n@@ -2938,6 +2942,9 @@ combine_comparisons (location_t loc,\n int\n operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (arg0);\n+  STRIP_ANY_LOCATION_WRAPPER (arg1);\n+\n   /* When checking, verify at the outermost operand_equal_p call that\n      if operand_equal_p returns non-zero then ARG0 and ARG1 has the same\n      hash value.  */\n@@ -13681,6 +13688,8 @@ integer_valued_real_p (tree t, int depth)\n   if (t == error_mark_node)\n     return false;\n \n+  STRIP_ANY_LOCATION_WRAPPER (t);\n+\n   tree_code code = TREE_CODE (t);\n   switch (TREE_CODE_CLASS (code))\n     {"}, {"sha": "8e11f78907f8ba438c2c7ee2aceae4fd8c80245a", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,3 +1,12 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43064\n+\tPR c++/43486\n+\t* objc-act.c (objc_maybe_build_component_ref): Strip any location\n+\twrapper before checking for UOBJC_SUPER_decl and self_decl.\n+\t(objc_finish_message_expr): Strip any location wrapper.\n+\t(gen_declaration): Strip location wrappers from \"w\".\n+\n 2018-10-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Make-lang.in (selftest-objc): New."}, {"sha": "42b2fc221f99c943a3d1aeb8cb6076a606d85b69", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1455,6 +1455,8 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t || TREE_CODE (t) == COMPONENT_REF)\n \t    t = TREE_OPERAND (t, 0);\n \n+\t  STRIP_ANY_LOCATION_WRAPPER (t);\n+\n \t  if (t == UOBJC_SUPER_decl)\n \t    interface_type = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n \t  else if (t == self_decl)\n@@ -5339,6 +5341,8 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n   tree retval, class_tree;\n   int self, super, have_cast;\n \n+  STRIP_ANY_LOCATION_WRAPPER (receiver);\n+\n   /* We have used the receiver, so mark it as read.  */\n   mark_exp_read (receiver);\n \n@@ -8906,9 +8910,13 @@ gen_declaration (tree decl)\n #else\n       tree w = DECL_INITIAL (decl);\n #endif\n-      if (w && TREE_CODE (w) == INTEGER_CST)\n-\tsprintf (errbuf + strlen (errbuf), \": \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t TREE_INT_CST_LOW (w));\n+      if (w)\n+\t{\n+\t  STRIP_ANY_LOCATION_WRAPPER (w);\n+\t  if (TREE_CODE (w) == INTEGER_CST)\n+\t    sprintf (errbuf + strlen (errbuf), \": \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t     TREE_INT_CST_LOW (w));\n+\t}\n     }\n \n   return errbuf;"}, {"sha": "27be70d4c4e9c6cd95120f4d2f9fcffcdcedd666", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -81,6 +81,7 @@ selftest::run_tests ()\n   input_c_tests ();\n   vec_perm_indices_c_tests ();\n   tree_c_tests ();\n+  convert_c_tests ();\n   gimple_c_tests ();\n   rtl_tests_c_tests ();\n   read_rtl_function_c_tests ();"}, {"sha": "3b2298b73d8ee97bc011ba821dc8234e26b5692c", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -216,6 +216,7 @@ class test_runner\n extern void attribute_c_tests ();\n extern void bitmap_c_tests ();\n extern void cgraph_c_tests ();\n+extern void convert_c_tests ();\n extern void diagnostic_c_tests ();\n extern void diagnostic_show_locus_c_tests ();\n extern void dumpfile_c_tests ();"}, {"sha": "ecf5ad6c9291ba46d4da9774bd7b48979cb45f73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,3 +1,31 @@\n+2018-12-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43064\n+\tPR c++/43486\n+\t* c-c++-common/pr51712.c (valid2): Mark xfail as passing on C++.\n+\t* g++.dg/cpp0x/constexpr-47969.C: Update column of expected error.\n+\t* g++.dg/cpp0x/constexpr-ex2.C: Likewise.\n+\t* g++.dg/cpp0x/scoped_enum2.C: Likewise.\n+\t* g++.dg/cpp1z/decomp48.C: Update expected location of warning\n+\tfor named local variables to use that of the local variable.\n+\t* g++.dg/ext/vla1.C: Update column.\n+\t* g++.dg/init/array43.C: Update expected column to be that of the\n+\tinitializer.\n+\t* g++.dg/init/initializer-string-too-long.C: New test.\n+\t* g++.dg/init/new44.C: Add \"-ftrack-macro-expansion=0\".\n+\t* g++.dg/init/pr43064-1.C: New test.\n+\t* g++.dg/init/pr43064-2.C: New test.\n+\t* g++.dg/init/pr43064-3.C: New test.\n+\t* g++.dg/other/fold1.C: Update column of expected error.\n+\t* g++.dg/parse/crash36.C: Likewise.\n+\t* g++.dg/plugin/diagnostic-test-expressions-1.C: Add negative\n+\tinteger and float expressions.\n+\t* g++.dg/template/defarg6.C: Move expected error to the default\n+\targument; add expected message about where instantiated.\n+\t* g++.dg/wrappers/Wparentheses.C: New test.\n+\t* g++.old-deja/g++.bugs/900402_02.C: Update column of expected\n+\terror.\n+\n 2018-12-19  Paul A. Clarke  <pc@us.ibm.com>\n \n \t* gcc.target/powerpc/ssse3-check.h: Enable tests to run."}, {"sha": "1ff36c40a1248cf5be2d84b90cbadf3fd641bd3a", "filename": "gcc/testsuite/c-c++-common/pr51712.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr51712.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr51712.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr51712.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -15,5 +15,5 @@ int valid(enum test_enum arg)\n \n int valid2(unsigned int arg2)\n {\n-  return arg2 >= FOO && arg2 <= BAR; /* { dg-bogus \"comparison of unsigned expression\" \"\" { xfail *-*-* } } */\n+  return arg2 >= FOO && arg2 <= BAR; /* { dg-bogus \"comparison of unsigned expression\" \"\" { xfail c } } */\n }"}, {"sha": "9ff21578b15dfe73a617a16d5d1951cd33871f2e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-47969.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-47969.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-47969.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-47969.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -9,4 +9,4 @@ struct A\n constexpr A a = A();\n \n int ar[a]; // { dg-error \"could not convert\" }\n-// { dg-error \"5:size of array .ar. has non-integral\" \"\" { target c++11 } .-1 }\n+// { dg-error \"8:size of array .ar. has non-integral\" \"\" { target c++11 } .-1 }"}, {"sha": "f6973007b8917ac165521f427f2792bd32a5815f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -19,4 +19,4 @@ constexpr A a = 42;\n X<a> x;\t    // OK: unique conversion to int\n int ar[X<a>::i]; // also OK\n int ary[a]; // { dg-error \"could not convert\" } ambiguous conversion\n-// { dg-error \"5:size of array .ary. has non-integral\" \"\" { target c++11 } .-1 }\n+// { dg-error \"9:size of array .ary. has non-integral\" \"\" { target c++11 } .-1 }"}, {"sha": "c4a869a6539e15cb6fdcced4f6761cdad15aea36", "filename": "gcc/testsuite/g++.dg/cpp0x/scoped_enum2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum2.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -5,7 +5,7 @@ enum E2 { e2 = 10 };\n \n struct C {\n   int arr[E::e];    // { dg-error \"could not convert\" }\n-// { dg-error \"7:size of array .arr. has non-integral\" \"\" { target c++11 } .-1 }\n+// { dg-error \"14:size of array .arr. has non-integral\" \"\" { target c++11 } .-1 }\n   int arr2[E2::e2]; // OK\n   int i: E::e;\t    // { dg-error \"could not convert|non-integral type\" }\n   int i2: E2::e2;   // OK"}, {"sha": "3c50b02a6c247165b45192a9b1912650ec795aeb", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp48.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp48.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -18,7 +18,7 @@ f2 ()\n {\n   S v {1, 2};\n   auto& [s, t] = v;\t// { dg-warning \"structured bindings only available with\" \"\" { target c++14_down } }\n-  return s;\t\t// { dg-warning \"reference to local variable 'v' returned\" }\n+  return s;\t\t// { dg-warning \"reference to local variable 'v' returned\" \"\" { target *-*-* } .-1 }\n }\n \n int &\n@@ -33,7 +33,7 @@ f4 ()\n {\n   int a[3] = {1, 2, 3};\n   auto& [s, t, u] = a;\t// { dg-warning \"structured bindings only available with\" \"\" { target c++14_down } }\n-  return s;\t\t// { dg-warning \"reference to local variable 'a' returned\" }\n+  return s;\t\t// { dg-warning \"reference to local variable 'a' returned\" \"\" { target *-*-* } .-1 }\n }\n \n int &\n@@ -78,7 +78,7 @@ f10 ()\n {\n   S v {1, 2};\n   auto& [s, t] = v;\t// { dg-warning \"structured bindings only available with\" \"\" { target c++14_down } }\n-  return &s;\t\t// { dg-warning \"address of local variable 'v' returned\" }\n+  return &s;\t\t// { dg-warning \"address of local variable 'v' returned\" \"\" { target *-*-* } .-1 }\n }\n \n int *\n@@ -93,7 +93,7 @@ f12 ()\n {\n   int a[3] = {1, 2, 3};\n   auto& [s, t, u] = a;\t// { dg-warning \"structured bindings only available with\" \"\" { target c++14_down } }\n-  return &s;\t\t// { dg-warning \"address of local variable 'a' returned\" }\n+  return &s;\t\t// { dg-warning \"address of local variable 'a' returned\" \"\" { target *-*-* } .-1 }\n }\n \n int *"}, {"sha": "c017b6e90ed8fb4fd97be6ee0107b27a0535ba12", "filename": "gcc/testsuite/g++.dg/ext/vla1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla1.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -19,7 +19,7 @@ class B { B (int); };\n B::B (int i)\n {\n   struct S {\n-    int ar[1][i];  // { dg-error \"9:size of array .ar. is not an integral\" \"\" { target c++11 } }\n+    int ar[1][i];  // { dg-error \"15:size of array .ar. is not an integral\" \"\" { target c++11 } }\n // { dg-error \"array bound\" \"\" { target c++98_only } .-1 }\n   } s;\n "}, {"sha": "00787840f196af8f5b2122880606ec5b734b86fa", "filename": "gcc/testsuite/g++.dg/init/array43.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray43.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,2 +1,2 @@\n-int a[] = 0;  // { dg-error \"5:initializer fails to determine size\" }\n+int a[] = 0;  // { dg-error \"11:initializer fails to determine size\" }\n // { dg-error \"11:array must be initialized\" \"\" { target *-*-* } .-1 }"}, {"sha": "c4ce468bae42d03d60c851d4b4fb48c427d7e8bd", "filename": "gcc/testsuite/g++.dg/init/initializer-string-too-long.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finitializer-string-too-long.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finitializer-string-too-long.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finitializer-string-too-long.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+/* Verify that we highlight *which* string is too long.  */\n+\n+char test[3][4] = { \"ok\", \"too long\", \"ok\" }; // { dg-error \"initializer-string for array of chars is too long\" }\n+/* { dg-begin-multiline-output \"\" }\n+ char test[3][4] = { \"ok\", \"too long\", \"ok\" };\n+                           ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "5c81c2c746b7fe68cb39d87596a969d2ac1e609c", "filename": "gcc/testsuite/g++.dg/init/new44.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -1,4 +1,5 @@\n // { dg-do compile }\n+// { dg-options \"-ftrack-macro-expansion=0\" }\n \n // Test for PR c++/67927 - array new expression with excessive number\n // of elements not diagnosed."}, {"sha": "171061b920af33ecf71ba796c870bd91e6f8de1e", "filename": "gcc/testsuite/g++.dg/init/pr43064-1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-1.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that errors about member initializers appear at the bad value,\n+   rather than on the last token of the final initializer.  */\n+\n+// { dg-do compile }\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+class X {\n+  X() : bad(42), // { dg-error \"invalid conversion from 'int' to 'void\\\\*'\" }\n+\tgood(42)\n+  { }\n+  \n+  void* bad;\n+  int good;\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   X() : bad(42),\n+             ^~\n+             |\n+             int\n+     { dg-end-multiline-output \"\" } */\n+};\n+\n+class Y {\n+  Y() : bad(-1), // { dg-error \"invalid conversion from 'int' to 'void\\\\*'\" }\n+\tgood(42)\n+  { }\n+  \n+  void* bad;\n+  int good;\n+\n+  /* { dg-begin-multiline-output \"\" }\n+   Y() : bad(-1),\n+             ^~\n+             |\n+             int\n+     { dg-end-multiline-output \"\" } */\n+};"}, {"sha": "bc8794792bfce3207a1b02672bcf28680049292e", "filename": "gcc/testsuite/g++.dg/init/pr43064-2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-2.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -0,0 +1,34 @@\n+/* Verify that warnings about member initializers appear at the bad value,\n+   rather than on the last token of the final initializer.  */\n+\n+// { dg-do compile }\n+// { dg-options \"-Wconversion-null -fdiagnostics-show-caret\" }\n+\n+#define NULL ((void *)0) // { dg-error \"invalid conversion from 'void\\\\*' to 'int'\" }\n+/* { dg-begin-multiline-output \"\" }\n+ #define NULL ((void *)0)\n+              ~^~~~~~~~~~\n+               |\n+               void*\n+   { dg-end-multiline-output \"\" } */\n+\n+class A\n+{\n+public:\n+  A();\n+  bool m_bool;\n+  int m_int;\n+  void *m_ptr;\n+};\n+\n+A::A()\n+  : m_bool(NULL),\n+    m_int(NULL), // { dg-message \"in expansion of macro 'NULL'\" }\n+    m_ptr(NULL)\n+{\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+     m_int(NULL),\n+           ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "36726a86c34da82db90917c2327cc31ae786f165", "filename": "gcc/testsuite/g++.dg/init/pr43064-3.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr43064-3.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -0,0 +1,32 @@\n+/* Verify that warnings about member initializers appear at the bad value,\n+   rather than on the last token of the final initializer.  */\n+\n+// { dg-do compile }\n+// { dg-options \"-Wconversion-null -fdiagnostics-show-caret\" }\n+\n+#define NULL __null // { dg-warning \"converting to non-pointer type 'int' from NULL\" }\n+/* { dg-begin-multiline-output \"\" }\n+ #define NULL __null\n+              ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+class A\n+{\n+public:\n+  A();\n+  bool m_bool;\n+  int m_int;\n+  void *m_ptr;\n+};\n+\n+A::A()\n+  : m_bool(NULL),\n+    m_int(NULL), // { dg-message \"in expansion of macro 'NULL'\" }\n+    m_ptr(NULL)\n+{\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+     m_int(NULL),\n+           ^~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "8d8df3de68eb368f12c7e6a954da71b033dcc312", "filename": "gcc/testsuite/g++.dg/other/fold1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -4,5 +4,5 @@\n struct A\n {\n     static const int i = i;  // { dg-error \"not declared\" }\n-    int x[i];\t\t     // { dg-error \"9:size of array .x. is not an integral constant-expression\" }\n+    int x[i];\t\t     // { dg-error \"11:size of array .x. is not an integral constant-expression\" }\n };"}, {"sha": "8a2b6f3a6223dd42ea3d786fc3179b63a69f6669", "filename": "gcc/testsuite/g++.dg/parse/crash36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -9,4 +9,4 @@ template <typename... T> struct A\t// { dg-warning \"variadic templates\" }\n   static const int i = sizeof (++t);\t// { dg-error \"was not declared in this scope\" }\n };\n \n-int x[A <int>::i];\t\t// { dg-error \"5:size of array .x. is not an integral constant-expression\" }\n+int x[A <int>::i];\t\t// { dg-error \"16:size of array .x. is not an integral constant-expression\" }"}, {"sha": "288da2cecff2b3af6cdd06c63538eb7c79bd8166", "filename": "gcc/testsuite/g++.dg/plugin/diagnostic-test-expressions-1.C", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -63,6 +63,13 @@ void test_integer_constants (void)\n    __emit_expression_range (0, 0);\n                                ^\n    { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, -273); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, -273);\n+                               ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n }\n \n void test_character_constants (void)\n@@ -111,6 +118,13 @@ void test_floating_constants (void)\n    __emit_expression_range (0, 6.022140857e23l );\n                                ^~~~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, -273.15f); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, -273.15f);\n+                               ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n }\n \n enum test_enum {"}, {"sha": "f5fd6b6e10fa04aa1459306be8db4683cf92abc0", "filename": "gcc/testsuite/g++.dg/template/defarg6.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg6.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -14,14 +14,12 @@ struct C\n template <typename T>\n struct D\n {\n-  static void func (X &ref = a); // not an error at this point\n+  static void func (X &ref = a); // { dg-error \"cannot bind non-const lvalue reference\" }\n };\n \n void Foo (X & obj)\n {\n   D<int>::func (obj);\n \n-  D<int>::func (); // { dg-error \"\" }\n+  D<int>::func (); // { dg-message \"when instantiating default argument for call\" }\n }\n-\n-// { dg-prune-output \"passing argument\" }"}, {"sha": "c6157ddfc7b09aaad622eed33d5173e39ac29132", "filename": "gcc/testsuite/g++.dg/wrappers/Wparentheses.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2FWparentheses.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2FWparentheses.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwrappers%2FWparentheses.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-Wparentheses\" }\n+\n+extern char read_skip_spaces ();\n+\n+void test ()\n+{\n+  char c;\n+  while ((c = read_skip_spaces ()) && c != ']')\n+    ;\n+}"}, {"sha": "21e2765c8eefb764c3d10ed9836fe051ac173685", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900402_02.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900402_02.C?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -6,17 +6,17 @@\n \n // keywords: arrays, array bound, zero length\n \n-typedef int array_type[0];\t\t// { dg-error \"13:ISO C\\\\+\\\\+ forbids zero-size array\" }\n+typedef int array_type[0];\t\t// { dg-error \"24:ISO C\\\\+\\\\+ forbids zero-size array\" }\n \n-int array_object_1[0];\t\t\t// { dg-error \"5:ISO C\\\\+\\\\+ forbids zero-size array\" }\n+int array_object_1[0];\t\t\t// { dg-error \"20:ISO C\\\\+\\\\+ forbids zero-size array\" }\n \n-void function_0 (int formal_array[0])\t// { dg-error \"22:ISO C\\\\+\\\\+ forbids zero-size array\" }\n+void function_0 (int formal_array[0])\t// { dg-error \"35:ISO C\\\\+\\\\+ forbids zero-size array\" }\n {\n }\n \n void function_2 ()\n {\n-  int local_object_array_0[0];\t\t// { dg-error \"7:ISO C\\\\+\\\\+ forbids zero-size array\" }\n+  int local_object_array_0[0];\t\t// { dg-error \"28:ISO C\\\\+\\\\+ forbids zero-size array\" }\n }\n \n int main () { return 0; }"}, {"sha": "5d0d4d3276811e665131647a0820c6a10260573c", "filename": "gcc/tree.c", "status": "modified", "additions": 389, "deletions": 13, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -2208,6 +2208,9 @@ build_string (int len, const char *str)\n tree\n build_complex (tree type, tree real, tree imag)\n {\n+  gcc_assert (CONSTANT_CLASS_P (real));\n+  gcc_assert (CONSTANT_CLASS_P (imag));\n+\n   tree t = make_node (COMPLEX_CST);\n \n   TREE_REALPART (t) = real;\n@@ -2506,11 +2509,13 @@ zerop (const_tree expr)\n }\n \n /* Return 1 if EXPR is the integer constant zero or a complex constant\n-   of zero.  */\n+   of zero, or a location wrapper for such a constant.  */\n \n bool\n integer_zerop (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n@@ -2528,11 +2533,13 @@ integer_zerop (const_tree expr)\n }\n \n /* Return 1 if EXPR is the integer constant one or the corresponding\n-   complex constant.  */\n+   complex constant, or a location wrapper for such a constant.  */\n \n bool\n integer_onep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n@@ -2550,11 +2557,14 @@ integer_onep (const_tree expr)\n }\n \n /* Return 1 if EXPR is the integer constant one.  For complex and vector,\n-   return 1 if every piece is the integer constant one.  */\n+   return 1 if every piece is the integer constant one.\n+   Also return 1 for location wrappers for such a constant.  */\n \n bool\n integer_each_onep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return (integer_onep (TREE_REALPART (expr))\n \t    && integer_onep (TREE_IMAGPART (expr)));\n@@ -2563,11 +2573,14 @@ integer_each_onep (const_tree expr)\n }\n \n /* Return 1 if EXPR is an integer containing all 1's in as much precision as\n-   it contains, or a complex or vector whose subparts are such integers.  */\n+   it contains, or a complex or vector whose subparts are such integers,\n+   or a location wrapper for such a constant.  */\n \n bool\n integer_all_onesp (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_CODE (expr) == COMPLEX_CST\n       && integer_all_onesp (TREE_REALPART (expr))\n       && integer_all_onesp (TREE_IMAGPART (expr)))\n@@ -2585,11 +2598,14 @@ integer_all_onesp (const_tree expr)\n \t  == wi::to_wide (expr));\n }\n \n-/* Return 1 if EXPR is the integer constant minus one.  */\n+/* Return 1 if EXPR is the integer constant minus one, or a location wrapper\n+   for such a constant.  */\n \n bool\n integer_minus_onep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return (integer_all_onesp (TREE_REALPART (expr))\n \t    && integer_zerop (TREE_IMAGPART (expr)));\n@@ -2598,11 +2614,13 @@ integer_minus_onep (const_tree expr)\n }\n \n /* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only\n-   one bit on).  */\n+   one bit on), or a location wrapper for such a constant.  */\n \n bool\n integer_pow2p (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_CODE (expr) == COMPLEX_CST\n       && integer_pow2p (TREE_REALPART (expr))\n       && integer_zerop (TREE_IMAGPART (expr)))\n@@ -2615,11 +2633,14 @@ integer_pow2p (const_tree expr)\n }\n \n /* Return 1 if EXPR is an integer constant other than zero or a\n-   complex constant other than zero.  */\n+   complex constant other than zero, or a location wrapper for such a\n+   constant.  */\n \n bool\n integer_nonzerop (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   return ((TREE_CODE (expr) == INTEGER_CST\n \t   && wi::to_wide (expr) != 0)\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n@@ -2629,21 +2650,27 @@ integer_nonzerop (const_tree expr)\n \n /* Return 1 if EXPR is the integer constant one.  For vector,\n    return 1 if every piece is the integer constant minus one\n-   (representing the value TRUE).  */\n+   (representing the value TRUE).\n+   Also return 1 for location wrappers for such a constant.  */\n \n bool\n integer_truep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_CODE (expr) == VECTOR_CST)\n     return integer_all_onesp (expr);\n   return integer_onep (expr);\n }\n \n-/* Return 1 if EXPR is the fixed-point constant zero.  */\n+/* Return 1 if EXPR is the fixed-point constant zero, or a location wrapper\n+   for such a constant.  */\n \n bool\n fixed_zerop (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   return (TREE_CODE (expr) == FIXED_CST\n \t  && TREE_FIXED_CST (expr).data.is_zero ());\n }\n@@ -2784,11 +2811,14 @@ tree_ctz (const_tree expr)\n }\n \n /* Return 1 if EXPR is the real constant zero.  Trailing zeroes matter for\n-   decimal float constants, so don't return 1 for them.  */\n+   decimal float constants, so don't return 1 for them.\n+   Also return 1 for location wrappers around such a constant.  */\n \n bool\n real_zerop (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case REAL_CST:\n@@ -2814,11 +2844,14 @@ real_zerop (const_tree expr)\n \n /* Return 1 if EXPR is the real constant one in real or complex form.\n    Trailing zeroes matter for decimal float constants, so don't return\n-   1 for them.  */\n+   1 for them.\n+   Also return 1 for location wrappers around such a constant.  */\n \n bool\n real_onep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case REAL_CST:\n@@ -2837,11 +2870,14 @@ real_onep (const_tree expr)\n }\n \n /* Return 1 if EXPR is the real constant minus one.  Trailing zeroes\n-   matter for decimal float constants, so don't return 1 for them.  */\n+   matter for decimal float constants, so don't return 1 for them.\n+   Also return 1 for location wrappers around such a constant.  */\n \n bool\n real_minus_onep (const_tree expr)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   switch (TREE_CODE (expr))\n     {\n     case REAL_CST:\n@@ -7106,6 +7142,9 @@ tree_int_cst_equal (const_tree t1, const_tree t2)\n   if (t1 == 0 || t2 == 0)\n     return 0;\n \n+  STRIP_ANY_LOCATION_WRAPPER (t1);\n+  STRIP_ANY_LOCATION_WRAPPER (t2);\n+\n   if (TREE_CODE (t1) == INTEGER_CST\n       && TREE_CODE (t2) == INTEGER_CST\n       && wi::to_widest (t1) == wi::to_widest (t2))\n@@ -7266,6 +7305,15 @@ simple_cst_equal (const_tree t1, const_tree t2)\n   if (t1 == 0 || t2 == 0)\n     return 0;\n \n+  /* For location wrappers to be the same, they must be at the same\n+     source location (and wrap the same thing).  */\n+  if (location_wrapper_p (t1) && location_wrapper_p (t2))\n+    {\n+      if (EXPR_LOCATION (t1) != EXPR_LOCATION (t2))\n+\treturn 0;\n+      return simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+    }\n+\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n@@ -11226,11 +11274,14 @@ uniform_vector_p (const_tree vec)\n \n /* If the argument is INTEGER_CST, return it.  If the argument is vector\n    with all elements the same INTEGER_CST, return that INTEGER_CST.  Otherwise\n-   return NULL_TREE.  */\n+   return NULL_TREE.\n+   Look through location wrappers. */\n \n tree\n uniform_integer_cst_p (tree t)\n {\n+  STRIP_ANY_LOCATION_WRAPPER (t);\n+\n   if (TREE_CODE (t) == INTEGER_CST)\n     return t;\n \n@@ -14646,6 +14697,11 @@ maybe_wrap_with_location (tree expr, location_t loc)\n   if (EXCEPTIONAL_CLASS_P (expr))\n     return expr;\n \n+  /* If any auto_suppress_location_wrappers are active, don't create\n+     wrappers.  */\n+  if (suppress_location_wrappers > 0)\n+    return expr;\n+\n   tree_code code\n     = (((CONSTANT_CLASS_P (expr) && TREE_CODE (expr) != STRING_CST)\n \t|| (TREE_CODE (expr) == CONST_DECL && !TREE_STATIC (expr)))\n@@ -14656,6 +14712,8 @@ maybe_wrap_with_location (tree expr, location_t loc)\n   return wrapper;\n }\n \n+int suppress_location_wrappers;\n+\n /* Return the name of combined function FN, for debugging purposes.  */\n \n const char *\n@@ -15146,6 +15204,323 @@ test_location_wrappers ()\n   check_strip_nops (wrapped_int_var, int_var);\n }\n \n+/* Test various tree predicates.  Verify that location wrappers don't\n+   affect the results.  */\n+\n+static void\n+test_predicates ()\n+{\n+  /* Build various constants and wrappers around them.  */\n+\n+  location_t loc = BUILTINS_LOCATION;\n+\n+  tree i_0 = build_int_cst (integer_type_node, 0);\n+  tree wr_i_0 = maybe_wrap_with_location (i_0, loc);\n+\n+  tree i_1 = build_int_cst (integer_type_node, 1);\n+  tree wr_i_1 = maybe_wrap_with_location (i_1, loc);\n+\n+  tree i_m1 = build_int_cst (integer_type_node, -1);\n+  tree wr_i_m1 = maybe_wrap_with_location (i_m1, loc);\n+\n+  tree f_0 = build_real_from_int_cst (float_type_node, i_0);\n+  tree wr_f_0 = maybe_wrap_with_location (f_0, loc);\n+  tree f_1 = build_real_from_int_cst (float_type_node, i_1);\n+  tree wr_f_1 = maybe_wrap_with_location (f_1, loc);\n+  tree f_m1 = build_real_from_int_cst (float_type_node, i_m1);\n+  tree wr_f_m1 = maybe_wrap_with_location (f_m1, loc);\n+\n+  tree c_i_0 = build_complex (NULL_TREE, i_0, i_0);\n+  tree c_i_1 = build_complex (NULL_TREE, i_1, i_0);\n+  tree c_i_m1 = build_complex (NULL_TREE, i_m1, i_0);\n+\n+  tree c_f_0 = build_complex (NULL_TREE, f_0, f_0);\n+  tree c_f_1 = build_complex (NULL_TREE, f_1, f_0);\n+  tree c_f_m1 = build_complex (NULL_TREE, f_m1, f_0);\n+\n+  /* TODO: vector constants.  */\n+\n+  /* Test integer_onep.  */\n+  ASSERT_FALSE (integer_onep (i_0));\n+  ASSERT_FALSE (integer_onep (wr_i_0));\n+  ASSERT_TRUE (integer_onep (i_1));\n+  ASSERT_TRUE (integer_onep (wr_i_1));\n+  ASSERT_FALSE (integer_onep (i_m1));\n+  ASSERT_FALSE (integer_onep (wr_i_m1));\n+  ASSERT_FALSE (integer_onep (f_0));\n+  ASSERT_FALSE (integer_onep (wr_f_0));\n+  ASSERT_FALSE (integer_onep (f_1));\n+  ASSERT_FALSE (integer_onep (wr_f_1));\n+  ASSERT_FALSE (integer_onep (f_m1));\n+  ASSERT_FALSE (integer_onep (wr_f_m1));\n+  ASSERT_FALSE (integer_onep (c_i_0));\n+  ASSERT_TRUE (integer_onep (c_i_1));\n+  ASSERT_FALSE (integer_onep (c_i_m1));\n+  ASSERT_FALSE (integer_onep (c_f_0));\n+  ASSERT_FALSE (integer_onep (c_f_1));\n+  ASSERT_FALSE (integer_onep (c_f_m1));\n+\n+  /* Test integer_zerop.  */\n+  ASSERT_TRUE (integer_zerop (i_0));\n+  ASSERT_TRUE (integer_zerop (wr_i_0));\n+  ASSERT_FALSE (integer_zerop (i_1));\n+  ASSERT_FALSE (integer_zerop (wr_i_1));\n+  ASSERT_FALSE (integer_zerop (i_m1));\n+  ASSERT_FALSE (integer_zerop (wr_i_m1));\n+  ASSERT_FALSE (integer_zerop (f_0));\n+  ASSERT_FALSE (integer_zerop (wr_f_0));\n+  ASSERT_FALSE (integer_zerop (f_1));\n+  ASSERT_FALSE (integer_zerop (wr_f_1));\n+  ASSERT_FALSE (integer_zerop (f_m1));\n+  ASSERT_FALSE (integer_zerop (wr_f_m1));\n+  ASSERT_TRUE (integer_zerop (c_i_0));\n+  ASSERT_FALSE (integer_zerop (c_i_1));\n+  ASSERT_FALSE (integer_zerop (c_i_m1));\n+  ASSERT_FALSE (integer_zerop (c_f_0));\n+  ASSERT_FALSE (integer_zerop (c_f_1));\n+  ASSERT_FALSE (integer_zerop (c_f_m1));\n+\n+  /* Test integer_all_onesp.  */\n+  ASSERT_FALSE (integer_all_onesp (i_0));\n+  ASSERT_FALSE (integer_all_onesp (wr_i_0));\n+  ASSERT_FALSE (integer_all_onesp (i_1));\n+  ASSERT_FALSE (integer_all_onesp (wr_i_1));\n+  ASSERT_TRUE (integer_all_onesp (i_m1));\n+  ASSERT_TRUE (integer_all_onesp (wr_i_m1));\n+  ASSERT_FALSE (integer_all_onesp (f_0));\n+  ASSERT_FALSE (integer_all_onesp (wr_f_0));\n+  ASSERT_FALSE (integer_all_onesp (f_1));\n+  ASSERT_FALSE (integer_all_onesp (wr_f_1));\n+  ASSERT_FALSE (integer_all_onesp (f_m1));\n+  ASSERT_FALSE (integer_all_onesp (wr_f_m1));\n+  ASSERT_FALSE (integer_all_onesp (c_i_0));\n+  ASSERT_FALSE (integer_all_onesp (c_i_1));\n+  ASSERT_FALSE (integer_all_onesp (c_i_m1));\n+  ASSERT_FALSE (integer_all_onesp (c_f_0));\n+  ASSERT_FALSE (integer_all_onesp (c_f_1));\n+  ASSERT_FALSE (integer_all_onesp (c_f_m1));\n+\n+  /* Test integer_minus_onep.  */\n+  ASSERT_FALSE (integer_minus_onep (i_0));\n+  ASSERT_FALSE (integer_minus_onep (wr_i_0));\n+  ASSERT_FALSE (integer_minus_onep (i_1));\n+  ASSERT_FALSE (integer_minus_onep (wr_i_1));\n+  ASSERT_TRUE (integer_minus_onep (i_m1));\n+  ASSERT_TRUE (integer_minus_onep (wr_i_m1));\n+  ASSERT_FALSE (integer_minus_onep (f_0));\n+  ASSERT_FALSE (integer_minus_onep (wr_f_0));\n+  ASSERT_FALSE (integer_minus_onep (f_1));\n+  ASSERT_FALSE (integer_minus_onep (wr_f_1));\n+  ASSERT_FALSE (integer_minus_onep (f_m1));\n+  ASSERT_FALSE (integer_minus_onep (wr_f_m1));\n+  ASSERT_FALSE (integer_minus_onep (c_i_0));\n+  ASSERT_FALSE (integer_minus_onep (c_i_1));\n+  ASSERT_TRUE (integer_minus_onep (c_i_m1));\n+  ASSERT_FALSE (integer_minus_onep (c_f_0));\n+  ASSERT_FALSE (integer_minus_onep (c_f_1));\n+  ASSERT_FALSE (integer_minus_onep (c_f_m1));\n+\n+  /* Test integer_each_onep.  */\n+  ASSERT_FALSE (integer_each_onep (i_0));\n+  ASSERT_FALSE (integer_each_onep (wr_i_0));\n+  ASSERT_TRUE (integer_each_onep (i_1));\n+  ASSERT_TRUE (integer_each_onep (wr_i_1));\n+  ASSERT_FALSE (integer_each_onep (i_m1));\n+  ASSERT_FALSE (integer_each_onep (wr_i_m1));\n+  ASSERT_FALSE (integer_each_onep (f_0));\n+  ASSERT_FALSE (integer_each_onep (wr_f_0));\n+  ASSERT_FALSE (integer_each_onep (f_1));\n+  ASSERT_FALSE (integer_each_onep (wr_f_1));\n+  ASSERT_FALSE (integer_each_onep (f_m1));\n+  ASSERT_FALSE (integer_each_onep (wr_f_m1));\n+  ASSERT_FALSE (integer_each_onep (c_i_0));\n+  ASSERT_FALSE (integer_each_onep (c_i_1));\n+  ASSERT_FALSE (integer_each_onep (c_i_m1));\n+  ASSERT_FALSE (integer_each_onep (c_f_0));\n+  ASSERT_FALSE (integer_each_onep (c_f_1));\n+  ASSERT_FALSE (integer_each_onep (c_f_m1));\n+\n+  /* Test integer_truep.  */\n+  ASSERT_FALSE (integer_truep (i_0));\n+  ASSERT_FALSE (integer_truep (wr_i_0));\n+  ASSERT_TRUE (integer_truep (i_1));\n+  ASSERT_TRUE (integer_truep (wr_i_1));\n+  ASSERT_FALSE (integer_truep (i_m1));\n+  ASSERT_FALSE (integer_truep (wr_i_m1));\n+  ASSERT_FALSE (integer_truep (f_0));\n+  ASSERT_FALSE (integer_truep (wr_f_0));\n+  ASSERT_FALSE (integer_truep (f_1));\n+  ASSERT_FALSE (integer_truep (wr_f_1));\n+  ASSERT_FALSE (integer_truep (f_m1));\n+  ASSERT_FALSE (integer_truep (wr_f_m1));\n+  ASSERT_FALSE (integer_truep (c_i_0));\n+  ASSERT_TRUE (integer_truep (c_i_1));\n+  ASSERT_FALSE (integer_truep (c_i_m1));\n+  ASSERT_FALSE (integer_truep (c_f_0));\n+  ASSERT_FALSE (integer_truep (c_f_1));\n+  ASSERT_FALSE (integer_truep (c_f_m1));\n+\n+  /* Test integer_nonzerop.  */\n+  ASSERT_FALSE (integer_nonzerop (i_0));\n+  ASSERT_FALSE (integer_nonzerop (wr_i_0));\n+  ASSERT_TRUE (integer_nonzerop (i_1));\n+  ASSERT_TRUE (integer_nonzerop (wr_i_1));\n+  ASSERT_TRUE (integer_nonzerop (i_m1));\n+  ASSERT_TRUE (integer_nonzerop (wr_i_m1));\n+  ASSERT_FALSE (integer_nonzerop (f_0));\n+  ASSERT_FALSE (integer_nonzerop (wr_f_0));\n+  ASSERT_FALSE (integer_nonzerop (f_1));\n+  ASSERT_FALSE (integer_nonzerop (wr_f_1));\n+  ASSERT_FALSE (integer_nonzerop (f_m1));\n+  ASSERT_FALSE (integer_nonzerop (wr_f_m1));\n+  ASSERT_FALSE (integer_nonzerop (c_i_0));\n+  ASSERT_TRUE (integer_nonzerop (c_i_1));\n+  ASSERT_TRUE (integer_nonzerop (c_i_m1));\n+  ASSERT_FALSE (integer_nonzerop (c_f_0));\n+  ASSERT_FALSE (integer_nonzerop (c_f_1));\n+  ASSERT_FALSE (integer_nonzerop (c_f_m1));\n+\n+  /* Test real_zerop.  */\n+  ASSERT_FALSE (real_zerop (i_0));\n+  ASSERT_FALSE (real_zerop (wr_i_0));\n+  ASSERT_FALSE (real_zerop (i_1));\n+  ASSERT_FALSE (real_zerop (wr_i_1));\n+  ASSERT_FALSE (real_zerop (i_m1));\n+  ASSERT_FALSE (real_zerop (wr_i_m1));\n+  ASSERT_TRUE (real_zerop (f_0));\n+  ASSERT_TRUE (real_zerop (wr_f_0));\n+  ASSERT_FALSE (real_zerop (f_1));\n+  ASSERT_FALSE (real_zerop (wr_f_1));\n+  ASSERT_FALSE (real_zerop (f_m1));\n+  ASSERT_FALSE (real_zerop (wr_f_m1));\n+  ASSERT_FALSE (real_zerop (c_i_0));\n+  ASSERT_FALSE (real_zerop (c_i_1));\n+  ASSERT_FALSE (real_zerop (c_i_m1));\n+  ASSERT_TRUE (real_zerop (c_f_0));\n+  ASSERT_FALSE (real_zerop (c_f_1));\n+  ASSERT_FALSE (real_zerop (c_f_m1));\n+\n+  /* Test real_onep.  */\n+  ASSERT_FALSE (real_onep (i_0));\n+  ASSERT_FALSE (real_onep (wr_i_0));\n+  ASSERT_FALSE (real_onep (i_1));\n+  ASSERT_FALSE (real_onep (wr_i_1));\n+  ASSERT_FALSE (real_onep (i_m1));\n+  ASSERT_FALSE (real_onep (wr_i_m1));\n+  ASSERT_FALSE (real_onep (f_0));\n+  ASSERT_FALSE (real_onep (wr_f_0));\n+  ASSERT_TRUE (real_onep (f_1));\n+  ASSERT_TRUE (real_onep (wr_f_1));\n+  ASSERT_FALSE (real_onep (f_m1));\n+  ASSERT_FALSE (real_onep (wr_f_m1));\n+  ASSERT_FALSE (real_onep (c_i_0));\n+  ASSERT_FALSE (real_onep (c_i_1));\n+  ASSERT_FALSE (real_onep (c_i_m1));\n+  ASSERT_FALSE (real_onep (c_f_0));\n+  ASSERT_TRUE (real_onep (c_f_1));\n+  ASSERT_FALSE (real_onep (c_f_m1));\n+\n+  /* Test real_minus_onep.  */\n+  ASSERT_FALSE (real_minus_onep (i_0));\n+  ASSERT_FALSE (real_minus_onep (wr_i_0));\n+  ASSERT_FALSE (real_minus_onep (i_1));\n+  ASSERT_FALSE (real_minus_onep (wr_i_1));\n+  ASSERT_FALSE (real_minus_onep (i_m1));\n+  ASSERT_FALSE (real_minus_onep (wr_i_m1));\n+  ASSERT_FALSE (real_minus_onep (f_0));\n+  ASSERT_FALSE (real_minus_onep (wr_f_0));\n+  ASSERT_FALSE (real_minus_onep (f_1));\n+  ASSERT_FALSE (real_minus_onep (wr_f_1));\n+  ASSERT_TRUE (real_minus_onep (f_m1));\n+  ASSERT_TRUE (real_minus_onep (wr_f_m1));\n+  ASSERT_FALSE (real_minus_onep (c_i_0));\n+  ASSERT_FALSE (real_minus_onep (c_i_1));\n+  ASSERT_FALSE (real_minus_onep (c_i_m1));\n+  ASSERT_FALSE (real_minus_onep (c_f_0));\n+  ASSERT_FALSE (real_minus_onep (c_f_1));\n+  ASSERT_TRUE (real_minus_onep (c_f_m1));\n+\n+  /* Test zerop.  */\n+  ASSERT_TRUE (zerop (i_0));\n+  ASSERT_TRUE (zerop (wr_i_0));\n+  ASSERT_FALSE (zerop (i_1));\n+  ASSERT_FALSE (zerop (wr_i_1));\n+  ASSERT_FALSE (zerop (i_m1));\n+  ASSERT_FALSE (zerop (wr_i_m1));\n+  ASSERT_TRUE (zerop (f_0));\n+  ASSERT_TRUE (zerop (wr_f_0));\n+  ASSERT_FALSE (zerop (f_1));\n+  ASSERT_FALSE (zerop (wr_f_1));\n+  ASSERT_FALSE (zerop (f_m1));\n+  ASSERT_FALSE (zerop (wr_f_m1));\n+  ASSERT_TRUE (zerop (c_i_0));\n+  ASSERT_FALSE (zerop (c_i_1));\n+  ASSERT_FALSE (zerop (c_i_m1));\n+  ASSERT_TRUE (zerop (c_f_0));\n+  ASSERT_FALSE (zerop (c_f_1));\n+  ASSERT_FALSE (zerop (c_f_m1));\n+\n+  /* Test tree_expr_nonnegative_p.  */\n+  ASSERT_TRUE (tree_expr_nonnegative_p (i_0));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (wr_i_0));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (i_1));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (wr_i_1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (i_m1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (wr_i_m1));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (f_0));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (wr_f_0));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (f_1));\n+  ASSERT_TRUE (tree_expr_nonnegative_p (wr_f_1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (f_m1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (wr_f_m1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_i_0));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_i_1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_i_m1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_f_0));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_f_1));\n+  ASSERT_FALSE (tree_expr_nonnegative_p (c_f_m1));\n+\n+  /* Test tree_expr_nonzero_p.  */\n+  ASSERT_FALSE (tree_expr_nonzero_p (i_0));\n+  ASSERT_FALSE (tree_expr_nonzero_p (wr_i_0));\n+  ASSERT_TRUE (tree_expr_nonzero_p (i_1));\n+  ASSERT_TRUE (tree_expr_nonzero_p (wr_i_1));\n+  ASSERT_TRUE (tree_expr_nonzero_p (i_m1));\n+  ASSERT_TRUE (tree_expr_nonzero_p (wr_i_m1));\n+\n+  /* Test integer_valued_real_p.  */\n+  ASSERT_FALSE (integer_valued_real_p (i_0));\n+  ASSERT_TRUE (integer_valued_real_p (f_0));\n+  ASSERT_TRUE (integer_valued_real_p (wr_f_0));\n+  ASSERT_TRUE (integer_valued_real_p (f_1));\n+  ASSERT_TRUE (integer_valued_real_p (wr_f_1));\n+\n+  /* Test integer_pow2p.  */\n+  ASSERT_FALSE (integer_pow2p (i_0));\n+  ASSERT_TRUE (integer_pow2p (i_1));\n+  ASSERT_TRUE (integer_pow2p (wr_i_1));\n+\n+  /* Test uniform_integer_cst_p.  */\n+  ASSERT_TRUE (uniform_integer_cst_p (i_0));\n+  ASSERT_TRUE (uniform_integer_cst_p (wr_i_0));\n+  ASSERT_TRUE (uniform_integer_cst_p (i_1));\n+  ASSERT_TRUE (uniform_integer_cst_p (wr_i_1));\n+  ASSERT_TRUE (uniform_integer_cst_p (i_m1));\n+  ASSERT_TRUE (uniform_integer_cst_p (wr_i_m1));\n+  ASSERT_FALSE (uniform_integer_cst_p (f_0));\n+  ASSERT_FALSE (uniform_integer_cst_p (wr_f_0));\n+  ASSERT_FALSE (uniform_integer_cst_p (f_1));\n+  ASSERT_FALSE (uniform_integer_cst_p (wr_f_1));\n+  ASSERT_FALSE (uniform_integer_cst_p (f_m1));\n+  ASSERT_FALSE (uniform_integer_cst_p (wr_f_m1));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_i_0));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_i_1));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_i_m1));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_f_0));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_f_1));\n+  ASSERT_FALSE (uniform_integer_cst_p (c_f_m1));\n+}\n+\n /* Check that string escaping works correctly.  */\n \n static void\n@@ -15199,6 +15574,7 @@ tree_c_tests ()\n   test_labels ();\n   test_vector_cst_patterns ();\n   test_location_wrappers ();\n+  test_predicates ();\n   test_escaped_strings ();\n }\n "}, {"sha": "ab928ca170e16ae7f39fd25d00db8d53c991503e", "filename": "gcc/tree.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd7fdca2ac17d8b823a16700525824ca312ade0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dfd7fdca2ac17d8b823a16700525824ca312ade0", "patch": "@@ -131,6 +131,12 @@ as_internal_fn (combined_fn code)\n #define CONSTANT_CLASS_P(NODE)\\\n \t(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_constant)\n \n+/* Nonzero if NODE represents a constant, or is a location wrapper\n+   around such a node.  */\n+\n+#define CONSTANT_CLASS_OR_WRAPPER_P(NODE)\\\n+\t(CONSTANT_CLASS_P (tree_strip_any_location_wrapper (NODE)))\n+\n /* Nonzero if NODE represents a type.  */\n \n #define TYPE_P(NODE)\\\n@@ -1175,6 +1181,19 @@ extern void protected_set_expr_location (tree, location_t);\n \n extern tree maybe_wrap_with_location (tree, location_t);\n \n+extern int suppress_location_wrappers;\n+\n+/* A class for suppressing the creation of location wrappers.\n+   Location wrappers will not be created during the lifetime\n+   of an instance of this class.  */\n+\n+class auto_suppress_location_wrappers\n+{\n+ public:\n+  auto_suppress_location_wrappers () { ++suppress_location_wrappers; }\n+  ~auto_suppress_location_wrappers () { --suppress_location_wrappers; }\n+};\n+\n /* In a TARGET_EXPR node.  */\n #define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)\n #define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)"}]}