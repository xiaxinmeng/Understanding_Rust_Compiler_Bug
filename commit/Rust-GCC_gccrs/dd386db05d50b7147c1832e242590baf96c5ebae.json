{"sha": "dd386db05d50b7147c1832e242590baf96c5ebae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQzODZkYjA1ZDUwYjcxNDdjMTgzMmUyNDI1OTBiYWY5NmM1ZWJhZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:13:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:13:26Z"}, "message": "[multiple changes]\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): For VM platforms, add missing expansion of\n\ttag check in case of dispatching call through \"=\".\n\n2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Subprogram_Declaration): In Ada2012 an incomplete\n\ttype is legal in the profile of any basic declaration.\n\t* sem_ch6.adb (Analyze_Return_Type, Process_Formals): In Ada2012 an\n\tincomplete type, including a limited view of a type, is legal in the\n\tprofile of any subprogram declaration.\n\tIf the type is tagged, its use is also legal in a body.\n\t* sem_ch10.adb (Install_Limited_With_Clause): Do not process context\n\titem if misplaced.\n\t(Install_Limited_Withed_Unit): Refine legality checks when both the\n\tlimited and the non-limited view of a package are visible in the context\n\tof a unit.\n\tIf this is not an error case, the limited view is ignored.\n\tfreeze.adb (Freeze_Entity): In Ada2012, an incomplete type is legal in\n\taccess to subprogram declarations\n\nFrom-SVN: r165295", "tree": {"sha": "60052b8b59e54383886c560597cfb24f91f11c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60052b8b59e54383886c560597cfb24f91f11c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd386db05d50b7147c1832e242590baf96c5ebae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd386db05d50b7147c1832e242590baf96c5ebae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd386db05d50b7147c1832e242590baf96c5ebae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd386db05d50b7147c1832e242590baf96c5ebae/comments", "author": null, "committer": null, "parents": [{"sha": "6dfc55927f4717baa28c751fedb85834733f7b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfc55927f4717baa28c751fedb85834733f7b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dfc55927f4717baa28c751fedb85834733f7b0d"}], "stats": {"total": 224, "additions": 202, "deletions": 22}, "files": [{"sha": "9260f78fcd89cf359212e3d726adbfebaa0cf77c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -1,3 +1,25 @@\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): For VM platforms, add missing expansion of\n+\ttag check in case of dispatching call through \"=\".\n+\n+2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Subprogram_Declaration): In Ada2012 an incomplete\n+\ttype is legal in the profile of any basic declaration.\n+\t* sem_ch6.adb (Analyze_Return_Type, Process_Formals): In Ada2012 an\n+\tincomplete type, including a limited view of a type, is legal in the\n+\tprofile of any subprogram declaration.\n+\tIf the type is tagged, its use is also legal in a body.\n+\t* sem_ch10.adb (Install_Limited_With_Clause): Do not process context\n+\titem if misplaced.\n+\t(Install_Limited_Withed_Unit): Refine legality checks when both the\n+\tlimited and the non-limited view of a package are visible in the context\n+\tof a unit.\n+\tIf this is not an error case, the limited view is ignored.\n+\tfreeze.adb (Freeze_Entity): In Ada2012, an incomplete type is legal in\n+\taccess to subprogram declarations\n+\n 2010-10-11  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch6.adb: Code clean up."}, {"sha": "1fe1eca0000b1618346cbfa63ce2163fd974a01f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -137,7 +137,7 @@ package body Exp_Ch6 is\n    --  access type. If the function call is the initialization expression for a\n    --  return object, we pass along the master passed in by the caller. The\n    --  activation chain to pass is always the local one. Note: Master_Actual\n-   --  can be Empty, but only if there are no tasks\n+   --  can be Empty, but only if there are no tasks.\n \n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n@@ -1779,6 +1779,11 @@ package body Exp_Ch6 is\n       --  convoluted tree traversal before setting the proper subprogram to be\n       --  called.\n \n+      function New_Value (From : Node_Id) return Node_Id;\n+      --  From is the original Expression. New_Value is equivalent to a call\n+      --  to Duplicate_Subexpr with an explicit dereference when From is an\n+      --  access parameter.\n+\n       --------------------------\n       -- Add_Actual_Parameter --\n       --------------------------\n@@ -1942,6 +1947,22 @@ package body Exp_Ch6 is\n          raise Program_Error;\n       end Inherited_From_Formal;\n \n+      ---------------\n+      -- New_Value --\n+      ---------------\n+\n+      function New_Value (From : Node_Id) return Node_Id is\n+         Res : constant Node_Id := Duplicate_Subexpr (From);\n+      begin\n+         if Is_Access_Type (Etype (From)) then\n+            return\n+              Make_Explicit_Dereference (Sloc (From),\n+                Prefix => Res);\n+         else\n+            return Res;\n+         end if;\n+      end New_Value;\n+\n       --  Local variables\n \n       Remote        : constant Boolean := Is_Remote_Call (Call_Node);\n@@ -2652,8 +2673,12 @@ package body Exp_Ch6 is\n         and then Present (Controlling_Argument (Call_Node))\n       then\n          declare\n+            Call_Typ   : constant Entity_Id := Etype (Call_Node);\n             Typ        : constant Entity_Id := Find_Dispatching_Type (Subp);\n             Eq_Prim_Op : Entity_Id := Empty;\n+            New_Call   : Node_Id;\n+            Param      : Node_Id;\n+            Prev_Call  : Node_Id;\n \n          begin\n             if not Is_Limited_Type (Typ) then\n@@ -2673,6 +2698,45 @@ package body Exp_Ch6 is\n             else\n                Apply_Tag_Checks (Call_Node);\n \n+               --  If this is a dispatching \"=\", we must first compare the\n+               --  tags so we generate: x.tag = y.tag and then x = y\n+\n+               if Subp = Eq_Prim_Op then\n+\n+                  --  Mark the node as analyzed to avoid reanalizing this\n+                  --  dispatching call (which would cause a never-ending loop)\n+\n+                  Prev_Call := Relocate_Node (Call_Node);\n+                  Set_Analyzed (Prev_Call);\n+\n+                  Param := First_Actual (Call_Node);\n+                  New_Call :=\n+                    Make_And_Then (Loc,\n+                      Left_Opnd =>\n+                           Make_Op_Eq (Loc,\n+                             Left_Opnd =>\n+                               Make_Selected_Component (Loc,\n+                                 Prefix        => New_Value (Param),\n+                                 Selector_Name =>\n+                                   New_Reference_To (First_Tag_Component (Typ),\n+                                                     Loc)),\n+\n+                             Right_Opnd =>\n+                               Make_Selected_Component (Loc,\n+                                 Prefix        =>\n+                                   Unchecked_Convert_To (Typ,\n+                                     New_Value (Next_Actual (Param))),\n+                                 Selector_Name =>\n+                                   New_Reference_To\n+                                     (First_Tag_Component (Typ), Loc))),\n+                      Right_Opnd => Prev_Call);\n+\n+                  Rewrite (Call_Node, New_Call);\n+\n+                  Analyze_And_Resolve\n+                    (Call_Node, Call_Typ, Suppress => All_Checks);\n+               end if;\n+\n                --  Expansion of a dispatching call results in an indirect call,\n                --  which in turn causes current values to be killed (see\n                --  Resolve_Call), so on VM targets we do the call here to\n@@ -2685,9 +2749,7 @@ package body Exp_Ch6 is\n             --  to the call node because we generated:\n             --     x.tag = y.tag and then x = y\n \n-            if Subp = Eq_Prim_Op\n-              and then Nkind (Call_Node) = N_Op_And\n-            then\n+            if Subp = Eq_Prim_Op then\n                Call_Node := Right_Opnd (Call_Node);\n             end if;\n          end;"}, {"sha": "c8072200591553857991532937065545953dc085", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -3738,7 +3738,11 @@ package body Freeze is\n                then\n                   if Is_Tagged_Type (Etype (Formal)) then\n                      null;\n-                  else\n+\n+                  --  AI05-151 : incomplete types are allowed in access to\n+                  --  subprogram specifications.\n+\n+                  elsif Ada_Version < Ada_2012 then\n                      Error_Msg_NE\n                        (\"invalid use of incomplete type&\", E, Etype (Formal));\n                   end if;"}, {"sha": "3e73151a402c0c234286bb2f7d843f5e468c90cd", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -3726,6 +3726,7 @@ package body Sem_Ch10 is\n       while Present (Item) loop\n          if Nkind (Item) = N_With_Clause\n            and then Limited_Present (Item)\n+           and then not Error_Posted (Item)\n          then\n             if Nkind (Name (Item)) = N_Selected_Component then\n                Expand_Limited_With_Clause\n@@ -4703,7 +4704,49 @@ package body Sem_Ch10 is\n           (Is_Immediately_Visible (P)\n             or else (Is_Child_Package and then Is_Visible_Child_Unit (P)))\n       then\n-         return;\n+\n+         --  The presence of both the limited and the analyzed nonlimited view\n+         --  may also be an error, such as an illegal context for a limited\n+         --  with_clause. In that case, do not process the context item at all.\n+\n+         if Error_Posted (N) then\n+            return;\n+         end if;\n+\n+         if Nkind (Unit (Cunit (Current_Sem_Unit))) = N_Package_Body then\n+            declare\n+               Item : Node_Id;\n+            begin\n+               Item := First (Context_Items (Cunit (Current_Sem_Unit)));\n+               while Present (Item) loop\n+                  if Nkind (Item) = N_With_Clause\n+                    and then Comes_From_Source (Item)\n+                    and then Entity (Name (Item)) = P\n+                  then\n+                     return;\n+                  end if;\n+\n+                  Next (Item);\n+               end loop;\n+            end;\n+\n+            --  If this is a child body, assume that the nonlimited with_clause\n+            --  appears in an ancestor. Could be refined ???\n+\n+            if Is_Child_Unit\n+              (Defining_Entity\n+                 (Unit (Library_Unit (Cunit (Current_Sem_Unit)))))\n+            then\n+               return;\n+            end if;\n+\n+         else\n+\n+            --  If in package declaration, nonlimited view brought in from\n+            --  parent unit or some error condition.\n+\n+            return;\n+         end if;\n       end if;\n \n       if Debug_Flag_I then"}, {"sha": "54457405070ab0259f10156a4eeeb66e331e44cc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -1112,9 +1112,18 @@ package body Sem_Ch3 is\n \n                else\n                   if From_With_Type (Typ) then\n-                     Error_Msg_NE\n-                      (\"illegal use of incomplete type&\",\n-                         Result_Definition (T_Def), Typ);\n+\n+                     --  AI05-151 : incomplete types are allowed in all basic\n+                     --  declarations, including access to subprograms.\n+\n+                     if Ada_Version >= Ada_2012 then\n+                        null;\n+\n+                     else\n+                        Error_Msg_NE\n+                         (\"illegal use of incomplete type&\",\n+                            Result_Definition (T_Def), Typ);\n+                     end if;\n \n                   elsif Ekind (Current_Scope) = E_Package\n                     and then In_Private_Part (Current_Scope)\n@@ -7037,7 +7046,7 @@ package body Sem_Ch3 is\n \n          Check_Or_Process_Discriminants (N, Derived_Type);\n \n-         --  For non-tagged types the constraint on the Parent_Type must be\n+         --  For untagged types, the constraint on the Parent_Type must be\n          --  present and is used to rename the discriminants.\n \n          if not Is_Tagged and then not Has_Discriminants (Parent_Type) then\n@@ -13179,7 +13188,7 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Final check: Direct descendants must have their primitives in the\n-      --  same order. We exclude from this test non-tagged types and instances\n+      --  same order. We exclude from this test untagged types and instances\n       --  of formal derived types. We skip this test if we have already\n       --  reported serious errors in the sources.\n \n@@ -16180,9 +16189,9 @@ package body Sem_Ch3 is\n                  (\"discriminant defaults not allowed for formal type\",\n                   Expression (Discr));\n \n-            --  Tagged types cannot have defaulted discriminants, but a\n-            --  non-tagged private type with defaulted discriminants\n-            --   can have a tagged completion.\n+            --  Tagged types declarations cannot have defaulted discriminants,\n+            --  but an untagged private type with defaulted discriminants can\n+            --  have a tagged completion.\n \n             elsif Is_Tagged_Type (Current_Scope)\n               and then Comes_From_Source (N)"}, {"sha": "9b77577e7aae63b4b174bff5b87de54a9e7f25af", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd386db05d50b7147c1832e242590baf96c5ebae/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=dd386db05d50b7147c1832e242590baf96c5ebae", "patch": "@@ -1432,8 +1432,27 @@ package body Sem_Ch6 is\n                          and then\n                            Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n             then\n-               Error_Msg_NE\n-                 (\"invalid use of incomplete type&\", Designator, Typ);\n+               --  AI05-0151: Tagged incomplete types are allowed in all formal\n+               --  parts. Untagged incomplete types are not allowed in bodies.\n+\n+               if Ada_Version >= Ada_2012 then\n+                  if Is_Tagged_Type (Typ) then\n+                     null;\n+\n+                  elsif Nkind_In (Parent (Parent (N)),\n+                     N_Accept_Statement,\n+                     N_Entry_Body,\n+                     N_Subprogram_Body)\n+                  then\n+                     Error_Msg_NE\n+                       (\"invalid use of untagged incomplete type&\",\n+                          Designator, Typ);\n+                  end if;\n+\n+               else\n+                  Error_Msg_NE\n+                    (\"invalid use of incomplete type&\", Designator, Typ);\n+               end if;\n             end if;\n          end if;\n \n@@ -8306,13 +8325,34 @@ package body Sem_Ch6 is\n                elsif not Nkind_In (Parent (T), N_Access_Function_Definition,\n                                                N_Access_Procedure_Definition)\n                then\n-                  Error_Msg_NE\n-                    (\"invalid use of incomplete type&\",\n-                       Param_Spec, Formal_Type);\n \n-                  --  Further checks on the legality of incomplete types\n-                  --  in formal parts must be delayed until the freeze point\n-                  --  of the enclosing subprogram or access to subprogram.\n+                  --  AI05-0151: Tagged incomplete types are allowed in all\n+                  --  formal parts. Untagged incomplete types are not allowed\n+                  --  in bodies.\n+\n+                  if Ada_Version >= Ada_2012 then\n+                     if Is_Tagged_Type (Formal_Type) then\n+                        null;\n+\n+                     elsif Nkind_In (Parent (Parent (T)),\n+                        N_Accept_Statement,\n+                        N_Entry_Body,\n+                        N_Subprogram_Body)\n+                     then\n+                        Error_Msg_NE\n+                          (\"invalid use of untagged incomplete type&\",\n+                             Ptype, Formal_Type);\n+                     end if;\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"invalid use of incomplete type&\",\n+                          Param_Spec, Formal_Type);\n+\n+                     --  Further checks on the legality of incomplete types\n+                     --  in formal parts are delayed until the freeze point\n+                     --  of the enclosing subprogram or access to subprogram.\n+                  end if;\n                end if;\n \n             elsif Ekind (Formal_Type) = E_Void then"}]}