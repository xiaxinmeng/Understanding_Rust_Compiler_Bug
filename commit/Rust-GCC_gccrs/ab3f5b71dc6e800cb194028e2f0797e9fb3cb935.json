{"sha": "ab3f5b71dc6e800cb194028e2f0797e9fb3cb935", "node_id": "C_kwDOANBUbNoAKGFiM2Y1YjcxZGM2ZTgwMGNiMTk0MDI4ZTJmMDc5N2U5ZmIzY2I5MzU", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-16T13:47:58Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-16T13:51:26Z"}, "message": "rs6000: Refactor altivec_build_resolved_builtin\n\nWhile replacing the built-in machinery, we agreed to defer some necessary\nrefactoring of the overload processing.  This patch cleans it up considerably.\n\nI've put in one FIXME for an additional level of cleanup that should be done\nindependently.  The various helper functions (resolve_VEC_*) can be simplified\nif we move the argument processing in altivec_resolve_overloaded_builtin\nearlier.  But this requires making nontrivial changes to those functions that\nwill need careful review.  Let's do that in a later patch.\n\n2021-12-16  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-c.c (resolution): New enum.\n\t(resolve_vec_mul): New function.\n\t(resolve_vec_cmpne): Likewise.\n\t(resolve_vec_adde_sube): Likewise.\n\t(resolve_vec_addec_subec): Likewise.\n\t(resolve_vec_splats): Likewise.\n\t(resolve_vec_extract): Likewise.\n\t(resolve_vec_insert): Likewise.\n\t(resolve_vec_step): Likewise.\n\t(find_instance): Likewise.\n\t(altivec_resolve_overloaded_builtin): Many cleanups.  Call factored-out\n\tfunctions.  Move variable declarations closer to uses.  Add commentary.\n\tRemove unnecessary levels of braces.  Avoid use of gotos.  Change\n\tmisleading variable names.  Use switches over if-else-if chains.", "tree": {"sha": "c77546364f7069e82c8caa8f4e2ccbf6cbd3a4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c77546364f7069e82c8caa8f4e2ccbf6cbd3a4c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935/comments", "author": null, "committer": null, "parents": [{"sha": "0a68862e782847752be0ea2b2a987278cdbefc9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a68862e782847752be0ea2b2a987278cdbefc9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a68862e782847752be0ea2b2a987278cdbefc9e"}], "stats": {"total": 1717, "additions": 945, "deletions": 772}, "files": [{"sha": "ac8fe8a1c23c4c5f671d1b61425469b4a8c474ae", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 945, "deletions": 772, "changes": 1717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3f5b71dc6e800cb194028e2f0797e9fb3cb935/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=ab3f5b71dc6e800cb194028e2f0797e9fb3cb935", "patch": "@@ -928,710 +928,939 @@ altivec_build_resolved_builtin (tree *args, int n, tree fntype, tree ret_type,\n   return fold_convert (ret_type, call);\n }\n \n-/* Implementation of the resolve_overloaded_builtin target hook, to\n-   support Altivec's overloaded builtins.  FIXME: This code needs\n-   to be brutally factored.  */\n+/* Enumeration of possible results from attempted overload resolution.\n+   This is used by special-case helper functions to tell their caller\n+   whether they succeeded and what still needs to be done.\n \n-tree\n-altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n-\t\t\t\t    void *passed_arglist)\n+\tunresolved = Still needs processing\n+\t  resolved = Resolved (but may be an error_mark_node)\n+      resolved_bad = An error that needs handling by the caller.  */\n+\n+enum resolution { unresolved, resolved, resolved_bad };\n+\n+/* Resolve an overloaded vec_mul call and return a tree expression for the\n+   resolved call if successful.  NARGS is the number of arguments to the call.\n+   ARGLIST contains the arguments.  RES must be set to indicate the status of\n+   the resolution attempt.  LOC contains statement location information.  */\n+\n+static tree\n+resolve_vec_mul (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n+\t\t location_t loc)\n {\n-  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n-  unsigned int nargs = vec_safe_length (arglist);\n-  enum rs6000_gen_builtins fcode\n-    = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n-  tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-  tree types[MAX_OVLD_ARGS];\n-  tree args[MAX_OVLD_ARGS];\n+  /* vec_mul needs to be special cased because there are no instructions for it\n+     for the {un}signed char, {un}signed short, and {un}signed int types.  */\n+  if (nargs != 2)\n+    {\n+      error (\"builtin %qs only accepts 2 arguments\", \"vec_mul\");\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-  /* Return immediately if this isn't an overload.  */\n-  if (fcode <= RS6000_OVLD_NONE)\n-    return NULL_TREE;\n+  tree arg0 = (*arglist)[0];\n+  tree arg0_type = TREE_TYPE (arg0);\n+  tree arg1 = (*arglist)[1];\n+  tree arg1_type = TREE_TYPE (arg1);\n \n-  unsigned int adj_fcode = fcode - RS6000_OVLD_NONE;\n+  /* Both arguments must be vectors and the types must be compatible.  */\n+  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-  if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"altivec_resolve_overloaded_builtin, code = %4d, %s\\n\",\n-\t     (int) fcode, IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+    {\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode:\n+      /* For scalar types just use a multiply expression.  */\n+      *res = resolved;\n+      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n+    case E_SFmode:\n+      {\n+\t/* For floats use the xvmulsp instruction directly.  */\n+\t*res = resolved;\n+\ttree call = rs6000_builtin_decls[RS6000_BIF_XVMULSP];\n+\treturn build_call_expr (call, 2, arg0, arg1);\n+      }\n+    case E_DFmode:\n+      {\n+\t/* For doubles use the xvmuldp instruction directly.  */\n+\t*res = resolved;\n+\ttree call = rs6000_builtin_decls[RS6000_BIF_XVMULDP];\n+\treturn build_call_expr (call, 2, arg0, arg1);\n+      }\n+    /* Other types are errors.  */\n+    default:\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n+}\n \n-  /* vec_lvsl and vec_lvsr are deprecated for use with LE element order.  */\n-  if (fcode == RS6000_OVLD_VEC_LVSL && !BYTES_BIG_ENDIAN)\n-    warning (OPT_Wdeprecated,\n-\t     \"%<vec_lvsl%> is deprecated for little endian; use \"\n-\t     \"assignment for unaligned loads and stores\");\n-  else if (fcode == RS6000_OVLD_VEC_LVSR && !BYTES_BIG_ENDIAN)\n-    warning (OPT_Wdeprecated,\n-\t     \"%<vec_lvsr%> is deprecated for little endian; use \"\n-\t     \"assignment for unaligned loads and stores\");\n+/* Resolve an overloaded vec_cmpne call and return a tree expression for the\n+   resolved call if successful.  NARGS is the number of arguments to the call.\n+   ARGLIST contains the arguments.  RES must be set to indicate the status of\n+   the resolution attempt.  LOC contains statement location information.  */\n \n-  if (fcode == RS6000_OVLD_VEC_MUL)\n+static tree\n+resolve_vec_cmpne (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs,\n+\t\t   location_t loc)\n+{\n+  /* vec_cmpne needs to be special cased because there are no instructions\n+     for it (prior to power 9).  */\n+  if (nargs != 2)\n     {\n-      /* vec_mul needs to be special cased because there are no instructions\n-\t for it for the {un}signed char, {un}signed short, and {un}signed int\n-\t types.  */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_mul\");\n-\t  return error_mark_node;\n-\t}\n+      error (\"builtin %qs only accepts 2 arguments\", \"vec_cmpne\");\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n+\n+  tree arg0 = (*arglist)[0];\n+  tree arg0_type = TREE_TYPE (arg0);\n+  tree arg1 = (*arglist)[1];\n+  tree arg1_type = TREE_TYPE (arg1);\n \n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n+  /* Both arguments must be vectors and the types must be compatible.  */\n+  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-      /* Both arguments must be vectors and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n-\tgoto bad;\n+  machine_mode arg0_elt_mode = TYPE_MODE (TREE_TYPE (arg0_type));\n \n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+  /* Power9 instructions provide the most efficient implementation of\n+     ALTIVEC_BUILTIN_VEC_CMPNE if the mode is not DImode or TImode\n+     or SFmode or DFmode.  */\n+  if (!TARGET_P9_VECTOR\n+      || arg0_elt_mode == DImode\n+      || arg0_elt_mode == TImode\n+      || arg0_elt_mode == SFmode\n+      || arg0_elt_mode == DFmode)\n+    {\n+      switch (arg0_elt_mode)\n \t{\n-\t  case E_QImode:\n-\t  case E_HImode:\n-\t  case E_SImode:\n-\t  case E_DImode:\n-\t  case E_TImode:\n-\t    {\n-\t      /* For scalar types just use a multiply expression.  */\n-\t      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n-\t    }\n-\t  case E_SFmode:\n-\t    {\n-\t      /* For floats use the xvmulsp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls[RS6000_BIF_XVMULSP];\n-\t      return build_call_expr (call, 2, arg0, arg1);\n-\t    }\n-\t  case E_DFmode:\n-\t    {\n-\t      /* For doubles use the xvmuldp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls[RS6000_BIF_XVMULDP];\n-\t      return build_call_expr (call, 2, arg0, arg1);\n-\t    }\n+\t  /* vec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb),\n+\t\t\t\t\t     vec_cmpeq (va, vb)).  */\n+\t  /* Note:  vec_nand also works but opt changes vec_nand's\n+\t     to vec_nor's anyway.  */\n+\tcase E_QImode:\n+\tcase E_HImode:\n+\tcase E_SImode:\n+\tcase E_DImode:\n+\tcase E_TImode:\n+\tcase E_SFmode:\n+\tcase E_DFmode:\n+\t  {\n+\t    /* call = vec_cmpeq (va, vb)\n+\t       result = vec_nor (call, call).  */\n+\t    vec<tree, va_gc> *params = make_tree_vector ();\n+\t    vec_safe_push (params, arg0);\n+\t    vec_safe_push (params, arg1);\n+\t    tree decl = rs6000_builtin_decls[RS6000_OVLD_VEC_CMPEQ];\n+\t    tree call = altivec_resolve_overloaded_builtin (loc, decl, params);\n+\t    /* Use save_expr to ensure that operands used more than once\n+\t       that may have side effects (like calls) are only evaluated\n+\t       once.  */\n+\t    call = save_expr (call);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, call);\n+\t    vec_safe_push (params, call);\n+\t    decl = rs6000_builtin_decls[RS6000_OVLD_VEC_NOR];\n+\t    *res = resolved;\n+\t    return altivec_resolve_overloaded_builtin (loc, decl, params);\n+\t  }\n \t  /* Other types are errors.  */\n-\t  default:\n-\t    goto bad;\n+\tdefault:\n+\t  *res = resolved_bad;\n+\t  return error_mark_node;\n \t}\n     }\n \n-  if (fcode == RS6000_OVLD_VEC_CMPNE)\n+  /* Otherwise this call is unresolved, and altivec_resolve_overloaded_builtin\n+     will later process the Power9 alternative.  */\n+  *res = unresolved;\n+  return error_mark_node;\n+}\n+\n+/* Resolve an overloaded vec_adde or vec_sube call and return a tree\n+   expression for the resolved call if successful.  NARGS is the number of\n+   arguments to the call.  ARGLIST contains the arguments.  RES must be set\n+   to indicate the status of the resolution attempt.  LOC contains statement\n+   location information.  */\n+\n+static tree\n+resolve_vec_adde_sube (resolution *res, rs6000_gen_builtins fcode,\n+\t\t       vec<tree, va_gc> *arglist, unsigned nargs,\n+\t\t       location_t loc)\n+{\n+  /* vec_adde needs to be special cased because there is no instruction\n+     for the {un}signed int version.  */\n+  if (nargs != 3)\n     {\n-      /* vec_cmpne needs to be special cased because there are no instructions\n-\t for it (prior to power 9).  */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_cmpne\");\n-\t  return error_mark_node;\n-\t}\n+      const char *name;\n+      name = fcode == RS6000_OVLD_VEC_ADDE ? \"vec_adde\" : \"vec_sube\";\n+      error (\"builtin %qs only accepts 3 arguments\", name);\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-\n-      /* Both arguments must be vectors and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n-\tgoto bad;\n-\n-      /* Power9 instructions provide the most efficient implementation of\n-\t ALTIVEC_BUILTIN_VEC_CMPNE if the mode is not DImode or TImode\n-\t or SFmode or DFmode.  */\n-      if (!TARGET_P9_VECTOR\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DImode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == TImode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == SFmode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DFmode))\n-\t{\n-\t  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t    {\n-\t      /* vec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb),\n-\t\t vec_cmpeq (va, vb)).  */\n-\t      /* Note:  vec_nand also works but opt changes vec_nand's\n-\t\t to vec_nor's anyway.  */\n-\t    case E_QImode:\n-\t    case E_HImode:\n-\t    case E_SImode:\n-\t    case E_DImode:\n-\t    case E_TImode:\n-\t    case E_SFmode:\n-\t    case E_DFmode:\n-\t      {\n-\t\t/* call = vec_cmpeq (va, vb)\n-\t\t   result = vec_nor (call, call).  */\n-\t\tvec<tree, va_gc> *params = make_tree_vector ();\n-\t\tvec_safe_push (params, arg0);\n-\t\tvec_safe_push (params, arg1);\n-\t\ttree call = altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls[RS6000_OVLD_VEC_CMPEQ],\n-\t\t   params);\n-\t\t/* Use save_expr to ensure that operands used more than once\n-\t\t   that may have side effects (like calls) are only evaluated\n-\t\t   once.  */\n-\t\tcall = save_expr (call);\n-\t\tparams = make_tree_vector ();\n-\t\tvec_safe_push (params, call);\n-\t\tvec_safe_push (params, call);\n-\t\treturn altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls[RS6000_OVLD_VEC_NOR], params);\n-\t      }\n-\t      /* Other types are errors.  */\n-\t    default:\n-\t      goto bad;\n-\t    }\n-\t}\n-      /* else, fall through and process the Power9 alternative below */\n+  tree arg0 = (*arglist)[0];\n+  tree arg0_type = TREE_TYPE (arg0);\n+  tree arg1 = (*arglist)[1];\n+  tree arg1_type = TREE_TYPE (arg1);\n+  tree arg2 = (*arglist)[2];\n+  tree arg2_type = TREE_TYPE (arg2);\n+\n+  /* All 3 arguments must be vectors of (signed or unsigned) (int or\n+     __int128) and the types must be compatible.  */\n+  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (arg0_type, arg1_type)\n+      || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n     }\n \n-  if (fcode == RS6000_OVLD_VEC_ADDE || fcode == RS6000_OVLD_VEC_SUBE)\n+  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n     {\n-      /* vec_adde needs to be special cased because there is no instruction\n-\t  for the {un}signed int version.  */\n-      if (nargs != 3)\n-\t{\n-\t  const char *name;\n-\t  name = fcode == RS6000_OVLD_VEC_ADDE ? \"vec_adde\" : \"vec_sube\";\n-\t  error (\"builtin %qs only accepts 3 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n+      /* For {un}signed ints,\n+\t vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n+\t\t\t\t\t       vec_and (carryv, 1)).\n+\t vec_sube (va, vb, carryv) == vec_sub (vec_sub (va, vb),\n+\t\t\t\t\t       vec_and (carryv, 1)).  */\n+    case E_SImode:\n+      {\n+\tvec<tree, va_gc> *params = make_tree_vector ();\n+\tvec_safe_push (params, arg0);\n+\tvec_safe_push (params, arg1);\n \n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-      tree arg2 = (*arglist)[2];\n-      tree arg2_type = TREE_TYPE (arg2);\n-\n-      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n-\t __int128) and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n-\tgoto bad;\n-\n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t{\n-\t  /* For {un}signed ints,\n-\t     vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n-\t\t\t\t\t\t   vec_and (carryv, 1)).\n-\t     vec_sube (va, vb, carryv) == vec_sub (vec_sub (va, vb),\n-\t\t\t\t\t\t   vec_and (carryv, 1)).  */\n-\t  case E_SImode:\n-\t    {\n-\t      tree add_sub_builtin;\n+\ttree add_sub_builtin;\n+\tif (fcode == RS6000_OVLD_VEC_ADDE)\n+\t  add_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n+\telse\n+\t  add_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n \n-\t      vec<tree, va_gc> *params = make_tree_vector ();\n-\t      vec_safe_push (params, arg0);\n-\t      vec_safe_push (params, arg1);\n+\ttree call = altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n+\t\t\t\t\t\t\tparams);\n+\ttree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n+\ttree ones_vector = build_vector_from_val (arg0_type, const1);\n+\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n+\t\t\t\t\t arg2, ones_vector);\n+\tparams = make_tree_vector ();\n+\tvec_safe_push (params, call);\n+\tvec_safe_push (params, and_expr);\n+\t*res = resolved;\n+\treturn altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n+\t\t\t\t\t\t   params);\n+      }\n+      /* For {un}signed __int128s use the vaddeuqm/vsubeuqm instruction\n+\t directly using the standard machinery.  */\n+    case E_TImode:\n+      *res = unresolved;\n+      break;\n \n-\t      if (fcode == RS6000_OVLD_VEC_ADDE)\n-\t\tadd_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n-\t      else\n-\t\tadd_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n-\n-\t      tree call\n-\t\t= altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n-\t\t\t\t\t\t      params);\n-\t      tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\t      tree ones_vector = build_vector_from_val (arg0_type, const1);\n-\t      tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t       arg2, ones_vector);\n-\t      params = make_tree_vector ();\n-\t      vec_safe_push (params, call);\n-\t      vec_safe_push (params, and_expr);\n-\t      return altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n-\t\t\t\t\t\t\t params);\n-\t    }\n-\t  /* For {un}signed __int128s use the vaddeuqm/vsubeuqm instruction\n-\t     directly.  */\n-\t  case E_TImode:\n-\t    break;\n-\n-\t  /* Types other than {un}signed int and {un}signed __int128\n-\t\tare errors.  */\n-\t  default:\n-\t    goto bad;\n-\t}\n+      /* Types other than {un}signed int and {un}signed __int128\n+\t are errors.  */\n+    default:\n+      *res = resolved_bad;\n     }\n \n-  if (fcode == RS6000_OVLD_VEC_ADDEC || fcode == RS6000_OVLD_VEC_SUBEC)\n+  return error_mark_node;\n+}\n+\n+/* Resolve an overloaded vec_addec or vec_subec call and return a tree\n+   expression for the resolved call if successful.  NARGS is the number of\n+   arguments to the call.  ARGLIST contains the arguments.  RES must be set\n+   to indicate the status of the resolution attempt.  LOC contains statement\n+   location information.  */\n+\n+static tree\n+resolve_vec_addec_subec (resolution *res, rs6000_gen_builtins fcode,\n+\t\t\t vec<tree, va_gc> *arglist, unsigned nargs,\n+\t\t\t location_t loc)\n+{\n+  /* vec_addec and vec_subec needs to be special cased because there is\n+     no instruction for the (un)signed int version.  */\n+  if (nargs != 3)\n     {\n-      /* vec_addec and vec_subec needs to be special cased because there is\n-\t no instruction for the {un}signed int version.  */\n-      if (nargs != 3)\n-\t{\n-\t  const char *name;\n-\t  name = fcode == RS6000_OVLD_VEC_ADDEC ? \"vec_addec\" : \"vec_subec\";\n-\t  error (\"builtin %qs only accepts 3 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n+      const char *name;\n+      name = fcode == RS6000_OVLD_VEC_ADDEC ? \"vec_addec\" : \"vec_subec\";\n+      error (\"builtin %qs only accepts 3 arguments\", name);\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-      tree arg2 = (*arglist)[2];\n-      tree arg2_type = TREE_TYPE (arg2);\n-\n-      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n-\t __int128) and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n-\tgoto bad;\n-\n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t{\n-\t  /* For {un}signed ints,\n-\t      vec_addec (va, vb, carryv) ==\n-\t\t\t\tvec_or (vec_addc (va, vb),\n-\t\t\t\t\tvec_addc (vec_add (va, vb),\n-\t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n-\t  case E_SImode:\n-\t    {\n-\t    /* Use save_expr to ensure that operands used more than once\n-\t\tthat may have side effects (like calls) are only evaluated\n-\t\tonce.  */\n-\t    tree as_builtin;\n-\t    tree as_c_builtin;\n+  tree arg0 = (*arglist)[0];\n+  tree arg0_type = TREE_TYPE (arg0);\n+  tree arg1 = (*arglist)[1];\n+  tree arg1_type = TREE_TYPE (arg1);\n+  tree arg2 = (*arglist)[2];\n+  tree arg2_type = TREE_TYPE (arg2);\n+\n+  /* All 3 arguments must be vectors of (signed or unsigned) (int or\n+     __int128) and the types must be compatible.  */\n+  if (TREE_CODE (arg0_type) != VECTOR_TYPE\n+      || !lang_hooks.types_compatible_p (arg0_type, arg1_type)\n+      || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-\t    arg0 = save_expr (arg0);\n-\t    arg1 = save_expr (arg1);\n-\t    vec<tree, va_gc> *params = make_tree_vector ();\n-\t    vec_safe_push (params, arg0);\n-\t    vec_safe_push (params, arg1);\n+  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+    {\n+      /* For {un}signed ints,\n+\t   vec_addec (va, vb, carryv) ==\n+\t     vec_or (vec_addc (va, vb),\n+\t\t     vec_addc (vec_add (va, vb),\n+\t\t\t       vec_and (carryv, 0x1))).  */\n+    case E_SImode:\n+      {\n+\t/* Use save_expr to ensure that operands used more than once that may\n+\t   have side effects (like calls) are only evaluated once.  */\n+\targ0 = save_expr (arg0);\n+\targ1 = save_expr (arg1);\n+\tvec<tree, va_gc> *params = make_tree_vector ();\n+\tvec_safe_push (params, arg0);\n+\tvec_safe_push (params, arg1);\n+\n+\ttree as_c_builtin;\n+\tif (fcode == RS6000_OVLD_VEC_ADDEC)\n+\t  as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADDC];\n+\telse\n+\t  as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUBC];\n \n-\t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n-\t      as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADDC];\n-\t    else\n-\t      as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUBC];\n+\ttree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n+\t\t\t\t\t\t\t params);\n+\tparams = make_tree_vector ();\n+\tvec_safe_push (params, arg0);\n+\tvec_safe_push (params, arg1);\n \n-\t    tree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n-\t\t\t\t\t\t\t     params);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, arg0);\n-\t    vec_safe_push (params, arg1);\n+\ttree as_builtin;\n+\tif (fcode == RS6000_OVLD_VEC_ADDEC)\n+\t  as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n+\telse\n+\t  as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n \n-\t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n-\t      as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n-\t    else\n-\t      as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n-\n-\t    tree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n-\t\t\t\t\t\t\t     params);\n-\t    tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\t    tree ones_vector = build_vector_from_val (arg0_type, const1);\n-\t    tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t     arg2, ones_vector);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, call2);\n-\t    vec_safe_push (params, and_expr);\n-\t    call2 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n-\t\t\t\t\t\t\tparams);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, call1);\n-\t    vec_safe_push (params, call2);\n-\t    tree or_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_OR];\n-\t    return altivec_resolve_overloaded_builtin (loc, or_builtin,\n-\t\t\t\t\t\t       params);\n-\t    }\n-\t  /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n-\t     instructions.  This occurs through normal processing.  */\n-\t  case E_TImode:\n-\t    break;\n-\n-\t  /* Types other than {un}signed int and {un}signed __int128\n-\t\tare errors.  */\n-\t  default:\n-\t    goto bad;\n-\t}\n+\ttree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n+\t\t\t\t\t\t\t params);\n+\ttree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n+\ttree ones_vector = build_vector_from_val (arg0_type, const1);\n+\ttree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n+\t\t\t\t\t arg2, ones_vector);\n+\tparams = make_tree_vector ();\n+\tvec_safe_push (params, call2);\n+\tvec_safe_push (params, and_expr);\n+\tcall2 = altivec_resolve_overloaded_builtin (loc, as_c_builtin, params);\n+\tparams = make_tree_vector ();\n+\tvec_safe_push (params, call1);\n+\tvec_safe_push (params, call2);\n+\ttree or_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_OR];\n+\t*res = resolved;\n+\treturn altivec_resolve_overloaded_builtin (loc, or_builtin, params);\n+      }\n+      /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n+\t instructions.  This occurs through normal processing.  */\n+    case E_TImode:\n+      *res = unresolved;\n+      break;\n+\n+      /* Types other than {un}signed int and {un}signed __int128\n+\t are errors.  */\n+    default:\n+      *res = resolved_bad;\n     }\n \n-  /* For now treat vec_splats and vec_promote as the same.  */\n-  if (fcode == RS6000_OVLD_VEC_SPLATS || fcode == RS6000_OVLD_VEC_PROMOTE)\n-    {\n-      tree type, arg;\n-      int size;\n-      int i;\n-      bool unsigned_p;\n-      vec<constructor_elt, va_gc> *vec;\n-      const char *name;\n-      name = fcode == RS6000_OVLD_VEC_SPLATS ? \"vec_splats\" : \"vec_promote\";\n+  return error_mark_node;\n+}\n \n-      if (fcode == RS6000_OVLD_VEC_SPLATS && nargs != 1)\n-\t{\n-\t  error (\"builtin %qs only accepts 1 argument\", name);\n-\t  return error_mark_node;\n-\t}\n-      if (fcode == RS6000_OVLD_VEC_PROMOTE && nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n-      /* Ignore promote's element argument.  */\n-      if (fcode == RS6000_OVLD_VEC_PROMOTE\n-\t  && !INTEGRAL_TYPE_P (TREE_TYPE ((*arglist)[1])))\n-\tgoto bad;\n-\n-      arg = (*arglist)[0];\n-      type = TREE_TYPE (arg);\n-      if (!SCALAR_FLOAT_TYPE_P (type)\n-\t  && !INTEGRAL_TYPE_P (type))\n-\tgoto bad;\n-      unsigned_p = TYPE_UNSIGNED (type);\n-      switch (TYPE_MODE (type))\n-\t{\n-\t  case E_TImode:\n-\t    type = unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node;\n-\t    size = 1;\n-\t    break;\n-\t  case E_DImode:\n-\t    type = unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node;\n-\t    size = 2;\n-\t    break;\n-\t  case E_SImode:\n-\t    type = unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node;\n-\t    size = 4;\n-\t    break;\n-\t  case E_HImode:\n-\t    type = unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node;\n-\t    size = 8;\n-\t    break;\n-\t  case E_QImode:\n-\t    type = unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node;\n-\t    size = 16;\n-\t    break;\n-\t  case E_SFmode:\n-\t    type = V4SF_type_node;\n-\t    size = 4;\n-\t    break;\n-\t  case E_DFmode:\n-\t    type = V2DF_type_node;\n-\t    size = 2;\n-\t    break;\n-\t  default:\n-\t    goto bad;\n-\t}\n-      arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n-      vec_alloc (vec, size);\n-      for (i = 0; i < size; i++)\n-\t{\n-\t  constructor_elt elt = {NULL_TREE, arg};\n-\t  vec->quick_push (elt);\n-\t}\n-      return build_constructor (type, vec);\n+/* Resolve an overloaded vec_splats or vec_promote call and return a tree\n+   expression for the resolved call if successful.  NARGS is the number of\n+   arguments to the call.  ARGLIST contains the arguments.  RES must be set\n+   to indicate the status of the resolution attempt.  */\n+\n+static tree\n+resolve_vec_splats (resolution *res, rs6000_gen_builtins fcode,\n+\t\t    vec<tree, va_gc> *arglist, unsigned nargs)\n+{\n+  const char *name;\n+  name = fcode == RS6000_OVLD_VEC_SPLATS ? \"vec_splats\" : \"vec_promote\";\n+\n+  if (fcode == RS6000_OVLD_VEC_SPLATS && nargs != 1)\n+    {\n+      error (\"builtin %qs only accepts 1 argument\", name);\n+      *res = resolved;\n+      return error_mark_node;\n     }\n \n-  /* For now use pointer tricks to do the extraction, unless we are on VSX\n-     extracting a double from a constant offset.  */\n-  if (fcode == RS6000_OVLD_VEC_EXTRACT)\n+  if (fcode == RS6000_OVLD_VEC_PROMOTE && nargs != 2)\n     {\n-      tree arg1;\n-      tree arg1_type;\n-      tree arg2;\n-      tree arg1_inner_type;\n-      tree decl, stmt;\n-      tree innerptrtype;\n-      machine_mode mode;\n-\n-      /* No second argument. */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_extract\");\n-\t  return error_mark_node;\n-\t}\n+      error (\"builtin %qs only accepts 2 arguments\", name);\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-      arg2 = (*arglist)[1];\n-      arg1 = (*arglist)[0];\n-      arg1_type = TREE_TYPE (arg1);\n+  /* Ignore promote's element argument.  */\n+  if (fcode == RS6000_OVLD_VEC_PROMOTE\n+      && !INTEGRAL_TYPE_P (TREE_TYPE ((*arglist)[1])))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n-\tgoto bad;\n+  tree arg = (*arglist)[0];\n+  tree type = TREE_TYPE (arg);\n \n-      /* See if we can optimize vec_extracts with the current VSX instruction\n-\t set.  */\n-      mode = TYPE_MODE (arg1_type);\n-      if (VECTOR_MEM_VSX_P (mode))\n+  if (!SCALAR_FLOAT_TYPE_P (type) && !INTEGRAL_TYPE_P (type))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-\t{\n-\t  tree call = NULL_TREE;\n-\t  int nunits = GET_MODE_NUNITS (mode);\n+  bool unsigned_p = TYPE_UNSIGNED (type);\n+  int size;\n \n-\t  arg2 = fold_for_warn (arg2);\n+  switch (TYPE_MODE (type))\n+    {\n+    case E_TImode:\n+      type = unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node;\n+      size = 1;\n+      break;\n+    case E_DImode:\n+      type = unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node;\n+      size = 2;\n+      break;\n+    case E_SImode:\n+      type = unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node;\n+      size = 4;\n+      break;\n+    case E_HImode:\n+      type = unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node;\n+      size = 8;\n+      break;\n+    case E_QImode:\n+      type = unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node;\n+      size = 16;\n+      break;\n+    case E_SFmode:\n+      type = V4SF_type_node;\n+      size = 4;\n+      break;\n+    case E_DFmode:\n+      type = V2DF_type_node;\n+      size = 2;\n+      break;\n+    default:\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-\t  /* If the second argument is an integer constant, generate\n-\t     the built-in code if we can.  We need 64-bit and direct\n-\t     move to extract the small integer vectors.  */\n-\t  if (TREE_CODE (arg2) == INTEGER_CST)\n-\t    {\n-\t      wide_int selector = wi::to_wide (arg2);\n-\t      selector = wi::umod_trunc (selector, nunits);\n-\t      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t      switch (mode)\n-\t\t{\n-\t\tdefault:\n-\t\t  break;\n+  arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n+  vec<constructor_elt, va_gc> *vec;\n+  vec_alloc (vec, size);\n \n-\t\tcase E_V1TImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V1TI];\n-\t\t  break;\n+  for (int i = 0; i < size; i++)\n+    {\n+      constructor_elt elt = {NULL_TREE, arg};\n+      vec->quick_push (elt);\n+    }\n \n-\t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n-\t\t  break;\n+  *res = resolved;\n+  return build_constructor (type, vec);\n+}\n \n-\t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n-\t\t  break;\n+/* Resolve an overloaded vec_extract call and return a tree expression for\n+   the resolved call if successful.  NARGS is the number of arguments to\n+   the call.  ARGLIST contains the arguments.  RES must be set to indicate\n+   the status of the resolution attempt.  LOC contains statement location\n+   information.  */\n \n-\t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n-\t\t  break;\n+static tree\n+resolve_vec_extract (resolution *res, vec<tree, va_gc> *arglist,\n+\t\t     unsigned nargs, location_t loc)\n+{\n+  if (nargs != 2)\n+    {\n+      error (\"builtin %qs only accepts 2 arguments\", \"vec_extract\");\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-\t\tcase E_V4SImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n-\t\t  break;\n+  tree arg1 = (*arglist)[0];\n+  tree arg1_type = TREE_TYPE (arg1);\n+  tree arg2 = (*arglist)[1];\n \n-\t\tcase E_V8HImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n-\t\t  break;\n+  if (TREE_CODE (arg1_type) != VECTOR_TYPE\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-\t\tcase E_V16QImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n-\t\t  break;\n-\t\t}\n-\t    }\n+  /* See if we can optimize vec_extract with the current VSX instruction\n+     set.  */\n+  machine_mode mode = TYPE_MODE (arg1_type);\n+  tree arg1_inner_type;\n \n-\t  /* If the second argument is variable, we can optimize it if we are\n-\t     generating 64-bit code on a machine with direct move.  */\n-\t  else if (TREE_CODE (arg2) != INTEGER_CST && TARGET_DIRECT_MOVE_64BIT)\n+  if (VECTOR_MEM_VSX_P (mode))\n+    {\n+      tree call = NULL_TREE;\n+      int nunits = GET_MODE_NUNITS (mode);\n+      arg2 = fold_for_warn (arg2);\n+\n+      /* If the second argument is an integer constant, generate\n+\t the built-in code if we can.  We need 64-bit and direct\n+\t move to extract the small integer vectors.  */\n+      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t{\n+\t  wide_int selector = wi::to_wide (arg2);\n+\t  selector = wi::umod_trunc (selector, nunits);\n+\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\t  switch (mode)\n \t    {\n-\t      switch (mode)\n-\t\t{\n-\t\tdefault:\n-\t\t  break;\n+\t    case E_V1TImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V1TI];\n+\t      break;\n \n-\t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n-\t\t  break;\n+\t    case E_V2DFmode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n+\t      break;\n \n-\t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n-\t\t  break;\n+\t    case E_V2DImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n+\t      break;\n \n-\t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n-\t\t  break;\n+\t    case E_V4SFmode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n+\t      break;\n \n-\t\tcase E_V4SImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n-\t\t  break;\n+\t    case E_V4SImode:\n+\t      if (TARGET_DIRECT_MOVE_64BIT)\n+\t\tcall = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n+\t      break;\n \n-\t\tcase E_V8HImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n-\t\t  break;\n+\t    case E_V8HImode:\n+\t      if (TARGET_DIRECT_MOVE_64BIT)\n+\t\tcall = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n+\t      break;\n \n-\t\tcase E_V16QImode:\n-\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n-\t\t  break;\n-\t\t}\n+\t    case E_V16QImode:\n+\t      if (TARGET_DIRECT_MOVE_64BIT)\n+\t\tcall = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n+\t      break;\n+\n+\t    default:\n+\t      break;\n \t    }\n+\t}\n \n-\t  if (call)\n+      /* If the second argument is variable, we can optimize it if we are\n+\t generating 64-bit code on a machine with direct move.  */\n+      else if (TREE_CODE (arg2) != INTEGER_CST && TARGET_DIRECT_MOVE_64BIT)\n+\t{\n+\t  switch (mode)\n \t    {\n-\t      tree result = build_call_expr (call, 2, arg1, arg2);\n-\t      /* Coerce the result to vector element type.  May be no-op.  */\n-\t      arg1_inner_type = TREE_TYPE (arg1_type);\n-\t      result = fold_convert (arg1_inner_type, result);\n-\t      return result;\n+\t    case E_V2DFmode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n+\t      break;\n+\n+\t    case E_V2DImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n+\t      break;\n+\n+\t    case E_V4SFmode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n+\t      break;\n+\n+\t    case E_V4SImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n+\t      break;\n+\n+\t    case E_V8HImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n+\t      break;\n+\n+\t    case E_V16QImode:\n+\t      call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n+\t      break;\n+\n+\t    default:\n+\t      break;\n \t    }\n \t}\n \n-      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n-      arg1_inner_type = TREE_TYPE (arg1_type);\n-      tree subp = build_int_cst (TREE_TYPE (arg2),\n-\t\t\t\t TYPE_VECTOR_SUBPARTS (arg1_type) - 1);\n-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2, subp, 0);\n-      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n-      DECL_EXTERNAL (decl) = 0;\n-      TREE_PUBLIC (decl) = 0;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-      TREE_USED (decl) = 1;\n-      TREE_TYPE (decl) = arg1_type;\n-      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n-      if (c_dialect_cxx ())\n+      if (call)\n \t{\n-\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n-\t\t\t NULL_TREE, NULL_TREE);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n+\t  tree result = build_call_expr (call, 2, arg1, arg2);\n+\t  /* Coerce the result to vector element type.  May be no-op.  */\n+\t  arg1_inner_type = TREE_TYPE (arg1_type);\n+\t  result = fold_convert (arg1_inner_type, result);\n+\t  *res = resolved;\n+\t  return result;\n \t}\n-      else\n+    }\n+\n+  /* Build *(((arg1_inner_type*) & (vector type){arg1}) + arg2). */\n+  arg1_inner_type = TREE_TYPE (arg1_type);\n+  tree subp = build_int_cst (TREE_TYPE (arg2),\n+\t\t\t     TYPE_VECTOR_SUBPARTS (arg1_type) - 1);\n+  arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2, subp, 0);\n+\n+  tree decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n+  DECL_EXTERNAL (decl) = 0;\n+  TREE_PUBLIC (decl) = 0;\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  TREE_USED (decl) = 1;\n+  TREE_TYPE (decl) = arg1_type;\n+  TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+\n+  tree stmt;\n+  if (c_dialect_cxx ())\n+    {\n+      stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1, NULL_TREE, NULL_TREE);\n+      SET_EXPR_LOCATION (stmt, loc);\n+    }\n+  else\n+    {\n+      DECL_INITIAL (decl) = arg1;\n+      stmt = build1 (DECL_EXPR, arg1_type, decl);\n+      TREE_ADDRESSABLE (decl) = 1;\n+      SET_EXPR_LOCATION (stmt, loc);\n+      stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+    }\n+\n+  tree innerptrtype = build_pointer_type (arg1_inner_type);\n+  stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n+  stmt = convert (innerptrtype, stmt);\n+  stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n+  stmt = build_indirect_ref (loc, stmt, RO_NULL);\n+\n+  /* PR83660: We mark this as having side effects so that downstream in\n+     fold_build_cleanup_point_expr () it will get a CLEANUP_POINT_EXPR.  If it\n+     does not we can run into an ICE later in gimplify_cleanup_point_expr ().\n+     Potentially this causes missed optimization because there actually is no\n+     side effect.  */\n+  if (c_dialect_cxx ())\n+    TREE_SIDE_EFFECTS (stmt) = 1;\n+\n+  *res = resolved;\n+  return stmt;\n+}\n+\n+/* Resolve an overloaded vec_insert call and return a tree expression for\n+   the resolved call if successful.  NARGS is the number of arguments to\n+   the call.  ARGLIST contains the arguments.  RES must be set to indicate\n+   the status of the resolution attempt.  LOC contains statement location\n+   information.  */\n+\n+static tree\n+resolve_vec_insert (resolution *res, vec<tree, va_gc> *arglist,\n+\t\t    unsigned nargs, location_t loc)\n+{\n+  if (nargs != 3)\n+    {\n+      error (\"builtin %qs only accepts 3 arguments\", \"vec_insert\");\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n+\n+  tree arg0 = (*arglist)[0];\n+  tree arg1 = (*arglist)[1];\n+  tree arg1_type = TREE_TYPE (arg1);\n+  tree arg2 = fold_for_warn ((*arglist)[2]);\n+\n+  if (TREE_CODE (arg1_type) != VECTOR_TYPE\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n+\n+  /* If we can use the VSX xxpermdi instruction, use that for insert.  */\n+  machine_mode mode = TYPE_MODE (arg1_type);\n+\n+  if ((mode == V2DFmode || mode == V2DImode)\n+      && VECTOR_UNIT_VSX_P (mode)\n+      && TREE_CODE (arg2) == INTEGER_CST)\n+    {\n+      wide_int selector = wi::to_wide (arg2);\n+      selector = wi::umod_trunc (selector, 2);\n+      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\n+      tree call = NULL_TREE;\n+      if (mode == V2DFmode)\n+\tcall = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DF];\n+      else if (mode == V2DImode)\n+\tcall = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DI];\n+\n+      /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n+\t reversed.  */\n+      if (call)\n \t{\n-\t  DECL_INITIAL (decl) = arg1;\n-\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n-\t  TREE_ADDRESSABLE (decl) = 1;\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+\t  *res = resolved;\n+\t  return build_call_expr (call, 3, arg1, arg0, arg2);\n \t}\n+    }\n \n-      innerptrtype = build_pointer_type (arg1_inner_type);\n+  else if (mode == V1TImode\n+\t   && VECTOR_UNIT_VSX_P (mode)\n+\t   && TREE_CODE (arg2) == INTEGER_CST)\n+    {\n+      tree call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V1TI];\n+      wide_int selector = wi::zero(32);\n+      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\n+      /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n+\t reversed.  */\n+      *res = resolved;\n+      return build_call_expr (call, 3, arg1, arg0, arg2);\n+    }\n+\n+  /* Build *(((arg1_inner_type*) & (vector type){arg1}) + arg2) = arg0 with\n+     VIEW_CONVERT_EXPR.  i.e.:\n+       D.3192 = v1;\n+       _1 = n & 3;\n+       VIEW_CONVERT_EXPR<int[4]>(D.3192)[_1] = i;\n+       v1 = D.3192;\n+       D.3194 = v1;  */\n+  if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)\n+    arg2 = build_int_cst (TREE_TYPE (arg2), 0);\n+  else\n+    {\n+      tree c = build_int_cst (TREE_TYPE (arg2),\n+\t\t\t      TYPE_VECTOR_SUBPARTS (arg1_type) - 1);\n+      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2, c, 0);\n+    }\n+\n+  tree decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n+  DECL_EXTERNAL (decl) = 0;\n+  TREE_PUBLIC (decl) = 0;\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  TREE_USED (decl) = 1;\n+  TREE_TYPE (decl) = arg1_type;\n+  TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+  TREE_ADDRESSABLE (decl) = 1;\n+\n+  tree stmt;\n+  if (c_dialect_cxx ())\n+    {\n+      stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1, NULL_TREE, NULL_TREE);\n+      SET_EXPR_LOCATION (stmt, loc);\n+    }\n+  else\n+    {\n+      DECL_INITIAL (decl) = arg1;\n+      stmt = build1 (DECL_EXPR, arg1_type, decl);\n+      SET_EXPR_LOCATION (stmt, loc);\n+      stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+    }\n \n+  if (TARGET_VSX)\n+    {\n+      stmt = build_array_ref (loc, stmt, arg2);\n+      stmt = fold_build2 (MODIFY_EXPR, TREE_TYPE (arg0), stmt,\n+\t\t\t  convert (TREE_TYPE (stmt), arg0));\n+      stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+    }\n+  else\n+    {\n+      tree arg1_inner_type = TREE_TYPE (arg1_type);\n+      tree innerptrtype = build_pointer_type (arg1_inner_type);\n       stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n       stmt = convert (innerptrtype, stmt);\n       stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n       stmt = build_indirect_ref (loc, stmt, RO_NULL);\n+      stmt = build2 (MODIFY_EXPR, TREE_TYPE (stmt), stmt,\n+\t\t     convert (TREE_TYPE (stmt), arg0));\n+      stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+    }\n \n-      /* PR83660: We mark this as having side effects so that\n-\t downstream in fold_build_cleanup_point_expr () it will get a\n-\t CLEANUP_POINT_EXPR.  If it does not we can run into an ICE\n-\t later in gimplify_cleanup_point_expr ().  Potentially this\n-\t causes missed optimization because there actually is no side\n-\t effect.  */\n-      if (c_dialect_cxx ())\n-\tTREE_SIDE_EFFECTS (stmt) = 1;\n+  *res = resolved;\n+  return stmt;\n+}\n \n-      return stmt;\n-    }\n+/* Resolve an overloaded vec_step call and return a tree expression for\n+   the resolved call if successful.  NARGS is the number of arguments to\n+   the call.  ARGLIST contains the arguments.  RES must be set to indicate\n+   the status of the resolution attempt.  */\n \n-  /* For now use pointer tricks to do the insertion, unless we are on VSX\n-     inserting a double to a constant offset.  */\n-  if (fcode == RS6000_OVLD_VEC_INSERT)\n+static tree\n+resolve_vec_step (resolution *res, vec<tree, va_gc> *arglist, unsigned nargs)\n+{\n+  if (nargs != 1)\n     {\n-      tree arg0;\n-      tree arg1;\n-      tree arg2;\n-      tree arg1_type;\n-      tree decl, stmt;\n-      machine_mode mode;\n-\n-      /* No second or third arguments. */\n-      if (nargs != 3)\n-\t{\n-\t  error (\"builtin %qs only accepts 3 arguments\", \"vec_insert\");\n-\t  return error_mark_node;\n-\t}\n+      error (\"builtin %qs only accepts 1 argument\", \"vec_step\");\n+      *res = resolved;\n+      return error_mark_node;\n+    }\n \n-      arg0 = (*arglist)[0];\n-      arg1 = (*arglist)[1];\n-      arg1_type = TREE_TYPE (arg1);\n-      arg2 = fold_for_warn ((*arglist)[2]);\n+  tree arg0 = (*arglist)[0];\n+  tree arg0_type = TREE_TYPE (arg0);\n \n-      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n-\tgoto bad;\n+  if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+    {\n+      *res = resolved_bad;\n+      return error_mark_node;\n+    }\n \n-      /* If we can use the VSX xxpermdi instruction, use that for insert.  */\n-      mode = TYPE_MODE (arg1_type);\n-      if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n-\t  && TREE_CODE (arg2) == INTEGER_CST)\n-\t{\n-\t  wide_int selector = wi::to_wide (arg2);\n-\t  selector = wi::umod_trunc (selector, 2);\n-\t  tree call = NULL_TREE;\n+  *res = resolved;\n+  return build_int_cst (NULL_TREE, TYPE_VECTOR_SUBPARTS (arg0_type));\n+}\n \n-\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t  if (mode == V2DFmode)\n-\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DF];\n-\t  else if (mode == V2DImode)\n-\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DI];\n-\n-\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n-\t     reversed.  */\n-\t  if (call)\n-\t    return build_call_expr (call, 3, arg1, arg0, arg2);\n-\t}\n-      else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n-\t       && TREE_CODE (arg2) == INTEGER_CST)\n-\t{\n-\t  tree call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V1TI];\n-\t  wide_int selector = wi::zero(32);\n+/* Look for a matching instance in a chain of instances.  INSTANCE points to\n+   the chain of instances; INSTANCE_CODE is the code identifying the specific\n+   built-in being searched for; FCODE is the overloaded function code; TYPES\n+   contains an array of two types that must match the types of the instance's\n+   parameters; and ARGS contains an array of two arguments to be passed to\n+   the instance.  If found, resolve the built-in and return it, unless the\n+   built-in is not supported in context.  In that case, set\n+   UNSUPPORTED_BUILTIN to true.  If we don't match, return error_mark_node\n+   and leave UNSUPPORTED_BUILTIN alone.  */\n \n-\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n-\t     reversed.  */\n-\t  return build_call_expr (call, 3, arg1, arg0, arg2);\n-\t}\n+tree\n+find_instance (bool *unsupported_builtin, ovlddata **instance,\n+\t       rs6000_gen_builtins instance_code,\n+\t       rs6000_gen_builtins fcode,\n+\t       tree *types, tree *args)\n+{\n+  while (*instance && (*instance)->bifid != instance_code)\n+    *instance = (*instance)->next;\n \n-      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0 with\n-\t VIEW_CONVERT_EXPR.  i.e.:\n-\t D.3192 = v1;\n-\t _1 = n & 3;\n-\t VIEW_CONVERT_EXPR<int[4]>(D.3192)[_1] = i;\n-\t v1 = D.3192;\n-\t D.3194 = v1;  */\n-      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)\n-\targ2 = build_int_cst (TREE_TYPE (arg2), 0);\n-      else\n-\targ2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n-\t\t\t\tbuild_int_cst (TREE_TYPE (arg2),\n-\t\t\t\t\t       TYPE_VECTOR_SUBPARTS (arg1_type)\n-\t\t\t\t\t       - 1), 0);\n-      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n-      DECL_EXTERNAL (decl) = 0;\n-      TREE_PUBLIC (decl) = 0;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-      TREE_USED (decl) = 1;\n-      TREE_TYPE (decl) = arg1_type;\n-      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n-      TREE_ADDRESSABLE (decl) = 1;\n-      if (c_dialect_cxx ())\n-\t{\n-\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n-\t\t\t NULL_TREE, NULL_TREE);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t}\n-      else\n-\t{\n-\t  DECL_INITIAL (decl) = arg1;\n-\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n-\t}\n+  ovlddata *inst = *instance;\n+  gcc_assert (inst != NULL);\n+  tree fntype = rs6000_builtin_info[inst->bifid].fntype;\n+  tree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n+  tree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n \n-      if (TARGET_VSX)\n+  if (rs6000_builtin_type_compatible (types[0], parmtype0)\n+      && rs6000_builtin_type_compatible (types[1], parmtype1))\n+    {\n+      if (rs6000_builtin_decl (inst->bifid, false) != error_mark_node\n+\t  && rs6000_builtin_is_supported (inst->bifid))\n \t{\n-\t  stmt = build_array_ref (loc, stmt, arg2);\n-\t  stmt = fold_build2 (MODIFY_EXPR, TREE_TYPE (arg0), stmt,\n-\t\t\t      convert (TREE_TYPE (stmt), arg0));\n-\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+\t  tree ret_type = TREE_TYPE (inst->fntype);\n+\t  return altivec_build_resolved_builtin (args, 2, fntype, ret_type,\n+\t\t\t\t\t\t inst->bifid, fcode);\n \t}\n       else\n-\t{\n-\t  tree arg1_inner_type;\n-\t  tree innerptrtype;\n-\t  arg1_inner_type = TREE_TYPE (arg1_type);\n-\t  innerptrtype = build_pointer_type (arg1_inner_type);\n-\n-\t  stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n-\t  stmt = convert (innerptrtype, stmt);\n-\t  stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n-\t  stmt = build_indirect_ref (loc, stmt, RO_NULL);\n-\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (stmt), stmt,\n-\t\t\t convert (TREE_TYPE (stmt), arg0));\n-\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n-\t}\n-      return stmt;\n+\t*unsupported_builtin = true;\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Implementation of the resolve_overloaded_builtin target hook, to\n+   support Altivec's overloaded builtins.  */\n+\n+tree\n+altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n+\t\t\t\t    void *passed_arglist)\n+{\n+  rs6000_gen_builtins fcode\n+    = (rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+\n+  /* Return immediately if this isn't an overload.  */\n+  if (fcode <= RS6000_OVLD_NONE)\n+    return NULL_TREE;\n+\n+  if (TARGET_DEBUG_BUILTIN)\n+    fprintf (stderr, \"altivec_resolve_overloaded_builtin, code = %4d, %s\\n\",\n+\t     (int) fcode, IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+\n+  /* vec_lvsl and vec_lvsr are deprecated for use with LE element order.  */\n+  if (fcode == RS6000_OVLD_VEC_LVSL && !BYTES_BIG_ENDIAN)\n+    warning (OPT_Wdeprecated,\n+\t     \"%<vec_lvsl%> is deprecated for little endian; use \"\n+\t     \"assignment for unaligned loads and stores\");\n+  else if (fcode == RS6000_OVLD_VEC_LVSR && !BYTES_BIG_ENDIAN)\n+    warning (OPT_Wdeprecated,\n+\t     \"%<vec_lvsr%> is deprecated for little endian; use \"\n+\t     \"assignment for unaligned loads and stores\");\n+\n+  /* Some overloads require special handling.  */\n+  /* FIXME: Could we simplify the helper functions if we gathered arguments\n+     and types into arrays first?  */\n+  tree returned_expr = NULL;\n+  resolution res = unresolved;\n+  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n+  unsigned int nargs = vec_safe_length (arglist);\n+\n+  switch (fcode)\n+    {\n+    case RS6000_OVLD_VEC_MUL:\n+      returned_expr = resolve_vec_mul (&res, arglist, nargs, loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_CMPNE:\n+      returned_expr = resolve_vec_cmpne (&res, arglist, nargs, loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_ADDE:\n+    case RS6000_OVLD_VEC_SUBE:\n+      returned_expr = resolve_vec_adde_sube (&res, fcode, arglist, nargs, loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_ADDEC:\n+    case RS6000_OVLD_VEC_SUBEC:\n+      returned_expr = resolve_vec_addec_subec (&res, fcode, arglist, nargs,\n+\t\t\t\t\t       loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_SPLATS:\n+    case RS6000_OVLD_VEC_PROMOTE:\n+      returned_expr = resolve_vec_splats (&res, fcode, arglist, nargs);\n+      break;\n+\n+    case RS6000_OVLD_VEC_EXTRACT:\n+      returned_expr = resolve_vec_extract (&res, arglist, nargs, loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_INSERT:\n+      returned_expr = resolve_vec_insert (&res, arglist, nargs, loc);\n+      break;\n+\n+    case RS6000_OVLD_VEC_STEP:\n+      returned_expr = resolve_vec_step (&res, arglist, nargs);\n+      break;\n+\n+    default:\n+      ;\n     }\n \n+  if (res == resolved)\n+    return returned_expr;\n+\n+  /* \"Regular\" built-in functions and overloaded functions share a namespace\n+     for some arrays, like rs6000_builtin_decls.  But rs6000_overload_info\n+     only has information for the overloaded functions, so we need an\n+     adjusted index for that.  */\n+  unsigned int adj_fcode = fcode - RS6000_OVLD_NONE;\n+\n+  if (res == resolved_bad)\n+    {\n+      const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+      error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n+      return error_mark_node;\n+    }\n+\n+  /* Gather the arguments and their types into arrays for easier handling.  */\n+  tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  tree types[MAX_OVLD_ARGS];\n+  tree args[MAX_OVLD_ARGS];\n   unsigned int n;\n+\n   for (n = 0;\n        !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n        fnargs = TREE_CHAIN (fnargs), n++)\n     {\n       tree decl_type = TREE_VALUE (fnargs);\n       tree arg = (*arglist)[n];\n-      tree type;\n \n       if (arg == error_mark_node)\n \treturn error_mark_node;\n@@ -1640,10 +1869,10 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \tabort ();\n \n       arg = default_conversion (arg);\n+      tree type = TREE_TYPE (arg);\n \n       /* The C++ front-end converts float * to const void * using\n \t NOP_EXPR<const void *> (NOP_EXPR<void *> (x)).  */\n-      type = TREE_TYPE (arg);\n       if (POINTER_TYPE_P (type)\n \t  && TREE_CODE (arg) == NOP_EXPR\n \t  && lang_hooks.types_compatible_p (TREE_TYPE (arg),\n@@ -1672,15 +1901,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \n       /* For RS6000_OVLD_VEC_LXVL, convert any const * to its non constant\n \t equivalent to simplify the overload matching below.  */\n-      if (fcode == RS6000_OVLD_VEC_LXVL)\n+      if (fcode == RS6000_OVLD_VEC_LXVL\n+\t  && POINTER_TYPE_P (type)\n+\t  && TYPE_READONLY (TREE_TYPE (type)))\n \t{\n-\t  if (POINTER_TYPE_P (type)\n-\t      && TYPE_READONLY (TREE_TYPE (type)))\n-\t    {\n-\t      type = build_qualified_type (TREE_TYPE (type), 0);\n-\t      type = build_pointer_type (type);\n-\t      arg = fold_convert (type, arg);\n-\t    }\n+\t  type = build_qualified_type (TREE_TYPE (type), 0);\n+\t  type = build_pointer_type (type);\n+\t  arg = fold_convert (type, arg);\n \t}\n \n       args[n] = arg;\n@@ -1692,85 +1919,54 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n   if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || n < nargs)\n     return NULL;\n \n-  if (fcode == RS6000_OVLD_VEC_STEP)\n-    {\n-      if (TREE_CODE (types[0]) != VECTOR_TYPE)\n-\tgoto bad;\n+  bool unsupported_builtin = false;\n+  rs6000_gen_builtins instance_code;\n+  bool supported = false;\n+  ovlddata *instance = rs6000_overload_info[adj_fcode].first_instance;\n+  gcc_assert (instance != NULL);\n \n-      return build_int_cst (NULL_TREE, TYPE_VECTOR_SUBPARTS (types[0]));\n-    }\n+  /* Functions with no arguments can have only one overloaded instance.  */\n+  gcc_assert (nargs > 0 || !instance->next);\n \n-  {\n-    bool unsupported_builtin = false;\n-    enum rs6000_gen_builtins overloaded_code;\n-    bool supported = false;\n-    ovlddata *instance = rs6000_overload_info[adj_fcode].first_instance;\n-    gcc_assert (instance != NULL);\n-\n-    /* Need to special case __builtin_cmpb because the overloaded forms\n-       of this function take (unsigned int, unsigned int) or (unsigned\n-       long long int, unsigned long long int).  Since C conventions\n-       allow the respective argument types to be implicitly coerced into\n-       each other, the default handling does not provide adequate\n-       discrimination between the desired forms of the function.  */\n-    if (fcode == RS6000_OVLD_SCAL_CMPB)\n+  /* Standard overload processing involves determining whether an instance\n+     exists that is type-compatible with the overloaded function call.  In\n+     a couple of cases, we need to do some extra processing to disambiguate\n+     between multiple compatible instances.  */\n+  switch (fcode)\n+    {\n+      /* Need to special case __builtin_cmpb because the overloaded forms\n+\t of this function take (unsigned int, unsigned int) or (unsigned\n+\t long long int, unsigned long long int).  Since C conventions\n+\t allow the respective argument types to be implicitly coerced into\n+\t each other, the default handling does not provide adequate\n+\t discrimination between the desired forms of the function.  */\n+    case RS6000_OVLD_SCAL_CMPB:\n       {\n \tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n \tmachine_mode arg2_mode = TYPE_MODE (types[1]);\n \n-\tif (nargs != 2)\n-\t  {\n-\t    error (\"builtin %qs only accepts 2 arguments\", \"__builtin_cmpb\");\n-\t    return error_mark_node;\n-\t  }\n-\n \t/* If any supplied arguments are wider than 32 bits, resolve to\n \t   64-bit variant of built-in function.  */\n \tif (GET_MODE_PRECISION (arg1_mode) > 32\n \t    || GET_MODE_PRECISION (arg2_mode) > 32)\n \t  /* Assure all argument and result types are compatible with\n \t     the built-in function represented by RS6000_BIF_CMPB.  */\n-\t  overloaded_code = RS6000_BIF_CMPB;\n+\t  instance_code = RS6000_BIF_CMPB;\n \telse\n \t  /* Assure all argument and result types are compatible with\n \t     the built-in function represented by RS6000_BIF_CMPB_32.  */\n-\t  overloaded_code = RS6000_BIF_CMPB_32;\n+\t  instance_code = RS6000_BIF_CMPB_32;\n \n-\twhile (instance && instance->bifid != overloaded_code)\n-\t  instance = instance->next;\n-\n-\tgcc_assert (instance != NULL);\n-\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n-\ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n-\ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n-\n-\tif (rs6000_builtin_type_compatible (types[0], parmtype0)\n-\t    && rs6000_builtin_type_compatible (types[1], parmtype1))\n-\t  {\n-\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n-\t\t&& rs6000_builtin_is_supported (instance->bifid))\n-\t      {\n-\t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t       ret_type,\n-\t\t\t\t\t\t       instance->bifid,\n-\t\t\t\t\t\t       fcode);\n-\t      }\n-\t    else\n-\t      unsupported_builtin = true;\n-\t  }\n+\ttree call = find_instance (&unsupported_builtin, &instance,\n+\t\t\t\t   instance_code, fcode, types, args);\n+\tif (call != error_mark_node)\n+\t  return call;\n+\tbreak;\n       }\n-    else if (fcode == RS6000_OVLD_VEC_VSIE)\n+    case RS6000_OVLD_VEC_VSIE:\n       {\n \tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n \n-\tif (nargs != 2)\n-\t  {\n-\t    error (\"builtin %qs only accepts 2 arguments\",\n-\t\t   \"scalar_insert_exp\");\n-\t    return error_mark_node;\n-\t  }\n-\n \t/* If supplied first argument is wider than 64 bits, resolve to\n \t   128-bit variant of built-in function.  */\n \tif (GET_MODE_PRECISION (arg1_mode) > 64)\n@@ -1779,119 +1975,96 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t       that expects __ieee128 argument.  Otherwise, expect\n \t       __int128 argument.  */\n \t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n-\t      overloaded_code = RS6000_BIF_VSIEQPF;\n+\t      instance_code = RS6000_BIF_VSIEQPF;\n \t    else\n-\t      overloaded_code = RS6000_BIF_VSIEQP;\n+\t      instance_code = RS6000_BIF_VSIEQP;\n \t  }\n \telse\n \t  {\n \t    /* If first argument is of float variety, choose variant\n \t       that expects double argument.  Otherwise, expect\n \t       long long int argument.  */\n \t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n-\t      overloaded_code = RS6000_BIF_VSIEDPF;\n+\t      instance_code = RS6000_BIF_VSIEDPF;\n \t    else\n-\t      overloaded_code = RS6000_BIF_VSIEDP;\n+\t      instance_code = RS6000_BIF_VSIEDP;\n \t  }\n \n-\twhile (instance && instance->bifid != overloaded_code)\n-\t  instance = instance->next;\n+\ttree call = find_instance (&unsupported_builtin, &instance,\n+\t\t\t\t   instance_code, fcode, types, args);\n+\tif (call != error_mark_node)\n+\t  return call;\n+\tbreak;\n+      }\n+    default:\n+      /* Standard overload processing.  Look for an instance with compatible\n+\t parameter types.  If it is supported in the current context, resolve\n+\t the overloaded call to that instance.  */\n+      for (; instance != NULL; instance = instance->next)\n+\t{\n+\t  bool mismatch = false;\n+\t  tree nextparm = TYPE_ARG_TYPES (instance->fntype);\n \n-\tgcc_assert (instance != NULL);\n-\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n-\ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n-\ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n+\t  for (unsigned int arg_i = 0;\n+\t       arg_i < nargs && nextparm != NULL;\n+\t       arg_i++)\n+\t    {\n+\t      tree parmtype = TREE_VALUE (nextparm);\n+\t      if (!rs6000_builtin_type_compatible (types[arg_i], parmtype))\n+\t\t{\n+\t\t  mismatch = true;\n+\t\t  break;\n+\t\t}\n+\t      nextparm = TREE_CHAIN (nextparm);\n+\t    }\n \n-\tif (rs6000_builtin_type_compatible (types[0], parmtype0)\n-\t    && rs6000_builtin_type_compatible (types[1], parmtype1))\n-\t  {\n-\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n-\t\t&& rs6000_builtin_is_supported (instance->bifid))\n-\t      {\n-\t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t       ret_type,\n-\t\t\t\t\t\t       instance->bifid,\n-\t\t\t\t\t\t       fcode);\n-\t      }\n-\t    else\n+\t  if (mismatch)\n+\t    continue;\n+\n+\t  supported = rs6000_builtin_is_supported (instance->bifid);\n+\t  if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n+\t      && supported)\n+\t    {\n+\t      tree fntype = rs6000_builtin_info[instance->bifid].fntype;\n+\t      tree ret_type = TREE_TYPE (instance->fntype);\n+\t      return altivec_build_resolved_builtin (args, nargs, fntype,\n+\t\t\t\t\t\t     ret_type, instance->bifid,\n+\t\t\t\t\t\t     fcode);\n+\t    }\n+\t  else\n+\t    {\n \t      unsupported_builtin = true;\n-\t  }\n-      }\n-    else\n-      {\n-\t/* Functions with no arguments can have only one overloaded\n-\t   instance.  */\n-\tgcc_assert (n > 0 || !instance->next);\n+\t      break;\n+\t    }\n+\t}\n+    }\n \n-\tfor (; instance != NULL; instance = instance->next)\n-\t  {\n-\t    bool mismatch = false;\n-\t    tree nextparm = TYPE_ARG_TYPES (instance->fntype);\n-\n-\t    for (unsigned int arg_i = 0;\n-\t\t arg_i < nargs && nextparm != NULL;\n-\t\t arg_i++)\n-\t      {\n-\t\ttree parmtype = TREE_VALUE (nextparm);\n-\t\tif (!rs6000_builtin_type_compatible (types[arg_i], parmtype))\n-\t\t  {\n-\t\t    mismatch = true;\n-\t\t    break;\n-\t\t  }\n-\t\tnextparm = TREE_CHAIN (nextparm);\n-\t      }\n-\n-\t    if (mismatch)\n-\t      continue;\n-\n-\t    supported = rs6000_builtin_is_supported (instance->bifid);\n-\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n-\t\t&& supported)\n-\t      {\n-\t\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n-\t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t       ret_type,\n-\t\t\t\t\t\t       instance->bifid,\n-\t\t\t\t\t\t       fcode);\n-\t      }\n-\t    else\n-\t      {\n-\t\tunsupported_builtin = true;\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n+  if (unsupported_builtin)\n+    {\n+      const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+      if (!supported)\n+\t{\n+\t  /* Indicate that the instantiation of the overloaded builtin\n+\t     name is not available with the target flags in effect.  */\n+\t  rs6000_gen_builtins fcode = (rs6000_gen_builtins) instance->bifid;\n+\t  rs6000_invalid_builtin (fcode);\n+\t  /* Provide clarity of the relationship between the overload\n+\t     and the instantiation.  */\n+\t  const char *internal_name\n+\t    = rs6000_builtin_info[instance->bifid].bifname;\n+\t  rich_location richloc (line_table, input_location);\n+\t  inform (&richloc,\n+\t\t  \"overloaded builtin %qs is implemented by builtin %qs\",\n+\t\t  name, internal_name);\n+\t}\n+      else\n+\terror (\"%qs is not supported in this compiler configuration\", name);\n \n-    if (unsupported_builtin)\n-      {\n-\tconst char *name = rs6000_overload_info[adj_fcode].ovld_name;\n-\tif (!supported)\n-\t  {\n-\t    /* Indicate that the instantiation of the overloaded builtin\n-\t       name is not available with the target flags in effect.  */\n-\t    rs6000_gen_builtins fcode = (rs6000_gen_builtins) instance->bifid;\n-\t    rs6000_invalid_builtin (fcode);\n-\t    /* Provide clarity of the relationship between the overload\n-\t       and the instantiation.  */\n-\t    const char *internal_name\n-\t      = rs6000_builtin_info[instance->bifid].bifname;\n-\t    rich_location richloc (line_table, input_location);\n-\t    inform (&richloc,\n-\t\t    \"overloaded builtin %qs is implemented by builtin %qs\",\n-\t\t    name, internal_name);\n-\t  }\n-\telse\n-\t  error (\"%qs is not supported in this compiler configuration\", name);\n+      return error_mark_node;\n+    }\n \n-\treturn error_mark_node;\n-      }\n-  }\n- bad:\n-  {\n-    const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n-    error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n-    return error_mark_node;\n-  }\n+  /* If we fall through to here, there were no compatible instances.  */\n+  const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+  error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n+  return error_mark_node;\n }"}]}