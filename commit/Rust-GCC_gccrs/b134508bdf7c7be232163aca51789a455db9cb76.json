{"sha": "b134508bdf7c7be232163aca51789a455db9cb76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEzNDUwOGJkZjdjN2JlMjMyMTYzYWNhNTE3ODlhNDU1ZGI5Y2I3Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@cygnus.com", "date": "1998-02-22T16:44:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-22T16:44:13Z"}, "message": "getopt.c: Update to latest FSF version.\n\n        * getopt.c: Update to latest FSF version.\n        * getopt1.c: Likewise.\nBring over from devo.\n\nFrom-SVN: r18169", "tree": {"sha": "3ba0edb65250d4aebf9bcfe6d4f733335a1552e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba0edb65250d4aebf9bcfe6d4f733335a1552e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b134508bdf7c7be232163aca51789a455db9cb76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b134508bdf7c7be232163aca51789a455db9cb76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b134508bdf7c7be232163aca51789a455db9cb76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b134508bdf7c7be232163aca51789a455db9cb76/comments", "author": null, "committer": null, "parents": [{"sha": "2b63596afe456e2e9878f67f286ab501398711a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b63596afe456e2e9878f67f286ab501398711a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b63596afe456e2e9878f67f286ab501398711a4"}], "stats": {"total": 490, "additions": 389, "deletions": 101}, "files": [{"sha": "c35a1689e5391d920ba80fabca574932bb9bb449", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b134508bdf7c7be232163aca51789a455db9cb76", "patch": "@@ -1,3 +1,8 @@\n+Thu Feb 12 16:29:49 1998  Ian Lance Taylor  <ian@cygnus.com>\n+\n+\t* getopt.c: Update to latest FSF version.\n+\t* getopt1.c: Likewise.\n+\n Fri Feb  6 01:35:17 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* Makefile.in (FLAGS_TO_PASS): Don't pass PICFLAG."}, {"sha": "fc87ce67d69fb6ea8b4e4d5ab91ad5e60ac640c0", "filename": "libiberty/getopt.c", "status": "modified", "additions": 360, "deletions": 76, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2Fgetopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2Fgetopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetopt.c?ref=b134508bdf7c7be232163aca51789a455db9cb76", "patch": "@@ -3,29 +3,26 @@\n    \"Keep this file name-space clean\" means, talk to roland@gnu.ai.mit.edu\n    before changing it!\n \n-   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95\n+   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97\n    \tFree Software Foundation, Inc.\n \n-This file is part of the libiberty library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n \f\n /* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.\n    Ditto for AIX 3.2 and <stdlib.h>.  */\n@@ -34,17 +31,10 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n #ifdef HAVE_CONFIG_H\n-#if defined (emacs) || defined (CONFIG_BROKETS)\n-/* We use <config.h> instead of \"config.h\" so that a compilation\n-   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h\n-   (which it would do because it found this file in $srcdir).  */\n #include <config.h>\n-#else\n-#include \"config.h\"\n-#endif\n #endif\n \n-#ifndef __STDC__\n+#if !defined (__STDC__) || !__STDC__\n /* This is a separate conditional since some stdc systems\n    reject `defined (const)'.  */\n #ifndef const\n@@ -61,11 +51,16 @@ the executable file might be covered by the GNU General Public License. */\n    (especially if it is a shared library).  Rather than having every GNU\n    program understand `configure --with-gnu-libc' and omit the object files,\n    it is simpler to just do this in the source for each such file.  */\n-/* Many versions of the Linux C library include older, broken versions\n-   of these routines, which will break the linker's command-line\n-   parsing.  */\n \n-#if defined (_LIBC) || !defined (__GNU_LIBRARY__) || defined (__linux__)\n+#define GETOPT_INTERFACE_VERSION 2\n+#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2\n+#include <gnu-versions.h>\n+#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION\n+#define ELIDE_CODE\n+#endif\n+#endif\n+\n+#ifndef ELIDE_CODE\n \n \n /* This needs to come after some library #include\n@@ -74,8 +69,27 @@ the executable file might be covered by the GNU General Public License. */\n /* Don't include stdlib.h for non-GNU C libraries because some of them\n    contain conflicting prototypes for getopt.  */\n #include <stdlib.h>\n+#include <unistd.h>\n #endif\t/* GNU C library.  */\n \n+#ifdef VMS\n+#include <unixlib.h>\n+#if HAVE_STRING_H - 0\n+#include <string.h>\n+#endif\n+#endif\n+\n+#ifndef _\n+/* This is for other GNU distributions with internationalized messages.\n+   When compiling libc, the _ macro is predefined.  */\n+#ifdef HAVE_LIBINTL_H\n+# include <libintl.h>\n+# define _(msgid)\tgettext (msgid)\n+#else\n+# define _(msgid)\t(msgid)\n+#endif\n+#endif\n+\n /* This version of `getopt' appears to the caller like standard Unix `getopt'\n    but it behaves differently for the user, since it allows the user\n    to intersperse the options with the other arguments.\n@@ -106,14 +120,20 @@ char *optarg = NULL;\n \n    On entry to `getopt', zero means this is the first call; initialize.\n \n-   When `getopt' returns EOF, this is the index of the first of the\n+   When `getopt' returns -1, this is the index of the first of the\n    non-option elements that the caller should itself scan.\n \n    Otherwise, `optind' communicates from one call to the next\n    how much of ARGV has been scanned so far.  */\n \n-/* XXX 1003.2 says this must be 1 before any call.  */\n-int optind = 0;\n+/* 1003.2 says this must be 1 before any call.  */\n+int optind = 1;\n+\n+/* Formerly, initialization of getopt depended on optind==0, which\n+   causes problems with re-calling getopt as programs generally don't\n+   know that. */\n+\n+int __getopt_initialized = 0;\n \n /* The next char to be scanned in the option-element\n    in which the last option character we returned was found.\n@@ -162,12 +182,15 @@ int optopt = '?';\n \n    The special argument `--' forces an end of option-scanning regardless\n    of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n-   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */\n+   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */\n \n static enum\n {\n   REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n } ordering;\n+\n+/* Value of POSIXLY_CORRECT environment variable.  */\n+static char *posixly_correct;\n \f\n #ifdef\t__GNU_LIBRARY__\n /* We want to avoid inclusion of string.h with non-GNU libraries\n@@ -202,7 +225,7 @@ my_index (str, chr)\n #ifdef __GNUC__\n /* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.\n    That was relevant to code that was here before.  */\n-#ifndef __STDC__\n+#if !defined (__STDC__) || !__STDC__\n /* gcc with -traditional declares the built-in strlen to return int,\n    and has done so at least since version 2.4.5. -- rms.  */\n extern int strlen (const char *);\n@@ -220,6 +243,46 @@ extern int strlen (const char *);\n static int first_nonopt;\n static int last_nonopt;\n \n+#ifdef _LIBC\n+/* Bash 2.0 gives us an environment variable containing flags\n+   indicating ARGV elements that should not be considered arguments.  */\n+\n+/* Defined in getopt_init.c  */\n+extern char *__getopt_nonoption_flags;\n+\n+static int nonoption_flags_max_len;\n+static int nonoption_flags_len;\n+\n+static int original_argc;\n+static char *const *original_argv;\n+\n+/* Make sure the environment variable bash 2.0 puts in the environment\n+   is valid for the getopt call we must make sure that the ARGV passed\n+   to getopt is that one passed to the process.  */\n+static void\n+__attribute__ ((unused))\n+store_args_and_env (int argc, char *const *argv)\n+{\n+  /* XXX This is no good solution.  We should rather copy the args so\n+     that we can compare them later.  But we must not use malloc(3).  */\n+  original_argc = argc;\n+  original_argv = argv;\n+}\n+# ifdef text_set_element\n+text_set_element (__libc_subinit, store_args_and_env);\n+# endif /* text_set_element */\n+\n+# define SWAP_FLAGS(ch1, ch2) \\\n+  if (nonoption_flags_len > 0)\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      char __tmp = __getopt_nonoption_flags[ch1];\t\t\t      \\\n+      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];\t      \\\n+      __getopt_nonoption_flags[ch2] = __tmp;\t\t\t\t      \\\n+    }\n+#else\t/* !_LIBC */\n+# define SWAP_FLAGS(ch1, ch2)\n+#endif\t/* _LIBC */\n+\n /* Exchange two adjacent subsequences of ARGV.\n    One subsequence is elements [first_nonopt,last_nonopt)\n    which contains all the non-options that have been skipped so far.\n@@ -229,6 +292,10 @@ static int last_nonopt;\n    `first_nonopt' and `last_nonopt' are relocated so that they describe\n    the new indices of the non-options in ARGV after they are moved.  */\n \n+#if defined (__STDC__) && __STDC__\n+static void exchange (char **);\n+#endif\n+\n static void\n exchange (argv)\n      char **argv;\n@@ -243,6 +310,28 @@ exchange (argv)\n      It leaves the longer segment in the right place overall,\n      but it consists of two parts that need to be swapped next.  */\n \n+#ifdef _LIBC\n+  /* First make sure the handling of the `__getopt_nonoption_flags'\n+     string can work normally.  Our top argument must be in the range\n+     of the string.  */\n+  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)\n+    {\n+      /* We must extend the array.  The user plays games with us and\n+\t presents new arguments.  */\n+      char *new_str = malloc (top + 1);\n+      if (new_str == NULL)\n+\tnonoption_flags_len = nonoption_flags_max_len = 0;\n+      else\n+\t{\n+\t  memset (__mempcpy (new_str, __getopt_nonoption_flags,\n+\t\t\t     nonoption_flags_max_len),\n+\t\t  '\\0', top + 1 - nonoption_flags_max_len);\n+\t  nonoption_flags_max_len = top + 1;\n+\t  __getopt_nonoption_flags = new_str;\n+\t}\n+    }\n+#endif\n+\n   while (top > middle && middle > bottom)\n     {\n       if (top - middle > middle - bottom)\n@@ -257,6 +346,7 @@ exchange (argv)\n \t      tem = argv[bottom + i];\n \t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n \t      argv[top - (middle - bottom) + i] = tem;\n+\t      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n \t    }\n \t  /* Exclude the moved bottom segment from further swapping.  */\n \t  top -= len;\n@@ -273,6 +363,7 @@ exchange (argv)\n \t      tem = argv[bottom + i];\n \t      argv[bottom + i] = argv[middle + i];\n \t      argv[middle + i] = tem;\n+\t      SWAP_FLAGS (bottom + i, middle + i);\n \t    }\n \t  /* Exclude the moved top segment from further swapping.  */\n \t  bottom += len;\n@@ -287,18 +378,25 @@ exchange (argv)\n \n /* Initialize the internal data when the first call is made.  */\n \n+#if defined (__STDC__) && __STDC__\n+static const char *_getopt_initialize (int, char *const *, const char *);\n+#endif\n static const char *\n-_getopt_initialize (optstring)\n+_getopt_initialize (argc, argv, optstring)\n+     int argc;\n+     char *const *argv;\n      const char *optstring;\n {\n   /* Start processing options with ARGV-element 1 (since ARGV-element 0\n      is the program name); the sequence of previously skipped\n      non-option ARGV-elements is empty.  */\n \n-  first_nonopt = last_nonopt = optind = 1;\n+  first_nonopt = last_nonopt = optind;\n \n   nextchar = NULL;\n \n+  posixly_correct = getenv (\"POSIXLY_CORRECT\");\n+\n   /* Determine how to handle the ordering of options and nonoptions.  */\n \n   if (optstring[0] == '-')\n@@ -311,11 +409,41 @@ _getopt_initialize (optstring)\n       ordering = REQUIRE_ORDER;\n       ++optstring;\n     }\n-  else if (getenv (\"POSIXLY_CORRECT\") != NULL)\n+  else if (posixly_correct != NULL)\n     ordering = REQUIRE_ORDER;\n   else\n     ordering = PERMUTE;\n \n+#ifdef _LIBC\n+  if (posixly_correct == NULL\n+      && argc == original_argc && argv == original_argv)\n+    {\n+      if (nonoption_flags_max_len == 0)\n+\t{\n+\t  if (__getopt_nonoption_flags == NULL\n+\t      || __getopt_nonoption_flags[0] == '\\0')\n+\t    nonoption_flags_max_len = -1;\n+\t  else\n+\t    {\n+\t      const char *orig_str = __getopt_nonoption_flags;\n+\t      int len = nonoption_flags_max_len = strlen (orig_str);\n+\t      if (nonoption_flags_max_len < argc)\n+\t\tnonoption_flags_max_len = argc;\n+\t      __getopt_nonoption_flags =\n+\t\t(char *) malloc (nonoption_flags_max_len);\n+\t      if (__getopt_nonoption_flags == NULL)\n+\t\tnonoption_flags_max_len = -1;\n+\t      else\n+\t\tmemset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n+\t\t\t'\\0', nonoption_flags_max_len - len);\n+\t    }\n+\t}\n+      nonoption_flags_len = nonoption_flags_max_len;\n+    }\n+  else\n+    nonoption_flags_len = 0;\n+#endif\n+\n   return optstring;\n }\n \f\n@@ -332,7 +460,7 @@ _getopt_initialize (optstring)\n    updating `optind' and `nextchar' so that the next call to `getopt' can\n    resume the scan with the following option character or ARGV-element.\n \n-   If there are no more option characters, `getopt' returns `EOF'.\n+   If there are no more option characters, `getopt' returns -1.\n    Then `optind' is the index in ARGV of the first ARGV-element\n    that is not an option.  (The ARGV-elements have been permuted\n    so that those that are not options now come last.)\n@@ -386,16 +514,37 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n {\n   optarg = NULL;\n \n-  if (optind == 0)\n-    optstring = _getopt_initialize (optstring);\n+  if (optind == 0 || !__getopt_initialized)\n+    {\n+      if (optind == 0)\n+\toptind = 1;\t/* Don't scan ARGV[0], the program name.  */\n+      optstring = _getopt_initialize (argc, argv, optstring);\n+      __getopt_initialized = 1;\n+    }\n \n-  if (argc == 0)\n-    return EOF;\n+  /* Test whether ARGV[optind] points to a non-option argument.\n+     Either it does not have option syntax, or there is an environment flag\n+     from the shell indicating it is not an option.  The later information\n+     is only used when the used in the GNU libc.  */\n+#ifdef _LIBC\n+#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\\0'\t      \\\n+\t\t     || (optind < nonoption_flags_len\t\t\t      \\\n+\t\t\t && __getopt_nonoption_flags[optind] == '1'))\n+#else\n+#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\\0')\n+#endif\n \n   if (nextchar == NULL || *nextchar == '\\0')\n     {\n       /* Advance to the next ARGV-element.  */\n \n+      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n+\t moved back by the user (who may also have changed the arguments).  */\n+      if (last_nonopt > optind)\n+\tlast_nonopt = optind;\n+      if (first_nonopt > optind)\n+\tfirst_nonopt = optind;\n+\n       if (ordering == PERMUTE)\n \t{\n \t  /* If we have just processed some options following some non-options,\n@@ -409,8 +558,7 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t  /* Skip any additional non-options\n \t     and extend the range of non-options previously skipped.  */\n \n-\t  while (optind < argc\n-\t\t && (argv[optind][0] != '-' || argv[optind][1] == '\\0'))\n+\t  while (optind < argc && NONOPTION_P)\n \t    optind++;\n \t  last_nonopt = optind;\n \t}\n@@ -442,16 +590,16 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t     that we previously skipped, so the caller will digest them.  */\n \t  if (first_nonopt != last_nonopt)\n \t    optind = first_nonopt;\n-\t  return EOF;\n+\t  return -1;\n \t}\n \n       /* If we have come to a non-option and did not permute it,\n \t either stop the scan or describe it to the caller and pass it by.  */\n \n-      if ((argv[optind][0] != '-' || argv[optind][1] == '\\0'))\n+      if (NONOPTION_P)\n \t{\n \t  if (ordering == REQUIRE_ORDER)\n-\t    return EOF;\n+\t    return -1;\n \t  optarg = argv[optind++];\n \t  return 1;\n \t}\n@@ -487,7 +635,7 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n       const struct option *pfound = NULL;\n       int exact = 0;\n       int ambig = 0;\n-      int indfound;\n+      int indfound = -1;\n       int option_index;\n \n       for (nameend = nextchar; *nameend && *nameend != '='; nameend++)\n@@ -498,7 +646,8 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n       for (p = longopts, option_index = 0; p->name; p++, option_index++)\n \tif (!strncmp (p->name, nextchar, nameend - nextchar))\n \t  {\n-\t    if (nameend - nextchar == strlen (p->name))\n+\t    if ((unsigned int) (nameend - nextchar)\n+\t\t== (unsigned int) strlen (p->name))\n \t      {\n \t\t/* Exact match found.  */\n \t\tpfound = p;\n@@ -520,10 +669,11 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n       if (ambig && !exact)\n \t{\n \t  if (opterr)\n-\t    fprintf (stderr, \"%s: option `%s' is ambiguous\\n\",\n+\t    fprintf (stderr, _(\"%s: option `%s' is ambiguous\\n\"),\n \t\t     argv[0], argv[optind]);\n \t  nextchar += strlen (nextchar);\n \t  optind++;\n+\t  optopt = 0;\n \t  return '?';\n \t}\n \n@@ -540,19 +690,20 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t      else\n \t\t{\n \t\t  if (opterr)\n-\t\t    {\n-\t\t      if (argv[optind - 1][1] == '-')\n-\t\t\t/* --option */\n-\t\t\tfprintf (stderr,\n-\t\t\t\t \"%s: option `--%s' doesn't allow an argument\\n\",\n-\t\t\t\t argv[0], pfound->name);\n-\t\t      else\n-\t\t\t/* +option or -option */\n-\t\t\tfprintf (stderr,\n-\t\t\t     \"%s: option `%c%s' doesn't allow an argument\\n\",\n-\t\t\t     argv[0], argv[optind - 1][0], pfound->name);\n-\t\t    }\n+\t\t   if (argv[optind - 1][1] == '-')\n+\t\t    /* --option */\n+\t\t    fprintf (stderr,\n+\t\t     _(\"%s: option `--%s' doesn't allow an argument\\n\"),\n+\t\t     argv[0], pfound->name);\n+\t\t   else\n+\t\t    /* +option or -option */\n+\t\t    fprintf (stderr,\n+\t\t     _(\"%s: option `%c%s' doesn't allow an argument\\n\"),\n+\t\t     argv[0], argv[optind - 1][0], pfound->name);\n+\n \t\t  nextchar += strlen (nextchar);\n+\n+\t\t  optopt = pfound->val;\n \t\t  return '?';\n \t\t}\n \t    }\n@@ -563,9 +714,11 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t      else\n \t\t{\n \t\t  if (opterr)\n-\t\t    fprintf (stderr, \"%s: option `%s' requires an argument\\n\",\n-\t\t\t     argv[0], argv[optind - 1]);\n+\t\t    fprintf (stderr,\n+\t\t\t   _(\"%s: option `%s' requires an argument\\n\"),\n+\t\t\t   argv[0], argv[optind - 1]);\n \t\t  nextchar += strlen (nextchar);\n+\t\t  optopt = pfound->val;\n \t\t  return optstring[0] == ':' ? ':' : '?';\n \t\t}\n \t    }\n@@ -591,15 +744,16 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t    {\n \t      if (argv[optind][1] == '-')\n \t\t/* --option */\n-\t\tfprintf (stderr, \"%s: unrecognized option `--%s'\\n\",\n+\t\tfprintf (stderr, _(\"%s: unrecognized option `--%s'\\n\"),\n \t\t\t argv[0], nextchar);\n \t      else\n \t\t/* +option or -option */\n-\t\tfprintf (stderr, \"%s: unrecognized option `%c%s'\\n\",\n+\t\tfprintf (stderr, _(\"%s: unrecognized option `%c%s'\\n\"),\n \t\t\t argv[0], argv[optind][0], nextchar);\n \t    }\n \t  nextchar = (char *) \"\";\n \t  optind++;\n+\t  optopt = 0;\n \t  return '?';\n \t}\n     }\n@@ -618,12 +772,141 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n       {\n \tif (opterr)\n \t  {\n-\t    /* 1003.2 specifies the format of this message.  */\n-\t    fprintf (stderr, \"%s: illegal option -- %c\\n\", argv[0], c);\n+\t    if (posixly_correct)\n+\t      /* 1003.2 specifies the format of this message.  */\n+\t      fprintf (stderr, _(\"%s: illegal option -- %c\\n\"),\n+\t\t       argv[0], c);\n+\t    else\n+\t      fprintf (stderr, _(\"%s: invalid option -- %c\\n\"),\n+\t\t       argv[0], c);\n \t  }\n \toptopt = c;\n \treturn '?';\n       }\n+    /* Convenience. Treat POSIX -W foo same as long option --foo */\n+    if (temp[0] == 'W' && temp[1] == ';')\n+      {\n+\tchar *nameend;\n+\tconst struct option *p;\n+\tconst struct option *pfound = NULL;\n+\tint exact = 0;\n+\tint ambig = 0;\n+\tint indfound = 0;\n+\tint option_index;\n+\n+\t/* This is an option that requires an argument.  */\n+\tif (*nextchar != '\\0')\n+\t  {\n+\t    optarg = nextchar;\n+\t    /* If we end this ARGV-element by taking the rest as an arg,\n+\t       we must advance to the next element now.  */\n+\t    optind++;\n+\t  }\n+\telse if (optind == argc)\n+\t  {\n+\t    if (opterr)\n+\t      {\n+\t\t/* 1003.2 specifies the format of this message.  */\n+\t\tfprintf (stderr, _(\"%s: option requires an argument -- %c\\n\"),\n+\t\t\t argv[0], c);\n+\t      }\n+\t    optopt = c;\n+\t    if (optstring[0] == ':')\n+\t      c = ':';\n+\t    else\n+\t      c = '?';\n+\t    return c;\n+\t  }\n+\telse\n+\t  /* We already incremented `optind' once;\n+\t     increment it again when taking next ARGV-elt as argument.  */\n+\t  optarg = argv[optind++];\n+\n+\t/* optarg is now the argument, see if it's in the\n+\t   table of longopts.  */\n+\n+\tfor (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)\n+\t  /* Do nothing.  */ ;\n+\n+\t/* Test all long options for either exact match\n+\t   or abbreviated matches.  */\n+\tfor (p = longopts, option_index = 0; p->name; p++, option_index++)\n+\t  if (!strncmp (p->name, nextchar, nameend - nextchar))\n+\t    {\n+\t      if ((unsigned int) (nameend - nextchar) == strlen (p->name))\n+\t\t{\n+\t\t  /* Exact match found.  */\n+\t\t  pfound = p;\n+\t\t  indfound = option_index;\n+\t\t  exact = 1;\n+\t\t  break;\n+\t\t}\n+\t      else if (pfound == NULL)\n+\t\t{\n+\t\t  /* First nonexact match found.  */\n+\t\t  pfound = p;\n+\t\t  indfound = option_index;\n+\t\t}\n+\t      else\n+\t\t/* Second or later nonexact match found.  */\n+\t\tambig = 1;\n+\t    }\n+\tif (ambig && !exact)\n+\t  {\n+\t    if (opterr)\n+\t      fprintf (stderr, _(\"%s: option `-W %s' is ambiguous\\n\"),\n+\t\t       argv[0], argv[optind]);\n+\t    nextchar += strlen (nextchar);\n+\t    optind++;\n+\t    return '?';\n+\t  }\n+\tif (pfound != NULL)\n+\t  {\n+\t    option_index = indfound;\n+\t    if (*nameend)\n+\t      {\n+\t\t/* Don't test has_arg with >, because some C compilers don't\n+\t\t   allow it to be used on enums.  */\n+\t\tif (pfound->has_arg)\n+\t\t  optarg = nameend + 1;\n+\t\telse\n+\t\t  {\n+\t\t    if (opterr)\n+\t\t      fprintf (stderr, _(\"\\\n+%s: option `-W %s' doesn't allow an argument\\n\"),\n+\t\t\t       argv[0], pfound->name);\n+\n+\t\t    nextchar += strlen (nextchar);\n+\t\t    return '?';\n+\t\t  }\n+\t      }\n+\t    else if (pfound->has_arg == 1)\n+\t      {\n+\t\tif (optind < argc)\n+\t\t  optarg = argv[optind++];\n+\t\telse\n+\t\t  {\n+\t\t    if (opterr)\n+\t\t      fprintf (stderr,\n+\t\t\t       _(\"%s: option `%s' requires an argument\\n\"),\n+\t\t\t       argv[0], argv[optind - 1]);\n+\t\t    nextchar += strlen (nextchar);\n+\t\t    return optstring[0] == ':' ? ':' : '?';\n+\t\t  }\n+\t      }\n+\t    nextchar += strlen (nextchar);\n+\t    if (longind != NULL)\n+\t      *longind = option_index;\n+\t    if (pfound->flag)\n+\t      {\n+\t\t*(pfound->flag) = pfound->val;\n+\t\treturn 0;\n+\t      }\n+\t    return pfound->val;\n+\t  }\n+\t  nextchar = NULL;\n+\t  return 'W';\t/* Let the application handle it.   */\n+      }\n     if (temp[1] == ':')\n       {\n \tif (temp[2] == ':')\n@@ -653,8 +936,9 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n \t\tif (opterr)\n \t\t  {\n \t\t    /* 1003.2 specifies the format of this message.  */\n-\t\t    fprintf (stderr, \"%s: option requires an argument -- %c\\n\",\n-\t\t\t     argv[0], c);\n+\t\t    fprintf (stderr,\n+\t\t\t   _(\"%s: option requires an argument -- %c\\n\"),\n+\t\t\t   argv[0], c);\n \t\t  }\n \t\toptopt = c;\n \t\tif (optstring[0] == ':')\n@@ -685,7 +969,7 @@ getopt (argc, argv, optstring)\n \t\t\t   0);\n }\n \n-#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n+#endif\t/* Not ELIDE_CODE.  */\n \f\n #ifdef TEST\n \n@@ -705,7 +989,7 @@ main (argc, argv)\n       int this_option_optind = optind ? optind : 1;\n \n       c = getopt (argc, argv, \"abc:d:0123456789\");\n-      if (c == EOF)\n+      if (c == -1)\n \tbreak;\n \n       switch (c)"}, {"sha": "af8e681965740e72dbfd83c6238e705c94ffc964", "filename": "libiberty/getopt1.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2Fgetopt1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b134508bdf7c7be232163aca51789a455db9cb76/libiberty%2Fgetopt1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetopt1.c?ref=b134508bdf7c7be232163aca51789a455db9cb76", "patch": "@@ -1,35 +1,31 @@\n /* getopt_long and getopt_long_only entry points for GNU getopt.\n-   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993\n-\tFree Software Foundation, Inc.\n+   Copyright (C) 1987,88,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-   This program is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Library General Public License\n-   as published by the Free Software Foundation; either version 2, or\n-   (at your option) any later version.\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n \n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU Library General Public License for more details.\n+   GNU General Public License for more details.\n \n-   You should have received a copy of the GNU Library General Public License\n+   You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n \f\n #ifdef HAVE_CONFIG_H\n-#if defined (emacs) || defined (CONFIG_BROKETS)\n-/* We use <config.h> instead of \"config.h\" so that a compilation\n-   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h\n-   (which it would do because it found this file in $srcdir).  */\n #include <config.h>\n-#else\n-#include \"config.h\"\n-#endif\n #endif\n \n #include \"getopt.h\"\n \n-#ifndef __STDC__\n+#if !defined (__STDC__) || !__STDC__\n /* This is a separate conditional since some stdc systems\n    reject `defined (const)'.  */\n #ifndef const\n@@ -46,19 +42,22 @@\n    (especially if it is a shared library).  Rather than having every GNU\n    program understand `configure --with-gnu-libc' and omit the object files,\n    it is simpler to just do this in the source for each such file.  */\n-/* Many versions of the Linux C library include older, broken versions\n-   of these routines, which will break the linker's command-line\n-   parsing.  */\n \n-#if defined (_LIBC) || !defined (__GNU_LIBRARY__) || defined (__linux__)\n+#define GETOPT_INTERFACE_VERSION 2\n+#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2\n+#include <gnu-versions.h>\n+#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION\n+#define ELIDE_CODE\n+#endif\n+#endif\n+\n+#ifndef ELIDE_CODE\n \n \n /* This needs to come after some library #include\n    to get __GNU_LIBRARY__ defined.  */\n #ifdef __GNU_LIBRARY__\n #include <stdlib.h>\n-#else\n-char *getenv ();\n #endif\n \n #ifndef\tNULL\n@@ -93,7 +92,7 @@ getopt_long_only (argc, argv, options, long_options, opt_index)\n }\n \n \n-#endif\t/* _LIBC or not __GNU_LIBRARY__.  */\n+#endif\t/* Not ELIDE_CODE.  */\n \f\n #ifdef TEST\n \n@@ -124,7 +123,7 @@ main (argc, argv)\n \n       c = getopt_long (argc, argv, \"abc:d:0123456789\",\n \t\t       long_options, &option_index);\n-      if (c == EOF)\n+      if (c == -1)\n \tbreak;\n \n       switch (c)"}]}