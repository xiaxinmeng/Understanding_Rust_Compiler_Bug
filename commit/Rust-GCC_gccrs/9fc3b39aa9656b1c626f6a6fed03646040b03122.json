{"sha": "9fc3b39aa9656b1c626f6a6fed03646040b03122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZjM2IzOWFhOTY1NmIxYzYyNmY2YTZmZWQwMzY0NjA0MGIwMzEyMg==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@apple.com", "date": "2004-08-23T03:12:38Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-08-23T03:12:38Z"}, "message": "re PR tree-optimization/15262 ([tree-ssa] Alias analyzer cannot handle addressable fields)\n\n2004-08-22  Andrew Pinski  <apinski@apple.com>\n\n       PR c/15262\n       * c-typeck.c (build_unary_op): Use &a.b if the foldded lowered\n       expression is not constant.\n       (c_finish_return): Do not go through INDIRECT_REF when looking\n       for the inner expression of an ADDR_EXPR for warning about.\n\n2004-08-22  Andrew Pinski  <apinski@apple.com>\n\n       * g++.dg/opt/pr14029.C: New test.\n       * gcc.c-torture/execute/pr15262.c: New test.\n2004-08-22  Andrew Pinski  <apinski@apple.com>\n\n       PR c++/14029\n       * typeck.c (build_unary_op): Use &a.b if the foldded lowered\n       expression is not constant.\n\nFrom-SVN: r86396", "tree": {"sha": "78eae43b8b4b4c41f658de8bb312ce1a83255267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78eae43b8b4b4c41f658de8bb312ce1a83255267"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fc3b39aa9656b1c626f6a6fed03646040b03122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc3b39aa9656b1c626f6a6fed03646040b03122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc3b39aa9656b1c626f6a6fed03646040b03122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc3b39aa9656b1c626f6a6fed03646040b03122/comments", "author": null, "committer": null, "parents": [{"sha": "35e0e58c7ae736ad49bb6c05222c0f04fed4a2c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e0e58c7ae736ad49bb6c05222c0f04fed4a2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e0e58c7ae736ad49bb6c05222c0f04fed4a2c4"}], "stats": {"total": 123, "additions": 121, "deletions": 2}, "files": [{"sha": "94756947a4e0661ec28933b8af7b17fad0feef5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -1,3 +1,11 @@\n+2004-08-22  Andrew Pinski  <apinski@apple.com>\n+\n+\tPR c/15262\n+\t* c-typeck.c (build_unary_op): Use &a.b if the foldded lowered\n+\texpression is not constant.\n+\t(c_finish_return): Do not go through INDIRECT_REF when looking\n+\tfor the inner expression of an ADDR_EXPR for warning about.\n+\n 2004-08-22  Richard Henderson  <rth@redhat.com>\n \n \tPR 17075"}, {"sha": "3530c20868a17e9227432b815eb4b85f5f350063", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -2538,9 +2538,14 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    addr = fold (build2 (PLUS_EXPR, argtype,\n \t\t\t\t convert (argtype, addr),\n \t\t\t\t convert (argtype, byte_position (field))));\n+\t    \n+\t    /* If the folded PLUS_EXPR is not a constant address, wrap\n+               it in an ADDR_EXPR.  */\n+\t    if (!TREE_CONSTANT (addr))\n+\t      addr = build1 (ADDR_EXPR, argtype, arg);\n \t  }\n \telse\n-\t  addr = build1 (code, argtype, arg);\n+\t  addr = build1 (ADDR_EXPR, argtype, arg);\n \n \tif (TREE_CODE (arg) == COMPOUND_LITERAL_EXPR)\n \t  TREE_INVARIANT (addr) = TREE_CONSTANT (addr) = 1;\n@@ -6310,7 +6315,8 @@ c_finish_return (tree retval)\n \t    case ADDR_EXPR:\n \t      inner = TREE_OPERAND (inner, 0);\n \n-\t      while (TREE_CODE_CLASS (TREE_CODE (inner)) == 'r')\n+\t      while (TREE_CODE_CLASS (TREE_CODE (inner)) == 'r'\n+\t             && TREE_CODE (inner) != INDIRECT_REF)\n \t\tinner = TREE_OPERAND (inner, 0);\n \n \t      if (DECL_P (inner)"}, {"sha": "e2b32126ce06ff818d74da873bd2d15830526eb8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -1,3 +1,9 @@\n+2004-08-22  Andrew Pinski  <apinski@apple.com>\n+\n+\tPR c++/14029\n+\t* typeck.c (build_unary_op): Use &a.b if the foldded lowered\n+\texpression is not constant.\n+\n 2004-08-20  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17121"}, {"sha": "a614db58978e3f470549137b02f1ed7f51936040", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -4123,6 +4123,11 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    addr = fold (build2 (PLUS_EXPR, argtype, rval,\n \t\t\t\t cp_convert (argtype,\n \t\t\t\t\t     byte_position (field))));\n+\n+\t    /* If the folded PLUS_EXPR is not a constant address, wrap\n+               it in an ADDR_EXPR.  */\n+\t    if (!TREE_CONSTANT (addr))\n+\t      addr = build_address (arg);\n \t  }\n \n \tif (TREE_CODE (argtype) == POINTER_TYPE"}, {"sha": "23d0604c2de84cb973b680c95ea9b41a3cc2eed8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -1,3 +1,8 @@\n+2004-08-22  Andrew Pinski  <apinski@apple.com>\n+\n+\t* g++.dg/opt/pr14029.C: New test.\n+\t* gcc.c-torture/execute/pr15262.c: New test.\n+\n 2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.dg/reduction.f90: Add checks with complex arguments."}, {"sha": "1673edfd615e309872386c8d997b4c5b4a355d73", "filename": "gcc/testsuite/g++.dg/opt/pr14029.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr14029.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr14029.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr14029.C?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// We used to mis-compile this testcase as we did not know that\n+// &a+offsetof(b,a) was the same as &a.b\n+\n+struct Iterator {\n+    int * ptr;\n+\n+    Iterator(int * i) : ptr(i) { }\n+    void operator++() { ++ptr; }\n+    int *const & base() const { return ptr; }\n+};\n+\n+\n+Iterator find_7(Iterator first, Iterator last)\n+{\n+  int trip_count  = (last.base() - first.base()) >> 1;\n+\n+  for ( ; trip_count > 0 ; --trip_count) {\n+    if (*first.ptr == 7) return first;\n+    ++first;\n+\n+    if (*first.ptr == 7) return first;\n+    ++first;\n+  }\n+\n+  switch(last.base() - first.base()) {\n+    case 1:\n+          if (*first.ptr == 7) return first;\n+          ++first;\n+    case 0:\n+    default:\n+          return last;\n+  }\n+}\n+\n+int main() {\n+  int as[5] = {4,4,4,4,7};\n+  return (find_7(Iterator(&as[0]), Iterator(&as[5])).ptr == &as[5]);\n+};\n+"}, {"sha": "2110f33a04a3c224d8c3de9d5e5581378125dd61", "filename": "gcc/testsuite/gcc.c-torture/execute/pr15262.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc3b39aa9656b1c626f6a6fed03646040b03122/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262.c?ref=9fc3b39aa9656b1c626f6a6fed03646040b03122", "patch": "@@ -0,0 +1,48 @@\n+/* We used to mis-compile this testcase as we did not know that\n+   &a+offsetof(b,a) was the same as &a.b */\n+struct A\n+{\n+  int t;\n+  int i;\n+};\n+\n+void\n+bar (float *p)\n+{\n+  *p = 5.2;\n+}\n+\n+int\n+foo(struct A *locp, int i, int str)\n+{\n+  float f, g, *p;\n+  int T355;\n+  int *T356;\n+  /* Currently, the alias analyzer has limited support for handling\n+     aliases of structure fields when no other variables are aliased.\n+     Introduce additional aliases to confuse it.  */\n+  p =  i ? &g : &f;\n+  bar (p);\n+  if (*p > 0.0)\n+    str = 1;\n+\n+  T355 = locp->i;\n+  T356 = &locp->i;\n+  *T356 = str;\n+  T355 = locp->i;\n+\n+  return T355;\n+}\n+\n+main ()\n+{\n+  struct A loc;\n+  int str;\n+\n+  loc.i = 2;\n+  str = foo (&loc, 10, 3);\n+  if (str!=1)\n+    abort ();\n+  return 0;\n+}\n+"}]}