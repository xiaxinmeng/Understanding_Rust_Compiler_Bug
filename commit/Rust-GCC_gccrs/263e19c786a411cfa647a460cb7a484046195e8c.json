{"sha": "263e19c786a411cfa647a460cb7a484046195e8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYzZTE5Yzc4NmE0MTFjZmE2NDdhNDYwY2I3YTQ4NDA0NjE5NWU4Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-05-19T08:52:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-19T08:52:26Z"}, "message": "ipa-inline-analysis.c (cgraph_2edge_hook_list, [...]): Remove.\n\n\t* ipa-inline-analysis.c (cgraph_2edge_hook_list, cgraph_edge_hook_list,\n\tinline_edge_removal_hook, inline_edge_duplication_hook): Remove.\n\t(inline_edge_summary_vec): Turn into ...\n\t(ipa_call_summaries): ... this one.\n\t(redirect_to_unreachable, edge_set_predicate,\n\tevaluate_properties_for_edge, inline_summary_alloc,\n\treset_ipa_call_summary, reset_inline_summary,\n\tinline_summary_t::duplicate): Update.\n\t(inline_edge_duplication_hook): Turn to ...\n\t(ipa_call_summary_t::duplicate): ... this one.\n\t(inline_edge_removal_hook): Turn to ...\n\t(ipa_call_summary_t::remove): ... this one.\n\t(dump_inline_edge_summary): Turn to ...\n\t(dump_ipa_call_summary): ... this one.\n\t(estimate_function_body_sizes): Update.\n\t(inline_update_callee_summaries): Update.\n\t(remap_edge_change_prob): Update.\n\t(remap_edge_summaries): Update.\n\t(inline_merge_summary): Update.\n\t(do_estimate_edge_time): Update.\n\t(inline_generate_summary): Update.\n\t(inline_read_section): Update.\n\t(inline_read_summary): Update.\n\t(inline_free_summary): Update.\n\t* ipa-inline.c (can_inline_edge_p): Update.\n\t(compute_inlined_call_time): Update.\n\t(want_inline_small_function_p): Update.\n\t(edge_badness): Update.\n\t(early_inliner): Update.\n\t* ipa-inline.h (inline_edge_summary): Turn to ...\n\t(ipa_call_summary): ... this one.\n\t(ipa_call_summary_t): New class.\n\t(inline_edge_summary_t, inline_edge_summary_vec): Remove.\n\t(ipa_call_summaries): New.\n\t(inline_edge_summary): Remove.\n\t(estimate_edge_growth): Update.\n\t* ipa-profile.c (ipa_propagate_frequency_1): Update.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n\t* ipa-split.c (execute_split_functions): Update.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Update.\n\nFrom-SVN: r248262", "tree": {"sha": "b12d5c2d813ff45036f743653212bf86759e0d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b12d5c2d813ff45036f743653212bf86759e0d06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/263e19c786a411cfa647a460cb7a484046195e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/263e19c786a411cfa647a460cb7a484046195e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/263e19c786a411cfa647a460cb7a484046195e8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/263e19c786a411cfa647a460cb7a484046195e8c/comments", "author": null, "committer": null, "parents": [{"sha": "035ab82621cd702bb7fc566ca7ccbcb6a9567058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035ab82621cd702bb7fc566ca7ccbcb6a9567058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/035ab82621cd702bb7fc566ca7ccbcb6a9567058"}], "stats": {"total": 298, "additions": 153, "deletions": 145}, "files": [{"sha": "0fc109dc783db94ce8bb41ba5d10ac20af069e7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -1,3 +1,46 @@\n+2017-05-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (cgraph_2edge_hook_list, cgraph_edge_hook_list,\n+\tinline_edge_removal_hook, inline_edge_duplication_hook): Remove.\n+\t(inline_edge_summary_vec): Turn into ...\n+\t(ipa_call_summaries): ... this one.\n+\t(redirect_to_unreachable, edge_set_predicate,\n+\tevaluate_properties_for_edge, inline_summary_alloc,\n+\treset_ipa_call_summary, reset_inline_summary,\n+\tinline_summary_t::duplicate): Update.\n+\t(inline_edge_duplication_hook): Turn to ...\n+\t(ipa_call_summary_t::duplicate): ... this one.\n+\t(inline_edge_removal_hook): Turn to ...\n+\t(ipa_call_summary_t::remove): ... this one.\n+\t(dump_inline_edge_summary): Turn to ...\n+\t(dump_ipa_call_summary): ... this one.\n+\t(estimate_function_body_sizes): Update.\n+\t(inline_update_callee_summaries): Update.\n+\t(remap_edge_change_prob): Update.\n+\t(remap_edge_summaries): Update.\n+\t(inline_merge_summary): Update.\n+\t(do_estimate_edge_time): Update.\n+\t(inline_generate_summary): Update.\n+\t(inline_read_section): Update.\n+\t(inline_read_summary): Update.\n+\t(inline_free_summary): Update.\n+\t* ipa-inline.c (can_inline_edge_p): Update.\n+\t(compute_inlined_call_time): Update.\n+\t(want_inline_small_function_p): Update.\n+\t(edge_badness): Update.\n+\t(early_inliner): Update.\n+\t* ipa-inline.h (inline_edge_summary): Turn to ...\n+\t(ipa_call_summary): ... this one.\n+\t(ipa_call_summary_t): New class.\n+\t(inline_edge_summary_t, inline_edge_summary_vec): Remove.\n+\t(ipa_call_summaries): New.\n+\t(inline_edge_summary): Remove.\n+\t(estimate_edge_growth): Update.\n+\t* ipa-profile.c (ipa_propagate_frequency_1): Update.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n+\t* ipa-split.c (execute_split_functions): Update.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Update.\n+\n 2017-05-19  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/80764"}, {"sha": "bda704a94735974806e3e211828738c263f58c73", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 63, "deletions": 96, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -86,17 +86,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgexpand.h\"\n #include \"gimplify.h\"\n \n-/* Holders of ipa cgraph hooks: */\n-static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n-static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-static void inline_edge_removal_hook (struct cgraph_edge *, void *);\n-static void inline_edge_duplication_hook (struct cgraph_edge *,\n-\t\t\t\t\t  struct cgraph_edge *, void *);\n-\n-/* VECtor holding inline summaries.  \n-   In GGC memory because conditions might point to constant trees.  */\n+/* Summaries.  */\n function_summary <inline_summary *> *inline_summaries;\n-vec<inline_edge_summary_t> inline_edge_summary_vec;\n+call_summary <ipa_call_summary *> *ipa_call_summaries;\n \n /* Cached node/edge growths.  */\n vec<edge_growth_cache_entry> edge_growth_cache;\n@@ -254,7 +246,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n     e->make_direct (target);\n   else\n     e->redirect_callee (target);\n-  struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   e->inline_failed = CIF_UNREACHABLE;\n   e->frequency = 0;\n   e->count = 0;\n@@ -279,7 +271,7 @@ edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n       && (!e->speculative || e->callee))\n     e = redirect_to_unreachable (e);\n \n-  struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   if (predicate && *predicate != true)\n     {\n       if (!es->predicate)\n@@ -457,7 +449,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n@@ -540,36 +532,25 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n static void\n inline_summary_alloc (void)\n {\n-  if (!edge_removal_hook_holder)\n-    edge_removal_hook_holder =\n-      symtab->add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n-  if (!edge_duplication_hook_holder)\n-    edge_duplication_hook_holder =\n-      symtab->add_edge_duplication_hook (&inline_edge_duplication_hook, NULL);\n-\n   if (!inline_summaries)\n-    inline_summaries = (inline_summary_t*) inline_summary_t::create_ggc (symtab);\n-\n-  if (inline_edge_summary_vec.length () <= (unsigned) symtab->edges_max_uid)\n-    inline_edge_summary_vec.safe_grow_cleared (symtab->edges_max_uid + 1);\n+    inline_summaries = inline_summary_t::create_ggc (symtab);\n+  if (!ipa_call_summaries)\n+    ipa_call_summaries = new ipa_call_summary_t (symtab, false);\n }\n \n /* We are called multiple time for given function; clear\n    data from previous run so they are not cumulated.  */\n \n static void\n-reset_inline_edge_summary (struct cgraph_edge *e)\n+reset_ipa_call_summary (struct cgraph_edge *e)\n {\n-  if (e->uid < (int) inline_edge_summary_vec.length ())\n-    {\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n \n-      es->call_stmt_size = es->call_stmt_time = 0;\n-      if (es->predicate)\n-\tedge_predicate_pool.remove (es->predicate);\n-      es->predicate = NULL;\n-      es->param.release ();\n-    }\n+  es->call_stmt_size = es->call_stmt_time = 0;\n+  if (es->predicate)\n+    edge_predicate_pool.remove (es->predicate);\n+  es->predicate = NULL;\n+  es->param.release ();\n }\n \n /* We are called multiple time for given function; clear\n@@ -608,9 +589,9 @@ reset_inline_summary (struct cgraph_node *node,\n   vec_free (info->conds);\n   vec_free (info->entry);\n   for (e = node->callees; e; e = e->next_callee)\n-    reset_inline_edge_summary (e);\n+    reset_ipa_call_summary (e);\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    reset_inline_edge_summary (e);\n+    reset_ipa_call_summary (e);\n   info->fp_expressions = false;\n }\n \n@@ -726,7 +707,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->callees; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\t  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n \t  if (!edge->inline_failed)\n@@ -745,7 +726,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\t  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n \t  gcc_checking_assert (edge->inline_failed);\n@@ -799,17 +780,13 @@ inline_summary_t::duplicate (cgraph_node *src,\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n-static void\n-inline_edge_duplication_hook (struct cgraph_edge *src,\n-\t\t\t      struct cgraph_edge *dst,\n-\t\t\t      ATTRIBUTE_UNUSED void *data)\n+void\n+ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n+\t\t\t       struct cgraph_edge *dst,\n+\t\t\t       struct ipa_call_summary *srcinfo,\n+\t\t\t       struct ipa_call_summary *info)\n {\n-  struct inline_edge_summary *info;\n-  struct inline_edge_summary *srcinfo;\n-  inline_summary_alloc ();\n-  info = inline_edge_summary (dst);\n-  srcinfo = inline_edge_summary (src);\n-  memcpy (info, srcinfo, sizeof (struct inline_edge_summary));\n+  *info = *srcinfo;\n   info->predicate = NULL;\n   edge_set_predicate (dst, srcinfo->predicate);\n   info->param = srcinfo->param.copy ();\n@@ -825,13 +802,13 @@ inline_edge_duplication_hook (struct cgraph_edge *src,\n \n /* Keep edge cache consistent across edge removal.  */\n \n-static void\n-inline_edge_removal_hook (struct cgraph_edge *edge,\n-\t\t\t  void *data ATTRIBUTE_UNUSED)\n+void\n+ipa_call_summary_t::remove (struct cgraph_edge *edge,\n+\t\t\t    struct ipa_call_summary *)\n {\n   if (edge_growth_cache.exists ())\n     reset_edge_growth_cache (edge);\n-  reset_inline_edge_summary (edge);\n+  reset_ipa_call_summary (edge);\n }\n \n \n@@ -858,13 +835,13 @@ free_growth_caches (void)\n    Indent by INDENT.  */\n \n static void\n-dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n-\t\t\t  struct inline_summary *info)\n+dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n+\t\t       struct inline_summary *info)\n {\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n-      struct inline_edge_summary *es = inline_edge_summary (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n       struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n       int i;\n \n@@ -906,12 +883,12 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n \t\t   (int) inline_summaries->get (callee)->stack_frame_offset,\n \t\t   (int) inline_summaries->get (callee)->estimated_self_stack_size,\n \t\t   (int) inline_summaries->get (callee)->estimated_stack_size);\n-\t  dump_inline_edge_summary (f, indent + 2, callee, info);\n+\t  dump_ipa_call_summary (f, indent + 2, callee, info);\n \t}\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n-      struct inline_edge_summary *es = inline_edge_summary (edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i\"\n \t       \" time: %2i\",\n \t       indent, \"\",\n@@ -991,7 +968,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \t  s->array_index->dump (f, s->conds);\n \t}\n       fprintf (f, \"  calls:\\n\");\n-      dump_inline_edge_summary (f, 4, node, s);\n+      dump_ipa_call_summary (f, 4, node, s);\n       fprintf (f, \"\\n\");\n     }\n }\n@@ -2234,7 +2211,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      && !gimple_call_internal_p (stmt))\n \t    {\n \t      struct cgraph_edge *edge = node->get_edge (stmt);\n-\t      struct inline_edge_summary *es = inline_edge_summary (edge);\n+\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n \n \t      /* Special case: results of BUILT_IN_CONSTANT_P will be always\n \t         resolved as constant.  We however don't want to optimize\n@@ -2487,7 +2464,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \n   if (node->thunk.thunk_p)\n     {\n-      struct inline_edge_summary *es = inline_edge_summary (node->callees);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (node->callees);\n       predicate t = true;\n \n       node->local.can_change_signature = false;\n@@ -2687,7 +2664,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     inline_hints *hints)\n {\n-  struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n   int cur_size;\n@@ -2725,10 +2702,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      if (inline_edge_summary_vec.length () <= (unsigned) e->uid)\n-\tcontinue;\n-\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n \n       /* Do not care about zero sized builtins.  */\n       if (e->inline_failed && !es->call_stmt_size)\n@@ -2759,10 +2733,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      if (inline_edge_summary_vec.length () <= (unsigned) e->uid)\n-\tcontinue;\n-\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       if (!es->predicate\n \t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n@@ -2964,10 +2935,10 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n     {\n       if (!e->inline_failed)\n \tinline_update_callee_summaries (e->callee, depth);\n-      inline_edge_summary (e)->loop_depth += depth;\n+      ipa_call_summaries->get (e)->loop_depth += depth;\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n-    inline_edge_summary (e)->loop_depth += depth;\n+    ipa_call_summaries->get (e)->loop_depth += depth;\n }\n \n /* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n@@ -2984,9 +2955,9 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n     {\n       int i;\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n-      struct inline_edge_summary *es = inline_edge_summary (edge);\n-      struct inline_edge_summary *inlined_es\n-\t= inline_edge_summary (inlined_edge);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      struct ipa_call_summary *inlined_es\n+\t= ipa_call_summaries->get (inlined_edge);\n \n       for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n \t{\n@@ -3033,7 +3004,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -3059,7 +3030,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n     }\n   for (e = node->indirect_calls; e; e = next)\n     {\n-      struct inline_edge_summary *es = inline_edge_summary (e);\n+      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -3120,7 +3091,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n   int i;\n   predicate toplev_predicate;\n   predicate true_p = true;\n-  struct inline_edge_summary *es = inline_edge_summary (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -3210,7 +3181,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n   inline_update_callee_summaries (edge->callee,\n-\t\t\t\t  inline_edge_summary (edge)->loop_depth);\n+\t\t\t\t  ipa_call_summaries->get (edge)->loop_depth);\n \n   /* We do not maintain predicates of inlined edges, free it.  */\n   edge_set_predicate (edge, &true_p);\n@@ -3284,7 +3255,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n-  struct inline_edge_summary *es = inline_edge_summary (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size;\n \n   callee = edge->callee->ultimate_alias_target ();\n@@ -3419,7 +3390,7 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  struct inline_edge_summary *es = inline_edge_summary (edge);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n   if (!es->predicate || *es->predicate != false)\n     {\n       int size = inline_summaries->get (node)->size + estimate_edge_growth (edge);\n@@ -3666,9 +3637,9 @@ inline_generate_summary (void)\n /* Write inline summary for edge E to OB.  */\n \n static void\n-read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n+read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n {\n-  struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   predicate p;\n   int length, i;\n \n@@ -3772,9 +3743,9 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       p.stream_in (&ib);\n       set_hint_predicate (&info->array_index, p);\n       for (e = node->callees; e; e = e->next_callee)\n-\tread_inline_edge_summary (&ib, e);\n+\tread_ipa_call_summary (&ib, e);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n-\tread_inline_edge_summary (&ib, e);\n+\tread_ipa_call_summary (&ib, e);\n     }\n \n   lto_free_section_data (file_data, LTO_section_inline_summary, NULL, data,\n@@ -3826,9 +3797,9 @@ inline_read_summary (void)\n /* Write inline summary for edge E to OB.  */\n \n static void\n-write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n+write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n-  struct inline_edge_summary *es = inline_edge_summary (e);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   int i;\n \n   streamer_write_uhwi (ob, es->call_stmt_size);\n@@ -3922,9 +3893,9 @@ inline_write_summary (void)\n \t  else\n \t    streamer_write_uhwi (ob, 0);\n \t  for (edge = cnode->callees; edge; edge = edge->next_callee)\n-\t    write_inline_edge_summary (ob, edge);\n+\t    write_ipa_call_summary (ob, edge);\n \t  for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)\n-\t    write_inline_edge_summary (ob, edge);\n+\t    write_ipa_call_summary (ob, edge);\n \t}\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n@@ -3942,19 +3913,15 @@ void\n inline_free_summary (void)\n {\n   struct cgraph_node *node;\n-  if (edge_removal_hook_holder)\n-    symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n-  edge_removal_hook_holder = NULL;\n-  if (edge_duplication_hook_holder)\n-    symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n-  edge_duplication_hook_holder = NULL;\n-  if (!inline_edge_summary_vec.exists ())\n+  if (!ipa_call_summaries)\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n       reset_inline_summary (node, inline_summaries->get (node));\n   inline_summaries->release ();\n   inline_summaries = NULL;\n-  inline_edge_summary_vec.release ();\n+  ipa_call_summaries->release ();\n+  delete ipa_call_summaries;\n+  ipa_call_summaries = NULL;\n   edge_predicate_pool.release ();\n }"}, {"sha": "0238de2dac8e205ea508ae389b490e3a4320dfc1", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -493,7 +493,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t\t   > opt_for_fn (caller->decl, optimize)))\n \t{\n \t  if (estimate_edge_time (e)\n-\t      >= 20 + inline_edge_summary (e)->call_stmt_time)\n+\t      >= 20 + ipa_call_summaries->get (e)->call_stmt_time)\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -672,7 +672,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   /* This calculation should match one in ipa-inline-analysis.c\n      (estimate_edge_size_and_time).  */\n   time -= (sreal) edge->frequency\n-\t   * inline_edge_summary (edge)->call_stmt_time / CGRAPH_FREQ_BASE;\n+\t   * ipa_call_summaries->get (edge)->call_stmt_time / CGRAPH_FREQ_BASE;\n   time += caller_time;\n   if (time <= 0)\n     time = ((sreal) 1) >> 8;\n@@ -722,16 +722,16 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count || !e->maybe_hot_p ()))\n \t   && inline_summaries->get (callee)->min_size\n-\t\t- inline_edge_summary (e)->call_stmt_size\n-\t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n+\t\t- ipa_call_summaries->get (e)->call_stmt_size\n+\t      > (unsigned)MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl) || e->count)\n \t   && inline_summaries->get (callee)->min_size\n-\t\t- inline_edge_summary (e)->call_stmt_size\n-\t      > 16 * MAX_INLINE_INSNS_SINGLE)\n+\t\t- ipa_call_summaries->get (e)->call_stmt_size\n+\t      > (unsigned)16 * MAX_INLINE_INSNS_SINGLE)\n     {\n       e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n \t\t\t  ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n@@ -1172,7 +1172,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      of functions fully inlined in program.  */\n   else\n     {\n-      int nest = MIN (inline_edge_summary (edge)->loop_depth, 8);\n+      int nest = MIN (ipa_call_summaries->get (edge)->loop_depth, 8);\n       badness = growth;\n \n       /* Decrease badness if call is nested.  */\n@@ -2691,14 +2691,11 @@ early_inliner (function *fun)\n \t     statements that don't have inline parameters computed.  */\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n-\t      if (inline_edge_summary_vec.length () > (unsigned) edge->uid)\n-\t\t{\n-\t\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n-\t\t  es->call_stmt_size\n-\t\t    = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-\t\t  es->call_stmt_time\n-\t\t    = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-\t\t}\n+\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      es->call_stmt_size\n+\t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+\t      es->call_stmt_time\n+\t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n \t    }\n \t  inline_update_overall_summary (node);\n \t  inlined = false;\n@@ -2719,14 +2716,12 @@ early_inliner (function *fun)\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n \t      /* We have no summary for new bound store calls yet.  */\n-\t      if (inline_edge_summary_vec.length () > (unsigned)edge->uid)\n-\t\t{\n-\t\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n-\t\t  es->call_stmt_size\n-\t\t    = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-\t\t  es->call_stmt_time\n-\t\t    = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-\t\t}\n+\t      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+\t      es->call_stmt_size\n+\t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+\t      es->call_stmt_time\n+\t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\n \t      if (edge->callee->decl\n \t\t  && !gimple_check_call_matching_types (\n \t\t      edge->call_stmt, edge->callee->decl, false))"}, {"sha": "14517c029fb4c991f2037961767ec7bc21d28d6d", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -183,24 +183,33 @@ class GTY((user)) inline_summary_t: public function_summary <inline_summary *>\n extern GTY(()) function_summary <inline_summary *> *inline_summaries;\n \n /* Information kept about callgraph edges.  */\n-struct inline_edge_summary\n+struct ipa_call_summary\n {\n-  /* Estimated size and time of the call statement.  */\n-  int call_stmt_size;\n-  int call_stmt_time;\n-  /* Depth of loop nest, 0 means no nesting.  */\n-  unsigned short int loop_depth;\n   class predicate *predicate;\n-  /* Array indexed by parameters.\n-     0 means that parameter change all the time, REG_BR_PROB_BASE means\n-     that parameter is constant.  */\n+  /* Vector indexed by parameters.  */\n   vec<inline_param_summary> param;\n+  /* Estimated size and time of the call statement.  */\n+  unsigned int call_stmt_size;\n+  unsigned int call_stmt_time;\n+  /* Depth of loop nest, 0 means no nesting.  */\n+  unsigned int loop_depth;\n };\n \n-/* Need a typedef for inline_edge_summary because of inline function\n-   'inline_edge_summary' below.  */\n-typedef struct inline_edge_summary inline_edge_summary_t;\n-extern vec<inline_edge_summary_t> inline_edge_summary_vec;\n+class ipa_call_summary_t: public call_summary <ipa_call_summary *>\n+{\n+public:\n+  ipa_call_summary_t (symbol_table *symtab, bool ggc):\n+    call_summary <ipa_call_summary *> (symtab, ggc) {}\n+\n+  /* Hook that is called by summary when an edge is duplicated.  */\n+  virtual void remove (cgraph_edge *cs, ipa_call_summary *);\n+  /* Hook that is called by summary when an edge is duplicated.  */\n+  virtual void duplicate (cgraph_edge *src, cgraph_edge *dst,\n+\t\t\t  ipa_call_summary *src_data,\n+\t\t\t  ipa_call_summary *dst_data);\n+};\n+\n+extern call_summary <ipa_call_summary *> *ipa_call_summaries;\n \n /* Data we cache about callgraph edges during inlining to avoid expensive\n    re-computations during the greedy algorithm.  */\n@@ -256,12 +265,6 @@ void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *,\n extern int ncalls_inlined;\n extern int nfunctions_inlined;\n \n-static inline struct inline_edge_summary *\n-inline_edge_summary (struct cgraph_edge *edge)\n-{\n-  return &inline_edge_summary_vec[edge->uid];\n-}\n-\n \n /* Return estimated size of the inline sequence of EDGE.  */\n \n@@ -280,10 +283,10 @@ estimate_edge_size (struct cgraph_edge *edge)\n static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n-  gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size\n+  gcc_checking_assert (ipa_call_summaries->get (edge)->call_stmt_size\n \t\t       || !edge->callee->analyzed);\n   return (estimate_edge_size (edge)\n-\t  - inline_edge_summary (edge)->call_stmt_size);\n+\t  - ipa_call_summaries->get (edge)->call_stmt_size);\n }\n \n /* Return estimated callee runtime increase after inlining"}, {"sha": "c60e05d84540c59a0e5864cb4e0a716566e646b8", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -348,7 +348,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n \t\t     edge->caller->name ());\n \t  d->maybe_unlikely_executed = false;\n-\t  if (inline_edge_summary (edge)->loop_depth)\n+\t  if (ipa_call_summaries->get (edge)->loop_depth)\n \t    {\n \t      d->maybe_executed_once = false;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "10741a2b7bd9b770a6c3939a20f1ef9f8eadc4ff", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -2828,7 +2828,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t\t\t\tbool speculative)\n {\n   struct cgraph_node *callee;\n-  struct inline_edge_summary *es = inline_edge_summary (ie);\n+  struct ipa_call_summary *es = ipa_call_summaries->get (ie);\n   bool unreachable = false;\n \n   if (TREE_CODE (target) == ADDR_EXPR)\n@@ -2977,7 +2977,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t for direct call (adjusted by inline_edge_duplication_hook).  */\n       if (ie == orig)\n \t{\n-\t  es = inline_edge_summary (ie);\n+\t  es = ipa_call_summaries->get (ie);\n \t  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n \t\t\t\t - eni_size_weights.call_cost);\n \t  es->call_stmt_time -= (eni_time_weights.indirect_call_cost"}, {"sha": "b8e644038d0fbb833deb8c54f3f8d089d7020ed2", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -1742,7 +1742,7 @@ execute_split_functions (void)\n     }\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n-  if (inline_edge_summary_vec.exists ()\n+  if (inline_summaries\n       && !inline_summaries->get (node)->inlinable)\n     {\n       if (dump_file)"}, {"sha": "aa4181b6c2c792f4f48481d6bbdcb1a561f1ba59", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/263e19c786a411cfa647a460cb7a484046195e8c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=263e19c786a411cfa647a460cb7a484046195e8c", "patch": "@@ -698,7 +698,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   symtab_node::checking_verify_symtab_nodes ();\n \n   /* If we removed something, perhaps profile could be improved.  */\n-  if (changed && optimize && inline_edge_summary_vec.exists ())\n+  if (changed && optimize && ipa_call_summaries)\n     FOR_EACH_DEFINED_FUNCTION (node)\n       ipa_propagate_frequency (node);\n "}]}