{"sha": "77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdkYmIyMTQ4ODQyMmJiZDMwZGJjZmNhZjM0ZjNjOTEzNWY3NzMyZg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-04-28T19:23:55Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-04-28T19:23:55Z"}, "message": "rs6000: Clean up rs6000_stack_info a bit\n\n- Rename \"info_ptr\" to \"info\", as in all other routines;\n- Don't set fields to 0, the whole struct already is set to 0;\n- Fix formatting a bit.\n\n\n\t* config/rs6000/rs6000.c (compute_save_world_info): Rename info_ptr\n\tto info.  Don't initialize separate fields to 0.  Clean up\n\tformatting a bit.\n\nFrom-SVN: r235606", "tree": {"sha": "bdb913ed019e7df896d23ce54f4c6ee9a9e8bf41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdb913ed019e7df896d23ce54f4c6ee9a9e8bf41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dbb21488422bbd30dbcfcaf34f3c9135f7732f/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4cb361287ea583f91ee8b850bca576a54f5917c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4cb361287ea583f91ee8b850bca576a54f5917c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4cb361287ea583f91ee8b850bca576a54f5917c"}], "stats": {"total": 284, "additions": 133, "deletions": 151}, "files": [{"sha": "4fa150479592ca3d2f49b9c416f33ff65f4ea38b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbb21488422bbd30dbcfcaf34f3c9135f7732f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbb21488422bbd30dbcfcaf34f3c9135f7732f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "patch": "@@ -1,3 +1,9 @@\n+2016-04-28  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (compute_save_world_info): Rename info_ptr\n+\tto info.  Don't initialize separate fields to 0.  Clean up\n+\tformatting a bit.\n+\n 2016-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (peephole2s for operations with memory inputs):"}, {"sha": "11cbb203f350ba2b6b99b7106f624a00de0b7629", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 127, "deletions": 151, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbb21488422bbd30dbcfcaf34f3c9135f7732f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbb21488422bbd30dbcfcaf34f3c9135f7732f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=77dbb21488422bbd30dbcfcaf34f3c9135f7732f", "patch": "@@ -23057,52 +23057,53 @@ compute_vrsave_mask (void)\n    routines.  */\n \n static void\n-compute_save_world_info (rs6000_stack_t *info_ptr)\n+compute_save_world_info (rs6000_stack_t *info)\n {\n-  info_ptr->world_save_p = 1;\n-  info_ptr->world_save_p\n-    = (WORLD_SAVE_P (info_ptr)\n+  info->world_save_p = 1;\n+  info->world_save_p\n+    = (WORLD_SAVE_P (info)\n        && DEFAULT_ABI == ABI_DARWIN\n        && !cfun->has_nonlocal_label\n-       && info_ptr->first_fp_reg_save == FIRST_SAVED_FP_REGNO\n-       && info_ptr->first_gp_reg_save == FIRST_SAVED_GP_REGNO\n-       && info_ptr->first_altivec_reg_save == FIRST_SAVED_ALTIVEC_REGNO\n-       && info_ptr->cr_save_p);\n+       && info->first_fp_reg_save == FIRST_SAVED_FP_REGNO\n+       && info->first_gp_reg_save == FIRST_SAVED_GP_REGNO\n+       && info->first_altivec_reg_save == FIRST_SAVED_ALTIVEC_REGNO\n+       && info->cr_save_p);\n \n   /* This will not work in conjunction with sibcalls.  Make sure there\n      are none.  (This check is expensive, but seldom executed.) */\n-  if (WORLD_SAVE_P (info_ptr))\n+  if (WORLD_SAVE_P (info))\n     {\n       rtx_insn *insn;\n       for (insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n \tif (CALL_P (insn) && SIBLING_CALL_P (insn))\n \t  {\n-\t    info_ptr->world_save_p = 0;\n+\t    info->world_save_p = 0;\n \t    break;\n \t  }\n     }\n \n-  if (WORLD_SAVE_P (info_ptr))\n+  if (WORLD_SAVE_P (info))\n     {\n       /* Even if we're not touching VRsave, make sure there's room on the\n \t stack for it, if it looks like we're calling SAVE_WORLD, which\n \t will attempt to save it. */\n-      info_ptr->vrsave_size  = 4;\n+      info->vrsave_size  = 4;\n \n       /* If we are going to save the world, we need to save the link register too.  */\n-      info_ptr->lr_save_p = 1;\n+      info->lr_save_p = 1;\n \n       /* \"Save\" the VRsave register too if we're saving the world.  */\n-      if (info_ptr->vrsave_mask == 0)\n-\tinfo_ptr->vrsave_mask = compute_vrsave_mask ();\n+      if (info->vrsave_mask == 0)\n+\tinfo->vrsave_mask = compute_vrsave_mask ();\n \n       /* Because the Darwin register save/restore routines only handle\n \t F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency\n \t check.  */\n-      gcc_assert (info_ptr->first_fp_reg_save >= FIRST_SAVED_FP_REGNO\n-\t\t  && (info_ptr->first_altivec_reg_save\n+      gcc_assert (info->first_fp_reg_save >= FIRST_SAVED_FP_REGNO\n+\t\t  && (info->first_altivec_reg_save\n \t\t      >= FIRST_SAVED_ALTIVEC_REGNO));\n     }\n+\n   return;\n }\n \n@@ -23450,7 +23451,7 @@ rs6000_stack_info (void)\n   /* We should never be called for thunks, we are not set up for that.  */\n   gcc_assert (!cfun->is_thunk);\n \n-  rs6000_stack_t *info_ptr = &stack_info;\n+  rs6000_stack_t *info = &stack_info;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int ehrd_size;\n   int ehcr_size;\n@@ -23459,26 +23460,26 @@ rs6000_stack_info (void)\n   HOST_WIDE_INT non_fixed_size;\n   bool using_static_chain_p;\n \n-  if (reload_completed && info_ptr->reload_completed)\n-    return info_ptr;\n+  if (reload_completed && info->reload_completed)\n+    return info;\n \n-  memset (info_ptr, 0, sizeof (*info_ptr));\n-  info_ptr->reload_completed = reload_completed;\n+  memset (info, 0, sizeof (*info));\n+  info->reload_completed = reload_completed;\n \n   if (TARGET_SPE)\n     {\n       /* Cache value so we don't rescan instruction chain over and over.  */\n       if (cfun->machine->spe_insn_chain_scanned_p == 0)\n \tcfun->machine->spe_insn_chain_scanned_p\n \t  = spe_func_has_64bit_regs_p () + 1;\n-      info_ptr->spe_64bit_regs_used = cfun->machine->spe_insn_chain_scanned_p - 1;\n+      info->spe_64bit_regs_used = cfun->machine->spe_insn_chain_scanned_p - 1;\n     }\n \n   /* Select which calling sequence.  */\n-  info_ptr->abi = DEFAULT_ABI;\n+  info->abi = DEFAULT_ABI;\n \n   /* Calculate which registers need to be saved & save area size.  */\n-  info_ptr->first_gp_reg_save = first_reg_to_save ();\n+  info->first_gp_reg_save = first_reg_to_save ();\n   /* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM,\n      even if it currently looks like we won't.  Reload may need it to\n      get at a constant; if so, it will have already created a constant\n@@ -23487,12 +23488,12 @@ rs6000_stack_info (void)\n        || (flag_pic == 1 && DEFAULT_ABI == ABI_V4)\n        || (flag_pic && DEFAULT_ABI == ABI_DARWIN))\n       && crtl->uses_const_pool\n-      && info_ptr->first_gp_reg_save > RS6000_PIC_OFFSET_TABLE_REGNUM)\n+      && info->first_gp_reg_save > RS6000_PIC_OFFSET_TABLE_REGNUM)\n     first_gp = RS6000_PIC_OFFSET_TABLE_REGNUM;\n   else\n-    first_gp = info_ptr->first_gp_reg_save;\n+    first_gp = info->first_gp_reg_save;\n \n-  info_ptr->gp_size = reg_size * (32 - first_gp);\n+  info->gp_size = reg_size * (32 - first_gp);\n \n   /* For the SPE, we have an additional upper 32-bits on each GPR.\n      Ideally we should save the entire 64-bits only when the upper\n@@ -23506,28 +23507,27 @@ rs6000_stack_info (void)\n \n      So... since when we save all GPRs (except the SP) in 64-bits, the\n      traditional GP save area will be empty.  */\n-  if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n-    info_ptr->gp_size = 0;\n+  if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n+    info->gp_size = 0;\n \n-  info_ptr->first_fp_reg_save = first_fp_reg_to_save ();\n-  info_ptr->fp_size = 8 * (64 - info_ptr->first_fp_reg_save);\n+  info->first_fp_reg_save = first_fp_reg_to_save ();\n+  info->fp_size = 8 * (64 - info->first_fp_reg_save);\n \n-  info_ptr->first_altivec_reg_save = first_altivec_reg_to_save ();\n-  info_ptr->altivec_size = 16 * (LAST_ALTIVEC_REGNO + 1\n-\t\t\t\t - info_ptr->first_altivec_reg_save);\n+  info->first_altivec_reg_save = first_altivec_reg_to_save ();\n+  info->altivec_size = 16 * (LAST_ALTIVEC_REGNO + 1\n+\t\t\t\t - info->first_altivec_reg_save);\n \n   /* Does this function call anything?  */\n-  info_ptr->calls_p = (! crtl->is_leaf \n-\t\t       || cfun->machine->ra_needs_full_frame);\n+  info->calls_p = (!crtl->is_leaf || cfun->machine->ra_needs_full_frame);\n \n   /* Determine if we need to save the condition code registers.  */\n   if (df_regs_ever_live_p (CR2_REGNO)\n       || df_regs_ever_live_p (CR3_REGNO)\n       || df_regs_ever_live_p (CR4_REGNO))\n     {\n-      info_ptr->cr_save_p = 1;\n+      info->cr_save_p = 1;\n       if (DEFAULT_ABI == ABI_V4)\n-\tinfo_ptr->cr_size = reg_size;\n+\tinfo->cr_size = reg_size;\n     }\n \n   /* If the current function calls __builtin_eh_return, then we need\n@@ -23540,8 +23540,7 @@ rs6000_stack_info (void)\n \tcontinue;\n \n       /* SPE saves EH registers in 64-bits.  */\n-      ehrd_size = i * (TARGET_SPE_ABI\n-\t\t       && info_ptr->spe_64bit_regs_used != 0\n+      ehrd_size = i * (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0\n \t\t       ? UNITS_PER_SPE_WORD : UNITS_PER_WORD);\n     }\n   else\n@@ -23554,41 +23553,33 @@ rs6000_stack_info (void)\n       /* This hard-codes that we have three call-saved CR fields.  */\n       ehcr_size = 3 * reg_size;\n       /* We do *not* use the regular CR save mechanism.  */\n-      info_ptr->cr_save_p = 0;\n+      info->cr_save_p = 0;\n     }\n   else\n     ehcr_size = 0;\n \n   /* Determine various sizes.  */\n-  info_ptr->reg_size     = reg_size;\n-  info_ptr->fixed_size   = RS6000_SAVE_AREA;\n-  info_ptr->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n-  info_ptr->parm_size    = RS6000_ALIGN (crtl->outgoing_args_size,\n+  info->reg_size     = reg_size;\n+  info->fixed_size   = RS6000_SAVE_AREA;\n+  info->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n+  info->parm_size    = RS6000_ALIGN (crtl->outgoing_args_size,\n \t\t\t\t\t TARGET_ALTIVEC ? 16 : 8);\n   if (FRAME_GROWS_DOWNWARD)\n-    info_ptr->vars_size\n-      += RS6000_ALIGN (info_ptr->fixed_size + info_ptr->vars_size\n-\t\t       + info_ptr->parm_size,\n+    info->vars_size\n+      += RS6000_ALIGN (info->fixed_size + info->vars_size + info->parm_size,\n \t\t       ABI_STACK_BOUNDARY / BITS_PER_UNIT)\n-\t - (info_ptr->fixed_size + info_ptr->vars_size\n-\t    + info_ptr->parm_size);\n+\t - (info->fixed_size + info->vars_size + info->parm_size);\n \n-  if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n-    info_ptr->spe_gp_size = 8 * (32 - first_gp);\n-  else\n-    info_ptr->spe_gp_size = 0;\n+  if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n+    info->spe_gp_size = 8 * (32 - first_gp);\n \n   if (TARGET_ALTIVEC_ABI)\n-    info_ptr->vrsave_mask = compute_vrsave_mask ();\n-  else\n-    info_ptr->vrsave_mask = 0;\n+    info->vrsave_mask = compute_vrsave_mask ();\n \n-  if (TARGET_ALTIVEC_VRSAVE && info_ptr->vrsave_mask)\n-    info_ptr->vrsave_size  = 4;\n-  else\n-    info_ptr->vrsave_size  = 0;\n+  if (TARGET_ALTIVEC_VRSAVE && info->vrsave_mask)\n+    info->vrsave_size = 4;\n \n-  compute_save_world_info (info_ptr);\n+  compute_save_world_info (info);\n \n   /* Calculate the offsets.  */\n   switch (DEFAULT_ABI)\n@@ -23600,112 +23591,98 @@ rs6000_stack_info (void)\n     case ABI_AIX:\n     case ABI_ELFv2:\n     case ABI_DARWIN:\n-      info_ptr->fp_save_offset   = - info_ptr->fp_size;\n-      info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n+      info->fp_save_offset = -info->fp_size;\n+      info->gp_save_offset = info->fp_save_offset - info->gp_size;\n \n       if (TARGET_ALTIVEC_ABI)\n \t{\n-\t  info_ptr->vrsave_save_offset\n-\t    = info_ptr->gp_save_offset - info_ptr->vrsave_size;\n+\t  info->vrsave_save_offset = info->gp_save_offset - info->vrsave_size;\n \n \t  /* Align stack so vector save area is on a quadword boundary.\n \t     The padding goes above the vectors.  */\n-\t  if (info_ptr->altivec_size != 0)\n-\t    info_ptr->altivec_padding_size\n-\t      = info_ptr->vrsave_save_offset & 0xF;\n-\t  else\n-\t    info_ptr->altivec_padding_size = 0;\n+\t  if (info->altivec_size != 0)\n+\t    info->altivec_padding_size = info->vrsave_save_offset & 0xF;\n \n-\t  info_ptr->altivec_save_offset\n-\t    = info_ptr->vrsave_save_offset\n-\t    - info_ptr->altivec_padding_size\n-\t    - info_ptr->altivec_size;\n-\t  gcc_assert (info_ptr->altivec_size == 0\n-\t\t      || info_ptr->altivec_save_offset % 16 == 0);\n+\t  info->altivec_save_offset = info->vrsave_save_offset\n+\t\t\t\t      - info->altivec_padding_size\n+\t\t\t\t      - info->altivec_size;\n+\t  gcc_assert (info->altivec_size == 0\n+\t\t      || info->altivec_save_offset % 16 == 0);\n \n \t  /* Adjust for AltiVec case.  */\n-\t  info_ptr->ehrd_offset = info_ptr->altivec_save_offset - ehrd_size;\n+\t  info->ehrd_offset = info->altivec_save_offset - ehrd_size;\n \t}\n       else\n-\tinfo_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n+\tinfo->ehrd_offset = info->gp_save_offset - ehrd_size;\n \n-      info_ptr->ehcr_offset      = info_ptr->ehrd_offset - ehcr_size;\n-      info_ptr->cr_save_offset   = reg_size; /* first word when 64-bit.  */\n-      info_ptr->lr_save_offset   = 2*reg_size;\n+      info->ehcr_offset = info->ehrd_offset - ehcr_size;\n+      info->cr_save_offset = reg_size; /* first word when 64-bit.  */\n+      info->lr_save_offset = 2*reg_size;\n       break;\n \n     case ABI_V4:\n-      info_ptr->fp_save_offset   = - info_ptr->fp_size;\n-      info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n-      info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n+      info->fp_save_offset = -info->fp_size;\n+      info->gp_save_offset = info->fp_save_offset - info->gp_size;\n+      info->cr_save_offset = info->gp_save_offset - info->cr_size;\n \n-      if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n+      if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n \t{\n \t  /* Align stack so SPE GPR save area is aligned on a\n \t     double-word boundary.  */\n-\t  if (info_ptr->spe_gp_size != 0 && info_ptr->cr_save_offset != 0)\n-\t    info_ptr->spe_padding_size\n-\t      = 8 - (-info_ptr->cr_save_offset % 8);\n+\t  if (info->spe_gp_size != 0 && info->cr_save_offset != 0)\n+\t    info->spe_padding_size = 8 - (-info->cr_save_offset % 8);\n \t  else\n-\t    info_ptr->spe_padding_size = 0;\n+\t    info->spe_padding_size = 0;\n \n-\t  info_ptr->spe_gp_save_offset\n-\t    = info_ptr->cr_save_offset\n-\t    - info_ptr->spe_padding_size\n-\t    - info_ptr->spe_gp_size;\n+\t  info->spe_gp_save_offset = info->cr_save_offset\n+\t\t\t\t     - info->spe_padding_size\n+\t\t\t\t     - info->spe_gp_size;\n \n \t  /* Adjust for SPE case.  */\n-\t  info_ptr->ehrd_offset = info_ptr->spe_gp_save_offset;\n+\t  info->ehrd_offset = info->spe_gp_save_offset;\n \t}\n       else if (TARGET_ALTIVEC_ABI)\n \t{\n-\t  info_ptr->vrsave_save_offset\n-\t    = info_ptr->cr_save_offset - info_ptr->vrsave_size;\n+\t  info->vrsave_save_offset = info->cr_save_offset - info->vrsave_size;\n \n \t  /* Align stack so vector save area is on a quadword boundary.  */\n-\t  if (info_ptr->altivec_size != 0)\n-\t    info_ptr->altivec_padding_size\n-\t      = 16 - (-info_ptr->vrsave_save_offset % 16);\n-\t  else\n-\t    info_ptr->altivec_padding_size = 0;\n+\t  if (info->altivec_size != 0)\n+\t    info->altivec_padding_size = 16 - (-info->vrsave_save_offset % 16);\n \n-\t  info_ptr->altivec_save_offset\n-\t    = info_ptr->vrsave_save_offset\n-\t    - info_ptr->altivec_padding_size\n-\t    - info_ptr->altivec_size;\n+\t  info->altivec_save_offset = info->vrsave_save_offset\n+\t\t\t\t      - info->altivec_padding_size\n+\t\t\t\t      - info->altivec_size;\n \n \t  /* Adjust for AltiVec case.  */\n-\t  info_ptr->ehrd_offset = info_ptr->altivec_save_offset;\n+\t  info->ehrd_offset = info->altivec_save_offset;\n \t}\n       else\n-\tinfo_ptr->ehrd_offset    = info_ptr->cr_save_offset;\n-      info_ptr->ehrd_offset      -= ehrd_size;\n-      info_ptr->lr_save_offset   = reg_size;\n-      break;\n+\tinfo->ehrd_offset = info->cr_save_offset;\n+\n+      info->ehrd_offset -= ehrd_size;\n+      info->lr_save_offset = reg_size;\n     }\n \n   save_align = (TARGET_ALTIVEC_ABI || DEFAULT_ABI == ABI_DARWIN) ? 16 : 8;\n-  info_ptr->save_size    = RS6000_ALIGN (info_ptr->fp_size\n-\t\t\t\t\t + info_ptr->gp_size\n-\t\t\t\t\t + info_ptr->altivec_size\n-\t\t\t\t\t + info_ptr->altivec_padding_size\n-\t\t\t\t\t + info_ptr->spe_gp_size\n-\t\t\t\t\t + info_ptr->spe_padding_size\n-\t\t\t\t\t + ehrd_size\n-\t\t\t\t\t + ehcr_size\n-\t\t\t\t\t + info_ptr->cr_size\n-\t\t\t\t\t + info_ptr->vrsave_size,\n-\t\t\t\t\t save_align);\n-\n-  non_fixed_size\t = (info_ptr->vars_size\n-\t\t\t    + info_ptr->parm_size\n-\t\t\t    + info_ptr->save_size);\n-\n-  info_ptr->total_size = RS6000_ALIGN (non_fixed_size + info_ptr->fixed_size,\n-\t\t\t\t       ABI_STACK_BOUNDARY / BITS_PER_UNIT);\n+  info->save_size = RS6000_ALIGN (info->fp_size\n+\t\t\t\t  + info->gp_size\n+\t\t\t\t  + info->altivec_size\n+\t\t\t\t  + info->altivec_padding_size\n+\t\t\t\t  + info->spe_gp_size\n+\t\t\t\t  + info->spe_padding_size\n+\t\t\t\t  + ehrd_size\n+\t\t\t\t  + ehcr_size\n+\t\t\t\t  + info->cr_size\n+\t\t\t\t  + info->vrsave_size,\n+\t\t\t\t  save_align);\n+\n+  non_fixed_size = info->vars_size + info->parm_size + info->save_size;\n+\n+  info->total_size = RS6000_ALIGN (non_fixed_size + info->fixed_size,\n+\t\t\t\t   ABI_STACK_BOUNDARY / BITS_PER_UNIT);\n \n   /* Determine if we need to save the link register.  */\n-  if (info_ptr->calls_p\n+  if (info->calls_p\n       || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t  && crtl->profile\n \t  && !TARGET_PROFILE_KERNEL)\n@@ -23714,23 +23691,22 @@ rs6000_stack_info (void)\n       || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n #endif\n       || rs6000_ra_ever_killed ())\n-    info_ptr->lr_save_p = 1;\n+    info->lr_save_p = 1;\n \n   using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n \t\t\t  && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n \t\t\t  && call_used_regs[STATIC_CHAIN_REGNUM]);\n-  info_ptr->savres_strategy = rs6000_savres_strategy (info_ptr,\n-\t\t\t\t\t\t      using_static_chain_p);\n-\n-  if (!(info_ptr->savres_strategy & SAVE_INLINE_GPRS)\n-      || !(info_ptr->savres_strategy & SAVE_INLINE_FPRS)\n-      || !(info_ptr->savres_strategy & SAVE_INLINE_VRS)\n-      || !(info_ptr->savres_strategy & REST_INLINE_GPRS)\n-      || !(info_ptr->savres_strategy & REST_INLINE_FPRS)\n-      || !(info_ptr->savres_strategy & REST_INLINE_VRS))\n-    info_ptr->lr_save_p = 1;\n-\n-  if (info_ptr->lr_save_p)\n+  info->savres_strategy = rs6000_savres_strategy (info, using_static_chain_p);\n+\n+  if (!(info->savres_strategy & SAVE_INLINE_GPRS)\n+      || !(info->savres_strategy & SAVE_INLINE_FPRS)\n+      || !(info->savres_strategy & SAVE_INLINE_VRS)\n+      || !(info->savres_strategy & REST_INLINE_GPRS)\n+      || !(info->savres_strategy & REST_INLINE_FPRS)\n+      || !(info->savres_strategy & REST_INLINE_VRS))\n+    info->lr_save_p = 1;\n+\n+  if (info->lr_save_p)\n     df_set_regs_ever_live (LR_REGNO, true);\n \n   /* Determine if we need to allocate any stack frame:\n@@ -23745,22 +23721,22 @@ rs6000_stack_info (void)\n      For V.4 we don't have the stack cushion that AIX uses, but assume\n      that the debugger can handle stackless frames.  */\n \n-  if (info_ptr->calls_p)\n-    info_ptr->push_p = 1;\n+  if (info->calls_p)\n+    info->push_p = 1;\n \n   else if (DEFAULT_ABI == ABI_V4)\n-    info_ptr->push_p = non_fixed_size != 0;\n+    info->push_p = non_fixed_size != 0;\n \n   else if (frame_pointer_needed)\n-    info_ptr->push_p = 1;\n+    info->push_p = 1;\n \n   else if (TARGET_XCOFF && write_symbols != NO_DEBUG)\n-    info_ptr->push_p = 1;\n+    info->push_p = 1;\n \n   else\n-    info_ptr->push_p = non_fixed_size > (TARGET_32BIT ? 220 : 288);\n+    info->push_p = non_fixed_size > (TARGET_32BIT ? 220 : 288);\n \n-  return info_ptr;\n+  return info;\n }\n \n /* Return true if the current function uses any GPRs in 64-bit SIMD"}]}