{"sha": "9474e8ab4a4f8b22a4411a0688cea4c870378425", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NGU4YWI0YTRmOGIyMmE0NDExYTA2ODhjZWE0Yzg3MDM3ODQyNQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-05-29T14:44:47Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-05-29T14:44:47Z"}, "message": "rtl.h (assign_stack_temp, [...]): Remove 'keep' argument.\n\n\t* rtl.h (assign_stack_temp, assign_stack_temp_for_type,\n\tassign_temp): Remove 'keep' argument.\n\t(mark_temp_addr_taken): Remove prototype.\n\t* tree.h (expand_decl): Remove prototype.\n\t* function.c (struct temp_slot): Remove addr_taken and keep\n\tmember.\n\t(assign_stack_temp_for_type) Don't initialize above, remove\n\tkeep argument.\n\t(assign_stack_temp, assign_temp): Remove keep argument.\n\t(mark_temp_addr_taken): Remove.\n\t(preserve_temp_slots): Remove handling of addr_taken and keep\n\tmembers.\n\t(free_temp_slots): Ditto.\n\t* expr.c (expand_expr_real_1 <COMPOUND_LITERAL_EXPR>): Remove\n\tdead code.\n\t* stmt.c (expand_asm_operands): Remove dead code.\n\t(expand_decl): Remove.\n\t* c-decl.c (finish_struct): Don't call expand_decl.\n\t* builtins.c (expand_builtin_cexpi): Adjust calls to assign_temp\n\tand assign_stack_temp.\n\t* calls.c (save_fixed_argument_area, initialize_argument_information,\n\texpand_call, emit_library_call_value_1, store_one_arg): Ditto.\n\t* expmed.c (extract_bit_field_1): Ditto.\n\t* expr.c (emit_group_load_1, emit_group_store,\n\tcopy_blkmode_from_reg, emit_push_insn, expand_assignment,\n\tstore_field, expand_constructor, expand_cond_expr_using_cmove,\n\texpand_expr_real_2, expand_expr_real_1): Ditto.\n\t* stmt.c (expand_asm_operands, expand_return): Ditto.\n\n\t* function.c (pop_temp_slots): Call free_temp_slots.\n\t* calls.c (store_one_arg): Don't call preserve_temp_slots or\n\tfree_temp_slots.\n\t* expr.c (expand_assignment): Don't call free_temp_slots.\n\n\t* config/arm/arm.c (neon_expand_vector_init): Ditto.\n\t* config/i386/i386.c (ix86_expand_vector_set): Ditto.\n\t(ix86_expand_vector_extract): Ditto.\n\t* config/ia64/ia64.c (spill_xfmode_rfmode_operand,\n\tia64_expand_movxf_movrf): Ditto.\n\t* config/mips/mips.c (mips_expand_vi_general): Ditto.\n\t* config/mmix/mmix.md (floatdisf2, floatunsdisf2, truncdfsf2,\n\textendsfdf2): Ditto.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init,\n\trs6000_expand_vector_set, rs6000_expand_vector_extract,\n\trs6000_allocate_stack_temp): Ditto.\n\t* config/rs6000/rs6000.md (fix_trunctfsi2_fprs): Ditto.\n\t* config/sparc/sparc.c (emit_soft_tfmode_libcall,\n\tsparc_emit_float_lib_cmp, sparc_emit_float_lib_cmp,\n\tsparc_expand_vector_init): Ditto.\n\nFrom-SVN: r187965", "tree": {"sha": "9cac16ca3b03c2c66c24eeab8ec66e412d413342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cac16ca3b03c2c66c24eeab8ec66e412d413342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9474e8ab4a4f8b22a4411a0688cea4c870378425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9474e8ab4a4f8b22a4411a0688cea4c870378425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9474e8ab4a4f8b22a4411a0688cea4c870378425", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9474e8ab4a4f8b22a4411a0688cea4c870378425/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca5f4331230013bba0a5e4d1c4340158b2991b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5f4331230013bba0a5e4d1c4340158b2991b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5f4331230013bba0a5e4d1c4340158b2991b65"}], "stats": {"total": 489, "additions": 132, "deletions": 357}, "files": [{"sha": "b883dca1d019c7e7d2ad5aca19c139068b6726f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -1,3 +1,55 @@\n+2012-05-29  Michael Matz  <matz@suse.de>\n+\n+\t* rtl.h (assign_stack_temp, assign_stack_temp_for_type,\n+\tassign_temp): Remove 'keep' argument.\n+\t(mark_temp_addr_taken): Remove prototype.\n+\t* tree.h (expand_decl): Remove prototype.\n+\t* function.c (struct temp_slot): Remove addr_taken and keep\n+\tmember.\n+\t(assign_stack_temp_for_type) Don't initialize above, remove\n+\tkeep argument.\n+\t(assign_stack_temp, assign_temp): Remove keep argument.\n+\t(mark_temp_addr_taken): Remove.\n+\t(preserve_temp_slots): Remove handling of addr_taken and keep\n+\tmembers.\n+\t(free_temp_slots): Ditto.\n+\t* expr.c (expand_expr_real_1 <COMPOUND_LITERAL_EXPR>): Remove\n+\tdead code.\n+\t* stmt.c (expand_asm_operands): Remove dead code.\n+\t(expand_decl): Remove.\n+\t* c-decl.c (finish_struct): Don't call expand_decl.\n+\t* builtins.c (expand_builtin_cexpi): Adjust calls to assign_temp\n+\tand assign_stack_temp.\n+\t* calls.c (save_fixed_argument_area, initialize_argument_information,\n+\texpand_call, emit_library_call_value_1, store_one_arg): Ditto.\n+\t* expmed.c (extract_bit_field_1): Ditto.\n+\t* expr.c (emit_group_load_1, emit_group_store,\n+\tcopy_blkmode_from_reg, emit_push_insn, expand_assignment,\n+\tstore_field, expand_constructor, expand_cond_expr_using_cmove,\n+\texpand_expr_real_2, expand_expr_real_1): Ditto.\n+\t* stmt.c (expand_asm_operands, expand_return): Ditto.\n+\n+\t* function.c (pop_temp_slots): Call free_temp_slots.\n+\t* calls.c (store_one_arg): Don't call preserve_temp_slots or\n+\tfree_temp_slots.\n+\t* expr.c (expand_assignment): Don't call free_temp_slots.\n+\n+\t* config/arm/arm.c (neon_expand_vector_init): Ditto.\n+\t* config/i386/i386.c (ix86_expand_vector_set): Ditto.\n+\t(ix86_expand_vector_extract): Ditto.\n+\t* config/ia64/ia64.c (spill_xfmode_rfmode_operand,\n+\tia64_expand_movxf_movrf): Ditto.\n+\t* config/mips/mips.c (mips_expand_vi_general): Ditto.\n+\t* config/mmix/mmix.md (floatdisf2, floatunsdisf2, truncdfsf2,\n+\textendsfdf2): Ditto.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_init,\n+\trs6000_expand_vector_set, rs6000_expand_vector_extract,\n+\trs6000_allocate_stack_temp): Ditto.\n+\t* config/rs6000/rs6000.md (fix_trunctfsi2_fprs): Ditto.\n+\t* config/sparc/sparc.c (emit_soft_tfmode_libcall,\n+\tsparc_emit_float_lib_cmp, sparc_emit_float_lib_cmp,\n+\tsparc_expand_vector_init): Ditto.\n+\n 2012-05-29  Michael Matz  <matz@suse.de>\n \n \t* c-tree.h (c_expand_decl): Remove prototype."}, {"sha": "b885f5f657b085d9fb3fcfaabe5335e9f1abe89e", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -2650,8 +2650,8 @@ expand_builtin_cexpi (tree exp, rtx target)\n       else\n \tgcc_unreachable ();\n \n-      op1 = assign_temp (TREE_TYPE (arg), 0, 1, 1);\n-      op2 = assign_temp (TREE_TYPE (arg), 0, 1, 1);\n+      op1 = assign_temp (TREE_TYPE (arg), 1, 1);\n+      op2 = assign_temp (TREE_TYPE (arg), 1, 1);\n       op1a = copy_addr_to_reg (XEXP (op1, 0));\n       op2a = copy_addr_to_reg (XEXP (op2, 0));\n       top1 = make_tree (build_pointer_type (TREE_TYPE (arg)), op1a);"}, {"sha": "29cd18c7dcd414a9d2d62d093392b98e794e7d5d", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -7317,8 +7317,6 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t  if (c_dialect_objc ())\n \t    objc_check_decl (decl);\n \t  rest_of_decl_compilation (decl, toplevel, 0);\n-\t  if (!toplevel)\n-\t    expand_decl (decl);\n \t}\n     }\n   C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t)) = 0;"}, {"sha": "d4bcd7b67d4fd3a950439d840cff2651c86180f1", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -933,7 +933,7 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n \tset_mem_align (stack_area, PARM_BOUNDARY);\n \tif (save_mode == BLKmode)\n \t  {\n-\t    save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t    save_area = assign_stack_temp (BLKmode, num_to_save);\n \t    emit_block_move (validize_mem (save_area), stack_area,\n \t\t\t     GEN_INT (num_to_save), BLOCK_OP_CALL_PARM);\n \t  }\n@@ -1258,7 +1258,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t  set_mem_attributes (copy, type, 1);\n \t\t}\n \t      else\n-\t\tcopy = assign_temp (type, 0, 1, 0);\n+\t\tcopy = assign_temp (type, 1, 0);\n \n \t      store_expr (args[i].tree_value, copy, 0, false);\n \n@@ -2404,7 +2404,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    /* For variable-sized objects, we must be called with a target\n \t       specified.  If we were to allocate space on the stack here,\n \t       we would have no way of knowing when to free it.  */\n-\t    rtx d = assign_temp (rettype, 0, 1, 1);\n+\t    rtx d = assign_temp (rettype, 1, 1);\n \t    structure_value_addr = XEXP (d, 0);\n \t    target = 0;\n \t  }\n@@ -3278,7 +3278,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t\t      (TYPE_QUALS (rettype)\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \n-\t      target = assign_temp (nt, 0, 1, 1);\n+\t      target = assign_temp (nt, 1, 1);\n \t    }\n \n \t  if (! rtx_equal_p (target, valreg))\n@@ -3694,7 +3694,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  if (value != 0 && MEM_P (value))\n \t    mem_value = value;\n \t  else\n-\t    mem_value = assign_temp (tfom, 0, 1, 1);\n+\t    mem_value = assign_temp (tfom, 1, 1);\n #endif\n \t  /* This call returns a big structure.  */\n \t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE);\n@@ -3809,7 +3809,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  else\n \t    {\n \t      slot = assign_temp (lang_hooks.types.type_for_mode (mode, 0),\n-\t\t\t\t  0, 1, 1);\n+\t\t\t\t  1, 1);\n \t      emit_move_insn (slot, val);\n \t    }\n \n@@ -4033,8 +4033,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t    {\n \t\t      argvec[argnum].save_area\n \t\t\t= assign_stack_temp (BLKmode,\n-\t\t\t\t\t     argvec[argnum].locate.size.constant,\n-\t\t\t\t\t     0);\n+\t\t\t\t\t     argvec[argnum].locate.size.constant\n+\t\t\t\t\t     );\n \n \t\t      emit_block_move (validize_mem (argvec[argnum].save_area),\n \t\t\t\t       stack_area,\n@@ -4444,7 +4444,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t  tree nt = build_qualified_type (ot, (TYPE_QUALS (ot)\n \t\t\t\t\t\t       | TYPE_QUAL_CONST));\n \n-\t\t  arg->save_area = assign_temp (nt, 0, 1, 1);\n+\t\t  arg->save_area = assign_temp (nt, 1, 1);\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n \t\t\t\t   GEN_INT (arg->locate.size.constant),\n@@ -4721,11 +4721,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n      be deferred during the rest of the arguments.  */\n   NO_DEFER_POP;\n \n-  /* Free any temporary slots made in processing this argument.  Show\n-     that we might have taken the address of something and pushed that\n-     as an operand.  */\n-  preserve_temp_slots (NULL_RTX);\n-  free_temp_slots ();\n+  /* Free any temporary slots made in processing this argument.  */\n   pop_temp_slots ();\n \n   return sibcall_failure;"}, {"sha": "cb7eed5ae58b2fb0db32feaf98b732a1b020e038", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -9459,7 +9459,7 @@ neon_expand_vector_init (rtx target, rtx vals)\n \n   /* Construct the vector in memory one field at a time\n      and load the whole vector.  */\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   for (i = 0; i < n_elts; i++)\n     emit_move_insn (adjust_address_nv (mem, inner_mode,\n \t\t\t\t    i * GET_MODE_SIZE (inner_mode)),"}, {"sha": "c6eb9628b3fca324d898e7bc666f68297dbd4d71", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -34410,7 +34410,7 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n     }\n   else\n     {\n-      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), false);\n+      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n \n       emit_move_insn (mem, target);\n \n@@ -34627,7 +34627,7 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n     }\n   else\n     {\n-      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), false);\n+      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n \n       emit_move_insn (mem, vec);\n "}, {"sha": "e49ee2c74da1f201d3e9ccf94e0a90dd3da5e058", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -1585,13 +1585,13 @@ spill_xfmode_rfmode_operand (rtx in, int force, enum machine_mode mode)\n       && GET_MODE (SUBREG_REG (in)) == TImode\n       && GET_CODE (SUBREG_REG (in)) == REG)\n     {\n-      rtx memt = assign_stack_temp (TImode, 16, 0);\n+      rtx memt = assign_stack_temp (TImode, 16);\n       emit_move_insn (memt, SUBREG_REG (in));\n       return adjust_address (memt, mode, 0);\n     }\n   else if (force && GET_CODE (in) == REG)\n     {\n-      rtx memx = assign_stack_temp (mode, 16, 0);\n+      rtx memx = assign_stack_temp (mode, 16);\n       emit_move_insn (memx, in);\n       return memx;\n     }\n@@ -1716,7 +1716,7 @@ ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n \t    memt = adjust_address (in, TImode, 0);\n \t  else\n \t    {\n-\t      memt = assign_stack_temp (TImode, 16, 0);\n+\t      memt = assign_stack_temp (TImode, 16);\n \t      memx = adjust_address (memt, mode, 0);\n \t      emit_move_insn (memx, in);\n \t    }"}, {"sha": "416c1aa41bb5fddc207c20a8493ca2ba9d641aa8", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -17201,7 +17201,7 @@ static void\n mips_expand_vi_general (enum machine_mode vmode, enum machine_mode imode,\n \t\t\tunsigned nelt, unsigned nvar, rtx target, rtx vals)\n {\n-  rtx mem = assign_stack_temp (vmode, GET_MODE_SIZE (vmode), 0);\n+  rtx mem = assign_stack_temp (vmode, GET_MODE_SIZE (vmode));\n   unsigned int i, isize = GET_MODE_SIZE (imode);\n \n   if (nvar < nelt)"}, {"sha": "1cd397a8a1458d9734b0c67957223ca77d96f68c", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -529,7 +529,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n \t better way.  */\n       stack_slot\n \t= validize_mem (assign_stack_temp (SFmode,\n-\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode)));\n       emit_insn (gen_floatdisf2 (stack_slot, operands[1]));\n       emit_move_insn (operands[0], stack_slot);\n       DONE;\n@@ -563,7 +563,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n \t way.  */\n       stack_slot\n \t= validize_mem (assign_stack_temp (SFmode,\n-\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode)));\n       emit_insn (gen_floatunsdisf2 (stack_slot, operands[1]));\n       emit_move_insn (operands[0], stack_slot);\n       DONE;\n@@ -645,7 +645,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n \t way.  */\n       stack_slot\n \t= validize_mem (assign_stack_temp (SFmode,\n-\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode)));\n       emit_insn (gen_truncdfsf2 (stack_slot, operands[1]));\n       emit_move_insn (operands[0], stack_slot);\n       DONE;\n@@ -678,7 +678,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n \t better way.  */\n       stack_slot\n \t= validize_mem (assign_stack_temp (SFmode,\n-\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode)));\n       emit_move_insn (stack_slot, operands[1]);\n       emit_insn (gen_extendsfdf2 (operands[0], stack_slot));\n       DONE;"}, {"sha": "a11aefd14fc19c16346b3d8b78da4002fb97653b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -4576,7 +4576,7 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n      of 64-bit items is not supported on Altivec.  */\n   if (all_same && GET_MODE_SIZE (inner_mode) <= 4)\n     {\n-      mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode), 0);\n+      mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode));\n       emit_move_insn (adjust_address_nv (mem, inner_mode, 0),\n \t\t      XVECEXP (vals, 0, 0));\n       x = gen_rtx_UNSPEC (VOIDmode,\n@@ -4612,7 +4612,7 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \n   /* Construct the vector in memory one field at a time\n      and load the whole vector.  */\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   for (i = 0; i < n_elts; i++)\n     emit_move_insn (adjust_address_nv (mem, inner_mode,\n \t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n@@ -4641,7 +4641,7 @@ rs6000_expand_vector_set (rtx target, rtx val, int elt)\n     }\n \n   /* Load single variable value.  */\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode), 0);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode));\n   emit_move_insn (adjust_address_nv (mem, inner_mode, 0), val);\n   x = gen_rtx_UNSPEC (VOIDmode,\n \t\t      gen_rtvec (1, const0_rtx), UNSPEC_LVE);\n@@ -4696,7 +4696,7 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n     }\n \n   /* Allocate mode-sized buffer.  */\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n \n   emit_move_insn (mem, vec);\n \n@@ -27812,7 +27812,7 @@ rs6000_allocate_stack_temp (enum machine_mode mode,\n \t\t\t    bool offsettable_p,\n \t\t\t    bool reg_reg_p)\n {\n-  rtx stack = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  rtx stack = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   rtx addr = XEXP (stack, 0);\n   int strict_p = (reload_in_progress || reload_completed);\n "}, {"sha": "ba4acb69de789afe58f1417095376767eb2d7acc", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -10038,7 +10038,7 @@\n   operands[2] = gen_reg_rtx (DFmode);\n   operands[3] = gen_reg_rtx (DFmode);\n   operands[4] = gen_reg_rtx (DImode);\n-  operands[5] = assign_stack_temp (DImode, GET_MODE_SIZE (DImode), 0);\n+  operands[5] = assign_stack_temp (DImode, GET_MODE_SIZE (DImode));\n })\n \n (define_insn_and_split \"*fix_trunctfsi2_internal\""}, {"sha": "ede3a5574fe14233eb7f7ebc075c98dda88de084", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -9044,6 +9044,7 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   lab_false = create_artificial_label (UNKNOWN_LOCATION);\n   lab_over = create_artificial_label (UNKNOWN_LOCATION);\n   addr = create_tmp_var (ptr_type_node, \"addr\");\n+  mark_sym_for_renaming (addr);\n \n   t = fold_convert (TREE_TYPE (reg), size_int (max_reg));\n   t = build2 (GT_EXPR, boolean_type_node, reg, t);"}, {"sha": "54fce8f6ddb20cb272769c7ccb3c57628b47f939", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -2738,7 +2738,7 @@ emit_soft_tfmode_libcall (const char *func_name, int nargs, rtx *operands)\n \t    }\n \t  else\n \t    {\n-\t      this_slot = assign_stack_temp (TFmode, GET_MODE_SIZE (TFmode), 0);\n+\t      this_slot = assign_stack_temp (TFmode, GET_MODE_SIZE (TFmode));\n \n \t      /* Operand 0 is the return value.  We'll copy it out later.  */\n \t      if (i > 0)\n@@ -7431,7 +7431,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \t}\n       else\n \t{\n-\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode));\n \t  emit_move_insn (slot0, x);\n \t}\n \n@@ -7444,7 +7444,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \t}\n       else\n \t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode));\n \t  emit_move_insn (slot1, y);\n \t}\n \n@@ -11631,7 +11631,7 @@ sparc_expand_vector_init (rtx target, rtx vals)\n \t}\n     }\n \n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   for (i = 0; i < n_elts; i++)\n     emit_move_insn (adjust_address_nv (mem, inner_mode,\n \t\t\t\t       i * GET_MODE_SIZE (inner_mode)),"}, {"sha": "a64138738975b9158fced670ee68fd8361ef9b3d", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -1351,7 +1351,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \telse\n \t  {\n \t    rtx mem = assign_stack_temp (GET_MODE (op0),\n-\t\t\t\t\t GET_MODE_SIZE (GET_MODE (op0)), 0);\n+\t\t\t\t\t GET_MODE_SIZE (GET_MODE (op0)));\n \t    emit_move_insn (mem, op0);\n \t    op0 = adjust_address (mem, BLKmode, 0);\n \t  }"}, {"sha": "8d815c94836416c8ea8c493cadf4912064506dc2", "filename": "gcc/expr.c", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -1615,7 +1615,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n     {\n       enum machine_mode imode = int_mode_for_mode (GET_MODE (orig_src));\n       if (imode == BLKmode)\n-\tsrc = assign_stack_temp (GET_MODE (orig_src), ssize, 0);\n+\tsrc = assign_stack_temp (GET_MODE (orig_src), ssize);\n       else\n \tsrc = gen_reg_rtx (imode);\n       if (imode != BLKmode)\n@@ -1717,7 +1717,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t      rtx mem;\n \n \t      gcc_assert (!bytepos);\n-\t      mem = assign_stack_temp (GET_MODE (src), slen, 0);\n+\t      mem = assign_stack_temp (GET_MODE (src), slen);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = extract_bit_field (mem, bytelen * BITS_PER_UNIT,\n \t\t\t\t\t   0, 1, false, NULL_RTX, mode, mode);\n@@ -1732,7 +1732,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t  int slen = GET_MODE_SIZE (GET_MODE (src));\n \t  rtx mem;\n \n-\t  mem = assign_stack_temp (GET_MODE (src), slen, 0);\n+\t  mem = assign_stack_temp (GET_MODE (src), slen);\n \t  emit_move_insn (mem, src);\n \t  tmps[i] = adjust_address (mem, mode, (int) bytepos);\n \t}\n@@ -1883,7 +1883,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     {\n       enum machine_mode imode = int_mode_for_mode (GET_MODE (orig_dst));\n       if (imode == BLKmode)\n-        dst = assign_stack_temp (GET_MODE (orig_dst), ssize, 0);\n+        dst = assign_stack_temp (GET_MODE (orig_dst), ssize);\n       else\n         dst = gen_reg_rtx (imode);\n       emit_group_store (dst, src, type, ssize);\n@@ -1933,7 +1933,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t it.  Allocate a temporary, and split this into a store/load to/from\n \t the temporary.  */\n \n-      temp = assign_stack_temp (GET_MODE (dst), ssize, 0);\n+      temp = assign_stack_temp (GET_MODE (dst), ssize);\n       emit_group_store (temp, src, type, ssize);\n       emit_group_load (dst, temp, type, ssize);\n       return;\n@@ -2028,8 +2028,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t\t  >= GET_MODE_ALIGNMENT (tmp_mode))\n \t\t{\n \t\t  dest = assign_stack_temp (dest_mode,\n-\t\t\t\t\t    GET_MODE_SIZE (dest_mode),\n-\t\t\t\t\t    0);\n+\t\t\t\t\t    GET_MODE_SIZE (dest_mode));\n \t\t  emit_move_insn (adjust_address (dest,\n \t\t\t\t\t\t  tmp_mode,\n \t\t\t\t\t\t  bytepos),\n@@ -2039,8 +2038,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t      else\n \t\t{\n \t\t  dest = assign_stack_temp (tmp_mode,\n-\t\t\t\t\t    GET_MODE_SIZE (tmp_mode),\n-\t\t\t\t\t    0);\n+\t\t\t\t\t    GET_MODE_SIZE (tmp_mode));\n \t\t  emit_move_insn (dest, tmps[i]);\n \t\t  dst = adjust_address (dest, dest_mode, bytepos);\n \t\t}\n@@ -2108,7 +2106,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n       tgtblk = assign_temp (build_qualified_type (type,\n \t\t\t\t\t\t  (TYPE_QUALS (type)\n \t\t\t\t\t\t   | TYPE_QUAL_CONST)),\n-\t\t\t    0, 1, 1);\n+\t\t\t    1, 1);\n       preserve_temp_slots (tgtblk);\n     }\n \n@@ -4030,7 +4028,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t  size = GEN_INT (GET_MODE_SIZE (mode));\n \t  if (!MEM_P (xinner))\n \t    {\n-\t      temp = assign_temp (type, 0, 1, 1);\n+\t      temp = assign_temp (type, 1, 1);\n \t      emit_move_insn (temp, xinner);\n \t      xinner = temp;\n \t    }\n@@ -4782,8 +4780,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  else\n \t    {\n \t      rtx temp = assign_stack_temp (GET_MODE (to_rtx),\n-\t\t\t\t\t    GET_MODE_SIZE (GET_MODE (to_rtx)),\n-\t\t\t\t\t    0);\n+\t\t\t\t\t    GET_MODE_SIZE (GET_MODE (to_rtx)));\n \t      write_complex_part (temp, XEXP (to_rtx, 0), false);\n \t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n \t      result = store_field (temp, bitsize, bitpos,\n@@ -4839,7 +4836,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       if (result)\n \tpreserve_temp_slots (result);\n-      free_temp_slots ();\n       pop_temp_slots ();\n       return;\n     }\n@@ -4887,7 +4883,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  emit_move_insn (to_rtx, value);\n \t}\n       preserve_temp_slots (to_rtx);\n-      free_temp_slots ();\n       pop_temp_slots ();\n       return;\n     }\n@@ -4914,7 +4909,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \temit_move_insn (to_rtx, temp);\n \n       preserve_temp_slots (to_rtx);\n-      free_temp_slots ();\n       pop_temp_slots ();\n       return;\n     }\n@@ -4944,7 +4938,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t TYPE_MODE (sizetype));\n \n       preserve_temp_slots (to_rtx);\n-      free_temp_slots ();\n       pop_temp_slots ();\n       return;\n     }\n@@ -4954,7 +4947,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   push_temp_slots ();\n   result = store_expr (from, to_rtx, 0, nontemporal);\n   preserve_temp_slots (result);\n-  free_temp_slots ();\n   pop_temp_slots ();\n   return;\n }\n@@ -6314,7 +6306,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n   if (mode == BLKmode\n       && (REG_P (target) || GET_CODE (target) == SUBREG))\n     {\n-      rtx object = assign_temp (type, 0, 1, 1);\n+      rtx object = assign_temp (type, 1, 1);\n       rtx blk_object = adjust_address (object, BLKmode, 0);\n \n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n@@ -7768,7 +7760,7 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n \t= assign_temp (build_qualified_type (type, (TYPE_QUALS (type)\n \t\t\t\t\t\t    | (TREE_READONLY (exp)\n \t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n-\t\t       0, TREE_ADDRESSABLE (exp), 1);\n+\t\t       TREE_ADDRESSABLE (exp), 1);\n     }\n \n   store_constructor (exp, target, 0, int_expr_size (exp));\n@@ -7892,7 +7884,7 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n   int unsignedp = TYPE_UNSIGNED (type);\n   enum machine_mode mode = TYPE_MODE (type);\n \n-  temp = assign_temp (type, 0, 0, 1);\n+  temp = assign_temp (type, 0, 1);\n \n   /* If we cannot do a conditional move on the mode, try doing it\n      with the promoted mode. */\n@@ -8050,7 +8042,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t      if (TYPE_MODE (type) != BLKmode)\n \t\ttarget = gen_reg_rtx (TYPE_MODE (type));\n \t      else\n-\t\ttarget = assign_temp (type, 0, 1, 1);\n+\t\ttarget = assign_temp (type, 1, 1);\n \t    }\n \n \t  if (MEM_P (target))\n@@ -9037,7 +9029,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  && !MEM_P (original_target))\n \ttemp = original_target;\n       else\n-\ttemp = assign_temp (type, 0, 0, 1);\n+\ttemp = assign_temp (type, 0, 1);\n \n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n@@ -9288,7 +9280,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       /* This is the case of an array whose size is to be determined\n \t from its initializer, while the initializer is still being parsed.\n-\t See expand_decl.  */\n+\t ??? We aren't parsing while expanding anymore.  */\n \n       if (MEM_P (decl_rtl) && REG_P (XEXP (decl_rtl, 0)))\n \ttemp = validize_mem (decl_rtl);\n@@ -9563,8 +9555,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    else\n \t      {\n \t\ttemp = assign_stack_temp (DECL_MODE (base),\n-\t\t\t\t\t  GET_MODE_SIZE (DECL_MODE (base)),\n-\t\t\t\t\t  0);\n+\t\t\t\t\t  GET_MODE_SIZE (DECL_MODE (base)));\n \t\tstore_expr (base, temp, 0, false);\n \t\ttemp = adjust_address (temp, BLKmode, offset);\n \t\tset_mem_size (temp, int_size_in_bytes (TREE_TYPE (exp)));\n@@ -9922,7 +9913,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    tree nt = build_qualified_type (TREE_TYPE (tem),\n \t\t\t\t\t    (TYPE_QUALS (TREE_TYPE (tem))\n \t\t\t\t\t     | TYPE_QUAL_CONST));\n-\t    memloc = assign_temp (nt, 0, 1, 1);\n+\t    memloc = assign_temp (nt, 1, 1);\n \t    emit_move_insn (memloc, op0);\n \t    op0 = memloc;\n \t    mem_attrs_from_type = true;\n@@ -10029,7 +10020,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    if (ext_mode == BLKmode)\n \t      {\n \t\tif (target == 0)\n-\t\t  target = assign_temp (type, 0, 1, 1);\n+\t\t  target = assign_temp (type, 1, 1);\n \n \t\tif (bitsize == 0)\n \t\t  return target;\n@@ -10085,7 +10076,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t\tnew_rtx = assign_stack_temp_for_type (ext_mode,\n \t\t\t\t\t\t   GET_MODE_BITSIZE (ext_mode),\n-\t\t\t\t\t\t   0, type);\n+\t\t\t\t\t\t   type);\n \t\temit_move_insn (new_rtx, op0);\n \t\top0 = copy_rtx (new_rtx);\n \t\tPUT_MODE (op0, BLKmode);\n@@ -10277,7 +10268,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    target\n \t      = assign_stack_temp_for_type\n \t\t(TYPE_MODE (inner_type),\n-\t\t GET_MODE_SIZE (TYPE_MODE (inner_type)), 0, inner_type);\n+\t\t GET_MODE_SIZE (TYPE_MODE (inner_type)), inner_type);\n \n \t  emit_move_insn (target, op0);\n \t  op0 = target;\n@@ -10324,7 +10315,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t= MAX (int_size_in_bytes (inner_type),\n \t\t       (HOST_WIDE_INT) GET_MODE_SIZE (mode));\n \t      rtx new_rtx\n-\t\t= assign_stack_temp_for_type (mode, temp_size, 0, type);\n+\t\t= assign_stack_temp_for_type (mode, temp_size, type);\n \t      rtx new_with_op0_mode\n \t\t= adjust_address (new_rtx, GET_MODE (op0), 0);\n \n@@ -10440,28 +10431,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return expand_expr_real (treeop0, original_target, tmode,\n \t\t\t       modifier, alt_rtl);\n \n-#if 0\n-      {\n-\t/* Initialize the anonymous variable declared in the compound\n-\t   literal, then return the variable.  */\n-\ttree decl = COMPOUND_LITERAL_EXPR_DECL (exp);\n-\n-\t/* Create RTL for this variable.  */\n-\tif (!DECL_RTL_SET_P (decl))\n-\t  {\n-\t    if (DECL_HARD_REGISTER (decl))\n-\t      /* The user specified an assembler name for this variable.\n-\t         Set that up now.  */\n-\t      rest_of_decl_compilation (decl, 0, 0);\n-\t    else\n-\t      expand_decl (decl);\n-\t  }\n-\n-\treturn expand_expr_real (decl, original_target, tmode,\n-\t\t\t\t modifier, alt_rtl);\n-      }\n-#endif\n-\n     default:\n       return expand_expr_real_2 (&ops, target, tmode, modifier);\n     }"}, {"sha": "87edf7abbcd893ac5ce97f666793c671acded03a", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 122, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -527,7 +527,6 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n   return assign_stack_local_1 (mode, size, align, ASLK_RECORD_PAD);\n }\n \f\n-\f\n /* In order to evaluate some expressions, such as function calls returning\n    structures in memory, we need to temporarily allocate stack locations.\n    We record each allocated temporary in the following structure.\n@@ -540,11 +539,7 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n    result could be in a temporary, we preserve it if we can determine which\n    one it is in.  If we cannot determine which temporary may contain the\n    result, all temporaries are preserved.  A temporary is preserved by\n-   pretending it was allocated at the previous nesting level.\n-\n-   Automatic variables are also assigned temporary slots, at the nesting\n-   level where they are defined.  They are marked a \"kept\" so that\n-   free_temp_slots will not free them.  */\n+   pretending it was allocated at the previous nesting level.  */\n \n struct GTY(()) temp_slot {\n   /* Points to next temporary slot.  */\n@@ -564,12 +559,8 @@ struct GTY(()) temp_slot {\n   unsigned int align;\n   /* Nonzero if this temporary is currently in use.  */\n   char in_use;\n-  /* Nonzero if this temporary has its address taken.  */\n-  char addr_taken;\n   /* Nesting level at which this slot is being used.  */\n   int level;\n-  /* Nonzero if this should survive a call to free_temp_slots.  */\n-  int keep;\n   /* The offset of the slot from the frame_pointer, including extra space\n      for alignment.  This info is for combine_temp_slots.  */\n   HOST_WIDE_INT base_offset;\n@@ -775,17 +766,11 @@ find_temp_slot_from_address (rtx x)\n    SIZE is the size in units of the space required.  We do no rounding here\n    since assign_stack_local will do any required rounding.\n \n-   KEEP is 1 if this slot is to be retained after a call to\n-   free_temp_slots.  Automatic variables for a block are allocated\n-   with this flag.  KEEP values of 2 or 3 were needed respectively\n-   for variables whose lifetime is controlled by CLEANUP_POINT_EXPRs\n-   or for SAVE_EXPRs, but they are now unused.\n-\n    TYPE is the type that will be used for the stack slot.  */\n \n rtx\n assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n-\t\t\t    int keep, tree type)\n+\t\t\t    tree type)\n {\n   unsigned int align;\n   struct temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n@@ -795,9 +780,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n      of a variable size.  */\n   gcc_assert (size != -1);\n \n-  /* These are now unused.  */\n-  gcc_assert (keep <= 1);\n-\n   align = get_stack_local_alignment (type, mode);\n \n   /* Try to find an available, already-allocated temporary of the proper\n@@ -846,7 +828,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n \t      p = ggc_alloc_temp_slot ();\n-\t      p->in_use = p->addr_taken = 0;\n+\t      p->in_use = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n \t      p->full_size = best_p->full_size - rounded_size;\n@@ -918,10 +900,8 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \n   p = selected;\n   p->in_use = 1;\n-  p->addr_taken = 0;\n   p->type = type;\n   p->level = temp_slot_level;\n-  p->keep = keep;\n \n   pp = temp_slots_at_level (p->level);\n   insert_slot_to_list (p, pp);\n@@ -946,26 +926,25 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n }\n \n /* Allocate a temporary stack slot and record it for possible later\n-   reuse.  First three arguments are same as in preceding function.  */\n+   reuse.  First two arguments are same as in preceding function.  */\n \n rtx\n-assign_stack_temp (enum machine_mode mode, HOST_WIDE_INT size, int keep)\n+assign_stack_temp (enum machine_mode mode, HOST_WIDE_INT size)\n {\n-  return assign_stack_temp_for_type (mode, size, keep, NULL_TREE);\n+  return assign_stack_temp_for_type (mode, size, NULL_TREE);\n }\n \f\n /* Assign a temporary.\n    If TYPE_OR_DECL is a decl, then we are doing it on behalf of the decl\n    and so that should be used in error messages.  In either case, we\n    allocate of the given type.\n-   KEEP is as for assign_stack_temp.\n    MEMORY_REQUIRED is 1 if the result must be addressable stack memory;\n    it is 0 if a register is OK.\n    DONT_PROMOTE is 1 if we should not promote values in register\n    to wider modes.  */\n \n rtx\n-assign_temp (tree type_or_decl, int keep, int memory_required,\n+assign_temp (tree type_or_decl, int memory_required,\n \t     int dont_promote ATTRIBUTE_UNUSED)\n {\n   tree type, decl;\n@@ -1011,7 +990,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n \t  size = 1;\n \t}\n \n-      tmp = assign_stack_temp_for_type (mode, size, keep, type);\n+      tmp = assign_stack_temp_for_type (mode, size, type);\n       return tmp;\n     }\n \n@@ -1139,32 +1118,10 @@ update_temp_slot_address (rtx old_rtx, rtx new_rtx)\n   insert_temp_slot_address (new_rtx, p);\n }\n \n-/* If X could be a reference to a temporary slot, mark the fact that its\n-   address was taken.  */\n-\n-void\n-mark_temp_addr_taken (rtx x)\n-{\n-  struct temp_slot *p;\n-\n-  if (x == 0)\n-    return;\n-\n-  /* If X is not in memory or is at a constant address, it cannot be in\n-     a temporary slot.  */\n-  if (!MEM_P (x) || CONSTANT_P (XEXP (x, 0)))\n-    return;\n-\n-  p = find_temp_slot_from_address (XEXP (x, 0));\n-  if (p != 0)\n-    p->addr_taken = 1;\n-}\n-\n /* If X could be a reference to a temporary slot, mark that slot as\n    belonging to the to one level higher than the current level.  If X\n    matched one of our slots, just mark that one.  Otherwise, we can't\n-   easily predict which it is, so upgrade all of them.  Kept slots\n-   need not be touched.\n+   easily predict which it is, so upgrade all of them.\n \n    This is called when an ({...}) construct occurs and a statement\n    returns a value in memory.  */\n@@ -1174,77 +1131,35 @@ preserve_temp_slots (rtx x)\n {\n   struct temp_slot *p = 0, *next;\n \n-  /* If there is no result, we still might have some objects whose address\n-     were taken, so we need to make sure they stay around.  */\n   if (x == 0)\n-    {\n-      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-\t{\n-\t  next = p->next;\n-\n-\t  if (p->addr_taken)\n-\t    move_slot_to_level (p, temp_slot_level - 1);\n-\t}\n-\n-      return;\n-    }\n+    return;\n \n   /* If X is a register that is being used as a pointer, see if we have\n-     a temporary slot we know it points to.  To be consistent with\n-     the code below, we really should preserve all non-kept slots\n-     if we can't find a match, but that seems to be much too costly.  */\n+     a temporary slot we know it points to.  */\n   if (REG_P (x) && REG_POINTER (x))\n     p = find_temp_slot_from_address (x);\n \n   /* If X is not in memory or is at a constant address, it cannot be in\n-     a temporary slot, but it can contain something whose address was\n-     taken.  */\n+     a temporary slot.  */\n   if (p == 0 && (!MEM_P (x) || CONSTANT_P (XEXP (x, 0))))\n-    {\n-      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-\t{\n-\t  next = p->next;\n-\n-\t  if (p->addr_taken)\n-\t    move_slot_to_level (p, temp_slot_level - 1);\n-\t}\n-\n-      return;\n-    }\n+    return;\n \n   /* First see if we can find a match.  */\n   if (p == 0)\n     p = find_temp_slot_from_address (XEXP (x, 0));\n \n   if (p != 0)\n     {\n-      /* Move everything at our level whose address was taken to our new\n-\t level in case we used its address.  */\n-      struct temp_slot *q;\n-\n       if (p->level == temp_slot_level)\n-\t{\n-\t  for (q = *temp_slots_at_level (temp_slot_level); q; q = next)\n-\t    {\n-\t      next = q->next;\n-\n-\t      if (p != q && q->addr_taken)\n-\t\tmove_slot_to_level (q, temp_slot_level - 1);\n-\t    }\n-\n-\t  move_slot_to_level (p, temp_slot_level - 1);\n-\t  p->addr_taken = 0;\n-\t}\n+\tmove_slot_to_level (p, temp_slot_level - 1);\n       return;\n     }\n \n   /* Otherwise, preserve all non-kept slots at this level.  */\n   for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n     {\n       next = p->next;\n-\n-      if (!p->keep)\n-\tmove_slot_to_level (p, temp_slot_level - 1);\n+      move_slot_to_level (p, temp_slot_level - 1);\n     }\n }\n \n@@ -1260,12 +1175,8 @@ free_temp_slots (void)\n   for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n     {\n       next = p->next;\n-\n-      if (!p->keep)\n-\t{\n-\t  make_slot_available (p);\n-\t  some_available = true;\n-\t}\n+      make_slot_available (p);\n+      some_available = true;\n     }\n \n   if (some_available)\n@@ -1289,22 +1200,7 @@ push_temp_slots (void)\n void\n pop_temp_slots (void)\n {\n-  struct temp_slot *p, *next;\n-  bool some_available = false;\n-\n-  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-    {\n-      next = p->next;\n-      make_slot_available (p);\n-      some_available = true;\n-    }\n-\n-  if (some_available)\n-    {\n-      remove_unused_temp_slot_addresses ();\n-      combine_temp_slots ();\n-    }\n-\n+  free_temp_slots ();\n   temp_slot_level--;\n }\n "}, {"sha": "ae5157e54c065a49e495b6119e7c17a2169082c2", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -1730,10 +1730,9 @@ extern rtx assign_stack_local (enum machine_mode, HOST_WIDE_INT, int);\n #define ASLK_REDUCE_ALIGN 1\n #define ASLK_RECORD_PAD 2\n extern rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int, int);\n-extern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT, int);\n-extern rtx assign_stack_temp_for_type (enum machine_mode,\n-\t\t\t\t       HOST_WIDE_INT, int, tree);\n-extern rtx assign_temp (tree, int, int, int);\n+extern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT);\n+extern rtx assign_stack_temp_for_type (enum machine_mode, HOST_WIDE_INT, tree);\n+extern rtx assign_temp (tree, int, int);\n \n /* In emit-rtl.c */\n extern rtx emit_insn_before (rtx, rtx);\n@@ -2498,7 +2497,6 @@ extern void print_inline_rtx (FILE *, const_rtx, int);\n extern void reposition_prologue_and_epilogue_notes (void);\n extern int prologue_epilogue_contains (const_rtx);\n extern int sibcall_epilogue_contains (const_rtx);\n-extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n extern void maybe_copy_prologue_epilogue_insn (rtx, rtx);\n extern void set_return_jump_label (rtx);"}, {"sha": "4ad4d0f1e595f32e0ca61c17b8d319109c6680b8", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 136, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -827,7 +827,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t}\n       else\n \t{\n-\t  op = assign_temp (type, 0, 0, 1);\n+\t  op = assign_temp (type, 0, 1);\n \t  op = validize_mem (op);\n \t  if (!MEM_P (op) && TREE_CODE (TREE_VALUE (tail)) == SSA_NAME)\n \t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (TREE_VALUE (tail)), op);\n@@ -911,33 +911,6 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-#if 0\n-\t    {\n-\t      warning (0, \"use of memory input without lvalue in \"\n-\t\t       \"asm operand %d is deprecated\", i + noutputs);\n-\n-\t      if (CONSTANT_P (op))\n-\t\t{\n-\t\t  rtx mem = force_const_mem (TYPE_MODE (type), op);\n-\t\t  if (mem)\n-\t\t    op = validize_mem (mem);\n-\t\t  else\n-\t\t    op = force_reg (TYPE_MODE (type), op);\n-\t\t}\n-\t      if (REG_P (op)\n-\t\t  || GET_CODE (op) == SUBREG\n-\t\t  || GET_CODE (op) == CONCAT)\n-\t\t{\n-\t\t  tree qual_type = build_qualified_type (type,\n-\t\t\t\t\t\t\t (TYPE_QUALS (type)\n-\t\t\t\t\t\t\t  | TYPE_QUAL_CONST));\n-\t\t  rtx memloc = assign_temp (qual_type, 1, 1, 1);\n-\t\t  memloc = validize_mem (memloc);\n-\t\t  emit_move_insn (memloc, op);\n-\t\t  op = memloc;\n-\t\t}\n-\t    }\n-#endif\n \t}\n \n       generating_concat_p = old_generating_concat_p;\n@@ -1606,7 +1579,7 @@ expand_return (tree retval)\n       tree ot = TREE_TYPE (DECL_RESULT (current_function_decl));\n       tree nt = build_qualified_type (ot, TYPE_QUALS (ot) | TYPE_QUAL_CONST);\n \n-      val = assign_temp (nt, 0, 0, 1);\n+      val = assign_temp (nt, 0, 1);\n       val = expand_expr (retval_rhs, val, GET_MODE (val), EXPAND_NORMAL);\n       val = force_not_mem (val);\n       /* Return the calculated value.  */\n@@ -1692,113 +1665,6 @@ expand_nl_goto_receiver (void)\n   emit_insn (gen_blockage ());\n }\n \f\n-/* Generate RTL for the automatic variable declaration DECL.\n-   (Other kinds of declarations are simply ignored if seen here.)  */\n-\n-void\n-expand_decl (tree decl)\n-{\n-  tree type;\n-\n-  type = TREE_TYPE (decl);\n-\n-  /* For a CONST_DECL, set mode, alignment, and sizes from those of the\n-     type in case this node is used in a reference.  */\n-  if (TREE_CODE (decl) == CONST_DECL)\n-    {\n-      gcc_unreachable ();\n-      DECL_MODE (decl) = TYPE_MODE (type);\n-      DECL_ALIGN (decl) = TYPE_ALIGN (type);\n-      DECL_SIZE (decl) = TYPE_SIZE (type);\n-      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (type);\n-      return;\n-    }\n-\n-  /* Otherwise, only automatic variables need any expansion done.  Static and\n-     external variables, and external functions, will be handled by\n-     `assemble_variable' (called from finish_decl).  TYPE_DECL requires\n-     nothing.  PARM_DECLs are handled in `assign_parms'.  */\n-  if (TREE_CODE (decl) != VAR_DECL)\n-    return;\n-\n-  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n-    return;\n-\n-  gcc_unreachable ();\n-  /* Create the RTL representation for the variable.  */\n-\n-  if (type == error_mark_node)\n-    SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));\n-\n-  else if (DECL_SIZE (decl) == 0)\n-    {\n-      /* Variable with incomplete type.  */\n-      rtx x;\n-      if (DECL_INITIAL (decl) == 0)\n-\t/* Error message was already done; now avoid a crash.  */\n-\tx = gen_rtx_MEM (BLKmode, const0_rtx);\n-      else\n-\t/* An initializer is going to decide the size of this array.\n-\t   Until we know the size, represent its address with a reg.  */\n-\tx = gen_rtx_MEM (BLKmode, gen_reg_rtx (Pmode));\n-\n-      set_mem_attributes (x, decl, 1);\n-      SET_DECL_RTL (decl, x);\n-    }\n-  else if (use_register_for_decl (decl))\n-    {\n-      /* Automatic variable that can go in a register.  */\n-      enum machine_mode reg_mode = promote_decl_mode (decl, NULL);\n-\n-      SET_DECL_RTL (decl, gen_reg_rtx (reg_mode));\n-\n-      /* Note if the object is a user variable.  */\n-      if (!DECL_ARTIFICIAL (decl))\n-\t  mark_user_reg (DECL_RTL (decl));\n-\n-      if (POINTER_TYPE_P (type))\n-\tmark_reg_pointer (DECL_RTL (decl),\n-\t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n-    }\n-\n-  else\n-    {\n-      rtx oldaddr = 0;\n-      rtx addr;\n-      rtx x;\n-\n-      /* Variable-sized decls are dealt with in the gimplifier.  */\n-      gcc_assert (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST);\n-\n-      /* If we previously made RTL for this decl, it must be an array\n-\t whose size was determined by the initializer.\n-\t The old address was a register; set that register now\n-\t to the proper address.  */\n-      if (DECL_RTL_SET_P (decl))\n-\t{\n-\t  gcc_assert (MEM_P (DECL_RTL (decl)));\n-\t  gcc_assert (REG_P (XEXP (DECL_RTL (decl), 0)));\n-\t  oldaddr = XEXP (DECL_RTL (decl), 0);\n-\t}\n-\n-      /* Set alignment we actually gave this decl.  */\n-      DECL_ALIGN (decl) = (DECL_MODE (decl) == BLKmode ? BIGGEST_ALIGNMENT\n-\t\t\t   : GET_MODE_BITSIZE (DECL_MODE (decl)));\n-      DECL_USER_ALIGN (decl) = 0;\n-\n-      x = assign_temp (decl, 1, 1, 1);\n-      set_mem_attributes (x, decl, 1);\n-      SET_DECL_RTL (decl, x);\n-\n-      if (oldaddr)\n-\t{\n-\t  addr = force_operand (XEXP (DECL_RTL (decl), 0), oldaddr);\n-\t  if (addr != oldaddr)\n-\t    emit_move_insn (oldaddr, addr);\n-\t}\n-    }\n-}\n-\f\n /* Emit code to save the current value of stack.  */\n rtx\n expand_stack_save (void)"}, {"sha": "94750b0b716e00c8a59e5348be0f5ea25751798b", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9474e8ab4a4f8b22a4411a0688cea4c870378425/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9474e8ab4a4f8b22a4411a0688cea4c870378425", "patch": "@@ -5693,7 +5693,6 @@ extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n extern bool expand_switch_using_bit_tests_p (tree, tree, unsigned int,\n \t\t\t\t\t     unsigned int);\n extern void expand_case (gimple);\n-extern void expand_decl (tree);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */\n extern tree tree_overlaps_hard_reg_set (tree, HARD_REG_SET *);"}]}