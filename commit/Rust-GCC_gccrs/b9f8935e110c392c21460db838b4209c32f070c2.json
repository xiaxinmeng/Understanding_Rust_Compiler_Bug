{"sha": "b9f8935e110c392c21460db838b4209c32f070c2", "node_id": "C_kwDOANBUbNoAKGI5Zjg5MzVlMTEwYzM5MmMyMTQ2MGRiODM4YjQyMDljMzJmMDcwYzI", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-02-10T00:42:47Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-02-10T00:42:47Z"}, "message": "c: Allow conversions of null pointer constants to nullptr_t\n\nWG14 has agreed to allow conversions (explicit and implicit) from null\npointer constants to nullptr_t; update GCC's nullptr_t implementation\nto match.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c/\n\t* c-convert.cc (c_convert): Allow conversion of a null pointer\n\tconstant to nullptr_t.\n\t* c-typeck.cc (null_pointer_constant_p): Remove static.\n\t(convert_for_assignment): Allow conversion of a null pointer\n\tconstant to nullptr_t.\n\t(digest_init): Handle NULLPTR_TYPE among scalar conversions.\n\t* c-tree.h (null_pointer_constant_p): Declare.\n\ngcc/testsuite/\n\t* gcc.dg/c2x-nullptr-1.c: Test conversion of null pointer\n\tconstants to nullptr_t.\n\t* gcc.dg/c2x-nullptr-3.c: Do not expect errors for conversion of\n\tnull pointer constants to nullptr_t.  Do test errors for\n\tconversion of other values to nullptr_t and for unary '+' on\n\tnullptr_t.", "tree": {"sha": "329ad18e382724a5d148e1cb74b5f66fec86d69e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329ad18e382724a5d148e1cb74b5f66fec86d69e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9f8935e110c392c21460db838b4209c32f070c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f8935e110c392c21460db838b4209c32f070c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f8935e110c392c21460db838b4209c32f070c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f8935e110c392c21460db838b4209c32f070c2/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41015797ad14bc9030a87d102e4ab1ad891345f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41015797ad14bc9030a87d102e4ab1ad891345f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41015797ad14bc9030a87d102e4ab1ad891345f6"}], "stats": {"total": 64, "additions": 48, "deletions": 16}, "files": [{"sha": "0f35dc4fe9a93bc14a5ba368c80de8f8e7e8d837", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=b9f8935e110c392c21460db838b4209c32f070c2", "patch": "@@ -157,6 +157,19 @@ c_convert (tree type, tree expr, bool init_const)\n       ret = convert_to_pointer (type, e);\n       goto maybe_fold;\n \n+    case NULLPTR_TYPE:\n+      /* A null pointer constant or value of type nullptr_t may be\n+\t converted to nullptr_t.  The latter case has already been\n+\t handled.  build_c_cast will create an additional NOP_EXPR to\n+\t ensure the result of the conversion is not itself a null\n+\t pointer constant.  */\n+      if (null_pointer_constant_p (expr))\n+\t{\n+\t  ret = build_int_cst (type, 0);\n+\t  goto maybe_fold;\n+\t}\n+      break;\n+\n     case REAL_TYPE:\n       ret = convert_to_real (type, e);\n       goto maybe_fold;\n@@ -201,12 +214,14 @@ c_convert (tree type, tree expr, bool init_const)\n     }\n \n   /* If we are converting to nullptr_t, don't say \"non-scalar type\" because\n-     the nullptr_t type is a scalar type.  Only nullptr_t shall be converted\n-     to nullptr_t.  */\n+     the nullptr_t type is a scalar type.  Only nullptr_t or a null pointer\n+     constant shall be converted to nullptr_t.  */\n   if (code == NULLPTR_TYPE)\n     {\n       error (\"conversion from %qT to %qT\", TREE_TYPE (e), type);\n-      inform (input_location, \"only %qT can be converted to %qT\", type, type);\n+      inform (input_location,\n+\t      \"only %qT or a null pointer constant can be converted to %qT\",\n+\t      type, type);\n     }\n   else\n     error (\"conversion to non-scalar type requested\");"}, {"sha": "e5eefe6bbba0af3cfda7a9f85b0fdca035b36c8e", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=b9f8935e110c392c21460db838b4209c32f070c2", "patch": "@@ -728,6 +728,7 @@ extern location_t c_last_sizeof_loc;\n \n extern struct c_switch *c_switch_stack;\n \n+extern bool null_pointer_constant_p (const_tree);\n extern bool char_type_p (tree);\n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (location_t, tree);"}, {"sha": "e37b0973cd69a264687f2a177a73be23f03dcb60", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=b9f8935e110c392c21460db838b4209c32f070c2", "patch": "@@ -89,7 +89,6 @@ static bool require_constant_value;\n static bool require_constant_elements;\n static bool require_constexpr_value;\n \n-static bool null_pointer_constant_p (const_tree);\n static tree qualify_type (tree, tree);\n static int tagged_types_tu_compatible_p (const_tree, const_tree, bool *,\n \t\t\t\t\t bool *);\n@@ -130,7 +129,7 @@ static int comptypes_internal (const_tree, const_tree, bool *, bool *);\n \f\n /* Return true if EXP is a null pointer constant, false otherwise.  */\n \n-static bool\n+bool\n null_pointer_constant_p (const_tree expr)\n {\n   /* This should really operate on c_expr structures, but they aren't\n@@ -7837,6 +7836,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n       in_late_binary_op = save;\n       return ret;\n     }\n+  else if (codel == NULLPTR_TYPE && null_pointer_constant)\n+    return convert (type, rhs);\n \n   switch (errtype)\n     {\n@@ -8596,7 +8597,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE\n       || code == POINTER_TYPE || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE\n-      || code == COMPLEX_TYPE || code == VECTOR_TYPE)\n+      || code == COMPLEX_TYPE || code == VECTOR_TYPE || code == NULLPTR_TYPE)\n     {\n       tree unconverted_init = inside_init;\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE"}, {"sha": "4e440234d52a852802d62aa521a53467f832f0cd", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-1.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c?ref=b9f8935e110c392c21460db838b4209c32f070c2", "patch": "@@ -11,8 +11,9 @@ void f2 (int *) { }\n void f3 (_Bool) { }\n nullptr_t cmp (void) { return nullptr; }\n \n-/* The type nullptr_t shall not be converted to any type other than void, bool or\n-   a pointer type.  No type other than nullptr_t shall be converted to nullptr_t.  */\n+/* The type nullptr_t shall not be converted to any type other than void, bool\n+   or a pointer type.  No type other than nullptr_t or a null pointer constant\n+   shall be converted to nullptr_t.  */\n void\n test1 (void)\n {\n@@ -63,6 +64,17 @@ test1 (void)\n   (void) np2;\n   (void) cmp ();\n   (void)(nullptr_t) nullptr;\n+\n+  const nullptr_t n = 0;\n+  (void) (nullptr_t) 0;\n+\n+  f1 (0);\n+  f1 ((void *) 0);\n+  f1 (0L);\n+  nullptr_t n2;\n+  n2 = (void *) 0;\n+  n2 = 123 - 123;\n+  (void) n2;\n }\n \n /* Test valid comparison.  */"}, {"sha": "09d9856ef97fb5920c366595edc5e5df307dd80e", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-3.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f8935e110c392c21460db838b4209c32f070c2/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c?ref=b9f8935e110c392c21460db838b4209c32f070c2", "patch": "@@ -29,21 +29,24 @@ test2 (void)\n   float d = nullptr; /* { dg-error \"incompatible types\" } */\n   char arr[10] = { nullptr }; /* { dg-error \"incompatible types\" } */\n \n-  /* No type other than nullptr_t shall be converted to nullptr_t.  */\n-  const nullptr_t n = 0; /* { dg-error \"invalid initializer\" } */\n-  +(nullptr_t) 0; /* { dg-error \"conversion from .int. to .nullptr_t.\" } */\n-\n-  g (0); /* { dg-error \"incompatible type\" } */\n+  /* Unary '+' is not valid for nullptr.  */\n+  +nullptr; /* { dg-error \"wrong type argument to unary plus\" } */\n \n+  g (0.0); /* { dg-error \"incompatible type\" } */\n+  g (1); /* { dg-error \"incompatible type\" } */\n+  g ((int) (float) 0.0); /* { dg-error \"incompatible type\" } */\n   int i = 42 + nullptr; /* { dg-error \"invalid operands\" } */\n \n   /* The assignment of an object of type nullptr_t with a value of another\n-     type, even if the value is a null pointer constant, is a constraint\n+     type, other than a null pointer constant, is a constraint\n      violation.  */\n   nullptr_t m;\n-  m = 0; /* { dg-error \"incompatible types\" } */\n+  m = 1; /* { dg-error \"incompatible types\" } */\n+  m = 0.0; /* { dg-error \"incompatible types\" } */\n   (void) m;\n-  nullptr_t o = 0; /* { dg-error \"invalid initializer\" } */\n+  nullptr_t o = 1; /* { dg-error \"incompatible types\" } */\n+  (nullptr_t) 0.0; /* { dg-error \"conversion\" } */\n+  (nullptr_t) (int) (float) 0.0; /* { dg-error \"conversion\" } */\n \n   switch (nullptr); /* { dg-error \"switch quantity not an integer\" } */\n }"}]}