{"sha": "df4aa89a5e7acb315655f193e7f549e8d32367e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0YWE4OWE1ZTdhY2IzMTU2NTVmMTkzZTdmNTQ5ZThkMzIzNjdlMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-13T05:11:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-13T05:11:45Z"}, "message": "libgo: Update to weekly.2011-12-22.\n\nFrom-SVN: r183150", "tree": {"sha": "eb5eccc07097c5fcf940967f33ab84a7d47c96fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb5eccc07097c5fcf940967f33ab84a7d47c96fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df4aa89a5e7acb315655f193e7f549e8d32367e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4aa89a5e7acb315655f193e7f549e8d32367e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4aa89a5e7acb315655f193e7f549e8d32367e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4aa89a5e7acb315655f193e7f549e8d32367e2/comments", "author": null, "committer": null, "parents": [{"sha": "f83fa0bf8f411697ec908cfa86ee6faf4cd9c476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83fa0bf8f411697ec908cfa86ee6faf4cd9c476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83fa0bf8f411697ec908cfa86ee6faf4cd9c476"}], "stats": {"total": 4923, "additions": 3635, "deletions": 1288}, "files": [{"sha": "a70a926da107cd1b148f05be7a8395bd65fd7f78", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug229.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug229.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug229.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug229.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -12,9 +12,9 @@ func main() {\n \tvar t testing.T\n \t\n \t// make sure error mentions that\n-\t// ch is unexported, not just \"ch not found\".\n+\t// name is unexported, not just \"name not found\".\n \n-\tt.ch = nil\t// ERROR \"unexported\"\n+\tt.name = nil\t// ERROR \"unexported\"\n \t\n \tprintln(testing.anyLowercaseName(\"asdf\"))\t// ERROR \"unexported\" \"undefined: testing.anyLowercaseName\"\n }"}, {"sha": "96fb7f66498e0cd28d80c714a48bbd242a2c2302", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -1,4 +1,4 @@\n-82fdc445f2ff\n+4a8268927758\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "348a1cae8d2c4b570654372909ce34b08c32d9a1", "filename": "libgo/Makefile.am", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -279,8 +279,7 @@ toolexeclibgoimage_DATA = \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n \timage/png.gox \\\n-\timage/tiff.gox \\\n-\timage/ycbcr.gox\n+\timage/tiff.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n \n@@ -586,7 +585,8 @@ go_image_files = \\\n \tgo/image/format.go \\\n \tgo/image/geom.go \\\n \tgo/image/image.go \\\n-\tgo/image/names.go\n+\tgo/image/names.go \\\n+\tgo/image/ycbcr.go\n \n go_io_files = \\\n \tgo/io/multi.go \\\n@@ -654,10 +654,15 @@ if LIBGO_IS_LINUX\n go_net_fd_os_file = go/net/fd_linux.go\n go_net_newpollserver_file = go/net/newpollserver.go\n else # !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n+if LIBGO_IS_NETBSD\n+go_net_fd_os_file = go/net/fd_netbsd.go\n+go_net_newpollserver_file = go/net/newpollserver.go\n+else # !LIBGO_IS_NETBSD && !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n # By default use select with pipes.  Most systems should have\n # something better.\n go_net_fd_os_file = go/net/fd_select.go\n go_net_newpollserver_file = go/net/newpollserver.go\n+endif # !LIBGO_IS_NETBSD\n endif # !LIBGO_IS_LINUX\n endif # !LIBGO_IS_RTEMS\n \n@@ -688,8 +693,12 @@ endif\n if LIBGO_IS_LINUX\n go_net_interface_file = go/net/interface_linux.go\n else\n+if LIBGO_IS_NETBSD\n+go_net_interface_file = go/net/interface_netbsd.go\n+else\n go_net_interface_file = go/net/interface_stub.go\n endif\n+endif\n \n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n@@ -845,6 +854,7 @@ go_strconv_files = \\\n \tgo/strconv/atof.go \\\n \tgo/strconv/atoi.go \\\n \tgo/strconv/decimal.go \\\n+\tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n@@ -880,7 +890,8 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/example.go \\\n-\tgo/testing/testing.go\n+\tgo/testing/testing.go \\\n+\tgo/testing/wrapper.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n@@ -1197,7 +1208,9 @@ go_go_build_files = \\\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go \\\n-\tgo/go/doc/example.go\n+\tgo/go/doc/example.go \\\n+\tgo/go/doc/exports.go \\\n+\tgo/go/doc/filter.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1241,7 +1254,8 @@ go_image_bmp_files = \\\n \tgo/image/bmp/reader.go\n \n go_image_color_files = \\\n-\tgo/image/color/color.go\n+\tgo/image/color/color.go \\\n+\tgo/image/color/ycbcr.go\n \n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n@@ -1266,9 +1280,6 @@ go_image_tiff_files = \\\n \tgo/image/tiff/consts.go \\\n \tgo/image/tiff/reader.go\n \n-go_image_ycbcr_files = \\\n-\tgo/image/ycbcr/ycbcr.go\n-\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1318,6 +1329,7 @@ go_net_http_files = \\\n \tgo/net/http/filetransport.go \\\n \tgo/net/http/fs.go \\\n \tgo/net/http/header.go \\\n+\tgo/net/http/jar.go \\\n \tgo/net/http/lex.go \\\n \tgo/net/http/request.go \\\n \tgo/net/http/response.go \\\n@@ -1761,7 +1773,6 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \timage/tiff.lo \\\n-\timage/ycbcr.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n@@ -3066,16 +3077,6 @@ image/tiff/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/tiff/check\n \n-@go_include@ image/ycbcr.lo.dep\n-image/ycbcr.lo.dep: $(go_image_ycbcr_files)\n-\t$(BUILDDEPS)\n-image/ycbcr.lo: $(go_image_ycbcr_files)\n-\t$(BUILDPACKAGE)\n-image/ycbcr/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/ycbcr\n-\t@$(CHECK)\n-.PHONY: image/ycbcr/check\n-\n @go_include@ index/suffixarray.lo.dep\n index/suffixarray.lo.dep: $(go_index_suffixarray_files)\n \t$(BUILDDEPS)\n@@ -3728,8 +3729,6 @@ image/png.gox: image/png.lo\n \t$(BUILDGOX)\n image/tiff.gox: image/tiff.lo\n \t$(BUILDGOX)\n-image/ycbcr.gox: image/ycbcr.lo\n-\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n@@ -3938,11 +3937,11 @@ TEST_PACKAGES = \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n+\timage/color/check \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \timage/tiff/check \\\n-\timage/ycbcr/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\"}, {"sha": "6bf18475628d9d50994ab43f89a6e7f26c0addd3", "filename": "libgo/Makefile.in", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -167,20 +167,19 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n \tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n \timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n-\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n-\tmime/mime.lo mime/multipart.lo net/dict.lo net/http.lo \\\n-\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n-\told/netchan.lo old/regexp.lo old/template.lo \\\n-\t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n-\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n-\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n-\tsyscall/syscall.lo syscall/errno.lo syscall/wait.lo \\\n-\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n-\ttext/template/parse.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo unicode/utf16.lo \\\n-\tunicode/utf8.lo\n+\timage/jpeg.lo image/png.lo image/tiff.lo index/suffixarray.lo \\\n+\tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n+\tmath/cmplx.lo math/rand.lo mime/mime.lo mime/multipart.lo \\\n+\tnet/dict.lo net/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n+\tnet/textproto.lo net/url.lo old/netchan.lo old/regexp.lo \\\n+\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n+\tpath/filepath.lo regexp/syntax.lo net/rpc/jsonrpc.lo \\\n+\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n+\tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n+\tsyscall/wait.lo text/scanner.lo text/tabwriter.lo \\\n+\ttext/template.lo text/template/parse.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo testing/script.lo \\\n+\tunicode/utf16.lo unicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -732,8 +731,7 @@ toolexeclibgoimage_DATA = \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n \timage/png.gox \\\n-\timage/tiff.gox \\\n-\timage/ycbcr.gox\n+\timage/tiff.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n toolexeclibgoindex_DATA = \\\n@@ -972,7 +970,8 @@ go_image_files = \\\n \tgo/image/format.go \\\n \tgo/image/geom.go \\\n \tgo/image/image.go \\\n-\tgo/image/names.go\n+\tgo/image/names.go \\\n+\tgo/image/ycbcr.go\n \n go_io_files = \\\n \tgo/io/multi.go \\\n@@ -1034,10 +1033,12 @@ go_mime_files = \\\n \n # By default use select with pipes.  Most systems should have\n # something better.\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_select.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_select.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_netbsd.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_linux.go\n @LIBGO_IS_RTEMS_TRUE@go_net_fd_os_file = go/net/fd_select.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n@@ -1050,7 +1051,8 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n-@LIBGO_IS_LINUX_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_netbsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n@@ -1165,6 +1167,7 @@ go_strconv_files = \\\n \tgo/strconv/atof.go \\\n \tgo/strconv/atoi.go \\\n \tgo/strconv/decimal.go \\\n+\tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n@@ -1194,7 +1197,8 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/example.go \\\n-\tgo/testing/testing.go\n+\tgo/testing/testing.go \\\n+\tgo/testing/wrapper.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n@@ -1563,7 +1567,9 @@ go_go_build_files = \\\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go \\\n-\tgo/go/doc/example.go\n+\tgo/go/doc/example.go \\\n+\tgo/go/doc/exports.go \\\n+\tgo/go/doc/filter.go\n \n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n@@ -1614,7 +1620,8 @@ go_image_bmp_files = \\\n \tgo/image/bmp/reader.go\n \n go_image_color_files = \\\n-\tgo/image/color/color.go\n+\tgo/image/color/color.go \\\n+\tgo/image/color/ycbcr.go\n \n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n@@ -1639,9 +1646,6 @@ go_image_tiff_files = \\\n \tgo/image/tiff/consts.go \\\n \tgo/image/tiff/reader.go\n \n-go_image_ycbcr_files = \\\n-\tgo/image/ycbcr/ycbcr.go\n-\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1694,6 +1698,7 @@ go_net_http_files = \\\n \tgo/net/http/filetransport.go \\\n \tgo/net/http/fs.go \\\n \tgo/net/http/header.go \\\n+\tgo/net/http/jar.go \\\n \tgo/net/http/lex.go \\\n \tgo/net/http/request.go \\\n \tgo/net/http/response.go \\\n@@ -2043,7 +2048,6 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \timage/tiff.lo \\\n-\timage/ycbcr.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n@@ -2299,11 +2303,11 @@ TEST_PACKAGES = \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n+\timage/color/check \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \timage/tiff/check \\\n-\timage/ycbcr/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n@@ -5657,16 +5661,6 @@ image/tiff/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/tiff/check\n \n-@go_include@ image/ycbcr.lo.dep\n-image/ycbcr.lo.dep: $(go_image_ycbcr_files)\n-\t$(BUILDDEPS)\n-image/ycbcr.lo: $(go_image_ycbcr_files)\n-\t$(BUILDPACKAGE)\n-image/ycbcr/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/ycbcr\n-\t@$(CHECK)\n-.PHONY: image/ycbcr/check\n-\n @go_include@ index/suffixarray.lo.dep\n index/suffixarray.lo.dep: $(go_index_suffixarray_files)\n \t$(BUILDDEPS)\n@@ -6314,8 +6308,6 @@ image/png.gox: image/png.lo\n \t$(BUILDGOX)\n image/tiff.gox: image/tiff.lo\n \t$(BUILDGOX)\n-image/ycbcr.gox: image/ycbcr.lo\n-\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)"}, {"sha": "7e8a38d37b4cc523b32d134d3b7ae5f550798c67", "filename": "libgo/configure", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -657,6 +657,8 @@ LIBGO_IS_SOLARIS_FALSE\n LIBGO_IS_SOLARIS_TRUE\n LIBGO_IS_RTEMS_FALSE\n LIBGO_IS_RTEMS_TRUE\n+LIBGO_IS_NETBSD_FALSE\n+LIBGO_IS_NETBSD_TRUE\n LIBGO_IS_LINUX_FALSE\n LIBGO_IS_LINUX_TRUE\n LIBGO_IS_IRIX_FALSE\n@@ -11097,7 +11099,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11100 \"configure\"\n+#line 11102 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11203,7 +11205,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11206 \"configure\"\n+#line 11208 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13473,6 +13475,7 @@ case ${host} in\n   *-*-freebsd*)  is_freebsd=yes; GOOS=freebsd ;;\n   *-*-irix6*)    is_irix=yes;    GOOS=irix ;;\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n+  *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n@@ -13508,6 +13511,14 @@ else\n   LIBGO_IS_LINUX_FALSE=\n fi\n \n+ if test $is_netbsd = yes; then\n+  LIBGO_IS_NETBSD_TRUE=\n+  LIBGO_IS_NETBSD_FALSE='#'\n+else\n+  LIBGO_IS_NETBSD_TRUE='#'\n+  LIBGO_IS_NETBSD_FALSE=\n+fi\n+\n  if test $is_rtems = yes; then\n   LIBGO_IS_RTEMS_TRUE=\n   LIBGO_IS_RTEMS_FALSE='#'\n@@ -14938,6 +14949,10 @@ if test -z \"${LIBGO_IS_LINUX_TRUE}\" && test -z \"${LIBGO_IS_LINUX_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_LINUX\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${LIBGO_IS_NETBSD_TRUE}\" && test -z \"${LIBGO_IS_NETBSD_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_NETBSD\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_RTEMS_TRUE}\" && test -z \"${LIBGO_IS_RTEMS_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_RTEMS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "81326557afa350efa426c427d16ca2164a7d9a7b", "filename": "libgo/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -134,13 +134,15 @@ case ${host} in\n   *-*-freebsd*)  is_freebsd=yes; GOOS=freebsd ;;\n   *-*-irix6*)    is_irix=yes;    GOOS=irix ;;\n   *-*-linux*)    is_linux=yes;   GOOS=linux ;;\n+  *-*-netbsd*)\t is_netbsd=yes;  GOOS=netbsd ;;\n   *-*-rtems*)    is_rtems=yes;   GOOS=rtems ;;\n   *-*-solaris2*) is_solaris=yes; GOOS=solaris ;;\n esac\n AM_CONDITIONAL(LIBGO_IS_DARWIN, test $is_darwin = yes)\n AM_CONDITIONAL(LIBGO_IS_FREEBSD, test $is_freebsd = yes)\n AM_CONDITIONAL(LIBGO_IS_IRIX, test $is_irix = yes)\n AM_CONDITIONAL(LIBGO_IS_LINUX, test $is_linux = yes)\n+AM_CONDITIONAL(LIBGO_IS_NETBSD, test $is_netbsd = yes)\n AM_CONDITIONAL(LIBGO_IS_RTEMS, test $is_rtems = yes)\n AM_CONDITIONAL(LIBGO_IS_SOLARIS, test $is_solaris = yes)\n AC_SUBST(GOOS)"}, {"sha": "0e40268c2f8c5475733ebf2a1995f904f1f28c5e", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -163,10 +163,10 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tdone := make(chan bool)\n \tfor i := 0; i < 5; i++ {\n \t\tfor j, ft := range zt.File {\n-\t\t\tgo func() {\n+\t\t\tgo func(j int, ft ZipTestFile) {\n \t\t\t\treadTestFile(t, ft, z.File[j])\n \t\t\t\tdone <- true\n-\t\t\t}()\n+\t\t\t}(j, ft)\n \t\t\tn++\n \t\t}\n \t}"}, {"sha": "34a87fae5b330596cf05d7221b939a7c8078fee6", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -96,12 +96,28 @@ func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n \t)\n }\n \n+// timeToMsDosTime converts a time.Time to an MS-DOS date and time.\n+// The resolution is 2s.\n+// See: http://msdn.microsoft.com/en-us/library/ms724274(v=VS.85).aspx\n+func timeToMsDosTime(t time.Time) (fDate uint16, fTime uint16) {\n+\tt = t.In(time.UTC)\n+\tfDate = uint16(t.Day() + int(t.Month())<<5 + (t.Year()-1980)<<9)\n+\tfTime = uint16(t.Second()/2 + t.Minute()<<5 + t.Hour()<<11)\n+\treturn\n+}\n+\n // ModTime returns the modification time.\n // The resolution is 2s.\n func (h *FileHeader) ModTime() time.Time {\n \treturn msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n }\n \n+// SetModTime sets the ModifiedTime and ModifiedDate fields to the given time.\n+// The resolution is 2s.\n+func (h *FileHeader) SetModTime(t time.Time) {\n+\th.ModifiedDate, h.ModifiedTime = timeToMsDosTime(t)\n+}\n+\n // traditional names for Unix constants\n const (\n \ts_IFMT  = 0xf000"}, {"sha": "8aab2b68123f704c4e1a255f99a3daf8f49d59b2", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type stringReaderAt string\n@@ -55,3 +56,13 @@ func TestOver65kFiles(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestModTime(t *testing.T) {\n+\tvar testTime = time.Date(2009, time.November, 10, 23, 45, 58, 0, time.UTC)\n+\tfh := new(FileHeader)\n+\tfh.SetModTime(testTime)\n+\toutTime := fh.ModTime()\n+\tif !outTime.Equal(testTime) {\n+\t\tt.Errorf(\"times don't match: got %s, want %s\", outTime, testTime)\n+\t}\n+}"}, {"sha": "adb93302a541ebcea1cc9ea6b7f9df1e055e11cb", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -16,7 +16,6 @@ const N = 10000  // make this bigger for a larger (and slower) test\n var data string  // test data for write tests\n var bytes []byte // test data; same as data but as a slice.\n \n-\n func init() {\n \tbytes = make([]byte, N)\n \tfor i := 0; i < N; i++ {"}, {"sha": "2a1d41b910e3f222b091ccefe2eeac734f9edefa", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -289,8 +289,7 @@ func bmIndexByte(b *testing.B, index func([]byte, byte) int, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\tj := index(buf, 'x')\n \t\tif j != n-1 {\n-\t\t\tprintln(\"bad index\", j)\n-\t\t\tpanic(\"bad index\")\n+\t\t\tb.Fatal(\"bad index\", j)\n \t\t}\n \t}\n \tbuf[n-1] = '\\x00'\n@@ -317,7 +316,7 @@ func bmEqual(b *testing.B, equal func([]byte, []byte) bool, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\teq := equal(buf1, buf2)\n \t\tif !eq {\n-\t\t\tpanic(\"bad equal\")\n+\t\t\tb.Fatal(\"bad equal\")\n \t\t}\n \t}\n \tbuf1[n-1] = '\\x00'\n@@ -339,8 +338,7 @@ func bmIndex(b *testing.B, index func([]byte, []byte) int, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\tj := index(buf, buf[n-7:])\n \t\tif j != n-7 {\n-\t\t\tprintln(\"bad index\", j)\n-\t\t\tpanic(\"bad index\")\n+\t\t\tb.Fatal(\"bad index\", j)\n \t\t}\n \t}\n \tbuf[n-1] = '\\x00'\n@@ -362,8 +360,7 @@ func bmIndexEasy(b *testing.B, index func([]byte, []byte) int, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\tj := index(buf, buf[n-7:])\n \t\tif j != n-7 {\n-\t\t\tprintln(\"bad index\", j)\n-\t\t\tpanic(\"bad index\")\n+\t\t\tb.Fatal(\"bad index\", j)\n \t\t}\n \t}\n \tbuf[n-1] = '\\x00'\n@@ -385,8 +382,7 @@ func bmCount(b *testing.B, count func([]byte, []byte) int, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\tj := count(buf, buf[n-7:])\n \t\tif j != 1 {\n-\t\t\tprintln(\"bad count\", j)\n-\t\t\tpanic(\"bad count\")\n+\t\t\tb.Fatal(\"bad count\", j)\n \t\t}\n \t}\n \tbuf[n-1] = '\\x00'\n@@ -408,8 +404,7 @@ func bmCountEasy(b *testing.B, count func([]byte, []byte) int, n int) {\n \tfor i := 0; i < b.N; i++ {\n \t\tj := count(buf, buf[n-7:])\n \t\tif j != 1 {\n-\t\t\tprintln(\"bad count\", j)\n-\t\t\tpanic(\"bad count\")\n+\t\t\tb.Fatal(\"bad count\", j)\n \t\t}\n \t}\n \tbuf[n-1] = '\\x00'"}, {"sha": "02da1ac082bd984315e3b02db1f1ce91b29e1ad8", "filename": "libgo/go/bytes/example_test.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,24 @@\n+package bytes_test\n+\n+import (\n+\t. \"bytes\"\n+\t\"encoding/base64\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Hello world!\n+func ExampleBuffer() {\n+\tvar b Buffer // A Buffer needs no initialization.\n+\tb.Write([]byte(\"Hello \"))\n+\tb.Write([]byte(\"world!\"))\n+\tb.WriteTo(os.Stdout)\n+}\n+\n+// Gophers rule!\n+func ExampleBuffer_reader() {\n+\t// A Buffer can turn a string or a []byte into an io.Reader.\n+\tbuf := NewBufferString(\"R29waGVycyBydWxlIQ==\")\n+\tdec := base64.NewDecoder(base64.StdEncoding, buf)\n+\tio.Copy(os.Stdout, dec)\n+}"}, {"sha": "e500c666d97ee42b62e4a6cc20d0343068ed649d", "filename": "libgo/go/crypto/aes/aes_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -356,7 +356,7 @@ func BenchmarkEncrypt(b *testing.B) {\n \ttt := encryptTests[0]\n \tc, err := NewCipher(tt.key)\n \tif err != nil {\n-\t\tpanic(\"NewCipher\")\n+\t\tb.Fatal(\"NewCipher:\", err)\n \t}\n \tout := make([]byte, len(tt.in))\n \tb.StartTimer()"}, {"sha": "c913494f61b92f1f0790ed4905e1757be8a9539f", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -71,3 +71,6 @@ func RegisterHash(h Hash, f func() hash.Hash) {\n \t}\n \thashes[h] = f\n }\n+\n+// PrivateKey represents a private key using an unspecified algorithm.\n+type PrivateKey interface{}"}, {"sha": "74e7d239e0882b2fc1ed1797c2b0befe173e5f42", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -16,6 +16,7 @@ import (\n \n // PublicKeyType is the armor type for a PGP public key.\n var PublicKeyType = \"PGP PUBLIC KEY BLOCK\"\n+\n // PrivateKeyType is the armor type for a PGP private key.\n var PrivateKeyType = \"PGP PRIVATE KEY BLOCK\"\n "}, {"sha": "5d4fc8198ac8cf85182fdeb15f33d6c91a5b3b1d", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Unix cryptographically secure pseudorandom number\n // generator."}, {"sha": "a461ad951b011447f6bf4ed43f88a5dc1ad8548a", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -5,8 +5,8 @@\n package tls\n \n import (\n+\t\"crypto\"\n \t\"crypto/rand\"\n-\t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"io\"\n \t\"strings\"\n@@ -255,7 +255,7 @@ func (c *Config) BuildNameToCertificate() {\n // A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n \tCertificate [][]byte\n-\tPrivateKey  *rsa.PrivateKey\n+\tPrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey\n \t// OCSPStaple contains an optional OCSP response which will be served\n \t// to clients that request it.\n \tOCSPStaple []byte"}, {"sha": "73648002bd58bd74db619cb74a2fd89ac7cc322e", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -234,7 +234,7 @@ func (c *Conn) clientHandshake() error {\n \t\tdigest := make([]byte, 0, 36)\n \t\tdigest = finishedHash.serverMD5.Sum(digest)\n \t\tdigest = finishedHash.serverSHA1.Sum(digest)\n-\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, crypto.MD5SHA1, digest)\n+\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey.(*rsa.PrivateKey), crypto.MD5SHA1, digest)\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n \t\t}"}, {"sha": "c3c16647853f043adcc5ed7864153c62213ac702", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -44,7 +44,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKe\n \t\tciphertext = ckx.ciphertext[2:]\n \t}\n \n-\terr = rsa.DecryptPKCS1v15SessionKey(config.rand(), config.Certificates[0].PrivateKey, ciphertext, preMasterSecret)\n+\terr = rsa.DecryptPKCS1v15SessionKey(config.rand(), config.Certificates[0].PrivateKey.(*rsa.PrivateKey), ciphertext, preMasterSecret)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -147,7 +147,7 @@ Curve:\n \tcopy(serverECDHParams[4:], ecdhePublic)\n \n \tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n-\tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, crypto.MD5SHA1, md5sha1)\n+\tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey.(*rsa.PrivateKey), crypto.MD5SHA1, md5sha1)\n \tif err != nil {\n \t\treturn nil, errors.New(\"failed to sign ECDHE parameters: \" + err.Error())\n \t}"}, {"sha": "db1b18b3c07dc7af2868de2dabec1a6bc0edb14a", "filename": "libgo/go/crypto/tls/root_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -8,7 +8,7 @@ package tls\n // Note: We disable -Werror here because the code in this file uses a deprecated API to stay\n // compatible with both Mac OS X 10.6 and 10.7. Using a deprecated function on Darwin generates\n // a warning.\n-#cgo CFLAGS: -Wno-error\n+#cgo CFLAGS: -Wno-error -Wno-deprecated-declarations\n #cgo LDFLAGS: -framework CoreFoundation -framework Security\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>"}, {"sha": "d00493a5736d466291e3fc9684e5308b94db5571", "filename": "libgo/go/crypto/tls/root_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build plan9\n+// +build plan9 darwin/nocgo\n \n package tls\n "}, {"sha": "5a0a87678e37336d238c23f222e89e1bbba05b45", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -28,6 +28,9 @@ func NewCertPool() *CertPool {\n // given certificate. If no such certificate can be found or the signature\n // doesn't match, it returns nil.\n func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int) {\n+\tif s == nil {\n+\t\treturn\n+\t}\n \tvar candidates []int\n \n \tif len(cert.AuthorityKeyId) > 0 {"}, {"sha": "2016858307e275e8ec3f81d6d7be1d9dfd07545b", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -19,6 +19,7 @@ type verifyTest struct {\n \troots         []string\n \tcurrentTime   int64\n \tdnsName       string\n+\tnilRoots      bool\n \n \terrorCallback  func(*testing.T, int, error) bool\n \texpectedChains [][]string\n@@ -45,6 +46,14 @@ var verifyTests = []verifyTest{\n \n \t\terrorCallback: expectHostnameError,\n \t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\tnilRoots:      true, // verifies that we don't crash\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"www.google.com\",\n+\t\terrorCallback: expectAuthorityUnknown,\n+\t},\n \t{\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{thawteIntermediate},\n@@ -136,6 +145,9 @@ func TestVerify(t *testing.T) {\n \t\t\tDNSName:       test.dnsName,\n \t\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n \t\t}\n+\t\tif test.nilRoots {\n+\t\t\topts.Roots = nil\n+\t\t}\n \n \t\tfor j, root := range test.roots {\n \t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))"}, {"sha": "28c7880e531922950c04d9a2d4bee9436103c0be", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -981,6 +981,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n // pemCRLPrefix is the magic string that indicates that we have a PEM encoded\n // CRL.\n var pemCRLPrefix = []byte(\"-----BEGIN X509 CRL\")\n+\n // pemType is the type of a PEM encoded CRL.\n var pemType = \"X509 CRL\"\n "}, {"sha": "e5c29889b7f8d5510d658cb5a761ecff70a412e0", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -13,7 +13,8 @@ import (\n \n func dotest() bool {\n \t// For now, only works on ELF platforms.\n-\treturn syscall.OS == \"linux\" && os.Getenv(\"GOARCH\") == \"amd64\"\n+\t// TODO: convert to work with new go tool\n+\treturn false && syscall.OS == \"linux\" && os.Getenv(\"GOARCH\") == \"amd64\"\n }\n \n func getTable(t *testing.T) *Table {"}, {"sha": "3e7057ea22787066f2054d82f30ef0b92adbc7ff", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -171,11 +171,42 @@ func (br *byteSliceReader) Read(p []byte) (int, error) {\n \treturn n, nil\n }\n \n-func BenchmarkRead(b *testing.B) {\n+func BenchmarkReadSlice1000Int32s(b *testing.B) {\n+\tbsr := &byteSliceReader{}\n+\tslice := make([]int32, 1000)\n+\tbuf := make([]byte, len(slice)*4)\n+\tb.SetBytes(int64(len(buf)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbsr.remain = buf\n+\t\tRead(bsr, BigEndian, slice)\n+\t}\n+}\n+\n+func BenchmarkReadStruct(b *testing.B) {\n+\tbsr := &byteSliceReader{}\n+\tvar buf bytes.Buffer\n+\tWrite(&buf, BigEndian, &s)\n+\tn := TotalSize(reflect.ValueOf(s))\n+\tb.SetBytes(int64(n))\n+\tt := s\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbsr.remain = buf.Bytes()\n+\t\tRead(bsr, BigEndian, &t)\n+\t}\n+\tb.StopTimer()\n+\tif !reflect.DeepEqual(s, t) {\n+\t\tb.Fatal(\"no match\")\n+\t}\n+}\n+\n+func BenchmarkReadInts(b *testing.B) {\n \tvar ls Struct\n \tbsr := &byteSliceReader{}\n \tvar r io.Reader = bsr\n-\n+\tb.SetBytes(2 * (1 + 2 + 4 + 8))\n+\tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tbsr.remain = big\n \t\tRead(r, BigEndian, &ls.Int8)\n@@ -196,25 +227,19 @@ func BenchmarkRead(b *testing.B) {\n \tfor i := range want.Array {\n \t\twant.Array[i] = 0\n \t}\n+\tb.StopTimer()\n \tif !reflect.DeepEqual(ls, want) {\n \t\tpanic(\"no match\")\n \t}\n }\n \n-func BenchmarkWrite(b *testing.B) {\n+func BenchmarkWriteInts(b *testing.B) {\n \tbuf := new(bytes.Buffer)\n \tvar w io.Writer = buf\n-\n+\tb.SetBytes(2 * (1 + 2 + 4 + 8))\n+\tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tbuf.Reset()\n-\t\tWrite(w, BigEndian, &s.Int8)\n-\t\tWrite(w, BigEndian, &s.Int16)\n-\t\tWrite(w, BigEndian, &s.Int32)\n-\t\tWrite(w, BigEndian, &s.Int64)\n-\t\tWrite(w, BigEndian, &s.Uint8)\n-\t\tWrite(w, BigEndian, &s.Uint16)\n-\t\tWrite(w, BigEndian, &s.Uint32)\n-\t\tWrite(w, BigEndian, &s.Uint64)\n \t\tWrite(w, BigEndian, s.Int8)\n \t\tWrite(w, BigEndian, s.Int16)\n \t\tWrite(w, BigEndian, s.Int32)\n@@ -224,11 +249,8 @@ func BenchmarkWrite(b *testing.B) {\n \t\tWrite(w, BigEndian, s.Uint32)\n \t\tWrite(w, BigEndian, s.Uint64)\n \t}\n-\n-\tif !bytes.Equal(buf.Bytes()[:30], big[:30]) {\n-\t\tpanic(\"first half doesn't match\")\n-\t}\n-\tif !bytes.Equal(buf.Bytes()[30:], big[:30]) {\n-\t\tpanic(\"second half doesn't match\")\n+\tb.StopTimer()\n+\tif !bytes.Equal(buf.Bytes(), big[:30]) {\n+\t\tb.Fatalf(\"first half doesn't match: %x %x\", buf.Bytes(), big[:30])\n \t}\n }"}, {"sha": "dc550f22f44e79c9eaee865956dd4ef0884ee29d", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -165,6 +165,7 @@ func TestNonCanonicalZero(t *testing.T) {\n \n func BenchmarkPutUvarint32(b *testing.B) {\n \tbuf := make([]byte, MaxVarintLen32)\n+\tb.SetBytes(4)\n \tfor i := 0; i < b.N; i++ {\n \t\tfor j := uint(0); j < MaxVarintLen32; j++ {\n \t\t\tPutUvarint(buf, 1<<(j*7))\n@@ -174,6 +175,7 @@ func BenchmarkPutUvarint32(b *testing.B) {\n \n func BenchmarkPutUvarint64(b *testing.B) {\n \tbuf := make([]byte, MaxVarintLen64)\n+\tb.SetBytes(8)\n \tfor i := 0; i < b.N; i++ {\n \t\tfor j := uint(0); j < MaxVarintLen64; j++ {\n \t\t\tPutUvarint(buf, 1<<(j*7))"}, {"sha": "73844b920c14bfa00fced5fd73ffc80df749ec73", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -102,12 +102,15 @@ func TestIntCodec(t *testing.T) {\n \n // The result of encoding a true boolean with field number 7\n var boolResult = []byte{0x07, 0x01}\n+\n // The result of encoding a number 17 with field number 7\n var signedResult = []byte{0x07, 2 * 17}\n var unsignedResult = []byte{0x07, 17}\n var floatResult = []byte{0x07, 0xFE, 0x31, 0x40}\n+\n // The result of encoding a number 17+19i with field number 7\n var complexResult = []byte{0x07, 0xFE, 0x31, 0x40, 0xFE, 0x33, 0x40}\n+\n // The result of encoding \"hello\" with field number 7\n var bytesResult = []byte{0x07, 0x05, 'h', 'e', 'l', 'l', 'o'}\n "}, {"sha": "f05b17c309699e6684fbd75722680f6ba842118e", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -469,7 +469,14 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n // isZero returns whether the value is the zero of its type.\n func isZero(val reflect.Value) bool {\n \tswitch val.Kind() {\n-\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n+\tcase reflect.Array:\n+\t\tfor i := 0; i < val.Len(); i++ {\n+\t\t\tif !isZero(val.Index(i)) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\tcase reflect.Map, reflect.Slice, reflect.String:\n \t\treturn val.Len() == 0\n \tcase reflect.Bool:\n \t\treturn !val.Bool()\n@@ -483,6 +490,13 @@ func isZero(val reflect.Value) bool {\n \t\treturn val.Float() == 0\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\treturn val.Uint() == 0\n+\tcase reflect.Struct:\n+\t\tfor i := 0; i < val.NumField(); i++ {\n+\t\t\tif !isZero(val.Field(i)) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n \t}\n \tpanic(\"unknown type in isZero \" + val.Type().String())\n }"}, {"sha": "b8dfeeb5156d0e066794ef749c3a6df588b8006d", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"io\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // Types that implement the GobEncoder/Decoder interfaces.\n@@ -526,3 +527,50 @@ func TestGobEncoderExtraIndirect(t *testing.T) {\n \t\tt.Errorf(\"got = %q, want %q\", got, gdb)\n \t}\n }\n+\n+// Another bug: this caused a crash with the new Go1 Time type.\n+// We throw in a gob-encoding array, to test another case of isZero\n+\n+type isZeroBug struct {\n+\tT time.Time\n+\tS string\n+\tI int\n+\tA isZeroBugArray\n+}\n+\n+type isZeroBugArray [2]uint8\n+\n+// Receiver is value, not pointer, to test isZero of array.\n+func (a isZeroBugArray) GobEncode() (b []byte, e error) {\n+\tb = append(b, a[:]...)\n+\treturn b, nil\n+}\n+\n+func (a *isZeroBugArray) GobDecode(data []byte) error {\n+\tprintln(\"DECODE\")\n+\tif len(data) != len(a) {\n+\t\treturn io.EOF\n+\t}\n+\ta[0] = data[0]\n+\ta[1] = data[1]\n+\treturn nil\n+}\n+\n+func TestGobEncodeIsZero(t *testing.T) {\n+\tx := isZeroBug{time.Now(), \"hello\", -55, isZeroBugArray{1, 2}}\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\tvar y isZeroBug\n+\tdec := NewDecoder(b)\n+\terr = dec.Decode(&y)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif x != y {\n+\t\tt.Fatalf(\"%v != %v\", x, y)\n+\t}\n+}"}, {"sha": "1017eb7f51d4100a8df8070360ef208b12b50c9a", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -39,7 +39,7 @@ func benchmarkEndToEnd(r io.Reader, w io.Writer, b *testing.B) {\n func BenchmarkEndToEndPipe(b *testing.B) {\n \tr, w, err := os.Pipe()\n \tif err != nil {\n-\t\tpanic(\"can't get pipe:\" + err.Error())\n+\t\tb.Fatal(\"can't get pipe:\", err)\n \t}\n \tbenchmarkEndToEnd(r, w, b)\n }"}, {"sha": "71a28be7cab8a7a497145f9fdd692f95ab5dadc8", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -130,6 +130,7 @@ func userType(rt reflect.Type) *userTypeInfo {\n \t}\n \treturn ut\n }\n+\n // A typeId represents a gob Type as an integer that can be passed on the wire.\n // Internally, typeIds are used as keys to a map to recover the underlying type info.\n type typeId int32"}, {"sha": "333c1c0ce9e3d13b63bfa9bd58543a6d5cd6bcad", "filename": "libgo/go/encoding/json/bench_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -84,7 +84,7 @@ func BenchmarkCodeEncoder(b *testing.B) {\n \tenc := NewEncoder(ioutil.Discard)\n \tfor i := 0; i < b.N; i++ {\n \t\tif err := enc.Encode(&codeStruct); err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Encode:\", err)\n \t\t}\n \t}\n \tb.SetBytes(int64(len(codeJSON)))\n@@ -98,7 +98,7 @@ func BenchmarkCodeMarshal(b *testing.B) {\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tif _, err := Marshal(&codeStruct); err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Marshal:\", err)\n \t\t}\n \t}\n \tb.SetBytes(int64(len(codeJSON)))\n@@ -120,7 +120,7 @@ func BenchmarkCodeDecoder(b *testing.B) {\n \t\tbuf.WriteByte('\\n')\n \t\tbuf.WriteByte('\\n')\n \t\tif err := dec.Decode(&r); err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Decode:\", err)\n \t\t}\n \t}\n \tb.SetBytes(int64(len(codeJSON)))\n@@ -135,7 +135,7 @@ func BenchmarkCodeUnmarshal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tvar r codeResponse\n \t\tif err := Unmarshal(codeJSON, &r); err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Unmmarshal:\", err)\n \t\t}\n \t}\n \tb.SetBytes(int64(len(codeJSON)))\n@@ -150,7 +150,7 @@ func BenchmarkCodeUnmarshalReuse(b *testing.B) {\n \tvar r codeResponse\n \tfor i := 0; i < b.N; i++ {\n \t\tif err := Unmarshal(codeJSON, &r); err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Unmmarshal:\", err)\n \t\t}\n \t}\n \tb.SetBytes(int64(len(codeJSON)))"}, {"sha": "8287b330034ab01da4768e63c02e2672978daf09", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -228,7 +228,9 @@ func (d *decodeState) value(v reflect.Value) {\n \t\t// Feed in an empty string - the shortest, simplest value -\n \t\t// so that it knows we got to the end of the value.\n \t\tif d.scan.redo {\n-\t\t\tpanic(\"redo\")\n+\t\t\t// rewind.\n+\t\t\td.scan.redo = false\n+\t\t\td.scan.step = stateBeginValue\n \t\t}\n \t\td.scan.step(&d.scan, '\"')\n \t\td.scan.step(&d.scan, '\"')\n@@ -317,25 +319,22 @@ func (d *decodeState) array(v reflect.Value) {\n \t}\n \tv = pv\n \n-\t// Decoding into nil interface?  Switch to non-reflect code.\n-\tiv := v\n-\tok := iv.Kind() == reflect.Interface\n-\tif ok {\n-\t\tiv.Set(reflect.ValueOf(d.arrayInterface()))\n-\t\treturn\n-\t}\n-\n \t// Check type of target.\n-\tav := v\n-\tif av.Kind() != reflect.Array && av.Kind() != reflect.Slice {\n+\tswitch v.Kind() {\n+\tdefault:\n \t\td.saveError(&UnmarshalTypeError{\"array\", v.Type()})\n \t\td.off--\n \t\td.next()\n \t\treturn\n+\tcase reflect.Interface:\n+\t\t// Decoding into nil interface?  Switch to non-reflect code.\n+\t\tv.Set(reflect.ValueOf(d.arrayInterface()))\n+\t\treturn\n+\tcase reflect.Array:\n+\tcase reflect.Slice:\n+\t\tbreak\n \t}\n \n-\tsv := v\n-\n \ti := 0\n \tfor {\n \t\t// Look ahead for ] - can only happen on first iteration.\n@@ -349,23 +348,25 @@ func (d *decodeState) array(v reflect.Value) {\n \t\td.scan.undo(op)\n \n \t\t// Get element of array, growing if necessary.\n-\t\tif i >= av.Cap() && sv.IsValid() {\n-\t\t\tnewcap := sv.Cap() + sv.Cap()/2\n-\t\t\tif newcap < 4 {\n-\t\t\t\tnewcap = 4\n+\t\tif v.Kind() == reflect.Slice {\n+\t\t\t// Grow slice if necessary\n+\t\t\tif i >= v.Cap() {\n+\t\t\t\tnewcap := v.Cap() + v.Cap()/2\n+\t\t\t\tif newcap < 4 {\n+\t\t\t\t\tnewcap = 4\n+\t\t\t\t}\n+\t\t\t\tnewv := reflect.MakeSlice(v.Type(), v.Len(), newcap)\n+\t\t\t\treflect.Copy(newv, v)\n+\t\t\t\tv.Set(newv)\n+\t\t\t}\n+\t\t\tif i >= v.Len() {\n+\t\t\t\tv.SetLen(i + 1)\n \t\t\t}\n-\t\t\tnewv := reflect.MakeSlice(sv.Type(), sv.Len(), newcap)\n-\t\t\treflect.Copy(newv, sv)\n-\t\t\tsv.Set(newv)\n-\t\t}\n-\t\tif i >= av.Len() && sv.IsValid() {\n-\t\t\t// Must be slice; gave up on array during i >= av.Cap().\n-\t\t\tsv.SetLen(i + 1)\n \t\t}\n \n-\t\t// Decode into element.\n-\t\tif i < av.Len() {\n-\t\t\td.value(av.Index(i))\n+\t\tif i < v.Len() {\n+\t\t\t// Decode into element.\n+\t\t\td.value(v.Index(i))\n \t\t} else {\n \t\t\t// Ran out of fixed array: skip.\n \t\t\td.value(reflect.Value{})\n@@ -382,19 +383,19 @@ func (d *decodeState) array(v reflect.Value) {\n \t\t}\n \t}\n \n-\tif i < av.Len() {\n-\t\tif !sv.IsValid() {\n+\tif i < v.Len() {\n+\t\tif v.Kind() == reflect.Array {\n \t\t\t// Array.  Zero the rest.\n-\t\t\tz := reflect.Zero(av.Type().Elem())\n-\t\t\tfor ; i < av.Len(); i++ {\n-\t\t\t\tav.Index(i).Set(z)\n+\t\t\tz := reflect.Zero(v.Type().Elem())\n+\t\t\tfor ; i < v.Len(); i++ {\n+\t\t\t\tv.Index(i).Set(z)\n \t\t\t}\n \t\t} else {\n-\t\t\tsv.SetLen(i)\n+\t\t\tv.SetLen(i)\n \t\t}\n \t}\n-\tif i == 0 && av.Kind() == reflect.Slice && sv.IsNil() {\n-\t\tsv.Set(reflect.MakeSlice(sv.Type(), 0, 0))\n+\tif i == 0 && v.Kind() == reflect.Slice {\n+\t\tv.Set(reflect.MakeSlice(v.Type(), 0, 0))\n \t}\n }\n "}, {"sha": "05c8a064a422c8bba383aa1683ebaa72a0ea4793", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -6,6 +6,7 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -73,6 +74,12 @@ var unmarshalTests = []unmarshalTest{\n \n \t// syntax errors\n \t{`{\"X\": \"foo\", \"Y\"}`, nil, nil, &SyntaxError{\"invalid character '}' after object key\", 17}},\n+\t{`[1, 2, 3+]`, nil, nil, &SyntaxError{\"invalid character '+' after array element\", 9}},\n+\n+\t// array tests\n+\t{`[1, 2, 3]`, new([3]int), [3]int{1, 2, 3}, nil},\n+\t{`[1, 2, 3]`, new([1]int), [1]int{1}, nil},\n+\t{`[1, 2, 3]`, new([5]int), [5]int{1, 2, 3, 0, 0}, nil},\n \n \t// composite tests\n \t{allValueIndent, new(All), allValue, nil},\n@@ -242,6 +249,38 @@ func TestHTMLEscape(t *testing.T) {\n \t}\n }\n \n+// WrongString is a struct that's misusing the ,string modifier.\n+type WrongString struct {\n+\tMessage string `json:\"result,string\"`\n+}\n+\n+type wrongStringTest struct {\n+\tin, err string\n+}\n+\n+// TODO(bradfitz): as part of Issue 2331, fix these tests' expected\n+// error values to be helpful, rather than the confusing messages they\n+// are now.\n+var wrongStringTests = []wrongStringTest{\n+\t{`{\"result\":\"x\"}`, \"JSON decoder out of sync - data changing underfoot?\"},\n+\t{`{\"result\":\"foo\"}`, \"json: cannot unmarshal bool into Go value of type string\"},\n+\t{`{\"result\":\"123\"}`, \"json: cannot unmarshal number into Go value of type string\"},\n+}\n+\n+// If people misuse the ,string modifier, the error message should be\n+// helpful, telling the user that they're doing it wrong.\n+func TestErrorMessageFromMisusedString(t *testing.T) {\n+\tfor n, tt := range wrongStringTests {\n+\t\tr := strings.NewReader(tt.in)\n+\t\tvar s WrongString\n+\t\terr := NewDecoder(r).Decode(&s)\n+\t\tgot := fmt.Sprintf(\"%v\", err)\n+\t\tif got != tt.err {\n+\t\t\tt.Errorf(\"%d. got err = %q, want %q\", n, got, tt.err)\n+\t\t}\n+\t}\n+}\n+\n func noSpace(c rune) rune {\n \tif isSpace(c) {\n \t\treturn -1"}, {"sha": "3d2f4fc316ea8e837995399d637851d3832ac7c3", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -197,6 +197,7 @@ var hex = \"0123456789abcdef\"\n // An encodeState encodes JSON into a bytes.Buffer.\n type encodeState struct {\n \tbytes.Buffer // accumulated output\n+\tscratch      [64]byte\n }\n \n func (e *encodeState) marshal(v interface{}) (err error) {\n@@ -275,14 +276,26 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\t}\n \n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\twriteString(e, strconv.FormatInt(v.Int(), 10))\n-\n+\t\tb := strconv.AppendInt(e.scratch[:0], v.Int(), 10)\n+\t\tif quoted {\n+\t\t\twriteString(e, string(b))\n+\t\t} else {\n+\t\t\te.Write(b)\n+\t\t}\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\twriteString(e, strconv.FormatUint(v.Uint(), 10))\n-\n+\t\tb := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)\n+\t\tif quoted {\n+\t\t\twriteString(e, string(b))\n+\t\t} else {\n+\t\t\te.Write(b)\n+\t\t}\n \tcase reflect.Float32, reflect.Float64:\n-\t\twriteString(e, strconv.FormatFloat(v.Float(), 'g', -1, v.Type().Bits()))\n-\n+\t\tb := strconv.AppendFloat(e.scratch[:0], v.Float(), 'g', -1, v.Type().Bits())\n+\t\tif quoted {\n+\t\t\twriteString(e, string(b))\n+\t\t} else {\n+\t\t\te.Write(b)\n+\t\t}\n \tcase reflect.String:\n \t\tif quoted {\n \t\t\tsb, err := Marshal(v.String())"}, {"sha": "6a241694baf85651ad1082c7f354975fa599e4d0", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -394,7 +394,7 @@ func TestUnmarshal(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: unexpected error: %#v\", i, err)\n \t\t} else if got, want := dest, test.Value; !reflect.DeepEqual(got, want) {\n-\t\t\tt.Errorf(\"#%d: unmarshal(%#s) = %#v, want %#v\", i, test.ExpectXML, got, want)\n+\t\t\tt.Errorf(\"#%d: unmarshal(%q) = %#v, want %#v\", i, test.ExpectXML, got, want)\n \t\t}\n \t}\n }"}, {"sha": "d035ec1410ff16afd9daa9a349e29de06ff5c18b", "filename": "libgo/go/exp/inotify/inotify_linux_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux\n+\n package inotify\n \n import (\n@@ -17,6 +19,9 @@ func TestInotifyEvents(t *testing.T) {\n \t\tt.Fatalf(\"NewWatcher() failed: %s\", err)\n \t}\n \n+\tt.Logf(\"NEEDS TO BE CONVERTED TO NEW GO TOOL\") // TODO\n+\treturn\n+\n \t// Add a watch for \"_test\"\n \terr = watcher.Watch(\"_test\")\n \tif err != nil {"}, {"sha": "937982cdbe6f9b3661ea963047f0efe9d92fd828", "filename": "libgo/go/exp/sql/sql.go", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -22,10 +22,10 @@ var drivers = make(map[string]driver.Driver)\n // it panics.\n func Register(name string, driver driver.Driver) {\n \tif driver == nil {\n-\t\tpanic(\"db: Register driver is nil\")\n+\t\tpanic(\"sql: Register driver is nil\")\n \t}\n \tif _, dup := drivers[name]; dup {\n-\t\tpanic(\"db: Register called twice for driver \" + name)\n+\t\tpanic(\"sql: Register called twice for driver \" + name)\n \t}\n \tdrivers[name] = driver\n }\n@@ -80,7 +80,7 @@ type ScannerInto interface {\n // ErrNoRows is returned by Scan when QueryRow doesn't return a\n // row. In such a case, QueryRow returns a placeholder *Row value that\n // defers this error until a Scan.\n-var ErrNoRows = errors.New(\"db: no rows in result set\")\n+var ErrNoRows = errors.New(\"sql: no rows in result set\")\n \n // DB is a database handle. It's safe for concurrent use by multiple\n // goroutines.\n@@ -102,7 +102,7 @@ type DB struct {\n func Open(driverName, dataSourceName string) (*DB, error) {\n \tdriver, ok := drivers[driverName]\n \tif !ok {\n-\t\treturn nil, fmt.Errorf(\"db: unknown driver %q (forgotten import?)\", driverName)\n+\t\treturn nil, fmt.Errorf(\"sql: unknown driver %q (forgotten import?)\", driverName)\n \t}\n \treturn &DB{driver: driver, dsn: dataSourceName}, nil\n }\n@@ -514,26 +514,26 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t// placeholders, so we won't sanity check input here and instead let the\n \t// driver deal with errors.\n \tif want := si.NumInput(); want != -1 && len(args) != want {\n-\t\treturn nil, fmt.Errorf(\"db: expected %d arguments, got %d\", want, len(args))\n+\t\treturn nil, fmt.Errorf(\"sql: expected %d arguments, got %d\", want, len(args))\n \t}\n \n \t// Convert args to subset types.\n \tif cc, ok := si.(driver.ColumnConverter); ok {\n \t\tfor n, arg := range args {\n \t\t\targs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"db: converting Exec argument #%d's type: %v\", n, err)\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n \t\t\t}\n \t\t\tif !driver.IsParameterSubsetType(args[n]) {\n-\t\t\t\treturn nil, fmt.Errorf(\"db: driver ColumnConverter error converted %T to unsupported type %T\",\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: driver ColumnConverter error converted %T to unsupported type %T\",\n \t\t\t\t\targ, args[n])\n \t\t\t}\n \t\t}\n \t} else {\n \t\tfor n, arg := range args {\n \t\t\targs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"db: converting Exec argument #%d's type: %v\", n, err)\n+\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument #%d's type: %v\", n, err)\n \t\t\t}\n \t\t}\n \t}\n@@ -555,7 +555,7 @@ func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, e\n \ts.mu.Lock()\n \tif s.closed {\n \t\ts.mu.Unlock()\n-\t\terr = errors.New(\"db: statement is closed\")\n+\t\terr = errors.New(\"sql: statement is closed\")\n \t\treturn\n \t}\n \n@@ -617,7 +617,7 @@ func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n \t// placeholders, so we won't sanity check input here and instead let the\n \t// driver deal with errors.\n \tif want := si.NumInput(); want != -1 && len(args) != want {\n-\t\treturn nil, fmt.Errorf(\"db: statement expects %d inputs; got %d\", si.NumInput(), len(args))\n+\t\treturn nil, fmt.Errorf(\"sql: statement expects %d inputs; got %d\", si.NumInput(), len(args))\n \t}\n \tsargs, err := subsetTypeArgs(args)\n \tif err != nil {\n@@ -737,27 +737,40 @@ func (rs *Rows) Err() error {\n \treturn rs.lasterr\n }\n \n+// Columns returns the column names.\n+// Columns returns an error if the rows are closed, or if the rows\n+// are from QueryRow and there was a deferred error.\n+func (rs *Rows) Columns() ([]string, error) {\n+\tif rs.closed {\n+\t\treturn nil, errors.New(\"sql: Rows are closed\")\n+\t}\n+\tif rs.rowsi == nil {\n+\t\treturn nil, errors.New(\"sql: no Rows available\")\n+\t}\n+\treturn rs.rowsi.Columns(), nil\n+}\n+\n // Scan copies the columns in the current row into the values pointed\n // at by dest. If dest contains pointers to []byte, the slices should\n // not be modified and should only be considered valid until the next\n // call to Next or Scan.\n func (rs *Rows) Scan(dest ...interface{}) error {\n \tif rs.closed {\n-\t\treturn errors.New(\"db: Rows closed\")\n+\t\treturn errors.New(\"sql: Rows closed\")\n \t}\n \tif rs.lasterr != nil {\n \t\treturn rs.lasterr\n \t}\n \tif rs.lastcols == nil {\n-\t\treturn errors.New(\"db: Scan called without calling Next\")\n+\t\treturn errors.New(\"sql: Scan called without calling Next\")\n \t}\n \tif len(dest) != len(rs.lastcols) {\n-\t\treturn fmt.Errorf(\"db: expected %d destination arguments in Scan, not %d\", len(rs.lastcols), len(dest))\n+\t\treturn fmt.Errorf(\"sql: expected %d destination arguments in Scan, not %d\", len(rs.lastcols), len(dest))\n \t}\n \tfor i, sv := range rs.lastcols {\n \t\terr := convertAssign(dest[i], sv)\n \t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"db: Scan error on column index %d: %v\", i, err)\n+\t\t\treturn fmt.Errorf(\"sql: Scan error on column index %d: %v\", i, err)\n \t\t}\n \t}\n \treturn nil"}, {"sha": "5307a235ddf13fc0eb84b09eb7da9e3358ed0f3a", "filename": "libgo/go/exp/sql/sql_test.go", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -75,6 +75,23 @@ func TestQuery(t *testing.T) {\n \t}\n }\n \n+func TestRowsColumns(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\trows, err := db.Query(\"SELECT|people|age,name|\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Query: %v\", err)\n+\t}\n+\tcols, err := rows.Columns()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Columns: %v\", err)\n+\t}\n+\twant := []string{\"age\", \"name\"}\n+\tif !reflect.DeepEqual(cols, want) {\n+\t\tt.Errorf(\"got %#v; want %#v\", cols, want)\n+\t}\n+}\n+\n func TestQueryRow(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -187,12 +204,12 @@ func TestExec(t *testing.T) {\n \t\t{[]interface{}{7, 9}, \"\"},\n \n \t\t// Invalid conversions:\n-\t\t{[]interface{}{\"Brad\", int64(0xFFFFFFFF)}, \"db: converting Exec argument #1's type: sql/driver: value 4294967295 overflows int32\"},\n-\t\t{[]interface{}{\"Brad\", \"strconv fail\"}, \"db: converting Exec argument #1's type: sql/driver: value \\\"strconv fail\\\" can't be converted to int32\"},\n+\t\t{[]interface{}{\"Brad\", int64(0xFFFFFFFF)}, \"sql: converting Exec argument #1's type: sql/driver: value 4294967295 overflows int32\"},\n+\t\t{[]interface{}{\"Brad\", \"strconv fail\"}, \"sql: converting Exec argument #1's type: sql/driver: value \\\"strconv fail\\\" can't be converted to int32\"},\n \n \t\t// Wrong number of args:\n-\t\t{[]interface{}{}, \"db: expected 2 arguments, got 0\"},\n-\t\t{[]interface{}{1, 2, 3}, \"db: expected 2 arguments, got 3\"},\n+\t\t{[]interface{}{}, \"sql: expected 2 arguments, got 0\"},\n+\t\t{[]interface{}{1, 2, 3}, \"sql: expected 2 arguments, got 3\"},\n \t}\n \tfor n, et := range execTests {\n \t\t_, err := stmt.Exec(et.args...)"}, {"sha": "3a7e9fb98017681e6da7e4dfdd3dd333d35f4067", "filename": "libgo/go/exp/ssh/client_auth.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -283,8 +283,8 @@ func (p *publickeyAuth) method() string {\n \treturn \"publickey\"\n }\n \n-// ClientAuthPublickey returns a ClientAuth using public key authentication.\n-func ClientAuthPublickey(impl ClientKeyring) ClientAuth {\n+// ClientAuthKeyring returns a ClientAuth using public key authentication.\n+func ClientAuthKeyring(impl ClientKeyring) ClientAuth {\n \treturn &publickeyAuth{impl}\n }\n "}, {"sha": "c41a93b5c7dbf91c0de8961b1b2d4907b9036ee7", "filename": "libgo/go/exp/ssh/client_auth_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -122,7 +122,7 @@ var (\n \t\tPasswordCallback: func(user, pass string) bool {\n \t\t\treturn user == \"testuser\" && pass == string(clientPassword)\n \t\t},\n-\t\tPubKeyCallback: func(user, algo string, pubkey []byte) bool {\n+\t\tPublicKeyCallback: func(user, algo string, pubkey []byte) bool {\n \t\t\tkey := clientKeychain.keys[0].(*rsa.PrivateKey).PublicKey\n \t\t\texpected := []byte(serializePublickey(key))\n \t\t\talgoname := algoName(key)\n@@ -179,7 +179,7 @@ func TestClientAuthPublickey(t *testing.T) {\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPublickey(clientKeychain),\n+\t\t\tClientAuthKeyring(clientKeychain),\n \t\t},\n \t}\n \tc, err := Dial(\"tcp\", newMockAuthServer(t), config)\n@@ -210,7 +210,7 @@ func TestClientAuthWrongPassword(t *testing.T) {\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n \t\t\tClientAuthPassword(wrongPw),\n-\t\t\tClientAuthPublickey(clientKeychain),\n+\t\t\tClientAuthKeyring(clientKeychain),\n \t\t},\n \t}\n \n@@ -228,7 +228,7 @@ func TestClientAuthInvalidPublickey(t *testing.T) {\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPublickey(kc),\n+\t\t\tClientAuthKeyring(kc),\n \t\t},\n \t}\n \n@@ -246,7 +246,7 @@ func TestClientAuthRSAandDSA(t *testing.T) {\n \tconfig := &ClientConfig{\n \t\tUser: \"testuser\",\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPublickey(kc),\n+\t\t\tClientAuthKeyring(kc),\n \t\t},\n \t}\n \tc, err := Dial(\"tcp\", newMockAuthServer(t), config)"}, {"sha": "b4bdba95396bcc64c83e33482bd2ef337dff3bac", "filename": "libgo/go/exp/ssh/client_func_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -50,7 +50,7 @@ func TestFuncPublickeyAuth(t *testing.T) {\n \tconfig := &ClientConfig{\n \t\tUser: *sshuser,\n \t\tAuth: []ClientAuth{\n-\t\t\tClientAuthPublickey(kc),\n+\t\t\tClientAuthKeyring(kc),\n \t\t},\n \t}\n \tconn, err := Dial(\"tcp\", \"localhost:22\", config)"}, {"sha": "31011c6617677658f1b2a4f1138534b49134e8ab", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -36,10 +36,10 @@ type ServerConfig struct {\n \t// several goroutines.\n \tPasswordCallback func(user, password string) bool\n \n-\t// PubKeyCallback, if non-nil, is called when a client attempts public\n+\t// PublicKeyCallback, if non-nil, is called when a client attempts public\n \t// key authentication. It must return true iff the given public key is\n \t// valid for the given user.\n-\tPubKeyCallback func(user, algo string, pubkey []byte) bool\n+\tPublicKeyCallback func(user, algo string, pubkey []byte) bool\n \n \t// Cryptographic-related configuration.\n \tCrypto CryptoConfig\n@@ -359,7 +359,7 @@ func isAcceptableAlgo(algo string) bool {\n \n // testPubKey returns true if the given public key is acceptable for the user.\n func (s *ServerConn) testPubKey(user, algo string, pubKey []byte) bool {\n-\tif s.config.PubKeyCallback == nil || !isAcceptableAlgo(algo) {\n+\tif s.config.PublicKeyCallback == nil || !isAcceptableAlgo(algo) {\n \t\treturn false\n \t}\n \n@@ -369,7 +369,7 @@ func (s *ServerConn) testPubKey(user, algo string, pubKey []byte) bool {\n \t\t}\n \t}\n \n-\tresult := s.config.PubKeyCallback(user, algo, pubKey)\n+\tresult := s.config.PublicKeyCallback(user, algo, pubKey)\n \tif len(s.cachedPubKeys) < maxCachedPubKeys {\n \t\tc := cachedPubKey{\n \t\t\tuser:   user,\n@@ -425,7 +425,7 @@ userAuthLoop:\n \t\t\t\tbreak userAuthLoop\n \t\t\t}\n \t\tcase \"publickey\":\n-\t\t\tif s.config.PubKeyCallback == nil {\n+\t\t\tif s.config.PublicKeyCallback == nil {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tpayload := userAuthReq.Payload\n@@ -499,7 +499,7 @@ userAuthLoop:\n \t\tif s.config.PasswordCallback != nil {\n \t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"password\")\n \t\t}\n-\t\tif s.config.PubKeyCallback != nil {\n+\t\tif s.config.PublicKeyCallback != nil {\n \t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"publickey\")\n \t\t}\n "}, {"sha": "807dd8740d780eb42bc1eb0190564d089edb4662", "filename": "libgo/go/exp/ssh/session.go", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -68,10 +68,12 @@ type Session struct {\n \n \t*clientChan // the channel backing this session\n \n-\tstarted        bool // true once Start, Run or Shell is invoked.\n-\tcloseAfterWait []io.Closer\n-\tcopyFuncs      []func() error\n-\terrch          chan error // one send per copyFunc\n+\tstarted   bool // true once Start, Run or Shell is invoked.\n+\tcopyFuncs []func() error\n+\terrch     chan error // one send per copyFunc\n+\n+\t// true if pipe method is active\n+\tstdinpipe, stdoutpipe, stderrpipe bool\n }\n \n // RFC 4254 Section 6.4.\n@@ -237,11 +239,9 @@ func (s *Session) waitForResponse() error {\n func (s *Session) start() error {\n \ts.started = true\n \n-\ttype F func(*Session) error\n+\ttype F func(*Session)\n \tfor _, setupFd := range []F{(*Session).stdin, (*Session).stdout, (*Session).stderr} {\n-\t\tif err := setupFd(s); err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\tsetupFd(s)\n \t}\n \n \ts.errch = make(chan error, len(s.copyFuncs))\n@@ -274,9 +274,6 @@ func (s *Session) Wait() error {\n \t\t\tcopyError = err\n \t\t}\n \t}\n-\tfor _, fd := range s.closeAfterWait {\n-\t\tfd.Close()\n-\t}\n \tif waitErr != nil {\n \t\treturn waitErr\n \t}\n@@ -341,7 +338,10 @@ func (s *Session) wait() error {\n \treturn &ExitError{wm}\n }\n \n-func (s *Session) stdin() error {\n+func (s *Session) stdin() {\n+\tif s.stdinpipe {\n+\t\treturn\n+\t}\n \tif s.Stdin == nil {\n \t\ts.Stdin = new(bytes.Buffer)\n \t}\n@@ -352,29 +352,32 @@ func (s *Session) stdin() error {\n \t\t}\n \t\treturn err\n \t})\n-\treturn nil\n }\n \n-func (s *Session) stdout() error {\n+func (s *Session) stdout() {\n+\tif s.stdoutpipe {\n+\t\treturn\n+\t}\n \tif s.Stdout == nil {\n \t\ts.Stdout = ioutil.Discard\n \t}\n \ts.copyFuncs = append(s.copyFuncs, func() error {\n \t\t_, err := io.Copy(s.Stdout, s.clientChan.stdout)\n \t\treturn err\n \t})\n-\treturn nil\n }\n \n-func (s *Session) stderr() error {\n+func (s *Session) stderr() {\n+\tif s.stderrpipe {\n+\t\treturn\n+\t}\n \tif s.Stderr == nil {\n \t\ts.Stderr = ioutil.Discard\n \t}\n \ts.copyFuncs = append(s.copyFuncs, func() error {\n \t\t_, err := io.Copy(s.Stderr, s.clientChan.stderr)\n \t\treturn err\n \t})\n-\treturn nil\n }\n \n // StdinPipe returns a pipe that will be connected to the\n@@ -386,10 +389,8 @@ func (s *Session) StdinPipe() (io.WriteCloser, error) {\n \tif s.started {\n \t\treturn nil, errors.New(\"ssh: StdinPipe after process started\")\n \t}\n-\tpr, pw := io.Pipe()\n-\ts.Stdin = pr\n-\ts.closeAfterWait = append(s.closeAfterWait, pr)\n-\treturn pw, nil\n+\ts.stdinpipe = true\n+\treturn s.clientChan.stdin, nil\n }\n \n // StdoutPipe returns a pipe that will be connected to the\n@@ -398,17 +399,15 @@ func (s *Session) StdinPipe() (io.WriteCloser, error) {\n // stdout and stderr streams. If the StdoutPipe reader is\n // not serviced fast enought it may eventually cause the\n // remote command to block.\n-func (s *Session) StdoutPipe() (io.ReadCloser, error) {\n+func (s *Session) StdoutPipe() (io.Reader, error) {\n \tif s.Stdout != nil {\n \t\treturn nil, errors.New(\"ssh: Stdout already set\")\n \t}\n \tif s.started {\n \t\treturn nil, errors.New(\"ssh: StdoutPipe after process started\")\n \t}\n-\tpr, pw := io.Pipe()\n-\ts.Stdout = pw\n-\ts.closeAfterWait = append(s.closeAfterWait, pw)\n-\treturn pr, nil\n+\ts.stdoutpipe = true\n+\treturn s.clientChan.stdout, nil\n }\n \n // StderrPipe returns a pipe that will be connected to the\n@@ -417,17 +416,15 @@ func (s *Session) StdoutPipe() (io.ReadCloser, error) {\n // stdout and stderr streams. If the StderrPipe reader is\n // not serviced fast enought it may eventually cause the\n // remote command to block.\n-func (s *Session) StderrPipe() (io.ReadCloser, error) {\n+func (s *Session) StderrPipe() (io.Reader, error) {\n \tif s.Stderr != nil {\n \t\treturn nil, errors.New(\"ssh: Stderr already set\")\n \t}\n \tif s.started {\n \t\treturn nil, errors.New(\"ssh: StderrPipe after process started\")\n \t}\n-\tpr, pw := io.Pipe()\n-\ts.Stderr = pw\n-\ts.closeAfterWait = append(s.closeAfterWait, pw)\n-\treturn pr, nil\n+\ts.stderrpipe = true\n+\treturn s.clientChan.stderr, nil\n }\n \n // TODO(dfc) add Output and CombinedOutput helpers"}, {"sha": "2882620b0ba3c89c54953429c8e36cb45ca512e9", "filename": "libgo/go/exp/ssh/session_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -20,7 +20,7 @@ func dial(handler serverType, t *testing.T) *ClientConn {\n \tserverConfig.PasswordCallback = func(user, pass string) bool {\n \t\treturn user == \"testuser\" && pass == string(pw)\n \t}\n-\tserverConfig.PubKeyCallback = nil\n+\tserverConfig.PublicKeyCallback = nil\n \n \tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n \tif err != nil {"}, {"sha": "bee41eeb0dbc64a2c13fdd7b0d594951aa482223", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"io\"\n \t\"net\"\n )\n+\n // Dial initiates a connection to the addr from the remote host.\n // addr is resolved using net.ResolveTCPAddr before connection. \n // This could allow an observer to observe the DNS name of the "}, {"sha": "809e88cacfa3f448a391ca857ec18a10fef7733c", "filename": "libgo/go/exp/terminal/terminal.go", "status": "modified", "additions": 180, "deletions": 26, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,20 +2,65 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux\n+\n package terminal\n \n-import \"io\"\n+import (\n+\t\"io\"\n+\t\"sync\"\n+)\n+\n+// EscapeCodes contains escape sequences that can be written to the terminal in\n+// order to achieve different styles of text.\n+type EscapeCodes struct {\n+\t// Foreground colors\n+\tBlack, Red, Green, Yellow, Blue, Magenta, Cyan, White []byte\n+\n+\t// Reset all attributes\n+\tReset []byte\n+}\n+\n+var vt100EscapeCodes = EscapeCodes{\n+\tBlack:   []byte{keyEscape, '[', '3', '0', 'm'},\n+\tRed:     []byte{keyEscape, '[', '3', '1', 'm'},\n+\tGreen:   []byte{keyEscape, '[', '3', '2', 'm'},\n+\tYellow:  []byte{keyEscape, '[', '3', '3', 'm'},\n+\tBlue:    []byte{keyEscape, '[', '3', '4', 'm'},\n+\tMagenta: []byte{keyEscape, '[', '3', '5', 'm'},\n+\tCyan:    []byte{keyEscape, '[', '3', '6', 'm'},\n+\tWhite:   []byte{keyEscape, '[', '3', '7', 'm'},\n+\n+\tReset: []byte{keyEscape, '[', '0', 'm'},\n+}\n \n // Terminal contains the state for running a VT100 terminal that is capable of\n // reading lines of input.\n type Terminal struct {\n+\t// AutoCompleteCallback, if non-null, is called for each keypress\n+\t// with the full input line and the current position of the cursor.\n+\t// If it returns a nil newLine, the key press is processed normally.\n+\t// Otherwise it returns a replacement line and the new cursor position.\n+\tAutoCompleteCallback func(line []byte, pos, key int) (newLine []byte, newPos int)\n+\n+\t// Escape contains a pointer to the escape codes for this terminal.\n+\t// It's always a valid pointer, although the escape codes themselves\n+\t// may be empty if the terminal doesn't support them.\n+\tEscape *EscapeCodes\n+\n+\t// lock protects the terminal and the state in this object from\n+\t// concurrent processing of a key press and a Write() call.\n+\tlock sync.Mutex\n+\n \tc      io.ReadWriter\n \tprompt string\n \n \t// line is the current line being entered.\n \tline []byte\n \t// pos is the logical position of the cursor in line\n \tpos int\n+\t// echo is true if local echo is enabled\n+\techo bool\n \n \t// cursorX contains the current X value of the cursor where the left\n \t// edge is 0. cursorY contains the row number where the first row of\n@@ -40,10 +85,12 @@ type Terminal struct {\n // \"> \").\n func NewTerminal(c io.ReadWriter, prompt string) *Terminal {\n \treturn &Terminal{\n+\t\tEscape:     &vt100EscapeCodes,\n \t\tc:          c,\n \t\tprompt:     prompt,\n \t\ttermWidth:  80,\n \t\ttermHeight: 24,\n+\t\techo:       true,\n \t}\n }\n \n@@ -109,18 +156,11 @@ func bytesToKey(b []byte) (int, []byte) {\n \n // queue appends data to the end of t.outBuf\n func (t *Terminal) queue(data []byte) {\n-\tif len(t.outBuf)+len(data) > cap(t.outBuf) {\n-\t\tnewOutBuf := make([]byte, len(t.outBuf), 2*(len(t.outBuf)+len(data)))\n-\t\tcopy(newOutBuf, t.outBuf)\n-\t\tt.outBuf = newOutBuf\n-\t}\n-\n-\toldLen := len(t.outBuf)\n-\tt.outBuf = t.outBuf[:len(t.outBuf)+len(data)]\n-\tcopy(t.outBuf[oldLen:], data)\n+\tt.outBuf = append(t.outBuf, data...)\n }\n \n var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n+var space = []byte{' '}\n \n func isPrintable(key int) bool {\n \treturn key >= 32 && key < 127\n@@ -129,6 +169,10 @@ func isPrintable(key int) bool {\n // moveCursorToPos appends data to t.outBuf which will move the cursor to the\n // given, logical position in the text.\n func (t *Terminal) moveCursorToPos(pos int) {\n+\tif !t.echo {\n+\t\treturn\n+\t}\n+\n \tx := len(t.prompt) + pos\n \ty := x / t.termWidth\n \tx = x % t.termWidth\n@@ -153,6 +197,12 @@ func (t *Terminal) moveCursorToPos(pos int) {\n \t\tright = x - t.cursorX\n \t}\n \n+\tt.cursorX = x\n+\tt.cursorY = y\n+\tt.move(up, down, left, right)\n+}\n+\n+func (t *Terminal) move(up, down, left, right int) {\n \tmovement := make([]byte, 3*(up+down+left+right))\n \tm := movement\n \tfor i := 0; i < up; i++ {\n@@ -180,11 +230,14 @@ func (t *Terminal) moveCursorToPos(pos int) {\n \t\tm = m[3:]\n \t}\n \n-\tt.cursorX = x\n-\tt.cursorY = y\n \tt.queue(movement)\n }\n \n+func (t *Terminal) clearLineToRight() {\n+\top := []byte{keyEscape, '[', 'K'}\n+\tt.queue(op)\n+}\n+\n const maxLineLength = 4096\n \n // handleKey processes the given key and, optionally, returns a line of text\n@@ -196,12 +249,15 @@ func (t *Terminal) handleKey(key int) (line string, ok bool) {\n \t\t\treturn\n \t\t}\n \t\tt.pos--\n+\t\tt.moveCursorToPos(t.pos)\n \n \t\tcopy(t.line[t.pos:], t.line[1+t.pos:])\n \t\tt.line = t.line[:len(t.line)-1]\n-\t\tt.writeLine(t.line[t.pos:])\n-\t\tt.moveCursorToPos(t.pos)\n+\t\tif t.echo {\n+\t\t\tt.writeLine(t.line[t.pos:])\n+\t\t}\n \t\tt.queue(eraseUnderCursor)\n+\t\tt.moveCursorToPos(t.pos)\n \tcase keyAltLeft:\n \t\t// move left by a word.\n \t\tif t.pos == 0 {\n@@ -260,6 +316,25 @@ func (t *Terminal) handleKey(key int) (line string, ok bool) {\n \t\tt.cursorY = 0\n \t\tt.maxLine = 0\n \tdefault:\n+\t\tif t.AutoCompleteCallback != nil {\n+\t\t\tt.lock.Unlock()\n+\t\t\tnewLine, newPos := t.AutoCompleteCallback(t.line, t.pos, key)\n+\t\t\tt.lock.Lock()\n+\n+\t\t\tif newLine != nil {\n+\t\t\t\tif t.echo {\n+\t\t\t\t\tt.moveCursorToPos(0)\n+\t\t\t\t\tt.writeLine(newLine)\n+\t\t\t\t\tfor i := len(newLine); i < len(t.line); i++ {\n+\t\t\t\t\t\tt.writeLine(space)\n+\t\t\t\t\t}\n+\t\t\t\t\tt.moveCursorToPos(newPos)\n+\t\t\t\t}\n+\t\t\t\tt.line = newLine\n+\t\t\t\tt.pos = newPos\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n \t\tif !isPrintable(key) {\n \t\t\treturn\n \t\t}\n@@ -274,7 +349,9 @@ func (t *Terminal) handleKey(key int) (line string, ok bool) {\n \t\tt.line = t.line[:len(t.line)+1]\n \t\tcopy(t.line[t.pos+1:], t.line[t.pos:])\n \t\tt.line[t.pos] = byte(key)\n-\t\tt.writeLine(t.line[t.pos:])\n+\t\tif t.echo {\n+\t\t\tt.writeLine(t.line[t.pos:])\n+\t\t}\n \t\tt.pos++\n \t\tt.moveCursorToPos(t.pos)\n \t}\n@@ -283,15 +360,6 @@ func (t *Terminal) handleKey(key int) (line string, ok bool) {\n \n func (t *Terminal) writeLine(line []byte) {\n \tfor len(line) != 0 {\n-\t\tif t.cursorX == t.termWidth {\n-\t\t\tt.queue([]byte(\"\\r\\n\"))\n-\t\t\tt.cursorX = 0\n-\t\t\tt.cursorY++\n-\t\t\tif t.cursorY > t.maxLine {\n-\t\t\t\tt.maxLine = t.cursorY\n-\t\t\t}\n-\t\t}\n-\n \t\tremainingOnLine := t.termWidth - t.cursorX\n \t\ttodo := len(line)\n \t\tif todo > remainingOnLine {\n@@ -300,16 +368,95 @@ func (t *Terminal) writeLine(line []byte) {\n \t\tt.queue(line[:todo])\n \t\tt.cursorX += todo\n \t\tline = line[todo:]\n+\n+\t\tif t.cursorX == t.termWidth {\n+\t\t\tt.cursorX = 0\n+\t\t\tt.cursorY++\n+\t\t\tif t.cursorY > t.maxLine {\n+\t\t\t\tt.maxLine = t.cursorY\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n func (t *Terminal) Write(buf []byte) (n int, err error) {\n-\treturn t.c.Write(buf)\n+\tt.lock.Lock()\n+\tdefer t.lock.Unlock()\n+\n+\tif t.cursorX == 0 && t.cursorY == 0 {\n+\t\t// This is the easy case: there's nothing on the screen that we\n+\t\t// have to move out of the way.\n+\t\treturn t.c.Write(buf)\n+\t}\n+\n+\t// We have a prompt and possibly user input on the screen. We\n+\t// have to clear it first.\n+\tt.move(0, /* up */ 0, /* down */ t.cursorX, /* left */ 0 /* right */ )\n+\tt.cursorX = 0\n+\tt.clearLineToRight()\n+\n+\tfor t.cursorY > 0 {\n+\t\tt.move(1, /* up */ 0, 0, 0)\n+\t\tt.cursorY--\n+\t\tt.clearLineToRight()\n+\t}\n+\n+\tif _, err = t.c.Write(t.outBuf); err != nil {\n+\t\treturn\n+\t}\n+\tt.outBuf = t.outBuf[:0]\n+\n+\tif n, err = t.c.Write(buf); err != nil {\n+\t\treturn\n+\t}\n+\n+\tt.queue([]byte(t.prompt))\n+\tchars := len(t.prompt)\n+\tif t.echo {\n+\t\tt.queue(t.line)\n+\t\tchars += len(t.line)\n+\t}\n+\tt.cursorX = chars % t.termWidth\n+\tt.cursorY = chars / t.termWidth\n+\tt.moveCursorToPos(t.pos)\n+\n+\tif _, err = t.c.Write(t.outBuf); err != nil {\n+\t\treturn\n+\t}\n+\tt.outBuf = t.outBuf[:0]\n+\treturn\n+}\n+\n+// ReadPassword temporarily changes the prompt and reads a password, without\n+// echo, from the terminal.\n+func (t *Terminal) ReadPassword(prompt string) (line string, err error) {\n+\tt.lock.Lock()\n+\tdefer t.lock.Unlock()\n+\n+\toldPrompt := t.prompt\n+\tt.prompt = prompt\n+\tt.echo = false\n+\n+\tline, err = t.readLine()\n+\n+\tt.prompt = oldPrompt\n+\tt.echo = true\n+\n+\treturn\n }\n \n // ReadLine returns a line of input from the terminal.\n func (t *Terminal) ReadLine() (line string, err error) {\n-\tif t.cursorX == 0 {\n+\tt.lock.Lock()\n+\tdefer t.lock.Unlock()\n+\n+\treturn t.readLine()\n+}\n+\n+func (t *Terminal) readLine() (line string, err error) {\n+\t// t.lock must be held at this point\n+\n+\tif t.cursorX == 0 && t.cursorY == 0 {\n \t\tt.writeLine([]byte(t.prompt))\n \t\tt.c.Write(t.outBuf)\n \t\tt.outBuf = t.outBuf[:0]\n@@ -320,7 +467,11 @@ func (t *Terminal) ReadLine() (line string, err error) {\n \t\t// containing a partial key sequence\n \t\treadBuf := t.inBuf[len(t.remainder):]\n \t\tvar n int\n+\n+\t\tt.lock.Unlock()\n \t\tn, err = t.c.Read(readBuf)\n+\t\tt.lock.Lock()\n+\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -358,5 +509,8 @@ func (t *Terminal) ReadLine() (line string, err error) {\n }\n \n func (t *Terminal) SetSize(width, height int) {\n+\tt.lock.Lock()\n+\tdefer t.lock.Unlock()\n+\n \tt.termWidth, t.termHeight = width, height\n }"}, {"sha": "75628f695e989e41fe5f6e8d48b24955f975dcfe", "filename": "libgo/go/exp/terminal/terminal_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux\n+\n package terminal\n \n import ("}, {"sha": "a5bbfca3b46b4e565c785ee1b6afe1dd11178adf", "filename": "libgo/go/exp/terminal/util.go", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,21 +2,24 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build linux\n+\n // Package terminal provides support functions for dealing with terminals, as\n // commonly found on UNIX systems.\n //\n // Putting a terminal into raw mode is the most common requirement:\n //\n // \toldState, err := terminal.MakeRaw(0)\n // \tif err != nil {\n-// \t        panic(err.String())\n+// \t        panic(err)\n // \t}\n // \tdefer terminal.Restore(0, oldState)\n package terminal\n \n import (\n \t\"io\"\n \t\"syscall\"\n+\t\"unsafe\"\n )\n \n // State contains the state of a terminal.\n@@ -57,6 +60,18 @@ func Restore(fd int, state *State) error {\n \treturn err\n }\n \n+func ioctl(int, int, unsafe.Pointer) int __asm__(\"ioctl\")\n+\n+// GetSize returns the dimensions of the given terminal.\n+func GetSize(fd int) (width, height int, err error) {\n+\tvar dimensions [4]uint16\n+\n+\tif ioctl(fd, syscall.TIOCGWINSZ, unsafe.Pointer(&dimensions)) < 0 {\n+\t\treturn -1, -1, syscall.GetErrno()\n+\t}\n+\treturn int(dimensions[1]), int(dimensions[0]), nil\n+}\n+\n // ReadPassword reads a line of input from a terminal without local echo.  This\n // is commonly used for inputting passwords and other sensitive data. The slice\n // returned does not include the \\n."}, {"sha": "a6e3a6a8fb75e2428bda27cedda9dfd5bbe1d719", "filename": "libgo/go/exp/winfsnotify/winfsnotify.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build windows\n+\n // Package winfsnotify allows the user to receive\n // file system event notifications on Windows.\n package winfsnotify"}, {"sha": "59ac1624a265c81b319f6eccb8a7cd420be11914", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build windows\n+\n package winfsnotify\n \n import ("}, {"sha": "3b79873fa2bda394dda1456f83c074cbae980030", "filename": "libgo/go/exp/wingui/gui.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build windows\n+\n package main\n \n import ("}, {"sha": "f876088e91fc893dac2ea6b634301358aad0fbf6", "filename": "libgo/go/exp/wingui/winapi.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build windows\n+\n package main\n \n import ("}, {"sha": "5666c6de5308f95d424ea21f8f5fb2999e4e150b", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -1,3 +1,4 @@\n+// +build windows\n // mksyscall_windows.pl winapi.go\n // MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n "}, {"sha": "d34a4f8fd2d368c2ce81f4497d26ee69be6c4d45", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 31, "deletions": 67, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -506,78 +506,42 @@ func BenchmarkSprintfFloat(b *testing.B) {\n \t}\n }\n \n+var mallocBuf bytes.Buffer\n+\n+var mallocTest = []struct {\n+\tcount int\n+\tdesc  string\n+\tfn    func()\n+}{\n+\t{0, `Sprintf(\"\")`, func() { Sprintf(\"\") }},\n+\t{1, `Sprintf(\"xxx\")`, func() { Sprintf(\"xxx\") }},\n+\t{1, `Sprintf(\"%x\")`, func() { Sprintf(\"%x\", 7) }},\n+\t{2, `Sprintf(\"%s\")`, func() { Sprintf(\"%s\", \"hello\") }},\n+\t{1, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x\", 7, 112) }},\n+\t{1, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", 3.14159) }},\n+\t{0, `Fprintf(buf, \"%x %x %x\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%x %x %x\", 7, 8, 9) }},\n+\t{1, `Fprintf(buf, \"%s\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%s\", \"hello\") }},\n+}\n+\n+var _ bytes.Buffer\n+\n func TestCountMallocs(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n \t}\n-\tconst N = 100\n-\truntime.UpdateMemStats()\n-\tmallocs := 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"\")\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"xxx\")\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"xxx\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"%x\", i)\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%x\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"%s\", \"hello\")\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%s\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"%x %x\", i, i)\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%x %%x\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tSprintf(\"%g\", 3.14159)\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Sprintf(\\\"%%g\\\"): %d\\n\", mallocs/N)\n-\tbuf := new(bytes.Buffer)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tbuf.Reset()\n-\t\tFprintf(buf, \"%x %x %x\", i, i, i)\n-\t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Fprintf(buf, \\\"%%x %%x %%x\\\"): %d\\n\", mallocs/N)\n-\truntime.UpdateMemStats()\n-\tmallocs = 0 - runtime.MemStats.Mallocs\n-\tfor i := 0; i < N; i++ {\n-\t\tbuf.Reset()\n-\t\tFprintf(buf, \"%s\", \"hello\")\n+\tfor _, mt := range mallocTest {\n+\t\tconst N = 100\n+\t\truntime.UpdateMemStats()\n+\t\tmallocs := 0 - runtime.MemStats.Mallocs\n+\t\tfor i := 0; i < N; i++ {\n+\t\t\tmt.fn()\n+\t\t}\n+\t\truntime.UpdateMemStats()\n+\t\tmallocs += runtime.MemStats.Mallocs\n+\t\tif mallocs/N != uint64(mt.count) {\n+\t\t\tt.Errorf(\"%s: expected %d mallocs, got %d\", mt.desc, mt.count, mallocs/N)\n+\t\t}\n \t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n-\tPrintf(\"mallocs per Fprintf(buf, \\\"%%s\\\"): %d\\n\", mallocs/N)\n }\n \n type flagPrinter struct{}"}, {"sha": "78d9e998b1fe0c32c5d600c02ac6fe114c15ba9d", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -154,12 +154,17 @@ func putint(buf []byte, base, val uint64, digits string) int {\n \treturn i - 1\n }\n \n+var (\n+\ttrueBytes  = []byte(\"true\")\n+\tfalseBytes = []byte(\"false\")\n+)\n+\n // fmt_boolean formats a boolean.\n func (f *fmt) fmt_boolean(v bool) {\n \tif v {\n-\t\tf.padString(\"true\")\n+\t\tf.pad(trueBytes)\n \t} else {\n-\t\tf.padString(\"false\")\n+\t\tf.pad(falseBytes)\n \t}\n }\n \n@@ -283,31 +288,18 @@ func (f *fmt) fmt_s(s string) {\n }\n \n // fmt_sx formats a string as a hexadecimal encoding of its bytes.\n-func (f *fmt) fmt_sx(s string) {\n-\tt := \"\"\n+func (f *fmt) fmt_sx(s, digits string) {\n+\t// TODO: Avoid buffer by pre-padding.\n+\tvar b bytes.Buffer\n \tfor i := 0; i < len(s); i++ {\n \t\tif i > 0 && f.space {\n-\t\t\tt += \" \"\n+\t\t\tb.WriteByte(' ')\n \t\t}\n \t\tv := s[i]\n-\t\tt += string(ldigits[v>>4])\n-\t\tt += string(ldigits[v&0xF])\n+\t\tb.WriteByte(digits[v>>4])\n+\t\tb.WriteByte(digits[v&0xF])\n \t}\n-\tf.padString(t)\n-}\n-\n-// fmt_sX formats a string as an uppercase hexadecimal encoding of its bytes.\n-func (f *fmt) fmt_sX(s string) {\n-\tt := \"\"\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif i > 0 && f.space {\n-\t\t\tt += \" \"\n-\t\t}\n-\t\tv := s[i]\n-\t\tt += string(udigits[v>>4])\n-\t\tt += string(udigits[v&0xF])\n-\t}\n-\tf.padString(t)\n+\tf.pad(b.Bytes())\n }\n \n // fmt_q formats a string as a double-quoted, escaped Go string constant.\n@@ -329,13 +321,13 @@ func (f *fmt) fmt_q(s string) {\n // fmt_qc formats the integer as a single-quoted, escaped Go character constant.\n // If the character is not valid Unicode, it will print '\\ufffd'.\n func (f *fmt) fmt_qc(c int64) {\n-\tvar quoted string\n+\tvar quoted []byte\n \tif f.plus {\n-\t\tquoted = strconv.QuoteRuneToASCII(rune(c))\n+\t\tquoted = strconv.AppendQuoteRuneToASCII(f.intbuf[0:0], rune(c))\n \t} else {\n-\t\tquoted = strconv.QuoteRune(rune(c))\n+\t\tquoted = strconv.AppendQuoteRune(f.intbuf[0:0], rune(c))\n \t}\n-\tf.padString(quoted)\n+\tf.pad(quoted)\n }\n \n // floating-point\n@@ -347,57 +339,70 @@ func doPrec(f *fmt, def int) int {\n \treturn def\n }\n \n-// Add a plus sign or space to the floating-point string representation if missing and required.\n-func (f *fmt) plusSpace(s string) {\n-\tif s[0] != '-' {\n+// formatFloat formats a float64; it is an efficient equivalent to  f.pad(strconv.FormatFloat()...).\n+func (f *fmt) formatFloat(v float64, verb byte, prec, n int) {\n+\t// We leave one byte at the beginning of f.intbuf for a sign if needed,\n+\t// and make it a space, which we might be able to use.\n+\tf.intbuf[0] = ' '\n+\tslice := strconv.AppendFloat(f.intbuf[0:1], v, verb, prec, n)\n+\t// Add a plus sign or space to the floating-point string representation if missing and required.\n+\t// The formatted number starts at slice[1].\n+\tswitch slice[1] {\n+\tcase '-', '+':\n+\t\t// We're set; drop the leading space.\n+\t\tslice = slice[1:]\n+\tdefault:\n+\t\t// There's no sign, but we might need one.\n \t\tif f.plus {\n-\t\t\ts = \"+\" + s\n+\t\t\tslice[0] = '+'\n \t\t} else if f.space {\n-\t\t\ts = \" \" + s\n+\t\t\t// space is already there\n+\t\t} else {\n+\t\t\tslice = slice[1:]\n \t\t}\n \t}\n-\tf.padString(s)\n+\tf.pad(slice)\n }\n \n // fmt_e64 formats a float64 in the form -1.23e+12.\n-func (f *fmt) fmt_e64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'e', doPrec(f, 6), 64)) }\n+func (f *fmt) fmt_e64(v float64) { f.formatFloat(v, 'e', doPrec(f, 6), 64) }\n \n // fmt_E64 formats a float64 in the form -1.23E+12.\n-func (f *fmt) fmt_E64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'E', doPrec(f, 6), 64)) }\n+func (f *fmt) fmt_E64(v float64) { f.formatFloat(v, 'E', doPrec(f, 6), 64) }\n \n // fmt_f64 formats a float64 in the form -1.23.\n-func (f *fmt) fmt_f64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'f', doPrec(f, 6), 64)) }\n+func (f *fmt) fmt_f64(v float64) { f.formatFloat(v, 'f', doPrec(f, 6), 64) }\n \n // fmt_g64 formats a float64 in the 'f' or 'e' form according to size.\n-func (f *fmt) fmt_g64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'g', doPrec(f, -1), 64)) }\n+func (f *fmt) fmt_g64(v float64) { f.formatFloat(v, 'g', doPrec(f, -1), 64) }\n \n // fmt_g64 formats a float64 in the 'f' or 'E' form according to size.\n-func (f *fmt) fmt_G64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'G', doPrec(f, -1), 64)) }\n+func (f *fmt) fmt_G64(v float64) { f.formatFloat(v, 'G', doPrec(f, -1), 64) }\n \n // fmt_fb64 formats a float64 in the form -123p3 (exponent is power of 2).\n-func (f *fmt) fmt_fb64(v float64) { f.plusSpace(strconv.FormatFloat(v, 'b', 0, 64)) }\n+func (f *fmt) fmt_fb64(v float64) { f.formatFloat(v, 'b', 0, 64) }\n \n // float32\n // cannot defer to float64 versions\n // because it will get rounding wrong in corner cases.\n \n // fmt_e32 formats a float32 in the form -1.23e+12.\n-func (f *fmt) fmt_e32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'e', doPrec(f, 6), 32)) }\n+func (f *fmt) fmt_e32(v float32) { f.formatFloat(float64(v), 'e', doPrec(f, 6), 32) }\n \n // fmt_E32 formats a float32 in the form -1.23E+12.\n-func (f *fmt) fmt_E32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'E', doPrec(f, 6), 32)) }\n+func (f *fmt) fmt_E32(v float32) { f.formatFloat(float64(v), 'E', doPrec(f, 6), 32) }\n \n // fmt_f32 formats a float32 in the form -1.23.\n-func (f *fmt) fmt_f32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'f', doPrec(f, 6), 32)) }\n+func (f *fmt) fmt_f32(v float32) { f.formatFloat(float64(v), 'f', doPrec(f, 6), 32) }\n \n // fmt_g32 formats a float32 in the 'f' or 'e' form according to size.\n-func (f *fmt) fmt_g32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'g', doPrec(f, -1), 32)) }\n+func (f *fmt) fmt_g32(v float32) { f.formatFloat(float64(v), 'g', doPrec(f, -1), 32) }\n \n // fmt_G32 formats a float32 in the 'f' or 'E' form according to size.\n-func (f *fmt) fmt_G32(v float32) { f.plusSpace(strconv.FormatFloat(float64(v), 'G', doPrec(f, -1), 32)) }\n+func (f *fmt) fmt_G32(v float32) { f.formatFloat(float64(v), 'G', doPrec(f, -1), 32) }\n \n // fmt_fb32 formats a float32 in the form -123p3 (exponent is power of 2).\n-func (f *fmt) fmt_fb32(v float32) { f.padString(strconv.FormatFloat(float64(v), 'b', 0, 32)) }\n+func (f *fmt) fmt_fb32(v float32) { f.formatFloat(float64(v), 'b', 0, 32) }\n \n // fmt_c64 formats a complex64 according to the verb.\n func (f *fmt) fmt_c64(v complex64, verb rune) {"}, {"sha": "3b7d3464e209a215e4d65fa7e88bca721e218c21", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -503,9 +503,9 @@ func (p *pp) fmtString(v string, verb rune, goSyntax bool) {\n \tcase 's':\n \t\tp.fmt.fmt_s(v)\n \tcase 'x':\n-\t\tp.fmt.fmt_sx(v)\n+\t\tp.fmt.fmt_sx(v, ldigits)\n \tcase 'X':\n-\t\tp.fmt.fmt_sX(v)\n+\t\tp.fmt.fmt_sx(v, udigits)\n \tcase 'q':\n \t\tp.fmt.fmt_q(v)\n \tdefault:\n@@ -542,9 +542,9 @@ func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, depth int) {\n \tcase 's':\n \t\tp.fmt.fmt_s(s)\n \tcase 'x':\n-\t\tp.fmt.fmt_sx(s)\n+\t\tp.fmt.fmt_sx(s, ldigits)\n \tcase 'X':\n-\t\tp.fmt.fmt_sX(s)\n+\t\tp.fmt.fmt_sx(s, udigits)\n \tcase 'q':\n \t\tp.fmt.fmt_q(s)\n \tdefault:"}, {"sha": "fbe4779671ec8fc67b857d89eae1c6e6cb01422a", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -80,7 +80,7 @@ func (s *Scope) String() string {\n type Object struct {\n \tKind ObjKind\n \tName string      // declared name\n-\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, or LabeledStmt; or nil\n+\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, or AssignStmt; or nil\n \tData interface{} // object-specific data; or nil\n \tType interface{} // place holder for type information; may be nil\n }\n@@ -125,6 +125,12 @@ func (obj *Object) Pos() token.Pos {\n \t\tif d.Label.Name == name {\n \t\t\treturn d.Label.Pos()\n \t\t}\n+\tcase *AssignStmt:\n+\t\tfor _, x := range d.Lhs {\n+\t\t\tif ident, isIdent := x.(*Ident); isIdent && ident.Name == name {\n+\t\t\t\treturn ident.Pos()\n+\t\t\t}\n+\t\t}\n \t}\n \treturn token.NoPos\n }"}, {"sha": "fd4030632a9d8dc77cc9e898fdc6d3ef1f756501", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -46,15 +46,23 @@ var buildPkgs = []struct {\n \t{\n \t\t\"go/build/cgotest\",\n \t\t&DirInfo{\n-\t\t\tCgoFiles:    []string{\"cgotest.go\"},\n+\t\t\tCgoFiles:    ifCgo([]string{\"cgotest.go\"}),\n \t\t\tCFiles:      []string{\"cgotest.c\"},\n+\t\t\tHFiles:      []string{\"cgotest.h\"},\n \t\t\tImports:     []string{\"C\", \"unsafe\"},\n \t\t\tTestImports: []string{},\n \t\t\tPackage:     \"cgotest\",\n \t\t},\n \t},\n }\n \n+func ifCgo(x []string) []string {\n+\tif DefaultContext.CgoEnabled {\n+\t\treturn x\n+\t}\n+\treturn nil\n+}\n+\n const cmdtestOutput = \"3\"\n \n func TestBuild(t *testing.T) {\n@@ -71,6 +79,10 @@ func TestBuild(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n+\t\tif tt.dir == \"go/build/cgotest\" && len(info.CgoFiles) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n \t\ts, err := Build(tree, tt.dir, info)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"Build(%#q): %v\", tt.dir, err)"}, {"sha": "265261f22eaaac2c71c7f43290a343a7b765f423", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -26,9 +26,9 @@ import (\n \n // A Context specifies the supporting context for a build.\n type Context struct {\n-\tGOARCH string // target architecture\n-\tGOOS   string // target operating system\n-\t// TODO(rsc,adg): GOPATH\n+\tGOARCH     string // target architecture\n+\tGOOS       string // target operating system\n+\tCgoEnabled bool   // whether cgo can be used\n \n \t// By default, ScanDir uses the operating system's\n \t// file system calls to read directories and files.\n@@ -75,9 +75,36 @@ func (ctxt *Context) readFile(dir, file string) (string, []byte, error) {\n // The DefaultContext is the default Context for builds.\n // It uses the GOARCH and GOOS environment variables\n // if set, or else the compiled code's GOARCH and GOOS.\n-var DefaultContext = Context{\n-\tGOARCH: envOr(\"GOARCH\", runtime.GOARCH),\n-\tGOOS:   envOr(\"GOOS\", runtime.GOOS),\n+var DefaultContext = defaultContext()\n+\n+var cgoEnabled = map[string]bool{\n+\t\"darwin/386\":    true,\n+\t\"darwin/amd64\":  true,\n+\t\"linux/386\":     true,\n+\t\"linux/amd64\":   true,\n+\t\"freebsd/386\":   true,\n+\t\"freebsd/amd64\": true,\n+\t\"windows/386\":   true,\n+\t\"windows/amd64\": true,\n+}\n+\n+func defaultContext() Context {\n+\tvar c Context\n+\n+\tc.GOARCH = envOr(\"GOARCH\", runtime.GOARCH)\n+\tc.GOOS = envOr(\"GOOS\", runtime.GOOS)\n+\n+\ts := os.Getenv(\"CGO_ENABLED\")\n+\tswitch s {\n+\tcase \"1\":\n+\t\tc.CgoEnabled = true\n+\tcase \"0\":\n+\t\tc.CgoEnabled = false\n+\tdefault:\n+\t\tc.CgoEnabled = cgoEnabled[c.GOOS+\"/\"+c.GOARCH]\n+\t}\n+\n+\treturn c\n }\n \n func envOr(name, def string) string {\n@@ -96,8 +123,9 @@ type DirInfo struct {\n \n \t// Source files\n \tGoFiles  []string // .go files in dir (excluding CgoFiles)\n+\tHFiles   []string // .h files in dir\n \tCFiles   []string // .c files in dir\n-\tSFiles   []string // .s files in dir\n+\tSFiles   []string // .s (and, when using cgo, .S files in dir)\n \tCgoFiles []string // .go files that import \"C\"\n \n \t// Cgo directives\n@@ -135,6 +163,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\treturn nil, err\n \t}\n \n+\tvar Sfiles []string // files with \".S\" (capital S)\n \tvar di DirInfo\n \timported := make(map[string]bool)\n \ttestImported := make(map[string]bool)\n@@ -154,7 +183,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \n \t\text := path.Ext(name)\n \t\tswitch ext {\n-\t\tcase \".go\", \".c\", \".s\":\n+\t\tcase \".go\", \".c\", \".s\", \".h\", \".S\":\n \t\t\t// tentatively okay\n \t\tdefault:\n \t\t\t// skip\n@@ -175,9 +204,15 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\tcase \".c\":\n \t\t\tdi.CFiles = append(di.CFiles, name)\n \t\t\tcontinue\n+\t\tcase \".h\":\n+\t\t\tdi.HFiles = append(di.HFiles, name)\n+\t\t\tcontinue\n \t\tcase \".s\":\n \t\t\tdi.SFiles = append(di.SFiles, name)\n \t\t\tcontinue\n+\t\tcase \".S\":\n+\t\t\tSfiles = append(Sfiles, name)\n+\t\t\tcontinue\n \t\t}\n \n \t\tpf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)\n@@ -256,7 +291,9 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\t}\n \t\t}\n \t\tif isCgo {\n-\t\t\tdi.CgoFiles = append(di.CgoFiles, name)\n+\t\t\tif ctxt.CgoEnabled {\n+\t\t\t\tdi.CgoFiles = append(di.CgoFiles, name)\n+\t\t\t}\n \t\t} else if isTest {\n \t\t\tif pkg == string(pf.Name.Name) {\n \t\t\t\tdi.TestGoFiles = append(di.TestGoFiles, name)\n@@ -282,14 +319,22 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\tdi.TestImports[i] = p\n \t\ti++\n \t}\n+\n+\t// add the .S files only if we are using cgo\n+\t// (which means gcc will compile them).\n+\t// The standard assemblers expect .s files.\n+\tif len(di.CgoFiles) > 0 {\n+\t\tdi.SFiles = append(di.SFiles, Sfiles...)\n+\t\tsort.Strings(di.SFiles)\n+\t}\n+\n \t// File name lists are sorted because ReadDir sorts.\n \tsort.Strings(di.Imports)\n \tsort.Strings(di.TestImports)\n \treturn &di, nil\n }\n \n var slashslash = []byte(\"//\")\n-var plusBuild = []byte(\"+build\")\n \n // shouldBuild reports whether it is okay to use this file,\n // The rule is that in the file's leading run of // comments\n@@ -510,14 +555,22 @@ func splitQuoted(s string) (r []string, err error) {\n //\n //\t$GOOS\n //\t$GOARCH\n-//\t$GOOS/$GOARCH\n+//\tcgo (if cgo is enabled)\n+//\tnocgo (if cgo is disabled)\n+//\ta slash-separated list of any of these\n //\n func (ctxt *Context) matchOSArch(name string) bool {\n+\tif ctxt.CgoEnabled && name == \"cgo\" {\n+\t\treturn true\n+\t}\n+\tif !ctxt.CgoEnabled && name == \"nocgo\" {\n+\t\treturn true\n+\t}\n \tif name == ctxt.GOOS || name == ctxt.GOARCH {\n \t\treturn true\n \t}\n \ti := strings.Index(name, \"/\")\n-\treturn i >= 0 && name[:i] == ctxt.GOOS && name[i+1:] == ctxt.GOARCH\n+\treturn i >= 0 && ctxt.matchOSArch(name[:i]) && ctxt.matchOSArch(name[i+1:])\n }\n \n // goodOSArchFile returns false if the name contains a $GOOS or $GOARCH"}, {"sha": "7a281800c2828afe57bdbe3cde1286b49f804d30", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -57,7 +57,7 @@ func (t *Tree) PkgDir() string {\n func (t *Tree) BinDir() string {\n \tif t.Goroot {\n \t\tif gobin := os.Getenv(\"GOBIN\"); gobin != \"\" {\n-\t\t\treturn gobin\n+\t\t\treturn filepath.Clean(gobin)\n \t\t}\n \t}\n \treturn filepath.Join(t.Path, \"bin\")\n@@ -85,8 +85,8 @@ func (t *Tree) HasPkg(pkg string) bool {\n }\n \n var (\n-\tErrNotFound     = errors.New(\"go/build: package could not be found locally\")\n-\tErrTreeNotFound = errors.New(\"go/build: no valid GOROOT or GOPATH could be found\")\n+\tErrNotFound     = errors.New(\"package could not be found locally\")\n+\tErrTreeNotFound = errors.New(\"no valid GOROOT or GOPATH could be found\")\n )\n \n // FindTree takes an import or filesystem path and returns the\n@@ -151,7 +151,7 @@ func init() {\n \troot := runtime.GOROOT()\n \tt, err := newTree(root)\n \tif err != nil {\n-\t\tlog.Printf(\"go/build: invalid GOROOT %q: %v\", root, err)\n+\t\tlog.Printf(\"invalid GOROOT %q: %v\", root, err)\n \t} else {\n \t\tt.Goroot = true\n \t\tPath = []*Tree{t}\n@@ -163,7 +163,7 @@ func init() {\n \t\t}\n \t\tt, err := newTree(p)\n \t\tif err != nil {\n-\t\t\tlog.Printf(\"go/build: invalid GOPATH %q: %v\", p, err)\n+\t\t\tlog.Printf(\"invalid GOPATH %q: %v\", p, err)\n \t\t\tcontinue\n \t\t}\n \t\tPath = append(Path, t)"}, {"sha": "1bb22416c78ad9f81a5103a50cf145c83cc94a99", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 222, "deletions": 169, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -13,17 +13,32 @@ import (\n )\n \n // ----------------------------------------------------------------------------\n+// Collection of documentation info\n \n-type typeDoc struct {\n+// embeddedType describes the type of an anonymous field.\n+//\n+type embeddedType struct {\n+\ttyp *typeInfo // the corresponding base type\n+\tptr bool      // if set, the anonymous field type is a pointer\n+}\n+\n+type typeInfo struct {\n \t// len(decl.Specs) == 1, and the element type is *ast.TypeSpec\n \t// if the type declaration hasn't been seen yet, decl is nil\n-\tdecl *ast.GenDecl\n-\t// values, factory functions, and methods associated with the type\n+\tdecl     *ast.GenDecl\n+\tembedded []embeddedType\n+\tforward  *TypeDoc // forward link to processed type documentation\n+\n+\t// declarations associated with the type\n \tvalues    []*ast.GenDecl // consts and vars\n \tfactories map[string]*ast.FuncDecl\n \tmethods   map[string]*ast.FuncDecl\n }\n \n+func (info *typeInfo) addEmbeddedType(embedded *typeInfo, isPtr bool) {\n+\tinfo.embedded = append(info.embedded, embeddedType{embedded, isPtr})\n+}\n+\n // docReader accumulates documentation for a single package.\n // It modifies the AST: Comments (declaration documentation)\n // that have been collected by the DocReader are set to nil\n@@ -32,17 +47,19 @@ type typeDoc struct {\n // printing the corresponding AST node).\n //\n type docReader struct {\n-\tdoc     *ast.CommentGroup // package documentation, if any\n-\tpkgName string\n-\tvalues  []*ast.GenDecl // consts and vars\n-\ttypes   map[string]*typeDoc\n-\tfuncs   map[string]*ast.FuncDecl\n-\tbugs    []*ast.CommentGroup\n+\tdoc      *ast.CommentGroup // package documentation, if any\n+\tpkgName  string\n+\tvalues   []*ast.GenDecl // consts and vars\n+\ttypes    map[string]*typeInfo\n+\tembedded map[string]*typeInfo // embedded types, possibly not exported\n+\tfuncs    map[string]*ast.FuncDecl\n+\tbugs     []*ast.CommentGroup\n }\n \n func (doc *docReader) init(pkgName string) {\n \tdoc.pkgName = pkgName\n-\tdoc.types = make(map[string]*typeDoc)\n+\tdoc.types = make(map[string]*typeInfo)\n+\tdoc.embedded = make(map[string]*typeInfo)\n \tdoc.funcs = make(map[string]*ast.FuncDecl)\n }\n \n@@ -52,56 +69,40 @@ func (doc *docReader) addDoc(comments *ast.CommentGroup) {\n \t\tdoc.doc = comments\n \t\treturn\n \t}\n-\n \t// More than one package comment: Usually there will be only\n \t// one file with a package comment, but it's better to collect\n \t// all comments than drop them on the floor.\n-\t// (This code isn't particularly clever - no amortized doubling is\n-\t// used - but this situation occurs rarely and is not time-critical.)\n-\tn1 := len(doc.doc.List)\n-\tn2 := len(comments.List)\n-\tlist := make([]*ast.Comment, n1+1+n2) // + 1 for separator line\n-\tcopy(list, doc.doc.List)\n-\tlist[n1] = &ast.Comment{token.NoPos, \"//\"} // separator line\n-\tcopy(list[n1+1:], comments.List)\n-\tdoc.doc = &ast.CommentGroup{list}\n-}\n-\n-func (doc *docReader) addType(decl *ast.GenDecl) {\n-\tspec := decl.Specs[0].(*ast.TypeSpec)\n-\ttyp := doc.lookupTypeDoc(spec.Name.Name)\n-\t// typ should always be != nil since declared types\n-\t// are always named - be conservative and check\n-\tif typ != nil {\n-\t\t// a type should be added at most once, so typ.decl\n-\t\t// should be nil - if it isn't, simply overwrite it\n-\t\ttyp.decl = decl\n-\t}\n+\tblankComment := &ast.Comment{token.NoPos, \"//\"}\n+\tlist := append(doc.doc.List, blankComment)\n+\tdoc.doc.List = append(list, comments.List...)\n }\n \n-func (doc *docReader) lookupTypeDoc(name string) *typeDoc {\n-\tif name == \"\" {\n+func (doc *docReader) lookupTypeInfo(name string) *typeInfo {\n+\tif name == \"\" || name == \"_\" {\n \t\treturn nil // no type docs for anonymous types\n \t}\n-\tif tdoc, found := doc.types[name]; found {\n-\t\treturn tdoc\n+\tif info, found := doc.types[name]; found {\n+\t\treturn info\n \t}\n \t// type wasn't found - add one without declaration\n-\ttdoc := &typeDoc{nil, nil, make(map[string]*ast.FuncDecl), make(map[string]*ast.FuncDecl)}\n-\tdoc.types[name] = tdoc\n-\treturn tdoc\n+\tinfo := &typeInfo{\n+\t\tfactories: make(map[string]*ast.FuncDecl),\n+\t\tmethods:   make(map[string]*ast.FuncDecl),\n+\t}\n+\tdoc.types[name] = info\n+\treturn info\n }\n \n-func baseTypeName(typ ast.Expr) string {\n+func baseTypeName(typ ast.Expr, allTypes bool) string {\n \tswitch t := typ.(type) {\n \tcase *ast.Ident:\n \t\t// if the type is not exported, the effect to\n \t\t// a client is as if there were no type name\n-\t\tif t.IsExported() {\n+\t\tif t.IsExported() || allTypes {\n \t\t\treturn t.Name\n \t\t}\n \tcase *ast.StarExpr:\n-\t\treturn baseTypeName(t.X)\n+\t\treturn baseTypeName(t.X, allTypes)\n \t}\n \treturn \"\"\n }\n@@ -120,7 +121,7 @@ func (doc *docReader) addValue(decl *ast.GenDecl) {\n \t\t\tswitch {\n \t\t\tcase v.Type != nil:\n \t\t\t\t// a type is present; determine its name\n-\t\t\t\tname = baseTypeName(v.Type)\n+\t\t\t\tname = baseTypeName(v.Type, false)\n \t\t\tcase decl.Tok == token.CONST:\n \t\t\t\t// no type is present but we have a constant declaration;\n \t\t\t\t// use the previous type name (w/o more type information\n@@ -148,7 +149,7 @@ func (doc *docReader) addValue(decl *ast.GenDecl) {\n \tvalues := &doc.values\n \tif domName != \"\" && domFreq >= int(float64(len(decl.Specs))*threshold) {\n \t\t// typed entries are sufficiently frequent\n-\t\ttyp := doc.lookupTypeDoc(domName)\n+\t\ttyp := doc.lookupTypeInfo(domName)\n \t\tif typ != nil {\n \t\t\tvalues = &typ.values // associate with that type\n \t\t}\n@@ -175,10 +176,13 @@ func setFunc(table map[string]*ast.FuncDecl, f *ast.FuncDecl) {\n }\n \n func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n+\t// strip function body\n+\tfun.Body = nil\n+\n \t// determine if it should be associated with a type\n \tif fun.Recv != nil {\n \t\t// method\n-\t\ttyp := doc.lookupTypeDoc(baseTypeName(fun.Recv.List[0].Type))\n+\t\ttyp := doc.lookupTypeInfo(baseTypeName(fun.Recv.List[0].Type, false))\n \t\tif typ != nil {\n \t\t\t// exported receiver type\n \t\t\tsetFunc(typ.methods, fun)\n@@ -199,8 +203,8 @@ func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n \t\t\t// exactly one (named or anonymous) result associated\n \t\t\t// with the first type in result signature (there may\n \t\t\t// be more than one result)\n-\t\t\ttname := baseTypeName(res.Type)\n-\t\t\ttyp := doc.lookupTypeDoc(tname)\n+\t\t\ttname := baseTypeName(res.Type, false)\n+\t\t\ttyp := doc.lookupTypeInfo(tname)\n \t\t\tif typ != nil {\n \t\t\t\t// named and exported result type\n \t\t\t\tsetFunc(typ.factories, fun)\n@@ -224,19 +228,50 @@ func (doc *docReader) addDecl(decl ast.Decl) {\n \t\t\tcase token.TYPE:\n \t\t\t\t// types are handled individually\n \t\t\t\tfor _, spec := range d.Specs {\n-\t\t\t\t\t// make a (fake) GenDecl node for this TypeSpec\n+\t\t\t\t\ttspec := spec.(*ast.TypeSpec)\n+\t\t\t\t\t// add the type to the documentation\n+\t\t\t\t\tinfo := doc.lookupTypeInfo(tspec.Name.Name)\n+\t\t\t\t\tif info == nil {\n+\t\t\t\t\t\tcontinue // no name - ignore the type\n+\t\t\t\t\t}\n+\t\t\t\t\t// Make a (fake) GenDecl node for this TypeSpec\n \t\t\t\t\t// (we need to do this here - as opposed to just\n \t\t\t\t\t// for printing - so we don't lose the GenDecl\n-\t\t\t\t\t// documentation)\n+\t\t\t\t\t// documentation). Since a new GenDecl node is\n+\t\t\t\t\t// created, there's no need to nil out d.Doc.\n \t\t\t\t\t//\n \t\t\t\t\t// TODO(gri): Consider just collecting the TypeSpec\n \t\t\t\t\t// node (and copy in the GenDecl.doc if there is no\n \t\t\t\t\t// doc in the TypeSpec - this is currently done in\n \t\t\t\t\t// makeTypeDocs below). Simpler data structures, but\n \t\t\t\t\t// would lose GenDecl documentation if the TypeSpec\n \t\t\t\t\t// has documentation as well.\n-\t\t\t\t\tdoc.addType(&ast.GenDecl{d.Doc, d.Pos(), token.TYPE, token.NoPos, []ast.Spec{spec}, token.NoPos})\n-\t\t\t\t\t// A new GenDecl node is created, no need to nil out d.Doc.\n+\t\t\t\t\tfake := &ast.GenDecl{d.Doc, d.Pos(), token.TYPE, token.NoPos,\n+\t\t\t\t\t\t[]ast.Spec{tspec}, token.NoPos}\n+\t\t\t\t\t// A type should be added at most once, so info.decl\n+\t\t\t\t\t// should be nil - if it isn't, simply overwrite it.\n+\t\t\t\t\tinfo.decl = fake\n+\t\t\t\t\t// Look for anonymous fields that might contribute methods.\n+\t\t\t\t\tvar fields *ast.FieldList\n+\t\t\t\t\tswitch typ := spec.(*ast.TypeSpec).Type.(type) {\n+\t\t\t\t\tcase *ast.StructType:\n+\t\t\t\t\t\tfields = typ.Fields\n+\t\t\t\t\tcase *ast.InterfaceType:\n+\t\t\t\t\t\tfields = typ.Methods\n+\t\t\t\t\t}\n+\t\t\t\t\tif fields != nil {\n+\t\t\t\t\t\tfor _, field := range fields.List {\n+\t\t\t\t\t\t\tif len(field.Names) == 0 {\n+\t\t\t\t\t\t\t\t// anonymous field - add corresponding type\n+\t\t\t\t\t\t\t\t// to the info and collect it in doc\n+\t\t\t\t\t\t\t\tname := baseTypeName(field.Type, true)\n+\t\t\t\t\t\t\t\tif embedded := doc.lookupTypeInfo(name); embedded != nil {\n+\t\t\t\t\t\t\t\t\t_, ptr := field.Type.(*ast.StarExpr)\n+\t\t\t\t\t\t\t\t\tinfo.addEmbeddedType(embedded, ptr)\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -285,19 +320,15 @@ func (doc *docReader) addFile(src *ast.File) {\n \tsrc.Comments = nil // consumed unassociated comments - remove from ast.File node\n }\n \n-func NewFileDoc(file *ast.File) *PackageDoc {\n-\tvar r docReader\n-\tr.init(file.Name.Name)\n-\tr.addFile(file)\n-\treturn r.newDoc(\"\", nil)\n-}\n-\n-func NewPackageDoc(pkg *ast.Package, importpath string) *PackageDoc {\n+func NewPackageDoc(pkg *ast.Package, importpath string, exportsOnly bool) *PackageDoc {\n \tvar r docReader\n \tr.init(pkg.Name)\n \tfilenames := make([]string, len(pkg.Files))\n \ti := 0\n \tfor filename, f := range pkg.Files {\n+\t\tif exportsOnly {\n+\t\t\tr.fileExports(f)\n+\t\t}\n \t\tr.addFile(f)\n \t\tfilenames[i] = filename\n \t\ti++\n@@ -397,6 +428,25 @@ func makeFuncDocs(m map[string]*ast.FuncDecl) []*FuncDoc {\n \treturn d\n }\n \n+type methodSet map[string]*FuncDoc\n+\n+func (mset methodSet) add(m *FuncDoc) {\n+\tif mset[m.Name] == nil {\n+\t\tmset[m.Name] = m\n+\t}\n+}\n+\n+func (mset methodSet) sortedList() []*FuncDoc {\n+\tlist := make([]*FuncDoc, len(mset))\n+\ti := 0\n+\tfor _, m := range mset {\n+\t\tlist[i] = m\n+\t\ti++\n+\t}\n+\tsort.Sort(sortFuncDoc(list))\n+\treturn list\n+}\n+\n // TypeDoc is the documentation for a declared type.\n // Consts and Vars are sorted lists of constants and variables of (mostly) that type.\n // Factories is a sorted list of factory functions that return that type.\n@@ -407,7 +457,9 @@ type TypeDoc struct {\n \tConsts    []*ValueDoc\n \tVars      []*ValueDoc\n \tFactories []*FuncDoc\n-\tMethods   []*FuncDoc\n+\tmethods   []*FuncDoc // top-level methods only\n+\tembedded  methodSet  // embedded methods only\n+\tMethods   []*FuncDoc // all methods including embedded ones\n \tDecl      *ast.GenDecl\n \torder     int\n }\n@@ -429,11 +481,17 @@ func (p sortTypeDoc) Less(i, j int) bool {\n // NOTE(rsc): This would appear not to be correct for type ( )\n // blocks, but the doc extractor above has split them into\n // individual declarations.\n-func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {\n-\td := make([]*TypeDoc, len(m))\n+func (doc *docReader) makeTypeDocs(m map[string]*typeInfo) []*TypeDoc {\n+\t// TODO(gri) Consider computing the embedded method information\n+\t//           before calling makeTypeDocs. Then this function can\n+\t//           be single-phased again. Also, it might simplify some\n+\t//           of the logic.\n+\t//\n+\t// phase 1: associate collected declarations with TypeDocs\n+\tlist := make([]*TypeDoc, len(m))\n \ti := 0\n \tfor _, old := range m {\n-\t\t// all typeDocs should have a declaration associated with\n+\t\t// all typeInfos should have a declaration associated with\n \t\t// them after processing an entire package - be conservative\n \t\t// and check\n \t\tif decl := old.decl; decl != nil {\n@@ -451,10 +509,16 @@ func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {\n \t\t\tt.Consts = makeValueDocs(old.values, token.CONST)\n \t\t\tt.Vars = makeValueDocs(old.values, token.VAR)\n \t\t\tt.Factories = makeFuncDocs(old.factories)\n-\t\t\tt.Methods = makeFuncDocs(old.methods)\n+\t\t\tt.methods = makeFuncDocs(old.methods)\n+\t\t\t// The list of embedded types' methods is computed from the list\n+\t\t\t// of embedded types, some of which may not have been processed\n+\t\t\t// yet (i.e., their forward link is nil) - do this in a 2nd phase.\n+\t\t\t// The final list of methods can only be computed after that -\n+\t\t\t// do this in a 3rd phase.\n \t\t\tt.Decl = old.decl\n \t\t\tt.order = i\n-\t\t\td[i] = t\n+\t\t\told.forward = t // old has been processed\n+\t\t\tlist[i] = t\n \t\t\ti++\n \t\t} else {\n \t\t\t// no corresponding type declaration found - move any associated\n@@ -477,9 +541,99 @@ func (doc *docReader) makeTypeDocs(m map[string]*typeDoc) []*TypeDoc {\n \t\t\t}\n \t\t}\n \t}\n-\td = d[0:i] // some types may have been ignored\n-\tsort.Sort(sortTypeDoc(d))\n-\treturn d\n+\tlist = list[0:i] // some types may have been ignored\n+\n+\t// phase 2: collect embedded methods for each processed typeInfo\n+\tfor _, old := range m {\n+\t\tif t := old.forward; t != nil {\n+\t\t\t// old has been processed into t; collect embedded\n+\t\t\t// methods for t from the list of processed embedded\n+\t\t\t// types in old (and thus for which the methods are known)\n+\t\t\ttyp := t.Type\n+\t\t\tif _, ok := typ.Type.(*ast.StructType); ok {\n+\t\t\t\t// struct\n+\t\t\t\tt.embedded = make(methodSet)\n+\t\t\t\tcollectEmbeddedMethods(t.embedded, old, typ.Name.Name)\n+\t\t\t} else {\n+\t\t\t\t// interface\n+\t\t\t\t// TODO(gri) fix this\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// phase 3: compute final method set for each TypeDoc\n+\tfor _, d := range list {\n+\t\tif len(d.embedded) > 0 {\n+\t\t\t// there are embedded methods - exclude\n+\t\t\t// the ones with names conflicting with\n+\t\t\t// non-embedded methods\n+\t\t\tmset := make(methodSet)\n+\t\t\t// top-level methods have priority\n+\t\t\tfor _, m := range d.methods {\n+\t\t\t\tmset.add(m)\n+\t\t\t}\n+\t\t\t// add non-conflicting embedded methods\n+\t\t\tfor _, m := range d.embedded {\n+\t\t\t\tmset.add(m)\n+\t\t\t}\n+\t\t\td.Methods = mset.sortedList()\n+\t\t} else {\n+\t\t\t// no embedded methods\n+\t\t\td.Methods = d.methods\n+\t\t}\n+\t}\n+\n+\tsort.Sort(sortTypeDoc(list))\n+\treturn list\n+}\n+\n+// collectEmbeddedMethods collects the embedded methods from all\n+// processed embedded types found in info in mset. It considers\n+// embedded types at the most shallow level first so that more\n+// deeply nested embedded methods with conflicting names are\n+// excluded.\n+//\n+func collectEmbeddedMethods(mset methodSet, info *typeInfo, recvTypeName string) {\n+\tfor _, e := range info.embedded {\n+\t\tif e.typ.forward != nil { // == e was processed\n+\t\t\tfor _, m := range e.typ.forward.methods {\n+\t\t\t\tmset.add(customizeRecv(m, e.ptr, recvTypeName))\n+\t\t\t}\n+\t\t\tcollectEmbeddedMethods(mset, e.typ, recvTypeName)\n+\t\t}\n+\t}\n+}\n+\n+func customizeRecv(m *FuncDoc, embeddedIsPtr bool, recvTypeName string) *FuncDoc {\n+\tif m == nil || m.Decl == nil || m.Decl.Recv == nil || len(m.Decl.Recv.List) != 1 {\n+\t\treturn m // shouldn't happen, but be safe\n+\t}\n+\n+\t// copy existing receiver field and set new type\n+\t// TODO(gri) is receiver type computation correct?\n+\t//           what about deeply nested embeddings?\n+\tnewField := *m.Decl.Recv.List[0]\n+\t_, origRecvIsPtr := newField.Type.(*ast.StarExpr)\n+\tvar typ ast.Expr = ast.NewIdent(recvTypeName)\n+\tif embeddedIsPtr || origRecvIsPtr {\n+\t\ttyp = &ast.StarExpr{token.NoPos, typ}\n+\t}\n+\tnewField.Type = typ\n+\n+\t// copy existing receiver field list and set new receiver field\n+\tnewFieldList := *m.Decl.Recv\n+\tnewFieldList.List = []*ast.Field{&newField}\n+\n+\t// copy existing function declaration and set new receiver field list\n+\tnewFuncDecl := *m.Decl\n+\tnewFuncDecl.Recv = &newFieldList\n+\n+\t// copy existing function documentation and set new declaration\n+\tnewM := *m\n+\tnewM.Decl = &newFuncDecl\n+\tnewM.Recv = typ\n+\n+\treturn &newM\n }\n \n func makeBugDocs(list []*ast.CommentGroup) []string {\n@@ -523,104 +677,3 @@ func (doc *docReader) newDoc(importpath string, filenames []string) *PackageDoc\n \tp.Bugs = makeBugDocs(doc.bugs)\n \treturn p\n }\n-\n-// ----------------------------------------------------------------------------\n-// Filtering by name\n-\n-type Filter func(string) bool\n-\n-func matchFields(fields *ast.FieldList, f Filter) bool {\n-\tif fields != nil {\n-\t\tfor _, field := range fields.List {\n-\t\t\tfor _, name := range field.Names {\n-\t\t\t\tif f(name.Name) {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func matchDecl(d *ast.GenDecl, f Filter) bool {\n-\tfor _, d := range d.Specs {\n-\t\tswitch v := d.(type) {\n-\t\tcase *ast.ValueSpec:\n-\t\t\tfor _, name := range v.Names {\n-\t\t\t\tif f(name.Name) {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n-\t\t\t}\n-\t\tcase *ast.TypeSpec:\n-\t\t\tif f(v.Name.Name) {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t\tswitch t := v.Type.(type) {\n-\t\t\tcase *ast.StructType:\n-\t\t\t\tif matchFields(t.Fields, f) {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n-\t\t\tcase *ast.InterfaceType:\n-\t\t\t\tif matchFields(t.Methods, f) {\n-\t\t\t\t\treturn true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func filterValueDocs(a []*ValueDoc, f Filter) []*ValueDoc {\n-\tw := 0\n-\tfor _, vd := range a {\n-\t\tif matchDecl(vd.Decl, f) {\n-\t\t\ta[w] = vd\n-\t\t\tw++\n-\t\t}\n-\t}\n-\treturn a[0:w]\n-}\n-\n-func filterFuncDocs(a []*FuncDoc, f Filter) []*FuncDoc {\n-\tw := 0\n-\tfor _, fd := range a {\n-\t\tif f(fd.Name) {\n-\t\t\ta[w] = fd\n-\t\t\tw++\n-\t\t}\n-\t}\n-\treturn a[0:w]\n-}\n-\n-func filterTypeDocs(a []*TypeDoc, f Filter) []*TypeDoc {\n-\tw := 0\n-\tfor _, td := range a {\n-\t\tn := 0 // number of matches\n-\t\tif matchDecl(td.Decl, f) {\n-\t\t\tn = 1\n-\t\t} else {\n-\t\t\t// type name doesn't match, but we may have matching consts, vars, factories or methods\n-\t\t\ttd.Consts = filterValueDocs(td.Consts, f)\n-\t\t\ttd.Vars = filterValueDocs(td.Vars, f)\n-\t\t\ttd.Factories = filterFuncDocs(td.Factories, f)\n-\t\t\ttd.Methods = filterFuncDocs(td.Methods, f)\n-\t\t\tn += len(td.Consts) + len(td.Vars) + len(td.Factories) + len(td.Methods)\n-\t\t}\n-\t\tif n > 0 {\n-\t\t\ta[w] = td\n-\t\t\tw++\n-\t\t}\n-\t}\n-\treturn a[0:w]\n-}\n-\n-// Filter eliminates documentation for names that don't pass through the filter f.\n-// TODO: Recognize \"Type.Method\" as a name.\n-//\n-func (p *PackageDoc) Filter(f Filter) {\n-\tp.Consts = filterValueDocs(p.Consts, f)\n-\tp.Vars = filterValueDocs(p.Vars, f)\n-\tp.Types = filterTypeDocs(p.Types, f)\n-\tp.Funcs = filterFuncDocs(p.Funcs, f)\n-\tp.Doc = \"\" // don't show top-level package doc\n-}"}, {"sha": "9cd186a9c7a81cefee3cf68e8bdad6eeac01c292", "filename": "libgo/go/go/doc/exports.go", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements export filtering of an AST.\n+\n+package doc\n+\n+import \"go/ast\"\n+\n+func filterIdentList(list []*ast.Ident) []*ast.Ident {\n+\tj := 0\n+\tfor _, x := range list {\n+\t\tif ast.IsExported(x.Name) {\n+\t\t\tlist[j] = x\n+\t\t\tj++\n+\t\t}\n+\t}\n+\treturn list[0:j]\n+}\n+\n+func baseName(x ast.Expr) *ast.Ident {\n+\tswitch t := x.(type) {\n+\tcase *ast.Ident:\n+\t\treturn t\n+\tcase *ast.SelectorExpr:\n+\t\tif _, ok := t.X.(*ast.Ident); ok {\n+\t\t\treturn t.Sel\n+\t\t}\n+\tcase *ast.StarExpr:\n+\t\treturn baseName(t.X)\n+\t}\n+\treturn nil\n+}\n+\n+func (doc *docReader) filterFieldList(fields *ast.FieldList) (removedFields bool) {\n+\tif fields == nil {\n+\t\treturn false\n+\t}\n+\tlist := fields.List\n+\tj := 0\n+\tfor _, f := range list {\n+\t\tkeepField := false\n+\t\tif len(f.Names) == 0 {\n+\t\t\t// anonymous field\n+\t\t\tname := baseName(f.Type)\n+\t\t\tkeepField = name != nil && name.IsExported()\n+\t\t} else {\n+\t\t\tn := len(f.Names)\n+\t\t\tf.Names = filterIdentList(f.Names)\n+\t\t\tif len(f.Names) < n {\n+\t\t\t\tremovedFields = true\n+\t\t\t}\n+\t\t\tkeepField = len(f.Names) > 0\n+\t\t}\n+\t\tif keepField {\n+\t\t\tdoc.filterType(f.Type)\n+\t\t\tlist[j] = f\n+\t\t\tj++\n+\t\t}\n+\t}\n+\tif j < len(list) {\n+\t\tremovedFields = true\n+\t}\n+\tfields.List = list[0:j]\n+\treturn\n+}\n+\n+func (doc *docReader) filterParamList(fields *ast.FieldList) bool {\n+\tif fields == nil {\n+\t\treturn false\n+\t}\n+\tvar b bool\n+\tfor _, f := range fields.List {\n+\t\tif doc.filterType(f.Type) {\n+\t\t\tb = true\n+\t\t}\n+\t}\n+\treturn b\n+}\n+\n+func (doc *docReader) filterType(typ ast.Expr) bool {\n+\tswitch t := typ.(type) {\n+\tcase *ast.Ident:\n+\t\treturn ast.IsExported(t.Name)\n+\tcase *ast.ParenExpr:\n+\t\treturn doc.filterType(t.X)\n+\tcase *ast.ArrayType:\n+\t\treturn doc.filterType(t.Elt)\n+\tcase *ast.StructType:\n+\t\tif doc.filterFieldList(t.Fields) {\n+\t\t\tt.Incomplete = true\n+\t\t}\n+\t\treturn len(t.Fields.List) > 0\n+\tcase *ast.FuncType:\n+\t\tb1 := doc.filterParamList(t.Params)\n+\t\tb2 := doc.filterParamList(t.Results)\n+\t\treturn b1 || b2\n+\tcase *ast.InterfaceType:\n+\t\tif doc.filterFieldList(t.Methods) {\n+\t\t\tt.Incomplete = true\n+\t\t}\n+\t\treturn len(t.Methods.List) > 0\n+\tcase *ast.MapType:\n+\t\tb1 := doc.filterType(t.Key)\n+\t\tb2 := doc.filterType(t.Value)\n+\t\treturn b1 || b2\n+\tcase *ast.ChanType:\n+\t\treturn doc.filterType(t.Value)\n+\t}\n+\treturn false\n+}\n+\n+func (doc *docReader) filterSpec(spec ast.Spec) bool {\n+\tswitch s := spec.(type) {\n+\tcase *ast.ValueSpec:\n+\t\ts.Names = filterIdentList(s.Names)\n+\t\tif len(s.Names) > 0 {\n+\t\t\tdoc.filterType(s.Type)\n+\t\t\treturn true\n+\t\t}\n+\tcase *ast.TypeSpec:\n+\t\tif ast.IsExported(s.Name.Name) {\n+\t\t\tdoc.filterType(s.Type)\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func (doc *docReader) filterSpecList(list []ast.Spec) []ast.Spec {\n+\tj := 0\n+\tfor _, s := range list {\n+\t\tif doc.filterSpec(s) {\n+\t\t\tlist[j] = s\n+\t\t\tj++\n+\t\t}\n+\t}\n+\treturn list[0:j]\n+}\n+\n+func (doc *docReader) filterDecl(decl ast.Decl) bool {\n+\tswitch d := decl.(type) {\n+\tcase *ast.GenDecl:\n+\t\td.Specs = doc.filterSpecList(d.Specs)\n+\t\treturn len(d.Specs) > 0\n+\tcase *ast.FuncDecl:\n+\t\treturn ast.IsExported(d.Name.Name)\n+\t}\n+\treturn false\n+}\n+\n+// fileExports trims the AST for a Go file in place such that\n+// only exported nodes remain. fileExports returns true if\n+// there are exported declarations; otherwise it returns false.\n+//\n+func (doc *docReader) fileExports(src *ast.File) bool {\n+\tj := 0\n+\tfor _, d := range src.Decls {\n+\t\tif doc.filterDecl(d) {\n+\t\t\tsrc.Decls[j] = d\n+\t\t\tj++\n+\t\t}\n+\t}\n+\tsrc.Decls = src.Decls[0:j]\n+\treturn j > 0\n+}"}, {"sha": "71c2ebb68bd14e0676594e079e15cb212cd11096", "filename": "libgo/go/go/doc/filter.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import \"go/ast\"\n+\n+type Filter func(string) bool\n+\n+func matchFields(fields *ast.FieldList, f Filter) bool {\n+\tif fields != nil {\n+\t\tfor _, field := range fields.List {\n+\t\t\tfor _, name := range field.Names {\n+\t\t\t\tif f(name.Name) {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func matchDecl(d *ast.GenDecl, f Filter) bool {\n+\tfor _, d := range d.Specs {\n+\t\tswitch v := d.(type) {\n+\t\tcase *ast.ValueSpec:\n+\t\t\tfor _, name := range v.Names {\n+\t\t\t\tif f(name.Name) {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase *ast.TypeSpec:\n+\t\t\tif f(v.Name.Name) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tswitch t := v.Type.(type) {\n+\t\t\tcase *ast.StructType:\n+\t\t\t\tif matchFields(t.Fields, f) {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\tcase *ast.InterfaceType:\n+\t\t\t\tif matchFields(t.Methods, f) {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func filterValueDocs(a []*ValueDoc, f Filter) []*ValueDoc {\n+\tw := 0\n+\tfor _, vd := range a {\n+\t\tif matchDecl(vd.Decl, f) {\n+\t\t\ta[w] = vd\n+\t\t\tw++\n+\t\t}\n+\t}\n+\treturn a[0:w]\n+}\n+\n+func filterFuncDocs(a []*FuncDoc, f Filter) []*FuncDoc {\n+\tw := 0\n+\tfor _, fd := range a {\n+\t\tif f(fd.Name) {\n+\t\t\ta[w] = fd\n+\t\t\tw++\n+\t\t}\n+\t}\n+\treturn a[0:w]\n+}\n+\n+func filterTypeDocs(a []*TypeDoc, f Filter) []*TypeDoc {\n+\tw := 0\n+\tfor _, td := range a {\n+\t\tn := 0 // number of matches\n+\t\tif matchDecl(td.Decl, f) {\n+\t\t\tn = 1\n+\t\t} else {\n+\t\t\t// type name doesn't match, but we may have matching consts, vars, factories or methods\n+\t\t\ttd.Consts = filterValueDocs(td.Consts, f)\n+\t\t\ttd.Vars = filterValueDocs(td.Vars, f)\n+\t\t\ttd.Factories = filterFuncDocs(td.Factories, f)\n+\t\t\ttd.Methods = filterFuncDocs(td.Methods, f)\n+\t\t\tn += len(td.Consts) + len(td.Vars) + len(td.Factories) + len(td.Methods)\n+\t\t}\n+\t\tif n > 0 {\n+\t\t\ta[w] = td\n+\t\t\tw++\n+\t\t}\n+\t}\n+\treturn a[0:w]\n+}\n+\n+// Filter eliminates documentation for names that don't pass through the filter f.\n+// TODO: Recognize \"Type.Method\" as a name.\n+//\n+func (p *PackageDoc) Filter(f Filter) {\n+\tp.Consts = filterValueDocs(p.Consts, f)\n+\tp.Vars = filterValueDocs(p.Vars, f)\n+\tp.Types = filterTypeDocs(p.Types, f)\n+\tp.Funcs = filterFuncDocs(p.Funcs, f)\n+\tp.Doc = \"\" // don't show top-level package doc\n+}"}, {"sha": "9fbed2d2ca35de31d605caf2336722ce22225d80", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -144,28 +144,31 @@ func (p *parser) declare(decl, data interface{}, scope *ast.Scope, kind ast.ObjK\n \t}\n }\n \n-func (p *parser) shortVarDecl(idents []*ast.Ident) {\n+func (p *parser) shortVarDecl(decl *ast.AssignStmt, list []ast.Expr) {\n \t// Go spec: A short variable declaration may redeclare variables\n \t// provided they were originally declared in the same block with\n \t// the same type, and at least one of the non-blank variables is new.\n \tn := 0 // number of new variables\n-\tfor _, ident := range idents {\n-\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n-\t\tobj := ast.NewObj(ast.Var, ident.Name)\n-\t\t// short var declarations cannot have redeclaration errors\n-\t\t// and are not global => no need to remember the respective\n-\t\t// declaration\n-\t\tident.Obj = obj\n-\t\tif ident.Name != \"_\" {\n-\t\t\tif alt := p.topScope.Insert(obj); alt != nil {\n-\t\t\t\tident.Obj = alt // redeclaration\n-\t\t\t} else {\n-\t\t\t\tn++ // new declaration\n+\tfor _, x := range list {\n+\t\tif ident, isIdent := x.(*ast.Ident); isIdent {\n+\t\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n+\t\t\tobj := ast.NewObj(ast.Var, ident.Name)\n+\t\t\t// remember corresponding assignment for other tools\n+\t\t\tobj.Decl = decl\n+\t\t\tident.Obj = obj\n+\t\t\tif ident.Name != \"_\" {\n+\t\t\t\tif alt := p.topScope.Insert(obj); alt != nil {\n+\t\t\t\t\tident.Obj = alt // redeclaration\n+\t\t\t\t} else {\n+\t\t\t\t\tn++ // new declaration\n+\t\t\t\t}\n \t\t\t}\n+\t\t} else {\n+\t\t\tp.errorExpected(x.Pos(), \"identifier\")\n \t\t}\n \t}\n \tif n == 0 && p.mode&DeclarationErrors != 0 {\n-\t\tp.error(idents[0].Pos(), \"no new variables on left side of :=\")\n+\t\tp.error(list[0].Pos(), \"no new variables on left side of :=\")\n \t}\n }\n \n@@ -522,7 +525,7 @@ func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n \tfor i, x := range list {\n \t\tident, isIdent := x.(*ast.Ident)\n \t\tif !isIdent {\n-\t\t\tpos := x.(ast.Expr).Pos()\n+\t\t\tpos := x.Pos()\n \t\t\tp.errorExpected(pos, \"identifier\")\n \t\t\tident = &ast.Ident{pos, \"_\", nil}\n \t\t}\n@@ -1400,10 +1403,11 @@ func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {\n \t\t} else {\n \t\t\ty = p.parseRhsList()\n \t\t}\n+\t\tas := &ast.AssignStmt{x, pos, tok, y}\n \t\tif tok == token.DEFINE {\n-\t\t\tp.shortVarDecl(p.makeIdentList(x))\n+\t\t\tp.shortVarDecl(as, x)\n \t\t}\n-\t\treturn &ast.AssignStmt{x, pos, tok, y}, isRange\n+\t\treturn as, isRange\n \t}\n \n \tif len(x) > 1 {\n@@ -1715,34 +1719,28 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\tcomm = &ast.SendStmt{lhs[0], arrow, rhs}\n \t\t} else {\n \t\t\t// RecvStmt\n-\t\t\tpos := p.pos\n-\t\t\ttok := p.tok\n-\t\t\tvar rhs ast.Expr\n-\t\t\tif tok == token.ASSIGN || tok == token.DEFINE {\n+\t\t\tif tok := p.tok; tok == token.ASSIGN || tok == token.DEFINE {\n \t\t\t\t// RecvStmt with assignment\n \t\t\t\tif len(lhs) > 2 {\n \t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 or 2 expressions\")\n \t\t\t\t\t// continue with first two expressions\n \t\t\t\t\tlhs = lhs[0:2]\n \t\t\t\t}\n+\t\t\t\tpos := p.pos\n \t\t\t\tp.next()\n-\t\t\t\trhs = p.parseRhs()\n-\t\t\t\tif tok == token.DEFINE && lhs != nil {\n-\t\t\t\t\tp.shortVarDecl(p.makeIdentList(lhs))\n+\t\t\t\trhs := p.parseRhs()\n+\t\t\t\tas := &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n+\t\t\t\tif tok == token.DEFINE {\n+\t\t\t\t\tp.shortVarDecl(as, lhs)\n \t\t\t\t}\n+\t\t\t\tcomm = as\n \t\t\t} else {\n-\t\t\t\t// rhs must be single receive operation\n+\t\t\t\t// lhs must be single receive operation\n \t\t\t\tif len(lhs) > 1 {\n \t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n \t\t\t\t\t// continue with first expression\n \t\t\t\t}\n-\t\t\t\trhs = lhs[0]\n-\t\t\t\tlhs = nil // there is no lhs\n-\t\t\t}\n-\t\t\tif lhs != nil {\n-\t\t\t\tcomm = &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n-\t\t\t} else {\n-\t\t\t\tcomm = &ast.ExprStmt{rhs}\n+\t\t\t\tcomm = &ast.ExprStmt{lhs[0]}\n \t\t\t}\n \t\t}\n \t} else {"}, {"sha": "6817cc42addef4323dd9dd22dd9083b52ef35eac", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -39,7 +39,10 @@ import (\n //            future (not yet interspersed) comments in this function.\n //\n func (p *printer) linebreak(line, min int, ws whiteSpace, newSection bool) (printedBreak bool) {\n-\tn := p.nlines(line-p.pos.Line, min)\n+\tn := nlimit(line - p.pos.Line)\n+\tif n < min {\n+\t\tn = min\n+\t}\n \tif n > 0 {\n \t\tp.print(ws)\n \t\tif newSection {\n@@ -361,9 +364,10 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \tlbrace := fields.Opening\n \tlist := fields.List\n \trbrace := fields.Closing\n+\thasComments := isIncomplete || p.commentBefore(p.fset.Position(rbrace))\n \tsrcIsOneLine := lbrace.IsValid() && rbrace.IsValid() && p.fset.Position(lbrace).Line == p.fset.Position(rbrace).Line\n \n-\tif !isIncomplete && !p.commentBefore(p.fset.Position(rbrace)) && srcIsOneLine {\n+\tif !hasComments && srcIsOneLine {\n \t\t// possibly a one-line struct/interface\n \t\tif len(list) == 0 {\n \t\t\t// no blank between keyword and {} in this case\n@@ -388,9 +392,13 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \t\t\treturn\n \t\t}\n \t}\n+\t// hasComments || !srcIsOneLine\n+\n+\tp.print(blank, lbrace, token.LBRACE, indent)\n+\tif hasComments || len(list) > 0 {\n+\t\tp.print(formfeed)\n+\t}\n \n-\t// at least one entry or incomplete\n-\tp.print(blank, lbrace, token.LBRACE, indent, formfeed)\n \tif isStruct {\n \n \t\tsep := vtab\n@@ -1509,9 +1517,14 @@ func (p *printer) file(src *ast.File) {\n \t\t\tprev := tok\n \t\t\ttok = declToken(d)\n \t\t\t// if the declaration token changed (e.g., from CONST to TYPE)\n+\t\t\t// or the next declaration has documentation associated with it,\n \t\t\t// print an empty line between top-level declarations\n+\t\t\t// (because p.linebreak is called with the position of d, which\n+\t\t\t// is past any documentation, the minimum requirement is satisfied\n+\t\t\t// even w/o the extra getDoc(d) nil-check - leave it in case the\n+\t\t\t// linebreak logic improves - there's already a TODO).\n \t\t\tmin := 1\n-\t\t\tif prev != tok {\n+\t\t\tif prev != tok || getDoc(d) != nil {\n \t\t\t\tmin = 2\n \t\t\t}\n \t\t\tp.linebreak(p.fset.Position(d.Pos()).Line, min, ignore, false)"}, {"sha": "a78cfc65fccb372399048449b35c282900599d13", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 83, "deletions": 62, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -18,8 +18,11 @@ import (\n \t\"text/tabwriter\"\n )\n \n-const debug = false // enable for debugging\n-const infinity = 1 << 30\n+const (\n+\tmaxNewlines = 2     // max. number of newlines between source text\n+\tdebug       = false // enable for debugging\n+\tinfinity    = 1 << 30\n+)\n \n type whiteSpace byte\n \n@@ -89,21 +92,7 @@ func (p *printer) internalError(msg ...interface{}) {\n \t}\n }\n \n-// nlines returns the adjusted number of linebreaks given the desired number\n-// of breaks n such that min <= result <= max.\n-//\n-func (p *printer) nlines(n, min int) int {\n-\tconst max = 2 // max. number of newlines\n-\tswitch {\n-\tcase n < min:\n-\t\treturn min\n-\tcase n > max:\n-\t\treturn max\n-\t}\n-\treturn n\n-}\n-\n-// writeByte writes a single byte to p.output and updates p.pos.\n+// writeByte writes ch to p.output and updates p.pos.\n func (p *printer) writeByte(ch byte) {\n \tp.output.WriteByte(ch)\n \tp.pos.Offset++\n@@ -128,13 +117,11 @@ func (p *printer) writeByte(ch byte) {\n \t}\n }\n \n-// writeNewlines writes up to n newlines to p.output and updates p.pos.\n-// The actual number of newlines written is limited by nlines.\n-// nl must be one of '\\n' or '\\f'.\n-//\n-func (p *printer) writeNewlines(n int, nl byte) {\n-\tfor n = p.nlines(n, 0); n > 0; n-- {\n-\t\tp.writeByte(nl)\n+// writeByteN writes ch n times to p.output and updates p.pos.\n+func (p *printer) writeByteN(ch byte, n int) {\n+\tfor n > 0 {\n+\t\tp.writeByte(ch)\n+\t\tn--\n \t}\n }\n \n@@ -223,8 +210,8 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t}\n \n \tif pos.IsValid() && pos.Filename != p.last.Filename {\n-\t\t// comment in a different file - separate with newlines (writeNewlines will limit the number)\n-\t\tp.writeNewlines(10, '\\f')\n+\t\t// comment in a different file - separate with newlines\n+\t\tp.writeByteN('\\f', maxNewlines)\n \t\treturn\n \t}\n \n@@ -270,6 +257,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t} else {\n \t\t// comment on a different line:\n \t\t// separate with at least one line break\n+\t\tdroppedLinebreak := false\n \t\tif prev == nil {\n \t\t\t// first comment of a comment group\n \t\t\tj := 0\n@@ -295,32 +283,49 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\t\t\tcase newline, formfeed:\n \t\t\t\t\t// TODO(gri): may want to keep formfeed info in some cases\n \t\t\t\t\tp.wsbuf[i] = ignore\n+\t\t\t\t\tdroppedLinebreak = true\n \t\t\t\t}\n \t\t\t\tj = i\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp.writeWhitespace(j)\n \t\t}\n \n-\t\t// turn off indent if we're about to print a line directive.\n-\t\tindent := p.indent\n-\t\tif strings.HasPrefix(comment.Text, linePrefix) {\n-\t\t\tp.indent = 0\n+\t\t// determine number of linebreaks before the comment\n+\t\tn := 0\n+\t\tif pos.IsValid() && p.last.IsValid() {\n+\t\t\tn = pos.Line - p.last.Line\n+\t\t\tif n < 0 { // should never happen\n+\t\t\t\tn = 0\n+\t\t\t}\n+\t\t}\n+\n+\t\t// at the package scope level only (p.indent == 0),\n+\t\t// add an extra newline if we dropped one before:\n+\t\t// this preserves a blank line before documentation\n+\t\t// comments at the package scope level (issue 2570)\n+\t\tif p.indent == 0 && droppedLinebreak {\n+\t\t\tn++\n \t\t}\n \n-\t\t// use formfeeds to break columns before a comment;\n-\t\t// this is analogous to using formfeeds to separate\n-\t\t// individual lines of /*-style comments - but make\n-\t\t// sure there is at least one line break if the previous\n-\t\t// comment was a line comment\n-\t\tn := pos.Line - p.last.Line // if !pos.IsValid(), pos.Line == 0, and n will be 0\n-\t\tif n <= 0 && prev != nil && prev.Text[1] == '/' {\n+\t\t// make sure there is at least one line break\n+\t\t// if the previous comment was a line comment\n+\t\tif n == 0 && prev != nil && prev.Text[1] == '/' {\n \t\t\tn = 1\n \t\t}\n+\n \t\tif n > 0 {\n-\t\t\tp.writeNewlines(n, '\\f')\n+\t\t\t// turn off indent if we're about to print a line directive\n+\t\t\tindent := p.indent\n+\t\t\tif strings.HasPrefix(comment.Text, linePrefix) {\n+\t\t\t\tp.indent = 0\n+\t\t\t}\n+\t\t\t// use formfeeds to break columns before a comment;\n+\t\t\t// this is analogous to using formfeeds to separate\n+\t\t\t// individual lines of /*-style comments\n+\t\t\tp.writeByteN('\\f', nlimit(n))\n+\t\t\tp.indent = indent // restore indent\n \t\t}\n-\t\tp.indent = indent\n \t}\n }\n \n@@ -550,10 +555,11 @@ func (p *printer) writeComment(comment *ast.Comment) {\n // writeCommentSuffix writes a line break after a comment if indicated\n // and processes any leftover indentation information. If a line break\n // is needed, the kind of break (newline vs formfeed) depends on the\n-// pending whitespace. writeCommentSuffix returns true if a pending\n-// formfeed was dropped from the whitespace buffer.\n+// pending whitespace. The writeCommentSuffix result indicates if a\n+// newline was written or if a formfeed was dropped from the whitespace\n+// buffer.\n //\n-func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n+func (p *printer) writeCommentSuffix(needsLinebreak bool) (wroteNewline, droppedFF bool) {\n \tfor i, ch := range p.wsbuf {\n \t\tswitch ch {\n \t\tcase blank, vtab:\n@@ -566,6 +572,7 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n \t\t\t// but remember if we dropped any formfeeds\n \t\t\tif needsLinebreak {\n \t\t\t\tneedsLinebreak = false\n+\t\t\t\twroteNewline = true\n \t\t\t} else {\n \t\t\t\tif ch == formfeed {\n \t\t\t\t\tdroppedFF = true\n@@ -579,6 +586,7 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n \t// make sure we have a line break\n \tif needsLinebreak {\n \t\tp.writeByte('\\n')\n+\t\twroteNewline = true\n \t}\n \n \treturn\n@@ -587,10 +595,10 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n // intersperseComments consumes all comments that appear before the next token\n // tok and prints it together with the buffered whitespace (i.e., the whitespace\n // that needs to be written before the next token). A heuristic is used to mix\n-// the comments and whitespace. intersperseComments returns true if a pending\n-// formfeed was dropped from the whitespace buffer.\n+// the comments and whitespace. The intersperseComments result indicates if a\n+// newline was written or if a formfeed was dropped from the whitespace buffer.\n //\n-func (p *printer) intersperseComments(next token.Position, tok token.Token) (droppedFF bool) {\n+func (p *printer) intersperseComments(next token.Position, tok token.Token) (wroteNewline, droppedFF bool) {\n \tvar last *ast.Comment\n \tfor ; p.commentBefore(next); p.cindex++ {\n \t\tfor _, c := range p.comments[p.cindex].List {\n@@ -618,7 +626,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (dro\n \t// no comment was written - we should never reach here since\n \t// intersperseComments should not be called in that case\n \tp.internalError(\"intersperseComments called without pending comments\")\n-\treturn false\n+\treturn\n }\n \n // whiteWhitespace writes the first n whitespace entries.\n@@ -671,6 +679,14 @@ func (p *printer) writeWhitespace(n int) {\n // ----------------------------------------------------------------------------\n // Printing interface\n \n+// nlines limits n to maxNewlines.\n+func nlimit(n int) int {\n+\tif n > maxNewlines {\n+\t\tn = maxNewlines\n+\t}\n+\treturn n\n+}\n+\n func mayCombine(prev token.Token, next byte) (b bool) {\n \tswitch prev {\n \tcase token.INT:\n@@ -765,17 +781,22 @@ func (p *printer) print(args ...interface{}) {\n \t\tp.pos = next\n \n \t\tif data != \"\" {\n-\t\t\tnl := byte('\\n')\n-\t\t\tif p.flush(next, tok) {\n-\t\t\t\tnl = '\\f' // dropped formfeed before\n-\t\t\t}\n+\t\t\twroteNewline, droppedFF := p.flush(next, tok)\n \n \t\t\t// intersperse extra newlines if present in the source\n \t\t\t// (don't do this in flush as it will cause extra newlines\n-\t\t\t// at the end of a file) - use formfeeds if we dropped one\n-\t\t\t// before\n-\t\t\tif n := next.Line - p.pos.Line; n > 0 {\n-\t\t\t\tp.writeNewlines(n, nl)\n+\t\t\t// at the end of a file)\n+\t\t\tn := nlimit(next.Line - p.pos.Line)\n+\t\t\t// don't exceed maxNewlines if we already wrote one\n+\t\t\tif wroteNewline && n == maxNewlines {\n+\t\t\t\tn = maxNewlines - 1\n+\t\t\t}\n+\t\t\tif n > 0 {\n+\t\t\t\tch := byte('\\n')\n+\t\t\t\tif droppedFF {\n+\t\t\t\t\tch = '\\f' // use formfeed since we dropped one before\n+\t\t\t\t}\n+\t\t\t\tp.writeByteN(ch, n)\n \t\t\t}\n \n \t\t\tp.writeItem(next, data, isLit)\n@@ -790,16 +811,15 @@ func (p *printer) commentBefore(next token.Position) bool {\n \treturn p.cindex < len(p.comments) && p.fset.Position(p.comments[p.cindex].List[0].Pos()).Offset < next.Offset\n }\n \n-// Flush prints any pending comments and whitespace occurring\n-// textually before the position of the next token tok. Flush\n-// returns true if a pending formfeed character was dropped\n-// from the whitespace buffer as a result of interspersing\n-// comments.\n+// Flush prints any pending comments and whitespace occurring textually\n+// before the position of the next token tok. The Flush result indicates\n+// if a newline was written or if a formfeed was dropped from the whitespace\n+// buffer.\n //\n-func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n+func (p *printer) flush(next token.Position, tok token.Token) (wroteNewline, droppedFF bool) {\n \tif p.commentBefore(next) {\n \t\t// if there are comments before the next item, intersperse them\n-\t\tdroppedFF = p.intersperseComments(next, tok)\n+\t\twroteNewline, droppedFF = p.intersperseComments(next, tok)\n \t} else {\n \t\t// otherwise, write any leftover whitespace\n \t\tp.writeWhitespace(len(p.wsbuf))\n@@ -810,7 +830,8 @@ func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n // getNode returns the ast.CommentGroup associated with n, if any.\n func getDoc(n ast.Node) *ast.CommentGroup {\n \tswitch n := n.(type) {\n-\t// *ast.Fields cannot be printed separately - ignore for now\n+\tcase *ast.Field:\n+\t\treturn n.Doc\n \tcase *ast.ImportSpec:\n \t\treturn n.Doc\n \tcase *ast.ValueSpec:"}, {"sha": "d2ad9e3a2ff94dc4e7747ade0df954dafa2cfe81", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -106,7 +106,7 @@ type S3 struct {\n var x int\t// x\n var ()\n \n-// This comment SHOULD be associated with the next declaration.\n+// This comment SHOULD be associated with f0.\n func f0() {\n \tconst pi = 3.14\t// pi\n \tvar s1 struct{}\t/* an empty struct */\t/* foo */\n@@ -115,8 +115,9 @@ func f0() {\n \tvar s2 struct{} = struct{}{}\n \tx := pi\n }\n+\n //\n-// NO SPACE HERE\n+// This comment should be associated with f1, with one blank line before the comment.\n //\n func f1() {\n \tf0()"}, {"sha": "222e0a713d4621786ab449c0ecfc6084d6d84a1f", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -107,7 +107,7 @@ var x int  // x\n var ()\n \n \n-// This comment SHOULD be associated with the next declaration.\n+// This comment SHOULD be associated with f0.\n func f0() {\n \tconst pi = 3.14  // pi\n \tvar s1 struct {}  /* an empty struct */ /* foo */\n@@ -117,7 +117,7 @@ func f0() {\n \tx := pi\n }\n //\n-// NO SPACE HERE\n+// This comment should be associated with f1, with one blank line before the comment.\n //\n func f1() {\n \tf0()\n@@ -130,7 +130,7 @@ func f1() {\n \n \n func _() {\n-\t// this comment should be properly indented\n+// this comment should be properly indented\n }\n \n "}, {"sha": "239ba890304599a0305f5567c666f3c518461fde", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -115,6 +115,18 @@ import _ \"io\"\n \n var _ int\n \n+// at least one empty line between declarations of the same kind\n+// if there is associated documentation (was issue 2570)\n+type T1 struct{}\n+\n+// T2 comment\n+type T2 struct {\n+}\t// should be a two-line struct\n+\n+// T3 comment\n+type T2 struct {\n+}\t// should be a two-line struct\n+\n // printing of constant literals\n const (\n \t_\t= \"foobar\"\n@@ -286,6 +298,15 @@ type _ struct {\n \t}\n }\n \n+// no blank lines in empty structs and interfaces, but leave 1- or 2-line layout alone\n+type _ struct{}\n+type _ struct {\n+}\n+\n+type _ interface{}\n+type _ interface {\n+}\n+\n // no tabs for single or ungrouped decls\n func _() {\n \tconst xxxxxx = 0"}, {"sha": "68f90308a362b942fb55a72ffe682346d5caeddf", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -115,6 +115,20 @@ import (\n import _ \"io\"\n var _ int\n \n+// at least one empty line between declarations of the same kind\n+// if there is associated documentation (was issue 2570)\n+type T1 struct{}\n+// T2 comment\n+type T2 struct {\n+} // should be a two-line struct\n+\n+\n+// T3 comment\n+type T2 struct {\n+\n+\n+} // should be a two-line struct\n+\n \n // printing of constant literals\n const (\n@@ -293,6 +307,18 @@ type _ struct {\n }\n \n \n+// no blank lines in empty structs and interfaces, but leave 1- or 2-line layout alone\n+type _ struct{            }\n+type _ struct {\n+\n+}\n+\n+type _ interface{            }\n+type _ interface {\n+\n+}\n+\n+\n // no tabs for single or ungrouped decls\n func _() {\n \tconst xxxxxx = 0"}, {"sha": "90e1743557d382007e8fcfe664e3edd157886f48", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -271,7 +271,6 @@ func _() {\n \t// Known bug: The first use call may have more than one empty line before\n \t//            (see go/printer/nodes.go, func linebreak).\n \n-\n \tuse(x)\n \n \tif x < x {\n@@ -386,7 +385,6 @@ L:\t// A comment on the same line as the label, followed by a single empty line.\n \t// Known bug: There may be more than one empty line before MoreCode()\n \t//            (see go/printer/nodes.go, func linebreak).\n \n-\n \tMoreCode()\n }\n "}, {"sha": "7fb0104e450a51d74df116cd347a137e0ccdbbb1", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -426,20 +426,24 @@ func (S *Scanner) scanString() {\n \tS.next()\n }\n \n-func (S *Scanner) scanRawString() {\n+func (S *Scanner) scanRawString() (hasCR bool) {\n \t// '`' opening already consumed\n \toffs := S.offset - 1\n \n \tfor S.ch != '`' {\n \t\tch := S.ch\n \t\tS.next()\n+\t\tif ch == '\\r' {\n+\t\t\thasCR = true\n+\t\t}\n \t\tif ch < 0 {\n \t\t\tS.error(offs, \"string not terminated\")\n \t\t\tbreak\n \t\t}\n \t}\n \n \tS.next()\n+\treturn\n }\n \n func (S *Scanner) skipWhitespace() {\n@@ -490,6 +494,18 @@ func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Tok\n \treturn tok0\n }\n \n+func stripCR(b []byte) []byte {\n+\tc := make([]byte, len(b))\n+\ti := 0\n+\tfor _, ch := range b {\n+\t\tif ch != '\\r' {\n+\t\t\tc[i] = ch\n+\t\t\ti++\n+\t\t}\n+\t}\n+\treturn c[:i]\n+}\n+\n // Scan scans the next token and returns the token position,\n // the token, and the literal string corresponding to the\n // token. The source end is indicated by token.EOF.\n@@ -518,6 +534,7 @@ scanAgain:\n \tinsertSemi := false\n \toffs := S.offset\n \ttok := token.ILLEGAL\n+\thasCR := false\n \n \t// determine token value\n \tswitch ch := S.ch; {\n@@ -556,7 +573,7 @@ scanAgain:\n \t\tcase '`':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n-\t\t\tS.scanRawString()\n+\t\t\thasCR = S.scanRawString()\n \t\tcase ':':\n \t\t\ttok = S.switch2(token.COLON, token.DEFINE)\n \t\tcase '.':\n@@ -663,5 +680,9 @@ scanAgain:\n \t// TODO(gri): The scanner API should change such that the literal string\n \t//            is only valid if an actual literal was scanned. This will\n \t//            permit a more efficient implementation.\n-\treturn S.file.Pos(offs), tok, string(S.src[offs:S.offset])\n+\tlit := S.src[offs:S.offset]\n+\tif hasCR {\n+\t\tlit = stripCR(lit)\n+\t}\n+\treturn S.file.Pos(offs), tok, string(lit)\n }"}, {"sha": "dc8ab2a748a08a7826ccef1dd103ea1110a13779", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -83,6 +83,8 @@ var tokens = [...]elt{\n \t\t\"`\",\n \t\tliteral,\n \t},\n+\t{token.STRING, \"`\\r`\", literal},\n+\t{token.STRING, \"`foo\\r\\nbar`\", literal},\n \n \t// Operators and delimiters\n \t{token.ADD, \"+\", operator},\n@@ -239,8 +241,16 @@ func TestScan(t *testing.T) {\n \t\tif tok != e.tok {\n \t\t\tt.Errorf(\"bad token for %q: got %s, expected %s\", lit, tok, e.tok)\n \t\t}\n-\t\tif e.tok.IsLiteral() && lit != e.lit {\n-\t\t\tt.Errorf(\"bad literal for %q: got %q, expected %q\", lit, lit, e.lit)\n+\t\tif e.tok.IsLiteral() {\n+\t\t\t// no CRs in raw string literals\n+\t\t\telit := e.lit\n+\t\t\tif elit[0] == '`' {\n+\t\t\t\telit = string(stripCR([]byte(elit)))\n+\t\t\t\tepos.Offset += len(e.lit) - len(lit) // correct position\n+\t\t\t}\n+\t\t\tif lit != elit {\n+\t\t\t\tt.Errorf(\"bad literal for %q: got %q, expected %q\", lit, lit, elit)\n+\t\t\t}\n \t\t}\n \t\tif tokenclass(tok) != e.class {\n \t\t\tt.Errorf(\"bad class for %q: got %d, expected %d\", lit, tokenclass(tok), e.class)"}, {"sha": "d7cc8bb9a9931f33a925b98c3a2930ddf112bf82", "filename": "libgo/go/html/const.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fconst.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -7,7 +7,7 @@ package html\n // Section 12.2.3.2 of the HTML5 specification says \"The following elements\n // have varying levels of special parsing rules\".\n // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-stack-of-open-elements\n-var isSpecialElement = map[string]bool{\n+var isSpecialElementMap = map[string]bool{\n \t\"address\":    true,\n \t\"applet\":     true,\n \t\"area\":       true,\n@@ -88,3 +88,13 @@ var isSpecialElement = map[string]bool{\n \t\"wbr\":        true,\n \t\"xmp\":        true,\n }\n+\n+func isSpecialElement(element *Node) bool {\n+\tswitch element.Namespace {\n+\tcase \"\", \"html\":\n+\t\treturn isSpecialElementMap[element.Data]\n+\tcase \"svg\":\n+\t\treturn element.Data == \"foreignObject\"\n+\t}\n+\treturn false\n+}"}, {"sha": "6962e643932cae1a27a559697393ca33400de8fb", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -319,10 +319,7 @@ func (p *parser) resetInsertionMode() {\n \t\tcase \"html\":\n \t\t\tp.im = beforeHeadIM\n \t\tdefault:\n-\t\t\tif p.top().Namespace == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tp.im = inForeignContentIM\n+\t\t\tcontinue\n \t\t}\n \t\treturn\n \t}\n@@ -705,7 +702,7 @@ func inBodyIM(p *parser) bool {\n \t\t\t\tcase \"address\", \"div\", \"p\":\n \t\t\t\t\tcontinue\n \t\t\t\tdefault:\n-\t\t\t\t\tif !isSpecialElement[node.Data] {\n+\t\t\t\t\tif !isSpecialElement(node) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -723,7 +720,7 @@ func inBodyIM(p *parser) bool {\n \t\t\t\tcase \"address\", \"div\", \"p\":\n \t\t\t\t\tcontinue\n \t\t\t\tdefault:\n-\t\t\t\t\tif !isSpecialElement[node.Data] {\n+\t\t\t\t\tif !isSpecialElement(node) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -814,7 +811,6 @@ func inBodyIM(p *parser) bool {\n \t\t\t// TODO: adjust foreign attributes.\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.top().Namespace = namespace\n-\t\t\tp.im = inForeignContentIM\n \t\t\treturn true\n \t\tcase \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// Ignore the token.\n@@ -895,7 +891,7 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t// Steps 5-6. Find the furthest block.\n \t\tvar furthestBlock *Node\n \t\tfor _, e := range p.oe[feIndex:] {\n-\t\t\tif isSpecialElement[e.Data] {\n+\t\t\tif isSpecialElement(e) {\n \t\t\t\tfurthestBlock = e\n \t\t\t\tbreak\n \t\t\t}\n@@ -988,7 +984,7 @@ func (p *parser) inBodyEndTagOther(tag string) {\n \t\t\tp.oe = p.oe[:i]\n \t\t\tbreak\n \t\t}\n-\t\tif isSpecialElement[p.oe[i].Data] {\n+\t\tif isSpecialElement(p.oe[i]) {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -1206,6 +1202,13 @@ func inTableBodyIM(p *parser) bool {\n \t\t\tadd = true\n \t\t\tdata = \"tr\"\n \t\t\tconsumed = false\n+\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\":\n+\t\t\tif !p.popUntil(tableScopeStopTags, \"tbody\", \"thead\", \"tfoot\") {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tp.im = inTableIM\n+\t\t\treturn false\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n@@ -1569,6 +1572,19 @@ func afterAfterFramesetIM(p *parser) bool {\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n+\tcase TextToken:\n+\t\t// Ignore all text but whitespace.\n+\t\ts := strings.Map(func(c rune) rune {\n+\t\t\tswitch c {\n+\t\t\tcase ' ', '\\t', '\\n', '\\f', '\\r':\n+\t\t\t\treturn c\n+\t\t\t}\n+\t\t\treturn -1\n+\t\t}, p.tok.Data)\n+\t\tif s != \"\" {\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addText(s)\n+\t\t}\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"html\":\n@@ -1583,16 +1599,34 @@ func afterAfterFramesetIM(p *parser) bool {\n }\n \n // Section 12.2.5.5.\n-func inForeignContentIM(p *parser) bool {\n+func parseForeignContent(p *parser) bool {\n \tswitch p.tok.Type {\n+\tcase TextToken:\n+\t\t// TODO: HTML integration points.\n+\t\tif p.top().Namespace == \"\" {\n+\t\t\tinBodyIM(p)\n+\t\t\tp.resetInsertionMode()\n+\t\t\treturn true\n+\t\t}\n+\t\tif p.framesetOK {\n+\t\t\tp.framesetOK = strings.TrimLeft(p.tok.Data, whitespace) == \"\"\n+\t\t}\n+\t\tp.addText(p.tok.Data)\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \tcase StartTagToken:\n \t\tif breakout[p.tok.Data] {\n-\t\t\t// TODO.\n+\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\t\t// TODO: HTML, MathML integration points.\n+\t\t\t\tif p.oe[i].Namespace == \"\" {\n+\t\t\t\t\tp.oe = p.oe[:i+1]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false\n \t\t}\n \t\tswitch p.top().Namespace {\n \t\tcase \"mathml\":\n@@ -1606,13 +1640,36 @@ func inForeignContentIM(p *parser) bool {\n \t\t// TODO: adjust foreign attributes.\n \t\tp.addElement(p.tok.Data, p.tok.Attr)\n \tcase EndTagToken:\n-\t\t// TODO.\n+\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\tif p.oe[i].Namespace == \"\" {\n+\t\t\t\treturn p.im(p)\n+\t\t\t}\n+\t\t\tif strings.EqualFold(p.oe[i].Data, p.tok.Data) {\n+\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n \tdefault:\n \t\t// Ignore the token.\n \t}\n \treturn true\n }\n \n+// Section 12.2.5.\n+func (p *parser) inForeignContent() bool {\n+\tif len(p.oe) == 0 {\n+\t\treturn false\n+\t}\n+\tn := p.oe[len(p.oe)-1]\n+\tif n.Namespace == \"\" {\n+\t\treturn false\n+\t}\n+\t// TODO: MathML, HTML integration points.\n+\t// TODO: MathML's annotation-xml combining with SVG's svg.\n+\treturn true\n+}\n+\n func (p *parser) parse() error {\n \t// Iterate until EOF. Any other error will cause an early return.\n \tconsumed := true\n@@ -1625,7 +1682,11 @@ func (p *parser) parse() error {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n-\t\tconsumed = p.im(p)\n+\t\tif p.inForeignContent() {\n+\t\t\tconsumed = parseForeignContent(p)\n+\t\t} else {\n+\t\t\tconsumed = p.im(p)\n+\t\t}\n \t}\n \t// Loop until the final token (the ErrorToken signifying EOF) is consumed.\n \tfor {"}, {"sha": "015b5838f0b50b3a0e8f33e39c545dc68988a60c", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -172,7 +172,8 @@ func TestParser(t *testing.T) {\n \t\t{\"tests3.dat\", -1},\n \t\t{\"tests4.dat\", -1},\n \t\t{\"tests5.dat\", -1},\n-\t\t{\"tests6.dat\", 36},\n+\t\t{\"tests6.dat\", 47},\n+\t\t{\"tests10.dat\", 16},\n \t}\n \tfor _, tf := range testFiles {\n \t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)"}, {"sha": "dcac748967691be048c851ea36441fc991cfdd77", "filename": "libgo/go/html/template/error.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -183,11 +183,11 @@ const (\n \n func (e *Error) Error() string {\n \tif e.Line != 0 {\n-\t\treturn fmt.Sprintf(\"exp/template/html:%s:%d: %s\", e.Name, e.Line, e.Description)\n+\t\treturn fmt.Sprintf(\"html/template:%s:%d: %s\", e.Name, e.Line, e.Description)\n \t} else if e.Name != \"\" {\n-\t\treturn fmt.Sprintf(\"exp/template/html:%s: %s\", e.Name, e.Description)\n+\t\treturn fmt.Sprintf(\"html/template:%s: %s\", e.Name, e.Description)\n \t}\n-\treturn \"exp/template/html: \" + e.Description\n+\treturn \"html/template: \" + e.Description\n }\n \n // errorf creates an error given a format string f and args."}, {"sha": "c6f723ae4a47baff517340b075fca9286d090005", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -486,9 +486,17 @@ func (e *escaper) escapeTree(c context, name string, line int) (context, string)\n \t}\n \tt := e.template(name)\n \tif t == nil {\n+\t\t// Two cases: The template exists but is empty, or has never been mentioned at\n+\t\t// all. Distinguish the cases in the error messages.\n+\t\tif e.tmpl.set[name] != nil {\n+\t\t\treturn context{\n+\t\t\t\tstate: stateError,\n+\t\t\t\terr:   errorf(ErrNoSuchTemplate, line, \"%q is an incomplete or empty template\", name),\n+\t\t\t}, dname\n+\t\t}\n \t\treturn context{\n \t\t\tstate: stateError,\n-\t\t\terr:   errorf(ErrNoSuchTemplate, line, \"no such template %s\", name),\n+\t\t\terr:   errorf(ErrNoSuchTemplate, line, \"no such template %q\", name),\n \t\t}, dname\n \t}\n \tif dname != name {"}, {"sha": "a57f9826b5b5a4e75a5214cc1bf039ed04228082", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -928,7 +928,7 @@ func TestErrors(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t`{{template \"foo\"}}`,\n-\t\t\t\"z:1: no such template foo\",\n+\t\t\t\"z:1: no such template \\\"foo\\\"\",\n \t\t},\n \t\t{\n \t\t\t`<div{{template \"y\"}}>` +\n@@ -944,23 +944,23 @@ func TestErrors(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t`<input type=button value=onclick=>`,\n-\t\t\t`exp/template/html:z: \"=\" in unquoted attr: \"onclick=\"`,\n+\t\t\t`html/template:z: \"=\" in unquoted attr: \"onclick=\"`,\n \t\t},\n \t\t{\n \t\t\t`<input type=button value= onclick=>`,\n-\t\t\t`exp/template/html:z: \"=\" in unquoted attr: \"onclick=\"`,\n+\t\t\t`html/template:z: \"=\" in unquoted attr: \"onclick=\"`,\n \t\t},\n \t\t{\n \t\t\t`<input type=button value= 1+1=2>`,\n-\t\t\t`exp/template/html:z: \"=\" in unquoted attr: \"1+1=2\"`,\n+\t\t\t`html/template:z: \"=\" in unquoted attr: \"1+1=2\"`,\n \t\t},\n \t\t{\n \t\t\t\"<a class=`foo>\",\n-\t\t\t\"exp/template/html:z: \\\"`\\\" in unquoted attr: \\\"`foo\\\"\",\n+\t\t\t\"html/template:z: \\\"`\\\" in unquoted attr: \\\"`foo\\\"\",\n \t\t},\n \t\t{\n \t\t\t`<a style=font:'Arial'>`,\n-\t\t\t`exp/template/html:z: \"'\" in unquoted attr: \"font:'Arial'\"`,\n+\t\t\t`html/template:z: \"'\" in unquoted attr: \"font:'Arial'\"`,\n \t\t},\n \t\t{\n \t\t\t`<a=foo>`,"}, {"sha": "c79816dd45aa7631e8ebbaeef650a915ff85563c", "filename": "libgo/go/image/color/ycbcr.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package color\n+\n+// RGBToYCbCr converts an RGB triple to a Y'CbCr triple. All components lie\n+// within the range [0, 255].\n+func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {\n+\t// The JFIF specification says:\n+\t//\tY' =  0.2990*R + 0.5870*G + 0.1140*B\n+\t//\tCb = -0.1687*R - 0.3313*G + 0.5000*B + 128\n+\t//\tCr =  0.5000*R - 0.4187*G - 0.0813*B + 128\n+\t// http://www.w3.org/Graphics/JPEG/jfif3.pdf says Y but means Y'.\n+\tr1 := int(r)\n+\tg1 := int(g)\n+\tb1 := int(b)\n+\tyy := (19595*r1 + 38470*g1 + 7471*b1 + 1<<15) >> 16\n+\tcb := (-11056*r1 - 21712*g1 + 32768*b1 + 257<<15) >> 16\n+\tcr := (32768*r1 - 27440*g1 - 5328*b1 + 257<<15) >> 16\n+\tif yy < 0 {\n+\t\tyy = 0\n+\t} else if yy > 255 {\n+\t\tyy = 255\n+\t}\n+\tif cb < 0 {\n+\t\tcb = 0\n+\t} else if cb > 255 {\n+\t\tcb = 255\n+\t}\n+\tif cr < 0 {\n+\t\tcr = 0\n+\t} else if cr > 255 {\n+\t\tcr = 255\n+\t}\n+\treturn uint8(yy), uint8(cb), uint8(cr)\n+}\n+\n+// YCbCrToRGB converts a Y'CbCr triple to an RGB triple. All components lie\n+// within the range [0, 255].\n+func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8) {\n+\t// The JFIF specification says:\n+\t//\tR = Y' + 1.40200*(Cr-128)\n+\t//\tG = Y' - 0.34414*(Cb-128) - 0.71414*(Cr-128)\n+\t//\tB = Y' + 1.77200*(Cb-128)\n+\t// http://www.w3.org/Graphics/JPEG/jfif3.pdf says Y but means Y'.\n+\tyy1 := int(y)<<16 + 1<<15\n+\tcb1 := int(cb) - 128\n+\tcr1 := int(cr) - 128\n+\tr := (yy1 + 91881*cr1) >> 16\n+\tg := (yy1 - 22554*cb1 - 46802*cr1) >> 16\n+\tb := (yy1 + 116130*cb1) >> 16\n+\tif r < 0 {\n+\t\tr = 0\n+\t} else if r > 255 {\n+\t\tr = 255\n+\t}\n+\tif g < 0 {\n+\t\tg = 0\n+\t} else if g > 255 {\n+\t\tg = 255\n+\t}\n+\tif b < 0 {\n+\t\tb = 0\n+\t} else if b > 255 {\n+\t\tb = 255\n+\t}\n+\treturn uint8(r), uint8(g), uint8(b)\n+}\n+\n+// YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for\n+// one luma and two chroma components.\n+//\n+// JPEG, VP8, the MPEG family and other codecs use this color model. Such\n+// codecs often use the terms YUV and Y'CbCr interchangeably, but strictly\n+// speaking, the term YUV applies only to analog video signals, and Y' (luma)\n+// is Y (luminance) after applying gamma correction.\n+//\n+// Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly\n+// different formulae for converting between the two. This package follows\n+// the JFIF specification at http://www.w3.org/Graphics/JPEG/jfif3.pdf.\n+type YCbCr struct {\n+\tY, Cb, Cr uint8\n+}\n+\n+func (c YCbCr) RGBA() (uint32, uint32, uint32, uint32) {\n+\tr, g, b := YCbCrToRGB(c.Y, c.Cb, c.Cr)\n+\treturn uint32(r) * 0x101, uint32(g) * 0x101, uint32(b) * 0x101, 0xffff\n+}\n+\n+// YCbCrModel is the Model for Y'CbCr colors.\n+var YCbCrModel Model = ModelFunc(func(c Color) Color {\n+\tif _, ok := c.(YCbCr); ok {\n+\t\treturn c\n+\t}\n+\tr, g, b, _ := c.RGBA()\n+\ty, u, v := RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n+\treturn YCbCr{y, u, v}\n+})"}, {"sha": "92a0e6ff1e7518abfc6cae957ec110dc2aad0297", "filename": "libgo/go/image/color/ycbcr_test.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fycbcr_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package ycbcr\n+package color\n \n import (\n \t\"testing\"", "previous_filename": "libgo/go/image/ycbcr/ycbcr_test.go"}, {"sha": "4cd2095c441195678f5be74c07e8a4f6e5432ae4", "filename": "libgo/go/image/draw/bench_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -7,7 +7,6 @@ package draw\n import (\n \t\"image\"\n \t\"image/color\"\n-\t\"image/ycbcr\"\n \t\"testing\"\n )\n \n@@ -51,7 +50,7 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \t\t}\n \t\tdst = dst1\n \tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tb.Fatal(\"unknown destination color model\", dcm)\n \t}\n \n \tvar src image.Image\n@@ -97,7 +96,7 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \t\t\t}\n \t\t}\n \t\tsrc = src1\n-\tcase ycbcr.YCbCrColorModel:\n+\tcase color.YCbCrModel:\n \t\tyy := make([]uint8, srcw*srch)\n \t\tcb := make([]uint8, srcw*srch)\n \t\tcr := make([]uint8, srcw*srch)\n@@ -106,17 +105,17 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \t\t\tcb[i] = uint8(5 * i % 0x100)\n \t\t\tcr[i] = uint8(7 * i % 0x100)\n \t\t}\n-\t\tsrc = &ycbcr.YCbCr{\n+\t\tsrc = &image.YCbCr{\n \t\t\tY:              yy,\n \t\t\tCb:             cb,\n \t\t\tCr:             cr,\n \t\t\tYStride:        srcw,\n \t\t\tCStride:        srcw,\n-\t\t\tSubsampleRatio: ycbcr.SubsampleRatio444,\n+\t\t\tSubsampleRatio: image.YCbCrSubsampleRatio444,\n \t\t\tRect:           image.Rect(0, 0, srcw, srch),\n \t\t}\n \tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tb.Fatal(\"unknown source color model\", scm)\n \t}\n \n \tvar mask image.Image\n@@ -137,7 +136,7 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \t\t}\n \t\tmask = mask1\n \tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tb.Fatal(\"unknown mask color model\", mcm)\n \t}\n \n \tb.StartTimer()\n@@ -177,7 +176,7 @@ func BenchmarkNRGBASrc(b *testing.B) {\n }\n \n func BenchmarkYCbCr(b *testing.B) {\n-\tbench(b, color.RGBAModel, ycbcr.YCbCrColorModel, nil, Over)\n+\tbench(b, color.RGBAModel, color.YCbCrModel, nil, Over)\n }\n \n func BenchmarkGlyphOver(b *testing.B) {"}, {"sha": "228ed6e719cc5e7242637de6dbebc09b79099455", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -11,7 +11,6 @@ package draw\n import (\n \t\"image\"\n \t\"image/color\"\n-\t\"image/ycbcr\"\n )\n \n // m is the maximum color value returned by image.Color.RGBA.\n@@ -81,7 +80,7 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \t\t\t\tcase *image.NRGBA:\n \t\t\t\t\tdrawNRGBAOver(dst0, r, src0, sp)\n \t\t\t\t\treturn\n-\t\t\t\tcase *ycbcr.YCbCr:\n+\t\t\t\tcase *image.YCbCr:\n \t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -104,7 +103,7 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \t\t\t\tcase *image.NRGBA:\n \t\t\t\t\tdrawNRGBASrc(dst0, r, src0, sp)\n \t\t\t\t\treturn\n-\t\t\t\tcase *ycbcr.YCbCr:\n+\t\t\t\tcase *image.YCbCr:\n \t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -346,8 +345,8 @@ func drawNRGBASrc(dst *image.RGBA, r image.Rectangle, src *image.NRGBA, sp image\n \t}\n }\n \n-func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *ycbcr.YCbCr, sp image.Point) {\n-\t// A YCbCr image is always fully opaque, and so if the mask is implicitly nil\n+func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Point) {\n+\t// An image.YCbCr is always fully opaque, and so if the mask is implicitly nil\n \t// (i.e. fully opaque) then the op is effectively always Src.\n \tvar (\n \t\tyy, cb, cr uint8\n@@ -357,30 +356,30 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *ycbcr.YCbCr, sp image.Po\n \ty0 := r.Min.Y - dst.Rect.Min.Y\n \ty1 := r.Max.Y - dst.Rect.Min.Y\n \tswitch src.SubsampleRatio {\n-\tcase ycbcr.SubsampleRatio422:\n+\tcase image.YCbCrSubsampleRatio422:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n \t\t\tfor x, sx := x0, sp.X; x != x1; x, sx = x+4, sx+1 {\n \t\t\t\ti := sx / 2\n \t\t\t\tyy = src.Y[sy*src.YStride+sx]\n \t\t\t\tcb = src.Cb[sy*src.CStride+i]\n \t\t\t\tcr = src.Cr[sy*src.CStride+i]\n-\t\t\t\trr, gg, bb := ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb\n \t\t\t\tdpix[x+3] = 255\n \t\t\t}\n \t\t}\n-\tcase ycbcr.SubsampleRatio420:\n+\tcase image.YCbCrSubsampleRatio420:\n \t\tfor y, sy := y0, sp.Y; y != y1; y, sy = y+1, sy+1 {\n \t\t\tdpix := dst.Pix[y*dst.Stride:]\n \t\t\tfor x, sx := x0, sp.X; x != x1; x, sx = x+4, sx+1 {\n \t\t\t\ti, j := sx/2, sy/2\n \t\t\t\tyy = src.Y[sy*src.YStride+sx]\n \t\t\t\tcb = src.Cb[j*src.CStride+i]\n \t\t\t\tcr = src.Cr[j*src.CStride+i]\n-\t\t\t\trr, gg, bb := ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb\n@@ -395,7 +394,7 @@ func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *ycbcr.YCbCr, sp image.Po\n \t\t\t\tyy = src.Y[sy*src.YStride+sx]\n \t\t\t\tcb = src.Cb[sy*src.CStride+sx]\n \t\t\t\tcr = src.Cr[sy*src.CStride+sx]\n-\t\t\t\trr, gg, bb := ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\trr, gg, bb := color.YCbCrToRGB(yy, cb, cr)\n \t\t\t\tdpix[x+0] = rr\n \t\t\t\tdpix[x+1] = gg\n \t\t\t\tdpix[x+2] = bb"}, {"sha": "56a45026b57ca46d6f362bc68db03d186ad1d3b3", "filename": "libgo/go/image/draw/draw_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -7,7 +7,6 @@ package draw\n import (\n \t\"image\"\n \t\"image/color\"\n-\t\"image/ycbcr\"\n \t\"testing\"\n )\n \n@@ -56,13 +55,13 @@ func vgradGreenNRGBA(alpha int) image.Image {\n }\n \n func vgradCr() image.Image {\n-\tm := &ycbcr.YCbCr{\n+\tm := &image.YCbCr{\n \t\tY:              make([]byte, 16*16),\n \t\tCb:             make([]byte, 16*16),\n \t\tCr:             make([]byte, 16*16),\n \t\tYStride:        16,\n \t\tCStride:        16,\n-\t\tSubsampleRatio: ycbcr.SubsampleRatio444,\n+\t\tSubsampleRatio: image.YCbCrSubsampleRatio444,\n \t\tRect:           image.Rect(0, 0, 16, 16),\n \t}\n \tfor y := 0; y < 16; y++ {"}, {"sha": "ed1a962586db5d20f162d997abdf2f2cf45e2d9a", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"bufio\"\n \t\"image\"\n \t\"image/color\"\n-\t\"image/ycbcr\"\n \t\"io\"\n )\n \n@@ -97,7 +96,7 @@ type decoder struct {\n \tr             Reader\n \twidth, height int\n \timg1          *image.Gray\n-\timg3          *ycbcr.YCbCr\n+\timg3          *image.YCbCr\n \tri            int // Restart Interval.\n \tnComp         int\n \tcomp          [nColorComponent]component\n@@ -203,20 +202,20 @@ func (d *decoder) makeImg(h0, v0, mxx, myy int) {\n \t\td.img1 = m.SubImage(image.Rect(0, 0, d.width, d.height)).(*image.Gray)\n \t\treturn\n \t}\n-\tvar subsampleRatio ycbcr.SubsampleRatio\n+\tvar subsampleRatio image.YCbCrSubsampleRatio\n \tn := h0 * v0\n \tswitch n {\n \tcase 1:\n-\t\tsubsampleRatio = ycbcr.SubsampleRatio444\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio444\n \tcase 2:\n-\t\tsubsampleRatio = ycbcr.SubsampleRatio422\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio422\n \tcase 4:\n-\t\tsubsampleRatio = ycbcr.SubsampleRatio420\n+\t\tsubsampleRatio = image.YCbCrSubsampleRatio420\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n \tb := make([]byte, mxx*myy*(1*8*8*n+2*8*8))\n-\td.img3 = &ycbcr.YCbCr{\n+\td.img3 = &image.YCbCr{\n \t\tY:              b[mxx*myy*(0*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+0*8*8)],\n \t\tCb:             b[mxx*myy*(1*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+1*8*8)],\n \t\tCr:             b[mxx*myy*(1*8*8*n+1*8*8) : mxx*myy*(1*8*8*n+2*8*8)],\n@@ -466,7 +465,7 @@ func DecodeConfig(r io.Reader) (image.Config, error) {\n \tcase nGrayComponent:\n \t\treturn image.Config{color.GrayModel, d.width, d.height}, nil\n \tcase nColorComponent:\n-\t\treturn image.Config{ycbcr.YCbCrColorModel, d.width, d.height}, nil\n+\t\treturn image.Config{color.YCbCrModel, d.width, d.height}, nil\n \t}\n \treturn image.Config{}, FormatError(\"missing SOF marker\")\n }"}, {"sha": "71fe37ce7ffc3d87cdc1ffe9785a62b6dddc84a1", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -8,7 +8,7 @@ import (\n \t\"bufio\"\n \t\"errors\"\n \t\"image\"\n-\t\"image/ycbcr\"\n+\t\"image/color\"\n \t\"io\"\n )\n \n@@ -379,7 +379,7 @@ func toYCbCr(m image.Image, p image.Point, yBlock, cbBlock, crBlock *block) {\n \tfor j := 0; j < 8; j++ {\n \t\tfor i := 0; i < 8; i++ {\n \t\t\tr, g, b, _ := m.At(min(p.X+i, xmax), min(p.Y+j, ymax)).RGBA()\n-\t\t\tyy, cb, cr := ycbcr.RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n+\t\t\tyy, cb, cr := color.RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n \t\t\tyBlock[8*j+i] = int(yy)\n \t\t\tcbBlock[8*j+i] = int(cb)\n \t\t\tcrBlock[8*j+i] = int(cr)\n@@ -404,7 +404,7 @@ func rgbaToYCbCr(m *image.RGBA, p image.Point, yBlock, cbBlock, crBlock *block)\n \t\t\t\tsx = xmax\n \t\t\t}\n \t\t\tpix := m.Pix[offset+sx*4:]\n-\t\t\tyy, cb, cr := ycbcr.RGBToYCbCr(pix[0], pix[1], pix[2])\n+\t\t\tyy, cb, cr := color.RGBToYCbCr(pix[0], pix[1], pix[2])\n \t\t\tyBlock[8*j+i] = int(yy)\n \t\t\tcbBlock[8*j+i] = int(cb)\n \t\t\tcrBlock[8*j+i] = int(cr)"}, {"sha": "e4b56d28847d517e7c9ea0eda7d19763623db55f", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -105,7 +105,7 @@ func BenchmarkEncodeRGBOpaque(b *testing.B) {\n \t\t}\n \t}\n \tif !img.Opaque() {\n-\t\tpanic(\"expected image to be opaque\")\n+\t\tb.Fatal(\"expected image to be opaque\")\n \t}\n \tb.SetBytes(640 * 480 * 4)\n \tb.StartTimer()"}, {"sha": "228ecccfb4f76486457d7ab6b81847abcf22229f", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -125,7 +125,7 @@ func BenchmarkEncodeRGBOpaque(b *testing.B) {\n \t\t}\n \t}\n \tif !img.Opaque() {\n-\t\tpanic(\"expected image to be opaque\")\n+\t\tb.Fatal(\"expected image to be opaque\")\n \t}\n \tb.SetBytes(640 * 480 * 4)\n \tb.StartTimer()\n@@ -138,7 +138,7 @@ func BenchmarkEncodeRGBA(b *testing.B) {\n \tb.StopTimer()\n \timg := image.NewRGBA(image.Rect(0, 0, 640, 480))\n \tif img.Opaque() {\n-\t\tpanic(\"expected image to not be opaque\")\n+\t\tb.Fatal(\"expected image to not be opaque\")\n \t}\n \tb.SetBytes(640 * 480 * 4)\n \tb.StartTimer()"}, {"sha": "ee5dafd9962a75ed37b7fb6dc66587169a356b2a", "filename": "libgo/go/image/tiff/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -113,7 +113,7 @@ func BenchmarkDecode(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\t_, err := Decode(r)\n \t\tif err != nil {\n-\t\t\tpanic(err)\n+\t\t\tb.Fatal(\"Decode:\", err)\n \t\t}\n \t}\n }"}, {"sha": "81f3c9fe03d12ce2310db18ad2516ee9cfb44ba5", "filename": "libgo/go/image/ycbcr.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fimage%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package image\n+\n+import (\n+\t\"image/color\"\n+)\n+\n+// YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.\n+type YCbCrSubsampleRatio int\n+\n+const (\n+\tYCbCrSubsampleRatio444 YCbCrSubsampleRatio = iota\n+\tYCbCrSubsampleRatio422\n+\tYCbCrSubsampleRatio420\n+)\n+\n+// YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per\n+// pixel, but each Cb and Cr sample can span one or more pixels.\n+// YStride is the Y slice index delta between vertically adjacent pixels.\n+// CStride is the Cb and Cr slice index delta between vertically adjacent pixels\n+// that map to separate chroma samples.\n+// It is not an absolute requirement, but YStride and len(Y) are typically\n+// multiples of 8, and:\n+//\tFor 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1.\n+//\tFor 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.\n+//\tFor 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.\n+type YCbCr struct {\n+\tY              []uint8\n+\tCb             []uint8\n+\tCr             []uint8\n+\tYStride        int\n+\tCStride        int\n+\tSubsampleRatio YCbCrSubsampleRatio\n+\tRect           Rectangle\n+}\n+\n+func (p *YCbCr) ColorModel() color.Model {\n+\treturn color.YCbCrModel\n+}\n+\n+func (p *YCbCr) Bounds() Rectangle {\n+\treturn p.Rect\n+}\n+\n+func (p *YCbCr) At(x, y int) color.Color {\n+\tif !(Point{x, y}.In(p.Rect)) {\n+\t\treturn color.YCbCr{}\n+\t}\n+\tswitch p.SubsampleRatio {\n+\tcase YCbCrSubsampleRatio422:\n+\t\ti := x / 2\n+\t\treturn color.YCbCr{\n+\t\t\tp.Y[y*p.YStride+x],\n+\t\t\tp.Cb[y*p.CStride+i],\n+\t\t\tp.Cr[y*p.CStride+i],\n+\t\t}\n+\tcase YCbCrSubsampleRatio420:\n+\t\ti, j := x/2, y/2\n+\t\treturn color.YCbCr{\n+\t\t\tp.Y[y*p.YStride+x],\n+\t\t\tp.Cb[j*p.CStride+i],\n+\t\t\tp.Cr[j*p.CStride+i],\n+\t\t}\n+\t}\n+\t// Default to 4:4:4 subsampling.\n+\treturn color.YCbCr{\n+\t\tp.Y[y*p.YStride+x],\n+\t\tp.Cb[y*p.CStride+x],\n+\t\tp.Cr[y*p.CStride+x],\n+\t}\n+}\n+\n+// SubImage returns an image representing the portion of the image p visible\n+// through r. The returned value shares pixels with the original image.\n+func (p *YCbCr) SubImage(r Rectangle) Image {\n+\tq := new(YCbCr)\n+\t*q = *p\n+\tq.Rect = q.Rect.Intersect(r)\n+\treturn q\n+}\n+\n+func (p *YCbCr) Opaque() bool {\n+\treturn true\n+}"}, {"sha": "84a35a3fb5eb94848a13c9654362f4e11c261070", "filename": "libgo/go/image/ycbcr/ycbcr.go", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83fa0bf8f411697ec908cfa86ee6faf4cd9c476/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83fa0bf8f411697ec908cfa86ee6faf4cd9c476/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go?ref=f83fa0bf8f411697ec908cfa86ee6faf4cd9c476", "patch": "@@ -1,184 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package ycbcr provides images from the Y'CbCr color model.\n-//\n-// JPEG, VP8, the MPEG family and other codecs use this color model. Such\n-// codecs often use the terms YUV and Y'CbCr interchangeably, but strictly\n-// speaking, the term YUV applies only to analog video signals.\n-//\n-// Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly\n-// different formulae for converting between the two. This package follows\n-// the JFIF specification at http://www.w3.org/Graphics/JPEG/jfif3.pdf.\n-package ycbcr\n-\n-import (\n-\t\"image\"\n-\t\"image/color\"\n-)\n-\n-// RGBToYCbCr converts an RGB triple to a YCbCr triple. All components lie\n-// within the range [0, 255].\n-func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8) {\n-\t// The JFIF specification says:\n-\t//\tY' =  0.2990*R + 0.5870*G + 0.1140*B\n-\t//\tCb = -0.1687*R - 0.3313*G + 0.5000*B + 128\n-\t//\tCr =  0.5000*R - 0.4187*G - 0.0813*B + 128\n-\t// http://www.w3.org/Graphics/JPEG/jfif3.pdf says Y but means Y'.\n-\tr1 := int(r)\n-\tg1 := int(g)\n-\tb1 := int(b)\n-\tyy := (19595*r1 + 38470*g1 + 7471*b1 + 1<<15) >> 16\n-\tcb := (-11056*r1 - 21712*g1 + 32768*b1 + 257<<15) >> 16\n-\tcr := (32768*r1 - 27440*g1 - 5328*b1 + 257<<15) >> 16\n-\tif yy < 0 {\n-\t\tyy = 0\n-\t} else if yy > 255 {\n-\t\tyy = 255\n-\t}\n-\tif cb < 0 {\n-\t\tcb = 0\n-\t} else if cb > 255 {\n-\t\tcb = 255\n-\t}\n-\tif cr < 0 {\n-\t\tcr = 0\n-\t} else if cr > 255 {\n-\t\tcr = 255\n-\t}\n-\treturn uint8(yy), uint8(cb), uint8(cr)\n-}\n-\n-// YCbCrToRGB converts a YCbCr triple to an RGB triple. All components lie\n-// within the range [0, 255].\n-func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8) {\n-\t// The JFIF specification says:\n-\t//\tR = Y' + 1.40200*(Cr-128)\n-\t//\tG = Y' - 0.34414*(Cb-128) - 0.71414*(Cr-128)\n-\t//\tB = Y' + 1.77200*(Cb-128)\n-\t// http://www.w3.org/Graphics/JPEG/jfif3.pdf says Y but means Y'.\n-\tyy1 := int(y)<<16 + 1<<15\n-\tcb1 := int(cb) - 128\n-\tcr1 := int(cr) - 128\n-\tr := (yy1 + 91881*cr1) >> 16\n-\tg := (yy1 - 22554*cb1 - 46802*cr1) >> 16\n-\tb := (yy1 + 116130*cb1) >> 16\n-\tif r < 0 {\n-\t\tr = 0\n-\t} else if r > 255 {\n-\t\tr = 255\n-\t}\n-\tif g < 0 {\n-\t\tg = 0\n-\t} else if g > 255 {\n-\t\tg = 255\n-\t}\n-\tif b < 0 {\n-\t\tb = 0\n-\t} else if b > 255 {\n-\t\tb = 255\n-\t}\n-\treturn uint8(r), uint8(g), uint8(b)\n-}\n-\n-// YCbCrColor represents a fully opaque 24-bit Y'CbCr color, having 8 bits for\n-// each of one luma and two chroma components.\n-type YCbCrColor struct {\n-\tY, Cb, Cr uint8\n-}\n-\n-func (c YCbCrColor) RGBA() (uint32, uint32, uint32, uint32) {\n-\tr, g, b := YCbCrToRGB(c.Y, c.Cb, c.Cr)\n-\treturn uint32(r) * 0x101, uint32(g) * 0x101, uint32(b) * 0x101, 0xffff\n-}\n-\n-func toYCbCrColor(c color.Color) color.Color {\n-\tif _, ok := c.(YCbCrColor); ok {\n-\t\treturn c\n-\t}\n-\tr, g, b, _ := c.RGBA()\n-\ty, u, v := RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n-\treturn YCbCrColor{y, u, v}\n-}\n-\n-// YCbCrColorModel is the color model for YCbCrColor.\n-var YCbCrColorModel color.Model = color.ModelFunc(toYCbCrColor)\n-\n-// SubsampleRatio is the chroma subsample ratio used in a YCbCr image.\n-type SubsampleRatio int\n-\n-const (\n-\tSubsampleRatio444 SubsampleRatio = iota\n-\tSubsampleRatio422\n-\tSubsampleRatio420\n-)\n-\n-// YCbCr is an in-memory image of YCbCr colors. There is one Y sample per pixel,\n-// but each Cb and Cr sample can span one or more pixels.\n-// YStride is the Y slice index delta between vertically adjacent pixels.\n-// CStride is the Cb and Cr slice index delta between vertically adjacent pixels\n-// that map to separate chroma samples.\n-// It is not an absolute requirement, but YStride and len(Y) are typically\n-// multiples of 8, and:\n-//\tFor 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1.\n-//\tFor 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.\n-//\tFor 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.\n-type YCbCr struct {\n-\tY              []uint8\n-\tCb             []uint8\n-\tCr             []uint8\n-\tYStride        int\n-\tCStride        int\n-\tSubsampleRatio SubsampleRatio\n-\tRect           image.Rectangle\n-}\n-\n-func (p *YCbCr) ColorModel() color.Model {\n-\treturn YCbCrColorModel\n-}\n-\n-func (p *YCbCr) Bounds() image.Rectangle {\n-\treturn p.Rect\n-}\n-\n-func (p *YCbCr) At(x, y int) color.Color {\n-\tif !(image.Point{x, y}.In(p.Rect)) {\n-\t\treturn YCbCrColor{}\n-\t}\n-\tswitch p.SubsampleRatio {\n-\tcase SubsampleRatio422:\n-\t\ti := x / 2\n-\t\treturn YCbCrColor{\n-\t\t\tp.Y[y*p.YStride+x],\n-\t\t\tp.Cb[y*p.CStride+i],\n-\t\t\tp.Cr[y*p.CStride+i],\n-\t\t}\n-\tcase SubsampleRatio420:\n-\t\ti, j := x/2, y/2\n-\t\treturn YCbCrColor{\n-\t\t\tp.Y[y*p.YStride+x],\n-\t\t\tp.Cb[j*p.CStride+i],\n-\t\t\tp.Cr[j*p.CStride+i],\n-\t\t}\n-\t}\n-\t// Default to 4:4:4 subsampling.\n-\treturn YCbCrColor{\n-\t\tp.Y[y*p.YStride+x],\n-\t\tp.Cb[y*p.CStride+x],\n-\t\tp.Cr[y*p.CStride+x],\n-\t}\n-}\n-\n-// SubImage returns an image representing the portion of the image p visible\n-// through r. The returned value shares pixels with the original image.\n-func (p *YCbCr) SubImage(r image.Rectangle) image.Image {\n-\tq := new(YCbCr)\n-\t*q = *p\n-\tq.Rect = q.Rect.Intersect(r)\n-\treturn q\n-}\n-\n-func (p *YCbCr) Opaque() bool {\n-\treturn true\n-}"}, {"sha": "103066817cd97428311d5584dc15f654c2151976", "filename": "libgo/go/io/ioutil/ioutil_test.go", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -37,7 +37,11 @@ func TestReadFile(t *testing.T) {\n }\n \n func TestWriteFile(t *testing.T) {\n-\tfilename := \"_test/rumpelstilzchen\"\n+\tf, err := TempFile(\"\", \"ioutil-test\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfilename := f.Name()\n \tdata := \"Programming today is a race between software engineers striving to \" +\n \t\t\"build bigger and better idiot-proof programs, and the Universe trying \" +\n \t\t\"to produce bigger and better idiots. So far, the Universe is winning.\"\n@@ -56,6 +60,7 @@ func TestWriteFile(t *testing.T) {\n \t}\n \n \t// cleanup\n+\tf.Close()\n \tos.Remove(filename) // ignore error\n }\n \n@@ -66,26 +71,28 @@ func TestReadDir(t *testing.T) {\n \t\tt.Fatalf(\"ReadDir %s: error expected, none found\", dirname)\n \t}\n \n-\tdirname = \".\"\n+\tdirname = \"..\"\n \tlist, err := ReadDir(dirname)\n \tif err != nil {\n \t\tt.Fatalf(\"ReadDir %s: %v\", dirname, err)\n \t}\n \n-\tfoundTest := false\n-\tfoundTestDir := false\n+/* Does not work in gccgo testing environment.\n+\tfoundFile := false\n+\tfoundSubDir := false\n \tfor _, dir := range list {\n \t\tswitch {\n-\t\tcase !dir.IsDir() && dir.Name() == \"ioutil_test.go\":\n-\t\t\tfoundTest = true\n-\t\tcase dir.IsDir() && dir.Name() == \"_test\":\n-\t\t\tfoundTestDir = true\n+\t\tcase !dir.IsDir() && dir.Name() == \"io_test.go\":\n+\t\t\tfoundFile = true\n+\t\tcase dir.IsDir() && dir.Name() == \"ioutil\":\n+\t\t\tfoundSubDir = true\n \t\t}\n \t}\n-\tif !foundTest {\n-\t\tt.Fatalf(\"ReadDir %s: test file not found\", dirname)\n+\tif !foundFile {\n+\t\tt.Fatalf(\"ReadDir %s: io_test.go file not found\", dirname)\n \t}\n-\tif !foundTestDir {\n-\t\tt.Fatalf(\"ReadDir %s: _test directory not found\", dirname)\n+\tif !foundSubDir {\n+\t\tt.Fatalf(\"ReadDir %s: ioutil directory not found\", dirname)\n \t}\n+*/\n }"}, {"sha": "914391af80d65132c8e9cf2151b676aaa20c5518", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -92,11 +92,13 @@ func (w *Writer) Emerg(m string) (err error) {\n \t_, err = w.writeString(LOG_EMERG, m)\n \treturn err\n }\n+\n // Crit logs a message using the LOG_CRIT priority.\n func (w *Writer) Crit(m string) (err error) {\n \t_, err = w.writeString(LOG_CRIT, m)\n \treturn err\n }\n+\n // ERR logs a message using the LOG_ERR priority.\n func (w *Writer) Err(m string) (err error) {\n \t_, err = w.writeString(LOG_ERR, m)\n@@ -114,11 +116,13 @@ func (w *Writer) Notice(m string) (err error) {\n \t_, err = w.writeString(LOG_NOTICE, m)\n \treturn err\n }\n+\n // Info logs a message using the LOG_INFO priority.\n func (w *Writer) Info(m string) (err error) {\n \t_, err = w.writeString(LOG_INFO, m)\n \treturn err\n }\n+\n // Debug logs a message using the LOG_DEBUG priority.\n func (w *Writer) Debug(m string) (err error) {\n \t_, err = w.writeString(LOG_DEBUG, m)"}, {"sha": "101c8dd85b4ac6f755fef9481738f68fef08804d", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -22,6 +22,7 @@ var vf = []float64{\n \t1.8253080916808550e+00,\n \t-8.6859247685756013e+00,\n }\n+\n // The expected results below were computed by the high precision calculators\n // at http://keisan.casio.com/.  More exact input values (array vf[], above)\n // were obtained by printing them with \"%.26f\".  The answers were calculated\n@@ -159,6 +160,7 @@ var cos = []float64{\n \t-2.517729313893103197176091e-01,\n \t-7.39241351595676573201918e-01,\n }\n+\n // Results for 100000 * Pi + vf[i]\n var cosLarge = []float64{\n \t2.634752141185559426744e-01,\n@@ -514,6 +516,7 @@ var sin = []float64{\n \t9.6778633541687993721617774e-01,\n \t-6.734405869050344734943028e-01,\n }\n+\n // Results for 100000 * Pi + vf[i]\n var sinLarge = []float64{\n \t-9.646661658548936063912e-01,\n@@ -563,6 +566,7 @@ var tan = []float64{\n \t-3.843885560201130679995041e+00,\n \t9.10988793377685105753416e-01,\n }\n+\n // Results for 100000 * Pi + vf[i]\n var tanLarge = []float64{\n \t-3.66131656475596512705e+00,"}, {"sha": "9c4b730187404fd25278ac3128d68fe19ae494d4", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"encoding/gob\"\n \t\"encoding/hex\"\n \t\"fmt\"\n+\t\"math/rand\"\n \t\"testing\"\n \t\"testing/quick\"\n )\n@@ -1405,3 +1406,9 @@ func TestIntGobEncoding(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIssue2607(t *testing.T) {\n+\t// This code sequence used to hang.\n+\tn := NewInt(10)\n+\tn.Rand(rand.New(rand.NewSource(9)), n)\n+}"}, {"sha": "69681ae2d640b825ba3b1bcbf3be370efea7b38f", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -1196,12 +1196,16 @@ func (x nat) powersOfTwoDecompose() (q nat, k int) {\n // random creates a random integer in [0..limit), using the space in z if\n // possible. n is the bit length of limit.\n func (z nat) random(rand *rand.Rand, limit nat, n int) nat {\n+\tif alias(z, limit) {\n+\t\tz = nil // z is an alias for limit - cannot reuse\n+\t}\n+\tz = z.make(len(limit))\n+\n \tbitLengthOfMSW := uint(n % _W)\n \tif bitLengthOfMSW == 0 {\n \t\tbitLengthOfMSW = _W\n \t}\n \tmask := Word((1 << bitLengthOfMSW) - 1)\n-\tz = z.make(len(limit))\n \n \tfor {\n \t\tfor i := range z {"}, {"sha": "25e39273c0c8b48313cd5b394b9984645cc49183", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -5,7 +5,6 @@\n package big\n \n import (\n-\t\"fmt\"\n \t\"io\"\n \t\"strings\"\n \t\"testing\"\n@@ -402,7 +401,7 @@ func ScanHelper(b *testing.B, base int, x, y Word) {\n \tvar s string\n \ts = z.string(lowercaseDigits[0:base])\n \tif t := toString(z, lowercaseDigits[0:base]); t != s {\n-\t\tpanic(fmt.Sprintf(\"scanning: got %s; want %s\", s, t))\n+\t\tb.Fatalf(\"scanning: got %s; want %s\", s, t)\n \t}\n \tb.StartTimer()\n "}, {"sha": "ebde7d43681afea2cc5a2c893f61685eddecdc30", "filename": "libgo/go/math/sin.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsin.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -98,6 +98,7 @@ var _sin = [...]float64{\n \t8.33333333332211858878E-3,  // 0x3f8111111110f7d0\n \t-1.66666666666666307295E-1, // 0xbfc5555555555548\n }\n+\n // cos coefficients\n var _cos = [...]float64{\n \t-1.13585365213876817300E-11, // 0xbda8fa49a0861a9b"}, {"sha": "2dab1eac78d41d5fb95d31f120659856de67998b", "filename": "libgo/go/mime/type_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmime%2Ftype_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fmime%2Ftype_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux netbsd openbsd plan9\n+\n package mime\n \n import ("}, {"sha": "66aff837d0a412fc2529b874152600fd46e6b5d2", "filename": "libgo/go/net/cgo_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_stub.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build openbsd\n+// +build nocgo\n \n // Stub cgo routines for systems that do not use cgo to do network lookups.\n "}, {"sha": "00acb8477d22dee3b555402b1aa7f50a4f675735", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -4,6 +4,10 @@\n \n package net\n \n+import (\n+\t\"time\"\n+)\n+\n func resolveNetAddr(op, net, addr string) (a Addr, err error) {\n \tif addr == \"\" {\n \t\treturn nil, &OpError{op, net, nil, errMissingAddress}\n@@ -42,11 +46,15 @@ func resolveNetAddr(op, net, addr string) (a Addr, err error) {\n //\tDial(\"tcp\", \"google.com:80\")\n //\tDial(\"tcp\", \"[de:ad:be:ef::ca:fe]:80\")\n //\n-func Dial(net, addr string) (c Conn, err error) {\n+func Dial(net, addr string) (Conn, error) {\n \taddri, err := resolveNetAddr(\"dial\", net, addr)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\treturn dialAddr(net, addr, addri)\n+}\n+\n+func dialAddr(net, addr string, addri Addr) (c Conn, err error) {\n \tswitch ra := addri.(type) {\n \tcase *TCPAddr:\n \t\tc, err = DialTCP(net, nil, ra)\n@@ -65,6 +73,62 @@ func Dial(net, addr string) (c Conn, err error) {\n \treturn\n }\n \n+// DialTimeout acts like Dial but takes a timeout.\n+// The timeout includes name resolution, if required.\n+func DialTimeout(net, addr string, timeout time.Duration) (Conn, error) {\n+\t// TODO(bradfitz): the timeout should be pushed down into the\n+\t// net package's event loop, so on timeout to dead hosts we\n+\t// don't have a goroutine sticking around for the default of\n+\t// ~3 minutes.\n+\tt := time.NewTimer(timeout)\n+\tdefer t.Stop()\n+\ttype pair struct {\n+\t\tConn\n+\t\terror\n+\t}\n+\tch := make(chan pair, 1)\n+\tresolvedAddr := make(chan Addr, 1)\n+\tgo func() {\n+\t\taddri, err := resolveNetAddr(\"dial\", net, addr)\n+\t\tif err != nil {\n+\t\t\tch <- pair{nil, err}\n+\t\t\treturn\n+\t\t}\n+\t\tresolvedAddr <- addri // in case we need it for OpError\n+\t\tc, err := dialAddr(net, addr, addri)\n+\t\tch <- pair{c, err}\n+\t}()\n+\tselect {\n+\tcase <-t.C:\n+\t\t// Try to use the real Addr in our OpError, if we resolved it\n+\t\t// before the timeout. Otherwise we just use stringAddr.\n+\t\tvar addri Addr\n+\t\tselect {\n+\t\tcase a := <-resolvedAddr:\n+\t\t\taddri = a\n+\t\tdefault:\n+\t\t\taddri = &stringAddr{net, addr}\n+\t\t}\n+\t\terr := &OpError{\n+\t\t\tOp:   \"dial\",\n+\t\t\tNet:  net,\n+\t\t\tAddr: addri,\n+\t\t\tErr:  &timeoutError{},\n+\t\t}\n+\t\treturn nil, err\n+\tcase p := <-ch:\n+\t\treturn p.Conn, p.error\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+type stringAddr struct {\n+\tnet, addr string\n+}\n+\n+func (a stringAddr) Network() string { return a.net }\n+func (a stringAddr) String() string  { return a.addr }\n+\n // Listen announces on the local network address laddr.\n // The network string net must be a stream-oriented\n // network: \"tcp\", \"tcp4\", \"tcp6\", or \"unix\", or \"unixpacket\"."}, {"sha": "16b726311534ed7409502f90e354060ebc327a58", "filename": "libgo/go/net/dial_test.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func newLocalListener(t *testing.T) Listener {\n+\tln, err := Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tln, err = Listen(\"tcp6\", \"[::1]:0\")\n+\t}\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn ln\n+}\n+\n+func TestDialTimeout(t *testing.T) {\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\n+\terrc := make(chan error)\n+\n+\tconst SOMAXCONN = 0x80 // copied from syscall, but not always available\n+\tconst numConns = SOMAXCONN + 10\n+\n+\t// TODO(bradfitz): It's hard to test this in a portable\n+\t// way. This is unforunate, but works for now.\n+\tswitch runtime.GOOS {\n+\tcase \"linux\":\n+\t\t// The kernel will start accepting TCP connections before userspace\n+\t\t// gets a chance to not accept them, so fire off a bunch to fill up\n+\t\t// the kernel's backlog.  Then we test we get a failure after that.\n+\t\tfor i := 0; i < numConns; i++ {\n+\t\t\tgo func() {\n+\t\t\t\t_, err := DialTimeout(\"tcp\", ln.Addr().String(), 200*time.Millisecond)\n+\t\t\t\terrc <- err\n+\t\t\t}()\n+\t\t}\n+\tcase \"darwin\":\n+\t\t// At least OS X 10.7 seems to accept any number of\n+\t\t// connections, ignoring listen's backlog, so resort\n+\t\t// to connecting to a hopefully-dead 127/8 address.\n+\t\tgo func() {\n+\t\t\t_, err := DialTimeout(\"tcp\", \"127.0.71.111:80\", 200*time.Millisecond)\n+\t\t\terrc <- err\n+\t\t}()\n+\tdefault:\n+\t\t// TODO(bradfitz): this probably doesn't work on\n+\t\t// Windows? SOMAXCONN is huge there.  I'm not sure how\n+\t\t// listen works there.\n+\t\t// OpenBSD may have a reject route to 10/8.\n+\t\t// FreeBSD likely works, but is untested.\n+\t\tt.Logf(\"skipping test on %q; untested.\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tconnected := 0\n+\tfor {\n+\t\tselect {\n+\t\tcase <-time.After(15 * time.Second):\n+\t\t\tt.Fatal(\"too slow\")\n+\t\tcase err := <-errc:\n+\t\t\tif err == nil {\n+\t\t\t\tconnected++\n+\t\t\t\tif connected == numConns {\n+\t\t\t\t\tt.Fatal(\"all connections connected; expected some to time out\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tterr, ok := err.(timeout)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tt.Fatalf(\"got error %q; want error with timeout interface\", err)\n+\t\t\t\t}\n+\t\t\t\tif !terr.Timeout() {\n+\t\t\t\t\tt.Fatalf(\"got error %q; not a timeout\", err)\n+\t\t\t\t}\n+\t\t\t\t// Pass. We saw a timeout error.\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "07e72ccb862cff6ac1f2d461ed3674edd04a829f", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // DNS client: see RFC 1035.\n // Has to be linked into package net for Dial."}, {"sha": "c0ab80288da349f8c9d5028849c210c076a9466b", "filename": "libgo/go/net/dnsconfig.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdnsconfig.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fdnsconfig.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsconfig.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Read system DNS config from /etc/resolv.conf\n "}, {"sha": "3dec9f4beb8b87ba6046ff148c48dac2e0ab7ce1", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package net\n \n@@ -377,14 +377,6 @@ func (fd *netFD) CloseWrite() error {\n \treturn fd.shutdown(syscall.SHUT_WR)\n }\n \n-type timeoutError struct{}\n-\n-func (e *timeoutError) Error() string   { return \"i/o timeout\" }\n-func (e *timeoutError) Timeout() bool   { return true }\n-func (e *timeoutError) Temporary() bool { return true }\n-\n-var errTimeout error = &timeoutError{}\n-\n func (fd *netFD) Read(p []byte) (n int, err error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL"}, {"sha": "c8df9c9326a0b8dc418ec56739dd8f532d9f06dd", "filename": "libgo/go/net/fd_linux.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_linux.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -37,11 +37,17 @@ func newpollster() (p *pollster, err error) {\n \tp = new(pollster)\n \tvar e error\n \n-\t// The arg to epoll_create is a hint to the kernel\n-\t// about the number of FDs we will care about.\n-\t// We don't know, and since 2.6.8 the kernel ignores it anyhow.\n-\tif p.epfd, e = syscall.EpollCreate(16); e != nil {\n-\t\treturn nil, os.NewSyscallError(\"epoll_create\", e)\n+\tif p.epfd, e = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC); e != nil {\n+\t\tif e != syscall.ENOSYS {\n+\t\t\treturn nil, os.NewSyscallError(\"epoll_create1\", e)\n+\t\t}\n+\t\t// The arg to epoll_create is a hint to the kernel\n+\t\t// about the number of FDs we will care about.\n+\t\t// We don't know, and since 2.6.8 the kernel ignores it anyhow.\n+\t\tif p.epfd, e = syscall.EpollCreate(16); e != nil {\n+\t\t\treturn nil, os.NewSyscallError(\"epoll_create\", e)\n+\t\t}\n+\t\tsyscall.CloseOnExec(p.epfd)\n \t}\n \tp.events = make(map[int]uint32)\n \treturn p, nil"}, {"sha": "31d0744e2cbe56af2447f2b14a84ce812bf607b1", "filename": "libgo/go/net/fd_netbsd.go", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_netbsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Waiting for FDs via kqueue/kevent.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type pollster struct {\n+\tkq       int\n+\teventbuf [10]syscall.Kevent_t\n+\tevents   []syscall.Kevent_t\n+\n+\t// An event buffer for AddFD/DelFD.\n+\t// Must hold pollServer lock.\n+\tkbuf [1]syscall.Kevent_t\n+}\n+\n+func newpollster() (p *pollster, err error) {\n+\tp = new(pollster)\n+\tif p.kq, err = syscall.Kqueue(); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"kqueue\", err)\n+\t}\n+\tsyscall.CloseOnExec(p.kq)\n+\tp.events = p.eventbuf[0:0]\n+\treturn p, nil\n+}\n+\n+func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n+\t// pollServer is locked.\n+\n+\tvar kmode int\n+\tif mode == 'r' {\n+\t\tkmode = syscall.EVFILT_READ\n+\t} else {\n+\t\tkmode = syscall.EVFILT_WRITE\n+\t}\n+\tev := &p.kbuf[0]\n+\t// EV_ADD - add event to kqueue list\n+\t// EV_ONESHOT - delete the event the first time it triggers\n+\tflags := syscall.EV_ADD\n+\tif !repeat {\n+\t\tflags |= syscall.EV_ONESHOT\n+\t}\n+\tsyscall.SetKevent(ev, fd, kmode, flags)\n+\n+\tn, e := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n+\tif e != nil {\n+\t\treturn false, os.NewSyscallError(\"kevent\", e)\n+\t}\n+\tif n != 1 || (ev.Flags&syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {\n+\t\treturn false, os.NewSyscallError(\"kqueue phase error\", e)\n+\t}\n+\tif ev.Data != 0 {\n+\t\treturn false, syscall.Errno(int(ev.Data))\n+\t}\n+\treturn false, nil\n+}\n+\n+func (p *pollster) DelFD(fd int, mode int) {\n+\t// pollServer is locked.\n+\n+\tvar kmode int\n+\tif mode == 'r' {\n+\t\tkmode = syscall.EVFILT_READ\n+\t} else {\n+\t\tkmode = syscall.EVFILT_WRITE\n+\t}\n+\tev := &p.kbuf[0]\n+\t// EV_DELETE - delete event from kqueue list\n+\tsyscall.SetKevent(ev, fd, kmode, syscall.EV_DELETE)\n+\tsyscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n+}\n+\n+func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err error) {\n+\tvar t *syscall.Timespec\n+\tfor len(p.events) == 0 {\n+\t\tif nsec > 0 {\n+\t\t\tif t == nil {\n+\t\t\t\tt = new(syscall.Timespec)\n+\t\t\t}\n+\t\t\t*t = syscall.NsecToTimespec(nsec)\n+\t\t}\n+\n+\t\ts.Unlock()\n+\t\tnn, e := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n+\t\ts.Lock()\n+\n+\t\tif e != nil {\n+\t\t\tif e == syscall.EINTR {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", e)\n+\t\t}\n+\t\tif nn == 0 {\n+\t\t\treturn -1, 0, nil\n+\t\t}\n+\t\tp.events = p.eventbuf[0:nn]\n+\t}\n+\tev := &p.events[0]\n+\tp.events = p.events[1:]\n+\tfd = int(ev.Ident)\n+\tif ev.Filter == syscall.EVFILT_READ {\n+\t\tmode = 'r'\n+\t} else {\n+\t\tmode = 'w'\n+\t}\n+\treturn fd, mode, nil\n+}\n+\n+func (p *pollster) Close() error { return os.NewSyscallError(\"close\", syscall.Close(p.kq)) }"}, {"sha": "31d0744e2cbe56af2447f2b14a84ce812bf607b1", "filename": "libgo/go/net/fd_openbsd.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_openbsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -26,6 +26,7 @@ func newpollster() (p *pollster, err error) {\n \tif p.kq, err = syscall.Kqueue(); err != nil {\n \t\treturn nil, os.NewSyscallError(\"kqueue\", err)\n \t}\n+\tsyscall.CloseOnExec(p.kq)\n \tp.events = p.eventbuf[0:0]\n \treturn p, nil\n }"}, {"sha": "4ac280bd1a34b657ff35043e5471623b4a336bd1", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package net\n "}, {"sha": "a4f8f19aac84d4662d083616d3c4c89379f34791", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -38,6 +38,11 @@ type Client struct {\n \t// If CheckRedirect is nil, the Client uses its default policy,\n \t// which is to stop after 10 consecutive requests.\n \tCheckRedirect func(req *Request, via []*Request) error\n+\n+\t// Jar specifies the cookie jar. \n+\t// If Jar is nil, cookies are not sent in requests and ignored \n+\t// in responses.\n+\tJar CookieJar\n }\n \n // DefaultClient is the default Client and is used by Get, Head, and Post.\n@@ -180,6 +185,11 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t\treturn nil, errors.New(\"http: nil Request.URL\")\n \t}\n \n+\tjar := c.Jar\n+\tif jar == nil {\n+\t\tjar = blackHoleJar{}\n+\t}\n+\n \treq := ireq\n \turlStr := \"\" // next relative or absolute URL to fetch (after first request)\n \tfor redirect := 0; ; redirect++ {\n@@ -203,12 +213,19 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfor _, cookie := range jar.Cookies(req.URL) {\n+\t\t\t\treq.AddCookie(cookie)\n+\t\t\t}\n \t\t}\n \n \t\turlStr = req.URL.String()\n \t\tif r, err = send(req, c.Transport); err != nil {\n \t\t\tbreak\n \t\t}\n+\t\tif c := r.Cookies(); len(c) > 0 {\n+\t\t\tjar.SetCookies(req.URL, c)\n+\t\t}\n+\n \t\tif shouldRedirect(r.StatusCode) {\n \t\t\tr.Body.Close()\n \t\t\tif urlStr = r.Header.Get(\"Location\"); urlStr == \"\" {"}, {"sha": "2c2caa251fe3eb24c7844b14a78fc440e7a8dd48", "filename": "libgo/go/net/http/jar.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fjar.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"net/url\"\n+)\n+\n+// A CookieJar manages storage and use of cookies in HTTP requests. \n+//\n+// Implementations of CookieJar must be safe for concurrent use by multiple\n+// goroutines.\n+type CookieJar interface {\n+\t// SetCookies handles the receipt of the cookies in a reply for the \n+\t// given URL.  It may or may not choose to save the cookies, depending \n+\t// on the jar's policy and implementation. \n+\tSetCookies(u *url.URL, cookies []*Cookie)\n+\n+\t// Cookies returns the cookies to send in a request for the given URL.\n+\t// It is up to the implementation to honor the standard cookie use \n+\t// restrictions such as in RFC 6265. \n+\tCookies(u *url.URL) []*Cookie\n+}\n+\n+type blackHoleJar struct{}\n+\n+func (blackHoleJar) SetCookies(u *url.URL, cookies []*Cookie) {}\n+func (blackHoleJar) Cookies(u *url.URL) []*Cookie             { return nil }"}, {"sha": "ad7e3c02b0ca0f382e3746319cefdcb725d23407", "filename": "libgo/go/net/http/readrequest_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -219,7 +219,7 @@ func TestReadRequest(t *testing.T) {\n \t\t\tt.Errorf(\"#%d: Body = %q want %q\", i, body, tt.Body)\n \t\t}\n \t\tif !reflect.DeepEqual(tt.Trailer, req.Trailer) {\n-\t\t\tt.Errorf(\"%#d. Trailers differ.\\n got: %v\\nwant: %v\", i, req.Trailer, tt.Trailer)\n+\t\t\tt.Errorf(\"#%d. Trailers differ.\\n got: %v\\nwant: %v\", i, req.Trailer, tt.Trailer)\n \t\t}\n \t}\n }"}, {"sha": "7b78645169eb56d65fcc110d2a5c562d709a4067", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -202,8 +202,8 @@ func validateTestMultipartContents(t *testing.T, req *Request, allMem bool) {\n \tif g, e := req.FormValue(\"texta\"), textaValue; g != e {\n \t\tt.Errorf(\"texta value = %q, want %q\", g, e)\n \t}\n-\tif g, e := req.FormValue(\"texta\"), textaValue; g != e {\n-\t\tt.Errorf(\"texta value = %q, want %q\", g, e)\n+\tif g, e := req.FormValue(\"textb\"), textbValue; g != e {\n+\t\tt.Errorf(\"textb value = %q, want %q\", g, e)\n \t}\n \tif g := req.FormValue(\"missing\"); g != \"\" {\n \t\tt.Errorf(\"missing value = %q, want empty string\", g)\n@@ -214,14 +214,16 @@ func validateTestMultipartContents(t *testing.T, req *Request, allMem bool) {\n \t\t\tt.Error(n, \" is *os.File, should not be\")\n \t\t}\n \t}\n-\tfd := testMultipartFile(t, req, \"filea\", \"filea.txt\", fileaContents)\n-\tassertMem(\"filea\", fd)\n-\tfd = testMultipartFile(t, req, \"fileb\", \"fileb.txt\", filebContents)\n+\tfda := testMultipartFile(t, req, \"filea\", \"filea.txt\", fileaContents)\n+\tdefer fda.Close()\n+\tassertMem(\"filea\", fda)\n+\tfdb := testMultipartFile(t, req, \"fileb\", \"fileb.txt\", filebContents)\n+\tdefer fdb.Close()\n \tif allMem {\n-\t\tassertMem(\"fileb\", fd)\n+\t\tassertMem(\"fileb\", fdb)\n \t} else {\n-\t\tif _, ok := fd.(*os.File); !ok {\n-\t\t\tt.Errorf(\"fileb has unexpected underlying type %T\", fd)\n+\t\tif _, ok := fdb.(*os.File); !ok {\n+\t\t\tt.Errorf(\"fileb has unexpected underlying type %T\", fdb)\n \t\t}\n \t}\n "}, {"sha": "24e6b50dab87e6d74d128927d8c40a72f9a02587", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -1164,15 +1164,15 @@ func BenchmarkClientServer(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tres, err := Get(ts.URL)\n \t\tif err != nil {\n-\t\t\tpanic(\"Get: \" + err.Error())\n+\t\t\tb.Fatal(\"Get:\", err)\n \t\t}\n \t\tall, err := ioutil.ReadAll(res.Body)\n \t\tif err != nil {\n-\t\t\tpanic(\"ReadAll: \" + err.Error())\n+\t\t\tb.Fatal(\"ReadAll:\", err)\n \t\t}\n \t\tbody := string(all)\n \t\tif body != \"Hello world.\\n\" {\n-\t\t\tpanic(\"Got body: \" + body)\n+\t\t\tb.Fatal(\"Got body:\", body)\n \t\t}\n \t}\n "}, {"sha": "907f80a80f3118522bf0cc16a0dd1113f31919c1", "filename": "libgo/go/net/interface_bsd.go", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_bsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n // Network interface identification for BSD variants\n \n@@ -18,21 +18,16 @@ import (\n // network interfaces.  Otheriwse it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n-\tvar (\n-\t\ttab  []byte\n-\t\te    error\n-\t\tmsgs []syscall.RoutingMessage\n-\t\tift  []Interface\n-\t)\n-\n-\ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route rib\", e)\n+\tvar ift []Interface\n+\n+\ttab, err := syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route rib\", err)\n \t}\n \n-\tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route message\", e)\n+\tmsgs, err := syscall.ParseRoutingMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n \tfor _, m := range msgs {\n@@ -54,9 +49,9 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n func newLink(m *syscall.InterfaceMessage) ([]Interface, error) {\n \tvar ift []Interface\n \n-\tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n+\tsas, err := syscall.ParseRoutingSockaddr(m)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n \tfor _, s := range sas {\n@@ -108,21 +103,16 @@ func linkFlags(rawFlags int32) Flags {\n // for all network interfaces.  Otherwise it returns addresses\n // for a specific interface.\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n-\tvar (\n-\t\ttab  []byte\n-\t\te    error\n-\t\tmsgs []syscall.RoutingMessage\n-\t\tifat []Addr\n-\t)\n-\n-\ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route rib\", e)\n+\tvar ifat []Addr\n+\n+\ttab, err := syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route rib\", err)\n \t}\n \n-\tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route message\", e)\n+\tmsgs, err := syscall.ParseRoutingMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n \tfor _, m := range msgs {\n@@ -133,40 +123,49 @@ func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n-\t\t\t\tifat = append(ifat, ifa...)\n+\t\t\t\tifat = append(ifat, ifa)\n \t\t\t}\n \t\t}\n \t}\n \n \treturn ifat, nil\n }\n \n-func newAddr(m *syscall.InterfaceAddrMessage) ([]Addr, error) {\n-\tvar ifat []Addr\n+func newAddr(m *syscall.InterfaceAddrMessage) (Addr, error) {\n+\tifa := &IPNet{}\n \n-\tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n+\tsas, err := syscall.ParseRoutingSockaddr(m)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n-\tfor _, s := range sas {\n+\tfor i, s := range sas {\n \t\tswitch v := s.(type) {\n \t\tcase *syscall.SockaddrInet4:\n-\t\t\tifa := &IPAddr{IP: IPv4(v.Addr[0], v.Addr[1], v.Addr[2], v.Addr[3])}\n-\t\t\tifat = append(ifat, ifa.toAddr())\n+\t\t\tswitch i {\n+\t\t\tcase 0:\n+\t\t\t\tifa.Mask = IPv4Mask(v.Addr[0], v.Addr[1], v.Addr[2], v.Addr[3])\n+\t\t\tcase 1:\n+\t\t\t\tifa.IP = IPv4(v.Addr[0], v.Addr[1], v.Addr[2], v.Addr[3])\n+\t\t\t}\n \t\tcase *syscall.SockaddrInet6:\n-\t\t\tifa := &IPAddr{IP: make(IP, IPv6len)}\n-\t\t\tcopy(ifa.IP, v.Addr[:])\n-\t\t\t// NOTE: KAME based IPv6 protcol stack usually embeds\n-\t\t\t// the interface index in the interface-local or link-\n-\t\t\t// local address as the kernel-internal form.\n-\t\t\tif ifa.IP.IsLinkLocalUnicast() {\n-\t\t\t\t// remove embedded scope zone ID\n-\t\t\t\tifa.IP[2], ifa.IP[3] = 0, 0\n+\t\t\tswitch i {\n+\t\t\tcase 0:\n+\t\t\t\tifa.Mask = make(IPMask, IPv6len)\n+\t\t\t\tcopy(ifa.Mask, v.Addr[:])\n+\t\t\tcase 1:\n+\t\t\t\tifa.IP = make(IP, IPv6len)\n+\t\t\t\tcopy(ifa.IP, v.Addr[:])\n+\t\t\t\t// NOTE: KAME based IPv6 protcol stack usually embeds\n+\t\t\t\t// the interface index in the interface-local or link-\n+\t\t\t\t// local address as the kernel-internal form.\n+\t\t\t\tif ifa.IP.IsLinkLocalUnicast() {\n+\t\t\t\t\t// remove embedded scope zone ID\n+\t\t\t\t\tifa.IP[2], ifa.IP[3] = 0, 0\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tifat = append(ifat, ifa.toAddr())\n \t\t}\n \t}\n \n-\treturn ifat, nil\n+\treturn ifa, nil\n }"}, {"sha": "c0887c57efeeb2b2e3e123a8eace09132844caf4", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -17,21 +17,16 @@ import (\n // network interfaces.  Otheriwse it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n-\tvar (\n-\t\tift  []Interface\n-\t\ttab  []byte\n-\t\tmsgs []syscall.NetlinkMessage\n-\t\te    error\n-\t)\n+\tvar ift []Interface\n \n-\ttab, e = syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"netlink rib\", e)\n+\ttab, err := syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"netlink rib\", err)\n \t}\n \n-\tmsgs, e = syscall.ParseNetlinkMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"netlink message\", e)\n+\tmsgs, err := syscall.ParseNetlinkMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"netlink message\", err)\n \t}\n \n \tfor _, m := range msgs {\n@@ -41,11 +36,11 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\tcase syscall.RTM_NEWLINK:\n \t\t\tifim := (*syscall.IfInfomsg)(unsafe.Pointer(&m.Data[0]))\n \t\t\tif ifindex == 0 || ifindex == int(ifim.Index) {\n-\t\t\t\tattrs, e := syscall.ParseNetlinkRouteAttr(&m)\n-\t\t\t\tif e != nil {\n-\t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", e)\n+\t\t\t\tattrs, err := syscall.ParseNetlinkRouteAttr(&m)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", err)\n \t\t\t\t}\n-\t\t\t\tifi := newLink(attrs, ifim)\n+\t\t\t\tifi := newLink(ifim, attrs)\n \t\t\t\tift = append(ift, ifi)\n \t\t\t}\n \t\t}\n@@ -55,7 +50,7 @@ done:\n \treturn ift, nil\n }\n \n-func newLink(attrs []syscall.NetlinkRouteAttr, ifim *syscall.IfInfomsg) Interface {\n+func newLink(ifim *syscall.IfInfomsg, attrs []syscall.NetlinkRouteAttr) Interface {\n \tifi := Interface{Index: int(ifim.Index), Flags: linkFlags(ifim.Flags)}\n \tfor _, a := range attrs {\n \t\tswitch a.Attr.Type {\n@@ -102,19 +97,19 @@ func linkFlags(rawFlags uint32) Flags {\n // for all network interfaces.  Otherwise it returns addresses\n // for a specific interface.\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n-\ttab, e := syscall.NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"netlink rib\", e)\n+\ttab, err := syscall.NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"netlink rib\", err)\n \t}\n \n-\tmsgs, e := syscall.ParseNetlinkMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"netlink message\", e)\n+\tmsgs, err := syscall.ParseNetlinkMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"netlink message\", err)\n \t}\n \n-\tifat, e := addrTable(msgs, ifindex)\n-\tif e != nil {\n-\t\treturn nil, e\n+\tifat, err := addrTable(msgs, ifindex)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \treturn ifat, nil\n@@ -130,11 +125,11 @@ func addrTable(msgs []syscall.NetlinkMessage, ifindex int) ([]Addr, error) {\n \t\tcase syscall.RTM_NEWADDR:\n \t\t\tifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))\n \t\t\tif ifindex == 0 || ifindex == int(ifam.Index) {\n-\t\t\t\tattrs, e := syscall.ParseNetlinkRouteAttr(&m)\n-\t\t\t\tif e != nil {\n-\t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", e)\n+\t\t\t\tattrs, err := syscall.ParseNetlinkRouteAttr(&m)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", err)\n \t\t\t\t}\n-\t\t\t\tifat = append(ifat, newAddr(attrs, int(ifam.Family))...)\n+\t\t\t\tifat = append(ifat, newAddr(attrs, int(ifam.Family), int(ifam.Prefixlen)))\n \t\t\t}\n \t\t}\n \t}\n@@ -143,34 +138,32 @@ done:\n \treturn ifat, nil\n }\n \n-func newAddr(attrs []syscall.NetlinkRouteAttr, family int) []Addr {\n-\tvar ifat []Addr\n-\n+func newAddr(attrs []syscall.NetlinkRouteAttr, family, pfxlen int) Addr {\n+\tifa := &IPNet{}\n \tfor _, a := range attrs {\n \t\tswitch a.Attr.Type {\n \t\tcase syscall.IFA_ADDRESS:\n \t\t\tswitch family {\n \t\t\tcase syscall.AF_INET:\n-\t\t\t\tifa := &IPAddr{IP: IPv4(a.Value[0], a.Value[1], a.Value[2], a.Value[3])}\n-\t\t\t\tifat = append(ifat, ifa.toAddr())\n+\t\t\t\tifa.IP = IPv4(a.Value[0], a.Value[1], a.Value[2], a.Value[3])\n+\t\t\t\tifa.Mask = CIDRMask(pfxlen, 8*IPv4len)\n \t\t\tcase syscall.AF_INET6:\n-\t\t\t\tifa := &IPAddr{IP: make(IP, IPv6len)}\n+\t\t\t\tifa.IP = make(IP, IPv6len)\n \t\t\t\tcopy(ifa.IP, a.Value[:])\n-\t\t\t\tifat = append(ifat, ifa.toAddr())\n+\t\t\t\tifa.Mask = CIDRMask(pfxlen, 8*IPv6len)\n \t\t\t}\n \t\t}\n \t}\n-\n-\treturn ifat\n+\treturn ifa\n }\n \n // If the ifindex is zero, interfaceMulticastAddrTable returns\n // addresses for all network interfaces.  Otherwise it returns\n // addresses for a specific interface.\n func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \tvar (\n-\t\tifi *Interface\n \t\terr error\n+\t\tifi *Interface\n \t)\n \n \tif ifindex > 0 {"}, {"sha": "4150e9ad5d15dd4c37bfb837bfb3d81595341503", "filename": "libgo/go/net/interface_netbsd.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_netbsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Network interface identification for NetBSD\n+\n+package net\n+\n+// If the ifindex is zero, interfaceMulticastAddrTable returns\n+// addresses for all network interfaces.  Otherwise it returns\n+// addresses for a specific interface.\n+func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n+\treturn nil, nil\n+}"}, {"sha": "4ce01dc906189598ac0be0052760d3f707c568bb", "filename": "libgo/go/net/interface_test.go", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Finterface_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -24,7 +24,7 @@ func sameInterface(i, j *Interface) bool {\n func TestInterfaces(t *testing.T) {\n \tift, err := Interfaces()\n \tif err != nil {\n-\t\tt.Fatalf(\"Interfaces() failed: %v\", err)\n+\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n \t}\n \tt.Logf(\"table: len/cap = %v/%v\\n\", len(ift), cap(ift))\n \n@@ -43,34 +43,57 @@ func TestInterfaces(t *testing.T) {\n \t\tif !sameInterface(ifxn, &ifi) {\n \t\t\tt.Fatalf(\"InterfaceByName(%#q) = %v, want %v\", ifi.Name, *ifxn, ifi)\n \t\t}\n-\t\tifat, err := ifi.Addrs()\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"Interface.Addrs() failed: %v\", err)\n-\t\t}\n-\t\tifmat, err := ifi.MulticastAddrs()\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"Interface.MulticastAddrs() failed: %v\", err)\n-\t\t}\n \t\tt.Logf(\"%q: flags %q, ifindex %v, mtu %v\\n\", ifi.Name, ifi.Flags.String(), ifi.Index, ifi.MTU)\n-\t\tfor _, ifa := range ifat {\n-\t\t\tt.Logf(\"\\tinterface address %q\\n\", ifa.String())\n-\t\t}\n-\t\tfor _, ifma := range ifmat {\n-\t\t\tt.Logf(\"\\tjoined group address %q\\n\", ifma.String())\n-\t\t}\n \t\tt.Logf(\"\\thardware address %q\", ifi.HardwareAddr.String())\n+\t\ttestInterfaceAddrs(t, &ifi)\n+\t\ttestInterfaceMulticastAddrs(t, &ifi)\n \t}\n }\n \n func TestInterfaceAddrs(t *testing.T) {\n \tifat, err := InterfaceAddrs()\n \tif err != nil {\n-\t\tt.Fatalf(\"InterfaceAddrs() failed: %v\", err)\n+\t\tt.Fatalf(\"InterfaceAddrs failed: %v\", err)\n \t}\n \tt.Logf(\"table: len/cap = %v/%v\\n\", len(ifat), cap(ifat))\n+\ttestAddrs(t, ifat)\n+}\n+\n+func testInterfaceAddrs(t *testing.T, ifi *Interface) {\n+\tifat, err := ifi.Addrs()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Interface.Addrs failed: %v\", err)\n+\t}\n+\ttestAddrs(t, ifat)\n+}\n+\n+func testInterfaceMulticastAddrs(t *testing.T, ifi *Interface) {\n+\tifmat, err := ifi.MulticastAddrs()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Interface.MulticastAddrs failed: %v\", err)\n+\t}\n+\ttestMulticastAddrs(t, ifmat)\n+}\n \n+func testAddrs(t *testing.T, ifat []Addr) {\n \tfor _, ifa := range ifat {\n-\t\tt.Logf(\"interface address %q\\n\", ifa.String())\n+\t\tswitch ifa.(type) {\n+\t\tcase *IPAddr, *IPNet:\n+\t\t\tt.Logf(\"\\tinterface address %q\\n\", ifa.String())\n+\t\tdefault:\n+\t\t\tt.Errorf(\"\\tunexpected type: %T\", ifa)\n+\t\t}\n+\t}\n+}\n+\n+func testMulticastAddrs(t *testing.T, ifmat []Addr) {\n+\tfor _, ifma := range ifmat {\n+\t\tswitch ifma.(type) {\n+\t\tcase *IPAddr:\n+\t\t\tt.Logf(\"\\tjoined group address %q\\n\", ifma.String())\n+\t\tdefault:\n+\t\t\tt.Errorf(\"\\tunexpected type: %T\", ifma)\n+\t\t}\n \t}\n }\n "}, {"sha": "979d7acd53d949e7184c6bcf1cbe23f363bcd7b9", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -450,6 +450,9 @@ func (n *IPNet) String() string {\n \treturn nn.String() + \"/\" + itod(uint(l))\n }\n \n+// Network returns the address's network name, \"ip+net\".\n+func (n *IPNet) Network() string { return \"ip+net\" }\n+\n // Parse IPv4 address (d.d.d.d).\n func parseIPv4(s string) IP {\n \tvar p [IPv4len]byte"}, {"sha": "67a4049d5d3ff885ccf1dff89467e0bd4ce295dc", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -59,6 +59,7 @@ func parsePingReply(p []byte) (id, seq int) {\n }\n \n var srchost = flag.String(\"srchost\", \"\", \"Source of the ICMP ECHO request\")\n+\n // 127.0.0.1 because this is an IPv4-specific test.\n var dsthost = flag.String(\"dsthost\", \"127.0.0.1\", \"Destination for the ICMP ECHO request\")\n "}, {"sha": "7bb4c7dc0d3d4d4a8ed86d35afa2f7cb14bb325b", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n // (Raw) IP sockets\n "}, {"sha": "d141c050b23042b4e8ae5611401966fd3e6636a7", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n package net\n "}, {"sha": "5c475477b8380170c18981effe7a2bf0a71ffd9d", "filename": "libgo/go/net/lookup_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package net\n "}, {"sha": "b236dfdb1dd81ae5daa50537485a521da4cf6702", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -157,6 +157,14 @@ func (e *OpError) Timeout() bool {\n \treturn ok && t.Timeout()\n }\n \n+type timeoutError struct{}\n+\n+func (e *timeoutError) Error() string   { return \"i/o timeout\" }\n+func (e *timeoutError) Timeout() bool   { return true }\n+func (e *timeoutError) Temporary() bool { return true }\n+\n+var errTimeout error = &timeoutError{}\n+\n type AddrError struct {\n \tErr  string\n \tAddr string"}, {"sha": "a410bb6ce1f86c3ba435feb5dda0bf7cb9689026", "filename": "libgo/go/net/newpollserver.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package net\n "}, {"sha": "16780da1160cd81dc6065924c364ae0f5adcf589", "filename": "libgo/go/net/port.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fport.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Read system port mappings from /etc/services\n "}, {"sha": "c1845fa50737bb2f2a72321230b60f20fd58334a", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -516,12 +516,10 @@ func benchmarkEndToEnd(dial func() (*Client, error), b *testing.B) {\n \t\t\tfor atomic.AddInt32(&N, -1) >= 0 {\n \t\t\t\terr = client.Call(\"Arith.Add\", args, reply)\n \t\t\t\tif err != nil {\n-\t\t\t\t\tfmt.Printf(\"Add: expected no error but got string %q\", err.Error())\n-\t\t\t\t\tpanic(\"rpc error\")\n+\t\t\t\t\tb.Fatalf(\"rpc error: Add: expected no error but got string %q\", err.Error())\n \t\t\t\t}\n \t\t\t\tif reply.C != args.A+args.B {\n-\t\t\t\t\tfmt.Printf(\"Add: expected %d got %d\", reply.C, args.A+args.B)\n-\t\t\t\t\tpanic(\"rpc error\")\n+\t\t\t\t\tb.Fatalf(\"rpc error: Add: expected %d got %d\", reply.C, args.A+args.B)\n \t\t\t\t}\n \t\t\t}\n \t\t\twg.Done()\n@@ -536,8 +534,7 @@ func benchmarkEndToEndAsync(dial func() (*Client, error), b *testing.B) {\n \tonce.Do(startServer)\n \tclient, err := dial()\n \tif err != nil {\n-\t\tfmt.Println(\"error dialing\", err)\n-\t\treturn\n+\t\tb.Fatalf(\"error dialing:\", err)\n \t}\n \n \t// Asynchronous calls\n@@ -561,12 +558,11 @@ func benchmarkEndToEndAsync(dial func() (*Client, error), b *testing.B) {\n \t\t}()\n \t\tgo func() {\n \t\t\tfor call := range res {\n-\t\t\t\ta := call.Args.(*Args).A\n-\t\t\t\tb := call.Args.(*Args).B\n-\t\t\t\tc := call.Reply.(*Reply).C\n-\t\t\t\tif a+b != c {\n-\t\t\t\t\tfmt.Printf(\"Add: expected %d got %d\", a+b, c)\n-\t\t\t\t\tpanic(\"incorrect reply\")\n+\t\t\t\tA := call.Args.(*Args).A\n+\t\t\t\tB := call.Args.(*Args).B\n+\t\t\t\tC := call.Reply.(*Reply).C\n+\t\t\t\tif A+B != C {\n+\t\t\t\t\tb.Fatalf(\"incorrect reply: Add: expected %d got %d\", A+B, C)\n \t\t\t\t}\n \t\t\t\t<-gate\n \t\t\t\tif atomic.AddInt32(&recv, -1) == 0 {"}, {"sha": "ff76ab9cf0e88f711832299ca67af25614f86a61", "filename": "libgo/go/net/sendfile_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsendfile_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsendfile_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_stub.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n package net\n "}, {"sha": "dc073927eb4211ee5b80d2fb690fb4b966181fe6", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n // Sockets\n "}, {"sha": "816e4fc3f741cfa97d4ab34905dff9f60712d5de", "filename": "libgo/go/net/sock_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n // Sockets for BSD variants\n "}, {"sha": "a7c09c73ed5bd89ac7f49160a4f9a3834dfd545e", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n // TCP sockets\n "}, {"sha": "0460c1c8deeb5557c07524ebed9a39f1ee9e7dd3", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -203,7 +203,7 @@ func TestRFC959Lines(t *testing.T) {\n \t\t\tt.Errorf(\"#%d: code=%d, want %d\", i, code, tt.wantCode)\n \t\t}\n \t\tif msg != tt.wantMsg {\n-\t\t\tt.Errorf(\"%#d: msg=%q, want %q\", i, msg, tt.wantMsg)\n+\t\t\tt.Errorf(\"#%d: msg=%q, want %q\", i, msg, tt.wantMsg)\n \t\t}\n \t}\n }"}, {"sha": "6bb15714e2b0efdc5f0ef224c4875140c4838d34", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n // UDP sockets\n "}, {"sha": "10632c1412e16558bebd92fad91b2580a307e06e", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n // Unix domain sockets\n "}, {"sha": "180dac4d455db6ff0decf8c5df9de52f23c0daf9", "filename": "libgo/go/old/regexp/all_test.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -321,8 +321,7 @@ func BenchmarkLiteral(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatal(\"no match!\")\n \t\t}\n \t}\n }\n@@ -334,8 +333,7 @@ func BenchmarkNotLiteral(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatal(\"no match!\")\n \t\t}\n \t}\n }\n@@ -347,8 +345,7 @@ func BenchmarkMatchClass(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatal(\"no match!\")\n \t\t}\n \t}\n }\n@@ -362,8 +359,7 @@ func BenchmarkMatchClass_InRange(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatal(\"no match!\")\n \t\t}\n \t}\n }"}, {"sha": "f42a61a1b13be5fdc51c111e8556a8d6c8d09719", "filename": "libgo/go/old/template/template_test.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -463,23 +464,32 @@ func TestAll(t *testing.T) {\n \t// Parse\n \ttestAll(t, func(test *Test) (*Template, error) { return Parse(test.in, formatters) })\n \t// ParseFile\n+\tf, err := ioutil.TempFile(\"\", \"template-test\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer func() {\n+\t\tname := f.Name()\n+\t\tf.Close()\n+\t\tos.Remove(name)\n+\t}()\n \ttestAll(t, func(test *Test) (*Template, error) {\n-\t\terr := ioutil.WriteFile(\"_test/test.tmpl\", []byte(test.in), 0600)\n+\t\terr := ioutil.WriteFile(f.Name(), []byte(test.in), 0600)\n \t\tif err != nil {\n \t\t\tt.Error(\"unexpected write error:\", err)\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn ParseFile(\"_test/test.tmpl\", formatters)\n+\t\treturn ParseFile(f.Name(), formatters)\n \t})\n \t// tmpl.ParseFile\n \ttestAll(t, func(test *Test) (*Template, error) {\n-\t\terr := ioutil.WriteFile(\"_test/test.tmpl\", []byte(test.in), 0600)\n+\t\terr := ioutil.WriteFile(f.Name(), []byte(test.in), 0600)\n \t\tif err != nil {\n \t\t\tt.Error(\"unexpected write error:\", err)\n \t\t\treturn nil, err\n \t\t}\n \t\ttmpl := New(formatters)\n-\t\treturn tmpl, tmpl.ParseFile(\"_test/test.tmpl\")\n+\t\treturn tmpl, tmpl.ParseFile(f.Name())\n \t})\n }\n "}, {"sha": "e7a29554c15af5a2fd6597922ad80dc09791a1da", "filename": "libgo/go/os/dir_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fdir_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fdir_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package os\n "}, {"sha": "ebbe4369703328d92f313754c5e54b715f0bad1b", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n package os\n "}, {"sha": "a00fdad497faa94a336242014ad6d29a9f51e22b", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -67,6 +67,9 @@ type Cmd struct {\n \t// ExtraFiles specifies additional open files to be inherited by the\n \t// new process. It does not include standard input, standard output, or\n \t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n+\t//\n+\t// BUG: on OS X 10.6, child processes may sometimes inherit extra fds.\n+\t// http://golang.org/issue/2603\n \tExtraFiles []*os.File\n \n \t// SysProcAttr holds optional, operating system-specific attributes."}, {"sha": "c68498047faa6ff159c85edaf06ac74b28ad6154", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -10,6 +10,9 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n \t\"os\"\n \t\"runtime\"\n \t\"strconv\"\n@@ -18,7 +21,7 @@ import (\n )\n \n func helperCommand(s ...string) *Cmd {\n-\tcs := []string{\"-test.run=exec.TestHelperProcess\", \"--\"}\n+\tcs := []string{\"-test.run=TestHelperProcess\", \"--\"}\n \tcs = append(cs, s...)\n \tcmd := Command(os.Args[0], cs...)\n \tcmd.Env = append([]string{\"GO_WANT_HELPER_PROCESS=1\"}, os.Environ()...)\n@@ -146,6 +149,23 @@ func TestExtraFiles(t *testing.T) {\n \t\tt.Logf(\"no operating system support; skipping\")\n \t\treturn\n \t}\n+\n+\t// Force network usage, to verify the epoll (or whatever) fd\n+\t// doesn't leak to the child,\n+\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer ln.Close()\n+\n+\t// Force TLS root certs to be loaded (which might involve\n+\t// cgo), to make sure none of that potential C code leaks fds.\n+\tts := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Write([]byte(\"Hello\"))\n+\t}))\n+\tdefer ts.Close()\n+\thttp.Get(ts.URL) // ignore result; just calling to force root cert loading\n+\n \ttf, err := ioutil.TempFile(\"\", \"\")\n \tif err != nil {\n \t\tt.Fatalf(\"TempFile: %v\", err)\n@@ -167,7 +187,7 @@ func TestExtraFiles(t *testing.T) {\n \tc.ExtraFiles = []*os.File{tf}\n \tbs, err := c.CombinedOutput()\n \tif err != nil {\n-\t\tt.Fatalf(\"CombinedOutput: %v\", err)\n+\t\tt.Fatalf(\"CombinedOutput: %v; output %q\", err, bs)\n \t}\n \tif string(bs) != text {\n \t\tt.Errorf(\"got %q; want %q\", string(bs), text)\n@@ -246,6 +266,32 @@ func TestHelperProcess(*testing.T) {\n \t\t\tfmt.Printf(\"ReadAll from fd 3: %v\", err)\n \t\t\tos.Exit(1)\n \t\t}\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"darwin\":\n+\t\t\t// TODO(bradfitz): broken? Sometimes.\n+\t\t\t// http://golang.org/issue/2603\n+\t\t\t// Skip this additional part of the test for now.\n+\t\tdefault:\n+\t\t\t// Now verify that there are no other open fds.\n+\t\t\tvar files []*os.File\n+\t\t\tfor wantfd := os.Stderr.Fd() + 2; wantfd <= 100; wantfd++ {\n+\t\t\t\tf, err := os.Open(os.Args[0])\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfmt.Printf(\"error opening file with expected fd %d: %v\", wantfd, err)\n+\t\t\t\t\tos.Exit(1)\n+\t\t\t\t}\n+\t\t\t\tif got := f.Fd(); got != wantfd {\n+\t\t\t\t\tfmt.Printf(\"leaked parent file. fd = %d; want %d\\n\", got, wantfd)\n+\t\t\t\t\tout, _ := Command(\"lsof\", \"-p\", fmt.Sprint(os.Getpid())).CombinedOutput()\n+\t\t\t\t\tfmt.Print(string(out))\n+\t\t\t\t\tos.Exit(1)\n+\t\t\t\t}\n+\t\t\t\tfiles = append(files, f)\n+\t\t\t}\n+\t\t\tfor _, f := range files {\n+\t\t\t\tf.Close()\n+\t\t\t}\n+\t\t}\n \t\tos.Stderr.Write(bs)\n \tcase \"exit\":\n \t\tn, _ := strconv.Atoi(args[0])"}, {"sha": "a221137230db379b04bab33eb6620c4e281e519b", "filename": "libgo/go/os/exec/lp_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package exec\n "}, {"sha": "218b8cdc1d68593602671e13e22c9c6e63c2f7fb", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n package os\n \n@@ -24,7 +24,7 @@ func (sig UnixSignal) String() string {\n // StartProcess starts a new process with the program, arguments and attributes\n // specified by name, argv and attr.\n //\n-// StartProcess is a low-level interface. The exec package provides\n+// StartProcess is a low-level interface. The os/exec package provides\n // higher-level interfaces.\n func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n \tsysattr := &syscall.ProcAttr{\n@@ -56,7 +56,7 @@ func (p *Process) Kill() error {\n // If successful, Exec never returns.  If it fails, it returns an error.\n //\n // To run a child process, see StartProcess (for a low-level interface)\n-// or the exec package (for higher-level interfaces).\n+// or the os/exec package (for higher-level interfaces).\n func Exec(name string, argv []string, envv []string) error {\n \tif envv == nil {\n \t\tenvv = Environ()"}, {"sha": "375813895d97d472fad7871a91c0a6ffdb7c457e", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package os\n "}, {"sha": "8231ef4817c96ee5ccd4edccacc184ce34700ebd", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd windows\n+// +build darwin freebsd linux netbsd openbsd windows\n \n package os\n \n@@ -24,39 +24,6 @@ func epipecheck(file *File, e error) {\n \t}\n }\n \n-// Remove removes the named file or directory.\n-func Remove(name string) error {\n-\t// System call interface forces us to know\n-\t// whether name is a file or directory.\n-\t// Try both: it is cheaper on average than\n-\t// doing a Stat plus the right one.\n-\te := syscall.Unlink(name)\n-\tif e == nil {\n-\t\treturn nil\n-\t}\n-\te1 := syscall.Rmdir(name)\n-\tif e1 == nil {\n-\t\treturn nil\n-\t}\n-\n-\t// Both failed: figure out which error to return.\n-\t// OS X and Linux differ on whether unlink(dir)\n-\t// returns EISDIR, so can't use that.  However,\n-\t// both agree that rmdir(file) returns ENOTDIR,\n-\t// so we can use that to decide which error is real.\n-\t// Rmdir might also return ENOTDIR if given a bad\n-\t// file path, like /etc/passwd/foo, but in that case,\n-\t// both errors will be ENOTDIR, so it's okay to\n-\t// use the error from unlink.\n-\t// For windows syscall.ENOTDIR is set\n-\t// to syscall.ERROR_PATH_NOT_FOUND, hopefully it should\n-\t// do the trick.\n-\tif e1 != syscall.ENOTDIR {\n-\t\te = e1\n-\t}\n-\treturn &PathError{\"remove\", name, e}\n-}\n-\n // LinkError records an error during a link or symlink or rename\n // system call and the paths that caused it.\n type LinkError struct {"}, {"sha": "069baa14d4e19fb16f92b08a8c5b6f652b427617", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package os\n \n@@ -67,8 +67,13 @@ func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n \t}\n \n \t// There's a race here with fork/exec, which we are\n-\t// content to live with.  See ../syscall/exec.go\n-\tif syscall.O_CLOEXEC == 0 { // O_CLOEXEC not supported\n+\t// content to live with.  See ../syscall/exec_unix.go.\n+\t// On OS X 10.6, the O_CLOEXEC flag is not respected.\n+\t// On OS X 10.7, the O_CLOEXEC flag works.\n+\t// Without a cheap & reliable way to detect 10.6 vs 10.7 at\n+\t// runtime, we just always call syscall.CloseOnExec on Darwin.\n+\t// Once >=10.7 is prevalent, this extra call can removed.\n+\tif syscall.O_CLOEXEC == 0 || runtime.GOOS == \"darwin\" { // O_CLOEXEC not supported\n \t\tsyscall.CloseOnExec(r)\n \t}\n \n@@ -216,6 +221,36 @@ func Truncate(name string, size int64) error {\n \treturn nil\n }\n \n+// Remove removes the named file or directory.\n+func Remove(name string) error {\n+\t// System call interface forces us to know\n+\t// whether name is a file or directory.\n+\t// Try both: it is cheaper on average than\n+\t// doing a Stat plus the right one.\n+\te := syscall.Unlink(name)\n+\tif e == nil {\n+\t\treturn nil\n+\t}\n+\te1 := syscall.Rmdir(name)\n+\tif e1 == nil {\n+\t\treturn nil\n+\t}\n+\n+\t// Both failed: figure out which error to return.\n+\t// OS X and Linux differ on whether unlink(dir)\n+\t// returns EISDIR, so can't use that.  However,\n+\t// both agree that rmdir(file) returns ENOTDIR,\n+\t// so we can use that to decide which error is real.\n+\t// Rmdir might also return ENOTDIR if given a bad\n+\t// file path, like /etc/passwd/foo, but in that case,\n+\t// both errors will be ENOTDIR, so it's okay to\n+\t// use the error from unlink.\n+\tif e1 != syscall.ENOTDIR {\n+\t\te = e1\n+\t}\n+\treturn &PathError{\"remove\", name, e}\n+}\n+\n // basename removes trailing slashes and the leading directory name from path name\n func basename(name string) string {\n \ti := len(name) - 1"}, {"sha": "9a6099080341e4e874fda6c2941fb186abb1f8bd", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -917,7 +917,7 @@ func TestReadAt(t *testing.T) {\n \tb := make([]byte, 5)\n \tn, err := f.ReadAt(b, 7)\n \tif err != nil || n != len(b) {\n-\t\tt.Fatalf(\"ReadAt 7: %d, %r\", n, err)\n+\t\tt.Fatalf(\"ReadAt 7: %d, %v\", n, err)\n \t}\n \tif string(b) != \"world\" {\n \t\tt.Fatalf(\"ReadAt 7: have %q want %q\", string(b), \"world\")"}, {"sha": "1f800d78ccaee956ec3ece4b5338b18d67db17b0", "filename": "libgo/go/os/os_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fos_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fos_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_unix_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package os_test\n "}, {"sha": "30a167b1adc0b3e4761f784b220fc013cdb61dcf", "filename": "libgo/go/os/path_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package os\n "}, {"sha": "bce4530e7bc73c2a05fc65f83f9ea4c5ba079551", "filename": "libgo/go/os/signal/signal.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux netbsd openbsd\n+\n // Package signal implements operating system-independent signal handling.\n package signal\n \n@@ -31,3 +33,5 @@ func init() {\n \tIncoming = ch\n \tgo process(ch)\n }\n+\n+// BUG(rsc): This package is unavailable on Plan 9 and Windows."}, {"sha": "4568aa9518e7b538fbf569ca92c1664eaec3d652", "filename": "libgo/go/os/signal/signal_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux netbsd openbsd\n+\n package signal\n \n import ("}, {"sha": "d196469e7d48d00c1d0e4390028a8109a23997f4", "filename": "libgo/go/os/sys_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsys_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fsys_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_bsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n // os code shared between *BSD systems including OS X (Darwin)\n // and FreeBSD."}, {"sha": "42fa557445f2c21476995473d75b8006352de080", "filename": "libgo/go/os/user/lookup_stubs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build openbsd plan9 windows\n+// +build nocgo windows\n \n package user\n "}, {"sha": "602a3da2cd4ec72a63c475dd36658e2757dbf693", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -3,6 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // +build darwin freebsd linux\n+// +build cgo\n \n package user\n "}, {"sha": "3dc52aab4672873a6ab1a00b1d7f66b4174bdd5c", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -147,6 +147,7 @@ func SplitList(path string) []string {\n // separating it into a directory and file name component.\n // If there is no Separator in path, Split returns an empty dir\n // and file set to path.\n+// The returned values have the property that path = dir+file.\n func Split(path string) (dir, file string) {\n \tvol := VolumeName(path)\n \ti := len(path) - 1\n@@ -262,6 +263,8 @@ func Abs(path string) (string, error) {\n // Rel returns a relative path that is lexically equivalent to targpath when\n // joined to basepath with an intervening separator. That is,\n // Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\n+// On success, the returned path will always be relative to basepath,\n+// even if basepath and targpath share no elements.\n // An error is returned if targpath can't be made relative to basepath or if\n // knowing the current working directory would be necessary to compute it.\n func Rel(basepath, targpath string) (string, error) {\n@@ -423,6 +426,8 @@ func Base(path string) string {\n \tfor len(path) > 0 && os.IsPathSeparator(path[len(path)-1]) {\n \t\tpath = path[0 : len(path)-1]\n \t}\n+\t// Throw away volume name\n+\tpath = path[len(VolumeName(path)):]\n \t// Find the last element\n \ti := len(path) - 1\n \tfor i >= 0 && !os.IsPathSeparator(path[i]) {\n@@ -437,3 +442,25 @@ func Base(path string) string {\n \t}\n \treturn path\n }\n+\n+// Dir returns the all but the last element of path, typically the path's directory.\n+// Trailing path separators are removed before processing.\n+// If the path is empty, Dir returns \".\".\n+// If the path consists entirely of separators, Dir returns a single separator.\n+// The returned path does not end in a separator unless it is the root directory.\n+func Dir(path string) string {\n+\tvol := VolumeName(path)\n+\ti := len(path) - 1\n+\tfor i >= len(vol) && !os.IsPathSeparator(path[i]) {\n+\t\ti--\n+\t}\n+\tdir := Clean(path[len(vol) : i+1])\n+\tlast := len(dir) - 1\n+\tif last > 0 && os.IsPathSeparator(dir[last]) {\n+\t\tdir = dir[:last]\n+\t}\n+\tif dir == \"\" {\n+\t\tdir = \".\"\n+\t}\n+\treturn vol + dir\n+}"}, {"sha": "63adcb88c46a94d98606b90a7bfb0855cc77cb3b", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -422,14 +422,77 @@ var basetests = []PathTest{\n \t{\"a/b/c.x\", \"c.x\"},\n }\n \n+var winbasetests = []PathTest{\n+\t{`c:\\`, `\\`},\n+\t{`c:.`, `.`},\n+\t{`c:\\a\\b`, `b`},\n+\t{`c:a\\b`, `b`},\n+\t{`c:a\\b\\c`, `c`},\n+\t{`\\\\host\\share\\`, `\\`},\n+\t{`\\\\host\\share\\a`, `a`},\n+\t{`\\\\host\\share\\a\\b`, `b`},\n+}\n+\n func TestBase(t *testing.T) {\n-\tfor _, test := range basetests {\n-\t\tif s := filepath.ToSlash(filepath.Base(test.path)); s != test.result {\n+\ttests := basetests\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// make unix tests work on windows\n+\t\tfor i, _ := range tests {\n+\t\t\ttests[i].result = filepath.Clean(tests[i].result)\n+\t\t}\n+\t\t// add windows specific tests\n+\t\ttests = append(tests, winbasetests...)\n+\t}\n+\tfor _, test := range tests {\n+\t\tif s := filepath.Base(test.path); s != test.result {\n \t\t\tt.Errorf(\"Base(%q) = %q, want %q\", test.path, s, test.result)\n \t\t}\n \t}\n }\n \n+var dirtests = []PathTest{\n+\t{\"\", \".\"},\n+\t{\".\", \".\"},\n+\t{\"/.\", \"/\"},\n+\t{\"/\", \"/\"},\n+\t{\"////\", \"/\"},\n+\t{\"/foo\", \"/\"},\n+\t{\"x/\", \"x\"},\n+\t{\"abc\", \".\"},\n+\t{\"abc/def\", \"abc\"},\n+\t{\"a/b/.x\", \"a/b\"},\n+\t{\"a/b/c.\", \"a/b\"},\n+\t{\"a/b/c.x\", \"a/b\"},\n+}\n+\n+var windirtests = []PathTest{\n+\t{`c:\\`, `c:\\`},\n+\t{`c:.`, `c:.`},\n+\t{`c:\\a\\b`, `c:\\a`},\n+\t{`c:a\\b`, `c:a`},\n+\t{`c:a\\b\\c`, `c:a\\b`},\n+\t{`\\\\host\\share\\`, `\\\\host\\share\\`},\n+\t{`\\\\host\\share\\a`, `\\\\host\\share\\`},\n+\t{`\\\\host\\share\\a\\b`, `\\\\host\\share\\a`},\n+}\n+\n+func TestDir(t *testing.T) {\n+\ttests := dirtests\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// make unix tests work on windows\n+\t\tfor i, _ := range tests {\n+\t\t\ttests[i].result = filepath.Clean(tests[i].result)\n+\t\t}\n+\t\t// add windows specific tests\n+\t\ttests = append(tests, windirtests...)\n+\t}\n+\tfor _, test := range tests {\n+\t\tif s := filepath.Dir(test.path); s != test.result {\n+\t\t\tt.Errorf(\"Dir(%q) = %q, want %q\", test.path, s, test.result)\n+\t\t}\n+\t}\n+}\n+\n type IsAbsTest struct {\n \tpath  string\n \tisAbs bool"}, {"sha": "c5ac71efe218f28117543436082e636140ed22e4", "filename": "libgo/go/path/filepath/path_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package filepath\n "}, {"sha": "20d89c9ff0cbcbee125e1c88ffa198cc67563ef5", "filename": "libgo/go/path/path.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -160,3 +160,21 @@ func Base(path string) string {\n func IsAbs(path string) bool {\n \treturn len(path) > 0 && path[0] == '/'\n }\n+\n+// Dir returns the all but the last element of path, typically the path's directory.\n+// Trailing path separators are removed before processing.\n+// If the path is empty, Dir returns \".\".\n+// If the path consists entirely of separators, Dir returns a single separator.\n+// The returned path does not end in a separator unless it is the root directory.\n+func Dir(path string) string {\n+\tdir, _ := Split(path)\n+\tdir = Clean(dir)\n+\tlast := len(dir) - 1\n+\tif last > 0 && dir[last] == '/' {\n+\t\tdir = dir[:last]\n+\t}\n+\tif dir == \"\" {\n+\t\tdir = \".\"\n+\t}\n+\treturn dir\n+}"}, {"sha": "77f080433b667719f103ec09f9f57656b4d4c907", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -8,11 +8,11 @@ import (\n \t\"testing\"\n )\n \n-type CleanTest struct {\n-\tpath, clean string\n+type PathTest struct {\n+\tpath, result string\n }\n \n-var cleantests = []CleanTest{\n+var cleantests = []PathTest{\n \t// Already clean\n \t{\"\", \".\"},\n \t{\"abc\", \"abc\"},\n@@ -64,8 +64,8 @@ var cleantests = []CleanTest{\n \n func TestClean(t *testing.T) {\n \tfor _, test := range cleantests {\n-\t\tif s := Clean(test.path); s != test.clean {\n-\t\t\tt.Errorf(\"Clean(%q) = %q, want %q\", test.path, s, test.clean)\n+\t\tif s := Clean(test.path); s != test.result {\n+\t\t\tt.Errorf(\"Clean(%q) = %q, want %q\", test.path, s, test.result)\n \t\t}\n \t}\n }\n@@ -148,7 +148,7 @@ func TestExt(t *testing.T) {\n \t}\n }\n \n-var basetests = []CleanTest{\n+var basetests = []PathTest{\n \t// Already clean\n \t{\"\", \".\"},\n \t{\".\", \".\"},\n@@ -165,8 +165,31 @@ var basetests = []CleanTest{\n \n func TestBase(t *testing.T) {\n \tfor _, test := range basetests {\n-\t\tif s := Base(test.path); s != test.clean {\n-\t\t\tt.Errorf(\"Base(%q) = %q, want %q\", test.path, s, test.clean)\n+\t\tif s := Base(test.path); s != test.result {\n+\t\t\tt.Errorf(\"Base(%q) = %q, want %q\", test.path, s, test.result)\n+\t\t}\n+\t}\n+}\n+\n+var dirtests = []PathTest{\n+\t{\"\", \".\"},\n+\t{\".\", \".\"},\n+\t{\"/.\", \"/\"},\n+\t{\"/\", \"/\"},\n+\t{\"////\", \"/\"},\n+\t{\"/foo\", \"/\"},\n+\t{\"x/\", \"x\"},\n+\t{\"abc\", \".\"},\n+\t{\"abc/def\", \"abc\"},\n+\t{\"a/b/.x\", \"a/b\"},\n+\t{\"a/b/c.\", \"a/b\"},\n+\t{\"a/b/c.x\", \"a/b\"},\n+}\n+\n+func TestDir(t *testing.T) {\n+\tfor _, test := range dirtests {\n+\t\tif s := Dir(test.path); s != test.result {\n+\t\t\tt.Errorf(\"Dir(%q) = %q, want %q\", test.path, s, test.result)\n \t\t}\n \t}\n }"}, {"sha": "e729510b5134da56ca57dd188ca648cea92e34bd", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -324,8 +324,7 @@ func BenchmarkLiteral(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatalf(\"no match!\")\n \t\t}\n \t}\n }\n@@ -337,8 +336,7 @@ func BenchmarkNotLiteral(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatalf(\"no match!\")\n \t\t}\n \t}\n }\n@@ -350,8 +348,7 @@ func BenchmarkMatchClass(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatalf(\"no match!\")\n \t\t}\n \t}\n }\n@@ -365,8 +362,7 @@ func BenchmarkMatchClass_InRange(b *testing.B) {\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tif !re.MatchString(x) {\n-\t\t\tprintln(\"no match!\")\n-\t\t\tbreak\n+\t\t\tb.Fatalf(\"no match!\")\n \t\t}\n \t}\n }"}, {"sha": "e668574a514389377c9baf2e95cc204799b91c46", "filename": "libgo/go/regexp/exec_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fregexp%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fregexp%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -673,7 +673,7 @@ func benchmark(b *testing.B, re string, n int) {\n \tb.SetBytes(int64(n))\n \tfor i := 0; i < b.N; i++ {\n \t\tif r.Match(t) {\n-\t\t\tpanic(\"match!\")\n+\t\t\tb.Fatal(\"match!\")\n \t\t}\n \t}\n }"}, {"sha": "4aa4ca6d7da78e25bdec3b83f1a4695b487d8dfc", "filename": "libgo/go/sort/sort.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsort%2Fsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsort%2Fsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fsort.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -240,14 +240,18 @@ func (p StringSlice) Sort() { Sort(p) }\n \n // Ints sorts a slice of ints in increasing order.\n func Ints(a []int) { Sort(IntSlice(a)) }\n+\n // Float64s sorts a slice of float64s in increasing order.\n func Float64s(a []float64) { Sort(Float64Slice(a)) }\n+\n // Strings sorts a slice of strings in increasing order.\n func Strings(a []string) { Sort(StringSlice(a)) }\n \n // IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n func IntsAreSorted(a []int) bool { return IsSorted(IntSlice(a)) }\n+\n // Float64sAreSorted tests whether a slice of float64s is sorted in increasing order.\n func Float64sAreSorted(a []float64) bool { return IsSorted(Float64Slice(a)) }\n+\n // StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n func StringsAreSorted(a []string) bool { return IsSorted(StringSlice(a)) }"}, {"sha": "42fc431db8a7cf153d1b02d2633dc9f6aaa8b2e9", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -263,6 +263,18 @@ func (d *decimal) atof32int() float32 {\n \treturn f\n }\n \n+// Reads a uint64 decimal mantissa, which might be truncated.\n+func (d *decimal) atou64() (mant uint64, digits int) {\n+\tconst uint64digits = 19\n+\tfor i, c := range d.d[:d.nd] {\n+\t\tif i == uint64digits {\n+\t\t\treturn mant, i\n+\t\t}\n+\t\tmant = 10*mant + uint64(c-'0')\n+\t}\n+\treturn mant, d.nd\n+}\n+\n // Exact powers of 10.\n var float64pow10 = []float64{\n \t1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n@@ -375,6 +387,17 @@ func atof64(s string) (f float64, err error) {\n \t\tif f, ok := d.atof64(); ok {\n \t\t\treturn f, nil\n \t\t}\n+\n+\t\t// Try another fast path.\n+\t\text := new(extFloat)\n+\t\tif ok := ext.AssignDecimal(&d); ok {\n+\t\t\tb, ovf := ext.floatBits()\n+\t\t\tf = math.Float64frombits(b)\n+\t\t\tif ovf {\n+\t\t\t\terr = rangeError(fnParseFloat, s)\n+\t\t\t}\n+\t\t\treturn f, err\n+\t\t}\n \t}\n \tb, ovf := d.floatBits(&float64info)\n \tf = math.Float64frombits(b)"}, {"sha": "3fa637d2bc6b42a261f99fb2891a94d7cefdd83c", "filename": "libgo/go/strconv/atof_test.go", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -5,9 +5,12 @@\n package strconv_test\n \n import (\n+\t\"math\"\n+\t\"math/rand\"\n \t\"reflect\"\n \t. \"strconv\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type atofTest struct {\n@@ -111,8 +114,22 @@ var atoftests = []atofTest{\n \t{\"2.2250738585072012e-308\", \"2.2250738585072014e-308\", nil},\n \t// http://www.exploringbinary.com/php-hangs-on-numeric-value-2-2250738585072011e-308/\n \t{\"2.2250738585072011e-308\", \"2.225073858507201e-308\", nil},\n+\n+\t// A very large number (initially wrongly parsed by the fast algorithm).\n+\t{\"4.630813248087435e+307\", \"4.630813248087435e+307\", nil},\n+}\n+\n+type atofSimpleTest struct {\n+\tx float64\n+\ts string\n }\n \n+var (\n+\tatofRandomTests        []atofSimpleTest\n+\tbenchmarksRandomBits   [1024]string\n+\tbenchmarksRandomNormal [1024]string\n+)\n+\n func init() {\n \t// The atof routines return NumErrors wrapping\n \t// the error and the string.  Convert the table above.\n@@ -122,6 +139,31 @@ func init() {\n \t\t\ttest.err = &NumError{\"ParseFloat\", test.in, test.err}\n \t\t}\n \t}\n+\n+\t// Generate random inputs for tests and benchmarks\n+\trand.Seed(time.Now().UnixNano())\n+\tif testing.Short() {\n+\t\tatofRandomTests = make([]atofSimpleTest, 100)\n+\t} else {\n+\t\tatofRandomTests = make([]atofSimpleTest, 10000)\n+\t}\n+\tfor i := range atofRandomTests {\n+\t\tn := uint64(rand.Uint32())<<32 | uint64(rand.Uint32())\n+\t\tx := math.Float64frombits(n)\n+\t\ts := FormatFloat(x, 'g', -1, 64)\n+\t\tatofRandomTests[i] = atofSimpleTest{x, s}\n+\t}\n+\n+\tfor i := range benchmarksRandomBits {\n+\t\tbits := uint64(rand.Uint32())<<32 | uint64(rand.Uint32())\n+\t\tx := math.Float64frombits(bits)\n+\t\tbenchmarksRandomBits[i] = FormatFloat(x, 'g', -1, 64)\n+\t}\n+\n+\tfor i := range benchmarksRandomNormal {\n+\t\tx := rand.NormFloat64()\n+\t\tbenchmarksRandomNormal[i] = FormatFloat(x, 'g', -1, 64)\n+\t}\n }\n \n func testAtof(t *testing.T, opt bool) {\n@@ -156,6 +198,19 @@ func TestAtof(t *testing.T) { testAtof(t, true) }\n \n func TestAtofSlow(t *testing.T) { testAtof(t, false) }\n \n+func TestAtofRandom(t *testing.T) {\n+\tfor _, test := range atofRandomTests {\n+\t\tx, _ := ParseFloat(test.s, 64)\n+\t\tswitch {\n+\t\tdefault:\n+\t\t\tt.Errorf(\"number %s badly parsed as %b (expected %b)\", test.s, x, test.x)\n+\t\tcase x == test.x:\n+\t\tcase math.IsNaN(test.x) && math.IsNaN(x):\n+\t\t}\n+\t}\n+\tt.Logf(\"tested %d random numbers\", len(atofRandomTests))\n+}\n+\n func BenchmarkAtof64Decimal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tParseFloat(\"33909\", 64)\n@@ -179,3 +234,15 @@ func BenchmarkAtof64Big(b *testing.B) {\n \t\tParseFloat(\"123456789123456789123456789\", 64)\n \t}\n }\n+\n+func BenchmarkAtof64RandomBits(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tParseFloat(benchmarksRandomBits[i%1024], 64)\n+\t}\n+}\n+\n+func BenchmarkAtof64RandomFloats(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tParseFloat(benchmarksRandomNormal[i%1024], 64)\n+\t}\n+}"}, {"sha": "cc5591a8d8f19a3d629cdbee9097af526c916d59", "filename": "libgo/go/strconv/decimal.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fdecimal.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -14,9 +14,9 @@ package strconv\n type decimal struct {\n \t// TODO(rsc): Can make d[] a bit smaller and add\n \t// truncated bool;\n-\td   [2000]byte // digits\n-\tnd  int        // number of digits used\n-\tdp  int        // decimal point\n+\td   [800]byte // digits\n+\tnd  int       // number of digits used\n+\tdp  int       // decimal point\n \tneg bool\n }\n "}, {"sha": "980052a778bc45813c807a2b7719f51673e4cfce", "filename": "libgo/go/strconv/extfloat.go", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fextfloat.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,311 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package strconv\n+\n+import \"math\"\n+\n+// An extFloat represents an extended floating-point number, with more\n+// precision than a float64. It does not try to save bits: the\n+// number represented by the structure is mant*(2^exp), with a negative\n+// sign if neg is true.\n+type extFloat struct {\n+\tmant uint64\n+\texp  int\n+\tneg  bool\n+}\n+\n+// Powers of ten taken from double-conversion library.\n+// http://code.google.com/p/double-conversion/\n+const (\n+\tfirstPowerOfTen = -348\n+\tstepPowerOfTen  = 8\n+)\n+\n+var smallPowersOfTen = [...]extFloat{\n+\t{1 << 63, -63, false},        // 1\n+\t{0xa << 60, -60, false},      // 1e1\n+\t{0x64 << 57, -57, false},     // 1e2\n+\t{0x3e8 << 54, -54, false},    // 1e3\n+\t{0x2710 << 50, -50, false},   // 1e4\n+\t{0x186a0 << 47, -47, false},  // 1e5\n+\t{0xf4240 << 44, -44, false},  // 1e6\n+\t{0x989680 << 40, -40, false}, // 1e7\n+}\n+\n+var powersOfTen = [...]extFloat{\n+\t{0xfa8fd5a0081c0288, -1220, false}, // 10^-348\n+\t{0xbaaee17fa23ebf76, -1193, false}, // 10^-340\n+\t{0x8b16fb203055ac76, -1166, false}, // 10^-332\n+\t{0xcf42894a5dce35ea, -1140, false}, // 10^-324\n+\t{0x9a6bb0aa55653b2d, -1113, false}, // 10^-316\n+\t{0xe61acf033d1a45df, -1087, false}, // 10^-308\n+\t{0xab70fe17c79ac6ca, -1060, false}, // 10^-300\n+\t{0xff77b1fcbebcdc4f, -1034, false}, // 10^-292\n+\t{0xbe5691ef416bd60c, -1007, false}, // 10^-284\n+\t{0x8dd01fad907ffc3c, -980, false},  // 10^-276\n+\t{0xd3515c2831559a83, -954, false},  // 10^-268\n+\t{0x9d71ac8fada6c9b5, -927, false},  // 10^-260\n+\t{0xea9c227723ee8bcb, -901, false},  // 10^-252\n+\t{0xaecc49914078536d, -874, false},  // 10^-244\n+\t{0x823c12795db6ce57, -847, false},  // 10^-236\n+\t{0xc21094364dfb5637, -821, false},  // 10^-228\n+\t{0x9096ea6f3848984f, -794, false},  // 10^-220\n+\t{0xd77485cb25823ac7, -768, false},  // 10^-212\n+\t{0xa086cfcd97bf97f4, -741, false},  // 10^-204\n+\t{0xef340a98172aace5, -715, false},  // 10^-196\n+\t{0xb23867fb2a35b28e, -688, false},  // 10^-188\n+\t{0x84c8d4dfd2c63f3b, -661, false},  // 10^-180\n+\t{0xc5dd44271ad3cdba, -635, false},  // 10^-172\n+\t{0x936b9fcebb25c996, -608, false},  // 10^-164\n+\t{0xdbac6c247d62a584, -582, false},  // 10^-156\n+\t{0xa3ab66580d5fdaf6, -555, false},  // 10^-148\n+\t{0xf3e2f893dec3f126, -529, false},  // 10^-140\n+\t{0xb5b5ada8aaff80b8, -502, false},  // 10^-132\n+\t{0x87625f056c7c4a8b, -475, false},  // 10^-124\n+\t{0xc9bcff6034c13053, -449, false},  // 10^-116\n+\t{0x964e858c91ba2655, -422, false},  // 10^-108\n+\t{0xdff9772470297ebd, -396, false},  // 10^-100\n+\t{0xa6dfbd9fb8e5b88f, -369, false},  // 10^-92\n+\t{0xf8a95fcf88747d94, -343, false},  // 10^-84\n+\t{0xb94470938fa89bcf, -316, false},  // 10^-76\n+\t{0x8a08f0f8bf0f156b, -289, false},  // 10^-68\n+\t{0xcdb02555653131b6, -263, false},  // 10^-60\n+\t{0x993fe2c6d07b7fac, -236, false},  // 10^-52\n+\t{0xe45c10c42a2b3b06, -210, false},  // 10^-44\n+\t{0xaa242499697392d3, -183, false},  // 10^-36\n+\t{0xfd87b5f28300ca0e, -157, false},  // 10^-28\n+\t{0xbce5086492111aeb, -130, false},  // 10^-20\n+\t{0x8cbccc096f5088cc, -103, false},  // 10^-12\n+\t{0xd1b71758e219652c, -77, false},   // 10^-4\n+\t{0x9c40000000000000, -50, false},   // 10^4\n+\t{0xe8d4a51000000000, -24, false},   // 10^12\n+\t{0xad78ebc5ac620000, 3, false},     // 10^20\n+\t{0x813f3978f8940984, 30, false},    // 10^28\n+\t{0xc097ce7bc90715b3, 56, false},    // 10^36\n+\t{0x8f7e32ce7bea5c70, 83, false},    // 10^44\n+\t{0xd5d238a4abe98068, 109, false},   // 10^52\n+\t{0x9f4f2726179a2245, 136, false},   // 10^60\n+\t{0xed63a231d4c4fb27, 162, false},   // 10^68\n+\t{0xb0de65388cc8ada8, 189, false},   // 10^76\n+\t{0x83c7088e1aab65db, 216, false},   // 10^84\n+\t{0xc45d1df942711d9a, 242, false},   // 10^92\n+\t{0x924d692ca61be758, 269, false},   // 10^100\n+\t{0xda01ee641a708dea, 295, false},   // 10^108\n+\t{0xa26da3999aef774a, 322, false},   // 10^116\n+\t{0xf209787bb47d6b85, 348, false},   // 10^124\n+\t{0xb454e4a179dd1877, 375, false},   // 10^132\n+\t{0x865b86925b9bc5c2, 402, false},   // 10^140\n+\t{0xc83553c5c8965d3d, 428, false},   // 10^148\n+\t{0x952ab45cfa97a0b3, 455, false},   // 10^156\n+\t{0xde469fbd99a05fe3, 481, false},   // 10^164\n+\t{0xa59bc234db398c25, 508, false},   // 10^172\n+\t{0xf6c69a72a3989f5c, 534, false},   // 10^180\n+\t{0xb7dcbf5354e9bece, 561, false},   // 10^188\n+\t{0x88fcf317f22241e2, 588, false},   // 10^196\n+\t{0xcc20ce9bd35c78a5, 614, false},   // 10^204\n+\t{0x98165af37b2153df, 641, false},   // 10^212\n+\t{0xe2a0b5dc971f303a, 667, false},   // 10^220\n+\t{0xa8d9d1535ce3b396, 694, false},   // 10^228\n+\t{0xfb9b7cd9a4a7443c, 720, false},   // 10^236\n+\t{0xbb764c4ca7a44410, 747, false},   // 10^244\n+\t{0x8bab8eefb6409c1a, 774, false},   // 10^252\n+\t{0xd01fef10a657842c, 800, false},   // 10^260\n+\t{0x9b10a4e5e9913129, 827, false},   // 10^268\n+\t{0xe7109bfba19c0c9d, 853, false},   // 10^276\n+\t{0xac2820d9623bf429, 880, false},   // 10^284\n+\t{0x80444b5e7aa7cf85, 907, false},   // 10^292\n+\t{0xbf21e44003acdd2d, 933, false},   // 10^300\n+\t{0x8e679c2f5e44ff8f, 960, false},   // 10^308\n+\t{0xd433179d9c8cb841, 986, false},   // 10^316\n+\t{0x9e19db92b4e31ba9, 1013, false},  // 10^324\n+\t{0xeb96bf6ebadf77d9, 1039, false},  // 10^332\n+\t{0xaf87023b9bf0ee6b, 1066, false},  // 10^340\n+}\n+\n+// floatBits returns the bits of the float64 that best approximates\n+// the extFloat passed as receiver. Overflow is set to true if\n+// the resulting float64 is \u00b1Inf.\n+func (f *extFloat) floatBits() (bits uint64, overflow bool) {\n+\tflt := &float64info\n+\tf.Normalize()\n+\n+\texp := f.exp + 63\n+\n+\t// Exponent too small.\n+\tif exp < flt.bias+1 {\n+\t\tn := flt.bias + 1 - exp\n+\t\tf.mant >>= uint(n)\n+\t\texp += n\n+\t}\n+\n+\t// Extract 1+flt.mantbits bits.\n+\tmant := f.mant >> (63 - flt.mantbits)\n+\tif f.mant&(1<<(62-flt.mantbits)) != 0 {\n+\t\t// Round up.\n+\t\tmant += 1\n+\t}\n+\n+\t// Rounding might have added a bit; shift down.\n+\tif mant == 2<<flt.mantbits {\n+\t\tmant >>= 1\n+\t\texp++\n+\t}\n+\n+\t// Infinities.\n+\tif exp-flt.bias >= 1<<flt.expbits-1 {\n+\t\tgoto overflow\n+\t}\n+\n+\t// Denormalized?\n+\tif mant&(1<<flt.mantbits) == 0 {\n+\t\texp = flt.bias\n+\t}\n+\tgoto out\n+\n+overflow:\n+\t// \u00b1Inf\n+\tmant = 0\n+\texp = 1<<flt.expbits - 1 + flt.bias\n+\toverflow = true\n+\n+out:\n+\t// Assemble bits.\n+\tbits = mant & (uint64(1)<<flt.mantbits - 1)\n+\tbits |= uint64((exp-flt.bias)&(1<<flt.expbits-1)) << flt.mantbits\n+\tif f.neg {\n+\t\tbits |= 1 << (flt.mantbits + flt.expbits)\n+\t}\n+\treturn\n+}\n+\n+// Assign sets f to the value of x.\n+func (f *extFloat) Assign(x float64) {\n+\tif x < 0 {\n+\t\tx = -x\n+\t\tf.neg = true\n+\t}\n+\tx, f.exp = math.Frexp(x)\n+\tf.mant = uint64(x * float64(1<<64))\n+\tf.exp -= 64\n+}\n+\n+// Normalize normalizes f so that the highest bit of the mantissa is\n+// set, and returns the number by which the mantissa was left-shifted.\n+func (f *extFloat) Normalize() uint {\n+\tif f.mant == 0 {\n+\t\treturn 0\n+\t}\n+\texp_before := f.exp\n+\tfor f.mant < (1 << 55) {\n+\t\tf.mant <<= 8\n+\t\tf.exp -= 8\n+\t}\n+\tfor f.mant < (1 << 63) {\n+\t\tf.mant <<= 1\n+\t\tf.exp -= 1\n+\t}\n+\treturn uint(exp_before - f.exp)\n+}\n+\n+// Multiply sets f to the product f*g: the result is correctly rounded,\n+// but not normalized.\n+func (f *extFloat) Multiply(g extFloat) {\n+\tfhi, flo := f.mant>>32, uint64(uint32(f.mant))\n+\tghi, glo := g.mant>>32, uint64(uint32(g.mant))\n+\n+\t// Cross products.\n+\tcross1 := fhi * glo\n+\tcross2 := flo * ghi\n+\n+\t// f.mant*g.mant is fhi*ghi << 64 + (cross1+cross2) << 32 + flo*glo\n+\tf.mant = fhi*ghi + (cross1 >> 32) + (cross2 >> 32)\n+\trem := uint64(uint32(cross1)) + uint64(uint32(cross2)) + ((flo * glo) >> 32)\n+\t// Round up.\n+\trem += (1 << 31)\n+\n+\tf.mant += (rem >> 32)\n+\tf.exp = f.exp + g.exp + 64\n+}\n+\n+var uint64pow10 = [...]uint64{\n+\t1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n+\t1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n+}\n+\n+// AssignDecimal sets f to an approximate value of the decimal d. It\n+// returns true if the value represented by f is guaranteed to be the\n+// best approximation of d after being rounded to a float64. \n+func (f *extFloat) AssignDecimal(d *decimal) (ok bool) {\n+\tconst uint64digits = 19\n+\tconst errorscale = 8\n+\tmant10, digits := d.atou64()\n+\texp10 := d.dp - digits\n+\terrors := 0 // An upper bound for error, computed in errorscale*ulp.\n+\n+\tif digits < d.nd {\n+\t\t// the decimal number was truncated.\n+\t\terrors += errorscale / 2\n+\t}\n+\n+\tf.mant = mant10\n+\tf.exp = 0\n+\tf.neg = d.neg\n+\n+\t// Multiply by powers of ten.\n+\ti := (exp10 - firstPowerOfTen) / stepPowerOfTen\n+\tif exp10 < firstPowerOfTen || i >= len(powersOfTen) {\n+\t\treturn false\n+\t}\n+\tadjExp := (exp10 - firstPowerOfTen) % stepPowerOfTen\n+\n+\t// We multiply by exp%step\n+\tif digits+adjExp <= uint64digits {\n+\t\t// We can multiply the mantissa\n+\t\tf.mant *= uint64(float64pow10[adjExp])\n+\t\tf.Normalize()\n+\t} else {\n+\t\tf.Normalize()\n+\t\tf.Multiply(smallPowersOfTen[adjExp])\n+\t\terrors += errorscale / 2\n+\t}\n+\n+\t// We multiply by 10 to the exp - exp%step.\n+\tf.Multiply(powersOfTen[i])\n+\tif errors > 0 {\n+\t\terrors += 1\n+\t}\n+\terrors += errorscale / 2\n+\n+\t// Normalize\n+\tshift := f.Normalize()\n+\terrors <<= shift\n+\n+\t// Now f is a good approximation of the decimal.\n+\t// Check whether the error is too large: that is, if the mantissa\n+\t// is perturbated by the error, the resulting float64 will change.\n+\t// The 64 bits mantissa is 1 + 52 bits for float64 + 11 extra bits.\n+\t//\n+\t// In many cases the approximation will be good enough.\n+\tconst denormalExp = -1023 - 63\n+\tflt := &float64info\n+\tvar extrabits uint\n+\tif f.exp <= denormalExp {\n+\t\textrabits = uint(63 - flt.mantbits + 1 + uint(denormalExp-f.exp))\n+\t} else {\n+\t\textrabits = uint(63 - flt.mantbits)\n+\t}\n+\n+\thalfway := uint64(1) << (extrabits - 1)\n+\tmant_extra := f.mant & (1<<extrabits - 1)\n+\n+\t// Do a signed comparison here! If the error estimate could make\n+\t// the mantissa round differently for the conversion to double,\n+\t// then we can't give a definite answer.\n+\tif int64(halfway)-int64(errors) < int64(mant_extra) &&\n+\t\tint64(mant_extra) < int64(halfway)+int64(errors) {\n+\t\treturn false\n+\t}\n+\treturn true\n+}"}, {"sha": "f4434fd51753c8a96e0ecee3406f09af2c8ae063", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -40,11 +40,7 @@ var float64info = floatInfo{52, 11, -1023}\n // For 'e', 'E', and 'f' it is the number of digits after the decimal point.\n // For 'g' and 'G' it is the total number of digits.\n // The special precision -1 uses the smallest number of digits\n-// necessary such that Atof32 will return f exactly.\n-//\n-// Ftoa32(f) is not the same as Ftoa64(float32(f)),\n-// because correct rounding and the number of digits\n-// needed to identify f depend on the precision of the representation.\n+// necessary such that ParseFloat will return f exactly.\n func FormatFloat(f float64, fmt byte, prec, bitSize int) string {\n \treturn string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))\n }"}, {"sha": "54046d68aa0073dea15d6f1cc47e44d6cb8d36dc", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bytes\"\n \t\"io\"\n \t\"reflect\"\n-\t\"strconv\"\n \t. \"strings\"\n \t\"testing\"\n \t\"unicode\"\n@@ -143,7 +142,7 @@ const benchmarkString = \"some_text=some\u263avalue\"\n \n func BenchmarkIndexRune(b *testing.B) {\n \tif got := IndexRune(benchmarkString, '\u263a'); got != 14 {\n-\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t\tb.Fatalf(\"wrong index: expected 14, got=%d\", got)\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tIndexRune(benchmarkString, '\u263a')\n@@ -152,7 +151,7 @@ func BenchmarkIndexRune(b *testing.B) {\n \n func BenchmarkIndexRuneFastPath(b *testing.B) {\n \tif got := IndexRune(benchmarkString, 'v'); got != 17 {\n-\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t\tb.Fatalf(\"wrong index: expected 17, got=%d\", got)\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tIndexRune(benchmarkString, 'v')\n@@ -161,7 +160,7 @@ func BenchmarkIndexRuneFastPath(b *testing.B) {\n \n func BenchmarkIndex(b *testing.B) {\n \tif got := Index(benchmarkString, \"v\"); got != 17 {\n-\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t\tb.Fatalf(\"wrong index: expected 17, got=%d\", got)\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tIndex(benchmarkString, \"v\")"}, {"sha": "f98036c42cdbfba560211f276ed85b080f942ae2", "filename": "libgo/go/syscall/bpf_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n // Berkeley packet filter for BSD variants\n "}, {"sha": "3ba0fb1b098d30be0b72c3730299a382ce825cfa", "filename": "libgo/go/syscall/env_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Unix environment variables.\n "}, {"sha": "0cd37c4a0b529c48c1c0cc369b54643937d956e9", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux netbsd openbsd\n+\n // Fork, exec, wait, etc.\n \n package syscall"}, {"sha": "e17d976b1548723cd1b19cc42c9662c7ac988173", "filename": "libgo/go/syscall/route_bsd.go", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_bsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd openbsd\n+// +build darwin freebsd netbsd openbsd\n \n // Routing sockets and messages\n \n@@ -85,8 +85,8 @@ func (m *RouteMessage) sockaddr() []Sockaddr {\n \t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n \t\tswitch i {\n \t\tcase RTAX_DST, RTAX_GATEWAY:\n-\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != nil {\n+\t\t\tsa, err := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif err != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tif i == RTAX_DST {\n@@ -128,8 +128,8 @@ func (m *InterfaceMessage) sockaddr() (sas []Sockaddr) {\n \tif m.Header.Addrs&RTA_IFP == 0 {\n \t\treturn nil\n \t}\n-\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(&m.Data[0])))\n-\tif e != nil {\n+\tsa, err := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(&m.Data[0])))\n+\tif err != nil {\n \t\treturn nil\n \t}\n \treturn append(sas, sa)\n@@ -157,12 +157,21 @@ func (m *InterfaceAddrMessage) sockaddr() (sas []Sockaddr) {\n \t\trsa := (*RawSockaddr)(unsafe.Pointer(&buf[0]))\n \t\tswitch i {\n \t\tcase RTAX_IFA:\n-\t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != nil {\n+\t\t\tsa, err := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif err != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tsas = append(sas, sa)\n-\t\tcase RTAX_NETMASK, RTAX_BRD:\n+\t\tcase RTAX_NETMASK:\n+\t\t\tif rsa.Family == AF_UNSPEC {\n+\t\t\t\trsa.Family = AF_INET // an old fasion, AF_UNSPEC means AF_INET\n+\t\t\t}\n+\t\t\tsa, err := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tsas = append(sas, sa)\n+\t\tcase RTAX_BRD:\n \t\t\t// nothing to do\n \t\t}\n \t\tbuf = buf[rsaAlignOf(int(rsa.Len)):]"}, {"sha": "d6d9031bcbf06cc033756bd1110946840b7903c5", "filename": "libgo/go/syscall/route_netbsd.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Froute_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Froute_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_netbsd.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Routing sockets and messages for NetBSD\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func (any *anyMessage) toRoutingMessage(buf []byte) RoutingMessage {\n+\tswitch any.Type {\n+\tcase RTM_ADD, RTM_DELETE, RTM_CHANGE, RTM_GET, RTM_LOSING, RTM_REDIRECT, RTM_MISS, RTM_LOCK, RTM_RESOLVE:\n+\t\tp := (*RouteMessage)(unsafe.Pointer(any))\n+\t\trtm := &RouteMessage{}\n+\t\trtm.Header = p.Header\n+\t\trtm.Data = buf[SizeofRtMsghdr:any.Msglen]\n+\t\treturn rtm\n+\tcase RTM_IFINFO:\n+\t\tp := (*InterfaceMessage)(unsafe.Pointer(any))\n+\t\tifm := &InterfaceMessage{}\n+\t\tifm.Header = p.Header\n+\t\tifm.Data = buf[SizeofIfMsghdr:any.Msglen]\n+\t\treturn ifm\n+\tcase RTM_NEWADDR, RTM_DELADDR:\n+\t\tp := (*InterfaceAddrMessage)(unsafe.Pointer(any))\n+\t\tifam := &InterfaceAddrMessage{}\n+\t\tifam.Header = p.Header\n+\t\tifam.Data = buf[SizeofIfaMsghdr:any.Msglen]\n+\t\treturn ifam\n+\t}\n+\treturn nil\n+}"}, {"sha": "d279decb65a5c31eec8628ee8310a84470f42981", "filename": "libgo/go/syscall/sockcmsg_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Socket control messages\n "}, {"sha": "42ab2185084136f626b58162c84241edeb7c51c5", "filename": "libgo/go/syscall/socket_linux.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -167,6 +167,9 @@ func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, error) {\n //sysnb\tEpollCreate(size int) (fd int, err error)\n //epoll_create(size int) int\n \n+//sysnb EpollCreate1(flags int) (fd int, err error)\n+//epoll_create1(flags int) int\n+\n //sysnb\tEpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)\n //epoll_ctl(epfd int, op int, fd int, event *EpollEvent) int\n "}, {"sha": "ba109f63ac1b23afe5e7f99e86ca102b70e7c7ca", "filename": "libgo/go/syscall/syscall_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package syscall\n "}, {"sha": "4ce637082ca660d3441ab484b0d02359849b6310", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 60, "deletions": 11, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -25,12 +25,12 @@ type InternalBenchmark struct {\n // B is a type passed to Benchmark functions to manage benchmark\n // timing and to specify the number of iterations to run.\n type B struct {\n+\tcommon\n \tN         int\n \tbenchmark InternalBenchmark\n-\tns        time.Duration\n \tbytes     int64\n-\tstart     time.Time\n \ttimerOn   bool\n+\tresult    BenchmarkResult\n }\n \n // StartTimer starts timing a test.  This function is called automatically\n@@ -48,7 +48,7 @@ func (b *B) StartTimer() {\n // want to measure.\n func (b *B) StopTimer() {\n \tif b.timerOn {\n-\t\tb.ns += time.Now().Sub(b.start)\n+\t\tb.duration += time.Now().Sub(b.start)\n \t\tb.timerOn = false\n \t}\n }\n@@ -59,7 +59,7 @@ func (b *B) ResetTimer() {\n \tif b.timerOn {\n \t\tb.start = time.Now()\n \t}\n-\tb.ns = 0\n+\tb.duration = 0\n }\n \n // SetBytes records the number of bytes processed in a single operation.\n@@ -70,7 +70,7 @@ func (b *B) nsPerOp() int64 {\n \tif b.N <= 0 {\n \t\treturn 0\n \t}\n-\treturn b.ns.Nanoseconds() / int64(b.N)\n+\treturn b.duration.Nanoseconds() / int64(b.N)\n }\n \n // runN runs a single benchmark for the specified number of iterations.\n@@ -127,17 +127,25 @@ func roundUp(n int) int {\n \treturn 10 * base\n }\n \n-// run times the benchmark function.  It gradually increases the number\n+// run times the benchmark function in a separate goroutine.\n+func (b *B) run() BenchmarkResult {\n+\tgo b.launch()\n+\t<-b.signal\n+\treturn b.result\n+}\n+\n+// launch launches the benchmark function.  It gradually increases the number\n // of benchmark iterations until the benchmark runs for a second in order\n // to get a reasonable measurement.  It prints timing information in this form\n //\t\ttesting.BenchmarkHello\t100000\t\t19 ns/op\n-func (b *B) run() BenchmarkResult {\n+// launch is run by the fun function as a separate goroutine.\n+func (b *B) launch() {\n \t// Run the benchmark for a single iteration in case it's expensive.\n \tn := 1\n \tb.runN(n)\n \t// Run the benchmark for at least the specified amount of time.\n \td := time.Duration(*benchTime * float64(time.Second))\n-\tfor b.ns < d && n < 1e9 {\n+\tfor !b.failed && b.duration < d && n < 1e9 {\n \t\tlast := n\n \t\t// Predict iterations/sec.\n \t\tif b.nsPerOp() == 0 {\n@@ -153,7 +161,8 @@ func (b *B) run() BenchmarkResult {\n \t\tn = roundUp(n)\n \t\tb.runN(n)\n \t}\n-\treturn BenchmarkResult{b.N, b.ns, b.bytes}\n+\tb.result = BenchmarkResult{b.N, b.duration, b.bytes}\n+\tb.signal <- b\n }\n \n // The results of a benchmark run.\n@@ -215,24 +224,64 @@ func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks [\n \t\t}\n \t\tfor _, procs := range cpuList {\n \t\t\truntime.GOMAXPROCS(procs)\n-\t\t\tb := &B{benchmark: Benchmark}\n+\t\t\tb := &B{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan interface{}),\n+\t\t\t\t},\n+\t\t\t\tbenchmark: Benchmark,\n+\t\t\t}\n \t\t\tbenchName := Benchmark.Name\n \t\t\tif procs != 1 {\n \t\t\t\tbenchName = fmt.Sprintf(\"%s-%d\", Benchmark.Name, procs)\n \t\t\t}\n \t\t\tfmt.Printf(\"%s\\t\", benchName)\n \t\t\tr := b.run()\n+\t\t\tif b.failed {\n+\t\t\t\t// The output could be very long here, but probably isn't.\n+\t\t\t\t// We print it all, regardless, because we don't want to trim the reason\n+\t\t\t\t// the benchmark failed.\n+\t\t\t\tfmt.Printf(\"--- FAIL: %s\\n%s\", benchName, b.output)\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tfmt.Printf(\"%v\\n\", r)\n+\t\t\t// Unlike with tests, we ignore the -chatty flag and always print output for\n+\t\t\t// benchmarks since the output generation time will skew the results.\n+\t\t\tif len(b.output) > 0 {\n+\t\t\t\tb.trimOutput()\n+\t\t\t\tfmt.Printf(\"--- BENCH: %s\\n%s\", benchName, b.output)\n+\t\t\t}\n \t\t\tif p := runtime.GOMAXPROCS(-1); p != procs {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s left GOMAXPROCS set to %d\\n\", benchName, p)\n \t\t\t}\n \t\t}\n \t}\n }\n \n+// trimOutput shortens the output from a benchmark, which can be very long.\n+func (b *B) trimOutput() {\n+\t// The output is likely to appear multiple times because the benchmark\n+\t// is run multiple times, but at least it will be seen. This is not a big deal\n+\t// because benchmarks rarely print, but just in case, we trim it if it's too long.\n+\tconst maxNewlines = 10\n+\tfor nlCount, j := 0, 0; j < len(b.output); j++ {\n+\t\tif b.output[j] == '\\n' {\n+\t\t\tnlCount++\n+\t\t\tif nlCount >= maxNewlines {\n+\t\t\t\tb.output = append(b.output[:j], \"\\n\\t... [output truncated]\\n\"...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n // Benchmark benchmarks a single function. Useful for creating\n // custom benchmarks that do not use gotest.\n func Benchmark(f func(b *B)) BenchmarkResult {\n-\tb := &B{benchmark: InternalBenchmark{\"\", f}}\n+\tb := &B{\n+\t\tcommon: common{\n+\t\t\tsignal: make(chan interface{}),\n+\t\t},\n+\t\tbenchmark: InternalBenchmark{\"\", f},\n+\t}\n \treturn b.run()\n }"}, {"sha": "fdeda137e7614facde2b4a4ade14e67970610ade", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n+\t\"strings\"\n \t\"time\"\n )\n \n@@ -67,11 +68,9 @@ func RunExamples(examples []InternalExample) (ok bool) {\n \n \t\t// report any errors\n \t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", dt.Seconds())\n-\t\tif out != eg.Output {\n-\t\t\tfmt.Printf(\n-\t\t\t\t\"--- FAIL: %s %s\\ngot:\\n%s\\nwant:\\n%s\\n\",\n-\t\t\t\teg.Name, tstr, out, eg.Output,\n-\t\t\t)\n+\t\tif g, e := strings.TrimSpace(out), strings.TrimSpace(eg.Output); g != e {\n+\t\t\tfmt.Printf(\"--- FAIL: %s %s\\ngot:\\n%s\\nwant:\\n%s\\n\",\n+\t\t\t\teg.Name, tstr, g, e)\n \t\t\tok = false\n \t\t} else if *chatty {\n \t\t\tfmt.Printf(\"--- PASS: %s %s\\n\", eg.Name, tstr)"}, {"sha": "16890e0b3fa2dc37fed36af4a2d411c5c7e572f7", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -23,8 +23,8 @@\n //     }\n // The benchmark package will vary b.N until the benchmark function lasts\n // long enough to be timed reliably.  The output\n-//     testing.BenchmarkHello\t500000\t      4076 ns/op\n-// means that the loop ran 500000 times at a speed of 4076 ns per loop.\n+//     testing.BenchmarkHello    10000000    282 ns/op\n+// means that the loop ran 10000000 times at a speed of 282 ns per loop.\n //\n // If a benchmark needs some expensive setup before running, the timer\n // may be stopped:\n@@ -70,6 +70,17 @@ var (\n \tcpuList []int\n )\n \n+// common holds the elements common between T and B and\n+// captures common methods such as Errorf.\n+type common struct {\n+\toutput   []byte    // Output generated by test or benchmark.\n+\tfailed   bool      // Test or benchmark has failed.\n+\tstart    time.Time // Time test or benchmark started\n+\tduration time.Duration\n+\tself     interface{}      // To be sent on signal channel when done.\n+\tsignal   chan interface{} // Output for serial tests.\n+}\n+\n // Short reports whether the -test.short flag is set.\n func Short() bool {\n \treturn *short\n@@ -79,7 +90,7 @@ func Short() bool {\n // If addFileLine is true, it also prefixes the string with the file and line of the call site.\n func decorate(s string, addFileLine bool) string {\n \tif addFileLine {\n-\t\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n+\t\t_, file, line, ok := runtime.Caller(4) // decorate + log + public function.\n \t\tif ok {\n \t\t\t// Truncate file name at last file name separator.\n \t\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n@@ -111,70 +122,68 @@ func decorate(s string, addFileLine bool) string {\n // T is a type passed to Test functions to manage test state and support formatted test logs.\n // Logs are accumulated during execution and dumped to standard error when done.\n type T struct {\n-\tname          string        // Name of test.\n-\terrors        string        // Error string from test.\n-\tfailed        bool          // Test has failed.\n-\tch            chan *T       // Output for serial tests.\n-\tstartParallel chan bool     // Parallel tests will wait on this.\n-\tstart         time.Time     // Time test started\n-\tdt            time.Duration // Length of test\n+\tcommon\n+\tname          string    // Name of test.\n+\tstartParallel chan bool // Parallel tests will wait on this.\n }\n \n-// Fail marks the Test function as having failed but continues execution.\n-func (t *T) Fail() { t.failed = true }\n+// Fail marks the function as having failed but continues execution.\n+func (c *common) Fail() { c.failed = true }\n \n-// Failed returns whether the Test function has failed.\n-func (t *T) Failed() bool { return t.failed }\n+// Failed returns whether the function has failed.\n+func (c *common) Failed() bool { return c.failed }\n \n-// FailNow marks the Test function as having failed and stops its execution.\n+// FailNow marks the function as having failed and stops its execution.\n // Execution will continue at the next Test.\n-func (t *T) FailNow() {\n-\tt.dt = time.Now().Sub(t.start)\n-\tt.Fail()\n-\tt.ch <- t\n+func (c *common) FailNow() {\n+\tc.duration = time.Now().Sub(c.start)\n+\tc.Fail()\n+\tc.signal <- c.self\n \truntime.Goexit()\n }\n \n // log generates the output. It's always at the same stack depth.\n-func (t *T) log(s string) { t.errors += decorate(s, true) }\n+func (c *common) log(s string) {\n+\tc.output = append(c.output, decorate(s, true)...)\n+}\n \n-// Log formats its arguments using default formatting, analogous to Print(),\n+// Log formats its arguments using default formatting, analogous to Println(),\n // and records the text in the error log.\n-func (t *T) Log(args ...interface{}) { t.log(fmt.Sprintln(args...)) }\n+func (c *common) Log(args ...interface{}) { c.log(fmt.Sprintln(args...)) }\n \n // Logf formats its arguments according to the format, analogous to Printf(),\n // and records the text in the error log.\n-func (t *T) Logf(format string, args ...interface{}) { t.log(fmt.Sprintf(format, args...)) }\n+func (c *common) Logf(format string, args ...interface{}) { c.log(fmt.Sprintf(format, args...)) }\n \n // Error is equivalent to Log() followed by Fail().\n-func (t *T) Error(args ...interface{}) {\n-\tt.log(fmt.Sprintln(args...))\n-\tt.Fail()\n+func (c *common) Error(args ...interface{}) {\n+\tc.log(fmt.Sprintln(args...))\n+\tc.Fail()\n }\n \n // Errorf is equivalent to Logf() followed by Fail().\n-func (t *T) Errorf(format string, args ...interface{}) {\n-\tt.log(fmt.Sprintf(format, args...))\n-\tt.Fail()\n+func (c *common) Errorf(format string, args ...interface{}) {\n+\tc.log(fmt.Sprintf(format, args...))\n+\tc.Fail()\n }\n \n // Fatal is equivalent to Log() followed by FailNow().\n-func (t *T) Fatal(args ...interface{}) {\n-\tt.log(fmt.Sprintln(args...))\n-\tt.FailNow()\n+func (c *common) Fatal(args ...interface{}) {\n+\tc.log(fmt.Sprintln(args...))\n+\tc.FailNow()\n }\n \n // Fatalf is equivalent to Logf() followed by FailNow().\n-func (t *T) Fatalf(format string, args ...interface{}) {\n-\tt.log(fmt.Sprintf(format, args...))\n-\tt.FailNow()\n+func (c *common) Fatalf(format string, args ...interface{}) {\n+\tc.log(fmt.Sprintf(format, args...))\n+\tc.FailNow()\n }\n \n // Parallel signals that this test is to be run in parallel with (and only with) \n // other parallel tests in this CPU group.\n func (t *T) Parallel() {\n-\tt.ch <- nil       // Release main testing loop\n-\t<-t.startParallel // Wait for serial tests to finish\n+\tt.signal <- (*T)(nil) // Release main testing loop\n+\t<-t.startParallel     // Wait for serial tests to finish\n }\n \n // An internal type but exported because it is cross-package; part of the implementation\n@@ -187,8 +196,8 @@ type InternalTest struct {\n func tRunner(t *T, test *InternalTest) {\n \tt.start = time.Now()\n \ttest.F(t)\n-\tt.dt = time.Now().Sub(t.start)\n-\tt.ch <- t\n+\tt.duration = time.Now().Sub(t.start)\n+\tt.signal <- t\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n@@ -211,13 +220,13 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n \tafter()\n }\n \n-func report(t *T) {\n-\ttstr := fmt.Sprintf(\"(%.2f seconds)\", t.dt.Seconds())\n+func (t *T) report() {\n+\ttstr := fmt.Sprintf(\"(%.2f seconds)\", t.duration.Seconds())\n \tformat := \"--- %s: %s %s\\n%s\"\n \tif t.failed {\n-\t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.errors)\n+\t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.output)\n \t} else if *chatty {\n-\t\tfmt.Printf(format, \"PASS\", t.name, tstr, t.errors)\n+\t\tfmt.Printf(format, \"PASS\", t.name, tstr, t.output)\n \t}\n }\n \n@@ -227,9 +236,14 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\tfmt.Fprintln(os.Stderr, \"testing: warning: no tests to run\")\n \t\treturn\n \t}\n-\tch := make(chan *T)\n \tfor _, procs := range cpuList {\n \t\truntime.GOMAXPROCS(procs)\n+\t\t// We build a new channel tree for each run of the loop.\n+\t\t// collector merges in one channel all the upstream signals from parallel tests.\n+\t\t// If all tests pump to the same channel, a bug can occur where a test\n+\t\t// kicks off a goroutine that Fails, yet the test still delivers a completion signal,\n+\t\t// which skews the counting.\n+\t\tvar collector = make(chan interface{})\n \n \t\tnumParallel := 0\n \t\tstartParallel := make(chan bool)\n@@ -247,17 +261,27 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\tif procs != 1 {\n \t\t\t\ttestName = fmt.Sprintf(\"%s-%d\", tests[i].Name, procs)\n \t\t\t}\n-\t\t\tt := &T{ch: ch, name: testName, startParallel: startParallel}\n+\t\t\tt := &T{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan interface{}),\n+\t\t\t\t},\n+\t\t\t\tname:          testName,\n+\t\t\t\tstartParallel: startParallel,\n+\t\t\t}\n+\t\t\tt.self = t\n \t\t\tif *chatty {\n \t\t\t\tfmt.Printf(\"=== RUN %s\\n\", t.name)\n \t\t\t}\n \t\t\tgo tRunner(t, &tests[i])\n-\t\t\tout := <-t.ch\n+\t\t\tout := (<-t.signal).(*T)\n \t\t\tif out == nil { // Parallel run.\n+\t\t\t\tgo func() {\n+\t\t\t\t\tcollector <- <-t.signal\n+\t\t\t\t}()\n \t\t\t\tnumParallel++\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treport(t)\n+\t\t\tt.report()\n \t\t\tok = ok && !out.failed\n \t\t}\n \n@@ -269,8 +293,8 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\t\tnumParallel--\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tt := <-ch\n-\t\t\treport(t)\n+\t\t\tt := (<-collector).(*T)\n+\t\t\tt.report()\n \t\t\tok = ok && !t.failed\n \t\t\trunning--\n \t\t}"}, {"sha": "2bef9df9c6f2339594f429fc6371008d7297f6e8", "filename": "libgo/go/testing/wrapper.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fwrapper.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftesting%2Fwrapper.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fwrapper.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains wrappers so t.Errorf etc. have documentation.\n+// TODO: delete when godoc shows exported methods for unexported embedded fields.\n+// TODO: need to change the argument to runtime.Caller in testing.go from 4 to 3 at that point.\n+\n+package testing\n+\n+// Fail marks the function as having failed but continues execution.\n+func (b *B) Fail() {\n+\tb.common.Fail()\n+}\n+\n+// Failed returns whether the function has failed.\n+func (b *B) Failed() bool {\n+\treturn b.common.Failed()\n+}\n+\n+// FailNow marks the function as having failed and stops its execution.\n+// Execution will continue at the next Test.\n+func (b *B) FailNow() {\n+\tb.common.FailNow()\n+}\n+\n+// Log formats its arguments using default formatting, analogous to Println(),\n+// and records the text in the error log.\n+func (b *B) Log(args ...interface{}) {\n+\tb.common.Log(args...)\n+}\n+\n+// Logf formats its arguments according to the format, analogous to Printf(),\n+// and records the text in the error log.\n+func (b *B) Logf(format string, args ...interface{}) {\n+\tb.common.Logf(format, args...)\n+}\n+\n+// Error is equivalent to Log() followed by Fail().\n+func (b *B) Error(args ...interface{}) {\n+\tb.common.Error(args...)\n+}\n+\n+// Errorf is equivalent to Logf() followed by Fail().\n+func (b *B) Errorf(format string, args ...interface{}) {\n+\tb.common.Errorf(format, args...)\n+}\n+\n+// Fatal is equivalent to Log() followed by FailNow().\n+func (b *B) Fatal(args ...interface{}) {\n+\tb.common.Fatal(args...)\n+}\n+\n+// Fatalf is equivalent to Logf() followed by FailNow().\n+func (b *B) Fatalf(format string, args ...interface{}) {\n+\tb.common.Fatalf(format, args...)\n+}\n+\n+// Fail marks the function as having failed but continues execution.\n+func (t *T) Fail() {\n+\tt.common.Fail()\n+}\n+\n+// Failed returns whether the function has failed.\n+func (t *T) Failed() bool {\n+\treturn t.common.Failed()\n+}\n+\n+// FailNow marks the function as having failed and stops its execution.\n+// Execution will continue at the next Test.\n+func (t *T) FailNow() {\n+\tt.common.FailNow()\n+}\n+\n+// Log formats its arguments using default formatting, analogous to Println(),\n+// and records the text in the error log.\n+func (t *T) Log(args ...interface{}) {\n+\tt.common.Log(args...)\n+}\n+\n+// Logf formats its arguments according to the format, analogous to Printf(),\n+// and records the text in the error log.\n+func (t *T) Logf(format string, args ...interface{}) {\n+\tt.common.Logf(format, args...)\n+}\n+\n+// Error is equivalent to Log() followed by Fail().\n+func (t *T) Error(args ...interface{}) {\n+\tt.common.Error(args...)\n+}\n+\n+// Errorf is equivalent to Logf() followed by Fail().\n+func (t *T) Errorf(format string, args ...interface{}) {\n+\tt.common.Errorf(format, args...)\n+}\n+\n+// Fatal is equivalent to Log() followed by FailNow().\n+func (t *T) Fatal(args ...interface{}) {\n+\tt.common.Fatal(args...)\n+}\n+\n+// Fatalf is equivalent to Logf() followed by FailNow().\n+func (t *T) Fatalf(format string, args ...interface{}) {\n+\tt.common.Fatalf(format, args...)\n+}"}, {"sha": "acb88afee3684afa1e1bfb4222277ac7664d2285", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -107,7 +107,7 @@ func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n \t\tvars: []variable{{\"$\", value}},\n \t}\n \tif t.Tree == nil || t.Root == nil {\n-\t\tstate.errorf(\"must be parsed before execution\")\n+\t\tstate.errorf(\"%q is an incomplete or empty template\", t.name)\n \t}\n \tstate.walk(value, t.Root)\n \treturn\n@@ -497,7 +497,13 @@ func (s *state) evalCall(dot, fun reflect.Value, name string, args []parse.Node,\n // validateType guarantees that the value is valid and assignable to the type.\n func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value {\n \tif !value.IsValid() {\n-\t\ts.errorf(\"invalid value; expected %s\", typ)\n+\t\tswitch typ.Kind() {\n+\t\tcase reflect.Interface, reflect.Ptr, reflect.Chan, reflect.Map, reflect.Slice, reflect.Func:\n+\t\t\t// An untyped nil interface{}. Accept as a proper nil value.\n+\t\t\tvalue = reflect.Zero(typ)\n+\t\tdefault:\n+\t\t\ts.errorf(\"invalid value; expected %s\", typ)\n+\t\t}\n \t}\n \tif !value.Type().AssignableTo(typ) {\n \t\t// Does one dereference or indirection work? We could do more, as we"}, {"sha": "e33988b86c0930a1b60971c3ecbe596587f363af", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -157,6 +157,10 @@ func (t *T) Method2(a uint16, b string) string {\n \treturn fmt.Sprintf(\"Method2: %d %s\", a, b)\n }\n \n+func (t *T) Method3(v interface{}) string {\n+\treturn fmt.Sprintf(\"Method3: %v\", v)\n+}\n+\n func (t *T) MAdd(a int, b []int) []int {\n \tv := make([]int, len(b))\n \tfor i, x := range b {\n@@ -293,6 +297,7 @@ var execTests = []execTest{\n \t{\".Method2(3, .X)\", \"-{{.Method2 3 .X}}-\", \"-Method2: 3 x-\", tVal, true},\n \t{\".Method2(.U16, `str`)\", \"-{{.Method2 .U16 `str`}}-\", \"-Method2: 16 str-\", tVal, true},\n \t{\".Method2(.U16, $x)\", \"{{if $x := .X}}-{{.Method2 .U16 $x}}{{end}}-\", \"-Method2: 16 x-\", tVal, true},\n+\t{\".Method3(nil)\", \"-{{.Method3 .MXI.unset}}-\", \"-Method3: <nil>-\", tVal, true},\n \t{\"method on var\", \"{{if $x := .}}-{{$x.Method2 .U16 $x.X}}{{end}}-\", \"-Method2: 16 x-\", tVal, true},\n \t{\"method on chained var\",\n \t\t\"{{range .MSIone}}{{if $.U.TrueFalse $.True}}{{$.U.TrueFalse $.True}}{{else}}WRONG{{end}}{{end}}\",\n@@ -322,6 +327,8 @@ var execTests = []execTest{\n \t{\"if slice\", \"{{if .SI}}NON-EMPTY{{else}}EMPTY{{end}}\", \"NON-EMPTY\", tVal, true},\n \t{\"if emptymap\", \"{{if .MSIEmpty}}NON-EMPTY{{else}}EMPTY{{end}}\", \"EMPTY\", tVal, true},\n \t{\"if map\", \"{{if .MSI}}NON-EMPTY{{else}}EMPTY{{end}}\", \"NON-EMPTY\", tVal, true},\n+\t{\"if map unset\", \"{{if .MXI.none}}NON-ZERO{{else}}ZERO{{end}}\", \"ZERO\", tVal, true},\n+\t{\"if map not unset\", \"{{if not .MXI.none}}ZERO{{else}}NON-ZERO{{end}}\", \"ZERO\", tVal, true},\n \t{\"if $x with $y int\", \"{{if $x := true}}{{with $y := .I}}{{$x}},{{$y}}{{end}}{{end}}\", \"true,17\", tVal, true},\n \t{\"if $x with $x int\", \"{{if $x := true}}{{with $x := .I}}{{$x}},{{end}}{{$x}}{{end}}\", \"17,true\", tVal, true},\n "}, {"sha": "56a7414e0ce875ddbb7d8c33771c3bd750c8f5bb", "filename": "libgo/go/time/sys_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Fsys_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Fsys_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package time\n "}, {"sha": "33d557f7369b8ef792f4ddf99727bdfcca169310", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -7,6 +7,8 @@\n // The calendrical calculations always assume a Gregorian calendar.\n package time\n \n+import \"errors\"\n+\n // A Time represents an instant in time with nanosecond precision.\n //\n // Programs using times should typically store and pass them as values,\n@@ -564,6 +566,20 @@ func (t Time) Sub(u Time) Duration {\n \treturn Duration(t.sec-u.sec)*Second + Duration(t.nsec-u.nsec)\n }\n \n+// AddDate returns the time corresponding to adding the\n+// given number of years, months, and days to t.\n+// For example, AddDate(-1, 2, 3) applied to January 1, 2011\n+// returns March 4, 2010.\n+//\n+// AddDate normalizes its result in the same way that Date does,\n+// so, for example, adding one month to October 31 yields\n+// December 1, the normalized form for November 31.\n+func (t Time) AddDate(years int, months int, days int) Time {\n+\tyear, month, day := t.Date()\n+\thour, min, sec := t.Clock()\n+\treturn Date(year+years, month+Month(months), day+days, hour, min, sec, int(t.nsec), t.loc)\n+}\n+\n const (\n \tsecondsPerMinute = 60\n \tsecondsPerHour   = 60 * 60\n@@ -751,11 +767,11 @@ func (t Time) GobEncode() ([]byte, error) {\n \t} else {\n \t\t_, offset := t.Zone()\n \t\tif offset%60 != 0 {\n-\t\t\treturn nil, gobError(\"Time.GobEncode: zone offset has fractional minute\")\n+\t\t\treturn nil, errors.New(\"Time.GobEncode: zone offset has fractional minute\")\n \t\t}\n \t\toffset /= 60\n \t\tif offset < -32768 || offset == -1 || offset > 32767 {\n-\t\t\treturn nil, gobError(\"Time.GobEncode: unexpected zone offset\")\n+\t\t\treturn nil, errors.New(\"Time.GobEncode: unexpected zone offset\")\n \t\t}\n \t\toffsetMin = int16(offset)\n \t}\n@@ -784,15 +800,15 @@ func (t Time) GobEncode() ([]byte, error) {\n // GobDecode implements the gob.GobDecoder interface.\n func (t *Time) GobDecode(buf []byte) error {\n \tif len(buf) == 0 {\n-\t\treturn gobError(\"Time.GobDecode: no data\")\n+\t\treturn errors.New(\"Time.GobDecode: no data\")\n \t}\n \n \tif buf[0] != timeGobVersion {\n-\t\treturn gobError(\"Time.GobDecode: unsupported version\")\n+\t\treturn errors.New(\"Time.GobDecode: unsupported version\")\n \t}\n \n \tif len(buf) != /*version*/ 1+ /*sec*/ 8+ /*nsec*/ 4+ /*zone offset*/ 2 {\n-\t\treturn gobError(\"Time.GobDecode: invalid length\")\n+\t\treturn errors.New(\"Time.GobDecode: invalid length\")\n \t}\n \n \tbuf = buf[1:]\n@@ -816,6 +832,52 @@ func (t *Time) GobDecode(buf []byte) error {\n \treturn nil\n }\n \n+// MarshalJSON implements the json.Marshaler interface.\n+// Time is formatted as RFC3339.\n+func (t Time) MarshalJSON() ([]byte, error) {\n+\tyearInt := t.Year()\n+\tif yearInt < 0 || yearInt > 9999 {\n+\t\treturn nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\")\n+\t}\n+\n+\t// We need a four-digit year, but Format produces variable-width years.\n+\tyear := itoa(yearInt)\n+\tyear = \"0000\"[:4-len(year)] + year\n+\n+\tvar formattedTime string\n+\tif t.nsec == 0 {\n+\t\t// RFC3339, no fractional second\n+\t\tformattedTime = t.Format(\"-01-02T15:04:05Z07:00\")\n+\t} else {\n+\t\t// RFC3339 with fractional second\n+\t\tformattedTime = t.Format(\"-01-02T15:04:05.000000000Z07:00\")\n+\n+\t\t// Trim trailing zeroes from fractional second.\n+\t\tconst nanoEnd = 24 // Index of last digit of fractional second\n+\t\tvar i int\n+\t\tfor i = nanoEnd; formattedTime[i] == '0'; i-- {\n+\t\t\t// Seek backwards until first significant digit is found.\n+\t\t}\n+\n+\t\tformattedTime = formattedTime[:i+1] + formattedTime[nanoEnd+1:]\n+\t}\n+\n+\tbuf := make([]byte, 0, 1+len(year)+len(formattedTime)+1)\n+\tbuf = append(buf, '\"')\n+\tbuf = append(buf, year...)\n+\tbuf = append(buf, formattedTime...)\n+\tbuf = append(buf, '\"')\n+\treturn buf, nil\n+}\n+\n+// UnmarshalJSON implements the json.Unmarshaler interface.\n+// Time is expected in RFC3339 format.\n+func (t *Time) UnmarshalJSON(data []byte) (err error) {\n+\t*t, err = Parse(\"\\\"\"+RFC3339+\"\\\"\", string(data))\n+\t// Fractional seconds are handled implicitly by Parse.\n+\treturn\n+}\n+\n // Unix returns the local Time corresponding to the given Unix time,\n // sec seconds and nsec nanoseconds since January 1, 1970 UTC.\n // It is valid to pass nsec outside the range [0, 999999999]."}, {"sha": "484ae4266a31e3d0a190cdde724f327350c28f29", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 86, "deletions": 6, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -7,6 +7,7 @@ package time_test\n import (\n \t\"bytes\"\n \t\"encoding/gob\"\n+\t\"encoding/json\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -634,6 +635,32 @@ func TestDate(t *testing.T) {\n \t}\n }\n \n+// Several ways of getting from\n+// Fri Nov 18 7:56:35 PST 2011\n+// to\n+// Thu Mar 19 7:56:35 PST 2016\n+var addDateTests = []struct {\n+\tyears, months, days int\n+}{\n+\t{4, 4, 1},\n+\t{3, 16, 1},\n+\t{3, 15, 30},\n+\t{5, -6, -18 - 30 - 12},\n+}\n+\n+func TestAddDate(t *testing.T) {\n+\tt0 := Date(2011, 11, 18, 7, 56, 35, 0, UTC)\n+\tt1 := Date(2016, 3, 19, 7, 56, 35, 0, UTC)\n+\tfor _, at := range addDateTests {\n+\t\ttime := t0.AddDate(at.years, at.months, at.days)\n+\t\tif !time.Equal(t1) {\n+\t\t\tt.Errorf(\"AddDate(%d, %d, %d) = %v, want %v\",\n+\t\t\t\tat.years, at.months, at.days,\n+\t\t\t\ttime, t1)\n+\t\t}\n+\t}\n+}\n+\n var daysInTests = []struct {\n \tyear, month, di int\n }{\n@@ -668,6 +695,12 @@ func TestAddToExactSecond(t *testing.T) {\n \t}\n }\n \n+func equalTimeAndZone(a, b Time) bool {\n+\taname, aoffset := a.Zone()\n+\tbname, boffset := b.Zone()\n+\treturn a.Equal(b) && aoffset == boffset && aname == bname\n+}\n+\n var gobTests = []Time{\n \tDate(0, 1, 2, 3, 4, 5, 6, UTC),\n \tDate(7, 8, 9, 10, 11, 12, 13, FixedZone(\"\", 0)),\n@@ -687,12 +720,8 @@ func TestTimeGob(t *testing.T) {\n \t\t\tt.Errorf(\"%v gob Encode error = %q, want nil\", tt, err)\n \t\t} else if err := dec.Decode(&gobtt); err != nil {\n \t\t\tt.Errorf(\"%v gob Decode error = %q, want nil\", tt, err)\n-\t\t} else {\n-\t\t\tgobname, goboffset := gobtt.Zone()\n-\t\t\tname, offset := tt.Zone()\n-\t\t\tif !gobtt.Equal(tt) || goboffset != offset || gobname != name {\n-\t\t\t\tt.Errorf(\"Decoded time = %v, want %v\", gobtt, tt)\n-\t\t\t}\n+\t\t} else if !equalTimeAndZone(gobtt, tt) {\n+\t\t\tt.Errorf(\"Decoded time = %v, want %v\", gobtt, tt)\n \t\t}\n \t\tb.Reset()\n \t}\n@@ -736,6 +765,57 @@ func TestNotGobEncodableTime(t *testing.T) {\n \t}\n }\n \n+var jsonTests = []struct {\n+\ttime Time\n+\tjson string\n+}{\n+\t{Date(9999, 4, 12, 23, 20, 50, .52*1e9, UTC), `\"9999-04-12T23:20:50.52Z\"`},\n+\t{Date(1996, 12, 19, 16, 39, 57, 0, Local), `\"1996-12-19T16:39:57-08:00\"`},\n+\t{Date(0, 1, 1, 0, 0, 0, 1, FixedZone(\"\", 1*60)), `\"0000-01-01T00:00:00.000000001+00:01\"`},\n+}\n+\n+func TestTimeJSON(t *testing.T) {\n+\tfor _, tt := range jsonTests {\n+\t\tvar jsonTime Time\n+\n+\t\tif jsonBytes, err := json.Marshal(tt.time); err != nil {\n+\t\t\tt.Errorf(\"%v json.Marshal error = %v, want nil\", tt.time, err)\n+\t\t} else if string(jsonBytes) != tt.json {\n+\t\t\tt.Errorf(\"%v JSON = %q, want %q\", tt.time, string(jsonBytes), tt.json)\n+\t\t} else if err = json.Unmarshal(jsonBytes, &jsonTime); err != nil {\n+\t\t\tt.Errorf(\"%v json.Unmarshal error = %v, want nil\", tt.time, err)\n+\t\t} else if !equalTimeAndZone(jsonTime, tt.time) {\n+\t\t\tt.Errorf(\"Unmarshaled time = %v, want %v\", jsonTime, tt.time)\n+\t\t}\n+\t}\n+}\n+\n+func TestInvalidTimeJSON(t *testing.T) {\n+\tvar tt Time\n+\terr := json.Unmarshal([]byte(`{\"now is the time\":\"buddy\"}`), &tt)\n+\t_, isParseErr := err.(*ParseError)\n+\tif !isParseErr {\n+\t\tt.Errorf(\"expected *time.ParseError unmarshaling JSON, got %v\", err)\n+\t}\n+}\n+\n+var notJSONEncodableTimes = []struct {\n+\ttime Time\n+\twant string\n+}{\n+\t{Date(10000, 1, 1, 0, 0, 0, 0, UTC), \"Time.MarshalJSON: year outside of range [0,9999]\"},\n+\t{Date(-1, 1, 1, 0, 0, 0, 0, UTC), \"Time.MarshalJSON: year outside of range [0,9999]\"},\n+}\n+\n+func TestNotJSONEncodableTime(t *testing.T) {\n+\tfor _, tt := range notJSONEncodableTimes {\n+\t\t_, err := tt.time.MarshalJSON()\n+\t\tif err == nil || err.Error() != tt.want {\n+\t\t\tt.Errorf(\"%v MarshalJSON error = %v, want %v\", tt.time, err, tt.want)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkNow(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tNow()"}, {"sha": "540b653c57d22e9977e38c291f3d29ca2c68a0d7", "filename": "libgo/go/time/zoneinfo_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux openbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n // Parse \"zoneinfo\" time zone file.\n // This is a fairly standard file format used on OS X, Linux, BSD, Sun, and others."}, {"sha": "63f48e25693c6a30c58e59366c0485075125aa76", "filename": "libgo/go/websocket/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fwebsocket%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fgo%2Fwebsocket%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fserver.go?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -74,7 +74,7 @@ A trivial example server:\n \t\thttp.Handle(\"/echo\", websocket.Handler(EchoServer));\n \t\terr := http.ListenAndServe(\":12345\", nil);\n \t\tif err != nil {\n-\t\t\tpanic(\"ListenAndServe: \" + err.String())\n+\t\t\tpanic(\"ListenAndServe: \" + err.Error())\n \t\t}\n \t}\n */"}, {"sha": "c8a57ca2816fa64d2f2cda722b837a1bebcc0396", "filename": "libgo/merge.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -168,8 +168,8 @@ for f in $runtime; do\n   merge_c $f $f\n done\n \n-merge_c linux/thread.c thread-linux.c\n-merge_c linux/mem.c mem.c\n+merge_c thread_linux.c thread-linux.c\n+merge_c mem_linux.c mem.c\n \n (cd ${OLDDIR}/src/pkg && find . -name '*.go' -print) | while read f; do\n   oldfile=${OLDDIR}/src/pkg/$f"}, {"sha": "93031ffe253c605630d66604ee48a48bd619e60b", "filename": "libgo/runtime/goc2c.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fgoc2c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fgoc2c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgoc2c.c?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n /*\n  * Translate a .goc file into a .c file.  A .goc file is a combination\n  * of a limited form of Go with C.\n@@ -774,6 +776,7 @@ main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tprintf(\"// AUTO-GENERATED by autogen.sh; DO NOT EDIT\\n\\n\");\n \tprocess_file();\n \texit(0);\n }"}, {"sha": "cdc12d7c75cd9d5002aa7263d91b2c8da8bffae3", "filename": "libgo/runtime/lock_futex.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Flock_futex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Flock_futex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_futex.c?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,17 +2,19 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build freebsd linux\n+\n #include \"runtime.h\"\n \n // This implementation depends on OS-specific implementations of\n //\n-//\truntime.futexsleep(uint32 *addr, uint32 val, int64 ns)\n+//\truntime_futexsleep(uint32 *addr, uint32 val, int64 ns)\n //\t\tAtomically,\n //\t\t\tif(*addr == val) sleep\n //\t\tMight be woken up spuriously; that's allowed.\n //\t\tDon't sleep longer than ns; ns < 0 means forever.\n //\n-//\truntime.futexwakeup(uint32 *addr, uint32 cnt)\n+//\truntime_futexwakeup(uint32 *addr, uint32 cnt)\n //\t\tIf any procs are sleeping on addr, wake up at most cnt.\n \n enum"}, {"sha": "b2a8f53be41e669f2b5643fbbe815a4677e5e2be", "filename": "libgo/runtime/lock_sema.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Flock_sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Flock_sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_sema.c?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -2,21 +2,23 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin netbsd openbsd plan9 windows\n+\n #include \"runtime.h\"\n \n // This implementation depends on OS-specific implementations of\n //\n-//\tuintptr runtime.semacreate(void)\n+//\tuintptr runtime_semacreate(void)\n //\t\tCreate a semaphore, which will be assigned to m->waitsema.\n //\t\tThe zero value is treated as absence of any semaphore,\n //\t\tso be sure to return a non-zero value.\n //\n-//\tint32 runtime.semasleep(int64 ns)\n+//\tint32 runtime_semasleep(int64 ns)\n //\t\tIf ns < 0, acquire m->waitsema and return 0.\n //\t\tIf ns >= 0, try to acquire m->waitsema for at most ns nanoseconds.\n //\t\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n //\n-//\tint32 runtime.semawakeup(M *mp)\n+//\tint32 runtime_semawakeup(M *mp)\n //\t\tWake up mp, which is or will soon be sleeping on mp->waitsema.\n //\n "}, {"sha": "d143d19e5ba61247be12b200b169a65192a888ef", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -12,8 +12,6 @@ package runtime\n #include \"defs.h\"\n #include \"go-type.h\"\n \n-typedef struct __go_open_array Slice;\n-\n // NOTE(rsc): Everything here could use cas if contention became an issue.\n static Lock proflock;\n "}, {"sha": "94113b8db8397fd497e8dcecf94748d26f2f4086", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -196,7 +196,7 @@ enum\n \n /* Macros.  */\n \n-#ifdef __WINDOWS__\n+#ifdef GOOS_windows\n enum {\n    Windows = 1\n };\n@@ -343,7 +343,6 @@ void\truntime_panic(Eface);\n #define runtime_printf printf\n #define runtime_malloc(s) __go_alloc(s)\n #define runtime_free(p) __go_free(p)\n-#define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n #define runtime_strcmp(s1, s2) __builtin_strcmp((s1), (s2))\n #define runtime_mcmp(a, b, s) __builtin_memcmp((a), (b), (s))\n #define runtime_memmove(a, b, s) __builtin_memmove((a), (b), (s))\n@@ -352,9 +351,6 @@ MCache*\truntime_allocmcache(void);\n void\tfree(void *v);\n struct __go_func_type;\n bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *);\n-#define runtime_mmap mmap\n-#define runtime_munmap munmap\n-#define runtime_madvise madvise\n #define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_casp(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_xadd(p, v) __sync_add_and_fetch (p, v)\n@@ -384,6 +380,14 @@ void\truntime_osyield(void);\n void\truntime_LockOSThread(void) __asm__(\"libgo_runtime.runtime.LockOSThread\");\n void\truntime_UnlockOSThread(void) __asm__(\"libgo_runtime.runtime.UnlockOSThread\");\n \n+/*\n+ * low level C-called\n+ */\n+#define runtime_mmap mmap\n+#define runtime_munmap munmap\n+#define runtime_madvise madvise\n+#define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n+\n struct __go_func_type;\n void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n \t\t  void **, void **)"}, {"sha": "486caf09a429244643697e229ef99d0ba24973f1", "filename": "libgo/runtime/string.goc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fstring.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4aa89a5e7acb315655f193e7f549e8d32367e2/libgo%2Fruntime%2Fstring.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstring.goc?ref=df4aa89a5e7acb315655f193e7f549e8d32367e2", "patch": "@@ -4,6 +4,9 @@\n \n package runtime\n #include \"runtime.h\"\n+#include \"arch.h\"\n+#include \"malloc.h\"\n+\n #define charntorune(pv, str, len) __go_get_rune(str, len, pv)\n \n int32"}]}