{"sha": "b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmNzUyNzZkNjM2MWNmYzhjNTY5YzRlY2Q3MTRiMWJmM2E1OTE1Yw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-19T16:01:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-19T16:01:13Z"}, "message": "Kill recombine_givs.\n\nFrom-SVN: r36536", "tree": {"sha": "7ee1dce22cd15981acc9db8c73d9645a964ad3f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ee1dce22cd15981acc9db8c73d9645a964ad3f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/comments", "author": null, "committer": null, "parents": [{"sha": "0f8056066331197225c8790f7223050382ff8419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8056066331197225c8790f7223050382ff8419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8056066331197225c8790f7223050382ff8419"}], "stats": {"total": 1113, "additions": 43, "deletions": 1070}, "files": [{"sha": "4000a6c69867d61f93a02d51cc52fe8ea617fc5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "patch": "@@ -1,3 +1,27 @@\n+2000-09-19  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\tUndo most of the Wed Jan 27 23:39:53 1999 patch:\n+\t* loop.h (struct induction): Delete members derived, ix and last_use.\n+\t(struct loop_ivs): Delete members first_increment_giv and\n+\tlast_increment_giv.\n+\t* loop.c (verify_dominator, find_life_end, cmp_recombine_givs_stats,\n+\trecombine_givs): Delete functions.\n+\t(find_and_verify_loops): Don't initialize cont_dominator.\n+\t(strength_reduce): Lose code to try to find bivs that can be\n+\texpressed as givs of another biv, and to convert biv increments\n+\tinto givs.\n+\tLose loop_scan_start variable, always use loop->scan_start.\n+\tDon't call recombine_givs.  Don't handle derived givs.\n+\t(record_giv): Don't initialize derived and last_use fields.\n+\t(biv_eliminiation_giv_has_0_offset): Lose code to handle derived\n+\tgivs.\n+\t* unroll.c (derived_regs): Delete static variable.\n+\t(unroll_loop): Don't initialize it.\n+\t(copy_loop_body): Lose code to handle derived givs.\n+\t(find_splittable_givs): Don't check for givs made from biv\n+\tincrements.\n+\tDon't set derived_regs.\n+\n 2000-09-19  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \tFix misapplied earlier patch:\n@@ -76,7 +100,7 @@\n \n Mon 18-Sep-2000 22:12:44 BST  Neil Booth  <NeilB@earthling.net>\n \n-        * cpp.texi: Update documentation, including some clarifications,\n+\t* cpp.texi: Update documentation, including some clarifications,\n \tthe treatment of various newline combinations, and space between\n \tbackslash and newline.\n "}, {"sha": "b53b148eadf7986c7d8f2fd87ead2b9cbe888528", "filename": "gcc/loop.c", "status": "modified", "additions": 11, "deletions": 985, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "patch": "@@ -159,7 +159,6 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n-static void verify_dominator PARAMS ((struct loop *));\n static void find_and_verify_loops PARAMS ((rtx, struct loops *));\n static void mark_loop_jump PARAMS ((rtx, struct loop *));\n static void prescan_loop PARAMS ((struct loop *));\n@@ -219,13 +218,8 @@ static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n static int check_dbra_loop PARAMS ((struct loop *, int));\n static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n+static int cmp_combine_givs_stats PARAMS ((const PTR, const PTR));\n static void combine_givs PARAMS ((struct loop_regs *, struct iv_class *));\n-struct recombine_givs_stats;\n-static int find_life_end PARAMS ((const struct loop *, rtx,\n-\t\t\t\t  struct recombine_givs_stats *,\n-\t\t\t\t  rtx, rtx));\n-static void recombine_givs PARAMS ((const struct loop *, struct iv_class *,\n-\t\t\t\t    int));\n static int product_cheap_p PARAMS ((rtx, rtx));\n static int maybe_eliminate_biv PARAMS ((const struct loop *, struct iv_class *,\n \t\t\t\t\tint, int, int));\n@@ -2431,58 +2425,6 @@ prescan_loop (loop)\n     }\n }\n \f\n-/* LOOP->CONT_DOMINATOR is now the last label between the loop start\n-   and the continue note that is a the destination of a (cond)jump after\n-   the continue note.  If there is any (cond)jump between the loop start\n-   and what we have so far as LOOP->CONT_DOMINATOR that has a\n-   target between LOOP->CONT_DOMINATOR and the continue note, move\n-   LOOP->CONT_DOMINATOR forward to that label; if a jump's\n-   destination cannot be determined, clear LOOP->CONT_DOMINATOR.  */\n-\n-static void\n-verify_dominator (loop)\n-     struct loop *loop;\n-{\n-  rtx insn;\n-\n-  if (! loop->cont_dominator)\n-    /* This can happen for an empty loop, e.g. in\n-       gcc.c-torture/compile/920410-2.c  */\n-    return;\n-  if (loop->cont_dominator == const0_rtx)\n-    {\n-      loop->cont_dominator = 0;\n-      return;\n-    }\n-  for (insn = loop->start; insn != loop->cont_dominator;\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == JUMP_INSN\n-\t  && GET_CODE (PATTERN (insn)) != RETURN)\n-\t{\n-\t  rtx label = JUMP_LABEL (insn);\n-\t  int label_luid;\n-\n-\t  /* If it is not a jump we can easily understand or for\n-\t     which we do not have jump target information in the JUMP_LABEL\n-\t     field (consider ADDR_VEC and ADDR_DIFF_VEC insns), then clear\n-\t     LOOP->CONT_DOMINATOR.  */\n-\t  if (! any_condjump_p (insn)\n-\t      || label == NULL_RTX)\n-\t    {\n-\t      loop->cont_dominator = NULL_RTX;\n-\t      return;\n-\t    }\n-\n-\t  label_luid = INSN_LUID (label);\n-\t  if (label_luid < INSN_LUID (loop->cont)\n-\t      && (label_luid\n-\t\t  > INSN_LUID (loop->cont)))\n-\t    loop->cont_dominator = label;\n-\t}\n-    }\n-}\n-\n /* Scan the function looking for loops.  Record the start and end of each loop.\n    Also mark as invalid loops any loops that contain a setjmp or are branched\n    to from outside the loop.  */\n@@ -2553,51 +2495,12 @@ find_and_verify_loops (f, loops)\n \t      abort ();\n \n \t    current_loop->end = insn;\n-\t    verify_dominator (current_loop);\n \t    current_loop = current_loop->outer;\n \t    break;\n \n \t  default:\n \t    break;\n \t  }\n-      /* If for any loop, this is a jump insn between the NOTE_INSN_LOOP_CONT\n-\t and NOTE_INSN_LOOP_END notes, update loop->cont_dominator.  */\n-      else if (GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (PATTERN (insn)) != RETURN\n-\t       && current_loop)\n-\t{\n-\t  rtx label = JUMP_LABEL (insn);\n-\n-\t  if (! any_condjump_p (insn))\n-\t    label = NULL_RTX;\n-\n-\t  loop = current_loop;\n-\t  do\n-\t    {\n-\t      /* First see if we care about this loop.  */\n-\t      if (loop->cont && loop->cont_dominator != const0_rtx)\n-\t\t{\n-\t\t  /* If the jump destination is not known, invalidate\n-\t\t     loop->cont_dominator.  */\n-\t\t  if (! label)\n-\t\t    loop->cont_dominator = const0_rtx;\n-\t\t  else\n-\t\t    /* Check if the destination is between loop start and\n-\t\t       cont.  */\n-\t\t    if ((INSN_LUID (label)\n-\t\t\t < INSN_LUID (loop->cont))\n-\t\t\t&& (INSN_LUID (label) > INSN_LUID (loop->start))\n-\t\t\t/* And if there is no later destination already\n-\t\t\t   recorded.  */\n-\t\t\t&& (! loop->cont_dominator\n-\t\t\t    || (INSN_LUID (label)\n-\t\t\t\t> INSN_LUID (loop->cont_dominator))))\n-\t\t      loop->cont_dominator = label;\n-\t\t}\n-\t      loop = loop->outer;\n-\t    }\n-\t  while (loop);\n-\t}\n \n       /* Note that this will mark the NOTE_INSN_LOOP_END note as being in the\n \t enclosing loop, but this doesn't matter.  */\n@@ -3750,11 +3653,9 @@ strength_reduce (loop, insn_count, flags)\n   int call_seen;\n   rtx test;\n   rtx end_insert_before;\n-  int n_extra_increment;\n   int unrolled_insn_copies = 0;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  rtx loop_scan_start = loop->scan_start;\n   rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n   VARRAY_INT_INIT (ivs->reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n@@ -3907,362 +3808,12 @@ strength_reduce (loop, insn_count, flags)\n \t\t}\n \t    }\n \t}\n-      else\n-\t{\n-\t  struct iv_class *bl2 = 0;\n-\t  rtx increment = NULL_RTX;\n-\n-\t  /* Biv initial value is not a simple move.  If it is the sum of\n-\t     another biv and a constant, check if both bivs are incremented\n-\t     in lockstep.  Then we are actually looking at a giv.\n-\t     For simplicity, we only handle the case where there is but a\n-\t     single increment, and the register is not used elsewhere.  */\n-\t  if (bl->biv_count == 1\n-\t      && bl->regno < max_reg_before_loop\n-\t      && uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n-\t      && GET_CODE (src) == PLUS\n-\t      && GET_CODE (XEXP (src, 0)) == REG\n-\t      && CONSTANT_P (XEXP (src, 1))\n-\t      && ((increment = biv_total_increment (bl)) != NULL_RTX))\n-\t    {\n-\t      unsigned int regno = REGNO (XEXP (src, 0));\n-\n-\t      for (bl2 = ivs->loop_iv_list; bl2; bl2 = bl2->next)\n-\t\tif (bl2->regno == regno)\n-\t\t  break;\n-\t    }\n-\n-\t  /* Now, can we transform this biv into a giv?  */\n-\t  if (bl2\n-\t      && bl2->biv_count == 1\n-\t      && rtx_equal_p (increment, biv_total_increment (bl2))\n-\t      /* init_insn is only set to insns that are before loop_start\n-\t\t without any intervening labels.  */\n-\t      && ! reg_set_between_p (bl2->biv->src_reg,\n-\t\t\t\t      PREV_INSN (bl->init_insn), loop_start)\n-\t      /* The register from BL2 must be set before the register from\n-\t\t BL is set, or we must be able to move the latter set after\n-\t\t the former set.  Currently there can't be any labels\n-\t         in-between when biv_total_increment returns nonzero both times\n-\t\t but we test it here in case some day some real cfg analysis\n-\t\t gets used to set always_computable.  */\n-\t      && (loop_insn_first_p (bl2->biv->insn, bl->biv->insn)\n-\t\t  ? no_labels_between_p (bl2->biv->insn, bl->biv->insn)\n-\t\t  : (! reg_used_between_p (bl->biv->src_reg, bl->biv->insn,\n-\t\t\t\t\t   bl2->biv->insn)\n-\t\t     && no_jumps_between_p (bl->biv->insn, bl2->biv->insn)))\n-\t      && validate_change (bl->biv->insn,\n-\t\t\t\t  &SET_SRC (single_set (bl->biv->insn)),\n-\t\t\t\t  copy_rtx (src), 0))\n-\t    {\n-\t      rtx dominator = loop->cont_dominator;\n-\t      rtx giv = bl->biv->src_reg;\n-\t      rtx giv_insn = bl->biv->insn;\n-\t      rtx after_giv = NEXT_INSN (giv_insn);\n-\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream, \"is giv of biv %d\\n\", bl2->regno);\n-\t      /* Let this giv be discovered by the generic code.  */\n-\t      REG_IV_TYPE (ivs, bl->regno) = UNKNOWN_INDUCT;\n-\t      ivs->reg_biv_class[bl->regno] = (struct iv_class *) NULL_PTR;\n-\t      /* We can get better optimization if we can move the giv setting\n-\t\t before the first giv use.  */\n-\t      if (dominator\n-\t\t  && ! loop_insn_first_p (dominator, loop_scan_start)\n-\t\t  && ! reg_set_between_p (bl2->biv->src_reg, loop_start,\n-\t\t\t\t\t  dominator)\n-\t\t  && ! reg_used_between_p (giv, loop_start, dominator)\n-\t\t  && ! reg_used_between_p (giv, giv_insn, loop_end))\n-\t\t{\n-\t\t  rtx p;\n-\t\t  rtx next;\n-\n-\t\t  for (next = NEXT_INSN (dominator);; next = NEXT_INSN (next))\n-\t\t    {\n-\t\t      if (GET_CODE (next) == JUMP_INSN\n-\t\t\t  || (INSN_P (next)\n-\t\t\t      && insn_dependent_p (giv_insn, next)))\n-\t\t\tbreak;\n-#ifdef HAVE_cc0\n-\t\t      if (! INSN_P (next) || ! sets_cc0_p (PATTERN (next)))\n-#endif\n-\t\t\tdominator = next;\n-\t\t    }\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream, \"move after insn %d\\n\",\n-\t\t\t     INSN_UID (dominator));\n-\t\t  /* Avoid problems with luids by actually moving the insn\n-\t\t     and adjusting all luids in the range.  */\n-\t\t  reorder_insns (giv_insn, giv_insn, dominator);\n-\t\t  for (p = dominator; INSN_UID (p) >= max_uid_for_loop;)\n-\t\t    p = PREV_INSN (p);\n-\t\t  compute_luids (giv_insn, after_giv, INSN_LUID (p));\n-\t\t  /* If the only purpose of the init insn is to initialize\n-\t\t     this giv, delete it.  */\n-\t\t  if (single_set (bl->init_insn)\n-\t\t      && ! reg_used_between_p (giv, bl->init_insn, loop_start))\n-\t\t    delete_insn (bl->init_insn);\n-\t\t}\n-\t      else if (! loop_insn_first_p (bl2->biv->insn, bl->biv->insn))\n-\t\t{\n-\t\t  rtx p = PREV_INSN (giv_insn);\n-\t\t  while (INSN_UID (p) >= max_uid_for_loop)\n-\t\t    p = PREV_INSN (p);\n-\t\t  reorder_insns (giv_insn, giv_insn, bl2->biv->insn);\n-\t\t  compute_luids (after_giv, NEXT_INSN (giv_insn),\n-\t\t\t\t INSN_LUID (p));\n-\t\t}\n-\t      /* Remove this biv from the chain.  */\n-\t      *backbl = bl->next;\n-\t    }\n-\n-\t  /* If we can't make it a giv,\n-\t     let biv keep initial value of \"itself\".  */\n-\t  else if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"is complex\\n\");\n-\t}\n+      /* If we can't make it a giv,\n+       let biv keep initial value of \"itself\".  */\n+      else if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"is complex\\n\");\n     }\n \n-  /* If a biv is unconditionally incremented several times in a row, convert\n-     all but the last increment into a giv.  */\n-\n-  /* Get an upper bound for the number of registers\n-     we might have after all bivs have been processed.  */\n-  ivs->first_increment_giv = max_reg_num ();\n-  for (n_extra_increment = 0, bl = ivs->loop_iv_list; bl; bl = bl->next)\n-    n_extra_increment += bl->biv_count - 1;\n-\n-  /* If the loop contains volatile memory references do not allow any\n-     replacements to take place, since this could loose the volatile\n-     markers.  */\n-  if (n_extra_increment  && ! loop_info->has_volatile)\n-    {\n-      unsigned int nregs = ivs->first_increment_giv + n_extra_increment;\n-\n-      /* Reallocate ivs->reg_iv_type and ivs->reg_iv_info.  */\n-      VARRAY_GROW (ivs->reg_iv_type, nregs);\n-      VARRAY_GROW (ivs->reg_iv_info, nregs);\n-\n-      for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n-\t{\n-\t  struct induction **vp, *v, *next;\n-\t  int biv_dead_after_loop = 0;\n-\n-\t  /* The biv increments lists are in reverse order.  Fix this\n-             first.  */\n-\t  for (v = bl->biv, bl->biv = 0; v; v = next)\n-\t    {\n-\t      next = v->next_iv;\n-\t      v->next_iv = bl->biv;\n-\t      bl->biv = v;\n-\t    }\n-\n-\t  /* We must guard against the case that an early exit between v->insn\n-\t     and next->insn leaves the biv live after the loop, since that\n-\t     would mean that we'd be missing an increment for the final\n-\t     value.  The following test to set biv_dead_after_loop is like\n-\t     the first part of the test to set bl->eliminable.\n-\t     We don't check here if we can calculate the final value, since\n-\t     this can't succeed if we already know that there is a jump\n-\t     between v->insn and next->insn, yet next->always_executed is\n-\t     set and next->maybe_multiple is cleared.  Such a combination\n-\t     implies that the jump destination is outside the loop.\n-\t     If we want to make this check more sophisticated, we should\n-\t     check each branch between v->insn and next->insn individually\n-\t     to see if the biv is dead at its destination.  */\n-\n-\t  if (uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n-\t      && bl->init_insn\n-\t      && INSN_UID (bl->init_insn) < max_uid_for_loop\n-\t      && (uid_luid[REGNO_FIRST_UID (bl->regno)]\n-\t\t  >= INSN_LUID (bl->init_insn))\n-#ifdef HAVE_decrement_and_branch_until_zero\n-\t      && ! bl->nonneg\n-#endif\n-\t      && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t    biv_dead_after_loop = 1;\n-\n-\t  for (vp = &bl->biv, next = *vp; v = next, next = v->next_iv;)\n-\t    {\n-\t      HOST_WIDE_INT offset;\n-\t      rtx set, add_val, old_reg, dest_reg, last_use_insn, note;\n-\t      int old_regno, new_regno;\n-\t      rtx next_loc_insn;\n-\n-\t      if (! v->always_executed\n-\t\t  || v->maybe_multiple\n-\t\t  || GET_CODE (v->add_val) != CONST_INT\n-\t\t  || ! next->always_executed\n-\t\t  || next->maybe_multiple\n-\t\t  || ! CONSTANT_P (next->add_val)\n-\t\t  || v->mult_val != const1_rtx\n-\t\t  || next->mult_val != const1_rtx\n-\t\t  || ! (biv_dead_after_loop\n-\t\t\t|| no_jumps_between_p (v->insn, next->insn)))\n-\t\t{\n-\t\t  vp = &v->next_iv;\n-\t\t  continue;\n-\t\t}\n-\t      offset = INTVAL (v->add_val);\n-\t      set = single_set (v->insn);\n-\t      add_val = plus_constant (next->add_val, offset);\n-\t      old_reg = v->dest_reg;\n-\t      dest_reg = gen_reg_rtx (v->mode);\n-\n-\t      /* Unlike ivs->reg_iv_type / ivs->reg_iv_info, the other\n-\t\t three arrays have been allocated with some slop\n-\t\t space, so we may not actually need to reallocate\n-\t\t them.  If we do, the following if statement will be\n-\t\t executed just once in this loop.  */\n-\t      if ((unsigned) max_reg_num () > regs->n_times_set->num_elements)\n-\t\t{\n-\t\t  /* Grow all the remaining arrays.  */\n-\t\t  VARRAY_GROW (regs->set_in_loop, nregs);\n-\t\t  VARRAY_GROW (regs->n_times_set, nregs);\n-\t\t  VARRAY_GROW (regs->may_not_optimize, nregs);\n-\t\t  VARRAY_GROW (regs->single_usage, nregs);\n-\t\t}\n-\n-\t      /* Some bivs are incremented with a multi-insn sequence.\n-\t\t The first insn contains the add.  */\n-\t      next_loc_insn = next->insn;\n-\t      while (NOTE_P (next_loc_insn)\n-\t\t     || ! loc_mentioned_in_p (next->location,\n-\t\t\t\t\t      PATTERN (next_loc_insn)))\n-\t\tnext_loc_insn = PREV_INSN (next_loc_insn);\n-\n-\t      if (next_loc_insn == v->insn)\n-\t\tabort ();\n-\n-\t      if (! validate_change (next_loc_insn, next->location, add_val, 0))\n-\t\t{\n-\t\t  vp = &v->next_iv;\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Here we can try to eliminate the increment by combining\n-\t\t it into the uses.  */\n-\n-\t      /* Set last_use_insn so that we can check against it.  */\n-\n-\t      for (last_use_insn = v->insn, p = NEXT_INSN (v->insn);\n-\t\t   p != next_loc_insn;\n-\t\t   p = next_insn_in_loop (loop, p))\n-\t\t{\n-\t\t  if (!INSN_P (p))\n-\t\t    continue;\n-\t\t  if (reg_mentioned_p (old_reg, PATTERN (p)))\n-\t\t    {\n-\t\t      last_use_insn = p;\n-\t\t    }\n-\t\t}\n-\n-\t      /* If we can't get the LUIDs for the insns, we can't\n-\t\t calculate the lifetime.  This is likely from unrolling\n-\t\t of an inner loop, so there is little point in making this\n-\t\t a DEST_REG giv anyways.  */\n-\t      if (INSN_UID (v->insn) >= max_uid_for_loop\n-\t\t  || INSN_UID (last_use_insn) >= max_uid_for_loop\n-\t\t  || ! validate_change (v->insn, &SET_DEST (set), dest_reg, 0))\n-\t\t{\n-\t\t  /* Change the increment at NEXT back to what it was.  */\n-\t\t  if (! validate_change (next_loc_insn, next->location,\n-\t\t      next->add_val, 0))\n-\t\t    abort ();\n-\t\t  vp = &v->next_iv;\n-\t\t  continue;\n-\t\t}\n-\t      next->add_val = add_val;\n-\t      v->dest_reg = dest_reg;\n-\t      v->giv_type = DEST_REG;\n-\t      v->location = &SET_SRC (set);\n-\t      v->cant_derive = 0;\n-\t      v->combined_with = 0;\n-\t      v->maybe_dead = 0;\n-\t      v->derive_adjustment = 0;\n-\t      v->same = 0;\n-\t      v->ignore = 0;\n-\t      v->new_reg = 0;\n-\t      v->final_value = 0;\n-\t      v->same_insn = 0;\n-\t      v->auto_inc_opt = 0;\n-\t      v->unrolled = 0;\n-\t      v->shared = 0;\n-\t      v->derived_from = 0;\n-\t      v->always_computable = 1;\n-\t      v->always_executed = 1;\n-\t      v->replaceable = 1;\n-\t      v->no_const_addval = 0;\n-\n-\t      old_regno = REGNO (old_reg);\n-\t      new_regno = REGNO (dest_reg);\n-\t      VARRAY_INT (regs->set_in_loop, old_regno)--;\n-\t      VARRAY_INT (regs->set_in_loop, new_regno) = 1;\n-\t      VARRAY_INT (regs->n_times_set, old_regno)--;\n-\t      VARRAY_INT (regs->n_times_set, new_regno) = 1;\n-\t      VARRAY_CHAR (regs->may_not_optimize, new_regno) = 0;\n-\n-\t      REG_IV_TYPE (ivs, new_regno) = GENERAL_INDUCT;\n-\t      REG_IV_INFO (ivs, new_regno) = v;\n-\n-\t      /* If next_insn has a REG_EQUAL note that mentiones OLD_REG,\n-\t\t it must be replaced.  */\n-\t      note = find_reg_note (next->insn, REG_EQUAL, NULL_RTX);\n-\t      if (note && reg_mentioned_p (old_reg, XEXP (note, 0)))\n-\t\tXEXP (note, 0) = copy_rtx (SET_SRC (single_set (next->insn)));\n-\n-\t      /* Remove the increment from the list of biv increments,\n-\t\t and record it as a giv.  */\n-\t      *vp = next;\n-\t      bl->biv_count--;\n-\t      v->next_iv = bl->giv;\n-\t      bl->giv = v;\n-\t      bl->giv_count++;\n-\t      v->benefit = rtx_cost (SET_SRC (set), SET);\n-\t      bl->total_benefit += v->benefit;\n-\n-\t      /* Now replace the biv with DEST_REG in all insns between\n-\t\t the replaced increment and the next increment, and\n-\t\t remember the last insn that needed a replacement.  */\n-\t      for (last_use_insn = v->insn, p = NEXT_INSN (v->insn);\n-\t\t   p != next_loc_insn;\n-\t\t   p = next_insn_in_loop (loop, p))\n-\t\t{\n-\t\t  rtx note;\n-\n-\t\t  if (! INSN_P (p))\n-\t\t    continue;\n-\t\t  if (reg_mentioned_p (old_reg, PATTERN (p)))\n-\t\t    {\n-\t\t      last_use_insn = p;\n-\t\t      if (! validate_replace_rtx (old_reg, dest_reg, p))\n-\t\t\tabort ();\n-\t\t    }\n-\t\t  for (note = REG_NOTES (p); note; note = XEXP (note, 1))\n-\t\t    {\n-\t\t      if (GET_CODE (note) == EXPR_LIST)\n-\t\t\tXEXP (note, 0)\n-\t\t\t  = replace_rtx (XEXP (note, 0), old_reg, dest_reg);\n-\t\t    }\n-\t\t}\n-\n-\t      v->last_use = last_use_insn;\n-\t      v->lifetime = INSN_LUID (last_use_insn) - INSN_LUID (v->insn);\n-\t      /* If the lifetime is zero, it means that this register is really\n-\t\t a dead store.  So mark this as a giv that can be ignored.\n-\t\t This will not prevent the biv from being eliminated.  */\n-\t      if (v->lifetime == 0)\n-\t\tv->ignore = 1;\n-\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n-\t\t\t \"Increment %d of biv %d converted to giv %d.\\n\\n\",\n-\t\t\t INSN_UID (v->insn), old_regno, new_regno);\n-\t    }\n-\t}\n-    }\n-  ivs->last_increment_giv = max_reg_num () - 1;\n-\n   /* Search the loop for general induction variables.  */\n \n   for_each_insn_in_loop (loop, check_insn_for_givs);\n@@ -4308,7 +3859,6 @@ strength_reduce (loop, insn_count, flags)\n       int benefit;\n       int all_reduced;\n       rtx final_value = 0;\n-      unsigned int nregs;\n \n       /* Test whether it will be possible to eliminate this biv\n \t provided all givs are reduced.  This is possible if either\n@@ -4487,16 +4037,8 @@ strength_reduce (loop, insn_count, flags)\n \t      || (v->same && v->same->ignore))\n \t    continue;\n \n-\t  if (v->last_use)\n-\t    {\n-\t      struct induction *v1;\n-\n-\t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n-\t\tif (v->last_use == v1->insn)\n-\t\t  v->maybe_dead = 1;\n-\t    }\n-\t  else if (v->giv_type == DEST_REG\n-\t\t   && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n+\t  if (v->giv_type == DEST_REG\n+\t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n \t    {\n \t      struct induction *v1;\n \n@@ -4506,25 +4048,6 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t}\n \n-      /* Now that we know which givs will be reduced, try to rearrange the\n-         combinations to reduce register pressure.\n-         recombine_givs calls find_life_end, which needs ivs->reg_iv_type and\n-\t ivs->reg_iv_info to be valid for all pseudos.  We do the necessary\n-\t reallocation here since it allows to check if there are still\n-\t more bivs to process.  */\n-      nregs = max_reg_num ();\n-      if (nregs > ivs->reg_iv_type->num_elements)\n-\t{\n-\t  /* If there are still more bivs to process, allocate some slack\n-\t     space so that we're not constantly reallocating these arrays.  */\n-\t  if (bl->next)\n-\t    nregs += nregs / 4;\n-\t  /* Reallocate ivs->reg_iv_type and ivs->reg_iv_info.  */\n-\t  VARRAY_GROW (ivs->reg_iv_type, nregs);\n-\t  VARRAY_GROW (ivs->reg_iv_info, nregs);\n-\t}\n-      recombine_givs (loop, bl, flags & LOOP_UNROLL);\n-\n       /* Reduce each giv that we decided to reduce.  */\n \n       for (v = bl->giv; v; v = v->next_iv)\n@@ -4539,45 +4062,6 @@ strength_reduce (loop, insn_count, flags)\n \t      if (! v->new_reg)\n \t\tv->new_reg = gen_reg_rtx (v->mode);\n \n-\t      if (v->derived_from)\n-\t\t{\n-\t\t  struct induction *d = v->derived_from;\n-\n-\t\t  /* In case d->dest_reg is not replaceable, we have\n-\t\t     to replace it in v->insn now.  */\n-\t\t  if (! d->new_reg)\n-\t\t    d->new_reg = gen_reg_rtx (d->mode);\n-\t\t  PATTERN (v->insn)\n-\t\t    = replace_rtx (PATTERN (v->insn), d->dest_reg, d->new_reg);\n-\t\t  PATTERN (v->insn)\n-\t\t    = replace_rtx (PATTERN (v->insn), v->dest_reg, v->new_reg);\n-\t\t  /* For each place where the biv is incremented, add an\n-\t\t     insn to set the new, reduced reg for the giv.\n-\t\t     We used to do this only for biv_count != 1, but\n-\t\t     this fails when there is a giv after a single biv\n-\t\t     increment, e.g. when the last giv was expressed as\n-\t\t     pre-decrement.  */\n-\t\t  for (tv = bl->biv; tv; tv = tv->next_iv)\n-\t\t    {\n-\t\t      /* We always emit reduced giv increments before the\n-\t\t\t biv increment when bl->biv_count != 1.  So by\n-\t\t\t emitting the add insns for derived givs after the\n-\t\t\t biv increment, they pick up the updated value of\n-\t\t\t the reduced giv.\n-\t\t\t If the reduced giv is processed with\n-\t\t\t auto_inc_opt == 1, then it is incremented earlier\n-\t\t\t than the biv, hence we'll still pick up the right\n-\t\t\t value.\n-\t\t\t If it's processed with auto_inc_opt == -1,\n-\t\t\t that implies that the biv increment is before the\n-\t\t\t first reduced giv's use.  The derived giv's lifetime\n-\t\t\t is after the reduced giv's lifetime, hence in this\n-\t\t\t case, the biv increment doesn't matter.  */\n-\t\t      emit_insn_after (copy_rtx (PATTERN (v->insn)), tv->insn);\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n-\n #ifdef AUTO_INC_DEC\n \t      /* If the target has auto-increment addressing modes, and\n \t\t this is an address giv, then try to put the increment\n@@ -4625,11 +4109,11 @@ strength_reduce (loop, insn_count, flags)\n \t\t  /* Check for case where increment is before the address\n \t\t     giv.  Do this test in \"loop order\".  */\n \t\t  else if ((INSN_LUID (v->insn) > INSN_LUID (bl->biv->insn)\n-\t\t\t    && (INSN_LUID (v->insn) < INSN_LUID (loop_scan_start)\n+\t\t\t    && (INSN_LUID (v->insn) < INSN_LUID (loop->scan_start)\n \t\t\t\t|| (INSN_LUID (bl->biv->insn)\n-\t\t\t\t    > INSN_LUID (loop_scan_start))))\n-\t\t\t   || (INSN_LUID (v->insn) < INSN_LUID (loop_scan_start)\n-\t\t\t       && (INSN_LUID (loop_scan_start)\n+\t\t\t\t    > INSN_LUID (loop->scan_start))))\n+\t\t\t   || (INSN_LUID (v->insn) < INSN_LUID (loop->scan_start)\n+\t\t\t       && (INSN_LUID (loop->scan_start)\n \t\t\t\t   < INSN_LUID (bl->biv->insn))))\n \t\t    auto_inc_opt = -1;\n \t\t  else\n@@ -5364,8 +4848,6 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n   v->auto_inc_opt = 0;\n   v->unrolled = 0;\n   v->shared = 0;\n-  v->derived_from = 0;\n-  v->last_use = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n      determine whether a giv can be used to derive another giv.  For a\n@@ -6157,8 +5639,6 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n \n static rtx sge_plus PARAMS ((enum machine_mode, rtx, rtx));\n static rtx sge_plus_constant PARAMS ((rtx, rtx));\n-static int cmp_combine_givs_stats PARAMS ((const PTR, const PTR));\n-static int cmp_recombine_givs_stats PARAMS ((const PTR, const PTR));\n \n static rtx\n simplify_giv_expr (loop, x, ext_val, benefit)\n@@ -7373,444 +6853,6 @@ combine_givs (regs, bl)\n   free (can_combine);\n }\n \f\n-struct recombine_givs_stats\n-{\n-  int giv_number;\n-  int start_luid, end_luid;\n-};\n-\n-/* Used below as comparison function for qsort.  We want a ascending luid\n-   when scanning the array starting at the end, thus the arguments are\n-   used in reverse.  */\n-static int\n-cmp_recombine_givs_stats (xp, yp)\n-     const PTR xp;\n-     const PTR yp;\n-{\n-  const struct recombine_givs_stats * const x =\n-    (const struct recombine_givs_stats *) xp;\n-  const struct recombine_givs_stats * const y =\n-    (const struct recombine_givs_stats *) yp;\n-  int d;\n-  d = y->start_luid - x->start_luid;\n-  /* Stabilize the sort.  */\n-  if (!d)\n-    d = y->giv_number - x->giv_number;\n-  return d;\n-}\n-\n-/* Scan X, which is a part of INSN, for the end of life of a giv.  Also\n-   look for the start of life of a giv where the start has not been seen\n-   yet to unlock the search for the end of its life.\n-   Only consider givs that belong to BIV.\n-   Return the total number of lifetime ends that have been found.  */\n-static int\n-find_life_end (loop, x, stats, insn, biv)\n-     const struct loop *loop;\n-     rtx x, insn, biv;\n-     struct recombine_givs_stats *stats;\n-{\n-  struct loop_ivs *ivs = LOOP_IVS (loop);\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-  int retval;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case SET:\n-      {\n-\trtx reg = SET_DEST (x);\n-\tif (GET_CODE (reg) == REG)\n-\t  {\n-\t    int regno = REGNO (reg);\n-\t    struct induction *v = REG_IV_INFO (ivs, regno);\n-\n-\t    if (REG_IV_TYPE (ivs, regno) == GENERAL_INDUCT\n-\t\t&& ! v->ignore\n-\t\t&& v->src_reg == biv\n-\t\t&& stats[v->ix].end_luid <= 0)\n-\t      {\n-\t\t/* If we see a 0 here for end_luid, it means that we have\n-\t\t   scanned the entire loop without finding any use at all.\n-\t\t   We must not predicate this code on a start_luid match\n-\t\t   since that would make the test fail for givs that have\n-\t\t   been hoisted out of inner loops.  */\n-\t\tif (stats[v->ix].end_luid == 0)\n-\t\t  {\n-\t\t    stats[v->ix].end_luid = stats[v->ix].start_luid;\n-\t\t    return 1 + find_life_end (loop, SET_SRC (x), stats,\n-\t\t\t\t\t      insn, biv);\n-\t\t  }\n-\t\telse if (stats[v->ix].start_luid == INSN_LUID (insn))\n-\t\t  stats[v->ix].end_luid = 0;\n-\t      }\n-\t    return find_life_end (loop, SET_SRC (x), stats, insn, biv);\n-\t  }\n-\tbreak;\n-      }\n-    case REG:\n-      {\n-\tint regno = REGNO (x);\n-\tstruct induction *v = REG_IV_INFO (ivs, regno);\n-\n-\tif (REG_IV_TYPE (ivs, regno) == GENERAL_INDUCT\n-\t    && ! v->ignore\n-\t    && v->src_reg == biv\n-\t    && stats[v->ix].end_luid == 0)\n-\t  {\n-\t    while (INSN_UID (insn) >= max_uid_for_loop)\n-\t      insn = NEXT_INSN (insn);\n-\t    stats[v->ix].end_luid = INSN_LUID (insn);\n-\t    return 1;\n-\t  }\n-\treturn 0;\n-      }\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-    case CONST_INT:\n-    case CONST:\n-      return 0;\n-    default:\n-      break;\n-    }\n-  fmt = GET_RTX_FORMAT (code);\n-  retval = 0;\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tretval += find_life_end (loop, XEXP (x, i), stats, insn, biv);\n-\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  retval += find_life_end (loop, XVECEXP (x, i, j), stats, insn, biv);\n-    }\n-  return retval;\n-}\n-\n-/* For each giv that has been combined with another, look if\n-   we can combine it with the most recently used one instead.\n-   This tends to shorten giv lifetimes, and helps the next step:\n-   try to derive givs from other givs.  */\n-static void\n-recombine_givs (loop, bl, unroll_p)\n-     const struct loop *loop;\n-     struct iv_class *bl;\n-     int unroll_p;\n-{\n-  struct loop_regs *regs = LOOP_REGS (loop);\n-  struct induction *v, **giv_array, *last_giv;\n-  struct recombine_givs_stats *stats;\n-  int giv_count;\n-  int i, rescan;\n-  int ends_need_computing;\n-\n-  for (giv_count = 0, v = bl->giv; v; v = v->next_iv)\n-    {\n-      if (! v->ignore)\n-\tgiv_count++;\n-    }\n-  giv_array\n-    = (struct induction **) xmalloc (giv_count * sizeof (struct induction *));\n-  stats = (struct recombine_givs_stats *) xmalloc (giv_count * sizeof *stats);\n-\n-  /* Initialize stats and set up the ix field for each giv in stats to name\n-     the corresponding index into stats.  */\n-  for (i = 0, v = bl->giv; v; v = v->next_iv)\n-    {\n-      rtx p;\n-\n-      if (v->ignore)\n-\tcontinue;\n-      giv_array[i] = v;\n-      stats[i].giv_number = i;\n-      /* If this giv has been hoisted out of an inner loop, use the luid of\n-\t the previous insn.  */\n-      for (p = v->insn; INSN_UID (p) >= max_uid_for_loop; )\n-\tp = PREV_INSN (p);\n-      stats[i].start_luid = INSN_LUID (p);\n-      i++;\n-    }\n-\n-  qsort (stats, giv_count, sizeof (*stats), cmp_recombine_givs_stats);\n-\n-  /* Set up the ix field for each giv in stats to name\n-     the corresponding index into stats, and\n-     do the actual most-recently-used recombination.  */\n-  for (last_giv = 0, i = giv_count - 1; i >= 0; i--)\n-    {\n-      v = giv_array[stats[i].giv_number];\n-      v->ix = i;\n-      if (v->same)\n-\t{\n-\t  struct induction *old_same = v->same;\n-\t  rtx new_combine;\n-\n-\t  /* combine_givs_p actually says if we can make this transformation.\n-\t     The other tests are here only to avoid keeping a giv alive\n-\t     that could otherwise be eliminated.  */\n-\t  if (last_giv\n-\t      && ((old_same->maybe_dead && ! old_same->combined_with)\n-\t\t  || ! last_giv->maybe_dead\n-\t\t  || last_giv->combined_with)\n-\t      && (new_combine = combine_givs_p (last_giv, v)))\n-\t    {\n-\t      old_same->combined_with--;\n-\t      v->new_reg = new_combine;\n-\t      v->same = last_giv;\n-\t      last_giv->combined_with++;\n-\t      /* No need to update lifetimes / benefits here since we have\n-\t\t already decided what to reduce.  */\n-\n-\t      if (loop_dump_stream)\n-\t\t{\n-\t\t  fprintf (loop_dump_stream,\n-\t\t\t   \"giv at %d recombined with giv at %d as \",\n-\t\t\t   INSN_UID (v->insn), INSN_UID (last_giv->insn));\n-\t\t  print_rtl (loop_dump_stream, v->new_reg);\n-\t\t  putc ('\\n', loop_dump_stream);\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  v = v->same;\n-\t}\n-      else if (v->giv_type != DEST_REG)\n-\tcontinue;\n-      if (! last_giv\n-\t  || (last_giv->maybe_dead && ! last_giv->combined_with)\n-\t  || ! v->maybe_dead\n-\t  || v->combined_with)\n-\tlast_giv = v;\n-    }\n-\n-  ends_need_computing = 0;\n-  /* For each DEST_REG giv, compute lifetime starts, and try to compute\n-     lifetime ends from regscan info.  */\n-  for (i = giv_count - 1; i >= 0; i--)\n-    {\n-      v = giv_array[stats[i].giv_number];\n-      if (v->ignore)\n-\tcontinue;\n-      if (v->giv_type == DEST_ADDR)\n-\t{\n-\t  /* Loop unrolling of an inner loop can even create new DEST_REG\n-\t     givs.  */\n-\t  rtx p;\n-\t  for (p = v->insn; INSN_UID (p) >= max_uid_for_loop;)\n-\t    p = PREV_INSN (p);\n-\t  stats[i].start_luid = stats[i].end_luid = INSN_LUID (p);\n-\t  if (p != v->insn)\n-\t    stats[i].end_luid++;\n-\t}\n-      else /* v->giv_type == DEST_REG */\n-\t{\n-\t  if (v->last_use)\n-\t    {\n-\t      stats[i].start_luid = INSN_LUID (v->insn);\n-\t      stats[i].end_luid = INSN_LUID (v->last_use);\n-\t    }\n-\t  else if (INSN_UID (v->insn) >= max_uid_for_loop)\n-\t    {\n-\t      rtx p;\n-\t      /* This insn has been created by loop optimization on an inner\n-\t\t loop.  We don't have a proper start_luid that will match\n-\t\t when we see the first set.  But we do know that there will\n-\t\t be no use before the set, so we can set end_luid to 0 so that\n-\t\t we'll start looking for the last use right away.  */\n-\t      for (p = PREV_INSN (v->insn); INSN_UID (p) >= max_uid_for_loop; )\n-\t\tp = PREV_INSN (p);\n-\t      stats[i].start_luid = INSN_LUID (p);\n-\t      stats[i].end_luid = 0;\n-\t      ends_need_computing++;\n-\t    }\n-\t  else\n-\t    {\n-\t      int regno = REGNO (v->dest_reg);\n-\t      int count = VARRAY_INT (regs->n_times_set, regno) - 1;\n-\t      rtx p = v->insn;\n-\n-\t      /* Find the first insn that sets the giv, so that we can verify\n-\t\t if this giv's lifetime wraps around the loop.  We also need\n-\t\t the luid of the first setting insn in order to detect the\n-\t\t last use properly.  */\n-\t      while (count)\n-\t\t{\n-\t\t  p = prev_nonnote_insn (p);\n-\t\t  if (reg_set_p (v->dest_reg, p))\n-\t\t    count--;\n-\t\t}\n-\n-\t      stats[i].start_luid = INSN_LUID (p);\n-\t      if (stats[i].start_luid > uid_luid[REGNO_FIRST_UID (regno)])\n-\t\t{\n-\t\t  stats[i].end_luid = -1;\n-\t\t  ends_need_computing++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  stats[i].end_luid = uid_luid[REGNO_LAST_UID (regno)];\n-\t\t  if (stats[i].end_luid > INSN_LUID (loop->end))\n-\t\t    {\n-\t\t      stats[i].end_luid = -1;\n-\t\t      ends_need_computing++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* If the regscan information was unconclusive for one or more DEST_REG\n-     givs, scan the all insn in the loop to find out lifetime ends.  */\n-  if (ends_need_computing)\n-    {\n-      rtx biv = bl->biv->src_reg;\n-      rtx p = loop->end;\n-\n-      do\n-\t{\n-\t  if (p == loop->start)\n-\t    p = loop->end;\n-\t  p = PREV_INSN (p);\n-\t  if (! INSN_P (p))\n-\t    continue;\n-\t  ends_need_computing -= find_life_end (loop, PATTERN (p),\n-\t\t\t\t\t\tstats, p, biv);\n-\t}\n-      while (ends_need_computing);\n-    }\n-\n-  /* Set start_luid back to the last insn that sets the giv.  This allows\n-     more combinations.  */\n-  for (i = giv_count - 1; i >= 0; i--)\n-    {\n-      v = giv_array[stats[i].giv_number];\n-      if (v->ignore)\n-\tcontinue;\n-      if (INSN_UID (v->insn) < max_uid_for_loop)\n-\tstats[i].start_luid = INSN_LUID (v->insn);\n-    }\n-\n-  /* Now adjust lifetime ends by taking combined givs into account.  */\n-  for (i = giv_count - 1; i >= 0; i--)\n-    {\n-      unsigned luid;\n-      int j;\n-\n-      v = giv_array[stats[i].giv_number];\n-      if (v->ignore)\n-\tcontinue;\n-      if (v->same && ! v->same->ignore)\n-\t{\n-\t  j = v->same->ix;\n-\t  luid = stats[i].start_luid;\n-\t  /* Use unsigned arithmetic to model loop wrap-around.  */\n-\t  if (luid - stats[j].start_luid\n-\t      > (unsigned) stats[j].end_luid - stats[j].start_luid)\n-\t    stats[j].end_luid = luid;\n-\t}\n-    }\n-\n-  qsort (stats, giv_count, sizeof (*stats), cmp_recombine_givs_stats);\n-\n-  /* Try to derive DEST_REG givs from previous DEST_REG givs with the\n-     same mult_val and non-overlapping lifetime.  This reduces register\n-     pressure.\n-     Once we find a DEST_REG giv that is suitable to derive others from,\n-     we set last_giv to this giv, and try to derive as many other DEST_REG\n-     givs from it without joining overlapping lifetimes.  If we then\n-     encounter a DEST_REG giv that we can't derive, we set rescan to the\n-     index for this giv (unless rescan is already set).\n-     When we are finished with the current LAST_GIV (i.e. the inner loop\n-     terminates), we start again with rescan, which then becomes the new\n-     LAST_GIV.  */\n-  for (i = giv_count - 1; i >= 0; i = rescan)\n-    {\n-      int life_start = 0, life_end = 0;\n-\n-      for (last_giv = 0, rescan = -1; i >= 0; i--)\n-\t{\n-\t  rtx sum;\n-\n-\t  v = giv_array[stats[i].giv_number];\n-\t  if (v->giv_type != DEST_REG || v->derived_from || v->same)\n-\t    continue;\n-\t  if (! last_giv)\n-\t    {\n-\t      /* Don't use a giv that's likely to be dead to derive\n-\t\t others - that would be likely to keep that giv alive.  */\n-\t      if (! v->maybe_dead || v->combined_with)\n-\t\t{\n-\t\t  last_giv = v;\n-\t\t  life_start = stats[i].start_luid;\n-\t\t  life_end = stats[i].end_luid;\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  /* Use unsigned arithmetic to model loop wrap around.  */\n-\t  if (((unsigned) stats[i].start_luid - life_start\n-\t       >= (unsigned) life_end - life_start)\n-\t      && ((unsigned) stats[i].end_luid - life_start\n-\t\t  > (unsigned) life_end - life_start)\n-\t      /*  Check that the giv insn we're about to use for deriving\n-\t\t  precedes all uses of that giv.  Note that initializing the\n-\t\t  derived giv would defeat the purpose of reducing register\n-\t\t  pressure.\n-\t\t  ??? We could arrange to move the insn.  */\n-\t      && ((unsigned) stats[i].end_luid - INSN_LUID (loop->start)\n-                  > (unsigned) stats[i].start_luid - INSN_LUID (loop->start))\n-\t      && rtx_equal_p (last_giv->mult_val, v->mult_val)\n-\t      /* ??? Could handle libcalls, but would need more logic.  */\n-\t      && ! find_reg_note (v->insn, REG_RETVAL, NULL_RTX)\n-\t      /* We would really like to know if for any giv that v\n-\t\t is combined with, v->insn or any intervening biv increment\n-\t\t dominates that combined giv.  However, we\n-\t\t don't have this detailed control flow information.\n-\t\t N.B. since last_giv will be reduced, it is valid\n-\t\t anywhere in the loop, so we don't need to check the\n-\t\t validity of last_giv.\n-\t\t We rely here on the fact that v->always_executed implies that\n-\t\t there is no jump to someplace else in the loop before the\n-\t\t giv insn, and hence any insn that is executed before the\n-\t\t giv insn in the loop will have a lower luid.  */\n-\t      && (v->always_executed || ! v->combined_with)\n-\t      && (sum = express_from (last_giv, v))\n-\t      /* Make sure we don't make the add more expensive.  ADD_COST\n-\t\t doesn't take different costs of registers and constants into\n-\t\t account, so compare the cost of the actual SET_SRCs.  */\n-\t      && (rtx_cost (sum, SET)\n-\t\t  <= rtx_cost (SET_SRC (single_set (v->insn)), SET))\n-\t      /* ??? unroll can't understand anything but reg + const_int\n-\t\t sums.  It would be cleaner to fix unroll.  */\n-\t      && ((GET_CODE (sum) == PLUS\n-\t\t   && GET_CODE (XEXP (sum, 0)) == REG\n-\t\t   && GET_CODE (XEXP (sum, 1)) == CONST_INT)\n-\t\t  || ! unroll_p)\n-\t      && validate_change (v->insn, &PATTERN (v->insn),\n-\t\t\t\t  gen_rtx_SET (VOIDmode, v->dest_reg, sum), 0))\n-\t    {\n-\t      v->derived_from = last_giv;\n-\t      life_end = stats[i].end_luid;\n-\n-\t      if (loop_dump_stream)\n-\t\t{\n-\t\t  fprintf (loop_dump_stream,\n-\t\t\t   \"giv at %d derived from %d as \",\n-\t\t\t   INSN_UID (v->insn), INSN_UID (last_giv->insn));\n-\t\t  print_rtl (loop_dump_stream, sum);\n-\t\t  putc ('\\n', loop_dump_stream);\n-\t\t}\n-\t    }\n-\t  else if (rescan < 0)\n-\t    rescan = i;\n-\t}\n-    }\n-\n-  /* Clean up.  */\n-  free (giv_array);\n-  free (stats);\n-}\n-\f\n /* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */\n \n void\n@@ -8695,22 +7737,6 @@ biv_elimination_giv_has_0_offset (biv, giv, insn)\n \t      && loop_insn_first_p (insn, giv->insn))))\n     return 0;\n \n-  /* If the giv V was derived from another giv, and INSN does\n-     not occur between the giv insn and the biv insn, then we'd\n-     have to adjust the value used here.  This is rare, so we don't\n-     bother to make this possible.  */\n-  if (giv->derived_from\n-      && ! (giv->always_executed\n-\t    && loop_insn_first_p (giv->insn, insn)\n-\t    && loop_insn_first_p (insn, biv->insn)))\n-    return 0;\n-  if (giv->same\n-      && giv->same->derived_from\n-      && ! (giv->same->always_executed\n-\t    && loop_insn_first_p (giv->same->insn, insn)\n-\t    && loop_insn_first_p (insn, biv->insn)))\n-    return 0;\n-\n   return 1;\n }\n "}, {"sha": "a1aaf82e099d29461fceb57a63e86b00423fea70", "filename": "gcc/loop.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "patch": "@@ -133,14 +133,10 @@ struct induction\n   struct induction *same;\t/* If this giv has been combined with another\n \t\t\t\t   giv, this points to the base giv.  The base\n \t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n-  struct induction *derived_from;/* For a giv, if we decided to derive this\n-\t\t\t\t   giv from another one.  */\n   HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n \t\t\t\t   for later use.  */\n-  int ix;\t\t\t/* Used by recombine_givs, as n index into\n-\t\t\t\t   the stats array.  */\n   struct induction *same_insn;\t/* If there are multiple identical givs in\n \t\t\t\t   the same insn, then all but one have this\n \t\t\t\t   field set, and they all point to the giv\n@@ -201,12 +197,6 @@ struct loop_ivs\n   /* The head of a list which links together (via the next field)\n      every iv class for the current loop.  */\n   struct iv_class *loop_iv_list;\n-\n-  /* Givs made from biv increments are always splittable for loop\n-     unrolling.  Since there is no regscan info for them, we have to\n-     keep track of them separately.  */\n-  unsigned int first_increment_giv;\n-  unsigned int last_increment_giv;\n };\n \n struct loop_regs"}, {"sha": "c1a488dc770b6b7fab3f2fedd1fbadf651173bfa", "filename": "gcc/unroll.c", "status": "modified", "additions": 7, "deletions": 74, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f75276d6361cfc8c569c4ecd714b1bf3a5915c/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b4f75276d6361cfc8c569c4ecd714b1bf3a5915c", "patch": "@@ -189,10 +189,6 @@ static struct induction **addr_combined_regs;\n \n static rtx *splittable_regs;\n \n-/* Indexed by register number, if this is a splittable induction variable,\n-   this indicates if it was made from a derived giv.  */\n-static char *derived_regs;\n-\n /* Indexed by register number, if this is a splittable induction variable,\n    then this will hold the number of instructions in the loop that modify\n    the induction variable.  Used to ensure that only the last insn modifying\n@@ -806,7 +802,6 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n      to access the splittable_regs[] and addr_combined_regs[] arrays.  */\n \n   splittable_regs = (rtx *) xcalloc (maxregnum, sizeof (rtx));\n-  derived_regs = (char *) xcalloc (maxregnum, sizeof (char));\n   splittable_regs_updates = (int *) xcalloc (maxregnum, sizeof (int));\n   addr_combined_regs\n     = (struct induction **) xcalloc (maxregnum, sizeof (struct induction *));\n@@ -872,14 +867,6 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t\t\t   r);\n \t      }\n \t  }\n-      /* Givs that have been created from multiple biv increments always have\n-\t local registers.  */\n-      for (r = ivs->first_increment_giv; r <= ivs->last_increment_giv; r++)\n-\t{\n-\t  local_regno[r] = 1;\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Marked reg %d as local\\n\", r);\n-\t}\n     }\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n@@ -1346,7 +1333,6 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n     }\n   free (map->insn_map);\n   free (splittable_regs);\n-  free (derived_regs);\n   free (splittable_regs_updates);\n   free (addr_combined_regs);\n   free (local_regno);\n@@ -1792,8 +1778,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\t we might accidentally delete insns generated immediately\n \t\t below by emit_unrolled_add.  */\n \n-\t      if (! derived_regs[regno])\n-\t\tgiv_inc = calculate_giv_inc (set, insn, regno);\n+\t      giv_inc = calculate_giv_inc (set, insn, regno);\n \n \t      /* Now find all address giv's that were combined with this\n \t\t giv 'v'.  */\n@@ -1880,23 +1865,12 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t      dest_reg_was_split = 1;\n \n \t      giv_dest_reg = SET_DEST (set);\n-\t      if (derived_regs[regno])\n-\t\t{\n-\t\t  /* ??? This relies on SET_SRC (SET) to be of\n-\t\t     the form (plus (reg) (const_int)), and thus\n-\t\t     forces recombine_givs to restrict the kind\n-\t\t     of giv derivations it does before unrolling.  */\n-\t\t  giv_src_reg = XEXP (SET_SRC (set), 0);\n-\t\t  giv_inc = XEXP (SET_SRC (set), 1);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  giv_src_reg = giv_dest_reg;\n-\t\t  /* Compute the increment value for the giv, if it wasn't\n-\t\t     already computed above.  */\n-\t\t  if (giv_inc == 0)\n-\t\t    giv_inc = calculate_giv_inc (set, insn, regno);\n-\t\t}\n+\t      giv_src_reg = giv_dest_reg;\n+\t      /* Compute the increment value for the giv, if it wasn't\n+\t\t already computed above.  */\n+\t      if (giv_inc == 0)\n+\t\tgiv_inc = calculate_giv_inc (set, insn, regno);\n+\n \t      src_regno = REGNO (giv_src_reg);\n \n \t      if (unroll_type == UNROLL_COMPLETELY)\n@@ -2726,10 +2700,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n \t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n \t\t  >= INSN_LUID (loop->end)))\n-\t  /* Givs made from biv increments are missed by the above test, so\n-\t     test explicitly for them.  */\n-\t  && (REGNO (v->dest_reg) < ivs->first_increment_giv\n-\t      || REGNO (v->dest_reg) > ivs->last_increment_giv)\n \t  && ! (final_value = v->final_value))\n \tcontinue;\n \n@@ -2831,7 +2801,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t}\n \n \t      splittable_regs[REGNO (v->new_reg)] = value;\n-\t      derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n \t    }\n \t  else\n \t    {\n@@ -2891,25 +2860,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t  rtx new_reg = v->new_reg;\n \t\t  record_base_value (REGNO (tem), v->add_val, 0);\n \n-\t\t  if (same && same->derived_from)\n-\t\t    {\n-\t\t      /* calculate_giv_inc doesn't work for derived givs.\n-\t\t\t copy_loop_body works around the problem for the\n-\t\t\t DEST_REG givs themselves, but it can't handle\n-\t\t\t DEST_ADDR givs that have been combined with\n-\t\t\t a derived DEST_REG giv.\n-\t\t\t So Handle V as if the giv from which V->SAME has\n-\t\t\t been derived has been combined with V.\n-\t\t\t recombine_givs only derives givs from givs that\n-\t\t\t are reduced the ordinary, so we need not worry\n-\t\t\t about same->derived_from being in turn derived.  */\n-\n-\t\t      same = same->derived_from;\n-\t\t      new_reg = express_from (same, v);\n-\t\t      new_reg = replace_rtx (new_reg, same->dest_reg,\n-\t\t\t\t\t     same->new_reg);\n-\t\t    }\n-\n \t\t  /* If the address giv has a constant in its new_reg value,\n \t\t     then this constant can be pulled out and put in value,\n \t\t     instead of being part of the initialization code.  */\n@@ -3017,17 +2967,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t\t\t INSN_UID (v->insn));\n \t\t      continue;\n \t\t    }\n-\t\t  if (v->same && v->same->derived_from)\n-\t\t    {\n-\t\t      /* Handle V as if the giv from which V->SAME has\n-\t\t\t been derived has been combined with V.  */\n-\n-\t\t      v->same = v->same->derived_from;\n-\t\t      v->new_reg = express_from (v->same, v);\n-\t\t      v->new_reg = replace_rtx (v->new_reg, v->same->dest_reg,\n-\t\t\t\t\t\tv->same->new_reg);\n-\t\t    }\n-\n \t\t}\n \n \t      /* Store the value of dest_reg into the insn.  This sharing\n@@ -3050,7 +2989,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t     Make sure that it's giv is marked as splittable here.  */\n \n \t\t  splittable_regs[REGNO (v->new_reg)] = value;\n-\t\t  derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n \n \t\t  /* Make it appear to depend upon itself, so that the\n \t\t     giv will be properly split in the main loop above.  */\n@@ -3094,11 +3032,6 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t  if (! v->ignore)\n \t    count = ivs->reg_biv_class[REGNO (v->src_reg)]->biv_count;\n \n-\t  if (count > 1 && v->derived_from)\n-\t     /* In this case, there is one set where the giv insn was and one\n-\t\tset each after each biv increment.  (Most are likely dead.)  */\n-\t    count++;\n-\n \t  splittable_regs_updates[REGNO (v->new_reg)] = count;\n \t}\n "}]}