{"sha": "ecbcf7b3198489daee27a8dd913314a69e947c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiY2Y3YjMxOTg0ODlkYWVlMjdhOGRkOTEzMzE0YTY5ZTk0N2MxMQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2001-12-08T22:34:54Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2001-12-08T22:34:54Z"}, "message": "c-common.h (rid): Add RID_CHOOSE_EXPR and RID_TYPES_COMPATIBLE_P.\n\n\t* c-common.h (rid): Add RID_CHOOSE_EXPR and\n        RID_TYPES_COMPATIBLE_P.\n\n        * c-parse.in (reswords): Add __builtin_choose_expr.\n        Add __builtin_types_compatible_p.\n        Add CHOOSE_EXPR token.\n\tAdd TYPES_COMPATIBLE_P token.\n        Add production for CHOOSE_EXPR.\n        Add production for TYPES_COMPATIBLE_P.\n\n        * doc/extend.texi (__builtin_choose_expr): Add documentation.\n        (__builtin_types_compatible_p): Likewise.\n\nFrom-SVN: r47798", "tree": {"sha": "bb7979ef02dfccc51f11263c3f2803727502419e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb7979ef02dfccc51f11263c3f2803727502419e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecbcf7b3198489daee27a8dd913314a69e947c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecbcf7b3198489daee27a8dd913314a69e947c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecbcf7b3198489daee27a8dd913314a69e947c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecbcf7b3198489daee27a8dd913314a69e947c11/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ec9bf8aa0d0b2375e43668f4a6c186856c9dbc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec9bf8aa0d0b2375e43668f4a6c186856c9dbc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec9bf8aa0d0b2375e43668f4a6c186856c9dbc9"}], "stats": {"total": 134, "additions": 132, "deletions": 2}, "files": [{"sha": "5155954714b1bbbbf34cadcfd82495016e45ce12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecbcf7b3198489daee27a8dd913314a69e947c11", "patch": "@@ -1,3 +1,18 @@\n+2001-10-08  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-common.h (rid): Add RID_CHOOSE_EXPR and\n+        RID_TYPES_COMPATIBLE_P.\n+\n+        * c-parse.in (reswords): Add __builtin_choose_expr.\n+        Add __builtin_types_compatible_p.\n+        Add CHOOSE_EXPR token.\n+\tAdd TYPES_COMPATIBLE_P token.\n+        Add production for CHOOSE_EXPR.\n+        Add production for TYPES_COMPATIBLE_P.\n+\n+        * doc/extend.texi (__builtin_choose_expr): Add documentation.\n+        (__builtin_types_compatible_p): Likewise.\n+\n 2001-12-08  David Edelsohn  <edelsohn@gnu.org>\n \n \t* stor-layout.c (place_union_field): Apply ADJUST_FIELD_ALIGN"}, {"sha": "59525d5dc535fac83eac5d432494bac872603782", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ecbcf7b3198489daee27a8dd913314a69e947c11", "patch": "@@ -74,7 +74,7 @@ enum rid\n   /* C extensions */\n   RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_PTRBASE,\n-  RID_PTREXTENT, RID_PTRVALUE,\n+  RID_PTREXTENT, RID_PTRVALUE, RID_CHOOSE_EXPR, RID_TYPES_COMPATIBLE_P,\n \n   /* Too many ways of getting the name of a function as a string */\n   RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,"}, {"sha": "84d1c0214b33e4e60c4b93dc141d88bf217f2d43", "filename": "gcc/c-parse.in", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=ecbcf7b3198489daee27a8dd913314a69e947c11", "patch": "@@ -110,7 +110,7 @@ end ifobjc\n %token SIZEOF ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n %token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF\n %token ATTRIBUTE EXTENSION LABEL\n-%token REALPART IMAGPART VA_ARG\n+%token REALPART IMAGPART VA_ARG CHOOSE_EXPR TYPES_COMPATIBLE_P\n %token PTR_VALUE PTR_BASE PTR_EXTENT\n \n /* function name can be a string const or a var decl. */\n@@ -664,6 +664,26 @@ primary:\n \t\t{ $$ = build_function_call ($1, $3); }\n \t| VA_ARG '(' expr_no_commas ',' typename ')'\n \t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n+      | CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ',' expr_no_commas ')'\n+\t\t{\n+                  tree c;\n+\n+                  c = fold ($3);\n+                  STRIP_NOPS (c);\n+                  if (TREE_CODE (c) != INTEGER_CST)\n+                    error (\"first argument to __builtin_choose_expr not a constant\");\n+                  $$ = integer_zerop (c) ? $7 : $5;\n+\t\t}\n+      | TYPES_COMPATIBLE_P '(' typename ',' typename ')'\n+\t\t{\n+\t\t  tree e1, e2;\n+\n+\t\t  e1 = TYPE_MAIN_VARIANT (groktypename ($3));\n+\t\t  e2 = TYPE_MAIN_VARIANT (groktypename ($5));\n+\n+\t\t  $$ = comptypes (e1, e2)\n+\t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n+\t\t}\n \t| primary '[' expr ']'   %prec '.'\n \t\t{ $$ = build_array_ref ($1, $3); }\n \t| primary '.' identifier\n@@ -3218,6 +3238,8 @@ static const struct resword reswords[] =\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n   { \"__bounded\",\tRID_BOUNDED,\t0 },\n   { \"__bounded__\",\tRID_BOUNDED,\t0 },\n+  { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, 0 },\n+  { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, 0 },\n   { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n   { \"__complex\",\tRID_COMPLEX,\t0 },\n   { \"__complex__\",\tRID_COMPLEX,\t0 },\n@@ -3390,6 +3412,9 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_PTREXTENT */\tPTR_EXTENT,\n   /* RID_PTRVALUE */\tPTR_VALUE,\n \n+  /* RID_CHOOSE_EXPR */\t\t\tCHOOSE_EXPR,\n+  /* RID_TYPES_COMPATIBLE_P */\t\tTYPES_COMPATIBLE_P,\n+\n   /* RID_FUNCTION_NAME */\t\tSTRING_FUNC_NAME,\n   /* RID_PRETTY_FUNCTION_NAME */\tSTRING_FUNC_NAME,\n   /* RID_C99_FUNCTION_NAME */\t\tVAR_FUNC_NAME,"}, {"sha": "1a4ff5814dfa3d88b5ef41534a17172ba3331d7c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecbcf7b3198489daee27a8dd913314a69e947c11/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ecbcf7b3198489daee27a8dd913314a69e947c11", "patch": "@@ -4388,6 +4388,96 @@ the same names as the standard macros ( @code{isgreater},\n prefixed.  We intend for a library implementor to be able to simply\n @code{#define} each standard macro to its built-in equivalent.\n \n+@deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n+\n+You can use the built-in function @code{__builtin_types_compatible_p} to\n+determine whether two types are the same.\n+\n+This built-in function returns 1 if the unqualified versions of the\n+types @var{type1} and @var{type2} (which are types, not expressions) are\n+compatible, 0 otherwise.  The result of this built-in function can be\n+used in integer constant expressions.\n+\n+This built-in function ignores top level qualifiers (e.g., @code{const},\n+@code{volatile}).  For example, @code{int} is equivalent to @code{const\n+int}.\n+\n+The type @code{int[]} and @code{int[5]} are compatible.  On the other\n+hand, @code{int} and @code{char *} are not compatible, even if the size\n+of their types, on the particular architecture are the same.  Also, the\n+amount of pointer indirection is taken into account when determining\n+similarity.  Consequently, @code{short *} is not similar to\n+@code{short **}.  Furthermore, two types that are typedefed are\n+considered compatible if their underlying types are compatible.\n+\n+An @code{enum} type is considered to be compatible with another\n+@code{enum} type.  For example, @code{enum @{foo, bar@}} is similar to\n+@code{enum @{hot, dog@}}.\n+\n+You would typically use this function in code whose execution varies\n+depending on the arguments' types.  For example:\n+\n+@smallexample\n+#define foo(x)                                                        \\\n+  (@{                                                                 \\\n+    typeof (x) tmp;                                                   \\\n+    if (__builtin_types_compatible_p (typeof (x), long double))       \\\n+      tmp = foo_long_double (tmp);                                    \\\n+    else if (__builtin_types_compatible_p (typeof (x), double))       \\\n+      tmp = foo_double (tmp);                                         \\\n+    else if (__builtin_types_compatible_p (typeof (x), float))        \\\n+      tmp = foo_float (tmp);                                          \\\n+    else                                                              \\\n+      abort ();                                                       \\\n+    tmp;                                                              \\\n+  @})\n+@end smallexample\n+\n+@emph{Note:} This construct is only available for C.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} @var{type} __builtin_choose_expr (@var{const_exp}, @var{exp1}, @var{exp2})\n+\n+You can use the built-in function @code{__builtin_choose_expr} to\n+evaluate code depending on the value of a constant expression.  This\n+built-in function returns @var{exp1} if @var{const_exp}, which is a\n+constant expression that must be able to be determined at compile time,\n+is nonzero.  Otherwise it returns 0.\n+\n+This built-in function is analogous to the @samp{? :} operator in C,\n+except that the expression returned has its type unaltered by promotion\n+rules.  Also, the built-in function does not evaluate the expression\n+that was not chosen.  For example, if @var{const_exp} evaluates to true,\n+@var{exp2} is not evaluated even if it has side-effects.\n+\n+This built-in function can return an lvalue if the chosen argument is an\n+lvalue.\n+\n+If @var{exp1} is returned, the return type is the same as @var{exp1}'s\n+type.  Similarly, if @var{exp2} is returned, its return type is the same\n+as @var{exp2}.\n+\n+Example:\n+\n+@smallexample\n+#define foo(x)                                                               \\\n+  __builtin_choose_expr (__builtin_types_compatible_p (typeof (x), double),  \\\n+    foo_double (x),                                                          \\\n+    __builtin_choose_expr (__builtin_types_compatible_p (typeof (x), float), \\\n+      foo_float (x),                                                         \\\n+      /* @r{The void expression results in a compile-time error}             \\\n+         @r{when assigning the result to something.}  */                     \\\n+      (void)0))\n+@end smallexample\n+\n+@emph{Note:} This construct is only available for C.  Furthermore, the\n+unused expression (@var{exp1} or @var{exp2} depending on the value of\n+@var{const_exp}) may still generate syntax errors.  This may change in\n+future revisions.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} int __builtin_constant_p (@var{exp})\n You can use the built-in function @code{__builtin_constant_p} to\n determine if a value is known to be constant at compile-time and hence"}]}