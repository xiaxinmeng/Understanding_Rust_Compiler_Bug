{"sha": "a36a1928e2b23355618c68a2d8d7e5a17b827df8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2YTE5MjhlMmIyMzM1NTYxOGM2OGEyZDhkN2U1YTE3YjgyN2RmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-08-28T06:23:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-08-28T06:23:58Z"}, "message": "lower-subreg.c (find_decomposable_subregs): Turn from being a for_each_rtx callback to being a function that examines each...\n\ngcc/\n\t* lower-subreg.c (find_decomposable_subregs): Turn from being\n\ta for_each_rtx callback to being a function that examines each\n\tsubrtx itself.  Remove handling of null rtxes.\n\t(decompose_multiword_subregs): Update accordingly.\n\nFrom-SVN: r214649", "tree": {"sha": "10f6397d61b66be31023cc54c0ba28ca31c2e1c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10f6397d61b66be31023cc54c0ba28ca31c2e1c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a36a1928e2b23355618c68a2d8d7e5a17b827df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a36a1928e2b23355618c68a2d8d7e5a17b827df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a36a1928e2b23355618c68a2d8d7e5a17b827df8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a36a1928e2b23355618c68a2d8d7e5a17b827df8/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2d3f3471e71233bfd0ed8ca6ae463ebf5dbfd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d3f3471e71233bfd0ed8ca6ae463ebf5dbfd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d3f3471e71233bfd0ed8ca6ae463ebf5dbfd8b"}], "stats": {"total": 208, "additions": 107, "deletions": 101}, "files": [{"sha": "1c5aaf971fed82728efe7506aae02511cfd700a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a36a1928e2b23355618c68a2d8d7e5a17b827df8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a36a1928e2b23355618c68a2d8d7e5a17b827df8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a36a1928e2b23355618c68a2d8d7e5a17b827df8", "patch": "@@ -1,3 +1,10 @@\n+2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lower-subreg.c (find_decomposable_subregs): Turn from being\n+\ta for_each_rtx callback to being a function that examines each\n+\tsubrtx itself.  Remove handling of null rtxes.\n+\t(decompose_multiword_subregs): Update accordingly.\n+\n 2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* lower-subreg.c (adjust_decomposed_uses): Delete."}, {"sha": "a8ea10f70997b618bed17729f4e1b99394008ead", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 100, "deletions": 101, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a36a1928e2b23355618c68a2d8d7e5a17b827df8/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a36a1928e2b23355618c68a2d8d7e5a17b827df8/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=a36a1928e2b23355618c68a2d8d7e5a17b827df8", "patch": "@@ -443,7 +443,7 @@ propagate_pseudo_copies (void)\n }\n \n /* A pointer to one of these values is passed to\n-   find_decomposable_subregs via for_each_rtx.  */\n+   find_decomposable_subregs.  */\n \n enum classify_move_insn\n {\n@@ -455,120 +455,121 @@ enum classify_move_insn\n   SIMPLE_MOVE\n };\n \n-/* This is called via for_each_rtx.  If we find a SUBREG which we\n-   could use to decompose a pseudo-register, set a bit in\n-   DECOMPOSABLE_CONTEXT.  If we find an unadorned register which is\n-   not a simple pseudo-register copy, DATA will point at the type of\n-   move, and we set a bit in DECOMPOSABLE_CONTEXT or\n-   NON_DECOMPOSABLE_CONTEXT as appropriate.  */\n+/* If we find a SUBREG in *LOC which we could use to decompose a\n+   pseudo-register, set a bit in DECOMPOSABLE_CONTEXT.  If we find an\n+   unadorned register which is not a simple pseudo-register copy,\n+   DATA will point at the type of move, and we set a bit in\n+   DECOMPOSABLE_CONTEXT or NON_DECOMPOSABLE_CONTEXT as appropriate.  */\n \n-static int\n-find_decomposable_subregs (rtx *px, void *data)\n+static void\n+find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n {\n-  enum classify_move_insn *pcmi = (enum classify_move_insn *) data;\n-  rtx x = *px;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-\n-  if (GET_CODE (x) == SUBREG)\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, *loc, NONCONST)\n     {\n-      rtx inner = SUBREG_REG (x);\n-      unsigned int regno, outer_size, inner_size, outer_words, inner_words;\n+      rtx x = *iter;\n+      if (GET_CODE (x) == SUBREG)\n+\t{\n+\t  rtx inner = SUBREG_REG (x);\n+\t  unsigned int regno, outer_size, inner_size, outer_words, inner_words;\n \n-      if (!REG_P (inner))\n-\treturn 0;\n+\t  if (!REG_P (inner))\n+\t    continue;\n \n-      regno = REGNO (inner);\n-      if (HARD_REGISTER_NUM_P (regno))\n-\treturn -1;\n+\t  regno = REGNO (inner);\n+\t  if (HARD_REGISTER_NUM_P (regno))\n+\t    {\n+\t      iter.skip_subrtxes ();\n+\t      continue;\n+\t    }\n \n-      outer_size = GET_MODE_SIZE (GET_MODE (x));\n-      inner_size = GET_MODE_SIZE (GET_MODE (inner));\n-      outer_words = (outer_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-      inner_words = (inner_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\t  outer_size = GET_MODE_SIZE (GET_MODE (x));\n+\t  inner_size = GET_MODE_SIZE (GET_MODE (inner));\n+\t  outer_words = (outer_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\t  inner_words = (inner_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n-      /* We only try to decompose single word subregs of multi-word\n-\t registers.  When we find one, we return -1 to avoid iterating\n-\t over the inner register.\n+\t  /* We only try to decompose single word subregs of multi-word\n+\t     registers.  When we find one, we return -1 to avoid iterating\n+\t     over the inner register.\n \n-\t ??? This doesn't allow, e.g., DImode subregs of TImode values\n-\t on 32-bit targets.  We would need to record the way the\n-\t pseudo-register was used, and only decompose if all the uses\n-\t were the same number and size of pieces.  Hopefully this\n-\t doesn't happen much.  */\n+\t     ??? This doesn't allow, e.g., DImode subregs of TImode values\n+\t     on 32-bit targets.  We would need to record the way the\n+\t     pseudo-register was used, and only decompose if all the uses\n+\t     were the same number and size of pieces.  Hopefully this\n+\t     doesn't happen much.  */\n \n-      if (outer_words == 1 && inner_words > 1)\n-\t{\n-\t  bitmap_set_bit (decomposable_context, regno);\n-\t  return -1;\n-\t}\n+\t  if (outer_words == 1 && inner_words > 1)\n+\t    {\n+\t      bitmap_set_bit (decomposable_context, regno);\n+\t      iter.skip_subrtxes ();\n+\t      continue;\n+\t    }\n \n-      /* If this is a cast from one mode to another, where the modes\n-\t have the same size, and they are not tieable, then mark this\n-\t register as non-decomposable.  If we decompose it we are\n-\t likely to mess up whatever the backend is trying to do.  */\n-      if (outer_words > 1\n-\t  && outer_size == inner_size\n-\t  && !MODES_TIEABLE_P (GET_MODE (x), GET_MODE (inner)))\n-\t{\n-\t  bitmap_set_bit (non_decomposable_context, regno);\n-\t  bitmap_set_bit (subreg_context, regno);\n-\t  return -1;\n+\t  /* If this is a cast from one mode to another, where the modes\n+\t     have the same size, and they are not tieable, then mark this\n+\t     register as non-decomposable.  If we decompose it we are\n+\t     likely to mess up whatever the backend is trying to do.  */\n+\t  if (outer_words > 1\n+\t      && outer_size == inner_size\n+\t      && !MODES_TIEABLE_P (GET_MODE (x), GET_MODE (inner)))\n+\t    {\n+\t      bitmap_set_bit (non_decomposable_context, regno);\n+\t      bitmap_set_bit (subreg_context, regno);\n+\t      iter.skip_subrtxes ();\n+\t      continue;\n+\t    }\n \t}\n-    }\n-  else if (REG_P (x))\n-    {\n-      unsigned int regno;\n-\n-      /* We will see an outer SUBREG before we see the inner REG, so\n-\t when we see a plain REG here it means a direct reference to\n-\t the register.\n-\n-\t If this is not a simple copy from one location to another,\n-\t then we can not decompose this register.  If this is a simple\n-\t copy we want to decompose, and the mode is right,\n-\t then we mark the register as decomposable.\n-\t Otherwise we don't say anything about this register --\n-\t it could be decomposed, but whether that would be\n-\t profitable depends upon how it is used elsewhere.\n-\n-\t We only set bits in the bitmap for multi-word\n-\t pseudo-registers, since those are the only ones we care about\n-\t and it keeps the size of the bitmaps down.  */\n-\n-      regno = REGNO (x);\n-      if (!HARD_REGISTER_NUM_P (regno)\n-\t  && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+      else if (REG_P (x))\n \t{\n-\t  switch (*pcmi)\n+\t  unsigned int regno;\n+\n+\t  /* We will see an outer SUBREG before we see the inner REG, so\n+\t     when we see a plain REG here it means a direct reference to\n+\t     the register.\n+\n+\t     If this is not a simple copy from one location to another,\n+\t     then we can not decompose this register.  If this is a simple\n+\t     copy we want to decompose, and the mode is right,\n+\t     then we mark the register as decomposable.\n+\t     Otherwise we don't say anything about this register --\n+\t     it could be decomposed, but whether that would be\n+\t     profitable depends upon how it is used elsewhere.\n+\n+\t     We only set bits in the bitmap for multi-word\n+\t     pseudo-registers, since those are the only ones we care about\n+\t     and it keeps the size of the bitmaps down.  */\n+\n+\t  regno = REGNO (x);\n+\t  if (!HARD_REGISTER_NUM_P (regno)\n+\t      && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n \t    {\n-\t    case NOT_SIMPLE_MOVE:\n-\t      bitmap_set_bit (non_decomposable_context, regno);\n-\t      break;\n-\t    case DECOMPOSABLE_SIMPLE_MOVE:\n-\t      if (MODES_TIEABLE_P (GET_MODE (x), word_mode))\n-\t\tbitmap_set_bit (decomposable_context, regno);\n-\t      break;\n-\t    case SIMPLE_MOVE:\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n+\t      switch (*pcmi)\n+\t\t{\n+\t\tcase NOT_SIMPLE_MOVE:\n+\t\t  bitmap_set_bit (non_decomposable_context, regno);\n+\t\t  break;\n+\t\tcase DECOMPOSABLE_SIMPLE_MOVE:\n+\t\t  if (MODES_TIEABLE_P (GET_MODE (x), word_mode))\n+\t\t    bitmap_set_bit (decomposable_context, regno);\n+\t\t  break;\n+\t\tcase SIMPLE_MOVE:\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t    }\n \t}\n-    }\n-  else if (MEM_P (x))\n-    {\n-      enum classify_move_insn cmi_mem = NOT_SIMPLE_MOVE;\n+      else if (MEM_P (x))\n+\t{\n+\t  enum classify_move_insn cmi_mem = NOT_SIMPLE_MOVE;\n \n-      /* Any registers used in a MEM do not participate in a\n-\t SIMPLE_MOVE or DECOMPOSABLE_SIMPLE_MOVE.  Do our own recursion\n-\t here, and return -1 to block the parent's recursion.  */\n-      for_each_rtx (&XEXP (x, 0), find_decomposable_subregs, &cmi_mem);\n-      return -1;\n+\t  /* Any registers used in a MEM do not participate in a\n+\t     SIMPLE_MOVE or DECOMPOSABLE_SIMPLE_MOVE.  Do our own recursion\n+\t     here, and return -1 to block the parent's recursion.  */\n+\t  find_decomposable_subregs (&XEXP (x, 0), &cmi_mem);\n+\t  iter.skip_subrtxes ();\n+\t}\n     }\n-\n-  return 0;\n }\n \n /* Decompose REGNO into word-sized components.  We smash the REG node\n@@ -1496,9 +1497,7 @@ decompose_multiword_subregs (bool decompose_copies)\n \t  n = recog_data.n_operands;\n \t  for (i = 0; i < n; ++i)\n \t    {\n-\t      for_each_rtx (&recog_data.operand[i],\n-\t\t\t    find_decomposable_subregs,\n-\t\t\t    &cmi);\n+\t      find_decomposable_subregs (&recog_data.operand[i], &cmi);\n \n \t      /* We handle ASM_OPERANDS as a special case to support\n \t\t things like x86 rdtsc which returns a DImode value."}]}