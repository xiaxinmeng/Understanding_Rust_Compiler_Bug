{"sha": "77d33a842d42d8de1dcfa142f8202ea60b4403ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdkMzNhODQyZDQyZDhkZTFkY2ZhMTQyZjgyMDJlYTYwYjQ0MDNhYw==", "commit": {"author": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-03-16T12:51:39Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-03-16T12:51:39Z"}, "message": "except.c (insn_eh_region, [...]): New static variables.\n\n\t* except.c (insn_eh_region, maximum_uid): New static variables.\n\t(set_insn_eh_region): New static function to set region numbers.\n\t(free_insn_eh_region): New function to free EH region table.\n\t(init_insn_eh_region): New function to initialize EH region table.\n\t(in_same_eh_region): New function used to determine if two rtl\n\tinstructions are in the same exception region or not.\n\nFrom-SVN: r18624", "tree": {"sha": "d974701b4d555ee83cbd742af65ae24bea335f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d974701b4d555ee83cbd742af65ae24bea335f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77d33a842d42d8de1dcfa142f8202ea60b4403ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d33a842d42d8de1dcfa142f8202ea60b4403ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77d33a842d42d8de1dcfa142f8202ea60b4403ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d33a842d42d8de1dcfa142f8202ea60b4403ac/comments", "author": null, "committer": null, "parents": [{"sha": "5aa550437e6a81bdf8b7eb59a5fc4c6f2825c6da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa550437e6a81bdf8b7eb59a5fc4c6f2825c6da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa550437e6a81bdf8b7eb59a5fc4c6f2825c6da"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "4a0c2491b5ce4fd8bffc731a7f33867bb3daa028", "filename": "gcc/except.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d33a842d42d8de1dcfa142f8202ea60b4403ac/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d33a842d42d8de1dcfa142f8202ea60b4403ac/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=77d33a842d42d8de1dcfa142f8202ea60b4403ac", "patch": "@@ -2168,3 +2168,109 @@ expand_builtin_set_eh_regs (handler, offset)\n   emit_insn (gen_rtx_USE (VOIDmode, reg1));\n   emit_insn (gen_rtx_USE (VOIDmode, reg2));\n }\n+\n+\f\n+\n+/* This contains the code required to verify whether arbitrary instructions\n+   are in the same exception region. */\n+\n+static int *insn_eh_region = (int *)0;\n+static int maximum_uid;\n+\n+static void set_insn_eh_region (first, region_num)\n+     rtx *first;\n+     int region_num;\n+{\n+  rtx insn;\n+  int rnum;\n+\n+  for (insn = *first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if ((GET_CODE (insn) == NOTE) && \n+                        (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG))\n+        {\n+          rnum = NOTE_BLOCK_NUMBER (insn);\n+          insn_eh_region[INSN_UID (insn)] =  rnum;\n+          insn = NEXT_INSN (insn);\n+          set_insn_eh_region (&insn, rnum);\n+          /* Upon return, insn points to the EH_REGION_END of nested region */\n+          continue;\n+        }\n+      insn_eh_region[INSN_UID (insn)] = region_num;\n+      if ((GET_CODE (insn) == NOTE) && \n+            (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+        break;\n+    }\n+  *first = insn;\n+}\n+\n+/* Free the insn table, an make sure it cannot be used again. */\n+\n+void free_insn_eh_region () \n+{\n+  if (!doing_eh (0))\n+    return;\n+\n+  if (insn_eh_region)\n+    {\n+      free (insn_eh_region);\n+      insn_eh_region = (int *)0;\n+    }\n+}\n+\n+/* Initialize the table. max_uid must be calculated and handed into \n+   this routine. If it is unavailable, passing a value of 0 will \n+   cause this routine to calculate it as well. */\n+\n+void init_insn_eh_region (first, max_uid)\n+     rtx first;\n+     int max_uid;\n+{\n+  rtx insn;\n+\n+  if (!doing_eh (0))\n+    return;\n+\n+  if (insn_eh_region)\n+    free_insn_eh_region();\n+\n+  if (max_uid == 0) \n+    for (insn = first; insn; insn = NEXT_INSN (insn))\n+      if (INSN_UID (insn) > max_uid)       /* find largest UID */\n+        max_uid = INSN_UID (insn);\n+\n+  maximum_uid = max_uid;\n+  insn_eh_region = (int *) malloc ((max_uid + 1) * sizeof (int));\n+  insn = first;\n+  set_insn_eh_region (&insn, 0);\n+}\n+\n+\n+/* Check whether 2 instructions are within the same region. */\n+\n+int in_same_eh_region(insn1, insn2) \n+     rtx insn1,insn2;\n+{\n+  int ret, uid1, uid2;\n+\n+  /* If no exceptions, instructions are always in same region. */\n+  if (!doing_eh (0))\n+    return 1;\n+\n+  /* If the table isn't allocated, assume the worst. */\n+  if (!insn_eh_region)  \n+    return 0;\n+\n+  uid1 = INSN_UID (insn1);\n+  uid2 = INSN_UID (insn2);\n+\n+  /* if instructions have been allocated beyond the end, either\n+     the table is out of date, or this is a late addition, or\n+     something... Assume the worst. */\n+  if (uid1 > maximum_uid || uid2 > maximum_uid)\n+    return 0;\n+\n+  ret = (insn_eh_region[uid1] == insn_eh_region[uid2]);\n+  return ret;\n+}\n+"}]}