{"sha": "f082c000379548ab460bd02f94e2986491b72c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA4MmMwMDAzNzk1NDhhYjQ2MGJkMDJmOTRlMjk4NjQ5MWI3MmM5ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-03-26T05:46:00Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-03-26T05:46:00Z"}, "message": "predicates.md (word_offset_memref_op): Handle cmodel medium addresses.\n\n\t* config/rs6000/predicates.md (word_offset_memref_op): Handle\n\tcmodel medium addresses.\n\t* config/rs6000/rs6000.c (rs6000_secondary_reload): Handle misaligned\n\t64-bit gpr loads and stores.\n\t(rs6000_secondary_reload_ppc64): New function.\n\t* config/rs6000/rs6000-protos.h: Declare it.\n\t* config/rs6000/rs6000.md (reload_di_store, reload_di_load): New.\n\nFrom-SVN: r171542", "tree": {"sha": "74fe5d727d7b73af92500e5d3b1c7b003a903ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fe5d727d7b73af92500e5d3b1c7b003a903ed7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f082c000379548ab460bd02f94e2986491b72c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f082c000379548ab460bd02f94e2986491b72c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f082c000379548ab460bd02f94e2986491b72c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f082c000379548ab460bd02f94e2986491b72c9e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2fbb4d751b0fc9ce11632570f71e267420d36384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbb4d751b0fc9ce11632570f71e267420d36384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbb4d751b0fc9ce11632570f71e267420d36384"}], "stats": {"total": 120, "additions": 118, "deletions": 2}, "files": [{"sha": "a8fd3f9642b073d2a6a897945bfe1cbb17e8602b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f082c000379548ab460bd02f94e2986491b72c9e", "patch": "@@ -1,3 +1,13 @@\n+2011-03-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/predicates.md (word_offset_memref_op): Handle\n+\tcmodel medium addresses.\n+\t* config/rs6000/rs6000.c (rs6000_secondary_reload): Handle misaligned\n+\t64-bit gpr loads and stores.\n+\t(rs6000_secondary_reload_ppc64): New function.\n+\t* config/rs6000/rs6000-protos.h: Declare it.\n+\t* config/rs6000/rs6000.md (reload_di_store, reload_di_load): New.\n+\n 2011-03-26  Alan Modra  <amodra@gmail.com>\n \n \tPR target/47487"}, {"sha": "e407eda86b3c30139b5806deed5d1b5d4fe0448a", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f082c000379548ab460bd02f94e2986491b72c9e", "patch": "@@ -435,9 +435,12 @@\n     op = XEXP (op, 0);\n   else if (GET_CODE (op) == PRE_MODIFY)\n     op = XEXP (op, 1);\n+  else if (GET_CODE (op) == LO_SUM\n+\t   && GET_CODE (XEXP (op, 0)) == REG\n+\t   && GET_CODE (XEXP (op, 1)) == CONST)\n+    op = XEXP (XEXP (op, 1), 0);\n \n   return (GET_CODE (op) != PLUS\n-\t  || ! REG_P (XEXP (op, 0))\n \t  || GET_CODE (XEXP (op, 1)) != CONST_INT\n \t  || INTVAL (XEXP (op, 1)) % 4 == 0);\n })"}, {"sha": "b7b60c0485f117272d0fde89d1f1bfcd88f94427", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f082c000379548ab460bd02f94e2986491b72c9e", "patch": "@@ -79,6 +79,7 @@ extern bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n \t\t\t\t\t\t    enum machine_mode,\n \t\t\t\t\t\t    enum reg_class);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n+extern void rs6000_secondary_reload_ppc64 (rtx, rtx, rtx, bool);\n extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,\n                                          rtx, rtx, rtx);\n extern void paired_expand_vector_move (rtx operands[]);"}, {"sha": "b1efc0dc9d332d07f50b4c6382cf31aef464a3a9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f082c000379548ab460bd02f94e2986491b72c9e", "patch": "@@ -14816,7 +14816,10 @@ rs6000_reload_register_type (enum reg_class rclass)\n    needed for the immediate register.\n \n    For VSX and Altivec, we may need a register to convert sp+offset into\n-   reg+sp.  */\n+   reg+sp.\n+\n+   For misaligned 64-bit gpr loads and stores we need a register to\n+   convert an offset address to indirect.  */\n \n static reg_class_t\n rs6000_secondary_reload (bool in_p,\n@@ -14919,6 +14922,34 @@ rs6000_secondary_reload (bool in_p,\n       else\n \tdefault_p = true;\n     }\n+  else if (TARGET_POWERPC64\n+\t   && rs6000_reload_register_type (rclass) == GPR_REGISTER_TYPE\n+\t   && MEM_P (x)\n+\t   && GET_MODE_SIZE (GET_MODE (x)) >= UNITS_PER_WORD)\n+    {\n+      rtx addr = XEXP (x, 0);\n+\n+      if (GET_CODE (addr) == PRE_MODIFY)\n+\taddr = XEXP (addr, 1);\n+      else if (GET_CODE (addr) == LO_SUM\n+\t       && GET_CODE (XEXP (addr, 0)) == REG\n+\t       && GET_CODE (XEXP (addr, 1)) == CONST)\n+\taddr = XEXP (XEXP (addr, 1), 0);\n+\n+      if (GET_CODE (addr) == PLUS\n+\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (addr, 1)) & 3) != 0)\n+\t{\n+\t  if (in_p)\n+\t    sri->icode = CODE_FOR_reload_di_load;\n+\t  else\n+\t    sri->icode = CODE_FOR_reload_di_store;\n+\t  sri->extra_cost = 2;\n+\t  ret = NO_REGS;\n+\t}\n+      else\n+\tdefault_p = true;\n+    }\n   else\n     default_p = true;\n \n@@ -15207,6 +15238,56 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n   return;\n }\n \n+/* Convert reloads involving 64-bit gprs and misaligned offset\n+   addressing to use indirect addressing.  */\n+\n+void\n+rs6000_secondary_reload_ppc64 (rtx reg, rtx mem, rtx scratch, bool store_p)\n+{\n+  int regno = true_regnum (reg);\n+  enum reg_class rclass;\n+  rtx addr;\n+  rtx scratch_or_premodify = scratch;\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\nrs6000_secondary_reload_ppc64, type = %s\\n\",\n+\t       store_p ? \"store\" : \"load\");\n+      fprintf (stderr, \"reg:\\n\");\n+      debug_rtx (reg);\n+      fprintf (stderr, \"mem:\\n\");\n+      debug_rtx (mem);\n+      fprintf (stderr, \"scratch:\\n\");\n+      debug_rtx (scratch);\n+    }\n+\n+  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n+  gcc_assert (GET_CODE (mem) == MEM);\n+  rclass = REGNO_REG_CLASS (regno);\n+  gcc_assert (rclass == GENERAL_REGS || rclass == BASE_REGS);\n+  addr = XEXP (mem, 0);\n+\n+  if (GET_CODE (addr) == PRE_MODIFY)\n+    {\n+      scratch_or_premodify = XEXP (addr, 0);\n+      gcc_assert (REG_P (scratch_or_premodify));\n+      addr = XEXP (addr, 1);\n+    }\n+  gcc_assert (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM);\n+\n+  rs6000_emit_move (scratch_or_premodify, addr, Pmode);\n+\n+  mem = replace_equiv_address_nv (mem, scratch_or_premodify);\n+\n+  /* Now create the move.  */\n+  if (store_p)\n+    emit_insn (gen_rtx_SET (VOIDmode, mem, reg));\n+  else\n+    emit_insn (gen_rtx_SET (VOIDmode, reg, mem));\n+\n+  return;\n+}\n+\n /* Target hook to return the cover classes for Integrated Register Allocator.\n    Cover classes is a set of non-intersected register classes covering all hard\n    registers used for register allocation purpose.  Any move between two"}, {"sha": "89836d7d63213990a49562cff5066996a2d6d193", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f082c000379548ab460bd02f94e2986491b72c9e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f082c000379548ab460bd02f94e2986491b72c9e", "patch": "@@ -9645,6 +9645,27 @@\n   [(set_attr \"type\" \"two,load,store,*,*,*\")\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n+;; Reload patterns to support gpr load/store with misaligned mem.\n+(define_expand \"reload_di_store\"\n+  [(parallel [(match_operand 0 \"memory_operand\" \"=m\")\n+              (match_operand 1 \"gpc_reg_operand\" \"r\")\n+              (match_operand:DI 2 \"register_operand\" \"=&b\")])]\n+  \"TARGET_POWERPC64\"\n+{\n+  rs6000_secondary_reload_ppc64 (operands[1], operands[0], operands[2], true);\n+  DONE;\n+})\n+\n+(define_expand \"reload_di_load\"\n+  [(parallel [(match_operand 0 \"gpc_reg_operand\" \"=r\")\n+              (match_operand 1 \"memory_operand\" \"m\")\n+              (match_operand:DI 2 \"register_operand\" \"=b\")])]\n+  \"TARGET_POWERPC64\"\n+{\n+  rs6000_secondary_reload_ppc64 (operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*movdf_hardfloat64_mfpgpr\""}]}