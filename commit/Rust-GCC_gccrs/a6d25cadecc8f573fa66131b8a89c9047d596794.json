{"sha": "a6d25cadecc8f573fa66131b8a89c9047d596794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkMjVjYWRlY2M4ZjU3M2ZhNjYxMzFiOGE4OWM5MDQ3ZDU5Njc5NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T11:01:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T11:01:32Z"}, "message": "[multiple changes]\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_elab.adb Add new type Visited_Element\n\tand update the contents of table Elab_Visited.\tVarious code clean up.\n\t(Check_Elab_Call): Determine whether a prior call to\n\tthe same subprogram was already examined within the same context.\n\t(Check_Internal_Call_Continue): Register the subprogram being\n\tcalled as examined within a particular context. Do not suppress\n\telaboration warnings.\n\n2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n\n\t* xoscons.adb, osint.ads: Minor reformatting.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* g-dyntab.ads, g-dyntab.adb: Misc cleanup. Rename\n\tTable_Count_Type --> Table_Last_Type, because the name\n\twas confusing (a \"count\" usually starts at zero).  Add\n\tfunctionality supported or needed by other tables packages\n\t(Move, Release_Threshold).\n\t* g-table.ads, g-table.adb: This is now just a thin wrapper\n\taround g-dyntab.ads/g-dyntab.adb.  Add functionality supported\n\tor needed by other tables packages (Save, Restore).\n\t* table.ads, table.adb: This is now just a thin wrapper around\n\t* g-table.ads/g-table.adb.\n\t* namet.h, scos.h, uintp.h: These files are reaching into the\n\tprivate data of some instances of g-table, whose names changed,\n\tso the above change requires some adjustment here. It now uses\n\tpublic interfaces.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* namet.adb, namet.ads: Minor: remove unused procedures.\n\n2017-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* checks.adb (Apply_Scalar_Range_Check): Initialize Ok variable too.\n\t(Minimize_Eliminate_Overflows): Initialize Llo and Lhi.\n\tAdd pragma Warnings on Rtype variable in nested block.\t*\n\t* exp_ch3.adb (Build_Init_Statements): Initialize VAR_LOC.\n\t* exp_ch4.adb (Expand_Concatenate): Initialize 3 variables.\n\t(Size_In_Storage_Elements): Add pragma Warnings on Res variable.\n\t* exp_ch7.adb (Build_Adjust_Statements): Initialize Bod_Stmts.\n\t(Process_Component_List_For_Finalize): Initialize Counter_Id.\n\t(Build_Finalize_Statements): Initialize Bod_Stmts.\n\t* exp_disp.adb (Expand_Dispatching_Call): Initialize SCIL_Node.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cfhama.adb, a-cfhamai.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions that are\n\tused in subprogram contracts.\n\t(Current_To_Last): Removed, model\n\tfunctions should be used instead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Strict_Equal): Removed, model functions should be used instead.\n\t(No_Overlap): Removed, model functions should be used instead.\n\t(Equivalent_Keys): Functions over cursors are removed. They were\n\tawkward with explicit container parameters.\n\t* a-cofuma.adb, a-cofuma.ads (Lift_Equivalent_Keys): New lemma\n\t(proof only) procedure to help GNATprove when equivalence over\n\tkeys is not equality.\n\nFrom-SVN: r247320", "tree": {"sha": "40189fb2688db0f8dfa38e3d0ebb85abeba0a155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40189fb2688db0f8dfa38e3d0ebb85abeba0a155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6d25cadecc8f573fa66131b8a89c9047d596794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d25cadecc8f573fa66131b8a89c9047d596794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d25cadecc8f573fa66131b8a89c9047d596794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d25cadecc8f573fa66131b8a89c9047d596794/comments", "author": null, "committer": null, "parents": [{"sha": "27eaddda0f838d0c837d902dea4505c48312ef17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eaddda0f838d0c837d902dea4505c48312ef17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27eaddda0f838d0c837d902dea4505c48312ef17"}], "stats": {"total": 2700, "additions": 1241, "deletions": 1459}, "files": [{"sha": "d68ec0edd37f266e433d15f41ddfe9f6289f19a5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -1,3 +1,68 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_elab.adb Add new type Visited_Element\n+\tand update the contents of table Elab_Visited.\tVarious code clean up.\n+\t(Check_Elab_Call): Determine whether a prior call to\n+\tthe same subprogram was already examined within the same context.\n+\t(Check_Internal_Call_Continue): Register the subprogram being\n+\tcalled as examined within a particular context. Do not suppress\n+\telaboration warnings.\n+\n+2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* xoscons.adb, osint.ads: Minor reformatting.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* g-dyntab.ads, g-dyntab.adb: Misc cleanup. Rename\n+\tTable_Count_Type --> Table_Last_Type, because the name\n+\twas confusing (a \"count\" usually starts at zero).  Add\n+\tfunctionality supported or needed by other tables packages\n+\t(Move, Release_Threshold).\n+\t* g-table.ads, g-table.adb: This is now just a thin wrapper\n+\taround g-dyntab.ads/g-dyntab.adb.  Add functionality supported\n+\tor needed by other tables packages (Save, Restore).\n+\t* table.ads, table.adb: This is now just a thin wrapper around\n+\t* g-table.ads/g-table.adb.\n+\t* namet.h, scos.h, uintp.h: These files are reaching into the\n+\tprivate data of some instances of g-table, whose names changed,\n+\tso the above change requires some adjustment here. It now uses\n+\tpublic interfaces.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.adb, namet.ads: Minor: remove unused procedures.\n+\n+2017-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Apply_Scalar_Range_Check): Initialize Ok variable too.\n+\t(Minimize_Eliminate_Overflows): Initialize Llo and Lhi.\n+\tAdd pragma Warnings on Rtype variable in nested block.\t*\n+\t* exp_ch3.adb (Build_Init_Statements): Initialize VAR_LOC.\n+\t* exp_ch4.adb (Expand_Concatenate): Initialize 3 variables.\n+\t(Size_In_Storage_Elements): Add pragma Warnings on Res variable.\n+\t* exp_ch7.adb (Build_Adjust_Statements): Initialize Bod_Stmts.\n+\t(Process_Component_List_For_Finalize): Initialize Counter_Id.\n+\t(Build_Finalize_Statements): Initialize Bod_Stmts.\n+\t* exp_disp.adb (Expand_Dispatching_Call): Initialize SCIL_Node.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfhama.adb, a-cfhamai.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions that are\n+\tused in subprogram contracts.\n+\t(Current_To_Last): Removed, model\n+\tfunctions should be used instead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Strict_Equal): Removed, model functions should be used instead.\n+\t(No_Overlap): Removed, model functions should be used instead.\n+\t(Equivalent_Keys): Functions over cursors are removed. They were\n+\tawkward with explicit container parameters.\n+\t* a-cofuma.adb, a-cofuma.ads (Lift_Equivalent_Keys): New lemma\n+\t(proof only) procedure to help GNATprove when equivalence over\n+\tkeys is not equality.\n+\n 2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb, a-cfdlli.adb, a-cfdlli.ads, exp_ch9.adb, g-dyntab.adb,"}, {"sha": "c292701093e29a65270ef96d894767d3acaae5fd", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 98, "deletions": 190, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -237,35 +237,6 @@ is\n       return Target;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n-\n-   function Current_To_Last (Container : Map; Current : Cursor) return Map is\n-      Curs : Cursor := First (Container);\n-      C    : Map (Container.Capacity, Container.Modulus) :=\n-               Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-\n-      elsif Current /= No_Element and not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-\n-      else\n-         while Curs.Node /= Current.Node loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n-         end loop;\n-\n-         return C;\n-      end if;\n-   end Current_To_Last;\n-\n    ---------------------\n    -- Default_Modulus --\n    ---------------------\n@@ -304,6 +275,7 @@ is\n       HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n \n       Free (Container, Position.Node);\n+      Position := No_Element;\n    end Delete;\n \n    -------------\n@@ -346,79 +318,6 @@ is\n       return Equivalent_Keys (Key, Node.Key);\n    end Equivalent_Keys;\n \n-   function Equivalent_Keys\n-     (Left   : Map;\n-      CLeft  : Cursor;\n-      Right  : Map;\n-      CRight : Cursor) return Boolean\n-   is\n-   begin\n-      if not Has_Element (Left, CLeft) then\n-         raise Constraint_Error with\n-           \"Left cursor of Equivalent_Keys has no element\";\n-      end if;\n-\n-      if not Has_Element (Right, CRight) then\n-         raise Constraint_Error with\n-           \"Right cursor of Equivalent_Keys has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Left, CLeft),\n-                     \"Left cursor of Equivalent_Keys is bad\");\n-      pragma Assert (Vet (Right, CRight),\n-                     \"Right cursor of Equivalent_Keys is bad\");\n-\n-      declare\n-         LN : Node_Type renames Left.Nodes (CLeft.Node);\n-         RN : Node_Type renames Right.Nodes (CRight.Node);\n-      begin\n-         return Equivalent_Keys (LN.Key, RN.Key);\n-      end;\n-   end Equivalent_Keys;\n-\n-   function Equivalent_Keys\n-     (Left  : Map;\n-      CLeft : Cursor;\n-      Right : Key_Type) return Boolean\n-   is\n-   begin\n-      if not Has_Element (Left, CLeft) then\n-         raise Constraint_Error with\n-           \"Left cursor of Equivalent_Keys has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Left, CLeft),\n-                     \"Left cursor in Equivalent_Keys is bad\");\n-\n-      declare\n-         LN : Node_Type renames Left.Nodes (CLeft.Node);\n-      begin\n-         return Equivalent_Keys (LN.Key, Right);\n-      end;\n-   end Equivalent_Keys;\n-\n-   function Equivalent_Keys\n-     (Left   : Key_Type;\n-      Right  : Map;\n-      CRight : Cursor) return Boolean\n-   is\n-   begin\n-      if Has_Element (Right, CRight) then\n-         raise Constraint_Error with\n-           \"Right cursor of Equivalent_Keys has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Right, CRight),\n-                     \"Right cursor of Equivalent_Keys is bad\");\n-\n-      declare\n-         RN : Node_Type renames Right.Nodes (CRight.Node);\n-\n-      begin\n-         return Equivalent_Keys (Left, RN.Key);\n-      end;\n-   end Equivalent_Keys;\n-\n    -------------\n    -- Exclude --\n    -------------\n@@ -460,37 +359,109 @@ is\n       return (Node => Node);\n    end First;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n \n-   function First_To_Previous\n-     (Container : Map;\n-      Current : Cursor) return Map is\n-      Curs : Cursor;\n-      C    : Map (Container.Capacity, Container.Modulus) :=\n-               Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n+   package body Formal_Model is\n \n-   begin\n-      Curs := Current;\n+      ----------\n+      -- Keys --\n+      ----------\n \n-      if Curs = No_Element then\n-         return C;\n+      function Keys (Container : Map) return K.Sequence is\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : K.Sequence;\n \n-      elsif not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n \n-      else\n-         while Curs.Node /= 0 loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n+         while Position /= 0 loop\n+            R := K.Add (R, Container.Nodes (Position).Key);\n+            Position := HT_Ops.Next (Container, Position);\n          end loop;\n \n-         return C;\n-      end if;\n-   end First_To_Previous;\n+         return R;\n+      end Keys;\n+\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n+\n+      procedure Lift_Abstraction_Level (Container : Map) is null;\n+\n+      -----------------------\n+      -- Mapping_preserved --\n+      -----------------------\n+\n+      function Mapping_Preserved\n+        (K_Left  : K.Sequence;\n+         K_Right : K.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if not P.Has_Key (P_Right, C)\n+              or else P.Get (P_Left,  C) > K.Length (K_Left)\n+              or else P.Get (P_Right, C) > K.Length (K_Right)\n+              or else K.Get (K_Left,  P.Get (P_Left,  C)) /=\n+                      K.Get (K_Right, P.Get (P_Right, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Map) return M.Map is\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : M.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := M.Add (Container => R,\n+                        New_Key   => Container.Nodes (Position).Key,\n+                        New_Item  => Container.Nodes (Position).Element);\n+            Position := HT_Ops.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Model;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : Map) return P.Map is\n+         I        : Count_Type := 1;\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : P.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = I);\n+            Position := HT_Ops.Next (Container, Position);\n+            I := I + 1;\n+         end loop;\n+\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n \n    ----------\n    -- Free --\n@@ -747,40 +718,6 @@ is\n       Position := Next (Container, Position);\n    end Next;\n \n-   -------------\n-   -- Overlap --\n-   -------------\n-\n-   function Overlap (Left, Right : Map) return Boolean is\n-      Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.Nodes;\n-\n-   begin\n-      if Length (Right) = 0 or Length (Left) = 0 then\n-         return False;\n-      end if;\n-\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      Left_Node := First (Left).Node;\n-      while Left_Node /= 0 loop\n-         declare\n-            N : Node_Type renames Left_Nodes (Left_Node);\n-            E : Key_Type renames N.Key;\n-         begin\n-            if Find (Right, E).Node /= 0 then\n-               return True;\n-            end if;\n-         end;\n-\n-         Left_Node := HT_Ops.Next (Left, Left_Node);\n-      end loop;\n-\n-      return False;\n-   end Overlap;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -850,35 +787,6 @@ is\n       Node.Next := Next;\n    end Set_Next;\n \n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : Map) return Boolean is\n-      CuL : Cursor := First (Left);\n-      CuR : Cursor := First (Right);\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      while CuL.Node /= 0 or else CuR.Node /= 0 loop\n-         if CuL.Node /= CuR.Node\n-           or else\n-             Left.Nodes (CuL.Node).Element /= Right.Nodes (CuR.Node).Element\n-           or else Left.Nodes (CuL.Node).Key /= Right.Nodes (CuR.Node).Key\n-         then\n-            return False;\n-         end if;\n-\n-         CuL := Next (Left, CuL);\n-         CuR := Next (Right, CuR);\n-      end loop;\n-\n-      return True;\n-   end Strict_Equal;\n-\n    ---------\n    -- Vet --\n    ---------"}, {"sha": "bc10de025748a9c4efe059dc9538c5464a787351", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 562, "deletions": 110, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,17 +44,11 @@\n --    and its previous version C'Old) for expressing properties, which is not\n --    possible if cursors encapsulate an access to the underlying container.\n \n---    There are four new functions:\n-\n---      function Strict_Equal (Left, Right : Map) return Boolean;\n---      function Overlap (Left, Right : Map) return Boolean;\n---      function First_To_Previous (Container : Map; Current : Cursor)\n---         return Map;\n---      function Current_To_Last (Container : Map; Current : Cursor)\n---         return Map;\n-\n---    See detailed specifications for these subprograms\n+--  Iteration over maps is done using the Iterable aspect which is SPARK\n+--  compatible. For of iteration ranges over keys instead of elements.\n \n+with Ada.Containers.Functional_Vectors;\n+with Ada.Containers.Functional_Maps;\n private with Ada.Containers.Hash_Tables;\n \n generic\n@@ -63,89 +57,308 @@ generic\n \n    with function Hash (Key : Key_Type) return Hash_Type;\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Hashed_Maps with\n-  Pure,\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is private with\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (Map);\n+                  Element     => Key),\n+     Default_Initial_Condition => Is_Empty (Map) and Length (Map) = 0;\n    pragma Preelaborable_Initialization (Map);\n \n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n-\n    Empty_Map : constant Map;\n \n-   No_Element : constant Cursor;\n+   type Cursor is record\n+      Node : Count_Type;\n+   end record;\n+\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   function Length (Container : Map) return Count_Type with\n+     Global => null,\n+     Post   => Length'Result <= Container.Capacity;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Maps\n+        (Element_Type    => Element_Type,\n+         Key_Type        => Key_Type,\n+         Equivalent_Keys => Equivalent_Keys);\n+\n+      function \"=\"\n+        (Left  : M.Map;\n+         Right : M.Map) return Boolean renames M.\"=\";\n+\n+      function \"<=\"\n+        (Left  : M.Map;\n+         Right : M.Map) return Boolean renames M.\"<=\";\n+\n+      package K is new Ada.Containers.Functional_Vectors\n+        (Element_Type => Key_Type,\n+         Index_Type   => Positive_Count_Type);\n+\n+      function \"=\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"=\";\n+\n+      function \"<\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"<\";\n+\n+      function \"<=\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"<=\";\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type        => Cursor,\n+         Element_Type    => Positive_Count_Type,\n+         Equivalent_Keys => \"=\");\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function Mapping_Preserved\n+        (K_Left  : K.Sequence;\n+         K_Right : K.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved'Result then\n+\n+             --  Right contains all the cursors of Left\n+\n+             P.Keys_Included (P_Left, P_Right)\n+\n+               --  Mappings from cursors to elements induced by K_Left, P_Left\n+               --  and K_Right, P_Right are the same.\n+\n+               and (for all C of P_Left =>\n+                     K.Get (K_Left, P.Get (P_Left, C)) =\n+                     K.Get (K_Right, P.Get (P_Right, C))));\n+\n+      function Model (Container : Map) return M.Map with\n+      --  The highlevel model of a map is a map from keys to elements. Neither\n+      --  cursors nor order of elements are represented in this model. Keys are\n+      --  modeled up to equivalence.\n+\n+        Ghost,\n+        Global => null;\n+\n+      function Keys (Container : Map) return K.Sequence with\n+      --  The Keys sequence represents the underlying list structure of maps\n+      --  that is used for iteration. It stores the actual values of keys in\n+      --  the map. It does not model cursors nor elements.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          K.Length (Keys'Result) = Length (Container)\n+\n+            --  It only contains keys contained in Model\n+\n+            and (for all Key of Keys'Result =>\n+                   M.Has_Key (Model (Container), Key))\n+\n+            --  It contains all the keys contained in Model\n+\n+            and\n+              (for all Key of Model (Container) =>\n+                (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n+\n+            --  It has no duplicate\n+\n+            and\n+              (for all I in 1 .. Length (Container) =>\n+                (for all J in 1 .. Length (Container) =>\n+                  (if Equivalent_Keys\n+                        (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n+                   then I = J)));\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n+\n+      function Positions (Container : Map) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and map them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length.\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                  then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : Map) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access to the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a lowlevel, cursor aware view of a container, to a highlevel\n+        --  position based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (for all Key of Keys (Container) =>\n+            (for some I of Positions (Container) =>\n+              K.Get (Keys (Container), P.Get (Positions (Container), I)) =\n+                Key));\n+\n+      function Contains\n+        (C : M.Map;\n+         K : Key_Type) return Boolean renames M.Has_Key;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  search for a key in the model to Contains.\n+\n+      function Element\n+        (C : M.Map;\n+         K : Key_Type) return Element_Type renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+   end Formal_Model;\n+   use Formal_Model;\n \n    function \"=\" (Left, Right : Map) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n \n    function Capacity (Container : Map) return Count_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => Capacity'Result = Container.Capacity;\n \n    procedure Reserve_Capacity\n      (Container : in out Map;\n       Capacity  : Count_Type)\n    with\n      Global => null,\n-     Pre    => Capacity <= Container.Capacity;\n-\n-   function Length (Container : Map) return Count_Type with\n-     Global => null;\n+     Pre    => Capacity <= Container.Capacity,\n+     Post   => Model (Container) = Model (Container)'Old;\n \n    function Is_Empty (Container : Map) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = M.Is_Empty (Model (Container));\n \n    procedure Clear (Container : in out Map) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n \n    procedure Assign (Target : in out Map; Source : Map) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)\n+         and Length (Source) = Length (Target)\n+\n+         --  Actual keys are preserved\n+\n+         and\n+           (for all Key of Keys (Source) =>\n+              Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n \n    function Copy\n      (Source   : Map;\n       Capacity : Count_Type := 0) return Map\n    with\n      Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Keys (Copy'Result) = Keys (Source)\n+         and Positions (Copy'Result) = Positions (Source)\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Source.Capacity\n+              else\n+                 Copy'Result.Capacity = Capacity);\n    --  Copy returns a container stricty equal to Source. It must have\n    --  the same cursors associated with each element. Therefore:\n-   --  - capacity=0 means use container.capacity as capacity of target\n+   --  - capacity=0 means use Source.Capacity as capacity of target\n    --  - the modulus cannot be changed.\n \n    function Key (Container : Map; Position : Cursor) return Key_Type with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Key'Result =\n+         K.Get (Keys (Container), P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Key);\n \n    function Element\n      (Container : Map;\n       Position  : Cursor) return Element_Type\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result = Element (Model (Container), Key (Container, Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+\n+       --  Order of keys and cursors are preserved\n+\n+       Keys (Container) = Keys (Container)'Old\n+         and Positions (Container) = Positions (Container)'Old\n+\n+         --  New_Item is now associated to the key at position Position in\n+         --  Container.\n+\n+         and Element (Container, Position) = New_Item\n+\n+         --  Elements associated to other keys are preserved\n+\n+         and M.Same_Keys (Model (Container), Model (Container)'Old)\n+         and M.Elements_Equal_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key (Container, Position));\n \n    procedure Move (Target : in out Map; Source : in out Map) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)'Old\n+         and Length (Source)'Old = Length (Target)\n+         and Length (Source) = 0\n+\n+         --  Actual keys are preserved\n+\n+         and\n+           (for all Key of Keys (Source)'Old =>\n+              Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n \n    procedure Insert\n      (Container : in out Map;\n@@ -154,124 +367,369 @@ is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity or Contains (Container, Key),\n+     Post           =>\n+       Contains (Container, Key)\n+         and Has_Element (Container, Position)\n+         and Equivalent_Keys\n+               (Formal_Hashed_Maps.Key (Container, Position), Key),\n+     Contract_Cases =>\n+\n+       --  If Key is already in Container, it is not modified and Inserted is\n+       --  set to False.\n+\n+       (Contains (Container, Key) =>\n+          not Inserted\n+            and Model (Container) = Model (Container)'Old\n+            and Keys (Container) = Keys (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Key is inserted in Container and Inserted is set to True\n+\n+        others =>\n+          Inserted\n+            and Length (Container) = Length (Container)'Old + 1\n+\n+            --  Key now maps to New_Item\n+\n+            and Formal_Hashed_Maps.Key (Container, Position) = Key\n+            and Element (Model (Container), Key) = New_Item\n+\n+            --  Other keys are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Keys_Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key)\n+\n+            --  Mapping from cursors to keys are preserved\n+\n+            and Mapping_Preserved\n+                  (K_Left  => Keys (Container)'Old,\n+                   K_Right => Keys (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container))\n+            and P.Keys_Included_Except\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Position));\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, Key));\n+     Pre    =>\n+       Length (Container) < Container.Capacity\n+        and then (not Contains (Container, Key)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+         and Contains (Container, Key)\n+\n+         --  Key now maps to New_Item\n+\n+         and Formal_Hashed_Maps.Key (Container, Find (Container, Key)) = Key\n+         and Element (Model (Container), Key) = New_Item\n+\n+         --  Other keys are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+         and M.Keys_Included_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key)\n+\n+         --  Mapping from cursors to keys are preserved\n+\n+         and Mapping_Preserved\n+               (K_Left  => Keys (Container)'Old,\n+                K_Right => Keys (Container),\n+                P_Left  => Positions (Container)'Old,\n+                P_Right => Positions (Container))\n+         and P.Keys_Included_Except\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Find (Container, Key));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity or Contains (Container, Key),\n+     Post           =>\n+       Contains (Container, Key) and Element (Container, Key) = New_Item,\n+     Contract_Cases =>\n+\n+       --  If Key is already in Container, Key is mapped to New_Item\n+\n+       (Contains (Container, Key) =>\n+\n+          --  Cursors are preserved\n+\n+          Positions (Container) = Positions (Container)'Old\n+\n+            --  The key equivalent to Key in Container is replaced by Key\n+\n+            and K.Get (Keys (Container),\n+                       P.Get (Positions (Container), Find (Container, Key))) =\n+                Key\n+            and K.Equal_Except\n+                  (Keys (Container)'Old,\n+                   Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key)))\n+\n+            --  Elements associated to other keys are preserved\n+\n+            and M.Same_Keys (Model (Container), Model (Container)'Old)\n+            and M.Elements_Equal_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key),\n+\n+        --  Otherwise, Key is inserted in Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old + 1\n+\n+            --  Other keys are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Keys_Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key)\n+\n+            --  Mapping from cursors to keys are preserved\n+\n+            and Mapping_Preserved\n+                  (K_Left  => Keys (Container)'Old,\n+                   K_Right => Keys (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container))\n+            and P.Keys_Included_Except\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Find (Container, Key)));\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Contains (Container, Key);\n+     Pre    => Contains (Container, Key),\n+     Post   =>\n+\n+       --  Cursors are preserved\n+\n+       Positions (Container) = Positions (Container)'Old\n+\n+         --  The key equivalent to Key in Container is replaced by Key\n+\n+         and K.Get (Keys (Container),\n+                    P.Get (Positions (Container), Find (Container, Key))) = Key\n+         and K.Equal_Except\n+              (Keys (Container)'Old,\n+               Keys (Container),\n+               P.Get (Positions (Container), Find (Container, Key)))\n+\n+         --  New_Item is now associated to the Key in Container\n+\n+         and Element (Model (Container), Key) = New_Item\n+\n+         --  Elements associated to other keys are preserved\n+\n+         and M.Same_Keys (Model (Container), Model (Container)'Old)\n+         and M.Elements_Equal_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key);\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) with\n-     Global => null;\n+     Global         => null,\n+     Post           => not Contains (Container, Key),\n+     Contract_Cases =>\n+\n+       --  If Key is not in Container, nothing is changed\n+\n+       (not Contains (Container, Key) =>\n+          Model (Container) = Model (Container)'Old\n+            and Keys (Container) = Keys (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Key is removed from Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Other keys are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Keys_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Key)\n+\n+            --  Mapping from cursors to keys are preserved\n+\n+            and Mapping_Preserved\n+                  (K_Left  => Keys (Container),\n+                   K_Right => Keys (Container)'Old,\n+                   P_Left  => Positions (Container),\n+                   P_Right => Positions (Container)'Old)\n+            and P.Keys_Included_Except\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Find (Container, Key)'Old));\n \n    procedure Delete (Container : in out Map; Key : Key_Type) with\n      Global => null,\n-     Pre    => Contains (Container, Key);\n+     Pre    => Contains (Container, Key),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Key is no longer in Container\n+\n+         and not Contains (Container, Key)\n+\n+         --  Other keys are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Keys_Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Key)\n+\n+         --  Mapping from cursors to keys are preserved\n+\n+         and Mapping_Preserved\n+               (K_Left  => Keys (Container),\n+                K_Right => Keys (Container)'Old,\n+                P_Left  => Positions (Container),\n+                P_Right => Positions (Container)'Old)\n+         and P.Keys_Included_Except\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Find (Container, Key)'Old);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Position = No_Element\n+         and Length (Container) = Length (Container)'Old - 1\n+\n+         --  The key at position Position is no longer in Container\n+\n+         and not Contains (Container, Key (Container, Position)'Old)\n+         and not P.Has_Key (Positions (Container), Position'Old)\n+\n+         --  Other keys are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Keys_Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Key (Container, Position)'Old)\n+\n+         --  Mapping from cursors to keys are preserved\n+\n+         and Mapping_Preserved\n+               (K_Left  => Keys (Container),\n+                K_Right => Keys (Container)'Old,\n+                P_Left  => Positions (Container),\n+                P_Right => Positions (Container)'Old)\n+         and P.Keys_Included_Except\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Position'Old);\n \n    function First (Container : Map) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n \n    function Next (Container : Map; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : Map; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n \n    function Find (Container : Map; Key : Key_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n \n-   function Contains (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null;\n+       --  If Key is not is not contained in Container, Find returns No_Element\n \n-   function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Global => null,\n-     Pre    => Contains (Container, Key);\n+       (not Contains (Model (Container), Key) =>\n+          Find'Result = No_Element,\n \n-   function Has_Element (Container : Map; Position : Cursor) return Boolean\n-   with\n-     Global => null;\n+        --  Otherwise, Find returns a valid cusror in Container\n \n-   function Equivalent_Keys\n-     (Left   : Map;\n-      CLeft  : Cursor;\n-      Right  : Map;\n-      CRight : Cursor) return Boolean\n-   with\n-     Global => null;\n+        others =>\n+          P.Has_Key (Positions (Container), Find'Result)\n \n-   function Equivalent_Keys\n-     (Left  : Map;\n-      CLeft : Cursor;\n-      Right : Key_Type) return Boolean\n-   with\n-     Global => null;\n+            --  The key designated by the result of Find is Key\n \n-   function Equivalent_Keys\n-     (Left   : Key_Type;\n-      Right  : Map;\n-      CRight : Cursor) return Boolean\n-   with\n-     Global => null;\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n-     Global => null;\n+            and Equivalent_Keys\n+                  (Formal_Hashed_Maps.Key (Container, Find'Result), Key));\n \n-   function Strict_Equal (Left, Right : Map) return Boolean with\n-     Ghost,\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n+   function Contains (Container : Map; Key : Key_Type) return Boolean with\n+     Global => null,\n+     Post   => Contains'Result = Contains (Model (Container), Key);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n \n-   function First_To_Previous (Container : Map; Current : Cursor) return Map\n-   with\n-     Ghost,\n+   function Element (Container : Map; Key : Key_Type) return Element_Type with\n      Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+     Pre    => Contains (Container, Key),\n+     Post   => Element'Result = Element (Model (Container), Key);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n-   function Current_To_Last (Container : Map; Current : Cursor) return Map\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean\n    with\n-     Ghost,\n      Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n-\n-   function Overlap (Left, Right : Map) return Boolean with\n+     Post   =>\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n      Global => null;\n-   --  Overlap returns True if the containers have common keys\n \n private\n    pragma SPARK_Mode (Off);\n@@ -302,12 +760,6 @@ private\n \n    use HT_Types;\n \n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n    Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n \n-   No_Element : constant Cursor := (Node => 0);\n-\n end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "38e481be571d2b8095fda13ba3e66734aaed4057", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -93,8 +93,10 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             K : constant Key_Type := Get (Left.Keys, I);\n          begin\n             if not Equivalent_Keys (K, New_Key)\n-              and then Get (Right.Elements, Find (Right.Keys, K)) /=\n-                       Get (Left.Elements, I)\n+              and then\n+                (Find (Right.Keys, K) = 0\n+                   or else Get (Right.Elements, Find (Right.Keys, K)) /=\n+                           Get (Left.Elements, I))\n             then\n                return False;\n             end if;\n@@ -116,8 +118,10 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n          begin\n             if not Equivalent_Keys (K, X)\n               and then not Equivalent_Keys (K, Y)\n-              and then Get (Right.Elements, Find (Right.Keys, K)) /=\n-                       Get (Left.Elements, I)\n+              and then\n+                (Find (Right.Keys, K) = 0\n+                   or else Get (Right.Elements, Find (Right.Keys, K)) /=\n+                           Get (Left.Elements, I))\n             then\n                return False;\n             end if;\n@@ -229,6 +233,16 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n       return Length (Container.Elements);\n    end Length;\n \n+   --------------------------\n+   -- Lift_Equivalent_Keys --\n+   --------------------------\n+\n+   procedure Lift_Equivalent_Keys\n+     (Container : Map;\n+      Left      : Key_Type;\n+      Right     : Key_Type)\n+   is null;\n+\n    ---------------\n    -- Same_Keys --\n    ---------------"}, {"sha": "1172d11895280ad6193132a62d1b6105ba4577b7", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -48,6 +48,9 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    --  Maps are empty when default initialized.\n    --  \"For in\" quantification over maps should not be used.\n    --  \"For of\" quantification over maps iterates over keys.\n+   --  Note that, for proof, for of quantification is understood modulo\n+   --  equivalence (quantification includes keys equivalent to keys of the\n+   --  map).\n \n    -----------------------\n    --  Basic operations --\n@@ -71,6 +74,22 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Global => null;\n    --  Return the number of mappings in Container\n \n+   procedure Lift_Equivalent_Keys\n+     (Container : Map;\n+      Left      : Key_Type;\n+      Right     : Key_Type)\n+   --  Lemma function which can be called manually to allow GNATprove to deduce\n+   --  that Has_Key and Get always return the same result on equivalent keys.\n+\n+   with\n+     Ghost,\n+     Global => null,\n+     Pre    => Equivalent_Keys (Left, Right),\n+     Post   =>\n+       Has_Key (Container, Left) = Has_Key (Container, Right)\n+         and (if Has_Key (Container, Left) then\n+                Get (Container, Left) = Get (Container, Right));\n+\n    ------------------------\n    -- Property Functions --\n    ------------------------\n@@ -162,12 +181,12 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    with\n      Global => null,\n-     Pre    => Keys_Included_Except (Left, Right, New_Key),\n      Post   =>\n        Elements_Equal_Except'Result =\n          (for all Key of Left =>\n            (if not Equivalent_Keys (Key, New_Key) then\n-               Get (Left, Key) = Get (Right, Key)));\n+               Has_Key (Right, Key)\n+                 and then Get (Left, Key) = Get (Right, Key)));\n \n    function Elements_Equal_Except\n      (Left  : Map;\n@@ -179,14 +198,14 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    with\n      Global => null,\n-     Pre    => Keys_Included_Except (Left, Right, X, Y),\n      Post   =>\n        Elements_Equal_Except'Result =\n          (for all Key of Left =>\n            (if not Equivalent_Keys (Key, X)\n               and not Equivalent_Keys (Key, Y)\n             then\n-               Get (Left, Key) = Get (Right, Key)));\n+               Has_Key (Right, Key)\n+                 and then Get (Left, Key) = Get (Right, Key)));\n \n    ----------------------------\n    -- Construction Functions --"}, {"sha": "8ed4893e7f9df53a921016ddfd1c354648414e71", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -2738,7 +2738,7 @@ package body Checks is\n       S_Typ   : Entity_Id;\n       Arr     : Node_Id   := Empty;  -- initialize to prevent warning\n       Arr_Typ : Entity_Id := Empty;  -- initialize to prevent warning\n-      OK      : Boolean;\n+      OK      : Boolean   := False;  -- initialize to prevent warning\n \n       Is_Subscr_Ref : Boolean;\n       --  Set true if Expr is a subscript\n@@ -7936,7 +7936,8 @@ package body Checks is\n       Rlo, Rhi : Uint;\n       --  Ranges of values for right operand (operator case)\n \n-      Llo, Lhi : Uint;\n+      Llo : Uint := No_Uint;  -- initialize to prevent warning\n+      Lhi : Uint := No_Uint;  -- initialize to prevent warning\n       --  Ranges of values for left operand (operator case)\n \n       LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n@@ -8238,6 +8239,7 @@ package body Checks is\n             else\n                declare\n                   Rtype    : Entity_Id;\n+                  pragma Warnings (Off, Rtype);\n                   New_Alts : List_Id;\n                   New_Exp  : Node_Id;\n "}, {"sha": "8520de4e6b7735e4183a40efbb11cdf559760e05", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -3174,7 +3174,7 @@ package body Exp_Ch3 is\n          if Present (Variant_Part (Comp_List)) then\n             declare\n                Variant_Alts : constant List_Id := New_List;\n-               Var_Loc      : Source_Ptr;\n+               Var_Loc      : Source_Ptr := No_Location;\n                Variant      : Node_Id;\n \n             begin"}, {"sha": "21d2621b53ed71b61563f8302d6b1957679a5314", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -2700,7 +2700,7 @@ package body Exp_Ch4 is\n       --  last operand is always retained, in case it provides the bounds for\n       --  a null result.\n \n-      Opnd : Node_Id;\n+      Opnd : Node_Id := Empty;\n       --  Current operand being processed in the loop through operands. After\n       --  this loop is complete, always contains the last operand (which is not\n       --  the same as Operands (NN), since null operands are skipped).\n@@ -2742,13 +2742,13 @@ package body Exp_Ch4 is\n       --  This is either an integer literal node, or an identifier reference to\n       --  a constant entity initialized to the appropriate value.\n \n-      Last_Opnd_Low_Bound : Node_Id;\n+      Last_Opnd_Low_Bound : Node_Id := Empty;\n       --  A tree node representing the low bound of the last operand. This\n       --  need only be set if the result could be null. It is used for the\n       --  special case of setting the right low bound for a null result.\n       --  This is of type Ityp.\n \n-      Last_Opnd_High_Bound : Node_Id;\n+      Last_Opnd_High_Bound : Node_Id := Empty;\n       --  A tree node representing the high bound of the last operand. This\n       --  need only be set if the result could be null. It is used for the\n       --  special case of setting the right high bound for a null result.\n@@ -4036,6 +4036,7 @@ package body Exp_Ch4 is\n          declare\n             Len : Node_Id;\n             Res : Node_Id;\n+            pragma Warnings (Off, Res);\n \n          begin\n             for J in 1 .. Number_Dimensions (E) loop"}, {"sha": "0a9bc0ed8288ec673ba8452ee6525cd2797b3479", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6722,7 +6722,7 @@ package body Exp_Ch7 is\n \n          --  Local variables\n \n-         Bod_Stmts       : List_Id;\n+         Bod_Stmts       : List_Id := No_List;\n          Finalizer_Decls : List_Id := No_List;\n          Rec_Def         : Node_Id;\n \n@@ -7068,7 +7068,7 @@ package body Exp_Ch7 is\n             --  Local variables\n \n             Alts       : List_Id;\n-            Counter_Id : Entity_Id;\n+            Counter_Id : Entity_Id := Empty;\n             Decl       : Node_Id;\n             Decl_Id    : Entity_Id;\n             Decl_Typ   : Entity_Id;\n@@ -7305,7 +7305,7 @@ package body Exp_Ch7 is\n \n          --  Local variables\n \n-         Bod_Stmts       : List_Id;\n+         Bod_Stmts       : List_Id := No_List;\n          Finalizer_Decls : List_Id := No_List;\n          Rec_Def         : Node_Id;\n "}, {"sha": "0a6a03b7fd5f6b594a2d7abcac518c92484bd38a", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -673,7 +673,7 @@ package body Exp_Disp is\n       --  Local variables\n \n       New_Node          : Node_Id;\n-      SCIL_Node         : Node_Id;\n+      SCIL_Node         : Node_Id := Empty;\n       SCIL_Related_Node : Node_Id := Call_Node;\n \n    --  Start of processing for Expand_Dispatching_Call"}, {"sha": "384d5137817888aa45845b5afafb3777307f5d9c", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 74, "deletions": 20, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -34,6 +34,7 @@ pragma Compiler_Unit_Warning;\n with GNAT.Heap_Sort_G;\n \n with Ada.Unchecked_Deallocation;\n+with System;\n \n package body GNAT.Dynamic_Tables is\n \n@@ -44,7 +45,7 @@ package body GNAT.Dynamic_Tables is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Grow (T : in out Instance; New_Last : Table_Count_Type);\n+   procedure Grow (T : in out Instance; New_Last : Table_Last_Type);\n    --  This is called when we are about to set the value of Last to a value\n    --  that is larger than Last_Allocated. This reallocates the table to the\n    --  larger size, as indicated by New_Last. At the time this is called,\n@@ -128,22 +129,20 @@ package body GNAT.Dynamic_Tables is\n \n    begin\n       if T.Table = Empty then\n-         pragma Assert (T.P.Last_Allocated = First - 1);\n-         pragma Assert (T.P.Last = First - 1);\n+         pragma Assert (T.P = (Last_Allocated | Last => First - 1));\n          null;\n       else\n          Free (Temp);\n          T.Table := Empty;\n-         T.P.Last_Allocated := First - 1;\n-         T.P.Last := First - 1;\n+         T.P := (Last_Allocated | Last => First - 1);\n       end if;\n    end Free;\n \n    ----------\n    -- Grow --\n    ----------\n \n-   procedure Grow (T : in out Instance; New_Last : Table_Count_Type) is\n+   procedure Grow (T : in out Instance; New_Last : Table_Last_Type) is\n \n       --  Note: Type Alloc_Ptr below needs to be declared locally so we know\n       --  the bounds. That means that the collection is local, so is finalized\n@@ -158,7 +157,7 @@ package body GNAT.Dynamic_Tables is\n       subtype Table_Length_Type is Table_Index_Type'Base\n         range 0 .. Table_Index_Type'Base'Last;\n \n-      Old_Last_Allocated   : constant Table_Count_Type  := T.P.Last_Allocated;\n+      Old_Last_Allocated   : constant Table_Last_Type  := T.P.Last_Allocated;\n       Old_Allocated_Length : constant Table_Length_Type :=\n                                Old_Last_Allocated - First + 1;\n \n@@ -241,24 +240,82 @@ package body GNAT.Dynamic_Tables is\n       Free (T);\n    end Init;\n \n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (T : Instance) return Boolean is\n+      Result : constant Boolean := T.P.Last = Table_Low_Bound - 1;\n+   begin\n+      pragma Assert (Result = (T.Table = Empty));\n+      return Result;\n+   end Is_Empty;\n+\n    ----------\n    -- Last --\n    ----------\n \n-   function Last (T : Instance) return Table_Count_Type is\n+   function Last (T : Instance) return Table_Last_Type is\n    begin\n       return T.P.Last;\n    end Last;\n \n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (From, To : in out Instance) is\n+   begin\n+      pragma Assert (Is_Empty (To));\n+      To := From;\n+\n+      From.Table            := Empty;\n+      From.Locked           := False;\n+      From.P.Last_Allocated := Table_Low_Bound - 1;\n+      From.P.Last           := Table_Low_Bound - 1;\n+      pragma Assert (Is_Empty (From));\n+   end Move;\n+\n    -------------\n    -- Release --\n    -------------\n \n    procedure Release (T : in out Instance) is\n-      pragma Assert (not T.Locked);\n-      Old_Last_Allocated : constant Table_Count_Type := T.P.Last_Allocated;\n+      Old_Last_Allocated : constant Table_Last_Type := T.P.Last_Allocated;\n+\n+      function New_Last_Allocated return Table_Last_Type;\n+      --  Compute the new value of Last_Allocated. This is normally equal to\n+      --  Last, but if Release_Threshold /= 0, then we need to take that into\n+      --  account.\n+\n+      function New_Last_Allocated return Table_Last_Type is\n+         subtype Table_Length_Type is Table_Index_Type'Base\n+           range 0 .. Table_Index_Type'Base'Last;\n+         Length : constant Table_Length_Type := T.P.Last - First + 1;\n+         Comp_Size_In_Bytes : constant Table_Length_Type :=\n+           Table_Type'Component_Size / System.Storage_Unit;\n+         Length_Threshold : constant Table_Length_Type :=\n+           Table_Length_Type (Release_Threshold) / Comp_Size_In_Bytes;\n+      begin\n+         if Release_Threshold = 0\n+           or else Length < Length_Threshold\n+         then\n+            return T.P.Last;\n+         else\n+            declare\n+               Extra_Length : constant Table_Length_Type := Length / 1000;\n+            begin\n+               return (Length + Extra_Length) - 1 + First;\n+            end;\n+         end if;\n+      end New_Last_Allocated;\n+\n+      New_Last_Alloc : constant Table_Last_Type := New_Last_Allocated;\n+\n+   --  Start of processing for Release\n+\n    begin\n-      if T.P.Last /= T.P.Last_Allocated then\n+      if New_Last_Alloc < T.P.Last_Allocated then\n          pragma Assert (T.P.Last < T.P.Last_Allocated);\n          pragma Assert (T.Table /= Empty);\n \n@@ -272,23 +329,21 @@ package body GNAT.Dynamic_Tables is\n               new Ada.Unchecked_Conversion (Table_Ptr, Old_Alloc_Ptr);\n \n             subtype Alloc_Type is\n-              Table_Type (First .. First + T.P.Last - 1);\n+              Table_Type (First .. New_Last_Alloc);\n             type Alloc_Ptr is access all Alloc_Type;\n \n             function To_Table_Ptr is\n-              new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n+               new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n \n             Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n-            New_Table : constant Alloc_Ptr :=\n-                          new Alloc_Type'(Old_Table (Alloc_Type'Range));\n+            New_Table : constant Alloc_Ptr := new Alloc_Type;\n          begin\n-            T.P.Last_Allocated := T.P.Last;\n+            New_Table (Alloc_Type'Range) := Old_Table (Alloc_Type'Range);\n+            T.P.Last_Allocated := New_Last_Alloc;\n             Free (Old_Table);\n             T.Table := To_Table_Ptr (New_Table);\n          end;\n       end if;\n-\n-      pragma Assert (T.P.Last = T.P.Last_Allocated);\n    end Release;\n \n    --------------\n@@ -329,8 +384,7 @@ package body GNAT.Dynamic_Tables is\n    -- Set_Last --\n    --------------\n \n-   procedure Set_Last (T : in out Instance; New_Val : Table_Count_Type) is\n-      pragma Assert (not T.Locked);\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Last_Type) is\n    begin\n       if New_Val > T.P.Last_Allocated then\n          Grow (T, New_Val);"}, {"sha": "9bfccc2822e953711f958363e3929f06d8ae076f", "filename": "gcc/ada/g-dyntab.ads", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-dyntab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-dyntab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2016, AdaCore                     --\n+--                     Copyright (C) 2000-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,13 +36,10 @@\n --  arrays as closely as possible with the one additional capability of\n --  dynamically modifying the value of the Last attribute.\n \n---  This package provides a facility similar to that of GNAT.Table, except\n---  that this package declares a type that can be used to define dynamic\n---  instances of the table, while an instantiation of GNAT.Table creates a\n---  single instance of the table type.\n+--  This package provides a facility similar to that of Ada.Containers.Vectors.\n \n --  Note that these three interfaces should remain synchronized to keep as much\n---  coherency as possible among these three related units:\n+--  coherency as possible among these related units:\n --\n --     GNAT.Dynamic_Tables\n --     GNAT.Table\n@@ -56,9 +53,10 @@ generic\n    type Table_Component_Type is private;\n    type Table_Index_Type     is range <>;\n \n-   Table_Low_Bound : Table_Index_Type;\n-   Table_Initial   : Positive := 8;\n-   Table_Increment : Natural := 100;\n+   Table_Low_Bound   : Table_Index_Type;\n+   Table_Initial     : Positive := 8;\n+   Table_Increment   : Natural := 100;\n+   Release_Threshold : Natural := 0; -- size in bytes\n \n package GNAT.Dynamic_Tables is\n \n@@ -69,15 +67,42 @@ package GNAT.Dynamic_Tables is\n \n    --  The lower bound of Table_Index_Type is ignored.\n \n-   pragma Assert (Table_Low_Bound /= Table_Index_Type'Base'First);\n+   --  Table_Component_Type must not be a type with controlled parts.\n \n-   function First return Table_Index_Type;\n-   pragma Inline (First);\n-   --  Export First as synonym for Table_Low_Bound (parallel with use of Last)\n+   --  The Table_Initial value controls the allocation of the table when\n+   --  it is first allocated.\n+\n+   --  The Table_Increment value controls the amount of increase, if the\n+   --  table has to be increased in size. The value given is a percentage\n+   --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+\n+   --  The Last and Set_Last subprograms provide control over the current\n+   --  logical allocation. They are quite efficient, so they can be used\n+   --  freely (expensive reallocation occurs only at major granularity\n+   --  chunks controlled by the allocation parameters).\n+\n+   --  Note: we do not make the table components aliased, since this would\n+   --  restrict the use of table for discriminated types. If it is necessary\n+   --  to take the access of a table element, use Unrestricted_Access.\n+\n+   --  WARNING: On HPPA, the virtual addressing approach used in this unit\n+   --  is incompatible with the indexing instructions on the HPPA. So when\n+   --  using this unit, compile your application with -mdisable-indexing.\n+\n+   --  WARNING: If the table is reallocated, then the address of all its\n+   --  components will change. So do not capture the address of an element\n+   --  and then use the address later after the table may be reallocated.\n+   --  One tricky case of this is passing an element of the table to a\n+   --  subprogram by reference where the table gets reallocated during\n+   --  the execution of the subprogram. The best rule to follow is never\n+   --  to pass a table element as a parameter except for the case of IN\n+   --  mode parameters with scalar values.\n+\n+   pragma Assert (Table_Low_Bound /= Table_Index_Type'Base'First);\n \n    subtype Valid_Table_Index_Type is Table_Index_Type'Base\n      range Table_Low_Bound .. Table_Index_Type'Base'Last;\n-   subtype Table_Count_Type is Table_Index_Type'Base\n+   subtype Table_Last_Type is Table_Index_Type'Base\n      range Table_Low_Bound - 1 .. Table_Index_Type'Base'Last;\n \n    --  Table_Component_Type must not be a type with controlled parts.\n@@ -112,7 +137,7 @@ package GNAT.Dynamic_Tables is\n \n    --     Table : Table_Type renames T.Table (First .. Last (T));\n \n-   --  and the refer to components of Table.\n+   --  and then refer to components of Table.\n \n    type Table_Ptr is access all Big_Table_Type;\n    for Table_Ptr'Storage_Size use 0;\n@@ -132,7 +157,7 @@ package GNAT.Dynamic_Tables is\n    --  an empty array.\n \n    type Instance is record\n-      Table : aliased Table_Ptr :=\n+      Table : Table_Ptr :=\n                 Empty_Table_Array_Ptr_To_Table_Ptr (Empty_Table_Array'Access);\n       --  The table itself. The lower bound is the value of First. Logically\n       --  the upper bound is the current value of Last (although the actual\n@@ -143,35 +168,50 @@ package GNAT.Dynamic_Tables is\n       --  to ensure bounds checking, as in:\n       --\n       --     Tab : Table_Type renames X.Table (First .. X.Last);\n+      --\n+      --  Note: The Table component must come first. See declarations of\n+      --  SCO_Unit_Table and SCO_Table in scos.h.\n \n       Locked : Boolean := False;\n-      --  Table expansion is permitted only if this switch is set to False. A\n-      --  client may set Locked to True, in which case any attempt to expand\n-      --  the table will cause an assertion failure. Note that while a table\n-      --  is locked, its address in memory remains fixed and unchanging.\n+      --  Table expansion is permitted only if this is False. A client may set\n+      --  Locked to True, in which case any attempt to expand the table will\n+      --  cause an assertion failure. Note that while a table is locked, its\n+      --  address in memory remains fixed and unchanging.\n \n       P : Table_Private;\n    end record;\n \n+   function Is_Empty (T : Instance) return Boolean;\n+\n    procedure Init (T : in out Instance);\n    --  Reinitializes the table to empty. There is no need to call this before\n    --  using a table; tables default to empty.\n \n-   function Last (T : Instance) return Table_Count_Type;\n+   function First return Table_Index_Type;\n+   pragma Inline (First);\n+   --  Export First as synonym for Table_Low_Bound (parallel with use of Last)\n+\n+   function Last (T : Instance) return Table_Last_Type;\n    pragma Inline (Last);\n    --  Returns the current value of the last used entry in the table, which can\n    --  then be used as a subscript for Table.\n \n    procedure Release (T : in out Instance);\n    --  Storage is allocated in chunks according to the values given in the\n-   --  Table_Initial and Table_Increment parameters. A call to Release releases\n-   --  all storage that is allocated, but is not logically part of the current\n-   --  array value. Current array values are not affected by this call.\n+   --  Table_Initial and Table_Increment parameters. If Release_Threshold is 0\n+   --  or the length of the table does not exceed this threshold then a call to\n+   --  Release releases all storage that is allocated, but is not logically\n+   --  part of the current array value; otherwise the call to Release leaves\n+   --  the current array value plus 0.1% of the current table length free\n+   --  elements located at the end of the table. This parameter facilitates\n+   --  reopening large tables and adding a few elements without allocating a\n+   --  chunk of memory. In both cases current array values are not affected by\n+   --  this call.\n \n    procedure Free (T : in out Instance);\n    --  Same as Init\n \n-   procedure Set_Last (T : in out Instance; New_Val : Table_Count_Type);\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Last_Type);\n    pragma Inline (Set_Last);\n    --  This procedure sets Last to the indicated value. If necessary the table\n    --  is reallocated to accommodate the new value (i.e. on return the\n@@ -205,8 +245,11 @@ package GNAT.Dynamic_Tables is\n    pragma Inline (Set_Item);\n    --  Put Item in the table at position Index. If Index points to an existing\n    --  item (i.e. it is in the range First .. Last (T)), the item is replaced.\n-   --  Otherwise (i.e. Index > Last (T), the table is expanded, and Last is set\n-   --  to Index.\n+   --  Otherwise (i.e. Index > Last (T)), the table is expanded, and Last is\n+   --  set to Index.\n+\n+   procedure Move (From, To : in out Instance);\n+   --  Moves from From to To, and sets From to empty\n \n    procedure Allocate (T : in out Instance; Num : Integer := 1);\n    pragma Inline (Allocate);\n@@ -236,11 +279,11 @@ package GNAT.Dynamic_Tables is\n private\n \n    type Table_Private is record\n-      Last_Allocated : Table_Count_Type := Table_Low_Bound - 1;\n+      Last_Allocated : Table_Last_Type := Table_Low_Bound - 1;\n       --  Subscript of the maximum entry in the currently allocated table.\n       --  Initial value ensures that we initially allocate the table.\n \n-      Last : Table_Count_Type := Table_Low_Bound - 1;\n+      Last : Table_Last_Type := Table_Low_Bound - 1;\n       --  Current value of Last function\n \n       --  Invariant: Last <= Last_Allocated"}, {"sha": "1c122d73a5218723ce6c7340968507e79f63bb67", "filename": "gcc/ada/g-table.adb", "status": "modified", "additions": 57, "deletions": 275, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-table.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-table.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -29,62 +29,27 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with GNAT.Heap_Sort_G;\n-\n with System;        use System;\n with System.Memory; use System.Memory;\n \n with Ada.Unchecked_Conversion;\n \n package body GNAT.Table is\n \n-   Min : constant Integer := Integer (Table_Low_Bound);\n-   --  Subscript of the minimum entry in the currently allocated table\n-\n-   Max : Integer;\n-   --  Subscript of the maximum entry in the currently allocated table\n-\n-   Length : Integer := 0;\n-   --  Number of entries in currently allocated table. The value of zero\n-   --  ensures that we initially allocate the table.\n-\n-   Last_Val : Integer;\n-   --  Current value of Last\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Reallocate;\n-   --  Reallocate the existing table according to the current value stored\n-   --  in Max. Works correctly to do an initial allocation if the table\n-   --  is currently null.\n-\n-   pragma Warnings (Off);\n-   --  Turn off warnings. The following unchecked conversions are only used\n-   --  internally in this package, and cannot never result in any instances\n-   --  of improperly aliased pointers for the client of the package.\n-\n-   function To_Address is new Ada.Unchecked_Conversion (Table_Ptr, Address);\n-   function To_Pointer is new Ada.Unchecked_Conversion (Address, Table_Ptr);\n-\n-   pragma Warnings (On);\n-\n    --------------\n    -- Allocate --\n    --------------\n \n-   function Allocate (Num : Integer := 1) return Table_Index_Type is\n-      Old_Last : constant Integer := Last_Val;\n-\n+   procedure Allocate (Num : Integer := 1) is\n    begin\n-      Last_Val := Last_Val + Num;\n-\n-      if Last_Val > Max then\n-         Reallocate;\n-      end if;\n+      Tab.Allocate (The_Instance, Num);\n+   end Allocate;\n \n-      return Table_Index_Type (Old_Last + 1);\n+   function Allocate (Num : Integer := 1) return Valid_Table_Index_Type is\n+      Result : constant Valid_Table_Index_Type := Last + 1;\n+   begin\n+      Allocate (Num);\n+      return Result;\n    end Allocate;\n \n    ------------\n@@ -93,7 +58,7 @@ package body GNAT.Table is\n \n    procedure Append (New_Val : Table_Component_Type) is\n    begin\n-      Set_Item (Table_Index_Type (Last_Val + 1), New_Val);\n+      Tab.Append (The_Instance, New_Val);\n    end Append;\n \n    ----------------\n@@ -102,9 +67,7 @@ package body GNAT.Table is\n \n    procedure Append_All (New_Vals : Table_Type) is\n    begin\n-      for J in New_Vals'Range loop\n-         Append (New_Vals (J));\n-      end loop;\n+      Tab.Append_All (The_Instance, New_Vals);\n    end Append_All;\n \n    --------------------\n@@ -113,7 +76,7 @@ package body GNAT.Table is\n \n    procedure Decrement_Last is\n    begin\n-      Last_Val := Last_Val - 1;\n+      Tab.Decrement_Last (The_Instance);\n    end Decrement_Last;\n \n    -----------\n@@ -122,20 +85,17 @@ package body GNAT.Table is\n \n    function First return Table_Index_Type is\n    begin\n-      return Table_Low_Bound;\n+      return Tab.First;\n    end First;\n \n    --------------\n    -- For_Each --\n    --------------\n \n    procedure For_Each is\n-      Quit : Boolean := False;\n+      procedure For_Each is new Tab.For_Each (Action);\n    begin\n-      for Index in Table_Low_Bound .. Table_Index_Type (Last_Val) loop\n-         Action (Index, Table (Index), Quit);\n-         exit when Quit;\n-      end loop;\n+      For_Each (The_Instance);\n    end For_Each;\n \n    ----------\n@@ -144,9 +104,7 @@ package body GNAT.Table is\n \n    procedure Free is\n    begin\n-      Free (To_Address (Table));\n-      Table := null;\n-      Length := 0;\n+      Tab.Free (The_Instance);\n    end Free;\n \n    --------------------\n@@ -155,271 +113,95 @@ package body GNAT.Table is\n \n    procedure Increment_Last is\n    begin\n-      Last_Val := Last_Val + 1;\n-\n-      if Last_Val > Max then\n-         Reallocate;\n-      end if;\n+      Tab.Increment_Last (The_Instance);\n    end Increment_Last;\n \n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty return Boolean is\n+   begin\n+      return Tab.Is_Empty (The_Instance);\n+   end Is_Empty;\n+\n    ----------\n    -- Init --\n    ----------\n \n    procedure Init is\n-      Old_Length : constant Integer := Length;\n-\n    begin\n-      Last_Val := Min - 1;\n-      Max      := Min + Table_Initial - 1;\n-      Length   := Max - Min + 1;\n-\n-      --  If table is same size as before (happens when table is never\n-      --  expanded which is a common case), then simply reuse it. Note\n-      --  that this also means that an explicit Init call right after\n-      --  the implicit one in the package body is harmless.\n-\n-      if Old_Length = Length then\n-         return;\n-\n-      --  Otherwise we can use Reallocate to get a table of the right size.\n-      --  Note that Reallocate works fine to allocate a table of the right\n-      --  initial size when it is first allocated.\n-\n-      else\n-         Reallocate;\n-      end if;\n+      Tab.Init (The_Instance);\n    end Init;\n \n    ----------\n    -- Last --\n    ----------\n \n-   function Last return Table_Index_Type is\n+   function Last return Table_Last_Type is\n    begin\n-      return Table_Index_Type (Last_Val);\n+      return Tab.Last (The_Instance);\n    end Last;\n \n-   ----------------\n-   -- Reallocate --\n-   ----------------\n-\n-   procedure Reallocate is\n-      New_Size   : size_t;\n-      New_Length : Long_Long_Integer;\n-\n-   begin\n-      if Max < Last_Val then\n-         pragma Assert (not Locked);\n-\n-         --  Now increment table length until it is sufficiently large. Use\n-         --  the increment value or 10, which ever is larger (the reason\n-         --  for the use of 10 here is to ensure that the table does really\n-         --  increase in size (which would not be the case for a table of\n-         --  length 10 increased by 3% for instance). Do the intermediate\n-         --  calculation in Long_Long_Integer to avoid overflow.\n-\n-         while Max < Last_Val loop\n-            New_Length :=\n-              Long_Long_Integer (Length) *\n-                (100 + Long_Long_Integer (Table_Increment)) / 100;\n-            Length := Integer'Max (Integer (New_Length), Length + 10);\n-            Max := Min + Length - 1;\n-         end loop;\n-      end if;\n-\n-      New_Size :=\n-        size_t ((Max - Min + 1) *\n-                (Table_Type'Component_Size / Storage_Unit));\n-\n-      if Table = null then\n-         Table := To_Pointer (Alloc (New_Size));\n-\n-      elsif New_Size > 0 then\n-         Table :=\n-           To_Pointer (Realloc (Ptr  => To_Address (Table),\n-                                Size => New_Size));\n-      end if;\n-\n-      if Length /= 0 and then Table = null then\n-         raise Storage_Error;\n-      end if;\n-\n-   end Reallocate;\n-\n    -------------\n    -- Release --\n    -------------\n \n    procedure Release is\n    begin\n-      Length := Last_Val - Integer (Table_Low_Bound) + 1;\n-      Max    := Last_Val;\n-      Reallocate;\n+      Tab.Release (The_Instance);\n    end Release;\n \n+   -------------\n+   -- Restore --\n+   -------------\n+\n+   procedure Restore (T : in out Saved_Table) is\n+   begin\n+      Init;\n+      Tab.Move (From => T, To => The_Instance);\n+   end Restore;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   function Save return Saved_Table is\n+      Result : Saved_Table;\n+   begin\n+      Tab.Move (From => The_Instance, To => Result);\n+      return Result;\n+   end Save;\n+\n    --------------\n    -- Set_Item --\n    --------------\n \n    procedure Set_Item\n-      (Index : Table_Index_Type;\n-       Item  : Table_Component_Type)\n+     (Index : Valid_Table_Index_Type;\n+      Item  : Table_Component_Type)\n    is\n-      --  If Item is a value within the current allocation, and we are going to\n-      --  reallocate, then we must preserve an intermediate copy here before\n-      --  calling Increment_Last. Otherwise, if Table_Component_Type is passed\n-      --  by reference, we are going to end up copying from storage that might\n-      --  have been deallocated from Increment_Last calling Reallocate.\n-\n-      subtype Allocated_Table_T is\n-        Table_Type (Table'First .. Table_Index_Type (Max + 1));\n-      --  A constrained table subtype one element larger than the currently\n-      --  allocated table.\n-\n-      Allocated_Table_Address : constant System.Address :=\n-                                  Table.all'Address;\n-      --  Used for address clause below (we can't use non-static expression\n-      --  Table.all'Address directly in the clause because some older versions\n-      --  of the compiler do not allow it).\n-\n-      Allocated_Table : Allocated_Table_T;\n-      pragma Import (Ada, Allocated_Table);\n-      pragma Suppress (Range_Check, On => Allocated_Table);\n-      for Allocated_Table'Address use Allocated_Table_Address;\n-      --  Allocated_Table represents the currently allocated array, plus one\n-      --  element (the supplementary element is used to have a convenient\n-      --  way of computing the address just past the end of the current\n-      --  allocation). Range checks are suppressed because this unit uses\n-      --  direct calls to System.Memory for allocation, and this can yield\n-      --  misaligned storage (and we cannot rely on the bootstrap compiler\n-      --  supporting specifically disabling alignment checks, so we need to\n-      --  suppress all range checks). It is safe to suppress this check here\n-      --  because we know that a (possibly misaligned) object of that type\n-      --  does actually exist at that address. ??? We should really improve\n-      --  the allocation circuitry here to\n-      --  guarantee proper alignment.\n-\n-      Need_Realloc : constant Boolean := Integer (Index) > Max;\n-      --  True if this operation requires storage reallocation (which may\n-      --  involve moving table contents around).\n-\n    begin\n-      --  If we're going to reallocate, check whether Item references an\n-      --  element of the currently allocated table.\n-\n-      if Need_Realloc\n-        and then Allocated_Table'Address <= Item'Address\n-        and then Item'Address <\n-                   Allocated_Table (Table_Index_Type (Max + 1))'Address\n-      then\n-         --  If so, save a copy on the stack because Increment_Last will\n-         --  reallocate storage and might deallocate the current table.\n-\n-         declare\n-            Item_Copy : constant Table_Component_Type := Item;\n-         begin\n-            Set_Last (Index);\n-            Table (Index) := Item_Copy;\n-         end;\n-\n-      else\n-         --  Here we know that either we won't reallocate (case of Index < Max)\n-         --  or that Item is not in the currently allocated table.\n-\n-         if Integer (Index) > Last_Val then\n-            Set_Last (Index);\n-         end if;\n-\n-         Table (Index) := Item;\n-      end if;\n+      Tab.Set_Item (The_Instance, Index, Item);\n    end Set_Item;\n \n    --------------\n    -- Set_Last --\n    --------------\n \n-   procedure Set_Last (New_Val : Table_Index_Type) is\n+   procedure Set_Last (New_Val : Table_Last_Type) is\n    begin\n-      if Integer (New_Val) < Last_Val then\n-         Last_Val := Integer (New_Val);\n-      else\n-         Last_Val := Integer (New_Val);\n-\n-         if Last_Val > Max then\n-            Reallocate;\n-         end if;\n-      end if;\n+      Tab.Set_Last (The_Instance, New_Val);\n    end Set_Last;\n \n    ----------------\n    -- Sort_Table --\n    ----------------\n \n    procedure Sort_Table is\n-\n-      Temp : Table_Component_Type;\n-      --  A temporary position to simulate index 0\n-\n-      --  Local subprograms\n-\n-      function Index_Of (Idx : Natural) return Table_Index_Type;\n-      --  Return index of Idx'th element of table\n-\n-      function Lower_Than (Op1, Op2 : Natural) return Boolean;\n-      --  Compare two components\n-\n-      procedure Move (From : Natural; To : Natural);\n-      --  Move one component\n-\n-      package Heap_Sort is new GNAT.Heap_Sort_G (Move, Lower_Than);\n-\n-      --------------\n-      -- Index_Of --\n-      --------------\n-\n-      function Index_Of (Idx : Natural) return Table_Index_Type is\n-         J : constant Integer'Base := Table_Index_Type'Pos (First) + Idx - 1;\n-      begin\n-         return Table_Index_Type'Val (J);\n-      end Index_Of;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         if From = 0 then\n-            Table (Index_Of (To)) := Temp;\n-         elsif To = 0 then\n-            Temp := Table (Index_Of (From));\n-         else\n-            Table (Index_Of (To)) := Table (Index_Of (From));\n-         end if;\n-      end Move;\n-\n-      ----------------\n-      -- Lower_Than --\n-      ----------------\n-\n-      function Lower_Than (Op1, Op2 : Natural) return Boolean is\n-      begin\n-         if Op1 = 0 then\n-            return Lt (Temp, Table (Index_Of (Op2)));\n-         elsif Op2 = 0 then\n-            return Lt (Table (Index_Of (Op1)), Temp);\n-         else\n-            return Lt (Table (Index_Of (Op1)), Table (Index_Of (Op2)));\n-         end if;\n-      end Lower_Than;\n-\n-   --  Start of processing for Sort_Table\n-\n+      procedure Sort_Table is new Tab.Sort_Table (Lt);\n    begin\n-      Heap_Sort.Sort (Natural (Last - First) + 1);\n+      Sort_Table (The_Instance);\n    end Sort_Table;\n \n-begin\n-   Init;\n end GNAT.Table;"}, {"sha": "c2c33244d95cf4da2d99b69bf973ac084a698c9b", "filename": "gcc/ada/g-table.ads", "status": "modified", "additions": 63, "deletions": 144, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-table.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fg-table.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -29,198 +29,117 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Resizable one dimensional array support\n+--  This package provides a singleton version of GNAT.Dynamic_Tables\n+--  (g-dyntab.ads). See that package for documentation. This package just\n+--  declares a single instance of GNAT.Dynamic_Tables.Instance, and provides\n+--  wrappers for all the subprograms, passing that single instance.\n \n---  This package provides an implementation of dynamically resizable one\n---  dimensional arrays. The idea is to mimic the normal Ada semantics for\n---  arrays as closely as possible with the one additional capability of\n---  dynamically modifying the value of the Last attribute.\n+--  Note that these three interfaces should remain synchronized to keep as much\n+--  coherency as possible among these related units:\n+--\n+--     GNAT.Dynamic_Tables\n+--     GNAT.Table\n+--     Table (the compiler unit)\n \n---  This package provides a facility similar to that of GNAT.Dynamic_Tables,\n---  except that this package declares a single instance of the table type,\n---  while an instantiation of GNAT.Dynamic_Tables creates a type that can be\n---  used to define dynamic instances of the table.\n+pragma Compiler_Unit_Warning;\n \n---  Note that this interface should remain synchronized with those in\n---  GNAT.Dynamic_Tables and the GNAT compiler source unit Table to keep\n---  as much coherency as possible between these three related units.\n+with GNAT.Dynamic_Tables;\n \n generic\n    type Table_Component_Type is private;\n    type Table_Index_Type     is range <>;\n \n-   Table_Low_Bound : Table_Index_Type;\n-   Table_Initial   : Positive;\n-   Table_Increment : Natural;\n+   Table_Low_Bound   : Table_Index_Type;\n+   Table_Initial     : Positive := 8;\n+   Table_Increment   : Natural := 100;\n+   Table_Name        : String := \"\"; -- for debugging printouts\n+   pragma Unreferenced (Table_Name);\n+   Release_Threshold : Natural := 0;\n \n package GNAT.Table is\n    pragma Elaborate_Body;\n \n-   --  Table_Component_Type and Table_Index_Type specify the type of the\n-   --  array, Table_Low_Bound is the lower bound. Table_Index_Type must be an\n-   --  integer type. The effect is roughly to declare:\n-\n-   --    Table : array (Table_Index_Type range Table_Low_Bound .. <>)\n-   --                       of Table_Component_Type;\n-\n-   --    Note: since the upper bound can be one less than the lower\n-   --    bound for an empty array, the table index type must be able\n-   --    to cover this range, e.g. if the lower bound is 1, then the\n-   --    Table_Index_Type should be Natural rather than Positive.\n-\n-   --  Table_Component_Type may be any Ada type, except that controlled\n-   --  types are not supported. Note however that default initialization\n-   --  will NOT occur for array components.\n-\n-   --  The Table_Initial values controls the allocation of the table when\n-   --  it is first allocated, either by default, or by an explicit Init call.\n-\n-   --  The Table_Increment value controls the amount of increase, if the\n-   --  table has to be increased in size. The value given is a percentage\n-   --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n-\n-   --  The Last and Set_Last subprograms provide control over the current\n-   --  logical allocation. They are quite efficient, so they can be used\n-   --  freely (expensive reallocation occurs only at major granularity\n-   --  chunks controlled by the allocation parameters).\n-\n-   --  Note: we do not make the table components aliased, since this would\n-   --  restrict the use of table for discriminated types. If it is necessary\n-   --  to take the access of a table element, use Unrestricted_Access.\n-\n-   --  WARNING: On HPPA, the virtual addressing approach used in this unit\n-   --  is incompatible with the indexing instructions on the HPPA. So when\n-   --  using this unit, compile your application with -mdisable-indexing.\n-\n-   --  WARNING: If the table is reallocated, then the address of all its\n-   --  components will change. So do not capture the address of an element\n-   --  and then use the address later after the table may be reallocated.\n-   --  One tricky case of this is passing an element of the table to a\n-   --  subprogram by reference where the table gets reallocated during\n-   --  the execution of the subprogram. The best rule to follow is never\n-   --  to pass a table element as a parameter except for the case of IN\n-   --  mode parameters with scalar values.\n-\n-   type Table_Type is\n-     array (Table_Index_Type range <>) of Table_Component_Type;\n-   subtype Big_Table_Type is\n-     Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n-   --  We work with pointers to a bogus array type that is constrained\n-   --  with the maximum possible range bound. This means that the pointer\n-   --  is a thin pointer, which is more efficient. Since subscript checks\n-   --  in any case must be on the logical, rather than physical bounds,\n-   --  safety is not compromised by this approach. These types should never\n-   --  be used by the client.\n-\n-   type Table_Ptr is access all Big_Table_Type;\n-   for Table_Ptr'Storage_Size use 0;\n-   --  The table is actually represented as a pointer to allow reallocation.\n-   --  This type should never be used by the client.\n-\n-   Table : aliased Table_Ptr := null;\n-   --  The table itself. The lower bound is the value of Low_Bound.\n-   --  Logically the upper bound is the current value of Last (although\n-   --  the actual size of the allocated table may be larger than this).\n-   --  The program may only access and modify Table entries in the range\n-   --  First .. Last.\n-\n-   Locked : Boolean := False;\n-   --  Table expansion is permitted only if this switch is set to False. A\n-   --  client may set Locked to True, in which case any attempt to expand\n-   --  the table will cause an assertion failure. Note that while a table\n-   --  is locked, its address in memory remains fixed and unchanging.\n+   package Tab is new GNAT.Dynamic_Tables\n+     (Table_Component_Type,\n+      Table_Index_Type,\n+      Table_Low_Bound,\n+      Table_Initial,\n+      Table_Increment,\n+      Release_Threshold);\n+\n+   subtype Valid_Table_Index_Type is Tab.Valid_Table_Index_Type;\n+   subtype Table_Last_Type is Tab.Table_Last_Type;\n+   subtype Table_Type is Tab.Table_Type;\n+   subtype Big_Table_Type is Tab.Big_Table_Type;\n+\n+   subtype Table_Ptr is Tab.Table_Ptr;\n+\n+   The_Instance : Tab.Instance;\n+   Table : Table_Ptr renames The_Instance.Table;\n+   Locked : Boolean renames The_Instance.Locked;\n+\n+   function Is_Empty return Boolean;\n \n    procedure Init;\n-   --  This procedure allocates a new table of size Initial (freeing any\n-   --  previously allocated larger table). It is not necessary to call\n-   --  Init when a table is first instantiated (since the instantiation does\n-   --  the same initialization steps). However, it is harmless to do so, and\n-   --  Init is convenient in reestablishing a table for new use.\n \n-   function Last return Table_Index_Type;\n+   function First return Table_Index_Type;\n+   pragma Inline (First);\n+\n+   function Last return Table_Last_Type;\n    pragma Inline (Last);\n-   --  Returns the current value of the last used entry in the table, which\n-   --  can then be used as a subscript for Table. Note that the only way to\n-   --  modify Last is to call the Set_Last procedure. Last must always be\n-   --  used to determine the logically last entry.\n \n    procedure Release;\n-   --  Storage is allocated in chunks according to the values given in the\n-   --  Initial and Increment parameters. A call to Release releases all\n-   --  storage that is allocated, but is not logically part of the current\n-   --  array value. Current array values are not affected by this call.\n \n    procedure Free;\n-   --  Free all allocated memory for the table. A call to Init is required\n-   --  before any use of this table after calling Free.\n \n-   function First return Table_Index_Type;\n-   pragma Inline (First);\n-   --  Export First as synonym for Table_Low_Bound (parallel with use of Last)\n-\n-   procedure Set_Last (New_Val : Table_Index_Type);\n+   procedure Set_Last (New_Val : Table_Last_Type);\n    pragma Inline (Set_Last);\n-   --  This procedure sets Last to the indicated value. If necessary the\n-   --  table is reallocated to accommodate the new value (i.e. on return\n-   --  the allocated table has an upper bound of at least Last). If Set_Last\n-   --  reduces the size of the table, then logically entries are removed\n-   --  from the table. If Set_Last increases the size of the table, then\n-   --  new entries are logically added to the table.\n \n    procedure Increment_Last;\n    pragma Inline (Increment_Last);\n-   --  Adds 1 to Last (same as Set_Last (Last + 1)\n \n    procedure Decrement_Last;\n    pragma Inline (Decrement_Last);\n-   --  Subtracts 1 from Last (same as Set_Last (Last - 1)\n \n    procedure Append (New_Val : Table_Component_Type);\n    pragma Inline (Append);\n-   --  Equivalent to:\n-   --    x.Increment_Last;\n-   --    x.Table (x.Last) := New_Val;\n-   --  i.e. the table size is increased by one, and the given new item\n-   --  stored in the newly created table element.\n \n    procedure Append_All (New_Vals : Table_Type);\n-   --  Appends all components of New_Vals\n \n    procedure Set_Item\n-     (Index : Table_Index_Type;\n+     (Index : Valid_Table_Index_Type;\n       Item  : Table_Component_Type);\n    pragma Inline (Set_Item);\n-   --  Put Item in the table at position Index. The table is expanded if the\n-   --  current table length is less than Index and in that case Last is set to\n-   --  Index. Item will replace any value already present in the table at this\n-   --  position.\n \n-   function Allocate (Num : Integer := 1) return Table_Index_Type;\n+   subtype Saved_Table is Tab.Instance;\n+   --  Type used for Save/Restore subprograms\n+\n+   function Save return Saved_Table;\n+   --  Resets table to empty, but saves old contents of table in returned\n+   --  value, for possible later restoration by a call to Restore.\n+\n+   procedure Restore (T : in out Saved_Table);\n+   --  Given a Saved_Table value returned by a prior call to Save, restores\n+   --  the table to the state it was in at the time of the Save call.\n+\n+   procedure Allocate (Num : Integer := 1);\n+   function Allocate (Num : Integer := 1) return Valid_Table_Index_Type;\n    pragma Inline (Allocate);\n-   --  Adds Num to Last, and returns the old value of Last + 1. Note that\n-   --  this function has the possible side effect of reallocating the table.\n-   --  This means that a reference X.Table (X.Allocate) is incorrect, since\n-   --  the call to X.Allocate may modify the results of calling X.Table.\n+   --  Adds Num to Last. The function version also returns the old value of\n+   --  Last + 1. Note that this function has the possible side effect of\n+   --  reallocating the table. This means that a reference X.Table (X.Allocate)\n+   --  is incorrect, since the call to X.Allocate may modify the results of\n+   --  calling X.Table.\n \n    generic\n      with procedure Action\n-       (Index : Table_Index_Type;\n+       (Index : Valid_Table_Index_Type;\n         Item  : Table_Component_Type;\n         Quit  : in out Boolean) is <>;\n    procedure For_Each;\n-   --  Calls procedure Action for each component of the table, or until\n-   --  one of these calls set Quit to True.\n \n    generic\n      with function Lt (Comp1, Comp2 : Table_Component_Type) return Boolean;\n    procedure Sort_Table;\n-   --  This procedure sorts the components of the table into ascending\n-   --  order making calls to Lt to do required comparisons, and using\n-   --  assignments to move components around. The Lt function returns True\n-   --  if Comp1 is less than Comp2 (in the sense of the desired sort), and\n-   --  False if Comp1 is greater than Comp2. For equal objects it does not\n-   --  matter if True or False is returned (it is slightly more efficient\n-   --  to return False). The sort is not stable (the order of equal items\n-   --  in the table is not preserved).\n \n end GNAT.Table;"}, {"sha": "20dd504b0186c6525aab851bf86392e22397fbed", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -36,6 +36,7 @@\n with Debug;    use Debug;\n with Opt;      use Opt;\n with Output;   use Output;\n+with System;   use System;\n with Tree_IO;  use Tree_IO;\n with Widechar; use Widechar;\n \n@@ -1093,15 +1094,6 @@ package body Namet is\n       Name_Entries.Release;\n    end Lock;\n \n-   ------------------------\n-   -- Name_Chars_Address --\n-   ------------------------\n-\n-   function Name_Chars_Address return System.Address is\n-   begin\n-      return Name_Chars.Table (0)'Address;\n-   end Name_Chars_Address;\n-\n    ----------------\n    -- Name_Enter --\n    ----------------\n@@ -1139,15 +1131,6 @@ package body Namet is\n       return Name_Enter (Buf);\n    end Name_Enter;\n \n-   --------------------------\n-   -- Name_Entries_Address --\n-   --------------------------\n-\n-   function Name_Entries_Address return System.Address is\n-   begin\n-      return Name_Entries.Table (First_Name_Id)'Address;\n-   end Name_Entries_Address;\n-\n    ------------------------\n    -- Name_Entries_Count --\n    ------------------------"}, {"sha": "124f7782036f7bac19f82d6c79a6ca999be8319f", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -32,7 +32,6 @@\n with Alloc;\n with Hostparm; use Hostparm;\n with Table;\n-with System;   use System;\n with Types;    use Types;\n \n package Namet is\n@@ -564,13 +563,6 @@ package Namet is\n    --  Like Write_Name, except that the name written is the decoded name, as\n    --  described for Append_Decoded.\n \n-   function Name_Chars_Address return System.Address;\n-   --  Return starting address of name characters table (used in Back_End call\n-   --  to Gigi).\n-\n-   function Name_Entries_Address return System.Address;\n-   --  Return starting address of Names table (used in Back_End call to Gigi)\n-\n    function Name_Entries_Count return Nat;\n    --  Return current number of entries in the names table\n "}, {"sha": "84255a807faf34e4f7443fadf61e31698281e14b", "filename": "gcc/ada/namet.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *            Copyright (C) 1992-2016, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 1992-2017, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -45,11 +45,11 @@ struct Name_Entry\n };\n \n /* Pointer to names table vector. */\n-#define Names_Ptr namet__name_entries__table\n+#define Names_Ptr namet__name_entries__tab__the_instance\n extern struct Name_Entry *Names_Ptr;\n \n /* Pointer to name characters table. */\n-#define Name_Chars_Ptr namet__name_chars__table\n+#define Name_Chars_Ptr namet__name_chars__tab__the_instance\n extern char *Name_Chars_Ptr;\n \n /* This is Hostparm.Max_Line_Length.  */"}, {"sha": "2805bfe62adfc39450f9f13f2c9565a0952cb045", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -662,7 +662,7 @@ package Osint is\n    --  The suffixes used for the ALI files\n \n    function Prep_Suffix return String;\n-   --  The suffix used for pre-processed files\n+   --  The suffix used for preprocessed files\n \n private\n "}, {"sha": "4fb396ca63004232f9dfc8f4abe7ce1f70b5b3e5", "filename": "gcc/ada/scos.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fscos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fscos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.h?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -45,8 +45,10 @@ struct SCO_Unit_Table_Entry\n \n typedef struct SCO_Unit_Table_Entry *SCO_Unit_Table_Type;\n \n-extern SCO_Unit_Table_Type scos__sco_unit_table__table;\n-#define SCO_Unit_Table scos__sco_unit_table__table\n+/* The following depends on the fact that The_Instance.Table\n+   is the first component. */\n+extern SCO_Unit_Table_Type scos__sco_unit_table__the_instance;\n+#define SCO_Unit_Table scos__sco_unit_table__the_instance\n \n extern Int scos__sco_unit_table__first(void);\n #define SCO_Unit_Table_First scos__sco_unit_table__first\n@@ -74,8 +76,10 @@ struct SCO_Table_Entry\n \n typedef struct SCO_Table_Entry *SCO_Table_Type;\n \n-extern SCO_Table_Type scos__sco_table__table;\n-#define SCO_Table scos__sco_table__table\n+/* The following depends on the fact that The_Instance.Table\n+   is the first component. */\n+extern SCO_Table_Type scos__sco_table__the_instance;\n+#define SCO_Table scos__sco_table__the_instance\n \n extern Int scos__sco_table__first(void);\n #define SCO_Table_First scos__sco_table__first"}, {"sha": "2579ab5eaffe8ac5c73233aaf294c189c4203f5f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 113, "deletions": 94, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -65,36 +65,51 @@ package body Sem_Elab is\n    --  Elab_Call.Last) indicates the current depth of recursion and is used to\n    --  identify the outer level.\n \n-   type Elab_Call_Entry is record\n+   type Elab_Call_Element is record\n       Cloc : Source_Ptr;\n       Ent  : Entity_Id;\n    end record;\n \n    package Elab_Call is new Table.Table\n-     (Table_Component_Type => Elab_Call_Entry,\n+     (Table_Component_Type => Elab_Call_Element,\n       Table_Index_Type     => Int,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 50,\n       Table_Increment      => 100,\n       Table_Name           => \"Elab_Call\");\n \n-   --  This table is initialized at the start of each outer level call. It\n-   --  holds the entities for all subprograms that have been examined for this\n-   --  particular outer level call, and is used to prevent both infinite\n-   --  recursion, and useless reanalysis of bodies already seen\n+   --  The following table records all calls that have been processed starting\n+   --  from an outer level call. The table prevents both infinite recursion and\n+   --  useless reanalysis of calls within the same context. The use of context\n+   --  is important because it allows for proper checks in more complex code:\n+\n+   --    if ... then\n+   --       Call;  --  requires a check\n+   --       Call;  --  does not need a check thanks to the table\n+   --    elsif ... then\n+   --       Call;  --  requires a check, different context\n+   --    end if;\n+\n+   --    Call;     --  requires a check, different context\n+\n+   type Visited_Element is record\n+      Subp_Id : Entity_Id;\n+      --  The entity of the subprogram being called\n+\n+      Context : Node_Id;\n+      --  The context where the call to the subprogram occurs\n+   end record;\n \n    package Elab_Visited is new Table.Table\n-     (Table_Component_Type => Entity_Id,\n+     (Table_Component_Type => Visited_Element,\n       Table_Index_Type     => Int,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 200,\n       Table_Increment      => 100,\n       Table_Name           => \"Elab_Visited\");\n \n-   --  This table stores calls to Check_Internal_Call that are delayed until\n-   --  all generics are instantiated and in particular until after all generic\n-   --  bodies have been inserted. We need to delay, because we need to be able\n-   --  to look through the inserted bodies.\n+   --  The following table records delayed calls which must be examined after\n+   --  all generic bodies have been instantiated.\n \n    type Delay_Element is record\n       N : Node_Id;\n@@ -743,7 +758,7 @@ package body Sem_Elab is\n \n          loop\n             if (Suppress_Elaboration_Warnings (Ent)\n-                or else Elaboration_Checks_Suppressed (Ent))\n+                 or else Elaboration_Checks_Suppressed (Ent))\n               and then (Inst_Case or else No (Alias (Ent)))\n             then\n                return;\n@@ -913,17 +928,17 @@ package body Sem_Elab is\n            Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (C_Scope)));\n       end if;\n \n-      --  Do not give a warning if the with'ed unit is internal and the\n-      --  caller is not internal (since the binder always elaborates\n-      --  internal units first).\n+      --  Do not give a warning if the with'ed unit is internal and the caller\n+      --  is not internal (since the binder always elaborates internal units\n+      --  first).\n \n-      if Callee_Unit_Internal and (not Caller_Unit_Internal) then\n+      if Callee_Unit_Internal and not Caller_Unit_Internal then\n          return;\n       end if;\n \n-      --  For now, if debug flag -gnatdE is not set, do no checking for\n-      --  one internal unit withing another. This fixes the problem with\n-      --  the sgi build and storage errors. To be resolved later ???\n+      --  For now, if debug flag -gnatdE is not set, do no checking for one\n+      --  internal unit withing another. This fixes the problem with the sgi\n+      --  build and storage errors. To be resolved later ???\n \n       if (Callee_Unit_Internal and Caller_Unit_Internal)\n         and not Debug_Flag_EE\n@@ -1151,7 +1166,7 @@ package body Sem_Elab is\n          --  All_Errors_Mode.\n \n          if not All_Errors_Mode and not Dynamic_Elaboration_Checks then\n-            Set_Suppress_Elaboration_Warnings (W_Scope, True);\n+            Set_Suppress_Elaboration_Warnings (W_Scope);\n          end if;\n       end if;\n \n@@ -1218,8 +1233,8 @@ package body Sem_Elab is\n             then\n                Error_Msg_Node_2 := W_Scope;\n                Error_Msg_NE\n-                 (\"info: call to& in elaboration code \" &\n-                  \"requires pragma Elaborate_All on&?$?\", N, E);\n+                 (\"info: call to& in elaboration code requires pragma \"\n+                  & \"Elaborate_All on&?$?\", N, E);\n             end if;\n \n             --  Set indication for binder to generate Elaborate_All\n@@ -1623,14 +1638,22 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Nothing to do if this is a recursive call (i.e. a call to\n-      --  an entity that is already in the Elab_Call stack)\n+      --  Determine whether a prior call to the same subprogram was already\n+      --  examined within the same context. If this is the case, then there is\n+      --  no need to proceed with the various warnings and checks because the\n+      --  work was already done for the previous call.\n \n-      for J in 1 .. Elab_Visited.Last loop\n-         if Ent = Elab_Visited.Table (J) then\n-            return;\n-         end if;\n-      end loop;\n+      declare\n+         Self : constant Visited_Element :=\n+                  (Subp_Id => Ent, Context => Parent (N));\n+\n+      begin\n+         for Index in 1 .. Elab_Visited.Last loop\n+            if Self = Elab_Visited.Table (Index) then\n+               return;\n+            end if;\n+         end loop;\n+      end;\n \n       --  See if we need to analyze this reference. We analyze it if either of\n       --  the following conditions is met:\n@@ -2394,14 +2417,19 @@ package body Sem_Elab is\n          Outer_Level_Sloc := Loc;\n       end if;\n \n-      Elab_Visited.Append (E);\n-\n       --  If the call is to a function that renames a literal, no check needed\n \n       if Ekind (E) = E_Enumeration_Literal then\n          return;\n       end if;\n \n+      --  Register the subprogram as examined within this particular context.\n+      --  This ensures that calls to the same subprogram but in different\n+      --  contexts receive warnings and checks of their own since the calls\n+      --  may be reached through different flow paths.\n+\n+      Elab_Visited.Append ((Subp_Id => E, Context => Parent (N)));\n+\n       Sbody := Unit_Declaration_Node (E);\n \n       if not Nkind_In (Sbody, N_Subprogram_Body, N_Package_Body) then\n@@ -2422,8 +2450,8 @@ package body Sem_Elab is\n       then\n          null;\n \n-      --  If we have the instantiation case we are done, since we now\n-      --  know that the body of the generic appeared earlier.\n+      --  If we have the instantiation case we are done, since we now know that\n+      --  the body of the generic appeared earlier.\n \n       elsif Inst_Case then\n          return;\n@@ -2579,26 +2607,22 @@ package body Sem_Elab is\n          if GNATprove_Mode then\n             null;\n \n-         --  Deal with dynamic elaboration check\n+         --  Generate an elaboration check\n \n          elsif not Elaboration_Checks_Suppressed (E) then\n             Set_Elaboration_Entity_Required (E);\n \n-            --  Case of no elaboration entity allocated yet\n+            --  Create a declaration of the elaboration entity, and insert it\n+            --  prior to the subprogram or the generic unit, within the same\n+            --  scope. Since the subprogram may be overloaded, create a unique\n+            --  entity.\n \n             if No (Elaboration_Entity (E)) then\n-\n-               --  Create object declaration for elaboration entity, and put it\n-               --  just in front of the spec of the subprogram or generic unit,\n-               --  in the same scope as this unit. The subprogram may be over-\n-               --  loaded, so make the name of elaboration entity unique by\n-               --  means of a numeric suffix.\n-\n                declare\n                   Loce : constant Source_Ptr := Sloc (E);\n                   Ent  : constant Entity_Id  :=\n                            Make_Defining_Identifier (Loc,\n-                             Chars => New_External_Name (Chars (E), 'E', -1));\n+                             New_External_Name (Chars (E), 'E', -1));\n \n                begin\n                   Set_Elaboration_Entity (E, Ent);\n@@ -2629,12 +2653,15 @@ package body Sem_Elab is\n                end;\n             end if;\n \n-            --  Generate check of the elaboration counter\n+            --  Generate:\n+            --    if Enn = 0 then\n+            --       raise Program_Error with \"access before elaboration\";\n+            --    end if;\n \n             Insert_Elab_Check (N,\n-               Make_Attribute_Reference (Loc,\n-                 Attribute_Name => Name_Elaborated,\n-                 Prefix         => New_Occurrence_Of (E, Loc)));\n+              Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Elaborated,\n+                Prefix         => New_Occurrence_Of (E, Loc)));\n          end if;\n \n          --  Generate the warning\n@@ -2657,8 +2684,8 @@ package body Sem_Elab is\n                  (\"instantiation of& may occur before body is seen<l<\",\n                   N, Orig_Ent);\n             else\n-               --  A rather specific check. For Finalize/Adjust/Initialize,\n-               --  if the type has Warnings_Off set, suppress the warning.\n+               --  A rather specific check. For Finalize/Adjust/Initialize, if\n+               --  the type has Warnings_Off set, suppress the warning.\n \n                if Nam_In (Chars (E), Name_Adjust,\n                                      Name_Finalize,\n@@ -2697,13 +2724,6 @@ package body Sem_Elab is\n             Output_Calls (N, Check_Elab_Flag => False);\n          end if;\n       end if;\n-\n-      --  Set flag to suppress further warnings on same subprogram\n-      --  unless in all errors mode\n-\n-      if not All_Errors_Mode then\n-         Set_Suppress_Elaboration_Warnings (E);\n-      end if;\n    end Check_Internal_Call_Continue;\n \n    ---------------------------\n@@ -2909,32 +2929,32 @@ package body Sem_Elab is\n          elsif Dynamic_Elaboration_Checks then\n             if not Elaboration_Checks_Suppressed (Ent)\n               and then not Cunit_SC\n-              and then\n-                not Restriction_Active (No_Entry_Calls_In_Elaboration_Code)\n+              and then not Restriction_Active\n+                             (No_Entry_Calls_In_Elaboration_Code)\n             then\n                --  Runtime elaboration check required. Generate check of the\n                --  elaboration counter for the unit containing the entity.\n \n                Insert_Elab_Check (N,\n                  Make_Attribute_Reference (Loc,\n-                   Attribute_Name => Name_Elaborated,\n-                   Prefix =>\n-                     New_Occurrence_Of (Spec_Entity (Task_Scope), Loc)));\n+                   Prefix         =>\n+                     New_Occurrence_Of (Spec_Entity (Task_Scope), Loc),\n+                   Attribute_Name => Name_Elaborated));\n             end if;\n \n          else\n             --  Force the binder to elaborate other unit first\n \n-            if not Suppress_Elaboration_Warnings (Ent)\n+            if Elab_Info_Messages\n+              and then not Suppress_Elaboration_Warnings (Ent)\n               and then not Elaboration_Checks_Suppressed (Ent)\n-              and then Elab_Info_Messages\n               and then not Suppress_Elaboration_Warnings (Task_Scope)\n               and then not Elaboration_Checks_Suppressed (Task_Scope)\n             then\n                Error_Msg_Node_2 := Task_Scope;\n                Error_Msg_NE\n-                 (\"info: activation of an instance of task type&\" &\n-                  \" requires pragma Elaborate_All on &?$?\", N, Ent);\n+                 (\"info: activation of an instance of task type & requires \"\n+                  & \"pragma Elaborate_All on &?$?\", N, Ent);\n             end if;\n \n             Activate_Elaborate_All_Desirable (N, Task_Scope);\n@@ -2988,18 +3008,19 @@ package body Sem_Elab is\n      Subp : Entity_Id;\n      Scop : Entity_Id)\n    is\n-      Elab_Unit  : Entity_Id;\n+      Elab_Unit : Entity_Id;\n \n       --  Check whether this is a call to an Initialize subprogram for a\n       --  controlled type. Note that Call can also be a 'Access attribute\n       --  reference, which now generates an elaboration check.\n \n-      Init_Call  : constant Boolean :=\n-                     Nkind (Call) = N_Procedure_Call_Statement\n-                       and then Chars (Subp) = Name_Initialize\n-                       and then Comes_From_Source (Subp)\n-                       and then Present (Parameter_Associations (Call))\n-                       and then Is_Controlled (Etype (First_Actual (Call)));\n+      Init_Call : constant Boolean :=\n+                    Nkind (Call) = N_Procedure_Call_Statement\n+                      and then Chars (Subp) = Name_Initialize\n+                      and then Comes_From_Source (Subp)\n+                      and then Present (Parameter_Associations (Call))\n+                      and then Is_Controlled (Etype (First_Actual (Call)));\n+\n    begin\n       --  If the unit is mentioned in a with_clause of the current unit, it is\n       --  visible, and we can set the elaboration flag.\n@@ -3008,13 +3029,13 @@ package body Sem_Elab is\n         or else (Is_Child_Unit (Scop) and then Is_Visible_Lib_Unit (Scop))\n       then\n          Activate_Elaborate_All_Desirable (Call, Scop);\n-         Set_Suppress_Elaboration_Warnings (Scop, True);\n+         Set_Suppress_Elaboration_Warnings (Scop);\n          return;\n       end if;\n \n       --  If this is not an initialization call or a call using object notation\n-      --  we know that the unit of the called entity is in the context, and\n-      --  we can set the flag as well. The unit need not be visible if the call\n+      --  we know that the unit of the called entity is in the context, and we\n+      --  can set the flag as well. The unit need not be visible if the call\n       --  occurs within an instantiation.\n \n       if Is_Init_Proc (Subp)\n@@ -3025,7 +3046,7 @@ package body Sem_Elab is\n \n       else\n          Activate_Elaborate_All_Desirable (Call, Scop);\n-         Set_Suppress_Elaboration_Warnings (Scop, True);\n+         Set_Suppress_Elaboration_Warnings (Scop);\n          return;\n       end if;\n \n@@ -3070,7 +3091,7 @@ package body Sem_Elab is\n       end if;\n \n       Activate_Elaborate_All_Desirable (Call, Elab_Unit);\n-      Set_Suppress_Elaboration_Warnings (Elab_Unit, True);\n+      Set_Suppress_Elaboration_Warnings (Elab_Unit);\n    end Set_Elaboration_Constraint;\n \n    ------------------------\n@@ -3616,23 +3637,22 @@ package body Sem_Elab is\n             if No (Corresponding_Body (N)) then\n                declare\n                   Loc     : constant Source_Ptr := Sloc (N);\n-                  B       : Node_Id;\n-                  Formals : constant List_Id := Copy_Parameter_List (Ent);\n-                  Nam     : constant Entity_Id :=\n+                  Formals : constant List_Id    := Copy_Parameter_List (Ent);\n+                  Nam     : constant Entity_Id  :=\n                               Make_Defining_Identifier (Loc, Chars (Ent));\n-                  Spec    : Node_Id;\n-                  Stats   : constant List_Id :=\n-                              New_List\n-                               (Make_Raise_Program_Error (Loc,\n+                  Stats   : constant List_Id    :=\n+                              New_List (\n+                                Make_Raise_Program_Error (Loc,\n                                   Reason => PE_Access_Before_Elaboration));\n+                  Spec    : Node_Id;\n \n                begin\n                   if Ekind (Ent) = E_Function then\n                      Spec :=\n                         Make_Function_Specification (Loc,\n-                          Defining_Unit_Name => Nam,\n+                          Defining_Unit_Name       => Nam,\n                           Parameter_Specifications => Formals,\n-                          Result_Definition =>\n+                          Result_Definition        =>\n                             New_Copy_Tree\n                               (Result_Definition (Specification (N))));\n \n@@ -3645,17 +3665,16 @@ package body Sem_Elab is\n                   else\n                      Spec :=\n                         Make_Procedure_Specification (Loc,\n-                          Defining_Unit_Name => Nam,\n+                          Defining_Unit_Name       => Nam,\n                           Parameter_Specifications => Formals);\n                   end if;\n \n-                  B := Make_Subprogram_Body (Loc,\n-                          Specification => Spec,\n-                          Declarations => New_List,\n-                          Handled_Statement_Sequence =>\n-                            Make_Handled_Sequence_Of_Statements (Loc,  Stats));\n-                  Insert_After (N, B);\n-                  Analyze (B);\n+                  Insert_After_And_Analyze (N,\n+                    Make_Subprogram_Body (Loc,\n+                      Specification               => Spec,\n+                       Declarations               => New_List,\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,  Stats)));\n                end;\n             end if;\n          end;"}, {"sha": "5d4522b449aea632b7819ecaa142d50b3712b1a7", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 8, "deletions": 363, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,380 +29,27 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Debug;   use Debug;\n-with Opt;     use Opt;\n-with Output;  use Output;\n with System;  use System;\n with Tree_IO; use Tree_IO;\n \n with System.Memory; use System.Memory;\n \n with Unchecked_Conversion;\n \n-pragma Elaborate_All (Output);\n-\n package body Table is\n    package body Table is\n \n-      Min : constant Int := Int (Table_Low_Bound);\n-      --  Subscript of the minimum entry in the currently allocated table\n-\n-      Length : Int := 0;\n-      --  Number of entries in currently allocated table. The value of zero\n-      --  ensures that we initially allocate the table.\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      procedure Reallocate;\n-      --  Reallocate the existing table according to the current value stored\n-      --  in Max. Works correctly to do an initial allocation if the table\n-      --  is currently null.\n-\n       function Tree_Get_Table_Address return Address;\n       --  Return Null_Address if the table length is zero,\n       --  Table (First)'Address if not.\n \n-      pragma Warnings (Off);\n-      --  Turn off warnings. The following unchecked conversions are only used\n-      --  internally in this package, and cannot never result in any instances\n-      --  of improperly aliased pointers for the client of the package.\n-\n-      function To_Address is new Unchecked_Conversion (Table_Ptr, Address);\n-      function To_Pointer is new Unchecked_Conversion (Address, Table_Ptr);\n-\n-      pragma Warnings (On);\n-\n-      ------------\n-      -- Append --\n-      ------------\n-\n-      procedure Append (New_Val : Table_Component_Type) is\n-      begin\n-         Set_Item (Table_Index_Type (Last_Val + 1), New_Val);\n-      end Append;\n-\n-      ----------------\n-      -- Append_All --\n-      ----------------\n-\n-      procedure Append_All (New_Vals : Table_Type) is\n-      begin\n-         for J in New_Vals'Range loop\n-            Append (New_Vals (J));\n-         end loop;\n-      end Append_All;\n-\n-      --------------------\n-      -- Decrement_Last --\n-      --------------------\n-\n-      procedure Decrement_Last is\n-      begin\n-         Last_Val := Last_Val - 1;\n-      end Decrement_Last;\n-\n-      ----------\n-      -- Free --\n-      ----------\n-\n-      procedure Free is\n-      begin\n-         Free (To_Address (Table));\n-         Table := null;\n-         Length := 0;\n-      end Free;\n-\n-      --------------------\n-      -- Increment_Last --\n-      --------------------\n-\n-      procedure Increment_Last is\n-      begin\n-         Last_Val := Last_Val + 1;\n-\n-         if Last_Val > Max then\n-            Reallocate;\n-         end if;\n-      end Increment_Last;\n-\n-      ----------\n-      -- Init --\n-      ----------\n-\n-      procedure Init is\n-         Old_Length : constant Int := Length;\n-\n-      begin\n-         Locked   := False;\n-         Last_Val := Min - 1;\n-         Max      := Min + (Table_Initial * Table_Factor) - 1;\n-         Length   := Max - Min + 1;\n-\n-         --  If table is same size as before (happens when table is never\n-         --  expanded which is a common case), then simply reuse it. Note\n-         --  that this also means that an explicit Init call right after\n-         --  the implicit one in the package body is harmless.\n-\n-         if Old_Length = Length then\n-            return;\n-\n-         --  Otherwise we can use Reallocate to get a table of the right size.\n-         --  Note that Reallocate works fine to allocate a table of the right\n-         --  initial size when it is first allocated.\n-\n-         else\n-            Reallocate;\n-         end if;\n-      end Init;\n-\n-      ----------\n-      -- Last --\n-      ----------\n-\n-      function Last return Table_Index_Type is\n-      begin\n-         return Table_Index_Type (Last_Val);\n-      end Last;\n-\n-      ----------------\n-      -- Reallocate --\n-      ----------------\n-\n-      procedure Reallocate is\n-         New_Size   : Memory.size_t;\n-         New_Length : Long_Long_Integer;\n-\n-      begin\n-         if Max < Last_Val then\n-            pragma Assert (not Locked);\n-\n-            --  Make sure that we have at least the initial allocation. This\n-            --  is needed in cases where a zero length table is written out.\n-\n-            Length := Int'Max (Length, Table_Initial);\n-\n-            --  Now increment table length until it is sufficiently large. Use\n-            --  the increment value or 10, which ever is larger (the reason\n-            --  for the use of 10 here is to ensure that the table does really\n-            --  increase in size (which would not be the case for a table of\n-            --  length 10 increased by 3% for instance). Do the intermediate\n-            --  calculation in Long_Long_Integer to avoid overflow.\n-\n-            while Max < Last_Val loop\n-               New_Length :=\n-                 Long_Long_Integer (Length) *\n-                    (100 + Long_Long_Integer (Table_Increment)) / 100;\n-               Length := Int'Max (Int (New_Length), Length + 10);\n-               Max := Min + Length - 1;\n-            end loop;\n-\n-            if Debug_Flag_D then\n-               Write_Str (\"--> Allocating new \");\n-               Write_Str (Table_Name);\n-               Write_Str (\" table, size = \");\n-               Write_Int (Max - Min + 1);\n-               Write_Eol;\n-            end if;\n-         end if;\n-\n-         --  Do the intermediate calculation in size_t to avoid signed overflow\n-\n-         New_Size :=\n-           Memory.size_t (Max - Min + 1) *\n-                                    (Table_Type'Component_Size / Storage_Unit);\n-\n-         if Table = null then\n-            Table := To_Pointer (Alloc (New_Size));\n-\n-         elsif New_Size > 0 then\n-            Table :=\n-              To_Pointer (Realloc (Ptr  => To_Address (Table),\n-                                   Size => New_Size));\n-         end if;\n-\n-         if Length /= 0 and then Table = null then\n-            Set_Standard_Error;\n-            Write_Str (\"available memory exhausted\");\n-            Write_Eol;\n-            Set_Standard_Output;\n-            raise Unrecoverable_Error;\n-         end if;\n-      end Reallocate;\n-\n-      -------------\n-      -- Release --\n-      -------------\n-\n-      procedure Release is\n-         Extra_Length : Int;\n-         Size         : Memory.size_t;\n-\n-      begin\n-         Length := Last_Val - Int (Table_Low_Bound) + 1;\n-         Size   := Memory.size_t (Length) *\n-                     (Table_Type'Component_Size / Storage_Unit);\n-\n-         --  If the size of the table exceeds the release threshold then leave\n-         --  space to store as many extra elements as 0.1% of the table length.\n-\n-         if Release_Threshold > 0\n-           and then Size > Memory.size_t (Release_Threshold)\n-         then\n-            Extra_Length := Length / 1000;\n-            Length := Length + Extra_Length;\n-            Max    := Int (Table_Low_Bound) + Length - 1;\n-\n-            if Debug_Flag_D then\n-               Write_Str (\"--> Release_Threshold reached (length=\");\n-               Write_Int (Int (Size));\n-               Write_Str (\"): leaving room space for \");\n-               Write_Int (Extra_Length);\n-               Write_Str (\" components\");\n-               Write_Eol;\n-            end if;\n-         else\n-            Max := Last_Val;\n-         end if;\n-\n-         Reallocate;\n-      end Release;\n-\n-      -------------\n-      -- Restore --\n-      -------------\n-\n-      procedure Restore (T : Saved_Table) is\n-      begin\n-         Free (To_Address (Table));\n-         Last_Val := T.Last_Val;\n-         Max      := T.Max;\n-         Table    := T.Table;\n-         Length   := Max - Min + 1;\n-      end Restore;\n-\n-      ----------\n-      -- Save --\n-      ----------\n-\n-      function Save return Saved_Table is\n-         Res : Saved_Table;\n-\n-      begin\n-         Res.Last_Val := Last_Val;\n-         Res.Max      := Max;\n-         Res.Table    := Table;\n-\n-         Table  := null;\n-         Length := 0;\n-         Init;\n-         return Res;\n-      end Save;\n-\n-      --------------\n-      -- Set_Item --\n-      --------------\n-\n-      procedure Set_Item\n-         (Index : Table_Index_Type;\n-          Item  : Table_Component_Type)\n-      is\n-         --  If Item is a value within the current allocation, and we are going\n-         --  to reallocate, then we must preserve an intermediate copy here\n-         --  before calling Increment_Last. Otherwise, if Table_Component_Type\n-         --  is passed by reference, we are going to end up copying from\n-         --  storage that might have been deallocated from Increment_Last\n-         --  calling Reallocate.\n-\n-         subtype Allocated_Table_T is\n-           Table_Type (Table'First .. Table_Index_Type (Max + 1));\n-         --  A constrained table subtype one element larger than the currently\n-         --  allocated table.\n-\n-         Allocated_Table_Address : constant System.Address :=\n-                                     Table.all'Address;\n-         --  Used for address clause below (we can't use non-static expression\n-         --  Table.all'Address directly in the clause because some older\n-         --  versions of the compiler do not allow it).\n-\n-         Allocated_Table : Allocated_Table_T;\n-         pragma Import (Ada, Allocated_Table);\n-         pragma Suppress (Range_Check, On => Allocated_Table);\n-         for Allocated_Table'Address use Allocated_Table_Address;\n-         --  Allocated_Table represents the currently allocated array, plus one\n-         --  element (the supplementary element is used to have a convenient\n-         --  way of computing the address just past the end of the current\n-         --  allocation). Range checks are suppressed because this unit\n-         --  uses direct calls to System.Memory for allocation, and this can\n-         --  yield misaligned storage (and we cannot rely on the bootstrap\n-         --  compiler supporting specifically disabling alignment checks, so we\n-         --  need to suppress all range checks). It is safe to suppress this\n-         --  check here because we know that a (possibly misaligned) object\n-         --  of that type does actually exist at that address.\n-         --  ??? We should really improve the allocation circuitry here to\n-         --  guarantee proper alignment.\n-\n-         Need_Realloc : constant Boolean := Int (Index) > Max;\n-         --  True if this operation requires storage reallocation (which may\n-         --  involve moving table contents around).\n-\n-      begin\n-         --  If we're going to reallocate, check whether Item references an\n-         --  element of the currently allocated table.\n-\n-         if Need_Realloc\n-           and then Allocated_Table'Address <= Item'Address\n-           and then Item'Address <\n-                      Allocated_Table (Table_Index_Type (Max + 1))'Address\n-         then\n-            --  If so, save a copy on the stack because Increment_Last will\n-            --  reallocate storage and might deallocate the current table.\n-\n-            declare\n-               Item_Copy : constant Table_Component_Type := Item;\n-            begin\n-               Set_Last (Index);\n-               Table (Index) := Item_Copy;\n-            end;\n-\n-         else\n-            --  Here we know that either we won't reallocate (case of Index <\n-            --  Max) or that Item is not in the currently allocated table.\n-\n-            if Int (Index) > Last_Val then\n-               Set_Last (Index);\n-            end if;\n-\n-            Table (Index) := Item;\n-         end if;\n-      end Set_Item;\n-\n-      --------------\n-      -- Set_Last --\n-      --------------\n-\n-      procedure Set_Last (New_Val : Table_Index_Type) is\n-      begin\n-         if Int (New_Val) < Last_Val then\n-            Last_Val := Int (New_Val);\n-\n-         else\n-            Last_Val := Int (New_Val);\n-\n-            if Last_Val > Max then\n-               Reallocate;\n-            end if;\n-         end if;\n-      end Set_Last;\n-\n       ----------------------------\n       -- Tree_Get_Table_Address --\n       ----------------------------\n \n       function Tree_Get_Table_Address return Address is\n       begin\n-         if Length = 0 then\n+         if Is_Empty then\n             return Null_Address;\n          else\n             return Table (First)'Address;\n@@ -418,15 +65,15 @@ package body Table is\n       --  does an implicit Release.\n \n       procedure Tree_Read is\n+         Last : Int;\n       begin\n-         Tree_Read_Int (Max);\n-         Last_Val := Max;\n-         Length := Max - Min + 1;\n-         Reallocate;\n+         Init;\n+         Tree_Read_Int (Last);\n+         Set_Last (Table_Last_Type (Last));\n \n          Tree_Read_Data\n            (Tree_Get_Table_Address,\n-             (Last_Val - Int (First) + 1) *\n+             (Last - Int (First) + 1) *\n \n                --  Note the importance of parenthesizing the following division\n                --  to avoid the possibility of intermediate overflow.\n@@ -446,11 +93,9 @@ package body Table is\n          Tree_Write_Int (Int (Last));\n          Tree_Write_Data\n            (Tree_Get_Table_Address,\n-            (Last_Val - Int (First) + 1) *\n+            (Int (Last - First) + 1) *\n               (Table_Type'Component_Size / Storage_Unit));\n       end Tree_Write;\n \n-   begin\n-      Init;\n    end Table;\n end Table;"}, {"sha": "7062665549211cf79f5d9121d0447962bdc8cba1", "filename": "gcc/ada/table.ads", "status": "modified", "additions": 55, "deletions": 175, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,16 +29,20 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides an implementation of dynamically resizable one\n---  dimensional arrays. The idea is to mimic the normal Ada semantics for\n---  arrays as closely as possible with the one additional capability of\n---  dynamically modifying the value of the Last attribute.\n+--  This package is a wrapper for GNAT.Table, for use in the compiler front\n+--  end. It adds the Tree_Write/Tree_Read functionality; everything else is\n+--  just a renaming of GNAT.Table. See GNAT.Table (g-table.ads) and\n+--  GNAT.Dynamic_Tables (g-dyntab.ads) for documentation.\n \n---  Note that this interface should remain synchronized with those in\n---  GNAT.Table and GNAT.Dynamic_Tables to keep coherency between these\n---  three related units.\n+--  Note that these three interfaces should remain synchronized to keep as much\n+--  coherency as possible among these related units:\n+--\n+--     GNAT.Dynamic_Tables\n+--     GNAT.Table\n+--     Table (the compiler unit)\n \n with Types; use Types;\n+with GNAT.Table;\n \n package Table is\n    pragma Elaborate_Body;\n@@ -50,83 +54,30 @@ package Table is\n       Table_Low_Bound   : Table_Index_Type;\n       Table_Initial     : Pos;\n       Table_Increment   : Nat;\n-      Table_Name        : String;\n+      Table_Name        : String; -- for debugging printouts\n       Release_Threshold : Nat := 0;\n \n    package Table is\n \n-      --  Table_Component_Type and Table_Index_Type specify the type of the\n-      --  array, Table_Low_Bound is the lower bound. Table_Index_Type must be\n-      --  an integer type. The effect is roughly to declare:\n-\n-      --    Table : array (Table_Index_Type range Table_Low_Bound .. <>)\n-      --                       of Table_Component_Type;\n-\n-      --    Note: since the upper bound can be one less than the lower\n-      --    bound for an empty array, the table index type must be able\n-      --    to cover this range, e.g. if the lower bound is 1, then the\n-      --    Table_Index_Type should be Natural rather than Positive.\n-\n-      --  Table_Component_Type may be any Ada type, except that controlled\n-      --  types are not supported. Note however that default initialization\n-      --  will NOT occur for array components.\n-\n-      --  The Table_Initial values controls the allocation of the table when\n-      --  it is first allocated, either by default, or by an explicit Init\n-      --  call. The value used is Opt.Table_Factor * Table_Initial.\n-\n-      --  The Table_Increment value controls the amount of increase, if the\n-      --  table has to be increased in size. The value given is a percentage\n-      --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n-\n-      --  The Table_Name parameter is simply use in debug output messages it\n-      --  has no other usage, and is not referenced in non-debugging mode.\n-\n-      --  The Last and Set_Last subprograms provide control over the current\n-      --  logical allocation. They are quite efficient, so they can be used\n-      --  freely (expensive reallocation occurs only at major granularity\n-      --  chunks controlled by the allocation parameters).\n-\n-      --  Note: We do not make the table components aliased, since this would\n-      --  restrict the use of table for discriminated types. If it is necessary\n-      --  to take the access of a table element, use Unrestricted_Access.\n-\n-      --  WARNING: On HPPA, the virtual addressing approach used in this unit\n-      --  is incompatible with the indexing instructions on the HPPA. So when\n-      --  using this unit, compile your application with -mdisable-indexing.\n-\n-      --  WARNING: If the table is reallocated, then the address of all its\n-      --  components will change. So do not capture the address of an element\n-      --  and then use the address later after the table may be reallocated.\n-      --  One tricky case of this is passing an element of the table to a\n-      --  subprogram by reference where the table gets reallocated during\n-      --  the execution of the subprogram. The best rule to follow is never\n-      --  to pass a table element as a parameter except for the case of IN\n-      --  mode parameters with scalar values.\n-\n-      type Table_Type is\n-        array (Table_Index_Type range <>) of Table_Component_Type;\n-\n-      subtype Big_Table_Type is\n-        Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n-      --  We work with pointers to a bogus array type that is constrained\n-      --  with the maximum possible range bound. This means that the pointer\n-      --  is a thin pointer, which is more efficient. Since subscript checks\n-      --  in any case must be on the logical, rather than physical bounds,\n-      --  safety is not compromised by this approach.\n-\n-      type Table_Ptr is access all Big_Table_Type;\n-      for Table_Ptr'Storage_Size use 0;\n-      --  The table is actually represented as a pointer to allow reallocation\n-\n-      Table : aliased Table_Ptr := null;\n-      --  The table itself. The lower bound is the value of Low_Bound.\n-      --  Logically the upper bound is the current value of Last (although\n-      --  the actual size of the allocated table may be larger than this).\n-      --  The program may only access and modify Table entries in the range\n-      --  First .. Last.\n-\n-      Locked : Boolean := False;\n+      package Tab is new GNAT.Table\n+        (Table_Component_Type,\n+         Table_Index_Type,\n+         Table_Low_Bound,\n+         Positive (Table_Initial),\n+         Natural (Table_Increment),\n+         Table_Name,\n+         Natural (Release_Threshold));\n+\n+      subtype Valid_Table_Index_Type is Tab.Valid_Table_Index_Type;\n+      subtype Table_Last_Type is Tab.Table_Last_Type;\n+      subtype Table_Type is Tab.Table_Type;\n+      subtype Big_Table_Type is Tab.Big_Table_Type;\n+\n+      subtype Table_Ptr is Tab.Table_Ptr;\n+\n+      Table : Table_Ptr renames Tab.Table;\n+\n+      Locked : Boolean renames Tab.Locked;\n       --  Table expansion is permitted only if this switch is set to False. A\n       --  client may set Locked to True, in which case any attempt to expand\n       --  the table will cause an assertion failure. Note that while a table\n@@ -136,110 +87,39 @@ package Table is\n       --  not move during processing, which means that they cannot be expanded.\n       --  The Locked flag is used to enforce this restriction.\n \n-      procedure Init;\n-      --  This procedure allocates a new table of size Initial (freeing any\n-      --  previously allocated larger table). It is not necessary to call\n-      --  Init when a table is first instantiated (since the instantiation does\n-      --  the same initialization steps). However, it is harmless to do so, and\n-      --  Init is convenient in reestablishing a table for new use.\n-\n-      function Last return Table_Index_Type;\n-      pragma Inline (Last);\n-      --  Returns the current value of the last used entry in the table, which\n-      --  can then be used as a subscript for Table. Note that the only way to\n-      --  modify Last is to call the Set_Last procedure. Last must always be\n-      --  used to determine the logically last entry.\n-\n-      procedure Release;\n-      --  Storage is allocated in chunks according to the values given in the\n-      --  Initial and Increment parameters. If Release_Threshold is 0 or the\n-      --  length of the table does not exceed this threshold then a call to\n-      --  Release releases all storage that is allocated, but is not logically\n-      --  part of the current array value; otherwise the call to Release leaves\n-      --  the current array value plus 0.1% of the current table length free\n-      --  elements located at the end of the table (this parameter facilitates\n-      --  reopening large tables and adding a few elements without allocating a\n-      --  chunk of memory). In both cases current array values are not affected\n-      --  by this call.\n-\n-      procedure Free;\n-      --  Free all allocated memory for the table. A call to init is required\n-      --  before any use of this table after calling Free.\n-\n-      First : constant Table_Index_Type := Table_Low_Bound;\n-      --  Export First as synonym for Low_Bound (parallel with use of Last)\n-\n-      procedure Set_Last (New_Val : Table_Index_Type);\n-      pragma Inline (Set_Last);\n-      --  This procedure sets Last to the indicated value. If necessary the\n-      --  table is reallocated to accommodate the new value (i.e. on return\n-      --  the allocated table has an upper bound of at least Last). If Set_Last\n-      --  reduces the size of the table, then logically entries are removed\n-      --  from the table. If Set_Last increases the size of the table, then\n-      --  new entries are logically added to the table.\n-\n-      procedure Increment_Last;\n-      pragma Inline (Increment_Last);\n-      --  Adds 1 to Last (same as Set_Last (Last + 1)\n-\n-      procedure Decrement_Last;\n-      pragma Inline (Decrement_Last);\n-      --  Subtracts 1 from Last (same as Set_Last (Last - 1)\n-\n-      procedure Append (New_Val : Table_Component_Type);\n-      pragma Inline (Append);\n-      --  Equivalent to:\n-      --    x.Increment_Last;\n-      --    x.Table (x.Last) := New_Val;\n-      --  i.e. the table size is increased by one, and the given new item\n-      --  stored in the newly created table element.\n-\n-      procedure Append_All (New_Vals : Table_Type);\n-      --  Appends all components of New_Vals\n+      function Is_Empty return Boolean renames Tab.Is_Empty;\n \n-      procedure Set_Item\n-        (Index : Table_Index_Type;\n-         Item  : Table_Component_Type);\n-      pragma Inline (Set_Item);\n-      --  Put Item in the table at position Index. The table is expanded if\n-      --  current table length is less than Index and in that case Last is set\n-      --  to Index. Item will replace any value already present in the table\n-      --  at this position.\n+      procedure Init renames Tab.Init;\n \n-      type Saved_Table is private;\n-      --  Type used for Save/Restore subprograms\n+      function First return Table_Index_Type renames Tab.First;\n+      function Last return Table_Last_Type renames Tab.Last;\n \n-      function Save return Saved_Table;\n-      --  Resets table to empty, but saves old contents of table in returned\n-      --  value, for possible later restoration by a call to Restore.\n+      procedure Release renames Tab.Release;\n \n-      procedure Restore (T : Saved_Table);\n-      --  Given a Saved_Table value returned by a prior call to Save, restores\n-      --  the table to the state it was in at the time of the Save call.\n+      procedure Free renames Tab.Free;\n \n-      procedure Tree_Write;\n-      --  Writes out contents of table using Tree_IO\n+      procedure Set_Last (New_Val : Table_Last_Type) renames Tab.Set_Last;\n \n-      procedure Tree_Read;\n-      --  Initializes table by reading contents previously written with the\n-      --  Tree_Write call (also using Tree_IO).\n+      procedure Increment_Last renames Tab.Increment_Last;\n+      procedure Decrement_Last renames Tab.Decrement_Last;\n \n-   private\n+      procedure Append (New_Val : Table_Component_Type) renames Tab.Append;\n+      procedure Append_All (New_Vals : Table_Type) renames Tab.Append_All;\n \n-      Last_Val : Int;\n-      --  Current value of Last. Note that we declare this in the private part\n-      --  because we don't want the client to modify Last except through one of\n-      --  the official interfaces (since a modification to Last may require a\n-      --  reallocation of the table).\n+      procedure Set_Item\n+        (Index : Valid_Table_Index_Type;\n+         Item  : Table_Component_Type) renames Tab.Set_Item;\n \n-      Max : Int;\n-      --  Subscript of the maximum entry in the currently allocated table\n+      subtype Saved_Table is Tab.Saved_Table;\n+      function Save return Saved_Table renames Tab.Save;\n+      procedure Restore (T : in out Saved_Table) renames Tab.Restore;\n \n-      type Saved_Table is record\n-         Last_Val : Int;\n-         Max      : Int;\n-         Table    : Table_Ptr;\n-      end record;\n+      procedure Tree_Write;\n+      --  Writes out contents of table using Tree_IO\n+\n+      procedure Tree_Read;\n+      --  Initializes table by reading contents previously written with the\n+      --  Tree_Write call, also using Tree_IO.\n \n    end Table;\n end Table;"}, {"sha": "5263b1ba82238b9e213a7bbd73bcb7388336d81d", "filename": "gcc/ada/uintp.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fuintp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fuintp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.h?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *            Copyright (C) 1992-2016, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 1992-2017, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -101,11 +101,11 @@ extern Boolean UI_Lt\t\t\t(Uint, Uint);\n    the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n    that a Uint value of Uint_Bias indexes the first element.  */\n \n-#define Uints_Ptr (uintp__uints__table - Uint_Table_Start)\n-extern struct Uint_Entry *uintp__uints__table;\n+#define Uints_Ptr (uintp__uints__tab__the_instance - Uint_Table_Start)\n+extern struct Uint_Entry *uintp__uints__tab__the_instance;\n \n-#define Udigits_Ptr uintp__udigits__table\n-extern int *uintp__udigits__table;\n+#define Udigits_Ptr uintp__udigits__tab__the_instance\n+extern int *uintp__udigits__tab__the_instance;\n \n #ifdef __cplusplus\n }"}, {"sha": "39a39f3b79a5e84713f4c662b597770905680f1f", "filename": "gcc/ada/xoscons.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fxoscons.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d25cadecc8f573fa66131b8a89c9047d596794/gcc%2Fada%2Fxoscons.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxoscons.adb?ref=a6d25cadecc8f573fa66131b8a89c9047d596794", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2008-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2008-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,7 @@\n --  The base name of the template file is given by Argument (1). This program\n --  generates the spec for this specified unit (let's call it UNIT_NAME).\n \n---  It works in conjunction with a C template file which must be pre-processed\n+--  It works in conjunction with a C template file which must be preprocessed\n --  and compiled using the cross compiler. Two input files are used:\n --    - the preprocessed C file: UNIT_NAME-tmplt.i\n --    - the generated assembly file: UNIT_NAME-tmplt.s"}]}