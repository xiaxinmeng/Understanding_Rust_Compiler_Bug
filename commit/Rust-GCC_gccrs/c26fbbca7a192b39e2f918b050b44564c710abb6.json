{"sha": "c26fbbca7a192b39e2f918b050b44564c710abb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI2ZmJiY2E3YTE5MmIzOWUyZjkxOGIwNTBiNDQ1NjRjNzEwYWJiNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-04T14:54:13Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-04T14:54:13Z"}, "message": "dwarf2out.c: Fix formatting.\n\n\t* dwarf2out.c: Fix formatting.\n\t* varasm.c: Likewise.\n\nFrom-SVN: r53160", "tree": {"sha": "68d17e919b2238662034537cea169d3d5cc98949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68d17e919b2238662034537cea169d3d5cc98949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c26fbbca7a192b39e2f918b050b44564c710abb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26fbbca7a192b39e2f918b050b44564c710abb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26fbbca7a192b39e2f918b050b44564c710abb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26fbbca7a192b39e2f918b050b44564c710abb6/comments", "author": null, "committer": null, "parents": [{"sha": "0387639b6290f723143524e84bf2373ee1791b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0387639b6290f723143524e84bf2373ee1791b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0387639b6290f723143524e84bf2373ee1791b33"}], "stats": {"total": 182, "additions": 95, "deletions": 87}, "files": [{"sha": "30c22dd9e707f022a82f4a0f17820c053f1075c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c26fbbca7a192b39e2f918b050b44564c710abb6", "patch": "@@ -1,3 +1,8 @@\n+2002-05-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* dwarf2out.c: Fix formatting.\n+\t* varasm.c: Likewise.\n+\n 2002-05-04  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR c/6543"}, {"sha": "2b8e56c771f68daf86ee54ce926c10ed0d27c44a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c26fbbca7a192b39e2f918b050b44564c710abb6", "patch": "@@ -959,8 +959,8 @@ stack_adjust_offset (pattern)\n       src = XEXP (dest, 0);\n       code = GET_CODE (src);\n \n-      switch (code) \n-        {\n+      switch (code)\n+\t{\n \tcase PRE_MODIFY:\n \tcase POST_MODIFY:\n \t  if (XEXP (src, 0) == stack_pointer_rtx)\n@@ -969,7 +969,7 @@ stack_adjust_offset (pattern)\n \t      /* We handle only adjustments by constant amount.  */\n \t      if (GET_CODE (XEXP (src, 1)) != PLUS ||\n \t\t  GET_CODE (val) != CONST_INT)\n-\t\tabort();\n+\t\tabort ();\n \t      offset = -INTVAL (val);\n \t      break;\n \t    }\n@@ -1114,7 +1114,7 @@ flush_queued_reg_saves ()\n {\n   struct queued_reg_save *q, *next;\n \n-  for (q = queued_reg_saves; q ; q = next)\n+  for (q = queued_reg_saves; q; q = next)\n     {\n       dwarf2out_reg_save (last_reg_save_label, REGNO (q->reg), q->cfa_offset);\n       next = q->next;\n@@ -1131,13 +1131,13 @@ clobbers_queued_reg_save (insn)\n {\n   struct queued_reg_save *q;\n \n-  for (q = queued_reg_saves; q ; q = q->next)\n+  for (q = queued_reg_saves; q; q = q->next)\n     if (modified_in_p (q->reg, insn))\n       return true;\n \n   return false;\n }\n-  \n+\n \n /* A temporary register holding an integral value used in adjusting SP\n    or setting up the store_reg.  The \"offset\" field holds the integer\n@@ -1188,7 +1188,7 @@ static dw_cfa_location cfa_temp;\n \t       stores the value, which will be used to adjust the\n \t       stack pointer.  cfa_temp is also used like cfa_store,\n \t       to track stores to the stack via fp or a temp reg.\n- \n+\n   Rules  1- 4: Setting a register's value to cfa.reg or an expression\n   \t       with cfa.reg as the first operand changes the cfa.reg and its\n \t       cfa.offset.  Rule 1 and 4 also set cfa_temp.reg and\n@@ -1656,7 +1656,7 @@ dwarf2out_frame_debug (insn)\n   if (! RTX_FRAME_RELATED_P (insn))\n     {\n       if (!ACCUMULATE_OUTGOING_ARGS)\n-        dwarf2out_stack_adjust (insn);\n+\tdwarf2out_stack_adjust (insn);\n \n       return;\n     }\n@@ -1896,7 +1896,7 @@ output_call_frame_info (for_eh)\n       if (p > augmentation + 1)\n \t{\n \t  augmentation[0] = 'z';\n-          *p = '\\0';\n+\t  *p = '\\0';\n \t}\n \n       /* Ug.  Some platforms can't do unaligned dynamic relocations at all.  */\n@@ -1952,7 +1952,7 @@ output_call_frame_info (for_eh)\n     output_cfi (cfi, NULL, for_eh);\n \n   /* Pad the CIE out to an address sized boundary.  */\n-  ASM_OUTPUT_ALIGN (asm_out_file, \n+  ASM_OUTPUT_ALIGN (asm_out_file,\n \t\t    floor_log2 (for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE));\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n@@ -1984,15 +1984,15 @@ output_call_frame_info (for_eh)\n \t\t   gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin),\n \t\t   \"FDE initial location\");\n \t  dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin, \n+\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n \t\t\t\t\"FDE address range\");\n \t}\n       else\n \t{\n \t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n \t\t\t       \"FDE initial location\");\n-\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, \n-\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin, \n+\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n+\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n \t\t\t\t\"FDE address range\");\n \t}\n \n@@ -2045,7 +2045,7 @@ output_call_frame_info (for_eh)\n \toutput_cfi (cfi, fde, for_eh);\n \n       /* Pad the FDE out to an address sized boundary.  */\n-      ASM_OUTPUT_ALIGN (asm_out_file, \n+      ASM_OUTPUT_ALIGN (asm_out_file,\n \t\t        floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n       ASM_OUTPUT_LABEL (asm_out_file, l2);\n     }\n@@ -3681,7 +3681,7 @@ static void retry_incomplete_types\tPARAMS ((void));\n static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n static void splice_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n static int file_info_cmp\t\tPARAMS ((const void *, const void *));\n-static dw_loc_list_ref new_loc_list     PARAMS ((dw_loc_descr_ref, \n+static dw_loc_list_ref new_loc_list     PARAMS ((dw_loc_descr_ref,\n \t\t\t\t\t\t const char *, const char *,\n \t\t\t\t\t\t const char *, unsigned));\n static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n@@ -4504,7 +4504,7 @@ add_AT_string (die, attr_kind, str)\n {\n   dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n   struct indirect_string_node *node;\n-  \n+\n   if (! debug_str_hash)\n     {\n       debug_str_hash = ht_create (10);\n@@ -4915,7 +4915,7 @@ is_cxx ()\n {\n   return (get_AT_unsigned (comp_unit_die, DW_AT_language)\n \t  == DW_LANG_C_plus_plus);\n-}  \n+}\n \n static inline int\n is_fortran ()\n@@ -5626,7 +5626,7 @@ is_symbol_die (c)\n      dw_die_ref c;\n {\n   return (is_type_die (c)\n-\t  || (get_AT (c, DW_AT_declaration) \n+\t  || (get_AT (c, DW_AT_declaration)\n \t      && !get_AT (c, DW_AT_specification)));\n }\n \n@@ -5679,7 +5679,7 @@ break_out_includes (die)\n   dw_die_ref unit = NULL;\n   limbo_die_node *node;\n \n-  for (ptr = &(die->die_child); *ptr; )\n+  for (ptr = &(die->die_child); *ptr;)\n     {\n       dw_die_ref c = *ptr;\n \n@@ -5761,6 +5761,7 @@ output_location_lists (die)\n     output_location_lists (c);\n \n }\n+\n /* The format of each DIE (and its attribute value pairs) is encoded in an\n    abbreviation table.  This routine builds the abbreviation table and assigns\n    a unique abbreviation id for each abbreviation entry.  The children of each\n@@ -6183,7 +6184,7 @@ new_loc_list (expr, begin, end, section, gensym)\n   retlist->end = end;\n   retlist->expr = expr;\n   retlist->section = section;\n-  if (gensym) \n+  if (gensym)\n     retlist->ll_symbol = gen_internal_sym (\"LLST\");\n \n   return retlist;\n@@ -6200,7 +6201,7 @@ add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n      const char *section;\n {\n   dw_loc_list_ref *d;\n-  \n+\n   /* Find the end of the chain.  */\n   for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n     ;\n@@ -6231,7 +6232,7 @@ output_loc_list (list_head)\n \t\t\t     \"Location list base address specifier base\");\n     }\n \n-  for (curr = list_head; curr != NULL; curr=curr->dw_loc_next)\n+  for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n     {\n       unsigned long size;\n \n@@ -6242,7 +6243,7 @@ output_loc_list (list_head)\n \t\t\t    \"Location list end address (%s)\",\n \t\t\t    list_head->ll_symbol);\n       size = size_of_locs (curr->expr);\n-      \n+\n       /* Output the block length for this list of location operations.  */\n       if (size > 0xffff)\n \tabort ();\n@@ -6331,7 +6332,7 @@ output_die (die)\n \n \t    dw2_asm_output_data (1,\n \t\t\t\t 2 * HOST_BITS_PER_LONG / HOST_BITS_PER_CHAR,\n-\t\t\t         \"%s\", name);\n+\t\t\t\t \"%s\", name);\n \n \t    if (WORDS_BIG_ENDIAN)\n \t      {\n@@ -6356,7 +6357,7 @@ output_die (die)\n \t    unsigned int i;\n \n \t    dw2_asm_output_data (1, a->dw_attr_val.v.val_float.length * 4,\n-\t\t\t         \"%s\", name);\n+\t\t\t\t \"%s\", name);\n \n \t    for (i = 0; i < a->dw_attr_val.v.val_float.length; i++)\n \t      dw2_asm_output_data (4, a->dw_attr_val.v.val_float.array[i],\n@@ -6368,7 +6369,7 @@ output_die (die)\n \t  dw2_asm_output_data (1, AT_flag (a), \"%s\", name);\n \t  break;\n \n-        case dw_val_class_loc_list:\n+\tcase dw_val_class_loc_list:\n \t  {\n \t    char *sym = AT_loc_list (a)->ll_symbol;\n \n@@ -6938,7 +6939,7 @@ output_file_names ()\n       if (total > dirs[i].length + 1)\n \t{\n \t  /* It's worthwhile adding.  */\n-          for (j = i; j < ndirs; j++)\n+\t  for (j = i; j < ndirs; j++)\n \t    if (savehere[j] > 0)\n \t      {\n \t\t/* Remember how much we saved for this directory so far.  */\n@@ -7499,10 +7500,10 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n       /* See if we already have the appropriately qualified variant of\n \t this type.  */\n-      qualified_type \n+      qualified_type\n \t= get_qualified_type (type,\n \t\t\t      ((is_const_type ? TYPE_QUAL_CONST : 0)\n-\t\t\t       | (is_volatile_type \n+\t\t\t       | (is_volatile_type\n \t\t\t\t  ? TYPE_QUAL_VOLATILE : 0)));\n \n       /* If we do, then we can just use its DIE, if it exists.  */\n@@ -7514,7 +7515,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t}\n \n       /* Handle C typedef types.  */\n-      if (qualified_type && TYPE_NAME (qualified_type) \n+      if (qualified_type && TYPE_NAME (qualified_type)\n \t  && TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL\n \t  && DECL_ORIGINAL_TYPE (TYPE_NAME (qualified_type)))\n \t{\n@@ -8141,7 +8142,7 @@ loc_descriptor_from_tree (loc, addressp)\n \treturn 0;\n       break;\n \n-    case TRUTH_AND_EXPR: \n+    case TRUTH_AND_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case BIT_AND_EXPR:\n       op = DW_OP_and;\n@@ -8662,7 +8663,7 @@ add_const_value_attribute (die, rtl)\n \t out, and the CONST_INT rtx is assigned VOIDmode.  */\n       {\n \tHOST_WIDE_INT val = INTVAL (rtl);\n-\t\n+\n \t/* ??? We really should be using HOST_WIDE_INT throughout.  */\n \tif (val < 0 && (long) val == val)\n \t  add_AT_int (die, DW_AT_const_value, (long) val);\n@@ -8691,7 +8692,7 @@ add_const_value_attribute (die, rtl)\n \tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t  {\n \t    unsigned length = GET_MODE_SIZE (mode) / 4;\n- \t    long *array = (long *) xmalloc (sizeof (long) * length);\n+\t    long *array = (long *) xmalloc (sizeof (long) * length);\n \t    REAL_VALUE_TYPE rv;\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, rtl);\n@@ -10060,7 +10061,7 @@ gen_formal_types_die (function_or_method_type, context_die)\n     }\n   else\n     arg = NULL_TREE;\n-  \n+\n   first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n \n   /* Make our first pass over the list of formal parameter types and output a\n@@ -10144,7 +10145,7 @@ dwarf2out_abstract_function (decl)\n   /* Make sure we have the actual abstract inline, not a clone.  */\n   decl = DECL_ORIGIN (decl);\n \n-  old_die = lookup_decl_die (decl);  \n+  old_die = lookup_decl_die (decl);\n   if (old_die && get_AT_unsigned (old_die, DW_AT_inline))\n     /* We've already generated the abstract instance.  */\n     return;\n@@ -10158,7 +10159,7 @@ dwarf2out_abstract_function (decl)\n \tgen_type_die_for_member\n \t  (context, decl, decl_function_context (decl) ? NULL : comp_unit_die);\n     }\n- \n+\n   /* Pretend we've just finished compiling this function.  */\n   save_fn = current_function_decl;\n   current_function_decl = decl;\n@@ -10477,7 +10478,7 @@ gen_variable_die (decl, context_die)\n \n      ??? Duplicated blocks have been rewritten to use .debug_ranges.  */\n   else if (old_die && TREE_STATIC (decl)\n- \t   && get_AT_flag (old_die, DW_AT_declaration) == 1)\n+\t   && get_AT_flag (old_die, DW_AT_declaration) == 1)\n     {\n       /* This is a definition of a C++ class level static.  */\n       add_AT_die_ref (var_die, DW_AT_specification, old_die);\n@@ -11559,7 +11560,7 @@ mark_limbo_die_list (ptr)\n      void *ptr ATTRIBUTE_UNUSED;\n {\n   limbo_die_node *node;\n-  for (node = limbo_die_list; node ; node = node->next)\n+  for (node = limbo_die_list; node; node = node->next)\n     ggc_mark_tree (node->created_for);\n }\n \f\n@@ -12165,7 +12166,7 @@ dwarf2out_finish (input_filename)\n \t    add_child_die (comp_unit_die, die);\n \t  else if (node->created_for\n \t\t   && ((DECL_P (node->created_for)\n-\t\t        && (context = DECL_CONTEXT (node->created_for)))\n+\t\t\t&& (context = DECL_CONTEXT (node->created_for)))\n \t\t       || (TYPE_P (node->created_for)\n \t\t\t   && (context = TYPE_CONTEXT (node->created_for))))\n \t\t   && TREE_CODE (context) == FUNCTION_DECL)\n@@ -12291,7 +12292,7 @@ dwarf2out_finish (input_filename)\n \n   /* Have to end the primary source file.  */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    { \n+    {\n       named_section_flags (DEBUG_MACINFO_SECTION, SECTION_DEBUG);\n       dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n     }"}, {"sha": "2215fdd19697f9087a906bd3824680cf04dfd1ea", "filename": "gcc/varasm.c", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26fbbca7a192b39e2f918b050b44564c710abb6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c26fbbca7a192b39e2f918b050b44564c710abb6", "patch": "@@ -268,6 +268,7 @@ data_section ()\n       in_section = in_data;\n     }\n }\n+\n /* Tell assembler to ALWAYS switch to data section, in case\n    it's not sure where it is.  */\n \n@@ -339,15 +340,15 @@ get_named_section_flags (section)\n {\n   struct in_named_entry **slot;\n \n-  slot = (struct in_named_entry**)\n+  slot = (struct in_named_entry **)\n     htab_find_slot_with_hash (in_named_htab, section,\n \t\t\t      htab_hash_string (section), NO_INSERT);\n \n   return slot ? (*slot)->flags : 0;\n }\n \n /* Returns true if the section has been declared before.   Sets internal\n-   flag on this section in in_named_hash so subsequent calls on this \n+   flag on this section in in_named_hash so subsequent calls on this\n    section will return false.  */\n \n bool\n@@ -356,15 +357,15 @@ named_section_first_declaration (name)\n {\n   struct in_named_entry **slot;\n \n-  slot = (struct in_named_entry**)\n-    htab_find_slot_with_hash (in_named_htab, name, \n+  slot = (struct in_named_entry **)\n+    htab_find_slot_with_hash (in_named_htab, name,\n \t\t\t      htab_hash_string (name), NO_INSERT);\n   if (! (*slot)->declared)\n     {\n       (*slot)->declared = true;\n       return true;\n     }\n-  else \n+  else\n     {\n       return false;\n     }\n@@ -381,7 +382,7 @@ set_named_section_flags (section, flags)\n {\n   struct in_named_entry **slot, *entry;\n \n-  slot = (struct in_named_entry**)\n+  slot = (struct in_named_entry **)\n     htab_find_slot_with_hash (in_named_htab, section,\n \t\t\t      htab_hash_string (section), INSERT);\n   entry = *slot;\n@@ -412,7 +413,7 @@ named_section_flags (name, flags)\n       if (! set_named_section_flags (name, flags))\n \tabort ();\n \n-      (* targetm.asm_out.named_section) (name, flags);\n+      (*targetm.asm_out.named_section) (name, flags);\n \n       if (flags & SECTION_FORGET)\n \tin_section = no_section;\n@@ -624,9 +625,9 @@ default_exception_section ()\n \n void\n mergeable_string_section (decl, align, flags)\n-  tree decl ATTRIBUTE_UNUSED;\n-  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-  unsigned int flags ATTRIBUTE_UNUSED;\n+     tree decl ATTRIBUTE_UNUSED;\n+     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+     unsigned int flags ATTRIBUTE_UNUSED;\n {\n #ifdef HAVE_GAS_SHF_MERGE\n   if (flag_merge_constants\n@@ -657,7 +658,7 @@ mergeable_string_section (decl, align, flags)\n \t  for (i = 0; i < len; i += unit)\n \t    {\n \t      for (j = 0; j < unit; j++)\n-\t\tif (str [i + j] != '\\0')\n+\t\tif (str[i + j] != '\\0')\n \t\t  break;\n \t      if (j == unit)\n \t\tbreak;\n@@ -693,15 +694,15 @@ mergeable_string_section (decl, align, flags)\n     }\n #endif\n   readonly_data_section ();\n-}  \n+}\n \n /* Tell assembler to switch to the section for constant merging.  */\n \n void\n mergeable_constant_section (mode, align, flags)\n-  enum machine_mode mode ATTRIBUTE_UNUSED;\n-  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-  unsigned int flags ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+     unsigned int flags ATTRIBUTE_UNUSED;\n {\n #ifdef HAVE_GAS_SHF_MERGE\n   unsigned int modesize = GET_MODE_BITSIZE (mode);\n@@ -720,7 +721,7 @@ mergeable_constant_section (mode, align, flags)\n       flags |= (align / 8) | SECTION_MERGE;\n       named_section_flags (name, flags);\n       return;\n-    }            \n+    }\n #endif\n   readonly_data_section ();\n }\n@@ -729,7 +730,7 @@ mergeable_constant_section (mode, align, flags)\n \n static const char *\n strip_reg_name (name)\n-  const char *name;\n+     const char *name;\n {\n #ifdef REGISTER_PREFIX\n   if (!strncmp (name, REGISTER_PREFIX, strlen (REGISTER_PREFIX)))\n@@ -750,7 +751,7 @@ strip_reg_name (name)\n \n int\n decode_reg_name (asmspec)\n-  const char *asmspec;\n+     const char *asmspec;\n {\n   if (asmspec != 0)\n     {\n@@ -1203,7 +1204,7 @@ assemble_start_function (decl, fnname)\n     {\n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n       ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,\n-\t\t\t\t align_functions_log, align_functions-1);\n+\t\t\t\t align_functions_log, align_functions - 1);\n #else\n       ASM_OUTPUT_ALIGN (asm_out_file, align_functions_log);\n #endif\n@@ -1373,7 +1374,7 @@ assemble_string (p, size)\n static void\n asm_emit_uninitialised (decl, name, size, rounded)\n      tree decl;\n-     const char * name;\n+     const char *name;\n      int size ATTRIBUTE_UNUSED;\n      int rounded ATTRIBUTE_UNUSED;\n {\n@@ -2486,7 +2487,7 @@ const_str_htab_eq (x, y)\n \n static void\n const_str_htab_del (dfsp)\n-    void *dfsp;\n+     void *dfsp;\n {\n   free (dfsp);\n }\n@@ -2778,7 +2779,7 @@ compare_constant_1 (exp, p)\n \t\t  && TREE_CODE (TREE_PURPOSE (link)) == FIELD_DECL)\n \t\t{\n \t\t  if (memcmp ((char *) &TREE_PURPOSE (link), p,\n-\t\t\t    sizeof TREE_PURPOSE (link)))\n+\t\t\t      sizeof TREE_PURPOSE (link)))\n \t\t    return 0;\n \n \t\t  p += sizeof TREE_PURPOSE (link);\n@@ -2839,7 +2840,7 @@ compare_constant_1 (exp, p)\n \ttree new = (*lang_hooks.expand_constant) (exp);\n \n \tif (new != exp)\n-          return compare_constant_1 (new, p);\n+\t  return compare_constant_1 (new, p);\n \telse\n \t  return 0;\n       }\n@@ -2935,7 +2936,7 @@ record_constant_1 (exp)\n \t  obstack_grow (&permanent_obstack, &nbytes, sizeof (nbytes));\n \t  obstack_blank (&permanent_obstack, nbytes);\n \t  get_set_constructor_bytes\n-\t    (exp, (unsigned char *) permanent_obstack.next_free-nbytes,\n+\t    (exp, (unsigned char *) permanent_obstack.next_free - nbytes,\n \t     nbytes);\n \t  return;\n \t}\n@@ -3053,7 +3054,7 @@ record_constant_1 (exp)\n \ttree new = (*lang_hooks.expand_constant) (exp);\n \n \tif (new != exp)\n-          record_constant_1 (new);\n+\t  record_constant_1 (new);\n \treturn;\n       }\n     }\n@@ -3631,16 +3632,16 @@ decode_rtx_const (mode, x, value)\n \n   if (value->kind == RTX_INT && value->un.addr.base != 0\n       && GET_CODE (value->un.addr.base) == UNSPEC)\n-    {      \n+    {\n       /* For a simple UNSPEC, the base is set to the\n \t operand, the kind field is set to the index of\n-\t the unspec expression. \n+\t the unspec expression.\n \t Together with the code below, in case that\n-\t the operand is a SYMBOL_REF or LABEL_REF, \n-\t the address of the string or the code_label \n+\t the operand is a SYMBOL_REF or LABEL_REF,\n+\t the address of the string or the code_label\n \t is taken as base.  */\n       if (XVECLEN (value->un.addr.base, 0) == 1)\n-        {\n+\t{\n \t  value->kind = RTX_UNSPEC + XINT (value->un.addr.base, 1);\n \t  value->un.addr.base = XVECEXP (value->un.addr.base, 0, 0);\n \t}\n@@ -3768,7 +3769,7 @@ mem_for_const_double (x)\n \n   return 0;\n }\n-  \n+\n /* Given a constant rtx X, make (or find) a memory constant for its value\n    and return a MEM rtx to refer to it in memory.  */\n \n@@ -3797,7 +3798,7 @@ force_const_mem (mode, x)\n   desc = record_constant_rtx (mode, x);\n   desc->next = const_rtx_hash_table[hash];\n   const_rtx_hash_table[hash] = desc;\n-  \n+\n   /* Align the location counter as required by EXP's data type.  */\n   align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);\n #ifdef CONSTANT_ALIGNMENT\n@@ -3826,7 +3827,7 @@ force_const_mem (mode, x)\n     first_pool = pool;\n   else\n     last_pool->next = pool;\n-  \n+\n   last_pool = pool;\n   pool_offset += GET_MODE_SIZE (mode);\n \n@@ -3944,8 +3945,8 @@ get_pool_size ()\n \n void\n output_constant_pool (fnname, fndecl)\n-  const char *fnname ATTRIBUTE_UNUSED;\n-  tree fndecl ATTRIBUTE_UNUSED;\n+     const char *fnname ATTRIBUTE_UNUSED;\n+     tree fndecl ATTRIBUTE_UNUSED;\n {\n   struct pool_constant *pool;\n   rtx x;\n@@ -4055,7 +4056,7 @@ output_constant_pool (fnname, fndecl)\n \t  }\n \t  break;\n \n-        case MODE_VECTOR_INT:\n+\tcase MODE_VECTOR_INT:\n \t  {\n \t    int i, units;\n \t    rtx elt;\n@@ -4202,10 +4203,11 @@ mark_constant (current_rtx, data)\n       if (CONSTANT_POOL_ADDRESS_P (x))\n \t{\n \t  struct pool_constant *pool = find_pool_constant (cfun, x);\n-\t  if (pool->mark == 0) {\n-\t    pool->mark = 1;\n-\t    for_each_rtx (&(pool->constant), &mark_constant, NULL);\n-\t  }\n+\t  if (pool->mark == 0)\n+\t    {\n+\t      pool->mark = 1;\n+\t      for_each_rtx (&(pool->constant), &mark_constant, NULL);\n+\t    }\n \t  else\n \t    return -1;\n \t}\n@@ -4279,7 +4281,7 @@ output_addressed_constants (exp)\n     case CONSTRUCTOR:\n       for (tem = CONSTRUCTOR_ELTS (exp); tem; tem = TREE_CHAIN (tem))\n \tif (TREE_VALUE (tem) != 0)\n-\t    reloc |= output_addressed_constants (TREE_VALUE (tem));\n+\t  reloc |= output_addressed_constants (TREE_VALUE (tem));\n \n       break;\n \n@@ -4397,7 +4399,7 @@ initializer_constant_valid_p (value, endtype)\n     case PLUS_EXPR:\n       if (! INTEGRAL_TYPE_P (endtype)\n \t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n-        {\n+\t{\n \t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n \t\t\t\t\t\t      endtype);\n \t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n@@ -4407,7 +4409,7 @@ initializer_constant_valid_p (value, endtype)\n \t    return valid1;\n \t  if (valid1 == null_pointer_node)\n \t    return valid0;\n-        }\n+\t}\n       break;\n \n     case MINUS_EXPR:\n@@ -4614,7 +4616,7 @@ output_constant (exp, size, align)\n       if (TREE_CODE (exp) == INTEGER_CST)\n \tassemble_integer (expand_expr (exp, NULL_RTX,\n \t\t\t\t       VOIDmode, EXPAND_INITIALIZER),\n-\t\t\t thissize, align, 1);\n+\t\t\t  thissize, align, 1);\n       else if (TREE_CODE (exp) == CONSTRUCTOR)\n \t{\n \t  unsigned char *buffer = (unsigned char *) alloca (thissize);\n@@ -4656,7 +4658,7 @@ array_size_for_constructor (val)\n     return TREE_STRING_LENGTH (val);\n \n   max_index = NULL_TREE;\n-  for (i = CONSTRUCTOR_ELTS (val); i ; i = TREE_CHAIN (i))\n+  for (i = CONSTRUCTOR_ELTS (val); i; i = TREE_CHAIN (i))\n     {\n       tree index = TREE_PURPOSE (i);\n \n@@ -5050,7 +5052,7 @@ weak_finish ()\n {\n   tree t;\n \n-  for (t = weak_decls; t ; t = TREE_CHAIN (t))\n+  for (t = weak_decls; t; t = TREE_CHAIN (t))\n     {\n       tree decl = TREE_VALUE (t);\n       const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n@@ -5234,7 +5236,7 @@ void\n init_varasm_once ()\n {\n   const_str_htab = htab_create (128, const_str_htab_hash, const_str_htab_eq,\n-  \t\t\t\tconst_str_htab_del);\n+\t\t\t\tconst_str_htab_del);\n   in_named_htab = htab_create (31, in_named_entry_hash,\n \t\t\t       in_named_entry_eq, NULL);\n "}]}