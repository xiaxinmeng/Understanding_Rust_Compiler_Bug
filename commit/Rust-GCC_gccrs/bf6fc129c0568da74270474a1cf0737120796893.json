{"sha": "bf6fc129c0568da74270474a1cf0737120796893", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2ZmMxMjljMDU2OGRhNzQyNzA0NzRhMWNmMDczNzEyMDc5Njg5Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-19T15:41:11Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-19T15:41:11Z"}, "message": "Implement speculative call verifier\n\nthis patch implements verifier and fixes one bug where speculative calls\nproduced by ipa-devirt ended up having num_speculative_call_targets = 0\ninstead of 1.\n\n\t* cgraph.c (cgraph_edge::make_speculative): Increase number of\n\tspeculative targets.\n\t(verify_speculative_call): New function\n\t(cgraph_node::verify_node): Use it.\n\t* ipa-profile.c (ipa_profile): Fix formating; do not set number of\n\tspeculations.", "tree": {"sha": "e1b5a92df1ad3673db683a4d03613cc3fd14d72b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1b5a92df1ad3673db683a4d03613cc3fd14d72b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6fc129c0568da74270474a1cf0737120796893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6fc129c0568da74270474a1cf0737120796893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6fc129c0568da74270474a1cf0737120796893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6fc129c0568da74270474a1cf0737120796893/comments", "author": null, "committer": null, "parents": [{"sha": "118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118aa5e31ce479bb81a003199b4c6ca0d997c9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118aa5e31ce479bb81a003199b4c6ca0d997c9a2"}], "stats": {"total": 335, "additions": 241, "deletions": 94}, "files": [{"sha": "a50847992f9931e57f3e63be5440252da53f710d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6fc129c0568da74270474a1cf0737120796893/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6fc129c0568da74270474a1cf0737120796893/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf6fc129c0568da74270474a1cf0737120796893", "patch": "@@ -1,3 +1,13 @@\n+2020-01-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/93318\n+\t* cgraph.c (cgraph_edge::make_speculative): Increase number of\n+\tspeculative targets.\n+\t(verify_speculative_call): New function\n+\t(cgraph_node::verify_node): Use it.\n+\t* ipa-profile.c (ipa_profile): Fix formating; do not set number of\n+\tspeculations.\n+\n 2020-01-18  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/93318"}, {"sha": "187f6ed30ba357b7bfaddf6039e72e205f3ac366", "filename": "gcc/cgraph.c", "status": "modified", "additions": 144, "deletions": 7, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6fc129c0568da74270474a1cf0737120796893/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6fc129c0568da74270474a1cf0737120796893/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=bf6fc129c0568da74270474a1cf0737120796893", "patch": "@@ -1076,6 +1076,7 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n   e2->speculative_id = speculative_id;\n   e2->target_prob = target_prob;\n   e2->in_polymorphic_cdtor = in_polymorphic_cdtor;\n+  indirect_info->num_speculative_call_targets++;\n   count -= e2->count;\n   symtab->call_edge_duplication_hooks (this, e2);\n   ref = n->create_reference (n2, IPA_REF_ADDR, call_stmt);\n@@ -3148,6 +3149,128 @@ cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n #  pragma GCC diagnostic ignored \"-Wformat-diag\"\n #endif\n \n+/* Verify consistency of speculative call in NODE corresponding to STMT\n+   and LTO_STMT_UID.  If INDIRECT is set, assume that it is the indirect\n+   edge of call sequence. Return true if error is found.\n+\n+   This function is called to every component of indirect call (direct edges,\n+   indirect edge and refs).  To save duplicated work, do full testing only\n+   in that case.  */\n+static bool\n+verify_speculative_call (struct cgraph_node *node, gimple *stmt,\n+\t\t\t unsigned int lto_stmt_uid,\n+\t\t\t struct cgraph_edge *indirect)\n+{\n+  if (indirect == NULL)\n+    {\n+      for (indirect = node->indirect_calls; indirect;\n+\t   indirect = indirect->next_callee)\n+\tif (indirect->call_stmt == stmt\n+\t    && indirect->lto_stmt_uid == lto_stmt_uid)\n+\t  break;\n+      if (!indirect)\n+\t{\n+\t  error (\"missing indirect call in speculative call sequence\");\n+\t  return true;\n+\t}\n+      if (!indirect->speculative)\n+\t{\n+\t  error (\"indirect call in speculative call sequence has no \"\n+\t\t \"speculative flag\");\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  /* Maximal number of targets.  We probably will never want to have more than\n+     this.  */\n+  const unsigned int num = 256;\n+  cgraph_edge *direct_calls[num];\n+  ipa_ref *refs[num];\n+\n+  for (unsigned int i = 0; i < num; i++)\n+    {\n+      direct_calls[i] = NULL;\n+      refs[i] = NULL;\n+    }\n+\n+  for (cgraph_edge *direct = node->callees; direct;\n+       direct = direct->next_callee)\n+    if (direct->call_stmt == stmt && direct->lto_stmt_uid == lto_stmt_uid)\n+      {\n+\tif (!direct->speculative)\n+\t  {\n+\t    error (\"direct call to %s in speculative call sequence has no \"\n+\t\t   \"speculative flag\", direct->callee->dump_name ());\n+\t    return true;\n+\t  }\n+\tif (direct->speculative_id >= num)\n+\t  {\n+\t    error (\"direct call to %s in speculative call sequence has \"\n+\t\t   \"speculative_uid %i out of range\",\n+\t\t   direct->callee->dump_name (), direct->speculative_id);\n+\t    return true;\n+\t  }\n+\tif (direct_calls[direct->speculative_id])\n+\t  {\n+\t    error (\"duplicate direct call to %s in speculative call sequence \"\n+\t\t   \"with speculative_uid %i\",\n+\t\t   direct->callee->dump_name (), direct->speculative_id);\n+\t    return true;\n+\t  }\n+\tdirect_calls[direct->speculative_id] = direct;\n+      }\n+\n+  ipa_ref *ref;\n+  for (int i = 0; node->iterate_reference (i, ref); i++)\n+    if (ref->speculative\n+\t&& ref->stmt == stmt && ref->lto_stmt_uid == lto_stmt_uid)\n+      {\n+\tif (ref->speculative_id >= num)\n+\t  {\n+\t    error (\"direct call to %s in speculative call sequence has \"\n+\t\t   \"speculative_uid %i out of range\",\n+\t\t   ref->referred->dump_name (), ref->speculative_id);\n+\t    return true;\n+\t  }\n+\tif (refs[ref->speculative_id])\n+\t  {\n+\t    error (\"duplicate reference %s in speculative call sequence \"\n+\t\t   \"with speculative_uid %i\",\n+\t\t   ref->referred->dump_name (), ref->speculative_id);\n+\t    return true;\n+\t  }\n+\trefs[ref->speculative_id] = ref;\n+      }\n+\n+  int num_targets = 0;\n+  for (unsigned int i = 0 ; i < num ; i++)\n+    {\n+      if (refs[i] && !direct_calls[i])\n+\t{\n+\t  error (\"missing direct call for speculation %i\", i);\n+\t  return true;\n+\t}\n+      if (!refs[i] && direct_calls[i])\n+\t{\n+\t  error (\"missing ref for speculation %i\", i);\n+\t  return true;\n+\t}\n+      if (refs[i] != NULL)\n+\tnum_targets++;\n+    }\n+\n+  if (num_targets != indirect->num_speculative_call_targets_p ())\n+    {\n+      error (\"number of speculative targets %i mismatched with \"\n+\t     \"num_speculative_targets %i\",\n+\t     num_targets,\n+\t     indirect->num_speculative_call_targets_p ());\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Verify cgraph nodes of given cgraph node.  */\n DEBUG_FUNCTION void\n cgraph_node::verify_node (void)\n@@ -3320,6 +3443,10 @@ cgraph_node::verify_node (void)\n \t  error (\"edge has both cal_stmt and lto_stmt_uid set\");\n \t  error_found = true;\n \t}\n+      if (e->speculative\n+\t  && verify_speculative_call (e->caller, e->call_stmt, e->lto_stmt_uid,\n+\t\t\t\t      NULL))\n+\terror_found = true;\n     }\n   for (e = indirect_calls; e; e = e->next_callee)\n     {\n@@ -3342,7 +3469,24 @@ cgraph_node::verify_node (void)\n \t  fprintf (stderr, \"\\n\");\n \t  error_found = true;\n \t}\n+      if (e->speculative\n+\t  && verify_speculative_call (e->caller, e->call_stmt, e->lto_stmt_uid,\n+\t\t\t\t      e))\n+\terror_found = true;\n     }\n+  for (i = 0; iterate_reference (i, ref); i++)\n+    {\n+      if (ref->stmt && ref->lto_stmt_uid)\n+\t{\n+\t  error (\"reference has both cal_stmt and lto_stmt_uid set\");\n+\t  error_found = true;\n+\t}\n+      if (ref->speculative\n+\t  && verify_speculative_call (this, ref->stmt,\n+\t\t\t\t      ref->lto_stmt_uid, NULL))\n+\terror_found = true;\n+    }\n+\n   if (!callers && inlined_to)\n     {\n       error (\"inlined_to pointer is set but no predecessors found\");\n@@ -3519,13 +3663,6 @@ cgraph_node::verify_node (void)\n \t/* No CFG available?!  */\n \tgcc_unreachable ();\n \n-      for (i = 0; iterate_reference (i, ref); i++)\n-\tif (ref->stmt && ref->lto_stmt_uid)\n-\t  {\n-\t    error (\"reference has both cal_stmt and lto_stmt_uid set\");\n-\t    error_found = true;\n-\t  }\n-\n       for (e = callees; e; e = e->next_callee)\n \t{\n \t  if (!e->aux && !e->speculative)"}, {"sha": "670d9e2fb73a32c6ea98741d8c002e729011f101", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6fc129c0568da74270474a1cf0737120796893/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6fc129c0568da74270474a1cf0737120796893/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=bf6fc129c0568da74270474a1cf0737120796893", "patch": "@@ -864,104 +864,104 @@ ipa_profile (void)\n \t\t}\n \n \t      unsigned speculative_id = 0;\n-\t      bool speculative_found = false;\n \t      for (unsigned i = 0; i < spec_count; i++)\n-\t      {\n-\t      speculative_call_target item\n-\t\t= csum->speculative_call_targets[i];\n-\t      n2 = find_func_by_profile_id (item.target_id);\n-\t      if (n2)\n \t\t{\n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n-\t\t\t       \" other module %s => %s, prob %3.2f\\n\",\n-\t\t\t       n->dump_name (),\n-\t\t\t       n2->dump_name (),\n-\t\t\t       item.target_probability\n-\t\t\t\t / (float) REG_BR_PROB_BASE);\n-\t\t    }\n-\t\t  if (item.target_probability < REG_BR_PROB_BASE / 2)\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: probability is too low.\\n\");\n-\t\t    }\n-\t\t  else if (!e->maybe_hot_p ())\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: call is cold.\\n\");\n-\t\t    }\n-\t\t  else if (n2->get_availability () <= AVAIL_INTERPOSABLE\n-\t\t\t   && n2->can_be_discarded_p ())\n-\t\t    {\n-\t\t      nuseless++;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: target is overwritable \"\n-\t\t\t\t \"and can be discarded.\\n\");\n-\t\t    }\n-\t\t  else if (!check_argument_count (n2, e))\n+\t\t  speculative_call_target item\n+\t\t    = csum->speculative_call_targets[i];\n+\t\t  n2 = find_func_by_profile_id (item.target_id);\n+\t\t  if (n2)\n \t\t    {\n-\t\t      nmismatch++;\n \t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: \"\n-\t\t\t\t \"parameter count mismatch\\n\");\n+\t\t\t{\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"Indirect call -> direct call from\"\n+\t\t\t\t   \" other module %s => %s, prob %3.2f\\n\",\n+\t\t\t\t   n->dump_name (),\n+\t\t\t\t   n2->dump_name (),\n+\t\t\t\t   item.target_probability\n+\t\t\t\t     / (float) REG_BR_PROB_BASE);\n+\t\t\t}\n+\t\t      if (item.target_probability < REG_BR_PROB_BASE / 2)\n+\t\t\t{\n+\t\t\t  nuseless++;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"Not speculating: \"\n+\t\t\t\t     \"probability is too low.\\n\");\n+\t\t\t}\n+\t\t      else if (!e->maybe_hot_p ())\n+\t\t\t{\n+\t\t\t  nuseless++;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"Not speculating: call is cold.\\n\");\n+\t\t\t}\n+\t\t      else if (n2->get_availability () <= AVAIL_INTERPOSABLE\n+\t\t\t       && n2->can_be_discarded_p ())\n+\t\t\t{\n+\t\t\t  nuseless++;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"Not speculating: target is overwritable \"\n+\t\t\t\t     \"and can be discarded.\\n\");\n+\t\t\t}\n+\t\t      else if (!check_argument_count (n2, e))\n+\t\t\t{\n+\t\t\t  nmismatch++;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"Not speculating: \"\n+\t\t\t\t     \"parameter count mismatch\\n\");\n+\t\t\t}\n+\t\t      else if (e->indirect_info->polymorphic\n+\t\t\t       && !opt_for_fn (n->decl, flag_devirtualize)\n+\t\t\t       && !possible_polymorphic_call_target_p (e, n2))\n+\t\t\t{\n+\t\t\t  nimpossible++;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"Not speculating: \"\n+\t\t\t\t     \"function is not in the polymorphic \"\n+\t\t\t\t     \"call target list\\n\");\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* Target may be overwritable, but profile says that\n+\t\t\t     control flow goes to this particular implementation\n+\t\t\t     of N2.  Speculate on the local alias to allow\n+\t\t\t     inlining.  */\n+\t\t\t  if (!n2->can_be_discarded_p ())\n+\t\t\t    {\n+\t\t\t      cgraph_node *alias;\n+\t\t\t      alias = dyn_cast<cgraph_node *>\n+\t\t\t\t   (n2->noninterposable_alias ());\n+\t\t\t      if (alias)\n+\t\t\t\tn2 = alias;\n+\t\t\t    }\n+\t\t\t  nconverted++;\n+\t\t\t  e->make_speculative (n2,\n+\t\t\t\t\t       e->count.apply_probability (\n+\t\t\t\t\t\t item.target_probability),\n+\t\t\t\t\t       speculative_id,\n+\t\t\t\t\t       item.target_probability);\n+\t\t\t  update = true;\n+\t\t\t  speculative_id++;\n+\t\t\t}\n \t\t    }\n-\t\t  else if (e->indirect_info->polymorphic\n-\t\t\t   && !opt_for_fn (n->decl, flag_devirtualize)\n-\t\t\t   && !possible_polymorphic_call_target_p (e, n2))\n+\t\t  else\n \t\t    {\n-\t\t      nimpossible++;\n \t\t      if (dump_file)\n \t\t\tfprintf (dump_file,\n-\t\t\t\t \"Not speculating: \"\n-\t\t\t\t \"function is not in the polymorphic \"\n-\t\t\t\t \"call target list\\n\");\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Target may be overwritable, but profile says that\n-\t\t\t control flow goes to this particular implementation\n-\t\t\t of N2.  Speculate on the local alias to allow inlining.\n-\t\t       */\n-\t\t      if (!n2->can_be_discarded_p ())\n-\t\t\t{\n-\t\t\t  cgraph_node *alias;\n-\t\t\t  alias = dyn_cast<cgraph_node *> (n2->noninterposable_alias ());\n-\t\t\t  if (alias)\n-\t\t\t    n2 = alias;\n-\t\t\t}\n-\t\t      nconverted++;\n-\t\t      e->make_speculative (n2,\n-\t\t\t\t\t   e->count.apply_probability (\n-\t\t\t\t\t     item.target_probability),\n-\t\t\t\t\t   speculative_id,\n-\t\t\t\t\t   item.target_probability);\n-\t\t      update = true;\n-\t\t      speculative_id++;\n-\t\t      speculative_found = true;\n+\t\t\t\t \"Function with profile-id %i not found.\\n\",\n+\t\t\t\t item.target_id);\n+\t\t      nunknown++;\n \t\t    }\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n-\t\t\t     item.target_id);\n-\t\t  nunknown++;\n-\t\t}\n-\t       }\n-\t     if (speculative_found)\n-\t       e->indirect_info->num_speculative_call_targets = speculative_id;\n \t    }\n-\t }\n-       if (update)\n-\t ipa_update_overall_fn_summary (n);\n-     }\n+\t}\n+      if (update)\n+\tipa_update_overall_fn_summary (n);\n+    }\n   if (node_map_initialized)\n     del_node_map ();\n   if (dump_file && nindirect)"}]}