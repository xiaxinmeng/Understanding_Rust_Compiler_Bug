{"sha": "d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRjZmQ0ODZlYmUzZmFkYjdhNjdjNTNjMjQ4NDM3NzBhMWQ4YmE3Mg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-02-27T22:28:21Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-02-27T22:28:21Z"}, "message": "PR c++/83871 - wrong code for attribute const and pure on distinct template specializations\n\nPR c++/83871 - wrong code for attribute const and pure on distinct template specializations\nPR c++/83503 - [8 Regression] bogus -Wattributes for const and pure on function template specialization\n\ngcc/ChangeLog:\n\n\tPR c++/83871\n\t* gcc/doc/invoke.texi (-Wmissing-attributes): New option.\n\t* gcc/print-tree.c (print_node): Handle DECL_UNINLINABLE.\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/83871\n\t* c.opt (-Wmissing-attributes): New option.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/83871\n\tPR c++/83503\n\t* cp-tree.h (warn_spec_missing_attributes): New function.\n\t((check_explicit_specialization): Add an argument.  Call the above\n\tfunction.\n\t* decl.c (duplicate_decls): Avoid applying primary function template's\n\tattributes to its explicit specializations.\n\tcp/pt.c (warn_spec_missing_attributes): Define.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/83871\n\tPR c++/83503\n\t* g++.dg/Wmissing-attributes.C: New test.\n\t* g++.dg/ext/attr-const-pure.C: New test.\n\t* g++.dg/ext/attr-const.C: New test.\n\t* g++.dg/ext/attr-deprecated-2.C: New test.\n\t* g++.dg/ext/attr-malloc-2.C: New test.\n\t* g++.dg/ext/attr-malloc.C: New test.\n\t* g++.dg/ext/attr-noinline-2.C: New test.\n\t* g++.dg/ext/attr-noinline.C: New test.\n\t* g++.dg/ext/attr-nonnull.C: New test.\n\t* g++.dg/ext/attr-noreturn-2.C: New test.\n\t* g++.dg/ext/attr-noreturn.C: New test.\n\t* g++.dg/ext/attr-nothrow-2.C: New test.\n\t* g++.dg/ext/attr-nothrow.C: New test.\n\t* g++.dg/ext/attr-optimize.C: New test.\n\t* g++.dg/ext/attr-pure.C: New test.\n\t* g++.dg/ext/attr-returns-nonnull.C: New test.\n\t* g++.dg/ext/attr-warning.C: New test.\n\nFrom-SVN: r258045", "tree": {"sha": "62d47ef8a95d209046feec191ee55fbe477706c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d47ef8a95d209046feec191ee55fbe477706c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c89478aef3ef9576f40013c3969179b3189ee95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c89478aef3ef9576f40013c3969179b3189ee95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c89478aef3ef9576f40013c3969179b3189ee95"}], "stats": {"total": 1442, "additions": 1404, "deletions": 38}, "files": [{"sha": "f99e782d8aee0a658651ec1dd3e15a8ca8f6015a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -1,3 +1,9 @@\n+2018-02-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83871\n+\t* gcc/doc/invoke.texi (-Wmissing-attributes): New option.\n+\t* gcc/print-tree.c (print_node): Handle DECL_UNINLINABLE.\n+\n 2018-02-27  Martin Sebor  <msebor@redhat.com>\n \n \tPR translation/84207"}, {"sha": "240cc7bccdaa55bcfb88ccafad22a5a8ef66803e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -1,3 +1,8 @@\n+2018-02-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83871\n+\t* c.opt (-Wmissing-attributes): New option.\n+\n 2018-02-21  Martin Liska  <mliska@suse.cz>\n \n \t* c.opt (Wcatch-value=): Add IntegerRange."}, {"sha": "a4c8c8ffcb37e2bc5d96a90c1c746976cb7d10c8", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -781,6 +781,11 @@ Wtemplates\n C++ ObjC++ Var(warn_templates) Warning\n Warn on primary template declaration.\n \n+Wmissing-attributes\n+C ObjC C++ ObjC++ Var(warn_missing_attributes) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn about declarations of entities that may be missing attributes\n+that related entities have been declared with it.\n+\n Wmissing-format-attribute\n C ObjC C++ ObjC++ Warning Alias(Wsuggest-attribute=format)\n ;"}, {"sha": "9b4dd033be4ee01e99910b999004fcb2430cd943", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -1,3 +1,14 @@\n+2018-02-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83871\n+\tPR c++/83503\n+\t* cp-tree.h (warn_spec_missing_attributes): New function.\n+\t((check_explicit_specialization): Add an argument.  Call the above\n+\tfunction.\n+\t* decl.c (duplicate_decls): Avoid applying primary function template's\n+\tattributes to its explicit specializations.\n+\tcp/pt.c (warn_spec_missing_attributes): Define.\n+\n 2018-02-27  H\u00e5kon Sandsmark  <hsandsmark@gmail.com>\n \n \tPR c++/71546 - lambda init-capture with qualified-id."}, {"sha": "743dd340245dba043b36f72b1dcb4bc58923e6cd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -6463,7 +6463,8 @@ extern void end_specialization\t\t\t(void);\n extern void begin_explicit_instantiation\t(void);\n extern void end_explicit_instantiation\t\t(void);\n extern void check_unqualified_spec_or_inst\t(tree, location_t);\n-extern tree check_explicit_specialization\t(tree, tree, int, int);\n+extern tree check_explicit_specialization\t(tree, tree, int, int,\n+\t\t\t\t\t\t tree = NULL_TREE);\n extern int num_template_headers_for_class\t(tree);\n extern void check_template_variable\t\t(tree);\n extern tree make_auto\t\t\t\t(void);"}, {"sha": "6af774fc0fd267f373d611a43890cd9c5042a7c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 74, "deletions": 31, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -1405,9 +1405,18 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t       \" literal operator template %qD\", newdecl, olddecl);\n     }\n \n+  /* True to merge attributes between the declarations, false to\n+     set OLDDECL's attributes to those of NEWDECL (for template\n+     explicit specializations that specify their own attributes\n+     independent of those specified for the primary template).  */\n+  const bool merge_attr = (TREE_CODE (newdecl) != FUNCTION_DECL\n+\t\t\t   || !DECL_TEMPLATE_SPECIALIZATION (newdecl)\n+\t\t\t   || DECL_TEMPLATE_SPECIALIZATION (olddecl));\n+\n   if (DECL_P (olddecl)\n       && TREE_CODE (newdecl) == FUNCTION_DECL\n       && TREE_CODE (olddecl) == FUNCTION_DECL\n+      && merge_attr\n       && diagnose_mismatched_attributes (olddecl, newdecl))\n     {\n       if (DECL_INITIAL (olddecl))\n@@ -1969,10 +1978,13 @@ next_arg:;\n       DECL_ORIGINAL_TYPE (newdecl) = DECL_ORIGINAL_TYPE (olddecl);\n     }\n \n-  /* Copy all the DECL_... slots specified in the new decl\n-     except for any that we copy here from the old type.  */\n-  DECL_ATTRIBUTES (newdecl)\n-    = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n+  /* Copy all the DECL_... slots specified in the new decl except for\n+     any that we copy here from the old type.  */\n+  if (merge_attr)\n+    DECL_ATTRIBUTES (newdecl)\n+      = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n+  else\n+    DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);\n \n   if (DECL_DECLARES_FUNCTION_P (olddecl) && DECL_DECLARES_FUNCTION_P (newdecl))\n     {\n@@ -2099,9 +2111,10 @@ next_arg:;\n \t\t  }\n \t    }\n \t}\n-      else\n-\t/* Merge the data types specified in the two decls.  */\n+      else if (merge_attr)\n \tnewtype = merge_types (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n+      else\n+\tnewtype = TREE_TYPE (newdecl);\n \n       if (VAR_P (newdecl))\n \t{\n@@ -2165,14 +2178,6 @@ next_arg:;\n \t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_decl (newdecl, 0);\n \n-      /* Merge the type qualifiers.  */\n-      if (TREE_READONLY (newdecl))\n-\tTREE_READONLY (olddecl) = 1;\n-      if (TREE_THIS_VOLATILE (newdecl))\n-\tTREE_THIS_VOLATILE (olddecl) = 1;\n-      if (TREE_NOTHROW (newdecl))\n-\tTREE_NOTHROW (olddecl) = 1;\n-\n       /* Merge deprecatedness.  */\n       if (TREE_DEPRECATED (newdecl))\n \tTREE_DEPRECATED (olddecl) = 1;\n@@ -2190,6 +2195,15 @@ next_arg:;\n \t    DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl)\n \t      = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl);\n \t}\n+      else\n+\t{\n+\t  /* Merge the const type qualifier.  */\n+\t  if (TREE_READONLY (newdecl))\n+\t    TREE_READONLY (olddecl) = 1;\n+\t  /* Merge the volatile type qualifier.  */\n+\t  if (TREE_THIS_VOLATILE (newdecl))\n+\t    TREE_THIS_VOLATILE (olddecl) = 1;\n+\t}\n \n       /* Merge the initialization information.  */\n       if (DECL_INITIAL (newdecl) == NULL_TREE\n@@ -2209,14 +2223,29 @@ next_arg:;\n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n \t  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n-\t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-\t  TREE_NOTHROW (newdecl) |= TREE_NOTHROW (olddecl);\n-\t  DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n \t  DECL_IS_OPERATOR_NEW (newdecl) |= DECL_IS_OPERATOR_NEW (olddecl);\n-\t  DECL_PURE_P (newdecl) |= DECL_PURE_P (olddecl);\n-\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n-\t  DECL_LOOPING_CONST_OR_PURE_P (newdecl) \n+\t  DECL_LOOPING_CONST_OR_PURE_P (newdecl)\n \t    |= DECL_LOOPING_CONST_OR_PURE_P (olddecl);\n+\n+\t  if (merge_attr)\n+\t    {\n+\t      TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+\t      TREE_THIS_VOLATILE (olddecl) |= TREE_THIS_VOLATILE (newdecl);\n+\t      TREE_NOTHROW (newdecl) |= TREE_NOTHROW (olddecl);\n+\t      TREE_NOTHROW (olddecl) |= TREE_NOTHROW (newdecl);\n+\t      TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+\t      DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n+\t      DECL_PURE_P (newdecl) |= DECL_PURE_P (olddecl);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Merge the noreturn bit.  */\n+\t      TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);\n+\t      TREE_READONLY (olddecl) = TREE_READONLY (newdecl);\n+\t      TREE_NOTHROW (olddecl) = TREE_NOTHROW (newdecl);\n+\t      DECL_IS_MALLOC (olddecl) = DECL_IS_MALLOC (newdecl);\n+\t      DECL_PURE_P (olddecl) = DECL_PURE_P (newdecl);\n+\t    }\n \t  /* Keep the old RTL.  */\n \t  COPY_DECL_RTL (olddecl, newdecl);\n \t}\n@@ -2381,17 +2410,30 @@ next_arg:;\n \t  /* [temp.expl.spec/14] We don't inline explicit specialization\n \t     just because the primary template says so.  */\n \n-\t  /* But still keep DECL_DISREGARD_INLINE_LIMITS in sync with\n-\t     the always_inline attribute.  */\n-\t  if (DECL_DISREGARD_INLINE_LIMITS (olddecl)\n-\t      && !DECL_DISREGARD_INLINE_LIMITS (newdecl))\n+\t  if (merge_attr)\n \t    {\n-\t      if (DECL_DECLARED_INLINE_P (newdecl))\n-\t\tDECL_DISREGARD_INLINE_LIMITS (newdecl) = true;\n-\t      else\n-\t\tDECL_ATTRIBUTES (newdecl)\n-\t\t  = remove_attribute (\"always_inline\",\n-\t\t\t\t      DECL_ATTRIBUTES (newdecl));\n+\t      /* But still keep DECL_DISREGARD_INLINE_LIMITS in sync with\n+\t\t the always_inline attribute.  */\n+\t      if (DECL_DISREGARD_INLINE_LIMITS (olddecl)\n+\t\t  && !DECL_DISREGARD_INLINE_LIMITS (newdecl))\n+\t\t{\n+\t\t  if (DECL_DECLARED_INLINE_P (newdecl))\n+\t\t    DECL_DISREGARD_INLINE_LIMITS (newdecl) = true;\n+\t\t  else\n+\t\t    DECL_ATTRIBUTES (newdecl)\n+\t\t      = remove_attribute (\"always_inline\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (newdecl));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_DECLARED_INLINE_P (olddecl)\n+\t\t= DECL_DECLARED_INLINE_P (newdecl);\n+\n+\t      DECL_DISREGARD_INLINE_LIMITS (olddecl)\n+\t\t= DECL_DISREGARD_INLINE_LIMITS (newdecl);\n+\n+\t      DECL_UNINLINABLE (olddecl) = DECL_UNINLINABLE (newdecl);\n \t    }\n \t}\n       else if (new_defines_function && DECL_INITIAL (olddecl))\n@@ -8917,7 +8959,8 @@ grokfndecl (tree ctype,\n \t\t\t\t\ttemplate_count,\n \t\t\t\t\t2 * funcdef_flag +\n \t\t\t\t\t4 * (friendp != 0) +\n-                                        8 * concept_p);\n+\t                                8 * concept_p,\n+\t\t\t\t\t*attrlist);\n   if (decl == error_mark_node)\n     return NULL_TREE;\n "}, {"sha": "ae777db82fe1aac3d1d432650ae7fbbe9463a726", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 118, "deletions": 5, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n      all methods must be provided in header files; can't use a source\n      file that contains only the method templates and \"just win\".  */\n \n+#include <string>\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -1473,8 +1474,10 @@ is_specialization_of_friend (tree decl, tree friend_decl)\n \n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  IS_FRIEND indicates whether the specialization\n-   is actually just a friend declaration.  Returns SPEC, or an\n-   equivalent prior declaration, if available.\n+   is actually just a friend declaration.  ATTRLIST is the list of\n+   attributes that the specialization is declared with or NULL when\n+   it isn't.  Returns SPEC, or an equivalent prior declaration, if\n+   available.\n \n    We also store instantiations of field packs in the hash table, even\n    though they are not themselves templates, to make lookup easier.  */\n@@ -2615,6 +2618,110 @@ check_unqualified_spec_or_inst (tree t, location_t loc)\n     }\n }\n \n+/* Warn for a template specialization SPEC that is missing some of a set\n+   of function or type attributes that the template TEMPL is declared with.\n+   ATTRLIST is a list of additional attributes that SPEC should be taken\n+   to ultimately be declared with.  */\n+\n+static void\n+warn_spec_missing_attributes (tree tmpl, tree spec, tree attrlist)\n+{\n+  if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n+    tmpl = DECL_TEMPLATE_RESULT (tmpl);\n+\n+  if (TREE_CODE (tmpl) != FUNCTION_DECL)\n+    return;\n+\n+  /* Avoid warning if either declaration or its type is deprecated.  */\n+  if (TREE_DEPRECATED (tmpl)\n+      || TREE_DEPRECATED (spec))\n+    return;\n+\n+  tree tmpl_type = TREE_TYPE (tmpl);\n+  tree spec_type = TREE_TYPE (spec);\n+\n+  if (TREE_DEPRECATED (tmpl_type)\n+      || TREE_DEPRECATED (spec_type)\n+      || TREE_DEPRECATED (TREE_TYPE (tmpl_type))\n+      || TREE_DEPRECATED (TREE_TYPE (spec_type)))\n+    return;\n+\n+  tree tmpl_attrs[] = { DECL_ATTRIBUTES (tmpl), TYPE_ATTRIBUTES (tmpl_type) };\n+  tree spec_attrs[] = { DECL_ATTRIBUTES (spec), TYPE_ATTRIBUTES (spec_type) };\n+\n+  if (!spec_attrs[0])\n+    spec_attrs[0] = attrlist;\n+  else if (!spec_attrs[1])\n+    spec_attrs[1] = attrlist;\n+\n+  /* Avoid warning if the primary has no attributes.  */\n+  if (!tmpl_attrs[0] && !tmpl_attrs[1])\n+    return;\n+\n+  /* Avoid warning if either declaration contains an attribute on\n+     the white list below.  */\n+  const char* const whitelist[] = {\n+    \"error\", \"warning\"\n+  };\n+\n+  for (unsigned i = 0; i != 2; ++i)\n+    for (unsigned j = 0; j != sizeof whitelist / sizeof *whitelist; ++j)\n+      if (lookup_attribute (whitelist[j], tmpl_attrs[i])\n+\t  || lookup_attribute (whitelist[j], spec_attrs[i]))\n+\treturn;\n+\n+  /* Avoid warning if the difference between the primary and\n+     the specialization is not in one of the attributes below.  */\n+  const char* const blacklist[] = {\n+    \"alloc_align\", \"alloc_size\", \"assume_aligned\", \"format\",\n+    \"format_arg\", \"malloc\", \"nonnull\"\n+  };\n+\n+  /* Put together a list of the black listed attributes that the primary\n+     template is declared with that the specialization is not, in case\n+     it's not apparent from the most recent declaration of the primary.  */\n+  unsigned nattrs = 0;\n+  std::string str;\n+\n+  for (unsigned i = 0; i != sizeof blacklist / sizeof *blacklist; ++i)\n+    {\n+      for (unsigned j = 0; j != 2; ++j)\n+\t{\n+\t  if (!lookup_attribute (blacklist[i], tmpl_attrs[j]))\n+\t    continue;\n+\n+\t  for (unsigned k = 0; k != 1 + !!spec_attrs[1]; ++k)\n+\t    {\n+\t      if (lookup_attribute (blacklist[i], spec_attrs[k]))\n+\t\tbreak;\n+\n+\t      if (str.size ())\n+\t\tstr += \", \";\n+\t      str += \"%<\";\n+\t      str += blacklist[i];\n+\t      str += \"%>\";\n+\t      ++nattrs;\n+\t    }\n+\t}\n+    }\n+\n+  if (!nattrs)\n+    return;\n+\n+  if (warning_at (DECL_SOURCE_LOCATION (spec), OPT_Wmissing_attributes,\n+\t\t  \"explicit specialization %q#D may be missing attributes\",\n+\t\t  spec))\n+    {\n+      if (nattrs > 1)\n+\tstr = G_(\"missing primary template attributes \") + str;\n+      else\n+\tstr = G_(\"missing primary template attribute \") + str;\n+\n+      inform (DECL_SOURCE_LOCATION (tmpl), str.c_str ());\n+    }\n+\n+}\n+\n /* Check to see if the function just declared, as indicated in\n    DECLARATOR, and in DECL, is a specialization of a function\n    template.  We may also discover that the declaration is an explicit\n@@ -2656,7 +2763,8 @@ tree\n check_explicit_specialization (tree declarator,\n \t\t\t       tree decl,\n \t\t\t       int template_count,\n-\t\t\t       int flags)\n+\t\t\t       int flags,\n+\t\t\t       tree attrlist)\n {\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n@@ -3113,8 +3221,13 @@ check_explicit_specialization (tree declarator,\n \t     it again.  Partial specializations will be registered in\n \t     process_partial_specialization.  */\n \t  if (!processing_template_decl)\n-\t    decl = register_specialization (decl, gen_tmpl, targs,\n-\t\t\t\t\t    is_friend, 0);\n+\t    {\n+\t      warn_spec_missing_attributes (gen_tmpl, decl, attrlist);\n+\n+\t      decl = register_specialization (decl, gen_tmpl, targs,\n+\t\t\t\t\t      is_friend, 0);\n+\t    }\n+\n \n \t  /* A 'structor should already have clones.  */\n \t  gcc_assert (decl == error_mark_node"}, {"sha": "8d366c626bae92caa57b9417bb665bb25f3fb3d2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -295,7 +295,7 @@ Objective-C and Objective-C++ Dialects}.\n -Winvalid-pch  -Wlarger-than=@var{len} @gol\n -Wlogical-op  -Wlogical-not-parentheses  -Wlong-long @gol\n -Wmain  -Wmaybe-uninitialized  -Wmemset-elt-size  -Wmemset-transposed-args @gol\n--Wmisleading-indentation  -Wmissing-braces @gol\n+-Wmisleading-indentation  -Wmissing-attributes -Wmissing-braces @gol\n -Wmissing-field-initializers  -Wmissing-include-dirs @gol\n -Wno-multichar  -Wmultistatement-macros  -Wnonnull  -Wnonnull-compare @gol\n -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} @gol\n@@ -3928,6 +3928,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wmemset-elt-size @gol\n -Wmemset-transposed-args @gol\n -Wmisleading-indentation @r{(only for C/C++)} @gol\n+-Wmissing-attributes @gol\n -Wmissing-braces @r{(only for C/ObjC)} @gol\n -Wmultistatement-macros  @gol\n -Wnarrowing @r{(only for C++)}  @gol\n@@ -4591,6 +4592,36 @@ about the layout of the file that the directive references.\n \n This warning is enabled by @option{-Wall} in C and C++.\n \n+@item -Wmissing-attributes\n+@opindex Wmissing-attributes\n+@opindex Wno-missing-attributes\n+Warn when a declaration of a function is missing one or more attributes\n+that a related function is declared with and whose absence may adversely\n+affect the correctness or efficiency of generated code.  For example, in\n+C++, the warning is issued when an explicit specialization of a primary\n+template declared with attribute @code{alloc_align}, @code{alloc_size},\n+@code{assume_aligned}, @code{format}, @code{format_arg}, @code{malloc},\n+or @code{nonnull} is declared without it.  Attributes @code{deprecated},\n+@code{error}, and @code{warning} suppress the warning.\n+(@pxref{Function Attributes}).\n+\n+@option{-Wmissing-attributes} is enabled by @option{-Wall}.\n+\n+For example, since the declaration of the primary function template\n+below makes use of both attribute @code{malloc} and @code{alloc_size}\n+the declaration of the explicit specialization of the template is\n+diagnosed because it is missing one of the attributes.\n+\n+@smallexample\n+template <class T>\n+T* __attribute__ ((malloc, alloc_size (1)))\n+allocate (size_t);\n+\n+template <>\n+void* __attribute__ ((malloc))   // missing alloc_size\n+allocate<void> (size_t);\n+@end smallexample\n+\n @item -Wmissing-braces\n @opindex Wmissing-braces\n @opindex Wno-missing-braces"}, {"sha": "caf5f2601475cdbf653fa2f129a9fec8c5e1c0e5", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -377,6 +377,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n \tfputs (\" function-specific-opt\", file);\n       if (code == FUNCTION_DECL && DECL_DECLARED_INLINE_P (node))\n \tfputs (\" autoinline\", file);\n+      if (code == FUNCTION_DECL && DECL_UNINLINABLE (node))\n+\tfputs (\" uninlinable\", file);\n       if (code == FUNCTION_DECL && DECL_BUILT_IN (node))\n \tfputs (\" built-in\", file);\n       if (code == FUNCTION_DECL && DECL_STATIC_CHAIN (node))"}, {"sha": "b957cb7f52f668fb2860b17f1d93b968ab32cf83", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -1,3 +1,25 @@\n+2018-02-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83871\n+\tPR c++/83503\n+\t* g++.dg/Wmissing-attributes.C: New test.\n+\t* g++.dg/ext/attr-const-pure.C: New test.\n+\t* g++.dg/ext/attr-const.C: New test.\n+\t* g++.dg/ext/attr-deprecated-2.C: New test.\n+\t* g++.dg/ext/attr-malloc-2.C: New test.\n+\t* g++.dg/ext/attr-malloc.C: New test.\n+\t* g++.dg/ext/attr-noinline-2.C: New test.\n+\t* g++.dg/ext/attr-noinline.C: New test.\n+\t* g++.dg/ext/attr-nonnull.C: New test.\n+\t* g++.dg/ext/attr-noreturn-2.C: New test.\n+\t* g++.dg/ext/attr-noreturn.C: New test.\n+\t* g++.dg/ext/attr-nothrow-2.C: New test.\n+\t* g++.dg/ext/attr-nothrow.C: New test.\n+\t* g++.dg/ext/attr-optimize.C: New test.\n+\t* g++.dg/ext/attr-pure.C: New test.\n+\t* g++.dg/ext/attr-returns-nonnull.C: New test.\n+\t* g++.dg/ext/attr-warning.C: New test.\n+\n 2018-02-27  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/84426"}, {"sha": "f4ebce1498d955a28a014702578228f86008dc16", "filename": "gcc/testsuite/g++.dg/Wmissing-attributes.C", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWmissing-attributes.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWmissing-attributes.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWmissing-attributes.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,102 @@\n+// PR c++/83871 - wrong code for attribute const and pure on distinct\n+// template specializations\n+// Test to verify that a declaration of an explicit specialization with\n+// no attributes is diagnosed when the primary template is declared with\n+// one or more attributes.  The warning helps highlight a change in GCC\n+// 8 from previous versions that copied the attributes from the primary\n+// to the specialization.  It also helps point out simply forgetting to\n+// declare the specialization with an attribute.\n+// { dg-do compile }\n+// { dg-options \"-Wmissing-attributes\" }\n+\n+#define ATTR(list)   __attribute__ (list)\n+\n+\n+// Verify that a primary without attributes doesn't cause warnings.\n+template <class T> void fnoattr ();\n+\n+template <> void fnoattr<void>();\n+template <> void ATTR ((cold)) fnoattr<int>();\n+template <> void ATTR ((hot)) fnoattr<double>();\n+\n+// Verify that a noreturn primary also doesn't cause warnings.\n+template <class T> int ATTR ((noreturn)) fnoreturn ();\n+\n+template <> int fnoreturn<void>();\n+template <> int ATTR ((cold)) fnoreturn<int>();\n+template <> int ATTR ((hot)) fnoreturn<double>();\n+\n+\n+template <class T>\n+void*\n+ATTR ((malloc, alloc_size (1)))\n+missing_all (int);            // { dg-message \"missing primary template attributes \\(.malloc., .alloc_size.|.alloc_size., .malloc.\\)\" }\n+\n+template <>\n+void*\n+missing_all<char>(int);       // { dg-warning \"explicit specialization .\\[^\\n\\r\\]+. may be missing attributes\" }\n+\n+// Verify that specifying the same attributes in whatever order\n+// doesn't trigger the warning, even when other attributes are\n+// added.\n+template <>\n+void*\n+ATTR ((alloc_size (1), malloc))\n+missing_all<char>(int);\n+\n+template <>\n+void*\n+ATTR ((alloc_size (1))) ATTR ((malloc)) ATTR ((returns_nonnull))\n+missing_all<char>(int);   // T = char, same as above\n+\n+template <>\n+void*\n+ATTR ((hot)) ATTR ((alloc_size (1))) ATTR ((malloc))\n+missing_all<char>(int);   // T = char, same as above\n+\n+// Verify that the following attributes suppress the warning.\n+template <> void* ATTR ((error (\"\"))) missing_all<short>(int);\n+template <> void* ATTR ((deprecated)) missing_all<int>(int);\n+template <> void* ATTR ((warning (\"\"))) missing_all<double>(int);\n+\n+\n+template <class T>\n+void*\n+ATTR ((malloc, alloc_size (1)))\n+missing_malloc (int);             // { dg-message \"missing primary template attribute .malloc.\" }\n+\n+template <>\n+void*\n+ATTR ((alloc_size (1)))\n+missing_malloc<char>(int);            // { dg-warning \"explicit specialization .\\[^\\n\\r\\]+. may be missing attributes\" }\n+\n+template <> void* ATTR ((malloc, alloc_size (1))) missing_malloc<short>(int);\n+template <> void* ATTR ((deprecated)) missing_malloc<int>(int);\n+template <> void* ATTR ((error (\"\"))) missing_malloc<long>(int);\n+template <> void* ATTR ((warning (\"\"))) missing_malloc<double>(int);\n+\n+template <class T>\n+void*\n+ATTR ((malloc, alloc_size (1)))\n+missing_alloc_size (int, int);        // { dg-message \"missing primary template attribute .alloc_size.\" }\n+\n+template <>\n+void*\n+ATTR ((malloc))\n+missing_alloc_size<char>(int, int);   // { dg-warning \"explicit specialization .\\[^\\n\\r\\]+. may be missing attributes\" }\n+\n+\n+template <class T>\n+void*\n+ATTR ((nonnull (1)))\n+missing_nonnull (void*);              // { dg-message \"missing primary template attribute .nonnull.\" }\n+\n+template <>\n+void*\n+ATTR ((malloc))\n+missing_nonnull<char>(void*);         // { dg-warning \"explicit specialization .\\[^\\n\\r\\]+. may be missing attributes\" }\n+\n+template <> void* ATTR ((nonnull (1))) missing_nonnull<short>(void*);\n+template <> void* ATTR ((deprecated)) missing_nonnull<int>(void*);\n+template <> void* ATTR ((error (\"\"))) missing_nonnull<long>(void*);\n+template <> void* ATTR ((warning (\"\"))) missing_nonnull<double>(void*);"}, {"sha": "f7c6f3b674cc9e587c60d61f34dfbd7867aed4ce", "filename": "gcc/testsuite/g++.dg/ext/attr-const-pure.C", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const-pure.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const-pure.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const-pure.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,144 @@\n+// Bug c++/83503 - bogus -Wattributes for const and pure on function template\n+// specialization\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+int global;\n+\n+template <class T>\n+int __attribute__ ((pure))\n+f (T);\n+\n+template <>\n+int __attribute__ ((const)) f<int> (int);   // { dg-bogus \"ignoring attribute .const.\" }\n+\n+void f_pure_primary_elim ();\n+void f_pure_primary_keep ();\n+void f_const_spec_elim ();\n+\n+void call_pure_primary_elim (double x)\n+{\n+  // Only the first call to f(x) must be emitted, the second one\n+  // is expected to be eliminated because the primary template\n+  // is pure.\n+  int i0 = f (x);\n+  int i1 = f (x);\n+  if (i0 != i1)\n+    f_pure_primary_elim ();\n+}\n+\n+void call_pure_primary_keep (const char *s)\n+{\n+  // Both calls to f(x) must be emitted because the primary is\n+  // pure and may read global.\n+  int i0 = f (s);\n+  global = 123;\n+  int i1 = f (s);\n+  if (i0 != i1)\n+    f_pure_primary_keep ();\n+}\n+\n+void call_const_spec_elim (int i)\n+{\n+  // Only the first call to f(x) must be emitted, the second\n+  // one is expected to be eliminated again, this time because\n+  // unlike the pure primary, the specialization is const.\n+  int i0 = f (i);\n+  global = 123;\n+  int i1 = f (i);\n+  if (i0 != i1)\n+    f_const_spec_elim ();\n+}\n+\n+template <class T>\n+int __attribute__ ((const))\n+g (T);\n+\n+template <>\n+int __attribute__ ((pure)) g<int> (int);   // { dg-bogus \"ignoring attribute .const.\" }\n+\n+template <class T>\n+int __attribute__ ((const))\n+h (T);\n+\n+template <class T>\n+int __attribute__ ((pure))\n+h (const T*);\n+\n+template <>\n+int h<int> (int);\n+\n+template <>\n+int h<int*> (int*);\n+\n+extern void h_const_primary_elim ();\n+extern void h_pure_cstptr_elim ();\n+extern void h_cstptr_keep ();\n+extern void h_int_keep ();\n+extern void h_intptr_keep ();\n+\n+void call_const_primary_elim (double x)\n+{\n+  // Only the first call to h(x) must be emitted, the second one\n+  // is expected to be eliminated.\n+  int i0 = h (x);\n+  int i1 = h (x);\n+\n+  if (i0 != i1)                   // must be folded into false\n+    h_const_primary_elim ();        // must be eliminated\n+}\n+\n+void call_pure_cstptr_elim (const void *p)\n+{\n+  // Only the first call to h(x) must be emitted, the second one\n+  // is expected to be eliminated.  This verifies that h<const\n+  // void*>*() is treated as const in this context.\n+  int i0 = h (p);\n+  int i1 = h (p);\n+\n+  if (i0 != i1)                   // must be folded into false\n+    h_pure_cstptr_elim ();          // must be eliminated\n+}\n+\n+void call_cstptr_keep (const void *p)\n+{\n+  // Because of the store to the global, both calls to h(p) must\n+  // be emitted.  This verifies that h<const void*>*() is not\n+  // treated as const.\n+  int i0 = h (p);\n+  global = 123;\n+  int i1 = h (p);\n+\n+  if (i0 != i1)                   // must not be folded\n+    h_cstptr_keep ();             // must be emitted\n+}\n+\n+void call_int_keep (int i)\n+{\n+  // Both calls to h(i) must be emitted.\n+  int i0 = h (i);\n+  int i1 = h (i);\n+\n+  if (i0 != i1)                   // must not be folded\n+    h_int_keep ();                // must be emitted\n+}\n+\n+void call_intptr_keep (int *ip)\n+{\n+  // Both calls to h(ip) must be emitted.\n+  int i0 = h (ip);\n+  int i1 = h (ip);\n+\n+  if (i0 != i1)                   // must not be folded\n+    h_intptr_keep ();             // must be emitted\n+}\n+\n+// { dg-final { scan-tree-dump-not \"f_pure_primary_elim\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-not \"f_const_primary_elim\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-not \"f_const_spec_elim\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-not \"h_pure_cstptr_elim\" \"optimized\" } }\n+\n+// { dg-final { scan-tree-dump-times \"f_pure_primary_keep\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"h_cstptr_keep\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"h_int_keep\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"h_intptr_keep\" 1 \"optimized\" } }"}, {"sha": "a9884db765faa7a5651e351dc7576a2123fedee9", "filename": "gcc/testsuite/g++.dg/ext/attr-const.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-const.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,69 @@\n+/*  PR c++/83871 - wrong code for attribute const and pure on distinct\n+    template specializations\n+    { dg-do compile }\n+    { dg-options \"-O -Wall\" } */\n+\n+int __attribute__ ((const)) fconst_none ();\n+int fconst_none ();\n+\n+void test_const_none_failed ();\n+\n+void func_const_none ()\n+{\n+  int i0 = fconst_none ();\n+  int i1 = fconst_none ();\n+  if (i0 != i1)\n+    test_const_none_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_const_none_failed\" \"optimized\" } }\n+}\n+\n+\n+int fnone_const ();\n+int __attribute__ ((const)) fnone_const ();\n+\n+void test_none_const_failed ();\n+\n+void func_none_const ()\n+{\n+  int i0 = fnone_const ();\n+  int i1 = fnone_const ();\n+  if (i0 != i1)\n+    test_none_const_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_none_const_failed\" \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+int __attribute__ ((const)) fconst_none (T);\n+\n+template <class T>\n+int fconst_none (T);\n+\n+void template_const_none ()\n+{\n+  int i0 = fconst_none<int> (0);\n+  int i1 = fconst_none<int> (0);\n+  if (i0 != i1)\n+    test_const_none_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_const_none_failed\" \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+int fnone_const (T);\n+\n+template <class T>\n+int __attribute__ ((const)) fnone_const (T);\n+\n+void test_fnone_const ()\n+{\n+  int i0 = fnone_const<int> (0);\n+  int i1 = fnone_const<int> (0);\n+  if (i0 != i1)\n+    test_none_const_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_none_const_failed\" \"optimized\" } }\n+}"}, {"sha": "bf9041506d1fe2403356d4d61c11c94e5889441a", "filename": "gcc/testsuite/g++.dg/ext/attr-deprecated-2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-deprecated-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-deprecated-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-deprecated-2.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,35 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute deprecated from a primary template declared\n+// with it.\n+// { dg-do compile }\n+// { dg-options \"-Wall -fdump-tree-optimized\" }\n+\n+struct Special;\n+\n+template <class T>\n+void fdeprecated_primary ();\n+\n+// The primary isn't deprecated at this point so the declaration\n+// of its specialization should not be diagnosed.\n+template <>\n+void fdeprecated_primary<Special> ();   // { dg-bogus \"deprecated\" }\n+\n+template <class T>\n+void __attribute__ ((deprecated))\n+fdeprecated_primary ();\n+\n+void use_primary ()\n+{\n+  // Verify that uses of the now deprecacted primary are diagnosed.\n+  fdeprecated_primary<void>();          // { dg-warning \"deprecated\" \"bug 84542\" { xfail *-*-* } }\n+  fdeprecated_primary<int>();           // { dg-warning \"deprecated\" \"bug 84542\" { xfail *-*-* } }\n+}\n+\n+void use_special ()\n+{\n+  // Verify that the use of the non-deprecated specializatoin\n+  // is not diagnosed.\n+  fdeprecated_primary<Special>();\n+}"}, {"sha": "600d430468c508992dd1ef4a56cce4a3a5a2ef56", "filename": "gcc/testsuite/g++.dg/ext/attr-malloc-2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc-2.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,49 @@\n+// Bug c++/83503 - bogus -Wattributes for const and pure on function template\n+// specialization\n+// Test to verify that attribute malloc on multiple declarations of\n+// the same ordinary function are merged.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+void* __attribute__ ((malloc))\n+fmalloc_none (unsigned);\n+\n+void*\n+fmalloc_none (unsigned);\n+\n+static char a[8];\n+\n+void fmalloc_none_failed ();\n+\n+void test_fmalloc_none (void)\n+{\n+  void *p = fmalloc_none (1);\n+  if (!p)\n+    return;\n+\n+  if (p == a)                     // must be false\n+    fmalloc_none_failed ();       // should be eliminated\n+\n+  // Verify that the call to fmalloc_none() is eliminated.\n+  // { dg-final { scan-tree-dump-not \"fmalloc_none_failed\" \"optimized\" } }\n+}\n+\n+void* fnone_malloc (unsigned);\n+\n+void* __attribute__ ((malloc))\n+fnone_malloc (unsigned);\n+\n+void fnone_malloc_failed ();\n+\n+void test_fnone_malloc (void)\n+{\n+  void *p = fnone_malloc (1);\n+  if (!p)\n+    return;\n+\n+  if (p == a)                     // must be false\n+    fnone_malloc_failed ();       // should be eliminated\n+\n+  // Verify that the call to fnone_malloc() is eliminated.\n+  // { dg-final { scan-tree-dump-not \"fnone_malloc_failed\" \"optimized\" } }\n+}"}, {"sha": "3cbb41407ea86773a00cc8a7d769df561834b378", "filename": "gcc/testsuite/g++.dg/ext/attr-malloc.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-malloc.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,69 @@\n+// Bug c++/83503 - bogus -Wattributes for const and pure on function template\n+// specialization\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute malloc from a primary template declared with one.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+template <class>\n+void* __attribute__ ((malloc))\n+fmalloc (unsigned);\n+\n+template <>\n+void*\n+fmalloc<int>(unsigned);       // { dg-warning \"may be missing attributes\" }\n+\n+static char a[8];\n+\n+void fmalloc_void_malloc ();\n+void fmalloc_int_not_malloc ();\n+\n+void test_fmalloc_primary (void)\n+{\n+  void *p = fmalloc<void>(1);\n+  if (!p)\n+    return;\n+\n+  if (p == a)                     // must be false\n+    fmalloc_void_malloc ();       // should be eliminated\n+\n+  // Verify that the call to fmalloc_void_malloc() is eliminated.\n+  // { dg-final { scan-tree-dump-not \"fmalloc_void_malloc\" \"optimized\" } }\n+}\n+\n+\n+void test_fmalloc_spec_none (void)\n+{\n+  void *p = fmalloc<int>(1);\n+  if (!p)\n+    return;\n+\n+  if (p == a)                     // can be true\n+    fmalloc_int_not_malloc ();    // must not be eliminated\n+\n+  // Verify that the call to fmalloc_int_not_malloc() is retained.\n+  // { dg-final { scan-tree-dump-times \"fmalloc_int_not_malloc\" 1 \"optimized\" } }\n+}\n+\n+template <>\n+void*\n+fmalloc<long>(unsigned);          // { dg-warning \"may be missing attributes\" }\n+\n+template <>\n+void* __attribute__ ((malloc))\n+fmalloc<long>(unsigned);\n+\n+void fmalloc_long_malloc ();\n+\n+void test_fmalloc_spec_malloc (void)\n+{\n+  void *p = fmalloc<long>(1);\n+  if (!p)\n+    return;\n+\n+  if (p == a)                     // can be true\n+    fmalloc_long_malloc ();       // must not be eliminated\n+\n+  // Verify that the call to fmalloc_long_malloc() is eliminated.\n+  // { dg-final { scan-tree-dump-not \"fmalloc_long_malloc\" \"optimized\" } }\n+}"}, {"sha": "4aab4f16f1ec34967254cfd62edc881270e5c9fa", "filename": "gcc/testsuite/g++.dg/ext/attr-noinline-2.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline-2.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,73 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attributes always_inline or noinline from a primary template\n+// declared with either.  Unlike attr-noinline.C, this test enables\n+// optimization to verify that noinline prevents inlining.\n+// { dg-do compile }\n+// { dg-options \"-O2 -Wall -fdump-tree-optimized\" }\n+\n+enum Special { };\n+\n+int global;\n+\n+template <class T>\n+inline void __attribute__ ((always_inline))\n+falways_inline_noinline ()\n+{\n+  // Create a side-effect that's unique to this function.\n+  global = __LINE__;\n+}\n+\n+template <>\n+void __attribute__ ((noinline))\n+falways_inline_noinline<Special>()\n+{\n+  global = __LINE__;\n+}\n+\n+// Verify that a call to the primary is inlined but one to\n+// the explicit specialization is not.\n+\n+void test_elim_primary_1 (void)\n+{\n+  // Should be inlined.\n+  falways_inline_noinline<void>();\n+// { dg-final { scan-tree-dump-not \"falways_inline_noinline<void> *\\\\(\\\\)\" \"optimized\" } }\n+}\n+\n+void test_keep_special_1 (void)\n+{\n+  // Should not be inlined.\n+  falways_inline_noinline<Special>();\n+// { dg-final { scan-tree-dump-times \"falways_inline_noinline<Special> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+void __attribute__ ((noinline))\n+fnoinline_always_inline ()\n+{\n+  global = __LINE__;\n+}\n+\n+template <>\n+inline void __attribute__ ((always_inline))\n+fnoinline_always_inline<Special>()    // { dg-bogus \"follows declaration\" }\n+{\n+  global = __LINE__;\n+}\n+\n+void test_keep_primary_2 (void)\n+{\n+  // Should not be inlined.\n+  fnoinline_always_inline<void>();\n+// { dg-final { scan-tree-dump-times \"fnoinline_always_inline<void> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+void test_elim_special_2 (void)\n+{\n+  // Should be inlined.\n+  fnoinline_always_inline<Special>();\n+// { dg-final { scan-tree-dump-not \"fnoinline_always_inline<Special> *\\\\(\\\\);\" optimized\" } }\n+}"}, {"sha": "b09037bd1a525630c01da8822c1d87bea8608cce", "filename": "gcc/testsuite/g++.dg/ext/attr-noinline.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noinline.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,128 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attributes always_inline or noinline from a primary template\n+// declared with either.  The test disables optimization to verify that\n+// always_inline forces inlining.\n+// { dg-do compile }\n+// { dg-options \"-O0 -Wall -fdump-tree-optimized\" }\n+\n+enum Special { };\n+\n+template <class T>\n+inline void __attribute__ ((always_inline))\n+falways_inline_none ()\n+{\n+  // Primary template should always be inlined, even without optimization.\n+  asm (\"\");   // induce a no-op \"side-effect\"\n+}\n+\n+template <>\n+inline void\n+falways_inline_none<Special>()\n+{\n+  // The specialization should not be inlined without optimization, even\n+  // though it's declared inline.\n+  asm (\"\");\n+}\n+\n+// Verify that a call to the primary is inlined but one to\n+// the explicit specialization is not.\n+\n+void test_elim_primary_1 (void)\n+{\n+  // Should be inlined.\n+  falways_inline_none<void>();\n+// { dg-final { scan-tree-dump-not \"falways_inline_none<void> *\\\\(\\\\)\" \"optimized\" } }\n+}\n+\n+void test_keep_special_1 (void)\n+{\n+  // Should not be inlined.\n+  falways_inline_none<Special>();\n+// { dg-final { scan-tree-dump-times \"falways_inline_none<Special> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+inline void __attribute__ ((always_inline))\n+falways_inline_noinline ()\n+{\n+  asm (\"\");   // induce a no-op \"side-effect\"\n+}\n+\n+template <>\n+void __attribute__ ((noinline))\n+falways_inline_noinline<Special>() { asm (\"\"); }\n+\n+// Verify that a call to the primary is inlined but one to\n+// the explicit specialization is not.\n+\n+void test_elim_primary_2 (void)\n+{\n+  falways_inline_noinline<void>();\n+// { dg-final { scan-tree-dump-not \"falways_inline_noinline<void> *\\\\(\\\\)\" \"optimized\" } }\n+}\n+\n+void test_keep_special_2 (void)\n+{\n+  falways_inline_noinline<Special>();\n+// { dg-final { scan-tree-dump-times \"falways_inline_noinline<Special> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+inline void\n+fnone_always_inline ()\n+{\n+  asm (\"\");   // induce a no-op \"side-effect\"\n+}\n+\n+template <>\n+inline void __attribute__ ((always_inline))\n+fnone_always_inline<Special>() { asm (\"\"); }\n+\n+// Verify that a call to the primary is not inlined but one to\n+// the explicit specialization is.\n+\n+void test_keep_primary_3 (void)\n+{\n+  fnone_always_inline<void>();\n+// { dg-final { scan-tree-dump-times \"fnone_always_inline<void> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+void test_elim_special_3 (void)\n+{\n+  fnone_always_inline<Special>();\n+// { dg-final { scan-tree-dump-not \"fnone_always_inline<Special> *\\\\(\\\\);\" optimized\" } }\n+}\n+\n+\n+template <class T>\n+void __attribute__ ((noinline))\n+fnoinline_always_inline ()\n+{\n+  asm (\"\");   // induce a no-op \"side-effect\"\n+}\n+\n+template <>\n+inline void __attribute__ ((always_inline))\n+fnoinline_always_inline<Special>()    // { dg-bogus \"follows declaration\" }\n+{\n+  asm (\"\");\n+}\n+\n+// Verify that a call to the primary is not inlined but one to\n+// the explicit specialization is.\n+\n+void test_keep_primary_4 (void)\n+{\n+  fnoinline_always_inline<void>();\n+// { dg-final { scan-tree-dump-times \"fnoinline_always_inline<void> *\\\\(\\\\);\" 1 \"optimized\" } }\n+}\n+\n+void test_elim_special_4 (void)\n+{\n+  fnoinline_always_inline<Special>();\n+// { dg-final { scan-tree-dump-not \"fnoinline_always_inline<Special> *\\\\(\\\\);\" optimized\" } }\n+}"}, {"sha": "57d2cb025f9160f31a264a7d5fd85d0956c567d8", "filename": "gcc/testsuite/g++.dg/ext/attr-nonnull.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nonnull.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nonnull.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nonnull.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,31 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit function template specifialization\n+// does not \"inherit\" attribute nonnull from an argument declared with\n+// one in the primary template.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+template <class T>\n+void __attribute__ ((nonnull (1)))\n+f (T*, T*, T*);\n+\n+template <>\n+void\n+f<int>(int*, int*, int*);     // { dg-warning \"may be missing attributes\" }\n+\n+template <>\n+void __attribute__ ((nonnull (3)))\n+f<float>(float*, float*, float*);\n+\n+\n+void test_nonnull (void)\n+{\n+  f<void>(0, 0, 0);           // { dg-warning \"null argument where non-null required \\\\\\(argument 1\\\\\\)\" }\n+\n+  f<int>(0, 0, 0);            // { dg-bogus \"null argument\" }\n+\n+  f<float>(0, 0, 0);\n+  // { dg-bogus \"null argument where non-null required \\\\\\(argument 1\\\\\\)\" \"\" { target *-*-* } .-1 }\n+  // { dg-warning \"null argument where non-null required \\\\\\(argument 3\\\\\\)\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "cf70ba11349c4f418822dcfb9d2f0ff773c4e457", "filename": "gcc/testsuite/g++.dg/ext/attr-noreturn-2.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn-2.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,47 @@\n+/*  PR c++/83871 - wrong code for attribute const and pure on distinct\n+    template specializations\n+    Test to verify that attributes noreturn on multiple declarations of\n+    the same function are merged.\n+    { dg-do compile }\n+    { dg-options \"-O -fdump-tree-eh\" } */\n+\n+int __attribute__ ((noreturn)) fnoreturn ();\n+\n+void fnoreturn_failed ();\n+\n+int test_noreturn () throw ()\n+{\n+  fnoreturn ();\n+  fnoreturn_failed ();\n+  // Verify that the call to fnoreturn_failed() is eliminated.\n+  // { dg-final { scan-tree-dump-not \"fnoreturn_failed\" \"optimized\" } }\n+\n+  // Expect no -Wreturn-type warning despite the absence of a return\n+  // statement in a non-void function.\n+}\n+\n+\n+int __attribute__ ((noreturn)) fnoreturn_none ();\n+int fnoreturn_none ();\n+\n+void fnoreturn_none_failed ();\n+\n+\n+int test_noreturn_none ()\n+{\n+  fnoreturn_none ();\n+  fnoreturn_none_failed ();\n+  // { dg-final { scan-tree-dump-not \"fnoreturn_none_failed\" \"optimized\" } }\n+}\n+\n+int fnone_noreturn ();\n+int __attribute__ ((noreturn)) fnone_noreturn ();\n+\n+void fnone_noreturn_failed ();\n+\n+int test_none_noreturn () throw ()\n+{\n+  fnone_noreturn ();\n+  fnone_noreturn_failed ();\n+  // { dg-final { scan-tree-dump-not \"fnone_noreturn_failed\" \"optimized\" } }\n+}"}, {"sha": "7d053d81af6b689dc7f023e8f8e7945df4d59a19", "filename": "gcc/testsuite/g++.dg/ext/attr-noreturn.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-noreturn.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,80 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute noreturn from a primary template declared with\n+// one.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+struct Noreturn { };\n+struct Returns { };\n+\n+// Primary declared noreturn but explicit specialization is not.\n+template <class T> int __attribute__ ((noreturn)) f ();\n+template <>        int                            f<Returns>();\n+\n+// Explicit specialization is noreturn but primary is not.\n+template <class T> int g ();\n+template <>        int __attribute__ ((noreturn)) g<Noreturn>();\n+\n+int val;\n+\n+int test_primary_noreturn (char, short)\n+{\n+  // Only the first call should be emitted, the second one should\n+  // be eliminated because the first one doesn't return.\n+  val = f<char>() + f<short>();\n+}   // expect no -Wreturn-type warning here\n+\n+int test_noreturn (int)\n+{\n+  // Call should be retained.\n+  f<int>();\n+}   // expect no -Wreturn-type warning here\n+\n+int test_special_return (int)\n+{\n+  // Both calls must be emitted.\n+  int val = f<Returns>() + f<Returns>();\n+  (void)&val;\n+}   // { dg-warning \"no return statement in function returning non-void\" }\n+\n+\n+int test_primary_return (void)\n+{\n+  int val = g<char>() + g<int>();\n+  (void)&val;\n+}   // { dg-warning \"no return statement in function returning non-void\" }\n+\n+\n+int test_special_noreturn (int, long)\n+{\n+  g<Noreturn>();\n+}   // expect no -Wreturn-type warning here\n+\n+\n+// Verify that the call to f<short>() above is eliminated but the call\n+// to f<int>() and the two calls to f<Returns>() are retained.\n+// { dg-final { scan-tree-dump-not \"f<short>\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"f<Returns>\" 2 \"optimized\" } }\n+\n+// Verify that the second call to f<Returns>() in test_special_return()\n+// is followed by __builtin_unreachable() because there is no return\n+// statement in the function.\n+// { dg-final { scan-tree-dump-times \"f<Returns> \\\\(\\\\);\\[\\n\\r \\]+__builtin_unreachable\" 1 \"optimized\" } }\n+\n+\n+// Verify that the call to g<short>() above is eliminated but the call\n+// to g<char>() and to g<Noreturn>() are both retained.\n+// { dg-final { scan-tree-dump-not \"g<short>\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"g<char>\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"g<Noreturn>\" 1 \"optimized\" } }\n+\n+// Verify that the call to g<int>() in test_primary_return() is\n+// followed by __builtin_unreachable() because there is no return\n+// statement in the function.\n+// { dg-final { scan-tree-dump-times \"g<int> *\\\\(\\\\);\\[\\n\\r \\]+__builtin_unreachable\" 1 \"optimized\" } }\n+// Verify that the call to g<Noreturn>() in test_special_noreturn()\n+// is not followed by __builtin_unreachable() even though there is no\n+// return statement in the function.\n+// { dg-final { scan-tree-dump-times \"g<Noreturn> *\\\\(\\\\);\\[\\n\\r \\]+__builtin_unreachable\" 0 \"optimized\" } }"}, {"sha": "8f1d7af7d066e55a0f6e3e1aab62be11f0bc0d15", "filename": "gcc/testsuite/g++.dg/ext/attr-nothrow-2.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow-2.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,48 @@\n+/*  PR c++/83871 - wrong code for attribute const and pure on distinct\n+    template specializations\n+    Test to verify that attributes nothrow on multiple declarations of\n+    the same function are merged.\n+    { dg-do compile }\n+    { dg-options \"-O -fdump-tree-eh\" } */\n+\n+void __attribute__ ((nothrow)) fnothrow ();\n+\n+void test_nothrow () throw ()\n+{\n+  // No exception handling necessary around the call to fnothrow().\n+  fnothrow ();\n+}\n+\n+void __attribute__ ((nothrow)) fnothrow_none ();\n+void fnothrow_none ();\n+\n+void test_nothrow_none () throw ()\n+{\n+  // No exception handling necessary around the call to fnothrow_none().\n+  fnothrow_none ();\n+}\n+\n+void fnone_nothrow ();\n+void __attribute__ ((nothrow)) fnone_nothrow ();\n+\n+void test_none_nothrow () throw ()\n+{\n+  // No exception handling necessary around the call to fnone_nothrow().\n+  fnone_nothrow ();\n+}\n+\n+int __attribute__ ((nothrow)) fnothrow_noreturn_none ();\n+int __attribute__ ((noreturn)) fnothrow_noreturn_none ();\n+int fnothrow_noreturn_none ();\n+\n+int test_nothrow_noreturn_none () throw ()\n+{\n+  // No exception handling necessary around the call().\n+  // No -Wreturn-value should be emitted because the function is\n+  // declared noreturn.\n+  fnothrow_noreturn_none ();\n+}\n+\n+// Verify that no exception handling code was emitted.\n+// { dg-final { scan-tree-dump-not \"eh_dispatch\" \"eh\" } }\n+// { dg-final { scan-tree-dump-not \"resx\" \"eh\" } }"}, {"sha": "1d3d7153b8d276735747f3fa9d023a2d57ca6cfa", "filename": "gcc/testsuite/g++.dg/ext/attr-nothrow.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-nothrow.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,46 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute nothrow from a primary template declared with one.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+template <class T>\n+void __attribute__ ((nothrow))\n+f ();\n+\n+template <>\n+void f<int>();\n+\n+void f_void_nothrow ();\n+void f_int_maythrow ();\n+\n+void fv (void)\n+{\n+  try\n+    {\n+      f<void>();\n+    }\n+  catch (...)                    // cannot be be reached\n+    {\n+      f_void_nothrow ();         // should be eliminated\n+    }\n+}\n+\n+\n+void fi (void)\n+{\n+  try\n+    {\n+      f<int>();\n+    }\n+  catch (...)                    // may be reached\n+    {\n+      f_int_maythrow ();         // must not be eliminated\n+    }\n+}\n+\n+// Verify that the call to f_void_nothrow() is eliminated but\n+// the call to f_int_maythrow() is retained.\n+// { dg-final { scan-tree-dump-not \"f_void_nothrow\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"f_int_maythrow\" 1 \"optimized\" } }"}, {"sha": "481cf3f590c3badc9b53abba36b023e2c9263db0", "filename": "gcc/testsuite/g++.dg/ext/attr-optimize.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-optimize.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-optimize.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-optimize.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,46 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute optimize from a primary template declared with\n+// one.\n+// { dg-do compile }\n+// { dg-options \"-O2 -Wall -fdump-tree-optimized\" }\n+\n+enum Special { };\n+\n+void foptimize_none_primary_failed ();\n+\n+template <class T>\n+void __attribute__ ((optimize (\"no-printf-return-value\")))\n+foptimize_none ()\n+{\n+  // The call to snprintf and the test should be retained.\n+  if (2 != __builtin_snprintf (0, 0, \"%hhx\", 0x12))\n+    foptimize_none_primary_failed ();\n+}\n+\n+void foptimize_none_special_failed ();\n+\n+template <>\n+inline void\n+foptimize_none<Special>()\n+{\n+  // The whole if statement should be eliminated.\n+  if (3 != __builtin_snprintf (0, 0, \"1%hhx\", 0x12))\n+    foptimize_none_special_failed ();\n+}\n+\n+void test_primary ()\n+{\n+  foptimize_none<void>();\n+  // { dg-final { scan-tree-dump-times \"foptimize_none_primary_failed *\\\\(\\\\)\" 1 \"optimized\" } }\n+}\n+\n+void test_special ()\n+{\n+  // Should be eliminated.\n+  foptimize_none<Special>();\n+// { dg-final { scan-tree-dump-not \"foptimize_none_special_failed *\\\\(\\\\)\" \"optimized\" } }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"__builtin_snprintf\" 1 \"optimized\" } }"}, {"sha": "af36a31d6d520d48b4d96d1e60c1534f709c1855", "filename": "gcc/testsuite/g++.dg/ext/attr-pure.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-pure.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-pure.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-pure.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,69 @@\n+/*  PR c++/83871 - wrong code for attribute const and pure on distinct\n+    template specializations\n+    { dg-do compile }\n+    { dg-options \"-O -Wall\" } */\n+\n+int __attribute__ ((pure)) fpure_none ();\n+int fpure_none ();\n+\n+void test_pure_none_failed ();\n+\n+void func_pure_none ()\n+{\n+  int i0 = fpure_none ();\n+  int i1 = fpure_none ();\n+  if (i0 != i1)\n+    test_pure_none_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_pure_none_failed\" \"optimized\" } }\n+}\n+\n+\n+int fnone_pure ();\n+int __attribute__ ((pure)) fnone_pure ();\n+\n+void test_none_pure_failed ();\n+\n+void func_none_pure ()\n+{\n+  int i0 = fnone_pure ();\n+  int i1 = fnone_pure ();\n+  if (i0 != i1)\n+    test_none_pure_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_none_pure_failed\" \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+int __attribute__ ((pure)) fpure_none (T);\n+\n+template <class T>\n+int fpure_none (T);\n+\n+void template_pure_none ()\n+{\n+  int i0 = fpure_none<int> (0);\n+  int i1 = fpure_none<int> (0);\n+  if (i0 != i1)\n+    test_pure_none_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_pure_none_failed\" \"optimized\" } }\n+}\n+\n+\n+template <class T>\n+int fnone_pure (T);\n+\n+template <class T>\n+int __attribute__ ((pure)) fnone_pure (T);\n+\n+void test_fnone_pure ()\n+{\n+  int i0 = fnone_pure<int> (0);\n+  int i1 = fnone_pure<int> (0);\n+  if (i0 != i1)\n+    test_none_pure_failed ();\n+\n+  // { dg-final { scan-tree-dump-not \"test_none_pure_failed\" \"optimized\" } }\n+}"}, {"sha": "f75f32e46e884e616e03597d842aca3e9e021049", "filename": "gcc/testsuite/g++.dg/ext/attr-returns-nonnull.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-returns-nonnull.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-returns-nonnull.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-returns-nonnull.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,42 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit function template specifialization\n+// does not \"inherit\" attribute nonnull from an argument declared with\n+// one in the primary template.\n+// { dg-do compile }\n+// { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+\n+template <class T>\n+void* __attribute__ ((returns_nonnull))\n+g ();\n+\n+template <>\n+void*\n+g<int>();\n+\n+extern void g_void_returns_nonnull ();\n+extern void g_int_may_return_null ();\n+\n+void test_returns_nonnull ()\n+{\n+  void *p = g<void>();\n+  if (!p)\n+    g_void_returns_nonnull ();\n+\n+  (void)&p;\n+}\n+\n+void test_may_return_null ()\n+{\n+  void *p = g<int>();\n+  if (!p)\n+    g_int_may_return_null ();\n+\n+  (void)&p;\n+}\n+\n+\n+// Verify that the call to g_void_returns_nonnull() is eliminated but\n+// the call to g_int_may_return_null() is retained.\n+// { dg-final { scan-tree-dump-not \"g_void_returns_nonnull\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"g_int_may_return_null\" 1 \"optimized\" } }"}, {"sha": "8369bac51d9eb6f44616015b7d0e303133ac6d81", "filename": "gcc/testsuite/g++.dg/ext/attr-warning.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-warning.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4cfd486ebe3fadb7a67c53c24843770a1d8ba72/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-warning.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-warning.C?ref=d4cfd486ebe3fadb7a67c53c24843770a1d8ba72", "patch": "@@ -0,0 +1,49 @@\n+// Bug c++/83871 - wrong code due to attributes on distinct template\n+// specializations\n+// Test to verify that an explicit template specifialization does not\n+// \"inherit\" attribute warning from a primary template declared with\n+// it.\n+// { dg-do compile }\n+// { dg-options \"-Wall -fdump-tree-optimized\" }\n+\n+struct Special;\n+\n+// Primary has no attributes here.\n+template <class T>\n+void fwarn_primary ();\n+\n+// Uses of the primary template, including declarations of its\n+// specializations, should not be diagnosed until after it has\n+// been redeclared with attribute warning.\n+template <>\n+void fwarn_primary<Special> ();\n+\n+void use_primary_before_warning ()\n+{\n+  // Verify that uses of the primary are not diagnosed.\n+  fwarn_primary<char>();\n+  fwarn_primary<short>();\n+}\n+\n+// Redeclare the primary with attribute warning.\n+template <class T>\n+void __attribute__ ((warning (\"primary\")))\n+fwarn_primary ();\n+\n+// Attribute warning is special in that it only warns for functions\n+// that are actually used, not those that are only declared.\n+template <>\n+void fwarn_primary<double> ();\n+\n+void use_primary_after_warning ()\n+{\n+  // Verify that uses of the redeclared primary are diagnosed.\n+  fwarn_primary<int>();           // { dg-warning \"primary\" }\n+  fwarn_primary<long>();          // { dg-warning \"primary\" }\n+}\n+\n+void use_special ()\n+{\n+  // Verify that the use of the specializatoin is not diagnosed.\n+  fwarn_primary<Special>();\n+}"}]}