{"sha": "bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNhZmQ4NzQ4Y2Y5ZWI4M2E5ZTcxYmY2N2M0ZTJhN2M1YzhmNTEzYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-04-03T03:40:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-04-03T17:49:45Z"}, "message": "c++: alias template and parameter packs (PR91966).\n\nIn this testcase, when we do a pack expansion of count_better_mins<nums>,\nnums appears both in the definition of count_better_mins and as its template\nargument.  The intent is that we get a expansion over pairs of elements of\nthe pack, i.e. less<2,2>, less<2,7>, less<7,2>, ....  But if we substitute\ninto the definition of count_better_mins when parsing the template, we end\nup with sum<less<nums,nums>...>, which never gives us less<2,7>.  We could\ndeal with this by somehow marking up the use of 'nums' as an argument for\n'num', but it's simpler to mark the alias as complex, so we need to\ninstantiate it later with all its arguments rather than replace it early\nwith its expansion.\n\ngcc/cp/ChangeLog\n2020-04-03  Jason Merrill  <jason@redhat.com>\n\n\tPR c++/91966\n\t* pt.c (complex_pack_expansion_r): New.\n\t(complex_alias_template_p): Use it.", "tree": {"sha": "2992d35e98d772b8e3557802b1cedf3ff59c48c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2992d35e98d772b8e3557802b1cedf3ff59c48c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8020a5aafd02af1ccf99372d3d8052c40b59725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8020a5aafd02af1ccf99372d3d8052c40b59725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8020a5aafd02af1ccf99372d3d8052c40b59725"}], "stats": {"total": 140, "additions": 139, "deletions": 1}, "files": [{"sha": "d0b0cb1cac5857a7e373e9cd18e68a88ad54052c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "patch": "@@ -1,3 +1,9 @@\n+2020-04-03  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/91966\n+\t* pt.c (complex_pack_expansion_r): New.\n+\t(complex_alias_template_p): Use it.\n+\n 2020-03-31  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/94205"}, {"sha": "b602f9f82c7e13a6b8b57fe956fc10f953fcf376", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "patch": "@@ -6351,6 +6351,33 @@ uses_all_template_parms_r (tree t, void *data_)\n   return 0;\n }\n \n+/* for_each_template_parm any_fn callback for complex_alias_template_p.  */\n+\n+static int\n+complex_pack_expansion_r (tree t, void *data_)\n+{\n+  /* An alias template with a pack expansion that expands a pack from the\n+     enclosing class needs to be considered complex, to avoid confusion with\n+     the same pack being used as an argument to the alias's own template\n+     parameter (91966).  */\n+  if (!PACK_EXPANSION_P (t))\n+    return 0;\n+  struct uses_all_template_parms_data &data\n+    = *(struct uses_all_template_parms_data*)data_;\n+  for (tree pack = PACK_EXPANSION_PARAMETER_PACKS (t); pack;\n+       pack = TREE_CHAIN (pack))\n+    {\n+      tree parm_pack = TREE_VALUE (pack);\n+      if (!TEMPLATE_PARM_P (parm_pack))\n+\tcontinue;\n+      int idx, level;\n+      template_parm_level_and_index (parm_pack, &level, &idx);\n+      if (level < data.level)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n static bool\n complex_alias_template_p (const_tree tmpl)\n {\n@@ -6371,7 +6398,9 @@ complex_alias_template_p (const_tree tmpl)\n   for (int i = 0; i < len; ++i)\n     data.seen[i] = false;\n \n-  for_each_template_parm (pat, uses_all_template_parms_r, &data, NULL, true);\n+  if (for_each_template_parm (pat, uses_all_template_parms_r, &data,\n+\t\t\t      NULL, true, complex_pack_expansion_r))\n+    return true;\n   for (int i = 0; i < len; ++i)\n     if (!data.seen[i])\n       return true;"}, {"sha": "ab64866d35fbd14b36c8c6e05a47c341ac6c3b95", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-alias2.C", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias2.C?ref=bcafd8748cf9eb83a9e71bf67c4e2a7c5c8f513c", "patch": "@@ -0,0 +1,103 @@\n+// PR c++/91966\n+// { dg-do compile { target c++11 } }\n+\n+// Reduced to this include-free example. Further reduction is hard: Either\n+// the bug(?) disappears, or the program becomes meaningless.\n+\n+template<class...>\n+struct list {};\n+\n+struct nil;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+template<int n>\n+struct number {\n+  constexpr /*implicit*/ operator int() const { return n; }\n+  using type = number<n>;\n+};\n+\n+using false_ = number<0>;\n+using true_ = number<1>;\n+\n+static_assert(!false_{}, \"\");\n+static_assert(true_{}, \"\");\n+\n+template<int... ns> using numbers = list<number<ns>...>;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+template<class lhs, class rhs>\n+struct less_impl;\n+\n+template<int lhs, int rhs>\n+struct less_impl<number<lhs>, number<rhs>>\n+  : number<(lhs < rhs)> {};\n+\n+template<class lhs, class rhs> using less = typename less_impl<lhs, rhs>::type;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+template<class v0, class... vs>\n+struct sum_impl {\n+  static_assert(sizeof...(vs) == 0, \"see specialization\");\n+  using type = v0;\n+};\n+\n+template<int v0, int v1, class... vs>\n+struct sum_impl<number<v0>, number<v1>, vs...>\n+  : sum_impl<number<v0 + v1>, vs...> {};\n+\n+template<class... nums> using sum = typename sum_impl<nums...>::type;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+template<class num>\n+struct conditional_impl {\n+  static_assert(num{}, \"see specialization\");\n+\n+  template<class T, class F>\n+  using type = T;\n+};\n+\n+template<>\n+struct conditional_impl<false_> {\n+  template<class T, class F>\n+  using type = F;\n+};\n+\n+template<class num, class T, class F>\n+using conditional = typename conditional_impl<num>::template type<T, F>;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+template<class seq>\n+struct min_filter_impl;\n+\n+template<class... nums>\n+struct min_filter_impl<list<nums...>> {\n+  template<class num>\n+  using count_better_mins = sum<less<nums, num>...>;\n+\n+  using type = list<conditional<count_better_mins<nums>, nil, nums>...>;\n+\n+//using debug = list<conditional<count_better_mins<nums>, nil, void>...>;\n+\n+// error: expansion pattern 'conditional<typename sum_impl<less<nums, nums>...>::type, nil, void>' contains no parameter packs\n+\n+};\n+\n+template<class seq> using min_filter = typename min_filter_impl<seq>::type;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n+void test_min_filter() {\n+  using computed = min_filter<numbers<2, 7, 2>>;\n+  using expected = list<number<2>, nil, number<2>>;\n+  (void)(computed{} = expected{});// compiles for identical types\n+\n+// error: no match for 'operator=' (operand types are 'computed' {aka 'list<number<2>, number<7>, number<2> >'} and 'expected' {aka 'list<number<2>, nil, number<2> >'})\n+\n+}\n+\n+int main() {}"}]}