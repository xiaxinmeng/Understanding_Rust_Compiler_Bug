{"sha": "2e2082d86450ccee4bf63f1a39e9f16742e893b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUyMDgyZDg2NDUwY2NlZTRiZjYzZjFhMzllOWYxNjc0MmU4OTNiMg==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-20T09:18:19Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-20T09:18:19Z"}, "message": "[multiple changes]\n\n2005-04-20  Chris Burdess  <dog@gnu.org>\n\n\t* java/io/DataOutputStream.java (writeUTF): Use block write for\n\toutput.\n\n2005-04-20  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/io/DataInputStream.java (ignoreInitialNewline): Removed\n\t(readLine): Changed newline handling.\n\nFrom-SVN: r98449", "tree": {"sha": "fe6f7a387506b97faeb00700a21d9b4578b670ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6f7a387506b97faeb00700a21d9b4578b670ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e2082d86450ccee4bf63f1a39e9f16742e893b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2082d86450ccee4bf63f1a39e9f16742e893b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2082d86450ccee4bf63f1a39e9f16742e893b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2082d86450ccee4bf63f1a39e9f16742e893b2/comments", "author": null, "committer": null, "parents": [{"sha": "9db695c1983e0067167722ac45732abfed0e723e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db695c1983e0067167722ac45732abfed0e723e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db695c1983e0067167722ac45732abfed0e723e"}], "stats": {"total": 130, "additions": 40, "deletions": 90}, "files": [{"sha": "2df30109e0e4136fff2b48dc33df0923a285edc1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2e2082d86450ccee4bf63f1a39e9f16742e893b2", "patch": "@@ -1,3 +1,13 @@\n+2005-04-20  Chris Burdess  <dog@gnu.org>\n+\n+\t* java/io/DataOutputStream.java (writeUTF): Use block write for\n+\toutput.\n+\n+2005-04-20  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/DataInputStream.java (ignoreInitialNewline): Removed\n+\t(readLine): Changed newline handling.\n+\n 2005-04-20  Jeroen Frijters  <jeroen@frijters.net>\n \n \t* java/awt/image/PixelGrabber.java (setPixels(int,int,int,int,"}, {"sha": "1eda85584207c1d2b32a67d26fb6259874be90f9", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 19, "deletions": 83, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=2e2082d86450ccee4bf63f1a39e9f16742e893b2", "patch": "@@ -1,5 +1,5 @@\n /* DataInputStream.java -- FilteredInputStream that implements DataInput\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2005  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -56,11 +56,6 @@\n  */\n public class DataInputStream extends FilterInputStream implements DataInput\n {\n-  // readLine() hack to ensure that an '\\r' not followed by an '\\n' is\n-  // handled correctly. If set, readLine() will ignore the first char it sees\n-  // if that char is a '\\n'\n-  boolean ignoreInitialNewline = false;\n-\n   // Byte buffer, used to make primitive read calls more efficient.\n   byte[] buf = new byte [8];\n   \n@@ -352,88 +347,29 @@ public final int readInt () throws IOException\n    *\n    * @deprecated\n    */\n-  public final String readLine () throws IOException\n+  public final String readLine() throws IOException\n   {\n-    StringBuffer strb = new StringBuffer ();\n+    StringBuffer strb = new StringBuffer();\n \n-    readloop: while (true)\n+    while (true)\n       {\n-        int c = 0;\n-        char ch = ' ';\n-        boolean getnext = true;\n-        while (getnext)\n-          {\n-\t    getnext = false;\n-\t    c = in.read();\n-\t    if (c < 0)\t// got an EOF\n-\t      return strb.length () > 0 ? strb.toString () : null;\n-\t    ch = (char) c;\n-\t    if ((ch &= 0xFF) == '\\n')\n-\t      // hack to correctly handle '\\r\\n' sequences\n-\t      if (ignoreInitialNewline)\n-\t\t{\n-\t\t  ignoreInitialNewline = false;\n-\t\t  getnext = true;\n-\t\t}\n-\t      else\n-\t\tbreak readloop;\n-\t  }\n-\n-\tif (ch == '\\r')\n+        int c = in.read();\n+\tif (c == -1)\t// got an EOF\n+\t    return strb.length() > 0 ? strb.toString() : null;\n+\tif (c == '\\r')\n \t  {\n-\t    // FIXME: The following code tries to adjust the stream back one\n-\t    // character if the next char read is '\\n'.  As a last resort,\n-\t    // it tries to mark the position before reading but the bottom\n-\t    // line is that it is possible that this method will not properly\n-\t    // deal with a '\\r' '\\n' combination thus not fulfilling the\n-\t    // DataInput contract for readLine.  It's not a particularly\n-\t    // safe approach threadwise since it is unsynchronized and\n-\t    // since it might mark an input stream behind the users back.\n-\t    // Along the same vein it could try the same thing for\n-\t    // ByteArrayInputStream and PushbackInputStream, but that is\n-\t    // probably overkill since this is deprecated & BufferedInputStream\n-\t    // is the most likely type of input stream.\n-\t    //\n-\t    // The alternative is to somehow push back the next byte if it\n-\t    // isn't a '\\n' or to have the reading methods of this class\n-\t    // keep track of whether the last byte read was '\\r' by readLine\n-\t    // and then skip the very next byte if it is '\\n'.  Either way,\n-\t    // this would increase the complexity of the non-deprecated methods\n-\t    // and since it is undesirable to make non-deprecated methods\n-\t    // less efficient, the following seems like the most reasonable\n-\t    // approach.\n-\t    int next_c = 0;\n-            char next_ch = ' ';\n-\t    if (in instanceof BufferedInputStream)\n-\t      {\n-\t        next_c = in.read();\n-\t        next_ch = (char) (next_c & 0xFF);\n-\t\tif ((next_ch != '\\n') && (next_c >= 0)) \n-\t\t  {\n-\t            BufferedInputStream bin = (BufferedInputStream) in;\n-\t\t    if (bin.pos > 0)\n-                      bin.pos--;\n-\t\t  }\n-\t      }\n-\t    else if (markSupported())\n-\t      {\n-\t        next_c = in.read();\n-\t        next_ch = (char) (next_c & 0xFF);\n-\t\tif ((next_ch != '\\n') && (next_c >= 0)) \n-\t\t  {\n-\t\t    mark(1);\n-\t\t    if ((in.read() & 0xFF) != '\\n')\n-\t\t      reset();\n-\t\t  }\n-\t      } \n-\t    // In order to catch cases where 'in' isn't a BufferedInputStream\n-\t    // and doesn't support mark() (such as reading from a Socket), set \n-\t    // a flag that instructs readLine() to ignore the first character \n-\t    // it sees _if_ that character is a '\\n'.\n-\t    else ignoreInitialNewline = true;\n-\t    break;\n+\t    int next_c = in.read();\n+            if (next_c != '\\n' && next_c != -1)\n+              {\n+                if (! (in instanceof PushbackInputStream))\n+                    in = new PushbackInputStream(in);\n+                ((PushbackInputStream) in).unread(next_c);\n+              }\n+            break;\n \t  }\n-\tstrb.append(ch);\n+        if (c == '\\n')\n+            break;\n+\tstrb.append((char) c);\n       }\n \n     return strb.length() > 0 ? strb.toString() : \"\";"}, {"sha": "c52a7eca1e1206aaaf606be7d40107c9966c0160", "filename": "libjava/java/io/DataOutputStream.java", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2Fjava%2Fio%2FDataOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2082d86450ccee4bf63f1a39e9f16742e893b2/libjava%2Fjava%2Fio%2FDataOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutputStream.java?ref=2e2082d86450ccee4bf63f1a39e9f16742e893b2", "patch": "@@ -423,28 +423,32 @@ else if (c == '\\u0000' || (c >= '\\u0080' && c <= '\\u07ff'))\n     if (sum > 65535)\n       throw new UTFDataFormatException ();\n \n-    writeShort (sum);\n+    int pos = 0;\n+    byte[] buf = new byte[sum];\n \n     for (int i = 0; i < len; ++i)\n       {\n \tchar c = value.charAt(i);\n \tif (c >= '\\u0001' && c <= '\\u007f')\n-\t  write (c);\n+          buf[pos++] = (byte) c;\n \telse if (c == '\\u0000' || (c >= '\\u0080' && c <= '\\u07ff'))\n \t  {\n-\t    write (0xc0 | (0x1f & (c >> 6)));\n-\t    write (0x80 | (0x3f & c));\n+\t    buf[pos++] = (byte) (0xc0 | (0x1f & (c >> 6)));\n+\t    buf[pos++] = (byte) (0x80 | (0x3f & c));\n \t  }\n \telse\n \t  {\n \t    // JSL says the first byte should be or'd with 0xc0, but\n \t    // that is a typo.  Unicode says 0xe0, and that is what is\n \t    // consistent with DataInputStream.\n-\t    write (0xe0 | (0x0f & (c >> 12)));\n-\t    write (0x80 | (0x3f & (c >> 6)));\n-\t    write (0x80 | (0x3f & c));\n+\t    buf[pos++] = (byte) (0xe0 | (0x0f & (c >> 12)));\n+\t    buf[pos++] = (byte) (0x80 | (0x3f & (c >> 6)));\n+\t    buf[pos++] = (byte) (0x80 | (0x3f & c));\n \t  }\n       }\n+    \n+    writeShort (sum);\n+    write(buf, 0, sum);\n   }\n \n } // class DataOutputStream"}]}