{"sha": "e27f8c8a496d9401d68f8b7982606136f2d09ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI3ZjhjOGE0OTZkOTQwMWQ2OGY4Yjc5ODI2MDYxMzZmMmQwOWVkZQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-10-14T22:46:04Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-10-14T22:46:04Z"}, "message": "c4x.c: Convert to use GEN_INT.\n\n\t* config/c4x/c4x.c: Convert to use GEN_INT.\n\t(c4x_parallel_process): Rework to handle new repeat loop structure.\n\t* config/c4x/c4x.md: Convert to use GEN_INT.\n\t(rptb_end): Convert to use GE test.  Replace uses with clobbers.\n\t(decrement_and_branch_on_count): Likewise.\n\t* config/c4x/c4x.h (REPEAT_BLOCK_PROCESS): Deleted hook now that\n\tloop.c has the desired functionality.\n\t(rc_reg_operand): New prototype.\n\t* config/c4x/t-c4x: Can now build all front ends.\n\nFrom-SVN: r23103", "tree": {"sha": "ae00e679557ca7c5f5350410855181869d321c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae00e679557ca7c5f5350410855181869d321c1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e27f8c8a496d9401d68f8b7982606136f2d09ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27f8c8a496d9401d68f8b7982606136f2d09ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27f8c8a496d9401d68f8b7982606136f2d09ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27f8c8a496d9401d68f8b7982606136f2d09ede/comments", "author": null, "committer": null, "parents": [{"sha": "7f3feeea20fc5d0bf85258bc1df0e570aab6b682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3feeea20fc5d0bf85258bc1df0e570aab6b682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3feeea20fc5d0bf85258bc1df0e570aab6b682"}], "stats": {"total": 242, "additions": 106, "deletions": 136}, "files": [{"sha": "a78adfbccc0cbadad052715570cf44793538b0dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e27f8c8a496d9401d68f8b7982606136f2d09ede", "patch": "@@ -1,3 +1,18 @@\n+Thu Oct 15 17:36:48 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c: Convert to use GEN_INT.\n+\t(c4x_parallel_process): Rework to handle new repeat loop structure.\n+\n+\t* config/c4x/c4x.md: Convert to use GEN_INT. \n+\t(rptb_end): Convert to use GE test.  Replace uses with clobbers.\n+\t(decrement_and_branch_on_count): Likewise.\n+\n+\t* config/c4x/c4x.h (REPEAT_BLOCK_PROCESS): Deleted hook now that\n+\tloop.c has the desired functionality.\n+\t(rc_reg_operand): New prototype.\n+\n+\t* config/c4x/t-c4x: Can now build all front ends.\n+\n Wed Oct 14 23:27:08 1998  Didier FORT (didier.fort@fedex.com)\n \n \t* fixincludes: Fix up rpc/{clnt,svr,xdr}.h for SunOS."}, {"sha": "312c2daa154da3c50803510c857e583c56df25c7", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 59, "deletions": 95, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=e27f8c8a496d9401d68f8b7982606136f2d09ede", "patch": "@@ -1120,7 +1120,7 @@ c4x_emit_libcall_mulhi (name, code, mode, operands)\n                             gen_rtx_MULT (HImode,\n                                      gen_rtx (code, HImode, operands[1]),\n                                      gen_rtx (code, HImode, operands[2])),\n-                                     gen_rtx_CONST_INT (VOIDmode, 32)));\n+                                     GEN_INT (32)));\n   insns = get_insns ();\n   end_sequence ();\n   emit_libcall_block (insns, operands[0], ret, equiv);\n@@ -1910,9 +1910,9 @@ c4x_scan_for_ldp (newop, insn, operand0)\n \t      addr = XEXP (addr, 0);\n \t      if (GET_CODE (addr) == CONST_INT)\n \t\t{\n-\t\t  op1 = gen_rtx_CONST_INT (VOIDmode, INTVAL (addr) & ~0xffff);\n+\t\t  op1 = GEN_INT (INTVAL (addr) & ~0xffff);\n \t\t  emit_insn_before (gen_movqi (operand0, op1), insn);\n-\t\t  op1 = gen_rtx_CONST_INT (VOIDmode, INTVAL (addr) & 0xffff);\n+\t\t  op1 = GEN_INT (INTVAL (addr) & 0xffff);\n \t\t  emit_insn_before (gen_iorqi3_noclobber (operand0,\n \t\t\t\t\t\t      operand0, op1), insn);\n \t\t  delete_insn (insn);\n@@ -4598,14 +4598,18 @@ c4x_parallel_process (loop_start, loop_end)\n   rtx insn;\n   rtx insn2;\n   rtx pack;\n-  rtx hoist;\n-  rtx sink;\n+  rtx hoist_pos;\n+  rtx sink_pos;\n   rtx loop_count;\n   rtx loop_count_set;\n+  rtx loop_count_reg;\n+  rtx jump_insn;\n   rtx end_label;\n   int num_packs;\n   int bb;\n \n+  jump_insn = PREV_INSN (loop_end);\n+\n   /* The loop must have a calculable number of iterations\n      since we need to reduce the loop count by one.  \n \n@@ -4614,77 +4618,34 @@ c4x_parallel_process (loop_start, loop_end)\n \n      The loop count must be at least 2?  */\n \n-  loop_count = NEXT_INSN (loop_start);\n-\n-  /* Skip past CLOBBER and USE and deleted insn. This is from flow. */\n-  for (;;)\n-    {\n-      if (GET_CODE (loop_count) == INSN)\n-\t{\n-          rtx x = PATTERN (loop_count);\n-          if (GET_CODE (x) != USE && GET_CODE (x) != CLOBBER)\n-\t    break;\n-\t}\n-      else if (GET_CODE (loop_count) == NOTE)\n-\t{\n-\t  if (! INSN_DELETED_P (loop_count))\n-\t    break;\n-\t}\n-      else\n-\tbreak;\n-      loop_count = NEXT_INSN (loop_count);\n-    }\n+  loop_count = PREV_INSN (loop_start);\n   \n   if (!(loop_count_set = single_set (loop_count)))\n     return 0;\n-  \n-  if (!REG_P (SET_DEST (loop_count_set)) \n-      || REGNO (SET_DEST (loop_count_set)) != RC_REGNO)\n+\n+  if (!find_reg_note (loop_count, REG_LOOP_COUNT, NULL_RTX))\n     return 0;\n \n-  /* Determine places to hoist and sink insns out of the loop.  We\n-     won't have to update basic_block_head if we move things after\n-     loop_count. */\n+  loop_count_reg = SET_DEST (loop_count_set);\n+\t\t  \n+  /* Determine places to hoist and sink insns out of the loop. \n+     We need to hoist insns before the label at the top of the loop. \n+     We'll have to update basic_block_head.  */\n   \n-  hoist = loop_count;\n-  end_label = PREV_INSN (loop_end);\n-\n-  /* Skip past filler insn if present.  */\n-  if (GET_CODE (end_label) != CODE_LABEL)\n-    end_label = PREV_INSN (end_label);\n-\n-  /* Skip past CLOBBER, USE, and deleted insns inserted by the flow pass. */\n-  for (;;)\n-    {\n-      if (GET_CODE (end_label) == INSN)\n-\t{\n-          rtx x = PATTERN (end_label);\n-          if (GET_CODE (x) != USE && GET_CODE (x) != CLOBBER)\n-\t    break;\n-\t}\n-      else if (GET_CODE (end_label) == NOTE)\n-\t{\n-\t  if (! INSN_DELETED_P (end_label))\n-\t    break;\n-\t}\n-      else\n-\tbreak;\n-      end_label = PREV_INSN (end_label);\n-    }\n+  /* Place in the rtx where we hoist insns after.  */\n+  hoist_pos = loop_count;\n \n-  if (GET_CODE (end_label) != CODE_LABEL)\n-    return 0;\n-\n-  sink = end_label;\n+  /* Place in the rtx where we sink insns after.  */\n+  sink_pos = loop_end;\n \n   /* There must be an easier way to work out which basic block we are\n      in.  */\n   for (bb = 0; bb < n_basic_blocks; bb++)\n-    if (basic_block_head[bb] == sink)\n+    if (basic_block_head[bb] == NEXT_INSN (loop_end))\n       break;\n \n   if (bb >= n_basic_blocks)\n-    fatal_insn(\"Cannot find basic block for insn\", sink);\n+    fatal_insn(\"Cannot find basic block for insn\", NEXT_INSN (loop_end));\n \n   /* Skip to label at top of loop.  */\n   for (; GET_CODE (loop_start) != CODE_LABEL;\n@@ -4750,12 +4711,13 @@ c4x_parallel_process (loop_start, loop_end)\n \n \t      /* We need to hoist all the insns from the loop top\n \t\t to and including insn.  */\n-\t      c4x_copy_insns_after(NEXT_INSN (loop_start), insn, &hoist, bb);\n+\t      c4x_copy_insns_after (NEXT_INSN (loop_start), insn,\n+\t\t\t\t    &hoist_pos, bb);\n \n \t      /* We need to sink all the insns after insn to \n \t\t loop_end.  */\n-\t      c4x_copy_insns_after (NEXT_INSN (insn), PREV_INSN(end_label),\n-\t\t\t\t    &sink, bb + 1);\n+\t      c4x_copy_insns_after (NEXT_INSN (insn), PREV_INSN (jump_insn),\n+\t\t\t\t    &sink_pos, bb + 1);\n \n \t      /* Change insn to the new parallel insn, retaining the notes\n \t\t of the old insn.  */\n@@ -4776,34 +4738,30 @@ c4x_parallel_process (loop_start, loop_end)\n \t      if (note)\n \t\tremove_note (insn, note);\n \n-\t      /* Do we have to modify the LOG_LINKS?  */\n+\t      /* ??? Do we have to modify the LOG_LINKS?  */\n \n \t      /* We need to decrement the loop count.  We probably\n-\t\t should test if RC is negative and branch to end label\n-\t\t if so.  */\n+\t\t should test if the loop count is negative and branch\n+\t\t to end label if so.  */\n \t      if (GET_CODE (SET_SRC (loop_count_set)) == CONST_INT)\n \t\t{\n \t\t  /* The loop count must be more than 1 surely?  */\n \t\t  SET_SRC (loop_count_set) \n-\t\t    = gen_rtx_CONST_INT (VOIDmode,\n-\t\t\t\t\t INTVAL (SET_SRC (loop_count_set)) -1);\n+\t\t    = GEN_INT (INTVAL (SET_SRC (loop_count_set)) - 1);\n \t\t}\n \t      else if (GET_CODE (SET_SRC (loop_count_set)) == PLUS\n \t\t       && GET_CODE (XEXP (SET_SRC (loop_count_set), 1))\n \t\t       == CONST_INT)\n \t\t{\n \t\t  XEXP (SET_SRC (loop_count_set), 1)\n-\t\t    = gen_rtx_CONST_INT (VOIDmode,\n-\t\t\t\t    INTVAL (XEXP (SET_SRC (loop_count_set), 1))\n-\t\t\t\t\t - 1);\n+\t\t    = GEN_INT (INTVAL (XEXP (SET_SRC (loop_count_set), 1))\n+\t\t\t       - 1);\n \t\t}\n \t      else\n \t\t{\n \t\t  start_sequence ();\n-\t\t  expand_binop (QImode, sub_optab,\n-\t\t\t\tgen_rtx_REG (QImode, RC_REGNO),\n-\t\t\t\tgen_rtx_CONST_INT (VOIDmode, 1),\n-\t\t\t\tgen_rtx_REG (QImode, RC_REGNO),\n+\t\t  expand_binop (QImode, sub_optab, loop_count_reg,\n+\t\t\t\tGEN_INT (1), loop_count_reg,\t\t\n \t\t\t\t1, OPTAB_DIRECT);\n \t\t  seq_start = get_insns ();\n \t\t  end_sequence ();\n@@ -4813,23 +4771,30 @@ c4x_parallel_process (loop_start, loop_end)\n \t\t     Can we emit more than one insn? */\n \t\t  REG_NOTES (seq_start)\n \t\t    = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t       gen_rtx_REG (QImode, RC_REGNO),\n+\t\t\t       loop_count_reg,\n \t\t\t       REG_NOTES (seq_start));\n \t\t}\n \n-\t      start_sequence ();\n-\t      emit_cmp_insn (gen_rtx_REG (QImode, RC_REGNO),\n-\t\t\t     const0_rtx, LT, NULL_RTX, QImode, 0, 0);\n-\t      emit_jump_insn (gen_blt (end_label));\n-\t      seq_start = get_insns ();\n-\t      end_sequence ();\n-\t      emit_insns_after (seq_start, hoist);\n-\t      \n-\t      /* This is a bit of a hack... */\n-\t      REG_NOTES (NEXT_INSN (seq_start))\n-\t\t= gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t   gen_rtx_REG (QImode, RC_REGNO),\n-\t\t\t   REG_NOTES (NEXT_INSN (seq_start)));\n+\t      if (GET_CODE (SET_SRC (loop_count_set)) != CONST_INT)\n+\t\t{\n+\t\t  end_label = gen_label_rtx();\n+\t\t  start_sequence ();\n+\t\t  emit_cmp_insn (loop_count_reg,\n+\t\t\t\t const0_rtx, LT, NULL_RTX, word_mode, 0, 0);\n+\t\t  emit_jump_insn (gen_blt (end_label));\n+\t\t  seq_start = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  emit_insns_after (seq_start, hoist_pos);\n+\t\t  emit_label_after (end_label, sink_pos);\n+\t\t \n+#if 0 \n+\t\t  /* This is a bit of a hack...but why was it necessary?  */\n+\t\t  REG_NOTES (NEXT_INSN (seq_start))\n+\t\t    = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t loop_count_reg,\n+\t\t\t\t\t REG_NOTES (NEXT_INSN (seq_start)));\n+#endif\n+\t\t}\n \n \t      if (TARGET_DEVEL)\n \t\tdebug_rtx(insn);\n@@ -5258,7 +5223,7 @@ c4x_rptb_emit_init (loop_info)\n \n   /* If have a known constant loop count, things are easy...  */\n   if (loop_info->loop_count > 0)\n-    return gen_rtx_CONST_INT (VOIDmode, loop_info->loop_count - 1);\n+    return GEN_INT (loop_info->loop_count - 1);\n \n   if (loop_info->shift < 0)\n     abort ();\n@@ -5288,14 +5253,13 @@ c4x_rptb_emit_init (loop_info)\n       /* (end_value - start_value + adjust) >> shift */\n       result = expand_binop (QImode, loop_info->unsigned_p ?\n \t\t\t     lshr_optab : ashr_optab, result,\n-\t\t\t     gen_rtx_CONST_INT (VOIDmode,\n-\t\t\t\t      loop_info->shift),\n+\t\t\t     GEN_INT (loop_info->shift),\n \t\t\t     0, loop_info->unsigned_p, OPTAB_DIRECT);\n     }\n \n   /* ((end_value - start_value + adjust) >> shift) - 1 */\n   result = expand_binop (QImode, sub_optab,\n-\t\t\t result, gen_rtx_CONST_INT (VOIDmode, 1),\n+\t\t\t result, GEN_INT (1),\n \t\t\t 0, loop_info->unsigned_p, OPTAB_DIRECT);\n \n   seq_start = get_insns ();"}, {"sha": "527c0a721bd9763bdb2604c0904789dfa23aa210", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=e27f8c8a496d9401d68f8b7982606136f2d09ede", "patch": "@@ -2458,11 +2458,6 @@ if (final_sequence != NULL_RTX)\t\t\\\n \n #define NO_FUNCTION_CSE\n \n-/* Repeat block stuff (hook into strength_reduce() in loop.c).  */\n-\n-extern void c4x_rptb_process ();\n-#define REPEAT_BLOCK_PROCESS(START, END) c4x_rptb_process(START, END)\n-\n /* We don't want a leading tab.  */\n \n #define ASM_OUTPUT_ASM(FILE, STRING) fprintf (FILE, \"%s\\n\", STRING)\n@@ -2581,6 +2576,8 @@ extern int dp_reg_operand ();\n \n extern int sp_reg_operand ();\n \n+extern int rc_reg_operand ();\n+\n extern int st_reg_operand ();\n \n extern int call_operand ();"}, {"sha": "bfcc7b0e33bbe1aab8beee5755cc92eaf09d1d00", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=e27f8c8a496d9401d68f8b7982606136f2d09ede", "patch": "@@ -1134,8 +1134,7 @@\n \n    if (!TARGET_C3X && which_alternative == 3)\n      {\n-       operands[1] = gen_rtx_CONST_INT (VOIDmode, \n-                                        (INTVAL (operands[1]) >> 16) & 0xffff);\n+       operands[1] = GEN_INT ((INTVAL (operands[1]) >> 16) & 0xffff);\n        return \\\"ldhi\\\\t%1,%0\\\";\n      }\n \n@@ -2639,10 +2638,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc,binary\")\n@@ -2661,10 +2660,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2686,10 +2685,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lb%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lh%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2722,10 +2721,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc,binary\")\n@@ -2744,10 +2743,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2769,10 +2768,10 @@\n   \"*\n    if (INTVAL (operands[2]) == 8)\n      {\n-       operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 8);\n+       operands[3] = GEN_INT (INTVAL (operands[3]) / 8);\n        return \\\"lbu%3\\\\t%1,%0\\\";\n      }\n-   operands[3] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[3]) / 16);\n+   operands[3] = GEN_INT (INTVAL (operands[3]) / 16);\n    return \\\"lhu%3\\\\t%1,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -2807,12 +2806,12 @@\n   \"*\n    if (INTVAL (operands[1]) == 8)\n      {\n-       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 8);\n+       operands[2] = GEN_INT (INTVAL (operands[2]) / 8);\n        return \\\"mb%2\\\\t%3,%0\\\";\n      }\n    else if (INTVAL (operands[1]) == 16)\n      {\n-       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 16);\n+       operands[2] = GEN_INT (INTVAL (operands[2]) / 16);\n        return \\\"mh%2\\\\t%3,%0\\\";\n      }\n    return \\\"lwl1\\\\t%3,%0\\\";\n@@ -2834,10 +2833,10 @@\n   \"*\n    if (INTVAL (operands[1]) == 8)\n      {\n-       operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 8);\n+       operands[2] = GEN_INT (INTVAL (operands[2]) / 8);\n        return \\\"mb%2\\\\t%3,%0\\\";\n      }\n-   operands[2] = gen_rtx_CONST_INT (VOIDmode, INTVAL (operands[2]) / 16);\n+   operands[2] = GEN_INT (INTVAL (operands[2]) / 16);\n    return \\\"mh%2\\\\t%3,%0\\\";\n   \"\n   [(set_attr \"type\" \"binarycc\")\n@@ -4564,15 +4563,15 @@\n \n (define_insn \"rptb_end\"\n   [(set (pc)\n-        (if_then_else (ne (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n+        (if_then_else (ge (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n                           (const_int 0))\n                       (label_ref (match_operand 1 \"\" \"\"))\n                       (pc)))\n-   (use (reg:QI 25))\n-   (use (reg:QI 26))\n    (set (match_dup 0)\n         (plus:QI (match_dup 0)\n-                 (const_int -1)))]\n+                 (const_int -1)))\n+   (clobber (reg:QI 25))\n+   (clobber (reg:QI 26))]\n   \"\"\n   \"*\n    return c4x_rptb_nop_p(insn) ? \\\"nop\\\" : \\\"\\\";\"\n@@ -4581,13 +4580,13 @@\n \n (define_expand \"decrement_and_branch_on_count\"\n   [(parallel [(set (pc)\n-                   (if_then_else (ne (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n+                   (if_then_else (ge (match_operand:QI 0 \"rc_reg_operand\" \"v\")\n                                      (const_int 0))\n                                  (label_ref (match_operand 1 \"\" \"\"))\n                                  (pc)))\n-              (use (reg:QI 25))\n-              (use (reg:QI 26))\n-              (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))])]\n+              (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))\n+              (clobber (reg:QI 25))\n+              (clobber (reg:QI 26))])]\n   \"\"\n   \"\")\n \n@@ -5731,7 +5730,7 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1lo = operand_subword (operands[1], 0, 0, HImode);\n-       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n+       rtx count = GEN_INT ((INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_ashlqi3 (op0hi, op1lo, count));\n@@ -5793,7 +5792,7 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1hi = operand_subword (operands[1], 1, 0, HImode);\n-       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n+       rtx count = GEN_INT ((INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_lshrqi3 (op0lo, op1hi, count));\n@@ -5861,14 +5860,13 @@\n        rtx op0hi = operand_subword (operands[0], 1, 0, HImode);\n        rtx op0lo = operand_subword (operands[0], 0, 0, HImode);\n        rtx op1hi = operand_subword (operands[1], 1, 0, HImode);\n-       rtx count = gen_rtx_CONST_INT (VOIDmode, (INTVAL (operands[2]) - 32));\n+       rtx count = GEN_INT ((INTVAL (operands[2]) - 32));\n \n        if (INTVAL (count))\n          emit_insn (gen_ashrqi3 (op0lo, op1hi, count));\n        else\n          emit_insn (gen_movqi (op0lo, op1hi));\n-       emit_insn (gen_ashrqi3 (op0hi, op1hi, \n-                               gen_rtx_CONST_INT (VOIDmode, 31)));\n+       emit_insn (gen_ashrqi3 (op0hi, op1hi, GEN_INT (31)));\n        DONE;\n     }\n     emit_insn (gen_ashrhi3_reg (operands[0], operands[1], operands[2]));"}, {"sha": "39e316e4d8d1563b32b0c7749145648fce87922c", "filename": "gcc/config/c4x/t-c4x", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Ft-c4x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27f8c8a496d9401d68f8b7982606136f2d09ede/gcc%2Fconfig%2Fc4x%2Ft-c4x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Ft-c4x?ref=e27f8c8a496d9401d68f8b7982606136f2d09ede", "patch": "@@ -8,7 +8,7 @@ LIB1ASMFUNCS = _divqf3 _divqi3 _udivqi3 _umodqi3 _modqi3 _mulqi3 \\\n \n # We do not have DF or DI types (or SF and SI for that matter),\n # so fake out the libgcc2 compilation.\n-LIBGCC2_CFLAGS = -O2 -Dexit=unused_exit $(GCC_CFLAGS) $(LIBGCC2_INCLUDES) -DDF=HF -DDI=HI -DSF=QF -DSI=QI\n+LIBGCC2_CFLAGS = -O2 -Dexit=unused_exit $(GCC_CFLAGS) $(LIBGCC2_INCLUDES) -DDF=HF -DDI=HI -DSF=QF -DSI=QI -Dinhibit_libc\n \n MULTILIB_OPTIONS = m30 msmall mmemparm\n MULTILIB_DIRNAMES = c3x small mem\n@@ -20,7 +20,3 @@ INSTALL_LIBGCC = install-multilib\n \n # Don't make libgcc1-test since require crt0.o\n LIBGCC1_TEST =\n-\n-# C[34]x has its own float and limits.h\n-TARGET_FLOAT_H=config/c4x/c4x-float.h\n-TARGET_LIMITS_H=config/c4x/c4x-limits.h"}]}