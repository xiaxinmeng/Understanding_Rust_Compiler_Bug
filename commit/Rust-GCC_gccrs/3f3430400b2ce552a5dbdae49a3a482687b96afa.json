{"sha": "3f3430400b2ce552a5dbdae49a3a482687b96afa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YzNDMwNDAwYjJjZTU1MmE1ZGJkYWU0OWEzYTQ4MjY4N2I5NmFmYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-02-03T16:38:15Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-02-03T16:38:15Z"}, "message": "PR tree-optimization/79352 - -fprintf-return-value doesn't handle flexible-like array members properly\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/79352\n\t* gimple-fold.c (get_range_strlen): Add argument.\n\t(get_range_strlen): Change return type to bool.\n\t(get_maxval_strlen): Pass in a dummy argument.\n\t* gimple-fold.h (get_range_strlen): Change return type to bool.\n\t* gimple-ssa-sprintf.c (get_string_length): Set unlikely counter.\n\t* tree.h (array_at_struct_end_p): Add argument.\n\t* tree.c (array_at_struct_end_p): Handle it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/79352\n\t* gcc.dg/tree-ssa/pr79352.c: New test.\n\nFrom-SVN: r245156", "tree": {"sha": "c78749d08d207350d71edfc1c5b9871d422a1f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c78749d08d207350d71edfc1c5b9871d422a1f1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f3430400b2ce552a5dbdae49a3a482687b96afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3430400b2ce552a5dbdae49a3a482687b96afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3430400b2ce552a5dbdae49a3a482687b96afa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3430400b2ce552a5dbdae49a3a482687b96afa/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46a2ab580a762b0fc3e64dc4ab24d459a4bd1fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a2ab580a762b0fc3e64dc4ab24d459a4bd1fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a2ab580a762b0fc3e64dc4ab24d459a4bd1fd2"}], "stats": {"total": 130, "additions": 109, "deletions": 21}, "files": [{"sha": "a8203a43b42225d2aa9f0a29546006779c527ed8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -1,3 +1,14 @@\n+2017-02-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/79352\n+\t* gimple-fold.c (get_range_strlen): Add argument.\n+\t(get_range_strlen): Change return type to bool.\n+\t(get_maxval_strlen): Pass in a dummy argument.\n+\t* gimple-fold.h (get_range_strlen): Change return type to bool.\n+\t* gimple-ssa-sprintf.c (get_string_length): Set unlikely counter.\n+\t* tree.h (array_at_struct_end_p): Add argument.\n+\t* tree.c (array_at_struct_end_p): Handle it.\n+\n 2017-02-03  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/66295"}, {"sha": "1cd22a8bfdd3cea1e72ca6aa57eb82c6dd8bac81", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -1177,11 +1177,15 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n    length and 2 for maximum value ARG can have.\n    When FUZZY is set and the length of a string cannot be determined,\n    the function instead considers as the maximum possible length the\n-   size of a character array it may refer to.  */\n+   size of a character array it may refer to.\n+   Set *FLEXP to true if the range of the string lengths has been\n+   obtained from the upper bound of an array at the end of a struct.\n+   Such an array may hold a string that's longer than its upper bound\n+   due to it being used as a poor-man's flexible array member.  */\n \n static bool\n get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n-\t\t  bool fuzzy)\n+\t\t  bool fuzzy, bool *flexp)\n {\n   tree var, val;\n   gimple *def_stmt;\n@@ -1202,7 +1206,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t  if (TREE_CODE (aop0) == INDIRECT_REF\n \t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n \t    return get_range_strlen (TREE_OPERAND (aop0, 0),\n-\t\t\t\t     length, visited, type, fuzzy);\n+\t\t\t\t     length, visited, type, fuzzy, flexp);\n \t}\n \n       if (type == 2)\n@@ -1219,7 +1223,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t{\n \t  if (TREE_CODE (arg) == ADDR_EXPR)\n \t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n-\t\t\t\t     visited, type, fuzzy);\n+\t\t\t\t     visited, type, fuzzy, flexp);\n \n \t  if (TREE_CODE (arg) == COMPONENT_REF\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1))) == ARRAY_TYPE)\n@@ -1228,7 +1232,12 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t\t bound on the length of the array.  This may be overly\n \t\t optimistic if the array itself isn't NUL-terminated and\n \t\t the caller relies on the subsequent member to contain\n-\t\t the NUL.  */\n+\t\t the NUL.\n+\t\t Set *FLEXP to true if the array whose bound is being\n+\t\t used is at the end of a struct.  */\n+\t      if (array_at_struct_end_p (arg, true))\n+\t\t*flexp = true;\n+\n \t      arg = TREE_OPERAND (arg, 1);\n \t      val = TYPE_SIZE_UNIT (TREE_TYPE (arg));\n \t      if (!val || integer_zerop (val))\n@@ -1295,14 +1304,14 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n             tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t    return get_range_strlen (rhs, length, visited, type, fuzzy);\n+\t    return get_range_strlen (rhs, length, visited, type, fuzzy, flexp);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n \t    tree op2 = gimple_assign_rhs2 (def_stmt);\n \t    tree op3 = gimple_assign_rhs3 (def_stmt);\n-\t    return get_range_strlen (op2, length, visited, type, fuzzy)\n-\t      && get_range_strlen (op3, length, visited, type, fuzzy);\n+\t    return get_range_strlen (op2, length, visited, type, fuzzy, flexp)\n+\t      && get_range_strlen (op3, length, visited, type, fuzzy, flexp);\n           }\n         return false;\n \n@@ -1325,7 +1334,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-\t    if (!get_range_strlen (arg, length, visited, type, fuzzy))\n+\t    if (!get_range_strlen (arg, length, visited, type, fuzzy, flexp))\n \t      {\n \t\tif (fuzzy)\n \t\t  *maxlen = build_all_ones_cst (size_type_node);\n@@ -1349,27 +1358,36 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n    and array declared as 'char array[8]', MINMAXLEN[0] will be set\n    to 3 and MINMAXLEN[1] to 7, the longest string that could be\n    stored in array.\n-*/\n+   Return true if the range of the string lengths has been obtained\n+   from the upper bound of an array at the end of a struct.  Such\n+   an array may hold a string that's longer than its upper bound\n+   due to it being used as a poor-man's flexible array member.  */\n \n-void get_range_strlen (tree arg, tree minmaxlen[2])\n+bool\n+get_range_strlen (tree arg, tree minmaxlen[2])\n {\n   bitmap visited = NULL;\n \n   minmaxlen[0] = NULL_TREE;\n   minmaxlen[1] = NULL_TREE;\n \n-  get_range_strlen (arg, minmaxlen, &visited, 1, true);\n+  bool flexarray = false;\n+  get_range_strlen (arg, minmaxlen, &visited, 1, true, &flexarray);\n \n   if (visited)\n     BITMAP_FREE (visited);\n+\n+  return flexarray;\n }\n \n tree\n get_maxval_strlen (tree arg, int type)\n {\n   bitmap visited = NULL;\n   tree len[2] = { NULL_TREE, NULL_TREE };\n-  if (!get_range_strlen (arg, len, &visited, type, false))\n+\n+  bool dummy;\n+  if (!get_range_strlen (arg, len, &visited, type, false, &dummy))\n     len[1] = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);"}, {"sha": "e4931a1af52c233bd1137a5e4f9a797cbb11c9e8", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n-extern void get_range_strlen (tree, tree[2]);\n+extern bool get_range_strlen (tree, tree[2]);\n extern tree get_maxval_strlen (tree, int);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);"}, {"sha": "3670bacd1f98910a5ffd7479e1e002bda605c1eb", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -1800,7 +1800,7 @@ get_string_length (tree str)\n      aren't known to point any such arrays result in LENRANGE[1] set\n      to SIZE_MAX.  */\n   tree lenrange[2];\n-  get_range_strlen (str, lenrange);\n+  bool flexarray = get_range_strlen (str, lenrange);\n \n   if (lenrange [0] || lenrange [1])\n     {\n@@ -1843,7 +1843,11 @@ get_string_length (tree str)\n \t  res.range.min = 0;\n \t}\n \n-      res.range.unlikely = res.range.max;\n+      /* If the range of string length has been estimated from the size\n+\t of an array at the end of a struct assume that it's longer than\n+\t the array bound says it is in case it's used as a poor man's\n+\t flexible array member, such as in struct S { char a[4]; };  */\n+      res.range.unlikely = flexarray ? HOST_WIDE_INT_MAX : res.range.max;\n \n       return res;\n     }"}, {"sha": "ff8ce70fed24cbaf61e3137d8da36a987afcf49e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -1,3 +1,8 @@\n+2017-02-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/79352\n+\t* gcc.dg/tree-ssa/pr79352.c: New test.\n+\n 2017-02-03  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/66295"}, {"sha": "4a153b71e431a180f3c50d06e5dbaf68ca59732c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79352.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79352.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79352.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79352.c?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -0,0 +1,45 @@\n+/* PR tree-optimization/79352 - -fprintf-return-value doesn't handle\n+   flexible-like array members properly\n+   { dg-compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+struct A { int i; char a1[1]; };\n+struct B { int i; char a3[3]; };\n+struct C { int i; char ax[]; };\n+\n+int test_array_1 (int i, struct A *a)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", a->a1);\n+}\n+\n+int test_array_3 (int i, struct B *b)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", b->a3);\n+}\n+\n+int test_array_1_3 (int i, struct A *a, struct B *b)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", i ? a->a1 : b->a3);\n+}\n+\n+int test_string_and_array_3 (int i, struct B *b)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", i ? \"123\" : b->a3);\n+}\n+\n+int test_flexarray (struct C *c)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", c->ax);\n+}\n+\n+int test_array_and_flexarray (int i, struct B *b, struct C *c)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", i ? b->a3 : c->ax);\n+}\n+\n+int test_string_and_flexarray (int i, struct C *c)\n+{\n+  return __builtin_snprintf (0, 0, \"%-s\", i ? \"123\" : c->ax);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"snprintf\" 7 \"optimized\"} } */"}, {"sha": "804ab5ed58a95a40c09fb7229df50fc1e51e6d5a", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -13195,13 +13195,16 @@ array_ref_up_bound (tree exp)\n \n /* Returns true if REF is an array reference to an array at the end of\n    a structure.  If this is the case, the array may be allocated larger\n-   than its upper bound implies.  */\n+   than its upper bound implies.  When ALLOW_COMPREF is true considers\n+   REF when it's a COMPONENT_REF in addition ARRAY_REF and\n+   ARRAY_RANGE_REF.  */\n \n bool\n-array_at_struct_end_p (tree ref)\n+array_at_struct_end_p (tree ref, bool allow_compref)\n {\n   if (TREE_CODE (ref) != ARRAY_REF\n-      && TREE_CODE (ref) != ARRAY_RANGE_REF)\n+      && TREE_CODE (ref) != ARRAY_RANGE_REF\n+      && (!allow_compref || TREE_CODE (ref) != COMPONENT_REF))\n     return false;\n \n   while (handled_component_p (ref))"}, {"sha": "f63a678216e411086e5c6da1aba7430eb5204bef", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3430400b2ce552a5dbdae49a3a482687b96afa/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3f3430400b2ce552a5dbdae49a3a482687b96afa", "patch": "@@ -4855,8 +4855,10 @@ extern tree array_ref_low_bound (tree);\n \n /* Returns true if REF is an array reference to an array at the end of\n    a structure.  If this is the case, the array may be allocated larger\n-   than its upper bound implies.  */\n-extern bool array_at_struct_end_p (tree);\n+   than its upper bound implies.  When second argument is true considers\n+   REF when it's a COMPONENT_REF in addition ARRAY_REF and\n+   ARRAY_RANGE_REF.  */\n+extern bool array_at_struct_end_p (tree, bool = false);\n \n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */"}]}