{"sha": "4844a259b41b4f31940b478216d6dc9faa2bcbca", "node_id": "C_kwDOANBUbNoAKDQ4NDRhMjU5YjQxYjRmMzE5NDBiNDc4MjE2ZDZkYzlmYWEyYmNiY2E", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-03T08:27:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-05T08:28:18Z"}, "message": "[Ada] Fix dangling bounds for array result of BIP functions\n\nThe implementation of the build-in-place return protocol for functions\nwhose result type is an unconstrained array type generates dangling\nreferences to local bounds built on the stack for the result as soon as\nthese bounds are not static.  The reason is that the implementation\ntreats the return object, either explicitly present in the source or\nsynthesized by the compiler, as a regular constrained object until very\nlate in the game, although it needs to be ultimately rewritten as the\nrenaming of the dereference of an allocator with unconstrained designated\ntype in order for the bounds to be part of the allocation.\n\nRecently a partial fix was implemented for the case where the result is an\naggregate, by preventing the return object from being expanded after it has\nbeen analyzed.  However, it does not work for the general case of extended\nreturn statements, because the statements therein are still analyzed with\nthe constrained version of the return object so, after it is changed into\nthe unconstrained renaming, this yields (sub)type mismatches.\n\nTherefore this change goes the other way around: it rolls back the partial\nfix and instead performs the transformation of the return object into the\nunconstrained renaming during the expansion of its declaration, in other\nwords before statements referencing it, if any, are analyzed, thus ensuring\nthat they see the final version of the object.\n\ngcc/ada/\n\n\t* exp_aggr.adb (Expand_Array_Aggregate): Remove obsolete code.\n\tDelay the expansion of aggregates initializing return objects of\n\tbuild-in-place functions.\n\t* exp_ch3.ads (Ensure_Activation_Chain_And_Master): Delete.\n\t* exp_ch3.adb (Ensure_Activation_Chain_And_Master): Fold back to...\n\t(Expand_N_Object_Declaration): ...here.\n\tPerform the expansion of return objects of build-in-place functions\n\there instead of...\n\t* exp_ch6.ads (Is_Build_In_Place_Return_Object): Declare.\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): ...here.\n\t(Is_Build_In_Place_Result_Type): Alphabetize.\n\t(Is_Build_In_Place_Return_Object): New predicate.\n\t* exp_ch7.adb (Enclosing_Function): Delete.\n\t(Process_Object_Declaration): Tidy up handling of return objects.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Do not decorate and\n\tfreeze the actual type if it is the same as the nominal type.\n\t* sem_ch6.adb: Remove use and with clauses for Exp_Ch3.\n\t(Analyze_Function_Return): Analyze again all return objects.\n\t(Create_Extra_Formals): Do not force the definition of an Itype\n\tif the subprogram is a compilation unit.", "tree": {"sha": "aeea40a56d2cf8ef46bab4833a8808775b3e269e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeea40a56d2cf8ef46bab4833a8808775b3e269e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4844a259b41b4f31940b478216d6dc9faa2bcbca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4844a259b41b4f31940b478216d6dc9faa2bcbca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4844a259b41b4f31940b478216d6dc9faa2bcbca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4844a259b41b4f31940b478216d6dc9faa2bcbca/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fde6c7114f079b38ebee420a541e14387bcc928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fde6c7114f079b38ebee420a541e14387bcc928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fde6c7114f079b38ebee420a541e14387bcc928"}], "stats": {"total": 1843, "additions": 867, "deletions": 976}, "files": [{"sha": "027a6477713c41f2677e2e0c2e8eba01a9825daf", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -6603,21 +6603,6 @@ package body Exp_Aggr is\n       then\n          return;\n \n-      --  Do not expand an aggregate for an array type which contains tasks if\n-      --  the aggregate is associated with an unexpanded return statement of a\n-      --  build-in-place function. The aggregate is expanded when the related\n-      --  return statement (rewritten into an extended return) is processed.\n-      --  This delay ensures that any temporaries and initialization code\n-      --  generated for the aggregate appear in the proper return block and\n-      --  use the correct _chain and _master.\n-\n-      elsif Has_Task (Base_Type (Etype (N)))\n-        and then Nkind (Parent (N)) = N_Simple_Return_Statement\n-        and then Is_Build_In_Place_Function\n-                   (Return_Applies_To (Return_Statement_Entity (Parent (N))))\n-      then\n-         return;\n-\n       elsif Present (Component_Associations (N))\n         and then Nkind (First (Component_Associations (N))) =\n                  N_Iterated_Component_Association\n@@ -6837,7 +6822,9 @@ package body Exp_Aggr is\n         or else Parent_Kind = N_Extension_Aggregate\n         or else Parent_Kind = N_Component_Association\n         or else (Parent_Kind = N_Object_Declaration\n-                  and then Needs_Finalization (Typ))\n+                  and then (Needs_Finalization (Typ)\n+                             or else Is_Build_In_Place_Return_Object\n+                                       (Defining_Identifier (Parent_Node))))\n         or else (Parent_Kind = N_Assignment_Statement\n                   and then Inside_Init_Proc)\n       then"}, {"sha": "7e4c4232e65f92a262bda8b84a3354de380ce1b1", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 781, "deletions": 55, "changes": 836, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -4895,47 +4895,6 @@ package body Exp_Ch3 is\n       end loop;\n    end Copy_Discr_Checking_Funcs;\n \n-   ----------------------------------------\n-   -- Ensure_Activation_Chain_And_Master --\n-   ----------------------------------------\n-\n-   procedure Ensure_Activation_Chain_And_Master (Obj_Decl : Node_Id) is\n-      Def_Id : constant Entity_Id := Defining_Identifier (Obj_Decl);\n-      Expr   : constant Node_Id   := Expression (Obj_Decl);\n-      Expr_Q : Node_Id;\n-      Typ    : constant Entity_Id := Etype (Def_Id);\n-\n-   begin\n-      pragma Assert (Nkind (Obj_Decl) = N_Object_Declaration);\n-\n-      if Might_Have_Tasks (Typ) then\n-         Build_Activation_Chain_Entity (Obj_Decl);\n-\n-         if Has_Task (Typ) then\n-            Build_Master_Entity (Def_Id);\n-\n-         --  Handle objects initialized with BIP function calls\n-\n-         elsif Present (Expr) then\n-            if Nkind (Expr) = N_Qualified_Expression then\n-               Expr_Q := Expression (Expr);\n-            else\n-               Expr_Q := Expr;\n-            end if;\n-\n-            if Is_Build_In_Place_Function_Call (Expr_Q)\n-              or else Present (Unqual_BIP_Iface_Function_Call (Expr_Q))\n-              or else\n-                (Nkind (Expr_Q) = N_Reference\n-                   and then\n-                 Is_Build_In_Place_Function_Call (Prefix (Expr_Q)))\n-            then\n-               Build_Master_Entity (Def_Id);\n-            end if;\n-         end if;\n-      end if;\n-   end Ensure_Activation_Chain_And_Master;\n-\n    ------------------------------\n    -- Expand_Freeze_Array_Type --\n    ------------------------------\n@@ -6180,6 +6139,47 @@ package body Exp_Ch3 is\n       --  value, it may be possible to build an equivalent aggregate instead,\n       --  and prevent an actual call to the initialization procedure.\n \n+      function Build_Heap_Or_Pool_Allocator\n+        (Temp_Id    : Entity_Id;\n+         Temp_Typ   : Entity_Id;\n+         Func_Id    : Entity_Id;\n+         Ret_Typ    : Entity_Id;\n+         Alloc_Expr : Node_Id) return Node_Id;\n+      --  Create the statements necessary to allocate a return object on the\n+      --  heap or user-defined storage pool. The object may need finalization\n+      --  actions depending on the return type.\n+      --\n+      --    * Controlled case\n+      --\n+      --       if BIPfinalizationmaster = null then\n+      --          Temp_Id := <Alloc_Expr>;\n+      --       else\n+      --          declare\n+      --             type Ptr_Typ is access Ret_Typ;\n+      --             for Ptr_Typ'Storage_Pool use\n+      --                   Base_Pool (BIPfinalizationmaster.all).all;\n+      --             Local : Ptr_Typ;\n+      --\n+      --          begin\n+      --             procedure Allocate (...) is\n+      --             begin\n+      --                System.Storage_Pools.Subpools.Allocate_Any (...);\n+      --             end Allocate;\n+      --\n+      --             Local := <Alloc_Expr>;\n+      --             Temp_Id := Temp_Typ (Local);\n+      --          end;\n+      --       end if;\n+      --\n+      --    * Non-controlled case\n+      --\n+      --       Temp_Id := <Alloc_Expr>;\n+      --\n+      --  Temp_Id is the temporary which is used to reference the internally\n+      --  created object in all allocation forms. Temp_Typ is the type of the\n+      --  temporary. Func_Id is the enclosing function. Ret_Typ is the return\n+      --  type of Func_Id. Alloc_Expr is the actual allocator.\n+\n       procedure Count_Default_Sized_Task_Stacks\n         (Typ         : Entity_Id;\n          Pri_Stacks  : out Int;\n@@ -6322,6 +6322,157 @@ package body Exp_Ch3 is\n          end if;\n       end Build_Equivalent_Aggregate;\n \n+      ----------------------------------\n+      -- Build_Heap_Or_Pool_Allocator --\n+      ----------------------------------\n+\n+      function Build_Heap_Or_Pool_Allocator\n+        (Temp_Id    : Entity_Id;\n+         Temp_Typ   : Entity_Id;\n+         Func_Id    : Entity_Id;\n+         Ret_Typ    : Entity_Id;\n+         Alloc_Expr : Node_Id) return Node_Id\n+      is\n+      begin\n+         pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n+         --  Processing for objects that require finalization actions\n+\n+         if Needs_Finalization (Ret_Typ) then\n+            declare\n+               Decls      : constant List_Id := New_List;\n+               Fin_Mas_Id : constant Entity_Id :=\n+                 Build_In_Place_Formal (Func_Id, BIP_Finalization_Master);\n+               Orig_Expr  : constant Node_Id := New_Copy_Tree (Alloc_Expr);\n+               Stmts      : constant List_Id := New_List;\n+               Local_Id   : Entity_Id;\n+               Pool_Id    : Entity_Id;\n+               Ptr_Typ    : Entity_Id;\n+\n+            begin\n+               --  Generate:\n+               --    Pool_Id renames Base_Pool (BIPfinalizationmaster.all).all;\n+\n+               Pool_Id := Make_Temporary (Loc, 'P');\n+\n+               Append_To (Decls,\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Pool_Id,\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (RTE (RE_Root_Storage_Pool), Loc),\n+                   Name                =>\n+                     Make_Explicit_Dereference (Loc,\n+                       Prefix =>\n+                         Make_Function_Call (Loc,\n+                           Name                   =>\n+                             New_Occurrence_Of (RTE (RE_Base_Pool), Loc),\n+                           Parameter_Associations => New_List (\n+                             Make_Explicit_Dereference (Loc,\n+                               Prefix =>\n+                                 New_Occurrence_Of (Fin_Mas_Id, Loc)))))));\n+\n+               --  Create an access type which uses the storage pool of the\n+               --  caller's master. This additional type is necessary because\n+               --  the finalization master cannot be associated with the type\n+               --  of the temporary. Otherwise the secondary stack allocation\n+               --  will fail.\n+\n+               --  Generate:\n+               --    type Ptr_Typ is access Ret_Typ;\n+\n+               Ptr_Typ := Make_Temporary (Loc, 'P');\n+\n+               Append_To (Decls,\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Ptr_Typ,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       Subtype_Indication =>\n+                         New_Occurrence_Of (Ret_Typ, Loc))));\n+\n+               --  Perform minor decoration in order to set the master and the\n+               --  storage pool attributes.\n+\n+               Mutate_Ekind                (Ptr_Typ, E_Access_Type);\n+               Set_Finalization_Master     (Ptr_Typ, Fin_Mas_Id);\n+               Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n+\n+               --  Create the temporary, generate:\n+               --    Local_Id : Ptr_Typ;\n+\n+               Local_Id := Make_Temporary (Loc, 'T');\n+\n+               Append_To (Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Local_Id,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Ptr_Typ, Loc)));\n+\n+               --  Allocate the object, generate:\n+               --    Local_Id := <Alloc_Expr>;\n+\n+               Append_To (Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (Local_Id, Loc),\n+                   Expression => Alloc_Expr));\n+\n+               --  Generate:\n+               --    Temp_Id := Temp_Typ (Local_Id);\n+\n+               Append_To (Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                   Expression =>\n+                     Unchecked_Convert_To (Temp_Typ,\n+                       New_Occurrence_Of (Local_Id, Loc))));\n+\n+               --  Wrap the allocation in a block. This is further conditioned\n+               --  by checking the caller finalization master at runtime. A\n+               --  null value indicates a non-existent master, most likely due\n+               --  to a Finalize_Storage_Only allocation.\n+\n+               --  Generate:\n+               --    if BIPfinalizationmaster = null then\n+               --       Temp_Id := <Orig_Expr>;\n+               --    else\n+               --       declare\n+               --          <Decls>\n+               --       begin\n+               --          <Stmts>\n+               --       end;\n+               --    end if;\n+\n+               return\n+                 Make_If_Statement (Loc,\n+                   Condition       =>\n+                     Make_Op_Eq (Loc,\n+                       Left_Opnd  => New_Occurrence_Of (Fin_Mas_Id, Loc),\n+                       Right_Opnd => Make_Null (Loc)),\n+\n+                   Then_Statements => New_List (\n+                     Make_Assignment_Statement (Loc,\n+                       Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                       Expression => Orig_Expr)),\n+\n+                   Else_Statements => New_List (\n+                     Make_Block_Statement (Loc,\n+                       Declarations               => Decls,\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Stmts))));\n+            end;\n+\n+         --  For all other cases, generate:\n+         --    Temp_Id := <Alloc_Expr>;\n+\n+         else\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                Expression => Alloc_Expr);\n+         end if;\n+      end Build_Heap_Or_Pool_Allocator;\n+\n       -------------------------------------\n       -- Count_Default_Sized_Task_Stacks --\n       -------------------------------------\n@@ -6869,7 +7020,27 @@ package body Exp_Ch3 is\n       --  also that a Master variable is established (and that the appropriate\n       --  enclosing construct is established as a task master).\n \n-      Ensure_Activation_Chain_And_Master (N);\n+      if Has_Task (Typ) or else Might_Have_Tasks (Typ) then\n+         Build_Activation_Chain_Entity (N);\n+\n+         if Has_Task (Typ) then\n+            Build_Master_Entity (Def_Id);\n+\n+         --  Handle objects initialized with BIP function calls\n+\n+         elsif Present (Expr) then\n+            Expr_Q := Unqualify (Expr);\n+\n+            if Is_Build_In_Place_Function_Call (Expr_Q)\n+              or else Present (Unqual_BIP_Iface_Function_Call (Expr_Q))\n+              or else (Nkind (Expr_Q) = N_Reference\n+                        and then\n+                       Is_Build_In_Place_Function_Call (Prefix (Expr_Q)))\n+            then\n+               Build_Master_Entity (Def_Id);\n+            end if;\n+         end if;\n+      end if;\n \n       --  If No_Implicit_Heap_Allocations or No_Implicit_Task_Allocations\n       --  restrictions are active then default-sized secondary stacks are\n@@ -6905,6 +7076,7 @@ package body Exp_Ch3 is\n       --  Default initialization required, and no expression present\n \n       if No (Expr) then\n+         Expr_Q := Expr;\n \n          --  If we have a type with a variant part, the initialization proc\n          --  will contain implicit tests of the discriminant values, which\n@@ -6964,7 +7136,9 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         Default_Initialize_Object (Init_After);\n+         if not Is_Build_In_Place_Return_Object (Def_Id) then\n+            Default_Initialize_Object (Init_After);\n+         end if;\n \n          --  Generate attribute for Persistent_BSS if needed\n \n@@ -7022,7 +7196,9 @@ package body Exp_Ch3 is\n                Expander_Mode_Restore;\n             end if;\n \n-            Convert_Aggr_In_Object_Decl (N);\n+            if not Is_Build_In_Place_Return_Object (Def_Id) then\n+               Convert_Aggr_In_Object_Decl (N);\n+            end if;\n \n          --  Ada 2005 (AI-318-02): If the initialization expression is a call\n          --  to a build-in-place function, then access to the declared object\n@@ -7091,13 +7267,12 @@ package body Exp_Ch3 is\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n-            --  If the object is a return object of an inherently limited type,\n-            --  which implies build-in-place treatment, bypass the special\n+            --  If the object is a built-in-place return object, bypass special\n             --  treatment of class-wide interface initialization below. In this\n             --  case, the expansion of the return statement will take care of\n             --  creating the object (via allocator) and initializing it.\n \n-            if Is_Return_Object (Def_Id) and then Is_Limited_View (Typ) then\n+            if Is_Build_In_Place_Return_Object (Def_Id) then\n                null;\n \n             elsif Tagged_Type_Expansion then\n@@ -7323,9 +7498,12 @@ package body Exp_Ch3 is\n                      Set_SPARK_Pragma_Inherited (Def_Id, Save_SPI);\n                   end;\n                end;\n-            end if;\n \n-            return;\n+               return;\n+\n+            else\n+               return;\n+            end if;\n \n          --  Common case of explicit object initialization\n \n@@ -7598,11 +7776,11 @@ package body Exp_Ch3 is\n                          Name       => New_Occurrence_Of (Def_Id, Loc),\n                          Expression => Relocate_Node (Expr));\n             begin\n-               Set_Expression (N, Empty);\n-               Set_No_Initialization (N);\n                Set_Assignment_OK (Name (Stat));\n                Set_No_Ctrl_Actions (Stat);\n-               Insert_After_And_Analyze (Init_After, Stat);\n+               Insert_Action_After (Init_After, Stat);\n+               Set_Expression (N, Empty);\n+               Set_No_Initialization (N);\n             end;\n          end if;\n       end if;\n@@ -7699,6 +7877,554 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n+      --  If this is the return object of a build-in-place function, locate the\n+      --  implicit BIPaccess parameter designating the caller-supplied return\n+      --  object and convert the declaration to a renaming of a dereference of\n+      --  this parameter. If the declaration includes an expression, add an\n+      --  assignment statement to ensure the return object gets initialized.\n+\n+      --    Result : T [:= <expression>];\n+\n+      --  is converted to\n+\n+      --    Result : T renames BIPaccess.all;\n+      --    [Result := <expression>;]\n+\n+      --  in the constrained case, or to\n+\n+      --    type Txx is access all ...;\n+      --    Rxx : Txx := null;\n+\n+      --    if BIPalloc = 1 then\n+      --       Rxx := BIPaccess;\n+      --    elsif BIPalloc = 2 then\n+      --       Rxx := new <expression-type>[storage_pool =\n+      --         system__secondary_stack__ss_pool][procedure_to_call =\n+      --         system__secondary_stack__ss_allocate];\n+      --    elsif BIPalloc = 3 then\n+      --       Rxx := new <expression-type>\n+      --    elsif BIPalloc = 4 then\n+      --       Pxx : system__storage_pools__root_storage_pool renames\n+      --         BIPstoragepool.all;\n+      --       Rxx := new <expression-type>[storage_pool =\n+      --         Pxx][procedure_to_call =\n+      --         system__storage_pools__allocate_any];\n+      --    else\n+      --       [program_error \"build in place mismatch\"]\n+      --    end if;\n+\n+      --    Result : T renames Rxx.all;\n+      --    Result := <expression>;\n+\n+      --  in the unconstrained case.\n+\n+      if Is_Build_In_Place_Return_Object (Def_Id) then\n+         declare\n+            Func_Id     : constant Entity_Id :=\n+              Return_Applies_To (Scope (Def_Id));\n+            Ret_Obj_Typ : constant Entity_Id := Etype (Def_Id);\n+\n+            Init_Stmt       : Node_Id;\n+            Obj_Acc_Formal  : Entity_Id;\n+\n+         begin\n+            --  Retrieve the implicit access parameter passed by the caller\n+\n+            Obj_Acc_Formal :=\n+              Build_In_Place_Formal (Func_Id, BIP_Object_Access);\n+\n+            --  If the return object's declaration includes an expression\n+            --  and the declaration isn't marked as No_Initialization, then\n+            --  we need to generate an assignment to the object and insert\n+            --  it after the declaration before rewriting it as a renaming\n+            --  (otherwise we'll lose the initialization). The case where\n+            --  the result type is an interface (or class-wide interface)\n+            --  is also excluded because the context of the function call\n+            --  must be unconstrained, so the initialization will always\n+            --  be done as part of an allocator evaluation (storage pool\n+            --  or secondary stack), never to a constrained target object\n+            --  passed in by the caller. Besides the assignment being\n+            --  unneeded in this case, it avoids problems with trying to\n+            --  generate a dispatching assignment when the return expression\n+            --  is a nonlimited descendant of a limited interface (the\n+            --  interface has no assignment operation).\n+\n+            if Present (Expr_Q)\n+              and then not Is_Delayed_Aggregate (Expr_Q)\n+              and then not No_Initialization (N)\n+              and then not Is_Interface (Etype (Def_Id))\n+            then\n+               if Is_Class_Wide_Type (Etype (Def_Id))\n+                 and then not Is_Class_Wide_Type (Etype (Expr_Q))\n+               then\n+                  Init_Stmt :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Def_Id, Loc),\n+                      Expression =>\n+                        Make_Type_Conversion (Loc,\n+                          Subtype_Mark =>\n+                            New_Occurrence_Of (Etype (Def_Id), Loc),\n+                          Expression   => New_Copy_Tree (Expr_Q)));\n+\n+               else\n+                  Init_Stmt :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Def_Id, Loc),\n+                      Expression => New_Copy_Tree (Expr_Q));\n+               end if;\n+\n+               Set_Assignment_OK (Name (Init_Stmt));\n+               Set_No_Ctrl_Actions (Init_Stmt);\n+\n+            else\n+               Init_Stmt := Empty;\n+            end if;\n+\n+            --  When the function's subtype is unconstrained, a run-time\n+            --  test may be needed to decide the form of allocation to use\n+            --  for the return object. The function has an implicit formal\n+            --  parameter indicating this. If the BIP_Alloc_Form formal has\n+            --  the value one, then the caller has passed access to an\n+            --  existing object for use as the return object. If the value\n+            --  is two, then the return object must be allocated on the\n+            --  secondary stack. Otherwise, the object must be allocated in\n+            --  a storage pool. We generate an if statement to test the\n+            --  implicit allocation formal and initialize a local access\n+            --  value appropriately, creating allocators in the secondary\n+            --  stack and global heap cases. The special formal also exists\n+            --  and must be tested when the function has a tagged result,\n+            --  even when the result subtype is constrained, because in\n+            --  general such functions can be called in dispatching contexts\n+            --  and must be handled similarly to functions with a class-wide\n+            --  result.\n+\n+            if Needs_BIP_Alloc_Form (Func_Id) then\n+               declare\n+                  Desig_Typ : constant Entity_Id :=\n+                    (if Ekind (Ret_Obj_Typ) = E_Array_Subtype\n+                     then Etype (Func_Id) else Ret_Obj_Typ);\n+                  --  Ensure that the we use a fat pointer when allocating\n+                  --  an unconstrained array on the heap. In this case the\n+                  --  result object type is a constrained array type even\n+                  --  though the function type is unconstrained.\n+                  Obj_Alloc_Formal : constant Entity_Id :=\n+                    Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n+                  Pool_Id          : constant Entity_Id :=\n+                    Make_Temporary (Loc, 'P');\n+\n+                  Alloc_Obj_Id   : Entity_Id;\n+                  Alloc_Obj_Decl : Node_Id;\n+                  Alloc_Stmt      : Node_Id;\n+                  Guard_Except   : Node_Id;\n+                  Heap_Allocator : Node_Id;\n+                  Pool_Decl      : Node_Id;\n+                  Pool_Allocator : Node_Id;\n+                  Ptr_Type_Decl  : Node_Id;\n+                  Ref_Type       : Entity_Id;\n+                  SS_Allocator   : Node_Id;\n+\n+               begin\n+                  --  Create an access type designating the function's\n+                  --  result subtype.\n+\n+                  Ref_Type := Make_Temporary (Loc, 'A');\n+\n+                  Ptr_Type_Decl :=\n+                    Make_Full_Type_Declaration (Loc,\n+                      Defining_Identifier => Ref_Type,\n+                      Type_Definition     =>\n+                        Make_Access_To_Object_Definition (Loc,\n+                          All_Present        => True,\n+                          Subtype_Indication =>\n+                            New_Occurrence_Of (Desig_Typ, Loc)));\n+\n+                  Insert_Action (N, Ptr_Type_Decl);\n+\n+                  --  Create an access object that will be initialized to an\n+                  --  access value denoting the return object, either coming\n+                  --  from an implicit access value passed in by the caller\n+                  --  or from the result of an allocator.\n+\n+                  Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+                  Set_Etype (Alloc_Obj_Id, Ref_Type);\n+\n+                  Alloc_Obj_Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Alloc_Obj_Id,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (Ref_Type, Loc));\n+\n+                  Insert_Action (N, Alloc_Obj_Decl);\n+\n+                     --  Create allocators for both the secondary stack and\n+                     --  global heap. If there's an initialization expression,\n+                     --  then create these as initialized allocators.\n+\n+                  if Present (Expr_Q)\n+                    and then not Is_Delayed_Aggregate (Expr_Q)\n+                    and then not No_Initialization (N)\n+                  then\n+                     --  Always use the type of the expression for the\n+                     --  qualified expression, rather than the result type.\n+                     --  In general we cannot always use the result type\n+                     --  for the allocator, because the expression might be\n+                     --  of a specific type, such as in the case of an\n+                     --  aggregate or even a nonlimited object when the\n+                     --  result type is a limited class-wide interface type.\n+\n+                     Heap_Allocator :=\n+                       Make_Allocator (Loc,\n+                         Expression =>\n+                           Make_Qualified_Expression (Loc,\n+                             Subtype_Mark =>\n+                               New_Occurrence_Of (Etype (Expr_Q), Loc),\n+                             Expression   => New_Copy_Tree (Expr_Q)));\n+\n+                  else\n+                     --  If the function returns a class-wide type we cannot\n+                     --  use the return type for the allocator. Instead we\n+                     --  use the type of the expression, which must be an\n+                     --  aggregate of a definite type.\n+\n+                     if Is_Class_Wide_Type (Ret_Obj_Typ) then\n+                        Heap_Allocator :=\n+                          Make_Allocator (Loc,\n+                            Expression =>\n+                              New_Occurrence_Of (Etype (Expr_Q), Loc));\n+\n+                     else\n+                        Heap_Allocator :=\n+                          Make_Allocator (Loc,\n+                            Expression =>\n+                              New_Occurrence_Of (Ret_Obj_Typ, Loc));\n+                     end if;\n+\n+                     --  If the object requires default initialization then\n+                     --  that will happen later following the elaboration of\n+                     --  the object renaming. If we don't turn it off here\n+                     --  then the object will be default initialized twice.\n+\n+                     Set_No_Initialization (Heap_Allocator);\n+                  end if;\n+\n+                  --  Set the flag indicating that the allocator came from\n+                  --  a build-in-place return statement, so we can avoid\n+                  --  adjusting the allocated object. Note that this flag\n+                  --  will be inherited by the copies made below.\n+\n+                  Set_Alloc_For_BIP_Return (Heap_Allocator);\n+\n+                  --  The Pool_Allocator is just like the Heap_Allocator,\n+                  --  except we set Storage_Pool and Procedure_To_Call so\n+                  --  it will use the user-defined storage pool.\n+\n+                  Pool_Allocator := New_Copy_Tree (Heap_Allocator);\n+\n+                  pragma Assert (Alloc_For_BIP_Return (Pool_Allocator));\n+\n+                  --  Do not generate the renaming of the build-in-place\n+                  --  pool parameter on ZFP because the parameter is not\n+                  --  created in the first place.\n+\n+                  if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n+                     Pool_Decl :=\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier => Pool_Id,\n+                         Subtype_Mark        =>\n+                           New_Occurrence_Of\n+                             (RTE (RE_Root_Storage_Pool), Loc),\n+                         Name                =>\n+                           Make_Explicit_Dereference (Loc,\n+                             New_Occurrence_Of\n+                               (Build_In_Place_Formal\n+                                  (Func_Id, BIP_Storage_Pool), Loc)));\n+                     Set_Storage_Pool (Pool_Allocator, Pool_Id);\n+                     Set_Procedure_To_Call\n+                       (Pool_Allocator, RTE (RE_Allocate_Any));\n+                  else\n+                     Pool_Decl := Make_Null_Statement (Loc);\n+                  end if;\n+\n+                  --  If the No_Allocators restriction is active, then only\n+                  --  an allocator for secondary stack allocation is needed.\n+                  --  It's OK for such allocators to have Comes_From_Source\n+                  --  set to False, because gigi knows not to flag them as\n+                  --  being a violation of No_Implicit_Heap_Allocations.\n+\n+                  if Restriction_Active (No_Allocators) then\n+                     SS_Allocator   := Heap_Allocator;\n+                     Heap_Allocator := Make_Null (Loc);\n+                     Pool_Allocator := Make_Null (Loc);\n+\n+                  --  Otherwise the heap and pool allocators may be needed,\n+                  --  so we make another allocator for secondary stack\n+                  --  allocation.\n+\n+                  else\n+                     SS_Allocator := New_Copy_Tree (Heap_Allocator);\n+\n+                     pragma Assert (Alloc_For_BIP_Return (SS_Allocator));\n+\n+                     --  The heap and pool allocators are marked as\n+                     --  Comes_From_Source since they correspond to an\n+                     --  explicit user-written allocator (that is, it will\n+                     --  only be executed on behalf of callers that call the\n+                     --  function as initialization for such an allocator).\n+                     --  Prevents errors when No_Implicit_Heap_Allocations\n+                     --  is in force.\n+\n+                     Set_Comes_From_Source (Heap_Allocator, True);\n+                     Set_Comes_From_Source (Pool_Allocator, True);\n+                  end if;\n+\n+                  --  The allocator is returned on the secondary stack\n+\n+                  Check_Restriction (No_Secondary_Stack, N);\n+                  Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n+                  Set_Procedure_To_Call\n+                    (SS_Allocator, RTE (RE_SS_Allocate));\n+\n+                  --  The allocator is returned on the secondary stack,\n+                  --  so indicate that the function return, as well as\n+                  --  all blocks that encloses the allocator, must not\n+                  --  release it. The flags must be set now because\n+                  --  the decision to use the secondary stack is done\n+                  --  very late in the course of expanding the return\n+                  --  statement, past the point where these flags are\n+                  --  normally set.\n+\n+                  Set_Uses_Sec_Stack (Func_Id);\n+                  Set_Uses_Sec_Stack (Scope (Def_Id));\n+                  Set_Sec_Stack_Needed_For_Return (Scope (Def_Id));\n+\n+                  --  Guard against poor expansion on the caller side by\n+                  --  using a raise statement to catch out-of-range values\n+                  --  of formal parameter BIP_Alloc_Form.\n+\n+                  if Exceptions_OK then\n+                     Guard_Except :=\n+                       Make_Raise_Program_Error (Loc,\n+                         Reason => PE_Build_In_Place_Mismatch);\n+                  else\n+                     Guard_Except := Make_Null_Statement (Loc);\n+                  end if;\n+\n+                  --  Create an if statement to test the BIP_Alloc_Form\n+                  --  formal and initialize the access object to either the\n+                  --  BIP_Object_Access formal (BIP_Alloc_Form =\n+                  --  Caller_Allocation), the result of allocating the\n+                  --  object in the secondary stack (BIP_Alloc_Form =\n+                  --  Secondary_Stack), or else an allocator to create the\n+                  --  return object in the heap or user-defined pool\n+                  --  (BIP_Alloc_Form = Global_Heap or User_Storage_Pool).\n+\n+                  --  ??? An unchecked type conversion must be made in the\n+                  --  case of assigning the access object formal to the\n+                  --  local access object, because a normal conversion would\n+                  --  be illegal in some cases (such as converting access-\n+                  --  to-unconstrained to access-to-constrained), but the\n+                  --  the unchecked conversion will presumably fail to work\n+                  --  right in just such cases. It's not clear at all how to\n+                  --  handle this. ???\n+\n+                  Alloc_Stmt :=\n+                    Make_If_Statement (Loc,\n+                      Condition =>\n+                        Make_Op_Eq (Loc,\n+                          Left_Opnd  =>\n+                            New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n+                          Right_Opnd =>\n+                            Make_Integer_Literal (Loc,\n+                              UI_From_Int (BIP_Allocation_Form'Pos\n+                                             (Caller_Allocation)))),\n+\n+                      Then_Statements => New_List (\n+                        Make_Assignment_Statement (Loc,\n+                          Name       =>\n+                            New_Occurrence_Of (Alloc_Obj_Id, Loc),\n+                          Expression =>\n+                            Unchecked_Convert_To\n+                              (Ref_Type,\n+                               New_Occurrence_Of (Obj_Acc_Formal, Loc)))),\n+\n+                      Elsif_Parts => New_List (\n+                        Make_Elsif_Part (Loc,\n+                          Condition =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  =>\n+                                New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n+                              Right_Opnd =>\n+                                Make_Integer_Literal (Loc,\n+                                  UI_From_Int (BIP_Allocation_Form'Pos\n+                                                 (Secondary_Stack)))),\n+\n+                          Then_Statements => New_List (\n+                            Make_Assignment_Statement (Loc,\n+                              Name       =>\n+                                New_Occurrence_Of (Alloc_Obj_Id, Loc),\n+                              Expression => SS_Allocator))),\n+\n+                        Make_Elsif_Part (Loc,\n+                          Condition =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  =>\n+                                New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n+                              Right_Opnd =>\n+                                Make_Integer_Literal (Loc,\n+                                  UI_From_Int (BIP_Allocation_Form'Pos\n+                                                 (Global_Heap)))),\n+\n+                          Then_Statements => New_List (\n+                            Build_Heap_Or_Pool_Allocator\n+                              (Temp_Id    => Alloc_Obj_Id,\n+                               Temp_Typ   => Ref_Type,\n+                               Func_Id    => Func_Id,\n+                               Ret_Typ    => Desig_Typ,\n+                               Alloc_Expr => Heap_Allocator))),\n+\n+                        --  ???If all is well, we can put the following\n+                        --  'elsif' in the 'else', but this is a useful\n+                        --  self-check in case caller and callee don't agree\n+                        --  on whether BIPAlloc and so on should be passed.\n+\n+                        Make_Elsif_Part (Loc,\n+                          Condition =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  =>\n+                                New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n+                              Right_Opnd =>\n+                                Make_Integer_Literal (Loc,\n+                                  UI_From_Int (BIP_Allocation_Form'Pos\n+                                                 (User_Storage_Pool)))),\n+\n+                          Then_Statements => New_List (\n+                            Pool_Decl,\n+                            Build_Heap_Or_Pool_Allocator\n+                              (Temp_Id    => Alloc_Obj_Id,\n+                               Temp_Typ   => Ref_Type,\n+                               Func_Id    => Func_Id,\n+                               Ret_Typ    => Desig_Typ,\n+                               Alloc_Expr => Pool_Allocator)))),\n+\n+                      --  Raise Program_Error if it's none of the above;\n+                      --  this is a compiler bug.\n+\n+                      Else_Statements => New_List (Guard_Except));\n+\n+                     --  If a separate initialization assignment was created\n+                     --  earlier, append that following the assignment of the\n+                     --  implicit access formal to the access object, to ensure\n+                     --  that the return object is initialized in that case. In\n+                     --  this situation, the target of the assignment must be\n+                     --  rewritten to denote a dereference of the access to the\n+                     --  return object passed in by the caller.\n+\n+                     if Present (Init_Stmt) then\n+                        Set_Name (Init_Stmt,\n+                          Make_Explicit_Dereference (Loc,\n+                            Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc)));\n+                        Set_Assignment_OK (Name (Init_Stmt));\n+\n+                        Append_To (Then_Statements (Alloc_Stmt), Init_Stmt);\n+                        Init_Stmt := Empty;\n+                     end if;\n+\n+                  Insert_Action (N, Alloc_Stmt, Suppress => All_Checks);\n+\n+                  --  From now on, the type of the return object is the\n+                  --  designated type.\n+\n+                  Set_Etype (Def_Id, Desig_Typ);\n+\n+                  --  Remember the local access object for use in the\n+                  --  dereference of the renaming created below.\n+\n+                  Obj_Acc_Formal := Alloc_Obj_Id;\n+               end;\n+\n+            --  When the function's subtype is unconstrained and a run-time\n+            --  test is not needed, we nevertheless need to build the return\n+            --  using the function's result subtype.\n+\n+            elsif not Is_Constrained (Underlying_Type (Etype (Func_Id))) then\n+               declare\n+                  Alloc_Obj_Id   : Entity_Id;\n+                  Alloc_Obj_Decl : Node_Id;\n+                  Ptr_Type_Decl  : Node_Id;\n+                  Ref_Type       : Entity_Id;\n+\n+               begin\n+                  --  Create an access type designating the function's\n+                  --  result subtype.\n+\n+                  Ref_Type := Make_Temporary (Loc, 'A');\n+\n+                  Ptr_Type_Decl :=\n+                    Make_Full_Type_Declaration (Loc,\n+                      Defining_Identifier => Ref_Type,\n+                      Type_Definition     =>\n+                        Make_Access_To_Object_Definition (Loc,\n+                          All_Present        => True,\n+                          Subtype_Indication =>\n+                            New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n+\n+                  Insert_Action (N, Ptr_Type_Decl);\n+\n+                  --  Create an access object initialized to the conversion\n+                  --  of the implicit access value passed in by the caller.\n+\n+                  Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+\n+                  --  See the ??? comment a few lines above about the use of\n+                  --  an unchecked conversion here.\n+\n+                  Alloc_Obj_Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Alloc_Obj_Id,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (Ref_Type, Loc),\n+                      Expression =>\n+                        Unchecked_Convert_To\n+                          (Ref_Type,\n+                           New_Occurrence_Of (Obj_Acc_Formal, Loc)));\n+\n+                  Insert_Action (N, Alloc_Obj_Decl, Suppress => All_Checks);\n+\n+                  --  Remember the local access object for use in the\n+                  --  dereference of the renaming created below.\n+\n+                  Obj_Acc_Formal := Alloc_Obj_Id;\n+               end;\n+            end if;\n+\n+            --  Initialize the object now that it has got its final subtype,\n+            --  but before rewriting it as a renaming.\n+\n+            if No (Expr_Q) then\n+               Default_Initialize_Object (Init_After);\n+\n+            elsif Is_Delayed_Aggregate (Expr_Q)\n+              and then not No_Initialization (N)\n+            then\n+               Convert_Aggr_In_Object_Decl (N);\n+\n+            elsif Present (Init_Stmt) then\n+               Insert_Action_After (Init_After, Init_Stmt);\n+               Set_Expression (N, Empty);\n+            end if;\n+\n+            --  Replace the return object declaration with a renaming of a\n+            --  dereference of the access value designating the return object.\n+\n+            Expr_Q :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Obj_Acc_Formal, Loc));\n+            Set_Etype (Expr_Q, Etype (Def_Id));\n+\n+            Rewrite_As_Renaming := True;\n+         end;\n+      end if;\n+\n       --  Final transformation - turn the object declaration into a renaming\n       --  if appropriate. If this is the completion of a deferred constant\n       --  declaration, then this transformation generates what would be\n@@ -7707,16 +8433,16 @@ package body Exp_Ch3 is\n       if Rewrite_As_Renaming then\n          Rewrite (N,\n            Make_Object_Renaming_Declaration (Loc,\n-             Defining_Identifier => Defining_Identifier (N),\n-             Subtype_Mark        => Obj_Def,\n+             Defining_Identifier => Def_Id,\n+             Subtype_Mark        => New_Occurrence_Of (Etype (Def_Id), Loc),\n              Name                => Expr_Q));\n \n          --  We do not analyze this renaming declaration, because all its\n          --  components have already been analyzed, and if we were to go\n          --  ahead and analyze it, we would in effect be trying to generate\n          --  another declaration of X, which won't do.\n \n-         Set_Renamed_Object (Defining_Identifier (N), Expr_Q);\n+         Set_Renamed_Object (Def_Id, Expr_Q);\n          Set_Analyzed (N);\n \n          --  We do need to deal with debug issues for this renaming"}, {"sha": "f7d43c4aa7ec34b2c6b43e8bbdab3b2cd75f04dd", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -113,13 +113,6 @@ package Exp_Ch3 is\n    --  Build the body of the equality function Body_Id for the untagged variant\n    --  record Typ with the given parameters specification list.\n \n-   procedure Ensure_Activation_Chain_And_Master (Obj_Decl : Node_Id);\n-   --  If tasks are being declared (or might be declared) by the given object\n-   --  declaration then ensure to have an activation chain defined for the\n-   --  tasks (has no effect if we already have one), and also that a Master\n-   --  variable is established (and that the appropriate enclosing construct\n-   --  is established as a task master).\n-\n    function Freeze_Type (N : Node_Id) return Boolean;\n    --  This function executes the freezing actions associated with the given\n    --  freeze type node N and returns True if the node is to be deleted. We"}, {"sha": "d6d9d008a55e5d6ef6b073ecd9754ea3fbe96103", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 45, "deletions": 812, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -5079,48 +5079,15 @@ package body Exp_Ch6 is\n    --  (in which case default initial values might need to be set)).\n \n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      function Build_Heap_Or_Pool_Allocator\n-        (Temp_Id    : Entity_Id;\n-         Temp_Typ   : Entity_Id;\n-         Func_Id    : Entity_Id;\n-         Ret_Typ    : Entity_Id;\n-         Alloc_Expr : Node_Id) return Node_Id;\n-      --  Create the statements necessary to allocate a return object on the\n-      --  heap or user-defined storage pool. The object may need finalization\n-      --  actions depending on the return type.\n-      --\n-      --    * Controlled case\n-      --\n-      --       if BIPfinalizationmaster = null then\n-      --          Temp_Id := <Alloc_Expr>;\n-      --       else\n-      --          declare\n-      --             type Ptr_Typ is access Ret_Typ;\n-      --             for Ptr_Typ'Storage_Pool use\n-      --                   Base_Pool (BIPfinalizationmaster.all).all;\n-      --             Local : Ptr_Typ;\n-      --\n-      --          begin\n-      --             procedure Allocate (...) is\n-      --             begin\n-      --                System.Storage_Pools.Subpools.Allocate_Any (...);\n-      --             end Allocate;\n-      --\n-      --             Local := <Alloc_Expr>;\n-      --             Temp_Id := Temp_Typ (Local);\n-      --          end;\n-      --       end if;\n-      --\n-      --    * Non-controlled case\n-      --\n-      --       Temp_Id := <Alloc_Expr>;\n-      --\n-      --  Temp_Id is the temporary which is used to reference the internally\n-      --  created object in all allocation forms. Temp_Typ is the type of the\n-      --  temporary. Func_Id is the enclosing function. Ret_Typ is the return\n-      --  type of Func_Id. Alloc_Expr is the actual allocator.\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Func_Id      : constant Entity_Id :=\n+                       Return_Applies_To (Return_Statement_Entity (N));\n+      Is_BIP_Func  : constant Boolean   :=\n+                       Is_Build_In_Place_Function (Func_Id);\n+      Ret_Obj_Id   : constant Entity_Id :=\n+                       First_Entity (Return_Statement_Entity (N));\n+      Ret_Obj_Decl : constant Node_Id   := Parent (Ret_Obj_Id);\n+      Ret_Typ      : constant Entity_Id := Etype (Func_Id);\n \n       function Move_Activation_Chain (Func_Id : Entity_Id) return Node_Id;\n       --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n@@ -5132,173 +5099,6 @@ package body Exp_Ch6 is\n       --  Func_Id is the entity of the function where the extended return\n       --  statement appears.\n \n-      ----------------------------------\n-      -- Build_Heap_Or_Pool_Allocator --\n-      ----------------------------------\n-\n-      function Build_Heap_Or_Pool_Allocator\n-        (Temp_Id    : Entity_Id;\n-         Temp_Typ   : Entity_Id;\n-         Func_Id    : Entity_Id;\n-         Ret_Typ    : Entity_Id;\n-         Alloc_Expr : Node_Id) return Node_Id\n-      is\n-      begin\n-         pragma Assert (Is_Build_In_Place_Function (Func_Id));\n-\n-         --  Processing for objects that require finalization actions\n-\n-         if Needs_Finalization (Ret_Typ) then\n-            declare\n-               Decls      : constant List_Id := New_List;\n-               Fin_Mas_Id : constant Entity_Id :=\n-                              Build_In_Place_Formal\n-                                (Func_Id, BIP_Finalization_Master);\n-               Orig_Expr  : constant Node_Id :=\n-                              New_Copy_Tree\n-                                (Source           => Alloc_Expr,\n-                                 Scopes_In_EWA_OK => True);\n-               Stmts      : constant List_Id := New_List;\n-               Desig_Typ  : Entity_Id;\n-               Local_Id   : Entity_Id;\n-               Pool_Id    : Entity_Id;\n-               Ptr_Typ    : Entity_Id;\n-\n-            begin\n-               --  Generate:\n-               --    Pool_Id renames Base_Pool (BIPfinalizationmaster.all).all;\n-\n-               Pool_Id := Make_Temporary (Loc, 'P');\n-\n-               Append_To (Decls,\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Pool_Id,\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (RTE (RE_Root_Storage_Pool), Loc),\n-                   Name                =>\n-                     Make_Explicit_Dereference (Loc,\n-                       Prefix =>\n-                         Make_Function_Call (Loc,\n-                           Name                   =>\n-                             New_Occurrence_Of (RTE (RE_Base_Pool), Loc),\n-                           Parameter_Associations => New_List (\n-                             Make_Explicit_Dereference (Loc,\n-                               Prefix =>\n-                                 New_Occurrence_Of (Fin_Mas_Id, Loc)))))));\n-\n-               --  Create an access type which uses the storage pool of the\n-               --  caller's master. This additional type is necessary because\n-               --  the finalization master cannot be associated with the type\n-               --  of the temporary. Otherwise the secondary stack allocation\n-               --  will fail.\n-\n-               Desig_Typ := Ret_Typ;\n-\n-               --  Ensure that the build-in-place machinery uses a fat pointer\n-               --  when allocating an unconstrained array on the heap. In this\n-               --  case the result object type is a constrained array type even\n-               --  though the function type is unconstrained.\n-\n-               if Ekind (Desig_Typ) = E_Array_Subtype then\n-                  Desig_Typ := Base_Type (Desig_Typ);\n-               end if;\n-\n-               --  Generate:\n-               --    type Ptr_Typ is access Desig_Typ;\n-\n-               Ptr_Typ := Make_Temporary (Loc, 'P');\n-\n-               Append_To (Decls,\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Ptr_Typ,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       Subtype_Indication =>\n-                         New_Occurrence_Of (Desig_Typ, Loc))));\n-\n-               --  Perform minor decoration in order to set the master and the\n-               --  storage pool attributes.\n-\n-               Mutate_Ekind                (Ptr_Typ, E_Access_Type);\n-               Set_Finalization_Master     (Ptr_Typ, Fin_Mas_Id);\n-               Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n-\n-               --  Create the temporary, generate:\n-               --    Local_Id : Ptr_Typ;\n-\n-               Local_Id := Make_Temporary (Loc, 'T');\n-\n-               Append_To (Decls,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Local_Id,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Ptr_Typ, Loc)));\n-\n-               --  Allocate the object, generate:\n-               --    Local_Id := <Alloc_Expr>;\n-\n-               Append_To (Stmts,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => New_Occurrence_Of (Local_Id, Loc),\n-                   Expression => Alloc_Expr));\n-\n-               --  Generate:\n-               --    Temp_Id := Temp_Typ (Local_Id);\n-\n-               Append_To (Stmts,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => New_Occurrence_Of (Temp_Id, Loc),\n-                   Expression =>\n-                     Unchecked_Convert_To (Temp_Typ,\n-                       New_Occurrence_Of (Local_Id, Loc))));\n-\n-               --  Wrap the allocation in a block. This is further conditioned\n-               --  by checking the caller finalization master at runtime. A\n-               --  null value indicates a non-existent master, most likely due\n-               --  to a Finalize_Storage_Only allocation.\n-\n-               --  Generate:\n-               --    if BIPfinalizationmaster = null then\n-               --       Temp_Id := <Orig_Expr>;\n-               --    else\n-               --       declare\n-               --          <Decls>\n-               --       begin\n-               --          <Stmts>\n-               --       end;\n-               --    end if;\n-\n-               return\n-                 Make_If_Statement (Loc,\n-                   Condition       =>\n-                     Make_Op_Eq (Loc,\n-                       Left_Opnd  => New_Occurrence_Of (Fin_Mas_Id, Loc),\n-                       Right_Opnd => Make_Null (Loc)),\n-\n-                   Then_Statements => New_List (\n-                     Make_Assignment_Statement (Loc,\n-                       Name       => New_Occurrence_Of (Temp_Id, Loc),\n-                       Expression => Orig_Expr)),\n-\n-                   Else_Statements => New_List (\n-                     Make_Block_Statement (Loc,\n-                       Declarations               => Decls,\n-                       Handled_Statement_Sequence =>\n-                         Make_Handled_Sequence_Of_Statements (Loc,\n-                           Statements => Stmts))));\n-            end;\n-\n-         --  For all other cases, generate:\n-         --    Temp_Id := <Alloc_Expr>;\n-\n-         else\n-            return\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Occurrence_Of (Temp_Id, Loc),\n-                Expression => Alloc_Expr);\n-         end if;\n-      end Build_Heap_Or_Pool_Allocator;\n-\n       ---------------------------\n       -- Move_Activation_Chain --\n       ---------------------------\n@@ -5331,15 +5131,6 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Func_Id      : constant Entity_Id :=\n-                       Return_Applies_To (Return_Statement_Entity (N));\n-      Is_BIP_Func  : constant Boolean   :=\n-                       Is_Build_In_Place_Function (Func_Id);\n-      Ret_Obj_Id   : constant Entity_Id :=\n-                       First_Entity (Return_Statement_Entity (N));\n-      Ret_Obj_Decl : constant Node_Id   := Parent (Ret_Obj_Id);\n-      Ret_Typ      : constant Entity_Id := Etype (Func_Id);\n-\n       Exp         : Node_Id;\n       HSS         : Node_Id;\n       Result      : Node_Id;\n@@ -5508,13 +5299,6 @@ package body Exp_Ch6 is\n             end;\n          end if;\n \n-         --  Build a simple_return_statement that returns the return object\n-\n-         Return_Stmt :=\n-           Make_Simple_Return_Statement (Loc,\n-             Expression => New_Occurrence_Of (Ret_Obj_Id, Loc));\n-         Append_To (Stmts, Return_Stmt);\n-\n          HSS := Make_Handled_Sequence_Of_Statements (Loc, Stmts);\n       end if;\n \n@@ -5535,571 +5319,12 @@ package body Exp_Ch6 is\n          Set_Identifier\n            (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n \n-         --  If the object decl was already rewritten as a renaming, then we\n-         --  don't want to do the object allocation and transformation of\n-         --  the return object declaration to a renaming. This case occurs\n-         --  when the return object is initialized by a call to another\n-         --  build-in-place function, and that function is responsible for\n-         --  the allocation of the return object.\n-\n-         if Is_BIP_Func\n-           and then Nkind (Ret_Obj_Decl) = N_Object_Renaming_Declaration\n-         then\n-            pragma Assert\n-              (Nkind (Original_Node (Ret_Obj_Decl)) = N_Object_Declaration\n-                and then\n-\n-                  --  It is a regular BIP object declaration\n-\n-                  (Is_Build_In_Place_Function_Call\n-                     (Expression (Original_Node (Ret_Obj_Decl)))\n-\n-                  --  It is a BIP object declaration that displaces the pointer\n-                  --  to the object to reference a converted interface type.\n-\n-                  or else\n-                    Present (Unqual_BIP_Iface_Function_Call\n-                              (Expression (Original_Node (Ret_Obj_Decl))))));\n-\n-         elsif Is_BIP_Func then\n-\n-            --  Locate the implicit access parameter associated with the\n-            --  caller-supplied return object and convert the return\n-            --  statement's return object declaration to a renaming of a\n-            --  dereference of the access parameter. If the return object's\n-            --  declaration includes an expression that has not already been\n-            --  expanded as separate assignments, then add an assignment\n-            --  statement to ensure the return object gets initialized.\n-\n-            --    declare\n-            --       Result : T [:= <expression>];\n-            --    begin\n-            --       ...\n-\n-            --  is converted to\n-\n-            --    declare\n-            --       Result : T renames FuncRA.all;\n-            --       [Result := <expression;]\n-            --    begin\n-            --       ...\n-\n-            declare\n-               Ret_Obj_Expr : constant Node_Id   := Expression (Ret_Obj_Decl);\n-               Ret_Obj_Typ  : constant Entity_Id := Etype (Ret_Obj_Id);\n-\n-               Init_Assignment  : Node_Id := Empty;\n-               Obj_Acc_Formal   : Entity_Id;\n-               Obj_Acc_Deref    : Node_Id;\n-               Obj_Alloc_Formal : Entity_Id;\n-\n-            begin\n-               --  Retrieve the implicit access parameter passed by the caller\n-\n-               Obj_Acc_Formal :=\n-                 Build_In_Place_Formal (Func_Id, BIP_Object_Access);\n-\n-               --  If the return object's declaration includes an expression\n-               --  and the declaration isn't marked as No_Initialization, then\n-               --  we need to generate an assignment to the object and insert\n-               --  it after the declaration before rewriting it as a renaming\n-               --  (otherwise we'll lose the initialization). The case where\n-               --  the result type is an interface (or class-wide interface)\n-               --  is also excluded because the context of the function call\n-               --  must be unconstrained, so the initialization will always\n-               --  be done as part of an allocator evaluation (storage pool\n-               --  or secondary stack), never to a constrained target object\n-               --  passed in by the caller. Besides the assignment being\n-               --  unneeded in this case, it avoids problems with trying to\n-               --  generate a dispatching assignment when the return expression\n-               --  is a nonlimited descendant of a limited interface (the\n-               --  interface has no assignment operation).\n-\n-               if Present (Ret_Obj_Expr)\n-                 and then not No_Initialization (Ret_Obj_Decl)\n-                 and then not Is_Interface (Ret_Obj_Typ)\n-               then\n-                  Init_Assignment :=\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Ret_Obj_Id, Loc),\n-                      Expression =>\n-                        New_Copy_Tree\n-                          (Source           => Ret_Obj_Expr,\n-                           Scopes_In_EWA_OK => True));\n-\n-                  Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n-                  Set_Assignment_OK (Name (Init_Assignment));\n-                  Set_No_Ctrl_Actions (Init_Assignment);\n-\n-                  Set_Parent (Name (Init_Assignment), Init_Assignment);\n-                  Set_Parent (Expression (Init_Assignment), Init_Assignment);\n-\n-                  Set_Expression (Ret_Obj_Decl, Empty);\n-\n-                  if Is_Class_Wide_Type (Etype (Ret_Obj_Id))\n-                    and then not Is_Class_Wide_Type\n-                                   (Etype (Expression (Init_Assignment)))\n-                  then\n-                     Rewrite (Expression (Init_Assignment),\n-                       Make_Type_Conversion (Loc,\n-                         Subtype_Mark =>\n-                           New_Occurrence_Of (Etype (Ret_Obj_Id), Loc),\n-                         Expression   =>\n-                           Relocate_Node (Expression (Init_Assignment))));\n-                  end if;\n-\n-                  --  In the case of functions where the calling context can\n-                  --  determine the form of allocation needed, initialization\n-                  --  is done with each part of the if statement that handles\n-                  --  the different forms of allocation (this is true for\n-                  --  unconstrained, tagged, and controlled result subtypes).\n-\n-                  if not Needs_BIP_Alloc_Form (Func_Id) then\n-                     Insert_After (Ret_Obj_Decl, Init_Assignment);\n-                  end if;\n-               end if;\n-\n-               --  When the function's subtype is unconstrained, a run-time\n-               --  test may be needed to decide the form of allocation to use\n-               --  for the return object. The function has an implicit formal\n-               --  parameter indicating this. If the BIP_Alloc_Form formal has\n-               --  the value one, then the caller has passed access to an\n-               --  existing object for use as the return object. If the value\n-               --  is two, then the return object must be allocated on the\n-               --  secondary stack. Otherwise, the object must be allocated in\n-               --  a storage pool. We generate an if statement to test the\n-               --  implicit allocation formal and initialize a local access\n-               --  value appropriately, creating allocators in the secondary\n-               --  stack and global heap cases. The special formal also exists\n-               --  and must be tested when the function has a tagged result,\n-               --  even when the result subtype is constrained, because in\n-               --  general such functions can be called in dispatching contexts\n-               --  and must be handled similarly to functions with a class-wide\n-               --  result.\n-\n-               if Needs_BIP_Alloc_Form (Func_Id) then\n-                  Obj_Alloc_Formal :=\n-                    Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n-\n-                  declare\n-                     Pool_Id        : constant Entity_Id :=\n-                                        Make_Temporary (Loc, 'P');\n-                     Alloc_Obj_Id   : Entity_Id;\n-                     Alloc_Obj_Decl : Node_Id;\n-                     Alloc_If_Stmt  : Node_Id;\n-                     Guard_Except   : Node_Id;\n-                     Heap_Allocator : Node_Id;\n-                     Pool_Decl      : Node_Id;\n-                     Pool_Allocator : Node_Id;\n-                     Ptr_Type_Decl  : Node_Id;\n-                     Ref_Type       : Entity_Id;\n-                     SS_Allocator   : Node_Id;\n-\n-                  begin\n-                     --  Create an access type designating the function's\n-                     --  result subtype.\n-\n-                     Ref_Type := Make_Temporary (Loc, 'A');\n-\n-                     Ptr_Type_Decl :=\n-                       Make_Full_Type_Declaration (Loc,\n-                         Defining_Identifier => Ref_Type,\n-                         Type_Definition     =>\n-                           Make_Access_To_Object_Definition (Loc,\n-                             All_Present        => True,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n-\n-                     Insert_Before (Ret_Obj_Decl, Ptr_Type_Decl);\n-\n-                     --  Create an access object that will be initialized to an\n-                     --  access value denoting the return object, either coming\n-                     --  from an implicit access value passed in by the caller\n-                     --  or from the result of an allocator.\n-\n-                     Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n-                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n-\n-                     Alloc_Obj_Decl :=\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Alloc_Obj_Id,\n-                         Object_Definition   =>\n-                           New_Occurrence_Of (Ref_Type, Loc));\n-\n-                     Insert_Before (Ret_Obj_Decl, Alloc_Obj_Decl);\n-\n-                     --  Create allocators for both the secondary stack and\n-                     --  global heap. If there's an initialization expression,\n-                     --  then create these as initialized allocators.\n-\n-                     if Present (Ret_Obj_Expr)\n-                       and then not No_Initialization (Ret_Obj_Decl)\n-                     then\n-                        --  Always use the type of the expression for the\n-                        --  qualified expression, rather than the result type.\n-                        --  In general we cannot always use the result type\n-                        --  for the allocator, because the expression might be\n-                        --  of a specific type, such as in the case of an\n-                        --  aggregate or even a nonlimited object when the\n-                        --  result type is a limited class-wide interface type.\n-\n-                        Heap_Allocator :=\n-                          Make_Allocator (Loc,\n-                            Expression =>\n-                              Make_Qualified_Expression (Loc,\n-                                Subtype_Mark =>\n-                                  New_Occurrence_Of\n-                                    (Etype (Ret_Obj_Expr), Loc),\n-                                Expression   =>\n-                                  New_Copy_Tree\n-                                    (Source           => Ret_Obj_Expr,\n-                                     Scopes_In_EWA_OK => True)));\n-\n-                     else\n-                        --  If the function returns a class-wide type we cannot\n-                        --  use the return type for the allocator. Instead we\n-                        --  use the type of the expression, which must be an\n-                        --  aggregate of a definite type.\n-\n-                        if Is_Class_Wide_Type (Ret_Obj_Typ) then\n-                           Heap_Allocator :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Occurrence_Of\n-                                   (Etype (Ret_Obj_Expr), Loc));\n-                        else\n-                           Heap_Allocator :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Occurrence_Of (Ret_Obj_Typ, Loc));\n-                        end if;\n-\n-                        --  If the object requires default initialization then\n-                        --  that will happen later following the elaboration of\n-                        --  the object renaming. If we don't turn it off here\n-                        --  then the object will be default initialized twice.\n-\n-                        Set_No_Initialization (Heap_Allocator);\n-                     end if;\n-\n-                     --  Set the flag indicating that the allocator came from\n-                     --  a build-in-place return statement, so we can avoid\n-                     --  adjusting the allocated object. Note that this flag\n-                     --  will be inherited by the copies made below.\n-\n-                     Set_Alloc_For_BIP_Return (Heap_Allocator);\n-\n-                     --  The Pool_Allocator is just like the Heap_Allocator,\n-                     --  except we set Storage_Pool and Procedure_To_Call so\n-                     --  it will use the user-defined storage pool.\n-\n-                     Pool_Allocator :=\n-                       New_Copy_Tree\n-                         (Source           => Heap_Allocator,\n-                          Scopes_In_EWA_OK => True);\n-\n-                     pragma Assert (Alloc_For_BIP_Return (Pool_Allocator));\n-\n-                     --  Do not generate the renaming of the build-in-place\n-                     --  pool parameter on ZFP because the parameter is not\n-                     --  created in the first place.\n-\n-                     if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n-                        Pool_Decl :=\n-                          Make_Object_Renaming_Declaration (Loc,\n-                            Defining_Identifier => Pool_Id,\n-                            Subtype_Mark        =>\n-                              New_Occurrence_Of\n-                                (RTE (RE_Root_Storage_Pool), Loc),\n-                            Name                =>\n-                              Make_Explicit_Dereference (Loc,\n-                                New_Occurrence_Of\n-                                  (Build_In_Place_Formal\n-                                     (Func_Id, BIP_Storage_Pool), Loc)));\n-                        Set_Storage_Pool (Pool_Allocator, Pool_Id);\n-                        Set_Procedure_To_Call\n-                          (Pool_Allocator, RTE (RE_Allocate_Any));\n-                     else\n-                        Pool_Decl := Make_Null_Statement (Loc);\n-                     end if;\n-\n-                     --  If the No_Allocators restriction is active, then only\n-                     --  an allocator for secondary stack allocation is needed.\n-                     --  It's OK for such allocators to have Comes_From_Source\n-                     --  set to False, because gigi knows not to flag them as\n-                     --  being a violation of No_Implicit_Heap_Allocations.\n-\n-                     if Restriction_Active (No_Allocators) then\n-                        SS_Allocator   := Heap_Allocator;\n-                        Heap_Allocator := Make_Null (Loc);\n-                        Pool_Allocator := Make_Null (Loc);\n-\n-                     --  Otherwise the heap and pool allocators may be needed,\n-                     --  so we make another allocator for secondary stack\n-                     --  allocation.\n-\n-                     else\n-                        SS_Allocator :=\n-                          New_Copy_Tree\n-                            (Source           => Heap_Allocator,\n-                             Scopes_In_EWA_OK => True);\n-\n-                        pragma Assert (Alloc_For_BIP_Return (SS_Allocator));\n-\n-                        --  The heap and pool allocators are marked as\n-                        --  Comes_From_Source since they correspond to an\n-                        --  explicit user-written allocator (that is, it will\n-                        --  only be executed on behalf of callers that call the\n-                        --  function as initialization for such an allocator).\n-                        --  Prevents errors when No_Implicit_Heap_Allocations\n-                        --  is in force.\n-\n-                        Set_Comes_From_Source (Heap_Allocator, True);\n-                        Set_Comes_From_Source (Pool_Allocator, True);\n-                     end if;\n-\n-                     --  The allocator is returned on the secondary stack\n-\n-                     Check_Restriction (No_Secondary_Stack, N);\n-                     Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n-                     Set_Procedure_To_Call\n-                       (SS_Allocator, RTE (RE_SS_Allocate));\n-\n-                     --  The allocator is returned on the secondary stack,\n-                     --  so indicate that the function return, as well as\n-                     --  all blocks that encloses the allocator, must not\n-                     --  release it. The flags must be set now because\n-                     --  the decision to use the secondary stack is done\n-                     --  very late in the course of expanding the return\n-                     --  statement, past the point where these flags are\n-                     --  normally set.\n-\n-                     Set_Uses_Sec_Stack (Func_Id);\n-                     Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n-                     Set_Sec_Stack_Needed_For_Return\n-                       (Return_Statement_Entity (N));\n-                     Set_Enclosing_Sec_Stack_Return (N);\n-\n-                     --  Guard against poor expansion on the caller side by\n-                     --  using a raise statement to catch out-of-range values\n-                     --  of formal parameter BIP_Alloc_Form.\n-\n-                     if Exceptions_OK then\n-                        Guard_Except :=\n-                          Make_Raise_Program_Error (Loc,\n-                            Reason => PE_Build_In_Place_Mismatch);\n-                     else\n-                        Guard_Except := Make_Null_Statement (Loc);\n-                     end if;\n-\n-                     --  Create an if statement to test the BIP_Alloc_Form\n-                     --  formal and initialize the access object to either the\n-                     --  BIP_Object_Access formal (BIP_Alloc_Form =\n-                     --  Caller_Allocation), the result of allocating the\n-                     --  object in the secondary stack (BIP_Alloc_Form =\n-                     --  Secondary_Stack), or else an allocator to create the\n-                     --  return object in the heap or user-defined pool\n-                     --  (BIP_Alloc_Form = Global_Heap or User_Storage_Pool).\n-\n-                     --  ??? An unchecked type conversion must be made in the\n-                     --  case of assigning the access object formal to the\n-                     --  local access object, because a normal conversion would\n-                     --  be illegal in some cases (such as converting access-\n-                     --  to-unconstrained to access-to-constrained), but the\n-                     --  the unchecked conversion will presumably fail to work\n-                     --  right in just such cases. It's not clear at all how to\n-                     --  handle this. ???\n-\n-                     Alloc_If_Stmt :=\n-                       Make_If_Statement (Loc,\n-                         Condition =>\n-                           Make_Op_Eq (Loc,\n-                             Left_Opnd  =>\n-                               New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n-                             Right_Opnd =>\n-                               Make_Integer_Literal (Loc,\n-                                 UI_From_Int (BIP_Allocation_Form'Pos\n-                                                (Caller_Allocation)))),\n-\n-                         Then_Statements => New_List (\n-                           Make_Assignment_Statement (Loc,\n-                             Name       =>\n-                               New_Occurrence_Of (Alloc_Obj_Id, Loc),\n-                             Expression =>\n-                               Unchecked_Convert_To\n-                                 (Ref_Type,\n-                                  New_Occurrence_Of (Obj_Acc_Formal, Loc)))),\n-\n-                         Elsif_Parts => New_List (\n-                           Make_Elsif_Part (Loc,\n-                             Condition =>\n-                               Make_Op_Eq (Loc,\n-                                 Left_Opnd  =>\n-                                   New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n-                                 Right_Opnd =>\n-                                   Make_Integer_Literal (Loc,\n-                                     UI_From_Int (BIP_Allocation_Form'Pos\n-                                                    (Secondary_Stack)))),\n-\n-                             Then_Statements => New_List (\n-                               Make_Assignment_Statement (Loc,\n-                                 Name       =>\n-                                   New_Occurrence_Of (Alloc_Obj_Id, Loc),\n-                                 Expression => SS_Allocator))),\n-\n-                           Make_Elsif_Part (Loc,\n-                             Condition =>\n-                               Make_Op_Eq (Loc,\n-                                 Left_Opnd  =>\n-                                   New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n-                                 Right_Opnd =>\n-                                   Make_Integer_Literal (Loc,\n-                                     UI_From_Int (BIP_Allocation_Form'Pos\n-                                                    (Global_Heap)))),\n-\n-                             Then_Statements => New_List (\n-                               Build_Heap_Or_Pool_Allocator\n-                                 (Temp_Id    => Alloc_Obj_Id,\n-                                  Temp_Typ   => Ref_Type,\n-                                  Func_Id    => Func_Id,\n-                                  Ret_Typ    => Ret_Obj_Typ,\n-                                  Alloc_Expr => Heap_Allocator))),\n-\n-                           --  ???If all is well, we can put the following\n-                           --  'elsif' in the 'else', but this is a useful\n-                           --  self-check in case caller and callee don't agree\n-                           --  on whether BIPAlloc and so on should be passed.\n-\n-                           Make_Elsif_Part (Loc,\n-                             Condition =>\n-                               Make_Op_Eq (Loc,\n-                                 Left_Opnd  =>\n-                                   New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n-                                 Right_Opnd =>\n-                                   Make_Integer_Literal (Loc,\n-                                     UI_From_Int (BIP_Allocation_Form'Pos\n-                                                    (User_Storage_Pool)))),\n-\n-                             Then_Statements => New_List (\n-                               Pool_Decl,\n-                               Build_Heap_Or_Pool_Allocator\n-                                 (Temp_Id    => Alloc_Obj_Id,\n-                                  Temp_Typ   => Ref_Type,\n-                                  Func_Id    => Func_Id,\n-                                  Ret_Typ    => Ret_Obj_Typ,\n-                                  Alloc_Expr => Pool_Allocator)))),\n-\n-                         --  Raise Program_Error if it's none of the above;\n-                         --  this is a compiler bug.\n-\n-                         Else_Statements => New_List (Guard_Except));\n-\n-                     --  If a separate initialization assignment was created\n-                     --  earlier, append that following the assignment of the\n-                     --  implicit access formal to the access object, to ensure\n-                     --  that the return object is initialized in that case. In\n-                     --  this situation, the target of the assignment must be\n-                     --  rewritten to denote a dereference of the access to the\n-                     --  return object passed in by the caller.\n-\n-                     if Present (Init_Assignment) then\n-                        Rewrite (Name (Init_Assignment),\n-                          Make_Explicit_Dereference (Loc,\n-                            Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc)));\n-                        pragma Assert\n-                          (Assignment_OK\n-                             (Original_Node (Name (Init_Assignment))));\n-                        Set_Assignment_OK (Name (Init_Assignment));\n-\n-                        Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n-\n-                        Append_To\n-                          (Then_Statements (Alloc_If_Stmt), Init_Assignment);\n-                     end if;\n-\n-                     Insert_Before (Ret_Obj_Decl, Alloc_If_Stmt);\n-\n-                     --  Remember the local access object for use in the\n-                     --  dereference of the renaming created below.\n-\n-                     Obj_Acc_Formal := Alloc_Obj_Id;\n-                  end;\n-\n-               --  When the function's subtype is unconstrained and a run-time\n-               --  test is not needed, we nevertheless need to build the return\n-               --  using the function's result subtype.\n-\n-               elsif not Is_Constrained (Underlying_Type (Etype (Func_Id)))\n-               then\n-                  declare\n-                     Alloc_Obj_Id   : Entity_Id;\n-                     Alloc_Obj_Decl : Node_Id;\n-                     Ptr_Type_Decl  : Node_Id;\n-                     Ref_Type       : Entity_Id;\n-\n-                  begin\n-                     --  Create an access type designating the function's\n-                     --  result subtype.\n-\n-                     Ref_Type := Make_Temporary (Loc, 'A');\n-\n-                     Ptr_Type_Decl :=\n-                       Make_Full_Type_Declaration (Loc,\n-                         Defining_Identifier => Ref_Type,\n-                         Type_Definition     =>\n-                           Make_Access_To_Object_Definition (Loc,\n-                             All_Present        => True,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n-\n-                     Insert_Before (Ret_Obj_Decl, Ptr_Type_Decl);\n-\n-                     --  Create an access object initialized to the conversion\n-                     --  of the implicit access value passed in by the caller.\n-\n-                     Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n-                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n-\n-                     --  See the ??? comment a few lines above about the use of\n-                     --  an unchecked conversion here.\n-\n-                     Alloc_Obj_Decl :=\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Alloc_Obj_Id,\n-                         Object_Definition   =>\n-                           New_Occurrence_Of (Ref_Type, Loc),\n-                         Expression =>\n-                           Unchecked_Convert_To\n-                             (Ref_Type,\n-                              New_Occurrence_Of (Obj_Acc_Formal, Loc)));\n-\n-                     Insert_Before (Ret_Obj_Decl, Alloc_Obj_Decl);\n-\n-                     --  Remember the local access object for use in the\n-                     --  dereference of the renaming created below.\n-\n-                     Obj_Acc_Formal := Alloc_Obj_Id;\n-                  end;\n-               end if;\n-\n-               --  Replace the return object declaration with a renaming of a\n-               --  dereference of the access value designating the return\n-               --  object.\n-\n-               Obj_Acc_Deref :=\n-                 Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Occurrence_Of (Obj_Acc_Formal, Loc));\n-\n-               Rewrite (Ret_Obj_Decl,\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Ret_Obj_Id,\n-                   Access_Definition   => Empty,\n-                   Subtype_Mark        => New_Occurrence_Of (Ret_Obj_Typ, Loc),\n-                   Name                => Obj_Acc_Deref));\n+         --  Build a simple_return_statement that returns the return object\n \n-               Set_Renamed_Object (Ret_Obj_Id, Obj_Acc_Deref);\n-            end;\n-         end if;\n+         Return_Stmt :=\n+           Make_Simple_Return_Statement (Loc,\n+             Expression => New_Occurrence_Of (Ret_Obj_Id, Loc));\n+         Append_To (Stmts, Return_Stmt);\n \n       --  Case where we do not need to build a block. But we're about to drop\n       --  Return_Object_Declarations on the floor, so assert that it contains\n@@ -6124,9 +5349,7 @@ package body Exp_Ch6 is\n       --  before an object is returned. A predicate that applies to the return\n       --  subtype is checked immediately before an object is returned.\n \n-      --  Suppress access checks to avoid generating extra checks for b-i-p.\n-\n-      Analyze (N, Suppress => Access_Check);\n+      Analyze (N);\n    end Expand_N_Extended_Return_Statement;\n \n    ----------------------------\n@@ -8518,26 +7741,6 @@ package body Exp_Ch6 is\n       end if;\n    end Install_Class_Preconditions_Check;\n \n-   -----------------------------------\n-   -- Is_Build_In_Place_Result_Type --\n-   -----------------------------------\n-\n-   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n-   begin\n-      if not Expander_Active then\n-         return False;\n-      end if;\n-\n-      --  In Ada 2005 all functions with an inherently limited return type\n-      --  must be handled using a build-in-place profile, including the case\n-      --  of a function with a limited interface result, where the function\n-      --  may return objects of nonlimited descendants.\n-\n-      return Is_Limited_View (Typ)\n-        and then Ada_Version >= Ada_2005\n-        and then not Debug_Flag_Dot_L;\n-   end Is_Build_In_Place_Result_Type;\n-\n    ------------------------------\n    -- Is_Build_In_Place_Entity --\n    ------------------------------\n@@ -8655,6 +7858,36 @@ package body Exp_Ch6 is\n       end;\n    end Is_Build_In_Place_Function_Call;\n \n+   -----------------------------------\n+   -- Is_Build_In_Place_Result_Type --\n+   -----------------------------------\n+\n+   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n+   begin\n+      if not Expander_Active then\n+         return False;\n+      end if;\n+\n+      --  In Ada 2005 all functions with an inherently limited return type\n+      --  must be handled using a build-in-place profile, including the case\n+      --  of a function with a limited interface result, where the function\n+      --  may return objects of nonlimited descendants.\n+\n+      return Is_Limited_View (Typ)\n+        and then Ada_Version >= Ada_2005\n+        and then not Debug_Flag_Dot_L;\n+   end Is_Build_In_Place_Result_Type;\n+\n+   -------------------------------------\n+   -- Is_Build_In_Place_Return_Object --\n+   -------------------------------------\n+\n+   function Is_Build_In_Place_Return_Object (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Return_Object (E)\n+        and then Is_Build_In_Place_Function (Return_Applies_To (Scope (E)));\n+   end Is_Build_In_Place_Return_Object;\n+\n    -----------------------\n    -- Is_Null_Procedure --\n    -----------------------"}, {"sha": "19d0bc3ff694fb829c9773189d80561fa42abd8d", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -127,22 +127,6 @@ package Exp_Ch6 is\n    function Is_Build_In_Place_Entity (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if E is a BIP entity.\n \n-   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-318-02): Returns True if functions returning the type use\n-   --  build-in-place protocols. For inherently limited types, this must be\n-   --  True in >= Ada 2005, and must be False in Ada 95. For other types, it\n-   --  can be True or False, and the decision should be based on efficiency,\n-   --  and should be the same for all language versions, so that mixed-dialect\n-   --  programs will work.\n-   --\n-   --  For inherently limited types in Ada 2005, True means that calls will\n-   --  actually be build-in-place in all cases. For other types, build-in-place\n-   --  will be used when possible, but we need to make a copy in some\n-   --  cases. For example, for \"X := F(...);\" if F can see X, or if F can\n-   --  propagate exceptions, we need to store its result in a temp in general,\n-   --  and copy the temp into X. Also, for \"return Global_Var;\" Global_Var\n-   --  needs to be copied into the function result object.\n-\n    function Is_Build_In_Place_Function (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if E denotes a function, generic\n    --  function, or access-to-function type for which\n@@ -155,6 +139,15 @@ package Exp_Ch6 is\n    --  that requires handling as a build-in-place call (possibly qualified or\n    --  converted).\n \n+   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Returns True if functions returning the type use\n+   --  build-in-place protocols. For inherently limited types, this must be\n+   --  True in >= Ada 2005 and must be False in Ada 95.\n+\n+   function Is_Build_In_Place_Return_Object (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Return True is E is a return object of a function\n+   --  that uses build-in-place protocols.\n+\n    function Is_Null_Procedure (Subp : Entity_Id) return Boolean;\n    --  Predicate to recognize stubbed procedures and null procedures, which\n    --  can be inlined unconditionally in all cases.\n@@ -272,4 +265,7 @@ package Exp_Ch6 is\n    --  to reference the secondary dispatch table of an interface; otherwise\n    --  return Empty.\n \n+private\n+   pragma Inline (Is_Build_In_Place_Return_Object);\n+\n end Exp_Ch6;"}, {"sha": "076648227914b0d21e4545ac5090fa41471fe995", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -441,10 +441,6 @@ package body Exp_Ch7 is\n    --  of the formal of Proc, or force a conversion to the class-wide type in\n    --  the case where the operation is abstract.\n \n-   function Enclosing_Function (E : Entity_Id) return Entity_Id;\n-   --  Given an arbitrary entity, traverse the scope chain looking for the\n-   --  first enclosing function. Return Empty if no function was found.\n-\n    function Make_Call\n      (Loc       : Source_Ptr;\n       Proc_Id   : Entity_Id;\n@@ -3431,7 +3427,9 @@ package body Exp_Ch7 is\n \n             if Is_Return_Object (Obj_Id) then\n                declare\n-                  Func_Id : constant Entity_Id := Enclosing_Function (Obj_Id);\n+                  Func_Id : constant Entity_Id :=\n+                              Return_Applies_To (Scope (Obj_Id));\n+\n                begin\n                   if Is_Build_In_Place_Function (Func_Id)\n                     and then Needs_BIP_Finalization_Master (Func_Id)\n@@ -5084,26 +5082,6 @@ package body Exp_Ch7 is\n       end if;\n    end Convert_View;\n \n-   ------------------------\n-   -- Enclosing_Function --\n-   ------------------------\n-\n-   function Enclosing_Function (E : Entity_Id) return Entity_Id is\n-      Func_Id : Entity_Id;\n-\n-   begin\n-      Func_Id := E;\n-      while Present (Func_Id) and then Func_Id /= Standard_Standard loop\n-         if Ekind (Func_Id) = E_Function then\n-            return Func_Id;\n-         end if;\n-\n-         Func_Id := Scope (Func_Id);\n-      end loop;\n-\n-      return Empty;\n-   end Enclosing_Function;\n-\n    -------------------------------\n    -- Establish_Transient_Scope --\n    -------------------------------"}, {"sha": "29969b3aa22447424e8eaf4c92d41a50b5f8d4ed", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -4043,7 +4043,6 @@ package body Sem_Ch3 is\n \n       Prev_Entity       : Entity_Id := Empty;\n       Related_Id        : Entity_Id;\n-      Full_View_Present : Boolean := False;\n \n    --  Start of processing for Analyze_Object_Declaration\n \n@@ -4732,28 +4731,32 @@ package body Sem_Ch3 is\n                Act_T := Find_Type_Of_Object (Object_Definition (N), N);\n             end if;\n \n-            --  Propagate attributes to full view when needed\n+            if Act_T /= T then\n+               declare\n+                  Full_View_Present : constant Boolean :=\n+                    Is_Private_Type (Act_T)\n+                      and then Present (Full_View (Act_T));\n+                  --  Propagate attributes to full view when needed\n \n-            Set_Is_Constr_Subt_For_U_Nominal (Act_T);\n+               begin\n+                  Set_Is_Constr_Subt_For_U_Nominal (Act_T);\n \n-            if Is_Private_Type (Act_T) and then Present (Full_View (Act_T))\n-            then\n-               Full_View_Present := True;\n-            end if;\n+                  if Full_View_Present then\n+                     Set_Is_Constr_Subt_For_U_Nominal (Full_View (Act_T));\n+                  end if;\n \n-            if Full_View_Present then\n-               Set_Is_Constr_Subt_For_U_Nominal (Full_View (Act_T));\n-            end if;\n+                  if Aliased_Present (N) then\n+                     Set_Is_Constr_Subt_For_UN_Aliased (Act_T);\n \n-            if Aliased_Present (N) then\n-               Set_Is_Constr_Subt_For_UN_Aliased (Act_T);\n+                     if Full_View_Present then\n+                        Set_Is_Constr_Subt_For_UN_Aliased (Full_View (Act_T));\n+                     end if;\n+                  end if;\n \n-               if Full_View_Present then\n-                  Set_Is_Constr_Subt_For_UN_Aliased (Full_View (Act_T));\n-               end if;\n+                  Freeze_Before (N, Act_T);\n+               end;\n             end if;\n \n-            Freeze_Before (N, Act_T);\n             Freeze_Before (N, T);\n          end if;\n "}, {"sha": "e5c13ed36b25ee7fd9342457788139c9f9d28532", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4844a259b41b4f31940b478216d6dc9faa2bcbca/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4844a259b41b4f31940b478216d6dc9faa2bcbca", "patch": "@@ -34,7 +34,6 @@ with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n with Expander;       use Expander;\n-with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch9;        use Exp_Ch9;\n with Exp_Dbug;       use Exp_Dbug;\n@@ -1520,33 +1519,7 @@ package body Sem_Ch6 is\n             --  object declaration.\n \n             Set_Is_Return_Object (Defining_Identifier (Obj_Decl));\n-\n-            --  Returning a build-in-place unconstrained array type we defer\n-            --  the full analysis of the returned object to avoid generating\n-            --  the corresponding constrained subtype; otherwise the bounds\n-            --  would be created in the stack and a dangling reference would\n-            --  be returned pointing to the bounds. We perform its preanalysis\n-            --  to report errors on the initializing aggregate now (if any);\n-            --  we also ensure its activation chain and Master variable are\n-            --  defined (if tasks are being declared) since they are generated\n-            --  as part of the analysis and expansion of the object declaration\n-            --  at this stage.\n-\n-            if Is_Array_Type (R_Type)\n-              and then not Is_Constrained (R_Type)\n-              and then Is_Build_In_Place_Function (Scope_Id)\n-              and then Needs_BIP_Alloc_Form (Scope_Id)\n-              and then Nkind (Expr) in N_Aggregate | N_Extension_Aggregate\n-            then\n-               Preanalyze (Obj_Decl);\n-\n-               if Expander_Active then\n-                  Ensure_Activation_Chain_And_Master (Obj_Decl);\n-               end if;\n-\n-            else\n-               Analyze (Obj_Decl);\n-            end if;\n+            Analyze (Obj_Decl);\n \n             Check_Return_Subtype_Indication (Obj_Decl);\n \n@@ -9274,7 +9247,9 @@ package body Sem_Ch6 is\n             --  Force the definition of the Itype in case of internal function\n             --  calls within the same or nested scope.\n \n-            if Is_Subprogram_Or_Generic_Subprogram (E) then\n+            if Is_Subprogram_Or_Generic_Subprogram (E)\n+              and then not Is_Compilation_Unit (E)\n+            then\n                Subp_Decl := Parent (E);\n \n                --  The insertion point for an Itype reference should be after"}]}