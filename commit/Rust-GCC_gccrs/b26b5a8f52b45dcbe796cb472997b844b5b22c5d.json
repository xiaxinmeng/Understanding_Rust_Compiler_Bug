{"sha": "b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2YjVhOGY1MmI0NWRjYmU3OTZjYjQ3Mjk5N2I4NDRiNWIyMmM1ZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:29:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:29:24Z"}, "message": "g-byorma.adb, [...]: New files.\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* g-byorma.adb, g-byorma.ads, g-decstr.adb, g-decstr.ads,\n\tg-deutst.ads, g-encstr.adb, g-encstr.ads, g-enutst.ads: New files.\n\n\t* scn.adb: Implement BOM recognition\n\nFrom-SVN: r130849", "tree": {"sha": "43bd0ad62150abfc2319fc29f19db59d9db58ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43bd0ad62150abfc2319fc29f19db59d9db58ebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/comments", "author": null, "committer": null, "parents": [{"sha": "150bbaff610db5c17dd906a39a2f0453d78ab6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150bbaff610db5c17dd906a39a2f0453d78ab6b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150bbaff610db5c17dd906a39a2f0453d78ab6b8"}], "stats": {"total": 1932, "additions": 1932, "deletions": 0}, "files": [{"sha": "9cc6f08b519ef6f5c1c3c1fcb7ee3699781a1b6d", "filename": "gcc/ada/g-byorma.adb", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-byorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-byorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-byorma.adb?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,191 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 G N A T . B Y T E _ O R D E R _ M A R K                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2006-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Byte_Order_Mark is\n+\n+   --------------\n+   -- Read_BOM --\n+   --------------\n+\n+   procedure Read_BOM\n+     (Str         : String;\n+      Len         : out Natural;\n+      BOM         : out BOM_Kind;\n+      XML_Support : Boolean := False)\n+   is\n+   begin\n+      --  UTF-16 (big-endian)\n+\n+      if Str'Length >= 2\n+        and then Str (Str'First) = Character'Val (16#FE#)\n+        and then Str (Str'First + 1) = Character'Val (16#FF#)\n+      then\n+         Len := 2;\n+         BOM := UTF16_BE;\n+\n+      --  UTF-16 (little-endian)\n+\n+      elsif Str'Length >= 2\n+        and then Str (Str'First) = Character'Val (16#FF#)\n+        and then Str (Str'First + 1) = Character'Val (16#FE#)\n+      then\n+         Len := 2;\n+         BOM := UTF16_LE;\n+\n+      --  UTF-32 (big-endian)\n+\n+      elsif Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#00#)\n+        and then Str (Str'First + 1) = Character'Val (16#00#)\n+        and then Str (Str'First + 2) = Character'Val (16#FE#)\n+        and then Str (Str'First + 3) = Character'Val (16#FF#)\n+      then\n+         Len := 4;\n+         BOM := UTF32_BE;\n+\n+      --  UTF-32 (little-endian)\n+\n+      elsif Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#FF#)\n+        and then Str (Str'First + 1) = Character'Val (16#FE#)\n+        and then Str (Str'First + 2) = Character'Val (16#00#)\n+        and then Str (Str'First + 3) = Character'Val (16#00#)\n+      then\n+         Len := 4;\n+         BOM := UTF32_LE;\n+\n+      --  UTF-8 (endian-independent)\n+\n+      elsif Str'Length >= 3\n+        and then Str (Str'First)     = Character'Val (16#EF#)\n+        and then Str (Str'First + 1) = Character'Val (16#BB#)\n+        and then Str (Str'First + 2) = Character'Val (16#BF#)\n+      then\n+         Len := 3;\n+         BOM := UTF8_All;\n+\n+      --  UCS-4 (big-endian) XML only\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#00#)\n+        and then Str (Str'First + 1) = Character'Val (16#00#)\n+        and then Str (Str'First + 2) = Character'Val (16#00#)\n+        and then Str (Str'First + 3) = Character'Val (16#3C#)\n+      then\n+         Len := 0;\n+         BOM := UCS4_BE;\n+\n+      --  UCS-4 (little-endian) XML case\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#3C#)\n+        and then Str (Str'First + 1) = Character'Val (16#00#)\n+        and then Str (Str'First + 2) = Character'Val (16#00#)\n+        and then Str (Str'First + 3) = Character'Val (16#00#)\n+      then\n+         Len := 0;\n+         BOM := UCS4_LE;\n+\n+      --  UCS-4 (unusual byte order 2143) XML case\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#00#)\n+        and then Str (Str'First + 1) = Character'Val (16#00#)\n+        and then Str (Str'First + 2) = Character'Val (16#3C#)\n+        and then Str (Str'First + 3) = Character'Val (16#00#)\n+      then\n+         Len := 0;\n+         BOM := UCS4_2143;\n+\n+      --  UCS-4 (unusual byte order 3412) XML case\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#00#)\n+        and then Str (Str'First + 1) = Character'Val (16#3C#)\n+        and then Str (Str'First + 2) = Character'Val (16#00#)\n+        and then Str (Str'First + 3) = Character'Val (16#00#)\n+      then\n+         Len := 0;\n+         BOM := UCS4_3412;\n+\n+      --  UTF-16 (big-endian) XML case\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#00#)\n+        and then Str (Str'First + 1) = Character'Val (16#3C#)\n+        and then Str (Str'First + 2) = Character'Val (16#00#)\n+        and then Str (Str'First + 3) = Character'Val (16#3F#)\n+      then\n+         Len := 0;\n+         BOM := UTF16_BE;\n+\n+      --  UTF-32 (little-endian) XML case\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#3C#)\n+        and then Str (Str'First + 1) = Character'Val (16#00#)\n+        and then Str (Str'First + 2) = Character'Val (16#3F#)\n+        and then Str (Str'First + 3) = Character'Val (16#00#)\n+      then\n+         Len := 0;\n+         BOM := UTF16_LE;\n+\n+      --  Unrecognized special encodings XML only\n+\n+      elsif XML_Support\n+        and then Str'Length >= 4\n+        and then Str (Str'First)     = Character'Val (16#3C#)\n+        and then Str (Str'First + 1) = Character'Val (16#3F#)\n+        and then Str (Str'First + 2) = Character'Val (16#78#)\n+        and then Str (Str'First + 3) = Character'Val (16#6D#)\n+      then\n+         --  Utf8, ASCII, some part of ISO8859, Shift-JIS, EUC,...\n+\n+         Len := 0;\n+         BOM := Unknown;\n+\n+      --  No BOM recognized\n+\n+      else\n+         Len := 0;\n+         BOM := Unknown;\n+      end if;\n+   end Read_BOM;\n+\n+end GNAT.Byte_Order_Mark;"}, {"sha": "6016f755bcc3b53d69825925caf8f9bc1cd5b8b4", "filename": "gcc/ada/g-byorma.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-byorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-byorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-byorma.ads?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 G N A T . B Y T E _ O R D E R _ M A R K                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2006-2007, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a procedure for reading and interpreting the BOM\n+--  (byte order mark) used to publish the encoding method for a string (for\n+--  example, a UTF-8 encoded file in windows will start with the appropriate\n+--  BOM sequence to signal UTF-8 encoding.\n+\n+--  There are two cases\n+\n+--    Case 1. UTF encodings for Unicode files\n+\n+--      Here the convention is to have the first character of the file be a\n+--      non-breaking zero width space character (16#0000_FEFF#). For the UTF\n+--      encodings, the representation of this character can be used to uniquely\n+--      determine the encoding. Furthermore, the possibility of any confusion\n+--      with unencoded files is minimal, since for example the UTF-8 encoding\n+--      of this character looks like the sequence:\n+\n+--        LC_I_Diaeresis\n+--        Right_Angle_Quotation\n+--        Fraction_One_Half\n+\n+--      which is so unlikely to occur legitimately in normal use that it can\n+--      safely be ignored in most cases (for example, no legitimate Ada source\n+--      file could start with this sequence of characters).\n+\n+--   Case 2. Specialized XML encodings\n+\n+--     The XML standard defines a number of other possible encodings and also\n+--     defines standardized sequences for marking these encodings. This package\n+--     can also optionally handle these XML defined BOM sequences. These XML\n+--     cases depend on the first character of the XML file being < so that the\n+--     encoding of this character can be recognized.\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+package GNAT.Byte_Order_Mark is\n+\n+   type BOM_Kind is\n+     (UTF8_All,  --  UTF8-encoding\n+      UTF16_LE,  --  UTF16 little-endian encoding\n+      UTF16_BE,  --  UTF16 big-endian encoding\n+      UTF32_LE,  --  UTF32 little-endian encoding\n+      UTF32_BE,  --  UTF32 big-endian encoding\n+\n+      --  The following cases are for XML only\n+\n+      UCS4_BE,   --  UCS-4, big endian machine (1234 order)\n+      UCS4_LE,   --  UCS-4, little endian machine (4321 order)\n+      UCS4_2143, --  UCS-4, unusual byte order (2143 order)\n+      UCS4_3412, --  UCS-4, unusual byte order (3412 order)\n+\n+      --  Value returned if no BOM recognized\n+\n+      Unknown);  --  Unknown, assumed to be ASCII compatible\n+\n+   procedure Read_BOM\n+     (Str         : String;\n+      Len         : out Natural;\n+      BOM         : out BOM_Kind;\n+      XML_Support : Boolean := False);\n+   --  This is the routine to read the BOM from the start of the given string\n+   --  Str. On return BOM is set to the appropriate BOM_Kind and Len is set to\n+   --  its length. The caller will typically skip the first Len characters in\n+   --  the string to ignore the BOM sequence. The special XML possibilities are\n+   --  recognized only if flag XML_Support is set to True. Note that for the\n+   --  XML cases, Len is always set to zero on return (not to the length of the\n+   --  relevant sequence) since in the XML cases, the sequence recognized is\n+   --  for the first real character in the file (<) which is not to be skipped.\n+\n+end GNAT.Byte_Order_Mark;"}, {"sha": "580ad15a4a622c9b7199bce460641bd775332533", "filename": "gcc/ada/g-decstr.adb", "status": "added", "additions": 972, "deletions": 0, "changes": 972, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-decstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-decstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-decstr.adb?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,972 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . D E C O D E _ S T R I N G                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a utility routine for converting from an encoded\n+--  string to a corresponding Wide_String or Wide_Wide_String value.\n+\n+with Interfaces; use Interfaces;\n+\n+with System.WCh_Cnv; use System.WCh_Cnv;\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body GNAT.Decode_String is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Bad;\n+   pragma No_Return (Bad);\n+   --  Raise error for bad encoding\n+\n+   procedure Past_End;\n+   pragma No_Return (Past_End);\n+   --  Raise error for off end of string\n+\n+   ---------\n+   -- Bad --\n+   ---------\n+\n+   procedure Bad is\n+   begin\n+      raise Constraint_Error with\n+        \"bad encoding or character out of range\";\n+   end Bad;\n+\n+   ---------------------------\n+   -- Decode_Wide_Character --\n+   ---------------------------\n+\n+   procedure Decode_Wide_Character\n+     (Input  : String;\n+      Ptr    : in out Natural;\n+      Result : out Wide_Character)\n+   is\n+      Char : Wide_Wide_Character;\n+   begin\n+      Decode_Wide_Wide_Character (Input, Ptr, Char);\n+\n+      if Wide_Wide_Character'Pos (Char) > 16#FFFF# then\n+         Bad;\n+      else\n+         Result := Wide_Character'Val (Wide_Wide_Character'Pos (Char));\n+      end if;\n+   end Decode_Wide_Character;\n+\n+   ------------------------\n+   -- Decode_Wide_String --\n+   ------------------------\n+\n+   function Decode_Wide_String (S : String) return Wide_String is\n+      Result : Wide_String (1 .. S'Length);\n+      Length : Natural;\n+   begin\n+      Decode_Wide_String (S, Result, Length);\n+      return Result (1 .. Length);\n+   end Decode_Wide_String;\n+\n+   procedure Decode_Wide_String\n+     (S      : String;\n+      Result : out Wide_String;\n+      Length : out Natural)\n+   is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      Length := 0;\n+      while Ptr <= S'Last loop\n+         if Length >= Result'Last then\n+            Past_End;\n+         end if;\n+\n+         Length := Length + 1;\n+         Decode_Wide_Character (S, Ptr, Result (Length));\n+      end loop;\n+   end Decode_Wide_String;\n+\n+   --------------------------------\n+   -- Decode_Wide_Wide_Character --\n+   --------------------------------\n+\n+   procedure Decode_Wide_Wide_Character\n+     (Input  : String;\n+      Ptr    : in out Natural;\n+      Result : out Wide_Wide_Character)\n+   is\n+      C : Character;\n+\n+      function In_Char return Character;\n+      pragma Inline (In_Char);\n+      --  Function to get one input character\n+\n+      -------------\n+      -- In_Char --\n+      -------------\n+\n+      function In_Char return Character is\n+      begin\n+         if Ptr <= Input'Last then\n+            Ptr := Ptr + 1;\n+            return Input (Ptr - 1);\n+         else\n+            Past_End;\n+         end if;\n+      end In_Char;\n+\n+   --  Start of processing for Decode_Wide_Wide_Character\n+\n+   begin\n+      C := In_Char;\n+\n+      --  Special fast processing for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+         UTF8 : declare\n+            U : Unsigned_32;\n+            W : Unsigned_32;\n+\n+            procedure Get_UTF_Byte;\n+            pragma Inline (Get_UTF_Byte);\n+            --  Used to interpret 2#10xxxxxx# continuation byte in UTF-8 mode.\n+            --  Reads a byte, and raises CE if the first two bits are not 10.\n+            --  Otherwise shifts W 6 bits left and or's in the 6 xxxxxx bits.\n+\n+            ------------------\n+            -- Get_UTF_Byte --\n+            ------------------\n+\n+            procedure Get_UTF_Byte is\n+            begin\n+               U := Unsigned_32 (Character'Pos (In_Char));\n+\n+               if (U and 2#11000000#) /= 2#10_000000# then\n+                  Bad;\n+               end if;\n+\n+               W := Shift_Left (W, 6) or (U and 2#00111111#);\n+            end Get_UTF_Byte;\n+\n+         --  Start of processing for UTF8 case\n+\n+         begin\n+            --  Note: for details of UTF8 encoding see RFC 3629\n+\n+            U := Unsigned_32 (Character'Pos (C));\n+\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+            if (U and 2#10000000#) = 2#00000000# then\n+               Result := Wide_Wide_Character'Val (Character'Pos (C));\n+\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            elsif (U and 2#11100000#) = 2#110_00000# then\n+               W := U and 2#00011111#;\n+               Get_UTF_Byte;\n+               Result := Wide_Wide_Character'Val (W);\n+\n+            --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11110000#) = 2#1110_0000# then\n+               W := U and 2#00001111#;\n+               Get_UTF_Byte;\n+               Get_UTF_Byte;\n+               Result := Wide_Wide_Character'Val (W);\n+\n+            --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111000#) = 2#11110_000# then\n+               W := U and 2#00000111#;\n+\n+               for K in 1 .. 3 loop\n+                  Get_UTF_Byte;\n+               end loop;\n+\n+               Result := Wide_Wide_Character'Val (W);\n+\n+            --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111100#) = 2#111110_00# then\n+               W := U and 2#00000011#;\n+\n+               for K in 1 .. 4 loop\n+                  Get_UTF_Byte;\n+               end loop;\n+\n+               Result := Wide_Wide_Character'Val (W);\n+\n+            --  All other cases are invalid, note that this includes:\n+\n+            --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            --  since Wide_Wide_Character does not include code values\n+            --  greater than 16#03FF_FFFF#.\n+\n+            else\n+               Bad;\n+            end if;\n+         end UTF8;\n+\n+      --  All encoding functions other than UTF-8\n+\n+      else\n+         Non_UTF8 : declare\n+            function Char_Sequence_To_UTF is\n+              new Char_Sequence_To_UTF_32 (In_Char);\n+\n+         begin\n+            --  For brackets, must test for specific case of [ not followed by\n+            --  quotation, where we must not call Char_Sequence_To_UTF, but\n+            --  instead just return the bracket unchanged.\n+\n+            if Encoding_Method = WCEM_Brackets\n+              and then C = '['\n+              and then (Ptr > Input'Last or else Input (Ptr) /= '\"')\n+            then\n+               Result := '[';\n+\n+            --  All other cases including [\" with Brackets\n+\n+            else\n+               Result :=\n+                 Wide_Wide_Character'Val\n+                   (Char_Sequence_To_UTF (C, Encoding_Method));\n+            end if;\n+         end Non_UTF8;\n+      end if;\n+   end Decode_Wide_Wide_Character;\n+\n+   -----------------------------\n+   -- Decode_Wide_Wide_String --\n+   -----------------------------\n+\n+   function Decode_Wide_Wide_String (S : String) return Wide_Wide_String is\n+      Result : Wide_Wide_String (1 .. S'Length);\n+      Length : Natural;\n+   begin\n+      Decode_Wide_Wide_String (S, Result, Length);\n+      return Result (1 .. Length);\n+   end Decode_Wide_Wide_String;\n+\n+   procedure Decode_Wide_Wide_String\n+     (S      : String;\n+      Result : out Wide_Wide_String;\n+      Length : out Natural)\n+   is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      Length := 0;\n+      while Ptr <= S'Last loop\n+         if Length >= Result'Last then\n+            Past_End;\n+         end if;\n+\n+         Length := Length + 1;\n+         Decode_Wide_Wide_Character (S, Ptr, Result (Length));\n+      end loop;\n+   end Decode_Wide_Wide_String;\n+\n+   -------------------------\n+   -- Next_Wide_Character --\n+   -------------------------\n+\n+   procedure Next_Wide_Character (Input : String; Ptr : in out Natural) is\n+   begin\n+      if Ptr < Input'First then\n+         Past_End;\n+      end if;\n+\n+      --  Special efficient encoding for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+         UTF8 : declare\n+            U : Unsigned_32;\n+\n+            procedure Getc;\n+            pragma Inline (Getc);\n+            --  Gets the character at Input (Ptr) and returns code in U as\n+            --  Unsigned_32 value. On return Ptr is bumped past the character.\n+\n+            procedure Skip_UTF_Byte;\n+            pragma Inline (Skip_UTF_Byte);\n+            --  Skips past one encoded byte which must be 2#10xxxxxx#\n+\n+            ----------\n+            -- Getc --\n+            ----------\n+\n+            procedure Getc is\n+            begin\n+               if Ptr > Input'Last then\n+                  Past_End;\n+               else\n+                  U := Unsigned_32 (Character'Pos (Input (Ptr)));\n+                  Ptr := Ptr + 1;\n+               end if;\n+            end Getc;\n+\n+            -------------------\n+            -- Skip_UTF_Byte --\n+            -------------------\n+\n+            procedure Skip_UTF_Byte is\n+            begin\n+               Getc;\n+\n+               if (U and 2#11000000#) /= 2#10_000000# then\n+                  Bad;\n+               end if;\n+            end Skip_UTF_Byte;\n+\n+         --  Start of processing for UTF-8 case\n+\n+         begin\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+            Getc;\n+\n+            if (U and 2#10000000#) = 2#00000000# then\n+               return;\n+\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            elsif (U and 2#11100000#) = 2#110_00000# then\n+               Skip_UTF_Byte;\n+\n+            --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11110000#) = 2#1110_0000# then\n+               Skip_UTF_Byte;\n+               Skip_UTF_Byte;\n+\n+            --  Any other code is invalid, note that this includes:\n+\n+            --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx\n+\n+            --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            --  since Wide_Character does not allow codes > 16#FFFF#\n+\n+            else\n+               Bad;\n+            end if;\n+         end UTF8;\n+\n+      --  Non-UTF-8 cass\n+\n+      else\n+         declare\n+            Discard : Wide_Character;\n+         begin\n+            Decode_Wide_Character (Input, Ptr, Discard);\n+         end;\n+      end if;\n+   end Next_Wide_Character;\n+\n+   ------------------------------\n+   -- Next_Wide_Wide_Character --\n+   ------------------------------\n+\n+   procedure Next_Wide_Wide_Character (Input : String; Ptr : in out Natural) is\n+   begin\n+      --  Special efficient encoding for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+         UTF8 : declare\n+            U : Unsigned_32;\n+\n+            procedure Getc;\n+            pragma Inline (Getc);\n+            --  Gets the character at Input (Ptr) and returns code in U as\n+            --  Unsigned_32 value. On return Ptr is bumped past the character.\n+\n+            procedure Skip_UTF_Byte;\n+            pragma Inline (Skip_UTF_Byte);\n+            --  Skips past one encoded byte which must be 2#10xxxxxx#\n+\n+            ----------\n+            -- Getc --\n+            ----------\n+\n+            procedure Getc is\n+            begin\n+               if Ptr > Input'Last then\n+                  Past_End;\n+               else\n+                  U := Unsigned_32 (Character'Pos (Input (Ptr)));\n+                  Ptr := Ptr + 1;\n+               end if;\n+            end Getc;\n+\n+            -------------------\n+            -- Skip_UTF_Byte --\n+            -------------------\n+\n+            procedure Skip_UTF_Byte is\n+            begin\n+               Getc;\n+\n+               if (U and 2#11000000#) /= 2#10_000000# then\n+                  Bad;\n+               end if;\n+            end Skip_UTF_Byte;\n+\n+         --  Start of processing for UTF-8 case\n+\n+         begin\n+            if Ptr < Input'First then\n+               Past_End;\n+            end if;\n+\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+            Getc;\n+\n+            if (U and 2#10000000#) = 2#00000000# then\n+               null;\n+\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            elsif (U and 2#11100000#) = 2#110_00000# then\n+               Skip_UTF_Byte;\n+\n+            --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11110000#) = 2#1110_0000# then\n+               Skip_UTF_Byte;\n+               Skip_UTF_Byte;\n+\n+            --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111000#) = 2#11110_000# then\n+               for K in 1 .. 3 loop\n+                  Skip_UTF_Byte;\n+               end loop;\n+\n+            --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx\n+\n+            elsif (U and 2#11111100#) = 2#111110_00# then\n+               for K in 1 .. 4 loop\n+                  Skip_UTF_Byte;\n+               end loop;\n+\n+            --  Any other code is invalid, note that this includes:\n+\n+            --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+            --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+            --  since Wide_Wide_Character does not allow codes > 16#03FF_FFFF#\n+\n+            else\n+               Bad;\n+            end if;\n+         end UTF8;\n+\n+      --  Non-UTF-8 cass\n+\n+      else\n+         declare\n+            Discard : Wide_Wide_Character;\n+         begin\n+            Decode_Wide_Wide_Character (Input, Ptr, Discard);\n+         end;\n+      end if;\n+   end Next_Wide_Wide_Character;\n+\n+   --------------\n+   -- Past_End --\n+   --------------\n+\n+   procedure Past_End is\n+   begin\n+      raise Constraint_Error with \"past end of string\";\n+   end Past_End;\n+\n+   -------------------------\n+   -- Prev_Wide_Character --\n+   -------------------------\n+\n+   procedure Prev_Wide_Character (Input : String; Ptr : in out Natural) is\n+   begin\n+      if Ptr > Input'Last + 1 then\n+         Past_End;\n+      end if;\n+\n+      --  Special efficient encoding for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+         UTF8 : declare\n+            U : Unsigned_32;\n+\n+            procedure Getc;\n+            pragma Inline (Getc);\n+            --  Gets the character at Input (Ptr - 1) and returns code in U as\n+            --  Unsigned_32 value. On return Ptr is decremented by one.\n+\n+            procedure Skip_UTF_Byte;\n+            pragma Inline (Skip_UTF_Byte);\n+            --  Checks that U is 2#10xxxxxx# and then calls Get\n+\n+            ----------\n+            -- Getc --\n+            ----------\n+\n+            procedure Getc is\n+            begin\n+               if Ptr <= Input'First then\n+                  Past_End;\n+               else\n+                  Ptr := Ptr - 1;\n+                  U := Unsigned_32 (Character'Pos (Input (Ptr)));\n+               end if;\n+            end Getc;\n+\n+            -------------------\n+            -- Skip_UTF_Byte --\n+            -------------------\n+\n+            procedure Skip_UTF_Byte is\n+            begin\n+               if (U and 2#11000000#) = 2#10_000000# then\n+                  Getc;\n+               else\n+                  Bad;\n+               end if;\n+            end Skip_UTF_Byte;\n+\n+         --  Start of processing for UTF-8 case\n+\n+         begin\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+            Getc;\n+\n+            if (U and 2#10000000#) = 2#00000000# then\n+               return;\n+\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            else\n+               Skip_UTF_Byte;\n+\n+               if (U and 2#11100000#) = 2#110_00000# then\n+                  return;\n+\n+               --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+               else\n+                  Skip_UTF_Byte;\n+\n+                  if (U and 2#11110000#) = 2#1110_0000# then\n+                     return;\n+\n+                     --  Any other code is invalid, note that this includes:\n+\n+                     --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx\n+                     --                           10xxxxxx\n+\n+                     --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx\n+                     --                               10xxxxxx 10xxxxxx\n+                     --                               10xxxxxx\n+\n+                     --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx\n+                     --                               10xxxxxx 10xxxxxx\n+                     --                               10xxxxxx 10xxxxxx\n+\n+                     --  since Wide_Character does not allow codes > 16#FFFF#\n+\n+                  else\n+                     Bad;\n+                  end if;\n+               end if;\n+            end if;\n+         end UTF8;\n+\n+      --  Special efficient encoding for brackets case\n+\n+      elsif Encoding_Method = WCEM_Brackets then\n+         Brackets : declare\n+            P : Natural;\n+            S : Natural;\n+\n+         begin\n+            --  See if we have \"] at end positions\n+\n+            if Ptr > Input'First + 1\n+              and then Input (Ptr - 1) = ']'\n+              and then Input (Ptr - 2) = '\"'\n+            then\n+               P := Ptr - 2;\n+\n+               --  Loop back looking for [\" at start\n+\n+               while P >= Ptr - 10 loop\n+                  if P <= Input'First + 1 then\n+                     Bad;\n+\n+                  elsif Input (P - 1) = '\"'\n+                    and then Input (P - 2) = '['\n+                  then\n+                     --  Found [\"...\"], scan forward to check it\n+\n+                     S := P - 2;\n+                     P := S;\n+                     Next_Wide_Character (Input, P);\n+\n+                     --  OK if at original pointer, else error\n+\n+                     if P = Ptr then\n+                        Ptr := S;\n+                        return;\n+                     else\n+                        Bad;\n+                     end if;\n+                  end if;\n+\n+                  P := P - 1;\n+               end loop;\n+\n+               --  Falling through loop means more than 8 chars between the\n+               --  enclosing brackets (or simply a missing left bracket)\n+\n+               Bad;\n+\n+            --  Here if no bracket sequence present\n+\n+            else\n+               if Ptr = Input'First then\n+                  Past_End;\n+               else\n+                  Ptr := Ptr - 1;\n+               end if;\n+            end if;\n+         end Brackets;\n+\n+      --  Non-UTF-8/Brackets. These are the inefficient cases where we have to\n+      --  go to the start of the string and skip forwards till Ptr matches.\n+\n+      else\n+         Non_UTF_Brackets : declare\n+            Discard : Wide_Character;\n+            PtrS    : Natural;\n+            PtrP    : Natural;\n+\n+         begin\n+            PtrS := Input'First;\n+\n+            if Ptr <= PtrS then\n+               Past_End;\n+            end if;\n+\n+            loop\n+               PtrP := PtrS;\n+               Decode_Wide_Character (Input, PtrS, Discard);\n+\n+               if PtrS = Ptr then\n+                  Ptr := PtrP;\n+                  return;\n+\n+               elsif PtrS > Ptr then\n+                  Bad;\n+               end if;\n+            end loop;\n+\n+         exception\n+            when Constraint_Error =>\n+               Bad;\n+         end Non_UTF_Brackets;\n+      end if;\n+   end Prev_Wide_Character;\n+\n+   ------------------------------\n+   -- Prev_Wide_Wide_Character --\n+   ------------------------------\n+\n+   procedure Prev_Wide_Wide_Character (Input : String; Ptr : in out Natural) is\n+   begin\n+      if Ptr > Input'Last + 1 then\n+         Past_End;\n+      end if;\n+\n+      --  Special efficient encoding for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+         UTF8 : declare\n+            U : Unsigned_32;\n+\n+            procedure Getc;\n+            pragma Inline (Getc);\n+            --  Gets the character at Input (Ptr - 1) and returns code in U as\n+            --  Unsigned_32 value. On return Ptr is decremented by one.\n+\n+            procedure Skip_UTF_Byte;\n+            pragma Inline (Skip_UTF_Byte);\n+            --  Checks that U is 2#10xxxxxx# and then calls Get\n+\n+            ----------\n+            -- Getc --\n+            ----------\n+\n+            procedure Getc is\n+            begin\n+               if Ptr <= Input'First then\n+                  Past_End;\n+               else\n+                  Ptr := Ptr - 1;\n+                  U := Unsigned_32 (Character'Pos (Input (Ptr)));\n+               end if;\n+            end Getc;\n+\n+            -------------------\n+            -- Skip_UTF_Byte --\n+            -------------------\n+\n+            procedure Skip_UTF_Byte is\n+            begin\n+               if (U and 2#11000000#) = 2#10_000000# then\n+                  Getc;\n+               else\n+                  Bad;\n+               end if;\n+            end Skip_UTF_Byte;\n+\n+         --  Start of processing for UTF-8 case\n+\n+         begin\n+            --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+            Getc;\n+\n+            if (U and 2#10000000#) = 2#00000000# then\n+               return;\n+\n+            --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+            else\n+               Skip_UTF_Byte;\n+\n+               if (U and 2#11100000#) = 2#110_00000# then\n+                  return;\n+\n+               --  16#00_0800#-16#00_ffff#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+               else\n+                  Skip_UTF_Byte;\n+\n+                  if (U and 2#11110000#) = 2#1110_0000# then\n+                     return;\n+\n+                  --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx\n+                  --                           10xxxxxx\n+\n+                  else\n+                     Skip_UTF_Byte;\n+\n+                     if (U and 2#11111000#) = 2#11110_000# then\n+                        return;\n+\n+                     --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx\n+                     --                               10xxxxxx 10xxxxxx\n+                     --                               10xxxxxx\n+\n+                     else\n+                        Skip_UTF_Byte;\n+\n+                        if (U and 2#11111100#) = 2#111110_00# then\n+                           return;\n+\n+                        --  Any other code is invalid, note that this includes:\n+\n+                        --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx\n+                        --                               10xxxxxx 10xxxxxx\n+                        --                               10xxxxxx 10xxxxxx\n+\n+                        --  since Wide_Wide_Character does not allow codes\n+                        --  greater than 16#03FF_FFFF#\n+\n+                        else\n+                           Bad;\n+                        end if;\n+                     end if;\n+                  end if;\n+               end if;\n+            end if;\n+         end UTF8;\n+\n+      --  Special efficient encoding for brackets case\n+\n+      elsif Encoding_Method = WCEM_Brackets then\n+         Brackets : declare\n+            P : Natural;\n+            S : Natural;\n+\n+         begin\n+            --  See if we have \"] at end positions\n+\n+            if Ptr > Input'First + 1\n+              and then Input (Ptr - 1) = ']'\n+              and then Input (Ptr - 2) = '\"'\n+            then\n+               P := Ptr - 2;\n+\n+               --  Loop back looking for [\" at start\n+\n+               while P >= Ptr - 10 loop\n+                  if P <= Input'First + 1 then\n+                     Bad;\n+\n+                  elsif Input (P - 1) = '\"'\n+                    and then Input (P - 2) = '['\n+                  then\n+                     --  Found [\"...\"], scan forward to check it\n+\n+                     S := P - 2;\n+                     P := S;\n+                     Next_Wide_Wide_Character (Input, P);\n+\n+                     --  OK if at original pointer, else error\n+\n+                     if P = Ptr then\n+                        Ptr := S;\n+                        return;\n+                     else\n+                        Bad;\n+                     end if;\n+                  end if;\n+\n+                  P := P - 1;\n+               end loop;\n+\n+               --  Falling through loop means more than 8 chars between the\n+               --  enclosing brackets (or simply a missing left bracket)\n+\n+               Bad;\n+\n+            --  Here if no bracket sequence present\n+\n+            else\n+               if Ptr = Input'First then\n+                  Past_End;\n+               else\n+                  Ptr := Ptr - 1;\n+               end if;\n+            end if;\n+         end Brackets;\n+\n+      --  Non-UTF-8/Brackets. These are the inefficient cases where we have to\n+      --  go to the start of the string and skip forwards till Ptr matches.\n+\n+      else\n+         Non_UTF8_Brackets : declare\n+            Discard : Wide_Wide_Character;\n+            PtrS    : Natural;\n+            PtrP    : Natural;\n+\n+         begin\n+            PtrS := Input'First;\n+\n+            if Ptr <= PtrS then\n+               Past_End;\n+            end if;\n+\n+            loop\n+               PtrP := PtrS;\n+               Decode_Wide_Wide_Character (Input, PtrS, Discard);\n+\n+               if PtrS = Ptr then\n+                  Ptr := PtrP;\n+                  return;\n+\n+               elsif PtrS > Ptr then\n+                  Bad;\n+               end if;\n+            end loop;\n+\n+         exception\n+             when Constraint_Error =>\n+               Bad;\n+         end Non_UTF8_Brackets;\n+      end if;\n+   end Prev_Wide_Wide_Character;\n+\n+   --------------------------\n+   -- Validate_Wide_String --\n+   --------------------------\n+\n+   function Validate_Wide_String (S : String) return Boolean is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      while Ptr <= S'Last loop\n+         Next_Wide_Character (S, Ptr);\n+      end loop;\n+\n+      return True;\n+\n+   exception\n+      when Constraint_Error =>\n+         return False;\n+   end Validate_Wide_String;\n+\n+   -------------------------------\n+   -- Validate_Wide_Wide_String --\n+   -------------------------------\n+\n+   function Validate_Wide_Wide_String (S : String) return Boolean is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      while Ptr <= S'Last loop\n+         Next_Wide_Wide_Character (S, Ptr);\n+      end loop;\n+\n+      return True;\n+\n+   exception\n+      when Constraint_Error =>\n+         return False;\n+   end Validate_Wide_Wide_String;\n+\n+end GNAT.Decode_String;"}, {"sha": "07d501552e0dd83d4e76c3f0c89b40889ad40743", "filename": "gcc/ada/g-decstr.ads", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-decstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-decstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-decstr.ads?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,163 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . D E C O D E _ S T R I N G                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This generic package provides utility routines for converting from an\n+--  encoded string to a corresponding Wide_String or Wide_Wide_String value\n+--  using a specified encoding convention, which is supplied as the generic\n+--  parameter. UTF-8 is handled especially efficiently, and if the encoding\n+--  method is known at compile time to be WCEM_UTF8, then the instantiation\n+--  is specialized to handle only the UTF-8 case and exclude code for the\n+--  other encoding methods. The package also provides positioning routines\n+--  for skipping encoded characters in either direction, and for validating\n+--  strings for correct encodings.\n+\n+--  Note: this package is only about decoding sequences of 8-bit characters\n+--  into corresponding 16-bit Wide_String or 32-bit Wide_Wide_String values.\n+--  It knows nothing at all about the character encodings being used for the\n+--  resulting Wide_Character and Wide_Wide_Character values. Most often this\n+--  will be Unicode/ISO-10646 as specified by the Ada RM, but this package\n+--  does not make any assumptions about the character coding. See also the\n+--  packages Ada.Wide_[Wide_]Characters.Unicode for unicode specific functions.\n+\n+--  Note on the use of brackets encoding (WCEM_Brackets). The brackets encoding\n+--  method is ambiguous in the context of this package, since there is no way\n+--  to tell if [\"1234\"] is eight unencoded characters or one encoded character.\n+--  In the context of Ada sources, any sequence starting [\" must be the start\n+--  of an encoding (since that sequence is not valid in Ada source otherwise).\n+--  The routines in this package use the same approach. If the input string\n+--  contains the sequence [\" then this is assumed to be the start of a brackets\n+--  encoding sequence, and if it does not match the syntax, an error is raised.\n+--  In the case of the Prev functions, a sequence ending with \"] is assumed to\n+--  be a valid brackets sequence, and an error is raised if it is not.\n+\n+with System.WCh_Con;\n+\n+generic\n+   Encoding_Method : System.WCh_Con.WC_Encoding_Method;\n+\n+package GNAT.Decode_String is\n+   pragma Pure;\n+\n+   function Decode_Wide_String (S : String) return Wide_String;\n+   pragma Inline (Decode_Wide_String);\n+   --  Decode the given String, which is encoded using the indicated coding\n+   --  method, returning the corresponding decoded Wide_String value. If S\n+   --  contains a character code that cannot be represented with the given\n+   --  encoding, then Constraint_Error is raised.\n+\n+   procedure Decode_Wide_String\n+     (S      : String;\n+      Result : out Wide_String;\n+      Length : out Natural);\n+   --  Similar to the above function except that the result is stored in the\n+   --  given Wide_String variable Result, starting at Result (Result'First). On\n+   --  return, Length is set to the number of characters stored in Result. The\n+   --  caller must ensure that Result is long enough (an easy choice is to set\n+   --  the length equal to the S'Length, since decoding can never increase the\n+   --  string length). If the length of Result is insufficient Constraint_Error\n+   --  will be raised.\n+\n+   function Decode_Wide_Wide_String (S : String) return Wide_Wide_String;\n+   pragma Inline (Decode_Wide_Wide_String);\n+   --  Same as above function but for Wide_Wide_String output\n+\n+   procedure Decode_Wide_Wide_String\n+     (S      : String;\n+      Result : out Wide_Wide_String;\n+      Length : out Natural);\n+   --  Same as above procedure, but for Wide_Wide_String output\n+\n+   function Validate_Wide_String (S : String) return Boolean;\n+   --  This function inspects the string S to determine if it contains only\n+   --  valid encodings corresponding to Wide_Character values using the\n+   --  given encoding. If a call to Decode_Wide_String (S) would return\n+   --  without raising Constraint_Error, then Validate_Wide_String will\n+   --  return True. If the call would have raised Constraint_Error, then\n+   --  Validate_Wide_String will return False.\n+\n+   function Validate_Wide_Wide_String (S : String) return Boolean;\n+   --  Similar to Validate_Wide_String, except that it succeeds if the string\n+   --  contains only encodings corresponding to Wide_Wide_Character values.\n+\n+   procedure Decode_Wide_Character\n+     (Input  : String;\n+      Ptr    : in out Natural;\n+      Result : out Wide_Character);\n+   pragma Inline (Decode_Wide_Character);\n+   --  This is a lower level procedure that decodes a single character using\n+   --  the given encoding method. The encoded character is stored in Input,\n+   --  starting at Input (Ptr). The resulting output character is stored in\n+   --  Result, and on return Ptr is updated past the input character or\n+   --  encoding sequence. Constraint_Error will be raised if the input has\n+   --  has a character that cannot be represented using the given encoding,\n+   --  or if Ptr is outside the bounds of the Input string.\n+\n+   procedure Decode_Wide_Wide_Character\n+     (Input  : String;\n+      Ptr    : in out Natural;\n+      Result : out Wide_Wide_Character);\n+   --  Same as above procedure but with Wide_Wide_Character input\n+\n+   procedure Next_Wide_Character (Input : String; Ptr : in out Natural);\n+   --  This procedure examines the input string starting at Input (Ptr), and\n+   --  advances Ptr past one character in the encoded string, so that on return\n+   --  Ptr points to the next encoded character. Constraint_Error is raised if\n+   --  an invalid encoding is encountered, or the end of the string is reached\n+   --  or if Ptr is less than String'First on entry, or if the character\n+   --  skipped is not a valid Wide_Character code. This call may be more\n+   --  efficient than calling Decode_Wide_Character and discarding the result.\n+\n+   procedure Prev_Wide_Character (Input : String; Ptr : in out Natural);\n+   --  This procedure is similar to Next_Encoded_Character except that it moves\n+   --  backwards in the string, so that on return, Ptr is set to point to the\n+   --  previous encoded character. Constraint_Error is raised if the start of\n+   --  the string is encountered. It is valid for Ptr to be one past the end\n+   --  of the string for this call (in which case on return it will point to\n+   --  the last encoded character).\n+   --\n+   --  Note: it is not generally possible to do this function efficiently with\n+   --  all encodings, the current implementation is only efficient for the case\n+   --  of UTF-8 (Encoding_Method = WCEM_UTF8) and Brackets (Encoding_Method =\n+   --  WCEM_Brackets). For all other encodings, we work by starting at the\n+   --  beginning of the string and moving forward till Ptr is reached, which\n+   --  is correct but slow.\n+\n+   procedure Next_Wide_Wide_Character (Input : String; Ptr : in out Natural);\n+   --  Similar to Next_Wide_Character except that codes skipped must be valid\n+   --  Wide_Wide_Character codes.\n+\n+   procedure Prev_Wide_Wide_Character (Input : String; Ptr : in out Natural);\n+   --  Similar to Prev_Wide_Character except that codes skipped must be valid\n+   --  Wide_Wide_Character codes.\n+\n+end GNAT.Decode_String;"}, {"sha": "ca03ace5260f870be22336610a5474ba7031f9e0", "filename": "gcc/ada/g-deutst.ads", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-deutst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-deutst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-deutst.ads?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,45 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               G N A T . D E C O D E _ U T F 8 _ S T R I N G              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a pre-instantiation of GNAT.Decode_String for the\n+--  common case of UTF-8 encoding. As noted in the documentation of that\n+--  package, this UTF-8 instantiation is efficient and specialized so that\n+--  it has only the code for the UTF-8 case. See g-decstr.ads for full\n+--  documentation on this package.\n+\n+with GNAT.Decode_String;\n+\n+with System.WCh_Con;\n+\n+package GNAT.Decode_UTF8_String is\n+  new GNAT.Decode_String (System.WCh_Con.WCEM_UTF8);"}, {"sha": "6f1411693fe6f76d17fa688128cbdbf42272388c", "filename": "gcc/ada/g-encstr.adb", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-encstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-encstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-encstr.adb?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,260 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . E N C O D E _ S T R I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces; use Interfaces;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+with System.WCh_Cnv; use System.WCh_Cnv;\n+\n+package body GNAT.Encode_String is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Bad;\n+   pragma No_Return (Bad);\n+   --  Raise error for bad character code\n+\n+   procedure Past_End;\n+   pragma No_Return (Past_End);\n+   --  Raise error for off end of string\n+\n+   ---------\n+   -- Bad --\n+   ---------\n+\n+   procedure Bad is\n+   begin\n+      raise Constraint_Error with\n+        \"character cannot be encoded with given Encoding_Method\";\n+   end Bad;\n+\n+   ------------------------\n+   -- Encode_Wide_String --\n+   ------------------------\n+\n+   function Encode_Wide_String (S : Wide_String) return String is\n+      Long : constant Natural := WC_Longest_Sequences (Encoding_Method);\n+      Result : String (1 .. S'Length * Long);\n+      Length : Natural;\n+   begin\n+      Encode_Wide_String (S, Result, Length);\n+      return Result (1 .. Length);\n+   end Encode_Wide_String;\n+\n+   procedure Encode_Wide_String\n+     (S      : Wide_String;\n+      Result : out String;\n+      Length : out Natural)\n+   is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      for J in S'Range loop\n+         Encode_Wide_Character (S (J), Result, Ptr);\n+      end loop;\n+\n+      Length := Ptr - S'First;\n+   end Encode_Wide_String;\n+\n+   -----------------------------\n+   -- Encode_Wide_Wide_String --\n+   -----------------------------\n+\n+   function Encode_Wide_Wide_String (S : Wide_Wide_String) return String is\n+      Long : constant Natural := WC_Longest_Sequences (Encoding_Method);\n+      Result : String (1 .. S'Length * Long);\n+      Length : Natural;\n+   begin\n+      Encode_Wide_Wide_String (S, Result, Length);\n+      return Result (1 .. Length);\n+   end Encode_Wide_Wide_String;\n+\n+   procedure Encode_Wide_Wide_String\n+     (S      : Wide_Wide_String;\n+      Result : out String;\n+      Length : out Natural)\n+   is\n+      Ptr : Natural;\n+\n+   begin\n+      Ptr := S'First;\n+      for J in S'Range loop\n+         Encode_Wide_Wide_Character (S (J), Result, Ptr);\n+      end loop;\n+\n+      Length := Ptr - S'First;\n+   end Encode_Wide_Wide_String;\n+\n+   ---------------------------\n+   -- Encode_Wide_Character --\n+   ---------------------------\n+\n+   procedure Encode_Wide_Character\n+     (Char   : Wide_Character;\n+      Result : in out String;\n+      Ptr    : in out Natural)\n+   is\n+   begin\n+      Encode_Wide_Wide_Character\n+        (Wide_Wide_Character'Val (Wide_Character'Pos (Char)), Result, Ptr);\n+\n+   exception\n+      when Constraint_Error =>\n+         Bad;\n+   end Encode_Wide_Character;\n+\n+   --------------------------------\n+   -- Encode_Wide_Wide_Character --\n+   --------------------------------\n+\n+   procedure Encode_Wide_Wide_Character\n+     (Char   : Wide_Wide_Character;\n+      Result : in out String;\n+      Ptr    : in out Natural)\n+   is\n+      U : Unsigned_32;\n+\n+      procedure Out_Char (C : Character);\n+      pragma Inline (Out_Char);\n+      --  Procedure to store one character for instantiation below\n+\n+      --------------\n+      -- Out_Char --\n+      --------------\n+\n+      procedure Out_Char (C : Character) is\n+      begin\n+         if Ptr > Result'Last then\n+            Past_End;\n+         else\n+            Result (Ptr) := C;\n+            Ptr := Ptr + 1;\n+         end if;\n+      end Out_Char;\n+\n+   --  Start of processing for Encode_Wide_Wide_Character;\n+\n+   begin\n+      --  Efficient code for UTF-8 case\n+\n+      if Encoding_Method = WCEM_UTF8 then\n+\n+         --  Note: for details of UTF8 encoding see RFC 3629\n+\n+         U := Unsigned_32 (Wide_Wide_Character'Pos (Char));\n+\n+         --  16#00_0000#-16#00_007F#: 0xxxxxxx\n+\n+         if U <= 16#00_007F# then\n+            Out_Char (Character'Val (U));\n+\n+         --  16#00_0080#-16#00_07FF#: 110xxxxx 10xxxxxx\n+\n+         elsif U <= 16#00_07FF# then\n+            Out_Char (Character'Val (2#11000000# or Shift_Right (U, 6)));\n+            Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+         --  16#00_0800#-16#00_FFFF#: 1110xxxx 10xxxxxx 10xxxxxx\n+\n+         elsif U <= 16#00_FFFF# then\n+            Out_Char (Character'Val (2#11100000# or Shift_Right (U, 12)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                          and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+         --  16#01_0000#-16#10_FFFF#: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+         elsif U <= 16#10_FFFF# then\n+            Out_Char (Character'Val (2#11110000# or Shift_Right (U, 18)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 12)\n+                                                          and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                       and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+         --  16#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx\n+         --                               10xxxxxx 10xxxxxx\n+\n+         elsif U <= 16#03FF_FFFF# then\n+            Out_Char (Character'Val (2#11111000# or Shift_Right (U, 24)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 18)\n+                                                       and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 12)\n+                                                       and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (Shift_Right (U, 6)\n+                                                       and 2#00111111#)));\n+            Out_Char (Character'Val (2#10000000# or (U and 2#00111111#)));\n+\n+         --  All other cases are invalid character codes, not this includes:\n+\n+         --  16#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx\n+         --                               10xxxxxx 10xxxxxx 10xxxxxx\n+\n+         --  since Wide_Wide_Character values cannot exceed 16#3F_FFFF#\n+\n+         else\n+            Bad;\n+         end if;\n+\n+      --  All encoding methods other than UTF-8\n+\n+      else\n+         Non_UTF8 : declare\n+            procedure UTF_32_To_String is\n+              new UTF_32_To_Char_Sequence (Out_Char);\n+            --  Instantiate conversion procedure with above Out_Char routine\n+\n+         begin\n+            UTF_32_To_String\n+              (UTF_32_Code (Wide_Wide_Character'Pos (Char)), Encoding_Method);\n+\n+         exception\n+            when Constraint_Error =>\n+               Bad;\n+         end Non_UTF8;\n+      end if;\n+   end Encode_Wide_Wide_Character;\n+\n+   --------------\n+   -- Past_End --\n+   --------------\n+\n+   procedure Past_End is\n+   begin\n+      raise Constraint_Error with \"past end of string\";\n+   end Past_End;\n+\n+end GNAT.Encode_String;"}, {"sha": "5862bbe182d5fbe794d24618a6d025b596eaffde", "filename": "gcc/ada/g-encstr.ads", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-encstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-encstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-encstr.ads?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,111 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . E N C O D E _ S T R I N G                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This generic package provides utility routines for converting from\n+--  Wide_String or Wide_Wide_String to encoded String using a specified\n+--  encoding convention, which is supplied as the generic parameter. If\n+--  this parameter is a known at compile time constant (e.g. a constant\n+--  definned in System.WCh_Con), the instantiation is specialized so that\n+--  it applies only to this specified coding.\n+\n+--  Note: this package is only about encoding sequences of 16- or 32-bit\n+--  characters into a sequence of 8-bit codes. It knows nothing at all about\n+--  the character encodings being used for the input Wide_Character and\n+--  Wide_Wide_Character values, although some of the encoding methods (notably\n+--  JIS and EUC) have built in assumptions about the range of possible input\n+--  code values. Most often the input will be Unicode/ISO-10646 as specified by\n+--  the Ada RM, but this package does not make any assumptions about the\n+--  character coding, and in the case of UTF-8 all possible code values can be\n+--  encoded. See also the packages Ada.Wide_[Wide_]Characters.Unicode for\n+--  unicode specific functions.\n+\n+--  Note on brackets encoding (WCEM_Brackets). On input, upper half characters\n+--  can be represented as [\"hh\"] but the routines in this package will only use\n+--  brackets encodings for codes higher than 16#FF#, so upper half characters\n+--  will be output as single Character values.\n+\n+with System.WCh_Con;\n+\n+generic\n+   Encoding_Method : System.WCh_Con.WC_Encoding_Method;\n+\n+package GNAT.Encode_String is\n+   pragma Pure;\n+\n+   function Encode_Wide_String (S : Wide_String) return String;\n+   pragma Inline (Encode_Wide_String);\n+   --  Encode the given Wide_String, returning a String encoded using the\n+   --  given encoding method. Constraint_Error will be raised if the encoding\n+   --  method cannot accomodate the input data.\n+\n+   procedure Encode_Wide_String\n+     (S      : Wide_String;\n+      Result : out String;\n+      Length : out Natural);\n+   --  Encode the given Wide_String, storing the encoded string in Result,\n+   --  with Length being set to the length of the encoded string. The caller\n+   --  must ensure that Result is long enough (see useful constants defined\n+   --  in System.WCh_Con: WC_Longest_Sequence, WC_Longest_Sequences). If the\n+   --  length of Result is insufficient Constraint_Error will be raised.\n+   --  Constraint_Error will also be raised if the encoding method cannot\n+   --  accomodate the input data.\n+\n+   function Encode_Wide_Wide_String (S : Wide_Wide_String) return String;\n+   pragma Inline (Encode_Wide_Wide_String);\n+   --  Same as above function but for Wide_Wide_String input\n+\n+   procedure Encode_Wide_Wide_String\n+     (S      : Wide_Wide_String;\n+      Result : out String;\n+      Length : out Natural);\n+   --  Same as above procedure, but for Wide_Wide_String input\n+\n+   procedure Encode_Wide_Character\n+     (Char   : Wide_Character;\n+      Result : in out String;\n+      Ptr    : in out Natural);\n+   pragma Inline (Encode_Wide_Character);\n+   --  This is a lower level procedure that encodes the single character Char.\n+   --  The output is stored in Result starting at Result (Ptr), and Ptr is\n+   --  updated past the stored value. Constraint_Error is raised if Result\n+   --  is not long enough to accomodate the result, or if the encoding method\n+   --  specified does not accomodate the input character value, or if Ptr is\n+   --  outside the bounds of the Result string.\n+\n+   procedure Encode_Wide_Wide_Character\n+     (Char   : Wide_Wide_Character;\n+      Result : in out String;\n+      Ptr    : in out Natural);\n+   --  Same as above procedure but with Wide_Wide_Character input\n+\n+end GNAT.Encode_String;"}, {"sha": "3c4632866bfcc8f478cafe00c340011d90e10658", "filename": "gcc/ada/g-enutst.ads", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-enutst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fg-enutst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-enutst.ads?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -0,0 +1,45 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               G N A T . E N C O D E _ U T F 8 _ S T R I N G              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2007, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a pre-instantiation of GNAT.Encode_String for the\n+--  common case of UTF-8 encoding. As noted in the documentation of that\n+--  package, this UTF-8 instantiation is efficient and specialized so that\n+--  it has only the code for the UTF-8 case. See g-encstr.ads for full\n+--  documentation on this package.\n+\n+with GNAT.Encode_String;\n+\n+with System.WCh_Con;\n+\n+package GNAT.Encode_UTF8_String is\n+  new GNAT.Encode_String (System.WCh_Con.WCEM_UTF8);"}, {"sha": "d4e7bd387d99ea39c35d53a0efa38e40b64f6dbf", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26b5a8f52b45dcbe796cb472997b844b5b22c5d/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=b26b5a8f52b45dcbe796cb472997b844b5b22c5d", "patch": "@@ -28,13 +28,18 @@ with Csets;    use Csets;\n with Hostparm; use Hostparm;\n with Namet;    use Namet;\n with Opt;      use Opt;\n+with Output;   use Output;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Scans;    use Scans;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Uintp;    use Uintp;\n \n+with GNAT.Byte_Order_Mark; use GNAT.Byte_Order_Mark;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+\n package body Scn is\n \n    use ASCII;\n@@ -266,6 +271,42 @@ package body Scn is\n          Set_License (Current_Source_File, Determine_License);\n       end if;\n \n+      --  Check for BOM\n+\n+      declare\n+         BOM : BOM_Kind;\n+         Len : Natural;\n+         Tst : String (1 .. 5);\n+\n+      begin\n+         for J in 1 .. 5 loop\n+            Tst (J) := Source (Scan_Ptr + Source_Ptr (J) - 1);\n+         end loop;\n+\n+         Read_BOM (Tst, Len, BOM, False);\n+\n+         case BOM is\n+            when UTF8_All =>\n+               Scan_Ptr := Scan_Ptr + Source_Ptr (Len);\n+               Wide_Character_Encoding_Method := WCEM_UTF8;\n+               Upper_Half_Encoding := True;\n+\n+            when UTF16_LE | UTF16_BE =>\n+               Write_Line (\"UTF-16 encoding format not recognized\");\n+               raise Unrecoverable_Error;\n+\n+            when UTF32_LE | UTF32_BE =>\n+               Write_Line (\"UTF-32 encoding format not recognized\");\n+               raise Unrecoverable_Error;\n+\n+            when Unknown =>\n+               null;\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+      end;\n+\n       --  Because of the License stuff above, Scng.Initialize_Scanner cannot\n       --  call Scan. Scan initial token (note this initializes Prev_Token,\n       --  Prev_Token_Ptr)."}]}