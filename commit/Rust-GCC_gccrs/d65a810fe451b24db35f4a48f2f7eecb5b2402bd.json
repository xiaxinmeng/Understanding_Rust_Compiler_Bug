{"sha": "d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY1YTgxMGZlNDUxYjI0ZGIzNWY0YTQ4ZjJmN2VlY2I1YjI0MDJiZA==", "commit": {"author": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2004-03-19T22:34:17Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2004-03-19T22:34:17Z"}, "message": "[multiple changes]\n\n2004-03-19  Matthias Klose  <doko@debian.org>\n\n        * Makefile.am: Update\n        * Makefile.in: Regenerate.\n        * src/pa/ffi.h.in: Remove.\n        * src/pa/ffitarget.h: New file.\n\n2004-02-10  Randolph Chung  <tausq@debian.org>\n\n        * Makefile.am: Add PA support.\n        * Makefile.in: Regenerate.\n        * include/Makefile.in: Regenerate.\n        * configure.ac: Add PA target.\n        * configure: Regenerate.\n        * src/pa/ffi.c: New file.\n        * src/pa/ffi.h.in: Add PA support.\n        * src/pa/linux.S: New file.\n        * prep_cif.c: Add PA support.\n\nFrom-SVN: r79702", "tree": {"sha": "1d5e90eb0399a43f056ab1dcedc49e1b1b1085d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5e90eb0399a43f056ab1dcedc49e1b1b1085d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/comments", "author": null, "committer": null, "parents": [{"sha": "d511a273463eb5bc42bcc6f66b67b03b682a46b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d511a273463eb5bc42bcc6f66b67b03b682a46b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d511a273463eb5bc42bcc6f66b67b03b682a46b5"}], "stats": {"total": 1130, "additions": 1067, "deletions": 63}, "files": [{"sha": "32c45ce118015305c72ffdb8eedf3c48268cb8c4", "filename": "libffi/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -1,3 +1,22 @@\n+2004-03-19  Matthias Klose  <doko@debian.org>\n+\n+\t* Makefile.am: Update \n+\t* Makefile.in: Regenerate.\n+\t* src/pa/ffi.h.in: Remove.\n+\t* src/pa/ffitarget.h: New file.\n+\n+2004-02-10  Randolph Chung  <tausq@debian.org>\n+\n+\t* Makefile.am: Add PA support.\n+\t* Makefile.in: Regenerate.\n+\t* include/Makefile.in: Regenerate.\n+\t* configure.ac: Add PA target.\n+\t* configure: Regenerate.\n+\t* src/pa/ffi.c: New file.\n+\t* src/pa/ffi.h.in: Add PA support.\n+\t* src/pa/linux.S: New file.\n+\t* prep_cif.c: Add PA support.\n+\n 2004-03-16  Hosaka Yuji  <hos@tamanegi.org>\n \n \t* src/types.c: Fix alignment size of X86_WIN32 case int64 and"}, {"sha": "a59df23e3a8ca18e27cd512bdd1390ac3be3324d", "filename": "libffi/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -22,7 +22,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 \\\n \tsrc/sparc/v8.S src/sparc/v9.S src/sparc/ffitarget.h \\\n \tsrc/sparc/ffi.c \\\n \tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n-\tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h\n+\tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n+\tsrc/pa/ffi.c src/pa/linux.S\n \n ## ################################################################\n \n@@ -135,6 +136,9 @@ endif\n if SH64\n nodist_libffi_la_SOURCES += src/sh64/sysv.S src/sh64/ffi.c\n endif\n+if PA\n+nodist_libffi_la_SOURCES += src/pa/linux.S src/pa/ffi.c\n+endif\n \n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)"}, {"sha": "1ef63d6c271cc6427d7857299cc0b693d19f95fe", "filename": "libffi/Makefile.in", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -54,6 +54,7 @@ target_triplet = @target@\n @X86_64_TRUE@am__append_14 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n @SH_TRUE@am__append_15 = src/sh/sysv.S src/sh/ffi.c\n @SH64_TRUE@am__append_16 = src/sh64/sysv.S src/sh64/ffi.c\n+@PA_TRUE@am__append_17 = src/pa/linux.S src/pa/ffi.c\n ACLOCAL = @ACLOCAL@\n ALLOCA = @ALLOCA@\n ALPHA_FALSE = @ALPHA_FALSE@\n@@ -113,6 +114,8 @@ PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n+PA_FALSE = @PA_FALSE@\n+PA_TRUE = @PA_TRUE@\n POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@\n POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@\n POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@\n@@ -209,7 +212,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 \\\n \tsrc/sparc/v8.S src/sparc/v9.S src/sparc/ffitarget.h \\\n \tsrc/sparc/ffi.c \\\n \tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n-\tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h\n+\tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n+\tsrc/pa/ffi.c src/pa/linux.S\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -269,7 +273,7 @@ libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n \t\tsrc/raw_api.c src/java_raw_api.c\n \n \n-nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) $(am__append_3) $(am__append_4) $(am__append_5) $(am__append_6) $(am__append_7) $(am__append_8) $(am__append_9) $(am__append_10) $(am__append_11) $(am__append_12) $(am__append_13) $(am__append_14) $(am__append_15) $(am__append_16)\n+nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) $(am__append_3) $(am__append_4) $(am__append_5) $(am__append_6) $(am__append_7) $(am__append_8) $(am__append_9) $(am__append_10) $(am__append_11) $(am__append_12) $(am__append_13) $(am__append_14) $(am__append_15) $(am__append_16) $(am__append_17)\n \n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n@@ -316,25 +320,26 @@ am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_64_TRUE@\tsrc/x86/ffi.lo src/x86/sysv.lo\n @SH_TRUE@am__objects_15 = src/sh/sysv.lo src/sh/ffi.lo\n @SH64_TRUE@am__objects_16 = src/sh64/sysv.lo src/sh64/ffi.lo\n+@PA_TRUE@am__objects_17 = src/pa/linux.lo src/pa/ffi.lo\n nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n \t$(am__objects_3) $(am__objects_4) $(am__objects_5) \\\n \t$(am__objects_6) $(am__objects_7) $(am__objects_8) \\\n \t$(am__objects_9) $(am__objects_10) $(am__objects_11) \\\n \t$(am__objects_12) $(am__objects_13) $(am__objects_14) \\\n-\t$(am__objects_15) $(am__objects_16)\n+\t$(am__objects_15) $(am__objects_16) $(am__objects_17)\n libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) $(nodist_libffi_la_OBJECTS)\n libffi_convenience_la_LDFLAGS =\n libffi_convenience_la_LIBADD =\n-am__objects_17 = src/debug.lo src/prep_cif.lo src/types.lo \\\n+am__objects_18 = src/debug.lo src/prep_cif.lo src/types.lo \\\n \tsrc/raw_api.lo src/java_raw_api.lo\n-am_libffi_convenience_la_OBJECTS = $(am__objects_17)\n-am__objects_18 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n+am_libffi_convenience_la_OBJECTS = $(am__objects_18)\n+am__objects_19 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n \t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n-\t$(am__objects_16)\n-nodist_libffi_convenience_la_OBJECTS = $(am__objects_18)\n+\t$(am__objects_16) $(am__objects_17)\n+nodist_libffi_convenience_la_OBJECTS = $(am__objects_19)\n libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n \t$(nodist_libffi_convenience_la_OBJECTS)\n \n@@ -360,11 +365,11 @@ RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \\\n \tcheck-recursive installcheck-recursive\n DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/configure \\\n \t../ABOUT-NLS ../COPYING ../COPYING.LIB ../ChangeLog ../README \\\n-\t../compile ../config.guess ../config.rpath ../config.sub \\\n-\t../configure ../configure.in ../install-sh ../ltcf-c.sh \\\n-\t../ltcf-cxx.sh ../ltcf-gcj.sh ../ltconfig ../ltmain.sh \\\n-\t../missing ../mkinstalldirs ../ylwrap ChangeLog Makefile.am \\\n-\tacinclude.m4 aclocal.m4 configure configure.ac fficonfig.h.in\n+\t../config.guess ../config.rpath ../config.sub ../configure \\\n+\t../configure.in ../install-sh ../ltcf-c.sh ../ltcf-cxx.sh \\\n+\t../ltcf-gcj.sh ../ltconfig ../ltmain.sh ../missing \\\n+\t../mkinstalldirs ../ylwrap ChangeLog Makefile.am acinclude.m4 \\\n+\taclocal.m4 configure configure.ac fficonfig.h.in\n DIST_SUBDIRS = $(SUBDIRS)\n SOURCES = $(libffi_la_SOURCES) $(nodist_libffi_la_SOURCES) $(libffi_convenience_la_SOURCES) $(nodist_libffi_convenience_la_SOURCES)\n \n@@ -519,6 +524,11 @@ src/sh64/$(am__dirstamp):\n \t@: > src/sh64/$(am__dirstamp)\n src/sh64/sysv.lo: src/sh64/$(am__dirstamp)\n src/sh64/ffi.lo: src/sh64/$(am__dirstamp)\n+src/pa/$(am__dirstamp):\n+\t@$(mkinstalldirs) src/pa\n+\t@: > src/pa/$(am__dirstamp)\n+src/pa/linux.lo: src/pa/$(am__dirstamp)\n+src/pa/ffi.lo: src/pa/$(am__dirstamp)\n libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) \n \t$(LINK) -rpath $(toolexeclibdir) $(libffi_la_LDFLAGS) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)\n libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) \n@@ -552,6 +562,10 @@ mostlyclean-compile:\n \t-rm -f src/mips/n32.lo\n \t-rm -f src/mips/o32.$(OBJEXT)\n \t-rm -f src/mips/o32.lo\n+\t-rm -f src/pa/ffi.$(OBJEXT)\n+\t-rm -f src/pa/ffi.lo\n+\t-rm -f src/pa/linux.$(OBJEXT)\n+\t-rm -f src/pa/linux.lo\n \t-rm -f src/powerpc/aix.$(OBJEXT)\n \t-rm -f src/powerpc/aix.lo\n \t-rm -f src/powerpc/aix_closure.$(OBJEXT)\n@@ -817,6 +831,15 @@ src/sh64/sysv.obj: src/sh64/sysv.S\n src/sh64/sysv.lo: src/sh64/sysv.S\n \t$(LIBTOOL) --mode=compile $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS) -c -o src/sh64/sysv.lo `test -f 'src/sh64/sysv.S' || echo '$(srcdir)/'`src/sh64/sysv.S\n \n+src/pa/linux.o: src/pa/linux.S\n+\t$(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS) -c -o src/pa/linux.o `test -f 'src/pa/linux.S' || echo '$(srcdir)/'`src/pa/linux.S\n+\n+src/pa/linux.obj: src/pa/linux.S\n+\t$(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS) -c -o src/pa/linux.obj `if test -f 'src/pa/linux.S'; then $(CYGPATH_W) 'src/pa/linux.S'; else $(CYGPATH_W) '$(srcdir)/src/pa/linux.S'; fi`\n+\n+src/pa/linux.lo: src/pa/linux.S\n+\t$(LIBTOOL) --mode=compile $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS) -c -o src/pa/linux.lo `test -f 'src/pa/linux.S' || echo '$(srcdir)/'`src/pa/linux.S\n+\n .c.o:\n \t$(COMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<\n \n@@ -988,6 +1011,15 @@ src/sh64/ffi.obj: src/sh64/ffi.c\n src/sh64/ffi.lo: src/sh64/ffi.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/sh64/ffi.lo `test -f 'src/sh64/ffi.c' || echo '$(srcdir)/'`src/sh64/ffi.c\n \n+src/pa/ffi.o: src/pa/ffi.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/pa/ffi.o `test -f 'src/pa/ffi.c' || echo '$(srcdir)/'`src/pa/ffi.c\n+\n+src/pa/ffi.obj: src/pa/ffi.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/pa/ffi.obj `if test -f 'src/pa/ffi.c'; then $(CYGPATH_W) 'src/pa/ffi.c'; else $(CYGPATH_W) '$(srcdir)/src/pa/ffi.c'; fi`\n+\n+src/pa/ffi.lo: src/pa/ffi.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o src/pa/ffi.lo `test -f 'src/pa/ffi.c' || echo '$(srcdir)/'`src/pa/ffi.c\n+\n mostlyclean-libtool:\n \t-rm -f *.lo\n \n@@ -999,6 +1031,7 @@ clean-libtool:\n \t-rm -rf src/ia64/.libs src/ia64/_libs\n \t-rm -rf src/m68k/.libs src/m68k/_libs\n \t-rm -rf src/mips/.libs src/mips/_libs\n+\t-rm -rf src/pa/.libs src/pa/_libs\n \t-rm -rf src/powerpc/.libs src/powerpc/_libs\n \t-rm -rf src/s390/.libs src/s390/_libs\n \t-rm -rf src/sh/.libs src/sh/_libs\n@@ -1164,7 +1197,7 @@ distcleancheck_listfiles = find . -type f -print\n distdir: $(DISTFILES)\n \t$(am__remove_distdir)\n \tmkdir $(distdir)\n-\t$(mkinstalldirs) $(distdir)/.. $(distdir)/include $(distdir)/src/alpha $(distdir)/src/arm $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/powerpc $(distdir)/src/s390 $(distdir)/src/sh $(distdir)/src/sh64 $(distdir)/src/sparc $(distdir)/src/x86\n+\t$(mkinstalldirs) $(distdir)/.. $(distdir)/include $(distdir)/src/alpha $(distdir)/src/arm $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/pa $(distdir)/src/powerpc $(distdir)/src/s390 $(distdir)/src/sh $(distdir)/src/sh64 $(distdir)/src/sparc $(distdir)/src/x86\n \t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n \ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n \tlist='$(DISTFILES)'; for file in $$list; do \\\n@@ -1307,6 +1340,7 @@ distclean-generic:\n \t-rm -f src/sh/$(am__dirstamp)\n \t-rm -f src/m68k/$(am__dirstamp)\n \t-rm -f src/sparc/$(am__dirstamp)\n+\t-rm -f src/pa/$(am__dirstamp)\n \t-rm -f src/$(am__dirstamp)\n \t-rm -f src/ia64/$(am__dirstamp)\n \t-rm -f src/alpha/$(am__dirstamp)"}, {"sha": "a40d6992a101229e663295937a3f4f384e6038c5", "filename": "libffi/configure", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -273,7 +273,7 @@ PACKAGE_VERSION='2.1'\n PACKAGE_STRING='libffi 2.1'\n PACKAGE_BUGREPORT='http://gcc.gnu.org/bugs.html'\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS CCAS CCASFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT TESTSUBDIR_TRUE TESTSUBDIR_FALSE AM_RUNTESTFLAGS MIPS_IRIX_TRUE MIPS_IRIX_FALSE MIPS_LINUX_TRUE MIPS_LINUX_FALSE SPARC_TRUE SPARC_FALSE X86_TRUE X86_FALSE X86_WIN32_TRUE X86_WIN32_FALSE ALPHA_TRUE ALPHA_FALSE IA64_TRUE IA64_FALSE M68K_TRUE M68K_FALSE POWERPC_TRUE POWERPC_FALSE POWERPC_AIX_TRUE POWERPC_AIX_FALSE POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE ARM_TRUE ARM_FALSE S390_TRUE S390_FALSE X86_64_TRUE X86_64_FALSE SH_TRUE SH_FALSE SH64_TRUE SH64_FALSE CPP CPPFLAGS EGREP ALLOCA HAVE_LONG_DOUBLE TARGET TARGETDIR toolexecdir toolexeclibdir tool_include_dir gcc_version LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS CCAS CCASFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT TESTSUBDIR_TRUE TESTSUBDIR_FALSE AM_RUNTESTFLAGS MIPS_IRIX_TRUE MIPS_IRIX_FALSE MIPS_LINUX_TRUE MIPS_LINUX_FALSE SPARC_TRUE SPARC_FALSE X86_TRUE X86_FALSE X86_WIN32_TRUE X86_WIN32_FALSE ALPHA_TRUE ALPHA_FALSE IA64_TRUE IA64_FALSE M68K_TRUE M68K_FALSE POWERPC_TRUE POWERPC_FALSE POWERPC_AIX_TRUE POWERPC_AIX_FALSE POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE ARM_TRUE ARM_FALSE S390_TRUE S390_FALSE X86_64_TRUE X86_64_FALSE SH_TRUE SH_FALSE SH64_TRUE SH64_FALSE PA_TRUE PA_FALSE CPP CPPFLAGS EGREP ALLOCA HAVE_LONG_DOUBLE TARGET TARGETDIR toolexecdir toolexeclibdir tool_include_dir gcc_version LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -925,7 +925,7 @@ esac\n     else\n       echo \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n     fi\n-    cd $ac_popdir\n+    cd \"$ac_popdir\"\n   done\n fi\n \n@@ -2409,8 +2409,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2468,8 +2467,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2585,8 +2583,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2640,8 +2637,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2686,8 +2682,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2731,8 +2726,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3794,7 +3788,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 3797 \"configure\"' > conftest.$ac_ext\n+  echo '#line 3791 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -3936,8 +3930,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4193,8 +4186,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4309,6 +4301,7 @@ s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n sh-*-linux* | sh[34]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n sh64-*-linux* | sh5*-*-linux*) TARGET=SH64; TARGETDIR=sh64;;\n+hppa-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;\n esac\n \n \n@@ -4480,6 +4473,16 @@ else\n fi\n \n \n+\n+if test x$TARGET = xPA; then\n+  PA_TRUE=\n+  PA_FALSE='#'\n+else\n+  PA_TRUE='#'\n+  PA_FALSE=\n+fi\n+\n+\n case x$TARGET in\n   xMIPS*) TARGET=MIPS ;;\n   *) ;;\n@@ -4768,8 +4771,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4970,8 +4972,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5034,8 +5035,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5116,8 +5116,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5258,8 +5257,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5396,8 +5394,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5467,8 +5464,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5555,8 +5551,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5597,8 +5592,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5766,8 +5760,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5833,8 +5826,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6233,6 +6225,13 @@ echo \"$as_me: error: conditional \\\"SH64\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&2;}\n    { (exit 1); exit 1; }; }\n fi\n+if test -z \"${PA_TRUE}\" && test -z \"${PA_FALSE}\"; then\n+  { { echo \"$as_me:$LINENO: error: conditional \\\"PA\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&5\n+echo \"$as_me: error: conditional \\\"PA\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_clean_files_save=$ac_clean_files\n@@ -6878,6 +6877,8 @@ s,@SH_TRUE@,$SH_TRUE,;t t\n s,@SH_FALSE@,$SH_FALSE,;t t\n s,@SH64_TRUE@,$SH64_TRUE,;t t\n s,@SH64_FALSE@,$SH64_FALSE,;t t\n+s,@PA_TRUE@,$PA_TRUE,;t t\n+s,@PA_FALSE@,$PA_FALSE,;t t\n s,@CPP@,$CPP,;t t\n s,@CPPFLAGS@,$CPPFLAGS,;t t\n s,@EGREP@,$EGREP,;t t\n@@ -7057,11 +7058,6 @@ esac\n   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;\n   esac\n \n-  if test x\"$ac_file\" != x-; then\n-    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n-echo \"$as_me: creating $ac_file\" >&6;}\n-    rm -f \"$ac_file\"\n-  fi\n   # Let's still pretend it is `configure' which instantiates (i.e., don't\n   # use $as_me), people would be surprised to read:\n   #    /* config.h.  Generated by config.status.  */\n@@ -7100,6 +7096,12 @@ echo \"$as_me: error: cannot find input file: $f\" >&2;}\n \t fi;;\n       esac\n     done` || { (exit 1); exit 1; }\n+\n+  if test x\"$ac_file\" != x-; then\n+    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n+echo \"$as_me: creating $ac_file\" >&6;}\n+    rm -f \"$ac_file\"\n+  fi\n _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF\n   sed \"$ac_vpsub"}, {"sha": "584a7d8a15fd8a73d5457aab6bdd94e0a2ad095d", "filename": "libffi/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -74,6 +74,7 @@ s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n sh-*-linux* | sh[[34]]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n sh64-*-linux* | sh5*-*-linux*) TARGET=SH64; TARGETDIR=sh64;;\n+hppa-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;\n esac\n \n AC_SUBST(AM_RUNTESTFLAGS)\n@@ -98,6 +99,7 @@ AM_CONDITIONAL(S390, test x$TARGET = xS390)\n AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)\n AM_CONDITIONAL(SH, test x$TARGET = xSH)\n AM_CONDITIONAL(SH64, test x$TARGET = xSH64)\n+AM_CONDITIONAL(PA, test x$TARGET = xPA)\n \n case x$TARGET in\n   xMIPS*) TARGET=MIPS ;;"}, {"sha": "37206a6dde1be3e02f8cccbee7f3cee897280e37", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -97,6 +97,8 @@ PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n+PA_FALSE = @PA_FALSE@\n+PA_TRUE = @PA_TRUE@\n POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@\n POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@\n POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@"}, {"sha": "57331fe675a86b5c12bba15e8f9eca7d48785a72", "filename": "libffi/src/pa/ffi.c", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -0,0 +1,603 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n+\n+   HPPA Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+#define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))\n+#define ROUND_DOWN(v, a)  (((size_t)(v) - (a) + 1) & ~((a) - 1))\n+#define MIN_STACK_SIZE  64\n+#define FIRST_ARG_SLOT  9\n+#define DEBUG_LEVEL   0\n+\n+#define fldw(addr, fpreg) asm volatile (\"fldw 0(%0), %%\" #fpreg \"L\" : : \"r\"(addr) : #fpreg)\n+#define fstw(fpreg, addr) asm volatile (\"fstw %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n+#define fldd(addr, fpreg) asm volatile (\"fldd 0(%0), %%\" #fpreg : : \"r\"(addr) : #fpreg)\n+#define fstd(fpreg, addr) asm volatile (\"fstd %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n+\n+#define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)\n+\n+static inline int ffi_struct_type(ffi_type *t)\n+{\n+  size_t sz = t->size;\n+\n+  /* Small structure results are passed in registers,\n+     larger ones are passed by pointer.  */\n+\n+  if (sz <= 1)\n+    return FFI_TYPE_UINT8;\n+  else if (sz == 2)\n+    return FFI_TYPE_UINT16;\n+  else if (sz == 3)\n+    return FFI_TYPE_SMALL_STRUCT1;\n+  else if (sz == 4)\n+    return FFI_TYPE_UINT32;\n+  else if (sz <= 6)\n+    return FFI_TYPE_SMALL_STRUCT2;\n+  else if (sz <= 8)\n+    return FFI_TYPE_UINT64;\n+  else\n+    return FFI_TYPE_STRUCT; /* else, we pass it by pointer.  */\n+}\n+\n+/* PA has a downward growing stack, which looks like this:\n+  \n+   Offset\n+        [ Variable args ]\n+   SP = (4*(n+9))       arg word N\n+   ...\n+   SP-52                arg word 4\n+        [ Fixed args ]\n+   SP-48                arg word 3\n+   SP-44                arg word 2\n+   SP-40                arg word 1\n+   SP-36                arg word 0\n+        [ Frame marker ]\n+   ...\n+   SP-20                RP\n+   SP-4                 previous SP\n+  \n+   First 4 non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23\n+   First 2 non-FP 64-bit args are passed in register pairs, starting\n+     on an even numbered register (i.e. r26/r25 and r24+r23)\n+   First 4 FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L\n+   First 2 FP 64-bit arguments are passed in fr5 and fr7\n+   The rest are passed on the stack starting at SP-52, but 64-bit\n+     arguments need to be aligned to an 8-byte boundary\n+  \n+   This means we can have holes either in the register allocation,\n+   or in the stack.  */\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments\n+  \n+   The following code will put everything into the stack frame\n+   (which was allocated by the asm routine), and on return\n+   the asm routine will load the arguments that should be\n+   passed by register into the appropriate registers\n+  \n+   NOTE: We load floating point args in this function... that means we\n+   assume gcc will not mess with fp regs in here.  */\n+\n+/*@-exportheader@*/\n+void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n+/*@=exportheader@*/\n+{\n+  register unsigned int i;\n+  register ffi_type **p_arg;\n+  register void **p_argv;\n+  unsigned int slot = FIRST_ARG_SLOT - 1;\n+  char *dest_cpy;\n+\n+  debug(1, \"%s: stack = %p, ecif = %p, bytes = %u\\n\", __FUNCTION__, stack, ecif, bytes);\n+\n+  p_arg = ecif->cif->arg_types;\n+  p_argv = ecif->avalue;\n+\n+  for (i = 0; i < ecif->cif->nargs; i++)\n+    {\n+      int type = (*p_arg)->type;\n+\n+      switch (type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\t  slot++;\n+\t  *(SINT32 *)(stack - slot) = *(SINT8 *)(*p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  slot++;\n+\t  *(UINT32 *)(stack - slot) = *(UINT8 *)(*p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT16:\n+\t  slot++;\n+\t  *(SINT32 *)(stack - slot) = *(SINT16 *)(*p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT16:\n+\t  slot++;\n+\t  *(UINT32 *)(stack - slot) = *(UINT16 *)(*p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  slot++;\n+\t  debug(3, \"Storing UINT32 %u in slot %u\\n\", *(UINT32 *)(*p_argv), slot);\n+\t  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  slot += 2;\n+\t  if (slot & 1)\n+\t    slot++;\n+\n+\t  *(UINT32 *)(stack - slot) = (*(UINT64 *)(*p_argv)) >> 32;\n+\t  *(UINT32 *)(stack - slot + 1) = (*(UINT64 *)(*p_argv)) & 0xffffffffUL;\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  /* First 4 args go in fr4L - fr7L */\n+\t  slot++;\n+\t  switch (slot - FIRST_ARG_SLOT)\n+\t    {\n+\t    case 0: fldw(*p_argv, fr4); break;\n+\t    case 1: fldw(*p_argv, fr5); break;\n+\t    case 2: fldw(*p_argv, fr6); break;\n+\t    case 3: fldw(*p_argv, fr7); break;\n+\t    default:\n+\t      /* Other ones are just passed on the stack.  */\n+\t      debug(3, \"Storing UINT32(float) in slot %u\\n\", slot);\n+\t      *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);\n+\t      break;\n+\t    }\n+\t    break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  slot += 2;\n+\t  if (slot & 1)\n+\t    slot++;\n+\t  switch (slot - FIRST_ARG_SLOT + 1)\n+\t    {\n+\t      /* First 2 args go in fr5, fr7 */\n+\t      case 2: fldd(*p_argv, fr5); break;\n+\t      case 4: fldd(*p_argv, fr7); break;\n+\t      default:\n+\t        debug(3, \"Storing UINT64(double) at slot %u\\n\", slot);\n+\t        *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);\n+\t        break;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\n+\t  /* Structs smaller or equal than 4 bytes are passed in one\n+\t     register. Structs smaller or equal 8 bytes are passed in two\n+\t     registers. Larger structures are passed by pointer.  */\n+\n+\t  if((*p_arg)->size <= 4) \n+\t    {\n+\t      slot++;\n+\t      dest_cpy = (char *)(stack - slot);\n+\t      dest_cpy += 4 - (*p_arg)->size;\n+\t      memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);\n+\t    }\n+\t  else if ((*p_arg)->size <= 8) \n+\t    {\n+\t      slot += 2;\n+\t      if (slot & 1)\n+\t        slot++;\n+\t      dest_cpy = (char *)(stack - slot);\n+\t      dest_cpy += 8 - (*p_arg)->size;\n+\t      memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);\n+\t    } \n+\t  else \n+\t    {\n+\t      slot++;\n+\t      *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      p_arg++;\n+      p_argv++;\n+    }\n+\n+  /* Make sure we didn't mess up and scribble on the stack.  */\n+  {\n+    int n;\n+\n+    debug(5, \"Stack setup:\\n\");\n+    for (n = 0; n < (bytes + 3) / 4; n++)\n+      {\n+\tif ((n%4) == 0) { debug(5, \"\\n%08x: \", (unsigned int)(stack - n)); }\n+\tdebug(5, \"%08x \", *(stack - n));\n+      }\n+    debug(5, \"\\n\");\n+  }\n+\n+  FFI_ASSERT(slot * 4 <= bytes);\n+\n+  return;\n+}\n+\n+static void ffi_size_stack_LINUX(ffi_cif *cif)\n+{\n+  ffi_type **ptr;\n+  int i;\n+  int z = 0; /* # stack slots */\n+\n+  for (ptr = cif->arg_types, i = 0; i < cif->nargs; ptr++, i++)\n+    {\n+      int type = (*ptr)->type;\n+\n+      switch (type)\n+\t{\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  z += 2 + (z & 1); /* must start on even regs, so we may waste one */\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  z += 1; /* pass by ptr, callee will copy */\n+\t  break;\n+\n+\tdefault: /* <= 32-bit values */\n+\t  z++;\n+\t}\n+    }\n+\n+  /* We can fit up to 6 args in the default 64-byte stack frame,\n+     if we need more, we need more stack.  */\n+  if (z <= 6)\n+    cif->bytes = MIN_STACK_SIZE; /* min stack size */\n+  else\n+    cif->bytes = 64 + ROUND_UP((z - 6) * sizeof(UINT32), MIN_STACK_SIZE);\n+\n+  debug(3, \"Calculated stack size is %u bytes\\n\", cif->bytes);\n+}\n+\n+/* Perform machine dependent cif processing.  */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  /* Set the return type flag */\n+  switch (cif->rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      cif->flags = (unsigned) cif->rtype->type;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      /* For the return type we have to check the size of the structures.\n+\t If the size is smaller or equal 4 bytes, the result is given back\n+\t in one register. If the size is smaller or equal 8 bytes than we\n+\t return the result in two registers. But if the size is bigger than\n+\t 8 bytes, we work with pointers.  */\n+      cif->flags = ffi_struct_type(cif->rtype);\n+      break;\n+\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      cif->flags = FFI_TYPE_UINT64;\n+      break;\n+\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      break;\n+    }\n+\n+  /* Lucky us, because of the unique PA ABI we get to do our\n+     own stack sizing.  */\n+  switch (cif->abi)\n+    {\n+    case FFI_LINUX:\n+      ffi_size_stack_LINUX(cif);\n+      break;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+\n+  return FFI_OK;\n+}\n+\n+/*@-declundef@*/\n+/*@-exportheader@*/\n+extern void ffi_call_LINUX(void (*)(UINT32 *, extended_cif *, unsigned),\n+\t\t\t   /*@out@*/ extended_cif *,\n+\t\t\t   unsigned, unsigned,\n+\t\t\t   /*@out@*/ unsigned *,\n+\t\t\t   void (*fn)());\n+/*@=declundef@*/\n+/*@=exportheader@*/\n+\n+void ffi_call(/*@dependent@*/ ffi_cif *cif,\n+\t      void (*fn)(),\n+\t      /*@out@*/ void *rvalue,\n+\t      /*@dependent@*/ void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  /* If the return value is a struct and we don't have a return\n+     value address then we need to make one.  */\n+\n+  if ((rvalue == NULL) &&\n+      (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      /*@-sysunrecog@*/\n+      ecif.rvalue = alloca(cif->rtype->size);\n+      /*@=sysunrecog@*/\n+    }\n+  else\n+    ecif.rvalue = rvalue;\n+\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_LINUX:\n+      /*@-usedef@*/\n+      debug(2, \"Calling ffi_call_LINUX: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n+      ffi_call_LINUX(ffi_prep_args_LINUX, &ecif, cif->bytes,\n+\t\t     cif->flags, ecif.rvalue, fn);\n+      /*@=usedef@*/\n+      break;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+\n+#if FFI_CLOSURES\n+/* This is more-or-less an inverse of ffi_call -- we have arguments on\n+   the stack, and we need to fill them into a cif structure and invoke\n+   the user function. This really ought to be in asm to make sure\n+   the compiler doesn't do things we don't expect.  */\n+UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n+{\n+  ffi_cif *cif;\n+  void **avalue;\n+  void *rvalue;\n+  UINT32 ret[2]; /* function can return up to 64-bits in registers */\n+  ffi_type **p_arg;\n+  char *tmp;\n+  int i, avn, slot = FIRST_ARG_SLOT - 1;\n+  register UINT32 r28 asm(\"r28\");\n+\n+  cif = closure->cif;\n+\n+  /* If returning via structure, callee will write to our pointer.  */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    rvalue = (void *)r28;\n+  else\n+    rvalue = &ret[0];\n+\n+  avalue = (void **)alloca(cif->nargs * FFI_SIZEOF_ARG);\n+  avn = cif->nargs;\n+  p_arg = cif->arg_types;\n+\n+  for (i = 0; i < avn; i++)\n+    {\n+      int type = (*p_arg)->type;\n+\n+      switch (type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  slot++;\n+\t  avalue[i] = (char *)(stack - slot) + sizeof(UINT32) - (*p_arg)->size;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  slot += 2;\n+\t  if (slot & 1)\n+\t    slot++;\n+\t  avalue[i] = (void *)(stack - slot);\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  slot++;\n+\t  switch (slot - FIRST_ARG_SLOT)\n+\t    {\n+\t    case 0: fstw(fr4, (void *)(stack - slot)); break;\n+\t    case 1: fstw(fr5, (void *)(stack - slot)); break;\n+\t    case 2: fstw(fr6, (void *)(stack - slot)); break;\n+\t    case 3: fstw(fr7, (void *)(stack - slot)); break;\n+\t    }\n+\t  avalue[i] = (void *)(stack - slot);\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  slot += 2;\n+\t  if (slot & 1)\n+\t    slot++;\n+\t  switch (slot - FIRST_ARG_SLOT + 1)\n+\t    {\n+\t    case 2: fstd(fr5, (void *)(stack - slot)); break;\n+\t    case 4: fstd(fr7, (void *)(stack - slot)); break;\n+\t    }\n+\t  avalue[i] = (void *)(stack - slot);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* Structs smaller or equal than 4 bytes are passed in one\n+\t     register. Structs smaller or equal 8 bytes are passed in two\n+\t     registers. Larger structures are passed by pointer.  */\n+\t  if((*p_arg)->size <= 4) {\n+\t    slot++;\n+\t    avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -\n+\t      (*p_arg)->size;\n+\t  } else if ((*p_arg)->size <= 8) {\n+\t    slot += 2;\n+\t    if (slot & 1)\n+\t      slot++;\n+\t    avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -\n+\t      (*p_arg)->size;\n+\t  } else {\n+\t    slot++;\n+\t    avalue[i] = (void *) *(stack - slot);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      p_arg++;\n+    }\n+\n+  /* Invoke the closure.  */\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  debug(3, \"after calling function, ret[0] = %d, ret[1] = %d\\n\", ret[0], ret[1]);\n+\n+  /* Store the result */\n+  switch (cif->flags)\n+    {\n+    case FFI_TYPE_UINT8:\n+      *(stack - FIRST_ARG_SLOT) = *(UINT8 *)&ret[0];\n+      break;\n+    case FFI_TYPE_SINT8:\n+      *(stack - FIRST_ARG_SLOT) = *(SINT8 *)&ret[0];\n+      break;\n+    case FFI_TYPE_UINT16:\n+      *(stack - FIRST_ARG_SLOT) = *(UINT16 *)&ret[0];\n+      break;\n+    case FFI_TYPE_SINT16:\n+      *(stack - FIRST_ARG_SLOT) = *(SINT16 *)&ret[0];\n+      break;\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_UINT32:\n+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];\n+      break;\n+    case FFI_TYPE_SINT32:\n+      *(stack - FIRST_ARG_SLOT) = *(SINT32 *)&ret[0];\n+      break;\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];\n+      *(stack - FIRST_ARG_SLOT - 1) = *(UINT32 *)&ret[1];\n+      break;\n+\n+    case FFI_TYPE_DOUBLE:\n+      fldd(rvalue, fr4);\n+      break;\n+\n+    case FFI_TYPE_FLOAT:\n+      fldw(rvalue, fr4);\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      /* Don't need a return value, done by caller.  */\n+      break;\n+\n+    case FFI_TYPE_SMALL_STRUCT1:\n+      tmp = (void*)(stack -  FIRST_ARG_SLOT);\n+      tmp += 4 - cif->rtype->size;\n+      memcpy((void*)tmp, &ret[0], cif->rtype->size);\n+      break;\n+\n+    case FFI_TYPE_SMALL_STRUCT2:\n+      *(stack - FIRST_ARG_SLOT) = ret[0];\n+      *(stack - FIRST_ARG_SLOT - 1) = ret[1];\n+      break;\n+\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_VOID:\n+      break;\n+\n+    default:\n+      debug(0, \"assert with cif->flags: %d\\n\",cif->flags);\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+  return FFI_OK;\n+}\n+\n+/* Fill in a closure to refer to the specified fun and user_data.\n+   cif specifies the argument and result types for fun.\n+   The cif must already be prep'ed.  */\n+\n+void ffi_closure_LINUX(void);\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t  void *user_data)\n+{\n+  UINT32 *tramp = (UINT32 *)(closure->tramp);\n+\n+  FFI_ASSERT (cif->abi == FFI_LINUX);\n+\n+  /* Make a small trampoline that will branch to our\n+     handler function. Use PC-relative addressing.  */\n+\n+  tramp[0] = 0xeaa00000; /* b,l  .+8, %r21      ; %r21 <- pc+8 */\n+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2, %r21   ; mask priv bits */\n+  tramp[2] = 0x4aa10028; /* ldw  20(%r21), %r1  ; load plabel */\n+  tramp[3] = 0x36b53ff1; /* ldo  -8(%r21), %r21 ; get closure addr */\n+  tramp[4] = 0x0c201096; /* ldw  0(%r1), %r22   ; address of handler */\n+  tramp[5] = 0xeac0c000; /* bv\t %r0(%r22)      ; branch to handler */\n+  tramp[6] = 0x0c281093; /* ldw  4(%r1), %r19   ; GP of handler */\n+  tramp[7] = ((UINT32)(ffi_closure_LINUX) & ~2);\n+\n+  /* Flush d/icache -- have to flush up 2 two lines because of\n+     alignment.  */\n+  asm volatile (\n+\t\t\"fdc 0(%0)\\n\"\n+\t\t\"fdc %1(%0)\\n\"\n+\t\t\"fic 0(%%sr4, %0)\\n\"\n+\t\t\"fic %1(%%sr4, %0)\\n\"\n+\t\t\"sync\\n\"\n+\t\t: : \"r\"((unsigned long)tramp & ~31), \"r\"(32 /* stride */));\n+\n+  closure->cif  = cif;\n+  closure->user_data = user_data;\n+  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}\n+#endif"}, {"sha": "b8bcad0872f88b7a81b2c37261d2a72674d9d916", "filename": "libffi/src/pa/ffitarget.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -0,0 +1,57 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   Target configuration macros for hppa.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+/* ---- System specific configurations ----------------------------------- */\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+\n+#ifdef PA\n+  FFI_LINUX,\n+  FFI_DEFAULT_ABI = FFI_LINUX,\n+#endif\n+\n+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+\n+#define FFI_TRAMPOLINE_SIZE 32\n+\n+#define FFI_TYPE_SMALL_STRUCT1 -1\n+#define FFI_TYPE_SMALL_STRUCT2 -2\n+#endif\n+"}, {"sha": "f5b7eb33dea68c736959740da6e2cabbc6f4abe8", "filename": "libffi/src/pa/linux.S", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Flinux.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fpa%2Flinux.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Flinux.S?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -0,0 +1,281 @@\n+/* -----------------------------------------------------------------------\n+   linux.S - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n+\n+   HPPA Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+\t.text\n+\t.align 4\n+\n+\t/* void ffi_call_LINUX(void (*)(char *, extended_cif *),\n+\t\t\t       extended_cif *ecif,\n+\t\t\t       unsigned bytes,\n+\t\t\t       unsigned flags,\n+\t\t\t       unsigned *rvalue,\n+\t\t\t       void (*fn)());\n+\t */\n+\n+\t.export ffi_call_LINUX,code\n+\t.import ffi_prep_args_LINUX,code\n+\n+\t.type ffi_call_LINUX, @function\n+.LFB1:\n+ffi_call_LINUX:\n+\t.proc\n+\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4\n+\t.entry\n+\tstw %rp, -20(%sp)\n+\tcopy %r3, %r1\n+.LCFI11:\n+\n+\tcopy %sp, %r3\n+.LCFI12:\n+\n+\t/* Setup the stack for calling prep_args...\n+\t   We want the stack to look like this:\n+\n+\t   [ Previous stack                            ] <- %r3\n+\n+\t   [ 64-bytes register save area               ] <- %r4\n+\n+\t   [ Stack space for actual call, passed as    ] <- %arg0\n+\t   [     arg0 to ffi_prep_args_LINUX           ]\n+\n+\t   [ Stack for calling prep_args               ] <- %sp\n+\t */\n+\n+\tstwm %r1, 64(%sp)\n+\tstw %r4, 12(%r3)\n+.LCFI13:\n+\tcopy %sp, %r4\n+\n+\taddl %arg2, %r4, %arg0                  /* arg stack */\n+\tstw %arg3, -48(%r3)                     /* save flags; we need it later */\n+\n+\t/* Call prep_args:\n+\t   %arg0(stack) -- set up above\n+\t   %arg1(ecif) -- same as incoming param\n+\t   %arg2(bytes) -- same as incoming param */\n+\tbl ffi_prep_args_LINUX,%r2\n+\tldo 64(%arg0), %sp\n+\tldo -64(%sp), %sp\n+\n+\t/* now %sp should point where %arg0 was pointing.  */\n+\n+\t/* Load the arguments that should be passed in registers */\n+\t   The fp args were loaded by the prep_args function.  */\n+\tldw -36(%sp), %arg0\n+\tldw -40(%sp), %arg1\n+\tldw -44(%sp), %arg2\n+\tldw -48(%sp), %arg3\n+\n+\t/* in case the function is going to return a structure\n+\t   we need to give it a place to put the result.  */\n+\tldw -52(%r3), %ret0                     /* %ret0 <- rvalue */\n+\tldw -56(%r3), %r22                      /* %r22 <- function to call */\n+\tbl $$dyncall, %r31                      /* Call the user function */\n+\tcopy %r31, %rp\n+\n+\t/* Prepare to store the result; we need to recover flags and rvalue.  */\n+\tldw -48(%r3), %r21                      /* r21 <- flags */\n+\tldw -52(%r3), %r20                      /* r20 <- rvalue */\n+\n+\t/* Store the result according to the return type.  */\n+\n+checksmst1:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT1, %r21, checksmst2\n+\t/* There is maybe a better way to handle 3 byte structs.  */\n+\tsh2add %ret0,0,%ret0\n+\tsh2add %ret0,0,%ret0\n+\tsh2add %ret0,0,%ret0\n+\tsh2add %ret0,0,%ret0\n+\tb done\n+\tstw %ret0, 0(%r20)\n+\n+checksmst2:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, checkint8\n+\t/* Up to now I don't have a way to handle 6/7 byte structs.\n+\t   The values are left bounded in the registers. In the struct\n+\t   itself they are left bounded.  */\n+\tstw %ret0, 0(%r20)\n+\tb done\n+\tstw %ret1, 4(%r20)\n+\n+checkint8:\n+\tcomib,<>,n FFI_TYPE_UINT8, %r21, checkint16\n+\tb done\n+\tstb %ret0, 0(%r20)\n+\n+checkint16:\n+\tcomib,<>,n FFI_TYPE_UINT16, %r21, checkint32\n+\tb done\n+\tsth %ret0, 0(%r20)\n+\n+checkint32:\n+\tcomib,<>,n FFI_TYPE_UINT32, %r21, checkint\n+\tb done\n+\tstw %ret0, 0(%r20)\n+\n+checkint:\n+\tcomib,<>,n FFI_TYPE_INT, %r21, checkll\n+\tb done\n+\tstw %ret0, 0(%r20)\n+\n+checkll:\n+\tcomib,<>,n FFI_TYPE_UINT64, %r21, checkdbl\n+\tstw %ret0, 0(%r20)\n+\tb done\n+\tstw %ret1, 4(%r20)\n+\n+checkdbl:\n+\tcomib,<>,n FFI_TYPE_DOUBLE, %r21, checkfloat\n+\tb done\n+\tfstd %fr4,0(%r20)\n+\n+checkfloat:\n+\tcomib,<>,n FFI_TYPE_FLOAT, %r21, done\n+\tfstw %fr4L,0(%r20)\n+\n+\t/* structure returns are either handled by one of the\n+\t   INT/UINT64 cases above, or, if passed by pointer,\n+\t   is handled by the callee.  */\n+\n+done:\n+\t/* all done, return */\n+\tcopy %r4, %sp                           /* pop arg stack */\n+\tldw 12(%r3), %r4\n+\tldwm -64(%sp), %r3                      /* .. and pop stack */\n+\tldw -20(%sp), %rp\n+\tbv %r0(%rp)\n+\tnop\n+\t.exit\n+\t.procend\n+.LFE1:\n+\n+\t/* void ffi_closure_LINUX(void);\n+\t   Called with closure argument in %r21 */\n+\t.export ffi_closure_LINUX,code\n+\t.import ffi_closure_inner_LINUX,code\n+\n+\t.type ffi_closure_LINUX, @function\n+.LFB2:\n+ffi_closure_LINUX:\n+\t.proc\n+\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n+\t.entry\n+\n+\tstw %rp, -20(%sp)\n+.LCFI20:\n+\tcopy %r3, %r1\n+.LCFI21:\n+\tcopy %sp, %r3\n+.LCFI22:\n+\tstwm %r1, 64(%sp)\n+\n+\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n+\tstw %arg0, -36(%r3)\n+\tstw %arg1, -40(%r3)\n+\tstw %arg2, -44(%r3)\n+\tstw %arg3, -48(%r3)\n+\n+\tcopy %r21, %arg0\n+\tbl ffi_closure_inner_LINUX, %r2\n+\tcopy %r3, %arg1\n+\n+\tldwm -64(%sp), %r3\n+\tldw -20(%sp), %rp\n+\tldw -36(%sp), %ret0\n+\tbv %r0(%r2)\n+\tldw -40(%sp), %ret1\n+\n+\t.exit\n+\t.procend\n+.LFE2:\n+\n+\t.section        \".eh_frame\",EH_FRAME_FLAGS,@progbits\n+.Lframe1:\n+\t.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry\n+.LSCIE1:\n+\t.word   0x0     ;# CIE Identifier Tag\n+\t.byte   0x1     ;# CIE Version\n+\t.ascii \"\\0\"     ;# CIE Augmentation\n+\t.uleb128 0x1    ;# CIE Code Alignment Factor\n+\t.sleb128 4      ;# CIE Data Alignment Factor\n+\t.byte   0x2     ;# CIE RA Column\n+\t.byte   0xc     ;# DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 0x0\n+\t.align 4\n+.LECIE1:\n+.LSFDE1:\n+\t.word   .LEFDE1-.LASFDE1        ;# FDE Length\n+.LASFDE1:\n+\t.word   .LASFDE1-.Lframe1       ;# FDE CIE offset\n+\t.word   .LFB1   ;# FDE initial location\n+\t.word   .LFE1-.LFB1     ;# FDE address range\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI11-.LFB1\n+\t.byte\t0x83\t;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI12-.LCFI11\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI13-.LCFI12\n+\t.byte\t0x84\t;# DW_CFA_offset, column 0x4\n+\t.uleb128 0x3\n+\n+\t.align 4\n+.LEFDE1:\n+\n+.LSFDE2:\n+\t.word   .LEFDE2-.LASFDE2        ;# FDE Length\n+.LASFDE2:\n+\t.word   .LASFDE2-.Lframe1       ;# FDE CIE offset\n+\t.word   .LFB2   ;# FDE initial location\n+\t.word   .LFE2-.LFB2     ;# FDE address range\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI21-.LFB2\n+\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI12-.LCFI11\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.align 4\n+.LEFDE2:"}, {"sha": "33477563b8e8e95b8ad4ac6d66096160430418d0", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a810fe451b24db35f4a48f2f7eecb5b2402bd/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=d65a810fe451b24db35f4a48f2f7eecb5b2402bd", "patch": "@@ -113,7 +113,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n   FFI_ASSERT_VALID_TYPE(cif->rtype);\n \n   /* x86-64 and s390 stack space allocation is handled in prep_machdep.  */\n-#if !defined M68K && !defined __x86_64__ && !defined S390\n+#if !defined M68K && !defined __x86_64__ && !defined S390 && !defined PA\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n@@ -134,7 +134,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n \t check after the initialization.  */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n-#if !defined __x86_64__ && !defined S390\n+#if !defined __x86_64__ && !defined S390 && !defined PA\n #ifdef SPARC\n       if (((*ptr)->type == FFI_TYPE_STRUCT\n \t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))"}]}