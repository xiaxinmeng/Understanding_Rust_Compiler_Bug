{"sha": "910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwZWQ3ZGM3MGVlMTc3NDdmNmFkNGQ0Y2Y3ZDM2NzA5MjRhYzk3OQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2010-04-25T07:52:43Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2010-04-25T07:52:43Z"}, "message": "combine.c (find_split_point): Add third argument.\n\n2010-04-25  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* combine.c (find_split_point): Add third argument.  Use it\n\tto find nested multiply-accumulate instructions.  Adjust calls.\n\t(try_combine): Adjust call to find_split_point.\n\ntestsuite:\n2010-04-25  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* gcc.target/arm/mla-1.c: New test.\n\nFrom-SVN: r158698", "tree": {"sha": "0cb93e77356922794da154ba78b8049b119704b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cb93e77356922794da154ba78b8049b119704b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/comments", "author": null, "committer": null, "parents": [{"sha": "16aee0d582e5c06458db78a468ffa0dda4a8283a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16aee0d582e5c06458db78a468ffa0dda4a8283a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16aee0d582e5c06458db78a468ffa0dda4a8283a"}], "stats": {"total": 72, "additions": 56, "deletions": 16}, "files": [{"sha": "f1389d84f9449e50d40dceb048c1856e840cf59f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "patch": "@@ -1,3 +1,9 @@\n+2010-04-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (find_split_point): Add third argument.  Use it\n+\tto find nested multiply-accumulate instructions.  Adjust calls.\n+\t(try_combine): Adjust call to find_split_point.\n+\n 2010-04-24  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/contrib.texi (Contributors): Add Dodji Seketeli."}, {"sha": "0c934457d260d532f906cde972e3c556477fecb5", "filename": "gcc/combine.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "patch": "@@ -391,7 +391,7 @@ static int contains_muldiv (rtx);\n static rtx try_combine (rtx, rtx, rtx, int *);\n static void undo_all (void);\n static void undo_commit (void);\n-static rtx *find_split_point (rtx *, rtx);\n+static rtx *find_split_point (rtx *, rtx, bool);\n static rtx subst (rtx, rtx, rtx, int, int);\n static rtx combine_simplify_rtx (rtx, enum machine_mode, int);\n static rtx simplify_if_then_else (rtx);\n@@ -3267,7 +3267,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       /* If we can split it and use I2DEST, go ahead and see if that\n \t helps things be recognized.  Verify that none of the registers\n \t are set between I2 and I3.  */\n-      if (insn_code_number < 0 && (split = find_split_point (&newpat, i3)) != 0\n+      if (insn_code_number < 0\n+          && (split = find_split_point (&newpat, i3, false)) != 0\n #ifdef HAVE_cc0\n \t  && REG_P (i2dest)\n #endif\n@@ -4144,7 +4145,7 @@ undo_commit (void)\n    two insns.  */\n \n static rtx *\n-find_split_point (rtx *loc, rtx insn)\n+find_split_point (rtx *loc, rtx insn, bool set_src)\n {\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n@@ -4164,7 +4165,7 @@ find_split_point (rtx *loc, rtx insn)\n       if (MEM_P (SUBREG_REG (x)))\n \treturn loc;\n #endif\n-      return find_split_point (&SUBREG_REG (x), insn);\n+      return find_split_point (&SUBREG_REG (x), insn, false);\n \n     case MEM:\n #ifdef HAVE_lo_sum\n@@ -4281,12 +4282,12 @@ find_split_point (rtx *loc, rtx insn)\n #endif\n \n       /* See if we can split SET_SRC as it stands.  */\n-      split = find_split_point (&SET_SRC (x), insn);\n+      split = find_split_point (&SET_SRC (x), insn, true);\n       if (split && split != &SET_SRC (x))\n \treturn split;\n \n       /* See if we can split SET_DEST as it stands.  */\n-      split = find_split_point (&SET_DEST (x), insn);\n+      split = find_split_point (&SET_DEST (x), insn, false);\n       if (split && split != &SET_DEST (x))\n \treturn split;\n \n@@ -4330,7 +4331,7 @@ find_split_point (rtx *loc, rtx insn)\n \n \t  SUBST (SET_DEST (x), dest);\n \n-\t  split = find_split_point (&SET_SRC (x), insn);\n+\t  split = find_split_point (&SET_SRC (x), insn, true);\n \t  if (split && split != &SET_SRC (x))\n \t    return split;\n \t}\n@@ -4366,7 +4367,7 @@ find_split_point (rtx *loc, rtx insn)\n \t      if (extraction != 0)\n \t\t{\n \t\t  SUBST (SET_SRC (x), extraction);\n-\t\t  return find_split_point (loc, insn);\n+\t\t  return find_split_point (loc, insn, false);\n \t\t}\n \t    }\n \t  break;\n@@ -4388,7 +4389,7 @@ find_split_point (rtx *loc, rtx insn)\n \t\t\t\t\t\t    XEXP (SET_SRC (x), 0),\n \t\t\t\t\t\t    GEN_INT (pos))));\n \n-\t      split = find_split_point (&SET_SRC (x), insn);\n+\t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n \t\treturn split;\n \t    }\n@@ -4447,7 +4448,7 @@ find_split_point (rtx *loc, rtx insn)\n \t\t\t\t   GEN_INT (pos)),\n \t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n \n-\t      split = find_split_point (&SET_SRC (x), insn);\n+\t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n \t\treturn split;\n \t    }\n@@ -4462,7 +4463,7 @@ find_split_point (rtx *loc, rtx insn)\n \t\t\t\t\t       - len - pos)),\n \t\t      GEN_INT (GET_MODE_BITSIZE (mode) - len)));\n \n-\t      split = find_split_point (&SET_SRC (x), insn);\n+\t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n \t\treturn split;\n \t    }\n@@ -4502,7 +4503,7 @@ find_split_point (rtx *loc, rtx insn)\n \t\t\t\t\t      GET_MODE (x),\n \t\t\t\t\t      XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t      XEXP (XEXP (x, 1), 0))));\n-\t  return find_split_point (loc, insn);\n+\t  return find_split_point (loc, insn, set_src);\n \t}\n \n       /* Many RISC machines have a large set of logical insns.  If the\n@@ -4516,6 +4517,14 @@ find_split_point (rtx *loc, rtx insn)\n \t}\n       break;\n \n+    case PLUS:\n+    case MINUS:\n+      /* Split at a multiply-accumulate instruction.  However if this is\n+         the SET_SRC, we likely do not have such an instruction and it's\n+         worthless to try this split.  */\n+      if (!set_src && GET_CODE (XEXP (x, 0)) == MULT)\n+        return loc;\n+\n     default:\n       break;\n     }\n@@ -4525,15 +4534,15 @@ find_split_point (rtx *loc, rtx insn)\n     {\n     case RTX_BITFIELD_OPS:\t\t/* This is ZERO_EXTRACT and SIGN_EXTRACT.  */\n     case RTX_TERNARY:\n-      split = find_split_point (&XEXP (x, 2), insn);\n+      split = find_split_point (&XEXP (x, 2), insn, false);\n       if (split)\n \treturn split;\n       /* ... fall through ...  */\n     case RTX_BIN_ARITH:\n     case RTX_COMM_ARITH:\n     case RTX_COMPARE:\n     case RTX_COMM_COMPARE:\n-      split = find_split_point (&XEXP (x, 1), insn);\n+      split = find_split_point (&XEXP (x, 1), insn, false);\n       if (split)\n \treturn split;\n       /* ... fall through ...  */\n@@ -4543,7 +4552,7 @@ find_split_point (rtx *loc, rtx insn)\n       if (GET_CODE (x) != AND && GET_CODE (XEXP (x, 0)) == AND)\n \treturn &XEXP (x, 0);\n \n-      split = find_split_point (&XEXP (x, 0), insn);\n+      split = find_split_point (&XEXP (x, 0), insn, false);\n       if (split)\n \treturn split;\n       return loc;"}, {"sha": "dd9da1aa4ec67854c4f32dbce93c868ad62eaaa7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "patch": "@@ -1,8 +1,12 @@\n+2010-04-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* gcc.target/arm/mla-1.c: New test.\n+\n 2010-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/30073\n \tPR fortran/43793\n-\tgfortran.dg/pr43793.f90: New test.\n+\t* gfortran.dg/pr43793.f90: New test.\n \n 2010-04-24  Bernd Schmidt  <bernds@codesourcery.com>\n "}, {"sha": "991fb59473aba491b7e30b09ee380374e5f0861d", "filename": "gcc/testsuite/gcc.target/arm/mla-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ed7dc70ee17747f6ad4d4cf7d3670924ac979/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmla-1.c?ref=910ed7dc70ee17747f6ad4d4cf7d3670924ac979", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=armv5\" } */\n+\n+\n+int\n+foo (int *p, int *q)\n+{\n+  int i;\n+  int accum = 0;\n+\n+  for (i = 0 ; i < 1024; i++)\n+    {\n+      accum += ((*p--) * (*q++));\n+      accum += 4096;\n+      accum >>= 13 ;\n+    }\n+\n+  return accum;\n+}\n+\n+/* { dg-final { scan-assembler \"mla\" } } */"}]}