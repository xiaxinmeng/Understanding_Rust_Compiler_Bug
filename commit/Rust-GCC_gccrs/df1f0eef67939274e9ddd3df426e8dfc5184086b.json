{"sha": "df1f0eef67939274e9ddd3df426e8dfc5184086b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxZjBlZWY2NzkzOTI3NGU5ZGRkM2RmNDI2ZThkZmM1MTg0MDg2Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-10T18:56:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-10T18:56:26Z"}, "message": "Remove call_fixed_reg_set\n\nOn targets that use reload, call_fixed_reg_set is structurally:\n\n  fixed_reg_set                           -- reginfo.c\n  | (call_used_reg_set & ~have_save_mode) -- first loop in init_caller_save\n  | ~have_save_insn                       -- final loop in init_caller_save\n\n(where \"have_save_mode\" and \"have_save_insn\" are just my names).\nBut the final loop in init_caller_save does:\n\n  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n      if (reg_save_code (i,regno_save_mode[i][j]) == -1)\n\nThis last condition ought to be true whenever:\n\n  regno_save_mode[i][j] == VOIDmode\n\nsince either targetm.hard_regno_mode_ok (i, VOIDmode) should be\nfalse or the VOIDmode save & restore shouldn't match any move insn.\nAnd after the first loop, regno_save_mode[i][j] == VOIDmode whenever\n!call_used_regs[i].  So the above is actually:\n\n  fixed_reg_set\n  | (call_used_reg_set & ~have_save_mode)\n  | (~call_used_reg_set | ~have_save_insn)\n\nwhich simplifies to:\n\n  fixed_reg_set                        -- reginfo.c\n  | ~have_save_mode                    -- first loop in init_caller_save\n  | ~have_save_insn                    -- final loop in init_caller_save\n  | ~call_used_reg_set                 -- final loop in init_caller_save\n\nSo:\n\n  ~call_fixed_reg_set == (~fixed_reg_set\n\t\t          & have_save_mode\n\t\t\t  & have_save_insn\n\t\t\t  & call_used_reg_set)  [A]\n\nAll users have the form:\n\n  (call_used_reg_set or some subset) & ~(call_fixed_reg_set | ...)\n\ni.e.:\n\n  (call_used_reg_set or some subset) & ~call_fixed_reg_set & ~(...)\n\nWe can therefore drop the \"& call_used_reg_set\" from [A], leaving:\n\n  ~fixed_reg_set & have_save_mode & have_save_insn\n\nThis patch combines have_save_mode & have_save_insn into a single\ncondition \"a save is possible\", represented as savable_regs.\nWe can then substitute:\n\n  ~call_fixed_reg_set --> ~fixed_reg_set & savable_regs\n                          (registers we can actually save around calls)\n\nThe patch also sets regno_save_mode[i][j] for all registers,\nin case non-default ABIs require a save when the default ABI\ndoesn't.  This ensures that savable_regs (like fixed_reg_set but\nunlike call_fixed_reg_set) isn't affected by the ABI.  This only\nbecomes significant with later patches and at this point is just\na simplification.\n\nSince init_caller_save is only called for reload targets,\nthe default assumption for LRA is that all registers are savable,\njust like the default assumption before the patch was that\n(~)call_fixed_reg_set == (~)fixed_reg_set.\n\n2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (target_hard_regs::x_call_fixed_reg_set): Delete.\n\t(target_hard_regs::x_savable_regs): New field.\n\t(call_fixed_reg_set): Delete.\n\t(savable_regs): New macro,\n\t* reginfo.c (globalize_reg): Don't set call_fixed_reg_set.\n\t(init_reg_sets_1): Likewise.  Initialize savable_regs.\n\t* caller-save.c (init_caller_save): Invoke HARD_REGNO_CALLER_SAVE_MODE\n\tfor all registers.  Set savable_regs instead of call_fixed_reg_set.\n\t(setup_save_areas, save_call_clobbered_regs): Replace uses of\n\t~call_fixed_reg_set with ~fixed_reg_set & savable_regs.\n\t* config/sh/sh.c (output_stack_adjust): Likewise.\n\nFrom-SVN: r275598", "tree": {"sha": "5c82b08c38893696032489e881bf32e860f507a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c82b08c38893696032489e881bf32e860f507a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df1f0eef67939274e9ddd3df426e8dfc5184086b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1f0eef67939274e9ddd3df426e8dfc5184086b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1f0eef67939274e9ddd3df426e8dfc5184086b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1f0eef67939274e9ddd3df426e8dfc5184086b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "031e8857886b91da290ffb03d9027424566e5da3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/031e8857886b91da290ffb03d9027424566e5da3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/031e8857886b91da290ffb03d9027424566e5da3"}], "stats": {"total": 77, "additions": 42, "deletions": 35}, "files": [{"sha": "aee319088f76d35bdc23902b749ec11804962d6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df1f0eef67939274e9ddd3df426e8dfc5184086b", "patch": "@@ -1,3 +1,17 @@\n+2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (target_hard_regs::x_call_fixed_reg_set): Delete.\n+\t(target_hard_regs::x_savable_regs): New field.\n+\t(call_fixed_reg_set): Delete.\n+\t(savable_regs): New macro,\n+\t* reginfo.c (globalize_reg): Don't set call_fixed_reg_set.\n+\t(init_reg_sets_1): Likewise.  Initialize savable_regs.\n+\t* caller-save.c (init_caller_save): Invoke HARD_REGNO_CALLER_SAVE_MODE\n+\tfor all registers.  Set savable_regs instead of call_fixed_reg_set.\n+\t(setup_save_areas, save_call_clobbered_regs): Replace uses of\n+\t~call_fixed_reg_set with ~fixed_reg_set & savable_regs.\n+\t* config/sh/sh.c (output_stack_adjust): Likewise.\n+\n 2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/c6x/c6x-protos.h (c6x_set_return_address): Declare."}, {"sha": "05fbc4421e1adb1cb961b62c18286bd500f89fb8", "filename": "gcc/caller-save.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=df1f0eef67939274e9ddd3df426e8dfc5184086b", "patch": "@@ -198,23 +198,12 @@ init_caller_save (void)\n      we can't have the register live over calls.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (call_used_regs[i]\n-          && !TEST_HARD_REG_BIT (call_fixed_reg_set, i))\n-\t{\n-\t  for (j = 1; j <= MOVE_MAX_WORDS; j++)\n-\t    {\n-\t      regno_save_mode[i][j] = HARD_REGNO_CALLER_SAVE_MODE (i, j,\n-\t\t\t\t\t\t\t\t   VOIDmode);\n-\t      if (regno_save_mode[i][j] == VOIDmode && j == 1)\n-\t\t{\n-\t\t  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\tregno_save_mode[i][1] = VOIDmode;\n-    }\n+    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n+      {\n+\tregno_save_mode[i][j] = HARD_REGNO_CALLER_SAVE_MODE (i, j, VOIDmode);\n+\tif (regno_save_mode[i][j] == VOIDmode && j == 1)\n+\t  CLEAR_HARD_REG_BIT (savable_regs, i);\n+      }\n \n   /* The following code tries to approximate the conditions under which\n      we can easily save and restore a register without scratch registers or\n@@ -276,7 +265,7 @@ init_caller_save (void)\n \t  regno_save_mode[i][j] = VOIDmode;\n \t  if (j == 1)\n \t    {\n-\t      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t      CLEAR_HARD_REG_BIT (savable_regs, i);\n \t      if (call_used_regs[i])\n \t\tSET_HARD_REG_BIT (no_caller_save_reg_set, i);\n \t    }\n@@ -455,8 +444,8 @@ setup_save_areas (void)\n       if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n \tmark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n \n-      used_regs &= ~(call_fixed_reg_set | this_insn_sets);\n-      hard_regs_to_save &= used_regs;\n+      used_regs &= ~(fixed_reg_set | this_insn_sets);\n+      hard_regs_to_save &= used_regs & savable_regs;\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n \t  {\n@@ -539,8 +528,8 @@ setup_save_areas (void)\n \t  if (SIBLING_CALL_P (insn) && crtl->return_rtx)\n \t    mark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);\n \n-\t  used_regs &= ~(call_fixed_reg_set | this_insn_sets);\n-\t  hard_regs_to_save &= used_regs;\n+\t  used_regs &= ~(fixed_reg_set | this_insn_sets);\n+\t  hard_regs_to_save &= used_regs & savable_regs;\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t    if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n \t      {\n@@ -850,9 +839,10 @@ save_call_clobbered_regs (void)\n \t      note_stores (insn, mark_set_regs, &this_insn_sets);\n \n \t      /* Compute which hard regs must be saved before this call.  */\n-\t      hard_regs_to_save &= ~(call_fixed_reg_set\n+\t      hard_regs_to_save &= ~(fixed_reg_set\n \t\t\t\t     | this_insn_sets\n \t\t\t\t     | hard_regs_saved);\n+\t      hard_regs_to_save &= savable_regs;\n \t      get_call_reg_set_usage (insn, &call_def_reg_set,\n \t\t\t\t      call_used_reg_set);\n \t      hard_regs_to_save &= call_def_reg_set;"}, {"sha": "7f881805eabafef50dab2fbc55ae020c807b3fa9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=df1f0eef67939274e9ddd3df426e8dfc5184086b", "patch": "@@ -6707,7 +6707,9 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t    temp = -1;\n \t  if (temp < 0 && ! current_function_interrupt && epilogue_p >= 0)\n \t    {\n-\t      HARD_REG_SET temps = call_used_reg_set & ~call_fixed_reg_set;\n+\t      HARD_REG_SET temps = (call_used_reg_set\n+\t\t\t\t    & ~fixed_reg_set\n+\t\t\t\t    & savable_regs);\n \t      if (epilogue_p > 0)\n \t\t{\n \t\t  int nreg = 0;"}, {"sha": "4c8da3a7ac8deacf847635e11a76fddf22be74da", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=df1f0eef67939274e9ddd3df426e8dfc5184086b", "patch": "@@ -400,11 +400,15 @@ struct target_hard_regs {\n   /* The same info as a HARD_REG_SET.  */\n   HARD_REG_SET x_call_used_reg_set;\n \n-  /* Contains registers that are fixed use -- i.e. in fixed_reg_set -- or\n-     a function value return register or TARGET_STRUCT_VALUE_RTX or\n-     STATIC_CHAIN_REGNUM.  These are the registers that cannot hold quantities\n-     across calls even if we are willing to save and restore them.  */\n-  HARD_REG_SET x_call_fixed_reg_set;\n+  /* For targets that use reload rather than LRA, this is the set\n+     of registers that we are able to save and restore around calls\n+     (i.e. those for which we know a suitable mode and set of\n+     load/store instructions exist).  For LRA targets it contains\n+     all registers.\n+\n+     This is legacy information and should be removed if all targets\n+     switch to LRA.  */\n+  HARD_REG_SET x_savable_regs;\n \n   /* Contains registers that are fixed use -- i.e. in fixed_reg_set -- but\n      only if they are not merely part of that set because they are global\n@@ -482,8 +486,8 @@ extern struct target_hard_regs *this_target_hard_regs;\n   (this_target_hard_regs->x_call_really_used_regs)\n #define call_used_reg_set \\\n   (this_target_hard_regs->x_call_used_reg_set)\n-#define call_fixed_reg_set \\\n-  (this_target_hard_regs->x_call_fixed_reg_set)\n+#define savable_regs \\\n+  (this_target_hard_regs->x_savable_regs)\n #define regs_invalidated_by_call \\\n   (this_target_hard_regs->x_regs_invalidated_by_call)\n #define no_caller_save_reg_set \\"}, {"sha": "b72a5675e18d2db616002846fdce511d9b8215e1", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1f0eef67939274e9ddd3df426e8dfc5184086b/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=df1f0eef67939274e9ddd3df426e8dfc5184086b", "patch": "@@ -351,7 +351,6 @@ init_reg_sets_1 (void)\n \n   CLEAR_HARD_REG_SET (fixed_reg_set);\n   CLEAR_HARD_REG_SET (call_used_reg_set);\n-  CLEAR_HARD_REG_SET (call_fixed_reg_set);\n   CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n \n   operand_reg_set &= accessible_reg_set;\n@@ -417,7 +416,7 @@ init_reg_sets_1 (void)\n \tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n     }\n \n-  call_fixed_reg_set = fixed_reg_set;\n+  SET_HARD_REG_SET (savable_regs);\n   fixed_nonglobal_reg_set = fixed_reg_set;\n \n   /* Preserve global registers if called more than once.  */\n@@ -428,7 +427,6 @@ init_reg_sets_1 (void)\n \t  fixed_regs[i] = call_used_regs[i] = 1;\n \t  SET_HARD_REG_BIT (fixed_reg_set, i);\n \t  SET_HARD_REG_BIT (call_used_reg_set, i);\n-\t  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n \t}\n     }\n \n@@ -782,7 +780,6 @@ globalize_reg (tree decl, int i)\n \n   SET_HARD_REG_BIT (fixed_reg_set, i);\n   SET_HARD_REG_BIT (call_used_reg_set, i);\n-  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n \n   reinit_regs ();\n }"}]}