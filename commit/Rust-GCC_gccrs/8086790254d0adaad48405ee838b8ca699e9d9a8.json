{"sha": "8086790254d0adaad48405ee838b8ca699e9d9a8", "node_id": "C_kwDOANBUbNoAKDgwODY3OTAyNTRkMGFkYWFkNDg0MDVlZTgzOGI4Y2E2OTllOWQ5YTg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-16T16:19:31Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-16T22:12:35Z"}, "message": "Fix unconstrained type parameter checks\n\nThis patch removes our old method of checking for unconstrained type\nparameters which only worked for the basic cases such as:\n\n  impl<T> Foo { }\n\nBut checking for unconstrained types is more complex, we need to handle\ncovariant types such as:\n\n  impl<T> *T { }\n\nOr\n\n  struct foo<X,Y>(X,Y);\n  impl<T> foo<&T,*T> {}\n\nThis rewrites the algorithm to take advantage of our substition\nabstractions and HirIds so we can map the ids of the type-params to be\nconstrained and look at the trait-references used-arguments when the\ngenerics are applied (or they may be empty) and then do the same for any\nused arguments on an algebraic data type.\n\nFixes #1019", "tree": {"sha": "12f83b7535a7c2c881f1e5a2b56df0d669c88cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12f83b7535a7c2c881f1e5a2b56df0d669c88cb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8086790254d0adaad48405ee838b8ca699e9d9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8086790254d0adaad48405ee838b8ca699e9d9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8086790254d0adaad48405ee838b8ca699e9d9a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8086790254d0adaad48405ee838b8ca699e9d9a8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21cf0e67a6f748525ca79e8d9aa59c94bef13519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21cf0e67a6f748525ca79e8d9aa59c94bef13519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21cf0e67a6f748525ca79e8d9aa59c94bef13519"}], "stats": {"total": 448, "additions": 289, "deletions": 159}, "files": [{"sha": "cd40efb9d339e6dda5ff73993078af52d37962b3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -99,6 +99,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-pattern.o \\\n     rust/rust-hir-type-check-expr.o \\\n     rust/rust-hir-dot-operator.o \\\n+    rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\"}, {"sha": "32c588165826a9d040b1f5487d0b00dffd2ed113", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+bool\n+TypeCheckBase::check_for_unconstrained (\n+  const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+  const TyTy::SubstitutionArgumentMappings &constraint_a,\n+  const TyTy::SubstitutionArgumentMappings &constraint_b,\n+  const TyTy::BaseType *reference)\n+{\n+  std::set<HirId> symbols_to_constrain;\n+  std::map<HirId, Location> symbol_to_location;\n+  for (const auto &p : params_to_constrain)\n+    {\n+      HirId ref = p.get_param_ty ()->get_ref ();\n+      symbols_to_constrain.insert (ref);\n+      symbol_to_location.insert ({ref, p.get_param_locus ()});\n+    }\n+\n+  // set up the set of constrained symbols\n+  std::set<HirId> constrained_symbols;\n+  for (const auto &c : constraint_a.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+  for (const auto &c : constraint_b.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+\n+  const auto root = reference->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+      constrained_symbols.insert (p->get_ty_ref ());\n+    }\n+\n+  // check for unconstrained\n+  bool unconstrained = false;\n+  for (auto &sym : symbols_to_constrain)\n+    {\n+      bool used = constrained_symbols.find (sym) != constrained_symbols.end ();\n+      if (!used)\n+\t{\n+\t  Location locus = symbol_to_location.at (sym);\n+\t  rust_error_at (locus, \"unconstrained type parameter\");\n+\t  unconstrained = true;\n+\t}\n+    }\n+  return unconstrained;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "5a3f553367f356c5b01852b9875b54f675b81c3e", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -47,6 +47,14 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n \n   TraitReference *resolve_trait_path (HIR::TypePath &);\n \n+  TyTy::TypeBoundPredicate get_predicate_from_bound (HIR::TypePath &path);\n+\n+  bool check_for_unconstrained (\n+    const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+    const TyTy::SubstitutionArgumentMappings &constraint_a,\n+    const TyTy::SubstitutionArgumentMappings &constraint_b,\n+    const TyTy::BaseType *reference);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "4c6c4a633d291f60734fa145f6b66a657b863282", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -70,34 +70,15 @@ class TypeCheckItem : public TypeCheckBase\n \t  }\n       }\n \n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    auto specified_bound = TyTy::TypeBoundPredicate::error ();\n     TraitReference *trait_reference = &TraitReference::error_node ();\n     if (impl_block.has_trait_ref ())\n       {\n \tstd::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n \ttrait_reference = TraitResolver::Resolve (*ref.get ());\n \trust_assert (!trait_reference->is_error ());\n \n-\t// setup the bound\n-\tTyTy::TypeBoundPredicate predicate (*trait_reference,\n-\t\t\t\t\t    ref->get_locus ());\n-\tauto &final_seg = ref->get_final_segment ();\n-\tif (final_seg->is_generic_segment ())\n-\t  {\n-\t    auto final_generic_seg\n-\t      = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-\t    if (final_generic_seg->has_generic_args ())\n-\t      {\n-\t\tHIR::GenericArgs &generic_args\n-\t\t  = final_generic_seg->get_generic_args ();\n-\n-\t\t// this is applying generic arguments to a trait\n-\t\t// reference\n-\t\tpredicate.apply_generic_arguments (&generic_args);\n-\t      }\n-\t  }\n-\n-\tspecified_bounds.push_back (std::move (predicate));\n+\tspecified_bound = get_predicate_from_bound (*ref.get ());\n       }\n \n     TyTy::BaseType *self = nullptr;\n@@ -108,11 +89,25 @@ class TypeCheckItem : public TypeCheckBase\n \t\t       \"failed to resolve Self for ImplBlock\");\n \treturn;\n       }\n-    // inherit the bounds\n-    self->inherit_bounds (specified_bounds);\n \n+    // inherit the bounds\n+    if (!specified_bound.is_error ())\n+      self->inherit_bounds ({specified_bound});\n+\n+    // check for any unconstrained type-params\n+    const TyTy::SubstitutionArgumentMappings trait_constraints\n+      = specified_bound.get_substitution_arguments ();\n+    const TyTy::SubstitutionArgumentMappings impl_constraints\n+      = GetUsedSubstArgs::From (self);\n+\n+    bool impl_block_has_unconstrained_typarams\n+      = check_for_unconstrained (substitutions, trait_constraints,\n+\t\t\t\t impl_constraints, self);\n+    if (impl_block_has_unconstrained_typarams)\n+      return;\n+\n+    // validate the impl items\n     bool is_trait_impl_block = !trait_reference->is_error ();\n-\n     std::vector<const TraitItemReference *> trait_item_refs;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {"}, {"sha": "5e124663fe744bebc3caa17d45609c0b3a43112d", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -468,9 +468,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n       }\n \n-    auto self\n-      = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n-    if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)\n+    auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+    if (self->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     for (auto &impl_item : impl_block.get_impl_items ())"}, {"sha": "914bebbecf82c1d0f8192bda703be6f59845b808", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -84,11 +84,6 @@ TypeCheckType::visit (HIR::TypePath &path)\n \t}\n \n       translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n-      if (translated->get_kind () != TyTy::TypeKind::ERROR\n-\t  && mappings != nullptr)\n-\t{\n-\t  check_for_unconstrained (args.get_type_args ());\n-\t}\n     }\n   else if (!args.is_empty ())\n     {\n@@ -548,26 +543,11 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n       HIR::TypeParamBound &b = *bound.get ();\n       HIR::TraitBound &trait_bound = static_cast<HIR::TraitBound &> (b);\n \n-      auto &type_path = trait_bound.get_path ();\n-      TraitReference *trait = resolve_trait_path (type_path);\n-      TyTy::TypeBoundPredicate predicate (*trait, trait_bound.get_locus ());\n-      auto &final_seg = type_path.get_final_segment ();\n-      if (final_seg->is_generic_segment ())\n-\t{\n-\t  auto final_generic_seg\n-\t    = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-\t  if (final_generic_seg->has_generic_args ())\n-\t    {\n-\t      HIR::GenericArgs &generic_args\n-\t\t= final_generic_seg->get_generic_args ();\n-\n-\t      // this is applying generic arguments to a trait\n-\t      // reference\n-\t      predicate.apply_generic_arguments (&generic_args);\n-\t    }\n-\t}\n+      TyTy::TypeBoundPredicate predicate\n+\t= get_predicate_from_bound (trait_bound.get_path ());\n \n-      if (predicate.is_object_safe (true, type.get_locus ()))\n+      if (!predicate.is_error ()\n+\t  && predicate.is_object_safe (true, type.get_locus ()))\n \tspecified_bounds.push_back (std::move (predicate));\n     }\n "}, {"sha": "127502f14941ce042876f2a3ebb0d081b268322d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 12, "deletions": 85, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -57,12 +57,9 @@ class TypeCheckType : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TyTy::BaseType *\n-  Resolve (HIR::Type *type,\n-\t   std::vector<TyTy::SubstitutionParamMapping> *subst_mappings\n-\t   = nullptr)\n+  static TyTy::BaseType *Resolve (HIR::Type *type)\n   {\n-    TypeCheckType resolver (type->get_mappings ().get_hirid (), subst_mappings);\n+    TypeCheckType resolver (type->get_mappings ().get_hirid ());\n     type->accept_vis (resolver);\n     rust_assert (resolver.translated != nullptr);\n     resolver.context->insert_type (type->get_mappings (), resolver.translated);\n@@ -159,43 +156,10 @@ class TypeCheckType : public TypeCheckBase\n   void visit (HIR::TraitObjectType &type) override;\n \n private:\n-  TypeCheckType (HirId id,\n-\t\t std::vector<TyTy::SubstitutionParamMapping> *subst_mappings)\n-    : TypeCheckBase (), subst_mappings (subst_mappings),\n-      translated (new TyTy::ErrorType (id))\n+  TypeCheckType (HirId id)\n+    : TypeCheckBase (), translated (new TyTy::ErrorType (id))\n   {}\n \n-  void\n-  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type>> &type_args)\n-  {\n-    std::map<std::string, Location> param_location_map;\n-    std::set<std::string> param_tys;\n-\n-    if (subst_mappings != nullptr)\n-      {\n-\tfor (auto &mapping : *subst_mappings)\n-\t  {\n-\t    std::string sym = mapping.get_param_ty ()->get_symbol ();\n-\t    param_tys.insert (sym);\n-\t    param_location_map[sym] = mapping.get_generic_param ().get_locus ();\n-\t  }\n-      }\n-\n-    std::set<std::string> args;\n-    for (auto &arg : type_args)\n-      args.insert (arg->as_string ());\n-\n-    for (auto &exp : param_tys)\n-      {\n-\tbool used = args.find (exp) != args.end ();\n-\tif (!used)\n-\t  {\n-\t    Location locus = param_location_map.at (exp);\n-\t    rust_error_at (locus, \"unconstrained type parameter\");\n-\t  }\n-      }\n-  }\n-\n   TyTy::BaseType *resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t\t\t\t     NodeId *root_resolved_node_id);\n \n@@ -205,7 +169,6 @@ class TypeCheckType : public TypeCheckBase\n     TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n     Location expr_locus);\n \n-  std::vector<TyTy::SubstitutionParamMapping> *subst_mappings;\n   TyTy::BaseType *translated;\n };\n \n@@ -245,28 +208,10 @@ class TypeResolveGenericParam : public TypeCheckBase\n \t\t  HIR::TraitBound *b\n \t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t\t  auto &type_path = b->get_path ();\n-\t\t  TraitReference *trait = resolve_trait_path (type_path);\n-\t\t  TyTy::TypeBoundPredicate predicate (*trait, b->get_locus ());\n-\n-\t\t  auto &final_seg = type_path.get_final_segment ();\n-\t\t  if (final_seg->is_generic_segment ())\n-\t\t    {\n-\t\t      auto final_generic_seg\n-\t\t\t= static_cast<HIR::TypePathSegmentGeneric *> (\n-\t\t\t  final_seg.get ());\n-\t\t      if (final_generic_seg->has_generic_args ())\n-\t\t\t{\n-\t\t\t  HIR::GenericArgs &generic_args\n-\t\t\t    = final_generic_seg->get_generic_args ();\n-\n-\t\t\t  // this is applying generic arguments to a trait\n-\t\t\t  // reference\n-\t\t\t  predicate.apply_generic_arguments (&generic_args);\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  specified_bounds.push_back (std::move (predicate));\n+\t\t  TyTy::TypeBoundPredicate predicate\n+\t\t    = get_predicate_from_bound (b->get_path ());\n+\t\t  if (!predicate.is_error ())\n+\t\t    specified_bounds.push_back (std::move (predicate));\n \t\t}\n \t\tbreak;\n \n@@ -315,28 +260,10 @@ class ResolveWhereClauseItem : public TypeCheckBase\n \t      HIR::TraitBound *b\n \t\t= static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t      auto &type_path = b->get_path ();\n-\t      TraitReference *trait = resolve_trait_path (type_path);\n-\t      TyTy::TypeBoundPredicate predicate (*trait, b->get_locus ());\n-\n-\t      auto &final_seg = type_path.get_final_segment ();\n-\t      if (final_seg->is_generic_segment ())\n-\t\t{\n-\t\t  auto final_generic_seg\n-\t\t    = static_cast<HIR::TypePathSegmentGeneric *> (\n-\t\t      final_seg.get ());\n-\t\t  if (final_generic_seg->has_generic_args ())\n-\t\t    {\n-\t\t      HIR::GenericArgs &generic_args\n-\t\t\t= final_generic_seg->get_generic_args ();\n-\n-\t\t      // this is applying generic arguments to a trait\n-\t\t      // reference\n-\t\t      predicate.apply_generic_arguments (&generic_args);\n-\t\t    }\n-\t\t}\n-\n-\t      specified_bounds.push_back (std::move (predicate));\n+\t      TyTy::TypeBoundPredicate predicate\n+\t\t= get_predicate_from_bound (b->get_path ());\n+\t      if (!predicate.is_error ())\n+\t\tspecified_bounds.push_back (std::move (predicate));\n \t    }\n \t    break;\n "}, {"sha": "a7ec42c7a1c278fcb4bb91b6fa5d3c0d1e630f24", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -63,6 +63,37 @@ TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n   return TraitResolver::Resolve (path);\n }\n \n+TyTy::TypeBoundPredicate\n+TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n+{\n+  TraitReference *trait = resolve_trait_path (type_path);\n+  if (trait->is_error ())\n+    return TyTy::TypeBoundPredicate::error ();\n+\n+  TyTy::TypeBoundPredicate predicate (*trait, type_path.get_locus ());\n+  HIR::GenericArgs args\n+    = HIR::GenericArgs::create_empty (type_path.get_locus ());\n+\n+  auto &final_seg = type_path.get_final_segment ();\n+  if (final_seg->is_generic_segment ())\n+    {\n+      auto final_generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+      if (final_generic_seg->has_generic_args ())\n+\t{\n+\t  args = final_generic_seg->get_generic_args ();\n+\t}\n+    }\n+\n+  if (predicate.requires_generic_args ())\n+    {\n+      // this is applying generic arguments to a trait reference\n+      predicate.apply_generic_arguments (&args);\n+    }\n+\n+  return predicate;\n+}\n+\n } // namespace Resolver\n \n namespace TyTy {\n@@ -72,15 +103,16 @@ TypeBoundPredicate::TypeBoundPredicate (\n   : SubstitutionRef (trait_reference.get_trait_substs (),\n \t\t     SubstitutionArgumentMappings::error ()),\n     reference (trait_reference.get_mappings ().get_defid ()), locus (locus),\n-    args (nullptr), error_flag (false)\n+    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n {}\n \n TypeBoundPredicate::TypeBoundPredicate (\n   DefId reference, std::vector<SubstitutionParamMapping> substitutions,\n   Location locus)\n   : SubstitutionRef (std::move (substitutions),\n \t\t     SubstitutionArgumentMappings::error ()),\n-    reference (reference), locus (locus), args (nullptr), error_flag (false)\n+    reference (reference), locus (locus),\n+    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n {}\n \n TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n@@ -95,6 +127,33 @@ TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n     }\n }\n \n+TypeBoundPredicate &\n+TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n+{\n+  reference = other.reference;\n+  locus = other.locus;\n+  args = other.args;\n+  error_flag = other.error_flag;\n+  used_arguments = other.used_arguments;\n+\n+  substitutions.clear ();\n+  if (!other.is_error ())\n+    {\n+      for (const auto &p : other.get_substs ())\n+\tsubstitutions.push_back (p.clone ());\n+    }\n+\n+  return *this;\n+}\n+\n+TypeBoundPredicate\n+TypeBoundPredicate::error ()\n+{\n+  auto p = TypeBoundPredicate (UNKNOWN_DEFID, {}, Location ());\n+  p.error_flag = true;\n+  return p;\n+}\n+\n std::string\n TypeBoundPredicate::as_string () const\n {\n@@ -139,8 +198,19 @@ TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n void\n TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n {\n-  args = generic_args;\n-  // TODO verify these arguments are valid and not too many were added\n+  // we need to get the substitutions argument mappings but also remember that\n+  // we have an implicit Self argument which we must be careful to respect\n+  rust_assert (used_arguments.is_empty ());\n+  rust_assert (!substitutions.empty ());\n+\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&substitutions.front (), nullptr);\n+  used_arguments.get_mappings ().push_back (std::move (placeholder_self));\n+\n+  // now actually perform a substitution\n+  used_arguments = get_mappings_from_generic_args (*generic_args);\n+  error_flag |= used_arguments.is_error ();\n+  args = *generic_args;\n }\n \n bool\n@@ -222,6 +292,15 @@ TypeBoundPredicate::handle_substitions (SubstitutionArgumentMappings mappings)\n   return nullptr;\n }\n \n+bool\n+TypeBoundPredicate::requires_generic_args () const\n+{\n+  if (is_error ())\n+    return false;\n+\n+  return substitutions.size () > 1 && args.is_empty ();\n+}\n+\n // trait item reference\n \n const Resolver::TraitItemReference *"}, {"sha": "c12095f26ebf37e62969581bbf153cfeb3050772", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -201,11 +201,16 @@ BaseType::inherit_bounds (\n const BaseType *\n BaseType::get_root () const\n {\n-  const BaseType *root = this;\n-  while (root->get_kind () == TyTy::REF)\n+  const TyTy::BaseType *root = this;\n+  if (get_kind () == TyTy::REF)\n     {\n       const ReferenceType *r = static_cast<const ReferenceType *> (root);\n-      root = r->get_base ();\n+      root = r->get_base ()->get_root ();\n+    }\n+  else if (get_kind () == TyTy::POINTER)\n+    {\n+      const PointerType *r = static_cast<const PointerType *> (root);\n+      root = r->get_base ()->get_root ();\n     }\n   return root;\n }\n@@ -543,11 +548,11 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       rust_error_at (\n \tr,\n \t\"generic item takes at least %lu type arguments but %lu were supplied\",\n-\tsubstitutions.size (), args.get_type_args ().size ());\n+\t(min_required_substitutions () - offs), args.get_type_args ().size ());\n       return SubstitutionArgumentMappings::error ();\n     }\n \n-  std::vector<SubstitutionArg> mappings;\n+  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n   for (auto &arg : args.get_type_args ())\n     {\n       BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n@@ -2351,7 +2356,7 @@ ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n \n   SubstitutionArg arg = SubstitutionArg::error ();\n   bool ok = mappings.get_argument_for_symbol (this, &arg);\n-  if (ok)\n+  if (ok && !arg.is_error ())\n     p->set_ty_ref (arg.get_tyty ()->get_ref ());\n \n   return p;"}, {"sha": "58b5042c34ab345be26578e73a3c5f9850f79aae", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -551,7 +551,13 @@ class SubstitutionParamMapping\n     : generic (other.generic), param (other.param)\n   {}\n \n-  std::string as_string () const { return param->get_name (); }\n+  std::string as_string () const\n+  {\n+    if (param == nullptr)\n+      return \"nullptr\";\n+\n+    return param->get_name ();\n+  }\n \n   bool fill_param_ty (BaseType &type, Location locus);\n \n@@ -615,7 +621,9 @@ class SubstitutionArg\n \n   BaseType *get_tyty () { return argument; }\n \n-  const SubstitutionParamMapping *get_param_mapping () { return param; }\n+  const BaseType *get_tyty () const { return argument; }\n+\n+  const SubstitutionParamMapping *get_param_mapping () const { return param; }\n \n   static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n \n@@ -634,7 +642,8 @@ class SubstitutionArg\n \n   std::string as_string () const\n   {\n-    return param->as_string () + \":\" + argument->as_string ();\n+    return param->as_string ()\n+\t   + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n   }\n \n private:\n@@ -712,8 +721,12 @@ class SubstitutionArgumentMappings\n \n   size_t size () const { return mappings.size (); }\n \n+  bool is_empty () const { return size () == 0; }\n+\n   std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n \n+  const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n+\n   std::string as_string () const\n   {\n     std::string buffer;\n@@ -951,6 +964,10 @@ class TypeBoundPredicate : public SubstitutionRef\n \n   TypeBoundPredicate (const TypeBoundPredicate &other);\n \n+  TypeBoundPredicate &operator= (const TypeBoundPredicate &other);\n+\n+  static TypeBoundPredicate error ();\n+\n   std::string as_string () const;\n \n   const Resolver::TraitReference *get () const;\n@@ -970,28 +987,24 @@ class TypeBoundPredicate : public SubstitutionRef\n   TypeBoundPredicateItem\n   lookup_associated_item (const std::string &search) const;\n \n-  HIR::GenericArgs *get_generic_args () { return args; }\n+  HIR::GenericArgs *get_generic_args () { return &args; }\n \n-  const HIR::GenericArgs *get_generic_args () const { return args; }\n+  const HIR::GenericArgs *get_generic_args () const { return &args; }\n \n-  bool has_generic_args () const\n-  {\n-    if (args == nullptr)\n-      return false;\n-\n-    return args->has_generic_args ();\n-  }\n+  bool has_generic_args () const { return args.has_generic_args (); }\n \n   // WARNING THIS WILL ALWAYS RETURN NULLPTR\n   BaseType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n   bool is_error () const;\n \n+  bool requires_generic_args () const;\n+\n private:\n   DefId reference;\n   Location locus;\n-  HIR::GenericArgs *args;\n+  HIR::GenericArgs args;\n   bool error_flag;\n };\n "}, {"sha": "aea86a821c773e25fe0ca657247322f8626dbba7", "filename": "gcc/testsuite/rust/compile/issue-1019.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -0,0 +1,19 @@\n+trait A<T> {\n+    type Output;\n+\n+    fn test(self, a: &T) -> &Self::Output;\n+}\n+\n+struct Foo<T> {\n+    // { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+    start: T,\n+    end: T,\n+}\n+\n+impl<X> A<X> for Foo<usize> {\n+    type Output = X;\n+\n+    fn test(self, a: &X) -> &Self::Output {\n+        a\n+    }\n+}"}, {"sha": "25e0eb7aaa3cd307f6d11e271729f595afc83ec6", "filename": "gcc/testsuite/rust/compile/traits12.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8086790254d0adaad48405ee838b8ca699e9d9a8/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs?ref=8086790254d0adaad48405ee838b8ca699e9d9a8", "patch": "@@ -0,0 +1,20 @@\n+trait A<T> {\n+    type Output;\n+\n+    fn test(self, a: &T) -> &Self::Output;\n+}\n+\n+struct Foo<T> {\n+    start: T,\n+    end: T,\n+}\n+\n+impl<T> A for Foo<usize> {\n+    // { dg-error \"generic item takes at least 1 type arguments but 0 were supplied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"unconstrained type parameter\" \"\" { target *-*-* } .-2 }\n+    type Output = T;\n+\n+    fn test(self, a: &T) -> &Self::Output {\n+        a\n+    }\n+}"}]}