{"sha": "068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY4ZjVkZWFiZmMxNmQwYTRhZTExMmQxODVjODVkOWY2YmM3NmVlZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-01-07T21:09:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-01-07T21:09:21Z"}, "message": "re PR target/8322 (SSE2 intrinsics broken?)\n\n\t* genopinit.c (optabs): Add addc_optab.\n\t* ifcvt.c (noce_try_store_flag): Rename to ...\n\t(noce_try_addcc): ... this one; handle generic conditional increment.\n\t(noce_process_if_block): Update noce_try_addcc call.\n\t* optabs.c (emit_conditional_add): New.\n\t(init_obtabs): Initialize addc_optab.\n\t* optabs.h (optab_index): Add OTI_addcc.\n\t(addcc_optab): New macro.\n\t* md.texi: Document addMcc\n\n\tPR target/8322\n\t* i386.c (ix86_init_mmx_sse_builtins): Constify arguments of loads.\n\t* xmmintrin.h (_mm_load*_si128. _mm_store*_si128): Add casts.\n\t* xmmintrin.h (_mm_load*_si128. _mm_store*_si128): Add casts.\n\n\t* reload1.c (delete_output_reload): Avoid repeated attempts\n\tto delete insn.\n\nFrom-SVN: r61019", "tree": {"sha": "0f2ce69928d0a8166860b927857a84fead2f2d9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f2ce69928d0a8166860b927857a84fead2f2d9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/comments", "author": null, "committer": null, "parents": [{"sha": "eb70d86d7eed92f410073ac5312c89840b209d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb70d86d7eed92f410073ac5312c89840b209d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb70d86d7eed92f410073ac5312c89840b209d7c"}], "stats": {"total": 324, "additions": 262, "deletions": 62}, "files": [{"sha": "7de2cb006f8868c8bfe6ce8ab68d1f7014f94294", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -1,3 +1,23 @@\n+Tue Jan  7 21:46:57 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* genopinit.c (optabs): Add addc_optab.\n+\t* ifcvt.c (noce_try_store_flag): Rename to ...\n+\t(noce_try_addcc): ... this one; handle generic conditional increment.\n+\t(noce_process_if_block): Update noce_try_addcc call.\n+\t* optabs.c (emit_conditional_add): New.\n+\t(init_obtabs): Initialize addc_optab.\n+\t* optabs.h (optab_index): Add OTI_addcc.\n+\t(addcc_optab): New macro.\n+\t* md.texi: Document addMcc\n+\n+\tPR target/8322\n+\t* i386.c (ix86_init_mmx_sse_builtins): Constify arguments of loads.\n+\t* xmmintrin.h (_mm_load*_si128. _mm_store*_si128): Add casts.\n+\t* xmmintrin.h (_mm_load*_si128. _mm_store*_si128): Add casts.\n+\n+\t* reload1.c (delete_output_reload): Avoid repeated attempts\n+\tto delete insn.\n+\n 2003-01-07  Andreas Schwab  <schwab@suse.de>\n \n         * configure.in: Restore CFLAGS before gcc_AC_INITFINI_ARRAY."}, {"sha": "c1a760b6358d66e64e803f2abf1b5c219b222cca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -9584,11 +9584,11 @@ ix86_expand_int_movcc (operands)\n \t  /* On x86_64 the lea instruction operates on Pmode, so we need\n \t     to get arithmetics done in proper mode to match.  */\n \t  if (diff == 1)\n-\t    tmp = out;\n+\t    tmp = copy_rtx (out);\n \t  else\n \t    {\n \t      rtx out1;\n-\t      out1 = out;\n+\t      out1 = copy_rtx (out);\n \t      tmp = gen_rtx_MULT (mode, out1, GEN_INT (diff & ~1));\n \t      nops++;\n \t      if (diff & 1)\n@@ -12590,7 +12590,11 @@ ix86_init_mmx_sse_builtins ()\n   size_t i;\n \n   tree pchar_type_node = build_pointer_type (char_type_node);\n+  tree pcchar_type_node = build_pointer_type (\n+\t\t\t     build_type_variant (char_type_node, 1, 0));\n   tree pfloat_type_node = build_pointer_type (float_type_node);\n+  tree pcfloat_type_node = build_pointer_type (\n+\t\t\t     build_type_variant (float_type_node, 1, 0));\n   tree pv2si_type_node = build_pointer_type (V2SI_type_node);\n   tree pv2di_type_node = build_pointer_type (V2DI_type_node);\n   tree pdi_type_node = build_pointer_type (long_long_unsigned_type_node);\n@@ -12663,8 +12667,8 @@ ix86_init_mmx_sse_builtins ()\n     = build_function_type_list (void_type_node,\n \t\t\t\tV8QI_type_node, V8QI_type_node,\n \t\t\t\tpchar_type_node, NULL_TREE);\n-  tree v4sf_ftype_pfloat\n-    = build_function_type_list (V4SF_type_node, pfloat_type_node, NULL_TREE);\n+  tree v4sf_ftype_pcfloat\n+    = build_function_type_list (V4SF_type_node, pcfloat_type_node, NULL_TREE);\n   /* @@@ the type is bogus */\n   tree v4sf_ftype_v4sf_pv2si\n     = build_function_type_list (V4SF_type_node,\n@@ -12719,7 +12723,11 @@ ix86_init_mmx_sse_builtins ()\n     = build_function_type_list (V2SI_type_node,\n \t\t\t\tV2SF_type_node, V2SF_type_node, NULL_TREE);\n   tree pint_type_node    = build_pointer_type (integer_type_node);\n+  tree pcint_type_node = build_pointer_type (\n+\t\t\t     build_type_variant (integer_type_node, 1, 0));\n   tree pdouble_type_node = build_pointer_type (double_type_node);\n+  tree pcdouble_type_node = build_pointer_type (\n+\t\t\t\tbuild_type_variant (double_type_node, 1, 0));\n   tree int_ftype_v2df_v2df\n     = build_function_type_list (integer_type_node,\n \t\t\t\tV2DF_type_node, V2DF_type_node, NULL_TREE);\n@@ -12731,8 +12739,8 @@ ix86_init_mmx_sse_builtins ()\n   tree ti_ftype_ti_ti\n     = build_function_type_list (intTI_type_node,\n \t\t\t\tintTI_type_node, intTI_type_node, NULL_TREE);\n-  tree void_ftype_pvoid\n-    = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+  tree void_ftype_pcvoid\n+    = build_function_type_list (void_type_node, const_ptr_type_node, NULL_TREE);\n   tree v2di_ftype_di\n     = build_function_type_list (V2DI_type_node,\n \t\t\t\tlong_long_unsigned_type_node, NULL_TREE);\n@@ -12787,8 +12795,8 @@ ix86_init_mmx_sse_builtins ()\n     = build_function_type_list (void_type_node,\n \t\t\t\tV16QI_type_node, V16QI_type_node,\n \t\t\t\tpchar_type_node, NULL_TREE);\n-  tree v2df_ftype_pdouble\n-    = build_function_type_list (V2DF_type_node, pdouble_type_node, NULL_TREE);\n+  tree v2df_ftype_pcdouble\n+    = build_function_type_list (V2DF_type_node, pcdouble_type_node, NULL_TREE);\n   tree v2df_ftype_v2df_v2df\n     = build_function_type_list (V2DF_type_node,\n \t\t\t\tV2DF_type_node, V2DF_type_node, NULL_TREE);\n@@ -12847,16 +12855,16 @@ ix86_init_mmx_sse_builtins ()\n \t\t\t\tV16QI_type_node, V16QI_type_node, NULL_TREE);\n   tree int_ftype_v16qi\n     = build_function_type_list (integer_type_node, V16QI_type_node, NULL_TREE);\n-  tree v16qi_ftype_pchar\n-    = build_function_type_list (V16QI_type_node, pchar_type_node, NULL_TREE);\n+  tree v16qi_ftype_pcchar\n+    = build_function_type_list (V16QI_type_node, pcchar_type_node, NULL_TREE);\n   tree void_ftype_pchar_v16qi\n     = build_function_type_list (void_type_node,\n \t\t\t        pchar_type_node, V16QI_type_node, NULL_TREE);\n-  tree v4si_ftype_pchar\n-    = build_function_type_list (V4SI_type_node, pchar_type_node, NULL_TREE);\n-  tree void_ftype_pchar_v4si\n+  tree v4si_ftype_pcint\n+    = build_function_type_list (V4SI_type_node, pcint_type_node, NULL_TREE);\n+  tree void_ftype_pcint_v4si\n     = build_function_type_list (void_type_node,\n-\t\t\t        pchar_type_node, V4SI_type_node, NULL_TREE);\n+\t\t\t        pcint_type_node, V4SI_type_node, NULL_TREE);\n   tree v2di_ftype_v2di\n     = build_function_type_list (V2DI_type_node, V2DI_type_node, NULL_TREE);\n \n@@ -12971,9 +12979,9 @@ ix86_init_mmx_sse_builtins ()\n \n   def_builtin (MASK_SSE1 | MASK_3DNOW_A, \"__builtin_ia32_maskmovq\", void_ftype_v8qi_v8qi_pchar, IX86_BUILTIN_MASKMOVQ);\n \n-  def_builtin (MASK_SSE1, \"__builtin_ia32_loadaps\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADAPS);\n-  def_builtin (MASK_SSE1, \"__builtin_ia32_loadups\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADUPS);\n-  def_builtin (MASK_SSE1, \"__builtin_ia32_loadss\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADSS);\n+  def_builtin (MASK_SSE1, \"__builtin_ia32_loadaps\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADAPS);\n+  def_builtin (MASK_SSE1, \"__builtin_ia32_loadups\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADUPS);\n+  def_builtin (MASK_SSE1, \"__builtin_ia32_loadss\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADSS);\n   def_builtin (MASK_SSE1, \"__builtin_ia32_storeaps\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREAPS);\n   def_builtin (MASK_SSE1, \"__builtin_ia32_storeups\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREUPS);\n   def_builtin (MASK_SSE1, \"__builtin_ia32_storess\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STORESS);\n@@ -13041,9 +13049,9 @@ ix86_init_mmx_sse_builtins ()\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movq2dq\", v2di_ftype_di, IX86_BUILTIN_MOVQ2DQ);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movdq2q\", di_ftype_v2di, IX86_BUILTIN_MOVDQ2Q);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadapd\", v2df_ftype_pdouble, IX86_BUILTIN_LOADAPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadupd\", v2df_ftype_pdouble, IX86_BUILTIN_LOADUPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadsd\", v2df_ftype_pdouble, IX86_BUILTIN_LOADSD);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadapd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADAPD);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadupd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADUPD);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadsd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADSD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storeapd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREAPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storeupd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREUPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storesd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STORESD);\n@@ -13094,21 +13102,21 @@ ix86_init_mmx_sse_builtins ()\n   def_builtin (MASK_SSE2, \"__builtin_ia32_setpd1\", v2df_ftype_double, IX86_BUILTIN_SETPD1);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_setpd\", v2df_ftype_double_double, IX86_BUILTIN_SETPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_setzeropd\", ti_ftype_void, IX86_BUILTIN_CLRPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadpd1\", v2df_ftype_pdouble, IX86_BUILTIN_LOADPD1);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadrpd\", v2df_ftype_pdouble, IX86_BUILTIN_LOADRPD);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadpd1\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADPD1);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadrpd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADRPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storepd1\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREPD1);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storerpd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STORERPD);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_clflush\", void_ftype_pvoid, IX86_BUILTIN_CLFLUSH);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_clflush\", void_ftype_pcvoid, IX86_BUILTIN_CLFLUSH);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_lfence\", void_ftype_void, IX86_BUILTIN_LFENCE);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_mfence\", void_ftype_void, IX86_BUILTIN_MFENCE);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqa\", v16qi_ftype_pchar, IX86_BUILTIN_LOADDQA);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqu\", v16qi_ftype_pchar, IX86_BUILTIN_LOADDQU);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadd\", v4si_ftype_pchar, IX86_BUILTIN_LOADD);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqa\", v16qi_ftype_pcchar, IX86_BUILTIN_LOADDQA);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqu\", v16qi_ftype_pcchar, IX86_BUILTIN_LOADDQU);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_loadd\", v4si_ftype_pcint, IX86_BUILTIN_LOADD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storedqa\", void_ftype_pchar_v16qi, IX86_BUILTIN_STOREDQA);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storedqu\", void_ftype_pchar_v16qi, IX86_BUILTIN_STOREDQU);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_stored\", void_ftype_pchar_v4si, IX86_BUILTIN_STORED);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_stored\", void_ftype_pcint_v4si, IX86_BUILTIN_STORED);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movq\", v2di_ftype_v2di, IX86_BUILTIN_MOVQ);\n \n   def_builtin (MASK_SSE1, \"__builtin_ia32_setzero128\", v2di_ftype_void, IX86_BUILTIN_CLRTI);"}, {"sha": "1c6db97a86a051c21081761a5b61b1ac4374de61", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -1586,13 +1586,13 @@ _mm_ucomineq_sd (__m128d __A, __m128d __B)\n static __inline __m128i\n _mm_load_si128 (__m128i const *__P)\n {\n-  return (__m128i) __builtin_ia32_loaddqa (__P);\n+  return (__m128i) __builtin_ia32_loaddqa ((char const *)__P);\n }\n \n static __inline __m128i\n _mm_loadu_si128 (__m128i const *__P)\n {\n-  return (__m128i) __builtin_ia32_loaddqu (__P);\n+  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);\n }\n \n static __inline __m128i\n@@ -1604,13 +1604,13 @@ _mm_loadl_epi64 (__m128i const *__P)\n static __inline void\n _mm_store_si128 (__m128i *__P, __m128i __B)\n {\n-  __builtin_ia32_storedqa (__P, (__v16qi)__B);\n+  __builtin_ia32_storedqa ((char *)__P, (__v16qi)__B);\n }\n \n static __inline void\n _mm_storeu_si128 (__m128i *__P, __m128i __B)\n {\n-  __builtin_ia32_storedqu (__P, (__v16qi)__B);\n+  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);\n }\n \n static __inline void"}, {"sha": "2d90de4537def3fab0166463cfae665d9217e7e5", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -2854,6 +2854,13 @@ codes and vice versa.\n If the machine does not have conditional move instructions, do not\n define these patterns.\n \n+@cindex @code{add@var{mode}cc} instruction pattern\n+@item @samp{mov@var{mode}cc}\n+Similar to @samp{mov@var{mode}cc} but for conditional addition.  Conditionally\n+move operand 2 or (operands 2 + operand 3) into operand 0 according to the\n+comparison in operand 1.  If the comparison is true, operand 2 is moved into\n+operand 0, otherwise operand 3 is moved.\n+\n @cindex @code{s@var{cond}} instruction pattern\n @item @samp{s@var{cond}}\n Store zero or nonzero in the operand according to the condition codes."}, {"sha": "1a10f0342e35495859bef7cebaf9ef3b439e48bf", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -130,6 +130,7 @@ static const char * const optabs[] =\n   \"movstrict_optab->handlers[$A].insn_code = CODE_FOR_$(movstrict$a$)\",\n   \"cmp_optab->handlers[$A].insn_code = CODE_FOR_$(cmp$a$)\",\n   \"tst_optab->handlers[$A].insn_code = CODE_FOR_$(tst$a$)\",\n+  \"addcc_optab->handlers[$A].insn_code = CODE_FOR_$(add$acc$)\",\n   \"bcc_gen_fctn[$C] = gen_$(b$c$)\",\n   \"setcc_gen_code[$C] = CODE_FOR_$(s$c$)\",\n   \"movcc_gen_code[$A] = CODE_FOR_$(mov$acc$)\","}, {"sha": "3cf01942da72c61c768a4bbad2e4cebca5296042", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -582,7 +582,7 @@ struct noce_if_info\n static rtx noce_emit_store_flag\t\tPARAMS ((struct noce_if_info *,\n \t\t\t\t\t\t rtx, int, int));\n static int noce_try_store_flag\t\tPARAMS ((struct noce_if_info *));\n-static int noce_try_store_flag_inc\tPARAMS ((struct noce_if_info *));\n+static int noce_try_addcc\t\tPARAMS ((struct noce_if_info *));\n static int noce_try_store_flag_constants PARAMS ((struct noce_if_info *));\n static int noce_try_store_flag_mask\tPARAMS ((struct noce_if_info *));\n static rtx noce_emit_cmove\t\tPARAMS ((struct noce_if_info *,\n@@ -864,61 +864,87 @@ noce_try_store_flag_constants (if_info)\n    similarly for \"foo--\".  */\n \n static int\n-noce_try_store_flag_inc (if_info)\n+noce_try_addcc (if_info)\n      struct noce_if_info *if_info;\n {\n   rtx target, seq;\n   int subtract, normalize;\n \n   if (! no_new_pseudos\n-      && (BRANCH_COST >= 2\n-\t  || HAVE_incscc\n-\t  || HAVE_decscc)\n       /* Should be no `else' case to worry about.  */\n       && if_info->b == if_info->x\n       && GET_CODE (if_info->a) == PLUS\n-      && (XEXP (if_info->a, 1) == const1_rtx\n-\t  || XEXP (if_info->a, 1) == constm1_rtx)\n       && rtx_equal_p (XEXP (if_info->a, 0), if_info->x)\n       && (reversed_comparison_code (if_info->cond, if_info->jump)\n \t  != UNKNOWN))\n     {\n-      if (STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n-\tsubtract = 0, normalize = 0;\n-      else if (-STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n-\tsubtract = 1, normalize = 0;\n-      else\n-\tsubtract = 0, normalize = INTVAL (XEXP (if_info->a, 1));\n-      \n-      start_sequence ();\n+      rtx cond = if_info->cond;\n+      enum rtx_code code = reversed_comparison_code (cond, if_info->jump);\n \n-      target = noce_emit_store_flag (if_info,\n-\t\t\t\t     gen_reg_rtx (GET_MODE (if_info->x)),\n-\t\t\t\t     1, normalize);\n-\n-      if (target)\n-\ttarget = expand_simple_binop (GET_MODE (if_info->x),\n-\t\t\t\t      subtract ? MINUS : PLUS,\n-\t\t\t\t      if_info->x, target, if_info->x,\n-\t\t\t\t      0, OPTAB_WIDEN);\n+      /* First try to use addcc pattern.  */\n+      start_sequence ();\n+      target = emit_conditional_add (if_info->x, code,\n+\t\t\t\t     XEXP (cond, 0), XEXP (cond, 1),\n+\t\t\t\t     VOIDmode,\n+\t\t\t\t     if_info->b, XEXP (if_info->a, 1),\n+\t\t\t\t     GET_MODE (if_info->x),\n+\t\t\t\t     (code == LTU || code == GEU\n+\t\t\t\t      || code == LEU || code == GTU));\n       if (target)\n \t{\n \t  if (target != if_info->x)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n-\n-\t  if (seq_contains_jump (seq))\n-\t    return FALSE;\n-\n \t  emit_insn_before_scope (seq, if_info->jump,\n \t\t\t\t  INSN_SCOPE (if_info->insn_a));\n-\n \t  return TRUE;\n \t}\n-\n       end_sequence ();\n+\t\n+      /* If that fails, construct conditional increment or decrement using\n+\t setcc.  */\n+      if (BRANCH_COST >= 2\n+\t  && (XEXP (if_info->a, 1) == const1_rtx\n+\t      || XEXP (if_info->a, 1) == constm1_rtx))\n+        {\n+\t  start_sequence ();\n+\t  if (STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n+\t    subtract = 0, normalize = 0;\n+\t  else if (-STORE_FLAG_VALUE == INTVAL (XEXP (if_info->a, 1)))\n+\t    subtract = 1, normalize = 0;\n+\t  else\n+\t    subtract = 0, normalize = INTVAL (XEXP (if_info->a, 1));\n+\n+\n+\t  target = noce_emit_store_flag (if_info,\n+\t\t\t\t\t gen_reg_rtx (GET_MODE (if_info->x)),\n+\t\t\t\t\t 1, normalize);\n+\n+\t  if (target)\n+\t    target = expand_simple_binop (GET_MODE (if_info->x),\n+\t\t\t\t\t  subtract ? MINUS : PLUS,\n+\t\t\t\t\t  if_info->x, target, if_info->x,\n+\t\t\t\t\t  0, OPTAB_WIDEN);\n+\t  if (target)\n+\t    {\n+\t      if (target != if_info->x)\n+\t\tnoce_emit_move_insn (if_info->x, target);\n+\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\n+\t      if (seq_contains_jump (seq))\n+\t\treturn FALSE;\n+\n+\t      emit_insn_before_scope (seq, if_info->jump,\n+\t\t\t\t      INSN_SCOPE (if_info->insn_a));\n+\n+\t      return TRUE;\n+\t    }\n+\t  end_sequence ();\n+\t}\n     }\n \n   return FALSE;\n@@ -1860,7 +1886,7 @@ noce_process_if_block (ce_info)\n     {\n       if (noce_try_store_flag_constants (&if_info))\n \tgoto success;\n-      if (noce_try_store_flag_inc (&if_info))\n+      if (noce_try_addcc (&if_info))\n \tgoto success;\n       if (noce_try_store_flag_mask (&if_info))\n \tgoto success;"}, {"sha": "3956299e4ea55ab14bb27bae1b9774aa770208dc", "filename": "gcc/optabs.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -4230,6 +4230,134 @@ can_conditionally_move_p (mode)\n }\n \n #endif /* HAVE_conditional_move */\n+\n+/* Emit a conditional addition instruction if the machine supports one for that\n+   condition and machine mode.\n+\n+   OP0 and OP1 are the operands that should be compared using CODE.  CMODE is\n+   the mode to use should they be constants.  If it is VOIDmode, they cannot\n+   both be constants.\n+\n+   OP2 should be stored in TARGET if the comparison is true, otherwise OP2+OP3\n+   should be stored there.  MODE is the mode to use should they be constants.\n+   If it is VOIDmode, they cannot both be constants.\n+\n+   The result is either TARGET (perhaps modified) or NULL_RTX if the operation\n+   is not supported.  */\n+\n+rtx\n+emit_conditional_add (target, code, op0, op1, cmode, op2, op3, mode,\n+\t\t      unsignedp)\n+     rtx target;\n+     enum rtx_code code;\n+     rtx op0, op1;\n+     enum machine_mode cmode;\n+     rtx op2, op3;\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  rtx tem, subtarget, comparison, insn;\n+  enum insn_code icode;\n+  enum rtx_code reversed;\n+\n+  /* If one operand is constant, make it the second one.  Only do this\n+     if the other operand is not constant as well.  */\n+\n+  if (swap_commutative_operands_p (op0, op1))\n+    {\n+      tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      code = swap_condition (code);\n+    }\n+\n+  /* get_condition will prefer to generate LT and GT even if the old\n+     comparison was against zero, so undo that canonicalization here since\n+     comparisons against zero are cheaper.  */\n+  if (code == LT && GET_CODE (op1) == CONST_INT && INTVAL (op1) == 1)\n+    code = LE, op1 = const0_rtx;\n+  else if (code == GT && GET_CODE (op1) == CONST_INT && INTVAL (op1) == -1)\n+    code = GE, op1 = const0_rtx;\n+\n+  if (cmode == VOIDmode)\n+    cmode = GET_MODE (op0);\n+\n+  if (swap_commutative_operands_p (op2, op3)\n+      && ((reversed = reversed_comparison_code_parts (code, op0, op1, NULL))\n+          != UNKNOWN))\n+    {\n+      tem = op2;\n+      op2 = op3;\n+      op3 = tem;\n+      code = reversed;\n+    }\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op2);\n+\n+  icode = addcc_optab->handlers[(int) mode].insn_code;\n+\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  if (flag_force_mem)\n+    {\n+      op2 = force_not_mem (op2);\n+      op3 = force_not_mem (op3);\n+    }\n+\n+  if (target)\n+    target = protect_from_queue (target, 1);\n+  else\n+    target = gen_reg_rtx (mode);\n+\n+  subtarget = target;\n+\n+  emit_queue ();\n+\n+  op2 = protect_from_queue (op2, 0);\n+  op3 = protect_from_queue (op3, 0);\n+\n+  /* If the insn doesn't accept these operands, put them in pseudos.  */\n+\n+  if (! (*insn_data[icode].operand[0].predicate)\n+      (subtarget, insn_data[icode].operand[0].mode))\n+    subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n+\n+  if (! (*insn_data[icode].operand[2].predicate)\n+      (op2, insn_data[icode].operand[2].mode))\n+    op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n+\n+  if (! (*insn_data[icode].operand[3].predicate)\n+      (op3, insn_data[icode].operand[3].mode))\n+    op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n+\n+  /* Everything should now be in the suitable form, so emit the compare insn\n+     and then the conditional move.  */\n+\n+  comparison \n+    = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX);\n+\n+  /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n+  /* We can get const0_rtx or const_true_rtx in some circumstances.  Just\n+     return NULL and let the caller figure out how best to deal with this\n+     situation.  */\n+  if (GET_CODE (comparison) != code)\n+    return NULL_RTX;\n+  \n+  insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n+\n+  /* If that failed, then give up.  */\n+  if (insn == 0)\n+    return 0;\n+\n+  emit_insn (insn);\n+\n+  if (subtarget != target)\n+    convert_move (target, subtarget, 0);\n+\n+  return target;\n+}\n \f\n /* These functions generate an insn body and return it\n    rather than emitting the insn.\n@@ -5229,6 +5357,7 @@ init_optabs ()\n   negv_optab = init_optabv (NEG);\n   abs_optab = init_optab (ABS);\n   absv_optab = init_optabv (ABS);\n+  addcc_optab = init_optab (UNKNOWN);\n   one_cmpl_optab = init_optab (NOT);\n   ffs_optab = init_optab (FFS);\n   sqrt_optab = init_optab (SQRT);"}, {"sha": "e3890fe9a900b1aa1548dd125c3e089e858ba951", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -160,6 +160,9 @@ enum optab_index\n   /* Push instruction.  */\n   OTI_push,\n \n+  /* Conditional add instruction.  */\n+  OTI_addcc,\n+\n   OTI_MAX\n };\n \n@@ -226,6 +229,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define cmov_optab (optab_table[OTI_cmov])\n #define cstore_optab (optab_table[OTI_cstore])\n #define push_optab (optab_table[OTI_push])\n+#define addcc_optab (optab_table[OTI_addcc])\n \n /* Tables of patterns for extending one integer mode to another.  */\n extern enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];"}, {"sha": "40204074af7c3a7a247fe508e5a6bd8a51734ec0", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068f5deabfc16d0a4ae112d185c85d9f6bc76eed/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=068f5deabfc16d0a4ae112d185c85d9f6bc76eed", "patch": "@@ -7608,6 +7608,11 @@ delete_output_reload (insn, j, last_reload_reg)\n   rtx i1;\n   rtx substed;\n \n+  /* It is possible that this reload has been only used to set another reload\n+     we eliminated earlier and thus deleted this instruction too.  */\n+  if (INSN_DELETED_P (output_reload_insn))\n+    return;\n+\n   /* Get the raw pseudo-register referred to.  */\n \n   while (GET_CODE (reg) == SUBREG)"}]}