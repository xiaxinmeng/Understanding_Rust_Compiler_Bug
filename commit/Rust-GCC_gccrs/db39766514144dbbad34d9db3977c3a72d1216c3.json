{"sha": "db39766514144dbbad34d9db3977c3a72d1216c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzOTc2NjUxNDE0NGRiYmFkMzRkOWRiMzk3N2MzYTcyZDEyMTZjMw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-29T14:47:31Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:34Z"}, "message": "Added new pattern stripping\n\nFixed get_locus_slow call in StructPatternField compile error\n\nAdded and improved cfg stripping\n\nFixed compilation errors", "tree": {"sha": "c7c470e4bf94ccb0105f8ad80ff85c7582ee9358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7c470e4bf94ccb0105f8ad80ff85c7582ee9358"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db39766514144dbbad34d9db3977c3a72d1216c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db39766514144dbbad34d9db3977c3a72d1216c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db39766514144dbbad34d9db3977c3a72d1216c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db39766514144dbbad34d9db3977c3a72d1216c3/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b252167a77316750f34c455222e5f30724e51e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b252167a77316750f34c455222e5f30724e51e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b252167a77316750f34c455222e5f30724e51e4"}], "stats": {"total": 1647, "additions": 1377, "deletions": 270}, "files": [{"sha": "439543e0f7870885e193dea230808935a6f51a24", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -594,7 +594,7 @@ TypeResolution::visit (AST::CallExpr &expr)\n       AST::Type *argument = typeBuffer.back ();\n       typeBuffer.pop_back ();\n \n-      if (!typesAreCompatible (it->type.get (), argument,\n+      if (!typesAreCompatible (it->get_type ().get (), argument,\n \t\t\t       expr.get_params ()[offs]->get_locus_slow ()))\n \treturn;\n       offs--;\n@@ -768,11 +768,11 @@ TypeResolution::visit (AST::Function &function)\n \n   for (auto &param : function.get_function_params ())\n     {\n-      if (!isTypeInScope (param.type.get (), param.get_locus ()))\n+      if (!isTypeInScope (param.get_type ().get (), param.get_locus ()))\n \treturn;\n \n       auto before = letPatternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n+      param.get_pattern ()->accept_vis (*this);\n       if (letPatternBuffer.size () <= before)\n \t{\n \t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n@@ -781,11 +781,11 @@ TypeResolution::visit (AST::Function &function)\n \n       auto paramName = letPatternBuffer.back ();\n       letPatternBuffer.pop_back ();\n-      scope.InsertType (paramName.variable_ident, param.type.get ());\n+      scope.InsertType (paramName.get_ident (), param.get_type ().get ());\n     }\n \n   // ensure the return type is resolved\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n       if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n \treturn;\n@@ -1015,12 +1015,12 @@ TypeResolution::visit (AST::LetStmt &stmt)\n   if (stmt.has_init_expr ())\n     {\n       auto before = typeBuffer.size ();\n-      stmt.init_expr->accept_vis (*this);\n+      stmt.get_init_expr ()->accept_vis (*this);\n \n       if (typeBuffer.size () <= before)\n \t{\n \t  rust_error_at (\n-\t    stmt.init_expr->get_locus_slow (),\n+\t    stmt.get_init_expr ()->get_locus_slow (),\n \t    \"unable to determine type for declaration from init expr\");\n \t  return;\n \t}\n@@ -1030,7 +1030,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \n       if (inferedType == NULL)\n \t{\n-\t  rust_error_at (stmt.init_expr->get_locus_slow (),\n+\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n \t\t\t \"void type found for statement initialisation\");\n \t  return;\n \t}\n@@ -1039,7 +1039,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n   if (stmt.has_type () && stmt.has_init_expr ())\n     {\n       if (!typesAreCompatible (stmt.type.get (), inferedType,\n-\t\t\t       stmt.init_expr->get_locus_slow ()))\n+\t\t\t       stmt.get_init_expr ()->get_locus_slow ()))\n \t{\n \t  return;\n \t}\n@@ -1059,9 +1059,9 @@ TypeResolution::visit (AST::LetStmt &stmt)\n     }\n \n   // get all the names part of this declaration and add the types to the scope\n-  stmt.variables_pattern->accept_vis (*this);\n+  stmt.get_pattern ()->accept_vis (*this);\n   for (auto &pattern : letPatternBuffer)\n-    scope.InsertType (pattern.variable_ident, inferedType);\n+    scope.InsertType (pattern.get_ident (), inferedType);\n \n   letPatternBuffer.clear ();\n }"}, {"sha": "26a335660af3b1fcb893f5b7ac5f03f9f9c6bafd", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -1103,7 +1103,7 @@ Function::as_string () const\n   if (\"\" != qstr)\n     str += qstr + \" \";\n \n-  if (has_function_return_type ())\n+  if (has_return_type ())\n     {\n       // DEBUG: null pointer check\n       if (return_type == nullptr)\n@@ -1168,9 +1168,7 @@ Function::as_string () const\n     }\n \n   if (has_where_clause ())\n-    {\n       str += \" where \" + where_clause.as_string ();\n-    }\n \n   str += \"\\n\";\n \n@@ -1201,9 +1199,7 @@ WhereClause::as_string () const\n   else\n     {\n       for (const auto &item : where_clause_items)\n-\t{\n \t  str += \"\\n  \" + item->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -1228,9 +1224,7 @@ BlockExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n     }\n \n   // statements\n@@ -1260,13 +1254,9 @@ BlockExpr::as_string () const\n   // final expression\n   str += \"\\n\" + indent_spaces (stay) + \"final expression: \";\n   if (expr == nullptr)\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += \"\\n\" + expr->as_string ();\n-    }\n \n   str += \"\\n\" + indent_spaces (out) + \"}\";\n   return str;\n@@ -1278,9 +1268,7 @@ TraitImpl::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-    {\n       str += \"unsafe \";\n-    }\n \n   str += \"impl \";\n \n@@ -1293,34 +1281,24 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &param : generic_params)\n-\t{\n \t  str += \"\\n  \" + param->as_string ();\n-\t}\n     }\n \n   str += \"\\n Has exclam: \";\n   if (has_exclam)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n TypePath (to trait): \" + trait_path.as_string ();\n \n   str += \"\\n Type (struct to impl on): \" + trait_type->as_string ();\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += where_clause.as_string ();\n-    }\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -1333,9 +1311,7 @@ TraitImpl::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\n trait impl items: \";\n@@ -1346,9 +1322,7 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &item : impl_items)\n-\t{\n \t  str += \"\\n  \" + item->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -1464,9 +1438,7 @@ ExternBlock::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\n external items: \";\n@@ -1477,9 +1449,7 @@ ExternBlock::as_string () const\n   else\n     {\n       for (const auto &item : extern_items)\n-\t{\n \t  str += \"\\n  \" + item->as_string ();\n-\t}\n     }\n \n   return str;\n@@ -1558,9 +1528,7 @@ PathInExpression::as_string () const\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-    {\n       str = \"::\";\n-    }\n \n   return str + PathPattern::as_string ();\n }\n@@ -1591,9 +1559,7 @@ ClosureParam::as_string () const\n   std::string str (pattern->as_string ());\n \n   if (has_type_given ())\n-    {\n       str += \" : \" + type->as_string ();\n-    }\n \n   return str;\n }\n@@ -1603,13 +1569,9 @@ ClosureExpr::as_string () const\n {\n   std::string str (\"ClosureExpr:\\n Has move: \");\n   if (has_move)\n-    {\n       str += \"true\";\n-    }\n   else\n-    {\n       str += \"false\";\n-    }\n \n   str += \"\\n Params: \";\n   if (params.empty ())\n@@ -1619,9 +1581,7 @@ ClosureExpr::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n     }\n \n   return str;\n@@ -1645,9 +1605,7 @@ PathPattern::as_string () const\n   std::string str;\n \n   for (const auto &segment : segments)\n-    {\n       str += segment.as_string () + \"::\";\n-    }\n \n   // basically a hack - remove last two characters of string (remove final ::)\n   str.erase (str.length () - 2);\n@@ -1662,9 +1620,7 @@ QualifiedPathType::as_string () const\n   str += type_to_invoke_on->as_string ();\n \n   if (has_as_clause ())\n-    {\n       str += \" as \" + trait_path.as_string ();\n-    }\n \n   return str + \">\";\n }\n@@ -1681,14 +1637,10 @@ BorrowExpr::as_string () const\n   std::string str (\"&\");\n \n   if (double_borrow)\n-    {\n       str += \"&\";\n-    }\n \n   if (is_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   str += main_or_left_expr->as_string ();\n \n@@ -1722,9 +1674,7 @@ GroupedExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n@@ -1744,9 +1694,7 @@ ContinueExpr::as_string () const\n   std::string str (\"continue \");\n \n   if (has_label ())\n-    {\n       str += label.as_string ();\n-    }\n \n   return str;\n }\n@@ -1881,9 +1829,7 @@ MethodCallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t    {\n \t      return \"ERROR_MARK_STRING - method call expr param is null\";\n-\t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -2022,9 +1968,7 @@ IfLetExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n \t  str += \"\\n  \" + pattern->as_string ();\n-\t}\n     }\n \n   str += \"\\n Scrutinee expr: \" + value->as_string ();\n@@ -2213,9 +2157,7 @@ CallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t    {\n \t      return \"ERROR_MARK_STRING - call expr param is null\";\n-\t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -2231,13 +2173,9 @@ WhileLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += loop_label.as_string ();\n-    }\n \n   str += \"\\n Conditional expr: \" + condition->as_string ();\n \n@@ -2282,13 +2220,9 @@ LoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += loop_label.as_string ();\n-    }\n \n   str += \"\\n Loop block: \" + loop_block->as_string ();\n \n@@ -2311,20 +2245,14 @@ ArrayExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += internal_elements->as_string ();\n-    }\n \n   return str;\n }\n@@ -2341,14 +2269,10 @@ BreakExpr::as_string () const\n   std::string str (\"break \");\n \n   if (has_label ())\n-    {\n       str += label.as_string () + \" \";\n-    }\n \n   if (has_break_expr ())\n-    {\n       str += break_expr->as_string ();\n-    }\n \n   return str;\n }\n@@ -2373,9 +2297,7 @@ MatchArm::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\nPatterns: \";\n@@ -2386,20 +2308,14 @@ MatchArm::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n \t  str += \"\\n \" + pattern->as_string ();\n-\t}\n     }\n \n   str += \"\\nGuard expr: \";\n   if (!has_match_arm_guard ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += guard_expr->as_string ();\n-    }\n \n   return str;\n }"}, {"sha": "b5e56ba0adc5330f18e8e77be8b49851109e99fb", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -968,6 +968,14 @@ class Pattern\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // as only one kind of pattern can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const = 0;\n+\n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;\n@@ -1002,6 +1010,12 @@ class Type\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // as only two kinds of types can be stripped, have default of nothing\n+  virtual void mark_for_strip () {}\n+  virtual bool is_marked_for_strip () const { return false; }\n+\n+  virtual Location get_locus_slow () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n@@ -1081,7 +1095,7 @@ class Lifetime : public TypeParamBound\n   {}\n \n   // Creates an \"error\" lifetime.\n-  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n+  static Lifetime error () { return Lifetime (NAMED, \"\"); }\n \n   // Returns true if the lifetime is in an error state.\n   bool is_error () const"}, {"sha": "34dfc25f79c5d45b45e2101a3aae0202dec08c3a", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -669,6 +669,12 @@ class TypeCastExpr : public OperatorExpr\n     return main_or_left_expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<TypeNoBounds> &get_type_to_cast_to () {\n+    rust_assert (type_to_convert_to != nullptr);\n+    return type_to_convert_to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1375,6 +1381,7 @@ class StructExpr : public ExprWithoutBlock\n \n public:\n   const PathInExpression &get_struct_name () const { return struct_name; }\n+  PathInExpression &get_struct_name () { return struct_name; }\n \n   std::string as_string () const override;\n \n@@ -1828,8 +1835,8 @@ class EnumVariantExpr : public ExprWithoutBlock\n   {}\n \n public:\n-  // TODO: maybe remove and have string version gotten here directly\n-  PathInExpression get_enum_variant_path () const { return enum_variant_path; }\n+  const PathInExpression& get_enum_variant_path () const { return enum_variant_path; }\n+  PathInExpression& get_enum_variant_path () { return enum_variant_path; }\n \n   // Invalid if path is in error state, so base stripping on that.\n   void mark_for_strip () override { enum_variant_path = PathInExpression::create_error (); }\n@@ -2305,7 +2312,8 @@ class MethodCallExpr : public ExprWithoutBlock\n     return receiver;\n   }\n \n-  PathExprSegment get_method_name () const { return method_name; }\n+  const PathExprSegment &get_method_name () const { return method_name; }\n+  PathExprSegment &get_method_name () { return method_name; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -2462,6 +2470,18 @@ struct ClosureParam\n \n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Pattern> &get_pattern () {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (has_type_given ());\n+    return type;\n+  }\n };\n \n // Base closure definition expression AST node - abstract\n@@ -2756,6 +2776,12 @@ class ClosureExprInnerTyped : public ClosureExpr\n     return expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (return_type != nullptr);\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3667,6 +3693,10 @@ class WhileLetLoopExpr : public BaseLoopExpr\n     return scrutinee;\n   }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3728,6 +3758,12 @@ class ForLoopExpr : public BaseLoopExpr\n     return iterator_expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Pattern> &get_pattern () {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3959,7 +3995,6 @@ class IfLetExpr : public ExprWithBlock\n   std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n   std::unique_ptr<Expr> value;\n   std::unique_ptr<BlockExpr> if_block;\n-\n   Location locus;\n \n public:\n@@ -4043,6 +4078,10 @@ class IfLetExpr : public ExprWithBlock\n     return if_block;\n   }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base (or rather this or any derived object) */\n@@ -4366,6 +4405,9 @@ struct MatchArm\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n };\n \n /*"}, {"sha": "c47a6f5650a605bd46f1d382167772951470659e", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 251, "deletions": 21, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -123,6 +123,16 @@ class TypeParam : public GenericParam\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeParam *clone_generic_param_impl () const override\n@@ -245,6 +255,16 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (bound_type != nullptr);\n+    return bound_type;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeBoundWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -299,6 +319,10 @@ struct WhereClause\n   bool is_empty () const { return where_clause_items.empty (); }\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<WhereClauseItem> > &get_items () { return where_clause_items; }\n+  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const { return where_clause_items; }\n };\n \n // A self parameter in a method\n@@ -322,6 +346,8 @@ struct SelfParam\n   {}\n   // this is ok as no outside classes can ever call this\n \n+  // TODO: self param can have outer attributes\n+\n public:\n   // Returns whether the self-param has a type field.\n   bool has_type () const { return type != nullptr; }\n@@ -332,21 +358,15 @@ struct SelfParam\n   // Returns whether the self-param is in an error state.\n   bool is_error () const\n   {\n-    return has_type () && has_lifetime ();\n+    return (has_type () && has_lifetime ()) || (has_lifetime () && !has_ref);\n     // not having either is not an error\n   }\n \n   // Creates an error state self-param.\n   static SelfParam create_error ()\n   {\n-    /* HACK: creates a dummy type. Since it's a unique pointer, it should\n-     * clean it up, but it still allocates memory, which is not ideal. */\n-    return SelfParam (Lifetime (Lifetime::STATIC), false, false,\n-\t\t      new QualifiedPathInType (\n-\t\t\tQualifiedPathInType::create_error ()));\n-    /* FIXME: is there a reason why I didn't just create a null pointer? Is it\n-     * due to error being having both a type and a lifetime? If it is, wouldn't\n-     * something like \"not has_ref and has lifetime\" for error be better? */\n+    // cannot have no ref but have a lifetime at the same time\n+    return SelfParam (Lifetime (Lifetime::STATIC), false, false, nullptr);\n   }\n \n   // Type-based self parameter (not ref, no lifetime)\n@@ -373,13 +393,16 @@ struct SelfParam\n   // Overload assignment operator to use clone\n   SelfParam &operator= (SelfParam const &other)\n   {\n-    if (other.type != nullptr)\n-      type = other.type->clone_type ();\n     is_mut = other.is_mut;\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n \n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -390,6 +413,12 @@ struct SelfParam\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n };\n \n // Qualifiers for function, i.e. const, unsafe, extern etc.\n@@ -437,11 +466,10 @@ struct FunctionParam\n private:\n   std::vector<Attribute> outer_attrs;\n   Location locus;\n-\n-public:\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n \n+public:\n   FunctionParam (std::unique_ptr<Pattern> param_name,\n \t\t std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), locus (locus), \n@@ -496,6 +524,18 @@ struct FunctionParam\n   // TODO: seems kinda dodgy. Think of better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Pattern> &get_pattern () {\n+    rust_assert (param_name != nullptr);\n+    return param_name;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -740,12 +780,30 @@ class Method : public InherentImplItem, public TraitImplItem\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<BlockExpr> &get_definition () {\n     rust_assert (function_body != nullptr);\n     return function_body;\n   }\n \n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1299,7 +1357,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   bool has_function_params () const { return !function_params.empty (); }\n \n   // Returns whether function has return type - if not, it is void.\n-  bool has_function_return_type () const { return return_type != nullptr; }\n+  bool has_return_type () const { return return_type != nullptr; }\n \n   // Returns whether function has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n@@ -1390,6 +1448,9 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<BlockExpr> &get_definition () {\n     rust_assert (function_body != nullptr);\n@@ -1408,7 +1469,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_return_type () {\n-    rust_assert (return_type != nullptr);\n+    rust_assert (has_return_type ());\n     return return_type;\n   }\n \n@@ -1518,6 +1579,21 @@ class TypeAlias : public VisItem, public TraitImplItem\n   void mark_for_strip () override { existing_type = nullptr; }\n   bool is_marked_for_strip () const override { return existing_type == nullptr; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type_aliased () {\n+    rust_assert (existing_type != nullptr);\n+    return existing_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1563,6 +1639,15 @@ class Struct : public VisItem\n \n   Identifier get_struct_name () const { return struct_name; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   Struct (Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -1819,6 +1904,12 @@ struct TupleField\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_field_type () {\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n+  }\n };\n \n // Rust tuple declared using struct keyword AST node\n@@ -2112,6 +2203,15 @@ class Enum : public VisItem\n   std::vector<std::unique_ptr<EnumItem>> &get_variants () { return items; }\n   const std::vector<std::unique_ptr<EnumItem>> &get_variants () const { return items; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2197,6 +2297,15 @@ class Union : public VisItem\n   std::vector<StructField> &get_variants () { return variants; }\n   const std::vector<StructField> &get_variants () const { return variants; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2282,6 +2391,12 @@ class ConstantItem : public VisItem,\n     return const_expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2377,6 +2492,12 @@ class StaticItem : public VisItem\n     return expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2488,6 +2609,21 @@ struct TraitFunctionDecl\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n };\n \n // Actual trait item function declaration within traits\n@@ -2552,15 +2688,18 @@ class TraitItemFunc : public TraitItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n-  std::vector<FunctionParam> &get_function_params () { return decl.get_function_params (); }\n-  const std::vector<FunctionParam> &get_function_params () const { return decl.get_function_params (); }\n-\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<BlockExpr> &get_definition () {\n-    rust_assert (has_definition());\n+    rust_assert (has_definition ());\n     return block_expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TraitFunctionDecl &get_trait_function_decl () {\n+    // TODO: maybe only allow access if not marked for strip?\n+    return decl;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemFunc *clone_trait_item_impl () const override\n@@ -2675,6 +2814,24 @@ struct TraitMethodDecl\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n };\n \n // Actual trait item method declaration within traits\n@@ -2740,8 +2897,11 @@ class TraitItemMethod : public TraitItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n-  std::vector<FunctionParam> &get_function_params () { return decl.get_function_params (); }\n-  const std::vector<FunctionParam> &get_function_params () const { return decl.get_function_params (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TraitMethodDecl &get_trait_method_decl () {\n+    // TODO: maybe only allow access if not marked for strip?\n+    return decl;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<BlockExpr> &get_definition () {\n@@ -2840,6 +3000,12 @@ class TraitItemConst : public TraitItem\n     return expr;\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2916,6 +3082,10 @@ class TraitItemType : public TraitItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -3044,6 +3214,18 @@ class Trait : public VisItem\n   const std::vector<std::unique_ptr<TraitItem>>& get_trait_items () const { return trait_items; }\n   std::vector<std::unique_ptr<TraitItem>>& get_trait_items () { return trait_items; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3091,6 +3273,21 @@ class Impl : public VisItem\n   const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (trait_type != nullptr);\n+    return trait_type;\n+  }\n+\n protected:\n   // Mega-constructor\n   Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -3274,6 +3471,12 @@ class TraitImpl : public Impl\n   const std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () const { return impl_items; }\n   std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () { return impl_items; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  TypePath &get_trait_path () {\n+    // TODO: assert that trait path is not empty?\n+    return trait_path;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3435,6 +3638,12 @@ class ExternalStaticItem : public ExternalItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (item_type != nullptr);\n+    return item_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3522,6 +3731,12 @@ struct NamedFunctionParam\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n };\n \n // A function item used in an extern block\n@@ -3652,6 +3867,21 @@ class ExternalFunctionItem : public ExternalItem\n   std::vector<NamedFunctionParam> &get_function_params () { return function_params; }\n   const std::vector<NamedFunctionParam> &get_function_params () const { return function_params; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "b5d7869217e220e188d7d805046743fba26f72a8", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -45,7 +45,6 @@ struct GenericArgsBinding\n private:\n   Identifier identifier;\n   std::unique_ptr<Type> type;\n-\n   Location locus;\n \n public:\n@@ -100,6 +99,12 @@ struct GenericArgsBinding\n   GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n };\n \n // Generic arguments allowed in each path expression segment - inline?\n@@ -166,6 +171,16 @@ struct GenericArgs\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<std::unique_ptr<Type>> &get_type_args () {\n+    return type_args;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<GenericArgsBinding> &get_binding_args () {\n+    return binding_args;\n+  }\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe\n@@ -221,6 +236,12 @@ class PathExprSegment\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args () {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -249,6 +270,10 @@ class PathPattern : public Pattern\n   bool is_single_segment () const { return segments.size () == 1; }\n \n   std::string as_string () const override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<PathExprSegment> &get_segments () { return segments; }\n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n };\n \n /* AST node representing a path-in-expression pattern (path that allows generic\n@@ -416,6 +441,12 @@ class TypePathSegmentGeneric : public TypePathSegment\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args () {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n@@ -504,6 +535,16 @@ struct TypePathFunction\n   TypePathFunction &operator= (TypePathFunction &&other) = default;\n \n   std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Type>> &get_params () const { return inputs; }\n+  std::vector<std::unique_ptr<Type>> &get_params () { return inputs; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n };\n \n // Segment used in type path with a function argument\n@@ -536,6 +577,12 @@ class TypePathSegmentFunction : public TypePathSegment\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePathFunction &get_type_path_function () {\n+    rust_assert (!function_path.is_error ());\n+    return function_path;\n+  }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentFunction *clone_type_path_segment_impl () const override\n@@ -547,7 +594,6 @@ class TypePathSegmentFunction : public TypePathSegment\n // Path used inside types\n class TypePath : public TypeNoBounds\n {\n-public:\n   bool has_opening_scope_resolution;\n   std::vector<std::unique_ptr<TypePathSegment>> segments;\n   Location locus;\n@@ -622,8 +668,13 @@ class TypePath : public TypeNoBounds\n   TraitBound *to_trait_bound (bool in_parens) const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment>> &get_segments () { return segments; }\n+  const std::vector<std::unique_ptr<TypePathSegment>> &get_segments () const { return segments; }\n };\n \n struct QualifiedPathType\n@@ -691,6 +742,18 @@ struct QualifiedPathType\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (type_to_invoke_on != nullptr);\n+    return type_to_invoke_on;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePath &get_as_type_path () {\n+    rust_assert (has_as_clause ());\n+    return trait_path;\n+  }\n };\n \n /* AST node representing a qualified path-in-expression pattern (path that\n@@ -735,6 +798,12 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   void mark_for_strip () override { path_type = QualifiedPathType::create_error (); }\n   bool is_marked_for_strip () const override { return is_error (); }\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type () {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -819,6 +888,19 @@ class QualifiedPathInType : public TypeNoBounds\n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type () {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment>> &get_segments () { return segments; }\n+  const std::vector<std::unique_ptr<TypePathSegment>> &get_segments () const { return segments; }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n };\n } // namespace AST\n } // namespace Rust"}, {"sha": "5dd042979822716f4a5c8f9c020fadc9966b6291", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 175, "deletions": 19, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -34,6 +34,7 @@ class LiteralPattern : public Pattern\n   {}\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -49,7 +50,6 @@ class LiteralPattern : public Pattern\n // Identifier pattern AST node (bind value matched to a variable)\n class IdentifierPattern : public Pattern\n {\n-public:\n   Identifier variable_ident;\n   bool is_ref;\n   bool is_mut;\n@@ -59,6 +59,7 @@ class IdentifierPattern : public Pattern\n \n   Location locus;\n \n+public:\n   std::string as_string () const;\n \n   // Returns whether the IdentifierPattern has a pattern to bind.\n@@ -104,9 +105,18 @@ class IdentifierPattern : public Pattern\n   IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_pattern_to_bind () {\n+    rust_assert (has_pattern_to_bind ());\n+    return to_bind;\n+  }\n+\n+  Identifier get_ident() const { return variable_ident; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -127,6 +137,7 @@ class WildcardPattern : public Pattern\n   WildcardPattern (Location locus) : locus (locus) {}\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -295,6 +306,7 @@ class RangePattern : public Pattern\n   RangePattern &operator= (RangePattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -345,8 +357,17 @@ class ReferencePattern : public Pattern\n   ReferencePattern (ReferencePattern &&other) = default;\n   ReferencePattern &operator= (ReferencePattern &&other) = default;\n \n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_referenced_pattern () {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -356,6 +377,7 @@ class ReferencePattern : public Pattern\n   }\n };\n \n+#if 0\n // aka StructPatternEtCetera; potential element in struct pattern\n struct StructPatternEtc\n {\n@@ -375,6 +397,7 @@ struct StructPatternEtc\n     return StructPatternEtc (std::vector<Attribute> ());\n   }\n };\n+#endif\n \n // Base class for a single field in a struct pattern - abstract\n class StructPatternField\n@@ -398,6 +421,13 @@ class StructPatternField\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n     : outer_attrs (std::move (outer_attribs)), locus (locus)\n@@ -424,19 +454,27 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   // Copy constructor requires clone\n   StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n-    : StructPatternField (other), index (other.index),\n-      tuple_pattern (other.tuple_pattern->clone_pattern ())\n-  {}\n+    : StructPatternField (other), index (other.index)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+  }\n \n   // Overload assignment operator to perform clone\n   StructPatternFieldTuplePat &\n   operator= (StructPatternFieldTuplePat const &other)\n   {\n     StructPatternField::operator= (other);\n-    tuple_pattern = other.tuple_pattern->clone_pattern ();\n     index = other.index;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    else\n+      tuple_pattern = nullptr;\n+\n     return *this;\n   }\n \n@@ -449,6 +487,16 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of tuple pattern no longer existing\n+  void mark_for_strip () override { tuple_pattern = nullptr; }\n+  bool is_marked_for_strip () const override { return tuple_pattern == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_index_pattern () {\n+    rust_assert (tuple_pattern != nullptr);\n+    return tuple_pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -475,19 +523,27 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   // Copy constructor requires clone\n   StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n-    : StructPatternField (other), ident (other.ident),\n-      ident_pattern (other.ident_pattern->clone_pattern ())\n-  {}\n+    : StructPatternField (other), ident (other.ident)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+  }\n \n   // Overload assignment operator to clone\n   StructPatternFieldIdentPat &\n   operator= (StructPatternFieldIdentPat const &other)\n   {\n     StructPatternField::operator= (other);\n     ident = other.ident;\n-    ident_pattern = other.ident_pattern->clone_pattern ();\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+    else\n+      ident_pattern = nullptr;\n+\n     return *this;\n   }\n \n@@ -500,6 +556,16 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of identifier pattern no longer existing\n+  void mark_for_strip () override { ident_pattern = nullptr; }\n+  bool is_marked_for_strip () const override { return ident_pattern == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_ident_pattern () {\n+    rust_assert (ident_pattern != nullptr);\n+    return ident_pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -527,6 +593,10 @@ class StructPatternFieldIdent : public StructPatternField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // based on idea of identifier no longer existing\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -544,7 +614,8 @@ struct StructPatternElements\n   std::vector<std::unique_ptr<StructPatternField>> fields;\n \n   bool has_struct_pattern_etc;\n-  StructPatternEtc etc;\n+  std::vector<Attribute> struct_pattern_etc_attrs;\n+  //StructPatternEtc etc;\n \n   // must have at least one of the two and maybe both\n \n@@ -561,24 +632,26 @@ struct StructPatternElements\n     return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n   }\n \n+  bool has_etc () const { return has_struct_pattern_etc; }\n+\n   // Constructor for StructPatternElements with both (potentially)\n   StructPatternElements (\n     std::vector<std::unique_ptr<StructPatternField>> fields,\n-    StructPatternEtc etc)\n+    std::vector<Attribute> etc_attrs)\n     : fields (std::move (fields)), has_struct_pattern_etc (true),\n-      etc (std::move (etc))\n+      struct_pattern_etc_attrs (std::move (etc_attrs))\n   {}\n \n   // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n     std::vector<std::unique_ptr<StructPatternField>> fields)\n     : fields (std::move (fields)), has_struct_pattern_etc (false),\n-      etc (StructPatternEtc::create_empty ())\n+      struct_pattern_etc_attrs ()\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n-    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc), struct_pattern_etc_attrs (other.struct_pattern_etc_attrs)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -588,7 +661,7 @@ struct StructPatternElements\n   // Overloaded assignment operator with vector clone\n   StructPatternElements &operator= (StructPatternElements const &other)\n   {\n-    etc = other.etc;\n+    struct_pattern_etc_attrs = other.struct_pattern_etc_attrs;\n     has_struct_pattern_etc = other.has_struct_pattern_etc;\n \n     fields.reserve (other.fields.size ());\n@@ -610,6 +683,20 @@ struct StructPatternElements\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<StructPatternField>> &get_struct_pattern_fields () { return fields; }\n+  const std::vector<std::unique_ptr<StructPatternField>> &get_struct_pattern_fields () const { return fields; }\n+\n+  std::vector<Attribute> &get_etc_outer_attrs () { return struct_pattern_etc_attrs; }\n+  const std::vector<Attribute> &get_etc_outer_attrs () const { return struct_pattern_etc_attrs; }\n+\n+  void strip_etc () \n+  { \n+    has_struct_pattern_etc = false; \n+    struct_pattern_etc_attrs.clear ();\n+    struct_pattern_etc_attrs.shrink_to_fit ();\n+  }\n };\n \n // Struct pattern AST node representation\n@@ -640,9 +727,14 @@ class StructPattern : public Pattern\n   bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n \n   Location get_locus () const { return path.get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  StructPatternElements &get_struct_pattern_elems () { return elems; }\n+  const StructPatternElements &get_struct_pattern_elems () const { return elems; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -712,6 +804,10 @@ class TupleStructItemsNoRange : public TupleStructItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_patterns () const { return patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -768,6 +864,14 @@ class TupleStructItemsRange : public TupleStructItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () { return lower_patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () const { return lower_patterns; }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () { return upper_patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () const { return upper_patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -789,21 +893,33 @@ class TupleStructPattern : public Pattern\n public:\n   std::string as_string () const override;\n \n+  // Returns whether the pattern has tuple struct items.\n+  bool has_items () const { return items != nullptr; }\n+\n   TupleStructPattern (PathInExpression tuple_struct_path,\n \t\t      std::unique_ptr<TupleStructItems> items)\n     : path (std::move (tuple_struct_path)), items (std::move (items))\n   {}\n \n   // Copy constructor required to clone\n   TupleStructPattern (TupleStructPattern const &other)\n-    : path (other.path), items (other.items->clone_tuple_struct_items ())\n-  {}\n+    : path (other.path)\n+  {\n+    // guard to protect from null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+  }\n \n   // Operator overload assignment operator to clone\n   TupleStructPattern &operator= (TupleStructPattern const &other)\n   {\n     path = other.path;\n-    items = other.items->clone_tuple_struct_items ();\n+\n+    // guard to protect from null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+    else\n+      items = nullptr;\n \n     return *this;\n   }\n@@ -813,9 +929,17 @@ class TupleStructPattern : public Pattern\n   TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n \n   Location get_locus () const { return path.get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TupleStructItems> &get_items () \n+  { \n+    rust_assert (has_items ());\n+    return items; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -921,6 +1045,10 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_patterns () const { return patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -979,6 +1107,14 @@ class TuplePatternItemsRanged : public TuplePatternItems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () { return lower_patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () const { return lower_patterns; }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () { return upper_patterns; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () const { return upper_patterns; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -993,7 +1129,6 @@ class TuplePattern : public Pattern\n {\n   // bool has_tuple_pattern_items;\n   std::unique_ptr<TuplePatternItems> items;\n-\n   Location locus;\n \n public:\n@@ -1030,9 +1165,17 @@ class TuplePattern : public Pattern\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TuplePatternItems> &get_items () \n+  { \n+    rust_assert (has_tuple_pattern_items ());\n+    return items; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1078,9 +1221,17 @@ class GroupedPattern : public Pattern\n   GroupedPattern &operator= (GroupedPattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<Pattern> &get_pattern_in_parens () \n+  { \n+    rust_assert (pattern_in_parens != nullptr);\n+    return pattern_in_parens; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1128,9 +1279,14 @@ class SlicePattern : public Pattern\n   SlicePattern &operator= (SlicePattern &&other) = default;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern>> &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Pattern>> &get_items () const { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "167828c1a77368d9ab2c8a7b982501bfbdb9f124", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -131,10 +131,15 @@ class LetStmt : public Stmt\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_init_expr () {\n-    rust_assert (init_expr != nullptr);\n+    rust_assert (has_init_expr ());\n     return init_expr;\n   }\n \n+  std::unique_ptr<Pattern> &get_pattern () {\n+    rust_assert (variables_pattern != nullptr);\n+    return variables_pattern;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "d5953a569e8ceaa0ab711f5b18e9ec3df95efc00", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -106,6 +106,7 @@ class ImplTraitType : public Type\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -164,6 +165,7 @@ class TraitObjectType : public Type\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -212,7 +214,7 @@ class ParenthesisedType : public TypeNoBounds\n   }\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  TraitBound *to_trait_bound (bool) const override\n   {\n     /* NOTE: obviously it is unknown whether the internal type is a trait bound\n      * due to polymorphism, so just let the internal type handle it. As\n@@ -221,6 +223,7 @@ class ParenthesisedType : public TypeNoBounds\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -229,7 +232,6 @@ class ParenthesisedType : public TypeNoBounds\n class ImplTraitTypeOneBound : public TypeNoBounds\n {\n   TraitBound trait_bound;\n-\n   Location locus;\n \n protected:\n@@ -248,6 +250,7 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -258,7 +261,6 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n {\n   bool has_dyn;\n   TraitBound trait_bound;\n-\n   Location locus;\n \n protected:\n@@ -279,14 +281,15 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   std::string as_string () const override;\n \n   // Creates a trait bound (clone of this one's trait bound) - HACK\n-  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  TraitBound *to_trait_bound (bool) const override\n   {\n     /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n      * this cloning would not be required as parsing is unambiguous. */\n-    return new AST::TraitBound (trait_bound);\n+    return new TraitBound (trait_bound);\n   }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -335,6 +338,7 @@ class TupleType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -368,6 +372,7 @@ class NeverType : public TypeNoBounds\n   std::string as_string () const override { return \"! (never type)\"; }\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -420,6 +425,7 @@ class RawPointerType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -480,6 +486,7 @@ class ReferenceType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -528,6 +535,7 @@ class ArrayType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -574,6 +582,7 @@ class SliceType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -607,6 +616,7 @@ class InferredType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n };\n@@ -755,6 +765,7 @@ class BareFunctionType : public TypeNoBounds\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n "}, {"sha": "d684c7de5efb708d6f8bc527cb513ba967118cc4", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -100,11 +100,11 @@ Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n   stmt->variables_pattern->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n-      auto var = backend->local_variable (fndecl, pattern.variable_ident,\n+      auto var = backend->local_variable (fndecl, pattern.get_ident (),\n \t\t\t\t\t  translatedType, NULL /*decl_var*/,\n \t\t\t\t\t  false /*address_taken*/, stmt->locus);\n       vars.push_back (var);\n-      scope.InsertVar (pattern.variable_ident, var);\n+      scope.InsertVar (pattern.get_ident (), var);\n     }\n   patternBuffer.clear ();\n   return true;\n@@ -219,7 +219,7 @@ Compilation::visit (AST::TypePathSegmentFunction &segment)\n void\n Compilation::visit (AST::TypePath &path)\n {\n-  if (path.segments.size () > 1)\n+  if (path.get_segments ().size () > 1)\n     {\n       rust_error_at (path.get_locus (), \"unable to compile multi segment types yet\");\n       return;\n@@ -953,15 +953,15 @@ Compilation::visit (AST::Function &function)\n     {\n       // translate the type\n       translatedType = NULL;\n-      param.type->accept_vis (*this);\n+      param.get_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n \t  rust_error_at (param.get_locus (), \"failed to generate type for parameter\");\n \t  return;\n \t}\n \n       auto before = patternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n+      param.get_pattern ()->accept_vis (*this);\n       if (patternBuffer.size () <= before)\n \t{\n \t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n@@ -974,13 +974,13 @@ Compilation::visit (AST::Function &function)\n \t  auto paramName = patternBuffer.back ();\n \t  patternBuffer.pop_back ();\n \t  parameters.push_back (\n-\t    Backend::Btyped_identifier (paramName.variable_ident,\n+\t    Backend::Btyped_identifier (paramName.get_ident (),\n \t\t\t\t\ttranslatedType, param.get_locus ()));\n \t}\n     }\n \n   Btype *returnType = NULL;\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n       translatedType = NULL;\n       function.get_return_type ()->accept_vis (*this);\n@@ -1051,7 +1051,7 @@ Compilation::visit (AST::Function &function)\n   scope.PushBlock (code_block);\n \n   Bvariable *retDecl = NULL;\n-  if (function.has_function_return_type ())\n+  if (function.has_return_type ())\n     {\n       bool address_is_taken = false;\n       Bstatement *ret_var_stmt = NULL;\n@@ -1302,21 +1302,21 @@ Compilation::visit (AST::LetStmt &stmt)\n   for (auto &pattern : patternBuffer)\n     {\n       Bvariable *var = NULL;\n-      if (!scope.LookupVar (pattern.variable_ident, &var))\n+      if (!scope.LookupVar (pattern.get_ident (), &var))\n \t{\n \t  rust_error_at (stmt.get_locus (), \"failed to find var decl for %s\",\n-\t\t\t pattern.variable_ident.c_str ());\n+\t\t\t pattern.get_ident ().c_str ());\n \t  return;\n \t}\n \n       varBuffer.push_back (var);\n \n       Bexpression *init = NULL;\n-      VISIT_POP (stmt.init_expr->get_locus_slow (), stmt.init_expr, init,\n+      VISIT_POP (stmt.get_init_expr ()->get_locus_slow (), stmt.get_init_expr (), init,\n \t\t exprs);\n       if (init == NULL)\n \t{\n-\t  rust_error_at (stmt.init_expr->get_locus_slow (),\n+\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n \t\t\t \"failed to compile init statement\");\n \t  return;\n \t}"}, {"sha": "2fe84cbe78b76f95e172452bfd966a31bd8469ac", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 709, "deletions": 77, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -15,37 +15,197 @@ namespace Rust {\n \n         void expand_struct_fields(std::vector<AST::StructField>& fields) {\n             for (int i = 0; i < fields.size();) {\n-                auto& field_attrs = fields[i].get_outer_attrs();\n+                auto& field = fields[i];\n+\n+                auto& field_attrs = field.get_outer_attrs();\n                 expander.expand_cfg_attrs(field_attrs);\n-                if (expander.fails_cfg(field_attrs))\n+                if (expander.fails_cfg(field_attrs)) {\n                     fields.erase(fields.begin() + i);\n-                else\n-                    i++;\n+                    continue;\n+                }\n+\n+                // expand sub-types of type, but can't strip type itself\n+                auto& type = field.get_field_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n+                // if nothing else happens, increment\n+                i++;\n             }\n         }\n \n         void expand_tuple_fields(std::vector<AST::TupleField>& fields) {\n             for (int i = 0; i < fields.size();) {\n-                auto& field_attrs = fields[i].get_outer_attrs();\n+                auto& field = fields[i];\n+\n+                auto& field_attrs = field.get_outer_attrs();\n                 expander.expand_cfg_attrs(field_attrs);\n-                if (expander.fails_cfg(field_attrs))\n+                if (expander.fails_cfg(field_attrs)) {\n                     fields.erase(fields.begin() + i);\n-                else\n-                    i++;\n+                    continue;\n+                }\n+\n+                // expand sub-types of type, but can't strip type itself\n+                auto& type = field.get_field_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n+                // if nothing else happens, increment\n+                i++;\n             }\n         }\n \n         void expand_function_params(std::vector<AST::FunctionParam>& params) {\n             for (int i = 0; i < params.size();) {\n-                auto& param_attrs = params[i].get_outer_attrs();\n+                auto& param = params[i];\n+\n+                auto& param_attrs = param.get_outer_attrs();\n                 expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg(param_attrs))\n+                if (expander.fails_cfg(param_attrs)) {\n                     params.erase(params.begin() + i);\n-                else\n-                    i++;\n+                    continue;\n+                }\n+\n+                // TODO: should an unwanted strip lead to break out of loop?\n+                auto& pattern = param.get_pattern();\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                \n+                auto& type = param.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+                \n+                // increment\n+                i++;\n+            }\n+        }\n+\n+        void expand_generic_args(AST::GenericArgs& args) {\n+            // lifetime args can't be expanded\n+\n+            // expand type args - strip sub-types only\n+            for (auto& type : args.get_type_args()) {\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            // expand binding args - strip sub-types only\n+            for (auto& binding : args.get_binding_args()) {\n+                auto& type = binding.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+        }\n+\n+        void expand_qualified_path_type(AST::QualifiedPathType& path_type) {\n+            auto& type = path_type.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            \n+            if (path_type.has_as_clause()) {\n+                auto& type_path = path_type.get_as_type_path();\n+                visit(type_path);\n+                if (type_path.is_marked_for_strip())\n+                    rust_error_at(type_path.get_locus(), \"cannot strip type path in this position\");\n+            }\n+        }\n+\n+        void expand_closure_params(std::vector<AST::ClosureParam>& params) {\n+            for (int i = 0; i < params.size();) {\n+                auto& param = params[i];\n+\n+                auto& param_attrs = param.get_outer_attrs();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg(param_attrs)) {\n+                    params.erase(params.begin() + i);\n+                    continue;\n+                }\n+\n+                auto& pattern = param.get_pattern();\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+\n+                if (param.has_type_given()) {\n+                    auto& type = param.get_type();\n+                    type->accept_vis(*this);\n+                    if (type->is_marked_for_strip())\n+                        rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+                }\n+                \n+                // increment if found nothing else so far\n+                i++;\n             }\n         }\n \n+        void expand_self_param(AST::SelfParam& self_param) {\n+            if (self_param.has_type()) {\n+                auto& type = self_param.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+            // TODO: maybe check for invariants being violated - e.g. both type and lifetime?\n+        }\n+\n+        void expand_where_clause(AST::WhereClause& where_clause) {\n+            // items cannot be stripped conceptually, so just accept visitor\n+            for (auto& item : where_clause.get_items()) \n+                item->accept_vis(*this);\n+        }\n+\n+        void expand_trait_function_decl(AST::TraitFunctionDecl& decl) {\n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : decl.get_generic_params()) \n+                param->accept_vis(*this);\n+\n+            /* strip function parameters if required - this is specifically\n+             * allowed by spec */\n+            expand_function_params(decl.get_function_params());\n+\n+            if (decl.has_return_type()) {\n+                auto& return_type = decl.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            if (decl.has_where_clause())\n+                expand_where_clause(decl.get_where_clause());\n+        }\n+\n+        void expand_trait_method_decl(AST::TraitMethodDecl& decl) {\n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : decl.get_generic_params()) \n+                param->accept_vis(*this);\n+            \n+            /* assuming you can't strip self param - wouldn't be a method\n+             * anymore. spec allows outer attrs on self param, but doesn't\n+             * specify whether cfg is used. */\n+            expand_self_param(decl.get_self_param());\n+\n+            /* strip function parameters if required - this is specifically\n+             * allowed by spec */\n+            expand_function_params(decl.get_function_params());\n+\n+            if (decl.has_return_type()) {\n+                auto& return_type = decl.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            if (decl.has_where_clause())\n+                expand_where_clause(decl.get_where_clause());\n+        }\n+\n         void visit(AST::Token& tok) override {\n             // shouldn't require?\n         }\n@@ -77,7 +237,11 @@ namespace Rust {\n                 return;\n             }\n \n+            // can't strip simple path\n+\n             // I don't think any macro token trees can be stripped in any way\n+\n+            // TODO: maybe have cfg! macro stripping behaviour here?\n         }\n \n         void visit(AST::PathInExpression& path) override {\n@@ -87,18 +251,43 @@ namespace Rust {\n                 path.mark_for_strip();\n                 return;\n             }\n+\n+            for (auto& segment : path.get_segments()) {\n+                if (segment.has_generic_args())\n+                    expand_generic_args(segment.get_generic_args());\n+            }\n         }\n         void visit(AST::TypePathSegment& segment) override {\n-            // shouldn't require?\n+            // shouldn't require\n         }\n         void visit(AST::TypePathSegmentGeneric& segment) override {\n-            // shouldn't require?\n+            // TODO: strip inside generic args\n+\n+            if (!segment.has_generic_args()) \n+                return;\n+\n+            expand_generic_args(segment.get_generic_args());\n         }\n         void visit(AST::TypePathSegmentFunction& segment) override {\n-            // shouldn't require?\n+            auto& type_path_function = segment.get_type_path_function();\n+            \n+            for (auto& type : type_path_function.get_params()) {\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            if (type_path_function.has_return_type()) {\n+                auto& return_type = type_path_function.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n         }\n         void visit(AST::TypePath& path) override {\n-            // shouldn't require?\n+            // this shouldn't strip any segments, but can strip inside them\n+            for (auto& segment : path.get_segments()) \n+                segment->accept_vis(*this);\n         }\n         void visit(AST::QualifiedPathInExpression& path) override {\n             // initial strip test based on outer attrs\n@@ -107,9 +296,20 @@ namespace Rust {\n                 path.mark_for_strip();\n                 return;\n             }\n+\n+            expand_qualified_path_type(path.get_qualified_path_type());\n+\n+            for (auto& segment : path.get_segments()) {\n+                if (segment.has_generic_args())\n+                    expand_generic_args(segment.get_generic_args());\n+            }\n         }\n         void visit(AST::QualifiedPathInType& path) override {\n-            // shouldn't require?\n+           expand_qualified_path_type(path.get_qualified_path_type());\n+\n+           // this shouldn't strip any segments, but can strip inside them\n+            for (auto& segment : path.get_segments()) \n+                segment->accept_vis(*this);\n         }\n \n         void visit(AST::LiteralExpr& expr) override {\n@@ -258,14 +458,21 @@ namespace Rust {\n             /* outer attributes never allowed before these. while cannot strip \n              * direct descendant expression, can strip ones below that */\n \n+            auto& casted_expr = expr.get_casted_expr();\n             /* should have no possibility for outer attrs as would be parsed \n              * with outer expr */\n-            expr.get_casted_expr()->accept_vis(*this);\n+            casted_expr->accept_vis(*this);\n \n             // ensure that they are not marked for strip\n-            if (expr.get_casted_expr()->is_marked_for_strip())\n-                rust_error_at(expr.get_casted_expr()->get_locus_slow(), \n+            if (casted_expr->is_marked_for_strip())\n+                rust_error_at(casted_expr->get_locus_slow(), \n                   \"cannot strip expression in this position - outer attributes are never allowed before cast exprs\");\n+            \n+            // TODO: strip sub-types of type\n+            auto& type = expr.get_type_to_cast_to();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n         }\n         void visit(AST::AssignmentExpr& expr) override {\n             /* outer attributes never allowed before these. while cannot strip \n@@ -478,6 +685,12 @@ namespace Rust {\n                 expr.mark_for_strip();\n                 return;\n             }  \n+\n+            // strip sub-exprs of path\n+            auto& struct_name = expr.get_struct_name();\n+            visit(struct_name);\n+            if (struct_name.is_marked_for_strip())\n+                rust_error_at(struct_name.get_locus(), \"cannot strip path in this position\");\n         }\n         void visit(AST::StructExprFieldIdentifier& field) override {\n             // as no attrs (at moment, at least), no stripping possible\n@@ -514,7 +727,13 @@ namespace Rust {\n             if (expander.fails_cfg(expr.get_inner_attrs())) {\n                 expr.mark_for_strip();\n                 return;\n-            }  \n+            } \n+\n+            // strip sub-exprs of path\n+            auto& struct_name = expr.get_struct_name();\n+            visit(struct_name);\n+            if (struct_name.is_marked_for_strip())\n+                rust_error_at(struct_name.get_locus(), \"cannot strip path in this position\");\n \n             /* spec does not specify whether expressions are allowed to be \n              * stripped at top level of struct fields, but I wouldn't think \n@@ -551,6 +770,12 @@ namespace Rust {\n                 return;\n             }  \n \n+            // strip sub-exprs of path\n+            auto& struct_name = expr.get_struct_name();\n+            visit(struct_name);\n+            if (struct_name.is_marked_for_strip())\n+                rust_error_at(struct_name.get_locus(), \"cannot strip path in this position\");\n+\n             /* struct base presumably can't be stripped, as the '..' is before\n              * the expression. as such, can only strip sub-expressions. */\n             rust_assert(!expr.get_struct_base().is_invalid());\n@@ -576,6 +801,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // strip sub-exprs of path\n+            auto& struct_name = expr.get_struct_name();\n+            visit(struct_name);\n+            if (struct_name.is_marked_for_strip())\n+                rust_error_at(struct_name.get_locus(), \"cannot strip path in this position\");\n+\n             /* spec says outer attributes are specifically allowed for elements \n              * of tuple-style struct expressions, so full stripping possible */\n             auto& values = expr.get_elems();\n@@ -598,6 +829,12 @@ namespace Rust {\n                 expr.mark_for_strip();\n                 return;\n             }\n+\n+            // strip sub-exprs of path\n+            auto& struct_name = expr.get_struct_name();\n+            visit(struct_name);\n+            if (struct_name.is_marked_for_strip())\n+                rust_error_at(struct_name.get_locus(), \"cannot strip path in this position\");\n         }\n         void visit(AST::EnumExprFieldIdentifier& field) override {\n             // as no attrs (at moment, at least), no stripping possible\n@@ -630,6 +867,12 @@ namespace Rust {\n \n             // supposedly spec doesn't allow inner attributes in enum exprs\n \n+            // strip sub-exprs of path\n+            auto& enum_path = expr.get_enum_variant_path();\n+            visit(enum_path);\n+            if (enum_path.is_marked_for_strip())\n+                rust_error_at(enum_path.get_locus(), \"cannot strip path in this position\");\n+\n             /* spec does not specify whether expressions are allowed to be \n              * stripped at top level of expression fields, but I wouldn't think\n              * that they would be, so operating under the assumption that only \n@@ -649,6 +892,12 @@ namespace Rust {\n \n             // supposedly spec doesn't allow inner attributes in enum exprs\n \n+            // strip sub-exprs of path\n+            auto& enum_path = expr.get_enum_variant_path();\n+            visit(enum_path);\n+            if (enum_path.is_marked_for_strip())\n+                rust_error_at(enum_path.get_locus(), \"cannot strip path in this position\");\n+\n             /* spec says outer attributes are specifically allowed for elements \n              * of tuple-style enum expressions, so full stripping possible */\n             auto& values = expr.get_elems();\n@@ -666,6 +915,12 @@ namespace Rust {\n         }\n         void visit(AST::EnumExprFieldless& expr) override {\n             // can't be stripped as no attrs\n+\n+            // strip sub-exprs of path\n+            auto& enum_path = expr.get_enum_variant_path();\n+            visit(enum_path);\n+            if (enum_path.is_marked_for_strip())\n+                rust_error_at(enum_path.get_locus(), \"cannot strip path in this position\");\n         }\n         void visit(AST::CallExpr& expr) override {\n             // initial strip test based on outer attrs\n@@ -716,7 +971,9 @@ namespace Rust {\n                 rust_error_at(receiver->get_locus_slow(), \n                   \"cannot strip expression in this position - outer attributes not allowed\");\n \n-            // no outer attrs on paths possible\n+            auto& method_name = expr.get_method_name();\n+            if (method_name.has_generic_args())\n+                expand_generic_args(method_name.get_generic_args());\n \n             /* spec says outer attributes are specifically allowed for elements \n              * of method call expressions, so full stripping possible */\n@@ -760,15 +1017,7 @@ namespace Rust {\n \n             /* strip closure parameters if required - this is specifically\n              * allowed by spec */\n-            auto& params = expr.get_params();\n-            for (int i = 0; i < params.size();) {\n-                auto& param_attrs = params[i].get_outer_attrs();\n-                expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg(param_attrs))\n-                    params.erase(params.begin() + i);\n-                else\n-                    i++;\n-            }\n+            expand_closure_params(expr.get_params());\n \n             // can't strip expression itself, but can strip sub-expressions\n             auto& definition_expr = expr.get_definition_expr();\n@@ -827,15 +1076,13 @@ namespace Rust {\n \n             /* strip closure parameters if required - this is specifically\n              * allowed by spec */\n-            auto& params = expr.get_params();\n-            for (int i = 0; i < params.size();) {\n-                auto& param_attrs = params[i].get_outer_attrs();\n-                expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg(param_attrs))\n-                    params.erase(params.begin() + i);\n-                else\n-                    i++;\n-            }\n+            expand_closure_params(expr.get_params());\n+\n+            // can't strip return type, but can strip sub-types\n+            auto& type = expr.get_return_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n \n             // can't strip expression itself, but can strip sub-expressions\n             auto& definition_block = expr.get_definition_block();\n@@ -1042,6 +1289,12 @@ namespace Rust {\n                 return;\n             }\n \n+            for (auto& pattern : expr.get_patterns()) {\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            }\n+\n             // can't strip scrutinee expr itself, but can strip sub-expressions\n             auto& scrutinee_expr = expr.get_scrutinee_expr();\n             scrutinee_expr->accept_vis(*this);\n@@ -1064,6 +1317,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // TODO: strip sub-patterns of pattern\n+            auto& pattern = expr.get_pattern();\n+            pattern->accept_vis(*this);\n+            if (pattern->is_marked_for_strip())\n+                rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+\n             // can't strip scrutinee expr itself, but can strip sub-expressions\n             auto& iterator_expr = expr.get_iterator_expr();\n             iterator_expr->accept_vis(*this);\n@@ -1195,6 +1454,12 @@ namespace Rust {\n                 return;\n             }\n \n+            for (auto& pattern : expr.get_patterns()) {\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            }\n+\n             // can't strip value expr itself, but can strip sub-expressions\n             auto& value_expr = expr.get_value_expr();\n             value_expr->accept_vis(*this);\n@@ -1217,6 +1482,12 @@ namespace Rust {\n                 return;\n             }\n \n+            for (auto& pattern : expr.get_patterns()) {\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            }\n+\n             // can't strip value expr itself, but can strip sub-expressions\n             auto& value_expr = expr.get_value_expr();\n             value_expr->accept_vis(*this);\n@@ -1246,6 +1517,12 @@ namespace Rust {\n                 return;\n             }\n \n+            for (auto& pattern : expr.get_patterns()) {\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            }\n+\n             // can't strip value expr itself, but can strip sub-expressions\n             auto& value_expr = expr.get_value_expr();\n             value_expr->accept_vis(*this);\n@@ -1275,6 +1552,12 @@ namespace Rust {\n                 return;\n             }\n \n+            for (auto& pattern : expr.get_patterns()) {\n+                pattern->accept_vis(*this);\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            }\n+\n             // can't strip value expr itself, but can strip sub-expressions\n             auto& value_expr = expr.get_value_expr();\n             value_expr->accept_vis(*this);\n@@ -1332,6 +1615,12 @@ namespace Rust {\n                     continue;\n                 } \n \n+                for (auto& pattern : match_arm.get_patterns()) {\n+                    pattern->accept_vis(*this);\n+                    if (pattern->is_marked_for_strip())\n+                        rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                }  \n+\n                 /* assuming that guard expression cannot be stripped as \n                  * strictly speaking you would have to strip the whole guard to \n                  * make syntactical sense, which you can't do. as such, only\n@@ -1388,13 +1677,35 @@ namespace Rust {\n         }\n \n         void visit(AST::TypeParam& param) override {\n-            // shouldn't require?\n+            // outer attributes don't actually do anything, so ignore them\n+\n+            if (param.has_type_param_bounds()) {\n+                // don't strip directly, only components of bounds\n+                for (auto& bound : param.get_type_param_bounds()) \n+                    bound->accept_vis(*this);\n+            }\n+\n+            if (param.has_type()) {\n+                auto& type = param.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n         }\n         void visit(AST::LifetimeWhereClauseItem& item) override {\n-            // shouldn't require?\n+            // shouldn't require\n         }\n         void visit(AST::TypeBoundWhereClauseItem& item) override {\n-            // shouldn't require?\n+            // for lifetimes shouldn't require\n+\n+            auto& type = item.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            \n+            // don't strip directly, only components of bounds\n+            for (auto& bound : item.get_type_param_bounds()) \n+                bound->accept_vis(*this);\n         }\n         void visit(AST::Method& method) override {\n             // initial test based on outer attrs\n@@ -1404,14 +1715,29 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : method.get_generic_params()) \n+                param->accept_vis(*this);\n+\n             /* assuming you can't strip self param - wouldn't be a method\n              * anymore. spec allows outer attrs on self param, but doesn't\n              * specify whether cfg is used. */\n+            expand_self_param(method.get_self_param());\n \n             /* strip method parameters if required - this is specifically\n              * allowed by spec */\n             expand_function_params(method.get_function_params());\n \n+            if (method.has_return_type()) {\n+                auto& return_type = method.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            if (method.has_where_clause())\n+                expand_where_clause(method.get_where_clause());\n+\n             /* body should always exist - if error state, should have returned\n              * before now */\n             // can't strip block itself, but can strip sub-expressions\n@@ -1491,10 +1817,24 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : function.get_generic_params()) \n+                param->accept_vis(*this);\n+\n             /* strip function parameters if required - this is specifically\n              * allowed by spec */\n             expand_function_params(function.get_function_params());\n \n+            if (function.has_return_type()) {\n+                auto& return_type = function.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+\n+            if (function.has_where_clause())\n+                expand_where_clause(function.get_where_clause());\n+\n             /* body should always exist - if error state, should have returned\n              * before now */\n             // can't strip block itself, but can strip sub-expressions\n@@ -1511,6 +1851,18 @@ namespace Rust {\n                 type_alias.mark_for_strip();\n                 return;\n             }\n+\n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : type_alias.get_generic_params()) \n+                param->accept_vis(*this);\n+\n+            if (type_alias.has_where_clause())\n+                expand_where_clause(type_alias.get_where_clause());\n+            \n+            auto& type = type_alias.get_type_aliased();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n         }\n         void visit(AST::StructStruct& struct_item) override {\n             // initial test based on outer attrs\n@@ -1520,6 +1872,13 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : struct_item.get_generic_params()) \n+                param->accept_vis(*this);\n+            \n+            if (struct_item.has_where_clause())\n+                expand_where_clause(struct_item.get_where_clause());\n+\n             /* strip struct fields if required - this is presumably\n              * allowed by spec */\n             expand_struct_fields(struct_item.get_fields());\n@@ -1532,9 +1891,16 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : tuple_struct.get_generic_params()) \n+                param->accept_vis(*this);\n+\n             /* strip struct fields if required - this is presumably\n              * allowed by spec */\n             expand_tuple_fields(tuple_struct.get_fields());\n+\n+            if (tuple_struct.has_where_clause())\n+                expand_where_clause(tuple_struct.get_where_clause());\n         }\n         void visit(AST::EnumItem& item) override {\n             // initial test based on outer attrs\n@@ -1593,6 +1959,13 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : enum_item.get_generic_params()) \n+                param->accept_vis(*this);\n+            \n+            if (enum_item.has_where_clause())\n+                expand_where_clause(enum_item.get_where_clause());\n+\n             /* strip enum fields if required - this is presumably\n              * allowed by spec */\n             auto& variants = enum_item.get_variants();\n@@ -1616,6 +1989,13 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : union_item.get_generic_params()) \n+                param->accept_vis(*this);\n+            \n+            if (union_item.has_where_clause())\n+                expand_where_clause(union_item.get_where_clause());\n+\n             /* strip union fields if required - this is presumably\n              * allowed by spec */\n             expand_struct_fields(union_item.get_variants());\n@@ -1628,6 +2008,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // strip any sub-types\n+            auto& type = const_item.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n@@ -1645,6 +2031,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // strip any sub-types\n+            auto& type = static_item.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n@@ -1662,9 +2054,7 @@ namespace Rust {\n                 return;\n             }\n \n-            /* strip function parameters if required - this is specifically\n-             * allowed by spec */\n-            expand_function_params(item.get_function_params());\n+            expand_trait_function_decl(item.get_trait_function_decl());\n \n             if (item.has_definition()) {\n                 /* strip any internal sub-expressions - expression itself isn't\n@@ -1685,13 +2075,7 @@ namespace Rust {\n                 return;\n             }\n \n-            /* assuming you can't strip self param - wouldn't be a method\n-             * anymore. spec allows outer attrs on self param, but doesn't\n-             * specify whether cfg is used. */\n-\n-            /* strip function parameters if required - this is specifically\n-             * allowed by spec */\n-            expand_function_params(item.get_function_params());\n+            expand_trait_method_decl(item.get_trait_method_decl());\n \n             if (item.has_definition()) {\n                 /* strip any internal sub-expressions - expression itself isn't\n@@ -1712,6 +2096,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // strip any sub-types\n+            auto& type = item.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped */\n@@ -1730,6 +2120,12 @@ namespace Rust {\n                 item.mark_for_strip();\n                 return;\n             }\n+\n+            if (item.has_type_param_bounds()) {\n+                // don't strip directly, only components of bounds\n+                for (auto& bound : item.get_type_param_bounds()) \n+                    bound->accept_vis(*this);\n+            }\n         }\n         void visit(AST::Trait& trait) override {\n             // initial strip test based on outer attrs\n@@ -1746,6 +2142,19 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : trait.get_generic_params()) \n+                param->accept_vis(*this);\n+            \n+            if (trait.has_type_param_bounds()) {\n+                // don't strip directly, only components of bounds\n+                for (auto& bound : trait.get_type_param_bounds()) \n+                    bound->accept_vis(*this);\n+            }\n+            \n+            if (trait.has_where_clause())\n+                expand_where_clause(trait.get_where_clause());\n+\n             // strip trait items if required\n             auto& trait_items = trait.get_trait_items();\n             for (int i = 0; i < trait_items.size();) {\n@@ -1775,6 +2184,18 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : impl.get_generic_params()) \n+                param->accept_vis(*this);\n+\n+            auto& type = impl.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+\n+            if (impl.has_where_clause())\n+                expand_where_clause(impl.get_where_clause());\n+\n             // strip inherent impl items if required\n             auto& impl_items = impl.get_impl_items();\n             for (int i = 0; i < impl_items.size();) {\n@@ -1804,6 +2225,23 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : impl.get_generic_params()) \n+                param->accept_vis(*this);\n+\n+            auto& type = impl.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            \n+            auto& trait_path = impl.get_trait_path();\n+            visit(trait_path);\n+            if (trait_path.is_marked_for_strip())\n+                rust_error_at(trait_path.get_locus(), \"cannot strip typepath in this position\");\n+\n+            if (impl.has_where_clause())\n+                expand_where_clause(impl.get_where_clause());\n+\n             // strip trait impl items if required\n             auto& impl_items = impl.get_impl_items();\n             for (int i = 0; i < impl_items.size();) {\n@@ -1825,6 +2263,11 @@ namespace Rust {\n                 item.mark_for_strip();\n                 return;\n             }\n+\n+            auto& type = item.get_type();\n+            type->accept_vis(*this);\n+            if (type->is_marked_for_strip())\n+                rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n         }\n         void visit(AST::ExternalFunctionItem& item) override {\n             // strip test based on outer attrs\n@@ -1834,23 +2277,47 @@ namespace Rust {\n                 return;\n             }\n \n+            // just expand sub-stuff - can't actually strip generic params themselves\n+            for (auto& param : item.get_generic_params()) \n+                param->accept_vis(*this);\n+\n             /* strip function parameters if required - this is specifically\n              * allowed by spec */\n             auto& params = item.get_function_params();\n             for (int i = 0; i < params.size();) {\n-                auto& param_attrs = params[i].get_outer_attrs();\n+                auto& param = params[i];\n+\n+                auto& param_attrs = param.get_outer_attrs();\n                 expander.expand_cfg_attrs(param_attrs);\n-                if (expander.fails_cfg(param_attrs))\n+                if (expander.fails_cfg(param_attrs)) {\n                     params.erase(params.begin() + i);\n-                else\n-                    i++;\n+                    continue;\n+                }\n+\n+                auto& type = param.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+                \n+                // increment if nothing else happens\n+                i++;\n             }\n             /* NOTE: these are extern function params, which may have different\n              * rules and restrictions to \"normal\" function params. So expansion\n              * handled separately. */\n \n             /* TODO: assuming that variadic nature cannot be stripped. If this\n              * is not true, then have code here to do so. */\n+            \n+            if (item.has_return_type()) {\n+                auto& return_type = item.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+            \n+            if (item.has_where_clause())\n+                expand_where_clause(item.get_where_clause());\n         }\n         void visit(AST::ExternBlock& block) override {\n             // initial strip test based on outer attrs\n@@ -1904,6 +2371,8 @@ namespace Rust {\n             }\n \n             // I don't think any macro token trees can be stripped in any way\n+\n+            // TODO: maybe have stripping behaviour for the cfg! macro here?\n         }\n         void visit(AST::MetaItemPath& meta_item) override {}\n         void visit(AST::MetaItemSeq& meta_item) override {}\n@@ -1912,29 +2381,186 @@ namespace Rust {\n         void visit(AST::MetaListPaths& meta_item) override {}\n         void visit(AST::MetaListNameValueStr& meta_item) override {}\n \n-        // stripping shouldn't be required or possible for patterns\n-        void visit(AST::LiteralPattern& pattern) override {}\n-        void visit(AST::IdentifierPattern& pattern) override {}\n-        void visit(AST::WildcardPattern& pattern) override {}\n-        void visit(AST::RangePatternBoundLiteral& bound) override {}\n-        void visit(AST::RangePatternBoundPath& bound) override {}\n-        void visit(AST::RangePatternBoundQualPath& bound) override {}\n-        void visit(AST::RangePattern& pattern) override {}\n-        void visit(AST::ReferencePattern& pattern) override {}\n-        void visit(AST::StructPatternFieldTuplePat& field) override {}\n-        void visit(AST::StructPatternFieldIdentPat& field) override {}\n-        void visit(AST::StructPatternFieldIdent& field) override {}\n+        void visit(AST::LiteralPattern& pattern) override {\n+            // not possible\n+        }\n+        void visit(AST::IdentifierPattern& pattern) override {\n+            // can only strip sub-patterns of the inner pattern to bind\n+            if (!pattern.has_pattern_to_bind())\n+                return;\n+        \n+            auto& sub_pattern = pattern.get_pattern_to_bind();\n+            sub_pattern->accept_vis(*this);\n+            if (sub_pattern->is_marked_for_strip())\n+                rust_error_at(sub_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+        }\n+        void visit(AST::WildcardPattern& pattern) override {\n+            // not possible\n+        }\n+        void visit(AST::RangePatternBoundLiteral& bound) override {\n+            // not possible\n+        }\n+        void visit(AST::RangePatternBoundPath& bound) override {\n+            // TODO: maybe possible if path is possible\n+        }\n+        void visit(AST::RangePatternBoundQualPath& bound) override {\n+            // TODO: maybe possible if path is possible\n+        }\n+        void visit(AST::RangePattern& pattern) override {\n+            // TODO: possible if any bounds are possible\n+        }\n+        void visit(AST::ReferencePattern& pattern) override {\n+            auto& sub_pattern = pattern.get_referenced_pattern();\n+            sub_pattern->accept_vis(*this);\n+            if (sub_pattern->is_marked_for_strip())\n+                rust_error_at(sub_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+        }\n+        void visit(AST::StructPatternFieldTuplePat& field) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(field.get_outer_attrs());\n+            if (expander.fails_cfg(field.get_outer_attrs())) {\n+                field.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip sub-patterns (can't strip top-level pattern)\n+            auto& sub_pattern = field.get_index_pattern();\n+            sub_pattern->accept_vis(*this);\n+            if (sub_pattern->is_marked_for_strip())\n+                rust_error_at(sub_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+        }\n+        void visit(AST::StructPatternFieldIdentPat& field) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(field.get_outer_attrs());\n+            if (expander.fails_cfg(field.get_outer_attrs())) {\n+                field.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip sub-patterns (can't strip top-level pattern)\n+            auto& sub_pattern = field.get_ident_pattern();\n+            sub_pattern->accept_vis(*this);\n+            if (sub_pattern->is_marked_for_strip())\n+                rust_error_at(sub_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+        }\n+        void visit(AST::StructPatternFieldIdent& field) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(field.get_outer_attrs());\n+            if (expander.fails_cfg(field.get_outer_attrs())) {\n+                field.mark_for_strip();\n+                return;\n+            }\n+        }\n         void visit(AST::StructPattern& pattern) override {\n             // TODO: apparently struct pattern fields can have outer attrs. so can they be stripped?\n+            if (!pattern.has_struct_pattern_elems())\n+                return;\n+\n+            auto& elems = pattern.get_struct_pattern_elems();\n+\n+            // assuming you can strip struct pattern fields\n+            auto& fields = elems.get_struct_pattern_fields();\n+            for (int i = 0; i < fields.size();) {\n+                auto& field = fields[i];\n+\n+                field->accept_vis(*this);\n+\n+                if (field->is_marked_for_strip())\n+                    fields.erase(fields.begin() + i);\n+                else\n+                    i++;\n+            }\n+\n+            // assuming you can strip the \"..\" part\n+            if (elems.has_etc()) {\n+                expander.expand_cfg_attrs(elems.get_etc_outer_attrs());\n+                if (expander.fails_cfg(elems.get_etc_outer_attrs())) \n+                    elems.strip_etc();\n+            }   \n+        }\n+        void visit(AST::TupleStructItemsNoRange& tuple_items) override {\n+            // can't strip individual patterns, only sub-patterns\n+            for (auto& pattern : tuple_items.get_patterns()) {\n+                pattern->accept_vis(*this);\n+\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+        }\n+        void visit(AST::TupleStructItemsRange& tuple_items) override {\n+            // can't strip individual patterns, only sub-patterns\n+            for (auto& lower_pattern : tuple_items.get_lower_patterns()) {\n+                lower_pattern->accept_vis(*this);\n+\n+                if (lower_pattern->is_marked_for_strip())\n+                    rust_error_at(lower_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+            for (auto& upper_pattern : tuple_items.get_upper_patterns()) {\n+                upper_pattern->accept_vis(*this);\n+\n+                if (upper_pattern->is_marked_for_strip())\n+                    rust_error_at(upper_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+        }\n+        void visit(AST::TupleStructPattern& pattern) override {\n+            // TODO: stripping of path?\n+\n+            if (pattern.has_items()) \n+                pattern.get_items()->accept_vis(*this);\n+        }\n+        void visit(AST::TuplePatternItemsMultiple& tuple_items) override {\n+            // can't strip individual patterns, only sub-patterns\n+            for (auto& pattern : tuple_items.get_patterns()) {\n+                pattern->accept_vis(*this);\n+\n+                if (pattern->is_marked_for_strip())\n+                    rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+        }\n+        void visit(AST::TuplePatternItemsRanged& tuple_items) override {\n+            // can't strip individual patterns, only sub-patterns\n+            for (auto& lower_pattern : tuple_items.get_lower_patterns()) {\n+                lower_pattern->accept_vis(*this);\n+\n+                if (lower_pattern->is_marked_for_strip())\n+                    rust_error_at(lower_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+            for (auto& upper_pattern : tuple_items.get_upper_patterns()) {\n+                upper_pattern->accept_vis(*this);\n+\n+                if (upper_pattern->is_marked_for_strip())\n+                    rust_error_at(upper_pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n+        }\n+        void visit(AST::TuplePattern& pattern) override {\n+            if (pattern.has_tuple_pattern_items()) \n+                pattern.get_items()->accept_vis(*this);\n+        }\n+        void visit(AST::GroupedPattern& pattern) override {\n+            // can't strip inner pattern, only sub-patterns\n+            auto& pattern_in_parens = pattern.get_pattern_in_parens();\n+\n+            pattern_in_parens->accept_vis(*this);\n+\n+            if (pattern_in_parens->is_marked_for_strip())\n+                rust_error_at(pattern_in_parens->get_locus_slow(), \"cannot strip pattern in this position\");\n+        }\n+        void visit(AST::SlicePattern& pattern) override {\n+            // can't strip individual patterns, only sub-patterns\n+            for (auto& item : pattern.get_items()) {\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip())\n+                    rust_error_at(item->get_locus_slow(), \"cannot strip pattern in this position\");\n+                // TODO: quit stripping now? or keep going?\n+            }\n         }\n-        void visit(AST::TupleStructItemsNoRange& tuple_items) override {}\n-        void visit(AST::TupleStructItemsRange& tuple_items) override {}\n-        void visit(AST::TupleStructPattern& pattern) override {}\n-        void visit(AST::TuplePatternItemsMultiple& tuple_items) override {}\n-        void visit(AST::TuplePatternItemsRanged& tuple_items) override {}\n-        void visit(AST::TuplePattern& pattern) override {}\n-        void visit(AST::GroupedPattern& pattern) override {}\n-        void visit(AST::SlicePattern& pattern) override {}\n \n         void visit(AST::EmptyStmt& stmt) override {\n             // assuming no outer attributes, so nothing can happen\n@@ -1947,6 +2573,12 @@ namespace Rust {\n                 return;\n             }\n \n+            // can't strip pattern, but call for sub-patterns\n+            auto& pattern = stmt.get_pattern();\n+            pattern->accept_vis(*this);\n+            if (pattern->is_marked_for_strip())\n+                rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped */"}, {"sha": "88252ac35d73a1d5cceb3e95b349dd3ce6f2d2d9", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -10150,6 +10150,14 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t      // tuple struct\n \t      lexer.skip_token ();\n \n+        // check if empty tuple\n+        if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+          {\n+            lexer.skip_token ();\n+            return std::unique_ptr<AST::TupleStructPattern> (\n+\t        new AST::TupleStructPattern (std::move (path), nullptr));\n+          }\n+\n \t      // parse items\n \t      std::unique_ptr<AST::TupleStructItems> items\n \t\t= parse_tuple_struct_items ();\n@@ -10574,6 +10582,14 @@ Parser<ManagedTokenSource>::parse_ident_leading_pattern ()\n \t// DEBUG\n \tfprintf (stderr, \"parsing tuple struct pattern\\n\");\n \n+  // check if empty tuple\n+  if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+    {\n+      lexer.skip_token ();\n+      return std::unique_ptr<AST::TupleStructPattern> (\n+\t  new AST::TupleStructPattern (std::move (path), nullptr));\n+    }\n+\n \t// parse items\n \tstd::unique_ptr<AST::TupleStructItems> items\n \t  = parse_tuple_struct_items ();\n@@ -10816,53 +10832,46 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n {\n   std::vector<std::unique_ptr<AST::StructPatternField> > fields;\n \n+  std::vector<AST::Attribute> etc_attrs;\n+  bool has_etc = false;\n+\n   // try parsing struct pattern fields\n   const_TokenPtr t = lexer.peek_token ();\n-  while (t->get_id () != RIGHT_CURLY && t->get_id () != DOT_DOT)\n+  while (t->get_id () != RIGHT_CURLY)\n     {\n+      std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+\n+      // parse etc (must be last in struct pattern, so breaks)\n+      if (lexer.peek_token ()->get_id () == DOT_DOT) \n+      {\n+        lexer.skip_token ();\n+        etc_attrs = std::move (outer_attrs);\n+        has_etc = true;\n+        break;\n+      }\n+\n       std::unique_ptr<AST::StructPatternField> field\n-\t= parse_struct_pattern_field ();\n+\t= parse_struct_pattern_field_partial (std::move (outer_attrs));\n       if (field == nullptr)\n \t{\n-\t  // TODO: should this be an error?\n-\t  // assuming that this means that it is a struct pattern etc instead\n-\n-\t  // DEBUG\n-\t  fprintf (\n-\t    stderr,\n-\t    \"failed to parse struct pattern field - breaking from loop\\n\");\n-\n-\t  break;\n+    rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse struct pattern field\");\n+    // skip after somewhere?\n+    return AST::StructPatternElements::create_empty ();\n \t}\n-\n       fields.push_back (std::move (field));\n \n-      // DEBUG\n-      fprintf (stderr, \"successfully pushed back a struct pattern field\\n\");\n-\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n-\t}\n-      lexer.skip_token ();\n-\n-      t = lexer.peek_token ();\n-    }\n \n-  /* FIXME: this method of parsing prevents parsing any outer attributes on the\n-   * .. - also there seems to be no distinction between having etc and not\n-   * having etc. */\n-  if (lexer.peek_token ()->get_id () == DOT_DOT)\n-    {\n+      // skip comma\n       lexer.skip_token ();\n-\n-      // as no outer attributes\n-      AST::StructPatternEtc etc = AST::StructPatternEtc::create_empty ();\n-\n-      return AST::StructPatternElements (std::move (fields), std::move (etc));\n+      t = lexer.peek_token ();\n     }\n \n-  return AST::StructPatternElements (std::move (fields));\n+  if (has_etc)\n+    return AST::StructPatternElements (std::move (fields), std::move (etc_attrs));\n+  else\n+    return AST::StructPatternElements (std::move (fields));\n }\n \n /* Parses a struct pattern field (tuple index/pattern, identifier/pattern, or\n@@ -10874,6 +10883,15 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n   // parse outer attributes (if they exist)\n   std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n \n+  return parse_struct_pattern_field_partial (std::move (outer_attrs));\n+}\n+\n+/* Parses a struct pattern field (tuple index/pattern, identifier/pattern, or\n+ * identifier), with outer attributes passed in. */\n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::StructPatternField>\n+Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs)\n+{\n   // branch based on next token\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())"}, {"sha": "a6de87b568dcf5b00645406836bcdc98f89a6e30", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db39766514144dbbad34d9db3977c3a72d1216c3/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=db39766514144dbbad34d9db3977c3a72d1216c3", "patch": "@@ -575,6 +575,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n   std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n+  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n \n   int left_binding_power (const_TokenPtr token);\n "}]}