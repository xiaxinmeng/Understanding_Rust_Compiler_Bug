{"sha": "46c3001944a778ddd079de47697c092bfd82419a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjMzAwMTk0NGE3NzhkZGQwNzlkZTQ3Njk3YzA5MmJmZDgyNDE5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-15T09:46:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-15T09:46:55Z"}, "message": "tree.h (memory_identifier_string): Remove.\n\n\n\t* tree.h (memory_identifier_string): Remove.\n\t* ipa-reference.c: Update comment; do not include gt-ipa-reference.h\n\t(ipa_reference_global_vars_info_d): Remove statics_not_read and\n\tstatics_not_written.\n\t(ipa_reference_optimization_summary_d): New structure.\n\t(ipa_reference_optimization_summary_t): New type and vector.\n\t(ipa_reference_vars_info_d): Embedd structures instead of using\n\tpointers.\n\t(reference_vars_to_consider): Remove out of GGC space.\n\t(module_statics_escape): Remove.\n\t(global_info_obstack): Rename to ...\n\t(optimization_summary_obstack): ... this one.\n\t(initialization_status_t): Remove.\n\t(memory_identifier_string): Remove.\n\t(get_reference_vars_info): Fix indenting.\n\t(set_reference_vars_info): Likewise.\n\t(get_reference_optimization_summary): New.\n\t(set_reference_optimization_summary): New.\n\t(get_global_reference_vars_info): Remove.\n\t(ipa_reference_get_read_global): Remove.\n\t(ipa_reference_get_written_global): Remove.\n\t(ipa_reference_get_not_read_global): Update.\n\t(ipa_reference_get_not_written_global): Update.\n\t(is_proper_for_analysis): Outlaw addressable.\n\t(propagate_bits): Update for new datastructures.\n\t(analyze_variable): Remove.\n\t(init_function_info): Update for new datastructures.\n\t(clean_function_local_data): Remove.\n\t(clean_function): Remove.\n\t(copy_global_bitmap): Use optimizations_summary_obstack.\n\t(duplicate_node_data): Duplicate optimization summary only.\n\t(remove_node_data): Remove optimization summary only.\n\t(generate_summary): Do not analyze variables; do not compute\n\tmodule_statics_escape; do not prune solutions by it.\n\t(read_write_all_from_decl): Fix typos in comments.\n\t(propagate): Doscover readonly and nonaddressable first;\n\tupdate for new datastructures; share global bitmaps.\n\t* ipa-reference.h (ipa_reference_get_read_global,\n\tipa_reference_get_written_global): Remove.\n\t* ipa-pure-const.c (check_stmt): Do not use memory_identifier_string.\n\t* Makefile.in: Remove ipa-refereference from GT files.\n\nFrom-SVN: r159430", "tree": {"sha": "44de42807a02b7f8a43a5d1b22665c200b03e1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44de42807a02b7f8a43a5d1b22665c200b03e1d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c3001944a778ddd079de47697c092bfd82419a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c3001944a778ddd079de47697c092bfd82419a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c3001944a778ddd079de47697c092bfd82419a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c3001944a778ddd079de47697c092bfd82419a/comments", "author": null, "committer": null, "parents": [{"sha": "22bf7d174a7667f07a4e467d86ad7facd331e77a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bf7d174a7667f07a4e467d86ad7facd331e77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bf7d174a7667f07a4e467d86ad7facd331e77a"}], "stats": {"total": 501, "additions": 196, "deletions": 305}, "files": [{"sha": "222101556358d03a6edaa33da2fbc36343fdd618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -1,3 +1,47 @@\n+2010-05-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.h (memory_identifier_string): Remove.\n+\t* ipa-reference.c: Update comment; do not include gt-ipa-reference.h\n+\t(ipa_reference_global_vars_info_d): Remove statics_not_read and\n+\tstatics_not_written.\n+\t(ipa_reference_optimization_summary_d): New structure.\n+\t(ipa_reference_optimization_summary_t): New type and vector.\n+\t(ipa_reference_vars_info_d): Embedd structures instead of using\n+\tpointers.\n+\t(reference_vars_to_consider): Remove out of GGC space.\n+\t(module_statics_escape): Remove.\n+\t(global_info_obstack): Rename to ...\n+\t(optimization_summary_obstack): ... this one.\n+\t(initialization_status_t): Remove.\n+\t(memory_identifier_string): Remove.\n+\t(get_reference_vars_info): Fix indenting.\n+\t(set_reference_vars_info): Likewise.\n+\t(get_reference_optimization_summary): New.\n+\t(set_reference_optimization_summary): New.\n+\t(get_global_reference_vars_info): Remove.\n+\t(ipa_reference_get_read_global): Remove.\n+\t(ipa_reference_get_written_global): Remove.\n+\t(ipa_reference_get_not_read_global): Update.\n+\t(ipa_reference_get_not_written_global): Update.\n+\t(is_proper_for_analysis): Outlaw addressable.\n+\t(propagate_bits): Update for new datastructures.\n+\t(analyze_variable): Remove.\n+\t(init_function_info): Update for new datastructures.\n+\t(clean_function_local_data): Remove.\n+\t(clean_function): Remove.\n+\t(copy_global_bitmap): Use optimizations_summary_obstack.\n+\t(duplicate_node_data): Duplicate optimization summary only.\n+\t(remove_node_data): Remove optimization summary only.\n+\t(generate_summary): Do not analyze variables; do not compute\n+\tmodule_statics_escape; do not prune solutions by it.\n+\t(read_write_all_from_decl): Fix typos in comments.\n+\t(propagate): Doscover readonly and nonaddressable first;\n+\tupdate for new datastructures; share global bitmaps.\n+\t* ipa-reference.h (ipa_reference_get_read_global,\n+\tipa_reference_get_written_global): Remove.\n+\t* ipa-pure-const.c (check_stmt): Do not use memory_identifier_string.\n+\t* Makefile.in: Remove ipa-refereference from GT files.\n+\n 2010-05-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/44112"}, {"sha": "db0537f30b75b1269f98b5106ea4c598085be54f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -2929,8 +2929,7 @@ ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \\\n-   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) gt-ipa-reference.h \\\n-   $(LTO_STREAMER_H)\n+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(LTO_STREAMER_H)\n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\\n@@ -3593,7 +3592,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n-  $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n+  $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n@@ -3625,7 +3624,6 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n   $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-phinodes.c \\\n-  $(srcdir)/ipa-reference.c \\\n   $(srcdir)/tree-ssa-structalias.c \\\n   $(srcdir)/lto-symtab.c \\\n   $(srcdir)/tree-ssa-alias.h \\"}, {"sha": "d1fe0595b6c05b0e1e2748863c80af0d9779f3ae", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -533,7 +533,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n       for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n \t{\n \t  tree op = gimple_asm_clobber_op (stmt, i);\n-\t  if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1)\n+\t  if (strcmp (TREE_STRING_POINTER (TREE_VALUE (op)), \"memory\") == 0)\n \t    {\n               if (dump_file)\n                 fprintf (dump_file, \"    memory asm clobber is not const/pure\");"}, {"sha": "6d4af1c17960e20e742afe188d2e058033b8a823", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 149, "deletions": 295, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -86,44 +86,37 @@ struct ipa_reference_local_vars_info_d\n /* Statics that are read and written by some set of functions. The\n    local ones are based on the loads and stores local to the function.\n    The global ones are based on the local info as well as the\n-   transitive closure of the functions that are called.  The\n-   structures are separated to allow the global structures to be\n-   shared between several functions since every function within a\n-   strongly connected component will have the same information.  This\n-   sharing saves both time and space in the computation of the vectors\n-   as well as their translation from decl_uid form to ann_uid\n-   form.  */\n+   transitive closure of the functions that are called. */\n \n struct ipa_reference_global_vars_info_d\n {\n   bitmap statics_read;\n   bitmap statics_written;\n+};\n+\n+/* Information we save about every function after ipa-reference is completted.  */\n+\n+struct ipa_reference_optimization_summary_d\n+{\n   bitmap statics_not_read;\n   bitmap statics_not_written;\n };\n \n typedef struct ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n typedef struct ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n+typedef struct ipa_reference_optimization_summary_d *ipa_reference_optimization_summary_t;\n+\n struct ipa_reference_vars_info_d\n {\n-  ipa_reference_local_vars_info_t local;\n-  ipa_reference_global_vars_info_t global;\n+  struct ipa_reference_local_vars_info_d local;\n+  struct ipa_reference_global_vars_info_d global;\n };\n \n typedef struct ipa_reference_vars_info_d *ipa_reference_vars_info_t;\n \n /* This splay tree contains all of the static variables that are\n-   being considered by the compilation level alias analysis.  For\n-   module_at_a_time compilation, this is the set of static but not\n-   public variables.  Any variables that either have their address\n-   taken or participate in otherwise unsavory operations are deleted\n-   from this list.  */\n-static GTY((param1_is(int), param2_is(tree)))\n-     splay_tree reference_vars_to_consider;\n-\n-/* This bitmap is used to knock out the module static variables whose\n-   addresses have been taken and passed around.  */\n-static bitmap module_statics_escape;\n+   being considered by the compilation level alias analysis.  */\n+static splay_tree reference_vars_to_consider;\n \n /* A bit is set for every module static we are considering.  This is\n    ored into the local info when asm code is found that clobbers all\n@@ -134,88 +127,72 @@ static bitmap all_module_statics;\n    propagation)  */\n static bitmap_obstack local_info_obstack;\n /* Obstack holding global analysis live forever.  */\n-static bitmap_obstack global_info_obstack;\n+static bitmap_obstack optimization_summary_obstack;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n-enum initialization_status_t\n-{\n-  UNINITIALIZED,\n-  RUNNING,\n-  FINISHED\n-};\n-\n-tree memory_identifier_string;\n-\n /* Vector where the reference var infos are actually stored. */\n DEF_VEC_P (ipa_reference_vars_info_t);\n DEF_VEC_ALLOC_P (ipa_reference_vars_info_t, heap);\n static VEC (ipa_reference_vars_info_t, heap) *ipa_reference_vars_vector;\n+DEF_VEC_P (ipa_reference_optimization_summary_t);\n+DEF_VEC_ALLOC_P (ipa_reference_optimization_summary_t, heap);\n+static VEC (ipa_reference_optimization_summary_t, heap) *ipa_reference_opt_sum_vector;\n \n /* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n static inline ipa_reference_vars_info_t\n get_reference_vars_info (struct cgraph_node *node)\n {\n   if (!ipa_reference_vars_vector\n-      || VEC_length (ipa_reference_vars_info_t, ipa_reference_vars_vector) <= (unsigned int)node->uid)\n+      || VEC_length (ipa_reference_vars_info_t,\n+\t\t     ipa_reference_vars_vector) <= (unsigned int) node->uid)\n     return NULL;\n-  return VEC_index (ipa_reference_vars_info_t, ipa_reference_vars_vector, node->uid);\n+  return VEC_index (ipa_reference_vars_info_t, ipa_reference_vars_vector,\n+\t\t    node->uid);\n }\n \n /* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n-static inline void\n-set_reference_vars_info (struct cgraph_node *node, ipa_reference_vars_info_t info)\n-{\n-  if (!ipa_reference_vars_vector\n-      || VEC_length (ipa_reference_vars_info_t, ipa_reference_vars_vector) <= (unsigned int)node->uid)\n-     VEC_safe_grow_cleared (ipa_reference_vars_info_t, heap, ipa_reference_vars_vector, node->uid + 1);\n-  VEC_replace (ipa_reference_vars_info_t, ipa_reference_vars_vector, node->uid, info);\n-}\n-\n-/* Get a bitmap that contains all of the globally referenced static\n-   variables for function FN.  */\n-\n-static ipa_reference_global_vars_info_t\n-get_global_reference_vars_info (struct cgraph_node *fn)\n+static inline ipa_reference_optimization_summary_t\n+get_reference_optimization_summary (struct cgraph_node *node)\n {\n-  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n-\n-  if (info)\n-    return info->global;\n-  else\n-    /* This phase was not run.  */\n+  if (!ipa_reference_opt_sum_vector\n+      || (VEC_length (ipa_reference_optimization_summary_t,\n+\t\t     ipa_reference_opt_sum_vector)\n+\t  <= (unsigned int) node->uid))\n     return NULL;\n+  return VEC_index (ipa_reference_optimization_summary_t, ipa_reference_opt_sum_vector,\n+\t\t    node->uid);\n }\n \n-/* Return a bitmap indexed by VAR_DECL uid for the static variables\n-   that are read during the execution of the function FN.  Returns\n-   NULL if no data is available.  */\n-\n-bitmap\n-ipa_reference_get_read_global (struct cgraph_node *fn)\n+/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n+static inline void\n+set_reference_vars_info (struct cgraph_node *node,\n+\t\t\t ipa_reference_vars_info_t info)\n {\n-  ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g)\n-    return g->statics_read;\n-  else\n-    return NULL;\n+  if (!ipa_reference_vars_vector\n+      || VEC_length (ipa_reference_vars_info_t,\n+\t\t     ipa_reference_vars_vector) <= (unsigned int) node->uid)\n+    VEC_safe_grow_cleared (ipa_reference_vars_info_t, heap,\n+\t\t\t   ipa_reference_vars_vector, node->uid + 1);\n+  VEC_replace (ipa_reference_vars_info_t, ipa_reference_vars_vector,\n+\t       node->uid, info);\n }\n \n-/* Return a bitmap indexed by VAR_DECL uid for the static variables\n-   that are written during the execution of the function FN.  Note\n-   that variables written may or may not be read during the function\n-   call.  Returns NULL if no data is available.  */\n-\n-bitmap\n-ipa_reference_get_written_global (struct cgraph_node *fn)\n+/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */\n+static inline void\n+set_reference_optimization_summary (struct cgraph_node *node,\n+\t\t\t\t    ipa_reference_optimization_summary_t info)\n {\n-  ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g)\n-    return g->statics_written;\n-  else\n-    return NULL;\n+  if (!ipa_reference_opt_sum_vector\n+      || (VEC_length (ipa_reference_optimization_summary_t,\n+\t\t      ipa_reference_opt_sum_vector)\n+\t  <= (unsigned int) node->uid))\n+    VEC_safe_grow_cleared (ipa_reference_optimization_summary_t,\n+\t\t\t   heap, ipa_reference_opt_sum_vector, node->uid + 1);\n+  VEC_replace (ipa_reference_optimization_summary_t,\n+\t       ipa_reference_opt_sum_vector, node->uid, info);\n }\n \n /* Return a bitmap indexed by_DECL_UID uid for the static variables\n@@ -225,9 +202,11 @@ ipa_reference_get_written_global (struct cgraph_node *fn)\n bitmap\n ipa_reference_get_not_read_global (struct cgraph_node *fn)\n {\n-  ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g)\n-    return g->statics_not_read;\n+  ipa_reference_optimization_summary_t info;\n+\n+  info = get_reference_optimization_summary (fn);\n+  if (info)\n+    return info->statics_not_read;\n   else\n     return NULL;\n }\n@@ -240,9 +219,11 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n bitmap\n ipa_reference_get_not_written_global (struct cgraph_node *fn)\n {\n-  ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g)\n-    return g->statics_not_written;\n+  ipa_reference_optimization_summary_t info;\n+\n+  info = get_reference_optimization_summary (fn);\n+  if (info)\n+    return info->statics_not_written;\n   else\n     return NULL;\n }\n@@ -259,8 +240,9 @@ add_static_var (tree var)\n   gcc_assert (TREE_CODE (var) == VAR_DECL);\n   if (!bitmap_bit_p (all_module_statics, uid))\n     {\n-      splay_tree_insert (reference_vars_to_consider,\n-\t\t\t uid, (splay_tree_value)var);\n+      if (dump_file)\n+\tsplay_tree_insert (reference_vars_to_consider,\n+\t\t\t   uid, (splay_tree_value)var);\n       bitmap_set_bit (all_module_statics, uid);\n     }\n }\n@@ -271,6 +253,9 @@ add_static_var (tree var)\n static inline bool\n is_proper_for_analysis (tree t)\n {\n+  /* We handle only variables whose address is never taken.  */\n+  if (TREE_ADDRESSABLE (t))\n+    return false;\n   /* If the variable has the \"used\" attribute, treat it as if it had a\n      been touched by the devil.  */\n   if (DECL_PRESERVE_P (t))\n@@ -325,10 +310,10 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \t    {\n \t      ipa_reference_vars_info_t y_info\n \t\t= get_reference_vars_info (y);\n-\t      ipa_reference_global_vars_info_t y_global = y_info->global;\n+\t      ipa_reference_global_vars_info_t y_global = &y_info->global;\n \n \t      /* Calls in current cycle do not have global computed yet.  */\n-\t      if (!y_info->global)\n+\t      if (!y_global->statics_read)\n \t\tcontinue;\n \n \t      if (x_global->statics_read\n@@ -385,56 +370,19 @@ ipa_init (void)\n \n   init_p = true;\n \n-  memory_identifier_string = build_string(7, \"memory\");\n-\n-  reference_vars_to_consider =\n-    splay_tree_new_ggc (splay_tree_compare_ints);\n+  if (dump_file)\n+    reference_vars_to_consider = splay_tree_new (splay_tree_compare_ints, 0, 0);\n \n   bitmap_obstack_initialize (&local_info_obstack);\n-  bitmap_obstack_initialize (&global_info_obstack);\n-  module_statics_escape = BITMAP_ALLOC (&local_info_obstack);\n-  all_module_statics = BITMAP_ALLOC (&global_info_obstack);\n+  bitmap_obstack_initialize (&optimization_summary_obstack);\n+  all_module_statics = BITMAP_ALLOC (&local_info_obstack);\n \n   node_removal_hook_holder =\n       cgraph_add_node_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n       cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n }\n \n-/* Check out the rhs of a static or global initialization VNODE to see\n-   if any of them contain addressof operations.  Note that some of\n-   these variables may  not even be referenced in the code in this\n-   compilation unit but their right hand sides may contain references\n-   to variables defined within this unit.  */\n-\n-static void\n-analyze_variable (struct varpool_node *vnode)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref); i++)\n-    {\n-      tree var;\n-      if (ref->refered_type != IPA_REF_VARPOOL)\n-\tcontinue;\n-      var = ipa_ref_varpool_node (ref)->decl;\n-      if (ipa_ref_varpool_node (ref)->externally_visible\n-\t  || !ipa_ref_varpool_node (ref)->analyzed\n-\t  || !is_proper_for_analysis (var))\n-\tcontinue;\n-      switch (ref->use)\n-\t{\n-\tcase IPA_REF_LOAD:\n-\tcase IPA_REF_STORE:\n-\t  gcc_unreachable ();\n-\t  break;\n-\tcase IPA_REF_ADDR:\n-\t  bitmap_set_bit (module_statics_escape, DECL_UID (var));\n-\t  break;\n-\t}\n-    }\n-}\n-\n \n /* Set up the persistent info for FN.  */\n \n@@ -443,17 +391,14 @@ init_function_info (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info\n     = XCNEW (struct ipa_reference_vars_info_d);\n-  ipa_reference_local_vars_info_t l\n-    = XCNEW (struct ipa_reference_local_vars_info_d);\n \n   /* Add the info to the tree's annotation.  */\n   set_reference_vars_info (fn, info);\n \n-  info->local = l;\n-  l->statics_read = BITMAP_ALLOC (&local_info_obstack);\n-  l->statics_written = BITMAP_ALLOC (&local_info_obstack);\n+  info->local.statics_read = BITMAP_ALLOC (&local_info_obstack);\n+  info->local.statics_written = BITMAP_ALLOC (&local_info_obstack);\n \n-  return l;\n+  return &info->local;\n }\n \n \n@@ -499,7 +444,6 @@ analyze_function (struct cgraph_node *fn)\n           bitmap_set_bit (local->statics_written, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_ADDR:\n-\t  bitmap_set_bit (module_statics_escape, DECL_UID (var));\n \t  break;\n \t}\n     }\n@@ -518,68 +462,13 @@ analyze_function (struct cgraph_node *fn)\n     BITMAP_FREE (local->statics_read);\n }\n \n-/* Remove local data associated with function FN.  */\n-static void\n-clean_function_local_data (struct cgraph_node *fn)\n-{\n-  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n-  ipa_reference_local_vars_info_t l = info->local;\n-  if (l)\n-    {\n-      if (l->statics_read\n-\t  && l->statics_read != all_module_statics)\n-\tBITMAP_FREE (l->statics_read);\n-      if (l->statics_written\n-\t  &&l->statics_written != all_module_statics)\n-\tBITMAP_FREE (l->statics_written);\n-      free (l);\n-      info->local = NULL;\n-    }\n-}\n-\n-/* Remove all data associated with function FN.  */\n-\n-static void\n-clean_function (struct cgraph_node *fn)\n-{\n-  ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n-  ipa_reference_global_vars_info_t g = info->global;\n-\n-  clean_function_local_data (fn);\n-  if (g)\n-    {\n-      if (g->statics_read\n-\t  && g->statics_read != all_module_statics)\n-\tBITMAP_FREE (g->statics_read);\n-\n-      if (g->statics_written\n-\t  && g->statics_written != all_module_statics)\n-\tBITMAP_FREE (g->statics_written);\n-\n-      if (g->statics_not_read\n-\t  && g->statics_not_read != all_module_statics)\n-\tBITMAP_FREE (g->statics_not_read);\n-\n-      if (g->statics_not_written\n-\t  && g->statics_not_written != all_module_statics)\n-\tBITMAP_FREE (g->statics_not_written);\n-      free (g);\n-      info->global = NULL;\n-    }\n-\n-  free (get_reference_vars_info (fn));\n-  set_reference_vars_info (fn, NULL);\n-}\n-\n static bitmap\n copy_global_bitmap (bitmap src)\n {\n   bitmap dst;\n   if (!src)\n     return NULL;\n-  if (src == all_module_statics)\n-    return all_module_statics;\n-  dst = BITMAP_ALLOC (&global_info_obstack);\n+  dst = BITMAP_ALLOC (&optimization_summary_obstack);\n   bitmap_copy (dst, src);\n   return dst;\n }\n@@ -591,31 +480,37 @@ static void\n duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n \t \t     void *data ATTRIBUTE_UNUSED)\n {\n-  ipa_reference_global_vars_info_t ginfo;\n-  ipa_reference_global_vars_info_t dst_ginfo;\n+  ipa_reference_optimization_summary_t ginfo;\n+  ipa_reference_optimization_summary_t dst_ginfo;\n \n-  ginfo = get_global_reference_vars_info (src);\n+  ginfo = get_reference_optimization_summary (src);\n   if (!ginfo)\n     return;\n-  init_function_info (dst);\n-  if (ginfo)\n-    {\n-      get_reference_vars_info (dst)->global = XCNEW (struct ipa_reference_global_vars_info_d);\n-      dst_ginfo = get_global_reference_vars_info (dst);\n-      dst_ginfo->statics_read = copy_global_bitmap (ginfo->statics_read);\n-      dst_ginfo->statics_written = copy_global_bitmap (ginfo->statics_written);\n-      dst_ginfo->statics_not_read = copy_global_bitmap (ginfo->statics_not_read);\n-      dst_ginfo->statics_not_written = copy_global_bitmap (ginfo->statics_not_written);\n-    }\n+  dst_ginfo = XCNEW (struct ipa_reference_optimization_summary_d);\n+  set_reference_optimization_summary (dst, dst_ginfo);\n+  dst_ginfo->statics_not_read = copy_global_bitmap (ginfo->statics_not_read);\n+  dst_ginfo->statics_not_written = copy_global_bitmap (ginfo->statics_not_written);\n }\n \n /* Called when node is removed.  */\n \n static void\n remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  if (get_reference_vars_info (node))\n-    clean_function (node);\n+  ipa_reference_optimization_summary_t ginfo;\n+  ginfo = get_reference_optimization_summary (node);\n+  if (ginfo)\n+    {\n+      if (ginfo->statics_not_read\n+\t  && ginfo->statics_not_read != all_module_statics)\n+\tBITMAP_FREE (ginfo->statics_not_read);\n+\n+      if (ginfo->statics_not_written\n+\t  && ginfo->statics_not_written != all_module_statics)\n+\tBITMAP_FREE (ginfo->statics_not_written);\n+      free (ginfo);\n+      set_reference_optimization_summary (node, NULL);\n+    }\n }\n \n /* Analyze each function in the cgraph to see which global or statics\n@@ -625,61 +520,25 @@ static void\n generate_summary (void)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n   unsigned int index;\n   bitmap_iterator bi;\n   bitmap bm_temp;\n \n   ipa_init ();\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n \n-  /* Process all of the variables first.  */\n-  FOR_EACH_STATIC_INITIALIZER (vnode)\n-    analyze_variable (vnode);\n-\n   /* Process all of the functions next.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n       analyze_function (node);\n \n-  /* Prune out the variables that were found to behave badly\n-     (i.e. have their address taken).  */\n-  EXECUTE_IF_SET_IN_BITMAP (module_statics_escape, 0, index, bi)\n-    {\n-      splay_tree_remove (reference_vars_to_consider, index);\n-    }\n-\n-  bitmap_and_compl_into (all_module_statics,\n-\t\t\t module_statics_escape);\n-\n-  BITMAP_FREE(module_statics_escape);\n-  module_statics_escape = NULL;\n-\n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n       {\n \tfprintf (dump_file, \"\\nPromotable global:%s\",\n \t\t get_static_name (index));\n       }\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n-      {\n-\tipa_reference_local_vars_info_t l;\n-\tl = get_reference_vars_info (node)->local;\n-\n-\t/* Any variables that are not in all_module_statics are\n-\t   removed from the local maps.  This will include all of the\n-\t   variables that were found to escape in the function\n-\t   scanning.  */\n-\tif (l->statics_read)\n-\t  bitmap_and_into (l->statics_read,\n-\t\t\t   all_module_statics);\n-\tif (l->statics_written)\n-\t  bitmap_and_into (l->statics_written,\n-\t\t\t   all_module_statics);\n-      }\n-\n   BITMAP_FREE(bm_temp);\n \n   if (dump_file)\n@@ -690,7 +549,7 @@ generate_summary (void)\n \t  unsigned int index;\n \t  bitmap_iterator bi;\n \n-\t  l = get_reference_vars_info (node)->local;\n+\t  l = &get_reference_vars_info (node)->local;\n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n \t\t   cgraph_node_name (node), node->uid);\n@@ -718,6 +577,7 @@ generate_summary (void)\n }\n \f\n /* Set READ_ALL/WRITE_ALL based on DECL flags.  */\n+\n static void\n read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n {\n@@ -729,11 +589,9 @@ read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n   else\n     {\n        /* TODO: To be able to produce sane results, we should also handle\n-\t  common builtins, in particular throw.\n-\t  Indirect calls hsould be only counted and as inliner is replacing them\n-\t  by direct calls, we can conclude if any indirect calls are left in body */\n+\t  common builtins, in particular throw.  */\n       *read_all = true;\n-      /* When function does not reutrn, it is safe to ignore anythign it writes\n+      /* When function does not return, it is safe to ignore anythign it writes\n \t to, because the effect will never happen.  */\n       if ((flags & (ECF_NOTHROW | ECF_NORETURN))\n \t  != (ECF_NOTHROW | ECF_NORETURN))\n@@ -742,8 +600,7 @@ read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n }\n \n /* Produce the global information by preforming a transitive closure\n-   on the local information that was produced by ipa_analyze_function\n-   and ipa_analyze_variable.  */\n+   on the local information that was produced by ipa_analyze_function */\n \n static unsigned int\n propagate (void)\n@@ -758,6 +615,7 @@ propagate (void)\n   if (dump_file)\n     dump_cgraph (dump_file);\n \n+  ipa_discover_readonly_nonaddressable_vars ();\n   generate_summary ();\n \n   /* Propagate the local information thru the call graph to produce\n@@ -771,8 +629,7 @@ propagate (void)\n   for (i = 0; i < order_pos; i++ )\n     {\n       ipa_reference_vars_info_t node_info;\n-      ipa_reference_global_vars_info_t node_g =\n-\tXCNEW (struct ipa_reference_global_vars_info_d);\n+      ipa_reference_global_vars_info_t node_g;\n       ipa_reference_local_vars_info_t node_l;\n       struct cgraph_edge *e;\n \n@@ -789,8 +646,8 @@ propagate (void)\n \t  gcc_unreachable ();\n \t}\n \n-      gcc_assert (!node_info->global);\n-      node_l = node_info->local;\n+      node_l = &node_info->local;\n+      node_g = &node_info->global;\n \n       read_all = node_l->calls_read_all;\n       write_all = node_l->calls_write_all;\n@@ -811,7 +668,7 @@ propagate (void)\n       while (w)\n \t{\n \t  ipa_reference_local_vars_info_t w_l =\n-\t    get_reference_vars_info (w)->local;\n+\t    &get_reference_vars_info (w)->local;\n \n \t  /* When function is overwrittable, we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n@@ -834,15 +691,15 @@ propagate (void)\n \tnode_g->statics_read = all_module_statics;\n       else\n \t{\n-\t  node_g->statics_read = BITMAP_ALLOC (&global_info_obstack);\n+\t  node_g->statics_read = BITMAP_ALLOC (&local_info_obstack);\n \t  bitmap_copy (node_g->statics_read,\n \t\t       node_l->statics_read);\n \t}\n       if (write_all)\n \tnode_g->statics_written = all_module_statics;\n       else\n \t{\n-\t  node_g->statics_written = BITMAP_ALLOC (&global_info_obstack);\n+\t  node_g->statics_written = BITMAP_ALLOC (&local_info_obstack);\n \t  bitmap_copy (node_g->statics_written,\n \t\t       node_l->statics_written);\n \t}\n@@ -854,7 +711,7 @@ propagate (void)\n \t{\n \t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n-\t  ipa_reference_local_vars_info_t w_l = w_ri->local;\n+\t  ipa_reference_local_vars_info_t w_l = &w_ri->local;\n \n \t  /* These global bitmaps are initialized from the local info\n \t     of all of the nodes in the region.  However there is no\n@@ -872,18 +729,15 @@ propagate (void)\n \t}\n \n       /* All nodes within a cycle have the same global info bitmaps.  */\n-      node_info->global = node_g;\n+      node_info->global = *node_g;\n       w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n \t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n \n-\t  gcc_assert (!w_ri->global);\n-          w_ri->global = XCNEW (struct ipa_reference_global_vars_info_d);\n-\t  w_ri->global->statics_read = copy_global_bitmap (node_g->statics_read);\n-\t  w_ri->global->statics_written = copy_global_bitmap (node_g->statics_written);\n+          w_ri->global = *node_g;\n \n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n@@ -903,8 +757,8 @@ propagate (void)\n \n \t  node = order[i];\n \t  node_info = get_reference_vars_info (node);\n-\t  node_g = node_info->global;\n-\t  node_l = node_info->local;\n+\t  node_g = &node_info->global;\n+\t  node_l = &node_info->local;\n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n \t\t   cgraph_node_name (node), node->uid);\n@@ -931,7 +785,7 @@ propagate (void)\n \t    {\n \t      ipa_reference_vars_info_t w_ri =\n \t\tget_reference_vars_info (w);\n-\t      ipa_reference_local_vars_info_t w_l = w_ri->local;\n+\t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n \t      fprintf (dump_file, \"\\n  next cycle: %s/%i \",\n \t\t       cgraph_node_name (w), w->uid);\n \t      fprintf (dump_file, \"\\n    locals read: \");\n@@ -983,48 +837,50 @@ propagate (void)\n     {\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n+      ipa_reference_optimization_summary_t opt;\n+\n       node = order[i];\n       node_info = get_reference_vars_info (node);\n-      node_g = node_info->global;\n-\n-      /* Create the complimentary sets.  These are more useful for\n-\t certain apis.  */\n-      node_g->statics_not_read = BITMAP_ALLOC (&global_info_obstack);\n-      node_g->statics_not_written = BITMAP_ALLOC (&global_info_obstack);\n-\n-      if (node_g->statics_read != all_module_statics)\n-\tbitmap_and_compl (node_g->statics_not_read,\n-\t\t\t  all_module_statics,\n-\t\t\t  node_g->statics_read);\n-\n-      if (node_g->statics_written\n-\t  != all_module_statics)\n-\tbitmap_and_compl (node_g->statics_not_written,\n-\t\t\t  all_module_statics,\n-\t\t\t  node_g->statics_written);\n-   }\n+      if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+\t{\n+\t  node_g = &node_info->global;\n \n-  free (order);\n+\t  opt = XCNEW (struct ipa_reference_optimization_summary_d);\n+\t  set_reference_optimization_summary (node, opt);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      ipa_reference_vars_info_t node_info;\n-      node_info = get_reference_vars_info (node);\n-      /* Get rid of the aux information.  */\n+\t  /* Create the complimentary sets.  */\n+\t  opt->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);\n+\t  opt->statics_not_written = BITMAP_ALLOC (&optimization_summary_obstack);\n+\n+\t  if (node_g->statics_read != all_module_statics)\n+\t    bitmap_and_compl (opt->statics_not_read,\n+\t\t\t      all_module_statics,\n+\t\t\t      node_g->statics_read);\n \n+\t  if (node_g->statics_written\n+\t      != all_module_statics)\n+\t    bitmap_and_compl (opt->statics_not_written,\n+\t\t\t      all_module_statics,\n+\t\t\t      node_g->statics_written);\n+\t}\n+      if (node_info)\n+\tfree (node_info);\n       if (node->aux)\n \t{\n \t  free (node->aux);\n \t  node->aux = NULL;\n \t}\n+   }\n+\n+  free (order);\n \n-      if (cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE)\n-\tclean_function (node);\n-      else if (node_info)\n-\tclean_function_local_data (node);\n-    }\n   bitmap_obstack_release (&local_info_obstack);\n-  ipa_discover_readonly_nonaddressable_vars ();\n+  VEC_free (ipa_reference_vars_info_t, heap, ipa_reference_vars_vector);\n+  ipa_reference_vars_vector = NULL;\n+  if (dump_file)\n+    splay_tree_delete (reference_vars_to_consider);\n+  reference_vars_to_consider = NULL;\n+  all_module_statics = NULL;\n   return 0;\n }\n \n@@ -1064,5 +920,3 @@ struct ipa_opt_pass_d pass_ipa_reference =\n  NULL,\t\t\t                /* function_transform */\n  NULL\t\t\t\t\t/* variable_transform */\n };\n-\n-#include \"gt-ipa-reference.h\""}, {"sha": "a9d6f175bcc46c2044b59ecaed4ff89af91a5707", "filename": "gcc/ipa-reference.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Fipa-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.h?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -24,8 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n \n /* In ipa-reference.c  */\n-bitmap ipa_reference_get_read_global (struct cgraph_node *fn);\n-bitmap ipa_reference_get_written_global (struct cgraph_node *fn);\n bitmap ipa_reference_get_not_read_global (struct cgraph_node *fn);\n bitmap ipa_reference_get_not_written_global (struct cgraph_node *fn);\n "}, {"sha": "7f9a54c1bf605135bef7b4237f2c40720519decb", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c3001944a778ddd079de47697c092bfd82419a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=46c3001944a778ddd079de47697c092bfd82419a", "patch": "@@ -5423,9 +5423,6 @@ extern tree build_personality_function (const char *);\n \n void init_inline_once (void);\n \n-/* In ipa-reference.c.  Used for parsing attributes of asm code.  */\n-extern GTY(()) tree memory_identifier_string;\n-\n /* Compute the number of operands in an expression node NODE.  For\n    tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,\n    otherwise it is looked up from the node's code.  */"}]}