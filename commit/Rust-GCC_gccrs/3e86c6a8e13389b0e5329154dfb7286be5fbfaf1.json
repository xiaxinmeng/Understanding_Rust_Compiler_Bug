{"sha": "3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U4NmM2YThlMTMzODliMGU1MzI5MTU0ZGZiNzI4NmJlNWZiZmFmMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-04-03T03:55:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-04-03T03:55:59Z"}, "message": "re PR ipa/60659 (ICE in get_polymorphic_call_info, at ipa-devirt.c:1292)\n\n\n\tPR ipa/60659\n\t* ipa-devirt.c (get_polymorphic_call_info): Do not ICE on type inconsistent\n\tcode and instead mark the context inconsistent.\n\t(possible_polymorphic_call_targets): For inconsistent contexts\n\treturn empty complete list.\n\t* testsuite/g++.dg/torture/pr60659.C: New testcase.\n\nFrom-SVN: r209048", "tree": {"sha": "73709b7b3d27ebdc259dd16d0f15be921c3302dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73709b7b3d27ebdc259dd16d0f15be921c3302dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/comments", "author": null, "committer": null, "parents": [{"sha": "2b9912aa3c48b911e6382355b6756e45002a604e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9912aa3c48b911e6382355b6756e45002a604e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9912aa3c48b911e6382355b6756e45002a604e"}], "stats": {"total": 110, "additions": 105, "deletions": 5}, "files": [{"sha": "a566a0fb62a2c36e44d1e401b3a4281797f844a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "patch": "@@ -1,3 +1,11 @@\n+2014-04-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/60659\n+\t* ipa-devirt.c (get_polymorphic_call_info): Do not ICE on type inconsistent\n+\tcode and instead mark the context inconsistent.\n+\t(possible_polymorphic_call_targets): For inconsistent contexts\n+\treturn empty complete list.\n+\n 2014-04-02  Anthony Green  <green@moxielogic.com>\n \n \t* config/moxie/moxie.md (zero_extendqisi2, zero_extendhisi2)"}, {"sha": "c84a26dba9ae7eba65add8e357413c02e44df6d5", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "patch": "@@ -1214,7 +1214,13 @@ get_polymorphic_call_info (tree fndecl,\n \t\t     not part of outer type.  */\n \t\t  if (!contains_type_p (TREE_TYPE (base),\n \t\t\t\t\tcontext->offset + offset2, *otr_type))\n-\t\t    return base_pointer;\n+\t\t    {\n+\t\t      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n+\t\t\t code sequences; we arrange the calls to be builtin_unreachable\n+\t\t\t later.  */\n+\t\t      *otr_token = INT_MAX;\n+\t\t      return base_pointer;\n+\t\t    }\n \t\t  get_polymorphic_call_info_for_decl (context, base,\n \t\t\t\t\t\t      context->offset + offset2);\n \t\t  return NULL;\n@@ -1288,8 +1294,10 @@ get_polymorphic_call_info (tree fndecl,\n \t  if (!contains_type_p (context->outer_type, context->offset,\n \t\t\t        *otr_type))\n \t    { \n-\t      context->outer_type = NULL;\n-\t      gcc_unreachable ();\n+\t      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n+\t\t code sequences; we arrange the calls to be builtin_unreachable\n+\t\t later.  */\n+\t      *otr_token = INT_MAX;\n \t      return base_pointer;\n \t    }\n \t  context->maybe_derived_type = false;\n@@ -1389,6 +1397,9 @@ devirt_variable_node_removal_hook (varpool_node *n,\n    temporarily change to one of base types.  INCLUDE_DERIVER_TYPES make\n    us to walk the inheritance graph for all derivations.\n \n+   OTR_TOKEN == INT_MAX is used to mark calls that are provably\n+   undefined and should be redirected to unreachable.\n+\n    If COMPLETEP is non-NULL, store true if the list is complete. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n    in the target cache.  If user needs to visit every target list\n@@ -1422,6 +1433,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   bool complete;\n   bool can_refer;\n \n+  /* If ODR is not initialized, return empty incomplete list.  */\n   if (!odr_hash.is_created ())\n     {\n       if (completep)\n@@ -1431,11 +1443,28 @@ possible_polymorphic_call_targets (tree otr_type,\n       return nodes;\n     }\n \n+  /* If we hit type inconsistency, just return empty list of targets.  */\n+  if (otr_token == INT_MAX)\n+    {\n+      if (completep)\n+\t*completep = true;\n+      if (nonconstruction_targetsp)\n+\t*nonconstruction_targetsp = 0;\n+      return nodes;\n+    }\n+\n   type = get_odr_type (otr_type, true);\n \n   /* Lookup the outer class type we want to walk.  */\n-  if (context.outer_type)\n-    get_class_context (&context, otr_type);\n+  if (context.outer_type\n+      && !get_class_context (&context, otr_type))\n+    {\n+      if (completep)\n+\t*completep = false;\n+      if (nonconstruction_targetsp)\n+\t*nonconstruction_targetsp = 0;\n+      return nodes;\n+    }\n \n   /* We canonicalize our query, so we do not need extra hashtable entries.  */\n "}, {"sha": "1ffa4b96ba6544baa0834fef68d8509cb33c66d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "patch": "@@ -1,3 +1,8 @@\n+2014-04-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/60659\n+\t* testsuite/g++.dg/torture/pr60659.C: New testcase.\n+\t\n 2014-04-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/60733"}, {"sha": "f0158a5220ad067b0bda95fe26917b632c31d0c8", "filename": "gcc/testsuite/g++.dg/torture/pr60659.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60659.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e86c6a8e13389b0e5329154dfb7286be5fbfaf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60659.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60659.C?ref=3e86c6a8e13389b0e5329154dfb7286be5fbfaf1", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do compile }\n+template <typename _InputIterator> void __distance (_InputIterator);\n+template <typename _InputIterator>\n+void distance (_InputIterator, _InputIterator p2)\n+{\n+  __distance (p2);\n+}\n+\n+namespace boost\n+{\n+template <class Iterator> struct A\n+{\n+  typedef typename Iterator::difference_type type;\n+};\n+template <class T> typename T::const_iterator end (T &);\n+template <class T> typename T::const_iterator begin (T &);\n+template <class T> struct D : A<typename T::const_iterator>\n+{\n+};\n+template <class T> typename D<T>::type distance (const T &p1)\n+{\n+  distance (boost::begin (p1), boost::end (p1));\n+  return 0;\n+}\n+template <class IteratorT> class B\n+{\n+public:\n+  typedef B type;\n+  typedef IteratorT const_iterator;\n+};\n+}\n+\n+typedef int storage_t[];\n+struct F;\n+template <template <typename> class> struct G\n+{\n+  G (const G &p1) { p1.m_fn1 ().m_fn1 (0); }\n+  const F &m_fn1 () const\n+  {\n+    const void *a;\n+    a = &data_m;\n+    return *static_cast<const F *>(a);\n+  }\n+  storage_t *data_m;\n+};\n+\n+struct F\n+{\n+  virtual F *m_fn1 (void *) const;\n+};\n+template <typename> struct H;\n+struct C : G<H>\n+{\n+  typedef int difference_type;\n+};\n+boost::B<C> AllTransVideos ();\n+int b = boost::distance (AllTransVideos ());\n+"}]}