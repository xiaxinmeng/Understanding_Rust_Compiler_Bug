{"sha": "4af16369d54a5a75f9ffd7b32a835f896995fe4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmMTYzNjlkNTRhNWE3NWY5ZmZkN2IzMmE4MzVmODk2OTk1ZmU0ZA==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2003-03-15T22:51:37Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2003-03-15T22:51:37Z"}, "message": "rtl.h (subrtx_p): Renamed to rtx_referenced_p.\n\n\t* rtl.h (subrtx_p): Renamed to rtx_referenced_p.\n\t(rtx_pair): Added new element update_label_nuses, renamed to\n\treplace_label_data.\n\t* cfgcleanup.c (outgoing_edges_match, try_crossjump_to_edge): Use\n\treplace_label_data instead of rtx_pair.\n\t* loop.c (load_mems): Likewise.\n\t* rtlanal.c (replace_label): Replace label in pool constants and in\n\tINSN_LIST (in REG_LABEL note).\n\t(subrtx_p): Renamed to rtx_referenced_p.\n\t(subrtx_p_1): Renamed to rtx_referenced_p_1, compare the interior of\n\tLABEL_REF with CODE_LABEL, traverse constants from pool.\n\nFrom-SVN: r64419", "tree": {"sha": "2b611926dbc72532503869b1479e8eecd0fc8e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b611926dbc72532503869b1479e8eecd0fc8e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af16369d54a5a75f9ffd7b32a835f896995fe4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af16369d54a5a75f9ffd7b32a835f896995fe4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af16369d54a5a75f9ffd7b32a835f896995fe4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af16369d54a5a75f9ffd7b32a835f896995fe4d/comments", "author": null, "committer": null, "parents": [{"sha": "d2184e79be1ae8498309d3dc99334e4c39099769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2184e79be1ae8498309d3dc99334e4c39099769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2184e79be1ae8498309d3dc99334e4c39099769"}], "stats": {"total": 129, "additions": 97, "deletions": 32}, "files": [{"sha": "b5486fda5686f6ec5784cc90fad715005a108500", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4af16369d54a5a75f9ffd7b32a835f896995fe4d", "patch": "@@ -1,3 +1,17 @@\n+2003-03-15  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* rtl.h (subrtx_p): Renamed to rtx_referenced_p.\n+\t(rtx_pair): Added new element update_label_nuses, renamed to\n+\treplace_label_data.\n+\t* cfgcleanup.c (outgoing_edges_match, try_crossjump_to_edge): Use\n+\treplace_label_data instead of rtx_pair.\n+\t* loop.c (load_mems): Likewise.\n+\t* rtlanal.c (replace_label): Replace label in pool constants and in\n+\tINSN_LIST (in REG_LABEL note).\n+\t(subrtx_p): Renamed to rtx_referenced_p.\n+\t(subrtx_p_1): Renamed to rtx_referenced_p_1, compare the interior of\n+\tLABEL_REF with CODE_LABEL, traverse constants from pool.\n+\n 2003-03-15  Aldy Hernandez <aldyh@redhat.com>\n \t    Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "76aebc47034414d74be44d06d1217d6526fdff9a", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=4af16369d54a5a75f9ffd7b32a835f896995fe4d", "patch": "@@ -1271,10 +1271,10 @@ outgoing_edges_match (mode, bb1, bb2)\n \t     the jump tables are same too. So disable crossjumping of blocks BB1\n \t     and BB2 because when deleting the common insns in the end of BB1\n \t     by flow_delete_block () the jump table would be deleted too.  */\n-\t  /* If LABEL2 is contained in BB1->END do not do anything\n+\t  /* If LABEL2 is referenced in BB1->END do not do anything\n \t     because we would loose information when replacing\n \t     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */\n-\t  if (label1 != label2 && !subrtx_p (label2, bb1->end))\n+\t  if (label1 != label2 && !rtx_referenced_p (label2, bb1->end))\n \t    {\n \t      /* Set IDENTICAL to true when the tables are identical.  */\n \t      bool identical = false;\n@@ -1301,13 +1301,14 @@ outgoing_edges_match (mode, bb1, bb2)\n \n \t      if (identical)\n \t\t{\n-\t\t  rtx_pair rr;\n+\t\t  replace_label_data rr;\n \t\t  bool match;\n \n \t\t  /* Temporarily replace references to LABEL1 with LABEL2\n \t\t     in BB1->END so that we could compare the instructions.  */\n \t\t  rr.r1 = label1;\n \t\t  rr.r2 = label2;\n+\t\t  rr.update_label_nuses = false;\n \t\t  for_each_rtx (&bb1->end, replace_label, &rr);\n \n \t\t  match = insns_match_p (mode, bb1->end, bb2->end);\n@@ -1459,12 +1460,13 @@ try_crossjump_to_edge (mode, e1, e2)\n \t  && tablejump_p (src2->end, &label2, &table2)\n \t  && label1 != label2)\n \t{\n-\t  rtx_pair rr;\n+\t  replace_label_data rr;\n \t  rtx insn;\n \n \t  /* Replace references to LABEL1 with LABEL2.  */\n \t  rr.r1 = label1;\n \t  rr.r2 = label2;\n+\t  rr.update_label_nuses = true;\n \t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t    {\n \t      /* Do not replace the label in SRC1->END because when deleting"}, {"sha": "781ed3725144b437daff3f199e5cab6e1130f54d", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4af16369d54a5a75f9ffd7b32a835f896995fe4d", "patch": "@@ -10137,9 +10137,10 @@ load_mems (loop)\n     {\n       /* Now, we need to replace all references to the previous exit\n \t label with the new one.  */\n-      rtx_pair rr;\n+      replace_label_data rr;\n       rr.r1 = end_label;\n       rr.r2 = label;\n+      rr.update_label_nuses = true;\n \n       for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n \t{"}, {"sha": "4bb760b24c75686511b3de7a080f809fa2d6ea57", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4af16369d54a5a75f9ffd7b32a835f896995fe4d", "patch": "@@ -1596,11 +1596,12 @@ extern rtx set_unique_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n #define single_set_1(I) single_set_2 (I, PATTERN (I))\n \n /* Structure used for passing data to REPLACE_LABEL.  */\n-typedef struct rtx_pair\n+typedef struct replace_label_data\n {\n   rtx r1;\n   rtx r2;\n-} rtx_pair;\n+  bool update_label_nuses;\n+} replace_label_data;\n \n extern int rtx_addr_can_trap_p\t\tPARAMS ((rtx));\n extern bool nonzero_address_p\t\tPARAMS ((rtx));\n@@ -1662,7 +1663,7 @@ extern rtx replace_rtx\t\t\tPARAMS ((rtx, rtx, rtx));\n extern rtx replace_regs\t\t\tPARAMS ((rtx, rtx *, unsigned int,\n \t\t\t\t\t\t int));\n extern int replace_label\t\tPARAMS ((rtx *, void *));\n-extern int subrtx_p\t\t\tPARAMS ((rtx, rtx));\n+extern int rtx_referenced_p\t\tPARAMS ((rtx, rtx));\n extern bool tablejump_p\t\t\tPARAMS ((rtx, rtx *, rtx *));\n extern int computed_jump_p\t\tPARAMS ((rtx));\n typedef int (*rtx_function)             PARAMS ((rtx *, void *));"}, {"sha": "dc87e451ac372ea5e4c5d9a6db783339274e7ce8", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af16369d54a5a75f9ffd7b32a835f896995fe4d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4af16369d54a5a75f9ffd7b32a835f896995fe4d", "patch": "@@ -38,7 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n-static int subrtx_p_1\t\tPARAMS ((rtx *, void *));\n+static int rtx_referenced_p_1\tPARAMS ((rtx *, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n static bool hoist_test_store\t\tPARAMS ((rtx, rtx, regset));\n@@ -2796,59 +2796,106 @@ replace_regs (x, reg_map, nregs, replace_dest)\n }\n \n /* Replace occurrences of the old label in *X with the new one.\n-   DATA is an rtx_pair containing the old and new labels, respectively.  */\n+   DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */\n \n int\n replace_label (x, data)\n      rtx *x;\n      void *data;\n {\n   rtx l = *x;\n-  rtx old_label = ((rtx_pair *) data)->r1;\n-  rtx new_label = ((rtx_pair *) data)->r2;\n+  rtx tmp;\n+  rtx old_label = ((replace_label_data *) data)->r1;\n+  rtx new_label = ((replace_label_data *) data)->r2;\n+  bool update_label_nuses = ((replace_label_data *) data)->update_label_nuses;\n \n   if (l == NULL_RTX)\n     return 0;\n \n+  if (GET_CODE (l) == MEM\n+      && (tmp = XEXP (l, 0)) != NULL_RTX\n+      && GET_CODE (tmp) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (tmp))\n+    {\n+      rtx c = get_pool_constant (tmp);\n+      if (rtx_referenced_p (old_label, c))\n+\t{\n+\t  rtx new_c, new_l;\n+\t  replace_label_data *d = (replace_label_data *) data;\n+\t  \n+\t  /* Create a copy of constant C; replace the label inside\n+\t     but do not update LABEL_NUSES because uses in constant pool\n+\t     are not counted.  */\n+\t  new_c = copy_rtx (c);\n+\t  d->update_label_nuses = false;\n+\t  for_each_rtx (&new_c, replace_label, data);\n+\t  d->update_label_nuses = update_label_nuses;\n+\n+\t  /* Add the new constant NEW_C to constant pool and replace\n+\t     the old reference to constant by new reference.  */\n+\t  new_l = force_const_mem (get_pool_mode (tmp), new_c);\n+\t  *x = replace_rtx (l, l, new_l);\n+\t}\n+      return 0;\n+    }\n+\n   /* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL\n      field.  This is not handled by for_each_rtx because it doesn't\n      handle unprinted ('0') fields.  */\n   if (GET_CODE (l) == JUMP_INSN && JUMP_LABEL (l) == old_label)\n     JUMP_LABEL (l) = new_label;\n-  \n-  if (GET_CODE (l) != LABEL_REF)\n-    return 0;\n-\n-  if (XEXP (l, 0) != old_label)\n-    return 0;\n \n-  XEXP (l, 0) = new_label;\n-  ++LABEL_NUSES (new_label);\n-  --LABEL_NUSES (old_label);\n+  if ((GET_CODE (l) == LABEL_REF\n+       || GET_CODE (l) == INSN_LIST)\n+      && XEXP (l, 0) == old_label)\n+    {\n+      XEXP (l, 0) = new_label;\n+      if (update_label_nuses)\n+\t{\n+\t  ++LABEL_NUSES (new_label);\n+\t  --LABEL_NUSES (old_label);\n+\t}\n+      return 0;\n+    }\n \n   return 0;\n }\n \n-/* Return RTX_EQUAL_P (*PX, SUBX).  If *PX and SUBX are not equal\n-   FOR_EACH_RTX continues traversing, if they are equal FOR_EACH_RTX\n-   stops traversing and returns the same value as this function.  */\n+/* When *BODY is equal to X or X is directly referenced by *BODY\n+   return nonzero, thus FOR_EACH_RTX stops traversing and returns nonzero\n+   too, otherwise FOR_EACH_RTX continues traversing *BODY.  */\n \n static int\n-subrtx_p_1 (px, subx)\n-     rtx *px;\n-     void *subx;\n+rtx_referenced_p_1 (body, x)\n+     rtx *body;\n+     void *x;\n {\n-  return rtx_equal_p (*px, (rtx) subx);\n+  rtx y = (rtx) x;\n+\n+  if (*body == NULL_RTX)\n+    return y == NULL_RTX;\n+\n+  /* Return true if a label_ref *BODY refers to label Y.  */\n+  if (GET_CODE (*body) == LABEL_REF && GET_CODE (y) == CODE_LABEL)\n+    return XEXP (*body, 0) == y;\n+\n+  /* If *BODY is a reference to pool constant traverse the constant.  */\n+  if (GET_CODE (*body) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (*body))\n+    return rtx_referenced_p (y, get_pool_constant (*body));\n+\n+  /* By default, compare the RTL expressions.  */\n+  return rtx_equal_p (*body, y);\n }\n \n-/* Return true if SUBX is equal to some subexpression of X.  */\n+/* Return true if X is referenced in BODY.  */\n \n int\n-subrtx_p (subx, x)\n-     rtx subx;\n+rtx_referenced_p (x, body)\n      rtx x;\n+     rtx body;\n {\n-  return for_each_rtx (&x, subrtx_p_1, subx);\n+  return for_each_rtx (&body, rtx_referenced_p_1, x);\n }\n \n /* If INSN is a jump to jumptable insn rturn true and store the label (which"}]}