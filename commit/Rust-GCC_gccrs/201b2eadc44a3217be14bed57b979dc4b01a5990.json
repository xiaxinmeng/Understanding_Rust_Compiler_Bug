{"sha": "201b2eadc44a3217be14bed57b979dc4b01a5990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAxYjJlYWRjNDRhMzIxN2JlMTRiZWQ1N2I5NzlkYzRiMDFhNTk5MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-09-07T11:28:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-09-07T11:28:35Z"}, "message": "passes.c (init_optimization_passes): Add simple dce and addressable passes.\n\n\n\t* passes.c (init_optimization_passes): Add simple dce and addressable\n\tpasses.\n\t* tree-ssa.c (execute_update_addresses_taken): New function.\n\t(pass_update_address_taken): New.\n\t* tree-ssa-dse.c (execute_simple_dse): New function.\n\t(pass_simple_dse): New.\n\t* tree-pass.h (pass_simple_dse, pass_update_address_taken): Declare.\n\nFrom-SVN: r128239", "tree": {"sha": "a9b189174aab2e413f3eb87f3545535fef231f0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b189174aab2e413f3eb87f3545535fef231f0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/201b2eadc44a3217be14bed57b979dc4b01a5990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201b2eadc44a3217be14bed57b979dc4b01a5990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/201b2eadc44a3217be14bed57b979dc4b01a5990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201b2eadc44a3217be14bed57b979dc4b01a5990/comments", "author": null, "committer": null, "parents": [{"sha": "f85138bc84767bdbf1e405461578432629df11a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f85138bc84767bdbf1e405461578432629df11a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f85138bc84767bdbf1e405461578432629df11a7"}], "stats": {"total": 246, "additions": 246, "deletions": 0}, "files": [{"sha": "be49cf50e604f51cd5315c9439a02b52f41aa0a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=201b2eadc44a3217be14bed57b979dc4b01a5990", "patch": "@@ -1,3 +1,13 @@\n+2007-09-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* passes.c (init_optimization_passes): Add simple dce and addressable\n+\tpasses.\n+\t* tree-ssa.c (execute_update_addresses_taken): New function.\n+\t(pass_update_address_taken): New.\n+\t* tree-ssa-dse.c (execute_simple_dse): New function.\n+\t(pass_simple_dse): New.\n+\t* tree-pass.h (pass_simple_dse, pass_update_address_taken): Declare.\n+\n 2007-09-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR middle-end/33321"}, {"sha": "1b88414dd0120240783b012a75bb14debc612c38", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=201b2eadc44a3217be14bed57b979dc4b01a5990", "patch": "@@ -523,10 +523,14 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_rename_ssa_copies);\n \t  NEXT_PASS (pass_ccp);\n \t  NEXT_PASS (pass_forwprop);\n+\t  NEXT_PASS (pass_update_address_taken);\n+\t  NEXT_PASS (pass_simple_dse);\n \t  NEXT_PASS (pass_sra_early);\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_merge_phi);\n \t  NEXT_PASS (pass_dce);\n+\t  NEXT_PASS (pass_update_address_taken);\n+\t  NEXT_PASS (pass_simple_dse);\n \t  NEXT_PASS (pass_tail_recursion);\n           NEXT_PASS (pass_profile);\n \t  NEXT_PASS (pass_release_ssa_names);"}, {"sha": "19bda7cf4b7281755804521ba60ddcd4a98bb72b", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=201b2eadc44a3217be14bed57b979dc4b01a5990", "patch": "@@ -306,6 +306,7 @@ extern struct tree_opt_pass pass_forwprop;\n extern struct tree_opt_pass pass_phiprop;\n extern struct tree_opt_pass pass_tree_ifcombine;\n extern struct tree_opt_pass pass_dse;\n+extern struct tree_opt_pass pass_simple_dse;\n extern struct tree_opt_pass pass_nrv;\n extern struct tree_opt_pass pass_mark_used_blocks;\n extern struct tree_opt_pass pass_rename_ssa_copies;\n@@ -445,6 +446,7 @@ extern struct tree_opt_pass pass_early_inline;\n extern struct tree_opt_pass pass_inline_parameters;\n extern struct tree_opt_pass pass_apply_inline;\n extern struct tree_opt_pass pass_all_early_optimizations;\n+extern struct tree_opt_pass pass_update_address_taken;\n \n /* The root of the compilation pass tree, once constructed.  */\n extern struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;"}, {"sha": "4416f7dc45d5fba6994314690c030d38a18de4e8", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=201b2eadc44a3217be14bed57b979dc4b01a5990", "patch": "@@ -918,3 +918,137 @@ struct tree_opt_pass pass_dse = {\n     | TODO_verify_ssa,\t\t/* todo_flags_finish */\n   0\t\t\t\t/* letter */\n };\n+\n+/* A very simple dead store pass eliminating write only local variables.\n+   The pass does not require alias information and thus can be run before\n+   inlining to quickly eliminate artifacts of some common C++ constructs.  */\n+\n+static unsigned int\n+execute_simple_dse (void)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  bitmap variables_loaded = BITMAP_ALLOC (NULL);\n+  unsigned int todo = 0;\n+\n+  /* Collect into VARIABLES LOADED all variables that are read in function\n+     body.  */\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      if (LOADED_SYMS (bsi_stmt (bsi)))\n+\tbitmap_ior_into (variables_loaded,\n+\t\t\t LOADED_SYMS (bsi_stmt (bsi)));\n+\n+  /* Look for statements writting into the write only variables.\n+     And try to remove them.  */\n+\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi);)\n+      {\n+\ttree stmt = bsi_stmt (bsi), op;\n+\tbool removed = false;\n+        ssa_op_iter iter;\n+\n+\tif (STORED_SYMS (stmt) && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (stmt) != RETURN_EXPR\n+\t    && !bitmap_intersect_p (STORED_SYMS (stmt), variables_loaded))\n+\t  {\n+\t    unsigned int i;\n+\t    bitmap_iterator bi;\n+\t    bool dead = true;\n+\n+\n+\n+\t    /* See if STMT only stores to write-only variables and\n+\t       verify that there are no volatile operands.  tree-ssa-operands\n+\t       sets has_volatile_ops flag for all statements involving\n+\t       reads and writes when aliases are not built to prevent passes\n+\t       from removing them as dead.  The flag thus has no use for us\n+\t       and we need to look into all operands.  */\n+\t      \n+\t    EXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n+\t      {\n+\t\ttree var = referenced_var_lookup (i);\n+\t\tif (TREE_ADDRESSABLE (var)\n+\t\t    || is_global_var (var)\n+\t\t    || TREE_THIS_VOLATILE (var))\n+\t\t  dead = false;\n+\t      }\n+\n+\t    if (dead && LOADED_SYMS (stmt))\n+\t      EXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n+\t\tif (TREE_THIS_VOLATILE (referenced_var_lookup (i)))\n+\t\t  dead = false;\n+\n+\t    if (dead)\n+\t      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_ALL_OPERANDS)\n+\t\tif (TREE_THIS_VOLATILE (op))\n+\t\t  dead = false;\n+\n+\t    /* Look for possible occurence var = indirect_ref (...) where\n+\t       indirect_ref itself is volatile.  */\n+\n+\t    if (dead && TREE_THIS_VOLATILE (GIMPLE_STMT_OPERAND (stmt, 1)))\n+\t      dead = false;\n+\n+\t    if (dead)\n+\t      {\n+\t\ttree call = get_call_expr_in (stmt);\n+\n+\t\t/* When LHS of var = call (); is dead, simplify it into\n+\t\t   call (); saving one operand.  */\n+\t\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t\t    && call\n+\t\t    && TREE_SIDE_EFFECTS (call))\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      {\n+\t\t\tfprintf (dump_file, \"Deleted LHS of call: \");\n+\t\t\tprint_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t      }\n+\t\t    push_stmt_changes (bsi_stmt_ptr (bsi));\n+\t\t    TREE_BLOCK (call) = TREE_BLOCK (stmt);\n+\t\t    bsi_replace (&bsi, call, false);\n+\t\t    maybe_clean_or_replace_eh_stmt (stmt, call);\n+\t\t    mark_symbols_for_renaming (call);\n+\t\t    pop_stmt_changes (bsi_stmt_ptr (bsi));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      {\n+\t\t\tfprintf (dump_file, \"  Deleted dead store '\");\n+\t\t\tprint_generic_expr (dump_file, stmt, dump_flags);\n+\t\t\tfprintf (dump_file, \"'\\n\");\n+\t\t      }\n+\t\t    removed = true;\n+\t\t    bsi_remove (&bsi, true);\n+\t\t    todo |= TODO_cleanup_cfg;\n+\t\t  }\n+\t\ttodo |= TODO_remove_unused_locals | TODO_ggc_collect;\n+\t      }\n+\t  }\n+\tif (!removed)\n+\t  bsi_next (&bsi);\n+      }\n+  BITMAP_FREE (variables_loaded);\n+  return todo;\n+}\n+\n+struct tree_opt_pass pass_simple_dse =\n+{\n+  \"sdse\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_simple_dse,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,          \t        /* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\n+};"}, {"sha": "9723afb0eec3d19232717528ef2efc07af10b3eb", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b2eadc44a3217be14bed57b979dc4b01a5990/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=201b2eadc44a3217be14bed57b979dc4b01a5990", "patch": "@@ -1378,3 +1378,99 @@ struct tree_opt_pass pass_late_warn_uninitialized =\n   0,                                    /* todo_flags_finish */\n   0\t\t\t\t        /* letter */\n };\n+\n+/* Compute TREE_ADDRESSABLE for local variables.  */\n+\n+static unsigned int\n+execute_update_addresses_taken (void)\n+{\n+  tree var;\n+  referenced_var_iterator rvi;\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  bitmap addresses_taken = BITMAP_ALLOC (NULL);\n+  bitmap vars_updated = BITMAP_ALLOC (NULL);\n+  bool update_vops;\n+  tree phi;\n+\n+  /* Collect into ADDRESSES_TAKEN all variables whose address is taken within\n+     the function body.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  stmt_ann_t s_ann = stmt_ann (bsi_stmt (bsi));\n+\n+\t  if (s_ann->addresses_taken)\n+\t    bitmap_ior_into (addresses_taken, s_ann->addresses_taken);\n+\t}\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  unsigned i, phi_num_args = PHI_NUM_ARGS (phi);\n+\t  for (i = 0; i < phi_num_args; i++)\n+\t    {\n+\t      tree op = PHI_ARG_DEF (phi, i), var;\n+\t      if (TREE_CODE (op) == ADDR_EXPR\n+\t\t  && (var = get_base_address (TREE_OPERAND (op, 0))) != NULL_TREE\n+\t\t  && DECL_P (var))\n+\t\tbitmap_set_bit (addresses_taken, DECL_UID (var));\n+\t    }\n+\t}\n+    }\n+\n+  /* When possible, clear ADDRESSABLE bit and mark variable for conversion into\n+     SSA.  */\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n+    if (!is_global_var (var)\n+\t&& TREE_CODE (var) != RESULT_DECL\n+\t&& TREE_ADDRESSABLE (var)\n+\t&& !bitmap_bit_p (addresses_taken, DECL_UID (var)))\n+      {\n+        TREE_ADDRESSABLE (var) = 0;\n+\tif (is_gimple_reg (var))\n+\t  mark_sym_for_renaming (var);\n+\tupdate_vops = true;\n+\tbitmap_set_bit (vars_updated, DECL_UID (var));\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"No longer having address taken \");\n+\t    print_generic_expr (dump_file, var, 0);\n+\t    fprintf (dump_file, \"\\n\");\n+\t  }\n+      }\n+\n+  /* Operand caches needs to be recomputed for operands referencing the updated\n+     variables.  */\n+  if (update_vops)\n+    FOR_EACH_BB (bb)\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  if ((LOADED_SYMS (stmt)\n+\t       && bitmap_intersect_p (LOADED_SYMS (stmt), vars_updated))\n+\t      || (STORED_SYMS (stmt)\n+\t\t  && bitmap_intersect_p (STORED_SYMS (stmt), vars_updated)))\n+\t    update_stmt (stmt);\n+\t}\n+  BITMAP_FREE (addresses_taken);\n+  BITMAP_FREE (vars_updated);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_update_address_taken =\n+{\n+  \"addressables\",\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_update_addresses_taken,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_update_ssa,                      /* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\n+};"}]}