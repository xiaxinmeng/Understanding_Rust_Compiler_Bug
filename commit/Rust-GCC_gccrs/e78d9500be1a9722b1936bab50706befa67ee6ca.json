{"sha": "e78d9500be1a9722b1936bab50706befa67ee6ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc4ZDk1MDBiZTFhOTcyMmIxOTM2YmFiNTA3MDZiZWZhNjdlZTZjYQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-10T19:45:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T19:45:18Z"}, "message": "gcse.c (run_jump_opt_after_gcse): New variable.\n\n        * gcse.c (run_jump_opt_after_gcse): New variable.\n        (gcse_main): Returns an integer.\n        (hash_scan_set): Record initializations from CONST_DOUBLEs too.\n        (try_replace_reg): Update some comments.\n        (cprop_insn): Allow propagation into some JUMP_INSNs too.\n        * rtl.h (gcse_main): Update prototype.\n        * toplev.c (rest_of_compilation): If gcse_main returns nonzero,\n        then run a jump optimization pass.\n        * jump.c (delete_barrier_successors): Delete nop jumps too.\n\nFrom-SVN: r25673", "tree": {"sha": "3207b4993cd0675a87b6ff1209d6388684e2eb53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3207b4993cd0675a87b6ff1209d6388684e2eb53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e78d9500be1a9722b1936bab50706befa67ee6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78d9500be1a9722b1936bab50706befa67ee6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78d9500be1a9722b1936bab50706befa67ee6ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78d9500be1a9722b1936bab50706befa67ee6ca/comments", "author": null, "committer": null, "parents": [{"sha": "b7975aedf6113725502bcc8327ace12c7bf568aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7975aedf6113725502bcc8327ace12c7bf568aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7975aedf6113725502bcc8327ace12c7bf568aa"}], "stats": {"total": 157, "additions": 144, "deletions": 13}, "files": [{"sha": "6c0b0c2bd2c5aab87713d36858d9dd810ebc56c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e78d9500be1a9722b1936bab50706befa67ee6ca", "patch": "@@ -1,3 +1,15 @@\n+Wed Mar 10 20:28:29 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* gcse.c (run_jump_opt_after_gcse): New variable.\n+\t(gcse_main): Returns an integer.\n+\t(hash_scan_set): Record initializations from CONST_DOUBLEs too.\n+\t(try_replace_reg): Update some comments.\n+\t(cprop_insn): Allow propagation into some JUMP_INSNs too.\n+\t* rtl.h (gcse_main): Update prototype.\n+\t* toplev.c (rest_of_compilation): If gcse_main returns nonzero,\n+\tthen run a jump optimization pass.\n+\t* jump.c (delete_barrier_successors): Delete nop jumps too.\n+\n Wed Mar 10 19:04:31 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.c (fp_arith_reg_operand): Actually test if reg is suitable"}, {"sha": "a80570400d8d55edcdcf7b978844b5c23885fbd8", "filename": "gcc/gcse.c", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e78d9500be1a9722b1936bab50706befa67ee6ca", "patch": "@@ -188,7 +188,7 @@ yyy\n \n    4) Perform global cse.\n \n-   5) Perform another pass of copy/constant propagation [only if PRE].\n+   5) Perform another pass of copy/constant propagation.\n \n    Two passes of copy/constant propagation are done because the first one\n    enables more GCSE and the second one helps to clean up the copies that\n@@ -333,6 +333,15 @@ static int_list_ptr *s_succs;\n static int *num_preds;\n static int *num_succs;\n \n+/* Note whether or not we should run jump optimization after gcse.  We\n+   want to do this for two cases.\n+\n+    * If we changed any jumps via cprop.\n+\n+    * If we added any labels via edge splitting.  */\n+\n+static int run_jump_opt_after_gcse;\n+\n /* Hash table of expressions.  */\n \n struct expr\n@@ -648,7 +657,7 @@ static void add_label_notes\t      PROTO ((rtx, rtx));\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n \n-void\n+int\n gcse_main (f, file)\n      rtx f;\n      FILE *file;\n@@ -661,10 +670,12 @@ gcse_main (f, file)\n   /* Point to release obstack data from for each pass.  */\n   char *gcse_obstack_bottom;\n \n+  run_jump_opt_after_gcse = 0;\n+\n   /* It's impossible to construct a correct control flow graph in the\n      presense of setjmp, so just punt to be safe.  */\n   if (current_function_calls_setjmp)\n-    return;\n+    return 0;\n    \n   /* For calling dump_foo fns from gdb.  */\n   debug_stderr = stderr;\n@@ -677,7 +688,7 @@ gcse_main (f, file)\n     {\n       /* Free storage allocated by find_basic_blocks.  */\n       free_basic_block_vars (0);\n-      return;\n+      return 0;\n     }\n \n   /* See what modes support reg/reg copy operations.  */\n@@ -778,6 +789,7 @@ gcse_main (f, file)\n   free_bb_mem ();\n   /* Free storage allocated by find_basic_blocks.  */\n   free_basic_block_vars (0);\n+  return run_jump_opt_after_gcse;\n }\n \f\n /* Misc. utilities.  */\n@@ -1800,7 +1812,8 @@ hash_scan_set (pat, insn, set_p)\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t\t    && can_copy_p [GET_MODE (dest)])\n \t\t   /* ??? CONST_INT:wip */\n-\t\t   || GET_CODE (src) == CONST_INT)\n+\t\t   || GET_CODE (src) == CONST_INT\n+\t\t   || GET_CODE (src) == CONST_DOUBLE)\n \t       /* A copy is not available if its src or dest is subsequently\n \t\t  modified.  Here we want to search from INSN+1 on, but\n \t\t  oprs_available_p searches from INSN on.  */\n@@ -3690,6 +3703,11 @@ static int\n try_replace_reg (from, to, insn)\n      rtx from, to, insn;\n {\n+  /* If this fails we could try to simplify the result of the\n+     replacement and attempt to recognize the simplified insn.\n+\n+     But we need a general simplify_rtx that doesn't have pass\n+     specific state variables.  I'm not aware of one at the moment.  */\n   return validate_replace_src (from, to, insn);\n }\n \n@@ -3723,8 +3741,10 @@ cprop_insn (insn)\n   struct reg_use *reg_used;\n   int changed = 0;\n \n-  /* ??? For now only propagate into SETs.  */\n-  if (GET_CODE (insn) != INSN\n+  /* Only propagate into SETs.  Note that a conditional jump is a\n+     SET with pc_rtx as the destination.  */\n+  if ((GET_CODE (insn) != INSN\n+       && GET_CODE (insn) != JUMP_INSN)\n       || GET_CODE (PATTERN (insn)) != SET)\n     return 0;\n \n@@ -3760,23 +3780,103 @@ cprop_insn (insn)\n \tabort ();\n       src = SET_SRC (pat);\n \n-      if (GET_CODE (src) == CONST_INT)\n+      /* Constant propagation.  */\n+      if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n \t{\n-\t  if (try_replace_reg (reg_used->reg_rtx, src, insn))\n+\t  /* Handle normal insns first.  */\n+\t  if (GET_CODE (insn) == INSN\n+\t      && try_replace_reg (reg_used->reg_rtx, src, insn))\n \t    {\n \t      changed = 1;\n \t      const_prop_count++;\n \t      if (gcse_file != NULL)\n \t\t{\n \t\t  fprintf (gcse_file, \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n \t\t\t   regno, INSN_UID (insn));\n-\t\t  fprintf (gcse_file, HOST_WIDE_INT_PRINT_DEC, INTVAL (src));\n+\t\t  print_rtl (gcse_file, src);\n \t\t  fprintf (gcse_file, \"\\n\");\n \t\t}\n \n \t      /* The original insn setting reg_used may or may not now be\n \t\t deletable.  We leave the deletion to flow.  */\n \t    }\n+\n+\t  /* Try to propagate a CONST_INT into a conditional jump.\n+\t     We're pretty specific about what we will handle in this\n+\t     code, we can extend this as necessary over time.\n+\n+\t     Right now the insn in question must look like\n+\n+\t     (set (pc) (if_then_else ...))\n+\n+\t     Note this does not currently handle machines which use cc0.  */\n+\t  else if (GET_CODE (insn) == JUMP_INSN && condjump_p (insn))\n+\t    {\n+\t      /* We want a copy of the JUMP_INSN so we can modify it\n+\t\t in-place as needed without effecting the original.  */\n+\t      rtx copy = copy_rtx (insn);\n+\t      rtx set = PATTERN (copy);\n+\t      rtx temp;\n+\n+\t      /* Replace the register with the appropriate constant.  */\n+\t      replace_rtx (SET_SRC (set), reg_used->reg_rtx, src);\n+\n+\t      temp = simplify_ternary_operation (GET_CODE (SET_SRC (set)),\n+\t\t\t\t\t\t GET_MODE (SET_SRC (set)),\n+\t\t\t\t\t\t GET_MODE (XEXP (SET_SRC (set), 0)),\n+\t\t\t\t\t\t XEXP (SET_SRC (set), 0),\n+\t\t\t\t\t\t XEXP (SET_SRC (set), 1),\n+\t\t\t\t\t\t XEXP (SET_SRC (set), 2));\n+\n+\t      /* If no simplification can be made, then try the next\n+\t\t register.  */\n+\t      if (temp)\n+\t\tSET_SRC (set) = temp;\n+\t      else\n+\t\tcontinue;\n+\n+\t      /* That may have changed the structure of TEMP, so\n+\t\t force it to be rerecognized if it has not turned\n+\t\t into a nop or unconditional jump.  */\n+\t\t\n+\t      INSN_CODE (copy) = -1;\n+\t      if ((SET_DEST (set) == pc_rtx\n+\t\t   && (SET_SRC (set) == pc_rtx\n+\t\t       || GET_CODE (SET_SRC (set)) == LABEL_REF))\n+\t\t  || recog (PATTERN (copy), copy, NULL) >= 0)\n+\t\t{\n+\t\t  /* This has either become an unconditional jump\n+\t\t     or a nop-jump.  We'd like to delete nop jumps\n+\t\t     here, but doing so confuses gcse.  So we just\n+\t\t     make the replacement and let later passes\n+\t\t     sort things out.  */\n+\t\t  PATTERN (insn) = set;\n+\t\t  INSN_CODE (insn) = -1;\n+\n+\t\t  /* One less use of the label this insn used to jump to\n+\t\t     if we turned this into a NOP jump.  */\n+\t\t  if (SET_SRC (set) == pc_rtx && JUMP_LABEL (insn) != 0)\n+\t\t    --LABEL_NUSES (JUMP_LABEL (insn));\n+\n+\t\t  /* If this has turned into an unconditional jump,\n+\t\t     then put a barrier after it so that the unreachable\n+\t\t     code will be deleted.  */\n+\t\t  if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n+\t\t    emit_barrier_after (insn);\n+\n+\t\t  run_jump_opt_after_gcse = 1;\n+\n+\t\t  changed = 1;\n+\t\t  const_prop_count++;\n+\t\t  if (gcse_file != NULL)\n+\t\t    {\n+\t\t      fprintf (gcse_file, \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n+\t\t\t       regno, INSN_UID (insn));\n+\t\t      print_rtl (gcse_file, src);\n+\t\t      fprintf (gcse_file, \"\\n\");\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n       else if (GET_CODE (src) == REG\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER"}, {"sha": "4ffeeff3f2186f16e12ab7e6fda0c967303603be", "filename": "gcc/jump.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=e78d9500be1a9722b1936bab50706befa67ee6ca", "patch": "@@ -2076,7 +2076,9 @@ init_label_info (f)\n   return largest_uid;\n }\n \n-/* Delete insns following barriers, up to next label.  */\n+/* Delete insns following barriers, up to next label. \n+\n+   Also delete no-op jumps created by gcse.  */\n static void\n delete_barrier_successors (f)\n      rtx f;\n@@ -2098,6 +2100,14 @@ delete_barrier_successors (f)\n \t    }\n \t  /* INSN is now the code_label.  */\n \t}\n+      /* Also remove (set (pc) (pc)) insns which can be created by\n+\t gcse.  We eliminate such insns now to avoid having them\n+\t cause problems later.  */\n+      else if (GET_CODE (insn) == JUMP_INSN\n+\t       && SET_SRC (PATTERN (insn)) == pc_rtx\n+\t       && SET_DEST (PATTERN (insn)) == pc_rtx)\n+\tinsn = delete_insn (insn);\n+\n       else\n \tinsn = NEXT_INSN (insn);\n     }"}, {"sha": "7f4460f19346051fba8544b6611be38fc081f715", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e78d9500be1a9722b1936bab50706befa67ee6ca", "patch": "@@ -1452,7 +1452,7 @@ extern rtx expand_mult_highpart\t\tPROTO ((enum machine_mode, rtx,\n \n /* In gcse.c */\n #ifdef BUFSIZ\n-extern void gcse_main\t\t\tPROTO ((rtx, FILE *));\n+extern int gcse_main\t\t\tPROTO ((rtx, FILE *));\n #endif\n \n /* In global.c */"}, {"sha": "f9a4c204ad13592aa8c1850e1e803a34ba787a9e", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78d9500be1a9722b1936bab50706befa67ee6ca/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e78d9500be1a9722b1936bab50706befa67ee6ca", "patch": "@@ -3789,7 +3789,16 @@ rest_of_compilation (decl)\n       if (gcse_dump)\n \topen_dump_file (\".gcse\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n-      TIMEVAR (gcse_time, gcse_main (insns, rtl_dump_file));\n+      TIMEVAR (gcse_time, tem = gcse_main (insns, rtl_dump_file));\n+\n+      /* If gcse altered any jumps, rerun jump optimizations to clean\n+\t things up.  */\n+      if (tem)\n+\t{\n+\t  TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t\t\t     !JUMP_NOOP_MOVES,\n+\t\t\t\t\t     !JUMP_AFTER_REGSCAN));\n+        }\n \n       if (gcse_dump)\n \t{"}]}