{"sha": "136b5d77fc26a99e0fadc748e42c883dd3edf46f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM2YjVkNzdmYzI2YTk5ZTBmYWRjNzQ4ZTQyYzg4M2RkM2VkZjQ2Zg==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-02-11T19:09:03Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-02-11T19:09:03Z"}, "message": "BigInteger.java (BigInteger(String, int)): New constructor.\n\n\t* java/math/BigInteger.java(BigInteger(String, int)): New constructor.\n\t(BigInteger(String)): New constructor.\n\t(not): Rewritten using version from Kawa's BitOps class.\n\t(valueOf): New private methods from Kawa's BitOps class.\n\t(swappedOp): ditto.\n\t(bitOp): ditto.\n\t(setBitOp): ditto.\n\t(and): Implemented.\n\t(or): Implemented.\n\t(xor): Implemented.\n\t(andNot): Implemented.\n\t(clearBit): Implemented.\n\t(setBit): Implemented.\n\t(bitCount): Implemented.\n\t(toByteArray): Implemented.\n\nFrom-SVN: r31926", "tree": {"sha": "91472e391abccb6ea679d64866fff7f652720bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91472e391abccb6ea679d64866fff7f652720bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/136b5d77fc26a99e0fadc748e42c883dd3edf46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136b5d77fc26a99e0fadc748e42c883dd3edf46f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136b5d77fc26a99e0fadc748e42c883dd3edf46f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136b5d77fc26a99e0fadc748e42c883dd3edf46f/comments", "author": null, "committer": null, "parents": [{"sha": "9d381124d8598b49c13767f4c32f6460f7057a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d381124d8598b49c13767f4c32f6460f7057a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d381124d8598b49c13767f4c32f6460f7057a48"}], "stats": {"total": 442, "additions": 418, "deletions": 24}, "files": [{"sha": "436de4c3034517e1f4a476f96932710a1963f626", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136b5d77fc26a99e0fadc748e42c883dd3edf46f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136b5d77fc26a99e0fadc748e42c883dd3edf46f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=136b5d77fc26a99e0fadc748e42c883dd3edf46f", "patch": "@@ -1,3 +1,21 @@\n+2000-02-04  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/math/BigInteger.java(BigInteger(String, int)): New constructor.\n+\t(BigInteger(String)): New constructor.\n+\t(not): Rewritten using version from Kawa's BitOps class.\n+\t(valueOf): New private methods from Kawa's BitOps class.\n+\t(swappedOp): ditto.\n+\t(bitOp): ditto.\n+\t(setBitOp): ditto.\n+\t(and): Implemented.\n+\t(or): Implemented.\n+\t(xor): Implemented.\n+\t(andNot): Implemented.\n+\t(clearBit): Implemented.\n+\t(setBit): Implemented.\n+\t(bitCount): Implemented.\n+\t(toByteArray): Implemented.\n+\n 2000-02-11  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/io/File.java (nextValue): Now synchronized."}, {"sha": "e16a26e52e0a0a57f087276da4ed1ac23ccb4381", "filename": "libjava/java/math/BigInteger.java", "status": "modified", "additions": 400, "deletions": 24, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136b5d77fc26a99e0fadc748e42c883dd3edf46f/libjava%2Fjava%2Fmath%2FBigInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136b5d77fc26a99e0fadc748e42c883dd3edf46f/libjava%2Fjava%2Fmath%2FBigInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigInteger.java?ref=136b5d77fc26a99e0fadc748e42c883dd3edf46f", "patch": "@@ -21,7 +21,7 @@\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * \n- * Based primarily on IntNum.java by Per Bothner <per@bothner.com>\n+ * Based primarily on IntNum.java BitOps.java by Per Bothner <per@bothner.com>\n  * (found in Kawa 1.6.62).\n  *\n  * Status:  Believed complete and correct.\n@@ -70,6 +70,18 @@ private BigInteger(int value)\n     ival = value;\n   }\n \n+  public BigInteger(String val, int radix)\n+  {\n+    BigInteger result = valueOf(val, radix);\n+    this.ival = result.ival;\n+    this.words = result.words;\n+  }\n+\n+  public BigInteger(String val)\n+  {\n+    this(val, 10);\n+  }\n+\n   /* Create a new (non-shared) BigInteger, and initialize from a byte array. */\n   public BigInteger(byte[] val)\n   {\n@@ -184,7 +196,7 @@ private static int[] byteArrayToIntArray(byte[] bytes, int sign)\n       word = (word << 8) | (((int) bytes[bptr]) & 0xff);\n     words[--nwords] = word;\n \n-    // Elements remaining in byte[] is a  multiple of 4.\n+    // Elements remaining in byte[] are a multiple of 4.\n     while (nwords > 0)\n       words[--nwords] = bytes[bptr++] << 24 |\n \t\t\t(((int) bytes[bptr++]) & 0xff) << 16 |\n@@ -339,13 +351,13 @@ private BigInteger canonicalize()\n     return this;\n   }\n \n-  /** Add two ints, yielding an BigInteger. */\n+  /** Add two ints, yielding a BigInteger. */\n   private static final BigInteger add(int x, int y)\n   {\n     return BigInteger.make((long) x + (long) y);\n   }\n \n-  /** Add an BigInteger and an int, yielding a new BigInteger. */\n+  /** Add a BigInteger and an int, yielding a new BigInteger. */\n   private static BigInteger add(BigInteger x, int y)\n   {\n     if (x.words == null)\n@@ -1183,15 +1195,6 @@ private void setInvert()\n       }\n   }\n \n-  public BigInteger not()\n-  {\n-    BigInteger result = new BigInteger();\n-    result.ival = ival;\n-    result.words = words;\n-    result.setInvert();\n-    return result;\n-  }\n-\n   private void setShiftLeft(BigInteger x, int count)\n   {\n     int[] xwords;\n@@ -1419,6 +1422,51 @@ public boolean equals(Object obj)\n     return BigInteger.equals(this, (BigInteger) obj);\n   }\n \n+  private static BigInteger valueOf(String s, int radix)\n+       throws NumberFormatException\n+  {\n+    int len = s.length();\n+    // Testing (len < MPN.chars_per_word(radix)) would be more accurate,\n+    // but slightly more expensive, for little practical gain.\n+    if (len <= 15 && radix <= 16)\n+      return BigInteger.make(Long.parseLong(s, radix));\n+    \n+    int byte_len = 0;\n+    byte[] bytes = new byte[len];\n+    boolean negative = false;\n+    for (int i = 0;  i < len;  i++)\n+      {\n+\tchar ch = s.charAt(i);\n+\tif (ch == '-')\n+\t  negative = true;\n+\telse if (ch == '_' || (byte_len == 0 && (ch == ' ' || ch == '\\t')))\n+\t  continue;\n+\telse\n+\t  {\n+\t    int digit = Character.digit(ch, radix);\n+\t    if (digit < 0)\n+\t      break;\n+\t    bytes[byte_len++] = (byte) digit;\n+\t  }\n+      }\n+    return valueOf(bytes, byte_len, negative, radix);\n+  }\n+\n+  private static BigInteger valueOf(byte[] digits, int byte_len,\n+\t\t\t\t    boolean negative, int radix)\n+  {\n+    int chars_per_word = MPN.chars_per_word(radix);\n+    int[] words = new int[byte_len / chars_per_word + 1];\n+    int size = MPN.set_str(words, digits, byte_len, radix);\n+    if (size == 0)\n+      return ZERO;\n+    if (words[size-1] < 0)\n+      words[size++] = 0;\n+    if (negative)\n+      negate(words, words, size);\n+    return make(words, size);\n+  }\n+\n   public double doubleValue()\n   {\n     if (words == null)\n@@ -1632,21 +1680,307 @@ public int bitLength()\n       return MPN.intLength(words, ival);\n   }\n \n-/* TODO:\n+  public byte[] toByteArray()\n+  {\n+    // Determine number of bytes needed.  The method bitlength returns\n+    // the size without the sign bit, so add one bit for that and then\n+    // add 7 more to emulate the ceil function using integer math.\n+    byte[] bytes = new byte[(bitLength() + 1 + 7) / 8];\n+    int nbytes = bytes.length;\n \n-  public BigInteger(String val, int radix)\n+    int wptr = 0;\n+    int word;\n \n-  public BigInteger(String val)\n+    // Deal with words array until one word or less is left to process.\n+    // If BigInteger is an int, then it is in ival and nbytes will be <= 4.\n+    while (nbytes > 4)\n+      {\n+\tword = words[wptr++];\n+\tfor (int i = 4; i > 0; --i, word >>= 8)\n+          bytes[--nbytes] = (byte) word;\n+      }\n \n-  public BigInteger(int bitLength, int certainty, Random rnd)\n+    // Deal with the last few bytes.  If BigInteger is an int, use ival.\n+    word = (words == null) ? ival : words[wptr];\n+    for ( ; nbytes > 0; word >>= 8)\n+      bytes[--nbytes] = (byte) word;\n \n-  public BigInteger and(BigInteger val)\n+    return bytes;\n+  }\n \n-  public BigInteger or(BigInteger val)\n+  /** Return the boolean opcode (for bitOp) for swapped operands.\n+   * I.e. bitOp(swappedOp(op), x, y) == bitOp(op, y, x).\n+   */\n+  private static int swappedOp(int op)\n+  {\n+    return\n+    \"\\000\\001\\004\\005\\002\\003\\006\\007\\010\\011\\014\\015\\012\\013\\016\\017\"\n+    .charAt(op);\n+  }\n \n-  public BigInteger xor(BigInteger val\n+  /** Do one the the 16 possible bit-wise operations of two BigIntegers. */\n+  private static BigInteger bitOp(int op, BigInteger x, BigInteger y)\n+  {\n+    switch (op)\n+      {\n+        case 0:  return ZERO;\n+        case 1:  return x.and(y);\n+        case 3:  return x;\n+        case 5:  return y;\n+        case 15: return smallFixNums[-1 - minFixNum];\t// Returns -1.\n+      }\n+    BigInteger result = new BigInteger();\n+    setBitOp(result, op, x, y);\n+    return result.canonicalize();\n+  }\n+\n+  /** Do one the the 16 possible bit-wise operations of two BigIntegers. */\n+  private static void setBitOp(BigInteger result, int op,\n+\t\t\t       BigInteger x, BigInteger y)\n+  {\n+    if (y.words == null) ;\n+    else if (x.words == null || x.ival < y.ival)\n+      {\n+\tBigInteger temp = x;  x = y;  y = temp;\n+\top = swappedOp(op);\n+      }\n+    int xi;\n+    int yi;\n+    int xlen, ylen;\n+    if (y.words == null)\n+      {\n+\tyi = y.ival;\n+\tylen = 1;\n+      }\n+    else\n+      {\n+\tyi = y.words[0];\n+\tylen = y.ival;\n+      }\n+    if (x.words == null)\n+      {\n+\txi = x.ival;\n+\txlen = 1;\n+      }\n+    else\n+      {\n+\txi = x.words[0];\n+\txlen = x.ival;\n+      }\n+    if (xlen > 1)\n+      result.realloc(xlen);\n+    int[] w = result.words;\n+    int i = 0;\n+    // Code for how to handle the remainder of x.\n+    // 0:  Truncate to length of y.\n+    // 1:  Copy rest of x.\n+    // 2:  Invert rest of x.\n+    int finish = 0;\n+    int ni;\n+    switch (op)\n+      {\n+      case 0:  // clr\n+\tni = 0;\n+\tbreak;\n+      case 1: // and\n+\tfor (;;)\n+\t  {\n+\t    ni = xi & yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi < 0) finish = 1;\n+\tbreak;\n+      case 2: // andc2\n+\tfor (;;)\n+\t  {\n+\t    ni = xi & ~yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi >= 0) finish = 1;\n+\tbreak;\n+      case 3:  // copy x\n+\tni = xi;\n+\tfinish = 1;  // Copy rest\n+\tbreak;\n+      case 4: // andc1\n+\tfor (;;)\n+\t  {\n+\t    ni = ~xi & yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi < 0) finish = 2;\n+\tbreak;\n+      case 5: // copy y\n+\tfor (;;)\n+\t  {\n+\t    ni = yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tbreak;\n+      case 6:  // xor\n+\tfor (;;)\n+\t  {\n+\t    ni = xi ^ yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tfinish = yi < 0 ? 2 : 1;\n+\tbreak;\n+      case 7:  // ior\n+\tfor (;;)\n+\t  {\n+\t    ni = xi | yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi >= 0) finish = 1;\n+\tbreak;\n+      case 8:  // nor\n+\tfor (;;)\n+\t  {\n+\t    ni = ~(xi | yi);\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi >= 0)  finish = 2;\n+\tbreak;\n+      case 9:  // eqv [exclusive nor]\n+\tfor (;;)\n+\t  {\n+\t    ni = ~(xi ^ yi);\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tfinish = yi >= 0 ? 2 : 1;\n+\tbreak;\n+      case 10:  // c2\n+\tfor (;;)\n+\t  {\n+\t    ni = ~yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tbreak;\n+      case 11:  // orc2\n+\tfor (;;)\n+\t  {\n+\t    ni = xi | ~yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi < 0)  finish = 1;\n+\tbreak;\n+      case 12:  // c1\n+\tni = ~xi;\n+\tfinish = 2;\n+\tbreak;\n+      case 13:  // orc1\n+\tfor (;;)\n+\t  {\n+\t    ni = ~xi | yi;\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi >= 0) finish = 2;\n+\tbreak;\n+      case 14:  // nand\n+\tfor (;;)\n+\t  {\n+\t    ni = ~(xi & yi);\n+\t    if (i+1 >= ylen) break;\n+\t    w[i++] = ni;  xi = x.words[i];  yi = y.words[i];\n+\t  }\n+\tif (yi < 0) finish = 2;\n+\tbreak;\n+      default:\n+      case 15:  // set\n+\tni = -1;\n+\tbreak;\n+      }\n+    // Here i==ylen-1; w[0]..w[i-1] have the correct result;\n+    // and ni contains the correct result for w[i+1].\n+    if (i+1 == xlen)\n+      finish = 0;\n+    switch (finish)\n+      {\n+      case 0:\n+\tif (i == 0 && w == null)\n+\t  {\n+\t    result.ival = ni;\n+\t    return;\n+\t  }\n+\tw[i++] = ni;\n+\tbreak;\n+      case 1:  w[i] = ni;  while (++i < xlen)  w[i] = x.words[i];  break;\n+      case 2:  w[i] = ni;  while (++i < xlen)  w[i] = ~x.words[i];  break;\n+      }\n+    result.ival = i;\n+  }\n+\n+  /** Return the logical (bit-wise) \"and\" of a BigInteger and an int. */\n+  private static BigInteger and(BigInteger x, int y)\n+  {\n+    if (x.words == null)\n+      return BigInteger.make(x.ival & y);\n+    if (y >= 0)\n+      return BigInteger.make(x.words[0] & y);\n+    int len = x.ival;\n+    int[] words = new int[len];\n+    words[0] = x.words[0] & y;\n+    while (--len > 0)\n+      words[len] = x.words[len];\n+    return BigInteger.make(words, x.ival);\n+  }\n+\n+  /** Return the logical (bit-wise) \"and\" of two BigIntegers. */\n+  public BigInteger and(BigInteger y)\n+  {\n+    if (y.words == null)\n+      return and(this, y.ival);\n+    else if (words == null)\n+      return and(y, ival);\n+\n+    BigInteger x = this;\n+    if (ival < y.ival)\n+      {\n+        BigInteger temp = this;  x = y;  y = temp;\n+      }\n+    int i;\n+    int len = y.isNegative() ? x.ival : y.ival;\n+    int[] words = new int[len];\n+    for (i = 0;  i < y.ival;  i++)\n+      words[i] = x.words[i] & y.words[i];\n+    for ( ; i < len;  i++)\n+      words[i] = x.words[i];\n+    return BigInteger.make(words, len);\n+  }\n+\n+  /** Return the logical (bit-wise) \"(inclusive) or\" of two BigIntegers. */\n+  public BigInteger or(BigInteger y)\n+  {\n+    return bitOp(7, this, y);\n+  }\n+\n+  /** Return the logical (bit-wise) \"exclusive or\" of two BigIntegers. */\n+  public BigInteger xor(BigInteger y)\n+  {\n+    return bitOp(6, this, y);\n+  }\n+\n+  /** Return the logical (bit-wise) negation of a BigInteger. */\n+  public BigInteger not()\n+  {\n+    return bitOp(12, this, ZERO);\n+  }\n \n   public BigInteger andNot(BigInteger val)\n+  {\n+    return and(val.not());\n+  }\n \n   public BigInteger clearBit(int n)\n   {\n@@ -1664,20 +1998,62 @@ public BigInteger setBit(int n)\n     return or(ONE.shiftLeft(n));\n   }\n \n+  // bit4count[I] is number of '1' bits in I.\n+  private static final byte[] bit4_count = { 0, 1, 1, 2,  1, 2, 2, 3,\n+\t\t\t\t\t     1, 2, 2, 3,  2, 3, 3, 4};\n+\n+  private static int bitCount(int i)\n+  {\n+    int count = 0;\n+    while (i != 0)\n+      {\n+\tcount += bit4_count[i & 15];\n+\ti >>>= 4;\n+      }\n+    return count;\n+  }\n+\n+  private static int bitCount(int[] x, int len)\n+  {\n+    int count = 0;\n+    while (--len >= 0)\n+      count += bitCount(x[len]);\n+    return count;\n+  }\n+\n+  /** Count one bits in a BigInteger.\n+   * If argument is negative, count zero bits instead. */\n+  public int bitCount()\n+  {\n+    int i, x_len;\n+    int[] x_words = words;\n+    if (x_words == null)\n+      {\n+\tx_len = 1;\n+\ti = bitCount(ival);\n+      }\n+    else\n+      {\n+\tx_len = ival;\n+\ti = bitCount(x_words, x_len);\n+      }\n+    return isNegative() ? x_len * 32 - i : i;\n+  }\n+\n+/* TODO:\n+\n+  public BigInteger(int bitLength, int certainty, Random rnd)\n+\n   public boolean testBit(int n)\n \n   public BigInteger flipBit(int n)\n \n   public int getLowestSetBit()\n \n-  public int bitCount()\n-\n   public boolean isProbablePrime(int certainty)\n \n   public BigInteger min(BigInteger val)\n \n   public BigInteger max(BigInteger val)\n-\n-  public byte[] toByteArray()\n */\n }"}]}