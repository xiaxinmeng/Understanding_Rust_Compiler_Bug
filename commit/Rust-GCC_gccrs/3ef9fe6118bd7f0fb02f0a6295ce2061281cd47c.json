{"sha": "3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VmOWZlNjExOGJkN2YwZmIwMmYwYTYyOTVjZTIwNjEyODFjZDQ3Yw==", "commit": {"author": {"name": "Branko Cibej", "email": "branko.cibej@hermes.si", "date": "2000-06-19T19:58:53Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-19T19:58:53Z"}, "message": "20_utilities: New directory.\n\n\n2000-06-19  Branko Cibej  <branko.cibej@hermes.si>\n\n        * testsuite/20_utilities: New directory.\n        * testsuite/20_utilities/auto_ptr.cc: New file.\n\nFrom-SVN: r34599", "tree": {"sha": "0b92d86de0399030958c1bfe3157db8fe0cbec4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b92d86de0399030958c1bfe3157db8fe0cbec4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c/comments", "author": null, "committer": null, "parents": [{"sha": "437fa02616ad72dca7eb2ad9ced34bccb849aab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437fa02616ad72dca7eb2ad9ced34bccb849aab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437fa02616ad72dca7eb2ad9ced34bccb849aab0"}], "stats": {"total": 288, "additions": 288, "deletions": 0}, "files": [{"sha": "53edd5565f87439689fd60e50b6712024b7d0f2b", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr.cc", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc?ref=3ef9fe6118bd7f0fb02f0a6295ce2061281cd47c", "patch": "@@ -0,0 +1,288 @@\n+// Copyright (C) 2000 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.5 Template class auto_ptr [lib.auto.ptr]\n+\n+#include <memory>\n+#ifdef DEBUG_ASSERT\n+#  include <assert.h>\n+#endif\n+\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+\n+// 20.4.5.1 auto_ptr constructors [lib.auto.ptr.cons]\n+\n+// Construction from pointer\n+bool test01()\n+{\n+  reset_count_struct reset;\n+  bool test = true;\n+\n+  std::auto_ptr<A> A_default;\n+  test &= A_default.get() == 0;\n+  test &= A::ctor_count == 0;\n+  test &= A::dtor_count == 0;\n+  test &= B::ctor_count == 0;\n+  test &= B::dtor_count == 0;\n+\n+  std::auto_ptr<A> A_from_A(new A);\n+  test &= A_from_A.get() != 0;\n+  test &= A::ctor_count == 1;\n+  test &= A::dtor_count == 0;\n+  test &= B::ctor_count == 0;\n+  test &= B::dtor_count == 0;\n+\n+  std::auto_ptr<A> A_from_B(new B);\n+  test &= A_from_B.get() != 0;\n+  test &= A::ctor_count == 2;\n+  test &= A::dtor_count == 0;\n+  test &= B::ctor_count == 1;\n+  test &= B::dtor_count == 0;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+// Construction from std::auto_ptr\n+bool test02()\n+{\n+  reset_count_struct reset;\n+  bool test = true;\n+\n+  std::auto_ptr<A> A_from_A(new A);\n+  std::auto_ptr<B> B_from_B(new B);\n+\n+  std::auto_ptr<A> A_from_ptr_A(A_from_A);\n+  std::auto_ptr<A> A_from_ptr_B(B_from_B);\n+  test &= A_from_A.get() == 0;\n+  test &= B_from_B.get() == 0;\n+  test &= A_from_ptr_A.get() != 0;\n+  test &= A_from_ptr_B.get() != 0;\n+  test &= A::ctor_count == 2;\n+  test &= A::dtor_count == 0;\n+  test &= B::ctor_count == 1;\n+  test &= B::dtor_count == 0;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+// Assignment from std::auto_ptr\n+bool test03()\n+{\n+  reset_count_struct reset;\n+  bool test = true;\n+\n+  std::auto_ptr<A> A_from_ptr_A;\n+  std::auto_ptr<A> A_from_ptr_B;\n+  std::auto_ptr<A> A_from_A(new A);\n+  std::auto_ptr<B> B_from_B(new B);\n+\n+  A_from_ptr_A = A_from_A;\n+  A_from_ptr_B = B_from_B;\n+  test &= A_from_A.get() == 0;\n+  test &= B_from_B.get() == 0;\n+  test &= A_from_ptr_A.get() != 0;\n+  test &= A_from_ptr_B.get() != 0;\n+  test &= A::ctor_count == 2;\n+  test &= A::dtor_count == 0;\n+  test &= B::ctor_count == 1;\n+  test &= B::dtor_count == 0;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+// Destruction\n+bool test04()\n+{\n+  reset_count_struct reset;\n+  bool test = true;\n+\n+  {/*lifetine scope*/\n+    std::auto_ptr<A> A_from_A(new A);\n+    std::auto_ptr<A> A_from_B(new B);\n+    std::auto_ptr<B> B_from_B(new B);\n+  }/*destructors called here*/\n+\n+  test &= A::ctor_count == 3;\n+  test &= A::dtor_count == 3;\n+  test &= B::ctor_count == 2;\n+  test &= B::dtor_count == 2;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+// Class member construction/destruction\n+template <typename T>\n+class pimpl\n+{\n+public:\n+  pimpl() : p_impl(new T) {}\n+private:\n+  std::auto_ptr<T> p_impl;\n+};\n+\n+bool test05()\n+{\n+  bool test = true;\n+  reset_count_struct reset;\n+\n+  pimpl<A>();\n+  pimpl<B>();\n+  test &= A::ctor_count == 2;\n+  test &= A::dtor_count == 2;\n+  test &= B::ctor_count == 1;\n+  test &= B::dtor_count == 1;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+\n+// 20.4.5.2 auto_ptr members [lib.auto.ptr.members]\n+\n+// Member access\n+bool test06()\n+{\n+  reset_count_struct reset;\n+  bool test = true;\n+\n+  std::auto_ptr<A> A_from_A(new A);\n+  std::auto_ptr<A> A_from_A_ptr(A_from_A.release());\n+  test &= A_from_A.get() == 0;\n+  test &= A_from_A_ptr.get() != 0;\n+  test &= A_from_A->ctor_count == 1;\n+  test &= (*A_from_A).dtor_count == 0;\n+\n+  A* A_ptr = A_from_A_ptr.get();\n+\n+  A_from_A_ptr.reset(A_ptr);\n+  test &= A_from_A_ptr.get() == A_ptr;\n+  test &= A_from_A_ptr->ctor_count == 1;\n+  test &= (*A_from_A_ptr).dtor_count == 0;\n+\n+  A_from_A_ptr.reset(new A);\n+  test &= A_from_A_ptr.get() != A_ptr;\n+  test &= A_from_A_ptr->ctor_count == 2;\n+  test &= (*A_from_A_ptr).dtor_count == 1;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+\n+// 20.4.5.3 auto_ptr conversions [lib.auto.ptr.conv]\n+\n+// Parameters and return values\n+template <typename T>\n+static std::auto_ptr<T> source()\n+{\n+  return std::auto_ptr<T>(new T);\n+}\n+\n+template <typename T>\n+static void drain(std::auto_ptr<T>)\n+{}\n+\n+bool test07()\n+{\n+  bool test = true;\n+  reset_count_struct reset;\n+\n+  drain(source<A>());\n+  drain<A>(source<B>());\n+  drain(source<B>());\n+  test &= A::ctor_count == 3;\n+  test &= A::dtor_count == 3;\n+  test &= B::ctor_count == 2;\n+  test &= B::dtor_count == 2;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+\n+int main()\n+{\n+  bool test = true;\n+\n+  test &= test01();\n+  test &= test02();\n+  test &= test03();\n+  test &= test04();\n+  test &= test05();\n+  test &= test06();\n+  test &= test07();\n+\n+  return test ? 0 : 1;\n+}"}]}