{"sha": "83f564f76ff896424c3ac8d6cde45867e9c083c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmNTY0Zjc2ZmY4OTY0MjRjM2FjOGQ2Y2RlNDU4NjdlOWMwODNjMA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-06T10:07:28Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-06T10:07:28Z"}, "message": "2003-05-06  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/DataOutputStream.java\n\t(write): Renamed argument to \"value\", merged documentation from\n\tclasspath.\n\t(writeBoolean): Likewise.\n\t(writeByte): Likewise.\n\t(writeShort): Likewise.\n\t(writeChar): Likewise.\n\t(writeInt): Likewise.\n\t(writeLong): Likewise.\n\t(writeFloat): Likewise.\n\t(writeDouble): Likewise.\n\t(writeBytes): Likewise.\n\t(writeChars): Likewise.\n\t(writeUTF): Likewise.\n\t* java/io/File.java\n\t(performDelete): Added documentation.\n\t(performList): Likewise.\n\t(performMkdir): Likewise.\n\t(performSetReadOnly): Likewise.\n\t(performRenameTo): Likewise.\n\t(performSetLastModified): Likewise.\n\t(delete): Made it sychronized.\n\t(renameTo): Made it sychronized.\n\t(equals): Reformatted.\n\t(isHidden): Likewise.\n\t(listFiles): Likewise.\n\t(setReadOnly): Likewise.\n\t(listRoots): Likewise.\n\t(setLastModified): Likewise.\n\t(checkRead): Likewise.\n\t(checkWrite): Likewise.\n\t* java/io/FileInputStream.java\n\t(skip): Made it sychronized, merged from classpath.\n\t* java/io/FileOutputStream.java\n\t(write): Merged from classpath.\n\t* java/io/InputStreamReader.java:\n\t(InputStreamReader): Merged documentation from classpath.\n\nFrom-SVN: r66520", "tree": {"sha": "451228bc753694ff53382b99623580cc39ef00df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/451228bc753694ff53382b99623580cc39ef00df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83f564f76ff896424c3ac8d6cde45867e9c083c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f564f76ff896424c3ac8d6cde45867e9c083c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f564f76ff896424c3ac8d6cde45867e9c083c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f564f76ff896424c3ac8d6cde45867e9c083c0/comments", "author": null, "committer": null, "parents": [{"sha": "c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e3960284ce035ac43af2525f8ee3fed15ab9b3"}], "stats": {"total": 402, "additions": 304, "deletions": 98}, "files": [{"sha": "434980a9b678d23c026bc3f844579c35b5a2bcb0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -1,3 +1,43 @@\n+2003-05-06  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/DataOutputStream.java\n+\t(write): Renamed argument to \"value\", merged documentation from\n+\tclasspath.\n+\t(writeBoolean): Likewise.\n+\t(writeByte): Likewise.\n+\t(writeShort): Likewise.\n+\t(writeChar): Likewise.\n+\t(writeInt): Likewise.\n+\t(writeLong): Likewise.\n+\t(writeFloat): Likewise.\n+\t(writeDouble): Likewise.\n+\t(writeBytes): Likewise.\n+\t(writeChars): Likewise.\n+\t(writeUTF): Likewise.\n+\t* java/io/File.java\n+\t(performDelete): Added documentation.\n+\t(performList): Likewise.\n+\t(performMkdir): Likewise.\n+\t(performSetReadOnly): Likewise.\n+\t(performRenameTo): Likewise.\n+\t(performSetLastModified): Likewise.\n+\t(delete): Made it sychronized.\n+\t(renameTo): Made it sychronized.\n+\t(equals): Reformatted.\n+\t(isHidden): Likewise.\n+\t(listFiles): Likewise.\n+\t(setReadOnly): Likewise.\n+\t(listRoots): Likewise.\n+\t(setLastModified): Likewise.\n+\t(checkRead): Likewise.\n+\t(checkWrite): Likewise.\n+\t* java/io/FileInputStream.java\n+\t(skip): Made it sychronized, merged from classpath.\n+\t* java/io/FileOutputStream.java\n+\t(write): Merged from classpath.\n+\t* java/io/InputStreamReader.java:\n+\t(InputStreamReader): Merged documentation from classpath.\n+\n 2003-05-05  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/NetworkInterface.java"}, {"sha": "d5f76ff812468f1b6a80238b94b3e23df35a7b9d", "filename": "libjava/java/io/DataOutputStream.java", "status": "modified", "additions": 149, "deletions": 67, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FDataOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FDataOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutputStream.java?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -101,13 +101,13 @@ public final int size ()\n    * This method writes the specified byte (passed as an <code>int</code>)\n    * to the underlying output stream.\n    *\n-   * @param b The byte to write, passed as an <code>int</code>.\n+   * @param value The <code>byte</code> to write, passed as an <code>int</code>.\n    *\n    * @exception IOException If an error occurs.\n    */\n-  public synchronized void write (int b) throws IOException\n+  public synchronized void write (int value) throws IOException\n   {\n-    out.write(b);\n+    out.write (value);\n     ++written;\n   }\n \n@@ -130,116 +130,185 @@ public synchronized void write (byte[] buf, int offset, int len)\n   }\n \n   /**\n-   * This method writes a Java <code>boolean</code> to the underlying output \n-   * stream. For a value of <code>true</code>, 1 is written to the stream.\n-   * For a value of <code>false</code>, 0 is written.\n+   * This method writes a Java boolean value to an output stream.  If\n+   * <code>value</code> is <code>true</code>, a byte with the value of\n+   * 1 will be written, otherwise a byte with the value of 0 will be\n+   * written.\n    *\n-   * @param b The <code>boolean</code> value to write to the stream\n+   * The value written can be read using the <code>readBoolean</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>boolean</code> value to write to the stream\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readBoolean\n    */\n-  public final void writeBoolean (boolean v) throws IOException\n+  public final void writeBoolean (boolean value) throws IOException\n   {\n-    write (v ? 1 : 0);\n+    write (value ? 1 : 0);\n   }\n \n   /**\n-   * This method writes a Java <code>byte</code> value to the underlying\n-   * output stream.\n+   * This method writes a Java byte value to an output stream.  The\n+   * byte to be written will be in the lowest 8 bits of the\n+   * <code>int</code> value passed.\n+   *\n+   * The value written can be read using the <code>readByte</code> or\n+   * <code>readUnsignedByte</code> methods in <code>DataInput</code>.\n    *\n-   * @param b The <code>byte</code> to write to the stream, passed as \n+   * @param value The <code>byte</code> to write to the stream, passed as \n    * the low eight bits of an <code>int</code>.\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readByte\n+   * @see DataInput#readUnsignedByte\n    */\n-  public final void writeByte (int v) throws IOException\n+  public final void writeByte (int value) throws IOException\n   {\n-    write (v & 0xff);\n+    write (value & 0xff);\n   }\n \n   /**\n-   * This method writes a Java <code>short</code> to the stream, high byte\n-   * first.  This method requires two bytes to encode the value.\n+   * This method writes a Java short value to an output stream.  The\n+   * char to be written will be in the lowest 16 bits of the <code>int</code>\n+   * value passed.  These bytes will be written \"big endian\".  That is,\n+   * with the high byte written first in the following manner:\n+   * <p>\n+   * <code>byte0 = (byte)((value & 0xFF00) >> 8);<br>\n+   * byte1 = (byte)(value & 0x00FF);</code>\n+   * <p>\n+   *\n+   * The value written can be read using the <code>readShort</code> and\n+   * <code>readUnsignedShort</code> methods in <code>DataInput</code>.\n    *\n-   * @param s The <code>short</code> value to write to the stream,\n+   * @param value The <code>short</code> value to write to the stream,\n    * passed as an <code>int</code>.\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readShort\n+   * @see DataInput#readUnsignedShort\n    */\n-  public final void writeShort (int v) throws IOException\n+  public final void writeShort (int value) throws IOException\n   {\n-    write ((byte) (0xff & (v >> 8)));\n-    write ((byte) (0xff & v));\n+    write ((byte) (0xff & (value >> 8)));\n+    write ((byte) (0xff & value));\n   }\n \n   /**\n-   * This method writes a single <code>char</code> value to the stream,\n-   * high byte first.\n+   * This method writes a Java char value to an output stream.  The\n+   * char to be written will be in the lowest 16 bits of the <code>int</code>\n+   * value passed.  These bytes will be written \"big endian\".  That is,\n+   * with the high byte written first in the following manner:\n+   * <p>\n+   * <code>byte0 = (byte)((value & 0xFF00) >> 8);<br>\n+   * byte1 = (byte)(value & 0x00FF);</code>\n+   * <p>\n+   *\n+   * The value written can be read using the <code>readChar</code>\n+   * method in <code>DataInput</code>.\n    *\n-   * @param c The <code>char</code> value to write, \n+   * @param value The <code>char</code> value to write, \n    * passed as an <code>int</code>.\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readChar\n    */\n-  public final void writeChar (int v) throws IOException\n+  public final void writeChar (int value) throws IOException\n   {\n-    write ((byte) (0xff & (v >> 8)));\n-    write ((byte) (0xff & v));\n+    write ((byte) (0xff & (value >> 8)));\n+    write ((byte) (0xff & value));\n   }\n \n   /**\n-   * This method writes a Java <code>int</code> to the stream, high bytes\n-   * first.  This method requires four bytes to encode the value.\n+   * This method writes a Java int value to an output stream.  The 4 bytes\n+   * of the passed value will be written \"big endian\".  That is, with\n+   * the high byte written first in the following manner:\n+   * <p>\n+   * <code>byte0 = (byte)((value & 0xFF000000) >> 24);<br>\n+   * byte1 = (byte)((value & 0x00FF0000) >> 16);<br>\n+   * byte2 = (byte)((value & 0x0000FF00) >> 8);<br>\n+   * byte3 = (byte)(value & 0x000000FF);</code>\n+   * <p>\n    *\n-   * @param i The <code>int</code> value to write to the stream.\n+   * The value written can be read using the <code>readInt</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>int</code> value to write to the stream\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readInt\n    */\n-  public final void writeInt (int v) throws IOException\n+  public final void writeInt (int value) throws IOException\n   {\n-    write ((byte) (0xff & (v >> 24)));\n-    write ((byte) (0xff & (v >> 16)));\n-    write ((byte) (0xff & (v >>  8)));\n-    write ((byte) (0xff & v));\n+    write ((byte) (0xff & (value >> 24)));\n+    write ((byte) (0xff & (value >> 16)));\n+    write ((byte) (0xff & (value >>  8)));\n+    write ((byte) (0xff & value));\n   }\n \n   /**\n-   * This method writes a Java <code>long</code> to the stream, high bytes\n-   * first.  This method requires eight bytes to encode the value.\n+   * This method writes a Java long value to an output stream.  The 8 bytes\n+   * of the passed value will be written \"big endian\".  That is, with\n+   * the high byte written first in the following manner:\n+   * <p>\n+   * <code>byte0 = (byte)((value & 0xFF00000000000000L) >> 56);<br>\n+   * byte1 = (byte)((value & 0x00FF000000000000L) >> 48);<br>\n+   * byte2 = (byte)((value & 0x0000FF0000000000L) >> 40);<br>\n+   * byte3 = (byte)((value & 0x000000FF00000000L) >> 32);<br>\n+   * byte4 = (byte)((value & 0x00000000FF000000L) >> 24);<br>\n+   * byte5 = (byte)((value & 0x0000000000FF0000L) >> 16);<br>\n+   * byte6 = (byte)((value & 0x000000000000FF00L) >> 8);<br>\n+   * byte7 = (byte)(value & 0x00000000000000FFL);</code>\n+   * <p>\n    *\n-   * @param l The <code>long</code> value to write to the stream.\n+   * The value written can be read using the <code>readLong</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>long</code> value to write to the stream\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readLong\n    */\n-  public final void writeLong (long v) throws IOException\n+  public final void writeLong (long value) throws IOException\n   {\n-    write ((byte) (0xff & (v >> 56)));\n-    write ((byte) (0xff & (v >> 48)));\n-    write ((byte) (0xff & (v >> 40)));\n-    write ((byte) (0xff & (v >> 32)));\n-    write ((byte) (0xff & (v >> 24)));\n-    write ((byte) (0xff & (v >> 16)));\n-    write ((byte) (0xff & (v >>  8)));\n-    write ((byte) (0xff & v));\n+    write ((byte) (0xff & (value >> 56)));\n+    write ((byte) (0xff & (value>> 48)));\n+    write ((byte) (0xff & (value>> 40)));\n+    write ((byte) (0xff & (value>> 32)));\n+    write ((byte) (0xff & (value>> 24)));\n+    write ((byte) (0xff & (value>> 16)));\n+    write ((byte) (0xff & (value>>  8)));\n+    write ((byte) (0xff & value));\n   }\n \n   /**\n    * This method writes a Java <code>float</code> value to the stream.  This\n-   * value is written by first calling the method \n+   * value is written by first calling the method\n    * <code>Float.floatToIntBits</code>\n    * to retrieve an <code>int</code> representing the floating point number,\n    * then writing this <code>int</code> value to the stream exactly the same\n    * as the <code>writeInt()</code> method does.\n    *\n-   * @param f The floating point number to write to the stream.\n+   * The value written can be read using the <code>readFloat</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>float</code> value to write to the stream\n    *\n    * @exception IOException If an error occurs\n    *\n    * @see writeInt\n+   * @see DataInput#readFloat\n+   * @see Float#floatToIntBits\n    */\n-  public final void writeFloat (float v) throws IOException\n+  public final void writeFloat (float value) throws IOException\n   {\n-    writeInt (Float.floatToIntBits(v));\n+    writeInt (Float.floatToIntBits (value));\n   }\n \n   /**\n@@ -250,49 +319,57 @@ public final void writeFloat (float v) throws IOException\n    * then writing this <code>long</code> value to the stream exactly the same\n    * as the <code>writeLong()</code> method does.\n    *\n-   * @param d The double precision floating point number to write to \n-   * the stream.\n+   * The value written can be read using the <code>readDouble</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>double</code> value to write to the stream\n    *\n    * @exception IOException If an error occurs\n    *\n    * @see writeLong\n+   * @see DataInput#readDouble\n+   * @see Double#doubleToLongBits\n    */\n-  public final void writeDouble (double v) throws IOException\n+  public final void writeDouble (double value) throws IOException\n   {\n-    writeLong (Double.doubleToLongBits(v));\n+    writeLong (Double.doubleToLongBits (value));\n   }\n \n   /**\n    * This method writes all the bytes in a <code>String</code> out to the\n    * stream.  One byte is written for each character in the\n    * <code>String</code>.\n-   * The high eight bits of each character are discarded.\n+   * The high eight bits of each character are discarded, thus this\n+   * method is inappropriate for completely representing Unicode characters.\n    *\n-   * @param s The <code>String</code> to write to the stream\n+   * @param value The <code>String</code> to write to the stream\n    *\n    * @exception IOException If an error occurs\n    */\n-  public final void writeBytes (String s) throws IOException\n+  public final void writeBytes (String value) throws IOException\n   {\n-    int len = s.length();\n+    int len = value.length();\n     for (int i = 0; i < len; ++i)\n-      writeByte (s.charAt(i));\n+      writeByte (value.charAt(i));\n   }\n \n   /**\n-   * This method writes all the characters in a <code>String</code> to the\n-   * stream.  There will be two bytes for each character value.  The high\n-   * byte of the character will be written first.\n+   * This method writes all the characters of a <code>String</code> to an\n+   * output stream as an array of <code>char</code>'s. Each character\n+   * is written using the method specified in the <code>writeChar</code>\n+   * method.\n    *\n-   * @param s The <code>String</code> to write to the stream.\n+   * @param value The <code>String</code> to write to the stream\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see writeChar\n    */\n-  public final void writeChars (String s) throws IOException\n+  public final void writeChars (String value) throws IOException\n   {\n-    int len = s.length();\n+    int len = value.length();\n     for (int i = 0; i < len; ++i)\n-      writeChar (s.charAt(i));\n+      writeChar (value.charAt(i));\n   }\n \n   /**\n@@ -318,9 +395,14 @@ public final void writeChars (String s) throws IOException\n    * character value are stored in bits 0-5 of byte three, with the high bits\n    * of that byte set to \"10\".\n    *\n-   * @param s The <code>String</code> to write to the output in UTF format\n+   * The value written can be read using the <code>readUTF</code>\n+   * method in <code>DataInput</code>.\n+   *\n+   * @param value The <code>String</code> to write to the output in UTF format\n    *\n    * @exception IOException If an error occurs\n+   *\n+   * @see DataInput#readUTF\n    */\n   public final void writeUTF (String s) throws IOException\n   {"}, {"sha": "4872076108e73de183f1a0cd283aad6e04b3e05c", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -199,7 +199,10 @@ public boolean createNewFile() throws IOException\n     checkWrite();\n     return performCreate();\n   }\n-  \n+ \n+  /*\n+   * This native method handles the actual deleting of the file\n+   */\n   private native boolean performDelete ();\n \n   /**\n@@ -211,12 +214,13 @@ public boolean createNewFile() throws IOException\n    *\n    * @exception SecurityException If deleting of the file is not allowed\n    */\n-  public boolean delete ()\n+  public synchronized boolean delete ()\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    String name = path;\n+    SecurityManager s = System.getSecurityManager ();\n+    \n     if (s != null)\n-      s.checkDelete(path);\n+      s.checkDelete (path);\n+    \n     return performDelete ();\n   }\n \n@@ -239,11 +243,12 @@ public boolean equals (Object obj)\n   {\n     if (! (obj instanceof File))\n       return false;\n+    \n     File other = (File) obj;\n     if (caseSensitive)\n-      return (path.equals(other.path));\n+      return path.equals(other.path);\n     else\n-      return (path.equalsIgnoreCase(other.path));      \n+      return path.equalsIgnoreCase(other.path);\n   }\n \n   /**\n@@ -663,7 +668,7 @@ public boolean isFile ()\n    *\n    * @since 1.2\n    */\n-  public boolean isHidden()\n+  public boolean isHidden ()\n   {\n     checkRead();\n     return _stat (ISHIDDEN);\n@@ -701,6 +706,11 @@ public long length ()\n     checkRead();\n     return attr (LENGTH);\n   }\n+\n+  /*\n+   * This native function actually produces the list of file in this\n+   * directory\n+   */\n     \n   private final native Object[] performList (FilenameFilter filter,\n \t\t\t\t\t     FileFilter fileFilter,\n@@ -781,7 +791,7 @@ public String[] list ()\n    *\n    * @since 1.2\n    */\n-  public File[] listFiles()\n+  public File[] listFiles ()\n   {\n     checkRead();\n     return (File[]) performList (null, null, File.class);\n@@ -811,12 +821,12 @@ public File[] listFiles()\n    *\n    * @since 1.2\n    */\n-  public File[] listFiles(FilenameFilter filter)\n+  public File[] listFiles (FilenameFilter filter)\n   {\n     checkRead();\n     return (File[]) performList (filter, null, File.class);\n   }\n-  \n+\n   /**\n    * This method returns an array of <code>File</code> objects representing\n    * all the files in the directory represented by this object. If this\n@@ -841,7 +851,7 @@ public File[] listFiles(FilenameFilter filter)\n    *\n    * @since 1.2\n    */\n-  public File[] listFiles(FileFilter filter)\n+  public File[] listFiles (FileFilter filter)\n   {\n     checkRead();\n     return (File[]) performList (null, filter, File.class);\n@@ -880,6 +890,9 @@ public URL toURL () throws MalformedURLException\n \t\t      + (isDirectory() ? \"/\" : \"\"));\n   }\n \n+  /*\n+   * This native method actually creates the directory\n+   */\n   private final native boolean performMkdir ();\n \n   /**\n@@ -1025,6 +1038,9 @@ public static File createTempFile (String prefix, String suffix,\n     throw new IOException (\"cannot create temporary file\");\n   }\n \n+  /*\n+   * This native method sets the permissions to make the file read only.\n+   */\n   private native boolean performSetReadOnly();\n \n   /**\n@@ -1041,7 +1057,7 @@ public static File createTempFile (String prefix, String suffix,\n    *\n    * @since 1.2\n    */\n-  public boolean setReadOnly()\n+  public boolean setReadOnly ()\n   {\n     checkWrite();\n     return performSetReadOnly();\n@@ -1060,7 +1076,7 @@ public boolean setReadOnly()\n    *\n    * @since 1.2\n    */\n-  public static File[] listRoots()\n+  public static File[] listRoots ()\n   {\n     File[] roots = performListRoots();\n     \n@@ -1180,6 +1196,9 @@ public int compareTo(Object o)\n     return compareTo (other);\n   }\n \n+  /*\n+   * This native method actually performs the rename.\n+   */\n   private native boolean performRenameTo (File dest);\n \n   /**\n@@ -1194,7 +1213,7 @@ public int compareTo(Object o)\n    * @exception SecurityException If write access is not allowed to the \n    * file by the <code>SecurityMananger</code>.\n    */\n-  public boolean renameTo (File dest)\n+  public synchronized boolean renameTo (File dest)\n   {\n     SecurityManager s = System.getSecurityManager();\n     String sname = getName();\n@@ -1207,6 +1226,9 @@ public boolean renameTo (File dest)\n     return performRenameTo (dest);\n   }\n \n+  /*\n+   * This method does the actual setting of the modification time.\n+   */\n   private native boolean performSetLastModified(long time);\n  \n   /**\n@@ -1225,24 +1247,28 @@ public boolean renameTo (File dest)\n    *\n    * @since 1.2\n    */\n-  public boolean setLastModified(long time)\n+  public boolean setLastModified (long time) \n   {\n     checkWrite();\n     return performSetLastModified(time);\n   }\n \n   private void checkWrite ()\n   {\n-    SecurityManager s = System.getSecurityManager();\n+    // Check the SecurityManager\n+    SecurityManager s = System.getSecurityManager ();\n+    \n     if (s != null)\n-      s.checkWrite(path);\n+      s.checkWrite (path);\n   }\n \n   private void checkRead ()\n   {\n-    SecurityManager s = System.getSecurityManager();\n+    // Check the SecurityManager\n+    SecurityManager s = System.getSecurityManager ();\n+    \n     if (s != null)\n-      s.checkRead(path);\n+      s.checkRead (path);\n   }\n \n   /** \n@@ -1254,6 +1280,7 @@ private void checkRead ()\n   // FIXME: This should use the ShutdownHook API once we implement that.\n   public void deleteOnExit ()\n   {\n+    // Check the SecurityManager\n     SecurityManager sm = System.getSecurityManager ();\n     if (sm != null)\n       sm.checkDelete (getName ());\n@@ -1275,8 +1302,9 @@ private void readObject (ObjectInputStream ois)\n     // If the file was from an OS with a different dir separator,\n     // fixup the path to use the separator on this OS.\n     char oldSeparatorChar = ois.readChar ();\n+    \n     if (oldSeparatorChar != separatorChar)\n       path = path.replace (oldSeparatorChar, separatorChar);\n   }\n+} // class File\n \n-}"}, {"sha": "e22a23a43261e8a55c819ee4aa99204856c0e4cd", "filename": "libjava/java/io/FileInputStream.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFileInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFileInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileInputStream.java?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -82,6 +82,7 @@ public FileInputStream(String name) throws FileNotFoundException\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkRead(name);\n+\n     fd = new FileDescriptor(name, FileDescriptor.READ);\n   }\n \n@@ -268,15 +269,15 @@ public int read(byte[] buf, int offset, int len) throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public long skip (long numBytes) throws IOException\n+  public synchronized long skip (long numBytes) throws IOException\n   {\n     if (numBytes < 0)\n-      throw new IllegalArgumentException ( \"Can't skip negative bytes: \" +\n-                                           numBytes);\n+      throw new IllegalArgumentException (\"Can't skip negative bytes: \" + \n+                                          numBytes);\n \n     if (numBytes == 0)\n       return 0;\n-    \n+\n     long curPos = fd.getFilePointer ();\n     long newPos = fd.seek (numBytes, FileDescriptor.CUR, true);\n     return newPos - curPos;"}, {"sha": "f4488dcca9358e5c6aa4082212b9277046520c5b", "filename": "libjava/java/io/FileOutputStream.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFileOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FFileOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileOutputStream.java?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -233,7 +233,7 @@ public void write (int b) throws IOException\n   public void write (byte[] buf)\n     throws IOException\n   {\n-    fd.write (buf, 0, buf.length);\n+    write (buf, 0, buf.length);\n   }\n \n   /**"}, {"sha": "d01541d981dce4c6ffff00985936eb1bc24a3296", "filename": "libjava/java/io/InputStreamReader.java", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f564f76ff896424c3ac8d6cde45867e9c083c0/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=83f564f76ff896424c3ac8d6cde45867e9c083c0", "patch": "@@ -37,17 +37,54 @@\n \n \n package java.io;\n+\n import gnu.gcj.convert.*;\n \n /**\n+ * This class reads characters from a byte input stream.   The characters\n+ * read are converted from bytes in the underlying stream by a \n+ * decoding layer.  The decoding layer transforms bytes to chars according\n+ * to an encoding standard.  There are many available encodings to choose \n+ * from.  The desired encoding can either be specified by name, or if no\n+ * encoding is selected, the system default encoding will be used.  The\n+ * system default encoding name is determined from the system property\n+ * <code>file.encoding</code>.  The only encodings that are guaranteed to \n+ * be availalbe are \"8859_1\" (the Latin-1 character set) and \"UTF8\".\n+ * Unforunately, Java does not provide a mechanism for listing the\n+ * ecodings that are supported in a given implementation.\n+ * <p>\n+ * Here is a list of standard encoding names that may be available:\n+ * <p>\n+ * <ul>\n+ * <li>8859_1 (ISO-8859-1/Latin-1)\n+ * <li>8859_2 (ISO-8859-2/Latin-2)\n+ * <li>8859_3 (ISO-8859-3/Latin-3)\n+ * <li>8859_4 (ISO-8859-4/Latin-4)\n+ * <li>8859_5 (ISO-8859-5/Latin-5)\n+ * <li>8859_6 (ISO-8859-6/Latin-6)\n+ * <li>8859_7 (ISO-8859-7/Latin-7)\n+ * <li>8859_8 (ISO-8859-8/Latin-8)\n+ * <li>8859_9 (ISO-8859-9/Latin-9)\n+ * <li>ASCII (7-bit ASCII)\n+ * <li>UTF8 (UCS Transformation Format-8)\n+ * <li>More later\n+ * </ul>\n+ * <p>\n+ * It is recommended that applications do not use \n+ * <code>InputStreamReader</code>'s\n+ * directly.  Rather, for efficiency purposes, an object of this class\n+ * should be wrapped by a <code>BufferedReader</code>.\n+ * <p>\n+ * Due to a deficiency the Java class library design, there is no standard\n+ * way for an application to install its own byte-character encoding.\n+ *\n+ * @see BufferedReader\n+ * @see InputStream\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner <bothner@cygnus.com>\n  * @date April 22, 1998.  \n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct, but only supports 8859_1.\n- */\n-\n public class InputStreamReader extends Reader\n {\n   BufferedInputStream in;\n@@ -61,11 +98,29 @@ public class InputStreamReader extends Reader\n \n   BytesToUnicode converter;\n \n+  /**\n+   * This method initializes a new instance of <code>InputStreamReader</code>\n+   * to read from the specified stream using the default encoding.\n+   *\n+   * @param in The <code>InputStream</code> to read from \n+   */\n   public InputStreamReader(InputStream in)\n   {\n     this(in, BytesToUnicode.getDefaultDecoder());\n   }\n \n+  /**\n+   * This method initializes a new instance of <code>InputStreamReader</code>\n+   * to read from the specified stream using a caller supplied character\n+   * encoding scheme.  Note that due to a deficiency in the Java language\n+   * design, there is no way to determine which encodings are supported.\n+   * \n+   * @param in The <code>InputStream</code> to read from\n+   * @param encoding_name The name of the encoding scheme to use\n+   *\n+   * @exception UnsupportedEncodingException If the encoding scheme \n+   * requested is not available.\n+   */\n   public InputStreamReader(InputStream in, String encoding_name)\n     throws UnsupportedEncodingException\n   {"}]}