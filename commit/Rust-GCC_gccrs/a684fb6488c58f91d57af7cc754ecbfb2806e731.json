{"sha": "a684fb6488c58f91d57af7cc754ecbfb2806e731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4NGZiNjQ4OGM1OGY5MWQ1N2FmN2NjNzU0ZWNiZmIyODA2ZTczMQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2015-03-21T08:29:40Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2015-03-21T08:29:40Z"}, "message": "trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented coindexed coarray accesses.\n\n2015-03-21  Tobias Burnus  <burnus@net-b.de>\n\n        * trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented\n        coindexed coarray accesses.\n\n2015-03-21  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_38.f90: New.\n        * gfortran.dg/coarray_39.f90: New.\n        * gfortran.dg/coarray/coindexed_3.f90: Add dg-error, turn into\n        compile test.\n\nFrom-SVN: r221549", "tree": {"sha": "8866246c2d51904060ad5f01de69c89fd377f1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8866246c2d51904060ad5f01de69c89fd377f1b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a684fb6488c58f91d57af7cc754ecbfb2806e731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a684fb6488c58f91d57af7cc754ecbfb2806e731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a684fb6488c58f91d57af7cc754ecbfb2806e731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a684fb6488c58f91d57af7cc754ecbfb2806e731/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "506fdd17dd5635b6a920eb0391b2d01ed65beda4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506fdd17dd5635b6a920eb0391b2d01ed65beda4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506fdd17dd5635b6a920eb0391b2d01ed65beda4"}], "stats": {"total": 327, "additions": 321, "deletions": 6}, "files": [{"sha": "a53b5a87be9b9f577d9308c52c385672f7f6d3a0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -1,3 +1,8 @@\n+2015-03-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-expr.c (gfc_get_tree_for_caf_expr): Reject unimplemented\n+\tcoindexed coarray accesses.\n+\n 2014-03-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/59198"}, {"sha": "fd3dd8c2725e308ee4cd08b5d8b07424fee2b59a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -1498,10 +1498,65 @@ gfc_get_tree_for_caf_expr (gfc_expr *expr)\n {\n   tree caf_decl;\n   bool found = false;\n-  gfc_ref *ref;\n+  gfc_ref *ref, *comp_ref = NULL;\n \n   gcc_assert (expr && expr->expr_type == EXPR_VARIABLE);\n \n+  /* Not-implemented diagnostic.  */\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT)\n+      {\n+        comp_ref = ref;\n+\tif ((ref->u.c.component->ts.type == BT_CLASS\n+\t     && !CLASS_DATA (ref->u.c.component)->attr.codimension\n+\t     && (CLASS_DATA (ref->u.c.component)->attr.pointer\n+\t\t || CLASS_DATA (ref->u.c.component)->attr.allocatable))\n+\t    || (ref->u.c.component->ts.type != BT_CLASS\n+\t\t&& !ref->u.c.component->attr.codimension\n+\t\t&& (ref->u.c.component->attr.pointer\n+\t\t    || ref->u.c.component->attr.allocatable)))\n+\t  gfc_error (\"Sorry, coindexed access to a pointer or allocatable \"\n+\t\t     \"component of the coindexed coarray at %L is not yet \"\n+\t\t     \"supported\", &expr->where);\n+      }\n+  if ((!comp_ref\n+       && ((expr->symtree->n.sym->ts.type == BT_CLASS\n+\t    && CLASS_DATA (expr->symtree->n.sym)->attr.alloc_comp)\n+\t   || (expr->symtree->n.sym->ts.type == BT_DERIVED\n+\t       && expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)))\n+      || (comp_ref\n+\t  && ((comp_ref->u.c.component->ts.type == BT_CLASS\n+\t       && CLASS_DATA (comp_ref->u.c.component)->attr.alloc_comp)\n+\t      || (comp_ref->u.c.component->ts.type == BT_DERIVED\n+\t\t  && comp_ref->u.c.component->ts.u.derived->attr.alloc_comp))))\n+    gfc_error (\"Sorry, coindexed coarray at %L with allocatable component is \"\n+\t       \"not yet supported\", &expr->where);\n+\n+  if (expr->rank)\n+    {\n+      /* Without the new array descriptor, access like \"caf[i]%a(:)%b\" is in\n+\t general not possible as the required stride multiplier might be not\n+\t a multiple of c_sizeof(b). In case of noncoindexed access, the\n+\t scalarizer often takes care of it - for coarrays, it always fails.  */\n+      for (ref = expr->ref; ref; ref = ref->next)\n+        if (ref->type == REF_COMPONENT\n+\t    && ((ref->u.c.component->ts.type == BT_CLASS\n+\t\t && CLASS_DATA (ref->u.c.component)->attr.codimension)\n+\t        || (ref->u.c.component->ts.type != BT_CLASS\n+\t\t    && ref->u.c.component->attr.codimension)))\n+\t  break;\n+      if (ref == NULL)\n+\tref = expr->ref;\n+      for ( ; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY && ref->u.ar.dimen)\n+\t  break;\n+      for ( ; ref; ref = ref->next)\n+\tif (ref->type == REF_COMPONENT)\n+\t  gfc_error (\"Sorry, coindexed access at %L to a scalar component \"\n+\t\t     \"with an array partref is not yet supported\",\n+\t\t     &expr->where);\n+    }\n+\n   caf_decl = expr->symtree->n.sym->backend_decl;\n   gcc_assert (caf_decl);\n   if (expr->symtree->n.sym->ts.type == BT_CLASS)"}, {"sha": "fd8a81394c60ddbe9bcad6fe3218ca23521ddac8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -1,3 +1,10 @@\n+2015-03-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_38.f90: New.\n+\t* gfortran.dg/coarray_39.f90: New.\n+\t* gfortran.dg/coarray/coindexed_3.f90: Add dg-error, turn into\n+\tcompile test.\n+\n 2015-03-20  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/65398"}, {"sha": "4642f2cfcf948cb2817f0a41d7b22e017382aa53", "filename": "gcc/testsuite/gfortran.dg/coarray/coindexed_3.f90", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run }\n+! { dg-do compile }\n !\n ! Contributed by Reinhold Bader\n !\n@@ -45,8 +45,8 @@ program pmup\n   allocate(t :: a(3)[*])\n   IF (this_image() == num_images()) THEN\n     SELECT TYPE (a)\n-      TYPE IS (t)\n-      a(:)[1]%a = 4.0\n+      TYPE IS (t)     ! FIXME: When implemented, turn into \"do-do run\"\n+      a(:)[1]%a = 4.0 ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n     END SELECT\n   END IF\n   SYNC ALL\n@@ -56,8 +56,8 @@ program pmup\n    TYPE IS (real)\n       ii = a(1)[1]\n       call abort()\n-    TYPE IS (t)\n-      IF (ALL(A(:)[1]%a == 4.0)) THEN\n+    TYPE IS (t)                       ! FIXME: When implemented, turn into \"do-do run\"\n+      IF (ALL(A(:)[1]%a == 4.0)) THEN ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n         !WRITE(*,*) 'OK'\n       ELSE\n         WRITE(*,*) 'FAIL'"}, {"sha": "6fa0a65edfcd014dccbabc1ddfb1351e7eefd8d2", "filename": "gcc/testsuite/gfortran.dg/coarray_38.f90", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -0,0 +1,124 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib\" }\n+!\n+! Valid code - but currently not implemented for -fcoarray=lib; single okay \n+!\n+subroutine one\n+implicit none\n+type t\n+  integer, allocatable :: a\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2[:]\n+end type t2\n+type(t), save :: caf[*],x\n+type(t2) :: y\n+\n+x = caf[4]     ! { dg-error \"Sorry, coindexed coarray at \\\\(1\\\\) with allocatable component is not yet supported\" }\n+x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = caf[4]%b ! OK\n+x = y%caf2[5]  ! { dg-error \"Sorry, coindexed coarray at \\\\(1\\\\) with allocatable component is not yet supported\" }\n+x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = y%caf2[4]%b ! OK\n+end subroutine one\n+\n+subroutine two\n+implicit none\n+type t\n+  integer, pointer :: a\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2[:]\n+end type t2\n+type(t), save :: caf[*],x\n+type(t2) :: y\n+\n+x = caf[4]     ! OK\n+x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = caf[4]%b ! OK\n+x = y%caf2[5]  ! OK\n+x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = y%caf2[4]%b ! OK\n+end subroutine two\n+\n+subroutine three\n+implicit none\n+type t\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2(:)[:]\n+end type t2\n+type(t), save :: caf(10)[*]\n+integer :: x(10)\n+type(t2) :: y\n+\n+x(1) = caf(2)[4]%b ! OK\n+x(:) = caf(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+\n+x(1) = y%caf2(2)[4]%b ! OK\n+x(:) = y%caf2(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+end subroutine three\n+\n+subroutine four\n+implicit none\n+type t\n+  integer, allocatable :: a\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2[:]\n+end type t2\n+class(t), allocatable :: caf[:]\n+type(t) :: x\n+type(t2) :: y\n+\n+!x = caf[4]    ! Unsupported - and ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n+x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = caf[4]%b ! OK\n+!x = y%caf2[5] ! Unsupported - and ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n+x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = y%caf2[4]%b ! OK\n+end subroutine four\n+\n+subroutine five\n+implicit none\n+type t\n+  integer, pointer :: a\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2[:]\n+end type t2\n+class(t), save, allocatable :: caf[:]\n+type(t) :: x\n+type(t2) :: y\n+\n+!x = caf[4]     ! OK - but ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n+x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = caf[4]%b ! OK\n+!x = y%caf2[5]  ! OK - but ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n+x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%b = y%caf2[4]%b ! OK\n+end subroutine five\n+\n+subroutine six\n+implicit none\n+type t\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2(:)[:]\n+end type t2\n+class(t), save, allocatable :: caf(:)[:]\n+integer :: x(10)\n+type(t2) :: y\n+\n+x(1) = caf(2)[4]%b ! OK\n+x(:) = caf(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+\n+x(1) = y%caf2(2)[4]%b ! OK\n+x(:) = y%caf2(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+end subroutine six"}, {"sha": "17eacb0acb8bda739b401464baba8e04ee8b8783", "filename": "gcc/testsuite/gfortran.dg/coarray_39.f90", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_39.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684fb6488c58f91d57af7cc754ecbfb2806e731/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_39.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_39.f90?ref=a684fb6488c58f91d57af7cc754ecbfb2806e731", "patch": "@@ -0,0 +1,124 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Valid code - but currently not implemented for -fcoarray=lib; single okay \n+!\n+subroutine one\n+implicit none\n+type t\n+  integer, allocatable :: a\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2[:]\n+end type t2\n+type(t), save :: caf[*],x\n+type(t2) :: y\n+\n+x = caf[4]\n+x%a = caf[4]%a\n+x%b = caf[4]%a\n+x = y%caf2[5]\n+x%a = y%caf2[4]%a\n+x%b = y%caf2[4]%b\n+end subroutine one\n+\n+subroutine two\n+implicit none\n+type t\n+  integer, pointer :: a\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2[:]\n+end type t2\n+type(t), save :: caf[*],x\n+type(t2) :: y\n+\n+x = caf[4]\n+x%a = caf[4]%a\n+x%b = caf[4]%b\n+x = y%caf2[5]\n+x%a = y%caf2[4]%a\n+x%b = y%caf2[4]%b\n+end subroutine two\n+\n+subroutine three\n+implicit none\n+type t\n+  integer :: b\n+end type t\n+type t2\n+  type(t), allocatable :: caf2(:)[:]\n+end type t2\n+type(t), save :: caf(10)[*]\n+integer :: x(10)\n+type(t2) :: y\n+\n+x(1) = caf(2)[4]%b\n+x(:) = caf(:)[4]%b\n+\n+x(1) = y%caf2(2)[4]%b\n+x(:) = y%caf2(:)[4]%b\n+end subroutine three\n+\n+subroutine four\n+implicit none\n+type t\n+  integer, allocatable :: a\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2[:]\n+end type t2\n+class(t), allocatable :: caf[:]\n+type(t) :: x\n+type(t2) :: y\n+\n+x = caf[4]\n+x%a = caf[4]%a\n+x%b = caf[4]%b\n+x = y%caf2[5]\n+x%a = y%caf2[4]%a\n+x%b = y%caf2[4]%b\n+end subroutine four\n+\n+subroutine five\n+implicit none\n+type t\n+  integer, pointer :: a\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2[:]\n+end type t2\n+class(t), save, allocatable :: caf[:]\n+type(t) :: x\n+type(t2) :: y\n+\n+x = caf[4]\n+x%a = caf[4]%a\n+x%b = caf[4]%b\n+x = y%caf2[5]\n+x%a = y%caf2[4]%a\n+x%b = y%caf2[4]%b\n+end subroutine five\n+\n+subroutine six\n+implicit none\n+type t\n+  integer :: b\n+end type t\n+type t2\n+  class(t), allocatable :: caf2(:)[:]\n+end type t2\n+class(t), save, allocatable :: caf(:)[:]\n+integer :: x(10)\n+type(t2) :: y\n+\n+x(1) = caf(2)[4]%b\n+x(:) = caf(:)[4]%b\n+\n+x(1) = y%caf2(2)[4]%b\n+x(:) = y%caf2(:)[4]%b\n+end subroutine six"}]}