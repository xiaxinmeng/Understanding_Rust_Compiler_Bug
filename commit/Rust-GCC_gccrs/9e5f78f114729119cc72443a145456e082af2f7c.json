{"sha": "9e5f78f114729119cc72443a145456e082af2f7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1Zjc4ZjExNDcyOTExOWNjNzI0NDNhMTQ1NDU2ZTA4MmFmMmY3Yw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2014-07-03T16:39:58Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2014-07-03T16:39:58Z"}, "message": "Fix the shift patterns, and add test\n\nFirstly, it adds back the split conditions that I accidentally removed.\nWithout it the dot insns are never generated, or rather, always split\nback to a separate compare instruction.\n\nSecondly, the shift amount should be SI always, not GPR, or GCC will\ninsert a zero-extend at expand time that it cannot get rid of later.\n\nThe test tests whether dot-form instructions are generated for both\n\"dot\" and \"dot2\" cases, that is, with just a CC output or also a GPR\noutput; for all four basic shifts, with a register amount or an\nimmediate amount.  It also tests for superfluous zero-extends.  This\nalso tests if combine \"simplifies\" the rotates to right-rotates, which\nit shouldn't do anymore.\n\nFrom-SVN: r212267", "tree": {"sha": "8eb1e5f8b2d28704820a8d4674af4aae01c28812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eb1e5f8b2d28704820a8d4674af4aae01c28812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e5f78f114729119cc72443a145456e082af2f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5f78f114729119cc72443a145456e082af2f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e5f78f114729119cc72443a145456e082af2f7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5f78f114729119cc72443a145456e082af2f7c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07b6c044833e9ae2a723400435b32612bd9cee2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b6c044833e9ae2a723400435b32612bd9cee2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b6c044833e9ae2a723400435b32612bd9cee2a"}], "stats": {"total": 103, "additions": 82, "deletions": 21}, "files": [{"sha": "de5484e59bef5e16ce81eb31581e1673dc327d88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e5f78f114729119cc72443a145456e082af2f7c", "patch": "@@ -1,3 +1,11 @@\n+2014-07-03  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.md (rotl<mode>3, ashl<mode>3, lshr<mode>3,\n+\tashr<mode>3): Correct mode of operands[2].\n+\t(rotl<mode>3_dot, rotl<mode>3_dot2, ashl<mode>3_dot, ashl<mode>3_dot2,\n+\tlshr<mode>3_dot, lshr<mode>3_dot2, ashr<mode>3_dot, ashr<mode>3_dot2):\n+\tCorrect mode of operands[2].  Fix split condition.\n+\n 2014-07-03  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (arch): Add armv6_or_vfpv3."}, {"sha": "83aaa58682b0bffc040b8a0eebda18b518d79b26", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=9e5f78f114729119cc72443a145456e082af2f7c", "patch": "@@ -3874,7 +3874,7 @@\n (define_insn \"rotl<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(rotate:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn\")))]\n+\t\t    (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")))]\n   \"\"\n   \"rotl<wd>%I2 %0,%1,%<hH>2\"\n   [(set_attr \"type\" \"shift\")\n@@ -3893,14 +3893,14 @@\n (define_insn_and_split \"*rotl<mode>3_dot\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (rotate:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n    rotl<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(rotate:GPR (match_dup 1)\n \t\t    (match_dup 2)))\n@@ -3916,7 +3916,7 @@\n (define_insn_and_split \"*rotl<mode>3_dot2\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (rotate:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(rotate:GPR (match_dup 1)\n@@ -3925,7 +3925,7 @@\n   \"@\n    rotl<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(rotate:GPR (match_dup 1)\n \t\t    (match_dup 2)))\n@@ -4353,7 +4353,7 @@\n (define_insn \"ashl<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn\")))]\n+\t\t    (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")))]\n   \"\"\n   \"sl<wd>%I2 %0,%1,%<hH>2\"\n   [(set_attr \"type\" \"shift\")\n@@ -4372,14 +4372,14 @@\n (define_insn_and_split \"*ashl<mode>3_dot\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n    sl<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(ashift:GPR (match_dup 1)\n \t\t    (match_dup 2)))\n@@ -4395,7 +4395,7 @@\n (define_insn_and_split \"*ashl<mode>3_dot2\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(ashift:GPR (match_dup 1)\n@@ -4404,7 +4404,7 @@\n   \"@\n    sl<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(ashift:GPR (match_dup 1)\n \t\t    (match_dup 2)))\n@@ -4498,7 +4498,7 @@\n (define_insn \"lshr<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(lshiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn\")))]\n+\t\t      (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")))]\n   \"\"\n   \"sr<wd>%I2 %0,%1,%<hH>2\"\n   [(set_attr \"type\" \"shift\")\n@@ -4517,14 +4517,14 @@\n (define_insn_and_split \"*lshr<mode>3_dot\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (lshiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t  (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n    sr<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(lshiftrt:GPR (match_dup 1)\n \t\t      (match_dup 2)))\n@@ -4540,7 +4540,7 @@\n (define_insn_and_split \"*lshr<mode>3_dot2\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (lshiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t  (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(lshiftrt:GPR (match_dup 1)\n@@ -4549,7 +4549,7 @@\n   \"@\n    sr<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(lshiftrt:GPR (match_dup 1)\n \t\t      (match_dup 2)))\n@@ -4971,7 +4971,7 @@\n (define_expand \"ashr<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n \t(ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n-\t\t      (match_operand:GPR 2 \"reg_or_cint_operand\" \"\")))]\n+\t\t      (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n {\n   /* The generic code does not generate optimal code for the low word\n@@ -4993,7 +4993,7 @@\n (define_insn \"*ashr<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn\")))]\n+\t\t      (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")))]\n   \"\"\n   \"sra<wd>%I2 %0,%1,%<hH>2\"\n   [(set_attr \"type\" \"shift\")\n@@ -5012,14 +5012,14 @@\n (define_insn_and_split \"*ashr<mode>3_dot\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t  (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n    sra<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(ashiftrt:GPR (match_dup 1)\n \t\t      (match_dup 2)))\n@@ -5035,7 +5035,7 @@\n (define_insn_and_split \"*ashr<mode>3_dot2\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t  (match_operand:GPR 2 \"reg_or_cint_operand\" \"rn,rn\"))\n+\t\t\t\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n \t\t    (const_int 0)))\n    (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(ashiftrt:GPR (match_dup 1)\n@@ -5044,7 +5044,7 @@\n   \"@\n    sra<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(ashiftrt:GPR (match_dup 1)\n \t\t      (match_dup 2)))"}, {"sha": "50831ebcdbd7298a0e26e01577abc196693ca172", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e5f78f114729119cc72443a145456e082af2f7c", "patch": "@@ -1,3 +1,7 @@\n+2014-07-03  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* gcc.target/powerpc/shift-dot.c: New test.\n+\n 2014-07-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.dg/ieee/ieee_1.F90: Mark variables as volatile to"}, {"sha": "002948c081555ddbd6360b1692b7755ad583c72b", "filename": "gcc/testsuite/gcc.target/powerpc/shift-dot.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fshift-dot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f78f114729119cc72443a145456e082af2f7c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fshift-dot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fshift-dot.c?ref=9e5f78f114729119cc72443a145456e082af2f7c", "patch": "@@ -0,0 +1,49 @@\n+/* Check that record-form instructions are used.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mgen-cell-microcode\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mrotl[wd]\\.} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msl[wd]\\.} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msr[wd]\\.} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msra[wd]\\.} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\mrotl[wd]i\\.} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msl[wd]i\\.} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msr[wd]i\\.} 2 } } */\n+/* Combine converts the arith shift right compares to a (more expensive)\n+   direct compare.  Luckily not the other shifts.  XFAIL for now.  */\n+/* { dg-final { scan-assembler-times {\\msra[wd]i\\.} 2 { xfail *-*-* } } } */\n+\n+/* There should not be any extends of the shift amount (or anything else).  */\n+/* { dg-final { scan-assembler-not {\\mextsw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mrldicl\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mclrldi\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mrlwinm\\M} } } */\n+\n+\n+typedef unsigned long u;\n+typedef long s;\n+#define M(n) (8 * sizeof(long) - (n))\n+#define T1 if ((s)x > 0) g();\n+#define T2 if ((s)x > 0) g(); return x;\n+\n+void g(void);\n+\n+void rot1(u x, u n) { x = (x << M(n)) | (x >> n); T1 }\n+   u rot2(u x, u n) { x = (x << M(n)) | (x >> n); T2 }\n+void shl1(u x, u n) { x <<= n; T1 }\n+   u shl2(u x, u n) { x <<= n; T2 }\n+void shr1(u x, u n) { x >>= n; T1 }\n+   u shr2(u x, u n) { x >>= n; T2 }\n+void asr1(s x, u n) { x >>= n; T1 }\n+   s asr2(s x, u n) { x >>= n; T2 }\n+\n+void rot1i(u x) { x = (x << M(23)) | (x >> 23); T1 }\n+   u rot2i(u x) { x = (x << M(23)) | (x >> 23); T2 }\n+void shl1i(u x) { x <<= 23; T1 }\n+   u shl2i(u x) { x <<= 23; T2 }\n+void shr1i(u x) { x >>= 23; T1 }\n+   u shr2i(u x) { x >>= 23; T2 }\n+void asr1i(s x) { x >>= 23; T1 }\n+   s asr2i(s x) { x >>= 23; T2 }"}]}