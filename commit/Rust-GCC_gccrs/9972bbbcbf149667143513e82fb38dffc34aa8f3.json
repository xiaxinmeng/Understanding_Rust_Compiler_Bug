{"sha": "9972bbbcbf149667143513e82fb38dffc34aa8f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3MmJiYmNiZjE0OTY2NzE0MzUxM2U4MmZiMzhkZmZjMzRhYThmMw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-01-23T11:10:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-01-23T11:10:47Z"}, "message": "-Warray-bounds: Fix false positive in some \"switch\" stmts (PR tree-optimization/83510)\n\nPR tree-optimization/83510 reports that r255649 (for\nPR tree-optimization/83312) introduced a false positive for\n-Warray-bounds for array accesses within certain switch statements:\nthose for which value-ranges allow more than one case to be reachable,\nbut for which one or more of the VR-unreachable cases contain\nout-of-range array accesses.\n\nIn the reproducer, after the switch in f is inlined into g, we have 3 cases\nfor the switch (case 9, case 10-19, and default), within a loop that\nranges from 0..9.\n\nWith both the old and new code, vr_values::simplify_switch_using_ranges clears\nthe EDGE_EXECUTABLE flag on the edge to the \"case 10-19\" block.  This\nhappens during the dom walk within the substitute_and_fold_engine.\n\nWith the old code, the clearing of that EDGE_EXECUTABLE flag led to the\n      /* Skip blocks that were found to be unreachable.  */\ncode in the old implementation of vrp_prop::check_all_array_refs skipping\nthe \"case 10-19\" block.\n\nWith the new code, we have a second dom walk, and that dom_walker's ctor\nsets all edges to be EDGE_EXECUTABLE, losing that information.\n\nThen, dom_walker::before_dom_children (here, the subclass'\ncheck_array_bounds_dom_walker::before_dom_children) can return one edge, if\nthere's a unique successor edge, and dom_walker::walk filters the dom walk\nto just that edge.\n\nHere we have two VR-valid edges (case 9 and default), and an VR-invalid\nsuccessor edge (case 10-19).  There's no *unique* valid successor edge,\nand hence taken_edge is NULL, and the filtering in dom_walker::walk\ndoesn't fire.\n\nHence we've lost the filtering of the \"case 10-19\" BB, hence the false\npositive.\n\nThe issue is that we have two dom walks: first within vr_values'\nsubstitute_and_fold_dom_walker (which has skip_unreachable_blocks == false),\nthen another within vrp_prop::check_all_array_refs (with\nskip_unreachable_blocks == true).\n\nEach has different \"knowledge\" about ruling out edges due to value-ranges,\nbut we aren't combining that information.  The former \"knows\" about\nout-edges at a particular control construct (e.g. at a switch), the latter\n\"knows\" about dominance, but only about unique successors (hence the\nproblem when two out of three switch cases are valid).\n\nThis patch combines the information by preserving the EDGE_EXECUTABLE\nflags from the first dom walk, and using it in the second dom walk,\npotentially rejecting additional edges.\n\nDoing so fixes the false positive.\n\nI attempted an alternative fix, merging the two dom walks into one, but\nthat led to crashes in identify_jump_threads, so I went with this, as\na less invasive fix.\n\ngcc/ChangeLog:\n\tPR tree-optimization/83510\n\t* domwalk.c (set_all_edges_as_executable): New function.\n\t(dom_walker::dom_walker): Convert bool param\n\t\"skip_unreachable_blocks\" to enum reachability.  Move setup of\n\tedge flags to set_all_edges_as_executable and only do it when\n\treachability is REACHABLE_BLOCKS.\n\t* domwalk.h (enum dom_walker::reachability): New enum.\n\t(dom_walker::dom_walker): Convert bool param\n\t\"skip_unreachable_blocks\" to enum reachability.\n\t(set_all_edges_as_executable): New decl.\n\t* graphite-scop-detection.c  (gather_bbs::gather_bbs): Convert\n\tfrom false for \"skip_unreachable_blocks\" to ALL_BLOCKS for\n\t\"reachability\".\n\t* tree-ssa-dom.c (dom_opt_dom_walker::dom_opt_dom_walker): Likewise,\n\tbut converting true to REACHABLE_BLOCKS.\n\t* tree-ssa-sccvn.c (sccvn_dom_walker::sccvn_dom_walker): Likewise.\n\t* tree-vrp.c\n\t(check_array_bounds_dom_walker::check_array_bounds_dom_walker):\n\tLikewise, but converting it to REACHABLE_BLOCKS_PRESERVING_FLAGS.\n\t(vrp_dom_walker::vrp_dom_walker): Likewise, but converting it to\n\tREACHABLE_BLOCKS.\n\t(vrp_prop::vrp_finalize): Call set_all_edges_as_executable\n\tif check_all_array_refs will be called.\n\ngcc/testsuite/ChangeLog:\n\tPR tree-optimization/83510\n\t* gcc.c-torture/compile/pr83510.c: New test case.\n\nFrom-SVN: r256980", "tree": {"sha": "db71c28dc84683fb632605a1b5af18d97c870118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db71c28dc84683fb632605a1b5af18d97c870118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9972bbbcbf149667143513e82fb38dffc34aa8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9972bbbcbf149667143513e82fb38dffc34aa8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9972bbbcbf149667143513e82fb38dffc34aa8f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9972bbbcbf149667143513e82fb38dffc34aa8f3/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02851c8c7f8b04a4a726e3162177a5ea4d19ca36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02851c8c7f8b04a4a726e3162177a5ea4d19ca36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02851c8c7f8b04a4a726e3162177a5ea4d19ca36"}], "stats": {"total": 321, "additions": 290, "deletions": 31}, "files": [{"sha": "6718a38fae72b68984566e0d89c8586cb67a1b9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -1,3 +1,29 @@\n+2018-01-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR tree-optimization/83510\n+\t* domwalk.c (set_all_edges_as_executable): New function.\n+\t(dom_walker::dom_walker): Convert bool param\n+\t\"skip_unreachable_blocks\" to enum reachability.  Move setup of\n+\tedge flags to set_all_edges_as_executable and only do it when\n+\treachability is REACHABLE_BLOCKS.\n+\t* domwalk.h (enum dom_walker::reachability): New enum.\n+\t(dom_walker::dom_walker): Convert bool param\n+\t\"skip_unreachable_blocks\" to enum reachability.\n+\t(set_all_edges_as_executable): New decl.\n+\t* graphite-scop-detection.c  (gather_bbs::gather_bbs): Convert\n+\tfrom false for \"skip_unreachable_blocks\" to ALL_BLOCKS for\n+\t\"reachability\".\n+\t* tree-ssa-dom.c (dom_opt_dom_walker::dom_opt_dom_walker): Likewise,\n+\tbut converting true to REACHABLE_BLOCKS.\n+\t* tree-ssa-sccvn.c (sccvn_dom_walker::sccvn_dom_walker): Likewise.\n+\t* tree-vrp.c\n+\t(check_array_bounds_dom_walker::check_array_bounds_dom_walker):\n+\tLikewise, but converting it to REACHABLE_BLOCKS_PRESERVING_FLAGS.\n+\t(vrp_dom_walker::vrp_dom_walker): Likewise, but converting it to\n+\tREACHABLE_BLOCKS.\n+\t(vrp_prop::vrp_finalize): Call set_all_edges_as_executable\n+\tif check_all_array_refs will be called.\n+\n 2018-01-23  David Malcolm  <dmalcolm@redhat.com>\n \n \t* tree.c (selftest::test_location_wrappers): Add more test"}, {"sha": "0161761330b2c7b8ecc444b7c1dd033ec86d3790", "filename": "gcc/domwalk.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -169,15 +169,28 @@ sort_bbs_postorder (basic_block *bbs, int n)\n     qsort (bbs, n, sizeof *bbs, cmp_bb_postorder);\n }\n \n-/* Constructor for a dom walker.\n+/* Set EDGE_EXECUTABLE on every edge within FN's CFG.  */\n+\n+void\n+set_all_edges_as_executable (function *fn)\n+{\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, fn)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+}\n+\n+/* Constructor for a dom walker.  */\n \n-   If SKIP_UNREACHBLE_BLOCKS is true, then we need to set\n-   EDGE_EXECUTABLE on every edge in the CFG. */\n dom_walker::dom_walker (cdi_direction direction,\n-\t\t\tbool skip_unreachable_blocks,\n+\t\t\tenum reachability reachability,\n \t\t\tint *bb_index_to_rpo)\n   : m_dom_direction (direction),\n-    m_skip_unreachable_blocks (skip_unreachable_blocks),\n+    m_skip_unreachable_blocks (reachability != ALL_BLOCKS),\n     m_user_bb_to_rpo (bb_index_to_rpo != NULL),\n     m_unreachable_dom (NULL),\n     m_bb_to_rpo (bb_index_to_rpo)\n@@ -195,18 +208,22 @@ dom_walker::dom_walker (cdi_direction direction,\n       free (postorder);\n     }\n \n-  /* If we are not skipping unreachable blocks, then there is nothing\n-     further to do.  */\n-  if (!m_skip_unreachable_blocks)\n-    return;\n-\n-  basic_block bb;\n-  FOR_ALL_BB_FN (bb, cfun)\n+  /* Set up edge flags if need be.  */\n+  switch (reachability)\n     {\n-      edge_iterator ei;\n-      edge e;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\te->flags |= EDGE_EXECUTABLE;\n+    default:\n+      gcc_unreachable ();\n+    case ALL_BLOCKS:\n+      /* No need to touch edge flags.  */\n+      break;\n+\n+    case REACHABLE_BLOCKS:\n+      set_all_edges_as_executable (cfun);\n+      break;\n+\n+    case REACHABLE_BLOCKS_PRESERVING_FLAGS:\n+      /* Preserve the edge flags.  */\n+      break;\n     }\n }\n "}, {"sha": "2e8290f3a1c4eb64649c90cbae549c88ac9567f4", "filename": "gcc/domwalk.h", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -32,17 +32,37 @@ class dom_walker\n public:\n   static const edge STOP;\n \n-  /* Use SKIP_UNREACHABLE_BLOCKS = true when your client can discover\n-     that some edges are not executable.\n-\n-     If a client can discover that a COND, SWITCH or GOTO has a static\n-     target in the before_dom_children callback, the taken edge should\n-     be returned.  The generic walker will clear EDGE_EXECUTABLE on all\n-     edges it can determine are not executable.\n-     \n-     You can provide a mapping of basic-block index to RPO if you\n+  /* An enum for determining whether the dom walk should be constrained to\n+     blocks reachable by executable edges.  */\n+\n+  enum reachability\n+  {\n+    /* Walk all blocks within the CFG.  */\n+    ALL_BLOCKS,\n+\n+    /* Use REACHABLE_BLOCKS when your subclass can discover that some edges\n+       are not executable.\n+\n+       If a subclass can discover that a COND, SWITCH or GOTO has a static\n+       target in the before_dom_children callback, the taken edge should\n+       be returned.  The generic walker will clear EDGE_EXECUTABLE on all\n+       edges it can determine are not executable.\n+\n+       With REACHABLE_BLOCKS, EDGE_EXECUTABLE will be set on every edge in\n+       the dom_walker ctor; the flag will then be cleared on edges that are\n+       determined to be not executable.  */\n+    REACHABLE_BLOCKS,\n+\n+    /* Identical to REACHABLE_BLOCKS, but the initial state of EDGE_EXECUTABLE\n+       will instead be preserved in the ctor, allowing for information about\n+       non-executable edges to be merged in from an earlier analysis (and\n+       potentially for additional edges to be marked as non-executable).  */\n+    REACHABLE_BLOCKS_PRESERVING_FLAGS\n+  };\n+\n+  /* You can provide a mapping of basic-block index to RPO if you\n      have that readily available or you do multiple walks.  */\n-  dom_walker (cdi_direction direction, bool skip_unreachable_blocks = false,\n+  dom_walker (cdi_direction direction, enum reachability = ALL_BLOCKS,\n \t      int *bb_index_to_rpo = NULL);\n \n   ~dom_walker ();\n@@ -87,4 +107,6 @@ class dom_walker\n \n };\n \n+extern void set_all_edges_as_executable (function *fn);\n+\n #endif"}, {"sha": "2d5dc3ec7315828e09b4866e3a1fe76aea1953f3", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -1424,7 +1424,7 @@ class gather_bbs : public dom_walker\n };\n }\n gather_bbs::gather_bbs (cdi_direction direction, scop_p scop, int *bb_to_rpo)\n-  : dom_walker (direction, false, bb_to_rpo), scop (scop)\n+  : dom_walker (direction, ALL_BLOCKS, bb_to_rpo), scop (scop)\n {\n }\n "}, {"sha": "827bcba4d536f68ff4141a182324e7414067d2b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -1,3 +1,8 @@\n+2018-01-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR tree-optimization/83510\n+\t* gcc.c-torture/compile/pr83510.c: New test case.\n+\n 2018-01-23  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR testsuite/83888"}, {"sha": "907dd80ccd79e4a9792c147e342d50792bb77387", "filename": "gcc/testsuite/gcc.c-torture/compile/pr83510.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr83510.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr83510.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr83510.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -0,0 +1,172 @@\n+/* Various examples of safe array access for which -Warray-bounds\n+   shouldn't issue a warning at any optimization level\n+   (PR tree-optimization/83510).  */\n+\n+/* { dg-options \"-Warray-bounds\" } */\n+\n+extern int get_flag (void);\n+\n+unsigned int arr[10];\n+\n+struct xyz {\n+  unsigned int a0;\n+};\n+\n+extern void wfm(struct xyz *, int, unsigned int);\n+\n+static unsigned int f(struct xyz * ctx, unsigned int number)\n+{\n+  switch (number) {\n+  case 0x9:\n+    return ctx->a0;\n+  case 0xA: case 0xB:\n+  case 0xC: case 0xD: case 0xE: case 0xF:\n+  case 0x10: case 0x11: case 0x12: case 0x13:\n+    return arr[number - 0xa];\n+  }\n+  return 0;\n+}\n+\n+int g(struct xyz * ctx) {\n+  int i;\n+\n+  for (i = 0; i < 10; i++) {\n+    wfm(ctx, i, f(ctx, i));\n+  }\n+\n+  return 0;\n+}\n+\n+static unsigned int f_signed(struct xyz * ctx, int number)\n+{\n+  switch (number) {\n+  case 0x9:\n+    return ctx->a0;\n+  case 0xA: case 0xB:\n+  case 0xC: case 0xD: case 0xE: case 0xF:\n+  case 0x10: case 0x11: case 0x12: case 0x13:\n+    return arr[number];\n+  }\n+  return 0;\n+}\n+\n+int g_signed(struct xyz * ctx) {\n+  int i;\n+\n+  for (i = 0; i < 10; i++) {\n+    wfm(ctx, i, f(ctx, i));\n+  }\n+\n+  return 0;\n+}\n+\n+void test_2 (struct xyz * ctx)\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++) {\n+    if (get_flag ())\n+      wfm(ctx, i, f(ctx, i));\n+  }\n+}\n+\n+void test_2_signed (struct xyz * ctx)\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++) {\n+    if (get_flag ())\n+      wfm(ctx, i, f_signed(ctx, i));\n+  }\n+}\n+\n+void test_3 (struct xyz * ctx)\n+{\n+  unsigned int i;\n+  \n+  for (i = 0; i < 10; i++) {\n+    switch (i) {\n+    case 0x9:\n+      wfm(ctx, i, ctx->a0);\n+      break;\n+    case 0xA: case 0xB:\n+    case 0xC: case 0xD: case 0xE: case 0xF:\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      if (get_flag ())\n+\twfm(ctx, i, arr[i - 0xa]);\n+      break;\n+    }\n+  }\n+}\n+\n+void test_3_signed (struct xyz * ctx)\n+{\n+  int i;\n+  \n+  for (i = 0; i < 10; i++) {\n+    switch (i) {\n+    case 0x9:\n+      wfm(ctx, i, ctx->a0);\n+      break;\n+    case 0xA: case 0xB:\n+    case 0xC: case 0xD: case 0xE: case 0xF:\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      if (get_flag ())\n+\twfm(ctx, i, arr[i]);\n+      break;\n+    }\n+  }\n+}\n+\n+void test_4 (struct xyz * ctx)\n+{\n+  unsigned int i, j;\n+  \n+  for (i = 0; i < 10; i++) {\n+    switch (i) {\n+    case 0x9:\n+      wfm(ctx, i, ctx->a0);\n+      break;\n+    case 0xA: case 0xB:\n+    case 0xC: case 0xD: case 0xE: case 0xF:\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      for (j = 0; j < 5; j++)\n+\twfm(ctx, i, arr[i - 0xa]);\n+      break;\n+    }\n+  }\n+}\n+void test_4_signed (struct xyz * ctx)\n+{\n+  int i, j;\n+  \n+  for (i = 0; i < 10; i++) {\n+    switch (i) {\n+    case 0x9:\n+      wfm(ctx, i, ctx->a0);\n+      break;\n+    case 0xA: case 0xB:\n+    case 0xC: case 0xD: case 0xE: case 0xF:\n+    case 0x10: case 0x11: case 0x12: case 0x13:\n+      for (j = 0; j < 5; j++)\n+\twfm(ctx, i, arr[i]);\n+      break;\n+    }\n+  }\n+}\n+\n+void test_5 (struct xyz * ctx)\n+{\n+  unsigned int i;\n+  for (i = 10; i < 20; i++) {\n+    wfm(ctx, i, arr[i - 10]);\n+  }    \n+}\n+\n+void test_5_signed (struct xyz * ctx)\n+{\n+  int i;\n+  for (i = 10; i < 20; i++) {\n+    wfm(ctx, i, arr[i - 10]);\n+  }    \n+}"}, {"sha": "2b371667253a3a9058ac1cf830d90137c2a19d77", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -574,7 +574,7 @@ class dom_opt_dom_walker : public dom_walker\n \t\t      class const_and_copies *const_and_copies,\n \t\t      class avail_exprs_stack *avail_exprs_stack,\n \t\t      gcond *dummy_cond)\n-    : dom_walker (direction, true),\n+    : dom_walker (direction, REACHABLE_BLOCKS),\n       m_const_and_copies (const_and_copies),\n       m_avail_exprs_stack (avail_exprs_stack),\n       m_dummy_cond (dummy_cond) { }"}, {"sha": "9844bbbbcf361ad76c93cfb2d757d10e27f9d7e7", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -4769,7 +4769,7 @@ class sccvn_dom_walker : public dom_walker\n {\n public:\n   sccvn_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS, true), cond_stack (0) {}\n+    : dom_walker (CDI_DOMINATORS, REACHABLE_BLOCKS), cond_stack (0) {}\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);"}, {"sha": "3af81f70872a30b4dc493b057e238af299c33d5c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9972bbbcbf149667143513e82fb38dffc34aa8f3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9972bbbcbf149667143513e82fb38dffc34aa8f3", "patch": "@@ -5029,7 +5029,12 @@ class check_array_bounds_dom_walker : public dom_walker\n {\n  public:\n   check_array_bounds_dom_walker (vrp_prop *prop)\n-    : dom_walker (CDI_DOMINATORS, true), m_prop (prop) {}\n+    : dom_walker (CDI_DOMINATORS,\n+\t\t  /* Discover non-executable edges, preserving EDGE_EXECUTABLE\n+\t\t     flags, so that we can merge in information on\n+\t\t     non-executable edges from vrp_folder .  */\n+\t\t  REACHABLE_BLOCKS_PRESERVING_FLAGS),\n+      m_prop (prop) {}\n   ~check_array_bounds_dom_walker () {}\n \n   edge before_dom_children (basic_block) FINAL OVERRIDE;\n@@ -6645,7 +6650,7 @@ class vrp_dom_walker : public dom_walker\n   vrp_dom_walker (cdi_direction direction,\n \t\t  class const_and_copies *const_and_copies,\n \t\t  class avail_exprs_stack *avail_exprs_stack)\n-    : dom_walker (direction, true),\n+    : dom_walker (direction, REACHABLE_BLOCKS),\n       m_const_and_copies (const_and_copies),\n       m_avail_exprs_stack (avail_exprs_stack),\n       m_dummy_cond (NULL) {}\n@@ -6835,6 +6840,18 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n \t\t\twi::to_wide (vr->max));\n     }\n \n+  /* If we're checking array refs, we want to merge information on\n+     the executability of each edge between vrp_folder and the\n+     check_array_bounds_dom_walker: each can clear the\n+     EDGE_EXECUTABLE flag on edges, in different ways.\n+\n+     Hence, if we're going to call check_all_array_refs, set\n+     the flag on every edge now, rather than in\n+     check_array_bounds_dom_walker's ctor; vrp_folder may clear\n+     it from some edges.  */\n+  if (warn_array_bounds && warn_array_bounds_p)\n+    set_all_edges_as_executable (cfun);\n+\n   class vrp_folder vrp_folder;\n   vrp_folder.vr_values = &vr_values;\n   vrp_folder.substitute_and_fold ();"}]}