{"sha": "b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcwNDhhYjdiMmIxMDlhODMyMDgxZDNmMmQ5OTBjMTdhZTNjZGRhNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-03-03T18:31:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-03-03T18:31:36Z"}, "message": "re PR rtl-optimization/13862 (ICE while optimizing asm)\n\n        PR opt/13862\n        * cselib.c (cselib_record_sets): Don't record multiple sets in\n        asm insns.\n\nFrom-SVN: r78845", "tree": {"sha": "bd9cbe3b3591e4199a27b80524fcbe954ba79dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd9cbe3b3591e4199a27b80524fcbe954ba79dc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/comments", "author": null, "committer": null, "parents": [{"sha": "039e3c5c4563e9530ec2aec77eed1096c9d27a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039e3c5c4563e9530ec2aec77eed1096c9d27a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039e3c5c4563e9530ec2aec77eed1096c9d27a0b"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "814f285b8d5346fe9986fe8ca6c85b115143655d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "patch": "@@ -1,3 +1,9 @@\n+2003-03-03  Richard Henderson  <rth@redhat.com>\n+\n+\tPR opt/13862\n+\t* cselib.c (cselib_record_sets): Don't record multiple sets in\n+\tasm insns.\n+\n 2004-03-03  Mostafa Hagog  <mustafa@il.ibm.com>\n \n \t* common.opt: Add description of the new -fgcse-after-reload flag."}, {"sha": "7cc37f1915a0f5e0c64137a6f71abb03ad8084e5", "filename": "gcc/cselib.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "patch": "@@ -1293,6 +1293,29 @@ cselib_record_sets (rtx insn)\n      locations may go away.  */\n   note_stores (body, cselib_invalidate_rtx, NULL);\n \n+  /* If this is an asm, look for duplicate sets.  This can happen when the\n+     user uses the same value as an output multiple times.  This is valid\n+     if the outputs are not actually used thereafter.  Treat this case as\n+     if the value isn't actually set.  We do this by smashing the destination\n+     to pc_rtx, so that we won't record the value later.  */\n+  if (n_sets >= 2 && asm_noperands (body) >= 0)\n+    {\n+      for (i = 0; i < n_sets; i++)\n+\t{\n+\t  rtx dest = sets[i].dest;\n+\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+\t    {\n+\t      int j;\n+\t      for (j = i + 1; j < n_sets; j++)\n+\t\tif (rtx_equal_p (dest, sets[j].dest))\n+\t\t  {\n+\t\t    sets[i].dest = pc_rtx;\n+\t\t    sets[j].dest = pc_rtx;\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+\n   /* Now enter the equivalences in our tables.  */\n   for (i = 0; i < n_sets; i++)\n     {"}, {"sha": "e143ea3697886fc9ef1c9e7424cc549cf354fce7", "filename": "gcc/testsuite/gcc.dg/i386-asm-2.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-asm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7048ab7b2b109a832081d3f2d990c17ae3cdda5/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-asm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-asm-2.c?ref=b7048ab7b2b109a832081d3f2d990c17ae3cdda5", "patch": "@@ -0,0 +1,61 @@\n+/* PR opt/13862 */\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O\" } */\n+\n+typedef struct _fame_syntax_t_ {\n+} fame_syntax_t;\n+\n+typedef struct _fame_bitbuffer_t_\n+{\n+  unsigned char * base;\n+  unsigned char * data;\n+  unsigned long shift;\n+} fame_bitbuffer_t;\n+\n+#define fast_bitbuffer_write(data, shift, c, l)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int d;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  asm(\"add %1, %%ecx\\n\"            /* ecx = shift + length */\t\t\\\n+      \"shrd %%cl, %2, %3\\n\"        /* adjust code to fit in */\t\t\\\n+      \"shr %%cl, %2\\n\"             /* adjust code to fit in */\t\t\\\n+      \"mov %%ecx, %1\\n\"            /* shift += length */\t\t\\\n+      \"bswap %2\\n\"                 /* reverse byte order of code */\t\\\n+      \"shr $5, %%ecx\\n\"            /* get dword increment */            \\\n+      \"or %2, (%0)\\n\"              /* put first 32 bits */\t\t\\\n+      \"bswap %3\\n\"                 /* reverse byte order of code */\t\\\n+      \"lea   (%0, %%ecx, 4), %0\\n\" /* data += (ecx>32) */\t\t\\\n+      \"andl $31, %1\\n\"             /* mask shift */\t\t\t\\\n+      \"orl %3, (%0)\\n\"             /* put last 32 bits */\t\t\\\n+      : \"=r\"(data), \"=r\"(shift), \"=a\"(d), \"=d\"(d), \"=c\"(d)\t\t\\\n+      : \"0\"(data), \"1\"(shift), \"2\"((unsigned long) c), \"3\"(0),\t\t\\\n+\t\"c\"((unsigned long) l)\t\t\t\t\t\t\\\n+      : \"memory\");\t\t\t\t\t\t\t\\\n+}\n+\n+#define bitbuffer_write(bb, c, l) \\\n+  fast_bitbuffer_write((bb)->data, (bb)->shift, c, l)\n+\n+typedef enum { frame_type_I, frame_type_P } frame_type_t;\n+\n+typedef struct _fame_syntax_mpeg1_t_ {\n+  fame_bitbuffer_t buffer;\n+  frame_type_t frame_type;\n+} fame_syntax_mpeg1_t;\n+\n+#define FAME_SYNTAX_MPEG1(x) ((fame_syntax_mpeg1_t *) x)\n+\n+void mpeg1_start_picture(fame_syntax_t *syntax)\n+{\n+  fame_syntax_mpeg1_t *syntax_mpeg1 = FAME_SYNTAX_MPEG1(syntax);\n+  bitbuffer_write(&syntax_mpeg1->buffer, 0xFFFF, 16); \n+\n+  switch(syntax_mpeg1->frame_type) {\n+    case frame_type_I:\n+      bitbuffer_write(&syntax_mpeg1->buffer, 0, 1);  \n+    break;\n+    case frame_type_P:\n+      bitbuffer_write(&syntax_mpeg1->buffer, 0, 1);\n+    break;\n+  }\n+}"}]}