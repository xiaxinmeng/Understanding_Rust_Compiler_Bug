{"sha": "15c2ef5ad3e24b393be17bcea677d1972bfe0945", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVjMmVmNWFkM2UyNGIzOTNiZTE3YmNlYTY3N2QxOTcyYmZlMDk0NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-09-20T18:55:12Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-09-20T18:55:12Z"}, "message": "re PR fortran/45081 (ICE in gfc_conv_array_initializer, at fortran/trans-array.c:4208)\n\n2010-09-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/45081\n\t* simplify.c (is_constant_array_expr): Allow structure array\n\telements as well as constants.\n\t(gfc_simplify_pack, gfc_simplify_reshape, gfc_simplify_spread,\n\tgfc_simplify_transpose, gfc_simplify_unpack): Copy the derived\n\ttype of source to the result.\n\n2010-09-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/45081\n\t* gfortran.dg/derived_array_intrinsics_1.f90 : New test.\n\nFrom-SVN: r164448", "tree": {"sha": "4fefd5f0a20782b1864cb03958e075ea4d9de51c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fefd5f0a20782b1864cb03958e075ea4d9de51c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15c2ef5ad3e24b393be17bcea677d1972bfe0945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c2ef5ad3e24b393be17bcea677d1972bfe0945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c2ef5ad3e24b393be17bcea677d1972bfe0945", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c2ef5ad3e24b393be17bcea677d1972bfe0945/comments", "author": null, "committer": null, "parents": [{"sha": "abc88a0827e475e92a4e39dac93b5f4ca7407ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc88a0827e475e92a4e39dac93b5f4ca7407ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc88a0827e475e92a4e39dac93b5f4ca7407ea6"}], "stats": {"total": 59, "additions": 58, "deletions": 1}, "files": [{"sha": "d80a522cab936c3919e2ecbf5a8db26127721278", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=15c2ef5ad3e24b393be17bcea677d1972bfe0945", "patch": "@@ -1,3 +1,12 @@\n+2010-09-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/45081\n+\t* simplify.c (is_constant_array_expr): Allow structure array\n+\telements as well as constants.\n+\t(gfc_simplify_pack, gfc_simplify_reshape, gfc_simplify_spread,\n+\tgfc_simplify_transpose, gfc_simplify_unpack): Copy the derived\n+\ttype of source to the result.\n+\n 2010-09-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* frontend-passes.c (gfc_expr_walker):  Also"}, {"sha": "c8d8a896c4e17417481afd43ed7abf34fadd9ae9", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=15c2ef5ad3e24b393be17bcea677d1972bfe0945", "patch": "@@ -235,7 +235,8 @@ is_constant_array_expr (gfc_expr *e)\n \n   for (c = gfc_constructor_first (e->value.constructor);\n        c; c = gfc_constructor_next (c))\n-    if (c->expr->expr_type != EXPR_CONSTANT)\n+    if (c->expr->expr_type != EXPR_CONSTANT\n+\t  && c->expr->expr_type != EXPR_STRUCTURE)\n       return false;\n \n   return true;\n@@ -4550,6 +4551,8 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n     return NULL;\n \n   result = gfc_get_array_expr (array->ts.type, array->ts.kind, &array->where);\n+  if (array->ts.type == BT_DERIVED)\n+    result->ts.u.derived = array->ts.u.derived;\n \n   array_ctor = gfc_constructor_first (array->value.constructor);\n   vector_ctor = vector\n@@ -4982,6 +4985,8 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,\n \n   result = gfc_get_array_expr (source->ts.type, source->ts.kind,\n \t\t\t       &source->where);\n+  if (source->ts.type == BT_DERIVED)\n+    result->ts.u.derived = source->ts.u.derived;\n   result->rank = rank;\n   result->shape = gfc_get_shape (rank);\n   for (i = 0; i < rank; i++)\n@@ -5732,6 +5737,8 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp\n \n       result = gfc_get_array_expr (source->ts.type, source->ts.kind,\n \t\t\t\t   &source->where);\n+      if (source->ts.type == BT_DERIVED)\n+\tresult->ts.u.derived = source->ts.u.derived;\n       result->rank = 1;\n       result->shape = gfc_get_shape (result->rank);\n       mpz_init_set_si (result->shape[0], ncopies);\n@@ -5750,6 +5757,8 @@ gfc_simplify_spread (gfc_expr *source, gfc_expr *dim_expr, gfc_expr *ncopies_exp\n \n       result = gfc_get_array_expr (source->ts.type, source->ts.kind,\n \t\t\t\t   &source->where);\n+      if (source->ts.type == BT_DERIVED)\n+\tresult->ts.u.derived = source->ts.u.derived;\n       result->rank = source->rank + 1;\n       result->shape = gfc_get_shape (result->rank);\n \n@@ -6038,6 +6047,8 @@ gfc_simplify_transpose (gfc_expr *matrix)\n \n   if (matrix->ts.type == BT_CHARACTER)\n     result->ts.u.cl = matrix->ts.u.cl;\n+  else if (matrix->ts.type == BT_DERIVED)\n+    result->ts.u.derived = matrix->ts.u.derived;\n \n   matrix_rows = mpz_get_si (matrix->shape[0]);\n   matrix_cols = mpz_get_si (matrix->shape[1]);\n@@ -6341,6 +6352,8 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \n   result = gfc_get_array_expr (vector->ts.type, vector->ts.kind,\n \t\t\t       &vector->where);\n+  if (vector->ts.type == BT_DERIVED)\n+    result->ts.u.derived = vector->ts.u.derived;\n   result->rank = mask->rank;\n   result->shape = gfc_copy_shape (mask->shape, mask->rank);\n "}, {"sha": "3d4bcf9415767eee801a5da888de0439d032e386", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15c2ef5ad3e24b393be17bcea677d1972bfe0945", "patch": "@@ -1,3 +1,8 @@\n+2010-09-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/45081\n+\t* gfortran.dg/derived_array_intrinsics_1.f90 : New test.\n+\n 2010-09-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* g++.dg/tree-ssa/pr45605.C: Add \"\\\\\"."}, {"sha": "07d89854eb73383c1bebcf788f69bf643bc76d46", "filename": "gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_array_intrinisics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c2ef5ad3e24b393be17bcea677d1972bfe0945/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_array_intrinisics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_array_intrinisics_1.f90?ref=15c2ef5ad3e24b393be17bcea677d1972bfe0945", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+! Test the fix for PR45081 in which derived type array valued intrinsics failed\n+! to simplify, which caused an ICE in trans-array.c\n+!\n+! Contributed by Thorsten Ohl <ohl@physik.uni-wuerzburg.de>\n+! \n+  module m\n+    implicit none\n+    integer :: i\n+    type t\n+      integer :: i\n+    end type t\n+    type(t), dimension(4), parameter :: t1  = [( t(i), i = 1, 4)]\n+    type(t), dimension(4), parameter :: t2  = [( t(i), i = 8, 11)]\n+    type(t), dimension(2,2), parameter :: a = reshape ( t1, [ 2, 2 ] )\n+    type(t), dimension(2,2), parameter :: b = transpose (a)\n+    type(t), dimension(4), parameter :: c = reshape ( b, [ 4 ] )\n+    type(t), dimension(2), parameter :: d = pack ( c, [.false.,.true.,.false.,.true.])\n+    type(t), dimension(4), parameter :: e = unpack (d, [.false.,.true.,.false.,.true.], t2)\n+    type(t), dimension(4,2), parameter :: f = spread (e, 2, 2)\n+    type(t), dimension(8), parameter :: g = reshape ( f, [ 8 ] )\n+    integer, parameter :: total = sum(g%i)\n+  end module m\n+\n+    use m\n+    integer :: j\n+    j = total\n+  end\n+! { dg-final { scan-tree-dump-times \"j = 50\" 1 \"original\" } }"}]}