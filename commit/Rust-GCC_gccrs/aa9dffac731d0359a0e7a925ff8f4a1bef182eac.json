{"sha": "aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5ZGZmYWM3MzFkMDM1OWEwZTdhOTI1ZmY4ZjRhMWJlZjE4MmVhYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-17T11:48:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-17T11:48:45Z"}, "message": "tree-vect-loop.c (needs_fold_left_reduction_p): Export.\n\n2019-10-17  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (needs_fold_left_reduction_p): Export.\n\t(vect_is_simple_reduction): Move all validity checks ...\n\t(vectorizable_reduction): ... here.  Compute whether we\n\tneed a fold-left reduction here.\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Merge\n\tboth overloads, check needs_fold_left_reduction_p directly.\n\t* tree-vectorizer.h (needs_fold_left_reduction_p): Declare.\n\nFrom-SVN: r277100", "tree": {"sha": "63f122fab3cd3141e4f8ebbfc2cd06115b7ee28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63f122fab3cd3141e4f8ebbfc2cd06115b7ee28b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "728ece16a633863c0a2f78239dc2679167b099dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728ece16a633863c0a2f78239dc2679167b099dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728ece16a633863c0a2f78239dc2679167b099dc"}], "stats": {"total": 161, "additions": 80, "deletions": 81}, "files": [{"sha": "eebb890282bd6eacda972a5708d8e9dc6da4b4d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "patch": "@@ -1,3 +1,13 @@\n+2019-10-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (needs_fold_left_reduction_p): Export.\n+\t(vect_is_simple_reduction): Move all validity checks ...\n+\t(vectorizable_reduction): ... here.  Compute whether we\n+\tneed a fold-left reduction here.\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Merge\n+\tboth overloads, check needs_fold_left_reduction_p directly.\n+\t* tree-vectorizer.h (needs_fold_left_reduction_p): Declare.\n+\n 2019-10-17  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Fix"}, {"sha": "0ad32cec2e2a0cc2aa59e3fdabe7144d5cc6c80b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "patch": "@@ -2536,7 +2536,7 @@ report_vect_op (dump_flags_t msg_type, gimple *stmt, const char *msg)\n    on type TYPE.  NEED_WRAPPING_INTEGRAL_OVERFLOW is true if integer\n    overflow must wrap.  */\n \n-static bool\n+bool\n needs_fold_left_reduction_p (tree type, tree_code code)\n {\n   /* CHECKME: check for !flag_finite_math_only too?  */\n@@ -2888,13 +2888,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       op1 = gimple_assign_rhs2 (def_stmt);\n       op2 = gimple_assign_rhs3 (def_stmt);\n     }\n-  else if (!commutative_tree_code (code) || !associative_tree_code (code))\n-    {\n-      if (dump_enabled_p ())\n-\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: not commutative/associative: \");\n-      return NULL;\n-    }\n   else if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS)\n     {\n       op1 = gimple_assign_rhs1 (def_stmt);\n@@ -2917,18 +2910,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       return NULL;\n     }\n \n-  /* Check whether it's ok to change the order of the computation.\n-     Generally, when vectorizing a reduction we change the order of the\n-     computation.  This may change the behavior of the program in some\n-     cases, so we need to check that this is ok.  One exception is when\n-     vectorizing an outer-loop: the inner-loop is executed sequentially,\n-     and therefore vectorizing reductions in the inner-loop during\n-     outer-loop vectorization is safe.  */\n-  tree type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n-  if (STMT_VINFO_REDUC_TYPE (phi_info) == TREE_CODE_REDUCTION\n-      && needs_fold_left_reduction_p (type, code))\n-    STMT_VINFO_REDUC_TYPE (phi_info) = FOLD_LEFT_REDUCTION;\n-\n   /* Reduction is safe. We're dealing with one of the following:\n      1) integer arithmetic and no trapv\n      2) floating point arithmetic, and special flags permit this optimization\n@@ -5633,7 +5614,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code;\n-  internal_fn reduc_fn;\n   int op_type;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n   stmt_vec_info cond_stmt_vinfo = NULL;\n@@ -5873,19 +5853,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n      operation in the reduction meta.  */\n   STMT_VINFO_REDUC_IDX (reduc_info) = reduc_index;\n \n-  /* When vectorizing a reduction chain w/o SLP the reduction PHI is not\n-     directy used in stmt.  */\n-  if (reduc_index == -1)\n-    {\n-      if (STMT_VINFO_REDUC_TYPE (phi_info) == FOLD_LEFT_REDUCTION)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"in-order reduction chain without SLP.\\n\");\n-\t  return false;\n-\t}\n-    }\n-\n   if (!(reduc_index == -1\n \t|| dts[reduc_index] == vect_reduction_def\n \t|| dts[reduc_index] == vect_nested_cycle\n@@ -6048,17 +6015,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       double_reduc = true;\n     }\n \n-  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n-  if ((double_reduc || reduction_type != TREE_CODE_REDUCTION)\n-      && ncopies > 1)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"multiple types in double reduction or condition \"\n-\t\t\t \"reduction.\\n\");\n-      return false;\n-    }\n-\n   /* 4.2. Check support for the epilog operation.\n \n           If STMT represents a reduction pattern, then the type of the\n@@ -6094,38 +6050,75 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n           (and also the same tree-code) when generating the epilog code and\n           when generating the code inside the loop.  */\n \n-  enum tree_code orig_code;\n-  if (orig_stmt_info\n-      && (reduction_type == TREE_CODE_REDUCTION\n-\t  || reduction_type == FOLD_LEFT_REDUCTION))\n+  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n+  enum tree_code orig_code = ERROR_MARK;\n+  if (reduction_type == CONST_COND_REDUCTION\n+      || reduction_type == INTEGER_INDUC_COND_REDUCTION)\n     {\n-      /* This is a reduction pattern: get the vectype from the type of the\n-         reduction variable, and get the tree-code from orig_stmt.  */\n-      orig_code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n-      gcc_assert (vectype_out);\n+      /* For simple condition reductions, replace with the actual expression\n+\t we want to base our reduction around.  */\n+      orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info);\n+      gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n     }\n-  else\n+  else if (reduction_type == COND_REDUCTION)\n+    orig_code = COND_EXPR;\n+  else if (reduction_type == TREE_CODE_REDUCTION\n+\t   || reduction_type == FOLD_LEFT_REDUCTION)\n     {\n-      /* Regular reduction: use the same vectype and tree-code as used for\n-         the vector code inside the loop can be used for the epilog code. */\n-      orig_code = code;\n-\n-      if (code == MINUS_EXPR)\n+      if (orig_stmt_info)\n+\torig_code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n+      else\n+\torig_code = code;\n+      gcc_assert (vectype_out);\n+      if (orig_code == MINUS_EXPR)\n \torig_code = PLUS_EXPR;\n+    }\n+  STMT_VINFO_REDUC_CODE (reduc_info) = orig_code;\n \n-      /* For simple condition reductions, replace with the actual expression\n-\t we want to base our reduction around.  */\n-      if (reduction_type == CONST_COND_REDUCTION\n-\t  || reduction_type == INTEGER_INDUC_COND_REDUCTION)\n+  if (reduction_type == TREE_CODE_REDUCTION)\n+    {\n+      /* Check whether it's ok to change the order of the computation.\n+\t Generally, when vectorizing a reduction we change the order of the\n+\t computation.  This may change the behavior of the program in some\n+\t cases, so we need to check that this is ok.  One exception is when\n+\t vectorizing an outer-loop: the inner-loop is executed sequentially,\n+\t and therefore vectorizing reductions in the inner-loop during\n+\t outer-loop vectorization is safe.  */\n+      if (needs_fold_left_reduction_p (scalar_type, orig_code))\n+\t{\n+\t  STMT_VINFO_REDUC_TYPE (reduc_info)\n+\t    = reduction_type = FOLD_LEFT_REDUCTION;\n+\t  /* When vectorizing a reduction chain w/o SLP the reduction PHI is not\n+\t     directy used in stmt.  */\n+\t  if (reduc_index == -1)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"in-order reduction chain without SLP.\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+      else if (!commutative_tree_code (orig_code)\n+\t       || !associative_tree_code (orig_code))\n \t{\n-\t  orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info);\n-\t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t    \"reduction: not commutative/associative\");\n+\t  return false;\n \t}\n     }\n-  STMT_VINFO_REDUC_CODE (reduc_info) = orig_code;\n \n-  reduc_fn = IFN_LAST;\n+  if ((double_reduc || reduction_type != TREE_CODE_REDUCTION)\n+      && ncopies > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"multiple types in double reduction or condition \"\n+\t\t\t \"reduction or fold-left reduction.\\n\");\n+      return false;\n+    }\n \n+  internal_fn reduc_fn = IFN_LAST;\n   if (reduction_type == TREE_CODE_REDUCTION\n       || reduction_type == FOLD_LEFT_REDUCTION\n       || reduction_type == INTEGER_INDUC_COND_REDUCTION"}, {"sha": "5387563a15edfedbeab2b57d635f2a1304f20c8c", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "patch": "@@ -833,19 +833,8 @@ vect_convert_output (stmt_vec_info stmt_info, tree type, gimple *pattern_stmt,\n /* Return true if STMT_VINFO describes a reduction for which reassociation\n    is allowed.  If STMT_INFO is part of a group, assume that it's part of\n    a reduction chain and optimistically assume that all statements\n-   except the last allow reassociation.  */\n-\n-static bool\n-vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n-{\n-  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n-    return (STMT_VINFO_REDUC_TYPE (STMT_VINFO_REDUC_DEF (stmt_vinfo))\n-\t    != FOLD_LEFT_REDUCTION);\n-  else\n-    return REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL;\n-}\n-\n-/* As above, but also require it to have code CODE and to be a reduction\n+   except the last allow reassociation.\n+   Also require it to have code CODE and to be a reduction\n    in the outermost loop.  When returning true, store the operands in\n    *OP0_OUT and *OP1_OUT.  */\n \n@@ -867,7 +856,13 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_info, tree_code code,\n   if (loop && nested_in_vect_loop_p (loop, stmt_info))\n     return false;\n \n-  if (!vect_reassociating_reduction_p (stmt_info))\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+    {\n+      if (needs_fold_left_reduction_p (TREE_TYPE (gimple_assign_lhs (assign)),\n+\t\t\t\t       code))\n+\treturn false;\n+    }\n+  else if (REDUC_GROUP_FIRST_ELEMENT (stmt_info) == NULL)\n     return false;\n \n   *op0_out = gimple_assign_rhs1 (assign);"}, {"sha": "559d78d4491c8644118aafaa5947122d0fe683c5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9dffac731d0359a0e7a925ff8f4a1bef182eac/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=aa9dffac731d0359a0e7a925ff8f4a1bef182eac", "patch": "@@ -1632,6 +1632,7 @@ extern widest_int vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo);\n /* Used in gimple-loop-interchange.c and tree-parloops.c.  */\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);\n+extern bool needs_fold_left_reduction_p (tree, tree_code);\n /* Drive for loop analysis stage.  */\n extern opt_loop_vec_info vect_analyze_loop (class loop *,\n \t\t\t\t\t    loop_vec_info,"}]}