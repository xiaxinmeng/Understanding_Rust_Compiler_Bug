{"sha": "53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNjZDE4ZWM4ZWZlNzk0MDY0MjA4ZTRhNWYwYWUyMGMyZTJlYTBiOA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-01-20T01:38:27Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-01-20T01:38:27Z"}, "message": "c-decl.c (c_init_decl_processing): Set pedantic_lvalues to true unconditionally.\n\n\t* c-decl.c (c_init_decl_processing): Set pedantic_lvalues to\n\ttrue unconditionally.\n\t* c-typeck.c (unary_complex_lvalue, pedantic_lvalue_warning):\n\tRemove.\n\t(build_unary_op, build_modify_expr): Don't handle extended\n\tlvalues.\n\t(build_component_ref, build_conditional_expr): Call non_lvalue\n\tinstead of pedantic_non_lvalue.\n\t(build_c_cast): Don't condition use of non_lvalue on pedantic.\n\t* fold-const.c (fold): Don't check pedantic directly for\n\tCOMPOUND_EXPR.  Ensure that results for COMPOUND_EXPR are\n\tpassed to pedantic_non_lvalue.\n\t* doc/extend.texi: Remove documentation of extended lvalues.\n\ntestsuite:\n\t* gcc.c-torture/compile/981022-1.c: Remove.\n\t* gcc.dg/array-5.c: Remove XFAIL.\n\t* gcc.dg/sequence-pt-1.c: Remove test using extended lvalues.\n\t* gcc.dg/cast-lvalue-1.c, gcc.dg/compound-lvalue-1.c,\n\tgcc.dg/cond-lvalue-1.c: Update.\n\t* gcc.dg/cast-lvalue-2.c: New test.\n\nFrom-SVN: r76192", "tree": {"sha": "dffc7ec646ed782d1cf4c5f053cb52946bc4ee1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dffc7ec646ed782d1cf4c5f053cb52946bc4ee1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d11ccc820b7795c7919c5b2ca6a2001a6c044c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d11ccc820b7795c7919c5b2ca6a2001a6c044c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d11ccc820b7795c7919c5b2ca6a2001a6c044c"}], "stats": {"total": 371, "additions": 56, "deletions": 315}, "files": [{"sha": "c2a1a5016072e789e1f699b524d052a0d40f106c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -1,3 +1,19 @@\n+2004-01-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-decl.c (c_init_decl_processing): Set pedantic_lvalues to\n+\ttrue unconditionally.\n+\t* c-typeck.c (unary_complex_lvalue, pedantic_lvalue_warning):\n+\tRemove.\n+\t(build_unary_op, build_modify_expr): Don't handle extended\n+\tlvalues.\n+\t(build_component_ref, build_conditional_expr): Call non_lvalue\n+\tinstead of pedantic_non_lvalue.\n+\t(build_c_cast): Don't condition use of non_lvalue on pedantic.\n+\t* fold-const.c (fold): Don't check pedantic directly for\n+\tCOMPOUND_EXPR.  Ensure that results for COMPOUND_EXPR are\n+\tpassed to pedantic_non_lvalue.\n+\t* doc/extend.texi: Remove documentation of extended lvalues.\n+\n 2004-01-19  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/5263"}, {"sha": "93360bebbc0b997ed852809b2d80935c6a9ebc02", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -2282,7 +2282,7 @@ c_init_decl_processing (void)\n \n   input_location = save_loc;\n \n-  pedantic_lvalues = pedantic;\n+  pedantic_lvalues = true;\n \n   make_fname_decl = c_make_fname_decl;\n   start_fname_decls ();"}, {"sha": "b6a5d9ee30e552d6e723f392b00b603b865cac2c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 208, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -60,8 +60,6 @@ static tree default_function_array_conversion (tree);\n static tree lookup_field (tree, tree);\n static tree convert_arguments (tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n-static tree unary_complex_lvalue (enum tree_code, tree, int);\n-static void pedantic_lvalue_warning (enum tree_code);\n static tree internal_build_compound_expr (tree, int);\n static tree convert_for_assignment (tree, tree, const char *, tree, tree,\n \t\t\t\t    int);\n@@ -1303,7 +1301,7 @@ build_component_ref (tree datum, tree component)\n   tree ref;\n \n   /* If DATUM is a COMPOUND_EXPR, move our reference inside it.\n-     If pedantic ensure that the arguments are not lvalues; otherwise,\n+     Ensure that the arguments are not lvalues; otherwise,\n      if the component is an array, it would wrongly decay to a pointer in\n      C89 mode.\n      We cannot do this with a COND_EXPR, because in a conditional expression\n@@ -1316,7 +1314,7 @@ build_component_ref (tree datum, tree component)\n       {\n \ttree value = build_component_ref (TREE_OPERAND (datum, 1), component);\n \treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t      TREE_OPERAND (datum, 0), pedantic_non_lvalue (value));\n+\t\t      TREE_OPERAND (datum, 0), non_lvalue (value));\n       }\n     default:\n       break;\n@@ -2287,12 +2285,6 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      /* Handle complex lvalues (when permitted)\n-\t by reduction to simpler cases.  */\n-\n-      val = unary_complex_lvalue (code, arg, 0);\n-      if (val != 0)\n-\treturn val;\n \n       /* Increment or decrement the real part of the value,\n \t and don't change the imaginary part.  */\n@@ -2360,57 +2352,6 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \n \tinc = convert (argtype, inc);\n \n-\t/* Handle incrementing a cast-expression.  */\n-\n-\twhile (1)\n-\t  switch (TREE_CODE (arg))\n-\t    {\n-\t    case NOP_EXPR:\n-\t    case CONVERT_EXPR:\n-\t    case FLOAT_EXPR:\n-\t    case FIX_TRUNC_EXPR:\n-\t    case FIX_FLOOR_EXPR:\n-\t    case FIX_ROUND_EXPR:\n-\t    case FIX_CEIL_EXPR:\n-\t      pedantic_lvalue_warning (CONVERT_EXPR);\n-\t      /* If the real type has the same machine representation\n-\t\t as the type it is cast to, we can make better output\n-\t\t by adding directly to the inside of the cast.  */\n-\t      if ((TREE_CODE (TREE_TYPE (arg))\n-\t\t   == TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\t\t  && (TYPE_MODE (TREE_TYPE (arg))\n-\t\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (arg, 0)))))\n-\t\targ = TREE_OPERAND (arg, 0);\n-\t      else\n-\t\t{\n-\t\t  tree incremented, modify, value;\n-\t\t  if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n-\t\t    value = boolean_increment (code, arg);\n-\t\t  else\n-\t\t    {\n-\t\t      arg = stabilize_reference (arg);\n-\t\t      if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n-\t\t\tvalue = arg;\n-\t\t      else\n-\t\t\tvalue = save_expr (arg);\n-\t\t      incremented = build (((code == PREINCREMENT_EXPR\n-\t\t\t\t\t     || code == POSTINCREMENT_EXPR)\n-\t\t\t\t\t    ? PLUS_EXPR : MINUS_EXPR),\n-\t\t\t\t\t   argtype, value, inc);\n-\t\t      TREE_SIDE_EFFECTS (incremented) = 1;\n-\t\t      modify = build_modify_expr (arg, NOP_EXPR, incremented);\n-\t\t      value = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n-\t\t    }\n-\t\t  TREE_USED (value) = 1;\n-\t\t  return value;\n-\t\t}\n-\t      break;\n-\n-\t    default:\n-\t      goto give_up;\n-\t    }\n-      give_up:\n-\n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t    || code == POSTINCREMENT_EXPR)\n@@ -2457,12 +2398,6 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t\t\t\t  TREE_OPERAND (arg, 1), 1);\n \t}\n \n-      /* Handle complex lvalues (when permitted)\n-\t by reduction to simpler cases.  */\n-      val = unary_complex_lvalue (code, arg, flag);\n-      if (val != 0)\n-\treturn val;\n-\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n       else if (typecode != FUNCTION_TYPE && !flag\n@@ -2580,67 +2515,6 @@ lvalue_or_else (tree ref, const char *msgid)\n   return win;\n }\n \n-/* Apply unary lvalue-demanding operator CODE to the expression ARG\n-   for certain kinds of expressions which are not really lvalues\n-   but which we can accept as lvalues.  If FLAG is nonzero, then\n-   non-lvalues are OK since we may be converting a non-lvalue array to\n-   a pointer in C99.\n-\n-   If ARG is not a kind of expression we can handle, return zero.  */\n-\n-static tree\n-unary_complex_lvalue (enum tree_code code, tree arg, int flag)\n-{\n-  /* Handle (a, b) used as an \"lvalue\".  */\n-  if (TREE_CODE (arg) == COMPOUND_EXPR)\n-    {\n-      tree real_result = build_unary_op (code, TREE_OPERAND (arg, 1), 0);\n-\n-      /* If this returns a function type, it isn't really being used as\n-\t an lvalue, so don't issue a warning about it.  */\n-      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE && !flag)\n-\tpedantic_lvalue_warning (COMPOUND_EXPR);\n-\n-      return build (COMPOUND_EXPR, TREE_TYPE (real_result),\n-\t\t    TREE_OPERAND (arg, 0), real_result);\n-    }\n-\n-  /* Handle (a ? b : c) used as an \"lvalue\".  */\n-  if (TREE_CODE (arg) == COND_EXPR)\n-    {\n-      if (!flag)\n-\tpedantic_lvalue_warning (COND_EXPR);\n-      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE && !flag)\n-\tpedantic_lvalue_warning (COMPOUND_EXPR);\n-\n-      return (build_conditional_expr\n-\t      (TREE_OPERAND (arg, 0),\n-\t       build_unary_op (code, TREE_OPERAND (arg, 1), flag),\n-\t       build_unary_op (code, TREE_OPERAND (arg, 2), flag)));\n-    }\n-\n-  return 0;\n-}\n-\n-/* If pedantic, warn about improper lvalue.   CODE is either COND_EXPR\n-   COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */\n-\n-static void\n-pedantic_lvalue_warning (enum tree_code code)\n-{\n-  switch (code)\n-    {\n-    case COND_EXPR:\n-      pedwarn (\"use of conditional expressions as lvalues is deprecated\");\n-      break;\n-    case COMPOUND_EXPR:\n-      pedwarn (\"use of compound expressions as lvalues is deprecated\");\n-      break;\n-    default:\n-      pedwarn (\"use of cast expressions as lvalues is deprecated\");\n-      break;\n-    }\n-}\n \f\n /* Warn about storing in something that is `const'.  */\n \n@@ -2901,7 +2775,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     op2 = convert_and_check (result_type, op2);\n \n   if (TREE_CODE (ifexp) == INTEGER_CST)\n-    return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n+    return non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n \n   return fold (build (COND_EXPR, result_type, ifexp, op1, op2));\n }\n@@ -3158,14 +3032,14 @@ build_c_cast (tree type, tree expr)\n \t}\n     }\n \n-  /* Pedantically, don't let (void *) (FOO *) 0 be a null pointer constant.  */\n-  if (pedantic && TREE_CODE (value) == INTEGER_CST\n+  /* Don't let (void *) (FOO *) 0 be a null pointer constant.  */\n+  if (TREE_CODE (value) == INTEGER_CST\n       && TREE_CODE (expr) == INTEGER_CST\n       && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE)\n     value = non_lvalue (value);\n \n-  /* If pedantic, don't let a cast be an lvalue.  */\n-  if (value == expr && pedantic)\n+  /* Don't let a cast be an lvalue.  */\n+  if (value == expr)\n     value = non_lvalue (value);\n \n   return value;\n@@ -3216,45 +3090,6 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n   newrhs = rhs;\n \n-  /* Handle control structure constructs used as \"lvalues\".  */\n-\n-  switch (TREE_CODE (lhs))\n-    {\n-      /* Handle (a, b) used as an \"lvalue\".  */\n-    case COMPOUND_EXPR:\n-      pedantic_lvalue_warning (COMPOUND_EXPR);\n-      newrhs = build_modify_expr (TREE_OPERAND (lhs, 1), modifycode, rhs);\n-      if (TREE_CODE (newrhs) == ERROR_MARK)\n-\treturn error_mark_node;\n-      return build (COMPOUND_EXPR, lhstype,\n-\t\t    TREE_OPERAND (lhs, 0), newrhs);\n-\n-      /* Handle (a ? b : c) used as an \"lvalue\".  */\n-    case COND_EXPR:\n-      pedantic_lvalue_warning (COND_EXPR);\n-      rhs = save_expr (rhs);\n-      {\n-\t/* Produce (a ? (b = rhs) : (c = rhs))\n-\t   except that the RHS goes through a save-expr\n-\t   so the code to compute it is only emitted once.  */\n-\ttree cond\n-\t  = build_conditional_expr (TREE_OPERAND (lhs, 0),\n-\t\t\t\t    build_modify_expr (TREE_OPERAND (lhs, 1),\n-\t\t\t\t\t\t       modifycode, rhs),\n-\t\t\t\t    build_modify_expr (TREE_OPERAND (lhs, 2),\n-\t\t\t\t\t\t       modifycode, rhs));\n-\tif (TREE_CODE (cond) == ERROR_MARK)\n-\t  return cond;\n-\t/* Make sure the code to compute the rhs comes out\n-\t   before the split.  */\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (lhs),\n-\t\t      /* But cast it to void to avoid an \"unused\" error.  */\n-\t\t      convert (void_type_node, rhs), cond);\n-      }\n-    default:\n-      break;\n-    }\n-\n   /* If a binary op has been requested, combine the old LHS value with the RHS\n      producing the value we should actually store into the LHS.  */\n \n@@ -3264,42 +3099,6 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n     }\n \n-  /* Handle a cast used as an \"lvalue\".\n-     We have already performed any binary operator using the value as cast.\n-     Now convert the result to the cast type of the lhs,\n-     and then true type of the lhs and store it there;\n-     then convert result back to the cast type to be the value\n-     of the assignment.  */\n-\n-  switch (TREE_CODE (lhs))\n-    {\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-    case FLOAT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_ROUND_EXPR:\n-    case FIX_CEIL_EXPR:\n-      newrhs = default_function_array_conversion (newrhs);\n-      {\n-\ttree inner_lhs = TREE_OPERAND (lhs, 0);\n-\ttree result;\n-\tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n-\t\t\t\t    convert (TREE_TYPE (inner_lhs),\n-\t\t\t\t\t     convert (lhstype, newrhs)));\n-\tif (TREE_CODE (result) == ERROR_MARK)\n-\t  return result;\n-\tpedantic_lvalue_warning (CONVERT_EXPR);\n-\treturn convert (TREE_TYPE (lhs), result);\n-      }\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Now we have handled acceptable kinds of LHS that are not truly lvalues.\n-     Reject anything strange now.  */\n-\n   if (!lvalue_or_else (lhs, \"invalid lvalue in assignment\"))\n     return error_mark_node;\n "}, {"sha": "0eed679280e08dd2e315c210574271606fc1d348", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -429,7 +429,6 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Nested Functions::    As in Algol and Pascal, lexical scoping of functions.\n * Constructing Calls::\tDispatching a call to another function.\n * Typeof::              @code{typeof}: referring to the type of an expression.\n-* Lvalues::             Using @samp{?:}, @samp{,} and casts in lvalues.\n * Conditionals::        Omitting the middle operand of a @samp{?:} expression.\n * Long Long::\t\tDouble-word integers---@code{long long int}.\n * Complex::             Data types for complex numbers.\n@@ -1060,94 +1059,6 @@ typedef typeof(@var{expr}) @var{T};\n @noindent\n This will work with all versions of GCC@.\n \n-@node Lvalues\n-@section Generalized Lvalues\n-@cindex compound expressions as lvalues\n-@cindex expressions, compound, as lvalues\n-@cindex conditional expressions as lvalues\n-@cindex expressions, conditional, as lvalues\n-@cindex casts as lvalues\n-@cindex generalized lvalues\n-@cindex lvalues, generalized\n-@cindex extensions, @code{?:}\n-@cindex @code{?:} extensions\n-\n-Compound expressions, conditional expressions and casts are allowed as\n-lvalues provided their operands are lvalues.  This means that you can take\n-their addresses or store values into them.  All these extensions are\n-deprecated.\n-\n-Standard C++ allows compound expressions and conditional expressions\n-as lvalues, and permits casts to reference type, so use of this\n-extension is not supported for C++ code.\n-\n-For example, a compound expression can be assigned, provided the last\n-expression in the sequence is an lvalue.  These two expressions are\n-equivalent:\n-\n-@smallexample\n-(a, b) += 5\n-a, (b += 5)\n-@end smallexample\n-\n-Similarly, the address of the compound expression can be taken.  These two\n-expressions are equivalent:\n-\n-@smallexample\n-&(a, b)\n-a, &b\n-@end smallexample\n-\n-A conditional expression is a valid lvalue if its type is not void and the\n-true and false branches are both valid lvalues.  For example, these two\n-expressions are equivalent:\n-\n-@smallexample\n-(a ? b : c) = 5\n-(a ? b = 5 : (c = 5))\n-@end smallexample\n-\n-A cast is a valid lvalue if its operand is an lvalue.  This extension\n-is deprecated.  A simple\n-assignment whose left-hand side is a cast works by converting the\n-right-hand side first to the specified type, then to the type of the\n-inner left-hand side expression.  After this is stored, the value is\n-converted back to the specified type to become the value of the\n-assignment.  Thus, if @code{a} has type @code{char *}, the following two\n-expressions are equivalent:\n-\n-@smallexample\n-(int)a = 5\n-(int)(a = (char *)(int)5)\n-@end smallexample\n-\n-An assignment-with-arithmetic operation such as @samp{+=} applied to a cast\n-performs the arithmetic using the type resulting from the cast, and then\n-continues as in the previous case.  Therefore, these two expressions are\n-equivalent:\n-\n-@smallexample\n-(int)a += 5\n-(int)(a = (char *)(int) ((int)a + 5))\n-@end smallexample\n-\n-You cannot take the address of an lvalue cast, because the use of its\n-address would not work out coherently.  Suppose that @code{&(int)f} were\n-permitted, where @code{f} has type @code{float}.  Then the following\n-statement would try to store an integer bit-pattern where a floating\n-point number belongs:\n-\n-@smallexample\n-*&(int)f = 1;\n-@end smallexample\n-\n-This is quite different from what @code{(int)f = 1} would do---that\n-would convert 1 to floating point and store it.  Rather than cause this\n-inconsistency, we think it is better to prohibit use of @samp{&} on a cast.\n-\n-If you really do want an @code{int *} pointer with the address of\n-@code{f}, you can simply write @code{(int *)&f}.\n-\n @node Conditionals\n @section Conditionals with Omitted Operands\n @cindex conditional expressions, extensions"}, {"sha": "402a560cebf1d48b771ed3b42ca4030f2db9d4d6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -8170,12 +8170,12 @@ fold (tree expr)\n     case COMPOUND_EXPR:\n       /* When pedantic, a compound expression can be neither an lvalue\n \t nor an integer constant expression.  */\n-      if (TREE_SIDE_EFFECTS (arg0) || pedantic)\n+      if (TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n \treturn t;\n       /* Don't let (0, 0) be null pointer constant.  */\n       if (integer_zerop (arg1))\n-\treturn build1 (NOP_EXPR, type, arg1);\n-      return convert (type, arg1);\n+\treturn pedantic_non_lvalue (build1 (NOP_EXPR, type, arg1));\n+      return pedantic_non_lvalue (convert (type, arg1));\n \n     case COMPLEX_EXPR:\n       if (wins)"}, {"sha": "35ac2ab1af457d1202b7d2481da447971831ef0f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -1,3 +1,12 @@\n+2004-01-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.c-torture/compile/981022-1.c: Remove.\n+\t* gcc.dg/array-5.c: Remove XFAIL.\n+\t* gcc.dg/sequence-pt-1.c: Remove test using extended lvalues.\n+\t* gcc.dg/cast-lvalue-1.c, gcc.dg/compound-lvalue-1.c,\n+\tgcc.dg/cond-lvalue-1.c: Update.\n+\t* gcc.dg/cast-lvalue-2.c: New test.\n+\n 2004-01-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13592"}, {"sha": "46369fc81815327010a4c3149ccb9d26f3b3ca09", "filename": "gcc/testsuite/gcc.c-torture/compile/981022-1.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d11ccc820b7795c7919c5b2ca6a2001a6c044c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F981022-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d11ccc820b7795c7919c5b2ca6a2001a6c044c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F981022-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F981022-1.c?ref=87d11ccc820b7795c7919c5b2ca6a2001a6c044c", "patch": "@@ -1,9 +0,0 @@\n-/* This tests a combination of two gcc extensions.  Omitting the middle\n-   operand of ?: and using ?: as an lvalue.  */\n-int x, y;\n-\n-int main ()\n-{\n-  (x ?: y) = 0; /* { dg-bogus \"lvalue\" \"\" { xfail *-*-* } } */\n-  return 0;\n-}"}, {"sha": "1717de4ba8e3093b9db3d761101f6fb28481861e", "filename": "gcc/testsuite/gcc.dg/array-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Farray-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Farray-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-5.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -37,6 +37,6 @@ void func(int n, int m)\n        expression, and thus A is a VLA.  */\n     int a[6][(2, 2)];\n     int (*p)[3];\n-    p = a; /* { dg-bogus \"incompatible\" \"bad vla handling\" { xfail *-*-* } } */\n+    p = a; /* { dg-bogus \"incompatible\" \"bad vla handling\" } */\n   }\n }"}, {"sha": "4e84804e66dcee1f34db417ec77a1d0e4e89c244", "filename": "gcc/testsuite/gcc.dg/cast-lvalue-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-1.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -8,5 +8,6 @@ int x;\n void\n foo (void)\n {\n-  (char) x = 1; /* { dg-warning \"lvalue\" \"cast as lvalue deprecated\" } */\n+  (char) x = 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n }\n+/* { dg-error \"lvalue\" \"cast as lvalue\" { target *-*-* } 11 } */"}, {"sha": "ed6a2e69fe816fb56fb5a0781d1174c2610722a9", "filename": "gcc/testsuite/gcc.dg/cast-lvalue-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-lvalue-2.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -0,0 +1,13 @@\n+/* Test for error on casts as lvalues.  Casts to same type.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int x;\n+\n+void\n+foo (void)\n+{\n+  (int) x = 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+}\n+/* { dg-error \"lvalue\" \"cast as lvalue\" { target *-*-*} 11 } */"}, {"sha": "30ed58ff8a1ce0cc73aef694325f3e321ba5ddcc", "filename": "gcc/testsuite/gcc.dg/compound-lvalue-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcompound-lvalue-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcompound-lvalue-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompound-lvalue-1.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -8,5 +8,6 @@ int x, y;\n void\n foo (void)\n {\n-  (x, y) = 1; /* { dg-warning \"lvalue\" \"compound expression as lvalue deprecated\" } */\n+  (x, y) = 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n }\n+/* { dg-error \"lvalue\" \"compound expression as lvalue\" { target *-*-* } 11 } */"}, {"sha": "f2605af6ad65e859e1e8d87f8663e745fa305027", "filename": "gcc/testsuite/gcc.dg/cond-lvalue-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcond-lvalue-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcond-lvalue-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcond-lvalue-1.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -8,5 +8,6 @@ int x, y, z;\n void\n foo (void)\n {\n-  (x ? y : z) = 1; /* { dg-warning \"lvalue\" \"conditional expression as lvalue deprecated\" } */\n+  (x ? y : z) = 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n }\n+/* { dg-error \"lvalue\" \"conditional expression as lvalue\" { target *-*-* } 11 } */"}, {"sha": "29f809ca064fed1f7c5a17f0156c6db6415faab7", "filename": "gcc/testsuite/gcc.dg/sequence-pt-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c?ref=53cd18ec8efe794064208e4a5f0ae20c2e2ea0b8", "patch": "@@ -58,7 +58,6 @@ foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n   b = a, a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = (b++ ? n : a) + b; /* { dg-warning \"undefined\" \"sequence point warning\" { xfail *-*-* } } */\n   b ? a = a++ : a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n-  b ? a : a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b && (a = a++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   (a = a++) && b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b, (a = a++); /* { dg-warning \"undefined\" \"sequence point warning\" } */"}]}