{"sha": "0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4MGZiYWJlODE3YWNmZWNkNDRlYTJjYTQ4ZGYwYmIwYjdhZjljYg==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-11-09T11:40:17Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-11-09T11:40:17Z"}, "message": "[RTL-ifcvt] PR rtl-optimization/67749: Do not emit separate SET insn in IF-ELSE case\n\n\tPR rtl-optimization/67749\n\t* ifcvt.c (noce_try_cmove_arith): Do not emit move in IF-ELSE\n\tcase before emitting the two blocks.  Instead modify the register\n\tin the corresponding final insn of the basic block.\n\nFrom-SVN: r230014", "tree": {"sha": "572a6ba8e727b901c527faeed99eee95900d2d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/572a6ba8e727b901c527faeed99eee95900d2d0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6b6bf09dd34ed9a35cbc7d37d0fde1849450aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6b6bf09dd34ed9a35cbc7d37d0fde1849450aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6b6bf09dd34ed9a35cbc7d37d0fde1849450aad"}], "stats": {"total": 112, "additions": 72, "deletions": 40}, "files": [{"sha": "4e96aeb27f1ccaf134470e6054b89c9df7618901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "patch": "@@ -1,3 +1,10 @@\n+2015-11-09  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR rtl-optimization/67749\n+\t* ifcvt.c (noce_try_cmove_arith): Do not emit move in IF-ELSE\n+\tcase before emitting the two blocks.  Instead modify the register\n+\tin the corresponding final insn of the basic block.\n+\n 2015-11-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* acinclude.m4 (gcc_AC_INITFINI_ARRAY): Allow for differences in"}, {"sha": "59bda5e02c008cadf4c14c1ec9c715d9f26e7fdc", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0780fbabe817acfecd44ea2ca48df0bb0b7af9cb/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=0780fbabe817acfecd44ea2ca48df0bb0b7af9cb", "patch": "@@ -2017,92 +2017,117 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      emit might clobber the register used by B or A, so move it to a pseudo\n      first.  */\n \n+  rtx tmp_a = NULL_RTX;\n+  rtx tmp_b = NULL_RTX;\n+\n   if (b_simple || !else_bb)\n-    {\n-      rtx tmp_b = gen_reg_rtx (x_mode);\n-      /* Perform the simplest kind of set.  The register allocator\n-\t should remove it if it's not actually needed.  If this set is not\n-\t a valid insn (can happen on the is_mem path) then end_ifcvt_sequence\n-\t will cancel the whole sequence.  Don't try any of the fallback paths\n-\t from noce_emit_move_insn since we want this to be the simplest kind\n-\t of move.  */\n-      emit_insn (gen_rtx_SET (tmp_b, b));\n-      b = tmp_b;\n-    }\n+    tmp_b = gen_reg_rtx (x_mode);\n \n   if (a_simple || !then_bb)\n-    {\n-      rtx tmp_a = gen_reg_rtx (x_mode);\n-      emit_insn (gen_rtx_SET (tmp_a, a));\n-      a = tmp_a;\n-    }\n+    tmp_a = gen_reg_rtx (x_mode);\n \n   orig_a = a;\n   orig_b = b;\n \n   rtx emit_a = NULL_RTX;\n   rtx emit_b = NULL_RTX;\n-\n+  rtx_insn *tmp_insn = NULL;\n+  bool modified_in_a = false;\n+  bool  modified_in_b = false;\n   /* If either operand is complex, load it into a register first.\n      The best way to do this is to copy the original insn.  In this\n      way we preserve any clobbers etc that the insn may have had.\n      This is of course not possible in the IS_MEM case.  */\n \n-  if (! general_operand (a, GET_MODE (a)))\n+  if (! general_operand (a, GET_MODE (a)) || tmp_a)\n     {\n \n       if (is_mem)\n \t{\n \t  rtx reg = gen_reg_rtx (GET_MODE (a));\n \t  emit_a = gen_rtx_SET (reg, a);\n \t}\n-      else if (! insn_a)\n-\tgoto end_seq_and_fail;\n       else\n \t{\n-\t  a = gen_reg_rtx (GET_MODE (a));\n-\t  rtx_insn *copy_of_a = as_a <rtx_insn *> (copy_rtx (insn_a));\n-\t  rtx set = single_set (copy_of_a);\n-\t  SET_DEST (set) = a;\n+\t  if (insn_a)\n+\t    {\n+\t      a = tmp_a ? tmp_a : gen_reg_rtx (GET_MODE (a));\n+\n+\t      rtx_insn *copy_of_a = as_a <rtx_insn *> (copy_rtx (insn_a));\n+\t      rtx set = single_set (copy_of_a);\n+\t      SET_DEST (set) = a;\n \n-\t  emit_a = PATTERN (copy_of_a);\n+\t      emit_a = PATTERN (copy_of_a);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = tmp_a ? tmp_a : gen_reg_rtx (GET_MODE (a));\n+\t      emit_a = gen_rtx_SET (tmp_reg, a);\n+\t      a = tmp_reg;\n+\t    }\n \t}\n     }\n \n-  if (! general_operand (b, GET_MODE (b)))\n+  if (! general_operand (b, GET_MODE (b)) || tmp_b)\n     {\n       if (is_mem)\n \t{\n           rtx reg = gen_reg_rtx (GET_MODE (b));\n \t  emit_b = gen_rtx_SET (reg, b);\n \t}\n-      else if (! insn_b)\n-\tgoto end_seq_and_fail;\n       else\n \t{\n-          b = gen_reg_rtx (GET_MODE (b));\n-\t  rtx_insn *copy_of_b = as_a <rtx_insn *> (copy_rtx (insn_b));\n-\t  rtx set = single_set (copy_of_b);\n+\t  if (insn_b)\n+\t    {\n+\t      b = tmp_b ? tmp_b : gen_reg_rtx (GET_MODE (b));\n+\t      rtx_insn *copy_of_b = as_a <rtx_insn *> (copy_rtx (insn_b));\n+\t      rtx set = single_set (copy_of_b);\n \n-\t  SET_DEST (set) = b;\n-\t  emit_b = PATTERN (copy_of_b);\n+\t      SET_DEST (set) = b;\n+\t      emit_b = PATTERN (copy_of_b);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = tmp_b ? tmp_b : gen_reg_rtx (GET_MODE (b));\n+\t      emit_b = gen_rtx_SET (tmp_reg, b);\n+\t      b = tmp_reg;\n+\t  }\n \t}\n     }\n \n     /* If insn to set up A clobbers any registers B depends on, try to\n        swap insn that sets up A with the one that sets up B.  If even\n        that doesn't help, punt.  */\n \n-    if (emit_a && modified_in_p (orig_b, emit_a))\n-      {\n-\tif (modified_in_p (orig_a, emit_b))\n-\t  goto end_seq_and_fail;\n+  modified_in_a = emit_a != NULL_RTX && modified_in_p (orig_b, emit_a);\n+  if (tmp_b && then_bb)\n+    {\n+      FOR_BB_INSNS (then_bb, tmp_insn)\n+\tif (modified_in_p (orig_b, tmp_insn))\n+\t  {\n+\t    modified_in_a = true;\n+\t    break;\n+\t  }\n \n-\tif (else_bb && !b_simple)\n+    }\n+    if (emit_a && modified_in_a)\n+      {\n+\tmodified_in_b = emit_b != NULL_RTX && modified_in_p (orig_a, emit_b);\n+\tif (tmp_b && else_bb)\n \t  {\n-\t    if (!noce_emit_bb (emit_b, else_bb, b_simple))\n-\t      goto end_seq_and_fail;\n+\t    FOR_BB_INSNS (else_bb, tmp_insn)\n+\t      if (modified_in_p (orig_a, tmp_insn))\n+\t\t{\n+\t\t  modified_in_b = true;\n+\t\t  break;\n+\t\t}\n+\n \t  }\n+\tif (modified_in_b)\n+\t  goto end_seq_and_fail;\n+\n+\tif (!noce_emit_bb (emit_b, else_bb, b_simple))\n+\t  goto end_seq_and_fail;\n \n \tif (!noce_emit_bb (emit_a, then_bb, a_simple))\n \t  goto end_seq_and_fail;"}]}