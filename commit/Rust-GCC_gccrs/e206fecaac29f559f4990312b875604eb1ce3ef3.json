{"sha": "e206fecaac29f559f4990312b875604eb1ce3ef3", "node_id": "C_kwDOANBUbNoAKGUyMDZmZWNhYWMyOWY1NTlmNDk5MDMxMmI4NzU2MDRlYjFjZTNlZjM", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-08-15T15:51:03Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-08-15T19:35:10Z"}, "message": "d: Fix internal compiler error: Segmentation fault at gimple-expr.cc:88\n\nBecause complex types are deprecated in the language, the new way to\nexpose native complex types is by defining an enum with a basetype of a\nlibrary-defined struct that is implicitly treated as-if it is native.\nAs casts are not implicitly added by the front-end when downcasting from\nenum to its underlying type, we must insert an explicit cast during the\ncode generation pass.\n\n\tPR d/106623\n\ngcc/d/ChangeLog:\n\n\t* d-codegen.cc (underlying_complex_expr): New function.\n\t(d_build_call): Handle passing native complex objects as the\n\tlibrary-defined equivalent.\n\t* d-tree.h (underlying_complex_expr): Declare.\n\t* expr.cc (ExprVisitor::visit (DotVarExp *)): Call\n\tunderlying_complex_expr instead of build_vconvert.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/torture/pr106623.d: New test.", "tree": {"sha": "c207c52302fdcdea131f36001347991d46f0020e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c207c52302fdcdea131f36001347991d46f0020e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e206fecaac29f559f4990312b875604eb1ce3ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e206fecaac29f559f4990312b875604eb1ce3ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e206fecaac29f559f4990312b875604eb1ce3ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e206fecaac29f559f4990312b875604eb1ce3ef3/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "250b1fa19d76b3e2f7a175b6b9ee6086fb548bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250b1fa19d76b3e2f7a175b6b9ee6086fb548bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250b1fa19d76b3e2f7a175b6b9ee6086fb548bfe"}], "stats": {"total": 65, "additions": 64, "deletions": 1}, "files": [{"sha": "aa6bc9e53e499206247db5a431decf6a5bcaf413", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=e206fecaac29f559f4990312b875604eb1ce3ef3", "patch": "@@ -1588,6 +1588,32 @@ complex_expr (tree type, tree re, tree im)\n \t\t\t  type, re, im);\n }\n \n+/* Build a two-field record TYPE representing the complex expression EXPR.  */\n+\n+tree\n+underlying_complex_expr (tree type, tree expr)\n+{\n+  gcc_assert (list_length (TYPE_FIELDS (type)) == 2);\n+\n+  expr = d_save_expr (expr);\n+\n+  /* Build a constructor from the real and imaginary parts.  */\n+  if (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (expr)) &&\n+      (!INDIRECT_REF_P (expr)\n+       || !CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (expr, 0)))))\n+    {\n+      vec <constructor_elt, va_gc> *ve = NULL;\n+      CONSTRUCTOR_APPEND_ELT (ve, TYPE_FIELDS (type),\n+                    real_part (expr));\n+      CONSTRUCTOR_APPEND_ELT (ve, TREE_CHAIN (TYPE_FIELDS (type)),\n+                    imaginary_part (expr));\n+      return build_constructor (type, ve);\n+    }\n+\n+  /* Replace type in the reinterpret cast with a cast to the record type.  */\n+  return build_vconvert (type, expr);\n+}\n+\n /* Cast EXP (which should be a pointer) to TYPE* and then indirect.\n    The back-end requires this cast in many cases.  */\n \n@@ -2214,6 +2240,14 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t\t\t      build_address (targ));\n \t    }\n \n+\t  /* Complex types are exposed as special types with an underlying\n+\t     struct representation, if we are passing the native type to a\n+\t     function that accepts the library-defined version, then ensure\n+\t     it is properly reinterpreted as the underlying struct type.  */\n+\t  if (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (targ))\n+\t      && arg->type->isTypeStruct ())\n+\t    targ = underlying_complex_expr (build_ctype (arg->type), targ);\n+\n \t  /* Type `noreturn` is a terminator, as no other arguments can possibly\n \t     be evaluated after it.  */\n \t  if (TREE_TYPE (targ) == noreturn_type_node)"}, {"sha": "809a242ea93db2dc7c2a34e54cf0c9803c0fcfd6", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=e206fecaac29f559f4990312b875604eb1ce3ef3", "patch": "@@ -576,6 +576,7 @@ extern tree size_mult_expr (tree, tree);\n extern tree real_part (tree);\n extern tree imaginary_part (tree);\n extern tree complex_expr (tree, tree, tree);\n+extern tree underlying_complex_expr (tree, tree);\n extern tree indirect_ref (tree, tree);\n extern tree build_deref (tree);\n extern tree build_pointer_index (tree, tree);"}, {"sha": "140df7ee41d762995c66a73309b2d7a9721724b9", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=e206fecaac29f559f4990312b875604eb1ce3ef3", "patch": "@@ -1892,7 +1892,7 @@ class ExprVisitor : public Visitor\n \t       underlying is really a complex type.  */\n \t    if (e->e1->type->ty == TY::Tenum\n \t\t&& e->e1->type->isTypeEnum ()->sym->isSpecial ())\n-\t      object = build_vconvert (build_ctype (tb), object);\n+\t      object = underlying_complex_expr (build_ctype (tb), object);\n \n \t    this->result_ = component_ref (object, get_symbol_decl (vd));\n \t  }"}, {"sha": "d782b236861917b35935cf763eb4689715773cd4", "filename": "gcc/testsuite/gdc.dg/torture/pr106623.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr106623.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e206fecaac29f559f4990312b875604eb1ce3ef3/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr106623.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr106623.d?ref=e206fecaac29f559f4990312b875604eb1ce3ef3", "patch": "@@ -0,0 +1,28 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106623\n+// { dg-do compile }\n+private struct _Complex(T) { T re; T im; }\n+enum __c_complex_double : _Complex!double;\n+\n+pragma(inline, true)\n+ulong hashOf()(scope const double val)\n+{\n+    return *cast(ulong*)&val;\n+}\n+\n+pragma(inline, true)\n+ulong hashOf()(scope const _Complex!double val, ulong seed = 0)\n+{\n+    return hashOf(val.re) + hashOf(val.im);\n+}\n+\n+pragma(inline, true)\n+ulong hashOf()(__c_complex_double val, ulong seed = 0)\n+{\n+    return hashOf(cast(_Complex!double) val, seed);\n+}\n+\n+ulong test106623()\n+{\n+    __c_complex_double val;\n+    return hashOf(val);\n+}"}]}