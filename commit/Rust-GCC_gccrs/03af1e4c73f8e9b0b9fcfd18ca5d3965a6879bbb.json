{"sha": "03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNhZjFlNGM3M2Y4ZTliMGI5ZmNmZDE4Y2E1ZDM5NjVhNjg3OWJiYg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-06-10T14:47:49Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-06-10T14:47:49Z"}, "message": "re PR fortran/38936 ([F03] ASSOCIATE construct / improved SELECT TYPE (a=>expr))\n\n2010-06-10  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.h (enum gfc_statement): Add ST_ASSOCIATE, ST_END_ASSOCIATE.\n\t(struct gfc_symbol): New field `assoc'.\n\t(struct gfc_association_list): New struct.\n\t(struct gfc_code): New struct `block' in union, move `ns' there\n\tand add association list.\n\t(gfc_free_association_list): New method.\n\t(gfc_has_vector_subscript): Made public;\n\t* match.h (gfc_match_associate): New method.\n\t* parse.h (enum gfc_compile_state): Add COMP_ASSOCIATE.\n\t* decl.c (gfc_match_end): Handle ST_END_ASSOCIATE.\n\t* interface.c (gfc_has_vector_subscript): Made public.\n\t(compare_actual_formal): Rename `has_vector_subscript' accordingly.\n\t* match.c (gfc_match_associate): New method.\n\t(gfc_match_select_type): Change reference to gfc_code's `ns' field.\n\t* primary.c (match_variable): Don't allow names associated to expr here.\n\t* parse.c (decode_statement): Try matching ASSOCIATE statement.\n\t(case_exec_markers, case_end): Add ASSOCIATE statement.\n\t(gfc_ascii_statement): Hande ST_ASSOCIATE and ST_END_ASSOCIATE.\n\t(parse_associate): New method.\n\t(parse_executable): Handle ST_ASSOCIATE.\n\t(parse_block_construct): Change reference to gfc_code's `ns' field.\n\t* resolve.c (resolve_select_type): Ditto.\n\t(resolve_code): Ditto.\n\t(resolve_block_construct): Ditto and add comment.\n\t(resolve_select_type): Set association list in generated BLOCK to NULL.\n\t(resolve_symbol): Resolve associate names.\n\t* st.c (gfc_free_statement): Change reference to gfc_code's `ns' field\n\tand free association list.\n\t(gfc_free_association_list): New method.\n\t* symbol.c (gfc_new_symbol): NULL new field `assoc'.\n\t* trans-stmt.c (gfc_trans_block_construct): Change reference to\n\tgfc_code's `ns' field.\n\n2010-06-10  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.dg/associate_1.f03: New test.\n\t* gfortran.dg/associate_2.f95: New test.\n\t* gfortran.dg/associate_3.f03: New test.\n\t* gfortran.dg/associate_4.f08: New test.\n\nFrom-SVN: r160550", "tree": {"sha": "92cc0dfbe516055a3602f51eff555b7609833069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92cc0dfbe516055a3602f51eff555b7609833069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29aba2bbfed88ef9fb5f68ff8dda08f0bfd48d0c"}], "stats": {"total": 484, "additions": 455, "deletions": 29}, "files": [{"sha": "d463f15139192b570dc01236de01de58cd4e1dad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -1,3 +1,39 @@\n+2010-06-10  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.h (enum gfc_statement): Add ST_ASSOCIATE, ST_END_ASSOCIATE.\n+\t(struct gfc_symbol): New field `assoc'.\n+\t(struct gfc_association_list): New struct.\n+\t(struct gfc_code): New struct `block' in union, move `ns' there\n+\tand add association list.\n+\t(gfc_free_association_list): New method.\n+\t(gfc_has_vector_subscript): Made public;\n+\t* match.h (gfc_match_associate): New method.\n+\t* parse.h (enum gfc_compile_state): Add COMP_ASSOCIATE.\n+\t* decl.c (gfc_match_end): Handle ST_END_ASSOCIATE.\n+\t* interface.c (gfc_has_vector_subscript): Made public.\n+\t(compare_actual_formal): Rename `has_vector_subscript' accordingly.\n+\t* match.c (gfc_match_associate): New method.\n+\t(gfc_match_select_type): Change reference to gfc_code's `ns' field.\n+\t* primary.c (match_variable): Don't allow names associated to expr here.\n+\t* parse.c (decode_statement): Try matching ASSOCIATE statement.\n+\t(case_exec_markers, case_end): Add ASSOCIATE statement.\n+\t(gfc_ascii_statement): Hande ST_ASSOCIATE and ST_END_ASSOCIATE.\n+\t(parse_associate): New method.\n+\t(parse_executable): Handle ST_ASSOCIATE.\n+\t(parse_block_construct): Change reference to gfc_code's `ns' field.\n+\t* resolve.c (resolve_select_type): Ditto.\n+\t(resolve_code): Ditto.\n+\t(resolve_block_construct): Ditto and add comment.\n+\t(resolve_select_type): Set association list in generated BLOCK to NULL.\n+\t(resolve_symbol): Resolve associate names.\n+\t* st.c (gfc_free_statement): Change reference to gfc_code's `ns' field\n+\tand free association list.\n+\t(gfc_free_association_list): New method.\n+\t* symbol.c (gfc_new_symbol): NULL new field `assoc'.\n+\t* trans-stmt.c (gfc_trans_block_construct): Change reference to\n+\tgfc_code's `ns' field.\n+\n 2010-06-10  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* error.c (error_print): Pre-initialize loc by NULL."}, {"sha": "e2de24f3f137aebc037028e2b400bf349527bafc", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -5483,14 +5483,23 @@ gfc_match_end (gfc_statement *st)\n   block_name = gfc_current_block () == NULL\n \t     ? NULL : gfc_current_block ()->name;\n \n-  if (state == COMP_BLOCK && !strcmp (block_name, \"block@\"))\n-    block_name = NULL;\n-\n-  if (state == COMP_CONTAINS || state == COMP_DERIVED_CONTAINS)\n+  switch (state)\n     {\n+    case COMP_ASSOCIATE:\n+    case COMP_BLOCK:\n+      if (!strcmp (block_name, \"block@\"))\n+\tblock_name = NULL;\n+      break;\n+\n+    case COMP_CONTAINS:\n+    case COMP_DERIVED_CONTAINS:\n       state = gfc_state_stack->previous->state;\n       block_name = gfc_state_stack->previous->sym == NULL\n \t\t ? NULL : gfc_state_stack->previous->sym->name;\n+      break;\n+\n+    default:\n+      break;\n     }\n \n   switch (state)\n@@ -5539,6 +5548,12 @@ gfc_match_end (gfc_statement *st)\n       eos_ok = 0;\n       break;\n \n+    case COMP_ASSOCIATE:\n+      *st = ST_END_ASSOCIATE;\n+      target = \" associate\";\n+      eos_ok = 0;\n+      break;\n+\n     case COMP_BLOCK:\n       *st = ST_END_BLOCK;\n       target = \" block\";\n@@ -5622,7 +5637,7 @@ gfc_match_end (gfc_statement *st)\n \n       if (*st != ST_ENDDO && *st != ST_ENDIF && *st != ST_END_SELECT\n \t  && *st != ST_END_FORALL && *st != ST_END_WHERE && *st != ST_END_BLOCK\n-\t  && *st != ST_END_CRITICAL)\n+\t  && *st != ST_END_ASSOCIATE && *st != ST_END_CRITICAL)\n \treturn MATCH_YES;\n \n       if (!block_name)"}, {"sha": "2a553d198fa743ac8bdb061aacc6ff65af105432", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -205,11 +205,12 @@ arith;\n /* Statements.  */\n typedef enum\n {\n-  ST_ARITHMETIC_IF, ST_ALLOCATE, ST_ATTR_DECL, ST_BACKSPACE,\n-  ST_BLOCK, ST_BLOCK_DATA,\n+  ST_ARITHMETIC_IF, ST_ALLOCATE, ST_ATTR_DECL, ST_ASSOCIATE,\n+  ST_BACKSPACE, ST_BLOCK, ST_BLOCK_DATA,\n   ST_CALL, ST_CASE, ST_CLOSE, ST_COMMON, ST_CONTINUE, ST_CONTAINS, ST_CYCLE,\n   ST_DATA, ST_DATA_DECL, ST_DEALLOCATE, ST_DO, ST_ELSE, ST_ELSEIF,\n-  ST_ELSEWHERE, ST_END_BLOCK, ST_END_BLOCK_DATA, ST_ENDDO, ST_IMPLIED_ENDDO,\n+  ST_ELSEWHERE, ST_END_ASSOCIATE, ST_END_BLOCK, ST_END_BLOCK_DATA,\n+  ST_ENDDO, ST_IMPLIED_ENDDO,\n   ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,\n   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,\n@@ -1201,6 +1202,9 @@ typedef struct gfc_symbol\n   char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n   /* Store a reference to the common_block, if this symbol is in one.  */\n   struct gfc_common_head *common_block;\n+\n+  /* Link to corresponding association-list if this is an associate name.  */\n+  struct gfc_association_list *assoc;\n }\n gfc_symbol;\n \n@@ -1974,6 +1978,25 @@ typedef struct gfc_forall_iterator\n gfc_forall_iterator;\n \n \n+/* Linked list to store associations in an ASSOCIATE statement.  */\n+\n+typedef struct gfc_association_list\n+{\n+  struct gfc_association_list *next; \n+\n+  /* Whether this is association to a variable that can be changed; otherwise,\n+     it's association to an expression and the name may not be used as\n+     lvalue.  */\n+  unsigned variable:1;\n+\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symtree *st; /* Symtree corresponding to name.  */\n+  gfc_expr *target;\n+}\n+gfc_association_list;\n+#define gfc_get_association_list() XCNEW (gfc_association_list)\n+\n+\n /* Executable statements that fill gfc_code structures.  */\n typedef enum\n {\n@@ -2026,6 +2049,13 @@ typedef struct gfc_code\n     }\n     alloc;\n \n+    struct\n+    {\n+      gfc_namespace *ns;\n+      gfc_association_list *assoc;\n+    }\n+    block;\n+\n     gfc_open *open;\n     gfc_close *close;\n     gfc_filepos *filepos;\n@@ -2040,7 +2070,6 @@ typedef struct gfc_code\n     const char *omp_name;\n     gfc_namelist *omp_namelist;\n     bool omp_bool;\n-    gfc_namespace *ns;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n \n@@ -2647,6 +2676,7 @@ gfc_code *gfc_get_code (void);\n gfc_code *gfc_append_code (gfc_code *, gfc_code *);\n void gfc_free_statement (gfc_code *);\n void gfc_free_statements (gfc_code *);\n+void gfc_free_association_list (gfc_association_list *);\n \n /* resolve.c */\n gfc_try gfc_resolve_expr (gfc_expr *);\n@@ -2719,6 +2749,7 @@ void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n+int gfc_has_vector_subscript (gfc_expr*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "379c636d695958fd0930fb7c2147b5efd79ff065", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -1821,8 +1821,8 @@ get_expr_storage_size (gfc_expr *e)\n    which has a vector subscript. If it has, one is returned,\n    otherwise zero.  */\n \n-static int\n-has_vector_subscript (gfc_expr *e)\n+int\n+gfc_has_vector_subscript (gfc_expr *e)\n {\n   int i;\n   gfc_ref *ref;\n@@ -2134,7 +2134,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n       if ((f->sym->attr.intent == INTENT_OUT\n \t   || f->sym->attr.intent == INTENT_INOUT\n \t   || f->sym->attr.volatile_)\n-          && has_vector_subscript (a->expr))\n+\t  && gfc_has_vector_subscript (a->expr))\n \t{\n \t  if (where)\n \t    gfc_error (\"Array-section actual argument with vector subscripts \""}, {"sha": "8c43531d8752af72298ab7f1ec283d67324efc7f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -1797,6 +1797,98 @@ gfc_match_block (void)\n }\n \n \n+/* Match an ASSOCIATE statement.  */\n+\n+match\n+gfc_match_associate (void)\n+{\n+  if (gfc_match_label () == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" associate\") != MATCH_YES)\n+    return MATCH_NO;\n+\n+  /* Match the association list.  */\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    {\n+      gfc_error (\"Expected association list at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.ext.block.assoc = NULL;\n+  while (true)\n+    {\n+      gfc_association_list* newAssoc = gfc_get_association_list ();\n+      gfc_association_list* a;\n+\n+      /* Match the next association.  */\n+      if (gfc_match (\" %n => %e\", newAssoc->name, &newAssoc->target)\n+\t    != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected association at %C\");\n+\t  goto assocListError;\n+\t}\n+\n+      /* Check that the current name is not yet in the list.  */\n+      for (a = new_st.ext.block.assoc; a; a = a->next)\n+\tif (!strcmp (a->name, newAssoc->name))\n+\t  {\n+\t    gfc_error (\"Duplicate name '%s' in association at %C\",\n+\t\t       newAssoc->name);\n+\t    goto assocListError;\n+\t  }\n+\n+      /* The target expression must not be coindexed.  */\n+      if (gfc_is_coindexed (newAssoc->target))\n+\t{\n+\t  gfc_error (\"Association target at %C must not be coindexed\");\n+\t  goto assocListError;\n+\t}\n+\n+      /* The target is a variable (and may be used as lvalue) if it's an\n+\t EXPR_VARIABLE and does not have vector-subscripts.  */\n+      newAssoc->variable = (newAssoc->target->expr_type == EXPR_VARIABLE\n+\t\t\t    && !gfc_has_vector_subscript (newAssoc->target));\n+\n+      /* Put it into the list.  */\n+      newAssoc->next = new_st.ext.block.assoc;\n+      new_st.ext.block.assoc = newAssoc;\n+\n+      /* Try next one or end if closing parenthesis is found.  */\n+      gfc_gobble_whitespace ();\n+      if (gfc_peek_char () == ')')\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected ')' or ',' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      continue;\n+\n+assocListError:\n+      gfc_free (newAssoc);\n+      goto error;\n+    }\n+  if (gfc_match_char (')') != MATCH_YES)\n+    {\n+      /* This should never happen as we peek above.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Junk after ASSOCIATE statement at %C\");\n+      goto error;\n+    }\n+\n+  return MATCH_YES;\n+\n+error:\n+  gfc_free_association_list (new_st.ext.block.assoc);\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a DO statement.  */\n \n match\n@@ -4361,7 +4453,7 @@ gfc_match_select_type (void)\n   new_st.op = EXEC_SELECT_TYPE;\n   new_st.expr1 = expr1;\n   new_st.expr2 = expr2;\n-  new_st.ext.ns = gfc_current_ns;\n+  new_st.ext.block.ns = gfc_current_ns;\n \n   select_type_push (expr1->symtree->n.sym);\n "}, {"sha": "09740fb248569fd19fda8a2b65053d1062f480b9", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -69,6 +69,7 @@ match gfc_match_else (void);\n match gfc_match_elseif (void);\n match gfc_match_critical (void);\n match gfc_match_block (void);\n+match gfc_match_associate (void);\n match gfc_match_do (void);\n match gfc_match_cycle (void);\n match gfc_match_exit (void);"}, {"sha": "7b887bc1e39adc126036c925a61332977b189840", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 102, "deletions": 6, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -292,7 +292,7 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n-  /* Check for the IF, DO, SELECT, WHERE, FORALL, CRITICAL, and BLOCK\n+  /* Check for the IF, DO, SELECT, WHERE, FORALL, CRITICAL, BLOCK and ASSOCIATE\n      statements, which might begin with a block label.  The match functions for\n      these statements are unusual in that their keyword is not seen before\n      the matcher is called.  */\n@@ -314,6 +314,7 @@ decode_statement (void)\n \n   match (NULL, gfc_match_do, ST_DO);\n   match (NULL, gfc_match_block, ST_BLOCK);\n+  match (NULL, gfc_match_associate, ST_ASSOCIATE);\n   match (NULL, gfc_match_critical, ST_CRITICAL);\n   match (NULL, gfc_match_select, ST_SELECT_CASE);\n   match (NULL, gfc_match_select_type, ST_SELECT_TYPE);\n@@ -949,7 +950,7 @@ next_statement (void)\n /* Statements that mark other executable statements.  */\n \n #define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: \\\n-  case ST_IF_BLOCK: case ST_BLOCK: \\\n+  case ST_IF_BLOCK: case ST_BLOCK: case ST_ASSOCIATE: \\\n   case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_SELECT_TYPE: \\\n   case ST_OMP_PARALLEL: \\\n   case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n@@ -970,7 +971,7 @@ next_statement (void)\n \n #define case_end case ST_END_BLOCK_DATA: case ST_END_FUNCTION: \\\n \t\t case ST_END_PROGRAM: case ST_END_SUBROUTINE: \\\n-\t\t case ST_END_BLOCK\n+\t\t case ST_END_BLOCK: case ST_END_ASSOCIATE\n \n \n /* Push a new state onto the stack.  */\n@@ -1155,6 +1156,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_ALLOCATE:\n       p = \"ALLOCATE\";\n       break;\n+    case ST_ASSOCIATE:\n+      p = \"ASSOCIATE\";\n+      break;\n     case ST_ATTR_DECL:\n       p = _(\"attribute declaration\");\n       break;\n@@ -1215,6 +1219,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_ELSEWHERE:\n       p = \"ELSEWHERE\";\n       break;\n+    case ST_END_ASSOCIATE:\n+      p = \"END ASSOCIATE\";\n+      break;\n     case ST_END_BLOCK:\n       p = \"END BLOCK\";\n       break;\n@@ -3160,7 +3167,8 @@ parse_block_construct (void)\n   my_ns = gfc_build_block_ns (gfc_current_ns);\n \n   new_st.op = EXEC_BLOCK;\n-  new_st.ext.ns = my_ns;\n+  new_st.ext.block.ns = my_ns;\n+  new_st.ext.block.assoc = NULL;\n   accept_statement (ST_BLOCK);\n \n   push_state (&s, COMP_BLOCK, my_ns->proc_name);\n@@ -3173,6 +3181,92 @@ parse_block_construct (void)\n }\n \n \n+/* Parse an ASSOCIATE construct.  This is essentially a BLOCK construct\n+   behind the scenes with compiler-generated variables.  */\n+\n+static void\n+parse_associate (void)\n+{\n+  gfc_namespace* my_ns;\n+  gfc_state_data s;\n+  gfc_statement st;\n+  gfc_association_list* a;\n+  gfc_code* assignTail;\n+\n+  gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASSOCIATE construct at %C\");\n+\n+  my_ns = gfc_build_block_ns (gfc_current_ns);\n+\n+  new_st.op = EXEC_BLOCK;\n+  new_st.ext.block.ns = my_ns;\n+  gcc_assert (new_st.ext.block.assoc);\n+\n+  /* Add all associations to expressions as BLOCK variables, and create\n+     assignments to them giving their values.  */\n+  gfc_current_ns = my_ns;\n+  assignTail = NULL;\n+  for (a = new_st.ext.block.assoc; a; a = a->next)\n+    if (!a->variable)\n+      {\n+\tgfc_code* newAssign;\n+\n+\tif (gfc_get_sym_tree (a->name, NULL, &a->st, false))\n+\t  gcc_unreachable ();\n+\n+\t/* Note that in certain cases, the target-expression's type is not yet\n+\t   known and so we have to adapt the symbol's ts also during resolution\n+\t   for these cases.  */\n+\ta->st->n.sym->ts = a->target->ts;\n+\ta->st->n.sym->attr.flavor = FL_VARIABLE;\n+\ta->st->n.sym->assoc = a;\n+\tgfc_set_sym_referenced (a->st->n.sym);\n+\n+\t/* Create the assignment to calculate the expression and set it.  */\n+\tnewAssign = gfc_get_code ();\n+\tnewAssign->op = EXEC_ASSIGN;\n+\tnewAssign->loc = gfc_current_locus;\n+\tnewAssign->expr1 = gfc_get_variable_expr (a->st);\n+\tnewAssign->expr2 = a->target;\n+\n+\t/* Hang it in.  */\n+\tif (assignTail)\n+\t  assignTail->next = newAssign;\n+\telse\n+\t  gfc_current_ns->code = newAssign;\n+\tassignTail = newAssign;\n+      }\n+    else\n+      {\n+\tgfc_error (\"Association to variables is not yet supported at %C\");\n+\treturn;\n+      }\n+  gcc_assert (assignTail);\n+\n+  accept_statement (ST_ASSOCIATE);\n+  push_state (&s, COMP_ASSOCIATE, my_ns->proc_name);\n+\n+loop:\n+  st = parse_executable (ST_NONE);\n+  switch (st)\n+    {\n+    case ST_NONE:\n+      unexpected_eof ();\n+\n+    case_end:\n+      accept_statement (st);\n+      assignTail->next = gfc_state_stack->head;\n+      break;\n+\n+    default:\n+      unexpected_statement (st);\n+      goto loop;\n+    }\n+\n+  gfc_current_ns = gfc_current_ns->parent;\n+  pop_state ();\n+}\n+\n+\n /* Parse a DO loop.  Note that the ST_CYCLE and ST_EXIT statements are\n    handled inside of parse_executable(), because they aren't really\n    loop statements.  */\n@@ -3542,8 +3636,6 @@ parse_executable (gfc_statement st)\n \t  case ST_END_SUBROUTINE:\n \n \t  case ST_DO:\n-\t  case ST_CRITICAL:\n-\t  case ST_BLOCK:\n \t  case ST_FORALL:\n \t  case ST_WHERE:\n \t  case ST_SELECT_CASE:\n@@ -3573,6 +3665,10 @@ parse_executable (gfc_statement st)\n \t  parse_block_construct ();\n \t  break;\n \n+\tcase ST_ASSOCIATE:\n+\t  parse_associate ();\n+\t  break;\n+\n \tcase ST_IF_BLOCK:\n \t  parse_if_block ();\n \t  break;"}, {"sha": "65d1a7e604a8f80e1c2323d6aa289f992d79b02d", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -28,7 +28,7 @@ typedef enum\n {\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,\n-  COMP_BLOCK, COMP_IF,\n+  COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL\n }"}, {"sha": "b6c08a9c406f79a168d32179c926384997cbdda7", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -2975,6 +2975,12 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  gfc_error (\"Assigning to PROTECTED variable at %C\");\n \t  return MATCH_ERROR;\n \t}\n+      if (sym->assoc && !sym->assoc->variable)\n+\t{\n+\t  gfc_error (\"'%s' associated to expression can't appear in a variable\"\n+\t\t     \" definition context at %C\", sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n       break;\n \n     case FL_UNKNOWN:"}, {"sha": "5f920c9e3d3c94e8cc16a073f1d8e34e9f29c049", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -7158,7 +7158,7 @@ resolve_select_type (gfc_code *code)\n   gfc_namespace *ns;\n   int error = 0;\n \n-  ns = code->ext.ns;\n+  ns = code->ext.block.ns;\n   gfc_resolve (ns);\n \n   /* Check for F03:C813.  */\n@@ -7245,6 +7245,7 @@ resolve_select_type (gfc_code *code)\n   else\n     ns->code->next = new_st;\n   code->op = EXEC_BLOCK;\n+  code->ext.block.assoc = NULL;\n   code->expr1 = code->expr2 =  NULL;\n   code->block = NULL;\n \n@@ -7988,10 +7989,11 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n static void\n resolve_block_construct (gfc_code* code)\n {\n-  /* Eventually, we may want to do some checks here or handle special stuff.\n-     But so far the only thing we can do is resolving the local namespace.  */\n+  /* For an ASSOCIATE block, the associations (and their targets) are already\n+     resolved during gfc_resolve_symbol.  */\n \n-  gfc_resolve (code->ext.ns);\n+  /* Resolve the BLOCK's namespace.  */\n+  gfc_resolve (code->ext.block.ns);\n }\n \n \n@@ -8312,7 +8314,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      gfc_resolve_omp_do_blocks (code, ns);\n \t      break;\n \t    case EXEC_SELECT_TYPE:\n-\t      gfc_current_ns = code->ext.ns;\n+\t      gfc_current_ns = code->ext.block.ns;\n \t      gfc_resolve_blocks (code->block, gfc_current_ns);\n \t      gfc_current_ns = ns;\n \t      break;\n@@ -8476,7 +8478,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_BLOCK:\n-\t  gfc_resolve (code->ext.ns);\n+\t  gfc_resolve (code->ext.block.ns);\n \t  break;\n \n \tcase EXEC_DO:\n@@ -11341,14 +11343,25 @@ resolve_symbol (gfc_symbol *sym)\n      can.  */\n   mp_flag = (sym->result != NULL && sym->result != sym);\n \n-\n   /* Make sure that the intrinsic is consistent with its internal \n      representation. This needs to be done before assigning a default \n      type to avoid spurious warnings.  */\n   if (sym->attr.flavor != FL_MODULE && sym->attr.intrinsic\n       && resolve_intrinsic (sym, &sym->declared_at) == FAILURE)\n     return;\n \n+  /* For associate names, resolve corresponding expression and make sure\n+     they get their type-spec set this way.  */\n+  if (sym->assoc)\n+    {\n+      gcc_assert (sym->attr.flavor == FL_VARIABLE);\n+      if (gfc_resolve_expr (sym->assoc->target) != SUCCESS)\n+\treturn;\n+\n+      sym->ts = sym->assoc->target->ts;\n+      gcc_assert (sym->ts.type != BT_UNKNOWN);\n+    }\n+\n   /* Assign default type to symbols that need one and don't have one.  */\n   if (sym->ts.type == BT_UNKNOWN)\n     {"}, {"sha": "f9ad5d82793e8233b0026588dbdec3bf7fb578d2", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -116,7 +116,8 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_BLOCK:\n-      gfc_free_namespace (p->ext.ns);\n+      gfc_free_namespace (p->ext.block.ns);\n+      gfc_free_association_list (p->ext.block.assoc);\n       break;\n \n     case EXEC_COMPCALL:\n@@ -231,3 +232,15 @@ gfc_free_statements (gfc_code *p)\n     }\n }\n \n+\n+/* Free an association list (of an ASSOCIATE statement).  */\n+\n+void\n+gfc_free_association_list (gfc_association_list* assoc)\n+{\n+  if (!assoc)\n+    return;\n+\n+  gfc_free_association_list (assoc->next);\n+  gfc_free (assoc);\n+}"}, {"sha": "049e4a735285bc7b6d079c0f6e8559270a92b8f4", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -2512,6 +2512,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n   /* Clear the ptrs we may need.  */\n   p->common_block = NULL;\n   p->f2k_derived = NULL;\n+  p->assoc = NULL;\n   \n   return p;\n }"}, {"sha": "e5636bfed53945a375c1a3fe0770f8a9fbabe20a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -850,7 +850,7 @@ gfc_trans_block_construct (gfc_code* code)\n   stmtblock_t body;\n   tree tmp;\n \n-  ns = code->ext.ns;\n+  ns = code->ext.block.ns;\n   gcc_assert (ns);\n   sym = ns->proc_name;\n   gcc_assert (sym);"}, {"sha": "e72a684dba7482ee9e4bc647feb0300daeed5927", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -1,3 +1,11 @@\n+2010-06-10  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.dg/associate_1.f03: New test.\n+\t* gfortran.dg/associate_2.f95: New test.\n+\t* gfortran.dg/associate_3.f03: New test.\n+\t* gfortran.dg/associate_4.f08: New test.\n+\n 2010-06-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.dg/selected_char_kind_4.f90: New test."}, {"sha": "90579c99ce3c5e469a70743f58dd7272fe5b2296", "filename": "gcc/testsuite/gfortran.dg/associate_1.f03", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+\n+! PR fortran/38936\n+! Check the basic semantics of the ASSOCIATE construct.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  REAL :: a, b, c\n+  INTEGER, ALLOCATABLE :: arr(:)\n+\n+  a = -2.0\n+  b = 3.0\n+  c = 4.0\n+\n+  ! Simple association to expressions.\n+  ASSOCIATE (r => SQRT (a**2 + b**2 + c**2), t => a + b)\n+    PRINT *, t, a, b\n+    IF (ABS (r - SQRT (4.0 + 9.0 + 16.0)) > 1.0e-3) CALL abort ()\n+    IF (ABS (t - a - b) > 1.0e-3) CALL abort ()\n+  END ASSOCIATE\n+\n+  ! TODO: Test association to variables when that is supported.\n+  ! TODO: Test association to derived types.\n+\n+  ! Test association to arrays.\n+  ! TODO: Enable when working.\n+  !ALLOCATE (arr(3))\n+  !arr = (/ 1, 2, 3 /)\n+  !ASSOCIATE (doubled => 2 * arr)\n+  !  IF (doubled(1) /= 2 .OR. doubled(2) /= 4 .OR. doubled(3) /= 6) &\n+  !    CALL abort ()\n+  !END ASSOCIATE\n+\n+  ! Named and nested associate.\n+  myname: ASSOCIATE (x => a - b * c)\n+    ASSOCIATE (y => 2.0 * x)\n+      IF (ABS (y - 2.0 * (a - b * c)) > 1.0e-3) CALL abort ()\n+    END ASSOCIATE\n+  END ASSOCIATE myname ! Matching end-label.\n+\n+  ! Correct behaviour when shadowing already existing names.\n+  ASSOCIATE (a => 1 * b, b => 1 * a, x => 1, y => 2)\n+    IF (ABS (a - 3.0) > 1.0e-3 .OR. ABS (b + 2.0) > 1.0e-3) CALL abort ()\n+    ASSOCIATE (x => 1 * y, y => 1 * x)\n+      IF (x /= 2 .OR. y /= 1) CALL abort ()\n+    END ASSOCIATE\n+  END ASSOCIATE\n+END PROGRAM main"}, {"sha": "a41398d7850c82ba9b926fe1272629a714060d85", "filename": "gcc/testsuite/gfortran.dg/associate_2.f95", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_2.f95?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! PR fortran/38936\n+! Test that F95 rejects ASSOCIATE.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  ASSOCIATE (a => 5) ! { dg-error \"Fortran 2003\" }\n+  END ASSOCIATE\n+END PROGRAM main"}, {"sha": "c53bd559fb8ef46deb1f2ff725d2fd04faf1caa5", "filename": "gcc/testsuite/gfortran.dg/associate_3.f03", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! PR fortran/38936\n+! Check for errors with ASSOCIATE.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  ASSOCIATE ! { dg-error \"Expected association list\" }\n+\n+  ASSOCIATE () ! { dg-error \"Expected association\" }\n+\n+  ASSOCIATE (a => 1) 5 ! { dg-error \"Junk after ASSOCIATE\" }\n+\n+  ASSOCIATE (x =>) ! { dg-error \"Expected association\" }\n+\n+  ASSOCIATE (=> 5) ! { dg-error \"Expected association\" }\n+\n+  ASSOCIATE (x => 5, ) ! { dg-error \"Expected association\" }\n+\n+  myname: ASSOCIATE (a => 1)\n+  END ASSOCIATE ! { dg-error \"Expected block name of 'myname'\" }\n+\n+  ASSOCIATE (b => 2)\n+  END ASSOCIATE myname ! { dg-error \"Syntax error in END ASSOCIATE\" }\n+\n+  myname2: ASSOCIATE (c => 3)\n+  END ASSOCIATE myname3 ! { dg-error \"Expected label 'myname2'\" }\n+\n+  ASSOCIATE (a => 1, b => 2, a => 3) ! { dg-error \"Duplicate name 'a'\" }\n+\n+  ASSOCIATE (a => 5)\n+    a = 4 ! { dg-error \"variable definition context\" }\n+  ENd ASSOCIATE\n+\n+  ASSOCIATE (a => 5)\n+    INTEGER :: b ! { dg-error \"Unexpected data declaration statement\" }\n+  END ASSOCIATE\n+END PROGRAM main ! { dg-error \"Expecting END ASSOCIATE\" }\n+! { dg-excess-errors \"Unexpected end of file\" }"}, {"sha": "c336af2ab13c0b1941f0ec0a78e73ef170698a27", "filename": "gcc/testsuite/gfortran.dg/associate_4.f08", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_4.f08?ref=03af1e4c73f8e9b0b9fcfd18ca5d3965a6879bbb", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008 -fcoarray=single\" }\n+\n+! PR fortran/38936\n+! Check for error with coindexed target.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: a[*]\n+\n+  ASSOCIATE (x => a[1]) ! { dg-error \"must not be coindexed\" }\n+END PROGRAM main"}]}