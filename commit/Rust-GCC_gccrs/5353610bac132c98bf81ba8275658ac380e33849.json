{"sha": "5353610bac132c98bf81ba8275658ac380e33849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1MzYxMGJhYzEzMmM5OGJmODFiYTgyNzU2NThhYzM4MGUzMzg0OQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-08T14:50:03Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-12-08T14:50:03Z"}, "message": "loop.c (strength_reduce): If scan_start points to the loop exit test...\n\n\t* loop.c (strength_reduce): If scan_start points to the loop exit\n\ttest, be wary of subversive use of gotos inside expression statements.\n\tDon't set maybe_multiple for a backward jump that does not\n\tinclude the label under consideration into its range.\n\t* unroll.c (biv_total_increment): Make use of maybe_multiple field.\n\nFrom-SVN: r24196", "tree": {"sha": "4a6ebb92a0bc307d49627551fdf771d6f47baae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a6ebb92a0bc307d49627551fdf771d6f47baae6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5353610bac132c98bf81ba8275658ac380e33849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5353610bac132c98bf81ba8275658ac380e33849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5353610bac132c98bf81ba8275658ac380e33849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5353610bac132c98bf81ba8275658ac380e33849/comments", "author": null, "committer": null, "parents": [{"sha": "03d937fcebea686f9d4f456daa0f8251e0de67c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d937fcebea686f9d4f456daa0f8251e0de67c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d937fcebea686f9d4f456daa0f8251e0de67c8"}], "stats": {"total": 56, "additions": 48, "deletions": 8}, "files": [{"sha": "da56aecfe877b1244e9a0dd3721899480186ac68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5353610bac132c98bf81ba8275658ac380e33849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5353610bac132c98bf81ba8275658ac380e33849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5353610bac132c98bf81ba8275658ac380e33849", "patch": "@@ -1,3 +1,11 @@\n+Tue Dec  8 22:47:15 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (strength_reduce): If scan_start points to the loop exit\n+\ttest, be wary of subversive use of gotos inside expression statements.\n+\tDon't set maybe_multiple for a backward jump that does not\n+\tinclude the label under consideration into its range.\n+\t* unroll.c (biv_total_increment): Make use of maybe_multiple field.\n+\n Tue Dec  8 22:33:18 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* explow.c (plus_constant_wide): Don't immediately return with"}, {"sha": "ec7d0e94938f493ca5e682b7a9e1351e77927f8a", "filename": "gcc/expmed.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5353610bac132c98bf81ba8275658ac380e33849", "patch": "@@ -2852,6 +2852,27 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n    This could optimize to a bfexts instruction.\n    But C doesn't use these operations, so their optimizations are\n    left for later.  */\n+/* ??? For modulo, we don't actually need the highpart of the first product,\n+   the low part will do nicely.  And for small divisors, the second multiply\n+   can also be a low-part only multiply or even be completely left out.\n+   E.g. to calculate the remainder of a division by 3 with a 32 bit\n+   multiply, multiply with 0x55555556 and extract the upper two bits;\n+   the result is exact for inputs up to 0x1fffffff.\n+   The input range can be reduced by using cross-sum rules.\n+   For odd divisors >= 3, the following table gives right shift counts\n+   so that if an number is shifted by an integer multiple of the given\n+   amount, the remainder stays the same:\n+   2, 4, 3, 6, 10, 12, 4, 8, 18, 6, 11, 20, 18, 0, 5, 10, 12, 0, 12, 20,\n+   14, 12, 23, 21, 8, 0, 20, 18, 0, 0, 6, 12, 0, 22, 0, 18, 20, 30, 0, 0,\n+   0, 8, 0, 11, 12, 10, 36, 0, 30, 0, 0, 12, 0, 0, 0, 0, 44, 12, 24, 0,\n+   20, 0, 7, 14, 0, 18, 36, 0, 0, 46, 60, 0, 42, 0, 15, 24, 20, 0, 0, 33,\n+   0, 20, 0, 0, 18, 0, 60, 0, 0, 0, 0, 0, 40, 18, 0, 0, 12\n+\n+   Cross-sum rules for even numbers can be derived by leaving as many bits\n+   to the right alone as the divisor has zeros to the right.\n+   E.g. if x is an unsigned 32 bit number:\n+   (x mod 12) == (((x & 1023) + ((x >> 8) & ~3)) * 0x15555558 >> 2 * 3) >> 28\n+   */\n \n #define EXACT_POWER_OF_2_OR_ZERO_P(x) (((x) & ((x) - 1)) == 0)\n "}, {"sha": "e989b3c7c15ca4e843901dc52c69c4ec630ca184", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5353610bac132c98bf81ba8275658ac380e33849", "patch": "@@ -3555,6 +3555,11 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   struct loop_info loop_iteration_info;\n   struct loop_info *loop_info = &loop_iteration_info;\n \n+  /* If scan_start points to the loop exit test, we have to be wary of\n+     subversive use of gotos inside expression statements.  */\n+  if (prev_nonnote_insn (scan_start) != prev_nonnote_insn (loop_start))\n+    maybe_multiple = back_branch_in_range_p (scan_start, loop_start, loop_end);\n+\n   reg_iv_type = (enum iv_mode *) alloca (max_reg_before_loop\n \t\t\t\t\t * sizeof (enum iv_mode));\n   bzero ((char *) reg_iv_type, max_reg_before_loop * sizeof (enum iv_mode));\n@@ -3618,8 +3623,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       /* Past CODE_LABEL, we get to insns that may be executed multiple\n \t times.  The only way we can be sure that they can't is if every\n \t jump insn between here and the end of the loop either\n-\t returns, exits the loop, is a forward jump, or is a jump\n-\t to the loop start.  */\n+\t returns, exits the loop, is a jump to a location that is still\n+\t behind the label, or is a jump to the loop start.  */\n \n       if (GET_CODE (p) == CODE_LABEL)\n \t{\n@@ -3648,9 +3653,12 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t      || (JUMP_LABEL (insn) != 0\n \t\t\t  && JUMP_LABEL (insn) != scan_start\n \t\t\t  && (INSN_UID (JUMP_LABEL (insn)) >= max_uid_for_loop\n-\t\t\t      || INSN_UID (insn) >= max_uid_for_loop\n-\t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n-\t\t\t\t  < INSN_LUID (insn))))))\n+\t\t\t      || (INSN_UID (p) < max_uid_for_loop\n+\t\t\t\t  ? (INSN_LUID (JUMP_LABEL (insn))\n+\t\t\t\t     <= INSN_LUID (p))\n+\t\t\t\t  : (INSN_UID (insn) >= max_uid_for_loop\n+\t\t\t\t     || (INSN_LUID (JUMP_LABEL (insn))\n+\t\t\t\t\t < INSN_LUID (insn))))))))\n \t\t{\n \t\t  maybe_multiple = 1;\n \t\t  break;"}, {"sha": "214e94844b90d0a2d34247bdde81718ce08374f3", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5353610bac132c98bf81ba8275658ac380e33849/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=5353610bac132c98bf81ba8275658ac380e33849", "patch": "@@ -1196,7 +1196,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \tPATTERN (insn) = remap_split_bivs (PATTERN (insn));\n     }\n \n-  /* For unroll_number - 1 times, make a copy of each instruction\n+  /* For unroll_number times, make a copy of each instruction\n      between copy_start and copy_end, and insert these new instructions\n      before the end of the loop.  */\n \n@@ -1295,7 +1295,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n /* ??? If the loop is known to be executed very many times, or the machine\n    has a very cheap divide instruction, then preconditioning is a win even\n    when the increment is not a power of 2.  Use RTX_COST to compute\n-   whether divide is cheap.  */\n+   whether divide is cheap.\n+   ??? A divide by constant doesn't actually need a divide, look at\n+   expand_divmod.  The reduced cost of this optimized modulo is not\n+   reflected in RTX_COST.  */\n \n int\n precondition_loop_p (loop_start, loop_info,\n@@ -2313,7 +2316,7 @@ biv_total_increment (bl, loop_start, loop_end)\n   for (v = bl->biv; v; v = v->next_iv)\n     {\n       if (v->always_computable && v->mult_val == const1_rtx\n-\t  && ! back_branch_in_range_p (v->insn, loop_start, loop_end))\n+\t  && ! v->maybe_multiple)\n \tresult = fold_rtx_mult_add (result, const1_rtx, v->add_val, v->mode);\n       else\n \treturn 0;"}]}