{"sha": "0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJmOGNkOWQ1ZThhY2Y2ZmQ5MGExNGY4MzJiYjJkNWRlOTc0NDliMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-16T09:56:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-21T09:09:49Z"}, "message": "Simplify maybe_fold_reference API\n\nThis simplifies the maybe_fold_reference API reflecting that it\nno longer canonicalizes refs (that's done with another function)\nbut only performs constant folding and thus does nothing for is_lhs.\n\nThis in turn allows to rip out quite some dead code and one user\nof valid_gimple_rhs_p.\n\n2021-04-16  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-fold.c (maybe_fold_reference): Remove is_lhs\n\tparameter (and assume it to be false).\n\t(fold_gimple_assign): Adjust, remove all callers of\n\tmaybe_fold_reference calling it with is_lhs true.\n\t(gimple_fold_call): Likewise.\n\t(fold_stmt_1): Likewise.", "tree": {"sha": "52ac7a7b89f27299c53f57522e39b8aae457277b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ac7a7b89f27299c53f57522e39b8aae457277b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61c4964cd71446232d62ec9b10a7d45b440dd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c4964cd71446232d62ec9b10a7d45b440dd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61c4964cd71446232d62ec9b10a7d45b440dd9f"}], "stats": {"total": 77, "additions": 19, "deletions": 58}, "files": [{"sha": "7602018ff923acd4bba8bd4f291edcc3cf06d8f0", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 19, "deletions": 58, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=0bf8cd9d5e8acf6fd90a14f832bb2d5de97449b3", "patch": "@@ -303,13 +303,11 @@ get_symbol_constant_value (tree sym)\n \n \n \n-/* Subroutine of fold_stmt.  We perform several simplifications of the\n-   memory reference tree EXPR and make sure to re-gimplify them properly\n-   after propagation of constant addresses.  IS_LHS is true if the\n-   reference is supposed to be an lvalue.  */\n+/* Subroutine of fold_stmt.  We perform constant folding of the\n+   memory reference tree EXPR.  */\n \n static tree\n-maybe_fold_reference (tree expr, bool is_lhs)\n+maybe_fold_reference (tree expr)\n {\n   tree result;\n \n@@ -330,8 +328,7 @@ maybe_fold_reference (tree expr, bool is_lhs)\n \t\t\t     TREE_OPERAND (expr, 1),\n \t\t\t     TREE_OPERAND (expr, 2));\n \n-  if (!is_lhs\n-      && (result = fold_const_aggregate_ref (expr))\n+  if ((result = fold_const_aggregate_ref (expr))\n       && is_gimple_min_invariant (result))\n     return result;\n \n@@ -363,7 +360,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t  return NULL_TREE;\n \n \tif (REFERENCE_CLASS_P (rhs))\n-\t  return maybe_fold_reference (rhs, false);\n+\t  return maybe_fold_reference (rhs);\n \n \telse if (TREE_CODE (rhs) == OBJ_TYPE_REF)\n \t  {\n@@ -405,28 +402,14 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \telse if (TREE_CODE (rhs) == ADDR_EXPR)\n \t  {\n \t    tree ref = TREE_OPERAND (rhs, 0);\n-\t    tree tem = maybe_fold_reference (ref, true);\n-\t    if (tem\n-\t\t&& TREE_CODE (tem) == MEM_REF\n-\t\t&& integer_zerop (TREE_OPERAND (tem, 1)))\n-\t      result = fold_convert (TREE_TYPE (rhs), TREE_OPERAND (tem, 0));\n-\t    else if (tem)\n-\t      result = fold_convert (TREE_TYPE (rhs),\n-\t\t\t\t     build_fold_addr_expr_loc (loc, tem));\n-\t    else if (TREE_CODE (ref) == MEM_REF\n-\t\t     && integer_zerop (TREE_OPERAND (ref, 1)))\n-\t      result = fold_convert (TREE_TYPE (rhs), TREE_OPERAND (ref, 0));\n-\n-\t    if (result)\n+\t    if (TREE_CODE (ref) == MEM_REF\n+\t\t&& integer_zerop (TREE_OPERAND (ref, 1)))\n \t      {\n-\t\t/* Strip away useless type conversions.  Both the\n-\t\t   NON_LVALUE_EXPR that may have been added by fold, and\n-\t\t   \"useless\" type conversions that might now be apparent\n-\t\t   due to propagation.  */\n-\t\tSTRIP_USELESS_TYPE_CONVERSION (result);\n-\n-\t\tif (result != rhs && valid_gimple_rhs_p (result))\n-\t\t  return result;\n+\t\tresult = TREE_OPERAND (ref, 0);\n+\t\tif (!useless_type_conversion_p (TREE_TYPE (rhs),\n+\t\t\t\t\t\tTREE_TYPE (result)))\n+\t\t  result = build1 (NOP_EXPR, TREE_TYPE (rhs), result);\n+\t\treturn result;\n \t      }\n \t  }\n \n@@ -5262,7 +5245,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n     if (REFERENCE_CLASS_P (gimple_call_arg (stmt, i)))\n       {\n-\ttree tmp = maybe_fold_reference (gimple_call_arg (stmt, i), false);\n+\ttree tmp = maybe_fold_reference (gimple_call_arg (stmt, i));\n \tif (tmp)\n \t  {\n \t    gimple_call_set_arg (stmt, i, tmp);\n@@ -5373,7 +5356,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t}\n       else\n \t{\n-\t  tree tmp = maybe_fold_reference (gimple_call_chain (stmt), false);\n+\t  tree tmp = maybe_fold_reference (gimple_call_chain (stmt));\n \t  if (tmp)\n \t    {\n \t      gimple_call_set_chain (stmt, tmp);\n@@ -6107,18 +6090,11 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \tnoutputs = gimple_asm_noutputs (asm_stmt);\n \toconstraints = XALLOCAVEC (const char *, noutputs);\n \n-\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); ++i)\n+\tfor (i = 0; i < noutputs; ++i)\n \t  {\n \t    tree link = gimple_asm_output_op (asm_stmt, i);\n-\t    tree op = TREE_VALUE (link);\n \t    oconstraints[i]\n \t      = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-\t    if (REFERENCE_CLASS_P (op)\n-\t\t&& (op = maybe_fold_reference (op, true)) != NULL_TREE)\n-\t      {\n-\t\tTREE_VALUE (link) = op;\n-\t\tchanged = true;\n-\t      }\n \t  }\n \tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); ++i)\n \t  {\n@@ -6129,8 +6105,8 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \t    parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n \t\t\t\t    oconstraints, &allows_mem, &allows_reg);\n \t    if (REFERENCE_CLASS_P (op)\n-\t\t&& (op = maybe_fold_reference (op, !allows_reg && allows_mem))\n-\t\t   != NULL_TREE)\n+\t\t&& (allows_reg || !allows_mem)\n+\t\t&& (op = maybe_fold_reference (op)) != NULL_TREE)\n \t      {\n \t\tTREE_VALUE (link) = op;\n \t\tchanged = true;\n@@ -6146,7 +6122,7 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \t  if (val\n \t      && REFERENCE_CLASS_P (val))\n \t    {\n-\t      tree tem = maybe_fold_reference (val, false);\n+\t      tree tem = maybe_fold_reference (val);\n \t      if (tem)\n \t\t{\n \t\t  gimple_debug_bind_set_value (stmt, tem);\n@@ -6157,7 +6133,7 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \t\t   && TREE_CODE (val) == ADDR_EXPR)\n \t    {\n \t      tree ref = TREE_OPERAND (val, 0);\n-\t      tree tem = maybe_fold_reference (ref, false);\n+\t      tree tem = maybe_fold_reference (ref);\n \t      if (tem)\n \t\t{\n \t\t  tem = build_fold_addr_expr_with_type (tem, TREE_TYPE (val));\n@@ -6191,21 +6167,6 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n \n   stmt = gsi_stmt (*gsi);\n \n-  /* Fold *& on the lhs.  */\n-  if (gimple_has_lhs (stmt))\n-    {\n-      tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && REFERENCE_CLASS_P (lhs))\n-\t{\n-\t  tree new_lhs = maybe_fold_reference (lhs, true);\n-\t  if (new_lhs)\n-\t    {\n-\t      gimple_set_lhs (stmt, new_lhs);\n-\t      changed = true;\n-\t    }\n-\t}\n-    }\n-\n   fold_undefer_overflow_warnings (changed && !nowarning, stmt, 0);\n   return changed;\n }"}]}