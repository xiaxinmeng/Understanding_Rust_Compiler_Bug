{"sha": "5bdc151289c62ce18bd013db9b7f730b37cf40f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkYzE1MTI4OWM2MmNlMThiZDAxM2RiOWI3ZjczMGIzN2NmNDBmNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T23:26:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T23:26:54Z"}, "message": "(enum sharp_token_type): New type.\n\n(stringify, raw_before, raw_after): Use this type instead of char.\n(collect_expansion, dump_single_macro): Keep track of white space\nafter # and around ## tokens, since the C Standard requires a\ndiagnostic if the white space doesn't match during a redefinition.\n(sharp_token, sharp_sharp_token): Labels renamed from hash_token and\nhash_hash_token for naming consistency.\n\nFrom-SVN: r9036", "tree": {"sha": "9891620a987e8e56b2e37f8b0f9f9b640b84c0ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9891620a987e8e56b2e37f8b0f9f9b640b84c0ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bdc151289c62ce18bd013db9b7f730b37cf40f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdc151289c62ce18bd013db9b7f730b37cf40f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bdc151289c62ce18bd013db9b7f730b37cf40f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdc151289c62ce18bd013db9b7f730b37cf40f4/comments", "author": null, "committer": null, "parents": [{"sha": "34dd38384440cabb02cc4c201e61fb76505bde32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34dd38384440cabb02cc4c201e61fb76505bde32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34dd38384440cabb02cc4c201e61fb76505bde32"}], "stats": {"total": 105, "additions": 73, "deletions": 32}, "files": [{"sha": "3121c5469a220d94a2e1874f8b4a7302ebc0b72f", "filename": "gcc/cccp.c", "status": "modified", "additions": 73, "deletions": 32, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc151289c62ce18bd013db9b7f730b37cf40f4/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc151289c62ce18bd013db9b7f730b37cf40f4/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=5bdc151289c62ce18bd013db9b7f730b37cf40f4", "patch": "@@ -677,6 +677,16 @@ struct macrodef\n static struct macrodef create_definition ();\n \n \f\n+enum sharp_token_type {\n+  NO_SHARP_TOKEN,\t\t/* token not present */\n+\n+  SHARP_TOKEN = '#',\t\t/* token spelled with # only */\n+  WHITE_SHARP_TOKEN,\t\t/* token spelled with # and white space */\n+\n+  PERCENT_COLON_TOKEN = '%',\t/* token spelled with %: only */\n+  WHITE_PERCENT_COLON_TOKEN\t/* token spelled with %: and white space */\n+};\n+\n /* Structure allocated for every #define.  For a simple replacement\n    such as\n    \t#define foo bar ,\n@@ -711,12 +721,9 @@ struct definition {\n   struct reflist {\n     struct reflist *next;\n \n-    /* The following three members have the value '#' if spelled with \"#\",\n-       and '%' if spelled with \"%:\".  */\n-    char stringify;\t\t/* nonzero if this arg was preceded by a\n-\t\t\t\t   # operator. */\n-    char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n-    char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n+    enum sharp_token_type stringify;\t/* set if a # operator before arg */\n+    enum sharp_token_type raw_before;\t/* set if a ## operator before arg */\n+    enum sharp_token_type raw_after;\t/* set if a ## operator after arg */\n \n     char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n     int nchars;\t\t\t/* Number of literal chars to copy before\n@@ -5757,9 +5764,9 @@ collect_expansion (buf, end, nargs, arglist)\n   U_CHAR *concat = 0;\n   /* Pointer to first nonspace after last single-# seen.  */\n   U_CHAR *stringify = 0;\n-  /* How those tokens were spelled: 0, '#', or '%' (meaning %:).  */\n-  char concat_spelling = 0;\n-  char stringify_spelling = 0;\n+  /* How those tokens were spelled.  */\n+  enum sharp_token_type concat_sharp_token_type = NO_SHARP_TOKEN;\n+  enum sharp_token_type stringify_sharp_token_type = NO_SHARP_TOKEN;\n   int maxsize;\n   int expected_delimiter = '\\0';\n \n@@ -5843,11 +5850,11 @@ collect_expansion (buf, end, nargs, arglist)\n \t    /* Treat %:%: as ## and %: as #.  */\n \t    if (p[1] == '%' && p[2] == ':') {\n \t      p += 2;\n-\t      goto hash_hash_token;\n+\t      goto sharp_sharp_token;\n \t    }\n \t    if (nargs >= 0) {\n \t      p++;\n-\t      goto hash_token;\n+\t      goto sharp_token;\n \t    }\n \t  }\n \t}\n@@ -5858,32 +5865,38 @@ collect_expansion (buf, end, nargs, arglist)\n \tif (expected_delimiter)\n \t  break;\n \tif (*p == '#') {\n-\thash_hash_token:\n+\tsharp_sharp_token:\n \t  /* ##: concatenate preceding and following tokens.  */\n \t  /* Take out the first #, discard preceding whitespace.  */\n \t  exp_p--;\n \t  while (exp_p > lastp && is_hor_space[exp_p[-1]])\n \t    --exp_p;\n \t  /* Skip the second #.  */\n \t  p++;\n-\t  /* Discard following whitespace.  */\n-\t  SKIP_WHITE_SPACE (p);\n+\t  concat_sharp_token_type = c;\n+\t  if (is_hor_space[*p]) {\n+\t    concat_sharp_token_type++;\n+\t    p++;\n+\t    SKIP_WHITE_SPACE (p);\n+\t  }\n \t  concat = p;\n-\t  concat_spelling = c;\n \t  if (p == limit)\n \t    error (\"`##' at end of macro definition\");\n \t} else if (nargs >= 0) {\n \t  /* Single #: stringify following argument ref.\n \t     Don't leave the # in the expansion.  */\n-\thash_token:\n+\tsharp_token:\n \t  exp_p--;\n-\t  SKIP_WHITE_SPACE (p);\n+\t  stringify_sharp_token_type = c;\n+\t  if (is_hor_space[*p]) {\n+\t    stringify_sharp_token_type++;\n+\t    p++;\n+\t    SKIP_WHITE_SPACE (p);\n+\t  }\n \t  if (! is_idstart[*p] || nargs == 0)\n \t    error (\"`#' operator is not followed by a macro argument name\");\n-\t  else {\n+\t  else\n \t    stringify = p;\n-\t    stringify_spelling = c;\n-\t  }\n \t}\n \tbreak;\n       }\n@@ -5965,11 +5978,13 @@ collect_expansion (buf, end, nargs, arglist)\n \t       the pat list */\n \t    tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n \t    tpat->next = NULL;\n-\t    tpat->raw_before = concat == id_beg ? concat_spelling : 0;\n-\t    tpat->raw_after = 0;\n+\t    tpat->raw_before\n+\t      = concat == id_beg ? concat_sharp_token_type : NO_SHARP_TOKEN;\n+\t    tpat->raw_after = NO_SHARP_TOKEN;\n \t    tpat->rest_args = arg->rest_args;\n-\t    tpat->stringify = (traditional ? expected_delimiter != '\\0'\n-\t\t\t       : stringify == id_beg) ? stringify_spelling : 0;\n+\t    tpat->stringify\n+\t      = ((traditional ? expected_delimiter : stringify == id_beg)\n+\t\t ? stringify_sharp_token_type : NO_SHARP_TOKEN);\n \n \t    if (endpat == NULL)\n \t      defn->pattern = tpat;\n@@ -5985,7 +6000,7 @@ collect_expansion (buf, end, nargs, arglist)\n \t      if (p1[0]=='#'\n \t          ? p1[1]=='#'\n \t\t  : p1[0]=='%' && p1[1]==':' && p1[2]=='%' && p1[3]==':')\n-\t\ttpat->raw_after = p1[0];\n+\t\ttpat->raw_after = p1[0] + (p != p1);\n \t    }\n \t    lastp = exp_p;\t/* place to start copying from next time */\n \t    skipped_arg = 1;\n@@ -7105,14 +7120,14 @@ skip_if_group (ip, any, op)\n       while (bp[0] == '\\\\' && bp[1] == '\\n')\n \tbp += 2;\n       if (*bp == ':')\n-\tgoto hash_token;\n+\tgoto sharp_token;\n       break;\n     case '#':\n       /* # keyword: a # must be first nonblank char on the line */\n       if (beg_of_line == 0)\n \tbreak;\n       ip->bufp = bp - 1;\n-    hash_token:\n+    sharp_token:\n       /* Scan from start of line, skipping whitespace, comments\n \t and backslash-newlines, and see if we reach this #.\n \t If not, this # is not special.  */\n@@ -9153,15 +9168,41 @@ dump_single_macro (hp, of)\n     if (!traditional) {\n       if (ap->nchars != 0)\n \tconcat = 0;\n-      if (ap->stringify)\n-\tfprintf (of, ap->stringify == '#' ? \" #\" : \" %:\");\n-      if (ap->raw_before && !concat)\n-\tfprintf (of, ap->raw_before == '#' ? \" ## \" : \" %:%: \");\n+      if (ap->stringify) {\n+\tswitch (ap->stringify) {\n+\t case SHARP_TOKEN: fprintf (of, \"#\"); break;\n+\t case WHITE_SHARP_TOKEN: fprintf (of, \"# \"); break;\n+\t case PERCENT_COLON_TOKEN: fprintf (of, \"%:\"); break;\n+\t case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \"%: \"); break;\n+\t}\n+      }\n+      if (ap->raw_before) {\n+\tif (concat) {\n+\t  switch (ap->raw_before) {\n+\t   case WHITE_SHARP_TOKEN:\n+\t   case WHITE_PERCENT_COLON_TOKEN:\n+\t    fprintf (of, \" \");\n+\t    break;\n+\t  }\n+\t} else {\n+\t  switch (ap->raw_before) {\n+\t   case SHARP_TOKEN: fprintf (of, \"##\"); break;\n+\t   case WHITE_SHARP_TOKEN: fprintf (of, \"## \"); break;\n+\t   case PERCENT_COLON_TOKEN: fprintf (of, \"%:%:\"); break;\n+\t   case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \"%:%: \"); break;\n+\t  }\n+\t}\n+      }\n       concat = 0;\n     }\n     dump_arg_n (defn, ap->argno, of);\n     if (!traditional && ap->raw_after) {\n-      fprintf (of, ap->raw_after == '#' ? \" ## \" : \" %:%: \");\n+      switch (ap->raw_after) {\n+       case SHARP_TOKEN: fprintf (of, \"##\"); break;\n+       case WHITE_SHARP_TOKEN: fprintf (of, \" ##\"); break;\n+       case PERCENT_COLON_TOKEN: fprintf (of, \"%:%:\"); break;\n+       case WHITE_PERCENT_COLON_TOKEN: fprintf (of, \" %:%:\"); break;\n+      }\n       concat = 1;\n     }\n   }"}]}