{"sha": "875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc1ZDZjYjNiNDkxOWI1OGFlNWU2MzEzZGI3MTViYzRkZDNkZGQ2Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-17T15:24:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-17T15:40:11Z"}, "message": "libstdc++: Add comparison operators for string and regex types\n\nSome more C++20 changes from P1614R2, \"The Mothership has Landed\".\n\nThis adds three-way comparison support to std::char_traits,\nstd::basic_string, std::basic_string_view, and std::sub_match.\n\n\t* include/bits/basic_string.h (basic_string): Define operator<=> and\n\tremove redundant comparison operators for C++20.\n\t* include/bits/char_traits.h (__gnu_cxx::char_traits, char_traits):\n\tAdd comparison_category members.\n\t(__detail::__char_traits_cmp_cat): New helper to get comparison\n\tcategory from char traits class.\n\t* include/bits/regex.h (regex_traits::_RegexMask::operator!=): Do not\n\tdefine for C++20.\n\t(sub_match): Define operator<=> and remove redundant comparison\n\toperators for C++20.\n\t(match_results): Remove redundant operator!= for C++20.\n\t* include/std/string_view (basic_string_view): Define operator<=> and\n\tremove redundant comparison operators for C++20.\n\t* testsuite/21_strings/basic_string/operators/char/cmp_c++20.cc: New\n\ttest.\n\t* testsuite/21_strings/basic_string/operators/wchar_t/cmp_c++20.cc:\n\tNew test.\n\t* testsuite/21_strings/basic_string_view/operations/copy/char/\n\tconstexpr.cc: Initialize variable.\n\t* testsuite/21_strings/basic_string_view/operations/copy/wchar_t/\n\tconstexpr.cc: Likewise.\n\t* testsuite/21_strings/basic_string_view/operators/char/2.cc: Add\n\tdg-do directive and remove comments showing incorrect signatures.\n\t* testsuite/21_strings/basic_string_view/operators/wchar_t/2.cc:\n\tLikewise.\n\t* testsuite/21_strings/basic_string_view/operators/char/cmp_c++20.cc:\n\tNew test.\n\t* testsuite/21_strings/basic_string_view/operators/wchar_t/cmp_c++20.cc:\n\tNew test.\n\t* testsuite/28_regex/sub_match/compare_c++20.cc: New test.", "tree": {"sha": "60ec809bcce439236e5778bc5b6a8c9d4d1fbcf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60ec809bcce439236e5778bc5b6a8c9d4d1fbcf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b50d7a47624030d87645237c60bd8f7ac78b2ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b50d7a47624030d87645237c60bd8f7ac78b2ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b50d7a47624030d87645237c60bd8f7ac78b2ec"}], "stats": {"total": 1825, "additions": 1628, "deletions": 197}, "files": [{"sha": "d24c757d00ab95cea434dce1ef5050df03ba07ad", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -1,3 +1,36 @@\n+2020-04-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/basic_string.h (basic_string): Define operator<=> and\n+\tremove redundant comparison operators for C++20.\n+\t* include/bits/char_traits.h (__gnu_cxx::char_traits, char_traits):\n+\tAdd comparison_category members.\n+\t(__detail::__char_traits_cmp_cat): New helper to get comparison\n+\tcategory from char traits class.\n+\t* include/bits/regex.h (regex_traits::_RegexMask::operator!=): Do not\n+\tdefine for C++20.\n+\t(sub_match): Define operator<=> and remove redundant comparison\n+\toperators for C++20.\n+\t(match_results): Remove redundant operator!= for C++20.\n+\t* include/std/string_view (basic_string_view): Define operator<=> and\n+\tremove redundant comparison operators for C++20.\n+\t* testsuite/21_strings/basic_string/operators/char/cmp_c++20.cc: New\n+\ttest.\n+\t* testsuite/21_strings/basic_string/operators/wchar_t/cmp_c++20.cc:\n+\tNew test.\n+\t* testsuite/21_strings/basic_string_view/operations/copy/char/\n+\tconstexpr.cc: Initialize variable.\n+\t* testsuite/21_strings/basic_string_view/operations/copy/wchar_t/\n+\tconstexpr.cc: Likewise.\n+\t* testsuite/21_strings/basic_string_view/operators/char/2.cc: Add\n+\tdg-do directive and remove comments showing incorrect signatures.\n+\t* testsuite/21_strings/basic_string_view/operators/wchar_t/2.cc:\n+\tLikewise.\n+\t* testsuite/21_strings/basic_string_view/operators/char/cmp_c++20.cc:\n+\tNew test.\n+\t* testsuite/21_strings/basic_string_view/operators/wchar_t/cmp_c++20.cc:\n+\tNew test.\n+\t* testsuite/28_regex/sub_match/compare_c++20.cc: New test.\n+\n 2020-04-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: Remove"}, {"sha": "bc0c256b65e4893ed6dba1f29557ec5310e49aeb", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -6164,18 +6164,6 @@ _GLIBCXX_END_NAMESPACE_CXX11\n \t      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),\n \t\t\t\t\t\t    __lhs.size())); }\n \n-  /**\n-   *  @brief  Test equivalence of C string and string.\n-   *  @param __lhs  C string.\n-   *  @param __rhs  String.\n-   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.\n-   */\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    inline bool\n-    operator==(const _CharT* __lhs,\n-\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n-    { return __rhs.compare(__lhs) == 0; }\n-\n   /**\n    *  @brief  Test equivalence of string and C string.\n    *  @param __lhs  String.\n@@ -6188,6 +6176,47 @@ _GLIBCXX_END_NAMESPACE_CXX11\n \t       const _CharT* __rhs)\n     { return __lhs.compare(__rhs) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Three-way comparison of a string and a C string.\n+   *  @param __lhs  A string.\n+   *  @param __rhs  A null-terminated string.\n+   *  @return  A value indicating whether `__lhs` is less than, equal to,\n+   *\t       greater than, or incomparable with `__rhs`.\n+   */\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline auto\n+    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t\tconst basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept\n+    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n+    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }\n+\n+  /**\n+   *  @brief  Three-way comparison of a string and a C string.\n+   *  @param __lhs  A string.\n+   *  @param __rhs  A null-terminated string.\n+   *  @return  A value indicating whether `__lhs` is less than, equal to,\n+   *\t       greater than, or incomparable with `__rhs`.\n+   */\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline auto\n+    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t\tconst _CharT* __rhs) noexcept\n+    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n+    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }\n+#else\n+  /**\n+   *  @brief  Test equivalence of C string and string.\n+   *  @param __lhs  C string.\n+   *  @param __rhs  String.\n+   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.\n+   */\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) == 0; }\n+\n   // operator !=\n   /**\n    *  @brief  Test difference of two strings.\n@@ -6377,6 +6406,7 @@ _GLIBCXX_END_NAMESPACE_CXX11\n     operator>=(const _CharT* __lhs,\n \t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) <= 0; }\n+#endif // three-way comparison\n \n   /**\n    *  @brief  Swap contents of two strings."}, {"sha": "c6da184e4bd4292546ad45626f58ae0313f69c28", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -39,6 +39,9 @@\n #include <bits/stl_algobase.h>  // std::copy, std::fill_n\n #include <bits/postypes.h>      // For streampos\n #include <cwchar>               // For WEOF, wmemmove, wmemset, etc.\n+#if __cplusplus > 201703L\n+# include <compare>\n+#endif\n \n #ifndef _GLIBCXX_ALWAYS_INLINE\n # define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))\n@@ -91,6 +94,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename _Char_types<_CharT>::pos_type    pos_type;\n       typedef typename _Char_types<_CharT>::off_type    off_type;\n       typedef typename _Char_types<_CharT>::state_type  state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = std::strong_ordering;\n+#endif\n \n       static _GLIBCXX14_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2)\n@@ -307,6 +313,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef streampos         pos_type;\n       typedef streamoff         off_type;\n       typedef mbstate_t         state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = strong_ordering;\n+#endif\n \n       static _GLIBCXX17_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n@@ -432,6 +441,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef streamoff         off_type;\n       typedef wstreampos        pos_type;\n       typedef mbstate_t         state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = strong_ordering;\n+#endif\n \n       static _GLIBCXX17_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n@@ -550,6 +562,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef u8streampos       pos_type;\n       typedef streamoff         off_type;\n       typedef mbstate_t         state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = strong_ordering;\n+#endif\n \n       static _GLIBCXX17_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n@@ -687,6 +702,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef streamoff         off_type;\n       typedef u16streampos      pos_type;\n       typedef mbstate_t         state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = strong_ordering;\n+#endif\n \n       static _GLIBCXX17_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2) noexcept\n@@ -798,6 +816,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef streamoff         off_type;\n       typedef u32streampos      pos_type;\n       typedef mbstate_t         state_type;\n+#if __cpp_lib_three_way_comparison\n+      using comparison_category = strong_ordering;\n+#endif\n \n       static _GLIBCXX17_CONSTEXPR void\n       assign(char_type& __c1, const char_type& __c2) noexcept\n@@ -895,6 +916,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return eq_int_type(__c, eof()) ? 0 : __c; }\n     };\n \n+#if __cpp_lib_three_way_comparison\n+  namespace __detail\n+  {\n+    template<typename _ChTraits>\n+      constexpr auto\n+      __char_traits_cmp_cat(int __cmp) noexcept\n+      {\n+\tif constexpr (requires { typename _ChTraits::comparison_category; })\n+\t  {\n+\t    using _Cat = typename _ChTraits::comparison_category;\n+\t    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );\n+\t    return static_cast<_Cat>(__cmp <=> 0);\n+\t  }\n+\telse\n+\t  return static_cast<weak_ordering>(__cmp <=> 0);\n+      }\n+  } // namespace __detail\n+#endif // C++20\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "6db05889e8cecaa84c22921b0f79978eaa62154f", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -142,11 +142,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t\t     && _M_base == __other._M_base;\n \t  }\n \n+#if __cpp_impl_three_way_comparison < 201907L\n \t  constexpr bool\n \t  operator!=(_RegexMask __other) const\n \t  { return !((*this) == __other); }\n-\n+#endif\n \t};\n+\n     public:\n       typedef _RegexMask char_class_type;\n \n@@ -1033,6 +1035,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n     { return __lhs.compare(__rhs) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   * @brief Three-way comparison of two regular expression submatches.\n+   * @param __lhs First regular expression submatch.\n+   * @param __rhs Second regular expression submatch.\n+   * @returns A value indicating whether `__lhs` is less than, equal to,\n+   *\t      greater than, or incomparable with `__rhs`.\n+   */\n+  template<typename _BiIter>\n+    inline auto\n+    operator<=>(const sub_match<_BiIter>& __lhs,\n+\t\tconst sub_match<_BiIter>& __rhs)\n+    noexcept(__detail::__is_contiguous_iter<_BiIter>::value)\n+    {\n+      using _Tr = char_traits<typename iterator_traits<_BiIter>::value_type>;\n+      return __detail::__char_traits_cmp_cat<_Tr>(__lhs.compare(__rhs));\n+    }\n+#else\n   /**\n    * @brief Tests the inequivalence of two regular expression submatches.\n    * @param __lhs First regular expression submatch.\n@@ -1087,6 +1107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     inline bool\n     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n     { return __lhs.compare(__rhs) > 0; }\n+#endif // three-way comparison\n \n   /// @cond undocumented\n \n@@ -1097,6 +1118,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t\t\t      _Ch_traits, _Ch_alloc>;\n   /// @endcond\n \n+#if ! __cpp_lib_three_way_comparison\n   /**\n    * @brief Tests the equivalence of a string and a regular expression\n    *        submatch.\n@@ -1170,6 +1192,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator<=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n \t       const sub_match<_Bi_iter>& __rhs)\n     { return !(__rhs < __lhs); }\n+#endif // three-way comparison\n \n   /**\n    * @brief Tests the equivalence of a regular expression submatch and a\n@@ -1184,6 +1207,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n     { return __lhs._M_compare(__rhs.data(), __rhs.size()) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   * @brief Three-way comparison of a regular expression submatch and a string.\n+   * @param __lhs A regular expression submatch.\n+   * @param __rhs A string.\n+   * @returns A value indicating whether `__lhs` is less than, equal to,\n+   *\t      greater than, or incomparable with `__rhs`.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Alloc>\n+    inline auto\n+    operator<=>(const sub_match<_Bi_iter>& __lhs,\n+\t\tconst __sub_match_string<_Bi_iter, _Ch_traits, _Alloc>& __rhs)\n+    noexcept(__detail::__is_contiguous_iter<_Bi_iter>::value)\n+    {\n+      return __detail::__char_traits_cmp_cat<_Ch_traits>(\n+\t  __lhs._M_compare(__rhs.data(), __rhs.size()));\n+    }\n+#else\n   /**\n    * @brief Tests the inequivalence of a regular expression submatch and a\n    *        string.\n@@ -1318,6 +1359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n \t       const sub_match<_Bi_iter>& __rhs)\n     { return !(__rhs < __lhs); }\n+#endif // three-way comparison\n \n   /**\n    * @brief Tests the equivalence of a regular expression submatch and a C\n@@ -1332,6 +1374,25 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n     { return __lhs.compare(__rhs) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   * @brief Three-way comparison of a regular expression submatch and a C\n+   *\t    string.\n+   * @param __lhs A regular expression submatch.\n+   * @param __rhs A null-terminated string.\n+   * @returns A value indicating whether `__lhs` is less than, equal to,\n+   *\t      greater than, or incomparable with `__rhs`.\n+   */\n+  template<typename _Bi_iter>\n+    inline auto\n+    operator<=>(const sub_match<_Bi_iter>& __lhs,\n+\t\ttypename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    noexcept(__detail::__is_contiguous_iter<_Bi_iter>::value)\n+    {\n+      using _Tr = char_traits<typename iterator_traits<_Bi_iter>::value_type>;\n+      return __detail::__char_traits_cmp_cat<_Tr>(__lhs.compare(__rhs));\n+    }\n+#else\n   /**\n    * @brief Tests the inequivalence of a regular expression submatch and a\n    *        string.\n@@ -1470,6 +1531,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n \t       const sub_match<_Bi_iter>& __rhs)\n     { return !(__rhs < __lhs); }\n+#endif // three-way comparison\n \n   /**\n    * @brief Tests the equivalence of a regular expression submatch and a\n@@ -1484,6 +1546,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n     { return __lhs._M_compare(std::__addressof(__rhs), 1) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   * @brief Three-way comparison of a regular expression submatch and a\n+   *\t    character.\n+   * @param __lhs A regular expression submatch.\n+   * @param __rhs A character.\n+   * @returns A value indicating whether `__lhs` is less than, equal to,\n+   *\t      greater than, or incomparable with `__rhs`.\n+   */\n+\n+  template<typename _Bi_iter>\n+    inline auto\n+    operator<=>(const sub_match<_Bi_iter>& __lhs,\n+\t\ttypename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    noexcept(__detail::__is_contiguous_iter<_Bi_iter>::value)\n+    {\n+      using _Tr = char_traits<typename iterator_traits<_Bi_iter>::value_type>;\n+      return __detail::__char_traits_cmp_cat<_Tr>(\n+\t  __lhs._M_compare(std::__addressof(__rhs), 1));\n+    }\n+#else\n   /**\n    * @brief Tests the inequivalence of a regular expression submatch and a\n    *        character.\n@@ -1548,6 +1631,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator<=(const sub_match<_Bi_iter>& __lhs,\n \t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n     { return !(__rhs < __lhs); }\n+#endif // three-way comparison\n \n   /**\n    * @brief Inserts a matched string into an output stream.\n@@ -2031,6 +2115,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t&& __m1.suffix() == __m2.suffix();\n     }\n \n+#if ! __cpp_lib_three_way_comparison\n   /**\n    * @brief Compares two match_results for inequality.\n    * @returns true if the two objects do not refer to the same match,\n@@ -2041,6 +2126,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     operator!=(const match_results<_Bi_iter, _Alloc>& __m1,\n \t       const match_results<_Bi_iter, _Alloc>& __m2) noexcept\n     { return !(__m1 == __m2); }\n+#endif\n \n   // [7.10.6] match_results swap\n   /**"}, {"sha": "b5d8eab2f337d98a5e0c42e474a61d8d756c179e", "filename": "libstdc++-v3/include/std/string_view", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -494,6 +494,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     noexcept\n     { return __x.size() == __y.size() && __x.compare(__y) == 0; }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _CharT, typename _Traits>\n+    constexpr auto\n+    operator<=>(basic_string_view<_CharT, _Traits> __x,\n+\t\tbasic_string_view<_CharT, _Traits> __y) noexcept\n+    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n+    { return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y)); }\n+\n+  template<typename _CharT, typename _Traits>\n+    constexpr auto\n+    operator<=>(basic_string_view<_CharT, _Traits> __x,\n+\t\t__type_identity_t<basic_string_view<_CharT, _Traits>> __y)\n+    noexcept\n+    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n+    { return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y)); }\n+#else\n   template<typename _CharT, typename _Traits>\n     constexpr bool\n     operator==(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,\n@@ -594,6 +610,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     operator>=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,\n                basic_string_view<_CharT, _Traits> __y) noexcept\n     { return __x.compare(__y) >= 0; }\n+#endif // three-way comparison\n \n   // [string.view.io], Inserters and extractors\n   template<typename _CharT, typename _Traits>"}, {"sha": "b62d10bdb639d43c86bc47985dccef233ff9f07b", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/operators/char/cmp_c++20.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -0,0 +1,194 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+// C++20 21.3.3.2 Non-member comparison functions [string.cmp]\n+\n+// operator==\n+/*\n+template<class charT, class traits, class Allocator>\n+  constexpr bool\n+  operator==(const basic_string<charT, traits, Allocator>& lhs,\n+\t     const basic_string<charT, traits, Allocator>& rhs);\n+\n+template<class charT, class traits, class Allocator>\n+  constexpr bool\n+  operator==(const basic_string<charT, traits, Allocator>& lhs,\n+\t     const charT* rhs);\n+*/\n+\n+// operator<=>\n+/*\n+template<class charT, class traits, class Allocator>\n+  constexpr [see below]\n+  operator<=>(const basic_string<charT, traits, Allocator>& lhs,\n+\t      const basic_string<charT, traits, Allocator>& rhs);\n+\n+template<class charT, class traits, class Allocator>\n+  constexpr [see below]\n+  operator<=>(const basic_string<charT,traits,Allocator>& lhs,\n+\t      const charT* rhs);\n+*/\n+\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::string \tstr_0(\"costa rica\");\n+  std::string \tstr_1(\"costa marbella\");\n+  std::string \tstr_2(\"cost\");\n+  std::string\tstr_3(\"costa ricans\");\n+  std::string        str_4;\n+\n+  str_4 = str_0;\n+  //comparisons between string objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string object and string literal\n+  VERIFY( !(str_0 == \"costa marbella\") );\n+  VERIFY( !(str_0 == \"cost\") );\n+  VERIFY( !(str_0 == \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" == str_0) );\n+  VERIFY( !(\"cost\" == str_0) );\n+  VERIFY( !(\"costa ricans\" == str_0) );\n+  VERIFY( \"costa rica\" == str_0 );\n+  VERIFY( str_0 == \"costa rica\" );\n+\n+  VERIFY( str_0 != \"costa marbella\" );\n+  VERIFY( str_0 != \"cost\" );\n+  VERIFY( str_0 != \"costa ricans\" );\n+  VERIFY( \"costa marbella\" != str_0 );\n+  VERIFY( \"cost\" != str_0 );\n+  VERIFY( \"costa ricans\" != str_0 );\n+  VERIFY( !(\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != \"costa rica\") );\n+\n+  VERIFY( str_0 > \"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > \"cost\" );\n+  VERIFY( !(str_0 > \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" > str_0) );\n+  VERIFY( \"costa ricans\" > str_0 );\n+  VERIFY( !(\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > \"costa rica\") );\n+\n+  VERIFY( !(str_0 < \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < \"cost\") );\n+  VERIFY( str_0 < \"costa ricans\" );\n+  VERIFY( \"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( \"cost\" < str_0 );\n+  VERIFY( !(\"costa ricans\" < str_0) );\n+  VERIFY( !(\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < \"costa rica\") );\n+\n+  VERIFY( str_0 >= \"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= \"cost\" );\n+  VERIFY( !(str_0 >= \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" >= str_0) );\n+  VERIFY( \"costa ricans\" >= str_0 );\n+  VERIFY( \"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= \"costa rica\" );\n+\n+  VERIFY( !(str_0 <= \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= \"cost\") );\n+  VERIFY( str_0 <= \"costa ricans\" );\n+  VERIFY( \"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( \"cost\" <= str_0 );\n+  VERIFY( !(\"costa ricans\" <= str_0) );\n+  VERIFY( \"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= \"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> \"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> \"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> \"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> \"costa rica\") );\n+  VERIFY( std::is_lt(\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(\"costa rica\" <=> str_0) );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "4dda0b5c0f58fe75dda4ea6575e9c11134746d08", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/operators/wchar_t/cmp_c++20.cc", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -0,0 +1,194 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+// C++20 21.3.3.2 Non-member comparison functions [string.cmp]\n+\n+// operator==\n+/*\n+template<class charT, class traits, class Allocator>\n+  constexpr bool\n+  operator==(const basic_string<charT, traits, Allocator>& lhs,\n+\t     const basic_string<charT, traits, Allocator>& rhs);\n+\n+template<class charT, class traits, class Allocator>\n+  constexpr bool\n+  operator==(const basic_string<charT, traits, Allocator>& lhs,\n+\t     const charT* rhs);\n+*/\n+\n+// operator<=>\n+/*\n+template<class charT, class traits, class Allocator>\n+  constexpr [see below]\n+  operator<=>(const basic_string<charT, traits, Allocator>& lhs,\n+\t      const basic_string<charT, traits, Allocator>& rhs);\n+\n+template<class charT, class traits, class Allocator>\n+  constexpr [see below]\n+  operator<=>(const basic_string<charT,traits,Allocator>& lhs,\n+\t      const charT* rhs);\n+*/\n+\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::wstring \tstr_0(L\"costa rica\");\n+  std::wstring \tstr_1(L\"costa marbella\");\n+  std::wstring \tstr_2(L\"cost\");\n+  std::wstring\tstr_3(L\"costa ricans\");\n+  std::wstring  str_4;\n+\n+  str_4 = str_0;\n+  //comparisons between string objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string object and string literal\n+  VERIFY( !(str_0 == L\"costa marbella\") );\n+  VERIFY( !(str_0 == L\"cost\") );\n+  VERIFY( !(str_0 == L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" == str_0) );\n+  VERIFY( !(L\"cost\" == str_0) );\n+  VERIFY( !(L\"costa ricans\" == str_0) );\n+  VERIFY( L\"costa rica\" == str_0 );\n+  VERIFY( str_0 == L\"costa rica\" );\n+\n+  VERIFY( str_0 != L\"costa marbella\" );\n+  VERIFY( str_0 != L\"cost\" );\n+  VERIFY( str_0 != L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" != str_0 );\n+  VERIFY( L\"cost\" != str_0 );\n+  VERIFY( L\"costa ricans\" != str_0 );\n+  VERIFY( !(L\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != L\"costa rica\") );\n+\n+  VERIFY( str_0 > L\"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > L\"cost\" );\n+  VERIFY( !(str_0 > L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" > str_0) );\n+  VERIFY( L\"costa ricans\" > str_0 );\n+  VERIFY( !(L\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > L\"costa rica\") );\n+\n+  VERIFY( !(str_0 < L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < L\"cost\") );\n+  VERIFY( str_0 < L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" < str_0 );\n+  VERIFY( !(L\"costa ricans\" < str_0) );\n+  VERIFY( !(L\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < L\"costa rica\") );\n+\n+  VERIFY( str_0 >= L\"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= L\"cost\" );\n+  VERIFY( !(str_0 >= L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" >= str_0) );\n+  VERIFY( L\"costa ricans\" >= str_0 );\n+  VERIFY( L\"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= L\"costa rica\" );\n+\n+  VERIFY( !(str_0 <= L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= L\"cost\") );\n+  VERIFY( str_0 <= L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" <= str_0 );\n+  VERIFY( !(L\"costa ricans\" <= str_0) );\n+  VERIFY( L\"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= L\"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> L\"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> L\"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> L\"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> L\"costa rica\") );\n+  VERIFY( std::is_lt(L\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(L\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(L\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(L\"costa rica\" <=> str_0) );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "86a78108696b759aca2f5ea0621c3ef2fd6c072d", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fchar%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fchar%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fchar%2Fconstexpr.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -24,7 +24,7 @@ constexpr bool\n test01()\n {\n   std::string_view s = \"Everything changes and nothing stands still.\";\n-  char buf[7];\n+  char buf[7]{};\n   auto n = s.copy(buf, 7, 11);\n   return std::string_view(buf, n) == \"changes\";\n }"}, {"sha": "54df755c26bee68df2fc3582d12b5846d63f0bf8", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/wchar_t/constexpr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fwchar_t%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fwchar_t%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperations%2Fcopy%2Fwchar_t%2Fconstexpr.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -24,7 +24,7 @@ constexpr bool\n test01()\n {\n   std::wstring_view s = L\"Everything changes and nothing stands still.\";\n-  wchar_t buf[7];\n+  wchar_t buf[7]{};\n   auto n = s.copy(buf, 7, 11);\n   return std::wstring_view(buf, n) == L\"changes\";\n }"}, {"sha": "bd3921d27284e16c9e656461d45d7df5b5f6b7f2", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/2.cc", "status": "modified", "additions": 2, "deletions": 91, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2F2.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -1,4 +1,5 @@\n // { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n \n // Copyright (C) 2013-2020 Free Software Foundation, Inc.\n //\n@@ -17,97 +18,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// basic_string non-member functions\n-\n-// operator==\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const basic_string<charT,traits,Allocator>& lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const charT* lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const basic_string<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-*/\n-\n-// operator!=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const charT* lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const basic_string<charT,traits,Allocator>& lhs, \n-                  const charT* rhs);\n-*/\n-\n-// operator<\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const basic_string<charT,traits,Allocator>& lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const basic_string<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const charT* lhs, \n-                  const basic_string<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator>\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const basic_string<charT,traits,Allocator>& lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const basic_string<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const charT* lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator<=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const basic_string<charT,traits,Allocator>& lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const basic_string<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const charT* lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator>=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const basic_string<charT,traits,Allocator>& lhs,\n-                const basic_string<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const basic_string<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const charT* lhs,\n-                  const basic_string<charT,traits,Allocator>& rhs);\n-*/\n+// C++17 24.4.3 Non-member comparison functions [string.view.comparison]\n \n #include <string_view>\n #include <testsuite_hooks.h>"}, {"sha": "e50b984c408b4e7f5f3c37e2929146a84c4d3571", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/cmp_c++20.cc", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fchar%2Fcmp_c%2B%2B20.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -0,0 +1,340 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++20 21.4.4 Non-member comparison functions [string.view.comparisons]\n+\n+// operator==\n+/*\n+template<class charT, class traits>\n+  constexpr bool\n+  operator==(basic_string_view<charT, traits> lhs,\n+\t     basic_string_view<charT, traits> rhs) noexcept;\n+\n+template<class charT, class traits>\n+  constexpr bool\n+  operator==(basic_string_view<charT, traits> lhs,\n+\t     type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;\n+*/\n+\n+// operator<=>\n+/*\n+template<class charT, class traits>\n+  constexpr [see below]\n+  operator<=>(basic_string_view<charT, traits> lhs,\n+\t      basic_string_view<charT, traits> rhs) noexcept;\n+\n+template<class charT, class traits>\n+  constexpr [see below]\n+  operator<=>(basic_string_view<charT, traits> lhs,\n+\t      type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;\n+*/\n+\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::string_view \tstr_0(\"costa rica\");\n+  std::string_view \tstr_1(\"costa marbella\");\n+  std::string_view \tstr_2(\"cost\");\n+  std::string_view\tstr_3(\"costa ricans\");\n+  std::string_view        str_4;\n+\n+  str_4 = str_0;\n+  //comparisons between string objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string object and string literal\n+  VERIFY( !(str_0 == \"costa marbella\") );\n+  VERIFY( !(str_0 == \"cost\") );\n+  VERIFY( !(str_0 == \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" == str_0) );\n+  VERIFY( !(\"cost\" == str_0) );\n+  VERIFY( !(\"costa ricans\" == str_0) );\n+  VERIFY( \"costa rica\" == str_0 );\n+  VERIFY( str_0 == \"costa rica\" );\n+\n+  VERIFY( str_0 != \"costa marbella\" );\n+  VERIFY( str_0 != \"cost\" );\n+  VERIFY( str_0 != \"costa ricans\" );\n+  VERIFY( \"costa marbella\" != str_0 );\n+  VERIFY( \"cost\" != str_0 );\n+  VERIFY( \"costa ricans\" != str_0 );\n+  VERIFY( !(\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != \"costa rica\") );\n+\n+  VERIFY( str_0 > \"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > \"cost\" );\n+  VERIFY( !(str_0 > \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" > str_0) );\n+  VERIFY( \"costa ricans\" > str_0 );\n+  VERIFY( !(\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > \"costa rica\") );\n+\n+  VERIFY( !(str_0 < \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < \"cost\") );\n+  VERIFY( str_0 < \"costa ricans\" );\n+  VERIFY( \"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( \"cost\" < str_0 );\n+  VERIFY( !(\"costa ricans\" < str_0) );\n+  VERIFY( !(\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < \"costa rica\") );\n+\n+  VERIFY( str_0 >= \"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= \"cost\" );\n+  VERIFY( !(str_0 >= \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" >= str_0) );\n+  VERIFY( \"costa ricans\" >= str_0 );\n+  VERIFY( \"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= \"costa rica\" );\n+\n+  VERIFY( !(str_0 <= \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= \"cost\") );\n+  VERIFY( str_0 <= \"costa ricans\" );\n+  VERIFY( \"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( \"cost\" <= str_0 );\n+  VERIFY( !(\"costa ricans\" <= str_0) );\n+  VERIFY( \"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= \"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> \"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> \"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> \"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> \"costa rica\") );\n+  VERIFY( std::is_lt(\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(\"costa rica\" <=> str_0) );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  std::string_view \tstr_0(\"costa rica\");\n+  std::string_view \tstr_1(\"costa marbella\");\n+  std::string_view \tstr_2(\"cost\");\n+  std::string_view\tstr_3(\"costa ricans\");\n+  std::string_view        str_4;\n+\n+#undef VERIFY\n+#define VERIFY(x) if (!(x)) return false\n+\n+  str_4 = str_0;\n+  //comparisons between string objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string object and string literal\n+  VERIFY( !(str_0 == \"costa marbella\") );\n+  VERIFY( !(str_0 == \"cost\") );\n+  VERIFY( !(str_0 == \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" == str_0) );\n+  VERIFY( !(\"cost\" == str_0) );\n+  VERIFY( !(\"costa ricans\" == str_0) );\n+  VERIFY( \"costa rica\" == str_0 );\n+  VERIFY( str_0 == \"costa rica\" );\n+\n+  VERIFY( str_0 != \"costa marbella\" );\n+  VERIFY( str_0 != \"cost\" );\n+  VERIFY( str_0 != \"costa ricans\" );\n+  VERIFY( \"costa marbella\" != str_0 );\n+  VERIFY( \"cost\" != str_0 );\n+  VERIFY( \"costa ricans\" != str_0 );\n+  VERIFY( !(\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != \"costa rica\") );\n+\n+  VERIFY( str_0 > \"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > \"cost\" );\n+  VERIFY( !(str_0 > \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" > str_0) );\n+  VERIFY( \"costa ricans\" > str_0 );\n+  VERIFY( !(\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > \"costa rica\") );\n+\n+  VERIFY( !(str_0 < \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < \"cost\") );\n+  VERIFY( str_0 < \"costa ricans\" );\n+  VERIFY( \"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( \"cost\" < str_0 );\n+  VERIFY( !(\"costa ricans\" < str_0) );\n+  VERIFY( !(\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < \"costa rica\") );\n+\n+  VERIFY( str_0 >= \"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= \"cost\" );\n+  VERIFY( !(str_0 >= \"costa ricans\") );\n+  VERIFY( !(\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(\"cost\" >= str_0) );\n+  VERIFY( \"costa ricans\" >= str_0 );\n+  VERIFY( \"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= \"costa rica\" );\n+\n+  VERIFY( !(str_0 <= \"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= \"cost\") );\n+  VERIFY( str_0 <= \"costa ricans\" );\n+  VERIFY( \"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( \"cost\" <= str_0 );\n+  VERIFY( !(\"costa ricans\" <= str_0) );\n+  VERIFY( \"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= \"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> \"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> \"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> \"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> \"costa rica\") );\n+  VERIFY( std::is_lt(\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(\"costa rica\" <=> str_0) );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert( test02() );\n+}"}, {"sha": "c6d5de3dce02a8ec08be56ae5bc20dc772de28cd", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operators/wchar_t/2.cc", "status": "modified", "additions": 2, "deletions": 91, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2F2.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -1,4 +1,5 @@\n // { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n \n // Copyright (C) 2013-2020 Free Software Foundation, Inc.\n //\n@@ -17,97 +18,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// basic_string_view non-member functions\n-\n-// operator==\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator==(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-*/\n-\n-// operator!=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator!=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-*/\n-\n-// operator<\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator< (const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator>\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator> (const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator<=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator<=(const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-*/\n-\n-// operator>=\n-/*\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                const basic_string_view<charT,traits,Allocator>& rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const basic_string_view<charT,traits,Allocator>& lhs,\n-                  const charT* rhs);\n-\n-template<class charT, class traits, class Allocator>\n-  bool operator>=(const charT* lhs,\n-                  const basic_string_view<charT,traits,Allocator>& rhs);\n-*/\n+// C++17 24.4.3 Non-member comparison functions [string.view.comparison]\n \n #include <string_view>\n #include <testsuite_hooks.h>"}, {"sha": "bb8e3496ba24b4699c4629ec37df309f3c614f24", "filename": "libstdc++-v3/testsuite/21_strings/basic_string_view/operators/wchar_t/cmp_c++20.cc", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string_view%2Foperators%2Fwchar_t%2Fcmp_c%2B%2B20.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -0,0 +1,340 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++20 21.4.4 Non-member comparison functions [string.view.comparisons]\n+\n+// operator==\n+/*\n+template<class charT, class traits>\n+  constexpr bool\n+  operator==(basic_string_view<charT, traits> lhs,\n+\t     basic_string_view<charT, traits> rhs) noexcept;\n+\n+template<class charT, class traits>\n+  constexpr bool\n+  operator==(basic_string_view<charT, traits> lhs,\n+\t     type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;\n+*/\n+\n+// operator<=>\n+/*\n+template<class charT, class traits>\n+  constexpr [see below]\n+  operator<=>(basic_string_view<charT, traits> lhs,\n+\t      basic_string_view<charT, traits> rhs) noexcept;\n+\n+template<class charT, class traits>\n+  constexpr [see below]\n+  operator<=>(basic_string_view<charT, traits> lhs,\n+\t      type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;\n+*/\n+\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::wstring_view \tstr_0(L\"costa rica\");\n+  std::wstring_view \tstr_1(L\"costa marbella\");\n+  std::wstring_view \tstr_2(L\"cost\");\n+  std::wstring_view\tstr_3(L\"costa ricans\");\n+  std::wstring_view  str_4;\n+\n+  str_4 = str_0;\n+  //comparisons between string_view objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string_view object and string_view literal\n+  VERIFY( !(str_0 == L\"costa marbella\") );\n+  VERIFY( !(str_0 == L\"cost\") );\n+  VERIFY( !(str_0 == L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" == str_0) );\n+  VERIFY( !(L\"cost\" == str_0) );\n+  VERIFY( !(L\"costa ricans\" == str_0) );\n+  VERIFY( L\"costa rica\" == str_0 );\n+  VERIFY( str_0 == L\"costa rica\" );\n+\n+  VERIFY( str_0 != L\"costa marbella\" );\n+  VERIFY( str_0 != L\"cost\" );\n+  VERIFY( str_0 != L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" != str_0 );\n+  VERIFY( L\"cost\" != str_0 );\n+  VERIFY( L\"costa ricans\" != str_0 );\n+  VERIFY( !(L\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != L\"costa rica\") );\n+\n+  VERIFY( str_0 > L\"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > L\"cost\" );\n+  VERIFY( !(str_0 > L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" > str_0) );\n+  VERIFY( L\"costa ricans\" > str_0 );\n+  VERIFY( !(L\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > L\"costa rica\") );\n+\n+  VERIFY( !(str_0 < L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < L\"cost\") );\n+  VERIFY( str_0 < L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" < str_0 );\n+  VERIFY( !(L\"costa ricans\" < str_0) );\n+  VERIFY( !(L\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < L\"costa rica\") );\n+\n+  VERIFY( str_0 >= L\"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= L\"cost\" );\n+  VERIFY( !(str_0 >= L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" >= str_0) );\n+  VERIFY( L\"costa ricans\" >= str_0 );\n+  VERIFY( L\"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= L\"costa rica\" );\n+\n+  VERIFY( !(str_0 <= L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= L\"cost\") );\n+  VERIFY( str_0 <= L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" <= str_0 );\n+  VERIFY( !(L\"costa ricans\" <= str_0) );\n+  VERIFY( L\"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= L\"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> L\"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> L\"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> L\"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> L\"costa rica\") );\n+  VERIFY( std::is_lt(L\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(L\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(L\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(L\"costa rica\" <=> str_0) );\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  std::wstring_view \tstr_0(L\"costa rica\");\n+  std::wstring_view \tstr_1(L\"costa marbella\");\n+  std::wstring_view \tstr_2(L\"cost\");\n+  std::wstring_view\tstr_3(L\"costa ricans\");\n+  std::wstring_view  str_4;\n+\n+#undef VERIFY\n+#define VERIFY(x) if (!(x)) return false\n+\n+  str_4 = str_0;\n+  //comparisons between string_view objects\n+  VERIFY( !(str_0 == str_1) );\n+  VERIFY( !(str_0 == str_2) );\n+  VERIFY( !(str_0 == str_3) );\n+  VERIFY( !(str_1 == str_0) );\n+  VERIFY( !(str_2 == str_0) );\n+  VERIFY( !(str_3 == str_0) );\n+  VERIFY( str_4 == str_0 );\n+  VERIFY( str_0 == str_4 );\n+\n+  VERIFY( str_0 != str_1 );\n+  VERIFY( str_0 != str_2 );\n+  VERIFY( str_0 != str_3 );\n+  VERIFY( str_1 != str_0 );\n+  VERIFY( str_2 != str_0 );\n+  VERIFY( str_3 != str_0 );\n+  VERIFY( !(str_0 != str_4) );\n+  VERIFY( !(str_4 != str_0) );\n+\n+  VERIFY( str_0 > str_1 ); //true cuz r>m\n+  VERIFY( str_0 > str_2 );\n+  VERIFY( !(str_0 > str_3) );\n+  VERIFY( !(str_1 > str_0) ); //false cuz m<r\n+  VERIFY( !(str_2 > str_0) );\n+  VERIFY( str_3 > str_0 );\n+  VERIFY( !(str_0 > str_4) );\n+  VERIFY( !(str_4 > str_0) );\n+\n+  VERIFY( !(str_0 < str_1) ); //false cuz r>m\n+  VERIFY( !(str_0 < str_2) );\n+  VERIFY( str_0 < str_3 );\n+  VERIFY( str_1 < str_0 ); //true cuz m<r\n+  VERIFY( str_2 < str_0 );\n+  VERIFY( !(str_3 < str_0) );\n+  VERIFY( !(str_0 < str_4) );\n+  VERIFY( !(str_4 < str_0) );\n+\n+  VERIFY( str_0 >= str_1 ); //true cuz r>m\n+  VERIFY( str_0 >= str_2 );\n+  VERIFY( !(str_0 >= str_3) );\n+  VERIFY( !(str_1 >= str_0) );//false cuz m<r\n+  VERIFY( !(str_2 >= str_0) );\n+  VERIFY( str_3 >= str_0 );\n+  VERIFY( str_0 >= str_4 );\n+  VERIFY( str_4 >= str_0 );\n+\n+  VERIFY( !(str_0 <= str_1) );//false cuz r>m\n+  VERIFY( !(str_0 <= str_2) );\n+  VERIFY( str_0 <= str_3 );\n+  VERIFY( str_1 <= str_0 );//true cuz m<r\n+  VERIFY( str_2 <= str_0 );\n+  VERIFY( !(str_3 <= str_0) );\n+  VERIFY( str_0 <= str_4 );\n+  VERIFY( str_4 <= str_0 );\n+\n+  VERIFY( std::is_gt(str_0 <=> str_1) );\n+  VERIFY( std::is_gt(str_0 <=> str_2) );\n+  VERIFY( std::is_lt(str_0 <=> str_3) );\n+  VERIFY( std::is_eq(str_0 <=> str_4) );\n+  VERIFY( std::is_lt(str_1 <=> str_0) );\n+  VERIFY( std::is_lt(str_2 <=> str_0) );\n+  VERIFY( std::is_gt(str_3 <=> str_0) );\n+  VERIFY( std::is_eq(str_4 <=> str_0) );\n+\n+  //comparisons between string_view object and string_view literal\n+  VERIFY( !(str_0 == L\"costa marbella\") );\n+  VERIFY( !(str_0 == L\"cost\") );\n+  VERIFY( !(str_0 == L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" == str_0) );\n+  VERIFY( !(L\"cost\" == str_0) );\n+  VERIFY( !(L\"costa ricans\" == str_0) );\n+  VERIFY( L\"costa rica\" == str_0 );\n+  VERIFY( str_0 == L\"costa rica\" );\n+\n+  VERIFY( str_0 != L\"costa marbella\" );\n+  VERIFY( str_0 != L\"cost\" );\n+  VERIFY( str_0 != L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" != str_0 );\n+  VERIFY( L\"cost\" != str_0 );\n+  VERIFY( L\"costa ricans\" != str_0 );\n+  VERIFY( !(L\"costa rica\" != str_0) );\n+  VERIFY( !(str_0 != L\"costa rica\") );\n+\n+  VERIFY( str_0 > L\"costa marbella\" ); //true cuz r>m\n+  VERIFY( str_0 > L\"cost\" );\n+  VERIFY( !(str_0 > L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" > str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" > str_0) );\n+  VERIFY( L\"costa ricans\" > str_0 );\n+  VERIFY( !(L\"costa rica\" > str_0) );\n+  VERIFY( !(str_0 > L\"costa rica\") );\n+\n+  VERIFY( !(str_0 < L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 < L\"cost\") );\n+  VERIFY( str_0 < L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" < str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" < str_0 );\n+  VERIFY( !(L\"costa ricans\" < str_0) );\n+  VERIFY( !(L\"costa rica\" < str_0) );\n+  VERIFY( !(str_0 < L\"costa rica\") );\n+\n+  VERIFY( str_0 >= L\"costa marbella\" );//true cuz r>m\n+  VERIFY( str_0 >= L\"cost\" );\n+  VERIFY( !(str_0 >= L\"costa ricans\") );\n+  VERIFY( !(L\"costa marbella\" >= str_0) );//false cuz m<r\n+  VERIFY( !(L\"cost\" >= str_0) );\n+  VERIFY( L\"costa ricans\" >= str_0 );\n+  VERIFY( L\"costa rica\" >= str_0 );\n+  VERIFY( str_0 >= L\"costa rica\" );\n+\n+  VERIFY( !(str_0 <= L\"costa marbella\") );//false cuz r>m\n+  VERIFY( !(str_0 <= L\"cost\") );\n+  VERIFY( str_0 <= L\"costa ricans\" );\n+  VERIFY( L\"costa marbella\" <= str_0 );//true cuz m<r\n+  VERIFY( L\"cost\" <= str_0 );\n+  VERIFY( !(L\"costa ricans\" <= str_0) );\n+  VERIFY( L\"costa rica\" <= str_0 );\n+  VERIFY( str_0 <= L\"costa rica\" );\n+\n+  VERIFY( std::is_gt(str_0 <=> L\"costa marbella\") );\n+  VERIFY( std::is_gt(str_0 <=> L\"cost\") );\n+  VERIFY( std::is_lt(str_0 <=> L\"costa ricans\") );\n+  VERIFY( std::is_eq(str_0 <=> L\"costa rica\") );\n+  VERIFY( std::is_lt(L\"costa marbella\" <=> str_0) );\n+  VERIFY( std::is_lt(L\"cost\" <=> str_0) );\n+  VERIFY( std::is_gt(L\"costa ricans\" <=> str_0) );\n+  VERIFY( std::is_eq(L\"costa rica\" <=> str_0) );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  static_assert( test02() );\n+}"}, {"sha": "d632d002f20607e349ebaf093a675c335d4fbe4f", "filename": "libstdc++-v3/testsuite/28_regex/sub_match/compare_c++20.cc", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fsub_match%2Fcompare_c%2B%2B20.cc?ref=875d6cb3b4919b58ae5e6313db715bc4dd3ddd6c", "patch": "@@ -0,0 +1,335 @@\n+// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+template<typename C> struct traits : std::char_traits<C> { };\n+\n+void\n+test01()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  const std::ssub_match sm, sm2;\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 0 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 0 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 0 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == -1 );\n+  VERIFY( sm.compare(s1.c_str()) == -1 );\n+\n+\n+  VERIFY( sm == sm2 );\n+  VERIFY( !(sm != sm2) );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( !(sm > sm2) );\n+  VERIFY( sm <= sm2 );\n+  VERIFY( sm >= sm2 );\n+  VERIFY( std::is_eq(sm <=> sm2) );\n+\n+  VERIFY( sm == s0 );\n+  VERIFY( !(sm != s0) );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( !(sm > s0) );\n+  VERIFY( sm <= s0 );\n+  VERIFY( sm >= s0 );\n+  VERIFY( std::is_eq(sm <=> s0) );\n+\n+  VERIFY( s0 == sm );\n+  VERIFY( !(s0 != sm) );\n+  VERIFY( !(s0 < sm) );\n+  VERIFY( !(s0 > sm) );\n+  VERIFY( s0 <= sm );\n+  VERIFY( s0 >= sm );\n+  VERIFY( std::is_eq(s0 <=> sm) );\n+\n+  VERIFY( sm == s0.c_str() );\n+  VERIFY( !(sm != s0.c_str()) );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( !(sm > s0.c_str()) );\n+  VERIFY( sm <= s0.c_str() );\n+  VERIFY( sm >= s0.c_str() );\n+  VERIFY( std::is_eq(sm <=> s0.c_str()) );\n+\n+  VERIFY( s0.c_str() == sm );\n+  VERIFY( !(s0.c_str() != sm) );\n+  VERIFY( !(s0.c_str() < sm) );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( s0.c_str() >= sm );\n+  VERIFY( std::is_eq(s0.c_str() <=> sm) );\n+\n+  VERIFY( !(sm == s1) );\n+  VERIFY( sm != s1 );\n+  VERIFY( sm < s1 );\n+  VERIFY( !(sm > s1) );\n+  VERIFY( sm <= s1 );\n+  VERIFY( !(sm >= s1) );\n+  VERIFY( std::is_lt(sm <=> s1) );\n+\n+  VERIFY( !(sm == s1.c_str()) );\n+  VERIFY( sm != s1.c_str() );\n+  VERIFY( sm < s1.c_str() );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( !(sm >= s1.c_str()) );\n+  VERIFY( std::is_lt(sm <=> s1.c_str()) );\n+\n+  VERIFY( !(s1.c_str() == sm) );\n+  VERIFY( s1.c_str() != sm );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( s1.c_str() > sm );\n+  VERIFY( !(s1.c_str() <= sm) );\n+  VERIFY( s1.c_str() >= sm );\n+  VERIFY( std::is_gt(s1.c_str() <=> sm) );\n+\n+  VERIFY( !(sm == s1[0]) );\n+  VERIFY( sm != s1[0] );\n+  VERIFY( sm < s1[0] );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( !(sm >= s1[0]) );\n+  VERIFY( std::is_lt(sm <=> s1[0]) );\n+\n+  VERIFY( !(s1[0] == sm) );\n+  VERIFY( s1[0] != sm );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( s1[0] > sm );\n+  VERIFY( !(s1[0] <= sm) );\n+  VERIFY( s1[0] >= sm );\n+  VERIFY( std::is_gt(s1[0] <=> sm) );\n+}\n+\n+void\n+test02()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  std::csub_match sm;\n+  const std::csub_match sm2;\n+  const char c[] = \"1\";\n+  sm.matched = true;\n+  sm.first = c;\n+  sm.second = c+1;\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 1 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 1 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 1 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == 0 );\n+  VERIFY( sm.compare(s1.c_str()) == 0 );\n+\n+  VERIFY( !(sm == sm2) );\n+  VERIFY( sm != sm2 );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( sm > sm2 );\n+  VERIFY( !(sm <= sm2) );\n+  VERIFY( sm >= sm2 );\n+  VERIFY( std::is_gt(sm <=> sm2) );\n+\n+  VERIFY( !(sm2 == sm) );\n+  VERIFY( sm2 != sm );\n+  VERIFY( sm2 < sm );\n+  VERIFY( !(sm2 > sm) );\n+  VERIFY( sm2 <= sm );\n+  VERIFY( !(sm2 >= sm) );\n+  VERIFY( std::is_lt(sm2 <=> sm) );\n+\n+  VERIFY( !(sm == s0) );\n+  VERIFY( sm != s0 );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( sm > s0 );\n+  VERIFY( !(sm <= s0) );\n+  VERIFY( sm >= s0 );\n+  VERIFY( std::is_gt(sm <=> s0) );\n+\n+  VERIFY( !(sm == s0.c_str()) );\n+  VERIFY( sm != s0.c_str() );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( sm > s0.c_str() );\n+  VERIFY( !(sm <= s0.c_str()) );\n+  VERIFY( sm >= s0.c_str() );\n+  VERIFY( std::is_gt(sm <=> s0.c_str()) );\n+\n+  VERIFY( !(s0.c_str() == sm) );\n+  VERIFY( s0.c_str() != sm );\n+  VERIFY( s0.c_str() < sm );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( !(s0.c_str() >= sm) );\n+  VERIFY( std::is_lt(s0.c_str() <=> sm) );\n+\n+  VERIFY( s1 == sm );\n+  VERIFY( !(s1 != sm) );\n+  VERIFY( !(s1 < sm) );\n+  VERIFY( !(s1 > sm) );\n+  VERIFY( s1 <= sm );\n+  VERIFY( s1 >= sm );\n+  VERIFY( std::is_eq(s1 <=> sm) );\n+\n+  VERIFY( sm == s1.c_str() );\n+  VERIFY( !(sm != s1.c_str()) );\n+  VERIFY( !(sm < s1.c_str()) );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( sm >= s1.c_str() );\n+  VERIFY( std::is_eq(sm <=> s1.c_str()) );\n+\n+  VERIFY( s1.c_str() == sm );\n+  VERIFY( !(s1.c_str() != sm) );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( !(s1.c_str() > sm) );\n+  VERIFY( s1.c_str() <= sm );\n+  VERIFY( s1.c_str() >= sm );\n+  VERIFY( std::is_eq(s1.c_str() <=> sm) );\n+\n+  VERIFY( sm == s1[0] );\n+  VERIFY( !(sm != s1[0]) );\n+  VERIFY( !(sm < s1[0]) );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( sm >= s1[0] );\n+  VERIFY( std::is_eq(sm <=> s1[0]) );\n+\n+  VERIFY( s1[0] == sm );\n+  VERIFY( !(s1[0] != sm) );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( !(s1[0] > sm) );\n+  VERIFY( s1[0] <= sm );\n+  VERIFY( s1[0] >= sm );\n+  VERIFY( std::is_eq(s1[0] <=> sm) );\n+}\n+\n+void\n+test03()\n+{\n+  const std::basic_string<char, traits<char>> s0, s1 = \"1\";\n+  const char c[] = \"1\";\n+  test_container<const char, bidirectional_iterator_wrapper> tc(c, c+1);\n+  std::sub_match<bidirectional_iterator_wrapper<const char>> sm;\n+  const std::sub_match<bidirectional_iterator_wrapper<const char>> sm2;\n+  sm.matched = true;\n+  sm.first = tc.begin();\n+  sm.second = tc.end();\n+\n+  VERIFY( sm.compare(sm) == 0 );\n+  VERIFY( sm.compare(sm2) == 1 );\n+  VERIFY( sm.compare(sm.str()) == 0 );\n+  VERIFY( sm.compare(sm.str().c_str()) == 0 );\n+  VERIFY( sm.compare(sm2.str()) == 1 );\n+  VERIFY( sm.compare(sm2.str().c_str()) == 1 );\n+  VERIFY( sm.compare(std::string(s1.c_str())) == 0 );\n+  VERIFY( sm.compare(s1.c_str()) == 0 );\n+\n+  VERIFY( !(sm == sm2) );\n+  VERIFY( sm != sm2 );\n+  VERIFY( !(sm < sm2) );\n+  VERIFY( sm > sm2 );\n+  VERIFY( !(sm <= sm2) );\n+  VERIFY( sm >= sm2 );\n+  VERIFY( std::is_gt(sm <=> sm2) );\n+\n+  VERIFY( !(sm2 == sm) );\n+  VERIFY( sm2 != sm );\n+  VERIFY( sm2 < sm );\n+  VERIFY( !(sm2 > sm) );\n+  VERIFY( sm2 <= sm );\n+  VERIFY( !(sm2 >= sm) );\n+  VERIFY( std::is_lt(sm2 <=> sm) );\n+\n+  VERIFY( !(sm == s0) );\n+  VERIFY( sm != s0 );\n+  VERIFY( !(sm < s0) );\n+  VERIFY( sm > s0 );\n+  VERIFY( !(sm <= s0) );\n+  VERIFY( sm >= s0 );\n+  VERIFY( std::is_gt(sm <=> s0) );\n+\n+  VERIFY( !(sm == s0.c_str()) );\n+  VERIFY( sm != s0.c_str() );\n+  VERIFY( !(sm < s0.c_str()) );\n+  VERIFY( sm > s0.c_str() );\n+  VERIFY( !(sm <= s0.c_str()) );\n+  VERIFY( sm >= s0.c_str() );\n+  VERIFY( std::is_gt(sm <=> s0.c_str()) );\n+\n+  VERIFY( !(s0.c_str() == sm) );\n+  VERIFY( s0.c_str() != sm );\n+  VERIFY( s0.c_str() < sm );\n+  VERIFY( !(s0.c_str() > sm) );\n+  VERIFY( s0.c_str() <= sm );\n+  VERIFY( !(s0.c_str() >= sm) );\n+  VERIFY( std::is_lt(s0.c_str() <=> sm) );\n+\n+  VERIFY( s1 == sm );\n+  VERIFY( !(s1 != sm) );\n+  VERIFY( !(s1 < sm) );\n+  VERIFY( !(s1 > sm) );\n+  VERIFY( s1 <= sm );\n+  VERIFY( s1 >= sm );\n+  VERIFY( std::is_eq(s1 <=> sm) );\n+\n+  VERIFY( sm == s1.c_str() );\n+  VERIFY( !(sm != s1.c_str()) );\n+  VERIFY( !(sm < s1.c_str()) );\n+  VERIFY( !(sm > s1.c_str()) );\n+  VERIFY( sm <= s1.c_str() );\n+  VERIFY( sm >= s1.c_str() );\n+  VERIFY( std::is_eq(sm <=> s1.c_str()) );\n+\n+  VERIFY( s1.c_str() == sm );\n+  VERIFY( !(s1.c_str() != sm) );\n+  VERIFY( !(s1.c_str() < sm) );\n+  VERIFY( !(s1.c_str() > sm) );\n+  VERIFY( s1.c_str() <= sm );\n+  VERIFY( s1.c_str() >= sm );\n+  VERIFY( std::is_eq(s1.c_str() <=> sm) );\n+\n+  VERIFY( sm == s1[0] );\n+  VERIFY( !(sm != s1[0]) );\n+  VERIFY( !(sm < s1[0]) );\n+  VERIFY( !(sm > s1[0]) );\n+  VERIFY( sm <= s1[0] );\n+  VERIFY( sm >= s1[0] );\n+  VERIFY( std::is_eq(sm <=> s1[0]) );\n+\n+  VERIFY( s1[0] == sm );\n+  VERIFY( !(s1[0] != sm) );\n+  VERIFY( !(s1[0] < sm) );\n+  VERIFY( !(s1[0] > sm) );\n+  VERIFY( s1[0] <= sm );\n+  VERIFY( s1[0] >= sm );\n+  VERIFY( std::is_eq(s1[0] <=> sm) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}