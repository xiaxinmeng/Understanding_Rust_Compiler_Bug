{"sha": "b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmNzNkZWI2YzRkNjVhODhlOWM2NzhhYWM5ZGUyYWMwMDZkNzdjYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-06-17T10:48:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-06-17T10:48:22Z"}, "message": "trans.c (push_stack, pop_stack): Delete.\n\n\t* gcc-interface/trans.c (push_stack, pop_stack): Delete.\n\t(Case_Statement_to_gnu): Adjust.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n\t(Compilation_Unit_to_gnu): Likewise.\n\nFrom-SVN: r160898", "tree": {"sha": "5ba656355e200ce41124153645a15bad9068260c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba656355e200ce41124153645a15bad9068260c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca/comments", "author": null, "committer": null, "parents": [{"sha": "092ef350718e36fdb53cdeb2665efcb30486f8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092ef350718e36fdb53cdeb2665efcb30486f8cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/092ef350718e36fdb53cdeb2665efcb30486f8cf"}], "stats": {"total": 65, "additions": 30, "deletions": 35}, "files": [{"sha": "edf856f7c7f08d3db720deb843bfef5988757ec5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "patch": "@@ -1,3 +1,12 @@\n+2010-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (push_stack, pop_stack): Delete.\n+\t(Case_Statement_to_gnu): Adjust.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n+\t(Compilation_Unit_to_gnu): Likewise.\n+\n 2010-06-17  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_fixd.adb, exp_imgv.adb, exp_intr.adb, exp_pakd.adb, exp_prag.adb,"}, {"sha": "e163d92309186011268bcc49632b0121047350e8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f73deb6c4d65a88e9c678aac9de2ac006d77ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b4f73deb6c4d65a88e9c678aac9de2ac006d77ca", "patch": "@@ -187,8 +187,6 @@ static void add_cleanup (tree, Node_Id);\n static void add_stmt_list (List_Id);\n static void push_exception_label_stack (VEC(tree,gc) **, Entity_Id);\n static tree build_stmt_group (List_Id, bool);\n-static void push_stack (VEC(tree,gc) **, tree);\n-static void pop_stack (VEC(tree,gc) *);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n@@ -1934,10 +1932,10 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \n   /* We build a SWITCH_EXPR that contains the code with interspersed\n      CASE_LABEL_EXPRs for each label.  */\n-\n-  push_stack (&gnu_switch_label_stack,\n-\t      create_artificial_label (input_location));\n+  VEC_safe_push (tree, gc, gnu_switch_label_stack,\n+\t\t create_artificial_label (input_location));\n   start_stmt_group ();\n+\n   for (gnat_when = First_Non_Pragma (Alternatives (gnat_node));\n        Present (gnat_when);\n        gnat_when = Next_Non_Pragma (gnat_when))\n@@ -2026,7 +2024,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t\t    VEC_last (tree, gnu_switch_label_stack)));\n   gnu_result = build3 (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n \t\t       end_stmt_group (), NULL_TREE);\n-  pop_stack (gnu_switch_label_stack);\n+  VEC_pop (tree, gnu_switch_label_stack);\n \n   return gnu_result;\n }\n@@ -2092,7 +2090,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n   /* Save the end label of this LOOP_STMT in a stack so that a corresponding\n      N_Exit_Statement can find it.  */\n-  push_stack (&gnu_loop_label_stack, gnu_loop_label);\n+  VEC_safe_push (tree, gc, gnu_loop_label_stack, gnu_loop_label);\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2309,7 +2307,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   else\n     gnu_result = gnu_loop_stmt;\n \n-  pop_stack (gnu_loop_label_stack);\n+  VEC_pop (tree, gnu_loop_label_stack);\n \n   return gnu_result;\n }\n@@ -2442,9 +2440,10 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      properly copies them out.  We do this by making a new block and converting\n      any inner return into a goto to a label at the end of the block.  */\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n-  push_stack (&gnu_return_label_stack,\n-\t      gnu_cico_list ? create_artificial_label (input_location)\n-\t      : NULL_TREE);\n+  VEC_safe_push (tree, gc, gnu_return_label_stack,\n+\t\t gnu_cico_list\n+\t\t ? create_artificial_label (input_location)\n+\t\t : NULL_TREE);\n \n   /* Get a tree corresponding to the code for the subprogram.  */\n   start_stmt_group ();\n@@ -2555,7 +2554,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n     }\n \n-  pop_stack (gnu_return_label_stack);\n+  VEC_pop (tree, gnu_return_label_stack);\n \n   /* Set the end location.  */\n   Sloc_to_locus\n@@ -3252,12 +3251,13 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       start_stmt_group ();\n       gnat_pushlevel ();\n \n-      push_stack (&gnu_except_ptr_stack,\n-\t\t  create_var_decl (get_identifier (\"EXCEPT_PTR\"),\n-\t\t\t\t   NULL_TREE,\n-\t\t\t\t   build_pointer_type (except_type_node),\n-\t\t\t\t   build_call_0_expr (get_excptr_decl), false,\n-\t\t\t\t   false, false, false, NULL, gnat_node));\n+      VEC_safe_push (tree, gc, gnu_except_ptr_stack,\n+\t\t     create_var_decl (get_identifier (\"EXCEPT_PTR\"),\n+\t\t\t\t      NULL_TREE,\n+\t\t\t\t      build_pointer_type (except_type_node),\n+\t\t\t\t      build_call_0_expr (get_excptr_decl),\n+\t\t\t\t\t\t\t false,\n+\t\t\t\t      false, false, false, NULL, gnat_node));\n \n       /* Generate code for each handler. The N_Exception_Handler case does the\n \t real work and returns a COND_EXPR for each handler, which we chain\n@@ -3293,7 +3293,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n       /* End the binding level dedicated to the exception handlers and get the\n \t whole statement group.  */\n-      pop_stack (gnu_except_ptr_stack);\n+      VEC_pop (tree, gnu_except_ptr_stack);\n       gnat_poplevel ();\n       gnu_handler = end_stmt_group ();\n \n@@ -3548,7 +3548,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n        NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL, gnat_unit);\n   struct elab_info *info;\n \n-  push_stack (&gnu_elab_proc_stack, gnu_elab_proc_decl);\n+  VEC_safe_push (tree, gc, gnu_elab_proc_stack, gnu_elab_proc_decl);\n   DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n \n   /* Initialize the information structure for the function.  */\n@@ -3635,7 +3635,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \n   /* Generate elaboration code for this unit, if necessary, and say whether\n      we did or not.  */\n-  pop_stack (gnu_elab_proc_stack);\n+  VEC_pop (tree, gnu_elab_proc_stack);\n \n   /* Invalidate the global renaming pointers.  This is necessary because\n      stabilization of the renamed entities may create SAVE_EXPRs which\n@@ -5928,20 +5928,6 @@ build_stmt_group (List_Id gnat_list, bool binding_p)\n   return end_stmt_group ();\n }\n \f\n-/* Push and pop routines for stacks.  */\n-\n-static void\n-push_stack (VEC(tree,gc) **gnu_stack_ptr, tree value)\n-{\n-  VEC_safe_push (tree, gc, *gnu_stack_ptr, value);\n-}\n-\n-static void\n-pop_stack (VEC(tree,gc) *gnu_stack)\n-{\n-  VEC_pop (tree, gnu_stack);\n-}\n-\f\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n \n int"}]}