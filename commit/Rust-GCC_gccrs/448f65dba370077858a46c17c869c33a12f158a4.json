{"sha": "448f65dba370077858a46c17c869c33a12f158a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ4ZjY1ZGJhMzcwMDc3ODU4YTQ2YzE3Yzg2OWMzM2ExMmYxNThhNA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-04-26T18:21:17Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-04-26T18:21:17Z"}, "message": "cfgloop.h (struct loop): Move can_be_parallel field up.\n\n\t* cfgloop.h (struct loop): Move can_be_parallel field up.\n\t* ipa-prop.h (struct ip_node_params): Move bitfields up.\n\t* tree-ssa-loop-ivopts.c (struct version_info): Move inv_id field\n\tdown.\n\t(struct iv_cand): Convert pos field into a bitfield.\n\t* tree-vectorizer.h (struct _loop_vec_info): Move loop_line_number\n\tfield up.\n\t(struct _stmt_vec_info): Shuffle fields for better packing.\n\nFrom-SVN: r158743", "tree": {"sha": "b29bb045ba52e3ce9f6781d3569951a8bdc1e19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b29bb045ba52e3ce9f6781d3569951a8bdc1e19b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/448f65dba370077858a46c17c869c33a12f158a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448f65dba370077858a46c17c869c33a12f158a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448f65dba370077858a46c17c869c33a12f158a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448f65dba370077858a46c17c869c33a12f158a4/comments", "author": null, "committer": null, "parents": [{"sha": "a1cbd45d53cf329cef12c2adccba5001a9d399c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1cbd45d53cf329cef12c2adccba5001a9d399c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1cbd45d53cf329cef12c2adccba5001a9d399c9"}], "stats": {"total": 89, "additions": 50, "deletions": 39}, "files": [{"sha": "2ceefa2ac2e4fab5d261bb3945f9020dde078dd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448f65dba370077858a46c17c869c33a12f158a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448f65dba370077858a46c17c869c33a12f158a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=448f65dba370077858a46c17c869c33a12f158a4", "patch": "@@ -1,3 +1,14 @@\n+2010-04-26  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* cfgloop.h (struct loop): Move can_be_parallel field up.\n+\t* ipa-prop.h (struct ip_node_params): Move bitfields up.\n+\t* tree-ssa-loop-ivopts.c (struct version_info): Move inv_id field\n+\tdown.\n+\t(struct iv_cand): Convert pos field into a bitfield.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Move loop_line_number\n+\tfield up.\n+\t(struct _stmt_vec_info): Shuffle fields for better packing.\n+\n 2010-04-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* varasm.c (IN_NAMED_SECTION): Remove guard."}, {"sha": "4135ed7a250b2516fc5139a517d08f1a53db92fd", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=448f65dba370077858a46c17c869c33a12f158a4", "patch": "@@ -148,6 +148,9 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   bool any_upper_bound;\n   bool any_estimate;\n \n+  /* True if the loop can be parallel.  */\n+  bool can_be_parallel;\n+\n   /* An integer estimation of the number of iterations.  Estimate_state\n      describes what is the state of the estimation.  */\n   enum loop_estimation estimate_state;\n@@ -158,9 +161,6 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   /* Head of the cyclic list of the exits of the loop.  */\n   struct loop_exit *exits;\n \n-  /* True if the loop can be parallel.  */\n-  bool can_be_parallel;\n-\n   /* The single induction variable of the loop when the loop is in\n      normal form.  */\n   tree single_iv;"}, {"sha": "1df3abd5fd456681dc7ca39a8224680aaf8da2c6", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=448f65dba370077858a46c17c869c33a12f158a4", "patch": "@@ -181,6 +181,15 @@ struct ipa_node_params\n      this function's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n   int param_count;\n+  /* Whether this function is called with variable number of actual\n+     arguments.  */\n+  unsigned called_with_var_arguments : 1;\n+  /* Whether the modification analysis has already been performed. */\n+  unsigned modification_analysis_done : 1;\n+  /* Whether the param uses analysis has already been performed.  */\n+  unsigned uses_analysis_done : 1;\n+  /* Whether the function is enqueued in an ipa_func_list.  */\n+  unsigned node_enqueued : 1;\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n   struct ipa_param_descriptor *params;\n@@ -195,16 +204,6 @@ struct ipa_node_params\n      the profiling information of the original function and the versioned\n      one.  */\n   gcov_type count_scale;\n-\n-  /* Whether this function is called with variable number of actual\n-     arguments.  */\n-  unsigned called_with_var_arguments : 1;\n-  /* Whether the modification analysis has already been performed. */\n-  unsigned modification_analysis_done : 1;\n-  /* Whether the param uses analysis has already been performed.  */\n-  unsigned uses_analysis_done : 1;\n-  /* Whether the function is enqueued in an ipa_func_list.  */\n-  unsigned node_enqueued : 1;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that"}, {"sha": "a64950ec85c838da4a794c9db5bfc376f8a4785c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=448f65dba370077858a46c17c869c33a12f158a4", "patch": "@@ -120,8 +120,8 @@ struct version_info\n   struct iv *iv;\t/* Induction variable description.  */\n   bool has_nonlin_use;\t/* For a loop-level invariant, whether it is used in\n \t\t\t   an expression that is not an induction variable.  */\n-  unsigned inv_id;\t/* Id of an invariant.  */\n   bool preserve_biv;\t/* For the original biv, whether to preserve it.  */\n+  unsigned inv_id;\t/* Id of an invariant.  */\n };\n \n /* Types of uses.  */\n@@ -192,7 +192,7 @@ struct iv_cand\n   unsigned id;\t\t/* The number of the candidate.  */\n   bool important;\t/* Whether this is an \"important\" candidate, i.e. such\n \t\t\t   that it should be considered by all uses.  */\n-  enum iv_position pos;\t/* Where it is computed.  */\n+  ENUM_BITFIELD(iv_position) pos : 8;\t/* Where it is computed.  */\n   gimple incremented_at;/* For original biv, the statement where it is\n \t\t\t   incremented.  */\n   tree var_before;\t/* The variable used for it before increment.  */"}, {"sha": "fc9f0e93af0a72f2a9024b0709be36894741bfa8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/448f65dba370077858a46c17c869c33a12f158a4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=448f65dba370077858a46c17c869c33a12f158a4", "patch": "@@ -198,6 +198,9 @@ typedef struct _loop_vec_info {\n   /* Unrolling factor  */\n   int vectorization_factor;\n \n+  /* The loop location in the source.  */\n+  LOC loop_line_number;\n+\n   /* Unknown DRs according to which loop was peeled.  */\n   struct data_reference *unaligned_dr;\n \n@@ -228,9 +231,6 @@ typedef struct _loop_vec_info {\n      runtime (loop versioning) misalignment check.  */\n   VEC(gimple,heap) *may_misalign_stmts;\n \n-  /* The loop location in the source.  */\n-  LOC loop_line_number;\n-\n   /* All interleaving chains of stores in the loop, represented by the first\n      stmt in the chain.  */\n   VEC(gimple, heap) *strided_stores;\n@@ -398,21 +398,23 @@ typedef struct _stmt_vec_info {\n \n   enum stmt_vec_info_type type;\n \n+  /* Indicates whether this stmts is part of a computation whose result is\n+     used outside the loop.  */\n+  bool live;\n+\n+  /* Stmt is part of some pattern (computation idiom)  */\n+  bool in_pattern_p;\n+\n+  /* For loads only, if there is a store with the same location, this field is\n+     TRUE.  */\n+  bool read_write_dep;\n+\n   /* The stmt to which this info struct refers to.  */\n   gimple stmt;\n \n   /* The loop_vec_info with respect to which STMT is vectorized.  */\n   loop_vec_info loop_vinfo;\n \n-  /* Not all stmts in the loop need to be vectorized. e.g, the increment\n-     of the loop induction variable and computation of array indexes. relevant\n-     indicates whether the stmt needs to be vectorized.  */\n-  enum vect_relevant relevant;\n-\n-  /* Indicates whether this stmts is part of a computation whose result is\n-     used outside the loop.  */\n-  bool live;\n-\n   /* The vector type to be used for the LHS of this statement.  */\n   tree vectype;\n \n@@ -436,9 +438,6 @@ typedef struct _stmt_vec_info {\n   tree dr_step;\n   tree dr_aligned_to;\n \n-  /* Stmt is part of some pattern (computation idiom)  */\n-  bool in_pattern_p;\n-\n   /* Used for various bookkeeping purposes, generally holding a pointer to\n      some other stmt S that is in some way \"related\" to this stmt.\n      Current use of this field is:\n@@ -457,11 +456,17 @@ typedef struct _stmt_vec_info {\n   /* Classify the def of this stmt.  */\n   enum vect_def_type def_type;\n \n+  /*  Whether the stmt is SLPed, loop-based vectorized, or both.  */\n+  enum slp_vect_type slp_type;\n+\n   /* Interleaving info.  */\n   /* First data-ref in the interleaving group.  */\n   gimple first_dr;\n   /* Pointer to the next data-ref in the group.  */\n   gimple next_dr;\n+  /* In case that two or more stmts share data-ref, this is the pointer to the\n+     previously detected stmt with the same dr.  */\n+  gimple same_dr_stmt;\n   /* The size of the interleaving group.  */\n   unsigned int size;\n   /* For stores, number of stores from this group seen. We vectorize the last\n@@ -470,12 +475,11 @@ typedef struct _stmt_vec_info {\n   /* For loads only, the gap from the previous load. For consecutive loads, GAP\n      is 1.  */\n   unsigned int gap;\n-  /* In case that two or more stmts share data-ref, this is the pointer to the\n-     previously detected stmt with the same dr.  */\n-  gimple same_dr_stmt;\n-  /* For loads only, if there is a store with the same location, this field is\n-     TRUE.  */\n-  bool read_write_dep;\n+\n+  /* Not all stmts in the loop need to be vectorized. e.g, the increment\n+     of the loop induction variable and computation of array indexes. relevant\n+     indicates whether the stmt needs to be vectorized.  */\n+  enum vect_relevant relevant;\n \n   /* Vectorization costs associated with statement.  */\n   struct\n@@ -484,9 +488,6 @@ typedef struct _stmt_vec_info {\n     int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n \n-  /*  Whether the stmt is SLPed, loop-based vectorized, or both.  */\n-  enum slp_vect_type slp_type;\n-\n   /* The bb_vec_info with respect to which STMT is vectorized.  */\n   bb_vec_info bb_vinfo;\n "}]}