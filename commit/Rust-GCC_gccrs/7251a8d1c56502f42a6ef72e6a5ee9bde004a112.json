{"sha": "7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI1MWE4ZDFjNTY1MDJmNDJhNmVmNzJlNmE1ZWU5YmRlMDA0YTExMg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2006-10-05T08:47:11Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2006-10-05T08:47:11Z"}, "message": "loop.texi: Add data references analysis description.\n\n        * doc/loop.texi: Add data references analysis description.\n\nFrom-SVN: r117453", "tree": {"sha": "03034fce2ac4d12509ad977ea1a2c77868fb1dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03034fce2ac4d12509ad977ea1a2c77868fb1dd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7251a8d1c56502f42a6ef72e6a5ee9bde004a112/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf822c0484ada5e9d939eec9c490303b35a5734a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf822c0484ada5e9d939eec9c490303b35a5734a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf822c0484ada5e9d939eec9c490303b35a5734a"}], "stats": {"total": 61, "additions": 61, "deletions": 0}, "files": [{"sha": "513e7c76be831ef75db1bcf1186736eda4a93359", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7251a8d1c56502f42a6ef72e6a5ee9bde004a112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7251a8d1c56502f42a6ef72e6a5ee9bde004a112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "patch": "@@ -1,3 +1,7 @@\n+2006-10-05  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* doc/loop.texi: Add data references analysis description.\n+\n 2006-10-04  Brooks Moses  <bmoses@stanford.edu>\n \n \t* doc/gcov.texi: Add formatting to \"Invoking gcov\" section head."}, {"sha": "b207b38cee846761136a735a03c2abb9eb867ef6", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7251a8d1c56502f42a6ef72e6a5ee9bde004a112/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7251a8d1c56502f42a6ef72e6a5ee9bde004a112/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=7251a8d1c56502f42a6ef72e6a5ee9bde004a112", "patch": "@@ -476,6 +476,63 @@ syntactic order is important in some classical data dependence tests,\n and mapping this order to the elements of this array avoids costly\n queries to the loop body representation.\n \n+Three types of data references are currently handled: ARRAY_REF, \n+INDIRECT_REF and COMPONENT_REF. The data structure for the data reference \n+is @code{data_reference}, where @code{data_reference_p} is a name of a \n+pointer to the data reference structure. The structure contains the \n+following elements:\n+\n+@itemize\n+@item @code{base_object_info}: Provides information about the base object \n+of the data reference and its access functions. These access functions \n+represent the evolution of the data reference in the loop relative to \n+its base, in keeping with the classical meaning of the data reference \n+access function for the support of arrays. For example, for a reference \n+@code{a.b[i][j]}, the base object is @code{a.b} and the access functions, \n+one for each array subscript, are: \n+@code{@{i_init, + i_step@}_1, @{j_init, +, j_step@}_2}.\n+\n+@item @code{first_location_in_loop}: Provides information about the first \n+location accessed by the data reference in the loop and about the access \n+function used to represent evolution relative to this location. This data \n+is used to support pointers, and is not used for arrays (for which we \n+have base objects). Pointer accesses are represented as a one-dimensional\n+access that starts from the first location accessed in the loop. For \n+example:\n+\n+@smallexample\n+      for1 i\n+         for2 j\n+          *((int *)p + i + j) = a[i][j];\n+@end smallexample\n+\n+The access function of the pointer access is @code{@{0, + 4B@}_for2} \n+relative to @code{p + i}. The access functions of the array are \n+@code{@{i_init, + i_step@}_for1} and @code{@{j_init, +, j_step@}_for2} \n+relative to @code{a}.\n+\n+Usually, the object the pointer refers to is either unknown, or we can't \n+prove that the access is confined to the boundaries of a certain object. \n+\n+Two data references can be compared only if at least one of these two \n+representations has all its fields filled for both data references. \n+\n+The current strategy for data dependence tests is as follows: \n+If both @code{a} and @code{b} are represented as arrays, compare \n+@code{a.base_object} and @code{b.base_object};\n+if they are equal, apply dependence tests (use access functions based on \n+base_objects).\n+Else if both @code{a} and @code{b} are represented as pointers, compare \n+@code{a.first_location} and @code{b.first_location}; \n+if they are equal, apply dependence tests (use access functions based on \n+first location).\n+However, if @code{a} and @code{b} are represented differently, only try \n+to prove that the bases are definitely different.\n+\n+@item Aliasing information.\n+@item Alignment information.\n+@end itemize\n+\n The structure describing the relation between two data references is\n @code{data_dependence_relation} and the shorter name for a pointer to\n such a structure is @code{ddr_p}.  This structure contains:"}]}