{"sha": "560ad596bdde2ca44f9890e9e1399b29736c63ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYwYWQ1OTZiZGRlMmNhNDRmOTg5MGU5ZTEzOTliMjk3MzZjNjNlYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-08-12T22:26:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-08-12T22:26:25Z"}, "message": "re PR c++/11703 (Problem with using enum in placement delete)\n\n\tPR c++/11703\n\t* call.c (type_passed_as): Use TYPE_SIZE, not TYPE_PRECISION to\n\tdetermine whether or not to promote types.\n\t(convert_for_arg_passing): Likewise.\n\t* decl2.c (cp_build_parm_decl): Do not set DECL_ARG_TYPE in\n\ttemplates.\n\t* pt.c (tsubst_decl): Do not expect it to be set.\n\n\tPR c++/9512\n\tPR c++/10923\n\t* cp-tree.h (check_elaborated_type_specifier): Declare.\n\t(handle_class_head): Remove.\n\t(note_got_semicolon): Likewise.\n\t(note_list_got_semicolon): Likewise.\n\t(finish_class_definition): Likewise.\n\t* decl.c (check_elaborated_type_specifier): Make it public.\n\tRobustify.\n\t(handle_class_head): Remove.\n\t* parser.c (cp_parser_elaborated_type_specifier): Use\n\tcheck_elaborated_type_specifier.\n\t(cp_parser_class_specifier): Do not call finish_class_definition.\n\t(cp_parser_class_head): Or handle_class_head.  Check for\n\tover-qualified names.\n\t* semantics.c (finish_class_definition): Remove.\n\n\t* parser.c (cp_parser_check_for_definition_in_return_type): New\n\tfunction.\n\t(cp_parser_simple_declaration): Adjust call to\n\tcp_parser_init_declarator.\n\t(cp_parser_decl_specifier_seq): Change type of\n\tdeclares_class_or_enum parameter.\n\t(cp_parser_explicit_instantiation): Adjust accordingly.\n\t(cp_parser_type_specifier): Change type of\n\tdeclares_class_or_enum parameter.\n\t(cp_parser_init_declarator): Add declares_class_or_enum\n\tparameter.\n\t(cp_parser_parameter_declaration): Adjust call to\n\tcp_parser_decl_specifier_seq.\n\t(cp_parser_function_definition): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_single_declaration): Likewise.\n\n\t* cp-tree.h (lang_type_class): Remove has_call_overloaded,\n\thas_array_ref_overloaded, has_arrow_overloaded, and got_semicolon.\n\t(TYPE_OVERLOADS_CALL_EXPR): Remove.\n\t(TYPE_OVERLOADS_ARRAY_REF): Likewise.\n\t(TYPE_OVERLOADS_ARROW): Likewise.\n\t(CLASSTYPE_GOT_SEMICOLON): Likewise.\n\t* class.c (check_bases): Do not set them.\n\t(finish_struct_1): Likewise.\n\t* decl.c (cp_finish_decl): Do not set CLASSTYPE_GOT_SEMICOLON.\n\t(build_ptrmemfunc_type): Likewise.\n\t(grok_op_properties): Do not set TYPE_OVERLOADS_*.\n\t(start_function): Do not check CLASSTYPE_GOT_SEMICOLON.\n\t* decl2.c (grokfield): Do not set CLASSTYPE_GOT_SEMICOLON.\n\t* lex.c (note_got_semicolon): Remove.\n\t(note_list_got_semicolon): Likewise.\n\t* parser.c (cp_parser_simple_declaration): Do not call\n\tnote_list_got_semicolon.\n\t* pt.c (list_eq): Remove.\n\t(lookup_template_class): Do not set CLASSTYPE_GOT_SEMICOLON.\n\t(instantiate_class_template): Do not set TYPE_OVERLOADS*.\n\t(instantiate_class_template): Do not set CLASSTYPE_GOT_SEMICOLON.\n\t* ptree.c (cxx_print_type): Do not print them.\n\t* semantics.c (finish_member_class_template): Do not call\n\tnote_list_got_semicolon.\n\n\t* g++.dg/parse/ret-type2.C: New test.\n\n\tPR c++/11703\n\t* g++.dg/init/new8.C: New test.\n\n\tPR c++/10923\n\t* g++.dg/parse/typedef5.C: New test.\n\n\tPR c++/9512\n\t* g++.dg/parse/qualified2.C: New test.\n\t* g++.old-deja/g++.other/decl5.C: Mark one more instance of\n\tinvalid code.\n\nFrom-SVN: r70391", "tree": {"sha": "98aa4b6b847333e82f9374a9201eb1371ef7d159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98aa4b6b847333e82f9374a9201eb1371ef7d159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/560ad596bdde2ca44f9890e9e1399b29736c63ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/560ad596bdde2ca44f9890e9e1399b29736c63ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/560ad596bdde2ca44f9890e9e1399b29736c63ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/560ad596bdde2ca44f9890e9e1399b29736c63ea/comments", "author": null, "committer": null, "parents": [{"sha": "35e6511a747ac8fd49a70401ba99857b57c16e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e6511a747ac8fd49a70401ba99857b57c16e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e6511a747ac8fd49a70401ba99857b57c16e5c"}], "stats": {"total": 556, "additions": 252, "deletions": 304}, "files": [{"sha": "6a2765215d76a6fb694a0cd8eb34695ca25928ec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -1,3 +1,72 @@\n+2003-08-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11703\n+\t* call.c (type_passed_as): Use TYPE_SIZE, not TYPE_PRECISION to\n+\tdetermine whether or not to promote types.\n+\t(convert_for_arg_passing): Likewise.\n+\t* decl2.c (cp_build_parm_decl): Do not set DECL_ARG_TYPE in\n+\ttemplates.\n+\t* pt.c (tsubst_decl): Do not expect it to be set.\n+\n+\tPR c++/9512\n+\tPR c++/10923\n+\t* cp-tree.h (check_elaborated_type_specifier): Declare.\n+\t(handle_class_head): Remove.\n+\t(note_got_semicolon): Likewise.\n+\t(note_list_got_semicolon): Likewise.\n+\t(finish_class_definition): Likewise.\n+\t* decl.c (check_elaborated_type_specifier): Make it public.\n+\tRobustify.\n+\t(handle_class_head): Remove.\n+\t* parser.c (cp_parser_elaborated_type_specifier): Use\n+\tcheck_elaborated_type_specifier.\n+\t(cp_parser_class_specifier): Do not call finish_class_definition.\n+\t(cp_parser_class_head): Or handle_class_head.  Check for\n+\tover-qualified names.\n+\t* semantics.c (finish_class_definition): Remove.\n+\n+\t* parser.c (cp_parser_check_for_definition_in_return_type): New\n+\tfunction.\n+\t(cp_parser_simple_declaration): Adjust call to\n+\tcp_parser_init_declarator.\n+\t(cp_parser_decl_specifier_seq): Change type of\n+\tdeclares_class_or_enum parameter.\n+\t(cp_parser_explicit_instantiation): Adjust accordingly.\n+\t(cp_parser_type_specifier): Change type of\n+\tdeclares_class_or_enum parameter.\n+\t(cp_parser_init_declarator): Add declares_class_or_enum\n+\tparameter.\n+\t(cp_parser_parameter_declaration): Adjust call to\n+\tcp_parser_decl_specifier_seq.\n+\t(cp_parser_function_definition): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_single_declaration): Likewise.\n+\t\n+\t* cp-tree.h (lang_type_class): Remove has_call_overloaded,\n+\thas_array_ref_overloaded, has_arrow_overloaded, and got_semicolon.\n+\t(TYPE_OVERLOADS_CALL_EXPR): Remove.\n+\t(TYPE_OVERLOADS_ARRAY_REF): Likewise.\n+\t(TYPE_OVERLOADS_ARROW): Likewise.\n+\t(CLASSTYPE_GOT_SEMICOLON): Likewise.\n+\t* class.c (check_bases): Do not set them.\n+\t(finish_struct_1): Likewise.\n+\t* decl.c (cp_finish_decl): Do not set CLASSTYPE_GOT_SEMICOLON.\n+\t(build_ptrmemfunc_type): Likewise.\n+\t(grok_op_properties): Do not set TYPE_OVERLOADS_*.\n+\t(start_function): Do not check CLASSTYPE_GOT_SEMICOLON.\n+\t* decl2.c (grokfield): Do not set CLASSTYPE_GOT_SEMICOLON.\n+\t* lex.c (note_got_semicolon): Remove.\n+\t(note_list_got_semicolon): Likewise.\n+\t* parser.c (cp_parser_simple_declaration): Do not call\n+\tnote_list_got_semicolon.\n+\t* pt.c (list_eq): Remove.\n+\t(lookup_template_class): Do not set CLASSTYPE_GOT_SEMICOLON.\n+\t(instantiate_class_template): Do not set TYPE_OVERLOADS*.\n+\t(instantiate_class_template): Do not set CLASSTYPE_GOT_SEMICOLON.\n+\t* ptree.c (cxx_print_type): Do not print them.\n+\t* semantics.c (finish_member_class_template): Do not call\n+\tnote_list_got_semicolon.\n+\t\n 2003-08-11  Aldy Hernandez  <aldyh@redhat.com>\n  \n         * call.c (standard_conversion): Opaque pointers interconvert."}, {"sha": "afdc2911891c58ba3abe3be0568ae5b99d0a79c3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -4330,7 +4330,8 @@ type_passed_as (tree type)\n     type = build_reference_type (type);\n   else if (PROMOTE_PROTOTYPES\n \t   && INTEGRAL_TYPE_P (type)\n-\t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\t   && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n+\t\t\t\t   TYPE_SIZE (integer_type_node)))\n     type = integer_type_node;\n \n   return type;\n@@ -4348,7 +4349,8 @@ convert_for_arg_passing (tree type, tree val)\n     val = build1 (ADDR_EXPR, build_reference_type (type), val);\n   else if (PROMOTE_PROTOTYPES\n \t   && INTEGRAL_TYPE_P (type)\n-\t   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\t   && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n+\t\t\t\t   TYPE_SIZE (integer_type_node)))\n     val = perform_integral_promotions (val);\n   return val;\n }"}, {"sha": "a224676ea957abe2b0bb122f1bbb8efc52139fa6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -1284,9 +1284,6 @@ check_bases (tree t,\n       TYPE_HAS_COMPLEX_ASSIGN_REF (t) \n \t|= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n       TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n-      TYPE_OVERLOADS_CALL_EXPR (t) |= TYPE_OVERLOADS_CALL_EXPR (basetype);\n-      TYPE_OVERLOADS_ARRAY_REF (t) |= TYPE_OVERLOADS_ARRAY_REF (basetype);\n-      TYPE_OVERLOADS_ARROW (t) |= TYPE_OVERLOADS_ARROW (basetype);\n       TYPE_POLYMORPHIC_P (t) |= TYPE_POLYMORPHIC_P (basetype);\n       CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) \n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n@@ -4977,7 +4974,6 @@ finish_struct_1 (tree t)\n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n   TYPE_SIZE (t) = NULL_TREE;\n-  CLASSTYPE_GOT_SEMICOLON (t) = 0;\n   CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n \n   fixup_inline_methods (t);"}, {"sha": "934acb9934b13dfdfcd648949277ce2b87548137", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -1071,12 +1071,12 @@ struct lang_type_class GTY(())\n   unsigned has_array_new : 1;\n \n   unsigned gets_delete : 2;\n-  unsigned has_call_overloaded : 1;\n-  unsigned has_array_ref_overloaded : 1;\n-  unsigned has_arrow_overloaded : 1;\n   unsigned interface_only : 1;\n   unsigned interface_unknown : 1;\n   unsigned contains_empty_class_p : 1;\n+  unsigned anon_aggr : 1;\n+  unsigned non_zero_init : 1;\n+  unsigned empty_p : 1;\n \n   unsigned marks: 6;\n   unsigned vec_new_uses_cookie : 1;\n@@ -1086,7 +1086,7 @@ struct lang_type_class GTY(())\n   unsigned redefined : 1;\n   unsigned debug_requested : 1;\n   unsigned use_template : 2;\n-  unsigned got_semicolon : 1;\n+  unsigned fields_readonly : 1;\n   unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n \n@@ -1097,11 +1097,6 @@ struct lang_type_class GTY(())\n   unsigned has_abstract_assign_ref : 1;\n   unsigned non_aggregate : 1;\n   unsigned java_interface : 1;\n-  unsigned anon_aggr : 1;\n-\n-  unsigned non_zero_init : 1;\n-  unsigned empty_p : 1;\n-  unsigned fields_readonly : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1110,7 +1105,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 5;\n+  unsigned dummy : 9;\n \n   tree primary_base;\n   tree vfields;\n@@ -1221,18 +1216,6 @@ struct lang_type GTY(())\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n #define TYPE_REDEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->redefined)\n \n-/* Nonzero means that this _CLASSTYPE node overloads operator().  */\n-#define TYPE_OVERLOADS_CALL_EXPR(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->has_call_overloaded)\n-\n-/* Nonzero means that this _CLASSTYPE node overloads operator[].  */\n-#define TYPE_OVERLOADS_ARRAY_REF(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->has_array_ref_overloaded)\n-\n-/* Nonzero means that this _CLASSTYPE node overloads operator->.  */\n-#define TYPE_OVERLOADS_ARROW(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->has_arrow_overloaded)\n-\n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    multiple inheritance.  If this is 0 for the root of a type\n    hierarchy, then we can use more efficient search techniques.  */\n@@ -1382,9 +1365,6 @@ struct lang_type GTY(())\n    class must provide its own definition for each of these functions.  */\n #define CLASSTYPE_PURE_VIRTUALS(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->pure_virtuals)\n \n-/* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n-#define CLASSTYPE_GOT_SEMICOLON(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->got_semicolon)\n-\n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->h.has_default_ctor)\n@@ -3763,6 +3743,7 @@ extern tree declare_global_var                  (tree, tree);\n extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *);\n+extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n extern bool have_extern_spec;\n \n /* in decl2.c */\n@@ -3808,7 +3789,6 @@ extern tree do_class_using_decl (tree);\n extern void do_using_directive (tree);\n extern void check_default_args (tree);\n extern void mark_used (tree);\n-extern tree handle_class_head (enum tag_types, tree, tree, tree);\n extern tree lookup_arg_dependent (tree, tree, tree);\n extern void finish_static_data_member_decl (tree, tree, tree, int);\n extern tree cp_build_parm_decl (tree, tree);\n@@ -3896,8 +3876,6 @@ extern void do_pending_inlines\t\t\t(void);\n extern void yyungetc\t\t\t\t(int, int);\n extern void snarf_method\t\t\t(tree);\n \n-extern void note_got_semicolon\t\t\t(tree);\n-extern void note_list_got_semicolon\t\t(tree);\n extern void see_typename\t\t\t(void);\n extern tree unqualified_name_lookup_error       (tree);\n extern tree unqualified_fn_lookup_error         (tree);\n@@ -4139,7 +4117,6 @@ extern tree finish_template_type_parm           (tree, tree);\n extern tree finish_template_template_parm       (tree, tree);\n extern tree finish_parmlist                     (tree, int);\n extern tree begin_class_definition              (tree);\n-extern tree finish_class_definition             (tree, tree, int, int);\n extern void finish_default_args                 (void);\n extern tree finish_member_class_template        (tree);\n extern void finish_template_decl                (tree);"}, {"sha": "0619147f29c97aa07af7c2c6d4741deddb8cd2a0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -8066,7 +8066,6 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n \t    warning (\"shadowing previous type declaration of `%#D'\", decl);\n \t  set_identifier_type_value (DECL_NAME (decl), type);\n-\t  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \t}\n \n       /* If we have installed this as the canonical typedef for this\n@@ -9245,9 +9244,6 @@ build_ptrmemfunc_type (tree type)\n      later.  */\n   TYPE_SET_PTRMEMFUNC_TYPE (type, t);\n \n-  /* Seems to be wanted.  */\n-  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-\n   return t;\n }\n \n@@ -12241,19 +12237,6 @@ grok_op_properties (tree decl, int friendp)\n     {\n       switch (operator_code)\n \t{\n-\tcase CALL_EXPR:\n-\t  TYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n-\t  break;\n-\n-\tcase ARRAY_REF:\n-\t  TYPE_OVERLOADS_ARRAY_REF (current_class_type) = 1;\n-\t  break;\n-\n-\tcase COMPONENT_REF:\n-\tcase MEMBER_REF:\n-\t  TYPE_OVERLOADS_ARROW (current_class_type) = 1;\n-\t  break;\n-\n \tcase NEW_EXPR:\n \t  TYPE_HAS_NEW_OPERATOR (current_class_type) = 1;\n \t  break;\n@@ -12541,7 +12524,7 @@ tag_name (enum tag_types code)\n    error_mark_node; otherwise, return TYPE itself.  \n    If ALLOW_TEMPLATE_P is true, TYPE may be a class template.  */\n \n-static tree\n+tree\n check_elaborated_type_specifier (enum tag_types tag_code,\n \t\t\t\t tree type,\n \t\t\t\t bool allow_template_p)\n@@ -12553,8 +12536,8 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n      ill-formed.  */\n   if (!t)\n     {\n-      error (\"using typedef-name `%D' after `%s'\",\n-\t     TYPE_NAME (type), tag_name (tag_code));\n+      error (\"using typedef-name `%T' after `%s'\",\n+\t     type, tag_name (tag_code));\n       t = error_mark_node;\n     }\n   else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n@@ -13412,20 +13395,6 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n       fntype = TREE_TYPE (decl1);\n \n       restype = TREE_TYPE (fntype);\n-      if (CLASS_TYPE_P (restype) && !CLASSTYPE_GOT_SEMICOLON (restype))\n-\t{\n-\t  error (\"semicolon missing after declaration of `%#T'\", restype);\n-\t  shadow_tag (build_tree_list (NULL_TREE, restype));\n-\t  CLASSTYPE_GOT_SEMICOLON (restype) = 1;\n-\t  if (TREE_CODE (fntype) == FUNCTION_TYPE)\n-\t    fntype = build_function_type (integer_type_node,\n-\t\t\t\t\t  TYPE_ARG_TYPES (fntype));\n-\t  else\n-\t    fntype = build_cplus_method_type (build_type_variant (TYPE_METHOD_BASETYPE (fntype), TREE_READONLY (decl1), TREE_SIDE_EFFECTS (decl1)),\n-\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t      TYPE_ARG_TYPES (fntype));\n-\t  TREE_TYPE (decl1) = fntype;\n-\t}\n \n       if (TREE_CODE (fntype) == METHOD_TYPE)\n \tctype = TYPE_METHOD_BASETYPE (fntype);"}, {"sha": "54e627f5569fd43354c2aa434bd9d503f1d70cfd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 94, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -223,7 +223,10 @@ tree\n cp_build_parm_decl (tree name, tree type)\n {\n   tree parm = build_decl (PARM_DECL, name, type);\n-  DECL_ARG_TYPE (parm) = type_passed_as (type);\n+  /* DECL_ARG_TYPE is only used by the back end and the back end never\n+     sees templates.  */\n+  if (!processing_template_decl)\n+    DECL_ARG_TYPE (parm) = type_passed_as (type);\n   return parm;\n }\n \n@@ -918,9 +921,6 @@ grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n \n-      if (CLASS_TYPE_P (TREE_TYPE (value)))\n-        CLASSTYPE_GOT_SEMICOLON (TREE_TYPE (value)) = 1;\n-      \n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n \n@@ -4215,94 +4215,4 @@ mark_used (tree decl)\n     }\n }\n \n-/* Called when a class-head is encountered.  TAG_KIND is the class-key\n-   for the class.  SCOPE, if non-NULL, is the type or namespace\n-   indicated in the nested-name-specifier for the declaration of the\n-   class.  ID is the name of the class, if any; it may be a TYPE_DECL,\n-   or an IDENTIFIER_NODE.  ATTRIBUTES are attributes that apply to the\n-   class.\n-\n-   Return a TYPE_DECL for the class being defined.  */\n-\n-tree\n-handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n-                   tree attributes)\n-{\n-  tree decl = NULL_TREE;\n-  tree current = current_scope ();\n-  bool xrefd_p = false;\n-  bool new_type_p;\n-  tree context;\n-\n-  if (current == NULL_TREE)\n-    current = current_namespace;\n-\n-  if (scope)\n-    {\n-      if (TREE_CODE (id) == TYPE_DECL)\n-\t/* We must bash typedefs back to the main decl of the\n-       \t   type. Otherwise we become confused about scopes.  */\n-\tdecl = TYPE_MAIN_DECL (TREE_TYPE (id));\n-      else if (DECL_CLASS_TEMPLATE_P (id))\n-\tdecl = DECL_TEMPLATE_RESULT (id);\n-      else\n-\t{\n-\t  if (TYPE_P (scope))\n-\t    {\n-\t      /* According to the suggested resolution of core issue\n-\t     \t 180, 'typename' is assumed after a class-key.  */\n-\t      decl = make_typename_type (scope, id, tf_error);\n-\t      if (decl != error_mark_node)\n-\t\tdecl = TYPE_MAIN_DECL (decl);\n-\t      else\n-\t\tdecl = NULL_TREE;\n-\t    }\n-\t  else if (scope == current)\n-\t    {\n-\t      /* We've been given AGGR SCOPE::ID, when we're already\n-             \t inside SCOPE.  Be nice about it.  */\n-\t      if (pedantic)\n-\t\tpedwarn (\"extra qualification `%T::' on member `%D' ignored\",\n-\t\t\t scope, id);\n-\t    }\n-\t  else\n-\t    error (\"`%T' does not have a class or union named `%D'\",\n-\t\t   scope, id);\n-\t}\n-    }\n-  \n-  if (!decl)\n-    {\n-      decl = xref_tag (tag_kind, id, attributes, false, false);\n-      if (decl == error_mark_node)\n-\treturn error_mark_node;\n-      decl = TYPE_MAIN_DECL (decl);\n-      xrefd_p = true;\n-    }\n-\n-  if (!TYPE_BINFO (TREE_TYPE (decl)))\n-    {\n-      error (\"`%T' is not a class or union type\", decl);\n-      return error_mark_node;\n-    }\n-  \n-  /* For a definition, we want to enter the containing scope before\n-     looking up any base classes etc. Only do so, if this is different\n-     to the current scope.  */\n-  context = CP_DECL_CONTEXT (decl);\n-  \n-  new_type_p = (current != context\n-\t\t&& TREE_CODE (context) != TEMPLATE_TYPE_PARM\n-\t\t&& TREE_CODE (context) != BOUND_TEMPLATE_TEMPLATE_PARM);\n-  if (new_type_p)\n-    push_scope (context);\n-  \n-  if (!xrefd_p \n-      && PROCESSING_REAL_TEMPLATE_DECL_P ()\n-      && !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n-    decl = push_template_decl (decl);\n-\n-  return decl;\n-}\n-\n #include \"gt-cp-decl2.h\""}, {"sha": "49b8311bd79c99a10812ae9bfdc03eb96552b237", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -506,28 +506,6 @@ interface_strcmp (const char* s)\n   return 1;\n }\n \n-void\n-note_got_semicolon (tree type)\n-{\n-  if (!TYPE_P (type))\n-    abort ();\n-  if (CLASS_TYPE_P (type))\n-    CLASSTYPE_GOT_SEMICOLON (type) = 1;\n-}\n-\n-void\n-note_list_got_semicolon (tree declspecs)\n-{\n-  tree link;\n-\n-  for (link = declspecs; link; link = TREE_CHAIN (link))\n-    {\n-      tree type = TREE_VALUE (link);\n-      if (type && TYPE_P (type))\n-\tnote_got_semicolon (type);\n-    }\n-  clear_anon_tags ();\n-}\n \f\n \n /* Parse a #pragma whose sole argument is a string constant."}, {"sha": "b485fb5e5827ab168b6f66bb1c71d6691f25f071", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 110, "deletions": 50, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -1405,13 +1405,13 @@ static void cp_parser_block_declaration\n static void cp_parser_simple_declaration\n   (cp_parser *, bool);\n static tree cp_parser_decl_specifier_seq \n-  (cp_parser *, cp_parser_flags, tree *, bool *);\n+  (cp_parser *, cp_parser_flags, tree *, int *);\n static tree cp_parser_storage_class_specifier_opt\n   (cp_parser *);\n static tree cp_parser_function_specifier_opt\n   (cp_parser *);\n static tree cp_parser_type_specifier\n-  (cp_parser *, cp_parser_flags, bool, bool, bool *, bool *);\n+  (cp_parser *, cp_parser_flags, bool, bool, int *, bool *);\n static tree cp_parser_simple_type_specifier\n   (cp_parser *, cp_parser_flags);\n static tree cp_parser_type_name\n@@ -1446,7 +1446,7 @@ static void cp_parser_linkage_specification\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  (cp_parser *, tree, tree, bool, bool, bool *);\n+  (cp_parser *, tree, tree, bool, bool, int, bool *);\n static tree cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *);\n static tree cp_parser_direct_declarator\n@@ -1674,6 +1674,8 @@ static bool cp_parser_simulate_error\n   (cp_parser *);\n static void cp_parser_check_type_definition\n   (cp_parser *);\n+static void cp_parser_check_for_definition_in_return_type\n+  (tree, int);\n static tree cp_parser_non_constant_expression\n   (const char *);\n static bool cp_parser_diagnose_invalid_type_name\n@@ -1763,6 +1765,28 @@ cp_parser_check_type_definition (cp_parser* parser)\n     error (\"%s\", parser->type_definition_forbidden_message);\n }\n \n+/* This function is called when a declaration is parsed.  If\n+   DECLARATOR is a function declarator and DECLARES_CLASS_OR_ENUM\n+   indicates that a type was defined in the decl-specifiers for DECL,\n+   then an error is issued.  */\n+\n+static void\n+cp_parser_check_for_definition_in_return_type (tree declarator, \n+\t\t\t\t\t       int declares_class_or_enum)\n+{\n+  /* [dcl.fct] forbids type definitions in return types.\n+     Unfortunately, it's not easy to know whether or not we are\n+     processing a return type until after the fact.  */\n+  while (declarator\n+\t && (TREE_CODE (declarator) == INDIRECT_REF\n+\t     || TREE_CODE (declarator) == ADDR_EXPR))\n+    declarator = TREE_OPERAND (declarator, 0);\n+  if (declarator\n+      && TREE_CODE (declarator) == CALL_EXPR \n+      && declares_class_or_enum & 2)\n+    error (\"new types may not be defined in a return type\");\n+}\n+\n /* Issue an eror message about the fact that THING appeared in a\n    constant-expression.  Returns ERROR_MARK_NODE.  */\n \n@@ -6041,7 +6065,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n {\n   tree decl_specifiers;\n   tree attributes;\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   bool saw_declarator;\n \n   /* Defer access checks until we know what is being declared; the\n@@ -6100,13 +6124,15 @@ cp_parser_simple_declaration (cp_parser* parser,\n     {\n       cp_token *token;\n       bool function_definition_p;\n+      tree decl;\n \n       saw_declarator = true;\n       /* Parse the init-declarator.  */\n-      cp_parser_init_declarator (parser, decl_specifiers, attributes,\n-\t\t\t\t function_definition_allowed_p,\n-\t\t\t\t /*member_p=*/false,\n-\t\t\t\t &function_definition_p);\n+      decl = cp_parser_init_declarator (parser, decl_specifiers, attributes,\n+\t\t\t\t\tfunction_definition_allowed_p,\n+\t\t\t\t\t/*member_p=*/false,\n+\t\t\t\t\tdeclares_class_or_enum,\n+\t\t\t\t\t&function_definition_p);\n       /* If an error occurred while parsing tentatively, exit quickly.\n \t (That usually happens when in the body of a function; each\n \t statement is treated as a declaration-statement until proven\n@@ -6170,10 +6196,6 @@ cp_parser_simple_declaration (cp_parser* parser,\n   /* Consume the `;'.  */\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n-  /* Mark all the classes that appeared in the decl-specifier-seq as\n-     having received a `;'.  */\n-  note_list_got_semicolon (decl_specifiers);\n-\n  done:\n   pop_deferring_access_checks ();\n }\n@@ -6208,20 +6230,29 @@ cp_parser_simple_declaration (cp_parser* parser,\n    appears, and the entity that will be a friend is not going to be a\n    class, then *FRIEND_IS_NOT_CLASS_P will be set to TRUE.  Note that\n    even if *FRIEND_IS_NOT_CLASS_P is FALSE, the entity to which\n-   friendship is granted might not be a class.  */\n+   friendship is granted might not be a class.  \n+\n+   *DECLARES_CLASS_OR_ENUM is set to the bitwise or of the following\n+   *flags:\n+\n+     1: one of the decl-specifiers is an elaborated-type-specifier\n+     2: one of the decl-specifiers is an enum-specifier or a\n+        class-specifier\n+\n+   */\n \n static tree\n cp_parser_decl_specifier_seq (cp_parser* parser, \n                               cp_parser_flags flags, \n                               tree* attributes,\n-\t\t\t      bool* declares_class_or_enum)\n+\t\t\t      int* declares_class_or_enum)\n {\n   tree decl_specs = NULL_TREE;\n   bool friend_p = false;\n   bool constructor_possible_p = !parser->in_declarator_p;\n   \n   /* Assume no class or enumeration type is declared.  */\n-  *declares_class_or_enum = false;\n+  *declares_class_or_enum = 0;\n \n   /* Assume there are no attributes.  */\n   *attributes = NULL_TREE;\n@@ -6317,7 +6348,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t a type-specifier.  */\n       if (!decl_spec && !constructor_p)\n \t{\n-\t  bool decl_spec_declares_class_or_enum;\n+\t  int decl_spec_declares_class_or_enum;\n \t  bool is_cv_qualifier;\n \n \t  decl_spec\n@@ -7913,7 +7944,7 @@ cp_parser_template_argument (cp_parser* parser)\n static void\n cp_parser_explicit_instantiation (cp_parser* parser)\n {\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   tree decl_specifiers;\n   tree attributes;\n   tree extension_specifier = NULL_TREE;\n@@ -7965,6 +7996,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       declarator \n \t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t/*ctor_dtor_or_conv_p=*/NULL);\n+      cp_parser_check_for_definition_in_return_type (declarator, \n+\t\t\t\t\t\t     declares_class_or_enum);\n       decl = grokdeclarator (declarator, decl_specifiers, \n \t\t\t     NORMAL, 0, NULL);\n       /* Turn access control back on for names used during\n@@ -8055,8 +8088,9 @@ cp_parser_explicit_specialization (cp_parser* parser)\n \n    If DECLARES_CLASS_OR_ENUM is non-NULL, and the type-specifier is a\n    class-specifier, enum-specifier, or elaborated-type-specifier, then\n-   *DECLARES_CLASS_OR_ENUM is set to TRUE.  Otherwise, it is set to\n-   FALSE.\n+   *DECLARES_CLASS_OR_ENUM is set to a non-zero value.  The value is 1\n+   if a type is declared; 2 if it is defined.  Otherwise, it is set to\n+   zero.\n \n    If IS_CV_QUALIFIER is non-NULL, and the type-specifier is a\n    cv-qualifier, then IS_CV_QUALIFIER is set to TRUE.  Otherwise, it\n@@ -8067,7 +8101,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t\t\t  cp_parser_flags flags, \n \t\t\t  bool is_friend,\n \t\t\t  bool is_declaration,\n-\t\t\t  bool* declares_class_or_enum,\n+\t\t\t  int* declares_class_or_enum,\n \t\t\t  bool* is_cv_qualifier)\n {\n   tree type_spec = NULL_TREE;\n@@ -8107,7 +8141,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       if (cp_parser_parse_definitely (parser))\n \t{\n \t  if (declares_class_or_enum)\n-\t    *declares_class_or_enum = true;\n+\t    *declares_class_or_enum = 2;\n \t  return type_spec;\n \t}\n \n@@ -8121,7 +8155,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       /* We're declaring a class or enum -- unless we're using\n \t `typename'.  */\n       if (declares_class_or_enum && keyword != RID_TYPENAME)\n-\t*declares_class_or_enum = true;\n+\t*declares_class_or_enum = 1;\n       return type_spec;\n \n     case RID_CONST:\n@@ -8512,13 +8546,13 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t      error (\"expected type-name\");\n \t      return error_mark_node;\n \t    }\n-\t  else if (TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE\n-\t\t   && tag_type != enum_type)\n-\t    error (\"`%T' referred to as `%s'\", TREE_TYPE (decl),\n-\t\t   tag_type == record_type ? \"struct\" : \"class\");\n-\t  else if (TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n-\t\t   && tag_type == enum_type)\n-\t    error (\"`%T' referred to as enum\", TREE_TYPE (decl));\n+\n+\t  if (TREE_CODE (TREE_TYPE (decl)) != TYPENAME_TYPE)\n+\t    check_elaborated_type_specifier \n+\t      (tag_type, \n+\t       TREE_TYPE (decl),\n+\t       (parser->num_template_parameter_lists\n+\t\t|| DECL_SELF_REFERENCE_P (decl)));\n \n \t  type = TREE_TYPE (decl);\n \t}\n@@ -9161,6 +9195,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   tree prefix_attributes,\n \t\t\t   bool function_definition_allowed_p,\n \t\t\t   bool member_p,\n+\t\t\t   int declares_class_or_enum,\n \t\t\t   bool* function_definition_p)\n {\n   cp_token *token;\n@@ -9198,6 +9233,9 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (declarator == error_mark_node)\n     return error_mark_node;\n \n+  cp_parser_check_for_definition_in_return_type (declarator,\n+\t\t\t\t\t\t declares_class_or_enum);\n+\n   /* Figure out what scope the entity declared by the DECLARATOR is\n      located in.  `grokdeclarator' sometimes changes the scope, so\n      we compute it now.  */\n@@ -10326,7 +10364,7 @@ static tree\n cp_parser_parameter_declaration (cp_parser *parser, \n \t\t\t\t bool template_parm_p)\n {\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   bool greater_than_is_operator_p;\n   tree decl_specifiers;\n   tree attributes;\n@@ -10561,7 +10599,7 @@ cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n   tree declarator;\n   tree fn;\n   cp_token *token;\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   bool member_p;\n   /* The saved value of the PEDANTIC flag.  */\n   int saved_pedantic;\n@@ -10635,6 +10673,9 @@ cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n       return error_mark_node;\n     }\n \n+  cp_parser_check_for_definition_in_return_type (declarator,\n+\t\t\t\t\t\t declares_class_or_enum);\n+\n   /* If we are in a class scope, then we must handle\n      function-definitions specially.  In particular, we save away the\n      tokens that make up the function body, and parse them again\n@@ -11126,11 +11167,16 @@ cp_parser_class_specifier (cp_parser* parser)\n   /* Look for attributes to apply to this class.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     attributes = cp_parser_attributes_opt (parser);\n-  /* Finish the class definition.  */\n-  type = finish_class_definition (type, \n-\t\t\t\t  attributes,\n-\t\t\t\t  has_trailing_semicolon,\n-\t\t\t\t  nested_name_specifier_p);\n+  /* If we got any attributes in class_head, xref_tag will stick them in\n+     TREE_TYPE of the type.  Grab them now.  */\n+  if (type != error_mark_node)\n+    {\n+      attributes = chainon (TYPE_ATTRIBUTES (type), attributes);\n+      TYPE_ATTRIBUTES (type) = NULL_TREE;\n+      type = finish_struct (type, attributes);\n+    }\n+  if (nested_name_specifier_p)\n+    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n   /* If this class is not itself within the scope of another class,\n      then we need to parse the bodies of all of the queued function\n      definitions.  Note that the queued functions defined in a class\n@@ -11444,21 +11490,31 @@ cp_parser_class_head (cp_parser* parser,\n \t\t \"enclose `%D'\", type, scope, nested_name_specifier);\n \t  return NULL_TREE;\n \t}\n+      /* [dcl.meaning]\n \n-      maybe_process_partial_specialization (TREE_TYPE (type));\n-      class_type = current_class_type;\n-      type = TREE_TYPE (handle_class_head (class_key, \n-\t\t\t\t\t   nested_name_specifier,\n-\t\t\t\t\t   type,\n-\t\t\t\t\t   attributes));\n-      if (type != error_mark_node)\n+         A declarator-id shall not be qualified exception of the\n+\t definition of a ... nested class outside of its class\n+\t ... [or] a the definition or explicit instantiation of a\n+\t class member of a namespace outside of its namespace.  */\n+      if (scope == CP_DECL_CONTEXT (type))\n \t{\n-\t  if (!class_type && TYPE_CONTEXT (type))\n-\t    *nested_name_specifier_p = true;\n-\t  else if (class_type && !same_type_p (TYPE_CONTEXT (type),\n-\t\t\t\t\t       class_type))\n-\t    *nested_name_specifier_p = true;\n+\t  pedwarn (\"extra qualification ignored\");\n+\t  nested_name_specifier = NULL_TREE;\n \t}\n+\n+      maybe_process_partial_specialization (TREE_TYPE (type));\n+      class_type = current_class_type;\n+      /* Enter the scope indicated by the nested-name-specifier.  */\n+      if (nested_name_specifier)\n+\tpush_scope (nested_name_specifier);\n+      /* Get the canonical version of this type.  */\n+      type = TYPE_MAIN_DECL (TREE_TYPE (type));\n+      if (PROCESSING_REAL_TEMPLATE_DECL_P ()\n+\t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (type)))\n+\ttype = push_template_decl (type);\n+      type = TREE_TYPE (type);\n+      if (nested_name_specifier)\n+\t*nested_name_specifier_p = true;\n     }\n   /* Indicate whether this class was declared as a `class' or as a\n      `struct'.  */\n@@ -11599,7 +11655,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   tree decl_specifiers;\n   tree prefix_attributes;\n   tree decl;\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   bool friend_p;\n   cp_token *token;\n   int saved_pedantic;\n@@ -11812,6 +11868,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  break;\n \t\t}\n \n+\t      cp_parser_check_for_definition_in_return_type \n+\t\t(declarator, declares_class_or_enum);\n+\n \t      /* Look for an asm-specification.  */\n \t      asm_specification = cp_parser_asm_specification_opt (parser);\n \t      /* Look for attributes that apply to the declaration.  */\n@@ -13543,7 +13602,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t      bool member_p,\n \t\t\t      bool* friend_p)\n {\n-  bool declares_class_or_enum;\n+  int declares_class_or_enum;\n   tree decl = NULL_TREE;\n   tree decl_specifiers;\n   tree attributes;\n@@ -13592,6 +13651,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t      attributes,\n \t\t\t\t      /*function_definition_allowed_p=*/false,\n \t\t\t\t      member_p,\n+\t\t\t\t      declares_class_or_enum,\n \t\t\t\t      /*function_definition_p=*/NULL);\n \n   pop_deferring_access_checks ();"}, {"sha": "edb43d98a81b73ca74ee7960ce95ad786a821e98", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -100,7 +100,6 @@ static void reopen_tinst_level (tree);\n static tree classtype_mangled_name (tree);\n static char* mangle_class_name_for_template (const char *, tree, tree);\n static tree tsubst_initializer_list (tree, tree);\n-static int list_eq (tree, tree);\n static tree get_class_bindings (tree, tree, tree);\n static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t, int);\n static void tsubst_enum\t(tree, tree, tree);\n@@ -4227,7 +4226,6 @@ lookup_template_class (tree d1,\n \t  t = make_aggr_type (TREE_CODE (template_type));\n \t  CLASSTYPE_DECLARED_CLASS (t) \n \t    = CLASSTYPE_DECLARED_CLASS (template_type);\n-\t  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \t  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n \t  TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (template_type);\n \n@@ -5141,9 +5139,6 @@ instantiate_class_template (tree type)\n \n   TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n   TYPE_HAS_DESTRUCTOR (type) = TYPE_HAS_DESTRUCTOR (pattern);\n-  TYPE_OVERLOADS_CALL_EXPR (type) = TYPE_OVERLOADS_CALL_EXPR (pattern);\n-  TYPE_OVERLOADS_ARRAY_REF (type) = TYPE_OVERLOADS_ARRAY_REF (pattern);\n-  TYPE_OVERLOADS_ARROW (type) = TYPE_OVERLOADS_ARROW (pattern);\n   TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n   TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);\n@@ -5385,7 +5380,6 @@ instantiate_class_template (tree type)\n   \n   unreverse_member_declarations (type);\n   finish_struct_1 (type);\n-  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \n   /* Clear this now so repo_template_used is happy.  */\n   TYPE_BEING_DEFINED (type) = 0;\n@@ -5414,21 +5408,6 @@ instantiate_class_template (tree type)\n   return type;\n }\n \n-static int\n-list_eq (tree t1, tree t2)\n-{\n-  if (t1 == NULL_TREE)\n-    return t2 == NULL_TREE;\n-  if (t2 == NULL_TREE)\n-    return 0;\n-  /* Don't care if one declares its arg const and the other doesn't -- the\n-     main variant of the arg type is all that matters.  */\n-  if (TYPE_MAIN_VARIANT (TREE_VALUE (t1))\n-      != TYPE_MAIN_VARIANT (TREE_VALUE (t2)))\n-    return 0;\n-  return list_eq (TREE_CHAIN (t1), TREE_CHAIN (t2));\n-}\n-\n static tree\n tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n@@ -6020,11 +5999,14 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n-\tif (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n-\t  DECL_INITIAL (r) = TREE_TYPE (r);\n-\telse\n-\t  DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args,\n-\t\t\t\t     complain, in_decl);\n+\tif (DECL_INITIAL (r))\n+\t  {\n+\t    if (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n+\t      DECL_INITIAL (r) = TREE_TYPE (r);\n+\t    else\n+\t      DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args,\n+\t\t\t\t\t complain, in_decl);\n+\t  }\n \n \tDECL_CONTEXT (r) = NULL_TREE;\n "}, {"sha": "6dbf0605a48441d8cb7bad47110aa8fc31eb909c", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -123,12 +123,6 @@ cxx_print_type (FILE *file, tree node, int indent)\n     fputs (\" delete[]\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))\n     fputs (\" this=(X&)\", file);\n-  if (TYPE_OVERLOADS_CALL_EXPR (node))\n-    fputs (\" op()\", file);\n-  if (TYPE_OVERLOADS_ARRAY_REF (node))\n-    fputs (\" op[]\", file);\n-  if (TYPE_OVERLOADS_ARROW (node))\n-    fputs (\" op->\", file);\n   if (TYPE_USES_MULTIPLE_INHERITANCE (node))\n     fputs (\" uses-multiple-inheritance\", file);\n "}, {"sha": "29d5dd7524b9d8ec5be4fa7ef9f79bdda6e935e6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -2133,41 +2133,6 @@ finish_member_declaration (tree decl)\n     }\n }\n \n-/* Finish a class definition T with the indicate ATTRIBUTES.  If SEMI,\n-   the definition is immediately followed by a semicolon.  Returns the\n-   type.  */\n-\n-tree\n-finish_class_definition (tree t, tree attributes, int semi, int pop_scope_p)\n-{\n-  if (t == error_mark_node)\n-    return error_mark_node;\n-\n-  /* finish_struct nukes this anyway; if finish_exception does too,\n-     then it can go.  */\n-  if (semi)\n-    note_got_semicolon (t);\n-\n-  /* If we got any attributes in class_head, xref_tag will stick them in\n-     TREE_TYPE of the type.  Grab them now.  */\n-  attributes = chainon (TYPE_ATTRIBUTES (t), attributes);\n-  TYPE_ATTRIBUTES (t) = NULL_TREE;\n-\n-  if (TREE_CODE (t) == ENUMERAL_TYPE)\n-    ;\n-  else\n-    {\n-      t = finish_struct (t, attributes);\n-      if (semi) \n-\tnote_got_semicolon (t);\n-    }\n-\n-  if (pop_scope_p)\n-    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (t)));\n-\n-  return t;\n-}\n-\n /* Finish processing the declaration of a member class template\n    TYPES whose template parameters are given by PARMS.  */\n \n@@ -2183,7 +2148,6 @@ finish_member_class_template (tree types)\n     if (IS_AGGR_TYPE_CODE (TREE_CODE (TREE_VALUE (t))))\n       maybe_process_partial_specialization (TREE_VALUE (t));\n \n-  note_list_got_semicolon (types);\n   grok_x_components (types);\n   if (TYPE_CONTEXT (TREE_VALUE (types)) != current_class_type)\n     /* The component was in fact a friend declaration.  We avoid"}, {"sha": "09b0248ff7ae0ccea58719d984a838d923bbc325", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -1,3 +1,18 @@\n+2003-08-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/parse/ret-type2.C: New test.\n+\n+\tPR c++/11703\n+\t* g++.dg/init/new8.C: New test.\n+\n+\tPR c++/10923\n+\t* g++.dg/parse/typedef5.C: New test.\n+\n+\tPR c++/9512\n+\t* g++.dg/parse/qualified2.C: New test.\n+\t* g++.old-deja/g++.other/decl5.C: Mark one more instance of\n+\tinvalid code.\n+\n 2003-08-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/conversion/ptrmem1.C: New test."}, {"sha": "92c8cd260ff29eb1e726c3186dd7aa7322d68f8a", "filename": "gcc/testsuite/g++.dg/init/new8.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew8.C?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -0,0 +1,17 @@\n+typedef unsigned int size_t;\n+\n+enum Refcount_Type {\n+  NO_REFCOUNT\n+};\n+\n+struct d0_Unknown_Object\n+{\n+  void* operator new (size_t, size_t,  Refcount_Type type);\n+  void operator delete (void*, size_t, Refcount_Type);\n+  d0_Unknown_Object ();\n+};\n+\n+void make ()\n+{\n+  new (10, NO_REFCOUNT) d0_Unknown_Object;\n+}"}, {"sha": "c582613c953350541b3e1fec9e0acdbc96908faf", "filename": "gcc/testsuite/g++.dg/parse/qualified2.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fqualified2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fqualified2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fqualified2.C?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -0,0 +1,4 @@\n+namespace Glib {\n+  template <typename> class Value {};\n+  template <>         class Glib::Value<int> {}; // { dg-error \"\" }\n+}"}, {"sha": "2e8fa36ec0cc7d9de9d837fd38cfc095c02938de", "filename": "gcc/testsuite/g++.dg/parse/ret-type2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fret-type2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fret-type2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fret-type2.C?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -0,0 +1,5 @@\n+struct S {} f(); // { dg-error \"\" }\n+struct T {} *g(); // { dg-error \"\" }\n+struct U {} h() {} // { dg-error \"\" }\n+struct V {} *i() {} // { dg-error \"\" }\n+struct W {} (*p) (); // { dg-error \"\" }"}, {"sha": "5f6b18ca395c8516fde7a83e4ff08666335dbc4f", "filename": "gcc/testsuite/g++.dg/parse/typedef5.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef5.C?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -0,0 +1,6 @@\n+namespace A\n+{\n+  typedef int T;\n+}\n+\n+class A::T x; // { dg-error \"\" }"}, {"sha": "4aa1647548a74ae613febef680b94b3325e20427", "filename": "gcc/testsuite/g++.old-deja/g++.other/decl5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/560ad596bdde2ca44f9890e9e1399b29736c63ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C?ref=560ad596bdde2ca44f9890e9e1399b29736c63ea", "patch": "@@ -11,7 +11,7 @@ struct A {\n   int A::fn();        // { dg-warning \"\" } extra qualification\n   int A::m;           // { dg-warning \"\" } extra qualification\n   struct e;\n-  struct A::e {int i;};\n+  struct A::e {int i;}; // { dg-warning \"\" } extra qualification\n   struct A::expand {  // { dg-warning \"\" } extra qualification\n   int m;\n   };"}]}