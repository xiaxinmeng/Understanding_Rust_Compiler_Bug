{"sha": "e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5ZGEyNGM2NWM1ZDkxNGFkZWM0MTRjM2I2Yjg2ZjJlZGE2YmZhYQ==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2009-04-02T21:57:41Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2009-04-02T21:57:41Z"}, "message": "mips.c (mips_frame_info): Add acc_mask...\n\n2009-04-02  Chao-ying Fu  <fu@mips.com>\n\t    James Grosbach <james.grosbach@microchip.com>\n\n\t* config/mips/mips.c (mips_frame_info): Add acc_mask, num_acc,\n\tnum_cop0_regs, acc_save_offset, cop0_save_offset, acc_sp_offset,\n\tcop0_sp_offset.\n\t(machine_function): Add interrupt_handler_p, use_shadow_register_set_p,\n\tkeep_interrupts_masked_p, use_debug_exception_return_p.\n\t(mips_attribute_table): Add interrupt, use_shadow_register_set,\n\tkeep_interrupts_masked, use_debug_exception_return.\n\t(mips_interrupt_type_p, mips_use_shadow_register_set_p,\n\tmips_keep_interrupts_masked_p, mips_use_debug_exception_return_p):\n\tNew functions.\n\t(mips_function_ok_for_sibcall): Return false for interrupt handlers.\n\t(mips_print_operand): Process COP0 registers to print $0 .. $31\n\tcorrectly for GAS to process.\n\t(mips_interrupt_extra_call_saved_reg_p): New function.\n\t(mips_cfun_call_saved_reg_p): For interrupt handlers, we need to check\n\textra registers.\n\t(mips_cfun_might_clobber_call_saved_reg_p): Likewise.\n\t(mips_compute_frame_info): Add supports for interrupt context that\n\tincludes doubleword accumulators and COP0 registers.\n\t(mips_for_each_saved_acc): New function.\n\t(mips_for_each_saved_gpr_and_fpr): Change the function name from\n\tmips_for_each_saved_reg.\n\t(mips_save_reg): Save accumulators.\n\t(mips_kernel_reg_p): A new for_each_rtx callback.\n\t(mips_expand_prologue): Support interrupt handlers.\n\t(mips_restore_reg): Restore accumulators.\n\t(mips_expand_epilogue): Support interrupt handlers.\n\t(mips_can_use_return_insn): Return false for interrupt handlers.\n\t(mips_epilogue_uses): New function.\n\t* config/mips/mips.md (UNSPEC_ERET, UNSPEC_DERET, UNSPEC_DI,\n\tUNSPEC_EHB, UNSPEC_RDPGPR, UNSPEC_COP0): New UNSPEC.\n\t(mips_eret, mips_deret, mips_di, mips_ehb, mips_rdpgpr,\n\tcop0_move): New instructions.\n\t* config/mips/mips-protos.h (mips_epilogue_uses): Declare.\n\t* config/mips/mips.h (K0_REG_NUM, K1_REG_NUM, KERNEL_REG_P): New\n\tdefines.\n\t(COP0_STATUS_REG_NUM, COP0_CAUSE_REG_NUM, COP0_EPC_REG_NUM):\n\tNew defines.\n\t(CAUSE_IPL, SR_IPL, SR_EXL, SR_IE): New defines.\n\t(MIPS_PROLOGUE_TEMP_REGNUM, MIPS_EPILOGUE_TEMP_REGNUM): For\n\tinterrupt handlers, we use K0 as the temporary register.\n\t(EPILOGUE_USES): Change to a function call.\n\t* config/mips/sde.h (MIPS_EPILOGUE_TEMP_REGNUM): For interrupt\n\thandlers, we use K0 as the temporary register.\n\n\t* doc/extend.texi (Function Attributes): Document interrupt,\n\tuse_shadow_register_set, keep_interrupts_masked,\n\tuse_debug_exception_return for MIPS attributes.\n\nCo-Authored-By: James Grosbach <james.grosbach@microchip.com>\n\nFrom-SVN: r145481", "tree": {"sha": "4a88d9ea253d4b48c6cee73bc42fff56fd33fdd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a88d9ea253d4b48c6cee73bc42fff56fd33fdd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/comments", "author": null, "committer": null, "parents": [{"sha": "608f7b2ec681eb2fd5f178a8e3042598e7c2c615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/608f7b2ec681eb2fd5f178a8e3042598e7c2c615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/608f7b2ec681eb2fd5f178a8e3042598e7c2c615"}], "stats": {"total": 728, "additions": 676, "deletions": 52}, "files": [{"sha": "6b8ad457ae6cb6747a5d9fa25810afa1a29480f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -1,3 +1,55 @@\n+2009-04-02  Chao-ying Fu  <fu@mips.com>\n+\t    James Grosbach <james.grosbach@microchip.com>\n+\n+\t* config/mips/mips.c (mips_frame_info): Add acc_mask, num_acc,\n+\tnum_cop0_regs, acc_save_offset, cop0_save_offset, acc_sp_offset,\n+\tcop0_sp_offset.\n+\t(machine_function): Add interrupt_handler_p, use_shadow_register_set_p,\n+\tkeep_interrupts_masked_p, use_debug_exception_return_p.\n+\t(mips_attribute_table): Add interrupt, use_shadow_register_set,\n+\tkeep_interrupts_masked, use_debug_exception_return.\n+\t(mips_interrupt_type_p, mips_use_shadow_register_set_p,\n+\tmips_keep_interrupts_masked_p, mips_use_debug_exception_return_p):\n+\tNew functions.\n+\t(mips_function_ok_for_sibcall): Return false for interrupt handlers.\n+\t(mips_print_operand): Process COP0 registers to print $0 .. $31\n+\tcorrectly for GAS to process.\n+\t(mips_interrupt_extra_call_saved_reg_p): New function.\n+\t(mips_cfun_call_saved_reg_p): For interrupt handlers, we need to check\n+\textra registers.\n+\t(mips_cfun_might_clobber_call_saved_reg_p): Likewise.\n+\t(mips_compute_frame_info): Add supports for interrupt context that\n+\tincludes doubleword accumulators and COP0 registers.\n+\t(mips_for_each_saved_acc): New function.\n+\t(mips_for_each_saved_gpr_and_fpr): Change the function name from\n+\tmips_for_each_saved_reg.\n+\t(mips_save_reg): Save accumulators.\n+\t(mips_kernel_reg_p): A new for_each_rtx callback.\n+\t(mips_expand_prologue): Support interrupt handlers.\n+\t(mips_restore_reg): Restore accumulators.\n+\t(mips_expand_epilogue): Support interrupt handlers.\n+\t(mips_can_use_return_insn): Return false for interrupt handlers.\n+\t(mips_epilogue_uses): New function.\n+\t* config/mips/mips.md (UNSPEC_ERET, UNSPEC_DERET, UNSPEC_DI,\n+\tUNSPEC_EHB, UNSPEC_RDPGPR, UNSPEC_COP0): New UNSPEC.\n+\t(mips_eret, mips_deret, mips_di, mips_ehb, mips_rdpgpr,\n+\tcop0_move): New instructions.\n+\t* config/mips/mips-protos.h (mips_epilogue_uses): Declare.\n+\t* config/mips/mips.h (K0_REG_NUM, K1_REG_NUM, KERNEL_REG_P): New\n+\tdefines.\n+\t(COP0_STATUS_REG_NUM, COP0_CAUSE_REG_NUM, COP0_EPC_REG_NUM):\n+\tNew defines.\n+\t(CAUSE_IPL, SR_IPL, SR_EXL, SR_IE): New defines.\n+\t(MIPS_PROLOGUE_TEMP_REGNUM, MIPS_EPILOGUE_TEMP_REGNUM): For\n+\tinterrupt handlers, we use K0 as the temporary register.\n+\t(EPILOGUE_USES): Change to a function call.\n+\t* config/mips/sde.h (MIPS_EPILOGUE_TEMP_REGNUM): For interrupt\n+\thandlers, we use K0 as the temporary register.\n+\t\n+\t* doc/extend.texi (Function Attributes): Document interrupt,\n+\tuse_shadow_register_set, keep_interrupts_masked,\n+\tuse_debug_exception_return for MIPS attributes.\n+\n 2009-04-03  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config.gcc (powerpc64-*-gnu*): Add rs6000/default64.h to tm_file."}, {"sha": "a704750286bed99302d8b2424cfb483b976895f8", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -332,4 +332,6 @@ extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,\n \n extern void mips_expand_vector_init (rtx, rtx);\n \n+extern bool mips_epilogue_uses (unsigned int);\n+\n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "9912105ecfac81a5dd9483db120436215779c320", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 494, "deletions": 39, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -261,18 +261,29 @@ struct mips_frame_info GTY(()) {\n   /* Likewise FPR X.  */\n   unsigned int fmask;\n \n-  /* The number of GPRs and FPRs saved.  */\n+  /* Likewise doubleword accumulator X ($acX).  */\n+  unsigned int acc_mask;\n+\n+  /* The number of GPRs, FPRs, doubleword accumulators and COP0\n+     registers saved.  */\n   unsigned int num_gp;\n   unsigned int num_fp;\n+  unsigned int num_acc;\n+  unsigned int num_cop0_regs;\n \n-  /* The offset of the topmost GPR and FPR save slots from the top of\n-     the frame, or zero if no such slots are needed.  */\n+  /* The offset of the topmost GPR, FPR, accumulator and COP0-register\n+     save slots from the top of the frame, or zero if no such slots are\n+     needed.  */\n   HOST_WIDE_INT gp_save_offset;\n   HOST_WIDE_INT fp_save_offset;\n+  HOST_WIDE_INT acc_save_offset;\n+  HOST_WIDE_INT cop0_save_offset;\n \n   /* Likewise, but giving offsets from the bottom of the frame.  */\n   HOST_WIDE_INT gp_sp_offset;\n   HOST_WIDE_INT fp_sp_offset;\n+  HOST_WIDE_INT acc_sp_offset;\n+  HOST_WIDE_INT cop0_sp_offset;\n \n   /* The offset of arg_pointer_rtx from frame_pointer_rtx.  */\n   HOST_WIDE_INT arg_pointer_offset;\n@@ -310,6 +321,20 @@ struct machine_function GTY(()) {\n   /* True if we have emitted an instruction to initialize\n      mips16_gp_pseudo_rtx.  */\n   bool initialized_mips16_gp_pseudo_p;\n+\n+  /* True if this is an interrupt handler.  */\n+  bool interrupt_handler_p;\n+\n+  /* True if this is an interrupt handler that uses shadow registers.  */\n+  bool use_shadow_register_set_p;\n+\n+  /* True if this is an interrupt handler that should keep interrupts\n+     masked.  */\n+  bool keep_interrupts_masked_p;\n+\n+  /* True if this is an interrupt handler that should use DERET\n+     instead of ERET.  */\n+  bool use_debug_exception_return_p;\n };\n \n /* Information about a single argument.  */\n@@ -554,6 +579,11 @@ const struct attribute_spec mips_attribute_table[] = {\n      code generation but don't carry other semantics.  */\n   { \"mips16\", \t   0, 0, true,  false, false, NULL },\n   { \"nomips16\",    0, 0, true,  false, false, NULL },\n+  /* Allow functions to be specified as interrupt handlers */\n+  { \"interrupt\",   0, 0, false, true,  true, NULL },\n+  { \"use_shadow_register_set\",\t0, 0, false, true,  true, NULL },\n+  { \"keep_interrupts_masked\",\t0, 0, false, true,  true, NULL },\n+  { \"use_debug_exception_return\", 0, 0, false, true,  true, NULL },\n   { NULL,\t   0, 0, false, false, false, NULL }\n };\n \f\n@@ -1172,6 +1202,42 @@ mips_nomips16_decl_p (const_tree decl)\n   return lookup_attribute (\"nomips16\", DECL_ATTRIBUTES (decl)) != NULL;\n }\n \n+/* Check if the interrupt attribute is set for a function.  */\n+\n+static bool\n+mips_interrupt_type_p (tree type)\n+{\n+  return lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n+/* Check if the attribute to use shadow register set is set for a function.  */\n+\n+static bool\n+mips_use_shadow_register_set_p (tree type)\n+{\n+  return lookup_attribute (\"use_shadow_register_set\",\n+\t\t\t   TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n+/* Check if the attribute to keep interrupts masked is set for a function.  */\n+\n+static bool\n+mips_keep_interrupts_masked_p (tree type)\n+{\n+  return lookup_attribute (\"keep_interrupts_masked\",\n+\t\t\t   TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n+/* Check if the attribute to use debug exception return is set for\n+   a function.  */\n+\n+static bool\n+mips_use_debug_exception_return_p (tree type)\n+{\n+  return lookup_attribute (\"use_debug_exception_return\",\n+\t\t\t   TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n /* Return true if function DECL is a MIPS16 function.  Return the ambient\n    setting if DECL is null.  */\n \n@@ -6188,6 +6254,11 @@ mips_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n   if (!TARGET_SIBCALLS)\n     return false;\n \n+  /* Interrupt handlers need special epilogue code and therefore can't\n+     use sibcalls.  */\n+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))\n+    return false;\n+\n   /* We can't do a sibcall if the called function is a MIPS16 function\n      because there is no direct \"jx\" instruction equivalent to \"jalx\" to\n      switch the ISA mode.  We only care about cases where the sibling\n@@ -7229,7 +7300,11 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \t\t|| (letter == 'L' && TARGET_BIG_ENDIAN)\n \t\t|| letter == 'D')\n \t      regno++;\n-\t    fprintf (file, \"%s\", reg_names[regno]);\n+\t    /* We need to print $0 .. $31 for COP0 registers.  */\n+\t    if (COP0_REG_P (regno))\n+\t      fprintf (file, \"$%s\", &reg_names[regno][4]);\n+\t    else\n+\t      fprintf (file, \"%s\", reg_names[regno]);\n \t  }\n \t  break;\n \n@@ -8436,12 +8511,53 @@ mips_global_pointer (void)\n   return GLOBAL_POINTER_REGNUM;\n }\n \n+/* Return true if REGNO is a register that is ordinarily call-clobbered\n+   but must nevertheless be preserved by an interrupt handler.  */\n+\n+static bool\n+mips_interrupt_extra_call_saved_reg_p (unsigned int regno)\n+{\n+  if (MD_REG_P (regno))\n+    return true;\n+\n+  if (TARGET_DSP && DSP_ACC_REG_P (regno))\n+    return true;\n+\n+  if (GP_REG_P (regno) && !cfun->machine->use_shadow_register_set_p)\n+    {\n+      /* $0 is hard-wired.  */\n+      if (regno == GP_REG_FIRST)\n+\treturn false;\n+\n+      /* The interrupt handler can treat kernel registers as\n+\t scratch registers.  */\n+      if (KERNEL_REG_P (regno))\n+\treturn false;\n+\n+      /* The function will return the stack pointer to its original value\n+\t anyway.  */\n+      if (regno == STACK_POINTER_REGNUM)\n+\treturn false;\n+\n+      /* Otherwise, return true for registers that aren't ordinarily\n+\t call-clobbered.  */\n+      return call_really_used_regs[regno];\n+    }\n+\n+  return false;\n+}\n+\n /* Return true if the current function should treat register REGNO\n    as call-saved.  */\n \n static bool\n mips_cfun_call_saved_reg_p (unsigned int regno)\n {\n+  /* Interrupt handlers need to save extra registers.  */\n+  if (cfun->machine->interrupt_handler_p\n+      && mips_interrupt_extra_call_saved_reg_p (regno))\n+    return true;\n+\n   /* call_insns preserve $28 unless they explicitly say otherwise,\n      so call_really_used_regs[] treats $28 as call-saved.  However,\n      we want the ABI property rather than the default call_insn\n@@ -8490,6 +8606,13 @@ mips_cfun_might_clobber_call_saved_reg_p (unsigned int regno)\n   if (regno == GP_REG_FIRST + 31 && mips16_cfun_returns_in_fpr_p ())\n     return true;\n \n+  /* If REGNO is ordinarily call-clobbered, we must assume that any\n+     called function could modify it.  */\n+  if (cfun->machine->interrupt_handler_p\n+      && !current_function_is_leaf\n+      && mips_interrupt_extra_call_saved_reg_p (regno))\n+    return true;\n+\n   return false;\n }\n \n@@ -8545,6 +8668,14 @@ mips_save_reg_p (unsigned int regno)\n       C |  callee-allocated save area   |\n \t|  for register varargs         |\n \t|                               |\n+\t+-------------------------------+ <-- frame_pointer_rtx\n+\t|                               |       + cop0_sp_offset\n+\t|  COP0 reg save area           |\t+ UNITS_PER_WORD\n+\t|                               |\n+\t+-------------------------------+ <-- frame_pointer_rtx + acc_sp_offset\n+\t|                               |       + UNITS_PER_WORD\n+\t|  accumulator save area        |\n+\t|                               |\n \t+-------------------------------+ <-- frame_pointer_rtx + fp_sp_offset\n \t|                               |       + UNITS_PER_HWFPVALUE\n \t|  FPR save area                |\n@@ -8588,6 +8719,28 @@ mips_compute_frame_info (void)\n   HOST_WIDE_INT offset, size;\n   unsigned int regno, i;\n \n+  /* Set this function's interrupt properties.  */\n+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))\n+    {\n+      if (!ISA_MIPS32R2)\n+\terror (\"the %<interrupt%> attribute requires a MIPS32r2 processor\");\n+      else if (TARGET_HARD_FLOAT)\n+\terror (\"the %<interrupt%> attribute requires %<-msoft-float%>\");\n+      else if (TARGET_MIPS16)\n+\terror (\"interrupt handlers cannot be MIPS16 functions\");\n+      else\n+\t{\n+\t  cfun->machine->interrupt_handler_p = true;\n+\t  cfun->machine->use_shadow_register_set_p =\n+\t    mips_use_shadow_register_set_p (TREE_TYPE (current_function_decl));\n+\t  cfun->machine->keep_interrupts_masked_p =\n+\t    mips_keep_interrupts_masked_p (TREE_TYPE (current_function_decl));\n+\t  cfun->machine->use_debug_exception_return_p =\n+\t    mips_use_debug_exception_return_p (TREE_TYPE\n+\t\t\t\t\t       (current_function_decl));\n+\t}\n+    }\n+\n   frame = &cfun->machine->frame;\n   memset (frame, 0, sizeof (*frame));\n   size = get_frame_size ();\n@@ -8657,7 +8810,7 @@ mips_compute_frame_info (void)\n     }\n \n   /* Find out which FPRs we need to save.  This loop must iterate over\n-     the same space as its companion in mips_for_each_saved_reg.  */\n+     the same space as its companion in mips_for_each_saved_gpr_and_fpr.  */\n   if (TARGET_HARD_FLOAT)\n     for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno += MAX_FPRS_PER_FMT)\n       if (mips_save_reg_p (regno))\n@@ -8673,6 +8826,47 @@ mips_compute_frame_info (void)\n       frame->fp_sp_offset = offset - UNITS_PER_HWFPVALUE;\n     }\n \n+  /* Add in space for the interrupt context information.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    {\n+      /* Check HI/LO.  */\n+      if (mips_save_reg_p (LO_REGNUM) || mips_save_reg_p (HI_REGNUM))\n+\t{\n+\t  frame->num_acc++;\n+\t  frame->acc_mask |= (1 << 0);\n+\t}\n+\n+      /* Check accumulators 1, 2, 3.  */\n+      for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)\n+\tif (mips_save_reg_p (i) || mips_save_reg_p (i + 1))\n+\t  {\n+\t    frame->num_acc++;\n+\t    frame->acc_mask |= 1 << (((i - DSP_ACC_REG_FIRST) / 2) + 1);\n+\t  }\n+\n+      /* All interrupt context functions need space to preserve STATUS.  */\n+      frame->num_cop0_regs++;\n+\n+      /* If we don't keep interrupts masked, we need to save EPC.  */\n+      if (!cfun->machine->keep_interrupts_masked_p)\n+\tframe->num_cop0_regs++;\n+    }\n+\n+  /* Move above the accumulator save area.  */\n+  if (frame->num_acc > 0)\n+    {\n+      /* Each accumulator needs 2 words.  */\n+      offset += frame->num_acc * 2 * UNITS_PER_WORD;\n+      frame->acc_sp_offset = offset - UNITS_PER_WORD;\n+    }\n+\n+  /* Move above the COP0 register save area.  */\n+  if (frame->num_cop0_regs > 0)\n+    {\n+      offset += frame->num_cop0_regs * UNITS_PER_WORD;\n+      frame->cop0_sp_offset = offset - UNITS_PER_WORD;\n+    }\n+\n   /* Move above the callee-allocated varargs save area.  */\n   offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n   frame->arg_pointer_offset = offset;\n@@ -8686,6 +8880,10 @@ mips_compute_frame_info (void)\n     frame->gp_save_offset = frame->gp_sp_offset - offset;\n   if (frame->fp_sp_offset > 0)\n     frame->fp_save_offset = frame->fp_sp_offset - offset;\n+  if (frame->acc_sp_offset > 0)\n+    frame->acc_save_offset = frame->acc_sp_offset - offset;\n+  if (frame->num_cop0_regs > 0)\n+    frame->cop0_save_offset = frame->cop0_sp_offset - offset;\n \n   /* MIPS16 code offsets the frame pointer by the size of the outgoing\n      arguments.  This tends to increase the chances of using unextended\n@@ -8882,12 +9080,41 @@ mips_save_restore_reg (enum machine_mode mode, int regno,\n   fn (gen_rtx_REG (mode, regno), mem);\n }\n \n+/* Call FN for each accumlator that is saved by the current function.\n+   SP_OFFSET is the offset of the current stack pointer from the start\n+   of the frame.  */\n+\n+static void\n+mips_for_each_saved_acc (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n+{\n+  HOST_WIDE_INT offset;\n+  int regno;\n+\n+  offset = cfun->machine->frame.acc_sp_offset - sp_offset;\n+  if (BITSET_P (cfun->machine->frame.acc_mask, 0))\n+    {\n+      mips_save_restore_reg (word_mode, LO_REGNUM, offset, fn);\n+      offset -= UNITS_PER_WORD;\n+      mips_save_restore_reg (word_mode, HI_REGNUM, offset, fn);\n+      offset -= UNITS_PER_WORD;\n+    }\n+\n+  for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)\n+    if (BITSET_P (cfun->machine->frame.acc_mask,\n+\t\t  ((regno - DSP_ACC_REG_FIRST) / 2) + 1))\n+      {\n+\tmips_save_restore_reg (word_mode, regno, offset, fn);\n+\toffset -= UNITS_PER_WORD;\n+      }\n+}\n+\n /* Call FN for each register that is saved by the current function.\n    SP_OFFSET is the offset of the current stack pointer from the start\n    of the frame.  */\n \n static void\n-mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n+mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,\n+\t\t\t\t mips_save_restore_fn fn)\n {\n   enum machine_mode fpr_mode;\n   HOST_WIDE_INT offset;\n@@ -9075,13 +9302,24 @@ mips_save_reg (rtx reg, rtx mem)\n     }\n   else\n     {\n-      if (TARGET_MIPS16\n-\t  && REGNO (reg) != GP_REG_FIRST + 31\n-\t  && !M16_REG_P (REGNO (reg)))\n+      if (REGNO (reg) == HI_REGNUM)\n \t{\n-\t  /* Save a non-MIPS16 register by moving it through a temporary.\n-\t     We don't need to do this for $31 since there's a special\n-\t     instruction for it.  */\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_mfhidi_ti (MIPS_PROLOGUE_TEMP (DImode),\n+\t\t\t\t      gen_rtx_REG (TImode, MD_REG_FIRST)));\n+\t  else\n+\t    emit_insn (gen_mfhisi_di (MIPS_PROLOGUE_TEMP (SImode),\n+\t\t\t\t      gen_rtx_REG (DImode, MD_REG_FIRST)));\n+\t  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n+\t}\n+      else if ((TARGET_MIPS16\n+\t\t&& REGNO (reg) != GP_REG_FIRST + 31\n+\t\t&& !M16_REG_P (REGNO (reg)))\n+\t       || ACC_REG_P (REGNO (reg)))\n+\t{\n+\t  /* If the register has no direct store instruction, move it\n+\t     through a temporary.  Note that there's a special MIPS16\n+\t     instruction to save $31.  */\n \t  mips_emit_move (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);\n \t  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n \t}\n@@ -9153,6 +9391,14 @@ mips_emit_loadgp (void)\n     emit_insn (gen_loadgp_blockage ());\n }\n \n+/* A for_each_rtx callback.  Stop the search if *X is a kernel register.  */\n+\n+static int\n+mips_kernel_reg_p (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  return GET_CODE (*x) == REG && KERNEL_REG_P (REGNO (*x));\n+}\n+\n /* Expand the \"prologue\" pattern.  */\n \n void\n@@ -9172,7 +9418,8 @@ mips_expand_prologue (void)\n   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP\n      bytes beforehand; this is enough to cover the register save area\n      without going out of range.  */\n-  if ((frame->mask | frame->fmask) != 0)\n+  if (((frame->mask | frame->fmask | frame->acc_mask) != 0)\n+      || frame->num_cop0_regs > 0)\n     {\n       HOST_WIDE_INT step1;\n \n@@ -9203,12 +9450,97 @@ mips_expand_prologue (void)\n  \t}\n       else\n  \t{\n-\t  insn = gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\tstack_pointer_rtx,\n-\t\t\t\tGEN_INT (-step1));\n-\t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n-\t  size -= step1;\n-\t  mips_for_each_saved_reg (size, mips_save_reg);\n+\t  if (cfun->machine->interrupt_handler_p)\n+\t    {\n+\t      HOST_WIDE_INT offset;\n+\t      rtx mem;\n+\n+\t      /* If this interrupt is using a shadow register set, we need to\n+\t\t get the stack pointer from the previous register set.  */\n+\t      if (cfun->machine->use_shadow_register_set_p)\n+\t\temit_insn (gen_mips_rdpgpr (stack_pointer_rtx,\n+\t\t\t\t\t    stack_pointer_rtx));\n+\n+\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t\t{\n+\t\t  /* Move from COP0 Cause to K0.  */\n+\t\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K0_REG_NUM),\n+\t\t\t\t\t    gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t COP0_CAUSE_REG_NUM)));\n+\t\t  /* Move from COP0 EPC to K1.  */\n+\t\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t\t    gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t COP0_EPC_REG_NUM)));\n+\t\t}\n+\n+\t      /* Allocate the first part of the frame.  */\n+\t      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-step1));\n+\t      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n+\t      size -= step1;\n+\n+\t      /* Start at the uppermost location for saving.  */\n+\t      offset = frame->cop0_sp_offset - size;\n+\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t\t{\n+\t\t  /* Push EPC into its stack slot.  */\n+\t\t  mem = gen_frame_mem (word_mode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset));\n+\t\t  mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n+\t\t  offset -= UNITS_PER_WORD;\n+\t\t}\n+\n+\t      /* Move from COP0 Status to K1.  */\n+\t      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t\tgen_rtx_REG (SImode,\n+\t\t\t\t\t\t     COP0_STATUS_REG_NUM)));\n+\n+\t      /* Right justify the RIPL in k0.  */\n+\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t\temit_insn (gen_lshrsi3 (gen_rtx_REG (SImode, K0_REG_NUM),\n+\t\t\t\t\tgen_rtx_REG (SImode, K0_REG_NUM),\n+\t\t\t\t\tGEN_INT (CAUSE_IPL)));\n+\n+\t      /* Push Status into its stack slot.  */\n+\t      mem = gen_frame_mem (word_mode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx, offset));\n+\t      mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n+\t      offset -= UNITS_PER_WORD;\n+\n+\t      /* Insert the RIPL into our copy of SR (k1) as the new IPL.  */\n+\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t\temit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t       GEN_INT (6),\n+\t\t\t\t       GEN_INT (SR_IPL),\n+\t\t\t\t       gen_rtx_REG (SImode, K0_REG_NUM)));\n+\n+\t      if (!cfun->machine->keep_interrupts_masked_p)\n+\t\t/* Enable interrupts by clearing the KSU ERL and EXL bits.\n+\t\t   IE is already the correct value, so we don't have to do\n+\t\t   anything explicit.  */\n+\t\temit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t       GEN_INT (4),\n+\t\t\t\t       GEN_INT (SR_EXL),\n+\t\t\t\t       gen_rtx_REG (SImode, GP_REG_FIRST)));\n+\t      else\n+\t\t/* Disable interrupts by clearing the KSU, ERL, EXL,\n+\t\t   and IE bits.  */\n+\t\temit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),\n+\t\t\t\t       GEN_INT (5),\n+\t\t\t\t       GEN_INT (SR_IE),\n+\t\t\t\t       gen_rtx_REG (SImode, GP_REG_FIRST)));\n+\t    }\n+\t  else\n+\t    {\n+\t      insn = gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-step1));\n+\t      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n+\t      size -= step1;\n+\t    }\n+\t  mips_for_each_saved_acc (size, mips_save_reg);\n+\t  mips_for_each_saved_gpr_and_fpr (size, mips_save_reg);\n \t}\n     }\n \n@@ -9293,6 +9625,20 @@ mips_expand_prologue (void)\n \t\t\tpic_offset_table_rtx);\n     }\n \n+  /* We need to search back to the last use of K0 or K1.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    {\n+      for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))\n+\tif (INSN_P (insn)\n+\t    && for_each_rtx (&PATTERN (insn), mips_kernel_reg_p, NULL))\n+\t  break;\n+      /* Emit a move from K1 to COP0 Status after insn.  */\n+      gcc_assert (insn != NULL_RTX);\n+      emit_insn_after (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),\n+\t\t\t\t      gen_rtx_REG (SImode, K1_REG_NUM)),\n+\t\t       insn);\n+    }\n+\n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n   if (crtl->profile)\n@@ -9309,7 +9655,20 @@ mips_restore_reg (rtx reg, rtx mem)\n   if (TARGET_MIPS16 && REGNO (reg) == GP_REG_FIRST + 31)\n     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);\n \n-  if (TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))\n+  if (REGNO (reg) == HI_REGNUM)\n+    {\n+      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n+      if (TARGET_64BIT)\n+\temit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD_REG_FIRST),\n+\t\t\t\t  MIPS_EPILOGUE_TEMP (DImode),\n+\t\t\t\t  gen_rtx_REG (DImode, LO_REGNUM)));\n+      else\n+\temit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD_REG_FIRST),\n+\t\t\t\t  MIPS_EPILOGUE_TEMP (SImode),\n+\t\t\t\t  gen_rtx_REG (SImode, LO_REGNUM)));\n+    }\n+  else if ((TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))\n+\t   || ACC_REG_P (REGNO (reg)))\n     {\n       /* Can't restore directly; move through a temporary.  */\n       mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n@@ -9345,7 +9704,7 @@ mips_expand_epilogue (bool sibcall_p)\n {\n   const struct mips_frame_info *frame;\n   HOST_WIDE_INT step1, step2;\n-  rtx base, target;\n+  rtx base, target, insn;\n \n   if (!sibcall_p && mips_can_use_return_insn ())\n     {\n@@ -9378,7 +9737,8 @@ mips_expand_epilogue (bool sibcall_p)\n \n   /* If we need to restore registers, deallocate as much stack as\n      possible in the second step without going out of range.  */\n-  if ((frame->mask | frame->fmask) != 0)\n+  if ((frame->mask | frame->fmask | frame->acc_mask) != 0\n+      || frame->num_cop0_regs > 0)\n     {\n       step2 = MIN (step1, MIPS_MAX_FIRST_STACK_STEP);\n       step1 -= step2;\n@@ -9440,13 +9800,53 @@ mips_expand_epilogue (bool sibcall_p)\n   else\n     {\n       /* Restore the registers.  */\n-      mips_for_each_saved_reg (frame->total_size - step2, mips_restore_reg);\n+      mips_for_each_saved_acc (frame->total_size - step2, mips_restore_reg);\n+      mips_for_each_saved_gpr_and_fpr (frame->total_size - step2,\n+\t\t\t\t       mips_restore_reg);\n \n-      /* Deallocate the final bit of the frame.  */\n-      if (step2 > 0)\n-\temit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (step2)));\n+      if (cfun->machine->interrupt_handler_p)\n+\t{\n+\t  HOST_WIDE_INT offset;\n+\t  rtx mem;\n+\n+\t  offset = frame->cop0_sp_offset - (frame->total_size - step2);\n+\t  if (!cfun->machine->keep_interrupts_masked_p)\n+\t    {\n+\t      /* Restore the original EPC.  */\n+\t      mem = gen_frame_mem (word_mode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx, offset));\n+\t      mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n+\t      offset -= UNITS_PER_WORD;\n+\n+\t      /* Move to COP0 EPC.  */\n+\t      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_EPC_REG_NUM),\n+\t\t\t\t\tgen_rtx_REG (SImode, K0_REG_NUM)));\n+\t    }\n+\n+\t  /* Restore the original Status.  */\n+\t  mem = gen_frame_mem (word_mode,\n+\t\t\t       plus_constant (stack_pointer_rtx, offset));\n+\t  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n+\t  offset -= UNITS_PER_WORD;\n+\n+\t  /* If we don't use shoadow register set, we need to update SP.  */\n+\t  if (!cfun->machine->use_shadow_register_set_p && step2 > 0)\n+\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (step2)));\n+\n+\t  /* Move to COP0 Status.  */\n+\t  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),\n+\t\t\t\t    gen_rtx_REG (SImode, K0_REG_NUM)));\n+\t}\n+      else\n+\t{\n+\t  /* Deallocate the final bit of the frame.  */\n+\t  if (step2 > 0)\n+\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (step2)));\n+\t}\n     }\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n@@ -9469,18 +9869,44 @@ mips_expand_epilogue (bool sibcall_p)\n \n   if (!sibcall_p)\n     {\n-      unsigned int regno;\n-\n-      /* When generating MIPS16 code, the normal mips_for_each_saved_reg\n-\t path will restore the return address into $7 rather than $31.  */\n-      if (TARGET_MIPS16\n-\t  && !GENERATE_MIPS16E_SAVE_RESTORE\n-\t  && BITSET_P (frame->mask, 31))\n-\tregno = GP_REG_FIRST + 7;\n-      else\n-\tregno = GP_REG_FIRST + 31;\n       mips_expand_before_return ();\n-      emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));\n+      if (cfun->machine->interrupt_handler_p)\n+\t{\n+\t  /* Interrupt handlers generate eret or deret.  */\n+\t  if (cfun->machine->use_debug_exception_return_p)\n+\t    emit_jump_insn (gen_mips_deret ());\n+\t  else\n+\t    emit_jump_insn (gen_mips_eret ());\n+\t}\n+      else\n+\t{\n+\t  unsigned int regno;\n+\n+\t  /* When generating MIPS16 code, the normal\n+\t     mips_for_each_saved_gpr_and_fpr path will restore the return\n+\t     address into $7 rather than $31.  */\n+\t  if (TARGET_MIPS16\n+\t      && !GENERATE_MIPS16E_SAVE_RESTORE\n+\t      && BITSET_P (frame->mask, 31))\n+\t    regno = GP_REG_FIRST + 7;\n+\t  else\n+\t    regno = GP_REG_FIRST + 31;\n+\t  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));\n+\t}\n+    }\n+\n+  /* Search from the beginning to the first use of K0 or K1.  */\n+  if (cfun->machine->interrupt_handler_p\n+      && !cfun->machine->keep_interrupts_masked_p)\n+    {\n+      for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn)\n+\t    && for_each_rtx (&PATTERN(insn), mips_kernel_reg_p, NULL))\n+\t  break;\n+      gcc_assert (insn != NULL_RTX);\n+      /* Insert disable interrupts before the first use of K0 or K1.  */\n+      emit_insn_before (gen_mips_di (), insn);\n+      emit_insn_before (gen_mips_ehb (), insn);\n     }\n }\n \f\n@@ -9491,6 +9917,10 @@ mips_expand_epilogue (bool sibcall_p)\n bool\n mips_can_use_return_insn (void)\n {\n+  /* Interrupt handlers need to go through the epilogue.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    return false;\n+\n   if (!reload_completed)\n     return false;\n \n@@ -14242,6 +14672,31 @@ mips_order_regs_for_local_alloc (void)\n       reg_alloc_order[24] = 0;\n     }\n }\n+\n+/* Implement EPILOGUE_USES.  */\n+\n+bool\n+mips_epilogue_uses (unsigned int regno)\n+{\n+  /* Say that the epilogue uses the return address register.  Note that\n+     in the case of sibcalls, the values \"used by the epilogue\" are\n+     considered live at the start of the called function.  */\n+  if (regno == 31)\n+    return true;\n+\n+  /* If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.\n+     See the comment above load_call<mode> for details.  */\n+  if (TARGET_USE_GOT && (regno) == GOT_VERSION_REGNUM)\n+    return true;\n+\n+  /* An interrupt handler must preserve some registers that are\n+     ordinarily call-clobbered.  */\n+  if (cfun->machine->interrupt_handler_p\n+      && mips_interrupt_extra_call_saved_reg_p (regno))\n+    return true;\n+\n+  return false;\n+}\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP"}, {"sha": "fbcfdca61e97b19b9ebd12f81579d5cc0bf96607", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -1622,6 +1622,9 @@ enum mips_code_readable_setting {\n #define GP_REG_LAST  31\n #define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)\n #define GP_DBX_FIRST 0\n+#define K0_REG_NUM   (GP_REG_FIRST + 26)\n+#define K1_REG_NUM   (GP_REG_FIRST + 27)\n+#define KERNEL_REG_P(REGNO)\t(IN_RANGE (REGNO, K0_REG_NUM, K1_REG_NUM))\n \n #define FP_REG_FIRST 32\n #define FP_REG_LAST  63\n@@ -1649,6 +1652,10 @@ enum mips_code_readable_setting {\n #define COP0_REG_LAST 111\n #define COP0_REG_NUM (COP0_REG_LAST - COP0_REG_FIRST + 1)\n \n+#define COP0_STATUS_REG_NUM\t(COP0_REG_FIRST + 12)\n+#define COP0_CAUSE_REG_NUM\t(COP0_REG_FIRST + 13)\n+#define COP0_EPC_REG_NUM\t(COP0_REG_FIRST + 14)\n+\n #define COP2_REG_FIRST 112\n #define COP2_REG_LAST 143\n #define COP2_REG_NUM (COP2_REG_LAST - COP2_REG_FIRST + 1)\n@@ -1667,6 +1674,17 @@ enum mips_code_readable_setting {\n #define HI_REGNUM\t(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)\n #define LO_REGNUM\t(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)\n \n+/* A few bitfield locations for the coprocessor registers.  */\n+/* Request Interrupt Priority Level is from bit 10 to bit 15 of\n+   the cause register for the EIC interrupt mode.  */\n+#define CAUSE_IPL\t10\n+/* Interrupt Priority Level is from bit 10 to bit 15 of the status register.  */\n+#define SR_IPL\t\t10\n+/* Exception Level is at bit 1 of the status register.  */\n+#define SR_EXL\t\t1\n+/* Interrupt Enable is at bit 0 of the status register.  */\n+#define SR_IE\t\t0\n+\n /* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.\n    If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG\n    should be used instead.  */\n@@ -1754,11 +1772,18 @@ enum mips_code_readable_setting {\n    incoming arguments, the static chain pointer, or the frame pointer.\n    The epilogue temporary mustn't conflict with the return registers,\n    the PIC call register ($25), the frame pointer, the EH stack adjustment,\n-   or the EH data registers.  */\n+   or the EH data registers.\n+\n+   If we're generating interrupt handlers, we use K0 as a temporary register\n+   in prologue/epilogue code.  */\n \n #define MIPS16_PIC_TEMP_REGNUM (GP_REG_FIRST + 2)\n-#define MIPS_PROLOGUE_TEMP_REGNUM (GP_REG_FIRST + 3)\n-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))\n+#define MIPS_PROLOGUE_TEMP_REGNUM \\\n+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 3)\n+#define MIPS_EPILOGUE_TEMP_REGNUM\t\t\\\n+  (cfun->machine->interrupt_handler_p\t\t\\\n+   ? K0_REG_NUM\t\t\t\t\t\\\n+   : GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))\n \n #define MIPS16_PIC_TEMP gen_rtx_REG (Pmode, MIPS16_PIC_TEMP_REGNUM)\n #define MIPS_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_PROLOGUE_TEMP_REGNUM)\n@@ -2284,14 +2309,7 @@ typedef struct mips_args {\n \t(mips_abi == ABI_EABI && UNITS_PER_FPVALUE >= UNITS_PER_DOUBLE)\n \n \f\n-/* Say that the epilogue uses the return address register.  Note that\n-   in the case of sibcalls, the values \"used by the epilogue\" are\n-   considered live at the start of the called function.\n-\n-   If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.\n-   See the comment above load_call<mode> for details.  */\n-#define EPILOGUE_USES(REGNO) \\\n-  ((REGNO) == 31 || (TARGET_USE_GOT && (REGNO) == GOT_VERSION_REGNUM))\n+#define EPILOGUE_USES(REGNO)\tmips_epilogue_uses (REGNO)\n \n /* Treat LOC as a byte offset from the stack pointer and round it up\n    to the next fully-aligned offset.  */"}, {"sha": "8a6719466d3ba4fac3d3ac47fff1ce91966a064a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -67,6 +67,12 @@\n    (UNSPEC_SET_GOT_VERSION\t46)\n    (UNSPEC_UPDATE_GOT_VERSION\t47)\n    (UNSPEC_COPYGP\t\t48)\n+   (UNSPEC_ERET\t\t\t49)\n+   (UNSPEC_DERET\t\t50)\n+   (UNSPEC_DI\t\t\t51)\n+   (UNSPEC_EHB\t\t\t52)\n+   (UNSPEC_RDPGPR\t\t53)\n+   (UNSPEC_COP0\t\t\t54)\n    \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n@@ -5679,6 +5685,60 @@\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n+;; Exception return.\n+(define_insn \"mips_eret\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] UNSPEC_ERET)]\n+  \"\"\n+  \"eret\"\n+  [(set_attr \"type\"\t\"trap\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Debug exception return.\n+(define_insn \"mips_deret\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] UNSPEC_DERET)]\n+  \"\"\n+  \"deret\"\n+  [(set_attr \"type\"\t\"trap\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Disable interrupts.\n+(define_insn \"mips_di\"\n+  [(unspec_volatile [(const_int 0)] UNSPEC_DI)]\n+  \"\"\n+  \"di\"\n+  [(set_attr \"type\"\t\"trap\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Execution hazard barrier.\n+(define_insn \"mips_ehb\"\n+  [(unspec_volatile [(const_int 0)] UNSPEC_EHB)]\n+  \"\"\n+  \"ehb\"\n+  [(set_attr \"type\"\t\"trap\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Read GPR from previous shadow register set.\n+(define_insn \"mips_rdpgpr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n+\t\t\t    UNSPEC_RDPGPR))]\n+  \"\"\n+  \"rdpgpr\\t%0,%1\"\n+  [(set_attr \"type\"\t\"move\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Move involving COP0 registers.\n+(define_insn \"cop0_move\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=B,d\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"d,B\")]\n+\t\t\t    UNSPEC_COP0))]\n+  \"\"\n+{ return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"mtc,mfc\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n ;; This is used in compiling the unwind routines.\n (define_expand \"eh_return\"\n   [(use (match_operand 0 \"general_operand\"))]"}, {"sha": "d2a32967b75488e5c352c229d0ccb253d30c6ad8", "filename": "gcc/config/mips/sde.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fsde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fconfig%2Fmips%2Fsde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsde.h?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -90,7 +90,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Use $5 as a temporary for both MIPS16 and non-MIPS16.  */\n #undef MIPS_EPILOGUE_TEMP_REGNUM\n-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + 5)\n+#define MIPS_EPILOGUE_TEMP_REGNUM \\\n+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 5)\n \n /* Using long will always be right for size_t and ptrdiff_t, since\n    sizeof(long) must equal sizeof(void *), following from the setting"}, {"sha": "e8b5628c0f1c40bd5c8bffcffd40d611d11615b7", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19da24c65c5d914adec414c3b6b86f2eda6bfaa/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e19da24c65c5d914adec414c3b6b86f2eda6bfaa", "patch": "@@ -2402,7 +2402,7 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k,\n+Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MIPS\n and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n@@ -2425,6 +2425,42 @@ Permissible values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF@.\n On ARMv7-M the interrupt type is ignored, and the attribute means the function\n may be called with a word aligned stack pointer.\n \n+On MIPS targets, you can use the following attributes to modify the behavior\n+of an interrupt handler:\n+@table @code\n+@item use_shadow_register_set\n+@cindex @code{use_shadow_register_set} attribute\n+Assume that the handler uses a shadow register set, instead of\n+the main general-purpose registers.\n+\n+@item keep_interrupts_masked\n+@cindex @code{keep_interrupts_masked} attribute\n+Keep interrupts masked for the whole function.  Without this attribute,\n+GCC tries to reenable interrupts for as much of the function as it can.\n+\n+@item use_debug_exception_return\n+@cindex @code{use_debug_exception_return} attribute\n+Return using the @code{deret} instruction.  Interrupt handlers that don't\n+have this attribute return using @code{eret} instead.\n+@end table\n+\n+You can use any combination of these attributes, as shown below:\n+@smallexample\n+void __attribute__ ((interrupt)) v0 ();\n+void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();\n+void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();\n+void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();\n+void __attribute__ ((interrupt, use_shadow_register_set,\n+\t\t     keep_interrupts_masked)) v4 ();\n+void __attribute__ ((interrupt, use_shadow_register_set,\n+\t\t     use_debug_exception_return)) v5 ();\n+void __attribute__ ((interrupt, keep_interrupts_masked,\n+\t\t     use_debug_exception_return)) v6 ();\n+void __attribute__ ((interrupt, use_shadow_register_set,\n+\t\t     keep_interrupts_masked,\n+\t\t     use_debug_exception_return)) v7 ();\n+@end smallexample\n+\n @item interrupt_handler\n @cindex interrupt handler functions on the Blackfin, m68k, H8/300 and SH processors\n Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and SH to"}]}