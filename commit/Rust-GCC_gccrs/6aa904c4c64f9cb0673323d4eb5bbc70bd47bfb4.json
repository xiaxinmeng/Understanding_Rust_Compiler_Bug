{"sha": "6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFhOTA0YzRjNjRmOWNiMDY3MzMyM2Q0ZWI1YmJjNzBiZDQ3YmZiNA==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-10-16T10:47:12Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-10-16T10:47:12Z"}, "message": "tree-vect-stmts.c (vectorizable_load): For SLP without permutation treat the first load of the node as the first...\n\n\n        * tree-vect-stmts.c (vectorizable_load): For SLP without\n        permutation treat the first load of the node as the first\n        element in its interleaving chain.\n        * tree-vect-slp.c (vect_get_and_check_slp_defs): Swap the\n        operands if necessary and possible.\n        (vect_build_slp_tree): Add new argument.  Allow load groups of\n        any size in basic blocks.  Keep all the loads for further\n        permutation check.  Use the new argument to determine if there\n        is a permutation.  Update the recursive calls.\n        (vect_supported_load_permutation_p): Allow subchains of\n        interleaving chains in basic block vectorization.\n        (vect_analyze_slp_instance): Update the call to\n        vect_build_slp_tree.  Check load permutation based on the new\n        parameter.\n        (vect_schedule_slp_instance): Don't start from the first element\n        in interleaving chain unless the loads are permuted.\n\nFrom-SVN: r180055", "tree": {"sha": "afce7ab0f20cd96ce8cfc5d418a37f92b01ae576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afce7ab0f20cd96ce8cfc5d418a37f92b01ae576"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/comments", "author": null, "committer": null, "parents": [{"sha": "1bb7e8f8fe35140b62b0d203f04c3d9f1c5ee909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb7e8f8fe35140b62b0d203f04c3d9f1c5ee909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bb7e8f8fe35140b62b0d203f04c3d9f1c5ee909"}], "stats": {"total": 267, "additions": 233, "deletions": 34}, "files": [{"sha": "969bc1e2abc7ba89913d5375e38b6f6d83598ef1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "patch": "@@ -1,3 +1,21 @@\n+2011-10-16 Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-stmts.c (vectorizable_load): For SLP without permutation\n+\ttreat the first load of the node as the first element in its\n+\tinterleaving chain.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Swap the operands if\n+\tnecessary and possible.\n+\t(vect_build_slp_tree): Add new argument.  Allow load groups of any size\n+\tin basic blocks.  Keep all the loads for further permutation check.\n+\tUse the new argument to determine if there is a permutation.  Update\n+\tthe recursive calls.\n+\t(vect_supported_load_permutation_p): Allow subchains of interleaving\n+\tchains in basic block vectorization.\n+\t(vect_analyze_slp_instance): Update the call to vect_build_slp_tree.\n+\tCheck load permutation based on the new parameter.\n+\t(vect_schedule_slp_instance): Don't start from the first element in\n+\tinterleaving chain unless the loads are permuted.\n+\n 2011-10-15  Jan Hubicka  <jh@suse.cz>\n \n \tPR target/48668"}, {"sha": "dbe22fed2f921ec76813fd0b008aee2f189d0a99", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "patch": "@@ -1,3 +1,7 @@\n+2011-10-16 Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-29.c: New test.\n+\n 2011-10-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50732"}, {"sha": "e37b96d14d9a51a27c826ffd2ca47d3c1b695343", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-29.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-29.c?ref=6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define A 3\n+#define B 4\n+#define N 256\n+\n+short src[N], dst[N];\n+\n+void foo (short * __restrict__ dst, short * __restrict__ src, int h, int stride, int dummy)\n+{\n+  int i;\n+  h /= 16;\n+  for (i = 0; i < h; i++)\n+    {\n+      dst[0] = A*src[0] + B*src[1];\n+      dst[1] = A*src[1] + B*src[2];\n+      dst[2] = A*src[2] + B*src[3];\n+      dst[3] = A*src[3] + B*src[4];\n+      dst[4] = A*src[4] + B*src[5];\n+      dst[5] = A*src[5] + B*src[6];\n+      dst[6] = A*src[6] + B*src[7];\n+      dst[7] = A*src[7] + B*src[8];\n+      dst += stride;\n+      src += stride;\n+      if (dummy == 32)\n+        abort ();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+       dst[i] = 0;\n+       src[i] = i;\n+    }\n+\n+  foo (dst, src, N, 8, 0);\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (dst[i] != A * src[i] + B * src[i+1])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { target { vect_int_mult &&  vect_element_align } } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+"}, {"sha": "4fdc854db9c2e723a7ce5ee24f80db087eba7f41", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 147, "deletions": 34, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "patch": "@@ -116,13 +116,15 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n-  tree def;\n+  tree def[2];\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   stmt_vec_info stmt_info =\n     vinfo_for_stmt (VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0));\n   enum gimple_rhs_class rhs_class;\n   struct loop *loop = NULL;\n+  enum tree_code rhs_code;\n+  bool different_types = false;\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -134,7 +136,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     {\n       oprnd = gimple_op (stmt, i + 1);\n \n-      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def,\n+      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def[i],\n                                &dt[i])\n \t  || (!def_stmt && dt[i] != vect_constant_def))\n \t{\n@@ -189,11 +191,11 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           switch (gimple_code (def_stmt))\n             {\n               case GIMPLE_PHI:\n-                def = gimple_phi_result (def_stmt);\n+                def[i] = gimple_phi_result (def_stmt);\n                 break;\n \n               case GIMPLE_ASSIGN:\n-                def = gimple_assign_lhs (def_stmt);\n+                def[i] = gimple_assign_lhs (def_stmt);\n                 break;\n \n               default:\n@@ -207,8 +209,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t{\n \t  /* op0 of the first stmt of the group - store its info.  */\n \t  *first_stmt_dt0 = dt[i];\n-\t  if (def)\n-\t    *first_stmt_def0_type = TREE_TYPE (def);\n+\t  if (def[i])\n+\t    *first_stmt_def0_type = TREE_TYPE (def[i]);\n \t  else\n \t    *first_stmt_const_oprnd = oprnd;\n \n@@ -228,8 +230,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      /* op1 of the first stmt of the group - store its info.  */\n \t      *first_stmt_dt1 = dt[i];\n-\t      if (def)\n-\t\t*first_stmt_def1_type = TREE_TYPE (def);\n+\t      if (def[i])\n+\t\t*first_stmt_def1_type = TREE_TYPE (def[i]);\n \t      else\n \t\t{\n \t\t  /* We assume that the stmt contains only one constant\n@@ -255,24 +257,56 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t   && ((*first_stmt_dt0 != dt[i]\n                         && !(*first_stmt_dt0 == vect_reduction_def\n                              && dt[i] == vect_internal_def))\n-\t\t       || (*first_stmt_def0_type && def\n+\t\t       || (*first_stmt_def0_type && def[0]\n \t\t\t   && !types_compatible_p (*first_stmt_def0_type,\n-\t\t\t\t\t\t   TREE_TYPE (def)))))\n+\t\t\t\t\t\t   TREE_TYPE (def[0])))))\n \t\t  || (i == 1\n \t\t      && ((*first_stmt_dt1 != dt[i]\n                            && !(*first_stmt_dt1 == vect_reduction_def\n                                 && dt[i] == vect_internal_def))\n-\t\t\t  || (*first_stmt_def1_type && def\n+\t\t\t  || (*first_stmt_def1_type && def[1]\n \t\t\t      && !types_compatible_p (*first_stmt_def1_type,\n-\t\t\t\t\t\t      TREE_TYPE (def)))))\n-\t\t  || (!def\n+\t\t\t\t\t\t      TREE_TYPE (def[1])))))\n+\t\t  || (!def[i]\n \t\t      && !types_compatible_p (TREE_TYPE (*first_stmt_const_oprnd),\n-\t\t\t\t\t      TREE_TYPE (oprnd))))\n+\t\t\t\t\t      TREE_TYPE (oprnd)))\n+\t\t  || different_types)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_SLP))\n-\t\t    fprintf (vect_dump, \"Build SLP failed: different types \");\n+                  if (i != number_of_oprnds - 1)\n+                    different_types = true;\n+                  else\n+\t            {\n+                      if (is_gimple_assign (stmt)\n+                          && (rhs_code = gimple_assign_rhs_code (stmt))\n+ \t\t          && TREE_CODE_CLASS (rhs_code) == tcc_binary\n+\t\t\t  && commutative_tree_code (rhs_code)\n+\t\t\t  && *first_stmt_dt0 == dt[1]\n+\t\t\t  && *first_stmt_dt1 == dt[0]\n+\t\t\t  && def[0] && def[1]\n+\t\t\t  && !(*first_stmt_def0_type\n+\t\t\t       && !types_compatible_p (*first_stmt_def0_type,\n+\t\t\t                               TREE_TYPE (def[1])))\n+                          && !(*first_stmt_def1_type\n+                               && !types_compatible_p (*first_stmt_def1_type,\n+                                                       TREE_TYPE (def[0]))))\n+                        {\n+                           if (vect_print_dump_info (REPORT_SLP))\n+\t                     {\n+\t\t\t       fprintf (vect_dump, \"Swapping operands of \");\n+ \t\t               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t\t     }\n+\n+ \t\t\t   swap_tree_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n+ \t                                      gimple_assign_rhs2_ptr (stmt));\n+\t\t\t}\n+                      else\n+                        {\n+         \t\t  if (vect_print_dump_info (REPORT_SLP))\n+\t        \t    fprintf (vect_dump, \"Build SLP failed: different types \");\n \n-\t\t  return false;\n+\t\t          return false;\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -286,18 +320,18 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \tcase vect_internal_def:\n         case vect_reduction_def:\n-\t  if (i == 0)\n+\t  if ((i == 0 && !different_types) || (i == 1 && different_types))\n \t    VEC_safe_push (gimple, heap, *def_stmts0, def_stmt);\n \t  else\n-\t    VEC_safe_push (gimple, heap, *def_stmts1, def_stmt);\n+ \t    VEC_safe_push (gimple, heap, *def_stmts1, def_stmt);\n \t  break;\n \n \tdefault:\n \t  /* FORNOW: Not supported.  */\n \t  if (vect_print_dump_info (REPORT_SLP))\n \t    {\n \t      fprintf (vect_dump, \"Build SLP failed: illegal type of def \");\n-\t      print_generic_expr (vect_dump, def, TDF_SLIM);\n+\t      print_generic_expr (vect_dump, def[i], TDF_SLIM);\n \t    }\n \n \t  return false;\n@@ -320,7 +354,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      int ncopies_for_cost, unsigned int *max_nunits,\n                      VEC (int, heap) **load_permutation,\n                      VEC (slp_tree, heap) **loads,\n-                     unsigned int vectorization_factor)\n+                     unsigned int vectorization_factor, bool *loads_permuted)\n {\n   VEC (gimple, heap) *def_stmts0 = VEC_alloc (gimple, heap, group_size);\n   VEC (gimple, heap) *def_stmts1 =  VEC_alloc (gimple, heap, group_size);\n@@ -531,7 +565,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n               /* Check that the size of interleaved loads group is not\n                  greater than the SLP group size.  */\n-              if (GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n+              if (loop_vinfo\n+                  && GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n                 {\n                   if (vect_print_dump_info (REPORT_SLP))\n                     {\n@@ -652,19 +687,22 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Strided loads were reached - stop the recursion.  */\n   if (stop_recursion)\n     {\n+      VEC_safe_push (slp_tree, heap, *loads, *node);\n       if (permutation)\n         {\n-          VEC_safe_push (slp_tree, heap, *loads, *node);\n+\n+          *loads_permuted = true;\n           *inside_cost \n             += targetm.vectorize.builtin_vectorization_cost (vec_perm, NULL, 0) \n                * group_size;\n         }\n       else\n-        { \n-          /* We don't check here complex numbers chains, so we keep them in\n-\t     LOADS for further check in vect_supported_load_permutation_p.  */ \n+        {\n+          /* We don't check here complex numbers chains, so we set\n+             LOADS_PERMUTED for further check in\n+             vect_supported_load_permutation_p.  */\n           if (rhs_code == REALPART_EXPR || rhs_code == IMAGPART_EXPR)\n-            VEC_safe_push (slp_tree, heap, *loads, *node);\n+            *loads_permuted = true;\n         }\n \n       return true;\n@@ -683,7 +721,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &left_node, group_size,\n \t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n \t\t\t\tmax_nunits, load_permutation, loads,\n-\t\t\t\tvectorization_factor))\n+\t\t\t\tvectorization_factor, loads_permuted))\n \treturn false;\n \n       SLP_TREE_LEFT (*node) = left_node;\n@@ -701,7 +739,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &right_node, group_size,\n \t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n \t\t\t\tmax_nunits, load_permutation, loads,\n-\t\t\t\tvectorization_factor))\n+\t\t\t\tvectorization_factor, loads_permuted))\n \treturn false;\n \n       SLP_TREE_RIGHT (*node) = right_node;\n@@ -887,8 +925,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   bool supported, bad_permutation = false;\n   sbitmap load_index;\n   slp_tree node, other_complex_node;\n-  gimple stmt, first = NULL, other_node_first;\n+  gimple stmt, first = NULL, other_node_first, load, next_load, first_load;\n   unsigned complex_numbers = 0;\n+  struct data_reference *dr;\n+  bb_vec_info bb_vinfo;\n \n   /* FORNOW: permutations are only supported in SLP.  */\n   if (!slp_instn)\n@@ -1050,6 +1090,76 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n         }\n     }\n \n+  /* In basic block vectorization we allow any subchain of an interleaving\n+     chain.\n+     FORNOW: not supported in loop SLP because of realignment compications.  */\n+  bb_vinfo = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n+  bad_permutation = false;\n+  /* Check that for every node in the instance teh loads form a subchain.  */\n+  if (bb_vinfo)\n+    {\n+      FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node)\n+        {\n+          next_load = NULL;\n+          first_load = NULL;\n+          FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), j, load)\n+            {\n+              if (!first_load)\n+                first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (load));\n+              else if (first_load\n+                         != GROUP_FIRST_ELEMENT (vinfo_for_stmt (load)))\n+                {\n+                  bad_permutation = true;\n+\t          break;\n+\t        }\n+\n+              if (j != 0 && next_load != load)\n+                {\n+                  bad_permutation = true;\n+                  break;\n+                }\n+\n+              next_load = GROUP_NEXT_ELEMENT (vinfo_for_stmt (load));\n+            }\n+\n+          if (bad_permutation)\n+            break;\n+        }\n+\n+      /* Check that the alignment of the first load in every subchain, i.e.,\n+         the first statement in every load node, is supported.  */\n+      if (!bad_permutation)\n+        {\n+          FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node)\n+            {\n+              first_load = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n+              if (first_load\n+                    != GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_load)))\n+                {\n+                  dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_load));\n+                  if (vect_supportable_dr_alignment (dr, false)\n+ \t               == dr_unaligned_unsupported)\n+                    {\n+   \t\t      if (vect_print_dump_info (REPORT_SLP))\n+\t\t        {\n+  \t                  fprintf (vect_dump, \"unsupported unaligned load \");\n+                          print_gimple_stmt (vect_dump, first_load, 0,\n+\t\t\t\t\t     TDF_SLIM);\n+                        }\n+  \t\t      bad_permutation = true;\n+                      break;\n+                    }\n+\t        }\n+            }\n+\n+          if (!bad_permutation)\n+            {\n+              VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (slp_instn));\n+              return true;\n+    \t    }\n+        }\n+    }\n+\n   /* FORNOW: the only supported permutation is 0..01..1.. of length equal to\n      GROUP_SIZE and where each sequence of same drs is of GROUP_SIZE length as\n      well (unless it's reduction).  */\n@@ -1159,6 +1269,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   VEC (int, heap) *load_permutation;\n   VEC (slp_tree, heap) *loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n+  bool loads_permuted = false;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n@@ -1250,7 +1361,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n                            &inside_cost, &outside_cost, ncopies_for_cost,\n \t\t\t   &max_nunits, &load_permutation, &loads,\n-\t\t\t   vectorization_factor))\n+\t\t\t   vectorization_factor, &loads_permuted))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1275,7 +1386,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n       SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n       SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n-      if (VEC_length (slp_tree, loads))\n+\n+      if (loads_permuted)\n         {\n           if (!vect_supported_load_permutation_p (new_instance, group_size,\n                                                   load_permutation))\n@@ -2567,10 +2679,11 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   /* Loads should be inserted before the first load.  */\n   if (SLP_INSTANCE_FIRST_LOAD_STMT (instance)\n       && STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-      && !REFERENCE_CLASS_P (gimple_get_lhs (stmt)))\n+      && !REFERENCE_CLASS_P (gimple_get_lhs (stmt))\n+      && SLP_INSTANCE_LOAD_PERMUTATION (instance))\n     si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n   else if (is_pattern_stmt_p (stmt_info))\n-     si = gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+    si = gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n   else\n     si = gsi_for_stmt (stmt);\n "}, {"sha": "0df3c0c412eeaf0fc8c8a670ae334e91f8b05538", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6aa904c4c64f9cb0673323d4eb5bbc70bd47bfb4", "patch": "@@ -4241,6 +4241,11 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (strided_load)\n     {\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      if (slp\n+          && !SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance)\n+\t  && first_stmt != VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0))\n+        first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n+\n       /* Check if the chain of loads is already vectorized.  */\n       if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt)))\n \t{"}]}