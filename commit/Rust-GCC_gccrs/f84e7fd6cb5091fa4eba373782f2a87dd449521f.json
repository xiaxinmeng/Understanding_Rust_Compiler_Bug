{"sha": "f84e7fd6cb5091fa4eba373782f2a87dd449521f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg0ZTdmZDZjYjUwOTFmYTRlYmEzNzM3ODJmMmE4N2RkNDQ5NTIxZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-13T13:58:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-13T13:58:59Z"}, "message": "match.pd: Add tcc_comparison...\n\n2014-11-13  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Add tcc_comparison, inverted_tcc_comparison\n\tand inverted_tcc_comparison_with_nans operator lists.\n\tUse tcc_comparison in the truth_valued_p predicate definition.\n\tRestrict logical_inverted_value with bit_xor to integral types.\n\tBuild a boolean true for simplifying x |^ !x because of\n\tvector types.  Implement patterns from forward_propagate_comparison\n\t* tree-ssa-forwprop.c (forward_propagate_comparison): Remove.\n\t(get_prop_dest_stmt): Likewise.\n\t(pass_forwprop::execute): Do not call it.\n\t* fold-const.c (fold_unary_loc): Remove the pattern here.\n\n\t* gcc.dg/tree-ssa/forwprop-28.c: Adjust.\n\nFrom-SVN: r217496", "tree": {"sha": "b84b11303968c5b98e08de3b9e43e7f0e574316c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b84b11303968c5b98e08de3b9e43e7f0e574316c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f84e7fd6cb5091fa4eba373782f2a87dd449521f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84e7fd6cb5091fa4eba373782f2a87dd449521f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84e7fd6cb5091fa4eba373782f2a87dd449521f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84e7fd6cb5091fa4eba373782f2a87dd449521f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8"}], "stats": {"total": 211, "additions": 74, "deletions": 137}, "files": [{"sha": "0d2f4db5362ebdce6d00d9041ff1047b411fdef2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -1,3 +1,16 @@\n+2014-11-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Add tcc_comparison, inverted_tcc_comparison\n+\tand inverted_tcc_comparison_with_nans operator lists.\n+\tUse tcc_comparison in the truth_valued_p predicate definition.\n+\tRestrict logical_inverted_value with bit_xor to integral types.\n+\tBuild a boolean true for simplifying x |^ !x because of\n+\tvector types.  Implement patterns from forward_propagate_comparison\n+\t* tree-ssa-forwprop.c (forward_propagate_comparison): Remove.\n+\t(get_prop_dest_stmt): Likewise.\n+\t(pass_forwprop::execute): Do not call it.\n+\t* fold-const.c (fold_unary_loc): Remove the pattern here.\n+\n 2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n \t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n "}, {"sha": "e51abee590c6e532895bc11cc60bd2cfe0e6f18a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -7938,18 +7938,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  if (i == count)\n \t    return build_vector (type, elements);\n \t}\n-      else if (COMPARISON_CLASS_P (arg0)\n-\t       && (VECTOR_TYPE_P (type)\n-\t\t   || (INTEGRAL_TYPE_P (type) && TYPE_PRECISION (type) == 1)))\n-\t{\n-\t  tree op_type = TREE_TYPE (TREE_OPERAND (arg0, 0));\n-\t  enum tree_code subcode = invert_tree_comparison (TREE_CODE (arg0),\n-\t\t\t\t     HONOR_NANS (TYPE_MODE (op_type)));\n-\t  if (subcode != ERROR_MARK)\n-\t    return build2_loc (loc, subcode, type, TREE_OPERAND (arg0, 0),\n-\t\t\t       TREE_OPERAND (arg0, 1));\n-\t}\n-\n \n       return NULL_TREE;\n "}, {"sha": "6231d4787f4345661ce31654549896cf70cf996b", "filename": "gcc/match.pd", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -31,6 +31,14 @@ along with GCC; see the file COPYING3.  If not see\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p)\n \n+/* Operator lists.  */\n+(define_operator_list tcc_comparison\n+  lt   le   eq ne ge   gt   unordered ordered   unlt unle ungt unge uneq ltgt)\n+(define_operator_list inverted_tcc_comparison\n+  ge   gt   ne eq lt   le   ordered   unordered ge   gt   le   lt   ltgt uneq)\n+(define_operator_list inverted_tcc_comparison_with_nans\n+  unge ungt ne eq unlt unle ordered   unordered ge   gt   le   lt   ltgt uneq)\n+\n \n /* Simplifications of operations with one constant operand and\n    simplifications to constants or single values.  */\n@@ -172,7 +180,7 @@ along with GCC; see the file COPYING3.  If not see\n (match truth_valued_p\n  @0\n  (if (INTEGRAL_TYPE_P (type) && TYPE_PRECISION (type) == 1)))\n-(for op (lt le eq ne ge gt truth_and truth_andif truth_or truth_orif truth_xor)\n+(for op (tcc_comparison truth_and truth_andif truth_or truth_orif truth_xor)\n  (match truth_valued_p\n   (op @0 @1)))\n (match truth_valued_p\n@@ -187,7 +195,8 @@ along with GCC; see the file COPYING3.  If not see\n  (ne truth_valued_p@0 integer_onep)\n  (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n (match (logical_inverted_value @0)\n- (bit_xor truth_valued_p@0 integer_onep))\n+ (bit_xor truth_valued_p@0 integer_onep)\n+ (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n \n /* X & !X -> 0.  */\n (simplify\n@@ -197,7 +206,7 @@ along with GCC; see the file COPYING3.  If not see\n (for op (bit_ior bit_xor)\n  (simplify\n   (op:c truth_valued_p@0 (logical_inverted_value @0))\n-  { build_one_cst (type); }))\n+  { constant_boolean_node (true, type); }))\n \n (for bitop (bit_and bit_ior)\n      rbitop (bit_ior bit_and)\n@@ -632,3 +641,42 @@ along with GCC; see the file COPYING3.  If not see\n (simplify\n  (cond (logical_inverted_value truth_valued_p@0) @1 @2)\n  (cond @0 @2 @1))\n+\n+\n+/* Simplifications of comparisons.  */\n+\n+/* We can simplify a logical negation of a comparison to the\n+   inverted comparison.  As we cannot compute an expression\n+   operator using invert_tree_comparison we have to simulate\n+   that with expression code iteration.  */\n+(for cmp (tcc_comparison)\n+     icmp (inverted_tcc_comparison)\n+     ncmp (inverted_tcc_comparison_with_nans)\n+ /* Ideally we'd like to combine the following two patterns\n+    and handle some more cases by using\n+      (logical_inverted_value (cmp @0 @1))\n+    here but for that genmatch would need to \"inline\" that.\n+    For now implement what forward_propagate_comparison did.  */\n+ (simplify\n+  (bit_not (cmp @0 @1))\n+  (if (VECTOR_TYPE_P (type)\n+       || (INTEGRAL_TYPE_P (type) && TYPE_PRECISION (type) == 1))\n+   /* Comparison inversion may be impossible for trapping math,\n+      invert_tree_comparison will tell us.  But we can't use\n+      a computed operator in the replacement tree thus we have\n+      to play the trick below.  */\n+   (with { enum tree_code ic = invert_tree_comparison\n+             (cmp, HONOR_NANS (TYPE_MODE (TREE_TYPE (@0)))); }\n+    (if (ic == icmp)\n+     (icmp @0 @1))\n+    (if (ic == ncmp)\n+     (ncmp @0 @1)))))\n+ (simplify\n+  (bit_xor (cmp @0 @1) integer_onep)\n+  (if (INTEGRAL_TYPE_P (type))\n+   (with { enum tree_code ic = invert_tree_comparison\n+             (cmp, HONOR_NANS (TYPE_MODE (TREE_TYPE (@0)))); }\n+    (if (ic == icmp)\n+     (icmp @0 @1))\n+    (if (ic == ncmp)\n+     (ncmp @0 @1))))))"}, {"sha": "279c1b4a57495b49eec5d3aba748720ea18e0003", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -1,3 +1,7 @@\n+2014-11-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/forwprop-28.c: Adjust.\n+\n 2014-11-12  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \n \t* lib/target-supports.exp (error_h): New check."}, {"sha": "1824131086ac71f5e409d0756e81810b2649a87d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-28.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -79,6 +79,11 @@ test_8 (int code)\n     oof ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"simplified to if \\\\\\(\\[^ ]* <\" 8 \"forwprop1\"} } */\n+/* ???  This used to check for 8 times transforming the combined conditional\n+   to a ordered compare.  But the transform does not trigger if we transform\n+   the negated code == 22 compare to code != 22 first.  It turns out if\n+   we do that we even generate better code on x86 at least.  */\n+\n+/* { dg-final { scan-tree-dump-times \"simplified to if \\\\\\(\\[^ ]* <\" 4 \"forwprop1\"} } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n "}, {"sha": "d42dcf891a94927b4725eab8ba11f944fed29ba8", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84e7fd6cb5091fa4eba373782f2a87dd449521f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=f84e7fd6cb5091fa4eba373782f2a87dd449521f", "patch": "@@ -233,38 +233,6 @@ fwprop_invalidate_lattice (tree name)\n }\n \n \n-/* Get the next statement we can propagate NAME's value into skipping\n-   trivial copies.  Returns the statement that is suitable as a\n-   propagation destination or NULL_TREE if there is no such one.\n-   This only returns destinations in a single-use chain.  FINAL_NAME_P\n-   if non-NULL is written to the ssa name that represents the use.  */\n-\n-static gimple\n-get_prop_dest_stmt (tree name, tree *final_name_p)\n-{\n-  use_operand_p use;\n-  gimple use_stmt;\n-\n-  do {\n-    /* If name has multiple uses, bail out.  */\n-    if (!single_imm_use (name, &use, &use_stmt))\n-      return NULL;\n-\n-    /* If this is not a trivial copy, we found it.  */\n-    if (!gimple_assign_ssa_name_copy_p (use_stmt)\n-\t|| gimple_assign_rhs1 (use_stmt) != name)\n-      break;\n-\n-    /* Continue searching uses of the copy destination.  */\n-    name = gimple_assign_lhs (use_stmt);\n-  } while (1);\n-\n-  if (final_name_p)\n-    *final_name_p = name;\n-\n-  return use_stmt;\n-}\n-\n /* Get the statement we can propagate from into NAME skipping\n    trivial copies.  Returns the statement which defines the\n    propagation source or NULL_TREE if there is no such one.\n@@ -1060,90 +1028,6 @@ forward_propagate_addr_expr (tree name, tree rhs, bool parent_single_use_p)\n }\n \n \n-/* Forward propagate the comparison defined in *DEFGSI like\n-   cond_1 = x CMP y to uses of the form\n-     a_1 = (T')cond_1\n-     a_1 = !cond_1\n-     a_1 = cond_1 != 0\n-   Returns true if stmt is now unused.  Advance DEFGSI to the next\n-   statement.  */\n-\n-static bool\n-forward_propagate_comparison (gimple_stmt_iterator *defgsi)\n-{\n-  gimple stmt = gsi_stmt (*defgsi);\n-  tree name = gimple_assign_lhs (stmt);\n-  gimple use_stmt;\n-  tree tmp = NULL_TREE;\n-  gimple_stmt_iterator gsi;\n-  enum tree_code code;\n-  tree lhs;\n-\n-  /* Don't propagate ssa names that occur in abnormal phis.  */\n-  if ((TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n-      || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n-        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n-    goto bailout;\n-\n-  /* Do not un-cse comparisons.  But propagate through copies.  */\n-  use_stmt = get_prop_dest_stmt (name, &name);\n-  if (!use_stmt\n-      || !is_gimple_assign (use_stmt))\n-    goto bailout;\n-\n-  code = gimple_assign_rhs_code (use_stmt);\n-  lhs = gimple_assign_lhs (use_stmt);\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-    goto bailout;\n-\n-  /* We can propagate the condition into a statement that\n-     computes the logical negation of the comparison result.  */\n-  if ((code == BIT_NOT_EXPR\n-       && TYPE_PRECISION (TREE_TYPE (lhs)) == 1)\n-      || (code == BIT_XOR_EXPR\n-\t  && integer_onep (gimple_assign_rhs2 (use_stmt))))\n-    {\n-      tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-      bool nans = HONOR_NANS (TYPE_MODE (type));\n-      enum tree_code inv_code;\n-      inv_code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n-      if (inv_code == ERROR_MARK)\n-\tgoto bailout;\n-\n-      tmp = build2 (inv_code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n-\t\t    gimple_assign_rhs2 (stmt));\n-    }\n-  else\n-    goto bailout;\n-\n-  gsi = gsi_for_stmt (use_stmt);\n-  gimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n-  use_stmt = gsi_stmt (gsi);\n-  update_stmt (use_stmt);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"  Replaced '\");\n-      print_gimple_expr (dump_file, stmt, 0, dump_flags);\n-      fprintf (dump_file, \"' with '\");\n-      print_gimple_expr (dump_file, use_stmt, 0, dump_flags);\n-      fprintf (dump_file, \"'\\n\");\n-    }\n-\n-  /* When we remove stmt now the iterator defgsi goes off it's current\n-     sequence, hence advance it now.  */\n-  gsi_next (defgsi);\n-\n-  /* Remove defining statements.  */\n-  return remove_prop_source_from_use (name);\n-\n-bailout:\n-  gsi_next (defgsi);\n-  return false;\n-}\n-\n-\n /* Helper function for simplify_gimple_switch.  Remove case labels that\n    have values outside the range of the new type.  */\n \n@@ -2316,11 +2200,6 @@ pass_forwprop::execute (function *fun)\n \t      else\n \t\tgsi_next (&gsi);\n \t    }\n-\t  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t    {\n-\t      if (forward_propagate_comparison (&gsi))\n-\t\tcfg_changed = true;\n-\t    }\n \t  else\n \t    gsi_next (&gsi);\n \t}"}]}