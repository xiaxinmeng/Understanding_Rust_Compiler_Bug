{"sha": "cfa658e4f8da804086f3076f907fcc98604bbf0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZhNjU4ZTRmOGRhODA0MDg2ZjMwNzZmOTA3ZmNjOTg2MDRiYmYwZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-11-16T18:20:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-11-16T18:20:33Z"}, "message": "backtrace.h (backtrace_syminfo): Update comment and parameter name to take any address, not just a PC value.\n\n\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n\tname to take any address, not just a PC value.\n\t* elf.c (STT_OBJECT): Define.\n\t(elf_nosyms): Rename parameter pc to addr.\n\t(elf_symbol_search): Rename local variable pc to addr.\n\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n\t(elf_syminfo): Rename parameter pc to addr.\n\t* btest.c (global): New global variable.\n\t(test5): New test.\n\t(main): Call test5.\n\nFrom-SVN: r204904", "tree": {"sha": "72f7254511f0fff93ad456661a8f4146957fca1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72f7254511f0fff93ad456661a8f4146957fca1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfa658e4f8da804086f3076f907fcc98604bbf0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa658e4f8da804086f3076f907fcc98604bbf0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfa658e4f8da804086f3076f907fcc98604bbf0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa658e4f8da804086f3076f907fcc98604bbf0d/comments", "author": null, "committer": null, "parents": [{"sha": "b032ec0d5039e2dcd878ab82d74e3a79e94687d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b032ec0d5039e2dcd878ab82d74e3a79e94687d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b032ec0d5039e2dcd878ab82d74e3a79e94687d5"}], "stats": {"total": 119, "additions": 94, "deletions": 25}, "files": [{"sha": "964efd629b796676b36cb653870674371e6f827e", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=cfa658e4f8da804086f3076f907fcc98604bbf0d", "patch": "@@ -1,3 +1,16 @@\n+2013-11-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n+\tname to take any address, not just a PC value.\n+\t* elf.c (STT_OBJECT): Define.\n+\t(elf_nosyms): Rename parameter pc to addr.\n+\t(elf_symbol_search): Rename local variable pc to addr.\n+\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n+\t(elf_syminfo): Rename parameter pc to addr.\n+\t* btest.c (global): New global variable.\n+\t(test5): New test.\n+\t(main): Call test5.\n+\n 2013-10-17  Ian Lance Taylor  <iant@google.com>\n \n \t* elf.c (elf_add): Don't get the wrong offsets if a debug section"}, {"sha": "ef99baf85eb59904bebed5ceed839180ab951e13", "filename": "libbacktrace/backtrace.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace.h?ref=cfa658e4f8da804086f3076f907fcc98604bbf0d", "patch": "@@ -177,17 +177,17 @@ typedef void (*backtrace_syminfo_callback) (void *data, uintptr_t pc,\n \t\t\t\t\t    const char *symname,\n \t\t\t\t\t    uintptr_t symval);\n \n-/* Given PC, a program counter in the current program, call the\n-   callback information with the symbol name and value describing the\n-   function in which PC may be found.  This will call either CALLBACK\n-   or ERROR_CALLBACK exactly once.  This returns 1 on success, 0 on\n-   failure.  This function requires the symbol table but does not\n-   require the debug info.  Note that if the symbol table is present\n-   but PC could not be found in the table, CALLBACK will be called\n-   with a NULL SYMNAME argument.  Returns 1 on success, 0 on\n-   error.  */\n-\n-extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n+/* Given ADDR, an address or program counter in the current program,\n+   call the callback information with the symbol name and value\n+   describing the function or variable in which ADDR may be found.\n+   This will call either CALLBACK or ERROR_CALLBACK exactly once.\n+   This returns 1 on success, 0 on failure.  This function requires\n+   the symbol table but does not require the debug info.  Note that if\n+   the symbol table is present but ADDR could not be found in the\n+   table, CALLBACK will be called with a NULL SYMNAME argument.\n+   Returns 1 on success, 0 on error.  */\n+\n+extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t addr,\n \t\t\t      backtrace_syminfo_callback callback,\n \t\t\t      backtrace_error_callback error_callback,\n \t\t\t      void *data);"}, {"sha": "c06493f341e8b2b85ec7c2b5ccbf1d59479848e1", "filename": "libbacktrace/btest.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Fbtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbtest.c?ref=cfa658e4f8da804086f3076f907fcc98604bbf0d", "patch": "@@ -598,6 +598,53 @@ f33 (int f1line, int f2line)\n   return failures;\n }\n \n+int global = 1;\n+\n+static int\n+test5 (void)\n+{\n+  struct symdata symdata;\n+  int i;\n+\n+  symdata.name = NULL;\n+  symdata.val = 0;\n+  symdata.failed = 0;\n+\n+  i = backtrace_syminfo (state, (uintptr_t) &global, callback_three,\n+\t\t\t error_callback_three, &symdata);\n+  if (i == 0)\n+    {\n+      fprintf (stderr,\n+\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n+\t       i);\n+      symdata.failed = 1;\n+    }\n+\n+  if (!symdata.failed)\n+    {\n+      if (symdata.name == NULL)\n+\t{\n+\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (strcmp (symdata.name, \"global\") != 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n+\t\t   symdata.name, \"global\");\n+\t  symdata.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_syminfo variable\\n\",\n+\t  symdata.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (symdata.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n static void\n error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n \t\t       int errnum)\n@@ -622,6 +669,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n   test2 ();\n   test3 ();\n   test4 ();\n+  test5 ();\n #endif\n \n   exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);"}, {"sha": "c58b74e192f57e90782939b9bd921edec185ecdc", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa658e4f8da804086f3076f907fcc98604bbf0d/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=cfa658e4f8da804086f3076f907fcc98604bbf0d", "patch": "@@ -101,6 +101,7 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n #undef SHT_SYMTAB\n #undef SHT_STRTAB\n #undef SHT_DYNSYM\n+#undef STT_OBJECT\n #undef STT_FUNC\n \n /* Basic types.  */\n@@ -215,6 +216,7 @@ typedef struct\n \n #endif /* BACKTRACE_ELF_SIZE != 32 */\n \n+#define STT_OBJECT 1\n #define STT_FUNC 2\n \n /* An index of ELF sections we care about.  */\n@@ -293,7 +295,7 @@ elf_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n \n static void\n elf_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t    uintptr_t pc ATTRIBUTE_UNUSED,\n+\t    uintptr_t addr ATTRIBUTE_UNUSED,\n \t    backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n \t    backtrace_error_callback error_callback, void *data)\n {\n@@ -316,7 +318,7 @@ elf_symbol_compare (const void *v1, const void *v2)\n     return 0;\n }\n \n-/* Compare a PC against an elf_symbol for bsearch.  We allocate one\n+/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n    extra entry in the array so that this can look safely at the next\n    entry.  */\n \n@@ -325,12 +327,12 @@ elf_symbol_search (const void *vkey, const void *ventry)\n {\n   const uintptr_t *key = (const uintptr_t *) vkey;\n   const struct elf_symbol *entry = (const struct elf_symbol *) ventry;\n-  uintptr_t pc;\n+  uintptr_t addr;\n \n-  pc = *key;\n-  if (pc < entry->address)\n+  addr = *key;\n+  if (addr < entry->address)\n     return -1;\n-  else if (pc >= entry->address + entry->size)\n+  else if (addr >= entry->address + entry->size)\n     return 1;\n   else\n     return 0;\n@@ -360,7 +362,10 @@ elf_initialize_syminfo (struct backtrace_state *state,\n   elf_symbol_count = 0;\n   for (i = 0; i < sym_count; ++i, ++sym)\n     {\n-      if ((sym->st_info & 0xf) == STT_FUNC)\n+      int info;\n+\n+      info = sym->st_info & 0xf;\n+      if (info == STT_FUNC || info == STT_OBJECT)\n \t++elf_symbol_count;\n     }\n \n@@ -375,7 +380,10 @@ elf_initialize_syminfo (struct backtrace_state *state,\n   j = 0;\n   for (i = 0; i < sym_count; ++i, ++sym)\n     {\n-      if ((sym->st_info & 0xf) != STT_FUNC)\n+      int info;\n+\n+      info = sym->st_info & 0xf;\n+      if (info != STT_FUNC && info != STT_OBJECT)\n \tcontinue;\n       if (sym->st_name >= strtab_size)\n \t{\n@@ -445,10 +453,10 @@ elf_add_syminfo_data (struct backtrace_state *state,\n     }\n }\n \n-/* Return the symbol name and value for a PC.  */\n+/* Return the symbol name and value for an ADDR.  */\n \n static void\n-elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n+elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n \t     backtrace_syminfo_callback callback,\n \t     backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n \t     void *data)\n@@ -463,7 +471,7 @@ elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n \t   edata = edata->next)\n \t{\n \t  sym = ((struct elf_symbol *)\n-\t\t bsearch (&pc, edata->symbols, edata->count,\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n \t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n \t  if (sym != NULL)\n \t    break;\n@@ -485,7 +493,7 @@ elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n \t    break;\n \n \t  sym = ((struct elf_symbol *)\n-\t\t bsearch (&pc, edata->symbols, edata->count,\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n \t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n \t  if (sym != NULL)\n \t    break;\n@@ -495,9 +503,9 @@ elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n     }\n \n   if (sym == NULL)\n-    callback (data, pc, NULL, 0);\n+    callback (data, addr, NULL, 0);\n   else\n-    callback (data, pc, sym->name, sym->address);\n+    callback (data, addr, sym->name, sym->address);\n }\n \n /* Add the backtrace data for one ELF file.  */"}]}