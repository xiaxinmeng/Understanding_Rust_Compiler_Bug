{"sha": "e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkOTJjZWNmYjJmYTE4OWVlOTU4ZWE0NTc0ZmZkOGExMTA5YTAyMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-02T04:33:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-02T04:33:51Z"}, "message": "parser.c (cp_parser_lambda_expression): Compute visibility.\n\n\t* parser.c (cp_parser_lambda_expression): Compute visibility.\n\t(no_linkage_lambda_type_p): Remove.\n\t* cp-tree.h: Remove declaration.\n\t* tree.c (no_linkage_check): Don't call it.  Don't check template\n\targs.  Don't check TREE_PUBLIC Types.\n\nFrom-SVN: r152395", "tree": {"sha": "20f31807b8adb84491c6a5380e4bfe0b7845abf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20f31807b8adb84491c6a5380e4bfe0b7845abf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e70c271ec0d77772ffa04b7985d1599f064e963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e70c271ec0d77772ffa04b7985d1599f064e963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e70c271ec0d77772ffa04b7985d1599f064e963"}], "stats": {"total": 88, "additions": 33, "deletions": 55}, "files": [{"sha": "269773532fbc990cbe7c6f595c5a611fb1a939a3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "patch": "@@ -1,3 +1,11 @@\n+2009-10-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* parser.c (cp_parser_lambda_expression): Compute visibility.\n+\t(no_linkage_lambda_type_p): Remove.\n+\t* cp-tree.h: Remove declaration.\n+\t* tree.c (no_linkage_check): Don't call it.  Don't check template\n+\targs.  Don't check TREE_PUBLIC Types.\n+\n 2009-10-01  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n \t    Jason Merrill <jason@redhat.com>\n "}, {"sha": "fc00176c276235b95a807b2d5f9105ce637fb6b6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "patch": "@@ -5303,9 +5303,6 @@ extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n extern void cxx_omp_finish_clause\t\t(tree);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n \n-/* in parser.c */\n-extern bool no_linkage_lambda_type_p\t\t(tree);\n-\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "210d3dda0e0eff32e31beee04cfdec5005236bbb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "patch": "@@ -7005,31 +7005,6 @@ finish_lambda_scope (void)\n   VEC_pop (tree_int, lambda_scope_stack);\n }\n \n-/* We want to determine the linkage of a lambda type at pushtag time,\n-   before CLASSTYPE_LAMBDA_EXPR has been set.  So this callback allows us\n-   to find out whether the current lambda mangling scope will give us\n-   linkage or not.  */\n-\n-bool\n-no_linkage_lambda_type_p (tree type)\n-{\n-  tree lambda, scope;\n-  if (!LAMBDA_TYPE_P (type))\n-    return false;\n-\n-  lambda = CLASSTYPE_LAMBDA_EXPR (type);\n-  if (lambda)\n-    scope = LAMBDA_EXPR_EXTRA_SCOPE (lambda);\n-  else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-    /* We can't use lambda_scope, and CLASSTYPE_TEMPLATE_INFO won't be set\n-       yet either, so guess it's public for now.  */\n-    return false;\n-  else\n-    scope = lambda_scope;\n-\n-  return (scope == NULL_TREE);\n-}\n-\n /* Parse a lambda expression.\n \n    lambda-expression:\n@@ -7054,6 +7029,9 @@ cp_parser_lambda_expression (cp_parser* parser)\n \n   record_lambda_scope (lambda_expr);\n \n+  /* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n+  determine_visibility (TYPE_NAME (type));\n+\n   {\n     /* Inside the class, surrounding template-parameter-lists do not apply.  */\n     unsigned int saved_num_template_parameter_lists"}, {"sha": "1cd2bf596f8b7fd91b3a508491867de47ce8b6d9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d92cecfb2fa189ee958ea4574ffd8a1109a022/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e6d92cecfb2fa189ee958ea4574ffd8a1109a022", "patch": "@@ -1556,46 +1556,41 @@ no_linkage_check (tree t, bool relaxed_p)\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \tgoto ptrmem;\n+      /* Lambda types that don't have mangling scope have no linkage.  We\n+\t check CLASSTYPE_LAMBDA_EXPR here rather than LAMBDA_TYPE_P because\n+\t when we get here from pushtag none of the lambda information is\n+\t set up yet, so we want to assume that the lambda has linkage and\n+\t fix it up later if not.  */\n+      if (CLASSTYPE_LAMBDA_EXPR (t)\n+\t  && LAMBDA_TYPE_EXTRA_SCOPE (t) == NULL_TREE)\n+\treturn t;\n       /* Fall through.  */\n     case UNION_TYPE:\n       if (!CLASS_TYPE_P (t))\n \treturn NULL_TREE;\n-\n-      /* Check template type-arguments.  I think that types with no linkage\n-         can't occur in non-type arguments, though that might change with\n-         constexpr.  */\n-      r = CLASSTYPE_TEMPLATE_INFO (t);\n-      if (r)\n-\t{\n-\t  tree args = INNERMOST_TEMPLATE_ARGS (TI_ARGS (r));\n-\t  int i;\n-\n-\t  for (i = TREE_VEC_LENGTH (args); i-- > 0; )\n-\t    {\n-\t      tree elt = TREE_VEC_ELT (args, i);\n-\t      if (TYPE_P (elt)\n-\t\t  && (r = no_linkage_check (elt, relaxed_p), r))\n-\t\treturn r;\n-\t    }\n-\t}\n       /* Fall through.  */\n     case ENUMERAL_TYPE:\n       /* Only treat anonymous types as having no linkage if they're at\n \t namespace scope.  This doesn't have a core issue number yet.  */\n       if (TYPE_ANONYMOUS_P (t) && TYPE_NAMESPACE_SCOPE_P (t))\n \treturn t;\n-      if (no_linkage_lambda_type_p (t))\n-\treturn t;\n \n-      r = CP_TYPE_CONTEXT (t);\n-      if (TYPE_P (r))\n-\treturn no_linkage_check (TYPE_CONTEXT (t), relaxed_p);\n-      else if (TREE_CODE (r) == FUNCTION_DECL)\n+      for (r = CP_TYPE_CONTEXT (t); ; )\n \t{\n-\t  if (!relaxed_p || !TREE_PUBLIC (r) || !vague_linkage_fn_p (r))\n-\t    return t;\n+\t  /* If we're a nested type of a !TREE_PUBLIC class, we might not\n+\t     have linkage, or we might just be in an anonymous namespace.\n+\t     If we're in a TREE_PUBLIC class, we have linkage.  */\n+\t  if (TYPE_P (r) && !TREE_PUBLIC (TYPE_NAME (r)))\n+\t    return no_linkage_check (TYPE_CONTEXT (t), relaxed_p);\n+\t  else if (TREE_CODE (r) == FUNCTION_DECL)\n+\t    {\n+\t      if (!relaxed_p || !vague_linkage_fn_p (r))\n+\t\treturn t;\n+\t      else\n+\t\tr = CP_DECL_CONTEXT (r);\n+\t    }\n \t  else\n-\t    return no_linkage_check (CP_DECL_CONTEXT (r), relaxed_p);\n+\t    break;\n \t}\n \n       return NULL_TREE;"}]}