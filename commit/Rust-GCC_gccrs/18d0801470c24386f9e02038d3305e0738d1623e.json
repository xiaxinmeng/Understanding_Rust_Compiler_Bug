{"sha": "18d0801470c24386f9e02038d3305e0738d1623e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkMDgwMTQ3MGMyNDM4NmY5ZTAyMDM4ZDMzMDVlMDczOGQxNjIzZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-06-12T12:06:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-06-12T12:06:19Z"}, "message": "re PR tree-optimization/15353 ([tree-ssa] Merge two \"if\"s if one subsumes the other.)\n\n2007-06-12  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/15353\n\tPR tree-optimization/31657\n\t* passes.c (init_optimization_passes): Add pass_tree_ifcombine.\n\t* timevar.def: Add TV_TREE_IFCOMBINE.\n\t* tree-pass.h (pass_tree_ifcombine): Declare.\n\t* tree-ssa-ifcombine.c: New file.\n\t* tree-ssa-phiopt.c (blocks_in_phiopt_order): Export.\n\t* tree-flow.h (blocks_in_phiopt_order): Declare.\n\t* Makefile.in (OBJS-common): Add tree-ssa-ifcombine.o.\n\t(tree-ssa-ifcombine.o): New dependencies.\n\n\t* gcc.c-torture/execute/20070424-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-2.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-3.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-4.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ifcombine-5.c: Likewise.\n\nFrom-SVN: r125644", "tree": {"sha": "172c6441c249e7e65732e9052654b4d84a7e6b47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/172c6441c249e7e65732e9052654b4d84a7e6b47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18d0801470c24386f9e02038d3305e0738d1623e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d0801470c24386f9e02038d3305e0738d1623e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18d0801470c24386f9e02038d3305e0738d1623e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d0801470c24386f9e02038d3305e0738d1623e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f482dfebf0aaaf2e35e53ffe16834de4eb1d375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f482dfebf0aaaf2e35e53ffe16834de4eb1d375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f482dfebf0aaaf2e35e53ffe16834de4eb1d375"}], "stats": {"total": 780, "additions": 778, "deletions": 2}, "files": [{"sha": "8e212fa6ced4b1ca6d6dce29ae76f06d7be541af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -1,3 +1,16 @@\n+2007-06-12  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15353\n+\tPR tree-optimization/31657\n+\t* passes.c (init_optimization_passes): Add pass_tree_ifcombine.\n+\t* timevar.def: Add TV_TREE_IFCOMBINE.\n+\t* tree-pass.h (pass_tree_ifcombine): Declare.\n+\t* tree-ssa-ifcombine.c: New file.\n+\t* tree-ssa-phiopt.c (blocks_in_phiopt_order): Export.\n+\t* tree-flow.h (blocks_in_phiopt_order): Declare.\n+\t* Makefile.in (OBJS-common): Add tree-ssa-ifcombine.o.\n+\t(tree-ssa-ifcombine.o): New dependencies.\n+\n 2007-06-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/32293"}, {"sha": "bb250f8337298593a720c3070614effedc6e4d5e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -1119,6 +1119,7 @@ OBJS-common = \\\n \ttree-ssa-dom.o \\\n \ttree-ssa-dse.o \\\n \ttree-ssa-forwprop.o \\\n+\ttree-ssa-ifcombine.o \\\n \ttree-ssa-live.o \\\n \ttree-ssa-loop-ch.o \\\n \ttree-ssa-loop-im.o \\\n@@ -1942,6 +1943,9 @@ tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    langhooks.h $(FLAGS_H)\n+tree-ssa-ifcombine.o : tree-ssa-ifcombine.c $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h $(TM_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H)\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\"}, {"sha": "c4c94ff88062fa93f5280200ce3fa29bdcdda03c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -575,6 +575,7 @@ init_optimization_passes (void)\n \t opportunities.  */\n       NEXT_PASS (pass_phi_only_cprop);\n \n+      NEXT_PASS (pass_tree_ifcombine);\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_may_alias);\n       NEXT_PASS (pass_tail_recursion);"}, {"sha": "c2970775bfb9b8a9a291b54878dc630f5a2563a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -1,3 +1,14 @@\n+2007-06-12  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15353\n+\tPR tree-optimization/31657\n+\t* gcc.c-torture/execute/20070424-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ifcombine-5.c: Likewise.\n+\n 2007-06-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/32293"}, {"sha": "4a9f9c916e4e2f4a1e27671a78660d0064103fc8", "filename": "gcc/testsuite/gcc.c-torture/execute/20070424-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070424-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070424-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070424-1.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,27 @@\n+extern void abort (void);\n+extern void exit (int);\n+\n+void do_exit (void) { exit (0); }\n+void do_abort (void) { abort (); }\n+\n+void foo (int x, int a)\n+{\n+  if (x < a)\n+    goto doit;\n+  do_exit ();\n+  if (x != a)\n+    goto doit;\n+\n+  /* else */\n+  do_abort ();\n+  return;\n+\n+doit:\n+  do_abort ();\n+}\n+\n+int main()\n+{\n+  foo (1, 0);\n+  return 0;\n+}"}, {"sha": "20854813d1e6761761e6f9206fa2302bbaf8d39e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-1.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase for PR31657.  */\n+\n+int foo (int x, int a, int b)\n+{\n+  int c = 1 << a;\n+  if (x & c)\n+    if (x & (1 << b))\n+      /* returning 1 causes phiopt to trigger in */\n+      return 2;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\|\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "dab30addd59e7828b3229eed74ed339fd3649844", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-2.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase for PR31657.  */\n+\n+int foo (int x, int a, int b)\n+{\n+  /* if ((x & a) || (x & b)) */\n+  if (x & a)\n+    goto doit;\n+  if (x & b)\n+    goto doit;\n+\n+  /* else */\n+  return 0;\n+\n+  /* then - returing 1 causes phiopt to trigger */\n+doit:\n+  return 2;\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\|\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "79fec8ba90ec3a5d78d79c0af83a43a94ae159e9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-3.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase extracted from PR15353.  */\n+\n+int foo (int x, int a)\n+{\n+  /* if ((x > a) || (x == a)) */\n+  if (x > a)\n+    goto doit;\n+  if (x == a)\n+    goto doit;\n+\n+  /* else */\n+  return 0;\n+\n+  /* then - returing 1 causes phiopt to trigger */\n+doit:\n+  return 2;\n+}\n+\n+/* { dg-final { scan-tree-dump \">=\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "da477867ef346bc2b6e3feedc8fb6ee41c4e7959", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-4.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase extracted from PR15353.  */\n+\n+extern void bar(void);\n+\n+void foo (int x, int a)\n+{\n+  /* if ((x < a) || (x != a)) return; else bar (); */\n+  if (x < a)\n+    return;\n+  if (x != a)\n+    return;\n+\n+  /* else */\n+  bar ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"!=\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "88bd81e25964a30686593db16a1fb64df7cfcb63", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ifcombine-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ifcombine-5.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+/* Testcase from PR15353.  */\n+\n+int g(void);\n+int h(void);\n+int f(int *i, int *j)\n+{\n+  while (1)\n+    {\n+      if (*i > *j || *i == *j)\n+        break;\n+      return g();\n+    }\n+  return h();\n+}\n+\n+/* { dg-final { scan-tree-dump \">=\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c12b651f40ff728a13174b8ffb4dafa4f5cc4cc4", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -187,6 +187,7 @@ DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n DEFTIMEVAR (TV_VAR_TRACKING          , \"variable tracking\")\n+DEFTIMEVAR (TV_TREE_IFCOMBINE        , \"tree if-combine\")\n \n /* Everything else in rest_of_compilation not included above.  */\n DEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")"}, {"sha": "c23a094707a22b68a817507803576429612f0d57", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -962,6 +962,7 @@ extern tree get_vectype_for_scalar_type (tree);\n \n /* In tree-ssa-phiopt.c */\n bool empty_block_p (basic_block);\n+basic_block *blocks_in_phiopt_order (void);\n \n /* In tree-ssa-loop*.c  */\n "}, {"sha": "6800edfdbc8d1509028fcb5fac815cc90a190f56", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -298,6 +298,7 @@ extern struct tree_opt_pass pass_warn_function_noreturn;\n extern struct tree_opt_pass pass_phiopt;\n extern struct tree_opt_pass pass_forwprop;\n extern struct tree_opt_pass pass_phiprop;\n+extern struct tree_opt_pass pass_tree_ifcombine;\n extern struct tree_opt_pass pass_dse;\n extern struct tree_opt_pass pass_nrv;\n extern struct tree_opt_pass pass_mark_used_blocks;"}, {"sha": "89fd61d2405bdb9cb4abd60575ab824a91983dd0", "filename": "gcc/tree-ssa-ifcombine.c", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -0,0 +1,614 @@\n+/* Combining of if-expressions on trees.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Richard Guenther <rguenther@suse.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+\n+/* This pass combines COND_EXPRs to simplify control flow.  It\n+   currently recognizes bit tests and comparisons in chains that\n+   represent logical and or logical or of two COND_EXPRs.\n+\n+   It does so by walking basic blocks in a approximate reverse\n+   post-dominator order and trying to match CFG patterns that\n+   represent logical and or logical or of two COND_EXPRs.\n+   Transformations are done if the COND_EXPR conditions match\n+   either\n+\n+     1. two single bit tests X & (1 << Yn) (for logical and)\n+\n+     2. two bit tests X & Yn (for logical or)\n+\n+     3. two comparisons X OPn Y (for logical or)\n+\n+   To simplify this pass, removing basic blocks and dead code\n+   is left to CFG cleanup and DCE.  */\n+\n+\n+/* Recognize a if-then-else CFG pattern starting to match with the\n+   COND_BB basic-block containing the COND_EXPR.  The recognized\n+   then end else blocks are stored to *THEN_BB and *ELSE_BB.  If\n+   *THEN_BB and/or *ELSE_BB are already set, they are required to\n+   match the then and else basic-blocks to make the pattern match.\n+   Returns true if the pattern matched, false otherwise.  */\n+\n+static bool\n+recognize_if_then_else (basic_block cond_bb,\n+\t\t\tbasic_block *then_bb, basic_block *else_bb)\n+{\n+  edge t, e;\n+\n+  if (EDGE_COUNT (cond_bb->succs) != 2)\n+    return false;\n+\n+  /* Find the then/else edges.  */\n+  t = EDGE_SUCC (cond_bb, 0);\n+  e = EDGE_SUCC (cond_bb, 1);\n+  if (!(t->flags & EDGE_TRUE_VALUE))\n+    {\n+      edge tmp = t;\n+      t = e;\n+      e = tmp;\n+    }\n+  if (!(t->flags & EDGE_TRUE_VALUE)\n+      || !(e->flags & EDGE_FALSE_VALUE))\n+    return false;\n+\n+  /* Check if the edge destinations point to the required block.  */\n+  if (*then_bb\n+      && t->dest != *then_bb)\n+    return false;\n+  if (*else_bb\n+      && e->dest != *else_bb)\n+    return false;\n+\n+  if (!*then_bb)\n+    *then_bb = t->dest;\n+  if (!*else_bb)\n+    *else_bb = e->dest;\n+\n+  return true;\n+}\n+\n+/* Verify if the basic block BB does not have side-effects.  Return\n+   true in this case, else false.  */\n+\n+static bool\n+bb_no_side_effects_p (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+      stmt_ann_t ann = stmt_ann (stmt);\n+\n+      if (ann->has_volatile_ops\n+\t  || !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Verify if all PHI node arguments in DEST for edges from BB1 or\n+   BB2 to DEST are the same.  This makes the CFG merge point\n+   free from side-effects.  Return true in this case, else false.  */\n+\n+static bool\n+same_phi_args_p (basic_block bb1, basic_block bb2, basic_block dest)\n+{\n+  edge e1 = find_edge (bb1, dest);\n+  edge e2 = find_edge (bb2, dest);\n+  tree phi;\n+\n+  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+    if (!operand_equal_p (PHI_ARG_DEF_FROM_EDGE (phi, e1),\n+\t\t\t  PHI_ARG_DEF_FROM_EDGE (phi, e2), 0))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Recognize a single bit test pattern in COND_EXPR and its defining\n+   statements.  Store the name being tested in *NAME and the bit\n+   in *BIT.  The COND_EXPR computes *NAME & (1 << *BIT).\n+   Returns true if the pattern matched, false otherwise.  */\n+\n+static bool\n+recognize_single_bit_test (tree cond_expr, tree *name, tree *bit)\n+{\n+  tree t;\n+\n+  /* Get at the definition of the result of the bit test.  */\n+  t = TREE_OPERAND (cond_expr, 0);\n+  if (TREE_CODE (t) == NE_EXPR\n+      && integer_zerop (TREE_OPERAND (t, 1)))\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) != SSA_NAME)\n+    return false;\n+  t = SSA_NAME_DEF_STMT (t);\n+  if (TREE_CODE (t) != GIMPLE_MODIFY_STMT)\n+    return false;\n+  t = GIMPLE_STMT_OPERAND (t, 1);\n+\n+  /* Look at which bit is tested.  One form to recognize is\n+     D.1985_5 = state_3(D) >> control1_4(D);\n+     D.1986_6 = (int) D.1985_5;\n+     D.1987_7 = op0 & 1;\n+     if (D.1987_7 != 0)  */\n+  if (TREE_CODE (t) == BIT_AND_EXPR\n+      && integer_onep (TREE_OPERAND (t, 1))\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+      do {\n+\tt = SSA_NAME_DEF_STMT (t);\n+\tif (TREE_CODE (t) != GIMPLE_MODIFY_STMT)\n+\t  return false;\n+\tt = GIMPLE_STMT_OPERAND (t, 1);\n+\tif (TREE_CODE (t) == NOP_EXPR\n+\t    || TREE_CODE (t) == CONVERT_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+      } while (TREE_CODE (t) == SSA_NAME);\n+\n+      if (TREE_CODE (t) == RSHIFT_EXPR)\n+\t{\n+\t  /* op0 & (1 << op1) */\n+\t  *bit = TREE_OPERAND (t, 1);\n+\t  *name = TREE_OPERAND (t, 0);\n+\t}\n+      else\n+\t{\n+\t  /* t & 1 */\n+\t  *bit = integer_one_node;\n+\t  *name = t;\n+\t}\n+\n+      return true;\n+    }\n+\n+  /* Another form is\n+     D.1987_7 = op0 & (1 << CST)\n+     if (D.1987_7 != 0)  */\n+  if (TREE_CODE (t) == BIT_AND_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && integer_pow2p (TREE_OPERAND (t, 1)))\n+    {\n+      *name = TREE_OPERAND (t, 0);\n+      *bit = build_int_cst (integer_type_node,\n+\t\t\t    tree_log2 (TREE_OPERAND (t, 1)));\n+      return true;\n+    }\n+\n+  /* Another form is\n+     D.1986_6 = 1 << control1_4(D)\n+     D.1987_7 = op0 & D.1986_6\n+     if (D.1987_7 != 0)  */\n+  if (TREE_CODE (t) == BIT_AND_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && TREE_CODE (TREE_OPERAND (t, 1)) == SSA_NAME)\n+    {\n+      tree tmp;\n+\n+      /* Both arguments of the BIT_AND_EXPR can be the single-bit\n+\t specifying expression.  */\n+      tmp = SSA_NAME_DEF_STMT (TREE_OPERAND (t, 0));\n+      if (TREE_CODE (tmp) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (tmp, 1)) == LSHIFT_EXPR\n+\t  && integer_onep (TREE_OPERAND (GIMPLE_STMT_OPERAND (tmp, 1), 0)))\n+\t{\n+\t  *name = TREE_OPERAND (t, 1);\n+\t  *bit = TREE_OPERAND (GIMPLE_STMT_OPERAND (tmp, 1), 1);\n+\t  return true;\n+\t}\n+\n+      tmp = SSA_NAME_DEF_STMT (TREE_OPERAND (t, 1));\n+      if (TREE_CODE (tmp) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (tmp, 1)) == LSHIFT_EXPR\n+\t  && integer_onep (TREE_OPERAND (GIMPLE_STMT_OPERAND (tmp, 1), 0)))\n+\t{\n+\t  *name = TREE_OPERAND (t, 0);\n+\t  *bit = TREE_OPERAND (GIMPLE_STMT_OPERAND (tmp, 1), 1);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Recognize a bit test pattern in COND_EXPR and its defining\n+   statements.  Store the name being tested in *NAME and the bits\n+   in *BITS.  The COND_EXPR computes *NAME & *BITS.\n+   Returns true if the pattern matched, false otherwise.  */\n+\n+static bool\n+recognize_bits_test (tree cond_expr, tree *name, tree *bits)\n+{\n+  tree t;\n+\n+  /* Get at the definition of the result of the bit test.  */\n+  t = TREE_OPERAND (cond_expr, 0);\n+  if (TREE_CODE (t) == NE_EXPR\n+      && integer_zerop (TREE_OPERAND (t, 1)))\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) != SSA_NAME)\n+    return false;\n+  t = SSA_NAME_DEF_STMT (t);\n+  if (TREE_CODE (t) != GIMPLE_MODIFY_STMT)\n+    return false;\n+  t = GIMPLE_STMT_OPERAND (t, 1);\n+\n+  if (TREE_CODE (t) != BIT_AND_EXPR)\n+    return false;\n+\n+  *name = TREE_OPERAND (t, 0);\n+  *bits = TREE_OPERAND (t, 1);\n+\n+  return true;\n+}\n+\n+/* If-convert on a and pattern with a common else block.  The inner\n+   if is specified by its INNER_COND_BB, the outer by OUTER_COND_BB.\n+   Returns true if the edges to the common else basic-block were merged.  */\n+\n+static bool\n+ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n+{\n+  block_stmt_iterator bsi;\n+  tree inner_cond, outer_cond;\n+  tree name1, name2, bit1, bit2;\n+\n+  inner_cond = last_stmt (inner_cond_bb);\n+  if (!inner_cond\n+      || TREE_CODE (inner_cond) != COND_EXPR)\n+    return false;\n+\n+  outer_cond = last_stmt (outer_cond_bb);\n+  if (!outer_cond\n+      || TREE_CODE (outer_cond) != COND_EXPR)\n+    return false;\n+\n+  /* See if we test a single bit of the same name in both tests.  In\n+     that case remove the outer test, merging both else edges,\n+     and change the inner one to test for\n+     name & (bit1 | bit2) == (bit1 | bit2).  */\n+  if (recognize_single_bit_test (inner_cond, &name1, &bit1)\n+      && recognize_single_bit_test (outer_cond, &name2, &bit2)\n+      && name1 == name2)\n+    {\n+      tree t, t2;\n+\n+      /* Do it.  */\n+      bsi = bsi_for_stmt (inner_cond);\n+      t = fold_build2 (LSHIFT_EXPR, TREE_TYPE (name1),\n+\t\t       integer_one_node, bit1);\n+      t2 = fold_build2 (LSHIFT_EXPR, TREE_TYPE (name1),\n+\t\t        integer_one_node, bit2);\n+      t = fold_build2 (BIT_IOR_EXPR, TREE_TYPE (name1), t, t2);\n+      t = force_gimple_operand_bsi (&bsi, t, true, NULL_TREE);\n+      t2 = fold_build2 (BIT_AND_EXPR, TREE_TYPE (name1), name1, t);\n+      t2 = force_gimple_operand_bsi (&bsi, t2, true, NULL_TREE);\n+      COND_EXPR_COND (inner_cond) = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t\t\t t2, t);\n+      update_stmt (inner_cond);\n+\n+      /* Leave CFG optimization to cfg_cleanup.  */\n+      COND_EXPR_COND (outer_cond) = boolean_true_node;\n+      update_stmt (outer_cond);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"optimizing double bit test to \");\n+\t  print_generic_expr (dump_file, name1, 0);\n+\t  fprintf (dump_file, \" & T == T\\nwith temporary T = (1 << \");\n+\t  print_generic_expr (dump_file, bit1, 0);\n+\t  fprintf (dump_file, \") | (1 << \");\n+\t  print_generic_expr (dump_file, bit2, 0);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* If-convert on a or pattern with a common then block.  The inner\n+   if is specified by its INNER_COND_BB, the outer by OUTER_COND_BB.\n+   Returns true, if the edges leading to the common then basic-block\n+   were merged.  */\n+\n+static bool\n+ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n+{\n+  tree inner_cond, outer_cond;\n+  tree name1, name2, bits1, bits2;\n+\n+  inner_cond = last_stmt (inner_cond_bb);\n+  if (!inner_cond\n+      || TREE_CODE (inner_cond) != COND_EXPR)\n+    return false;\n+\n+  outer_cond = last_stmt (outer_cond_bb);\n+  if (!outer_cond\n+      || TREE_CODE (outer_cond) != COND_EXPR)\n+    return false;\n+\n+  /* See if we have two bit tests of the same name in both tests.\n+     In that case remove the outer test and change the inner one to\n+     test for name & (bits1 | bits2) != 0.  */\n+  if (recognize_bits_test (inner_cond, &name1, &bits1)\n+      && recognize_bits_test (outer_cond, &name2, &bits2))\n+    {\n+      block_stmt_iterator bsi;\n+      tree t;\n+\n+      /* Find the common name which is bit-tested.  */\n+      if (name1 == name2)\n+\t;\n+      else if (bits1 == bits2)\n+\t{\n+\t  t = name2;\n+\t  name2 = bits2;\n+\t  bits2 = t;\n+\t  t = name1;\n+\t  name1 = bits1;\n+\t  bits1 = t;\n+\t}\n+      else if (name1 == bits2)\n+\t{\n+\t  t = name2;\n+\t  name2 = bits2;\n+\t  bits2 = t;\n+\t}\n+      else if (bits1 == name2)\n+\t{\n+\t  t = name1;\n+\t  name1 = bits1;\n+\t  bits1 = t;\n+\t}\n+      else\n+\treturn false;\n+\n+      /* Do it.  */\n+      bsi = bsi_for_stmt (inner_cond);\n+      t = fold_build2 (BIT_IOR_EXPR, TREE_TYPE (name1), bits1, bits2);\n+      t = force_gimple_operand_bsi (&bsi, t, true, NULL_TREE);\n+      t = fold_build2 (BIT_AND_EXPR, TREE_TYPE (name1), name1, t);\n+      t = force_gimple_operand_bsi (&bsi, t, true, NULL_TREE);\n+      COND_EXPR_COND (inner_cond) = fold_build2 (NE_EXPR, boolean_type_node, t,\n+\t\t\t\t\t\t build_int_cst (TREE_TYPE (t), 0));\n+      update_stmt (inner_cond);\n+\n+      /* Leave CFG optimization to cfg_cleanup.  */\n+      COND_EXPR_COND (outer_cond) = boolean_false_node;\n+      update_stmt (outer_cond);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"optimizing bits or bits test to \");\n+\t  print_generic_expr (dump_file, name1, 0);\n+\t  fprintf (dump_file, \" & T != 0\\nwith temporary T = \");\n+\t  print_generic_expr (dump_file, bits1, 0);\n+\t  fprintf (dump_file, \" | \");\n+\t  print_generic_expr (dump_file, bits2, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      return true;\n+    }\n+\n+  /* See if we have two comparisons that we can merge into one.\n+     This happens for C++ operator overloading where for example\n+     GE_EXPR is implemented as GT_EXPR || EQ_EXPR.  */\n+  else if (COMPARISON_CLASS_P (COND_EXPR_COND (inner_cond))\n+\t   && COMPARISON_CLASS_P (COND_EXPR_COND (outer_cond))\n+\t   && operand_equal_p (TREE_OPERAND (COND_EXPR_COND (inner_cond), 0),\n+\t\t\t       TREE_OPERAND (COND_EXPR_COND (outer_cond), 0), 0)\n+\t   && operand_equal_p (TREE_OPERAND (COND_EXPR_COND (inner_cond), 1),\n+\t\t\t       TREE_OPERAND (COND_EXPR_COND (outer_cond), 1), 0))\n+    {\n+      tree ccond1 = COND_EXPR_COND (inner_cond);\n+      tree ccond2 = COND_EXPR_COND (outer_cond);\n+      enum tree_code code1 = TREE_CODE (ccond1);\n+      enum tree_code code2 = TREE_CODE (ccond2);\n+      enum tree_code code;\n+      tree t;\n+\n+#define CHK(a,b) ((code1 == a ## _EXPR && code2 == b ## _EXPR) \\\n+\t\t  || (code2 == a ## _EXPR && code1 == b ## _EXPR))\n+      /* Merge the two condition codes if possible.  */\n+      if (code1 == code2)\n+\tcode = code1;\n+      else if (CHK (EQ, LT))\n+\tcode = LE_EXPR;\n+      else if (CHK (EQ, GT))\n+\tcode = GE_EXPR;\n+      else if (CHK (LT, LE))\n+\tcode = LE_EXPR;\n+      else if (CHK (GT, GE))\n+\tcode = GE_EXPR;\n+      else if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (ccond1, 0)))\n+\t       || flag_unsafe_math_optimizations)\n+\t{\n+\t  if (CHK (LT, GT))\n+\t    code = NE_EXPR;\n+\t  else if (CHK (LT, NE))\n+\t    code = NE_EXPR;\n+\t  else if (CHK (GT, NE))\n+\t    code = NE_EXPR;\n+\t  else\n+\t    return false;\n+\t}\n+      /* We could check for combinations leading to trivial true/false.  */\n+      else\n+\treturn false;\n+#undef CHK\n+\n+      /* Do it.  */\n+      t = fold_build2 (code, boolean_type_node,\n+\t\t       TREE_OPERAND (ccond2, 0), TREE_OPERAND (ccond2, 1));\n+      COND_EXPR_COND (inner_cond) = t;\n+      update_stmt (inner_cond);\n+\n+      /* Leave CFG optimization to cfg_cleanup.  */\n+      COND_EXPR_COND (outer_cond) = boolean_false_node;\n+      update_stmt (outer_cond);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"optimizing two comparisons to \");\n+\t  print_generic_expr (dump_file, t, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Recognize a CFG pattern and dispatch to the appropriate\n+   if-conversion helper.  We start with BB as the innermost\n+   worker basic-block.  Returns true if a transformation was done.  */\n+\n+static bool\n+tree_ssa_ifcombine_bb (basic_block inner_cond_bb)\n+{\n+  basic_block then_bb = NULL, else_bb = NULL;\n+\n+  if (!recognize_if_then_else (inner_cond_bb, &then_bb, &else_bb))\n+    return false;\n+\n+  /* Recognize && and || of two conditions with a common\n+     then/else block which entry edges we can merge.  That is:\n+       if (a || b)\n+\t ;\n+     and\n+       if (a && b)\n+\t ;\n+     This requires a single predecessor of the inner cond_bb.  */\n+  if (single_pred_p (inner_cond_bb))\n+    {\n+      basic_block outer_cond_bb = single_pred (inner_cond_bb);\n+\n+      /* The && form is characterized by a common else_bb with\n+\t the two edges leading to it mergable.  The latter is\n+\t guaranteed by matching PHI arguments in the else_bb and\n+\t the inner cond_bb having no side-effects.  */\n+      if (recognize_if_then_else (outer_cond_bb, &inner_cond_bb, &else_bb)\n+\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, else_bb)\n+\t  && bb_no_side_effects_p (inner_cond_bb))\n+\t{\n+\t  /* We have\n+\t       <outer_cond_bb>\n+\t\t if (q) goto inner_cond_bb; else goto else_bb;\n+\t       <inner_cond_bb>\n+\t\t if (p) goto ...; else goto else_bb;\n+\t\t ...\n+\t       <else_bb>\n+\t\t ...\n+\t   */\n+\t  return ifcombine_ifandif (inner_cond_bb, outer_cond_bb);\n+\t}\n+\n+      /* The || form is characterized by a common then_bb with the\n+\t two edges leading to it mergable.  The latter is guaranteed\n+         by matching PHI arguments in the then_bb and the inner cond_bb\n+\t having no side-effects.  */\n+      if (recognize_if_then_else (outer_cond_bb, &then_bb, &inner_cond_bb)\n+\t  && same_phi_args_p (outer_cond_bb, inner_cond_bb, then_bb)\n+\t  && bb_no_side_effects_p (inner_cond_bb))\n+\t{\n+\t  /* We have\n+\t       <outer_cond_bb>\n+\t\t if (q) goto then_bb; else goto inner_cond_bb;\n+\t       <inner_cond_bb>\n+\t\t if (q) goto then_bb; else goto ...;\n+\t       <then_bb>\n+\t\t ...\n+\t   */\n+\t  return ifcombine_iforif (inner_cond_bb, outer_cond_bb);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Main entry for the tree if-conversion pass.  */\n+\n+static unsigned int\n+tree_ssa_ifcombine (void)\n+{\n+  basic_block *bbs;\n+  bool cfg_changed = false;\n+  int i;\n+\n+  bbs = blocks_in_phiopt_order ();\n+\n+  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; ++i)\n+    {\n+      basic_block bb = bbs[i];\n+      tree stmt = last_stmt (bb);\n+\n+      if (stmt\n+\t  && TREE_CODE (stmt) == COND_EXPR)\n+\tcfg_changed |= tree_ssa_ifcombine_bb (bb);\n+    }\n+\n+  free (bbs);\n+\n+  return cfg_changed ? TODO_cleanup_cfg : 0;\n+}\n+\n+static bool\n+gate_ifcombine (void)\n+{\n+  return 1;\n+}\n+\n+struct tree_opt_pass pass_tree_ifcombine = {\n+  \"ifcombine\",\t\t\t/* name */\n+  gate_ifcombine,\t\t/* gate */\n+  tree_ssa_ifcombine,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_IFCOMBINE,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\n+  | TODO_ggc_collect\n+  | TODO_update_ssa\n+  | TODO_verify_ssa,\t\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n+};"}, {"sha": "8cdd3c80da947ac5d6b1575d5e23b23631338e18", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d0801470c24386f9e02038d3305e0738d1623e/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=18d0801470c24386f9e02038d3305e0738d1623e", "patch": "@@ -45,7 +45,6 @@ static bool minmax_replacement (basic_block, basic_block,\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, tree, tree, tree);\n static void replace_phi_edge_with_variable (basic_block, edge, tree, tree);\n-static basic_block *blocks_in_phiopt_order (void);\n \n /* This pass tries to replaces an if-then-else block with an\n    assignment.  We have four kinds of transformations.  Some of these\n@@ -247,7 +246,7 @@ tree_ssa_phiopt (void)\n    that if a block X has just a single predecessor Y, then Y is after X in the\n    ordering.  */\n \n-static basic_block *\n+basic_block *\n blocks_in_phiopt_order (void)\n {\n   basic_block x, y;"}]}