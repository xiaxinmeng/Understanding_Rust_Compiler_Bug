{"sha": "a1e25d0008791118dd58eaddff5f4c3691f8750e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlMjVkMDAwODc5MTExOGRkNThlYWRkZmY1ZjRjMzY5MWY4NzUwZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-08T14:37:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-09T11:17:07Z"}, "message": "remove premature vect_verify_datarefs_alignment\n\nThis followup removes vect_verify_datarefs_alignment and its\npremature cancellation of vectorization leaving the actual\ndecision whether alignment is supported to the functions\ndeciding whether we can vectorize a load or store.\n\n2020-07-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_verify_datarefs_alignment): Remove.\n\t(vect_slp_analyze_and_verify_instance_alignment): Rename to ...\n\t(vect_slp_analyze_instance_alignment): ... this.\n\t* tree-vect-data-refs.c (verify_data_ref_alignment): Remove.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vect_enhance_data_refs_alignment): Do not call\n\tvect_verify_datarefs_alignment.\n\t(vect_slp_analyze_node_alignment): Rename from\n\tvect_slp_analyze_and_verify_node_alignment and do not\n\tcall verify_data_ref_alignment.\n\t(vect_slp_analyze_instance_alignment): Rename from\n\tvect_slp_analyze_and_verify_instance_alignment.\n\t* tree-vect-stmts.c (vectorizable_store): Dump when\n\twe vectorize an unaligned access.\n\t(vectorizable_load): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Do not call\n\tvect_verify_datarefs_alignment.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Adjust.\n\n\t* gcc.dg/vect/bb-slp-10.c: Adjust.\n\t* gcc.dg/vect/slp-45.c: Likewise.\n\t* gcc.dg/vect/vect-109.c: Likewise.", "tree": {"sha": "43f3ef21028a8e22ca748259ff67e9ded6f5bb15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f3ef21028a8e22ca748259ff67e9ded6f5bb15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1e25d0008791118dd58eaddff5f4c3691f8750e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e25d0008791118dd58eaddff5f4c3691f8750e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e25d0008791118dd58eaddff5f4c3691f8750e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e25d0008791118dd58eaddff5f4c3691f8750e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd21b03900085c4d60bf03207ad28bcbfbc86a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd21b03900085c4d60bf03207ad28bcbfbc86a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd21b03900085c4d60bf03207ad28bcbfbc86a4b"}], "stats": {"total": 117, "additions": 28, "deletions": 89}, "files": [{"sha": "ad6f878e4076a9aa969efbc35d747dbcbd43c72b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -49,6 +49,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"bad data alignment in basic block\" \"slp2\" { target { ! vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump \"unsupported unaligned access\" \"slp2\" { target { ! vect_element_align } } } } */\n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" { target vect_element_align } } } */\n   "}, {"sha": "1e35d354203f903bc7977f676e73f2cf0bf30e3c", "filename": "gcc/testsuite/gcc.dg/vect/slp-45.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-45.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -77,5 +77,4 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 13 \"vect\" { target vect_hw_misalign } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { ! vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 13 \"vect\" } } */"}, {"sha": "fe7ea6c420fb1512286b0b468cbe9ffed5daae71", "filename": "gcc/testsuite/gcc.dg/vect/vect-109.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -77,6 +77,6 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_element_align } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" { xfail vect_element_align } } } */\n+/* { dg-final { scan-tree-dump-times \"unsupported unaligned access\" 2 \"vect\" { xfail vect_element_align } } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_element_align xfail { ! vect_unaligned_possible } } } } */\n "}, {"sha": "e35a215e042478d11d6545f1f829d816d0c3620f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 79, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -1214,56 +1214,6 @@ vect_relevant_for_alignment_p (dr_vec_info *dr_info)\n   return true;\n }\n \n-/* Function verify_data_ref_alignment\n-\n-   Return TRUE if DR_INFO can be handled with respect to alignment.  */\n-\n-static opt_result\n-verify_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n-{\n-  enum dr_alignment_support supportable_dr_alignment\n-    = vect_supportable_dr_alignment (vinfo, dr_info, false);\n-  if (!supportable_dr_alignment)\n-    return opt_result::failure_at\n-      (dr_info->stmt->stmt,\n-       DR_IS_READ (dr_info->dr)\n-\t? \"not vectorized: unsupported unaligned load: %T\\n\"\n-\t: \"not vectorized: unsupported unaligned store: %T\\n\",\n-       DR_REF (dr_info->dr));\n-\n-  if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"Vectorizing an unaligned access.\\n\");\n-\n-  return opt_result::success ();\n-}\n-\n-/* Function vect_verify_datarefs_alignment\n-\n-   Return TRUE if all data references in the loop can be\n-   handled with respect to alignment.  */\n-\n-opt_result\n-vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n-{\n-  vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  struct data_reference *dr;\n-  unsigned int i;\n-\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    {\n-      dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-      if (!vect_relevant_for_alignment_p (dr_info))\n-\tcontinue;\n-\n-      opt_result res = verify_data_ref_alignment (loop_vinfo, dr_info);\n-      if (!res)\n-\treturn res;\n-    }\n-\n-  return opt_result::success ();\n-}\n-\n /* Given an memory reference EXP return whether its alignment is less\n    than its size.  */\n \n@@ -2091,13 +2041,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       /* Check if all datarefs are supportable and log.  */\n       if (do_peeling && known_alignment_for_access_p (dr0_info) && npeel == 0)\n-        {\n-          opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n-          if (!stat)\n-            do_peeling = false;\n-          else\n-\t    return stat;\n-        }\n+\treturn opt_result::success ();\n \n       /* Cost model #1 - honor --param vect-max-peeling-for-alignment.  */\n       if (do_peeling)\n@@ -2186,9 +2130,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* The inside-loop cost will be accounted for in vectorizable_load\n \t     and vectorizable_store correctly with adjusted alignments.\n \t     Drop the body_cst_vec on the floor here.  */\n-\t  opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n-\t  gcc_assert (stat);\n-          return stat;\n+\t  return opt_result::success ();\n         }\n     }\n \n@@ -2318,16 +2260,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n \n-      opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n-      gcc_assert (stat);\n-      return stat;\n+      return opt_result::success ();\n     }\n \n   /* This point is reached if neither peeling nor versioning is being done.  */\n   gcc_assert (! (do_peeling || do_versioning));\n \n-  opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n-  return stat;\n+  return opt_result::success ();\n }\n \n \n@@ -2431,7 +2370,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n /* Analyze alignment of DRs of stmts in NODE.  */\n \n static bool\n-vect_slp_analyze_and_verify_node_alignment (vec_info *vinfo, slp_tree node)\n+vect_slp_analyze_node_alignment (vec_info *vinfo, slp_tree node)\n {\n   /* We vectorize from the first scalar stmt in the node unless\n      the node is permuted in which case we start from the first\n@@ -2457,15 +2396,6 @@ vect_slp_analyze_and_verify_node_alignment (vec_info *vinfo, slp_tree node)\n \tvect_compute_data_ref_alignment (vinfo, first_dr_info);\n     }\n \n-  if (! verify_data_ref_alignment (vinfo, dr_info))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: bad data alignment in basic \"\n-\t\t\t \"block.\\n\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -2475,20 +2405,20 @@ vect_slp_analyze_and_verify_node_alignment (vec_info *vinfo, slp_tree node)\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n bool\n-vect_slp_analyze_and_verify_instance_alignment (vec_info *vinfo,\n+vect_slp_analyze_instance_alignment (vec_info *vinfo,\n \t\t\t\t\t\tslp_instance instance)\n {\n-  DUMP_VECT_SCOPE (\"vect_slp_analyze_and_verify_instance_alignment\");\n+  DUMP_VECT_SCOPE (\"vect_slp_analyze_instance_alignment\");\n \n   slp_tree node;\n   unsigned i;\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, node)\n-    if (! vect_slp_analyze_and_verify_node_alignment (vinfo, node))\n+    if (! vect_slp_analyze_node_alignment (vinfo, node))\n       return false;\n \n   node = SLP_INSTANCE_TREE (instance);\n   if (STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (node))\n-      && ! vect_slp_analyze_and_verify_node_alignment\n+      && ! vect_slp_analyze_node_alignment\n \t     (vinfo, SLP_INSTANCE_TREE (instance)))\n     return false;\n "}, {"sha": "6ec16475c6631f83fe03d0ba786f9534987f1c70", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -2136,8 +2136,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n     /* This pass will decide on using loop versioning and/or loop peeling in\n        order to enhance the alignment of data references in the loop.  */\n     ok = vect_enhance_data_refs_alignment (loop_vinfo);\n-  else\n-    ok = vect_verify_datarefs_alignment (loop_vinfo);\n   if (!ok)\n     return ok;\n "}, {"sha": "35ae698459349f6125fda75e280d887fec91f055", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -3289,7 +3289,7 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n      dependence in the SLP instances.  */\n   for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n     {\n-      if (! vect_slp_analyze_and_verify_instance_alignment (bb_vinfo, instance)\n+      if (! vect_slp_analyze_instance_alignment (bb_vinfo, instance)\n \t  || ! vect_slp_analyze_instance_dependence (bb_vinfo, instance))\n \t{\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);"}, {"sha": "6730cae8085463cbd57a28b28e52430c1e16e544", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -7190,6 +7190,13 @@ vectorizable_store (vec_info *vinfo,\n \t  return false;\n \t}\n \n+      if (dump_enabled_p ()\n+\t  && memory_access_type != VMAT_ELEMENTWISE\n+\t  && memory_access_type != VMAT_GATHER_SCATTER\n+\t  && alignment_support_scheme != dr_aligned)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Vectorizing an unaligned access.\\n\");\n+\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       vect_model_store_cost (vinfo, stmt_info, ncopies,\n \t\t\t     memory_access_type, vls_type, slp_node, cost_vec);\n@@ -8475,6 +8482,13 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t\t\t      group_size, memory_access_type,\n \t\t\t\t\t      &gs_info, mask);\n \n+      if (dump_enabled_p ()\n+\t  && memory_access_type != VMAT_ELEMENTWISE\n+\t  && memory_access_type != VMAT_GATHER_SCATTER\n+\t  && alignment_support_scheme != dr_aligned)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Vectorizing an unaligned access.\\n\");\n+\n       STMT_VINFO_TYPE (orig_stmt_info) = load_vec_info_type;\n       vect_model_load_cost (vinfo, stmt_info, ncopies, vf, memory_access_type,\n \t\t\t    slp_node, cost_vec);"}, {"sha": "91d3291ab566e0d56f439a046cdebb92a0fa48d9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e25d0008791118dd58eaddff5f4c3691f8750e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a1e25d0008791118dd58eaddff5f4c3691f8750e", "patch": "@@ -1892,9 +1892,7 @@ extern opt_result vect_analyze_data_ref_dependences (loop_vec_info, unsigned int\n extern bool vect_slp_analyze_instance_dependence (vec_info *, slp_instance);\n extern opt_result vect_enhance_data_refs_alignment (loop_vec_info);\n extern opt_result vect_analyze_data_refs_alignment (loop_vec_info);\n-extern opt_result vect_verify_datarefs_alignment (loop_vec_info);\n-extern bool vect_slp_analyze_and_verify_instance_alignment (vec_info *,\n-\t\t\t\t\t\t\t    slp_instance);\n+extern bool vect_slp_analyze_instance_alignment (vec_info *, slp_instance);\n extern opt_result vect_analyze_data_ref_accesses (vec_info *);\n extern opt_result vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_gather_scatter_fn_p (vec_info *, bool, bool, tree, tree,"}]}