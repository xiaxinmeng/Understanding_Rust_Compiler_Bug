{"sha": "2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "node_id": "C_kwDOANBUbNoAKDJlNTNmYTdiYjJhZTlmZTExNTJjMjdlNDIzYmU5ZTI2MWRhODJkZGM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-03-11T14:10:59Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-03-12T13:00:46Z"}, "message": "Enhance further testcases to verify handling of OpenACC privatization level [PR90115]\n\nAs originally introduced in commit 11b8286a83289f5b54e813f14ff56d730c3f3185\n\"[OpenACC privatization] Largely extend diagnostics and corresponding testsuite\ncoverage [PR90115]\".\n\n\tPR middle-end/90115\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/default-1.c: Enhance.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-reduction-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-dims.c: Likewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90: Likewise.", "tree": {"sha": "3ca7381ff0aed5805d83fc44065b5c532d0ad788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca7381ff0aed5805d83fc44065b5c532d0ad788"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "337ed336d7dd83526891bdb436f0bfe9e351f69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337ed336d7dd83526891bdb436f0bfe9e351f69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337ed336d7dd83526891bdb436f0bfe9e351f69d"}], "stats": {"total": 321, "additions": 266, "deletions": 55}, "files": [{"sha": "0ac8d7132d46b1380e788925cc6ee169ee6aa8b9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/default-1.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdefault-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdefault-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdefault-1.c?ref=2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "patch": "@@ -1,4 +1,18 @@\n-/* { dg-do run } */\n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0] }\n+   { dg-message dummy {} { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n \n #include  <openacc.h>\n \n@@ -13,10 +27,15 @@ int test_parallel ()\n     ary[i] = ~0;\n \n   /* val defaults to firstprivate, ary defaults to copy.  */\n-#pragma acc parallel num_gangs (32) copy (ok) copy(ondev)\n+#pragma acc parallel num_gangs (32) copy (ok) copy(ondev) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     ondev = acc_on_device (acc_device_not_host);\n-#pragma acc loop gang(static:1)\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+       ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n+#pragma acc loop gang(static:1) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (unsigned i = 0; i < 32; i++)\n       {\n \tif (val != 2)\n@@ -51,10 +70,13 @@ int test_kernels ()\n     ary[i] = ~0;\n \n   /* val defaults to copy, ary defaults to copy.  */\n-#pragma acc kernels copy(ondev)\n+#pragma acc kernels copy(ondev) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n   {\n     ondev = acc_on_device (acc_device_not_host);\n-#pragma acc loop \n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (unsigned i = 0; i < 32; i++)\n       {\n \tary[i] = val;"}, {"sha": "fbd9815f683d85beda01847cc9e2a1bec4335511", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-reduction-1.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-reduction-1.c?ref=2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "patch": "@@ -1,6 +1,14 @@\n /* Verify that a simple, explicit acc loop reduction works inside\n  a kernels region.  */\n \n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n #include <stdlib.h>\n \n #define N 100\n@@ -10,9 +18,11 @@ main ()\n {\n   int i, red = 0;\n \n-#pragma acc kernels\n+#pragma acc kernels /* { dg-line l_compute1 } */\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute1 } */\n   {\n-#pragma acc loop reduction (+:red)\n+#pragma acc loop reduction (+:red) /* { dg-line l_loop_i1 } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i1 } */\n   for (i = 0; i < N; i++)\n     red++;\n   }"}, {"sha": "f9c7aed3a5638e9845e019be10faae7e511a5dea", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c", "status": "modified", "additions": 215, "deletions": 46, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c?ref=2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "patch": "@@ -1,6 +1,22 @@\n /* OpenACC parallelism dimensions clauses: num_gangs, num_workers,\n    vector_length.  */\n \n+/* { dg-additional-options \"-fopt-info-all-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message dummy {} { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n /* { dg-additional-options \"-Wopenacc-parallelism\" } for testing/documenting\n    aspects of that functionality.  */\n \n@@ -11,18 +27,21 @@\n #include <gomp-constants.h>\n \n #pragma acc routine seq\n+inline __attribute__ ((always_inline))\n static int acc_gang ()\n {\n   return __builtin_goacc_parlevel_id (GOMP_DIM_GANG);\n }\n \n #pragma acc routine seq\n+inline __attribute__ ((always_inline))\n static int acc_worker ()\n {\n   return __builtin_goacc_parlevel_id (GOMP_DIM_WORKER);\n }\n \n #pragma acc routine seq\n+inline __attribute__ ((always_inline))\n static int acc_vector ()\n {\n   return __builtin_goacc_parlevel_id (GOMP_DIM_VECTOR);\n@@ -39,14 +58,19 @@ int main ()\n \n   /* GR, WS, VS.  */\n   {\n-#define GANGS 0 /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c } } */\n+#define GANGS 0\n+    /* { dg-warning {'num_gangs' value must be positive} {} { target c } .-1 } */\n     int gangs_actual = GANGS;\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (gangs_actual) \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (gangs_actual) \\\n   reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max) \\\n-  num_gangs (GANGS) /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c++ } } */\n+  num_gangs (GANGS)\n+    /* { dg-note {in expansion of macro 'GANGS'} {} { target c } .-1 } */\n+    /* { dg-warning {'num_gangs' value must be positive} {} { target c++ } .-2 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n     {\n       /* We're actually executing with num_gangs (1).  */\n       gangs_actual = 1;\n@@ -68,18 +92,27 @@ int main ()\n \n   /* GP, WS, VS.  */\n   {\n-#define GANGS 0 /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c } } */\n+#define GANGS 0\n+    /* { dg-warning {'num_gangs' value must be positive} {} { target c } .-1 } */\n     int gangs_actual = GANGS;\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (gangs_actual) \\\n-  num_gangs (GANGS) /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c++ } } */\n-    /* { dg-warning \"region contains gang partitioned code but is not gang partitioned\" \"\" { target *-*-* } .-2 } */\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (gangs_actual) \\\n+  num_gangs (GANGS)\n+    /* { dg-note {in expansion of macro 'GANGS'} {} { target c } .-1 } */\n+    /* { dg-warning {'num_gangs' value must be positive} {} { target c++ } .-2 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {region contains gang partitioned code but is not gang partitioned} {} { target *-*-* } l_compute$c_compute } */\n     {\n       /* We're actually executing with num_gangs (1).  */\n       gangs_actual = 1;\n-#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  gang \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -98,18 +131,27 @@ int main ()\n \n   /* GR, WP, VS.  */\n   {\n-#define WORKERS 0 /* { dg-warning \"'num_workers' value must be positive\" \"\" { target c } } */\n+#define WORKERS 0\n+    /* { dg-warning {'num_workers' value must be positive} {} { target c } .-1 } */\n     int workers_actual = WORKERS;\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (workers_actual) \\\n-  num_workers (WORKERS) /* { dg-warning \"'num_workers' value must be positive\" \"\" { target c++ } } */\n-    /* { dg-warning \"region contains worker partitioned code but is not worker partitioned\" \"\" { target *-*-* } .-2 } */\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (workers_actual) \\\n+  num_workers (WORKERS)\n+    /* { dg-note {in expansion of macro 'WORKERS'} {} { target c } .-1 } */\n+    /* { dg-warning {'num_workers' value must be positive} {} { target c++ } .-2 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {region contains worker partitioned code but is not worker partitioned} {} { target *-*-* } l_compute$c_compute } */\n     {\n       /* We're actually executing with num_workers (1).  */\n       workers_actual = 1;\n-#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  worker \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC worker loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -128,22 +170,34 @@ int main ()\n \n   /* GR, WS, VP.  */\n   {\n-#define VECTORS 0 /* { dg-warning \"'vector_length' value must be positive\" \"\" { target c } } */\n+#define VECTORS 0\n+    /* { dg-warning {'vector_length' value must be positive} {} { target c } .-1 } */\n     int vectors_actual = VECTORS;\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using .vector_length \\\\(32\\\\)., ignoring 1\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n-  vector_length (VECTORS) /* { dg-warning \"'vector_length' value must be positive\" \"\" { target c++ } } */\n-    /* { dg-warning \"region contains vector partitioned code but is not vector partitioned\" \"\" { target *-*-* } .-2 } */\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (vectors_actual) \\\n+  vector_length (VECTORS)\n+    /* { dg-note {in expansion of macro 'VECTORS'} {} { target c } .-1 } */\n+    /* { dg-warning {'vector_length' value must be positive} {} { target c++ } .-2 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {region contains vector partitioned code but is not vector partitioned} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(32\\)', ignoring 1} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       /* We're actually executing with vector_length (1), just the GCC nvptx\n \t back end enforces vector_length (32).  */\n       if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \tvectors_actual = 32;\n       else\n \tvectors_actual = 1;\n-#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  vector \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC vector loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -178,12 +232,16 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (gangs_actual) \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (gangs_actual) \\\n   reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max) \\\n   num_gangs (gangs)\n-    /* { dg-bogus \"warning: region is gang partitioned but does not contain gang partitioned code\" \"TODO 'reduction'\" { xfail *-*-* } .-3 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-bogus {warning: region is gang partitioned but does not contain gang partitioned code} {TODO 'reduction'} { xfail *-*-* } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_gangs (1).  */\n \t  gangs_actual = 1;\n@@ -214,15 +272,23 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (gangs_actual) \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (gangs_actual) \\\n   num_gangs (gangs)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_gangs (1).  */\n \t  gangs_actual = 1;\n \t}\n-#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  gang \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -246,27 +312,40 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (workers_actual) /* { dg-warning \"using .num_workers \\\\(32\\\\)., ignoring 2097152\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (workers_actual) \\\n   num_workers (WORKERS)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'num_workers \\(32\\)', ignoring 2097152} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_workers (1).  */\n \t  workers_actual = 1;\n \t}\n       else if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC nvptx back end enforces num_workers (32).  */\n \t  workers_actual = 32;\n \t}\n       else if (acc_on_device (acc_device_radeon))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC GCN back end is limited to num_workers (16).  */\n \t  workers_actual = 16;\n \t}\n       else\n \t__builtin_abort ();\n-#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  worker \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC worker loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -297,27 +376,39 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (workers_actual) \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (workers_actual) \\\n   num_workers (workers)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_workers (1).  */\n \t  workers_actual = 1;\n \t}\n       else if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_workers (32).  */\n \t  /* workers_actual = 32; */\n \t}\n       else if (acc_on_device (acc_device_radeon))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC GCN back end is limited to num_workers (16).  */\n \t  workers_actual = 16;\n \t}\n       else\n \t__builtin_abort ();\n-#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  worker \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC worker loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -341,27 +432,40 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using .vector_length \\\\(1024\\\\)., ignoring 2097152\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (vectors_actual) \\\n   vector_length (VECTORS)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(1024\\)', ignoring 2097152} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with vector_length (1).  */\n \t  vectors_actual = 1;\n \t}\n       else if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC nvptx back end reduces to vector_length (1024).  */\n \t  vectors_actual = 1024;\n \t}\n       else if (acc_on_device (acc_device_radeon))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC GCN back end enforces vector_length (1): autovectorize. */\n \t  vectors_actual = 1;\n \t}\n       else\n \t__builtin_abort ();\n-#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  vector \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC vector loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -386,20 +490,29 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using .vector_length \\\\(32\\\\)., ignoring runtime setting\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (vectors_actual) \\\n   vector_length (vectors)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(32\\)', ignoring runtime setting} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with vector_length (1).  */\n \t  vectors_actual = 1;\n \t}\n       else if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC nvptx back end enforces vector_length (32).  */\n \t  vectors_actual = 32;\n \t}\n       else if (acc_on_device (acc_device_radeon))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* Because of the way vectors are implemented for GCN, a vector loop\n \t     containing a seq routine call will not vectorize calls to that\n@@ -408,7 +521,11 @@ int main ()\n \t}\n       else\n \t__builtin_abort ();\n-#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  vector \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC vector loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -443,12 +560,17 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc parallel copy (gangs_actual, workers_actual, vectors_actual) /* { dg-warning \"using .vector_length \\\\(32\\\\)., ignoring 11\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc parallel /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (gangs_actual, workers_actual, vectors_actual) \\\n   num_gangs (gangs) \\\n   num_workers (WORKERS) \\\n   vector_length (VECTORS)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(32\\)', ignoring 11} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_host))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* We're actually executing with num_gangs (1), num_workers (1),\n \t     vector_length (1).  */\n@@ -457,22 +579,40 @@ int main ()\n \t  vectors_actual = 1;\n \t}\n       else if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC nvptx back end enforces vector_length (32).  */\n \t  vectors_actual = 32;\n \t}\n       else if (acc_on_device (acc_device_radeon))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* See above comments about GCN vectors_actual.  */\n \t  vectors_actual = 1;\n \t}\n       else\n \t__builtin_abort ();\n-#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  gang \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n-#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_j[incr c_loop_j] } */ \\\n+  worker \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-optimized {assigned OpenACC worker loop parallelism} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 100 * workers_actual; j > -100 * workers_actual; --j)\n-#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_k[incr c_loop_k] } */ \\\n+  vector \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\t  /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n+\t  /* { dg-optimized {assigned OpenACC vector loop parallelism} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t  for (int k = 100 * vectors_actual; k > -100 * vectors_actual; --k)\n \t    {\n \t      gangs_min = gangs_max = acc_gang ();\n@@ -502,12 +642,16 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc kernels\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n     {\n       /* This is to make the OpenACC kernels construct unparallelizable.  */\n       asm volatile (\"\" : : : \"memory\");\n \n-#pragma acc loop reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100; i > -100; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -532,15 +676,19 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc kernels \\\n+#pragma acc kernels /* { dg-line l_compute[incr c_compute] } */ \\\n   num_gangs (gangs) \\\n   num_workers (WORKERS) \\\n   vector_length (VECTORS)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n     {\n       /* This is to make the OpenACC kernels construct unparallelizable.  */\n       asm volatile (\"\" : : : \"memory\");\n \n-#pragma acc loop reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100; i > -100; --i)\n \t{\n \t  gangs_min = gangs_max = acc_gang ();\n@@ -564,8 +712,10 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc serial /* { dg-warning \"using .vector_length \\\\(32\\\\)., ignoring 1\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc serial /* { dg-line l_compute[incr c_compute] } */ \\\n   reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(32\\)', ignoring 1} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       for (int i = 100; i > -100; i--)\n \t{\n@@ -586,25 +736,44 @@ int main ()\n     int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n     gangs_min = workers_min = vectors_min = INT_MAX;\n     gangs_max = workers_max = vectors_max = INT_MIN;\n-#pragma acc serial copy (vectors_actual) /* { dg-warning \"using .vector_length \\\\(32\\\\)., ignoring 1\" \"\" { target openacc_nvidia_accel_selected } } */ \\\n+#pragma acc serial /* { dg-line l_compute[incr c_compute] } */ \\\n+  copy (vectors_actual) \\\n   copy (gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max)\n-    /* { dg-bogus \"warning: region contains gang partitioned code but is not gang partitioned\" \"TODO 'serial'\" { xfail *-*-* } .-2 }\n-       { dg-bogus \"warning: region contains worker partitioned code but is not worker partitioned\" \"TODO 'serial'\" { xfail *-*-* } .-3 }\n-       { dg-bogus \"warning: region contains vector partitioned code but is not vector partitioned\" \"TODO 'serial'\" { xfail *-*-* } .-4 } */\n+    /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+    /* { dg-bogus {warning: region contains gang partitioned code but is not gang partitioned} {TODO 'serial'} { xfail *-*-* } l_compute$c_compute }\n+       { dg-bogus {warning: region contains worker partitioned code but is not worker partitioned} {TODO 'serial'} { xfail *-*-* } l_compute$c_compute }\n+       { dg-bogus {warning: region contains vector partitioned code but is not vector partitioned} {TODO 'serial'} { xfail *-*-* } l_compute$c_compute } */\n+    /* { dg-warning {using 'vector_length \\(32\\)', ignoring 1} {} { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n     {\n       if (acc_on_device (acc_device_nvidia))\n+\t/* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target { c++ && { ! __OPTIMIZE__ } } } .-1 }\n+\t   ..., as without optimizations, we're not inlining the C++ 'acc_on_device' wrapper.  */\n \t{\n \t  /* The GCC nvptx back end enforces vector_length (32).  */\n \t  /* It's unclear if that's actually permissible here;\n \t     <https://github.com/OpenACC/openacc-spec/issues/238> \"OpenACC\n \t     'serial' construct might not actually be serial\".  */\n \t  vectors_actual = 32;\n \t}\n-#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_i[incr c_loop_i] } */ \\\n+  gang \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+      /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n       for (int i = 100; i > -100; i--)\n-#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_j[incr c_loop_j] } */ \\\n+  worker \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-optimized {assigned OpenACC worker loop parallelism} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 100; j > -100; j--)\n-#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+#pragma acc loop /* { dg-line l_loop_k[incr c_loop_k] } */ \\\n+  vector \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\t  /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n+\t  /* { dg-optimized {assigned OpenACC vector loop parallelism} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t  for (int k = 100 * vectors_actual; k > -100 * vectors_actual; k--)\n \t    {\n \t      gangs_min = gangs_max = acc_gang ();"}, {"sha": "6ff740efc32f045b306108814077cf1d98427ded", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-reduction-1.f90", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-reduction-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e53fa7bb2ae9fe1152c27e423be9e261da82ddc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-reduction-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-reduction-1.f90?ref=2e53fa7bb2ae9fe1152c27e423be9e261da82ddc", "patch": "@@ -2,14 +2,24 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"-fopt-info-all-omp\" }\n+! { dg-additional-options \"-foffload=-fopt-info-all-omp\" } */\n+\n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting, and potentially varying depending on GCC configuration (data types):\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n+\n program reduction\n   integer, parameter     :: n = 20\n   integer                :: i, red\n \n   red = 0\n \n-  !$acc kernels\n-  !$acc loop reduction (+:red)\n+  !$acc kernels ! { dg-line l_compute1 } */\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute1 }\n+  !$acc loop reduction (+:red) ! { dg-line l_loop_i1 }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i1 }\n   do i = 1, n\n      red = red + 1\n   end do"}]}