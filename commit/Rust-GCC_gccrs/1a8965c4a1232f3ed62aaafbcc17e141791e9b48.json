{"sha": "1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4OTY1YzRhMTIzMmYzZWQ2MmFhYWZiY2MxN2UxNDE3OTFlOWI0OA==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "2003-05-17T18:20:55Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2003-05-17T18:20:55Z"}, "message": "coff.h: Remove support for Sun FPA and Sun SKY board.\n\n2003-05-17  Andreas Schwab  <schwab@suse.de>\n\n\t* config/m68k/coff.h: Remove support for Sun FPA and Sun SKY board.\n\t* config/m68k/linux.h: Likewise.\n\t* config/m68k/m68k-none.h: Likewise.\n\t* config/m68k/netbsd-elf.h: Likewise.\n\t* config/m68k/sgs.h: Likewise.\n\t* config/m68k/m68k.h: Likewise.\n\t* config/m68k/m68k.md: Likewise.\n\t* config/m68k/m68k.c: Likewise.\n\t* doc/md.texi (Machine Constraints): Remove Sun FPA specific\n\tconstraints.\n\t* doc/invoke.texi (Option Summary): Remove -mfpa.\n\t(M680x0 Options): Likewise.\n\nFrom-SVN: r66907", "tree": {"sha": "7d4a95f9ded596058315b62c1708c26179815b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d4a95f9ded596058315b62c1708c26179815b1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a8fa26cf40c70514db7b2cba1f167f8ac7ba54c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a8fa26cf40c70514db7b2cba1f167f8ac7ba54c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a8fa26cf40c70514db7b2cba1f167f8ac7ba54c"}], "stats": {"total": 1463, "additions": 87, "deletions": 1376}, "files": [{"sha": "b860f0f1756b2430697103c818dcb76f1476a110", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,3 +1,18 @@\n+2003-05-17  Andreas Schwab  <schwab@suse.de>\n+\n+\t* config/m68k/coff.h: Remove support for Sun FPA and Sun SKY board.\n+\t* config/m68k/linux.h: Likewise.\n+\t* config/m68k/m68k-none.h: Likewise.\n+\t* config/m68k/netbsd-elf.h: Likewise.\n+\t* config/m68k/sgs.h: Likewise.\n+\t* config/m68k/m68k.h: Likewise.\n+\t* config/m68k/m68k.md: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* doc/md.texi (Machine Constraints): Remove Sun FPA specific\n+\tconstraints.\n+\t* doc/invoke.texi (Option Summary): Remove -mfpa.\n+\t(M680x0 Options): Likewise.\n+\n 2003-05-17  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.c (rs6000_function_value): Simplify REAL_TYPE logic."}, {"sha": "062a4b6489a25723606d0ab2114e86826f11ec35", "filename": "gcc/config/m68k/coff.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcoff.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    m68k series COFF object files and debugging, version.\n-   Copyright (C) 1994, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 1997, 2000, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -71,21 +71,10 @@ Boston, MA 02111-1307, USA.  */\n /* Here are the new register names.  */\n \n #undef REGISTER_NAMES\n-#ifndef SUPPORT_SUN_FPA\n #define REGISTER_NAMES \\\n {\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n  \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\" }\n-#else /* SUPPORTED_SUN_FPA */\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \\\n- \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\", \"%fpa7\", \\\n- \"%fpa8\", \"%fpa9\", \"%fpa10\", \"%fpa11\", \"%fpa12\", \"%fpa13\", \"%fpa14\", \"%fpa15\", \\\n- \"%fpa16\", \"%fpa17\", \"%fpa18\", \"%fpa19\", \"%fpa20\", \"%fpa21\", \"%fpa22\", \"%fpa23\", \\\n- \"%fpa24\", \"%fpa25\", \"%fpa26\", \"%fpa27\", \"%fpa28\", \"%fpa29\", \"%fpa30\", \"%fpa31\" }\n-#endif /* defined SUPPORT_SUN_FPA */\n \n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE) \\"}, {"sha": "7a90756839f1bf71ee2e885f5eabc27d7469b69b", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for Motorola 68k running Linux-based GNU systems with\n    ELF format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -80,26 +80,11 @@ Boston, MA 02111-1307, USA.  */\n \n #undef REGISTER_NAMES\n \n-#ifndef SUPPORT_SUN_FPA\n-\n #define REGISTER_NAMES \\\n {\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\", \\\n  \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\", \\\n  \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\" }\n \n-#else /* SUPPORTED_SUN_FPA */\n-\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\", \\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\", \\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \\\n- \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\", \"%fpa7\", \\\n- \"%fpa8\", \"%fpa9\", \"%fpa10\",\"%fpa11\",\"%fpa12\",\"%fpa13\",\"%fpa14\",\"%fpa15\", \\\n- \"%fpa16\",\"%fpa17\",\"%fpa18\",\"%fpa19\",\"%fpa20\",\"%fpa21\",\"%fpa22\",\"%fpa23\", \\\n- \"%fpa24\",\"%fpa25\",\"%fpa26\",\"%fpa27\",\"%fpa28\",\"%fpa29\",\"%fpa30\",\"%fpa31\" }\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\"\n  "}, {"sha": "eb9cdae2ed1f2e795de2378e42ed5e8a9dbd06a5", "filename": "gcc/config/m68k/m68k-none.h", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-none.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  \"naked\" 68020.\n-   Copyright (C) 1994, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -92,22 +92,15 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-Dmc68000\"\n \n-/* Define one of __HAVE_68881__, __HAVE_FPA__, __HAVE_SKY__, or nothing \n-   (soft float), appropriately.  */\n+/* Define __HAVE_68881__ or nothing (soft float), appropriately.  */\n #undef CPP_FPU_SPEC\n #if TARGET_DEFAULT & MASK_68881\n #define CPP_FPU_SPEC \"\\\n-%{!mc68000:%{!m68000:%{!m68302:%{!mcpu32:%{!m68332:%{!m5200:%{!msoft-float:%{!mno-68881:%{!mfpa:%{!msky:-D__HAVE_68881__ }}}}}}}}}} \\\n-%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }%{msky:-D__HAVE_SKY__ }\"\n-#else\n-/* This can't currently happen, but we code it anyway to show how it's done.  */\n-#if TARGET_DEFAULT & MASK_FPA\n-#define CPP_FPU_SPEC \\\n-\"%{!msoft-float:%{m68881:-D__HAVE_68881__ }%{!m68881:-D__HAVE_FPA__ }}\"\n+%{!mc68000:%{!m68000:%{!m68302:%{!mcpu32:%{!m68332:%{!m5200:%{!msoft-float:%{!mno-68881:-D__HAVE_68881__ }}}}}}}} \\\n+%{m68881:-D__HAVE_68881__ }\"\n #else\n #define CPP_FPU_SPEC \"\\\n-%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }%{msky:-D__HAVE_SKY__ }\"\n-#endif\n+%{m68881:-D__HAVE_68881__ }\"\n #endif\n \n /* Names to predefine in the preprocessor for this target machine.\n@@ -175,8 +168,6 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define SUBTARGET_EXTRA_SPECS\n \f\n /* Avoid building multilib libraries for the defaults.\n-   t-m68kbare doesn't support -mfpa in the multilib'd libraries, so we don't\n-   either.\n    For targets not handled here, just build the full set of multilibs.\n    The default is m68k 99.9% of the time anyway.  */\n "}, {"sha": "05cffcc96e9ba932c078a55d55bd9f605e4f6644", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 28, "deletions": 372, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -45,16 +45,6 @@ Boston, MA 02111-1307, USA.  */\n /* Needed for use_return_insn.  */\n #include \"flags.h\"\n \n-#ifdef SUPPORT_SUN_FPA\n-\n-/* Index into this array by (register number >> 3) to find the\n-   smallest class which contains that register.  */\n-const enum reg_class regno_reg_class[]\n-  = { DATA_REGS, ADDR_REGS, FP_REGS,\n-      LO_FPA_REGS, LO_FPA_REGS, FPA_REGS, FPA_REGS };\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n /* This flag is used to communicate between movhi and ASM_OUTPUT_CASE_END,\n    if SGS_SWITCH_TABLE.  */\n int switch_table_difference_label_flag;\n@@ -480,31 +470,6 @@ m68k_output_function_prologue (stream, size)\n \t  dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, cfa_offset);\n \t}\n     }\n-#ifdef SUPPORT_SUN_FPA\n-  for (regno = 24; regno < 56; regno++)\n-    if (m68k_save_reg (regno))\n-      {\n-#ifdef MOTOROLA\n-\tasm_fprintf (stream, \"\\tfpmovd %s,-(%Rsp)\\n\",\n-\t\t     reg_names[regno]);\n-#else\n-\tasm_fprintf (stream, \"\\tfpmoved %s,%Rsp@-\\n\",\n-\t\t     reg_names[regno]);\n-#endif\n-\tif (dwarf2out_do_frame ())\n-\t  {\n-\t    char *l = dwarf2out_cfi_label ();\n-\n-\t    cfa_store_offset += 8;\n-\t    if (! frame_pointer_needed)\n-\t      {\n-\t\tcfa_offset = cfa_store_offset;\n-\t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n-\t      }\n-\t    dwarf2out_reg_save (l, regno, -cfa_store_offset);\n-\t  }\n-      }\n-#endif\n   if (TARGET_68881)\n     {\n       for (regno = 16; regno < 24; regno++)\n@@ -712,19 +677,19 @@ m68k_output_function_epilogue (stream, size)\n   register int regno;\n   register int mask, fmask;\n   register int nregs;\n-  HOST_WIDE_INT offset, foffset, fpoffset;\n+  HOST_WIDE_INT offset, foffset;\n   HOST_WIDE_INT fsize = ((size) + 3) & -4;\n   int big = 0;\n \n-  nregs = 0;  fmask = 0; fpoffset = 0;\n+  nregs = 0;  fmask = 0;\n   for (regno = 16; regno < 24; regno++)\n     if (m68k_save_reg (regno))\n       {\n \tnregs++;\n \tfmask |= 1 << (23 - regno);\n       }\n \n-  foffset = fpoffset + nregs * 12;\n+  foffset = nregs * 12;\n   nregs = 0;  mask = 0;\n \n   for (regno = 0; regno < 16; regno++)\n@@ -737,7 +702,7 @@ m68k_output_function_epilogue (stream, size)\n   offset = foffset + nregs * 4;\n   if (offset + fsize >= 0x8000\n       && frame_pointer_needed\n-      && (mask || fmask || fpoffset))\n+      && (mask || fmask))\n     {\n       fprintf (stream, \"\\tmovel $%d,a0\\n\", -fsize);\n       fsize = 0, big = 1;\n@@ -779,22 +744,6 @@ m68k_output_function_epilogue (stream, size)\n \t\t foffset + fsize, fmask);\n     }\n \n-  if (fpoffset != 0)\n-    for (regno = 55; regno >= 24; regno--)\n-      if (m68k_save_reg (regno))\n-\t{\n-\t  if (big)\n-\t    fprintf(stream, \"\\tfpmoved -%d(a6,a0.l), %s\\n\",\n-\t\t    fpoffset + fsize, reg_names[regno]);\n-\t  else if (! frame_pointer_needed)\n-\t    fprintf(stream, \"\\tfpmoved (sp)+, %s\\n\",\n-\t\t    reg_names[regno]);\n-\t  else\n-\t    fprintf(stream, \"\\tfpmoved -%d(a6), %s\\n\",\n-\t\t    fpoffset + fsize, reg_names[regno]);\n-\t  fpoffset -= 8;\n-\t}\n-\n   if (frame_pointer_needed)\n     fprintf (stream, \"\\tunlk a6\\n\");\n   else if (fsize)\n@@ -824,7 +773,7 @@ m68k_output_function_epilogue (stream, size)\n   register int regno;\n   register int mask, fmask;\n   register int nregs;\n-  HOST_WIDE_INT offset, foffset, fpoffset;\n+  HOST_WIDE_INT offset, foffset;\n   HOST_WIDE_INT fsize = (size + 3) & -4;\n   int big = 0;\n   rtx insn = get_last_insn ();\n@@ -844,14 +793,7 @@ m68k_output_function_epilogue (stream, size)\n #ifdef FUNCTION_EXTRA_EPILOGUE\n   FUNCTION_EXTRA_EPILOGUE (stream, size);\n #endif\n-  nregs = 0;  fmask = 0; fpoffset = 0;\n-#ifdef SUPPORT_SUN_FPA\n-  for (regno = 24 ; regno < 56 ; regno++)\n-    if (m68k_save_reg (regno))\n-      nregs++;\n-  fpoffset = nregs * 8;\n-#endif\n-  nregs = 0;\n+  nregs = 0;  fmask = 0;\n   if (TARGET_68881)\n     {\n       for (regno = 16; regno < 24; regno++)\n@@ -861,7 +803,7 @@ m68k_output_function_epilogue (stream, size)\n \t    fmask |= 1 << (23 - regno);\n \t  }\n     }\n-  foffset = fpoffset + nregs * 12;\n+  foffset = nregs * 12;\n   nregs = 0;  mask = 0;\n   for (regno = 0; regno < 16; regno++)\n     if (m68k_save_reg (regno))\n@@ -877,7 +819,7 @@ m68k_output_function_epilogue (stream, size)\n \t     || (! current_function_calls_alloca && leaf_function_p ());\n   if (offset + fsize >= 0x8000\n       && ! restore_from_sp\n-      && (mask || fmask || fpoffset))\n+      && (mask || fmask))\n     {\n #ifdef MOTOROLA\n       asm_fprintf (stream, \"\\t%Omove.l %0I%d,%Ra1\\n\", -fsize);\n@@ -1012,50 +954,6 @@ m68k_output_function_epilogue (stream, size)\n #endif\n \t}\n     }\n-  if (fpoffset != 0)\n-    for (regno = 55; regno >= 24; regno--)\n-      if (m68k_save_reg (regno))\n-        {\n-\t  if (big)\n-\t    {\n-#ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tfpmovd -%d(%s,%Ra1.l), %s\\n\",\n-\t\t\t   fpoffset + fsize,\n-\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   reg_names[regno]);\n-#else\n-\t      asm_fprintf (stream, \"\\tfpmoved %s@(-%d,%Ra1:l), %s\\n\",\n-\t\t\t   reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t   fpoffset + fsize, reg_names[regno]);\n-#endif\n-\t    }\n-\t  else if (restore_from_sp)\n-\t    {\n-#ifdef MOTOROLA\n-\t      asm_fprintf (stream, \"\\tfpmovd (%Rsp)+,%s\\n\",\n-\t\t\t   reg_names[regno]);\n-#else\n-\t      asm_fprintf (stream, \"\\tfpmoved %Rsp@+, %s\\n\",\n-\t\t\t   reg_names[regno]);\n-#endif\n-\t    }\n-\t  else\n-\t    {\n-#ifdef MOTOROLA\n-\t      fprintf (stream, \"\\tfpmovd -\"HOST_WIDE_INT_PRINT_DEC\n-\t\t       \"(%s), %s\\n\",\n-\t\t       fpoffset + fsize,\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       reg_names[regno]);\n-#else\n-\t      fprintf (stream, \"\\tfpmoved %s@(-\"HOST_WIDE_INT_PRINT_DEC\n-\t\t       \"), %s\\n\",\n-\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t       fpoffset + fsize, reg_names[regno]);\n-#endif\n-\t    }\n-\t  fpoffset -= 8;\n-\t}\n   if (frame_pointer_needed)\n     fprintf (stream, \"\\tunlk %s\\n\",\n \t     reg_names[FRAME_POINTER_REGNUM]);\n@@ -2133,10 +2031,6 @@ static const char *\n singlemove_string (operands)\n      rtx *operands;\n {\n-#ifdef SUPPORT_SUN_FPA\n-  if (FPA_REG_P (operands[0]) || FPA_REG_P (operands[1]))\n-    return \"fpmoves %1,%0\";\n-#endif\n   if (GET_CODE (operands[1]) == CONST_INT)\n     return output_move_simode_const (operands);\n   return \"move%.l %1,%0\";\n@@ -2624,18 +2518,7 @@ notice_update_cc (exp, insn)\n      rtx exp;\n      rtx insn;\n {\n-  /* If the cc is being set from the fpa and the expression is not an\n-     explicit floating point test instruction (which has code to deal with\n-     this), reinit the CC.  */\n-  if (((cc_status.value1 && FPA_REG_P (cc_status.value1))\n-       || (cc_status.value2 && FPA_REG_P (cc_status.value2)))\n-      && !(GET_CODE (exp) == PARALLEL\n-\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET\n-\t   && XEXP (XVECEXP (exp, 0, 0), 0) == cc0_rtx))\n-    {\n-      CC_STATUS_INIT; \n-    }\n-  else if (GET_CODE (exp) == SET)\n+  if (GET_CODE (exp) == SET)\n     {\n       if (GET_CODE (SET_SRC (exp)) == CALL)\n \t{\n@@ -2696,8 +2579,7 @@ notice_update_cc (exp, insn)\n       && ADDRESS_REG_P (cc_status.value2)\n       && GET_MODE (cc_status.value2) == QImode)\n     CC_STATUS_INIT;\n-  if (cc_status.value2 != 0\n-      && !(cc_status.value1 && FPA_REG_P (cc_status.value1)))\n+  if (cc_status.value2 != 0)\n     switch (GET_CODE (cc_status.value2))\n       {\n       case PLUS: case MINUS: case MULT:\n@@ -2724,78 +2606,40 @@ notice_update_cc (exp, insn)\n       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n     cc_status.value2 = 0;\n   if (((cc_status.value1 && FP_REG_P (cc_status.value1))\n-       || (cc_status.value2 && FP_REG_P (cc_status.value2)))\n-      && !((cc_status.value1 && FPA_REG_P (cc_status.value1))\n-\t   || (cc_status.value2 && FPA_REG_P (cc_status.value2))))\n+       || (cc_status.value2 && FP_REG_P (cc_status.value2))))\n     cc_status.flags = CC_IN_68881;\n }\n \f\n const char *\n output_move_const_double (operands)\n      rtx *operands;\n {\n-#ifdef SUPPORT_SUN_FPA\n-  if (TARGET_FPA && FPA_REG_P (operands[0]))\n-    {\n-      int code = standard_sun_fpa_constant_p (operands[1]);\n+  int code = standard_68881_constant_p (operands[1]);\n \n-      if (code != 0)\n-\t{\n-\t  static char buf[40];\n-\n-\t  sprintf (buf, \"fpmove%%.d %%%%%d,%%0\", code & 0x1ff);\n-\t  return buf;\n-\t}\n-      return \"fpmove%.d %1,%0\";\n-    }\n-  else\n-#endif\n+  if (code != 0)\n     {\n-      int code = standard_68881_constant_p (operands[1]);\n-\n-      if (code != 0)\n-\t{\n-\t  static char buf[40];\n+      static char buf[40];\n \n-\t  sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n-\t  return buf;\n-\t}\n-      return \"fmove%.d %1,%0\";\n+      sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+      return buf;\n     }\n+  return \"fmove%.d %1,%0\";\n }\n \n const char *\n output_move_const_single (operands)\n      rtx *operands;\n {\n-#ifdef SUPPORT_SUN_FPA\n-  if (TARGET_FPA)\n-    {\n-      int code = standard_sun_fpa_constant_p (operands[1]);\n-\n-      if (code != 0)\n-\t{\n-\t  static char buf[40];\n+  int code = standard_68881_constant_p (operands[1]);\n \n-\t  sprintf (buf, \"fpmove%%.s %%%%%d,%%0\", code & 0x1ff);\n-\t  return buf;\n-\t}\n-      return \"fpmove%.s %1,%0\";\n-    }\n-  else\n-#endif /* defined SUPPORT_SUN_FPA */\n+  if (code != 0)\n     {\n-      int code = standard_68881_constant_p (operands[1]);\n+      static char buf[40];\n \n-      if (code != 0)\n-\t{\n-\t  static char buf[40];\n-\n-\t  sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n-\t  return buf;\n-\t}\n-      return \"fmove%.s %f1,%0\";\n+      sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+      return buf;\n     }\n+  return \"fmove%.s %f1,%0\";\n }\n \n /* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n@@ -2913,165 +2757,6 @@ floating_exact_log2 (x)\n   return 0;\n }\n \f\n-#ifdef SUPPORT_SUN_FPA\n-/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n-   from the Sun FPA's constant RAM.\n-   The value returned, anded with 0x1ff, gives the code to use in fpmove\n-   to get the desired constant.  */\n-\n-static int inited_FPA_table = 0;\n-\n-static const char *const strings_FPA[38] = {\n-/* small rationals */\n-  \"0.0\",\n-  \"1.0\",\n-  \"0.5\",\n-  \"-1.0\",\n-  \"2.0\",\n-  \"3.0\",\n-  \"4.0\",\n-  \"8.0\",\n-  \"0.25\",\n-  \"0.125\",\n-  \"10.0\",\n-  \"-0.5\",\n-/* Decimal equivalents of double precision values */\n-  \"2.718281828459045091\", /* D_E */\n-  \"6.283185307179586477\", /* 2 pi */\n-  \"3.141592653589793116\", /* D_PI */\n-  \"1.570796326794896619\", /* pi/2 */\n-  \"1.414213562373095145\", /* D_SQRT2 */\n-  \"0.7071067811865475244\", /* 1/sqrt(2) */\n-  \"-1.570796326794896619\", /* -pi/2 */\n-  \"1.442695040888963387\", /* D_LOG2ofE */\n-  \"3.321928024887362182\", /* D_LOG2of10 */\n-  \"0.6931471805599452862\", /* D_LOGEof2 */\n-  \"2.302585092994045901\", /* D_LOGEof10 */\n-  \"0.3010299956639811980\", /* D_LOG10of2 */\n-  \"0.4342944819032518167\", /* D_LOG10ofE */\n-/* Decimal equivalents of single precision values */\n-  \"2.718281745910644531\", /* S_E */\n-  \"6.283185307179586477\", /* 2 pi */\n-  \"3.141592741012573242\", /* S_PI */\n-  \"1.570796326794896619\", /* pi/2 */\n-  \"1.414213538169860840\", /* S_SQRT2 */\n-  \"0.7071067811865475244\", /* 1/sqrt(2) */\n-  \"-1.570796326794896619\", /* -pi/2 */\n-  \"1.442695021629333496\", /* S_LOG2ofE */\n-  \"3.321928024291992188\", /* S_LOG2of10 */\n-  \"0.6931471824645996094\", /* S_LOGEof2 */\n-  \"2.302585124969482442\", /* S_LOGEof10 */\n-  \"0.3010300099849700928\", /* S_LOG10of2 */\n-  \"0.4342944920063018799\", /* S_LOG10ofE */\n-};\n-\n-\n-static const int codes_FPA[38] = {\n-/* small rationals */\n-  0x200,\n-  0xe,\n-  0xf,\n-  0x10,\n-  0x11,\n-  0xb1,\n-  0x12,\n-  0x13,\n-  0x15,\n-  0x16,\n-  0x17,\n-  0x2e,\n-/* double precision */\n-  0x8,\n-  0x9,\n-  0xa,\n-  0xb,\n-  0xc,\n-  0xd,\n-  0x27,\n-  0x28,\n-  0x29,\n-  0x2a,\n-  0x2b,\n-  0x2c,\n-  0x2d,\n-/* single precision */\n-  0x8,\n-  0x9,\n-  0xa,\n-  0xb,\n-  0xc,\n-  0xd,\n-  0x27,\n-  0x28,\n-  0x29,\n-  0x2a,\n-  0x2b,\n-  0x2c,\n-  0x2d\n-  };\n-\n-REAL_VALUE_TYPE values_FPA[38];\n-\n-/* This code has been fixed for cross-compilation.  */\n-\n-static void init_FPA_table PARAMS ((void));\n-static void\n-init_FPA_table ()\n-{\n-  enum machine_mode mode;\n-  int i;\n-  REAL_VALUE_TYPE r;\n-\n-  mode = DFmode;\n-  for (i = 0; i < 38; i++)\n-    {\n-      if (i == 25)\n-        mode = SFmode;\n-      r = REAL_VALUE_ATOF (strings_FPA[i], mode);\n-      values_FPA[i] = r;\n-    }\n-  inited_FPA_table = 1;\n-}\n-\n-\n-int\n-standard_sun_fpa_constant_p (x)\n-     rtx x;\n-{\n-  REAL_VALUE_TYPE r;\n-  int i;\n-\n-  if (! inited_FPA_table)\n-    init_FPA_table ();\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\n-  for (i=0; i<12; i++)\n-    {\n-      if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n-        return (codes_FPA[i]);\n-    }\n-\n-  if (GET_MODE (x) == SFmode)\n-    {\n-      for (i=25; i<38; i++)\n-        {\n-          if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n-            return (codes_FPA[i]);\n-        }\n-    }\n-  else\n-    {\n-      for (i=12; i<25; i++)\n-        {\n-          if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n-            return (codes_FPA[i]);\n-        }\n-    }\n-  return 0x0;\n-}\n-#endif /* define SUPPORT_SUN_FPA */\n-\f\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL\n    expression.\n@@ -3113,13 +2798,8 @@ standard_sun_fpa_constant_p (x)\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n    'o' for operands to go directly to output_operand_address (bypassing\n        print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n-   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n-       than directly).  Second part of 'y' below.\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n        or print pair of registers as rx:ry.\n-   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n-       CONST_DOUBLE's as SunFPA constant RAM registers if\n-       possible, so it should not be used except for the SunFPA.\n \n    */\n \n@@ -3129,10 +2809,6 @@ print_operand (file, op, letter)\n      rtx op;\t\t\t/* operand to print */\n      int letter;\t\t/* %<letter> or 0 */\n {\n-#ifdef SUPPORT_SUN_FPA\n-  int i;\n-#endif\n-\n   if (letter == '.')\n     {\n #if defined (MOTOROLA) && !defined (CRDS)\n@@ -3199,24 +2875,12 @@ print_operand (file, op, letter)\n     }\n   else if (GET_CODE (op) == REG)\n     {\n-#ifdef SUPPORT_SUN_FPA\n-      if (REGNO (op) < 16\n-\t  && (letter == 'y' || letter == 'x')\n-\t  && GET_MODE (op) == DFmode)\n-\t{\n-\t  fprintf (file, \"%s:%s\", reg_names[REGNO (op)],\n-\t\t   reg_names[REGNO (op)+1]);\n-\t}\n+      if (letter == 'R')\n+\t/* Print out the second register name of a register pair.\n+\t   I.e., R (6) => 7.  */\n+\tfputs (reg_names[REGNO (op) + 1], file);\n       else\n-#endif\n-\t{\n-\t  if (letter == 'R')\n-\t    /* Print out the second register name of a register pair.\n-\t       I.e., R (6) => 7.  */\n-\t    fputs (reg_names[REGNO (op) + 1], file);\n-\t  else\n-\t    fputs (reg_names[REGNO (op)], file);\n-\t}\n+\tfputs (reg_names[REGNO (op)], file);\n     }\n   else if (GET_CODE (op) == MEM)\n     {\n@@ -3234,14 +2898,6 @@ print_operand (file, op, letter)\n #endif\n \t}\n     }\n-#ifdef SUPPORT_SUN_FPA\n-  else if ((letter == 'y' || letter == 'w')\n-\t   && GET_CODE (op) == CONST_DOUBLE\n-\t   && (i = standard_sun_fpa_constant_p (op)))\n-    {\n-      fprintf (file, \"%%%d\", i & 0x1ff);\n-    }\n-#endif\n   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == SFmode)\n     {\n       REAL_VALUE_TYPE r;"}, {"sha": "383dbb976cb56b1f2d20bd47f7def298419d7310", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 285, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler.\n    Sun 68000/68020 version.\n    Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -46,15 +46,6 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_VERSION fprintf (stderr, \" (68k, MIT syntax)\");\n #endif\n \n-/* Define SUPPORT_SUN_FPA to include support for generating code for\n-   the Sun Floating Point Accelerator, an optional product for Sun 3\n-   machines.  By default, it is not defined.  Avoid defining it unless\n-   you need to output code for the Sun3+FPA architecture, as it has the\n-   effect of slowing down the register set operations in hard-reg-set.h\n-   (total number of registers will exceed number of bits in a long,\n-   if defined, causing the set operations to expand to loops).\n-   SUPPORT_SUN_FPA is typically defined in sun3.h.  */\n-\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n@@ -90,14 +81,6 @@ extern int target_flags;\n #define MASK_SHORT\t32\n #define TARGET_SHORT (target_flags & MASK_SHORT)\n \n-/* Compile with special insns for Sun FPA.  */\n-#define MASK_FPA\t64\n-#define TARGET_FPA (target_flags & MASK_FPA)\n-\n-/* Compile (actually, link) for Sun SKY board.  */\n-#define MASK_SKY\t128\n-#define TARGET_SKY (target_flags & MASK_SKY)\n-\n /* Optimize for 68040, but still allow execution on 68020\n    (-m68020-40 or -m68040).\n    The 68040 will execute all 68030 and 68881/2 instructions, but some\n@@ -182,21 +165,8 @@ extern int target_flags;\n       N_(\"Consider type `int' to be 16 bits wide\") },\t\t\t\\\n     { \"noshort\", - MASK_SHORT,\t\t\t\t\t\t\\\n       N_(\"Consider type `int' to be 32 bits wide\") },\t\t\t\\\n-    { \"fpa\", -(MASK_SKY|MASK_68040_ONLY|MASK_68881),\t\t\t\\\n-      N_(\"Generate code for a Sun FPA\") },\t\t\t\t\\\n-    { \"fpa\", MASK_FPA, \"\" },\t\t\t\t\t\t\\\n-    { \"nofpa\", - MASK_FPA,\t\t\t\t\t\t\\\n-      N_(\"Do not generate code for a Sun FPA\") },\t\t\t\\\n-    { \"sky\", -(MASK_FPA|MASK_68040_ONLY|MASK_68881),\t\t\t\\\n-      N_(\"Generate code for a Sun Sky board\") },\t\t\t\\\n-    { \"sky\", MASK_SKY,\t\t\t\t\t\t\t\\\n-      N_(\"Generate code for a Sun Sky board\") },\t\t\t\\\n-    { \"nosky\", - MASK_SKY,\t\t\t\t\t\t\\\n-      N_(\"Do not use Sky linkage convention\") },\t\t\t\\\n-    { \"68881\", - (MASK_FPA|MASK_SKY),\t\t\t\t\t\\\n-      N_(\"Generate code for a 68881\") },\t\t\t\t\\\n     { \"68881\", MASK_68881, \"\" },\t\t\t\t\t\\\n-    { \"soft-float\", - (MASK_FPA|MASK_SKY|MASK_68040_ONLY|MASK_68881),\t\\\n+    { \"soft-float\", - (MASK_68040_ONLY|MASK_68881),\t\t\t\\\n       N_(\"Generate code with library calls for floating point\") },\t\\\n     { \"68020-40\", -(MASK_5200|MASK_68060|MASK_68040_ONLY),\t\t\\\n       N_(\"Generate code for a 68040, without any new instructions\") },\t\\\n@@ -367,17 +337,11 @@ extern int target_flags;\n    For the 68000, we give the data registers numbers 0-7,\n    the address registers numbers 010-017,\n    and the 68881 floating point registers numbers 020-027.  */\n-#ifndef SUPPORT_SUN_FPA\n #define FIRST_PSEUDO_REGISTER 24\n-#else\n-#define FIRST_PSEUDO_REGISTER 56\n-#endif\n \n /* This defines the register which is used to hold the offset table for PIC.  */\n #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 13 : INVALID_REGNUM)\n \n-#ifndef SUPPORT_SUN_FPA\n-\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the 68000, only the stack pointer is such.  */\n@@ -404,81 +368,12 @@ extern int target_flags;\n   1, 1, 0, 0, 0, 0, 0, 1,   \\\n   1, 1, 0, 0, 0, 0, 0, 0 }\n \n-#else /* SUPPORT_SUN_FPA */\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the 68000, only the stack pointer is such.  */\n-\n-/* fpa0 is also reserved so that it can be used to move data back and\n-   forth between high fpa regs and everything else.  */\n-\n-#define FIXED_REGISTERS        \\\n- {/* Data registers.  */       \\\n-  0, 0, 0, 0, 0, 0, 0, 0,      \\\n-                               \\\n-  /* Address registers.  */    \\\n-  0, 0, 0, 0, 0, 0, 0, 1,      \\\n-                               \\\n-  /* Floating point registers  \\\n-     (if available).  */       \\\n-  0, 0, 0, 0, 0, 0, 0, 0,      \\\n-                               \\\n-  /* Sun3 FPA registers.  */   \\\n-  1, 0, 0, 0, 0, 0, 0, 0,      \\\n-  0, 0, 0, 0, 0, 0, 0, 0,      \\\n-  0, 0, 0, 0, 0, 0, 0, 0,      \\\n-  0, 0, 0, 0, 0, 0, 0, 0 }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS \\\n- {1, 1, 0, 0, 0, 0, 0, 0, \\\n-  1, 1, 0, 0, 0, 0, 0, 1, \\\n-  1, 1, 0, 0, 0, 0, 0, 0, \\\n-  /* FPA registers.  */   \\\n-  1, 1, 1, 1, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0  }\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n \n /* Make sure everything's fine if we *don't* have a given processor.\n    This assumes that putting a register in fixed_regs will keep the\n    compiler's mitts completely off it.  We don't bother to zero it out\n    of register classes.  */\n \n-#ifdef SUPPORT_SUN_FPA\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-{ \t\t\t\t\t\t\t\t\\\n-  int i; \t\t\t\t\t\t\t\\\n-  HARD_REG_SET x; \t\t\t\t\t\t\\\n-  if (! TARGET_FPA)\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPA_REGS]);\t\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\t\\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\t\t\\\n-    } \t\t\t\t\t\t\t\t\\\n-  if (! TARGET_68881)\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\t\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\t\\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\t\t\\\n-    } \t\t\t\t\t\t\t\t\\\n-  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n-      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n-}\n-#else\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n { \t\t\t\t\t\t\t\t\\\n   int i; \t\t\t\t\t\t\t\\\n@@ -495,8 +390,6 @@ extern int target_flags;\n       = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n }\n \n-#endif /* defined SUPPORT_SUN_FPA */\n-\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -509,8 +402,6 @@ extern int target_flags;\n   ((REGNO) >= 16 ? GET_MODE_NUNITS (MODE)\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-#ifndef SUPPORT_SUN_FPA\n-\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the 68000, the cpu registers can hold any mode but the 68881 registers\n    can hold only SFmode or DFmode.  */\n@@ -523,38 +414,6 @@ extern int target_flags;\n \t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n        && GET_MODE_UNIT_SIZE (MODE) <= 12))\n \n-#else /* defined SUPPORT_SUN_FPA */\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 68000, the cpu registers can hold any mode but the 68881 registers\n-   can hold only SFmode or DFmode.  However, the Sun FPA register can\n-   (apparently) hold whatever you feel like putting in them.\n-   If using the fpa, don't put a double in d7/a0.  */\n-\n-/* ??? This is confused.  The check to prohibit d7/a0 overlaps should always\n-   be enabled regardless of whether TARGET_FPA is specified.  It isn't clear\n-   what the other d/a register checks are for.  Every check using REGNO\n-   actually needs to use a range, e.g. 24>=X<56 not <56.  There is probably\n-   no one using this code anymore.  \n-   This code used to be used to suppress register usage for the 68881 by\n-   saying that the 68881 registers couldn't hold values of any mode if there\n-   was no 68881.  This was wrong, because reload (etc.) will still try\n-   to save and restore call-saved registers during, for instance, non-local\n-   goto.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-(((REGNO) < 16\t\t\t\t\t\t\t\t\\\n-  && !(TARGET_FPA\t\t\t\t\t\t\t\\\n-       && GET_MODE_CLASS ((MODE)) != MODE_INT\t\t\t\t\\\n-       && GET_MODE_UNIT_SIZE ((MODE)) > 4\t\t\t\t\\\n-       && (REGNO) < 8 && (REGNO) + GET_MODE_SIZE ((MODE)) / 4 > 8\t\\\n-       && (REGNO) % (GET_MODE_UNIT_SIZE ((MODE)) / 4) != 0))\t\t\\\n- || ((REGNO) >= 16 && (REGNO) < 24\t\t\t\t\t\\\n-     ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n-\t&& GET_MODE_UNIT_SIZE (MODE) <= 12)\t\t\t\t\\\n-     : ((REGNO) < 56 ? TARGET_FPA && GET_MODE_UNIT_SIZE (MODE) <= 8 : 0)))\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -618,8 +477,6 @@ extern int target_flags;\n /* The 68000 has three kinds of registers, so eight classes would be\n    a complete set.  One of them is not needed.  */\n \n-#ifndef SUPPORT_SUN_FPA\n-\n enum reg_class {\n   NO_REGS, DATA_REGS,\n   ADDR_REGS, FP_REGS,\n@@ -660,68 +517,6 @@ enum reg_class {\n \n #define REGNO_REG_CLASS(REGNO) (((REGNO)>>3)+1)\n \n-#else /* defined SUPPORT_SUN_FPA */\n-\n-/*\n- * Notes on final choices:\n- *\n- *   1) Didn't feel any need to union-ize LOW_FPA_REGS with anything\n- * else.\n- *   2) Removed all unions that involve address registers with\n- * floating point registers (left in unions of address and data with\n- * floating point).\n- *   3) Defined GENERAL_REGS as ADDR_OR_DATA_REGS.\n- *   4) Defined ALL_REGS as FPA_OR_FP_OR_GENERAL_REGS.\n- *   4) Left in everything else.\n- */\n-enum reg_class { NO_REGS, LO_FPA_REGS, FPA_REGS, FP_REGS,\n-  FP_OR_FPA_REGS, DATA_REGS, DATA_OR_FPA_REGS, DATA_OR_FP_REGS,\n-  DATA_OR_FP_OR_FPA_REGS, ADDR_REGS, GENERAL_REGS,\n-  GENERAL_OR_FPA_REGS, GENERAL_OR_FP_REGS, ALL_REGS,\n-  LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES \\\n- { \"NO_REGS\", \"LO_FPA_REGS\", \"FPA_REGS\", \"FP_REGS\",  \\\n-   \"FP_OR_FPA_REGS\", \"DATA_REGS\", \"DATA_OR_FPA_REGS\", \"DATA_OR_FP_REGS\",  \\\n-   \"DATA_OR_FP_OR_FPA_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\",  \\\n-   \"GENERAL_OR_FPA_REGS\", \"GENERAL_OR_FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-{\t\t\t\t\t\t\t\\\n- {0, 0},\t\t\t/* NO_REGS */\t\t\\\n- {0xff000000, 0x000000ff},\t/* LO_FPA_REGS */\t\\\n- {0xff000000, 0x00ffffff},\t/* FPA_REGS */\t\t\\\n- {0x00ff0000, 0x00000000},\t/* FP_REGS */\t\t\\\n- {0xffff0000, 0x00ffffff},\t/* FP_OR_FPA_REGS */\t\\\n- {0x000000ff, 0x00000000},\t/* DATA_REGS */\t\t\\\n- {0xff0000ff, 0x00ffffff},\t/* DATA_OR_FPA_REGS */\t\\\n- {0x00ff00ff, 0x00000000},\t/* DATA_OR_FP_REGS */\t\\\n- {0xffff00ff, 0x00ffffff},\t/* DATA_OR_FP_OR_FPA_REGS */\\\n- {0x0000ff00, 0x00000000},\t/* ADDR_REGS */\t\t\\\n- {0x0000ffff, 0x00000000},\t/* GENERAL_REGS */\t\\\n- {0xff00ffff, 0x00ffffff},\t/* GENERAL_OR_FPA_REGS */\\\n- {0x00ffffff, 0x00000000},\t/* GENERAL_OR_FP_REGS */\\\n- {0xffffffff, 0x00ffffff},\t/* ALL_REGS */\t\t\\\n-}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-extern const enum reg_class regno_reg_class[];\n-#define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)>>3])\n-\n-#endif /* SUPPORT_SUN_FPA */\n-\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS GENERAL_REGS\n@@ -734,30 +529,13 @@ extern const enum reg_class regno_reg_class[];\n    that a specific kind of register will not be used for a given target\n    without fiddling with the register classes above.  */\n \n-#ifndef SUPPORT_SUN_FPA\n-\n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n    ((C) == 'd' ? DATA_REGS :\t\t\t\\\n     ((C) == 'f' ? (TARGET_68881 ? FP_REGS :\t\\\n \t\t   NO_REGS) :\t\t\t\\\n      NO_REGS)))\n \n-#else /* defined SUPPORT_SUN_FPA */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n-   ((C) == 'd' ? DATA_REGS :\t\t\t\\\n-    ((C) == 'f' ? (TARGET_68881 ? FP_REGS :\t\\\n-\t\t   NO_REGS) :\t\t\t\\\n-     ((C) == 'x' ? (TARGET_FPA ? FPA_REGS :\t\\\n-\t\t    NO_REGS) :\t\t\t\\\n-      ((C) == 'y' ? (TARGET_FPA ? LO_FPA_REGS :\t\\\n-\t\t     NO_REGS) :\t\t\t\\\n-       NO_REGS)))))\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n@@ -788,18 +566,10 @@ extern const enum reg_class regno_reg_class[];\n  * A small bit of explanation:\n  * \"G\" defines all of the floating constants that are *NOT* 68881\n  * constants.  this is so 68881 constants get reloaded and the\n- * fpmovecr is used.  \"H\" defines *only* the class of constants that\n- * the fpa can use, because these can be gotten at in any fpa\n- * instruction and there is no need to force reloads.\n+ * fpmovecr is used.\n  */\n-#ifndef SUPPORT_SUN_FPA\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n   ((C) == 'G' ? ! (TARGET_68881 && standard_68881_constant_p (VALUE)) : 0 )\n-#else /* defined SUPPORT_SUN_FPA */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? ! (TARGET_68881 && standard_68881_constant_p (VALUE)) : \\\n-   (C) == 'H' ? (TARGET_FPA && standard_sun_fpa_constant_p (VALUE)) : 0)\n-#endif /* defined SUPPORT_SUN_FPA */\n \n /* A C expression that defines the optional machine-dependent constraint\n    letters that can be used to segregate specific types of operands,  \n@@ -877,8 +647,6 @@ extern const enum reg_class regno_reg_class[];\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 68000, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */\n-#ifndef SUPPORT_SUN_FPA\n-\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n  ((CLASS) == FP_REGS ? 1 \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n@@ -888,23 +656,6 @@ extern const enum reg_class regno_reg_class[];\n   (((CLASS1) == FP_REGS && (CLASS2) != FP_REGS)\t        \\\n     || ((CLASS2) == FP_REGS && (CLASS1) != FP_REGS)\t\\\n     ? 4 : 2)\n-\n-#else /* defined SUPPORT_SUN_FPA */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FP_REGS || (CLASS) == FPA_REGS || (CLASS) == LO_FPA_REGS ? 1 \\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Moves between fp regs and other regs are two insns.  */\n-/* Likewise for high fpa regs and other regs.  */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n-  ((((CLASS1) == FP_REGS && (CLASS2) != FP_REGS)\t\\\n-    || ((CLASS2) == FP_REGS && (CLASS1) != FP_REGS)\t\\\n-    || ((CLASS1) == FPA_REGS && (CLASS2) != FPA_REGS)\t\\\n-    || ((CLASS2) == FPA_REGS && (CLASS1) != FPA_REGS))\t\\\n-   ? 4 : 2)\n-\n-#endif /* define SUPPORT_SUN_FPA */\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1209,10 +960,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n ((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n (((REGNO) ^ 020) < 8 || (unsigned) (reg_renumber[REGNO] ^ 020) < 8)\n-#ifdef SUPPORT_SUN_FPA\n-#define REGNO_OK_FOR_FPA_P(REGNO) \\\n-(((REGNO) >= 24 && (REGNO) < 56) || (reg_renumber[REGNO] >= 24 && reg_renumber[REGNO] < 56))\n-#endif\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -1232,14 +979,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n /* 1 if X is an address register  */\n \n #define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n-#ifdef SUPPORT_SUN_FPA\n-/* 1 if X is a register in the Sun FPA.  */\n-#define FPA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FPA_P (REGNO (X)))\n-#else\n-/* Answer must be no if we don't have an FPA.  */\n-#define FPA_REG_P(X) 0\n-#endif\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -1604,26 +1343,11 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-#ifndef SUPPORT_SUN_FPA\n-\n #define REGISTER_NAMES \\\n {\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n  \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n  \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\" }\n \n-#else /* SUPPORTED_SUN_FPA */\n-\n-#define REGISTER_NAMES \\\n-{\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n- \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n- \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\", \\\n- \"fpa0\", \"fpa1\", \"fpa2\", \"fpa3\", \"fpa4\", \"fpa5\", \"fpa6\", \"fpa7\", \\\n- \"fpa8\", \"fpa9\", \"fpa10\", \"fpa11\", \"fpa12\", \"fpa13\", \"fpa14\", \"fpa15\", \\\n- \"fpa16\", \"fpa17\", \"fpa18\", \"fpa19\", \"fpa20\", \"fpa21\", \"fpa22\", \"fpa23\", \\\n- \"fpa24\", \"fpa25\", \"fpa26\", \"fpa27\", \"fpa28\", \"fpa29\", \"fpa30\", \"fpa31\" }\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n /* How to renumber registers for dbx and gdb.\n    On the Sun-3, the floating point registers have numbers\n    18 to 25, not 16 to 23 as they do in the compiler.  */\n@@ -1786,13 +1510,8 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n    'o' for operands to go directly to output_operand_address (bypassing\n        print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n-   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n-       than directly).  Second part of 'y' below.\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n-       or print pair of registers as rx:ry.\n-   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n-       CONST_DOUBLE's as SunFPA constant RAM registers if\n-       possible, so it should not be used except for the SunFPA.  */\n+       or print pair of registers as rx:ry.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n   ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\"}, {"sha": "539ff5858a015c7c14a469d8ecdd10900d1bf6e8", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 30, "deletions": 631, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -47,14 +47,11 @@\n ;;- 'd' one of the data registers can be used.\n ;;- 'f' one of the m68881 registers can be used\n ;;- 'r' either a data or an address register can be used.\n-;;- 'x' if one of the Sun FPA registers\n-;;- 'y' if one of the Low Sun FPA registers (fpa0-fpa15).\n \n ;;- Immediate Floating point operator constraints\n ;;- 'G' a floating point constant that is *NOT* one of the standard\n ;;   68881 constant values (to force calling output_move_const_double\n ;;   to get it from rom if it is a 68881 constant).\n-;;- 'H' one of the standard FPA constant values\n ;;\n ;;   See the functions standard_XXX_constant_p in output-m68k.c for more\n ;; info.\n@@ -115,165 +112,6 @@\n ;;- divu.l <ea>,Dr:Dq; muls.l <ea>,Dr:Dq; mulu.l <ea>,Dr:Dq; and\n ;;- fscale.  The TARGET_68060 flag turns the use of the opcodes off.\n \n-;;- \t\tFPA port explanation:\n-\n-;;-\t\tUsage of the Sun FPA and the 68881 together\n-\n-;;- The current port of gcc to the sun fpa disallows use of the m68881\n-;;- instructions completely if code is targeted for the fpa.  This is\n-;;- for the following reasons:\n-\n-;;- 1) Expressing the preference hierarchy (ie. use the fpa if you\n-;;- can, the 68881 otherwise, and data registers only if you are\n-;;- forced to it) is a bitch with the current constraint scheme,\n-;;- especially since it would have to work for any combination of\n-;;- -mfpa, -m68881.\n-\n-;;- 2) There are no instructions to move between the two types of\n-;;- registers; the stack must be used as an intermediary.\n-\n-;;- It could indeed be done; I think the best way would be to have\n-;;- separate patterns for TARGET_FPA (which implies a 68881),\n-;;- TARGET_68881, and no floating point co-processor.  Use\n-;;- define_expands for all of the named instruction patterns, and\n-;;- include code in the FPA instruction to deal with the 68881 with\n-;;- preferences specifically set to favor the fpa.  Some of this has\n-;;- already been done:\n-;;-\n-;;- \t1) Separation of most of the patterns out into a TARGET_FPA\n-;;- case and a TARGET_68881 case (the exceptions are the patterns\n-;;- which would need one define_expand and three define_insn's under\n-;;- it (with a lot of duplicate code between them) to replace the\n-;;- current single define_insn.  These are mov{[ds]f,[ds]i} and the\n-;;- first two patterns in the md.\n-;;-\n-;;- Some would still have to be done:\n-;;-\n-;;-\t1) Add code to the fpa patterns which correspond to 68881\n-;;- patterns to deal with the 68881 case (including preferences!).\n-;;- What you might actually do here is combine the fpa and 68881 code\n-;;- back together into one pattern for those instructions where it's\n-;;- absolutely necessary and save yourself some duplicate code.  I'm\n-;;- not completely sure as to whether you could get away with doing\n-;;- this only for the mov* insns, or if you'd have to do it for all\n-;;- named insns.\n-;;- \t2) Add code to the mov{[ds]f,[ds]i} instructions to handle\n-;;- moving between fpa regs and 68881 regs.\n-\n-;;- Since the fpa is more powerful than the 68881 and also has more\n-;;- registers, and since I think the resultant md would be medium ugly\n-;;- (lot's of duplicate code, ugly constraint strings), I elected not\n-;;- to do this change.\n-\n-;;- Another reason why someone *might* want to do the change is to\n-;;- control which register classes are accessed in a slightly cleaner\n-;;- way than I have.  See the blurb on CONDITIONAL_REGISTER_USAGE in\n-;;- the internals manual.\n-\n-;;- Yet another reason why someone might want to do this change is to\n-;;- allow use of some of the 68881 insns which have no equivalent on\n-;;- the fpa.  The sqrt instruction comes fairly quickly to mind.\n-\n-;;- If this is ever done, don't forget to change sun3.h so that\n-;;- it *will* define __HAVE_68881__ when the FPA is in use.\n-\n-;;-\t\tCondition code hack\n-\n-;;- When a floating point compare is done in the fpa, the resulting\n-;;- condition codes are left in the fpastatus register.  The values in\n-;;- this register must be moved into the 68000 cc register before any\n-;;- jump is executed.  Once this has been done, regular jump\n-;;- instructions are fine (ie. floating point jumps are not necessary.\n-;;- They are only done if the cc is in the 68881).\n-\n-;;- The instructions that move the fpastatus register to the 68000\n-;;- register clobber a data register (the move cannot be done direct).\n-;;- These instructions might be bundled either with the compare\n-;;- instruction, or the branch instruction.  If we were using both the\n-;;- fpa and the 68881 together, we would wish to only mark the\n-;;- register clobbered if we were doing the compare in the fpa, but I\n-;;- think that that decision (whether to clobber the register or not)\n-;;- must be done before register allocation (makes sense) and hence we\n-;;- can't know if the floating point compare will be done in the fpa\n-;;- or the fp.  So whenever we are asked for code that uses the fpa,\n-;;- we will mark a data register as clobbered.  This is reasonable, as\n-;;- almost all floating point compare operations done with fpa code\n-;;- enabled will be done in the fpa.  It's even more reasonable since\n-;;- we decided to make the 68881 and the fpa mutually exclusive.\n-\n-;;- We place to code to move the fpastatus register inside of a\n-;;- define_expand so that we can do it conditionally based on whether\n-;;- we are targeting an fpa or not.\n-\n-;;- This still leaves us with the question of where we wish to put the\n-;;- code to move the fpastatus reg.  If we put it in the compare\n-;;- instruction, we can restrict the clobbering of the register to\n-;;- floating point compares, but we can't take advantage of floating\n-;;- point subtracts & etc. that alter the fpastatus register.  If we\n-;;- put it in the branch instruction, all branches compiled with fpa\n-;;- code enabled will clobber a data register, but we will be able to\n-;;- take advantage of fpa subtracts.  This balance favors putting the\n-;;- code in with the compare instruction.\n-\n-;;- Note that if some enterprising hacker should decide to switch\n-;;- this, he'll need to modify the code in NOTICE_UPDATE_CC.\n-\n-;;-\t\tUsage of the top 16 fpa registers\n-\n-;;- The only locations which we may transfer fpa registers 16-31 from\n-;;- or to are the fpa registers 0-15.  (68000 registers and memory\n-;;- locations are impossible).  This causes problems in gcc, which\n-;;- assumes that mov?? instructions require no additional registers\n-;;- (see section 11.7) and since floating point moves *must* be\n-;;- supported into general registers (see section 12.3 under\n-;;- HARD_REGNO_OK_FOR_MODE_P) from anywhere.\n-\n-;;- My solution was to reserve fpa0 for moves into or out of these top\n-;;- 16 registers and to disparage the choice to reload into or out of\n-;;- these registers as much as I could.  That alternative is always\n-;;- last in the list, so it will not be used unless all else fails.  I\n-;;- will note that according to my current information, sun's compiler\n-;;- doesn't use these top 16 registers at all.\n-\n-;;- There is another possible way to do it.  I *believe* that if you\n-;;- make absolutely sure that the code will not be executed in the\n-;;- reload pass, you can support the mov?? names with define_expands\n-;;- which require new registers.  This may be possible by the\n-;;- appropriate juggling of constraints.  I may come back to this later.\n-\n-;;- \t\tUsage of constant RAM\n-\n-;;- This has been handled correctly (I believe) but the way I've done\n-;;- it could use a little explanation.  The constant RAM can only be\n-;;- accessed when the instruction is in \"command register\" mode.\n-;;- \"command register\" mode means that no accessing of memory or the\n-;;- 68000 registers is being done.  This can be expressed easily in\n-;;- constraints, so generally the mode of the instruction is\n-;;- determined by a branch off of which_alternative.  In outputting\n-;;- instructions, a 'w' means to output an access to the constant ram\n-;;- (if the arg is CONST_DOUBLE and is one of the available\n-;;- constants), and 'x' means to output a register pair (if the arg is\n-;;- a 68000 register) and a 'y' is the combination of the above two\n-;;- processes.  You use a 'y' in two operand DF instructions where you\n-;;- *know* the other operand is an fpa register, you use an 'x' in DF\n-;;- instructions where the arg might be a 68000 register and the\n-;;- instruction is *not* in \"command register\" mode, and you use a 'w'\n-;;- in two situations: 1) The instruction *is* in command register\n-;;- mode (and hence won't be accessing 68000 registers), or 2) The\n-;;- instruction is a two operand SF instruction where you know the\n-;;- other operand is an fpa register.\n-\n-;;-\t\tOptimization issues\n-\n-;;- I actually think that I've included all of the fpa instructions\n-;;- that should be included.  Note that if someone is interested in\n-;;- doing serious floating point work on the sun fpa, I would advise\n-;;- the use of the \"asm\" instruction in gcc to allow you to use the\n-;;- sin, cos, and exponential functions on the fpa board.\n-\n-;;- END FPA Explanation Section.\n-\n-\n ;;- Some of these insn's are composites of several m68000 op codes.\n ;;- The assembler (or final @@??) insures that the appropriate one is\n ;;- selected.\n@@ -286,8 +124,6 @@\n {\n   if (FP_REG_P (operands[1]))\n     return \\\"fmove%.d %f1,%0\\\";\n-  if (FPA_REG_P (operands[1]))\n-    return \\\"fpmove%.d %1, %x0\\\";\n   return output_move_double (operands);\n }\")\n \n@@ -402,24 +238,12 @@\n (define_expand \"tstsf\"\n   [(set (cc0)\n \t(match_operand:SF 0 \"general_operand\" \"\"))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\n {\n   m68k_last_compare_had_fp_operands = 1;\n-  if (TARGET_FPA)\n-    {\n-      emit_insn (gen_tstsf_fpa (operands[0]));\n-      DONE;\n-    }\n }\")\n \n-(define_insn \"tstsf_fpa\"\n-  [(set (cc0)\n-\t(match_operand:SF 0 \"general_operand\" \"xmdF\"))\n-   (clobber (match_scratch:SI 1 \"=d\"))]\n-  \"TARGET_FPA\"\n-  \"fptst%.s %x0\\;fpmove fpastatus,%1\\;movw %1,cc\")\n-\n (define_insn \"\"\n   [(set (cc0)\n \t(match_operand:SF 0 \"general_operand\" \"fdm\"))]\n@@ -435,24 +259,12 @@\n (define_expand \"tstdf\"\n   [(set (cc0)\n \t(match_operand:DF 0 \"general_operand\" \"\"))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\n {\n   m68k_last_compare_had_fp_operands = 1;\n-  if (TARGET_FPA)\n-    {\n-      emit_insn (gen_tstsf_fpa (operands[0]));\n-      DONE;\n-    }\n }\")\n \n-(define_insn \"tstdf_fpa\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"xrmF\"))\n-   (clobber (match_scratch:SI 1 \"=d\"))]\n-  \"TARGET_FPA\"\n-  \"fptst%.d %x0\\;fpmove fpastatus,%1\\;movw %1,cc\")\n-\n (define_insn \"\"\n   [(set (cc0)\n \t(match_operand:DF 0 \"general_operand\" \"fm\"))]\n@@ -654,25 +466,12 @@\n   [(set (cc0)\n \t(compare (match_operand:DF 0 \"general_operand\" \"\")\n \t\t (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\n {\n   m68k_last_compare_had_fp_operands = 1;\n-  if (TARGET_FPA)\n-    {\n-      emit_insn (gen_cmpdf_fpa (operands[0], operands[1]));\n-      DONE;\n-    }\n }\")\n \n-(define_insn \"cmpdf_fpa\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"x,y\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"xH,rmF\")))\n-   (clobber (match_scratch:SI 2 \"=d,d\"))]\n-  \"TARGET_FPA\"\n-  \"fpcmp%.d %y1,%0\\;fpmove fpastatus,%2\\;movw %2,cc\")\n-\n (define_insn \"\"\n   [(set (cc0)\n \t(compare (match_operand:DF 0 \"general_operand\" \"f,mG\")\n@@ -708,25 +507,12 @@\n  [(set (cc0)\n        (compare (match_operand:SF 0 \"general_operand\" \"\")\n \t\t(match_operand:SF 1 \"general_operand\" \"\")))]\n- \"TARGET_68881 || TARGET_FPA\"\n+ \"TARGET_68881\"\n  \"\n {\n   m68k_last_compare_had_fp_operands = 1;\n-  if (TARGET_FPA)\n-    {\n-      emit_insn (gen_cmpsf_fpa (operands[0], operands[1]));\n-      DONE;\n-    }\n }\")\n \n-(define_insn \"cmpsf_fpa\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"x,y\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"xH,rmF\")))\n-   (clobber (match_scratch:SI 2 \"=d,d\"))]\n-  \"TARGET_FPA\"\n-  \"fpcmp%.s %w1,%x0\\;fpmove fpastatus,%2\\;movw %2,cc\")\n-\n (define_insn \"\"\n   [(set (cc0)\n \t(compare (match_operand:SF 0 \"general_operand\" \"f,mdG\")\n@@ -976,17 +762,12 @@\n (define_insn \"\"\n   ;; Notes: make sure no alternative allows g vs g.\n   ;; We don't allow f-regs since fixed point cannot go in them.\n-  ;; We do allow y and x regs since fixed point is allowed in them.\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d,a<,y,!*x*r*m\")\n-        (match_operand:SI 1 \"general_src_operand\" \"daymSKT,n,i,g,*x*r*m\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d,a<\")\n+        (match_operand:SI 1 \"general_src_operand\" \"daymSKT,n,i\"))]\n \n   \"!TARGET_5200\"\n   \"*\n {\n-  if (which_alternative == 4)\n-    return \\\"fpmove%.l %x1,fpa0\\;fpmove%.l fpa0,%x0\\\";\n-  if (FPA_REG_P (operands[1]) || FPA_REG_P (operands[0]))\n-    return \\\"fpmove%.l %x1,%x0\\\";\n   return output_move_simode (operands);\n }\")\n \n@@ -1095,32 +876,11 @@\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rmf,x,y,rm,!x,!rm\")\n-\t(match_operand:SF 1 \"general_operand\" \"rmfF,xH,rmF,y,rm,x\"))]\n-;  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rmf\")\n-;\t(match_operand:SF 1 \"general_operand\" \"rmfF\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rmf\")\n+\t(match_operand:SF 1 \"general_operand\" \"rmfF\"))]\n   \"!TARGET_5200\"\n   \"*\n {\n-  if (which_alternative >= 4)\n-    return \\\"fpmove%.s %1,fpa0\\;fpmove%.s fpa0,%0\\\";\n-  if (FPA_REG_P (operands[0]))\n-    {\n-      if (FPA_REG_P (operands[1]))\n-\treturn \\\"fpmove%.s %x1,%x0\\\";\n-      else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_single (operands);\n-      else if (FP_REG_P (operands[1]))\n-        return \\\"fmove%.s %1,sp@-\\;fpmove%.d sp@+, %0\\\";\n-      return \\\"fpmove%.s %x1,%x0\\\";\n-    }\n-  if (FPA_REG_P (operands[1]))\n-    {\n-      if (FP_REG_P (operands[0]))\n-\treturn \\\"fpmove%.s %x1,sp@-\\;fmove%.s sp@+,%0\\\";\n-      else\n-\treturn \\\"fpmove%.s %x1,%x0\\\";\n-    }\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n@@ -1189,32 +949,13 @@\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=*rm,*rf,*rf,&*rof<>,y,*rm,x,!x,!*rm\")\n-\t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\t\"*rf,m,0,*rofE<>,*rmE,y,xH,*rm,x\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=rm,rf,rf,&rof<>\")\n+\t(match_operand:DF 1 \"general_operand\" \"*rf,m,0,*rofE<>\"))]\n ;  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=rm,&rf,&rof<>\")\n ;\t(match_operand:DF 1 \"general_operand\" \"rf,m,rofF<>\"))]\n   \"!TARGET_5200\"\n   \"*\n {\n-  if (which_alternative == 7)\n-    return \\\"fpmove%.d %x1,fpa0\\;fpmove%.d fpa0,%x0\\\";\n-  if (FPA_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_double (operands);\n-      if (FP_REG_P (operands[1]))\n-        return \\\"fmove%.d %1,sp@-\\;fpmove%.d sp@+,%x0\\\";\n-      return \\\"fpmove%.d %x1,%x0\\\";\n-    }\n-  else if (FPA_REG_P (operands[1]))\n-    {\n-      if (FP_REG_P(operands[0]))\n-        return \\\"fpmove%.d %x1,sp@-\\;fmoved sp@+,%0\\\";\n-      else\n-        return \\\"fpmove%.d %x1,%x0\\\";\n-    }\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n@@ -1373,19 +1114,15 @@\n ;; movdi can apply to fp regs in some cases\n (define_insn \"\"\n   ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r,&ro<>,y,rm,!*x,!rm\")\n-\t(match_operand:DI 1 \"general_operand\" \"rF,m,roi<>F,rmiF,y,rmF,*x\"))]\n-;  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,&r,&ro<>,!&rm,!&f,y,rm,x,!x,!rm\")\n-;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF,rfmF,rmi,y,rm,x\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r,&ro<>\")\n+\t(match_operand:DI 1 \"general_operand\" \"rF,m,roi<>F\"))]\n+;  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,&r,&ro<>,!&rm,!&f\")\n+;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF\"))]\n ;  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,&rf,&ro<>,!&rm,!&f\")\n ;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF,rfF\"))]\n   \"!TARGET_5200\"\n   \"*\n {\n-  if (which_alternative == 8)\n-    return \\\"fpmove%.d %x1,fpa0\\;fpmove%.d fpa0,%x0\\\";\n-  if (FPA_REG_P (operands[0]) || FPA_REG_P (operands[1]))\n-    return \\\"fpmove%.d %x1,%x0\\\";\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n@@ -1849,16 +1586,9 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:DF\n \t (match_operand:SF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(float_extend:DF\n-\t (match_operand:SF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpstod %w1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=*fdm,f\")\n \t(float_extend:DF\n@@ -1891,21 +1621,13 @@\n \n ;; This cannot output into an f-reg because there is no way to be\n ;; sure of truncating in that case.\n-;; But on the Sun FPA, we can be sure.\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(float_truncate:SF\n \t  (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(float_truncate:SF\n-\t  (match_operand:DF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpdtos %y1,%0\")\n-\n ;; On the '040 we can truncate in a register accurately and easily.\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n@@ -1937,15 +1659,9 @@\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(float:SF (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=y,x\")\n-\t(float:SF (match_operand:SI 1 \"general_operand\" \"rmi,x\")))]\n-  \"TARGET_FPA\"\n-  \"fpltos %1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n@@ -1955,15 +1671,9 @@\n (define_expand \"floatsidf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(float:DF (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=y,x\")\n-\t(float:DF (match_operand:SI 1 \"general_operand\" \"rmi,x\")))]\n-  \"TARGET_FPA\"\n-  \"fpltod %1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(float:DF (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n@@ -2097,21 +1807,6 @@\n \t(fix:SI (match_operand:DF 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n   \"fmove%.l %1,%0\")\n-\n-;; Convert a float to an integer.\n-;; On the Sun FPA, this is done in one step.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF\"))))]\n-  \"TARGET_FPA\"\n-  \"fpstol %w1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"xH,rmF\"))))]\n-  \"TARGET_FPA\"\n-  \"fpdtol %y1,%0\")\n \f\n ;; add instructions\n \n@@ -2622,25 +2317,9 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"general_operand\" \"\")\n \t\t (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%xH,y\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"xH,dmF\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpadd%.d %y2,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fpadd%.d %y1,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpadd3%.d %w2,%w1,%0\\\";\n-  return \\\"fpadd3%.d %x2,%x1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(plus:DF (float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n@@ -2678,25 +2357,9 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(plus:SF (match_operand:SF 1 \"general_operand\" \"\")\n \t\t (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%xH,y\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpadd%.s %w2,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fpadd%.s %w1,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpadd3%.s %w2,%w1,%0\\\";\n-  return \\\"fpadd3%.s %2,%1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(plus:SF (float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n@@ -2907,25 +2570,9 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(minus:DF (match_operand:DF 1 \"general_operand\" \"\")\n \t\t  (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y,y\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"xH,y,dmF\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"xH,dmF,0\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fprsub%.d %y1,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpsub%.d %y2,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpsub3%.d %w2,%w1,%0\\\";\n-  return \\\"fpsub3%.d %x2,%x1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n@@ -2963,25 +2610,9 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(minus:SF (match_operand:SF 1 \"general_operand\" \"\")\n \t\t  (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y,y\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"xH,y,rmF\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"xH,rmF,0\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fprsub%.s %w1,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpsub%.s %w2,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpsub3%.s %w2,%w1,%0\\\";\n-  return \\\"fpsub3%.s %2,%1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n@@ -3287,27 +2918,9 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"general_operand\" \"\")\n \t\t (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%xH,y\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[1], operands[2]))\n-    return \\\"fpsqr%.d %y1,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpmul%.d %y2,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fpmul%.d %y1,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpmul3%.d %w2,%w1,%0\\\";\n-  return \\\"fpmul3%.d %x2,%x1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:DF (float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n@@ -3352,27 +2965,9 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(mult:SF (match_operand:SF 1 \"general_operand\" \"\")\n \t\t (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%xH,y\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[1], operands[2]))\n-    return \\\"fpsqr%.s %w1,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpmul%.s %w2,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fpmul%.s %w1,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpmul3%.s %w2,%w1,%0\\\";\n-  return \\\"fpmul3%.s %2,%1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:SF (float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n@@ -3438,25 +3033,9 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(div:DF (match_operand:DF 1 \"general_operand\" \"\")\n \t\t(match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y,y\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"xH,y,rmF\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"xH,rmF,0\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fprdiv%.d %y1,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpdiv%.d %y2,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpdiv3%.d %w2,%w1,%0\\\";\n-  return \\\"fpdiv3%.d %x2,%x1,%x0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n@@ -3494,25 +3073,9 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"general_operand\" \"\")\n \t\t(match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n+  \"TARGET_68881\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y,y\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"xH,y,rmF\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"xH,rmF,0\")))]\n-  \"TARGET_FPA\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    return \\\"fpdiv%.s %w2,%0\\\";\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"fprdiv%.s %w1,%0\\\";\n-  if (which_alternative == 0)\n-    return \\\"fpdiv3%.s %w2,%w1,%0\\\";\n-  return \\\"fpdiv3%.s %2,%1,%0\\\";\n-}\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n@@ -4237,7 +3800,7 @@\n   \"\"\n   \"\n {\n-  if (!TARGET_FPA && !TARGET_68881)\n+  if (!TARGET_68881)\n     {\n       rtx result;\n       rtx target;\n@@ -4258,12 +3821,6 @@\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(neg:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpneg%.s %w1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,d\")\n \t(neg:SF (match_operand:SF 1 \"general_operand\" \"fdmF,0\")))]\n@@ -4286,7 +3843,7 @@\n   \"\"\n   \"\n {\n-  if (!TARGET_FPA && !TARGET_68881)\n+  if (!TARGET_68881)\n     {\n       rtx result;\n       rtx target;\n@@ -4314,12 +3871,6 @@\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(neg:DF (match_operand:DF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpneg%.d %y1, %0\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,d\")\n \t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF,0\")))]\n@@ -4371,7 +3922,7 @@\n   \"\"\n   \"\n {\n-  if (!TARGET_FPA && !TARGET_68881)\n+  if (!TARGET_68881)\n     {\n       rtx result;\n       rtx target;\n@@ -4392,12 +3943,6 @@\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(abs:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpabs%.s %y1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(abs:SF (match_operand:SF 1 \"general_operand\" \"fdmF\")))]\n@@ -4415,7 +3960,7 @@\n   \"\"\n   \"\n {\n-  if (!TARGET_FPA && !TARGET_68881)\n+  if (!TARGET_68881)\n     {\n       rtx result;\n       rtx target;\n@@ -4443,12 +3988,6 @@\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,y\")\n-\t(abs:DF (match_operand:DF 1 \"general_operand\" \"xH,rmF\")))]\n-  \"TARGET_FPA\"\n-  \"fpabs%.d %y1,%0\")\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n@@ -7806,142 +7345,6 @@\n }\")\n \n \f\n-;; FPA multiply and add.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(plus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%x,dmF,y\")\n-\t\t\t  (match_operand:DF 2 \"general_operand\" \"xH,y,y\"))\n-\t\t (match_operand:DF 3 \"general_operand\" \"xH,y,dmF\")))]\n-   \"TARGET_FPA\"\n-   \"@\n-    fpma%.d %1,%w2,%w3,%0\n-    fpma%.d %x1,%x2,%x3,%0\n-    fpma%.d %x1,%x2,%x3,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(plus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%x,ydmF,y\")\n-\t\t\t  (match_operand:SF 2 \"general_operand\" \"xH,y,ydmF\"))\n-\t\t (match_operand:SF 3 \"general_operand\" \"xH,ydmF,ydmF\")))]\n-   \"TARGET_FPA\"\n-   \"@\n-    fpma%.s %1,%w2,%w3,%0\n-    fpma%.s %1,%2,%3,%0\n-    fpma%.s %1,%2,%3,%0\")\n-\n-;; FPA Multiply and subtract\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"xH,rmF,y\")\n-\t\t  (mult:DF (match_operand:DF 2 \"general_operand\" \"%xH,y,y\")\n-\t\t\t   (match_operand:DF 3 \"general_operand\" \"x,y,rmF\"))))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpms%.d %3,%w2,%w1,%0\n-   fpms%.d %x3,%2,%x1,%0\n-   fpms%.d %x3,%2,%x1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF,yrmF\")\n-\t\t  (mult:SF (match_operand:SF 2 \"general_operand\" \"%xH,rmF,y\")\n-\t\t\t   (match_operand:SF 3 \"general_operand\" \"x,y,yrmF\"))))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpms%.s %3,%w2,%w1,%0\n-   fpms%.s %3,%2,%1,%0\n-   fpms%.s %3,%2,%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(minus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%xH,y,y\")\n-\t\t\t   (match_operand:DF 2 \"general_operand\" \"x,y,rmF\"))\n-\t\t  (match_operand:DF 3 \"general_operand\" \"xH,rmF,y\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpmr%.d %2,%w1,%w3,%0\n-   fpmr%.d %x2,%1,%x3,%0\n-   fpmr%.d %x2,%1,%x3,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(minus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%xH,rmF,y\")\n-\t\t\t   (match_operand:SF 2 \"general_operand\" \"x,y,yrmF\"))\n-\t\t  (match_operand:SF 3 \"general_operand\" \"xH,rmF,yrmF\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpmr%.s %2,%w1,%w3,%0\n-   fpmr%.s %x2,%1,%x3,%0\n-   fpmr%.s %x2,%1,%x3,%0\")\n-\n-;; FPA Add and multiply\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:DF (plus:DF (match_operand:DF 1 \"general_operand\" \"%xH,y,y\")\n-\t\t\t  (match_operand:DF 2 \"general_operand\" \"x,y,rmF\"))\n-\t\t (match_operand:DF 3 \"general_operand\" \"xH,rmF,y\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpam%.d %2,%w1,%w3,%0\n-   fpam%.d %x2,%1,%x3,%0\n-   fpam%.d %x2,%1,%x3,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:SF (plus:SF (match_operand:SF 1 \"general_operand\" \"%xH,rmF,y\")\n-\t\t\t  (match_operand:SF 2 \"general_operand\" \"x,y,yrmF\"))\n-\t\t (match_operand:SF 3 \"general_operand\" \"xH,rmF,yrmF\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpam%.s %2,%w1,%w3,%0\n-   fpam%.s %x2,%1,%x3,%0\n-   fpam%.s %x2,%1,%x3,%0\")\n-\n-;;FPA Subtract and multiply\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:DF (minus:DF (match_operand:DF 1 \"general_operand\" \"xH,y,y\")\n-\t\t\t   (match_operand:DF 2 \"general_operand\" \"x,y,rmF\"))\n-\t\t (match_operand:DF 3 \"general_operand\" \"xH,rmF,y\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpsm%.d %2,%w1,%w3,%0\n-   fpsm%.d %x2,%1,%x3,%0\n-   fpsm%.d %x2,%1,%x3,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"xH,rmF,y\")\n-\t\t (minus:DF (match_operand:DF 2 \"general_operand\" \"xH,y,y\")\n-\t\t\t   (match_operand:DF 3 \"general_operand\" \"x,y,rmF\"))))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpsm%.d %3,%w2,%w1,%0\n-   fpsm%.d %x3,%2,%x1,%0\n-   fpsm%.d %x3,%2,%x1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:SF (minus:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF,y\")\n-\t\t\t   (match_operand:SF 2 \"general_operand\" \"x,y,yrmF\"))\n-\t\t (match_operand:SF 3 \"general_operand\" \"xH,rmF,yrmF\")))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpsm%.s %2,%w1,%w3,%0\n-   fpsm%.s %x2,%1,%x3,%0\n-   fpsm%.s %x2,%1,%x3,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,y,y\")\n-\t(mult:SF (match_operand:SF 1 \"general_operand\" \"xH,rmF,yrmF\")\n-\t\t (minus:SF (match_operand:SF 2 \"general_operand\" \"xH,rmF,y\")\n-\t\t\t   (match_operand:SF 3 \"general_operand\" \"x,y,yrmF\"))))]\n-  \"TARGET_FPA\"\n-  \"@\n-   fpsm%.s %3,%w2,%w1,%0\n-   fpsm%.s %x3,%2,%x1,%0\n-   fpsm%.s %x3,%2,%x1,%0\")\n-\n (define_expand \"tstxf\"\n   [(set (cc0)\n \t(match_operand:XF 0 \"nonimmediate_operand\" \"\"))]\n@@ -8272,8 +7675,6 @@\n   \"\"\n   \"\n {\n-  /* ??? There isn't an FPA define_insn so we could handle it here too.\n-     For now we don't (paranoia).  */\n   if (!TARGET_68881)\n     {\n       rtx result;\n@@ -8321,8 +7722,6 @@\n   \"\"\n   \"\n {\n-  /* ??? There isn't an FPA define_insn so we could handle it here too.\n-     For now we don't (paranoia).  */\n   if (!TARGET_68881)\n     {\n       rtx result;"}, {"sha": "2d24d4a602ebb1d7ca2a7b4b5b6f3af4ab267e8e", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler,\n    for m68k (including m68010) NetBSD platforms using the\n    ELF object format.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Wasabi Systems. Inc.\n \n    This file is derived from <m68k/m68kv4.h>, <m68k/m68kelf.h>,\n@@ -187,26 +187,11 @@ while (0)\n \n #undef REGISTER_NAMES\n \n-#ifndef SUPPORT_SUN_FPA\n-\n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n {\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t\\\n  \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t\\\n  \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n \n-#else /* SUPPORT_SUN_FPA */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t\\\n- \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t\\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\",\t\\\n- \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\",\"%fpa7\",\t\\\n- \"%fpa8\", \"%fpa9\", \"%fpa10\",\"%fpa11\",\"%fpa12\",\"%fpa13\",\"%fpa14\",\"%fpa15\", \\\n- \"%fpa16\",\"%fpa17\",\"%fpa18\",\"%fpa19\",\"%fpa20\",\"%fpa21\",\"%fpa22\",\"%fpa23\", \\\n- \"%fpa24\",\"%fpa25\",\"%fpa26\",\"%fpa27\",\"%fpa28\",\"%fpa29\",\"%fpa30\",\"%fpa31\" }\n-\n-#endif /* ! SUPPORT_SUN_FPA */\n-\n \n /* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n    keep switch tables in the text section.  */"}, {"sha": "470c066c9958b5de5a7ea22683f0ff7e37c9779a", "filename": "gcc/config/m68k/sgs.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for m68k targets using\n    assemblers derived from AT&T \"SGS\" releases.\n-   Copyright (C) 1991, 1993, 1996, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1993, 1996, 2000, 2003 Free Software Foundation, Inc.\n    Written by Fred Fish (fnf@cygnus.com)\n \n This file is part of GNU CC.\n@@ -79,26 +79,11 @@ Boston, MA 02111-1307, USA.  */\n \n #undef REGISTER_NAMES\n \n-#ifndef SUPPORT_SUN_FPA\n-\n #define REGISTER_NAMES \\\n {\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n  \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t     \\\n  \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n \n-#else /* SUPPORTED_SUN_FPA */\n-\n-#define REGISTER_NAMES \\\n-{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n- \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t     \\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\",\t     \\\n- \"%fpa0\", \"%fpa1\", \"%fpa2\", \"%fpa3\", \"%fpa4\", \"%fpa5\", \"%fpa6\",\"%fpa7\",\t     \\\n- \"%fpa8\", \"%fpa9\", \"%fpa10\",\"%fpa11\",\"%fpa12\",\"%fpa13\",\"%fpa14\",\"%fpa15\",    \\\n- \"%fpa16\",\"%fpa17\",\"%fpa18\",\"%fpa19\",\"%fpa20\",\"%fpa21\",\"%fpa22\",\"%fpa23\",    \\\n- \"%fpa24\",\"%fpa25\",\"%fpa26\",\"%fpa27\",\"%fpa28\",\"%fpa29\",\"%fpa30\",\"%fpa31\" }\n-\n-#endif /* defined SUPPORT_SUN_FPA */\n-\n /* This is how to output an assembler line that says to advance the\n    location counter to a multiple of 2**LOG bytes.  */\n "}, {"sha": "778454d4b01fa51115163c893d76b0df9f839244", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -329,7 +329,7 @@ in the following sections.\n @emph{M680x0 Options}\n @gccoptlist{-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 @gol\n -m68060  -mcpu32  -m5200  -m68881  -mbitfield  -mc68000  -mc68020   @gol\n--mfpa  -mnobitfield  -mrtd  -mshort  -msoft-float  -mpcrel @gol\n+-mnobitfield  -mrtd  -mshort  -msoft-float  -mpcrel @gol\n -malign-int  -mstrict-align}\n \n @emph{M68hc1x Options}\n@@ -5700,10 +5700,6 @@ This results in code which can run relatively efficiently on either a\n 68020/68881 or a 68030 or a 68040.  The generated code does use the\n 68881 instructions that are emulated on the 68060.\n \n-@item -mfpa\n-@opindex mfpa\n-Generate output containing Sun FPA instructions for floating point.\n-\n @item -msoft-float\n @opindex msoft-float\n Generate output containing library calls for floating point."}, {"sha": "328fcd805cbfefd041d324acdebfb362751c120a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8965c4a1232f3ed62aaafbcc17e141791e9b48/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1a8965c4a1232f3ed62aaafbcc17e141791e9b48", "patch": "@@ -1934,12 +1934,6 @@ Data register\n @item f\n 68881 floating-point register, if available\n \n-@item x\n-Sun FPA (floating-point) register, if available\n-\n-@item y\n-First 16 Sun FPA registers, if available\n-\n @item I\n Integer in the range 1 to 8\n \n@@ -1957,9 +1951,6 @@ Signed number whose magnitude is greater than 0x100\n \n @item G\n Floating point constant that is not a 68881 constant\n-\n-@item H\n-Floating point constant that can be used by Sun FPA\n @end table\n \n @item Motorola 68HC11 & 68HC12 families---@file{m68hc11.h}"}]}