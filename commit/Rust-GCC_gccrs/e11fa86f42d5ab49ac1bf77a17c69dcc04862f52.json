{"sha": "e11fa86f42d5ab49ac1bf77a17c69dcc04862f52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExZmE4NmY0MmQ1YWI0OWFjMWJmNzdhMTdjNjlkY2MwNDg2MmY1Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-01T14:07:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-01T14:07:38Z"}, "message": "(rtx_equal_for_field_assignment_p): New function.\n\n(make_field_assignment): Use it.\nExpand compound operations on both sides of an IOR.\nProperly adjust constand in IOR when computing bit position.\n\nFrom-SVN: r10927", "tree": {"sha": "6660fa592b0117515f86c0a2d4708d92d246a2b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6660fa592b0117515f86c0a2d4708d92d246a2b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52/comments", "author": null, "committer": null, "parents": [{"sha": "6cad67d2d0789487217a2091c2f14d48f9e1ad6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cad67d2d0789487217a2091c2f14d48f9e1ad6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cad67d2d0789487217a2091c2f14d48f9e1ad6b"}], "stats": {"total": 85, "additions": 61, "deletions": 24}, "files": [{"sha": "efcdea3eb4a0f4656d13713fcf6d873b0b7ef22a", "filename": "gcc/combine.c", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11fa86f42d5ab49ac1bf77a17c69dcc04862f52/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e11fa86f42d5ab49ac1bf77a17c69dcc04862f52", "patch": "@@ -1,5 +1,5 @@\n /* Optimize by combining instructions for GNU compiler.\n-   Copyright (C) 1987, 88, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -410,6 +410,7 @@ static rtx force_to_mode\tPROTO((rtx, enum machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT, rtx, int));\n static rtx if_then_else_cond\tPROTO((rtx, rtx *, rtx *));\n static rtx known_cond\t\tPROTO((rtx, enum rtx_code, rtx, rtx));\n+static int rtx_equal_for_field_assignment_p PROTO((rtx, rtx));\n static rtx make_field_assignment  PROTO((rtx));\n static rtx apply_distributive_law  PROTO((rtx));\n static rtx simplify_and_const_int  PROTO((rtx, enum machine_mode, rtx,\n@@ -6471,6 +6472,46 @@ known_cond (x, cond, reg, val)\n   return x;\n }\n \f\n+/* See if X and Y are equal for the purposes of seeing if we can rewrite an\n+   assignment as a field assignment.  */\n+\n+static int\n+rtx_equal_for_field_assignment_p (x, y)\n+     rtx x;\n+     rtx y;\n+{\n+  rtx last_x, last_y;\n+\n+  if (x == y || rtx_equal_p (x, y))\n+    return 1;\n+\n+  if (x == 0 || y == 0 || GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* Check for a paradoxical SUBREG of a MEM compared with the MEM.\n+     Note that all SUBREGs of MEM are paradoxical; otherwise they\n+     would have been rewritten.  */\n+  if (GET_CODE (x) == MEM && GET_CODE (y) == SUBREG\n+      && GET_CODE (SUBREG_REG (y)) == MEM\n+      && rtx_equal_p (SUBREG_REG (y),\n+\t\t      gen_lowpart_for_combine (GET_MODE (SUBREG_REG (y)), x)))\n+    return 1;\n+\n+  if (GET_CODE (y) == MEM && GET_CODE (x) == SUBREG\n+      && GET_CODE (SUBREG_REG (x)) == MEM\n+      && rtx_equal_p (SUBREG_REG (x),\n+\t\t      gen_lowpart_for_combine (GET_MODE (SUBREG_REG (x)), y)))\n+    return 1;\n+\n+  last_x = get_last_value (x);\n+  last_y = get_last_value (y);\n+\n+  return ((last_x != 0 && rtx_equal_for_field_assignment_p (last_x, y))\n+\t  || (last_y != 0 && rtx_equal_for_field_assignment_p (x, last_y))\n+\t  || (last_x != 0 && last_y != 0\n+\t      && rtx_equal_for_field_assignment_p (last_x, last_y)));\n+}\n+\f\n /* See if X, a SET operation, can be rewritten as a bit-field assignment.\n    Return that assignment if so.\n \n@@ -6483,6 +6524,7 @@ make_field_assignment (x)\n   rtx dest = SET_DEST (x);\n   rtx src = SET_SRC (x);\n   rtx assign;\n+  rtx rhs, lhs;\n   HOST_WIDE_INT c1;\n   int pos, len;\n   rtx other;\n@@ -6496,9 +6538,7 @@ make_field_assignment (x)\n   if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == ROTATE\n       && GET_CODE (XEXP (XEXP (src, 0), 0)) == CONST_INT\n       && INTVAL (XEXP (XEXP (src, 0), 0)) == -2\n-      && (rtx_equal_p (dest, XEXP (src, 1))\n-\t  || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n-\t  || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n+      && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n       assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n@@ -6511,9 +6551,7 @@ make_field_assignment (x)\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n \t   && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n \t   && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n-\t   && (rtx_equal_p (dest, XEXP (src, 1))\n-\t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n-\t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n+\t   && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n       assign = make_extraction (VOIDmode, dest, 0,\n \t\t\t\tXEXP (SUBREG_REG (XEXP (src, 0)), 1),\n@@ -6525,9 +6563,7 @@ make_field_assignment (x)\n      one-bit field.  */\n   else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == ASHIFT\n \t   && XEXP (XEXP (src, 0), 0) == const1_rtx\n-\t   && (rtx_equal_p (dest, XEXP (src, 1))\n-\t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n-\t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n+\t   && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n       assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n@@ -6542,23 +6578,24 @@ make_field_assignment (x)\n      to the appropriate position, force it to the required mode, and\n      make the extraction.  Check for the AND in both operands.  */\n \n-  if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == AND\n-      && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n-      && (rtx_equal_p (XEXP (XEXP (src, 0), 0), dest)\n-\t  || rtx_equal_p (XEXP (XEXP (src, 0), 0), get_last_value (dest))\n-\t  || rtx_equal_p (get_last_value (XEXP (XEXP (src, 0), 1)), dest)))\n-    c1 = INTVAL (XEXP (XEXP (src, 0), 1)), other = XEXP (src, 1);\n-  else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 1)) == AND\n-\t   && GET_CODE (XEXP (XEXP (src, 1), 1)) == CONST_INT\n-\t   && (rtx_equal_p (XEXP (XEXP (src, 1), 0), dest)\n-\t       || rtx_equal_p (XEXP (XEXP (src, 1), 0), get_last_value (dest))\n-\t       || rtx_equal_p (get_last_value (XEXP (XEXP (src, 1), 0)),\n-\t\t\t       dest)))\n-    c1 = INTVAL (XEXP (XEXP (src, 1), 1)), other = XEXP (src, 0);\n+  if (GET_CODE (src) != IOR)\n+    return x;\n+\n+  rhs = expand_compound_operation (XEXP (src, 0));\n+  lhs = expand_compound_operation (XEXP (src, 1));\n+\n+  if (GET_CODE (rhs) == AND\n+      && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+      && rtx_equal_for_field_assignment_p (XEXP (rhs, 0), dest))\n+    c1 = INTVAL (XEXP (rhs, 1)), other = lhs;\n+  else if (GET_CODE (lhs) == AND\n+\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t   && rtx_equal_for_field_assignment_p (XEXP (lhs, 0), dest))\n+    c1 = INTVAL (XEXP (lhs, 1)), other = rhs;\n   else\n     return x;\n \n-  pos = get_pos_from_mask (c1 ^ GET_MODE_MASK (GET_MODE (dest)), &len);\n+  pos = get_pos_from_mask ((~ c1) & GET_MODE_MASK (GET_MODE (dest)), &len);\n   if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n       || (GET_MODE_BITSIZE (GET_MODE (other)) <= HOST_BITS_PER_WIDE_INT\n \t  && (c1 & nonzero_bits (other, GET_MODE (other))) != 0))"}]}