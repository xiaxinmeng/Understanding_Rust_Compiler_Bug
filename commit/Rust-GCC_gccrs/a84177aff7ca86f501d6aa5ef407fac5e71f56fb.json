{"sha": "a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "node_id": "C_kwDOANBUbNoAKGE4NDE3N2FmZjdjYTg2ZjUwMWQ2YWE1ZWY0MDdmYWM1ZTcxZjU2ZmI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-19T09:05:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-19T09:05:01Z"}, "message": "c++: Fix up -fstrong-eval-order handling of call arguments [PR70796]\n\nFor -fstrong-eval-order (default for C++17 and later) we make sure to\ngimplify arguments in the right order, but as the following testcase\nshows that is not enough.\nThe problem is that some lvalues can satisfy the is_gimple_val / fb_rvalue\npredicate used by gimplify_arg for is_gimple_reg_type typed expressions,\nor is_gimple_lvalue / fb_either used for other types.\nE.g. in foo we have:\n  C::C (&p,  ++i,  ++i)\nbefore gimplification where i is an automatic int variable and without this\npatch gimplify that as:\n  i = i + 1;\n  i = i + 1;\n  C::C (&p, i, i);\nwhich means that the ctor is called with the original i value incremented\nby 2 in both arguments, while because the call is CALL_EXPR_ORDERED_ARGS\nthe first argument should be different.  Similarly in qux we have:\n  B::B (&p, TARGET_EXPR <D.2274, *(const struct A &) A::operator++ (&i)>,\n        TARGET_EXPR <D.2275, *(const struct A &) A::operator++ (&i)>)\nand gimplify it as:\n      _1 = A::operator++ (&i);\n      _2 = A::operator++ (&i);\n      B::B (&p, MEM[(const struct A &)_1], MEM[(const struct A &)_2]);\nbut because A::operator++ returns the passed in argument, again we have\nthe same value in both cases due to gimplify_arg doing:\n      /* Also strip a TARGET_EXPR that would force an extra copy.  */\n      if (TREE_CODE (*arg_p) == TARGET_EXPR)\n        {\n          tree init = TARGET_EXPR_INITIAL (*arg_p);\n          if (init\n              && !VOID_TYPE_P (TREE_TYPE (init)))\n            *arg_p = init;\n        }\nwhich is perfectly fine optimization for calls with unordered arguments,\nbut breaks the ordered ones.\nLastly, in corge, we have before gimplification:\n  D::foo (NON_LVALUE_EXPR <p>, 3,  ++p)\nand gimplify it as\n  p = p + 4;\n  D::foo (p, 3, p);\nwhich is again wrong, because the this argument isn't before the\nside-effects but after it.\nThe following patch adds cp_gimplify_arg wrapper, which if ordered\nand is_gimple_reg_type forces non-SSA_NAME is_gimple_variable\nresult into a temporary, and if ordered, not is_gimple_reg_type\nand argument is TARGET_EXPR bypasses the gimplify_arg optimization.\nSo, in foo with this patch we gimplify it as:\n  i = i + 1;\n  i.0_1 = i;\n  i = i + 1;\n  C::C (&p, i.0_1, i);\nin qux as:\n      _1 = A::operator++ (&i);\n      D.2312 = MEM[(const struct A &)_1];\n      _2 = A::operator++ (&i);\n      B::B (&p, D.2312, MEM[(const struct A &)_2]);\nwhere D.2312 is a temporary and in corge as:\n  p.9_1 = p;\n  p = p + 4;\n  D::foo (p.9_1, 3, p);\nThe is_gimple_reg_type forcing into a temporary should be really cheap\n(I think even at -O0 it should be optimized if there is no modification in\nbetween), the aggregate copies might be more expensive but I think e.g. SRA\nor FRE should be able to deal with those if there are no intervening\nchanges.  But still, the patch tries to avoid those when it is cheaply\nprovable that nothing bad happens (if no argument following it in the\nstrong evaluation order doesn't have TREE_SIDE_EFFECTS, then even VAR_DECLs\netc. shouldn't be modified after it).  There is also an optimization to\navoid doing that for this or for arguments with reference types as nothing\ncan modify the parameter values during evaluation of other argument's\nside-effects.\n\nI've tried if e.g.\n  int i = 1;\n  return i << ++i;\ndoesn't suffer from this problem as well, but it doesn't, the FE uses\n  SAVE_EXPR <i>, SAVE_EXPR <i> << ++i;\nin that case which gimplifies the way we want (temporary in the first\noperand).\n\n2021-11-19  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/70796\n\t* cp-gimplify.c (cp_gimplify_arg): New function.\n\t(cp_gimplify_expr): Use cp_gimplify_arg instead of gimplify_arg,\n\tpass true as last argument to it if there are any following\n\targuments in strong evaluation order with side-effects.\n\n\t* g++.dg/cpp1z/eval-order11.C: New test.", "tree": {"sha": "f05af0aa1dd5df37ad0d386c02d95793c0f24736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f05af0aa1dd5df37ad0d386c02d95793c0f24736"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84177aff7ca86f501d6aa5ef407fac5e71f56fb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e510ab53414430e93c6f5b64841e2f40031cda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e510ab53414430e93c6f5b64841e2f40031cda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e510ab53414430e93c6f5b64841e2f40031cda7"}], "stats": {"total": 154, "additions": 151, "deletions": 3}, "files": [{"sha": "c1691c3e073c1b42297b8730d26a314c82bcbe94", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84177aff7ca86f501d6aa5ef407fac5e71f56fb/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84177aff7ca86f501d6aa5ef407fac5e71f56fb/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "patch": "@@ -398,6 +398,47 @@ gimplify_to_rvalue (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   return t;\n }\n \n+/* Like gimplify_arg, but if ORDERED is set (which should be set if\n+   any of the arguments this argument is sequenced before has\n+   TREE_SIDE_EFFECTS set, make sure expressions with is_gimple_reg_type type\n+   are gimplified into SSA_NAME or a fresh temporary and for\n+   non-is_gimple_reg_type we don't optimize away TARGET_EXPRs.  */\n+\n+static enum gimplify_status\n+cp_gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location,\n+\t\t bool ordered)\n+{\n+  enum gimplify_status t;\n+  if (ordered\n+      && !is_gimple_reg_type (TREE_TYPE (*arg_p))\n+      && TREE_CODE (*arg_p) == TARGET_EXPR)\n+    {\n+      /* gimplify_arg would strip away the TARGET_EXPR, but\n+\t that can mean we don't copy the argument and some following\n+\t argument with side-effect could modify it.  */\n+      protected_set_expr_location (*arg_p, call_location);\n+      return gimplify_expr (arg_p, pre_p, NULL, is_gimple_lvalue, fb_either);\n+    }\n+  else\n+    {\n+      t = gimplify_arg (arg_p, pre_p, call_location);\n+      if (t == GS_ERROR)\n+\treturn GS_ERROR;\n+      else if (ordered\n+\t       && is_gimple_reg_type (TREE_TYPE (*arg_p))\n+\t       && is_gimple_variable (*arg_p)\n+\t       && TREE_CODE (*arg_p) != SSA_NAME\n+\t       /* No need to force references into register, references\n+\t\t  can't be modified.  */\n+\t       && !TYPE_REF_P (TREE_TYPE (*arg_p))\n+\t       /* And this can't be modified either.  */\n+\t       && *arg_p != current_class_ptr)\n+\t*arg_p = get_initialized_tmp_var (*arg_p, pre_p);\n+      return t;\n+    }\n+\n+}\n+\n /* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n \n int\n@@ -613,7 +654,8 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  gcc_assert (call_expr_nargs (*expr_p) == 2);\n \t  gcc_assert (!CALL_EXPR_ORDERED_ARGS (*expr_p));\n \t  enum gimplify_status t\n-\t    = gimplify_arg (&CALL_EXPR_ARG (*expr_p, 1), pre_p, loc);\n+\t    = cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, 1), pre_p, loc,\n+\t\t\t       TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, 0)));\n \t  if (t == GS_ERROR)\n \t    ret = GS_ERROR;\n \t}\n@@ -622,10 +664,18 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  /* Leave the last argument for gimplify_call_expr, to avoid problems\n \t     with __builtin_va_arg_pack().  */\n \t  int nargs = call_expr_nargs (*expr_p) - 1;\n+\t  int last_side_effects_arg = -1;\n+\t  for (int i = nargs; i > 0; --i)\n+\t    if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n+\t      {\n+\t\tlast_side_effects_arg = i;\n+\t\tbreak;\n+\t      }\n \t  for (int i = 0; i < nargs; ++i)\n \t    {\n \t      enum gimplify_status t\n-\t\t= gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p, loc);\n+\t\t= cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p, loc,\n+\t\t\t\t   i < last_side_effects_arg);\n \t      if (t == GS_ERROR)\n \t\tret = GS_ERROR;\n \t    }\n@@ -639,8 +689,17 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t    fntype = TREE_TYPE (fntype);\n \t  if (TREE_CODE (fntype) == METHOD_TYPE)\n \t    {\n+\t      int nargs = call_expr_nargs (*expr_p);\n+\t      bool side_effects = false;\n+\t      for (int i = 1; i < nargs; ++i)\n+\t\tif (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n+\t\t  {\n+\t\t    side_effects = true;\n+\t\t    break;\n+\t\t  }\n \t      enum gimplify_status t\n-\t\t= gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p, loc);\n+\t\t= cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p, loc,\n+\t\t\t\t   side_effects);\n \t      if (t == GS_ERROR)\n \t\tret = GS_ERROR;\n \t    }"}, {"sha": "19a24c8ed221d3f37817874720177d8e802b1c51", "filename": "gcc/testsuite/g++.dg/cpp1z/eval-order11.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a84177aff7ca86f501d6aa5ef407fac5e71f56fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a84177aff7ca86f501d6aa5ef407fac5e71f56fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order11.C?ref=a84177aff7ca86f501d6aa5ef407fac5e71f56fb", "patch": "@@ -0,0 +1,89 @@\n+// PR c++/70796\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-fstrong-eval-order\" { target c++14_down } }\n+\n+struct A\n+{\n+  int x = 0;\n+  A & operator ++ () { ++x; return *this; }\n+};\n+struct B\n+{\n+  A first, second;\n+  B (A x, A y) : first{x}, second{y} {}\n+};\n+struct C\n+{\n+  int first, second;\n+  C (int x, int y) : first{x}, second{y} {}\n+};\n+struct D\n+{\n+  int d;\n+  void foo (int x, D *y)\n+  {\n+    if (y != this + 1)\n+      __builtin_abort ();\n+    d = x;\n+  }\n+};\n+D d[2] = { { 1 }, { 2 } };\n+\n+void\n+foo ()\n+{\n+  int i = 0;\n+  C p{++i, ++i};\n+  if (p.first != 1 || p.second != 2)\n+    __builtin_abort ();\n+}\n+\n+void\n+bar ()\n+{\n+  int i = 0;\n+  C p{++i, ++i};\n+  if (p.first != 1 || p.second != 2)\n+    __builtin_abort ();\n+  int &j = i;\n+  C q{++j, ++j};\n+  if (q.first != 3 || q.second != 4)\n+    __builtin_abort ();\n+}\n+\n+void\n+baz ()\n+{\n+  int i = 0;\n+  C p{(int &) ++i, (int &) ++i};\n+  if (p.first != 1 || p.second != 2)\n+    __builtin_abort ();\n+}\n+\n+void\n+qux ()\n+{\n+  A i;\n+  B p{++i, ++i};\n+  if (p.first.x != 1 || p.second.x != 2)\n+    __builtin_abort ();\n+}\n+\n+void\n+corge ()\n+{\n+  D *p = &d[0];\n+  p->foo (3, ++p);\n+  if (d[0].d != 3 || d[1].d != 2)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  bar ();\n+  baz ();\n+  foo ();\n+  qux ();\n+  corge ();\n+}"}]}