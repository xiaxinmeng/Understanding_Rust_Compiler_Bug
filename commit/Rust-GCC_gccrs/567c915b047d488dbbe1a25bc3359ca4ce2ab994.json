{"sha": "567c915b047d488dbbe1a25bc3359ca4ce2ab994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3YzkxNWIwNDdkNDg4ZGJiZTFhMjViYzMzNTljYTRjZTJhYjk5NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2007-02-19T20:49:10Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-02-19T20:49:10Z"}, "message": "re PR libfortran/30533 ([4.1 only] minval, maxval missing for kind=1 and kind=2)\n\n2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30533\n\tPR libfortran/30765\n\t* Makefile.am: Add $(srcdir) too all files in generated/.\n\t(i_maxloc0_c): Add maxloc0_4_i1.c, maxloc0_8_i1.c,\n\tmaxloc0_16_i1.c, maxloc0_4_i2.c, maxloc0_8_i2.c and\n\tmaxloc0_16_i2.c.\n\t(i_maxloc1_c): Add maxloc1_4_i1.c, maxloc1_8_i1.c,\n\tmaxloc1_16_i1.c, maxloc1_4_i2.c, maxloc1_8_i2.c and\n\tmaxloc1_16_i2.c.\n\t(i_maxval_c): Add maxval_i1.c and maxval_i2.c.\n\t(i_minloc0_c):  Add minloc0_4_i1.c, minloc0_8_i1.c,\n\tminloc0_16_i1.c, minloc0_4_i2.c, minloc0_8_i2.c and\n\tminloc0_16_i2.c.\n\t(i_minloc_1.c): Add minloc1_4_i1.c, minloc1_8_i1.c,\n\tminloc1_16_i1.c, minloc1_4_i2.c, minloc1_8_i2.c and\n\tminloc1_16_i2.c.\n\t(i_minval_c):  Add minval_i1.c and minval_i2.c.\n\t(i_sum_c):  Add sum_i1.c and sum_i2.c.\n\t(i_product_c):  Add product_i1.c and product_i2.c.\n\t(i_matmul_c):  Add matmul_i1.c and matmul_i2.c.\n\t(gfor_built_specific_src):  Remove $(srcdir) from target.\n\t(gfor_bulit_specific2_src):  Likewise.\n\tMakefile.in:  Regenerated.\n\tlibgfortran.h:  Add GFC_INTEGER_1_HUGE and GFC_INTEGER_2_HUGE.\n\tAdd gfc_array_i1 and gfc_array_i2.\n\t* generated/matmul_i1.c: New file.\n\t* generated/matmul_i2.c: New file.\n\t* generated/maxloc0_16_i1.c: New file.\n\t* generated/maxloc0_16_i2.c: New file.\n\t* generated/maxloc0_4_i1.c: New file.\n\t* generated/maxloc0_4_i2.c: New file.\n\t* generated/maxloc0_8_i1.c: New file.\n\t* generated/maxloc0_8_i2.c: New file.\n\t* generated/maxloc1_16_i1.c: New file.\n\t* generated/maxloc1_16_i2.c: New file.\n\t* generated/maxloc1_4_i1.c: New file.\n\t* generated/maxloc1_4_i2.c: New file.\n\t* generated/maxloc1_8_i1.c: New file.\n\t* generated/maxloc1_8_i2.c: New file.\n\t* generated/maxval_i1.c: New file.\n\t* generated/maxval_i2.c: New file.\n\t* generated/minloc0_16_i1.c: New file.\n\t* generated/minloc0_16_i2.c: New file.\n\t* generated/minloc0_4_i1.c: New file.\n\t* generated/minloc0_4_i2.c: New file.\n\t* generated/minloc0_8_i1.c: New file.\n\t* generated/minloc0_8_i2.c: New file.\n\t* generated/minloc1_16_i1.c: New file.\n\t* generated/minloc1_16_i2.c: New file.\n\t* generated/minloc1_4_i1.c: New file.\n\t* generated/minloc1_4_i2.c: New file.\n\t* generated/minloc1_8_i1.c: New file.\n\t* generated/minloc1_8_i2.c: New file.\n\t* generated/minval_i1.c: New file.\n\t* generated/minval_i2.c: New file.\n\t* generated/product_i1.c: New file.\n\t* generated/product_i2.c: New file.\n\t* generated/sum_i1.c: New file.\n\t* generated/sum_i2.c: New file.\n\n2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30533\n\t* fortran/iresolve.c(gfc_resolve_maxloc):  Remove coercion of\n\targument to default integer.\n\t(gfc_resolve_minloc):  Likewise.\n\n2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30533\n\t* gfortran.dg/intrinsic_intkinds_1.f90:  New test.\n\nFrom-SVN: r122137", "tree": {"sha": "40c73c5243d3a275e9adee4142be718963ee6f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c73c5243d3a275e9adee4142be718963ee6f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/567c915b047d488dbbe1a25bc3359ca4ce2ab994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567c915b047d488dbbe1a25bc3359ca4ce2ab994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567c915b047d488dbbe1a25bc3359ca4ce2ab994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567c915b047d488dbbe1a25bc3359ca4ce2ab994/comments", "author": null, "committer": null, "parents": [{"sha": "c116cd05fb0e993227162e466ba5f5093392e3e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c116cd05fb0e993227162e466ba5f5093392e3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c116cd05fb0e993227162e466ba5f5093392e3e6"}], "stats": {"total": 17586, "additions": 15463, "deletions": 2123}, "files": [{"sha": "1f2f26ae5dd4e99a177f6f6d159ab91506c3cad3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -1,3 +1,10 @@\n+2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30533\n+\t* fortran/iresolve.c(gfc_resolve_maxloc):  Remove coercion of\n+\targument to default integer.\n+\t(gfc_resolve_minloc):  Likewise.\n+\n 2007-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/30681"}, {"sha": "63741f2ba6f8397fe9e03c5cfb92a9c351b013c5", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -1231,19 +1231,6 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"maxloc\";\n \n-  /* If the rank of the function is nonzero, we are going to call\n-     a library function.  Coerce the argument to one of the\n-     existing library functions for this case.  */\n-\n-  if (f->rank != 0 && array->ts.type == BT_INTEGER\n-      && array->ts.kind < gfc_default_integer_kind)\n-    {\n-      gfc_typespec ts;\n-      ts.type = BT_INTEGER;\n-      ts.kind = gfc_default_integer_kind;\n-      gfc_convert_type_warn (array, &ts, 2, 0);\n-    }\n-\n   f->value.function.name\n     = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n \t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n@@ -1398,19 +1385,6 @@ gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"minloc\";\n \n-  /* If the rank of the function is nonzero, we are going to call\n-     a library function.  Coerce the argument to one of the\n-     existing library functions for this case.  */\n-\n-  if (f->rank != 0 && array->ts.type == BT_INTEGER\n-      && array->ts.kind < gfc_default_integer_kind)\n-    {\n-      gfc_typespec ts;\n-      ts.type = BT_INTEGER;\n-      ts.kind = gfc_default_integer_kind;\n-      gfc_convert_type_warn (array, &ts, 2, 0);\n-    }\n-\n   f->value.function.name\n     = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n \t\t      gfc_type_letter (array->ts.type), array->ts.kind);"}, {"sha": "18be9274f26ba545971c9f7429e2666770ed4f83", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -1,3 +1,8 @@\n+2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30533\n+\t* gfortran.dg/intrinsic_intkinds_1.f90:  New test.\n+\n 2007-02-19  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* gcc.dg/20031012-1.c: Replace -Walways-true with -Waddress."}, {"sha": "ea5057ac82e46aa8cd964c67119a2b233246bc17", "filename": "gcc/testsuite/gfortran.dg/intrinsic_intkinds_1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intkinds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intkinds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intkinds_1.f90?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! Test assorted intrinsics for integer kinds 1 and 2\n+program main\n+  integer(kind=1), dimension(2,2) :: a\n+  integer(kind=2), dimension(2,2) :: b\n+  integer(kind=1), dimension(2) :: r1\n+  integer(kind=2), dimension(2) :: r2\n+  logical, dimension(2,2) :: ma\n+  ma = .false.\n+  a = reshape((/ 1_1, 2_1, 3_1, 4_1/), shape(a))\n+  b = reshape((/ 1_2, 2_2, 3_2, 4_2/), shape(b))\n+  if (any(sum(a,dim=2) /= (/ 4, 6 /))) call abort\n+  if (any(sum(b,dim=2) /= (/ 4, 6 /))) call abort\n+  if (any(product(a,dim=2) /= (/ 3, 8 /))) call abort\n+  if (any(product(b,dim=2) /= (/ 3, 8 /))) call abort\n+  if (any(matmul(a,a) /= reshape ( (/ 7, 10, 15, 22 /), shape(a)))) call abort\n+  if (any(matmul(b,b) /= reshape ( (/ 7, 10, 15, 22 /), shape(b)))) call abort\n+  if (any(maxval(a,dim=2,mask=ma) /= -128)) call abort\n+  if (any(maxval(b,dim=2,mask=ma) /= -32768)) call abort\n+end program main"}, {"sha": "695cf9411e83fec325243783cfbbcd63762f501f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -1,3 +1,65 @@\n+2007-02-19  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30533\n+\tPR libfortran/30765\n+\t* Makefile.am: Add $(srcdir) too all files in generated/.\n+\t(i_maxloc0_c): Add maxloc0_4_i1.c, maxloc0_8_i1.c,\n+\tmaxloc0_16_i1.c, maxloc0_4_i2.c, maxloc0_8_i2.c and\n+\tmaxloc0_16_i2.c.\n+\t(i_maxloc1_c): Add maxloc1_4_i1.c, maxloc1_8_i1.c,\n+\tmaxloc1_16_i1.c, maxloc1_4_i2.c, maxloc1_8_i2.c and\n+\tmaxloc1_16_i2.c.\n+\t(i_maxval_c): Add maxval_i1.c and maxval_i2.c.\n+\t(i_minloc0_c):  Add minloc0_4_i1.c, minloc0_8_i1.c,\n+\tminloc0_16_i1.c, minloc0_4_i2.c, minloc0_8_i2.c and\n+\tminloc0_16_i2.c.\n+\t(i_minloc_1.c): Add minloc1_4_i1.c, minloc1_8_i1.c,\n+\tminloc1_16_i1.c, minloc1_4_i2.c, minloc1_8_i2.c and\n+\tminloc1_16_i2.c.\n+\t(i_minval_c):  Add minval_i1.c and minval_i2.c.\n+\t(i_sum_c):  Add sum_i1.c and sum_i2.c.\n+\t(i_product_c):  Add product_i1.c and product_i2.c.\n+\t(i_matmul_c):  Add matmul_i1.c and matmul_i2.c.\n+\t(gfor_built_specific_src):  Remove $(srcdir) from target.\n+\t(gfor_bulit_specific2_src):  Likewise.\n+\tMakefile.in:  Regenerated.\n+\tlibgfortran.h:  Add GFC_INTEGER_1_HUGE and GFC_INTEGER_2_HUGE.\n+\tAdd gfc_array_i1 and gfc_array_i2.\n+\t* generated/matmul_i1.c: New file.\n+\t* generated/matmul_i2.c: New file.\n+\t* generated/maxloc0_16_i1.c: New file.\n+\t* generated/maxloc0_16_i2.c: New file.\n+\t* generated/maxloc0_4_i1.c: New file.\n+\t* generated/maxloc0_4_i2.c: New file.\n+\t* generated/maxloc0_8_i1.c: New file.\n+\t* generated/maxloc0_8_i2.c: New file.\n+\t* generated/maxloc1_16_i1.c: New file.\n+\t* generated/maxloc1_16_i2.c: New file.\n+\t* generated/maxloc1_4_i1.c: New file.\n+\t* generated/maxloc1_4_i2.c: New file.\n+\t* generated/maxloc1_8_i1.c: New file.\n+\t* generated/maxloc1_8_i2.c: New file.\n+\t* generated/maxval_i1.c: New file.\n+\t* generated/maxval_i2.c: New file.\n+\t* generated/minloc0_16_i1.c: New file.\n+\t* generated/minloc0_16_i2.c: New file.\n+\t* generated/minloc0_4_i1.c: New file.\n+\t* generated/minloc0_4_i2.c: New file.\n+\t* generated/minloc0_8_i1.c: New file.\n+\t* generated/minloc0_8_i2.c: New file.\n+\t* generated/minloc1_16_i1.c: New file.\n+\t* generated/minloc1_16_i2.c: New file.\n+\t* generated/minloc1_4_i1.c: New file.\n+\t* generated/minloc1_4_i2.c: New file.\n+\t* generated/minloc1_8_i1.c: New file.\n+\t* generated/minloc1_8_i2.c: New file.\n+\t* generated/minval_i1.c: New file.\n+\t* generated/minval_i2.c: New file.\n+\t* generated/product_i1.c: New file.\n+\t* generated/product_i2.c: New file.\n+\t* generated/sum_i1.c: New file.\n+\t* generated/sum_i2.c: New file.\n+\n 2007-02-16  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* runtime/memory.c (deallocate): Correct comment."}, {"sha": "926d18a419bf08b10f4e91178c3410cca6c1d19a", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 429, "deletions": 395, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -109,314 +109,348 @@ runtime/string.c \\\n runtime/select.c\n \n i_all_c= \\\n-generated/all_l4.c \\\n-generated/all_l8.c \\\n-generated/all_l16.c\n+$(srcdir)/generated/all_l4.c \\\n+$(srcdir)/generated/all_l8.c \\\n+$(srcdir)/generated/all_l16.c\n \n i_any_c= \\\n-generated/any_l4.c \\\n-generated/any_l8.c \\\n-generated/any_l16.c\n+$(srcdir)/generated/any_l4.c \\\n+$(srcdir)/generated/any_l8.c \\\n+$(srcdir)/generated/any_l16.c\n \n i_count_c= \\\n-generated/count_4_l4.c \\\n-generated/count_8_l4.c \\\n-generated/count_16_l4.c \\\n-generated/count_4_l8.c \\\n-generated/count_8_l8.c \\\n-generated/count_16_l8.c \\\n-generated/count_4_l16.c \\\n-generated/count_8_l16.c \\\n-generated/count_16_l16.c\n+$(srcdir)/generated/count_4_l4.c \\\n+$(srcdir)/generated/count_8_l4.c \\\n+$(srcdir)/generated/count_16_l4.c \\\n+$(srcdir)/generated/count_4_l8.c \\\n+$(srcdir)/generated/count_8_l8.c \\\n+$(srcdir)/generated/count_16_l8.c \\\n+$(srcdir)/generated/count_4_l16.c \\\n+$(srcdir)/generated/count_8_l16.c \\\n+$(srcdir)/generated/count_16_l16.c\n \n i_maxloc0_c= \\\n-generated/maxloc0_4_i4.c \\\n-generated/maxloc0_8_i4.c \\\n-generated/maxloc0_16_i4.c \\\n-generated/maxloc0_4_i8.c \\\n-generated/maxloc0_8_i8.c \\\n-generated/maxloc0_16_i8.c \\\n-generated/maxloc0_4_i16.c \\\n-generated/maxloc0_8_i16.c \\\n-generated/maxloc0_16_i16.c \\\n-generated/maxloc0_4_r4.c \\\n-generated/maxloc0_8_r4.c \\\n-generated/maxloc0_16_r4.c \\\n-generated/maxloc0_4_r8.c \\\n-generated/maxloc0_8_r8.c \\\n-generated/maxloc0_16_r8.c \\\n-generated/maxloc0_4_r10.c \\\n-generated/maxloc0_8_r10.c \\\n-generated/maxloc0_16_r10.c \\\n-generated/maxloc0_4_r16.c \\\n-generated/maxloc0_8_r16.c \\\n-generated/maxloc0_16_r16.c\n+$(srcdir)/generated/maxloc0_4_i1.c \\\n+$(srcdir)/generated/maxloc0_8_i1.c \\\n+$(srcdir)/generated/maxloc0_16_i1.c \\\n+$(srcdir)/generated/maxloc0_4_i2.c \\\n+$(srcdir)/generated/maxloc0_8_i2.c \\\n+$(srcdir)/generated/maxloc0_16_i2.c \\\n+$(srcdir)/generated/maxloc0_4_i4.c \\\n+$(srcdir)/generated/maxloc0_8_i4.c \\\n+$(srcdir)/generated/maxloc0_16_i4.c \\\n+$(srcdir)/generated/maxloc0_4_i8.c \\\n+$(srcdir)/generated/maxloc0_8_i8.c \\\n+$(srcdir)/generated/maxloc0_16_i8.c \\\n+$(srcdir)/generated/maxloc0_4_i16.c \\\n+$(srcdir)/generated/maxloc0_8_i16.c \\\n+$(srcdir)/generated/maxloc0_16_i16.c \\\n+$(srcdir)/generated/maxloc0_4_r4.c \\\n+$(srcdir)/generated/maxloc0_8_r4.c \\\n+$(srcdir)/generated/maxloc0_16_r4.c \\\n+$(srcdir)/generated/maxloc0_4_r8.c \\\n+$(srcdir)/generated/maxloc0_8_r8.c \\\n+$(srcdir)/generated/maxloc0_16_r8.c \\\n+$(srcdir)/generated/maxloc0_4_r10.c \\\n+$(srcdir)/generated/maxloc0_8_r10.c \\\n+$(srcdir)/generated/maxloc0_16_r10.c \\\n+$(srcdir)/generated/maxloc0_4_r16.c \\\n+$(srcdir)/generated/maxloc0_8_r16.c \\\n+$(srcdir)/generated/maxloc0_16_r16.c\n \n i_maxloc1_c= \\\n-generated/maxloc1_4_i4.c \\\n-generated/maxloc1_8_i4.c \\\n-generated/maxloc1_16_i4.c \\\n-generated/maxloc1_4_i8.c \\\n-generated/maxloc1_8_i8.c \\\n-generated/maxloc1_16_i8.c \\\n-generated/maxloc1_4_i16.c \\\n-generated/maxloc1_8_i16.c \\\n-generated/maxloc1_16_i16.c \\\n-generated/maxloc1_4_r4.c \\\n-generated/maxloc1_8_r4.c \\\n-generated/maxloc1_16_r4.c \\\n-generated/maxloc1_4_r8.c \\\n-generated/maxloc1_8_r8.c \\\n-generated/maxloc1_16_r8.c \\\n-generated/maxloc1_4_r10.c \\\n-generated/maxloc1_8_r10.c \\\n-generated/maxloc1_16_r10.c \\\n-generated/maxloc1_4_r16.c \\\n-generated/maxloc1_8_r16.c \\\n-generated/maxloc1_16_r16.c\n+$(srcdir)/generated/maxloc1_4_i1.c \\\n+$(srcdir)/generated/maxloc1_8_i1.c \\\n+$(srcdir)/generated/maxloc1_16_i1.c \\\n+$(srcdir)/generated/maxloc1_4_i2.c \\\n+$(srcdir)/generated/maxloc1_8_i2.c \\\n+$(srcdir)/generated/maxloc1_16_i2.c \\\n+$(srcdir)/generated/maxloc1_4_i4.c \\\n+$(srcdir)/generated/maxloc1_8_i4.c \\\n+$(srcdir)/generated/maxloc1_16_i4.c \\\n+$(srcdir)/generated/maxloc1_4_i8.c \\\n+$(srcdir)/generated/maxloc1_8_i8.c \\\n+$(srcdir)/generated/maxloc1_16_i8.c \\\n+$(srcdir)/generated/maxloc1_4_i16.c \\\n+$(srcdir)/generated/maxloc1_8_i16.c \\\n+$(srcdir)/generated/maxloc1_16_i16.c \\\n+$(srcdir)/generated/maxloc1_4_r4.c \\\n+$(srcdir)/generated/maxloc1_8_r4.c \\\n+$(srcdir)/generated/maxloc1_16_r4.c \\\n+$(srcdir)/generated/maxloc1_4_r8.c \\\n+$(srcdir)/generated/maxloc1_8_r8.c \\\n+$(srcdir)/generated/maxloc1_16_r8.c \\\n+$(srcdir)/generated/maxloc1_4_r10.c \\\n+$(srcdir)/generated/maxloc1_8_r10.c \\\n+$(srcdir)/generated/maxloc1_16_r10.c \\\n+$(srcdir)/generated/maxloc1_4_r16.c \\\n+$(srcdir)/generated/maxloc1_8_r16.c \\\n+$(srcdir)/generated/maxloc1_16_r16.c\n \n i_maxval_c= \\\n-generated/maxval_i4.c \\\n-generated/maxval_i8.c \\\n-generated/maxval_i16.c \\\n-generated/maxval_r4.c \\\n-generated/maxval_r8.c \\\n-generated/maxval_r10.c \\\n-generated/maxval_r16.c\n+$(srcdir)/generated/maxval_i1.c \\\n+$(srcdir)/generated/maxval_i2.c \\\n+$(srcdir)/generated/maxval_i4.c \\\n+$(srcdir)/generated/maxval_i8.c \\\n+$(srcdir)/generated/maxval_i16.c \\\n+$(srcdir)/generated/maxval_r4.c \\\n+$(srcdir)/generated/maxval_r8.c \\\n+$(srcdir)/generated/maxval_r10.c \\\n+$(srcdir)/generated/maxval_r16.c\n \n i_minloc0_c= \\\n-generated/minloc0_4_i4.c \\\n-generated/minloc0_8_i4.c \\\n-generated/minloc0_16_i4.c \\\n-generated/minloc0_4_i8.c \\\n-generated/minloc0_8_i8.c \\\n-generated/minloc0_16_i8.c \\\n-generated/minloc0_4_i16.c \\\n-generated/minloc0_8_i16.c \\\n-generated/minloc0_16_i16.c \\\n-generated/minloc0_4_r4.c \\\n-generated/minloc0_8_r4.c \\\n-generated/minloc0_16_r4.c \\\n-generated/minloc0_4_r8.c \\\n-generated/minloc0_8_r8.c \\\n-generated/minloc0_16_r8.c \\\n-generated/minloc0_4_r10.c \\\n-generated/minloc0_8_r10.c \\\n-generated/minloc0_16_r10.c \\\n-generated/minloc0_4_r16.c \\\n-generated/minloc0_8_r16.c \\\n-generated/minloc0_16_r16.c\n+$(srcdir)/generated/minloc0_4_i1.c \\\n+$(srcdir)/generated/minloc0_8_i1.c \\\n+$(srcdir)/generated/minloc0_16_i1.c \\\n+$(srcdir)/generated/minloc0_4_i2.c \\\n+$(srcdir)/generated/minloc0_8_i2.c \\\n+$(srcdir)/generated/minloc0_16_i2.c \\\n+$(srcdir)/generated/minloc0_4_i4.c \\\n+$(srcdir)/generated/minloc0_8_i4.c \\\n+$(srcdir)/generated/minloc0_16_i4.c \\\n+$(srcdir)/generated/minloc0_4_i8.c \\\n+$(srcdir)/generated/minloc0_8_i8.c \\\n+$(srcdir)/generated/minloc0_16_i8.c \\\n+$(srcdir)/generated/minloc0_4_i16.c \\\n+$(srcdir)/generated/minloc0_8_i16.c \\\n+$(srcdir)/generated/minloc0_16_i16.c \\\n+$(srcdir)/generated/minloc0_4_r4.c \\\n+$(srcdir)/generated/minloc0_8_r4.c \\\n+$(srcdir)/generated/minloc0_16_r4.c \\\n+$(srcdir)/generated/minloc0_4_r8.c \\\n+$(srcdir)/generated/minloc0_8_r8.c \\\n+$(srcdir)/generated/minloc0_16_r8.c \\\n+$(srcdir)/generated/minloc0_4_r10.c \\\n+$(srcdir)/generated/minloc0_8_r10.c \\\n+$(srcdir)/generated/minloc0_16_r10.c \\\n+$(srcdir)/generated/minloc0_4_r16.c \\\n+$(srcdir)/generated/minloc0_8_r16.c \\\n+$(srcdir)/generated/minloc0_16_r16.c\n \n i_minloc1_c= \\\n-generated/minloc1_4_i4.c \\\n-generated/minloc1_8_i4.c \\\n-generated/minloc1_16_i4.c \\\n-generated/minloc1_4_i8.c \\\n-generated/minloc1_8_i8.c \\\n-generated/minloc1_16_i8.c \\\n-generated/minloc1_4_i16.c \\\n-generated/minloc1_8_i16.c \\\n-generated/minloc1_16_i16.c \\\n-generated/minloc1_4_r4.c \\\n-generated/minloc1_8_r4.c \\\n-generated/minloc1_16_r4.c \\\n-generated/minloc1_4_r8.c \\\n-generated/minloc1_8_r8.c \\\n-generated/minloc1_16_r8.c \\\n-generated/minloc1_4_r10.c \\\n-generated/minloc1_8_r10.c \\\n-generated/minloc1_16_r10.c \\\n-generated/minloc1_4_r16.c \\\n-generated/minloc1_8_r16.c \\\n-generated/minloc1_16_r16.c\n+$(srcdir)/generated/minloc1_4_i1.c \\\n+$(srcdir)/generated/minloc1_8_i1.c \\\n+$(srcdir)/generated/minloc1_16_i1.c \\\n+$(srcdir)/generated/minloc1_4_i2.c \\\n+$(srcdir)/generated/minloc1_8_i2.c \\\n+$(srcdir)/generated/minloc1_16_i2.c \\\n+$(srcdir)/generated/minloc1_4_i4.c \\\n+$(srcdir)/generated/minloc1_8_i4.c \\\n+$(srcdir)/generated/minloc1_16_i4.c \\\n+$(srcdir)/generated/minloc1_4_i8.c \\\n+$(srcdir)/generated/minloc1_8_i8.c \\\n+$(srcdir)/generated/minloc1_16_i8.c \\\n+$(srcdir)/generated/minloc1_4_i16.c \\\n+$(srcdir)/generated/minloc1_8_i16.c \\\n+$(srcdir)/generated/minloc1_16_i16.c \\\n+$(srcdir)/generated/minloc1_4_r4.c \\\n+$(srcdir)/generated/minloc1_8_r4.c \\\n+$(srcdir)/generated/minloc1_16_r4.c \\\n+$(srcdir)/generated/minloc1_4_r8.c \\\n+$(srcdir)/generated/minloc1_8_r8.c \\\n+$(srcdir)/generated/minloc1_16_r8.c \\\n+$(srcdir)/generated/minloc1_4_r10.c \\\n+$(srcdir)/generated/minloc1_8_r10.c \\\n+$(srcdir)/generated/minloc1_16_r10.c \\\n+$(srcdir)/generated/minloc1_4_r16.c \\\n+$(srcdir)/generated/minloc1_8_r16.c \\\n+$(srcdir)/generated/minloc1_16_r16.c\n \n i_minval_c= \\\n-generated/minval_i4.c \\\n-generated/minval_i8.c \\\n-generated/minval_i16.c \\\n-generated/minval_r4.c \\\n-generated/minval_r8.c \\\n-generated/minval_r10.c \\\n-generated/minval_r16.c\n+$(srcdir)/generated/minval_i1.c \\\n+$(srcdir)/generated/minval_i2.c \\\n+$(srcdir)/generated/minval_i4.c \\\n+$(srcdir)/generated/minval_i8.c \\\n+$(srcdir)/generated/minval_i16.c \\\n+$(srcdir)/generated/minval_r4.c \\\n+$(srcdir)/generated/minval_r8.c \\\n+$(srcdir)/generated/minval_r10.c \\\n+$(srcdir)/generated/minval_r16.c\n \n i_sum_c= \\\n-generated/sum_i4.c \\\n-generated/sum_i8.c \\\n-generated/sum_i16.c \\\n-generated/sum_r4.c \\\n-generated/sum_r8.c \\\n-generated/sum_r10.c \\\n-generated/sum_r16.c \\\n-generated/sum_c4.c \\\n-generated/sum_c8.c \\\n-generated/sum_c10.c \\\n-generated/sum_c16.c\n+$(srcdir)/generated/sum_i1.c \\\n+$(srcdir)/generated/sum_i2.c \\\n+$(srcdir)/generated/sum_i4.c \\\n+$(srcdir)/generated/sum_i8.c \\\n+$(srcdir)/generated/sum_i16.c \\\n+$(srcdir)/generated/sum_r4.c \\\n+$(srcdir)/generated/sum_r8.c \\\n+$(srcdir)/generated/sum_r10.c \\\n+$(srcdir)/generated/sum_r16.c \\\n+$(srcdir)/generated/sum_c4.c \\\n+$(srcdir)/generated/sum_c8.c \\\n+$(srcdir)/generated/sum_c10.c \\\n+$(srcdir)/generated/sum_c16.c\n \n i_product_c= \\\n-generated/product_i4.c \\\n-generated/product_i8.c \\\n-generated/product_i16.c \\\n-generated/product_r4.c \\\n-generated/product_r8.c \\\n-generated/product_r10.c \\\n-generated/product_r16.c \\\n-generated/product_c4.c \\\n-generated/product_c8.c \\\n-generated/product_c10.c \\\n-generated/product_c16.c\n+$(srcdir)/generated/product_i1.c \\\n+$(srcdir)/generated/product_i2.c \\\n+$(srcdir)/generated/product_i4.c \\\n+$(srcdir)/generated/product_i8.c \\\n+$(srcdir)/generated/product_i16.c \\\n+$(srcdir)/generated/product_r4.c \\\n+$(srcdir)/generated/product_r8.c \\\n+$(srcdir)/generated/product_r10.c \\\n+$(srcdir)/generated/product_r16.c \\\n+$(srcdir)/generated/product_c4.c \\\n+$(srcdir)/generated/product_c8.c \\\n+$(srcdir)/generated/product_c10.c \\\n+$(srcdir)/generated/product_c16.c\n \n i_matmul_c= \\\n-generated/matmul_i4.c \\\n-generated/matmul_i8.c \\\n-generated/matmul_i16.c \\\n-generated/matmul_r4.c \\\n-generated/matmul_r8.c \\\n-generated/matmul_r10.c \\\n-generated/matmul_r16.c \\\n-generated/matmul_c4.c \\\n-generated/matmul_c8.c \\\n-generated/matmul_c10.c \\\n-generated/matmul_c16.c\n+$(srcdir)/generated/matmul_i1.c \\\n+$(srcdir)/generated/matmul_i2.c \\\n+$(srcdir)/generated/matmul_i4.c \\\n+$(srcdir)/generated/matmul_i8.c \\\n+$(srcdir)/generated/matmul_i16.c \\\n+$(srcdir)/generated/matmul_r4.c \\\n+$(srcdir)/generated/matmul_r8.c \\\n+$(srcdir)/generated/matmul_r10.c \\\n+$(srcdir)/generated/matmul_r16.c \\\n+$(srcdir)/generated/matmul_c4.c \\\n+$(srcdir)/generated/matmul_c8.c \\\n+$(srcdir)/generated/matmul_c10.c \\\n+$(srcdir)/generated/matmul_c16.c\n \n i_matmull_c= \\\n-generated/matmul_l4.c \\\n-generated/matmul_l8.c \\\n-generated/matmul_l16.c\n+$(srcdir)/generated/matmul_l4.c \\\n+$(srcdir)/generated/matmul_l8.c \\\n+$(srcdir)/generated/matmul_l16.c\n \n i_transpose_c= \\\n-generated/transpose_i4.c \\\n-generated/transpose_i8.c \\\n-generated/transpose_i16.c \\\n-generated/transpose_r4.c \\\n-generated/transpose_r8.c \\\n-generated/transpose_r10.c \\\n-generated/transpose_r16.c \\\n-generated/transpose_c4.c \\\n-generated/transpose_c8.c \\\n-generated/transpose_c10.c \\\n-generated/transpose_c16.c\n+$(srcdir)/generated/transpose_i4.c \\\n+$(srcdir)/generated/transpose_i8.c \\\n+$(srcdir)/generated/transpose_i16.c \\\n+$(srcdir)/generated/transpose_r4.c \\\n+$(srcdir)/generated/transpose_r8.c \\\n+$(srcdir)/generated/transpose_r10.c \\\n+$(srcdir)/generated/transpose_r16.c \\\n+$(srcdir)/generated/transpose_c4.c \\\n+$(srcdir)/generated/transpose_c8.c \\\n+$(srcdir)/generated/transpose_c10.c \\\n+$(srcdir)/generated/transpose_c16.c\n \n i_shape_c= \\\n-generated/shape_i4.c \\\n-generated/shape_i8.c \\\n-generated/shape_i16.c\n+$(srcdir)/generated/shape_i4.c \\\n+$(srcdir)/generated/shape_i8.c \\\n+$(srcdir)/generated/shape_i16.c\n \n i_reshape_c= \\\n-generated/reshape_i4.c \\\n-generated/reshape_i8.c \\\n-generated/reshape_i16.c \\\n-generated/reshape_r4.c \\\n-generated/reshape_r8.c \\\n-generated/reshape_r10.c \\\n-generated/reshape_r16.c \\\n-generated/reshape_c4.c \\\n-generated/reshape_c8.c \\\n-generated/reshape_c10.c \\\n-generated/reshape_c16.c\n+$(srcdir)/generated/reshape_i4.c \\\n+$(srcdir)/generated/reshape_i8.c \\\n+$(srcdir)/generated/reshape_i16.c \\\n+$(srcdir)/generated/reshape_r4.c \\\n+$(srcdir)/generated/reshape_r8.c \\\n+$(srcdir)/generated/reshape_r10.c \\\n+$(srcdir)/generated/reshape_r16.c \\\n+$(srcdir)/generated/reshape_c4.c \\\n+$(srcdir)/generated/reshape_c8.c \\\n+$(srcdir)/generated/reshape_c10.c \\\n+$(srcdir)/generated/reshape_c16.c\n \n i_eoshift1_c= \\\n-generated/eoshift1_4.c \\\n-generated/eoshift1_8.c \\\n-generated/eoshift1_16.c\n+$(srcdir)/generated/eoshift1_4.c \\\n+$(srcdir)/generated/eoshift1_8.c \\\n+$(srcdir)/generated/eoshift1_16.c\n \n i_eoshift3_c= \\\n-generated/eoshift3_4.c \\\n-generated/eoshift3_8.c \\\n-generated/eoshift3_16.c\n+$(srcdir)/generated/eoshift3_4.c \\\n+$(srcdir)/generated/eoshift3_8.c \\\n+$(srcdir)/generated/eoshift3_16.c\n \n i_cshift1_c= \\\n-generated/cshift1_4.c \\\n-generated/cshift1_8.c \\\n-generated/cshift1_16.c\n+$(srcdir)/generated/cshift1_4.c \\\n+$(srcdir)/generated/cshift1_8.c \\\n+$(srcdir)/generated/cshift1_16.c\n \n in_pack_c = \\\n-generated/in_pack_i4.c \\\n-generated/in_pack_i8.c \\\n-generated/in_pack_i16.c \\\n-generated/in_pack_c4.c \\\n-generated/in_pack_c8.c \\\n-generated/in_pack_c10.c \\\n-generated/in_pack_c16.c\n+$(srcdir)/generated/in_pack_i4.c \\\n+$(srcdir)/generated/in_pack_i8.c \\\n+$(srcdir)/generated/in_pack_i16.c \\\n+$(srcdir)/generated/in_pack_c4.c \\\n+$(srcdir)/generated/in_pack_c8.c \\\n+$(srcdir)/generated/in_pack_c10.c \\\n+$(srcdir)/generated/in_pack_c16.c\n \n in_unpack_c = \\\n-generated/in_unpack_i4.c \\\n-generated/in_unpack_i8.c \\\n-generated/in_unpack_i16.c \\\n-generated/in_unpack_c4.c \\\n-generated/in_unpack_c8.c \\\n-generated/in_unpack_c10.c \\\n-generated/in_unpack_c16.c\n+$(srcdir)/generated/in_unpack_i4.c \\\n+$(srcdir)/generated/in_unpack_i8.c \\\n+$(srcdir)/generated/in_unpack_i16.c \\\n+$(srcdir)/generated/in_unpack_c4.c \\\n+$(srcdir)/generated/in_unpack_c8.c \\\n+$(srcdir)/generated/in_unpack_c10.c \\\n+$(srcdir)/generated/in_unpack_c16.c\n \n i_exponent_c = \\\n-generated/exponent_r4.c \\\n-generated/exponent_r8.c \\\n-generated/exponent_r10.c \\\n-generated/exponent_r16.c\n+$(srcdir)/generated/exponent_r4.c \\\n+$(srcdir)/generated/exponent_r8.c \\\n+$(srcdir)/generated/exponent_r10.c \\\n+$(srcdir)/generated/exponent_r16.c\n \n i_spacing_c = \\\n-generated/spacing_r4.c \\\n-generated/spacing_r8.c \\\n-generated/spacing_r10.c \\\n-generated/spacing_r16.c\n+$(srcdir)/generated/spacing_r4.c \\\n+$(srcdir)/generated/spacing_r8.c \\\n+$(srcdir)/generated/spacing_r10.c \\\n+$(srcdir)/generated/spacing_r16.c\n \n i_rrspacing_c = \\\n-generated/rrspacing_r4.c \\\n-generated/rrspacing_r8.c \\\n-generated/rrspacing_r10.c \\\n-generated/rrspacing_r16.c\n+$(srcdir)/generated/rrspacing_r4.c \\\n+$(srcdir)/generated/rrspacing_r8.c \\\n+$(srcdir)/generated/rrspacing_r10.c \\\n+$(srcdir)/generated/rrspacing_r16.c\n \n i_fraction_c = \\\n-generated/fraction_r4.c \\\n-generated/fraction_r8.c \\\n-generated/fraction_r10.c \\\n-generated/fraction_r16.c\n+$(srcdir)/generated/fraction_r4.c \\\n+$(srcdir)/generated/fraction_r8.c \\\n+$(srcdir)/generated/fraction_r10.c \\\n+$(srcdir)/generated/fraction_r16.c\n \n i_nearest_c = \\\n-generated/nearest_r4.c \\\n-generated/nearest_r8.c \\\n-generated/nearest_r10.c \\\n-generated/nearest_r16.c\n+$(srcdir)/generated/nearest_r4.c \\\n+$(srcdir)/generated/nearest_r8.c \\\n+$(srcdir)/generated/nearest_r10.c \\\n+$(srcdir)/generated/nearest_r16.c\n \n i_set_exponent_c = \\\n-generated/set_exponent_r4.c \\\n-generated/set_exponent_r8.c \\\n-generated/set_exponent_r10.c \\\n-generated/set_exponent_r16.c\n+$(srcdir)/generated/set_exponent_r4.c \\\n+$(srcdir)/generated/set_exponent_r8.c \\\n+$(srcdir)/generated/set_exponent_r10.c \\\n+$(srcdir)/generated/set_exponent_r16.c\n \n i_pow_c = \\\n-generated/pow_i4_i4.c \\\n-generated/pow_i8_i4.c \\\n-generated/pow_i16_i4.c \\\n-generated/pow_r4_i4.c \\\n-generated/pow_r8_i4.c \\\n-generated/pow_r10_i4.c \\\n-generated/pow_r16_i4.c \\\n-generated/pow_c4_i4.c \\\n-generated/pow_c8_i4.c \\\n-generated/pow_c10_i4.c \\\n-generated/pow_c16_i4.c \\\n-generated/pow_i4_i8.c \\\n-generated/pow_i8_i8.c \\\n-generated/pow_i16_i8.c \\\n-generated/pow_r4_i8.c \\\n-generated/pow_r8_i8.c \\\n-generated/pow_r10_i8.c \\\n-generated/pow_r16_i8.c \\\n-generated/pow_c4_i8.c \\\n-generated/pow_c8_i8.c \\\n-generated/pow_c10_i8.c \\\n-generated/pow_c16_i8.c \\\n-generated/pow_i4_i16.c \\\n-generated/pow_i8_i16.c \\\n-generated/pow_i16_i16.c \\\n-generated/pow_r4_i16.c \\\n-generated/pow_r8_i16.c \\\n-generated/pow_r10_i16.c \\\n-generated/pow_r16_i16.c \\\n-generated/pow_c4_i16.c \\\n-generated/pow_c8_i16.c \\\n-generated/pow_c10_i16.c \\\n-generated/pow_c16_i16.c\n+$(srcdir)/generated/pow_i4_i4.c \\\n+$(srcdir)/generated/pow_i8_i4.c \\\n+$(srcdir)/generated/pow_i16_i4.c \\\n+$(srcdir)/generated/pow_r4_i4.c \\\n+$(srcdir)/generated/pow_r8_i4.c \\\n+$(srcdir)/generated/pow_r10_i4.c \\\n+$(srcdir)/generated/pow_r16_i4.c \\\n+$(srcdir)/generated/pow_c4_i4.c \\\n+$(srcdir)/generated/pow_c8_i4.c \\\n+$(srcdir)/generated/pow_c10_i4.c \\\n+$(srcdir)/generated/pow_c16_i4.c \\\n+$(srcdir)/generated/pow_i4_i8.c \\\n+$(srcdir)/generated/pow_i8_i8.c \\\n+$(srcdir)/generated/pow_i16_i8.c \\\n+$(srcdir)/generated/pow_r4_i8.c \\\n+$(srcdir)/generated/pow_r8_i8.c \\\n+$(srcdir)/generated/pow_r10_i8.c \\\n+$(srcdir)/generated/pow_r16_i8.c \\\n+$(srcdir)/generated/pow_c4_i8.c \\\n+$(srcdir)/generated/pow_c8_i8.c \\\n+$(srcdir)/generated/pow_c10_i8.c \\\n+$(srcdir)/generated/pow_c16_i8.c \\\n+$(srcdir)/generated/pow_i4_i16.c \\\n+$(srcdir)/generated/pow_i8_i16.c \\\n+$(srcdir)/generated/pow_i16_i16.c \\\n+$(srcdir)/generated/pow_r4_i16.c \\\n+$(srcdir)/generated/pow_r8_i16.c \\\n+$(srcdir)/generated/pow_r10_i16.c \\\n+$(srcdir)/generated/pow_r16_i16.c \\\n+$(srcdir)/generated/pow_c4_i16.c \\\n+$(srcdir)/generated/pow_c8_i16.c \\\n+$(srcdir)/generated/pow_c10_i16.c \\\n+$(srcdir)/generated/pow_c16_i16.c\n \n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n@@ -440,146 +474,146 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n-generated/_abs_c4.F90 \\\n-generated/_abs_c8.F90 \\\n-generated/_abs_c10.F90 \\\n-generated/_abs_c16.F90 \\\n-generated/_abs_i4.F90 \\\n-generated/_abs_i8.F90 \\\n-generated/_abs_i16.F90 \\\n-generated/_abs_r4.F90 \\\n-generated/_abs_r8.F90 \\\n-generated/_abs_r10.F90 \\\n-generated/_abs_r16.F90 \\\n-generated/_aimag_c4.F90 \\\n-generated/_aimag_c8.F90 \\\n-generated/_aimag_c10.F90 \\\n-generated/_aimag_c16.F90 \\\n-generated/_exp_r4.F90 \\\n-generated/_exp_r8.F90 \\\n-generated/_exp_r10.F90 \\\n-generated/_exp_r16.F90 \\\n-generated/_exp_c4.F90 \\\n-generated/_exp_c8.F90 \\\n-generated/_exp_c10.F90 \\\n-generated/_exp_c16.F90 \\\n-generated/_log_r4.F90 \\\n-generated/_log_r8.F90 \\\n-generated/_log_r10.F90 \\\n-generated/_log_r16.F90 \\\n-generated/_log_c4.F90 \\\n-generated/_log_c8.F90 \\\n-generated/_log_c10.F90 \\\n-generated/_log_c16.F90 \\\n-generated/_log10_r4.F90 \\\n-generated/_log10_r8.F90 \\\n-generated/_log10_r10.F90 \\\n-generated/_log10_r16.F90 \\\n-generated/_sqrt_r4.F90 \\\n-generated/_sqrt_r8.F90 \\\n-generated/_sqrt_r10.F90 \\\n-generated/_sqrt_r16.F90 \\\n-generated/_sqrt_c4.F90 \\\n-generated/_sqrt_c8.F90 \\\n-generated/_sqrt_c10.F90 \\\n-generated/_sqrt_c16.F90 \\\n-generated/_asin_r4.F90 \\\n-generated/_asin_r8.F90 \\\n-generated/_asin_r10.F90 \\\n-generated/_asin_r16.F90 \\\n-generated/_asinh_r4.F90 \\\n-generated/_asinh_r8.F90 \\\n-generated/_asinh_r10.F90 \\\n-generated/_asinh_r16.F90 \\\n-generated/_acos_r4.F90 \\\n-generated/_acos_r8.F90 \\\n-generated/_acos_r10.F90 \\\n-generated/_acos_r16.F90 \\\n-generated/_acosh_r4.F90 \\\n-generated/_acosh_r8.F90 \\\n-generated/_acosh_r10.F90 \\\n-generated/_acosh_r16.F90 \\\n-generated/_atan_r4.F90 \\\n-generated/_atan_r8.F90 \\\n-generated/_atan_r10.F90 \\\n-generated/_atan_r16.F90 \\\n-generated/_atanh_r4.F90 \\\n-generated/_atanh_r8.F90 \\\n-generated/_atanh_r10.F90 \\\n-generated/_atanh_r16.F90 \\\n-generated/_sin_r4.F90 \\\n-generated/_sin_r8.F90 \\\n-generated/_sin_r10.F90 \\\n-generated/_sin_r16.F90 \\\n-generated/_sin_c4.F90 \\\n-generated/_sin_c8.F90 \\\n-generated/_sin_c10.F90 \\\n-generated/_sin_c16.F90 \\\n-generated/_cos_r4.F90 \\\n-generated/_cos_r8.F90 \\\n-generated/_cos_r10.F90 \\\n-generated/_cos_r16.F90 \\\n-generated/_cos_c4.F90 \\\n-generated/_cos_c8.F90 \\\n-generated/_cos_c10.F90 \\\n-generated/_cos_c16.F90 \\\n-generated/_tan_r4.F90 \\\n-generated/_tan_r8.F90 \\\n-generated/_tan_r10.F90 \\\n-generated/_tan_r16.F90 \\\n-generated/_sinh_r4.F90 \\\n-generated/_sinh_r8.F90 \\\n-generated/_sinh_r10.F90 \\\n-generated/_sinh_r16.F90 \\\n-generated/_cosh_r4.F90 \\\n-generated/_cosh_r8.F90 \\\n-generated/_cosh_r10.F90 \\\n-generated/_cosh_r16.F90 \\\n-generated/_tanh_r4.F90 \\\n-generated/_tanh_r8.F90 \\\n-generated/_tanh_r10.F90 \\\n-generated/_tanh_r16.F90 \\\n-generated/_conjg_c4.F90 \\\n-generated/_conjg_c8.F90 \\\n-generated/_conjg_c10.F90 \\\n-generated/_conjg_c16.F90 \\\n-generated/_aint_r4.F90 \\\n-generated/_aint_r8.F90 \\\n-generated/_aint_r10.F90 \\\n-generated/_aint_r16.F90 \\\n-generated/_anint_r4.F90 \\\n-generated/_anint_r8.F90 \\\n-generated/_anint_r10.F90 \\\n-generated/_anint_r16.F90\n+$(srcdir)/generated/_abs_c4.F90 \\\n+$(srcdir)/generated/_abs_c8.F90 \\\n+$(srcdir)/generated/_abs_c10.F90 \\\n+$(srcdir)/generated/_abs_c16.F90 \\\n+$(srcdir)/generated/_abs_i4.F90 \\\n+$(srcdir)/generated/_abs_i8.F90 \\\n+$(srcdir)/generated/_abs_i16.F90 \\\n+$(srcdir)/generated/_abs_r4.F90 \\\n+$(srcdir)/generated/_abs_r8.F90 \\\n+$(srcdir)/generated/_abs_r10.F90 \\\n+$(srcdir)/generated/_abs_r16.F90 \\\n+$(srcdir)/generated/_aimag_c4.F90 \\\n+$(srcdir)/generated/_aimag_c8.F90 \\\n+$(srcdir)/generated/_aimag_c10.F90 \\\n+$(srcdir)/generated/_aimag_c16.F90 \\\n+$(srcdir)/generated/_exp_r4.F90 \\\n+$(srcdir)/generated/_exp_r8.F90 \\\n+$(srcdir)/generated/_exp_r10.F90 \\\n+$(srcdir)/generated/_exp_r16.F90 \\\n+$(srcdir)/generated/_exp_c4.F90 \\\n+$(srcdir)/generated/_exp_c8.F90 \\\n+$(srcdir)/generated/_exp_c10.F90 \\\n+$(srcdir)/generated/_exp_c16.F90 \\\n+$(srcdir)/generated/_log_r4.F90 \\\n+$(srcdir)/generated/_log_r8.F90 \\\n+$(srcdir)/generated/_log_r10.F90 \\\n+$(srcdir)/generated/_log_r16.F90 \\\n+$(srcdir)/generated/_log_c4.F90 \\\n+$(srcdir)/generated/_log_c8.F90 \\\n+$(srcdir)/generated/_log_c10.F90 \\\n+$(srcdir)/generated/_log_c16.F90 \\\n+$(srcdir)/generated/_log10_r4.F90 \\\n+$(srcdir)/generated/_log10_r8.F90 \\\n+$(srcdir)/generated/_log10_r10.F90 \\\n+$(srcdir)/generated/_log10_r16.F90 \\\n+$(srcdir)/generated/_sqrt_r4.F90 \\\n+$(srcdir)/generated/_sqrt_r8.F90 \\\n+$(srcdir)/generated/_sqrt_r10.F90 \\\n+$(srcdir)/generated/_sqrt_r16.F90 \\\n+$(srcdir)/generated/_sqrt_c4.F90 \\\n+$(srcdir)/generated/_sqrt_c8.F90 \\\n+$(srcdir)/generated/_sqrt_c10.F90 \\\n+$(srcdir)/generated/_sqrt_c16.F90 \\\n+$(srcdir)/generated/_asin_r4.F90 \\\n+$(srcdir)/generated/_asin_r8.F90 \\\n+$(srcdir)/generated/_asin_r10.F90 \\\n+$(srcdir)/generated/_asin_r16.F90 \\\n+$(srcdir)/generated/_asinh_r4.F90 \\\n+$(srcdir)/generated/_asinh_r8.F90 \\\n+$(srcdir)/generated/_asinh_r10.F90 \\\n+$(srcdir)/generated/_asinh_r16.F90 \\\n+$(srcdir)/generated/_acos_r4.F90 \\\n+$(srcdir)/generated/_acos_r8.F90 \\\n+$(srcdir)/generated/_acos_r10.F90 \\\n+$(srcdir)/generated/_acos_r16.F90 \\\n+$(srcdir)/generated/_acosh_r4.F90 \\\n+$(srcdir)/generated/_acosh_r8.F90 \\\n+$(srcdir)/generated/_acosh_r10.F90 \\\n+$(srcdir)/generated/_acosh_r16.F90 \\\n+$(srcdir)/generated/_atan_r4.F90 \\\n+$(srcdir)/generated/_atan_r8.F90 \\\n+$(srcdir)/generated/_atan_r10.F90 \\\n+$(srcdir)/generated/_atan_r16.F90 \\\n+$(srcdir)/generated/_atanh_r4.F90 \\\n+$(srcdir)/generated/_atanh_r8.F90 \\\n+$(srcdir)/generated/_atanh_r10.F90 \\\n+$(srcdir)/generated/_atanh_r16.F90 \\\n+$(srcdir)/generated/_sin_r4.F90 \\\n+$(srcdir)/generated/_sin_r8.F90 \\\n+$(srcdir)/generated/_sin_r10.F90 \\\n+$(srcdir)/generated/_sin_r16.F90 \\\n+$(srcdir)/generated/_sin_c4.F90 \\\n+$(srcdir)/generated/_sin_c8.F90 \\\n+$(srcdir)/generated/_sin_c10.F90 \\\n+$(srcdir)/generated/_sin_c16.F90 \\\n+$(srcdir)/generated/_cos_r4.F90 \\\n+$(srcdir)/generated/_cos_r8.F90 \\\n+$(srcdir)/generated/_cos_r10.F90 \\\n+$(srcdir)/generated/_cos_r16.F90 \\\n+$(srcdir)/generated/_cos_c4.F90 \\\n+$(srcdir)/generated/_cos_c8.F90 \\\n+$(srcdir)/generated/_cos_c10.F90 \\\n+$(srcdir)/generated/_cos_c16.F90 \\\n+$(srcdir)/generated/_tan_r4.F90 \\\n+$(srcdir)/generated/_tan_r8.F90 \\\n+$(srcdir)/generated/_tan_r10.F90 \\\n+$(srcdir)/generated/_tan_r16.F90 \\\n+$(srcdir)/generated/_sinh_r4.F90 \\\n+$(srcdir)/generated/_sinh_r8.F90 \\\n+$(srcdir)/generated/_sinh_r10.F90 \\\n+$(srcdir)/generated/_sinh_r16.F90 \\\n+$(srcdir)/generated/_cosh_r4.F90 \\\n+$(srcdir)/generated/_cosh_r8.F90 \\\n+$(srcdir)/generated/_cosh_r10.F90 \\\n+$(srcdir)/generated/_cosh_r16.F90 \\\n+$(srcdir)/generated/_tanh_r4.F90 \\\n+$(srcdir)/generated/_tanh_r8.F90 \\\n+$(srcdir)/generated/_tanh_r10.F90 \\\n+$(srcdir)/generated/_tanh_r16.F90 \\\n+$(srcdir)/generated/_conjg_c4.F90 \\\n+$(srcdir)/generated/_conjg_c8.F90 \\\n+$(srcdir)/generated/_conjg_c10.F90 \\\n+$(srcdir)/generated/_conjg_c16.F90 \\\n+$(srcdir)/generated/_aint_r4.F90 \\\n+$(srcdir)/generated/_aint_r8.F90 \\\n+$(srcdir)/generated/_aint_r10.F90 \\\n+$(srcdir)/generated/_aint_r16.F90 \\\n+$(srcdir)/generated/_anint_r4.F90 \\\n+$(srcdir)/generated/_anint_r8.F90 \\\n+$(srcdir)/generated/_anint_r10.F90 \\\n+$(srcdir)/generated/_anint_r16.F90\n \n gfor_built_specific2_src= \\\n-generated/_sign_i4.F90 \\\n-generated/_sign_i8.F90 \\\n-generated/_sign_i16.F90 \\\n-generated/_sign_r4.F90 \\\n-generated/_sign_r8.F90 \\\n-generated/_sign_r10.F90 \\\n-generated/_sign_r16.F90 \\\n-generated/_dim_i4.F90 \\\n-generated/_dim_i8.F90 \\\n-generated/_dim_i16.F90 \\\n-generated/_dim_r4.F90 \\\n-generated/_dim_r8.F90 \\\n-generated/_dim_r10.F90 \\\n-generated/_dim_r16.F90 \\\n-generated/_atan2_r4.F90 \\\n-generated/_atan2_r8.F90 \\\n-generated/_atan2_r10.F90 \\\n-generated/_atan2_r16.F90 \\\n-generated/_mod_i4.F90 \\\n-generated/_mod_i8.F90 \\\n-generated/_mod_i16.F90 \\\n-generated/_mod_r4.F90 \\\n-generated/_mod_r8.F90 \\\n-generated/_mod_r10.F90 \\\n-generated/_mod_r16.F90\n-\n-gfor_misc_specifics = generated/misc_specifics.F90\n+$(srcdir)/generated/_sign_i4.F90 \\\n+$(srcdir)/generated/_sign_i8.F90 \\\n+$(srcdir)/generated/_sign_i16.F90 \\\n+$(srcdir)/generated/_sign_r4.F90 \\\n+$(srcdir)/generated/_sign_r8.F90 \\\n+$(srcdir)/generated/_sign_r10.F90 \\\n+$(srcdir)/generated/_sign_r16.F90 \\\n+$(srcdir)/generated/_dim_i4.F90 \\\n+$(srcdir)/generated/_dim_i8.F90 \\\n+$(srcdir)/generated/_dim_i16.F90 \\\n+$(srcdir)/generated/_dim_r4.F90 \\\n+$(srcdir)/generated/_dim_r8.F90 \\\n+$(srcdir)/generated/_dim_r10.F90 \\\n+$(srcdir)/generated/_dim_r16.F90 \\\n+$(srcdir)/generated/_atan2_r4.F90 \\\n+$(srcdir)/generated/_atan2_r8.F90 \\\n+$(srcdir)/generated/_atan2_r10.F90 \\\n+$(srcdir)/generated/_atan2_r16.F90 \\\n+$(srcdir)/generated/_mod_i4.F90 \\\n+$(srcdir)/generated/_mod_i8.F90 \\\n+$(srcdir)/generated/_mod_i16.F90 \\\n+$(srcdir)/generated/_mod_r4.F90 \\\n+$(srcdir)/generated/_mod_r8.F90 \\\n+$(srcdir)/generated/_mod_r10.F90 \\\n+$(srcdir)/generated/_mod_r16.F90\n+\n+gfor_misc_specifics = $(srcdir)/generated/misc_specifics.F90\n \n gfor_specific_src= \\\n $(gfor_built_specific_src) \\\n@@ -717,13 +751,13 @@ $(i_pow_c): m4/pow.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 pow.m4 > $@\n \n $(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n-\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $(srcdir)/$@\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n \n $(gfor_built_specific2_src): m4/specific2.m4 m4/head.m4\n-\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific2.m4 > $(srcdir)/$@\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific2.m4 > $@\n \n $(gfor_misc_specifics): m4/misc_specifics.m4 m4/head.m4\n-\t$(M4) -Dfile=$@ -I$(srcdir)/m4 misc_specifics.m4 > $(srcdir)/$@\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 misc_specifics.m4 > $@\n ## end of maintainer mode only rules\n endif\n "}, {"sha": "2040d6a51be6c388a898e18316164a2de396d468", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 2020, "deletions": 1702, "changes": 3722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994"}, {"sha": "ce98de1795011ec848a0cf8895ed7c8beb456e15", "filename": "libgfortran/generated/matmul_i1.c", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,339 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_1 *, const GFC_INTEGER_1 *,\n+                          const int *, const GFC_INTEGER_1 *, const int *,\n+                          const GFC_INTEGER_1 *, GFC_INTEGER_1 *, const int *,\n+                          int, int);\n+\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n+       DO I=1,M\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)*B(K,J)\n+         C(I,J) = S\n+   ENDIF\n+*/\n+\n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n+extern void matmul_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n+export_proto(matmul_i1);\n+\n+void\n+matmul_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_INTEGER_1) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_INTEGER_1 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      const GFC_INTEGER_1 * restrict bbase_y;\n+      GFC_INTEGER_1 * restrict dest_y;\n+      const GFC_INTEGER_1 * restrict abase_n;\n+      GFC_INTEGER_1 bbase_yn;\n+\n+      if (rystride == xcount)\n+\tmemset (dest, 0, (sizeof (GFC_INTEGER_1) * xcount * ycount));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_INTEGER_1)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+\n+#endif"}, {"sha": "b86839e379bb1b0b7932b68cbd1bdbd40c150f26", "filename": "libgfortran/generated/matmul_i2.c", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,339 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright 2002, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_2 *, const GFC_INTEGER_2 *,\n+                          const int *, const GFC_INTEGER_2 *, const int *,\n+                          const GFC_INTEGER_2 *, GFC_INTEGER_2 *, const int *,\n+                          int, int);\n+\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n+\n+   DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n+       DO I=1,M\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)*B(K,J)\n+         C(I,J) = S\n+   ENDIF\n+*/\n+\n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n+extern void matmul_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n+export_proto(matmul_i2);\n+\n+void\n+matmul_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+  */\n+\n+  if (retarray->data == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+        }\n+      else\n+        {\n+          retarray->dim[0].lbound = 0;\n+          retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n+          retarray->dim[0].stride = 1;\n+\n+          retarray->dim[1].lbound = 0;\n+          retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n+          retarray->dim[1].stride = retarray->dim[0].ubound+1;\n+        }\n+\n+      retarray->data\n+\t= internal_malloc_size (sizeof (GFC_INTEGER_2) * size0 ((array_t *) retarray));\n+      retarray->offset = 0;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = retarray->dim[0].stride;\n+    }\n+  else\n+    {\n+      rxstride = retarray->dim[0].stride;\n+      rystride = retarray->dim[1].stride;\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = a->dim[0].stride;\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+  else\n+    {\n+      axstride = a->dim[0].stride;\n+      aystride = a->dim[1].stride;\n+\n+      count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n+      xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n+    }\n+\n+  assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = b->dim[0].stride;\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = b->dim[0].stride;\n+      bystride = b->dim[1].stride;\n+      ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n+    }\n+\n+  abase = a->data;\n+  bbase = b->data;\n+  dest = retarray->data;\n+\n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_INTEGER_2 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      const GFC_INTEGER_2 * restrict bbase_y;\n+      GFC_INTEGER_2 * restrict dest_y;\n+      const GFC_INTEGER_2 * restrict abase_n;\n+      GFC_INTEGER_2 bbase_yn;\n+\n+      if (rystride == xcount)\n+\tmemset (dest, 0, (sizeof (GFC_INTEGER_2) * xcount * ycount));\n+      else\n+\t{\n+\t  for (y = 0; y < ycount; y++)\n+\t    for (x = 0; x < xcount; x++)\n+\t      dest[x + y*rystride] = (GFC_INTEGER_2)0;\n+\t}\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = bbase + y*bystride;\n+\t  dest_y = dest + y*rystride;\n+\t  for (n = 0; n < count; n++)\n+\t    {\n+\t      abase_n = abase + n*aystride;\n+\t      bbase_yn = bbase_y[n];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+\n+#endif"}, {"sha": "29c5f84b2a2425f291dfca75d23969b08a6586bf", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(maxloc0_16_i1);\n+\n+void\n+maxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_16_i1);\n+\n+void\n+mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_i1);\n+\n+void\n+smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "8cec214da8df4480e73f8520d52863f923412800", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(maxloc0_16_i2);\n+\n+void\n+maxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_16_i2);\n+\n+void\n+mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_i2);\n+\n+void\n+smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "33d576ccfcb4e3439f0260eea555dcbc63c1f5e9", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(maxloc0_4_i1);\n+\n+void\n+maxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_4_i1);\n+\n+void\n+mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_i1);\n+\n+void\n+smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "548f769cfd8a32da828ed5912a07ca6ef021b1ce", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(maxloc0_4_i2);\n+\n+void\n+maxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_4_i2);\n+\n+void\n+mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_i2);\n+\n+void\n+smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "76ce6c6cb81910f6b61ef5a627e82c990e489c79", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(maxloc0_8_i1);\n+\n+void\n+maxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_8_i1);\n+\n+void\n+mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 maxval;\n+\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_i1);\n+\n+void\n+smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "d6eaf04dd01632533ee4d1041c4441fe196d85c8", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(maxloc0_8_i2);\n+\n+void\n+maxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base > maxval || !dest[0])\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mmaxloc0_8_i2);\n+\n+void\n+mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 maxval;\n+\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base > maxval || !dest[0]))\n+    {\n+      maxval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_i2);\n+\n+void\n+smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "faa8d8539db3be34e129e4ef6c25d27c7c2a6099", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_16_i1);\n+\n+void\n+maxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_16_i1);\n+\n+void\n+mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_i1);\n+\n+void\n+smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "2bbaef5f70d12d7083ceaa1677fb209b7ef35e5b", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_16_i2);\n+\n+void\n+maxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_16_i2);\n+\n+void\n+mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_i2);\n+\n+void\n+smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "f441d7b0df859a18b617fc8b059e41581a172858", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_4_i1);\n+\n+void\n+maxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_4_i1);\n+\n+void\n+mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_i1);\n+\n+void\n+smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "40b66bb655a6f96c216f400108b6b9d957572604", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_4_i2);\n+\n+void\n+maxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_4_i2);\n+\n+void\n+mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_i2);\n+\n+void\n+smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "f103083c34aaef57ac8037533a6bb2542fc52be1", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_8_i1);\n+\n+void\n+maxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_8_i1);\n+\n+void\n+mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 maxval;\n+  maxval = (-GFC_INTEGER_1_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_i1);\n+\n+void\n+smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "9c0c6350cfd99fd038267651ededb609afeecc9f", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(maxloc1_8_i2);\n+\n+void\n+maxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > maxval || !result)\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxloc1_8_i2);\n+\n+void\n+mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 maxval;\n+  maxval = (-GFC_INTEGER_2_HUGE-1);\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src > maxval || !result))\n+    {\n+      maxval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_i2);\n+\n+void\n+smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "042e8ad922030edf39628b5c8644bcdea512e22c", "filename": "libgfortran/generated/maxval_i1.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,410 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void maxval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(maxval_i1);\n+\n+void\n+maxval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = (-GFC_INTEGER_1_HUGE-1);\n+        if (len <= 0)\n+\t  *dest = (-GFC_INTEGER_1_HUGE-1);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > result)\n+    result = *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxval_i1);\n+\n+void\n+mmaxval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = (-GFC_INTEGER_1_HUGE-1);\n+        if (len <= 0)\n+\t  *dest = (-GFC_INTEGER_1_HUGE-1);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > result)\n+    result = *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_i1);\n+\n+void\n+smaxval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_1 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = (-GFC_INTEGER_1_HUGE-1) ;\n+}\n+\n+#endif"}, {"sha": "53a090684c33fdf0ee726273d3c386605aa027cb", "filename": "libgfortran/generated/maxval_i2.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,410 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void maxval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(maxval_i2);\n+\n+void\n+maxval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = (-GFC_INTEGER_2_HUGE-1);\n+        if (len <= 0)\n+\t  *dest = (-GFC_INTEGER_2_HUGE-1);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src > result)\n+    result = *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mmaxval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mmaxval_i2);\n+\n+void\n+mmaxval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = (-GFC_INTEGER_2_HUGE-1);\n+        if (len <= 0)\n+\t  *dest = (-GFC_INTEGER_2_HUGE-1);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src > result)\n+    result = *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void smaxval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_i2);\n+\n+void\n+smaxval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_2 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = (-GFC_INTEGER_2_HUGE-1) ;\n+}\n+\n+#endif"}, {"sha": "963abdbd9512c3bb403c003699f52008143772ee", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void minloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(minloc0_16_i1);\n+\n+void\n+minloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_16_i1);\n+\n+void\n+mminloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_i1);\n+\n+void\n+sminloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "edf1c0408fc4ed560521341ebf8047d3d51b1cfb", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void minloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(minloc0_16_i2);\n+\n+void\n+minloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_16 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_16_i2);\n+\n+void\n+mminloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_i2);\n+\n+void\n+sminloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "c07ba80802d62a4a178305aa9436ee8c20e10587", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void minloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(minloc0_4_i1);\n+\n+void\n+minloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_4_i1);\n+\n+void\n+mminloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_i1);\n+\n+void\n+sminloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "398bf65492dfbf55d8b3b26f663117c0a87b65d2", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void minloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(minloc0_4_i2);\n+\n+void\n+minloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_4 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_4_i2);\n+\n+void\n+mminloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_i2);\n+\n+void\n+sminloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "628e94025d989630c365b1d92a9f78cdd9271815", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void minloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array);\n+export_proto(minloc0_8_i1);\n+\n+void\n+minloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_8_i1);\n+\n+void\n+mminloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_1 minval;\n+\n+  minval = GFC_INTEGER_1_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_i1);\n+\n+void\n+sminloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_i1 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "9e03ee5dce1c038b67986f3d2acac83f7e4f92b2", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,326 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void minloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array);\n+export_proto(minloc0_8_i2);\n+\n+void\n+minloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_2 *base;\n+  GFC_INTEGER_8 *dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*base < minval || !dest[0])\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+export_proto(mminloc0_8_i2);\n+\n+void\n+mminloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_2 *base;\n+  GFC_LOGICAL_4 *mbase;\n+  int rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_INTEGER_2 minval;\n+\n+  minval = GFC_INTEGER_2_HUGE;\n+\n+  while (base)\n+    {\n+      {\n+        /* Implementation start.  */\n+\n+  if (*mbase && (*base < minval || !dest[0]))\n+    {\n+      minval = *base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+        /* Implementation end.  */\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the loop.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+            }\n+        }\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_i2);\n+\n+void\n+sminloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_i2 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "9325b1f0863c88fe6f406138b8fd540f998adc16", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void minloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_16_i1);\n+\n+void\n+minloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_16_i1);\n+\n+void\n+mminloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_16_i1 (gfc_array_i16 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_i1);\n+\n+void\n+sminloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "0e8aa00f87c0df41c287b9ce52122924a36fb2b9", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void minloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_16_i2);\n+\n+void\n+minloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_16_i2);\n+\n+void\n+mminloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_16)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_16_i2 (gfc_array_i16 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_i2);\n+\n+void\n+sminloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "4e0c4dd02bb576a272363edd297030539a80dca1", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void minloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_4_i1);\n+\n+void\n+minloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_4_i1);\n+\n+void\n+mminloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_4_i1 (gfc_array_i4 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_i1);\n+\n+void\n+sminloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "6c6ba8f9be90061a2dbaab2394aa824fecf77c94", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void minloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_4_i2);\n+\n+void\n+minloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_4_i2);\n+\n+void\n+mminloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_4)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_4_i2 (gfc_array_i4 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_i2);\n+\n+void\n+sminloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "187393aaef0652a39f14a29d945ed46eabf2a81b", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void minloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_8_i1);\n+\n+void\n+minloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_8_i1);\n+\n+void\n+mminloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_1 minval;\n+  minval = GFC_INTEGER_1_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_8_i1 (gfc_array_i8 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_i1);\n+\n+void\n+sminloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "04c3618805e22461b47cbcbe654907c604240b4a", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,421 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include <limits.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void minloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(minloc1_8_i2);\n+\n+void\n+minloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < minval || !result)\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminloc1_8_i2);\n+\n+void\n+mminloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  GFC_INTEGER_2 minval;\n+  minval = GFC_INTEGER_2_HUGE;\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && (*src < minval || !result))\n+    {\n+      minval = *src;\n+      result = (GFC_INTEGER_8)n + 1;\n+    }\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminloc1_8_i2 (gfc_array_i8 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_i2);\n+\n+void\n+sminloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "9959915493a899dd51be96ec971741f0786fd8b0", "filename": "libgfortran/generated/minval_i1.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,410 @@\n+/* Implementation of the MINVAL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void minval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(minval_i1);\n+\n+void\n+minval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = GFC_INTEGER_1_HUGE;\n+        if (len <= 0)\n+\t  *dest = GFC_INTEGER_1_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < result)\n+    result = *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminval_i1);\n+\n+void\n+mminval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = GFC_INTEGER_1_HUGE;\n+        if (len <= 0)\n+\t  *dest = GFC_INTEGER_1_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src < result)\n+    result = *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminval_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_i1);\n+\n+void\n+sminval_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_1 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_INTEGER_1_HUGE ;\n+}\n+\n+#endif"}, {"sha": "e42c9f69be526ad4f0f685f48ff0231b25b8f51f", "filename": "libgfortran/generated/minval_i2.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,410 @@\n+/* Implementation of the MINVAL intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <float.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void minval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(minval_i2);\n+\n+void\n+minval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = GFC_INTEGER_2_HUGE;\n+        if (len <= 0)\n+\t  *dest = GFC_INTEGER_2_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (*src < result)\n+    result = *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mminval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mminval_i2);\n+\n+void\n+mminval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = GFC_INTEGER_2_HUGE;\n+        if (len <= 0)\n+\t  *dest = GFC_INTEGER_2_HUGE;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc && *src < result)\n+    result = *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sminval_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_i2);\n+\n+void\n+sminval_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_2 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_INTEGER_2_HUGE ;\n+}\n+\n+#endif"}, {"sha": "76427e4cbb7ac5170142284efe7e792a48e0f60a", "filename": "libgfortran/generated/product_i1.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void product_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(product_i1);\n+\n+void\n+product_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result *= *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mproduct_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mproduct_i1);\n+\n+void\n+mproduct_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result *= *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sproduct_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_i1);\n+\n+void\n+sproduct_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_1 *dest;\n+\n+  if (*mask)\n+    {\n+      product_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n+#endif"}, {"sha": "bdb51a65c529e035c6fc21d8663502f32bc131de", "filename": "libgfortran/generated/product_i2.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the PRODUCT intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void product_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(product_i2);\n+\n+void\n+product_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result *= *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void mproduct_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(mproduct_i2);\n+\n+void\n+mproduct_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result *= *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void sproduct_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_i2);\n+\n+void\n+sproduct_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_2 *dest;\n+\n+  if (*mask)\n+    {\n+      product_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n+#endif"}, {"sha": "87205b8f7166ccb14f0310843135455c05bae5a5", "filename": "libgfortran/generated/sum_i1.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the SUM intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void sum_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(sum_i1);\n+\n+void\n+sum_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result += *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void msum_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(msum_i1);\n+\n+void\n+msum_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result += *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void ssum_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_i1);\n+\n+void\n+ssum_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_1 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_i1 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "c4452c3ce9d8636f0919c01a4f902128635c906d", "filename": "libgfortran/generated/sum_i2.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the SUM intrinsic\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void sum_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(sum_i2);\n+\n+void\n+sum_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result += *src;\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void msum_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l4 * const restrict);\n+export_proto(msum_i2);\n+\n+void\n+msum_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l4 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_4 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  if (len <= 0)\n+    return;\n+  delta = array->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+  mbase = mask->data;\n+\n+  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n+    {\n+      /* This allows the same loop to be used for all logical types.  */\n+      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n+      for (n = 0; n < rank; n++)\n+        mstride[n] <<= 1;\n+      mdelta <<= 1;\n+      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n+    }\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_4 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result += *src;\n+              }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          mbase -= mstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              mbase += mstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+\n+extern void ssum_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_i2);\n+\n+void\n+ssum_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_2 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_i2 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "80698e944225873284fe3b8568c7441aecf6049b", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567c915b047d488dbbe1a25bc3359ca4ce2ab994/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=567c915b047d488dbbe1a25bc3359ca4ce2ab994", "patch": "@@ -224,6 +224,10 @@ internal_proto(l8_to_l4_offset);\n #define GFOR_POINTER_L8_TO_L4(p8) \\\n   (l8_to_l4_offset + (GFC_LOGICAL_4 *)(p8))\n \n+#define GFC_INTEGER_1_HUGE \\\n+  (GFC_INTEGER_1)((((GFC_UINTEGER_1)1) << 7) - 1)\n+#define GFC_INTEGER_2_HUGE \\\n+  (GFC_INTEGER_2)((((GFC_UINTEGER_2)1) << 15) - 1)\n #define GFC_INTEGER_4_HUGE \\\n   (GFC_INTEGER_4)((((GFC_UINTEGER_4)1) << 31) - 1)\n #define GFC_INTEGER_8_HUGE \\\n@@ -283,6 +287,8 @@ struct {\\\n /* Commonly used array descriptor types.  */\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, void) gfc_array_void;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, char) gfc_array_char;\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_INTEGER_1) gfc_array_i1;\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_INTEGER_2) gfc_array_i2;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_INTEGER_4) gfc_array_i4;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_INTEGER_8) gfc_array_i8;\n #ifdef HAVE_GFC_INTEGER_16"}]}