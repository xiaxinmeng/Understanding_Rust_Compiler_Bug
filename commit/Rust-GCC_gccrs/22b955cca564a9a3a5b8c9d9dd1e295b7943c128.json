{"sha": "22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiOTU1Y2NhNTY0YTlhM2E1YjhjOWQ5ZGQxZTI5NWI3OTQzYzEyOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-07-22T18:15:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-07-22T18:15:38Z"}, "message": "libgo: update to go1.7rc3\n    \n    Reviewed-on: https://go-review.googlesource.com/25150\n\nFrom-SVN: r238662", "tree": {"sha": "abdbd898676e1f853fca2d7e031d105d7ebcf676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abdbd898676e1f853fca2d7e031d105d7ebcf676"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/comments", "author": null, "committer": null, "parents": [{"sha": "9d04a3af4c6491536badf6bde9707c907e4d196b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d04a3af4c6491536badf6bde9707c907e4d196b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d04a3af4c6491536badf6bde9707c907e4d196b"}], "stats": {"total": 68417, "additions": 51789, "deletions": 16628}, "files": [{"sha": "99a68baee786202db17961bde4b53897cba2ab63", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-4c88f31a83ca28963d29d6dc9fcdb2e9b093610c\n+b156d71ad75a1b73d0ed805a5370a297648d9270\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "dc6e379977099d1a564df6a1cbcb511c9ace2058", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-f5cf5673590a68c55b2330df9dfcdd6fac75b893\n+8707f31c0abc6b607014e843b7cc188b3019daa9\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7801290d26361daade80829768c1603566f1e4c0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 226, "deletions": 23, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -111,6 +111,7 @@ endif\n toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n+\tcontext.gox \\\n \tcrypto.gox \\\n \tencoding.gox \\\n \terrors.gox \\\n@@ -315,6 +316,7 @@ toolexeclibgonethttp_DATA = \\\n \tnet/http/cookiejar.gox \\\n \tnet/http/fcgi.gox \\\n \tnet/http/httptest.gox \\\n+\tnet/http/httptrace.gox \\\n \tnet/http/httputil.gox \\\n \tnet/http/pprof.gox\n \n@@ -593,6 +595,9 @@ go_bytes_files = \\\n go_bytes_c_files = \\\n \tgo/bytes/indexbyte.c\n \n+go_context_files = \\\n+\tgo/context/context.go\n+\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n@@ -776,15 +781,19 @@ if LIBGO_IS_LINUX\n go_net_interface_file = go/net/interface_linux.go\n else\n if LIBGO_IS_NETBSD\n-go_net_interface_file = go/net/interface_netbsd.go\n+go_net_interface_file = go/net/interface_bsdvar.go\n else\n if LIBGO_IS_DRAGONFLY\n-go_net_interface_file = go/net/interface_dragonfly.go\n+go_net_interface_file = go/net/interface_bsdvar.go\n+else\n+if LIBGO_IS_OPENBSD\n+go_net_interface_file = go/net/interface_bsdvar.go\n else\n go_net_interface_file = go/net/interface_stub.go\n endif\n endif\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_net_cloexec_file = go/net/sock_cloexec.go go/net/hook_cloexec.go\n@@ -845,6 +854,7 @@ go_net_common_files = \\\n \tgo/net/nss.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n+\tgo/net/port.go \\\n \tgo/net/fd_poll_runtime.go \\\n \tgo/net/port_unix.go \\\n \t$(go_net_sendfile_file) \\\n@@ -991,6 +1001,20 @@ endif\n endif\n endif\n \n+if LIBGO_IS_LINUX\n+go_os_wait_file = go/os/wait_waitid.go\n+else\n+if LIBGO_IS_DARWIN\n+go_os_wait_file = go/os/wait_waitid.go\n+else\n+if LIBGO_IS_FREEBSD\n+go_os_wait_file = go/os/wait_wait6.go\n+else\n+go_os_wait_file = go/os/wait_unimp.go\n+endif\n+endif\n+endif\n+\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -1016,7 +1040,8 @@ go_os_files = \\\n \t$(go_os_sys_file) \\\n \t$(go_os_cloexec_file) \\\n \tgo/os/types.go \\\n-\tgo/os/types_unix.go\n+\tgo/os/types_unix.go \\\n+\t$(go_os_wait_file)\n \n go_path_files = \\\n \tgo/path/match.go \\\n@@ -1048,6 +1073,7 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n+\tgo/runtime/symtab.go \\\n \tversion.go\n \n version.go: s-version; @true\n@@ -1134,6 +1160,7 @@ go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/cover.go \\\n \tgo/testing/example.go \\\n+\tgo/testing/match.go \\\n \tgo/testing/testing.go\n \n go_time_files = \\\n@@ -1174,6 +1201,7 @@ endif\n \n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n+\tgo/archive/tar/format.go \\\n \tgo/archive/tar/reader.go \\\n \tgo/archive/tar/stat_unix.go \\\n \tgo/archive/tar/writer.go \\\n@@ -1192,8 +1220,9 @@ go_compress_bzip2_files = \\\n \tgo/compress/bzip2/move_to_front.go\n \n go_compress_flate_files = \\\n-\tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n+\tgo/compress/flate/deflatefast.go \\\n+\tgo/compress/flate/dict_decoder.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n@@ -1225,7 +1254,8 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/cipher_generic.go \\\n-\tgo/crypto/aes/const.go\n+\tgo/crypto/aes/const.go \\\n+\tgo/crypto/aes/modes.go\n go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cbc.go \\\n \tgo/crypto/cipher/cfb.go \\\n@@ -1257,8 +1287,12 @@ go_crypto_md5_files = \\\n if LIBGO_IS_LINUX\n crypto_rand_file = go/crypto/rand/rand_linux.go\n else\n+if LIBGO_IS_OPENBSD\n+crypto_rand_file = go/crypto/rand/rand_openbsd.go\n+else\n crypto_rand_file =\n endif\n+endif\n \n go_crypto_rand_files = \\\n \tgo/crypto/rand/eagain.go \\\n@@ -1280,10 +1314,12 @@ go_crypto_sha1_files = \\\n \tgo/crypto/sha1/sha1block_generic.go\n go_crypto_sha256_files = \\\n \tgo/crypto/sha256/sha256.go \\\n-\tgo/crypto/sha256/sha256block.go\n+\tgo/crypto/sha256/sha256block.go \\\n+\tgo/crypto/sha256/sha256block_generic.go\n go_crypto_sha512_files = \\\n \tgo/crypto/sha512/sha512.go \\\n-\tgo/crypto/sha512/sha512block.go\n+\tgo/crypto/sha512/sha512block.go \\\n+\tgo/crypto/sha512/sha512block_generic.go\n go_crypto_subtle_files = \\\n \tgo/crypto/subtle/constant_time.go\n go_crypto_tls_files = \\\n@@ -1375,7 +1411,10 @@ go_debug_macho_files = \\\n \tgo/debug/macho/macho.go\n go_debug_pe_files = \\\n \tgo/debug/pe/file.go \\\n-\tgo/debug/pe/pe.go\n+\tgo/debug/pe/pe.go \\\n+\tgo/debug/pe/section.go \\\n+\tgo/debug/pe/string.go \\\n+\tgo/debug/pe/symbol.go\n go_debug_plan9obj_files = \\\n \tgo/debug/plan9obj/file.go \\\n \tgo/debug/plan9obj/plan9obj.go\n@@ -1517,6 +1556,87 @@ go_go_internal_gccgoimporter_files = \\\n \tgo/go/internal/gccgoimporter/importer.go \\\n \tgo/go/internal/gccgoimporter/parser.go\n \n+go_golang_org_x_net_http2_hpack_files = \\\n+\tgo/golang_org/x/net/http2/hpack/encode.go \\\n+\tgo/golang_org/x/net/http2/hpack/hpack.go \\\n+\tgo/golang_org/x/net/http2/hpack/huffman.go \\\n+\tgo/golang_org/x/net/http2/hpack/tables.go\n+\n+go_golang_org_x_net_lex_httplex_files = \\\n+\tgo/golang_org/x/net/lex/httplex/httplex.go\n+\n+if LIBGO_IS_BSD\n+\n+if LIBGO_IS_DARWIN\n+x_net_route_files =\n+\tgo/golang_org/x/net/route/interface_classic.go \\\n+\tgo/golang_org/x/net/route/interface_multicast.go \\\n+\tgo/golang_org/x/net/route/route_classic.go \\\n+\tgo/golang_org/x/net/route/sys_darwin.go \\\n+\tgo/golang_org/x/net/route/zsys_darwin.go\n+endif\n+if LIBGO_IS_DRAGONFLY\n+x_net_route_files =\n+\tgo/golang_org/x/net/route/interface_announce.go \\\n+\tgo/golang_org/x/net/route/interface_classic.go \\\n+\tgo/golang_org/x/net/route/interface_multicast.go \\\n+\tgo/golang_org/x/net/route/route_classic.go \\\n+\tgo/golang_org/x/net/route/sys_dragonfly.go \\\n+\tgo/golang_org/x/net/route/zsys_dragonfly.go\n+endif\n+if LIBGO_IS_FREEBSD\n+if LIBGO_IS_386\n+x_net_route_freebsd_file =\n+\tgo/golang_org/x/net/route/zsys_freebsd_386.go\n+endif\n+if LIBGO_IS_X86_64\n+x_net_route_freebsd_file =\n+\tgo/golang_org/x/net/route/zsys_freebsd_amd64.go\n+endif\n+if LIBGO_IS_ARM\n+x_net_route_freebsd_file =\n+\tgo/golang_org/x/net/route/zsys_freebsd_arm.go\n+endif\n+x_net_route_files =\n+\tgo/golang_org/x/net/route/interface_announce.go \\\n+\tgo/golang_org/x/net/route/interface_freebsd.go \\\n+\tgo/golang_org/x/net/route/interface_multicast.go \\\n+\tgo/golang_org/x/net/route/route_classic.go \\\n+\tgo/golang_org/x/net/route/sys_freebsd.go \\\n+\t$(x_net_route_freebsd_file)\n+endif\n+if LIBGO_IS_NETBSD\n+x_net_route_files =\n+\tgo/golang_org/x/net/route/interface_announce.go \\\n+\tgo/golang_org/x/net/route/interface_classic.go \\\n+\tgo/golang_org/x/net/route/route_classic.go \\\n+\tgo/golang_org/x/net/route/sys_netbsd.go \\\n+\tgo/golang_org/x/net/route/zsys_netbsd.go\n+endif\n+if LIBGO_IS_OPENBSD\n+x_net_route_files =\n+\tgo/golang_org/x/net/route/route_openbsd.go \\\n+\tgo/golang_org/x/net/route/sys_openbsd.go \\\n+\tgo/golang_org/x/net/route/zsys_openbsd.go\n+endif\n+\n+go_golang_org_x_net_route_files = \\\n+\tgo/golang_org/x/net/route/address.go \\\n+\tgo/golang_org/x/net/route/binary.go \\\n+\tgo/golang_org/x/net/route/interface.go \\\n+\tgo/golang_org/x/net/route/message.go \\\n+\tgo/golang_org/x/net/route/route.go \\\n+\tgo/golang_org/x/net/route/syscall.go \\\n+\tgo/golang_org/x/net/route/sys.go \\\n+\t$(x_net_route_files)\n+\n+golang_org_x_net_route_lo = \\\n+\tgolang_org/x/net/route/route.lo\n+golang_org_x_net_route_check = \\\n+\tgolang_org/x/net/route/check\n+\n+endif\n+\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n go_hash_crc32_files = \\\n@@ -1576,11 +1696,8 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n-go_internal_golang_org_x_net_http2_hpack_files = \\\n-\tgo/internal/golang.org/x/net/http2/hpack/encode.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/hpack.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/huffman.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/tables.go\n+go_internal_nettrace_files = \\\n+\tgo/internal/nettrace/nettrace.go\n go_internal_race_files = \\\n \tgo/internal/race/doc.go \\\n \tgo/internal/race/norace.go\n@@ -1603,15 +1720,23 @@ else\n if LIBGO_IS_MIPS64\n internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_mips64x.go\n else\n+if LIBGO_IS_S390X\n+internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_s390x.go\n+else\n internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_generic.go\n endif\n endif\n endif\n endif\n endif\n+endif\n+else\n+if LIBGO_IS_OPENBSD\n+internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getentropy_openbsd.go\n else\n internal_syscall_unix_getrandom_files =\n endif\n+endif\n \n go_internal_syscall_unix_files = \\\n \tgo/internal/syscall/unix/dummy.go \\\n@@ -1621,6 +1746,7 @@ go_internal_testenv_files = \\\n \tgo/internal/testenv/testenv.go\n go_internal_trace_files = \\\n \tgo/internal/trace/goroutines.go \\\n+\tgo/internal/trace/order.go \\\n \tgo/internal/trace/parser.go\n \n go_io_ioutil_files = \\\n@@ -1684,8 +1810,8 @@ go_net_http_files = \\\n \tgo/net/http/fs.go \\\n \tgo/net/http/h2_bundle.go \\\n \tgo/net/http/header.go \\\n+\tgo/net/http/http.go \\\n \tgo/net/http/jar.go \\\n-\tgo/net/http/lex.go \\\n \tgo/net/http/method.go \\\n \tgo/net/http/request.go \\\n \tgo/net/http/response.go \\\n@@ -1718,10 +1844,13 @@ go_net_http_fcgi_files = \\\n \tgo/net/http/fcgi/child.go \\\n \tgo/net/http/fcgi/fcgi.go\n go_net_http_httptest_files = \\\n+\tgo/net/http/httptest/httptest.go \\\n \tgo/net/http/httptest/recorder.go \\\n \tgo/net/http/httptest/server.go\n go_net_http_pprof_files = \\\n \tgo/net/http/pprof/pprof.go\n+go_net_http_httptrace_files = \\\n+\tgo/net/http/httptrace/trace.go\n go_net_http_httputil_files = \\\n \tgo/net/http/httputil/dump.go \\\n \tgo/net/http/httputil/httputil.go \\\n@@ -1768,15 +1897,18 @@ go_os_signal_files = \\\n \n if LIBGO_IS_SOLARIS\n os_user_decls_file = go/os/user/decls_solaris.go\n+os_user_listgroups_file = go/os/user/listgroups_solaris.go\n else\n os_user_decls_file = go/os/user/decls_unix.go\n+os_user_listgroups_file = go/os/user/listgroups_unix.go\n endif\n \n go_os_user_files = \\\n \tgo/os/user/lookup.go \\\n \tgo/os/user/lookup_unix.go \\\n \tgo/os/user/user.go \\\n-\t$(os_user_decls_file)\n+\t$(os_user_decls_file) \\\n+\t$(os_user_listgroups_file)\n \n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n@@ -2147,6 +2279,7 @@ libgo_go_objs = \\\n \tbufio.lo \\\n \tbytes.lo \\\n \tbytes/index.lo \\\n+\tcontext.lo \\\n \tcrypto.lo \\\n \tencoding.lo \\\n \terrors.lo \\\n@@ -2242,6 +2375,9 @@ libgo_go_objs = \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n \tgo/types.lo \\\n+\tgolang_org/x/net/http2/hpack.lo \\\n+\tgolang_org/x/net/lex/httplex.lo \\\n+\t$(golang_org_x_net_route_lo) \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -2250,6 +2386,7 @@ libgo_go_objs = \\\n \tnet/http/cookiejar.lo \\\n \tnet/http/fcgi.lo \\\n \tnet/http/httptest.lo \\\n+\tnet/http/httptrace.lo \\\n \tnet/http/httputil.lo \\\n \tnet/http/internal.lo \\\n \tnet/http/pprof.lo \\\n@@ -2261,7 +2398,7 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n-\tinternal/golang.org/x/net/http2/hpack.lo \\\n+\tinternal/nettrace.lo \\\n \tinternal/race.lo \\\n \tinternal/singleflight.lo \\\n \tinternal/syscall/unix.lo \\\n@@ -2460,6 +2597,15 @@ bytes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: bytes/check\n \n+@go_include@ context.lo.dep\n+context.lo.dep: $(go_context_files)\n+\t$(BUILDDEPS)\n+context.lo: $(go_context_files)\n+\t$(BUILDPACKAGE)\n+context/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: context/check\n+\n @go_include@ crypto.lo.dep\n crypto.lo.dep: $(go_crypto_files)\n \t$(BUILDDEPS)\n@@ -3275,6 +3421,35 @@ go/internal/gccgoimporter/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/internal/gccgoimporter/check\n \n+@go_include@ golang_org/x/net/http2/hpack.lo.dep\n+golang_org/x/net/http2/hpack.lo.dep: $(go_golang_org_x_net_http2_hpack_files)\n+\t$(BUILDDEPS)\n+golang_org/x/net/http2/hpack.lo: $(go_golang_org_x_net_http2_hpack_files)\n+\t$(BUILDPACKAGE)\n+golang_org/x/net/http2/hpack/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: golang_org/x/net/http2/hpack/check\n+\n+@go_include@ golang_org/x/net/lex/httplex.lo.dep\n+golang_org/x/net/lex/httplex.lo.dep: $(go_golang_org_x_net_lex_httplex_files)\n+\t$(BUILDDEPS)\n+golang_org/x/net/lex/httplex.lo: $(go_golang_org_x_net_lex_httplex_files)\n+\t$(BUILDPACKAGE)\n+golang_org/x/net/lex/httplex/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: golang_org/x/net/lex/httplex/check\n+\n+if LIBGO_IS_BSD\n+@go_include@ golang_org/x/net/route.lo.dep\n+golang_org/x/net/route.lo.dep: $(go_golang_org_x_net_route_files)\n+\t$(BUILDDEPS)\n+golang_org/x/net/route.lo: $(go_golang_org_x_net_route_files)\n+\t$(BUILDPACKAGE)\n+golang_org/x/net/route/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+endif\n+.PHONY: golang_org/x/net/route/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -3383,14 +3558,14 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: index/suffixarray/check\n \n-@go_include@ internal/golang.org/x/net/http2/hpack.lo.dep\n-internal/golang.org/x/net/http2/hpack.lo.dep: $(go_internal_golang_org_x_net_http2_hpack_files)\n+@go_include@ internal/nettrace.lo.dep\n+internal/nettrace.lo.dep: $(go_internal_nettrace_files)\n \t$(BUILDDEPS)\n-internal/golang.org/x/net/http2/hpack.lo: $(go_internal_golang_org_x_net_http2_hpack_files)\n+internal/nettrace.lo: $(go_internal_nettrace_files)\n \t$(BUILDPACKAGE)\n-internal/golang.org/x/net/http2/hpack/check: $(CHECK_DEPS)\n+internal/nettrace/check: $(CHECK_DEPS)\n \t@$(CHECK)\n-.PHONY: internal/golang.org/x/net/http2/hpack/check\n+.PHONY: internal/nettrace/check\n \n @go_include@ internal/race.lo.dep\n internal/race.lo.dep: $(go_internal_race_files)\n@@ -3593,6 +3768,15 @@ net/http/httptest/check: $(check_deps)\n \t@$(CHECK)\n .PHONY: net/http/httptest/check\n \n+@go_include@ net/http/httptrace.lo.dep\n+net/http/httptrace.lo.dep: $(go_net_http_httptrace_files)\n+\t$(BUILDDEPS)\n+net/http/httptrace.lo: $(go_net_http_httptrace_files)\n+\t$(BUILDPACKAGE)\n+net/http/httptrace/check: $(check_deps)\n+\t@$(CHECK)\n+.PHONY: net/http/httptrace/check\n+\n @go_include@ net/http/httputil.lo.dep\n net/http/httputil.lo.dep: $(go_net_http_httputil_files)\n \t$(BUILDDEPS)\n@@ -3833,6 +4017,8 @@ bufio.gox: bufio.lo\n \t$(BUILDGOX)\n bytes.gox: bytes.lo\n \t$(BUILDGOX)\n+context.gox: context.lo\n+\t$(BUILDGOX)\n crypto.gox: crypto.lo\n \t$(BUILDGOX)\n encoding.gox: encoding.lo\n@@ -4027,6 +4213,17 @@ go/internal/gcimporter.gox: go/internal/gcimporter.lo\n go/internal/gccgoimporter.gox: go/internal/gccgoimporter.lo\n \t$(BUILDGOX)\n \n+golang_org/x/net/http2/hpack.gox: golang_org/x/net/http2/hpack.lo\n+\t$(BUILDGOX)\n+\n+golang_org/x/net/lex/httplex.gox: golang_org/x/net/lex/httplex.lo\n+\t$(BUILDGOX)\n+\n+if LIBGO_IS_BSD\n+golang_org/x/net/route.gox: golang_org/x/net/route.lo\n+\t$(BUILDGOX)\n+endif\n+\n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n hash/crc32.gox: hash/crc32.lo\n@@ -4055,7 +4252,7 @@ image/color/palette.gox: image/color/palette.lo\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n \n-internal/golang.org/x/net/http2/hpack.gox: internal/golang.org/x/net/http2/hpack.lo\n+internal/nettrace.gox: internal/nettrace.lo\n \t$(BUILDGOX)\n internal/race.gox: internal/race.lo\n \t$(BUILDGOX)\n@@ -4107,6 +4304,8 @@ net/http/fcgi.gox: net/http/fcgi.lo\n \t$(BUILDGOX)\n net/http/httptest.gox: net/http/httptest.lo\n \t$(BUILDGOX)\n+net/http/httptrace.gox: net/http/httptrace.lo\n+\t$(BUILDGOX)\n net/http/httputil.gox: net/http/httputil.lo\n \t$(BUILDGOX)\n net/http/pprof.gox: net/http/pprof.lo\n@@ -4169,6 +4368,7 @@ unicode/utf8.gox: unicode/utf8.lo\n TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n+\tcontext/check \\\n \terrors/check \\\n \texpvar/check \\\n \tflag/check \\\n@@ -4252,6 +4452,9 @@ TEST_PACKAGES = \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/types/check \\\n+\tgolang_org/x/net/http2/hpack/check \\\n+\tgolang_org/x/net/lex/httplex/check \\\n+\t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n@@ -4261,7 +4464,6 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n-\tinternal/golang.org/x/net/http2/hpack/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n@@ -4276,6 +4478,7 @@ TEST_PACKAGES = \\\n \tnet/http/cookiejar/check \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n+\tnet/http/httptrace/check \\\n \tnet/http/httputil/check \\\n \tnet/http/internal/check \\\n \tnet/internal/socktest/check \\"}, {"sha": "740885ef372854286e5a57e2591fa0cd6709e667", "filename": "libgo/Makefile.in", "status": "modified", "additions": 208, "deletions": 48, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -174,14 +174,14 @@ am_libnetgo_a_OBJECTS = $(am__objects_3)\n libnetgo_a_OBJECTS = $(am_libnetgo_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n-\tencoding.lo errors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo \\\n-\timage.lo io.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n-\treflect-go.lo reflect/makefunc_ffi_c.lo regexp.lo \\\n-\truntime-go.lo sort.lo strconv.lo strings.lo strings/index.lo \\\n-\tsync.lo syscall.lo syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo testing.lo time-go.lo unicode.lo \\\n-\tarchive/tar.lo archive/zip.lo compress/bzip2.lo \\\n+am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo context.lo \\\n+\tcrypto.lo encoding.lo errors.lo expvar.lo flag.lo fmt.lo \\\n+\thash.lo html.lo image.lo io.lo log.lo math.lo mime.lo net.lo \\\n+\tos.lo path.lo reflect-go.lo reflect/makefunc_ffi_c.lo \\\n+\tregexp.lo runtime-go.lo sort.lo strconv.lo strings.lo \\\n+\tstrings/index.lo sync.lo syscall.lo syscall/errno.lo \\\n+\tsyscall/signame.lo syscall/wait.lo testing.lo time-go.lo \\\n+\tunicode.lo archive/tar.lo archive/zip.lo compress/bzip2.lo \\\n \tcompress/flate.lo compress/gzip.lo compress/lzw.lo \\\n \tcompress/zlib.lo container/heap.lo container/list.lo \\\n \tcontainer/ring.lo crypto/aes.lo crypto/cipher.lo crypto/des.lo \\\n@@ -199,22 +199,24 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tgo/ast.lo go/build.lo go/constant.lo go/doc.lo go/format.lo \\\n \tgo/importer.lo go/internal/gcimporter.lo \\\n \tgo/internal/gccgoimporter.lo go/parser.lo go/printer.lo \\\n-\tgo/scanner.lo go/token.lo go/types.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n-\tnet/http/cookiejar.lo net/http/fcgi.lo net/http/httptest.lo \\\n+\tgo/scanner.lo go/token.lo go/types.lo \\\n+\tgolang_org/x/net/http2/hpack.lo \\\n+\tgolang_org/x/net/lex/httplex.lo $(golang_org_x_net_route_lo) \\\n+\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n+\tnet/http/cgi.lo net/http/cookiejar.lo net/http/fcgi.lo \\\n+\tnet/http/httptest.lo net/http/httptrace.lo \\\n \tnet/http/httputil.lo net/http/internal.lo net/http/pprof.lo \\\n \timage/color.lo image/color/palette.lo image/draw.lo \\\n \timage/gif.lo image/internal/imageutil.lo image/jpeg.lo \\\n-\timage/png.lo index/suffixarray.lo \\\n-\tinternal/golang.org/x/net/http2/hpack.lo internal/race.lo \\\n-\tinternal/singleflight.lo internal/syscall/unix.lo \\\n-\tinternal/testenv.lo internal/trace.lo io/ioutil.lo \\\n-\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n-\tmath/rand.lo mime/multipart.lo mime/quotedprintable.lo \\\n-\tnet/http.lo net/internal/socktest.lo net/mail.lo net/rpc.lo \\\n-\tnet/smtp.lo net/textproto.lo net/url.lo old/regexp.lo \\\n-\told/template.lo os/exec.lo $(am__DEPENDENCIES_1) os/signal.lo \\\n-\tos/user.lo path/filepath.lo regexp/syntax.lo \\\n+\timage/png.lo index/suffixarray.lo internal/nettrace.lo \\\n+\tinternal/race.lo internal/singleflight.lo \\\n+\tinternal/syscall/unix.lo internal/testenv.lo internal/trace.lo \\\n+\tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n+\tmath/cmplx.lo math/rand.lo mime/multipart.lo \\\n+\tmime/quotedprintable.lo net/http.lo net/internal/socktest.lo \\\n+\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\told/regexp.lo old/template.lo os/exec.lo $(am__DEPENDENCIES_1) \\\n+\tos/signal.lo os/user.lo path/filepath.lo regexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n \tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n \ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n@@ -576,6 +578,7 @@ FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n+\tcontext.gox \\\n \tcrypto.gox \\\n \tencoding.gox \\\n \terrors.gox \\\n@@ -758,6 +761,7 @@ toolexeclibgonethttp_DATA = \\\n \tnet/http/cookiejar.gox \\\n \tnet/http/fcgi.gox \\\n \tnet/http/httptest.gox \\\n+\tnet/http/httptrace.gox \\\n \tnet/http/httputil.gox \\\n \tnet/http/pprof.gox\n \n@@ -946,6 +950,9 @@ go_bytes_files = \\\n go_bytes_c_files = \\\n \tgo/bytes/indexbyte.c\n \n+go_context_files = \\\n+\tgo/context/context.go\n+\n go_crypto_files = \\\n \tgo/crypto/crypto.go\n \n@@ -1086,9 +1093,10 @@ go_mime_files = \\\n @LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_dragonfly.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_freebsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n-@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n-@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_dragonfly.go\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_netbsd.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_TRUE@go_net_interface_file = go/net/interface_bsdvar.go\n+@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_bsdvar.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@go_net_interface_file = go/net/interface_bsdvar.go\n @LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_cloexec_file = go/net/sys_cloexec.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cloexec_file = go/net/sock_cloexec.go go/net/hook_cloexec.go\n@@ -1129,6 +1137,7 @@ go_net_common_files = \\\n \tgo/net/nss.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n+\tgo/net/port.go \\\n \tgo/net/fd_poll_runtime.go \\\n \tgo/net/port_unix.go \\\n \t$(go_net_sendfile_file) \\\n@@ -1190,6 +1199,10 @@ go_netgo_files = \\\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n @LIBGO_IS_DARWIN_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_os_wait_file = go/os/wait_unimp.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_os_wait_file = go/os/wait_wait6.go\n+@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@go_os_wait_file = go/os/wait_waitid.go\n+@LIBGO_IS_LINUX_TRUE@go_os_wait_file = go/os/wait_waitid.go\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -1215,7 +1228,8 @@ go_os_files = \\\n \t$(go_os_sys_file) \\\n \t$(go_os_cloexec_file) \\\n \tgo/os/types.go \\\n-\tgo/os/types_unix.go\n+\tgo/os/types_unix.go \\\n+\t$(go_os_wait_file)\n \n go_path_files = \\\n \tgo/path/match.go \\\n@@ -1248,6 +1262,7 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n+\tgo/runtime/symtab.go \\\n \tversion.go\n \n noinst_DATA = zstdpkglist.go\n@@ -1304,6 +1319,7 @@ go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/cover.go \\\n \tgo/testing/example.go \\\n+\tgo/testing/match.go \\\n \tgo/testing/testing.go\n \n go_time_files = \\\n@@ -1331,6 +1347,7 @@ go_unicode_files = \\\n @LIBGO_IS_SOLARIS_TRUE@archive_tar_atim_file = go/archive/tar/stat_atim.go\n go_archive_tar_files = \\\n \tgo/archive/tar/common.go \\\n+\tgo/archive/tar/format.go \\\n \tgo/archive/tar/reader.go \\\n \tgo/archive/tar/stat_unix.go \\\n \tgo/archive/tar/writer.go \\\n@@ -1349,8 +1366,9 @@ go_compress_bzip2_files = \\\n \tgo/compress/bzip2/move_to_front.go\n \n go_compress_flate_files = \\\n-\tgo/compress/flate/copy.go \\\n \tgo/compress/flate/deflate.go \\\n+\tgo/compress/flate/deflatefast.go \\\n+\tgo/compress/flate/dict_decoder.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n \tgo/compress/flate/huffman_code.go \\\n \tgo/compress/flate/inflate.go \\\n@@ -1382,7 +1400,8 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/cipher_generic.go \\\n-\tgo/crypto/aes/const.go\n+\tgo/crypto/aes/const.go \\\n+\tgo/crypto/aes/modes.go\n \n go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cbc.go \\\n@@ -1418,7 +1437,8 @@ go_crypto_md5_files = \\\n \tgo/crypto/md5/md5block.go \\\n \tgo/crypto/md5/md5block_generic.go\n \n-@LIBGO_IS_LINUX_FALSE@crypto_rand_file = \n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_FALSE@crypto_rand_file = \n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_TRUE@crypto_rand_file = go/crypto/rand/rand_openbsd.go\n @LIBGO_IS_LINUX_TRUE@crypto_rand_file = go/crypto/rand/rand_linux.go\n go_crypto_rand_files = \\\n \tgo/crypto/rand/eagain.go \\\n@@ -1443,11 +1463,13 @@ go_crypto_sha1_files = \\\n \n go_crypto_sha256_files = \\\n \tgo/crypto/sha256/sha256.go \\\n-\tgo/crypto/sha256/sha256block.go\n+\tgo/crypto/sha256/sha256block.go \\\n+\tgo/crypto/sha256/sha256block_generic.go\n \n go_crypto_sha512_files = \\\n \tgo/crypto/sha512/sha512.go \\\n-\tgo/crypto/sha512/sha512block.go\n+\tgo/crypto/sha512/sha512block.go \\\n+\tgo/crypto/sha512/sha512block_generic.go\n \n go_crypto_subtle_files = \\\n \tgo/crypto/subtle/constant_time.go\n@@ -1523,7 +1545,10 @@ go_debug_macho_files = \\\n \n go_debug_pe_files = \\\n \tgo/debug/pe/file.go \\\n-\tgo/debug/pe/pe.go\n+\tgo/debug/pe/pe.go \\\n+\tgo/debug/pe/section.go \\\n+\tgo/debug/pe/string.go \\\n+\tgo/debug/pe/symbol.go\n \n go_debug_plan9obj_files = \\\n \tgo/debug/plan9obj/file.go \\\n@@ -1688,6 +1713,39 @@ go_go_internal_gccgoimporter_files = \\\n \tgo/go/internal/gccgoimporter/importer.go \\\n \tgo/go/internal/gccgoimporter/parser.go\n \n+go_golang_org_x_net_http2_hpack_files = \\\n+\tgo/golang_org/x/net/http2/hpack/encode.go \\\n+\tgo/golang_org/x/net/http2/hpack/hpack.go \\\n+\tgo/golang_org/x/net/http2/hpack/huffman.go \\\n+\tgo/golang_org/x/net/http2/hpack/tables.go\n+\n+go_golang_org_x_net_lex_httplex_files = \\\n+\tgo/golang_org/x/net/lex/httplex/httplex.go\n+\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@x_net_route_files = \n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@x_net_route_files = \n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@x_net_route_files = \n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@x_net_route_files = \n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_OPENBSD_TRUE@x_net_route_files = \n+@LIBGO_IS_386_TRUE@@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@x_net_route_freebsd_file = \n+@LIBGO_IS_ARM_TRUE@@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@x_net_route_freebsd_file = \n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_X86_64_TRUE@x_net_route_freebsd_file = \n+@LIBGO_IS_BSD_TRUE@go_golang_org_x_net_route_files = \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/address.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/binary.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/interface.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/message.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/route.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/syscall.go \\\n+@LIBGO_IS_BSD_TRUE@\tgo/golang_org/x/net/route/sys.go \\\n+@LIBGO_IS_BSD_TRUE@\t$(x_net_route_files)\n+\n+@LIBGO_IS_BSD_TRUE@golang_org_x_net_route_lo = \\\n+@LIBGO_IS_BSD_TRUE@\tgolang_org/x/net/route/route.lo\n+\n+@LIBGO_IS_BSD_TRUE@golang_org_x_net_route_check = \\\n+@LIBGO_IS_BSD_TRUE@\tgolang_org/x/net/route/check\n+\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n@@ -1750,11 +1808,8 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n-go_internal_golang_org_x_net_http2_hpack_files = \\\n-\tgo/internal/golang.org/x/net/http2/hpack/encode.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/hpack.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/huffman.go \\\n-\tgo/internal/golang.org/x/net/http2/hpack/tables.go\n+go_internal_nettrace_files = \\\n+\tgo/internal/nettrace/nettrace.go\n \n go_internal_race_files = \\\n \tgo/internal/race/doc.go \\\n@@ -1763,13 +1818,15 @@ go_internal_race_files = \\\n go_internal_singleflight_files = \\\n \tgo/internal/singleflight/singleflight.go\n \n-@LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_MIPS64_FALSE@@LIBGO_IS_PPC64_FALSE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_generic.go\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_MIPS64_FALSE@@LIBGO_IS_PPC64_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_generic.go\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_MIPS64_FALSE@@LIBGO_IS_PPC64_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_s390x.go\n @LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_MIPS64_TRUE@@LIBGO_IS_PPC64_FALSE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_mips64x.go\n @LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_PPC64_TRUE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_ppc64x.go\n @LIBGO_IS_386_FALSE@@LIBGO_IS_ARM_TRUE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_X86_64_FALSE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_arm.go\n @LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_X86_64_TRUE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_amd64.go\n @LIBGO_IS_386_TRUE@@LIBGO_IS_LINUX_TRUE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getrandom_linux.go go/internal/syscall/unix/getrandom_linux_386.go\n-@LIBGO_IS_LINUX_FALSE@internal_syscall_unix_getrandom_files = \n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_FALSE@internal_syscall_unix_getrandom_files = \n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_TRUE@internal_syscall_unix_getrandom_files = go/internal/syscall/unix/getentropy_openbsd.go\n go_internal_syscall_unix_files = \\\n \tgo/internal/syscall/unix/dummy.go \\\n \t$(internal_syscall_unix_getrandom_files)\n@@ -1779,6 +1836,7 @@ go_internal_testenv_files = \\\n \n go_internal_trace_files = \\\n \tgo/internal/trace/goroutines.go \\\n+\tgo/internal/trace/order.go \\\n \tgo/internal/trace/parser.go\n \n go_io_ioutil_files = \\\n@@ -1844,8 +1902,8 @@ go_net_http_files = \\\n \tgo/net/http/fs.go \\\n \tgo/net/http/h2_bundle.go \\\n \tgo/net/http/header.go \\\n+\tgo/net/http/http.go \\\n \tgo/net/http/jar.go \\\n-\tgo/net/http/lex.go \\\n \tgo/net/http/method.go \\\n \tgo/net/http/request.go \\\n \tgo/net/http/response.go \\\n@@ -1885,12 +1943,16 @@ go_net_http_fcgi_files = \\\n \tgo/net/http/fcgi/fcgi.go\n \n go_net_http_httptest_files = \\\n+\tgo/net/http/httptest/httptest.go \\\n \tgo/net/http/httptest/recorder.go \\\n \tgo/net/http/httptest/server.go\n \n go_net_http_pprof_files = \\\n \tgo/net/http/pprof/pprof.go\n \n+go_net_http_httptrace_files = \\\n+\tgo/net/http/httptrace/trace.go\n+\n go_net_http_httputil_files = \\\n \tgo/net/http/httputil/dump.go \\\n \tgo/net/http/httputil/httputil.go \\\n@@ -1932,11 +1994,14 @@ go_os_signal_files = \\\n \n @LIBGO_IS_SOLARIS_FALSE@os_user_decls_file = go/os/user/decls_unix.go\n @LIBGO_IS_SOLARIS_TRUE@os_user_decls_file = go/os/user/decls_solaris.go\n+@LIBGO_IS_SOLARIS_FALSE@os_user_listgroups_file = go/os/user/listgroups_unix.go\n+@LIBGO_IS_SOLARIS_TRUE@os_user_listgroups_file = go/os/user/listgroups_solaris.go\n go_os_user_files = \\\n \tgo/os/user/lookup.go \\\n \tgo/os/user/lookup_unix.go \\\n \tgo/os/user/user.go \\\n-\t$(os_user_decls_file)\n+\t$(os_user_decls_file) \\\n+\t$(os_user_listgroups_file)\n \n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n@@ -2158,6 +2223,7 @@ libgo_go_objs = \\\n \tbufio.lo \\\n \tbytes.lo \\\n \tbytes/index.lo \\\n+\tcontext.lo \\\n \tcrypto.lo \\\n \tencoding.lo \\\n \terrors.lo \\\n@@ -2253,6 +2319,9 @@ libgo_go_objs = \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n \tgo/types.lo \\\n+\tgolang_org/x/net/http2/hpack.lo \\\n+\tgolang_org/x/net/lex/httplex.lo \\\n+\t$(golang_org_x_net_route_lo) \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -2261,6 +2330,7 @@ libgo_go_objs = \\\n \tnet/http/cookiejar.lo \\\n \tnet/http/fcgi.lo \\\n \tnet/http/httptest.lo \\\n+\tnet/http/httptrace.lo \\\n \tnet/http/httputil.lo \\\n \tnet/http/internal.lo \\\n \tnet/http/pprof.lo \\\n@@ -2272,7 +2342,7 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n-\tinternal/golang.org/x/net/http2/hpack.lo \\\n+\tinternal/nettrace.lo \\\n \tinternal/race.lo \\\n \tinternal/singleflight.lo \\\n \tinternal/syscall/unix.lo \\\n@@ -2439,6 +2509,7 @@ BUILDGOX = \\\n TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n+\tcontext/check \\\n \terrors/check \\\n \texpvar/check \\\n \tflag/check \\\n@@ -2522,6 +2593,9 @@ TEST_PACKAGES = \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/types/check \\\n+\tgolang_org/x/net/http2/hpack/check \\\n+\tgolang_org/x/net/lex/httplex/check \\\n+\t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n@@ -2531,7 +2605,6 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n-\tinternal/golang.org/x/net/http2/hpack/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n@@ -2546,6 +2619,7 @@ TEST_PACKAGES = \\\n \tnet/http/cookiejar/check \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n+\tnet/http/httptrace/check \\\n \tnet/http/httputil/check \\\n \tnet/http/internal/check \\\n \tnet/internal/socktest/check \\\n@@ -4761,6 +4835,34 @@ s-zstdpkglist: Makefile\n \techo '}' >> zstdpkglist.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh zstdpkglist.go.tmp zstdpkglist.go\n \t$(STAMP) $@\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@\tgo/golang_org/x/net/route/interface_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@\tgo/golang_org/x/net/route/interface_multicast.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@\tgo/golang_org/x/net/route/route_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@\tgo/golang_org/x/net/route/sys_darwin.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DARWIN_TRUE@\tgo/golang_org/x/net/route/zsys_darwin.go\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/interface_announce.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/interface_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/interface_multicast.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/route_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/sys_dragonfly.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_DRAGONFLY_TRUE@\tgo/golang_org/x/net/route/zsys_dragonfly.go\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/zsys_freebsd_386.go\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_X86_64_TRUE@\tgo/golang_org/x/net/route/zsys_freebsd_amd64.go\n+@LIBGO_IS_ARM_TRUE@@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/zsys_freebsd_arm.go\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/interface_announce.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/interface_freebsd.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/interface_multicast.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/route_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\tgo/golang_org/x/net/route/sys_freebsd.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_FREEBSD_TRUE@\t$(x_net_route_freebsd_file)\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@\tgo/golang_org/x/net/route/interface_announce.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@\tgo/golang_org/x/net/route/interface_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@\tgo/golang_org/x/net/route/route_classic.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@\tgo/golang_org/x/net/route/sys_netbsd.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_NETBSD_TRUE@\tgo/golang_org/x/net/route/zsys_netbsd.go\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_OPENBSD_TRUE@\tgo/golang_org/x/net/route/route_openbsd.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_OPENBSD_TRUE@\tgo/golang_org/x/net/route/sys_openbsd.go \\\n+@LIBGO_IS_BSD_TRUE@@LIBGO_IS_OPENBSD_TRUE@\tgo/golang_org/x/net/route/zsys_openbsd.go\n \n libcalls.go: s-libcalls; @true\n s-libcalls: libcalls-list go/syscall/mksyscall.awk $(go_base_syscall_files)\n@@ -4841,6 +4943,15 @@ bytes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: bytes/check\n \n+@go_include@ context.lo.dep\n+context.lo.dep: $(go_context_files)\n+\t$(BUILDDEPS)\n+context.lo: $(go_context_files)\n+\t$(BUILDPACKAGE)\n+context/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: context/check\n+\n @go_include@ crypto.lo.dep\n crypto.lo.dep: $(go_crypto_files)\n \t$(BUILDDEPS)\n@@ -5656,6 +5767,33 @@ go/internal/gccgoimporter/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/internal/gccgoimporter/check\n \n+@go_include@ golang_org/x/net/http2/hpack.lo.dep\n+golang_org/x/net/http2/hpack.lo.dep: $(go_golang_org_x_net_http2_hpack_files)\n+\t$(BUILDDEPS)\n+golang_org/x/net/http2/hpack.lo: $(go_golang_org_x_net_http2_hpack_files)\n+\t$(BUILDPACKAGE)\n+golang_org/x/net/http2/hpack/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: golang_org/x/net/http2/hpack/check\n+\n+@go_include@ golang_org/x/net/lex/httplex.lo.dep\n+golang_org/x/net/lex/httplex.lo.dep: $(go_golang_org_x_net_lex_httplex_files)\n+\t$(BUILDDEPS)\n+golang_org/x/net/lex/httplex.lo: $(go_golang_org_x_net_lex_httplex_files)\n+\t$(BUILDPACKAGE)\n+golang_org/x/net/lex/httplex/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: golang_org/x/net/lex/httplex/check\n+\n+@LIBGO_IS_BSD_TRUE@@go_include@ golang_org/x/net/route.lo.dep\n+@LIBGO_IS_BSD_TRUE@golang_org/x/net/route.lo.dep: $(go_golang_org_x_net_route_files)\n+@LIBGO_IS_BSD_TRUE@\t$(BUILDDEPS)\n+@LIBGO_IS_BSD_TRUE@golang_org/x/net/route.lo: $(go_golang_org_x_net_route_files)\n+@LIBGO_IS_BSD_TRUE@\t$(BUILDPACKAGE)\n+@LIBGO_IS_BSD_TRUE@golang_org/x/net/route/check: $(CHECK_DEPS)\n+@LIBGO_IS_BSD_TRUE@\t@$(CHECK)\n+.PHONY: golang_org/x/net/route/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -5764,14 +5902,14 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: index/suffixarray/check\n \n-@go_include@ internal/golang.org/x/net/http2/hpack.lo.dep\n-internal/golang.org/x/net/http2/hpack.lo.dep: $(go_internal_golang_org_x_net_http2_hpack_files)\n+@go_include@ internal/nettrace.lo.dep\n+internal/nettrace.lo.dep: $(go_internal_nettrace_files)\n \t$(BUILDDEPS)\n-internal/golang.org/x/net/http2/hpack.lo: $(go_internal_golang_org_x_net_http2_hpack_files)\n+internal/nettrace.lo: $(go_internal_nettrace_files)\n \t$(BUILDPACKAGE)\n-internal/golang.org/x/net/http2/hpack/check: $(CHECK_DEPS)\n+internal/nettrace/check: $(CHECK_DEPS)\n \t@$(CHECK)\n-.PHONY: internal/golang.org/x/net/http2/hpack/check\n+.PHONY: internal/nettrace/check\n \n @go_include@ internal/race.lo.dep\n internal/race.lo.dep: $(go_internal_race_files)\n@@ -5974,6 +6112,15 @@ net/http/httptest/check: $(check_deps)\n \t@$(CHECK)\n .PHONY: net/http/httptest/check\n \n+@go_include@ net/http/httptrace.lo.dep\n+net/http/httptrace.lo.dep: $(go_net_http_httptrace_files)\n+\t$(BUILDDEPS)\n+net/http/httptrace.lo: $(go_net_http_httptrace_files)\n+\t$(BUILDPACKAGE)\n+net/http/httptrace/check: $(check_deps)\n+\t@$(CHECK)\n+.PHONY: net/http/httptrace/check\n+\n @go_include@ net/http/httputil.lo.dep\n net/http/httputil.lo.dep: $(go_net_http_httputil_files)\n \t$(BUILDDEPS)\n@@ -6205,6 +6352,8 @@ bufio.gox: bufio.lo\n \t$(BUILDGOX)\n bytes.gox: bytes.lo\n \t$(BUILDGOX)\n+context.gox: context.lo\n+\t$(BUILDGOX)\n crypto.gox: crypto.lo\n \t$(BUILDGOX)\n encoding.gox: encoding.lo\n@@ -6399,6 +6548,15 @@ go/internal/gcimporter.gox: go/internal/gcimporter.lo\n go/internal/gccgoimporter.gox: go/internal/gccgoimporter.lo\n \t$(BUILDGOX)\n \n+golang_org/x/net/http2/hpack.gox: golang_org/x/net/http2/hpack.lo\n+\t$(BUILDGOX)\n+\n+golang_org/x/net/lex/httplex.gox: golang_org/x/net/lex/httplex.lo\n+\t$(BUILDGOX)\n+\n+@LIBGO_IS_BSD_TRUE@golang_org/x/net/route.gox: golang_org/x/net/route.lo\n+@LIBGO_IS_BSD_TRUE@\t$(BUILDGOX)\n+\n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n hash/crc32.gox: hash/crc32.lo\n@@ -6427,7 +6585,7 @@ image/color/palette.gox: image/color/palette.lo\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n \n-internal/golang.org/x/net/http2/hpack.gox: internal/golang.org/x/net/http2/hpack.lo\n+internal/nettrace.gox: internal/nettrace.lo\n \t$(BUILDGOX)\n internal/race.gox: internal/race.lo\n \t$(BUILDGOX)\n@@ -6479,6 +6637,8 @@ net/http/fcgi.gox: net/http/fcgi.lo\n \t$(BUILDGOX)\n net/http/httptest.gox: net/http/httptest.lo\n \t$(BUILDGOX)\n+net/http/httptrace.gox: net/http/httptrace.lo\n+\t$(BUILDGOX)\n net/http/httputil.gox: net/http/httputil.lo\n \t$(BUILDGOX)\n net/http/pprof.gox: net/http/pprof.lo"}, {"sha": "a323ae8190fee00532a0dfe3417c6c05ff775e9b", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1 +1 @@\n-go1.6.1\n\\ No newline at end of file\n+go1.7rc3"}, {"sha": "ee86b35d8a64447631e4a3eaeee147ff41e2458a", "filename": "libgo/configure", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -670,6 +670,8 @@ LIBGO_IS_386_FALSE\n LIBGO_IS_386_TRUE\n USE_DEJAGNU\n GOOS\n+LIBGO_IS_BSD_FALSE\n+LIBGO_IS_BSD_TRUE\n LIBGO_IS_SOLARIS_FALSE\n LIBGO_IS_SOLARIS_TRUE\n LIBGO_IS_RTEMS_FALSE\n@@ -11126,7 +11128,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11129 \"configure\"\n+#line 11131 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11232,7 +11234,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11235 \"configure\"\n+#line 11237 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13611,6 +13613,14 @@ else\n   LIBGO_IS_SOLARIS_FALSE=\n fi\n \n+ if test $is_darwin = yes -o $is_dragonfly = yes -o $is_freebsd = yes -o $is_netbsd = yes -o $is_openbsd = yes; then\n+  LIBGO_IS_BSD_TRUE=\n+  LIBGO_IS_BSD_FALSE='#'\n+else\n+  LIBGO_IS_BSD_TRUE='#'\n+  LIBGO_IS_BSD_FALSE=\n+fi\n+\n \n \n USE_DEJAGNU=no\n@@ -15769,6 +15779,10 @@ if test -z \"${LIBGO_IS_SOLARIS_TRUE}\" && test -z \"${LIBGO_IS_SOLARIS_FALSE}\"; th\n   as_fn_error \"conditional \\\"LIBGO_IS_SOLARIS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${LIBGO_IS_BSD_TRUE}\" && test -z \"${LIBGO_IS_BSD_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_BSD\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_386_TRUE}\" && test -z \"${LIBGO_IS_386_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_386\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "cda34db037d4536a408950100f0845113aa1b088", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -172,6 +172,7 @@ AM_CONDITIONAL(LIBGO_IS_OPENBSD, test $is_openbsd = yes)\n AM_CONDITIONAL(LIBGO_IS_DRAGONFLY, test $is_dragonfly = yes)\n AM_CONDITIONAL(LIBGO_IS_RTEMS, test $is_rtems = yes)\n AM_CONDITIONAL(LIBGO_IS_SOLARIS, test $is_solaris = yes)\n+AM_CONDITIONAL(LIBGO_IS_BSD, test $is_darwin = yes -o $is_dragonfly = yes -o $is_freebsd = yes -o $is_netbsd = yes -o $is_openbsd = yes)\n AC_SUBST(GOOS)\n \n dnl Test whether we need to use DejaGNU or whether we can use the"}, {"sha": "2a1e4321826195572f685e6435edc01c929cfc54", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -21,10 +21,8 @@ import (\n \t\"time\"\n )\n \n+// Header type flags.\n const (\n-\tblockSize = 512\n-\n-\t// Types\n \tTypeReg           = '0'    // regular file\n \tTypeRegA          = '\\x00' // regular file\n \tTypeLink          = '1'    // hard link\n@@ -61,12 +59,6 @@ type Header struct {\n \tXattrs     map[string]string\n }\n \n-// File name constants from the tar spec.\n-const (\n-\tfileNameSize       = 100 // Maximum number of bytes in a standard tar name.\n-\tfileNamePrefixSize = 155 // Maximum number of ustar extension bytes.\n-)\n-\n // FileInfo returns an os.FileInfo for the Header.\n func (h *Header) FileInfo() os.FileInfo {\n \treturn headerFileInfo{h}\n@@ -279,33 +271,6 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \treturn h, nil\n }\n \n-var zeroBlock = make([]byte, blockSize)\n-\n-// POSIX specifies a sum of the unsigned byte values, but the Sun tar uses signed byte values.\n-// We compute and return both.\n-func checksum(header []byte) (unsigned int64, signed int64) {\n-\tfor i := 0; i < len(header); i++ {\n-\t\tif i == 148 {\n-\t\t\t// The chksum field (header[148:156]) is special: it should be treated as space bytes.\n-\t\t\tunsigned += ' ' * 8\n-\t\t\tsigned += ' ' * 8\n-\t\t\ti += 7\n-\t\t\tcontinue\n-\t\t}\n-\t\tunsigned += int64(header[i])\n-\t\tsigned += int64(int8(header[i]))\n-\t}\n-\treturn\n-}\n-\n-type slicer []byte\n-\n-func (sp *slicer) next(n int) (b []byte) {\n-\ts := *sp\n-\tb, *sp = s[0:n], s[n:]\n-\treturn\n-}\n-\n func isASCII(s string) bool {\n \tfor _, c := range s {\n \t\tif c >= 0x80 {"}, {"sha": "c2c9910d00281ffd918258dcee2a5004daf4c554", "filename": "libgo/go/archive/tar/format.go", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tar\n+\n+// Constants to identify various tar formats.\n+const (\n+\t// The format is unknown.\n+\tformatUnknown = (1 << iota) / 2 // Sequence of 0, 1, 2, 4, 8, etc...\n+\n+\t// The format of the original Unix V7 tar tool prior to standardization.\n+\tformatV7\n+\n+\t// The old and new GNU formats, which are incompatible with USTAR.\n+\t// This does cover the old GNU sparse extension.\n+\t// This does not cover the GNU sparse extensions using PAX headers,\n+\t// versions 0.0, 0.1, and 1.0; these fall under the PAX format.\n+\tformatGNU\n+\n+\t// Schily's tar format, which is incompatible with USTAR.\n+\t// This does not cover STAR extensions to the PAX format; these fall under\n+\t// the PAX format.\n+\tformatSTAR\n+\n+\t// USTAR is the former standardization of tar defined in POSIX.1-1988.\n+\t// This is incompatible with the GNU and STAR formats.\n+\tformatUSTAR\n+\n+\t// PAX is the latest standardization of tar defined in POSIX.1-2001.\n+\t// This is an extension of USTAR and is \"backwards compatible\" with it.\n+\t//\n+\t// Some newer formats add their own extensions to PAX, such as GNU sparse\n+\t// files and SCHILY extended attributes. Since they are backwards compatible\n+\t// with PAX, they will be labelled as \"PAX\".\n+\tformatPAX\n+)\n+\n+// Magics used to identify various formats.\n+const (\n+\tmagicGNU, versionGNU     = \"ustar \", \" \\x00\"\n+\tmagicUSTAR, versionUSTAR = \"ustar\\x00\", \"00\"\n+\ttrailerSTAR              = \"tar\\x00\"\n+)\n+\n+// Size constants from various tar specifications.\n+const (\n+\tblockSize  = 512 // Size of each block in a tar stream\n+\tnameSize   = 100 // Max length of the name field in USTAR format\n+\tprefixSize = 155 // Max length of the prefix field in USTAR format\n+)\n+\n+var zeroBlock block\n+\n+type block [blockSize]byte\n+\n+// Convert block to any number of formats.\n+func (b *block) V7() *headerV7       { return (*headerV7)(b) }\n+func (b *block) GNU() *headerGNU     { return (*headerGNU)(b) }\n+func (b *block) STAR() *headerSTAR   { return (*headerSTAR)(b) }\n+func (b *block) USTAR() *headerUSTAR { return (*headerUSTAR)(b) }\n+func (b *block) Sparse() sparseArray { return (sparseArray)(b[:]) }\n+\n+// GetFormat checks that the block is a valid tar header based on the checksum.\n+// It then attempts to guess the specific format based on magic values.\n+// If the checksum fails, then formatUnknown is returned.\n+func (b *block) GetFormat() (format int) {\n+\t// Verify checksum.\n+\tvar p parser\n+\tvalue := p.parseOctal(b.V7().Chksum())\n+\tchksum1, chksum2 := b.ComputeChecksum()\n+\tif p.err != nil || (value != chksum1 && value != chksum2) {\n+\t\treturn formatUnknown\n+\t}\n+\n+\t// Guess the magic values.\n+\tmagic := string(b.USTAR().Magic())\n+\tversion := string(b.USTAR().Version())\n+\ttrailer := string(b.STAR().Trailer())\n+\tswitch {\n+\tcase magic == magicUSTAR && trailer == trailerSTAR:\n+\t\treturn formatSTAR\n+\tcase magic == magicUSTAR:\n+\t\treturn formatUSTAR\n+\tcase magic == magicGNU && version == versionGNU:\n+\t\treturn formatGNU\n+\tdefault:\n+\t\treturn formatV7\n+\t}\n+}\n+\n+// SetFormat writes the magic values necessary for specified format\n+// and then updates the checksum accordingly.\n+func (b *block) SetFormat(format int) {\n+\t// Set the magic values.\n+\tswitch format {\n+\tcase formatV7:\n+\t\t// Do nothing.\n+\tcase formatGNU:\n+\t\tcopy(b.GNU().Magic(), magicGNU)\n+\t\tcopy(b.GNU().Version(), versionGNU)\n+\tcase formatSTAR:\n+\t\tcopy(b.STAR().Magic(), magicUSTAR)\n+\t\tcopy(b.STAR().Version(), versionUSTAR)\n+\t\tcopy(b.STAR().Trailer(), trailerSTAR)\n+\tcase formatUSTAR, formatPAX:\n+\t\tcopy(b.USTAR().Magic(), magicUSTAR)\n+\t\tcopy(b.USTAR().Version(), versionUSTAR)\n+\tdefault:\n+\t\tpanic(\"invalid format\")\n+\t}\n+\n+\t// Update checksum.\n+\t// This field is special in that it is terminated by a NULL then space.\n+\tvar f formatter\n+\tfield := b.V7().Chksum()\n+\tchksum, _ := b.ComputeChecksum() // Possible values are 256..128776\n+\tf.formatOctal(field[:7], chksum) // Never fails since 128776 < 262143\n+\tfield[7] = ' '\n+}\n+\n+// ComputeChecksum computes the checksum for the header block.\n+// POSIX specifies a sum of the unsigned byte values, but the Sun tar used\n+// signed byte values.\n+// We compute and return both.\n+func (b *block) ComputeChecksum() (unsigned, signed int64) {\n+\tfor i, c := range b {\n+\t\tif 148 <= i && i < 156 {\n+\t\t\tc = ' ' // Treat the checksum field itself as all spaces.\n+\t\t}\n+\t\tunsigned += int64(uint8(c))\n+\t\tsigned += int64(int8(c))\n+\t}\n+\treturn unsigned, signed\n+}\n+\n+type headerV7 [blockSize]byte\n+\n+func (h *headerV7) Name() []byte     { return h[000:][:100] }\n+func (h *headerV7) Mode() []byte     { return h[100:][:8] }\n+func (h *headerV7) UID() []byte      { return h[108:][:8] }\n+func (h *headerV7) GID() []byte      { return h[116:][:8] }\n+func (h *headerV7) Size() []byte     { return h[124:][:12] }\n+func (h *headerV7) ModTime() []byte  { return h[136:][:12] }\n+func (h *headerV7) Chksum() []byte   { return h[148:][:8] }\n+func (h *headerV7) TypeFlag() []byte { return h[156:][:1] }\n+func (h *headerV7) LinkName() []byte { return h[157:][:100] }\n+\n+type headerGNU [blockSize]byte\n+\n+func (h *headerGNU) V7() *headerV7       { return (*headerV7)(h) }\n+func (h *headerGNU) Magic() []byte       { return h[257:][:6] }\n+func (h *headerGNU) Version() []byte     { return h[263:][:2] }\n+func (h *headerGNU) UserName() []byte    { return h[265:][:32] }\n+func (h *headerGNU) GroupName() []byte   { return h[297:][:32] }\n+func (h *headerGNU) DevMajor() []byte    { return h[329:][:8] }\n+func (h *headerGNU) DevMinor() []byte    { return h[337:][:8] }\n+func (h *headerGNU) AccessTime() []byte  { return h[345:][:12] }\n+func (h *headerGNU) ChangeTime() []byte  { return h[357:][:12] }\n+func (h *headerGNU) Sparse() sparseArray { return (sparseArray)(h[386:][:24*4+1]) }\n+func (h *headerGNU) RealSize() []byte    { return h[483:][:12] }\n+\n+type headerSTAR [blockSize]byte\n+\n+func (h *headerSTAR) V7() *headerV7      { return (*headerV7)(h) }\n+func (h *headerSTAR) Magic() []byte      { return h[257:][:6] }\n+func (h *headerSTAR) Version() []byte    { return h[263:][:2] }\n+func (h *headerSTAR) UserName() []byte   { return h[265:][:32] }\n+func (h *headerSTAR) GroupName() []byte  { return h[297:][:32] }\n+func (h *headerSTAR) DevMajor() []byte   { return h[329:][:8] }\n+func (h *headerSTAR) DevMinor() []byte   { return h[337:][:8] }\n+func (h *headerSTAR) Prefix() []byte     { return h[345:][:131] }\n+func (h *headerSTAR) AccessTime() []byte { return h[476:][:12] }\n+func (h *headerSTAR) ChangeTime() []byte { return h[488:][:12] }\n+func (h *headerSTAR) Trailer() []byte    { return h[508:][:4] }\n+\n+type headerUSTAR [blockSize]byte\n+\n+func (h *headerUSTAR) V7() *headerV7     { return (*headerV7)(h) }\n+func (h *headerUSTAR) Magic() []byte     { return h[257:][:6] }\n+func (h *headerUSTAR) Version() []byte   { return h[263:][:2] }\n+func (h *headerUSTAR) UserName() []byte  { return h[265:][:32] }\n+func (h *headerUSTAR) GroupName() []byte { return h[297:][:32] }\n+func (h *headerUSTAR) DevMajor() []byte  { return h[329:][:8] }\n+func (h *headerUSTAR) DevMinor() []byte  { return h[337:][:8] }\n+func (h *headerUSTAR) Prefix() []byte    { return h[345:][:155] }\n+\n+type sparseArray []byte\n+\n+func (s sparseArray) Entry(i int) sparseNode { return (sparseNode)(s[i*24:]) }\n+func (s sparseArray) IsExtended() []byte     { return s[24*s.MaxEntries():][:1] }\n+func (s sparseArray) MaxEntries() int        { return len(s) / 24 }\n+\n+type sparseNode []byte\n+\n+func (s sparseNode) Offset() []byte   { return s[00:][:12] }\n+func (s sparseNode) NumBytes() []byte { return s[12:][:12] }"}, {"sha": "096ef082bf8764dab9ccd3684acaf53e1ceac46c", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 73, "deletions": 117, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"math\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -30,11 +29,11 @@ const maxNanoSecondIntSize = 9\n // The Next method advances to the next file in the archive (including the first),\n // and then it can be treated as an io.Reader to access the file's data.\n type Reader struct {\n-\tr       io.Reader\n-\terr     error\n-\tpad     int64           // amount of padding (ignored) after current file entry\n-\tcurr    numBytesReader  // reader for current file entry\n-\thdrBuff [blockSize]byte // buffer to use in readHeader\n+\tr    io.Reader\n+\terr  error\n+\tpad  int64          // amount of padding (ignored) after current file entry\n+\tcurr numBytesReader // reader for current file entry\n+\tblk  block          // buffer to use as temporary local storage\n }\n \n type parser struct {\n@@ -99,17 +98,6 @@ const (\n \tpaxGNUSparseRealSize  = \"GNU.sparse.realsize\"\n )\n \n-// Keywords for old GNU sparse headers\n-const (\n-\toldGNUSparseMainHeaderOffset               = 386\n-\toldGNUSparseMainHeaderIsExtendedOffset     = 482\n-\toldGNUSparseMainHeaderNumEntries           = 4\n-\toldGNUSparseExtendedHeaderIsExtendedOffset = 504\n-\toldGNUSparseExtendedHeaderNumEntries       = 21\n-\toldGNUSparseOffsetSize                     = 12\n-\toldGNUSparseNumBytesSize                   = 12\n-)\n-\n // NewReader creates a new Reader reading from r.\n func NewReader(r io.Reader) *Reader { return &Reader{r: r} }\n \n@@ -307,7 +295,7 @@ func mergePAX(hdr *Header, headers map[string]string) error {\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\thdr.Size = int64(size)\n+\t\t\thdr.Size = size\n \t\tdefault:\n \t\t\tif strings.HasPrefix(k, paxXattr) {\n \t\t\t\tif hdr.Xattrs == nil {\n@@ -337,17 +325,17 @@ func parsePAXTime(t string) (time.Time, error) {\n \t\tif err != nil {\n \t\t\treturn time.Time{}, err\n \t\t}\n-\t\tnano_buf := string(buf[pos+1:])\n+\t\tnanoBuf := string(buf[pos+1:])\n \t\t// Pad as needed before converting to a decimal.\n \t\t// For example .030 -> .030000000 -> 30000000 nanoseconds\n-\t\tif len(nano_buf) < maxNanoSecondIntSize {\n+\t\tif len(nanoBuf) < maxNanoSecondIntSize {\n \t\t\t// Right pad\n-\t\t\tnano_buf += strings.Repeat(\"0\", maxNanoSecondIntSize-len(nano_buf))\n-\t\t} else if len(nano_buf) > maxNanoSecondIntSize {\n+\t\t\tnanoBuf += strings.Repeat(\"0\", maxNanoSecondIntSize-len(nanoBuf))\n+\t\t} else if len(nanoBuf) > maxNanoSecondIntSize {\n \t\t\t// Right truncate\n-\t\t\tnano_buf = nano_buf[:maxNanoSecondIntSize]\n+\t\t\tnanoBuf = nanoBuf[:maxNanoSecondIntSize]\n \t\t}\n-\t\tnanoseconds, err = strconv.ParseInt(string(nano_buf), 10, 0)\n+\t\tnanoseconds, err = strconv.ParseInt(nanoBuf, 10, 0)\n \t\tif err != nil {\n \t\t\treturn time.Time{}, err\n \t\t}\n@@ -379,14 +367,14 @@ func parsePAX(r io.Reader) (map[string]string, error) {\n \t\t}\n \t\tsbuf = residual\n \n-\t\tkeyStr := string(key)\n+\t\tkeyStr := key\n \t\tif keyStr == paxGNUSparseOffset || keyStr == paxGNUSparseNumBytes {\n \t\t\t// GNU sparse format 0.0 special key. Write to sparseMap instead of using the headers map.\n \t\t\tsparseMap.WriteString(value)\n \t\t\tsparseMap.Write([]byte{','})\n \t\t} else {\n \t\t\t// Normal key. Set the value in the headers map.\n-\t\t\theaders[keyStr] = string(value)\n+\t\t\theaders[keyStr] = value\n \t\t}\n \t}\n \tif sparseMap.Len() != 0 {\n@@ -523,10 +511,10 @@ func (tr *Reader) skipUnread() error {\n \t\t// io.Seeker, but calling Seek always returns an error and performs\n \t\t// no action. Thus, we try an innocent seek to the current position\n \t\t// to see if Seek is really supported.\n-\t\tpos1, err := sr.Seek(0, os.SEEK_CUR)\n+\t\tpos1, err := sr.Seek(0, io.SeekCurrent)\n \t\tif err == nil {\n \t\t\t// Seek seems supported, so perform the real Seek.\n-\t\t\tpos2, err := sr.Seek(dataSkip-1, os.SEEK_CUR)\n+\t\t\tpos2, err := sr.Seek(dataSkip-1, io.SeekCurrent)\n \t\t\tif err != nil {\n \t\t\t\ttr.err = err\n \t\t\t\treturn tr.err\n@@ -543,17 +531,6 @@ func (tr *Reader) skipUnread() error {\n \treturn tr.err\n }\n \n-func (tr *Reader) verifyChecksum(header []byte) bool {\n-\tif tr.err != nil {\n-\t\treturn false\n-\t}\n-\n-\tvar p parser\n-\tgiven := p.parseOctal(header[148:156])\n-\tunsigned, signed := checksum(header)\n-\treturn p.err == nil && (given == unsigned || given == signed)\n-}\n-\n // readHeader reads the next block header and assumes that the underlying reader\n // is already aligned to a block boundary.\n //\n@@ -562,91 +539,72 @@ func (tr *Reader) verifyChecksum(header []byte) bool {\n //\t* Exactly 1 block of zeros is read and EOF is hit.\n //\t* At least 2 blocks of zeros are read.\n func (tr *Reader) readHeader() *Header {\n-\theader := tr.hdrBuff[:]\n-\tcopy(header, zeroBlock)\n-\n-\tif _, tr.err = io.ReadFull(tr.r, header); tr.err != nil {\n+\tif _, tr.err = io.ReadFull(tr.r, tr.blk[:]); tr.err != nil {\n \t\treturn nil // io.EOF is okay here\n \t}\n \n \t// Two blocks of zero bytes marks the end of the archive.\n-\tif bytes.Equal(header, zeroBlock[0:blockSize]) {\n-\t\tif _, tr.err = io.ReadFull(tr.r, header); tr.err != nil {\n+\tif bytes.Equal(tr.blk[:], zeroBlock[:]) {\n+\t\tif _, tr.err = io.ReadFull(tr.r, tr.blk[:]); tr.err != nil {\n \t\t\treturn nil // io.EOF is okay here\n \t\t}\n-\t\tif bytes.Equal(header, zeroBlock[0:blockSize]) {\n+\t\tif bytes.Equal(tr.blk[:], zeroBlock[:]) {\n \t\t\ttr.err = io.EOF\n \t\t} else {\n \t\t\ttr.err = ErrHeader // zero block and then non-zero block\n \t\t}\n \t\treturn nil\n \t}\n \n-\tif !tr.verifyChecksum(header) {\n+\t// Verify the header matches a known format.\n+\tformat := tr.blk.GetFormat()\n+\tif format == formatUnknown {\n \t\ttr.err = ErrHeader\n \t\treturn nil\n \t}\n \n-\t// Unpack\n \tvar p parser\n \thdr := new(Header)\n-\ts := slicer(header)\n-\n-\thdr.Name = p.parseString(s.next(100))\n-\thdr.Mode = p.parseNumeric(s.next(8))\n-\thdr.Uid = int(p.parseNumeric(s.next(8)))\n-\thdr.Gid = int(p.parseNumeric(s.next(8)))\n-\thdr.Size = p.parseNumeric(s.next(12))\n-\thdr.ModTime = time.Unix(p.parseNumeric(s.next(12)), 0)\n-\ts.next(8) // chksum\n-\thdr.Typeflag = s.next(1)[0]\n-\thdr.Linkname = p.parseString(s.next(100))\n-\n-\t// The remainder of the header depends on the value of magic.\n-\t// The original (v7) version of tar had no explicit magic field,\n-\t// so its magic bytes, like the rest of the block, are NULs.\n-\tmagic := string(s.next(8)) // contains version field as well.\n-\tvar format string\n-\tswitch {\n-\tcase magic[:6] == \"ustar\\x00\": // POSIX tar (1003.1-1988)\n-\t\tif string(header[508:512]) == \"tar\\x00\" {\n-\t\t\tformat = \"star\"\n-\t\t} else {\n-\t\t\tformat = \"posix\"\n-\t\t}\n-\tcase magic == \"ustar  \\x00\": // old GNU tar\n-\t\tformat = \"gnu\"\n-\t}\n \n-\tswitch format {\n-\tcase \"posix\", \"gnu\", \"star\":\n-\t\thdr.Uname = p.parseString(s.next(32))\n-\t\thdr.Gname = p.parseString(s.next(32))\n-\t\tdevmajor := s.next(8)\n-\t\tdevminor := s.next(8)\n+\t// Unpack the V7 header.\n+\tv7 := tr.blk.V7()\n+\thdr.Name = p.parseString(v7.Name())\n+\thdr.Mode = p.parseNumeric(v7.Mode())\n+\thdr.Uid = int(p.parseNumeric(v7.UID()))\n+\thdr.Gid = int(p.parseNumeric(v7.GID()))\n+\thdr.Size = p.parseNumeric(v7.Size())\n+\thdr.ModTime = time.Unix(p.parseNumeric(v7.ModTime()), 0)\n+\thdr.Typeflag = v7.TypeFlag()[0]\n+\thdr.Linkname = p.parseString(v7.LinkName())\n+\n+\t// Unpack format specific fields.\n+\tif format > formatV7 {\n+\t\tustar := tr.blk.USTAR()\n+\t\thdr.Uname = p.parseString(ustar.UserName())\n+\t\thdr.Gname = p.parseString(ustar.GroupName())\n \t\tif hdr.Typeflag == TypeChar || hdr.Typeflag == TypeBlock {\n-\t\t\thdr.Devmajor = p.parseNumeric(devmajor)\n-\t\t\thdr.Devminor = p.parseNumeric(devminor)\n+\t\t\thdr.Devmajor = p.parseNumeric(ustar.DevMajor())\n+\t\t\thdr.Devminor = p.parseNumeric(ustar.DevMinor())\n \t\t}\n+\n \t\tvar prefix string\n \t\tswitch format {\n-\t\tcase \"posix\", \"gnu\":\n-\t\t\tprefix = p.parseString(s.next(155))\n-\t\tcase \"star\":\n-\t\t\tprefix = p.parseString(s.next(131))\n-\t\t\thdr.AccessTime = time.Unix(p.parseNumeric(s.next(12)), 0)\n-\t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(s.next(12)), 0)\n+\t\tcase formatUSTAR, formatGNU:\n+\t\t\t// TODO(dsnet): Do not use the prefix field for the GNU format!\n+\t\t\t// See golang.org/issues/12594\n+\t\t\tustar := tr.blk.USTAR()\n+\t\t\tprefix = p.parseString(ustar.Prefix())\n+\t\tcase formatSTAR:\n+\t\t\tstar := tr.blk.STAR()\n+\t\t\tprefix = p.parseString(star.Prefix())\n+\t\t\thdr.AccessTime = time.Unix(p.parseNumeric(star.AccessTime()), 0)\n+\t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(star.ChangeTime()), 0)\n \t\t}\n \t\tif len(prefix) > 0 {\n \t\t\thdr.Name = prefix + \"/\" + hdr.Name\n \t\t}\n \t}\n \n-\tif p.err != nil {\n-\t\ttr.err = p.err\n-\t\treturn nil\n-\t}\n-\n \tnb := hdr.Size\n \tif isHeaderOnlyType(hdr.Typeflag) {\n \t\tnb = 0\n@@ -663,14 +621,14 @@ func (tr *Reader) readHeader() *Header {\n \t// Check for old GNU sparse format entry.\n \tif hdr.Typeflag == TypeGNUSparse {\n \t\t// Get the real size of the file.\n-\t\thdr.Size = p.parseNumeric(header[483:495])\n+\t\thdr.Size = p.parseNumeric(tr.blk.GNU().RealSize())\n \t\tif p.err != nil {\n \t\t\ttr.err = p.err\n \t\t\treturn nil\n \t\t}\n \n \t\t// Read the sparse map.\n-\t\tsp := tr.readOldGNUSparseMap(header)\n+\t\tsp := tr.readOldGNUSparseMap(&tr.blk)\n \t\tif tr.err != nil {\n \t\t\treturn nil\n \t\t}\n@@ -682,26 +640,24 @@ func (tr *Reader) readHeader() *Header {\n \t\t}\n \t}\n \n+\tif p.err != nil {\n+\t\ttr.err = p.err\n+\t\treturn nil\n+\t}\n+\n \treturn hdr\n }\n \n // readOldGNUSparseMap reads the sparse map as stored in the old GNU sparse format.\n // The sparse map is stored in the tar header if it's small enough. If it's larger than four entries,\n // then one or more extension headers are used to store the rest of the sparse map.\n-func (tr *Reader) readOldGNUSparseMap(header []byte) []sparseEntry {\n+func (tr *Reader) readOldGNUSparseMap(blk *block) []sparseEntry {\n \tvar p parser\n-\tisExtended := header[oldGNUSparseMainHeaderIsExtendedOffset] != 0\n-\tspCap := oldGNUSparseMainHeaderNumEntries\n-\tif isExtended {\n-\t\tspCap += oldGNUSparseExtendedHeaderNumEntries\n-\t}\n-\tsp := make([]sparseEntry, 0, spCap)\n-\ts := slicer(header[oldGNUSparseMainHeaderOffset:])\n-\n-\t// Read the four entries from the main tar header\n-\tfor i := 0; i < oldGNUSparseMainHeaderNumEntries; i++ {\n-\t\toffset := p.parseNumeric(s.next(oldGNUSparseOffsetSize))\n-\t\tnumBytes := p.parseNumeric(s.next(oldGNUSparseNumBytesSize))\n+\tvar s sparseArray = blk.GNU().Sparse()\n+\tvar sp = make([]sparseEntry, 0, s.MaxEntries())\n+\tfor i := 0; i < s.MaxEntries(); i++ {\n+\t\toffset := p.parseOctal(s.Entry(i).Offset())\n+\t\tnumBytes := p.parseOctal(s.Entry(i).NumBytes())\n \t\tif p.err != nil {\n \t\t\ttr.err = p.err\n \t\t\treturn nil\n@@ -712,17 +668,17 @@ func (tr *Reader) readOldGNUSparseMap(header []byte) []sparseEntry {\n \t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n \t}\n \n-\tfor isExtended {\n+\tfor s.IsExtended()[0] > 0 {\n \t\t// There are more entries. Read an extension header and parse its entries.\n-\t\tsparseHeader := make([]byte, blockSize)\n-\t\tif _, tr.err = io.ReadFull(tr.r, sparseHeader); tr.err != nil {\n+\t\tvar blk block\n+\t\tif _, tr.err = io.ReadFull(tr.r, blk[:]); tr.err != nil {\n \t\t\treturn nil\n \t\t}\n-\t\tisExtended = sparseHeader[oldGNUSparseExtendedHeaderIsExtendedOffset] != 0\n-\t\ts = slicer(sparseHeader)\n-\t\tfor i := 0; i < oldGNUSparseExtendedHeaderNumEntries; i++ {\n-\t\t\toffset := p.parseNumeric(s.next(oldGNUSparseOffsetSize))\n-\t\t\tnumBytes := p.parseNumeric(s.next(oldGNUSparseNumBytesSize))\n+\t\ts = blk.Sparse()\n+\n+\t\tfor i := 0; i < s.MaxEntries(); i++ {\n+\t\t\toffset := p.parseOctal(s.Entry(i).Offset())\n+\t\t\tnumBytes := p.parseOctal(s.Entry(i).NumBytes())\n \t\t\tif p.err != nil {\n \t\t\t\ttr.err = p.err\n \t\t\t\treturn nil"}, {"sha": "426e4434eb75444a81e86e86bb7b07f9aaae2d8e", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 46, "deletions": 60, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -36,10 +36,10 @@ type Writer struct {\n \tnb         int64 // number of unwritten bytes for current file entry\n \tpad        int64 // amount of padding to write after current file entry\n \tclosed     bool\n-\tusedBinary bool            // whether the binary numeric field extension was used\n-\tpreferPax  bool            // use pax header instead of binary numeric header\n-\thdrBuff    [blockSize]byte // buffer to use in writeHeader when writing a regular header\n-\tpaxHdrBuff [blockSize]byte // buffer to use in writeHeader when writing a pax header\n+\tusedBinary bool  // whether the binary numeric field extension was used\n+\tpreferPax  bool  // use PAX header instead of binary numeric header\n+\thdrBuff    block // buffer to use in writeHeader when writing a regular header\n+\tpaxHdrBuff block // buffer to use in writeHeader when writing a PAX header\n }\n \n type formatter struct {\n@@ -153,27 +153,24 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \t// a map to hold pax header records, if any are needed\n \tpaxHeaders := make(map[string]string)\n \n-\t// TODO(shanemhansen): we might want to use PAX headers for\n+\t// TODO(dsnet): we might want to use PAX headers for\n \t// subsecond time resolution, but for now let's just capture\n \t// too long fields or non ascii characters\n \n-\tvar f formatter\n-\tvar header []byte\n-\n \t// We need to select which scratch buffer to use carefully,\n \t// since this method is called recursively to write PAX headers.\n \t// If allowPax is true, this is the non-recursive call, and we will use hdrBuff.\n \t// If allowPax is false, we are being called by writePAXHeader, and hdrBuff is\n \t// already being used by the non-recursive call, so we must use paxHdrBuff.\n-\theader = tw.hdrBuff[:]\n+\theader := &tw.hdrBuff\n \tif !allowPax {\n-\t\theader = tw.paxHdrBuff[:]\n+\t\theader = &tw.paxHdrBuff\n \t}\n-\tcopy(header, zeroBlock)\n-\ts := slicer(header)\n+\tcopy(header[:], zeroBlock[:])\n \n \t// Wrappers around formatter that automatically sets paxHeaders if the\n \t// argument extends beyond the capacity of the input byte slice.\n+\tvar f formatter\n \tvar formatString = func(b []byte, s string, paxKeyword string) {\n \t\tneedsPaxHeader := paxKeyword != paxNone && len(s) > len(b) || !isASCII(s)\n \t\tif needsPaxHeader {\n@@ -202,61 +199,50 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \t\tf.formatNumeric(b, x)\n \t}\n \n-\t// keep a reference to the filename to allow to overwrite it later if we detect that we can use ustar longnames instead of pax\n-\tpathHeaderBytes := s.next(fileNameSize)\n-\n-\tformatString(pathHeaderBytes, hdr.Name, paxPath)\n-\n \t// Handle out of range ModTime carefully.\n \tvar modTime int64\n \tif !hdr.ModTime.Before(minTime) && !hdr.ModTime.After(maxTime) {\n \t\tmodTime = hdr.ModTime.Unix()\n \t}\n \n-\tf.formatOctal(s.next(8), hdr.Mode)               // 100:108\n-\tformatNumeric(s.next(8), int64(hdr.Uid), paxUid) // 108:116\n-\tformatNumeric(s.next(8), int64(hdr.Gid), paxGid) // 116:124\n-\tformatNumeric(s.next(12), hdr.Size, paxSize)     // 124:136\n-\tformatNumeric(s.next(12), modTime, paxNone)      // 136:148 --- consider using pax for finer granularity\n-\ts.next(8)                                        // chksum (148:156)\n-\ts.next(1)[0] = hdr.Typeflag                      // 156:157\n-\n-\tformatString(s.next(100), hdr.Linkname, paxLinkpath)\n-\n-\tcopy(s.next(8), []byte(\"ustar\\x0000\"))          // 257:265\n-\tformatString(s.next(32), hdr.Uname, paxUname)   // 265:297\n-\tformatString(s.next(32), hdr.Gname, paxGname)   // 297:329\n-\tformatNumeric(s.next(8), hdr.Devmajor, paxNone) // 329:337\n-\tformatNumeric(s.next(8), hdr.Devminor, paxNone) // 337:345\n-\n-\t// keep a reference to the prefix to allow to overwrite it later if we detect that we can use ustar longnames instead of pax\n-\tprefixHeaderBytes := s.next(155)\n-\tformatString(prefixHeaderBytes, \"\", paxNone) // 345:500  prefix\n+\tv7 := header.V7()\n+\tformatString(v7.Name(), hdr.Name, paxPath)\n+\t// TODO(dsnet): The GNU format permits the mode field to be encoded in\n+\t// base-256 format. Thus, we can use formatNumeric instead of formatOctal.\n+\tf.formatOctal(v7.Mode(), hdr.Mode)\n+\tformatNumeric(v7.UID(), int64(hdr.Uid), paxUid)\n+\tformatNumeric(v7.GID(), int64(hdr.Gid), paxGid)\n+\tformatNumeric(v7.Size(), hdr.Size, paxSize)\n+\t// TODO(dsnet): Consider using PAX for finer time granularity.\n+\tformatNumeric(v7.ModTime(), modTime, paxNone)\n+\tv7.TypeFlag()[0] = hdr.Typeflag\n+\tformatString(v7.LinkName(), hdr.Linkname, paxLinkpath)\n+\n+\tustar := header.USTAR()\n+\tformatString(ustar.UserName(), hdr.Uname, paxUname)\n+\tformatString(ustar.GroupName(), hdr.Gname, paxGname)\n+\tformatNumeric(ustar.DevMajor(), hdr.Devmajor, paxNone)\n+\tformatNumeric(ustar.DevMinor(), hdr.Devminor, paxNone)\n \n-\t// Use the GNU magic instead of POSIX magic if we used any GNU extensions.\n-\tif tw.usedBinary {\n-\t\tcopy(header[257:265], []byte(\"ustar  \\x00\"))\n-\t}\n-\n-\t_, paxPathUsed := paxHeaders[paxPath]\n \t// try to use a ustar header when only the name is too long\n+\t_, paxPathUsed := paxHeaders[paxPath]\n \tif !tw.preferPax && len(paxHeaders) == 1 && paxPathUsed {\n \t\tprefix, suffix, ok := splitUSTARPath(hdr.Name)\n \t\tif ok {\n \t\t\t// Since we can encode in USTAR format, disable PAX header.\n \t\t\tdelete(paxHeaders, paxPath)\n \n \t\t\t// Update the path fields\n-\t\t\tformatString(pathHeaderBytes, suffix, paxNone)\n-\t\t\tformatString(prefixHeaderBytes, prefix, paxNone)\n+\t\t\tformatString(v7.Name(), suffix, paxNone)\n+\t\t\tformatString(ustar.Prefix(), prefix, paxNone)\n \t\t}\n \t}\n \n-\t// The chksum field is terminated by a NUL and a space.\n-\t// This is different from the other octal fields.\n-\tchksum, _ := checksum(header)\n-\tf.formatOctal(header[148:155], chksum) // Never fails\n-\theader[155] = ' '\n+\tif tw.usedBinary {\n+\t\theader.SetFormat(formatGNU)\n+\t} else {\n+\t\theader.SetFormat(formatUSTAR)\n+\t}\n \n \t// Check if there were any formatting errors.\n \tif f.err != nil {\n@@ -278,29 +264,29 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \t\t\treturn err\n \t\t}\n \t}\n-\ttw.nb = int64(hdr.Size)\n+\ttw.nb = hdr.Size\n \ttw.pad = (blockSize - (tw.nb % blockSize)) % blockSize\n \n-\t_, tw.err = tw.w.Write(header)\n+\t_, tw.err = tw.w.Write(header[:])\n \treturn tw.err\n }\n \n // splitUSTARPath splits a path according to USTAR prefix and suffix rules.\n // If the path is not splittable, then it will return (\"\", \"\", false).\n func splitUSTARPath(name string) (prefix, suffix string, ok bool) {\n \tlength := len(name)\n-\tif length <= fileNameSize || !isASCII(name) {\n+\tif length <= nameSize || !isASCII(name) {\n \t\treturn \"\", \"\", false\n-\t} else if length > fileNamePrefixSize+1 {\n-\t\tlength = fileNamePrefixSize + 1\n+\t} else if length > prefixSize+1 {\n+\t\tlength = prefixSize + 1\n \t} else if name[length-1] == '/' {\n \t\tlength--\n \t}\n \n \ti := strings.LastIndex(name[:length], \"/\")\n \tnlen := len(name) - i - 1 // nlen is length of suffix\n \tplen := i                 // plen is length of prefix\n-\tif i <= 0 || nlen > fileNameSize || nlen == 0 || plen > fileNamePrefixSize {\n+\tif i <= 0 || nlen > nameSize || nlen == 0 || plen > prefixSize {\n \t\treturn \"\", \"\", false\n \t}\n \treturn name[:i], name[i+1:], true\n@@ -316,15 +302,15 @@ func (tw *Writer) writePAXHeader(hdr *Header, paxHeaders map[string]string) erro\n \t// succeed, and seems harmless enough.\n \text.ModTime = hdr.ModTime\n \t// The spec asks that we namespace our pseudo files\n-\t// with the current pid.  However, this results in differing outputs\n-\t// for identical inputs.  As such, the constant 0 is now used instead.\n+\t// with the current pid. However, this results in differing outputs\n+\t// for identical inputs. As such, the constant 0 is now used instead.\n \t// golang.org/issue/12358\n \tdir, file := path.Split(hdr.Name)\n \tfullName := path.Join(dir, \"PaxHeaders.0\", file)\n \n \tascii := toASCII(fullName)\n-\tif len(ascii) > 100 {\n-\t\tascii = ascii[:100]\n+\tif len(ascii) > nameSize {\n+\t\tascii = ascii[:nameSize]\n \t}\n \text.Name = ascii\n \t// Construct the body\n@@ -407,7 +393,7 @@ func (tw *Writer) Close() error {\n \n \t// trailer: two zero blocks\n \tfor i := 0; i < 2; i++ {\n-\t\t_, tw.err = tw.w.Write(zeroBlock)\n+\t\t_, tw.err = tw.w.Write(zeroBlock[:])\n \t\tif tw.err != nil {\n \t\t\tbreak\n \t\t}"}, {"sha": "27aa8e5dab67243fc7014333226761a836f70b40", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -587,17 +587,17 @@ func TestSplitUSTARPath(t *testing.T) {\n \t\t{\"\", \"\", \"\", false},\n \t\t{\"abc\", \"\", \"\", false},\n \t\t{\"\u7528\u6236\u540d\", \"\", \"\", false},\n-\t\t{sr(\"a\", fileNameSize), \"\", \"\", false},\n-\t\t{sr(\"a\", fileNameSize) + \"/\", \"\", \"\", false},\n-\t\t{sr(\"a\", fileNameSize) + \"/a\", sr(\"a\", fileNameSize), \"a\", true},\n-\t\t{sr(\"a\", fileNamePrefixSize) + \"/\", \"\", \"\", false},\n-\t\t{sr(\"a\", fileNamePrefixSize) + \"/a\", sr(\"a\", fileNamePrefixSize), \"a\", true},\n-\t\t{sr(\"a\", fileNameSize+1), \"\", \"\", false},\n-\t\t{sr(\"/\", fileNameSize+1), sr(\"/\", fileNameSize-1), \"/\", true},\n-\t\t{sr(\"a\", fileNamePrefixSize) + \"/\" + sr(\"b\", fileNameSize),\n-\t\t\tsr(\"a\", fileNamePrefixSize), sr(\"b\", fileNameSize), true},\n-\t\t{sr(\"a\", fileNamePrefixSize) + \"//\" + sr(\"b\", fileNameSize), \"\", \"\", false},\n-\t\t{sr(\"a/\", fileNameSize), sr(\"a/\", 77) + \"a\", sr(\"a/\", 22), true},\n+\t\t{sr(\"a\", nameSize), \"\", \"\", false},\n+\t\t{sr(\"a\", nameSize) + \"/\", \"\", \"\", false},\n+\t\t{sr(\"a\", nameSize) + \"/a\", sr(\"a\", nameSize), \"a\", true},\n+\t\t{sr(\"a\", prefixSize) + \"/\", \"\", \"\", false},\n+\t\t{sr(\"a\", prefixSize) + \"/a\", sr(\"a\", prefixSize), \"a\", true},\n+\t\t{sr(\"a\", nameSize+1), \"\", \"\", false},\n+\t\t{sr(\"/\", nameSize+1), sr(\"/\", nameSize-1), \"/\", true},\n+\t\t{sr(\"a\", prefixSize) + \"/\" + sr(\"b\", nameSize),\n+\t\t\tsr(\"a\", prefixSize), sr(\"b\", nameSize), true},\n+\t\t{sr(\"a\", prefixSize) + \"//\" + sr(\"b\", nameSize), \"\", \"\", false},\n+\t\t{sr(\"a/\", nameSize), sr(\"a/\", 77) + \"a\", sr(\"a/\", 22), true},\n \t}\n \n \tfor _, v := range vectors {"}, {"sha": "f6c3ead3beabd20aca92de87c2b9ab2fba664556", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -87,7 +87,7 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \tz.File = make([]*File, 0, end.directoryRecords)\n \tz.Comment = end.comment\n \trs := io.NewSectionReader(r, 0, size)\n-\tif _, err = rs.Seek(int64(end.directoryOffset), os.SEEK_SET); err != nil {\n+\tif _, err = rs.Seek(int64(end.directoryOffset), io.SeekStart); err != nil {\n \t\treturn err\n \t}\n \tbuf := bufio.NewReader(rs)\n@@ -153,19 +153,18 @@ func (f *File) DataOffset() (offset int64, err error) {\n \n // Open returns a ReadCloser that provides access to the File's contents.\n // Multiple files may be read concurrently.\n-func (f *File) Open() (rc io.ReadCloser, err error) {\n+func (f *File) Open() (io.ReadCloser, error) {\n \tbodyOffset, err := f.findBodyOffset()\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \tsize := int64(f.CompressedSize64)\n \tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, size)\n \tdcomp := f.zip.decompressor(f.Method)\n \tif dcomp == nil {\n-\t\terr = ErrAlgorithm\n-\t\treturn\n+\t\treturn nil, ErrAlgorithm\n \t}\n-\trc = dcomp(r)\n+\tvar rc io.ReadCloser = dcomp(r)\n \tvar desr io.Reader\n \tif f.hasDataDescriptor() {\n \t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n@@ -176,7 +175,7 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \t\tf:    f,\n \t\tdesr: desr,\n \t}\n-\treturn\n+\treturn rc, nil\n }\n \n type checksumReader struct {"}, {"sha": "dfaae784361b7184ffdc36e89bd955cae0bd7233", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -399,7 +399,7 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \t// Don't bother uncompressing: too big.\n \tif ft.Content == nil && ft.File == \"\" && ft.Size > 0 {\n \t\tif size != ft.Size {\n-\t\t\tt.Errorf(\"%v: uncompressed size %#x, want %#x\", size, ft.Size)\n+\t\t\tt.Errorf(\"%v: uncompressed size %#x, want %#x\", ft.Name, size, ft.Size)\n \t\t}\n \t\tr.Close()\n \t\treturn"}, {"sha": "2e76386b1fdbe5b5492f676c67bfc863ac9f85be", "filename": "libgo/go/archive/zip/register.go", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -64,6 +64,44 @@ func (w *pooledFlateWriter) Close() error {\n \treturn err\n }\n \n+var flateReaderPool sync.Pool\n+\n+func newFlateReader(r io.Reader) io.ReadCloser {\n+\tfr, ok := flateReaderPool.Get().(io.ReadCloser)\n+\tif ok {\n+\t\tfr.(flate.Resetter).Reset(r, nil)\n+\t} else {\n+\t\tfr = flate.NewReader(r)\n+\t}\n+\treturn &pooledFlateReader{fr: fr}\n+}\n+\n+type pooledFlateReader struct {\n+\tmu sync.Mutex // guards Close and Read\n+\tfr io.ReadCloser\n+}\n+\n+func (r *pooledFlateReader) Read(p []byte) (n int, err error) {\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tif r.fr == nil {\n+\t\treturn 0, errors.New(\"Read after Close\")\n+\t}\n+\treturn r.fr.Read(p)\n+}\n+\n+func (r *pooledFlateReader) Close() error {\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tvar err error\n+\tif r.fr != nil {\n+\t\terr = r.fr.Close()\n+\t\tflateReaderPool.Put(r.fr)\n+\t\tr.fr = nil\n+\t}\n+\treturn err\n+}\n+\n var (\n \tmu sync.RWMutex // guards compressor and decompressor maps\n \n@@ -74,7 +112,7 @@ var (\n \n \tdecompressors = map[uint16]Decompressor{\n \t\tStore:   ioutil.NopCloser,\n-\t\tDeflate: flate.NewReader,\n+\t\tDeflate: newFlateReader,\n \t}\n )\n "}, {"sha": "e92d02f8a2e872ddab84503a6ea0cd4e238faa78", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -5,7 +5,7 @@\n /*\n Package zip provides support for reading and writing ZIP archives.\n \n-See: http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n+See: https://www.pkware.com/documents/casestudies/APPNOTE.TXT\n \n This package does not support disk spanning.\n "}, {"sha": "3a9292e380705573fdd0249602cb5ab83177b42e", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -52,7 +52,7 @@ func (w *Writer) Flush() error {\n }\n \n // Close finishes writing the zip file by writing the central directory.\n-// It does not (and can not) close the underlying writer.\n+// It does not (and cannot) close the underlying writer.\n func (w *Writer) Close() error {\n \tif w.last != nil && !w.last.closed {\n \t\tif err := w.last.close(); err != nil {"}, {"sha": "86841c755f160ee371976556d03b1506b7c271e2", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -184,7 +184,7 @@ func BenchmarkCompressedZipGarbage(b *testing.B) {\n \tb.ReportAllocs()\n \tvar buf bytes.Buffer\n \tbigBuf := bytes.Repeat([]byte(\"a\"), 1<<20)\n-\tfor i := 0; i < b.N; i++ {\n+\tfor i := 0; i <= b.N; i++ {\n \t\tbuf.Reset()\n \t\tzw := NewWriter(&buf)\n \t\tfor j := 0; j < 3; j++ {\n@@ -195,5 +195,11 @@ func BenchmarkCompressedZipGarbage(b *testing.B) {\n \t\t\tw.Write(bigBuf)\n \t\t}\n \t\tzw.Close()\n+\t\tif i == 0 {\n+\t\t\t// Reset the timer after the first time through.\n+\t\t\t// This effectively discards the very large initial flate setup cost,\n+\t\t\t// as well as the initialization of bigBuf.\n+\t\t\tb.ResetTimer()\n+\t\t}\n \t}\n }"}, {"sha": "3a3c915d34e0a07f63e95550bad6b979eb205f00", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -366,27 +366,6 @@ func testZip64DirectoryRecordLength(buf *rleBuffer, t *testing.T) {\n \t}\n }\n \n-func testInvalidHeader(h *FileHeader, t *testing.T) {\n-\tvar buf bytes.Buffer\n-\tz := NewWriter(&buf)\n-\n-\tf, err := z.CreateHeader(h)\n-\tif err != nil {\n-\t\tt.Fatalf(\"error creating header: %v\", err)\n-\t}\n-\tif _, err := f.Write([]byte(\"hi\")); err != nil {\n-\t\tt.Fatalf(\"error writing content: %v\", err)\n-\t}\n-\tif err := z.Close(); err != nil {\n-\t\tt.Fatalf(\"error closing zip writer: %v\", err)\n-\t}\n-\n-\tb := buf.Bytes()\n-\tif _, err = NewReader(bytes.NewReader(b), int64(len(b))); err != ErrFormat {\n-\t\tt.Fatalf(\"got %v, expected ErrFormat\", err)\n-\t}\n-}\n-\n func testValidHeader(h *FileHeader, t *testing.T) {\n \tvar buf bytes.Buffer\n \tz := NewWriter(&buf)"}, {"sha": "3b30b8b80cd6c0f66e7f0ae15e24b5db8c89aeaf", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -124,14 +124,16 @@ func (b *Reader) Peek(n int) ([]byte, error) {\n \tif n < 0 {\n \t\treturn nil, ErrNegativeCount\n \t}\n-\tif n > len(b.buf) {\n-\t\treturn nil, ErrBufferFull\n-\t}\n-\t// 0 <= n <= len(b.buf)\n-\tfor b.w-b.r < n && b.err == nil {\n+\n+\tfor b.w-b.r < n && b.w-b.r < len(b.buf) && b.err == nil {\n \t\tb.fill() // b.w-b.r < len(b.buf) => buffer is not full\n \t}\n \n+\tif n > len(b.buf) {\n+\t\treturn b.buf[b.r:b.w], ErrBufferFull\n+\t}\n+\n+\t// 0 <= n <= len(b.buf)\n \tvar err error\n \tif avail := b.w - b.r; avail < n {\n \t\t// not enough data in buffer\n@@ -220,21 +222,21 @@ func (b *Reader) Read(p []byte) (n int, err error) {\n \n // ReadByte reads and returns a single byte.\n // If no byte is available, returns an error.\n-func (b *Reader) ReadByte() (c byte, err error) {\n+func (b *Reader) ReadByte() (byte, error) {\n \tb.lastRuneSize = -1\n \tfor b.r == b.w {\n \t\tif b.err != nil {\n \t\t\treturn 0, b.readErr()\n \t\t}\n \t\tb.fill() // buffer is empty\n \t}\n-\tc = b.buf[b.r]\n+\tc := b.buf[b.r]\n \tb.r++\n \tb.lastByte = int(c)\n \treturn c, nil\n }\n \n-// UnreadByte unreads the last byte.  Only the most recently read byte can be unread.\n+// UnreadByte unreads the last byte. Only the most recently read byte can be unread.\n func (b *Reader) UnreadByte() error {\n \tif b.lastByte < 0 || b.r == 0 && b.w > 0 {\n \t\treturn ErrInvalidUnreadByte\n@@ -264,7 +266,7 @@ func (b *Reader) ReadRune() (r rune, size int, err error) {\n \t\treturn 0, 0, b.readErr()\n \t}\n \tr, size = rune(b.buf[b.r]), 1\n-\tif r >= 0x80 {\n+\tif r >= utf8.RuneSelf {\n \t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])\n \t}\n \tb.r += size\n@@ -273,7 +275,7 @@ func (b *Reader) ReadRune() (r rune, size int, err error) {\n \treturn r, size, nil\n }\n \n-// UnreadRune unreads the last rune.  If the most recent read operation on\n+// UnreadRune unreads the last rune. If the most recent read operation on\n // the buffer was not a ReadRune, UnreadRune returns an error.  (In this\n // regard it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n@@ -395,12 +397,12 @@ func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {\n // ReadBytes returns err != nil if and only if the returned data does not end in\n // delim.\n // For simple uses, a Scanner may be more convenient.\n-func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n+func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n \t// Use ReadSlice to look for array,\n \t// accumulating full buffers.\n \tvar frag []byte\n \tvar full [][]byte\n-\n+\tvar err error\n \tfor {\n \t\tvar e error\n \t\tfrag, e = b.ReadSlice(delim)\n@@ -442,10 +444,9 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n // ReadString returns err != nil if and only if the returned data does not end in\n // delim.\n // For simple uses, a Scanner may be more convenient.\n-func (b *Reader) ReadString(delim byte) (line string, err error) {\n+func (b *Reader) ReadString(delim byte) (string, error) {\n \tbytes, err := b.ReadBytes(delim)\n-\tline = string(bytes)\n-\treturn line, err\n+\treturn string(bytes), err\n }\n \n // WriteTo implements io.WriterTo.\n@@ -705,7 +706,7 @@ func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n \t\t}\n \t}\n \tif err == io.EOF {\n-\t\t// If we filled the buffer exactly, flush pre-emptively.\n+\t\t// If we filled the buffer exactly, flush preemptively.\n \t\tif b.Available() == 0 {\n \t\t\terr = b.flush()\n \t\t} else {"}, {"sha": "858048696e4ed15789c445523925b54989953566", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -673,8 +673,8 @@ func TestPeek(t *testing.T) {\n \tif _, err := buf.Peek(-1); err != ErrNegativeCount {\n \t\tt.Fatalf(\"want ErrNegativeCount got %v\", err)\n \t}\n-\tif _, err := buf.Peek(32); err != ErrBufferFull {\n-\t\tt.Fatalf(\"want ErrBufFull got %v\", err)\n+\tif s, err := buf.Peek(32); string(s) != \"abcdefghijklmnop\" || err != ErrBufferFull {\n+\t\tt.Fatalf(\"want %q, ErrBufFull got %q, err=%v\", \"abcdefghijklmnop\", string(s), err)\n \t}\n \tif _, err := buf.Read(p[0:3]); string(p[0:3]) != \"abc\" || err != nil {\n \t\tt.Fatalf(\"want %q got %q, err=%v\", \"abc\", string(p[0:3]), err)\n@@ -1475,7 +1475,7 @@ func BenchmarkReaderWriteToOptimal(b *testing.B) {\n \t\tb.Fatal(\"ioutil.Discard doesn't support ReaderFrom\")\n \t}\n \tfor i := 0; i < b.N; i++ {\n-\t\tr.Seek(0, 0)\n+\t\tr.Seek(0, io.SeekStart)\n \t\tsrcReader.Reset(onlyReader{r})\n \t\tn, err := srcReader.WriteTo(ioutil.Discard)\n \t\tif err != nil {"}, {"sha": "1bb1e8839325eee0b50c50b9f6e9d4244b30a391", "filename": "libgo/go/bufio/scan_test.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbufio%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -264,10 +264,6 @@ func testNoNewline(text string, lines []string, t *testing.T) {\n \t}\n }\n \n-var noNewlineLines = []string{\n-\t\"abcdefghijklmn\\nopqrstuvwxyz\",\n-}\n-\n // Test that the line splitter handles a final line without a newline.\n func TestScanLineNoNewline(t *testing.T) {\n \tconst text = \"abcdefghijklmn\\nopqrstuvwxyz\"\n@@ -351,7 +347,7 @@ func TestSplitError(t *testing.T) {\n // Test that an EOF is overridden by a user-generated scan error.\n func TestErrAtEOF(t *testing.T) {\n \ts := NewScanner(strings.NewReader(\"1 2 33\"))\n-\t// This spitter will fail on last entry, after s.err==EOF.\n+\t// This splitter will fail on last entry, after s.err==EOF.\n \tsplit := func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n \t\tadvance, token, err = ScanWords(data, atEOF)\n \t\tif len(token) > 1 {"}, {"sha": "9154a1b954597486dafc5192f23cd271b8ed9c57", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -17,8 +17,8 @@ import (\n type Buffer struct {\n \tbuf       []byte            // contents are the bytes buf[off : len(buf)]\n \toff       int               // read at &buf[off], write at &buf[len(buf)]\n-\truneBytes [utf8.UTFMax]byte // avoid allocation of slice on each WriteByte or Rune\n-\tbootstrap [64]byte          // memory to hold first slice; helps small buffers (Printf) avoid allocation.\n+\truneBytes [utf8.UTFMax]byte // avoid allocation of slice on each call to WriteRune\n+\tbootstrap [64]byte          // memory to hold first slice; helps small buffers avoid allocation.\n \tlastRead  readOp            // last read operation, so that Unread* can work correctly.\n }\n \n@@ -44,7 +44,7 @@ var ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\n func (b *Buffer) Bytes() []byte { return b.buf[b.off:] }\n \n // String returns the contents of the unread portion of the buffer\n-// as a string.  If the Buffer is a nil pointer, it returns \"<nil>\".\n+// as a string. If the Buffer is a nil pointer, it returns \"<nil>\".\n func (b *Buffer) String() string {\n \tif b == nil {\n \t\t// Special case, useful in debugging.\n@@ -145,7 +145,7 @@ func (b *Buffer) WriteString(s string) (n int, err error) {\n }\n \n // MinRead is the minimum slice size passed to a Read call by\n-// Buffer.ReadFrom.  As long as the Buffer has at least MinRead bytes beyond\n+// Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond\n // what is required to hold the contents of r, ReadFrom will not grow the\n // underlying buffer.\n const MinRead = 512\n@@ -252,7 +252,7 @@ func (b *Buffer) WriteRune(r rune) (n int, err error) {\n }\n \n // Read reads the next len(p) bytes from the buffer or until the buffer\n-// is drained.  The return value n is the number of bytes read.  If the\n+// is drained. The return value n is the number of bytes read. If the\n // buffer has no data to return, err is io.EOF (unless len(p) is zero);\n // otherwise it is nil.\n func (b *Buffer) Read(p []byte) (n int, err error) {\n@@ -293,14 +293,14 @@ func (b *Buffer) Next(n int) []byte {\n \n // ReadByte reads and returns the next byte from the buffer.\n // If no byte is available, it returns error io.EOF.\n-func (b *Buffer) ReadByte() (c byte, err error) {\n+func (b *Buffer) ReadByte() (byte, error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n \t\treturn 0, io.EOF\n \t}\n-\tc = b.buf[b.off]\n+\tc := b.buf[b.off]\n \tb.off++\n \tb.lastRead = opRead\n \treturn c, nil\n@@ -347,7 +347,7 @@ func (b *Buffer) UnreadRune() error {\n }\n \n // UnreadByte unreads the last byte returned by the most recent\n-// read operation.  If write has happened since the last read, UnreadByte\n+// read operation. If write has happened since the last read, UnreadByte\n // returns an error.\n func (b *Buffer) UnreadByte() error {\n \tif b.lastRead != opReadRune && b.lastRead != opRead {\n@@ -400,7 +400,7 @@ func (b *Buffer) ReadString(delim byte) (line string, err error) {\n }\n \n // NewBuffer creates and initializes a new Buffer using buf as its initial\n-// contents.  It is intended to prepare a Buffer to read existing data.  It\n+// contents. It is intended to prepare a Buffer to read existing data. It\n // can also be used to size the internal buffer for writing. To do that,\n // buf should have the desired capacity but a length of zero.\n //"}, {"sha": "305c85d9f412fcb449272653c6931eb86af81e16", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -83,6 +83,16 @@ func Contains(b, subslice []byte) bool {\n \treturn Index(b, subslice) != -1\n }\n \n+// ContainsAny reports whether any of the UTF-8-encoded Unicode code points in chars are within b.\n+func ContainsAny(b []byte, chars string) bool {\n+\treturn IndexAny(b, chars) >= 0\n+}\n+\n+// ContainsRune reports whether the Unicode code point r is within b.\n+func ContainsRune(b []byte, r rune) bool {\n+\treturn IndexRune(b, r) >= 0\n+}\n+\n // Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n func Index(s, sep []byte) int {\n \tn := len(sep)\n@@ -164,7 +174,7 @@ func IndexRune(s []byte, r rune) int {\n \n // IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index of the first occurrence in s of any of the Unicode\n-// code points in chars.  It returns -1 if chars is empty or if there is no code\n+// code points in chars. It returns -1 if chars is empty or if there is no code\n // point in common.\n func IndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n@@ -188,8 +198,8 @@ func IndexAny(s []byte, chars string) int {\n }\n \n // LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\n-// points.  It returns the byte index of the last occurrence in s of any of\n-// the Unicode code points in chars.  It returns -1 if chars is empty or if\n+// points. It returns the byte index of the last occurrence in s of any of\n+// the Unicode code points in chars. It returns -1 if chars is empty or if\n // there is no code point in common.\n func LastIndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n@@ -276,7 +286,7 @@ func Fields(s []byte) [][]byte {\n \n // FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It splits the slice s at each run of code points c satisfying f(c) and\n-// returns a slice of subslices of s.  If all code points in s satisfy f(c), or\n+// returns a slice of subslices of s. If all code points in s satisfy f(c), or\n // len(s) == 0, an empty slice is returned.\n // FieldsFunc makes no guarantees about the order in which it calls f(c).\n // If f does not return consistent results for a given c, FieldsFunc may crash.\n@@ -352,12 +362,12 @@ func HasSuffix(s, suffix []byte) bool {\n \n // Map returns a copy of the byte slice s with all its characters modified\n // according to the mapping function. If mapping returns a negative value, the character is\n-// dropped from the string with no replacement.  The characters in s and the\n+// dropped from the string with no replacement. The characters in s and the\n // output are interpreted as UTF-8-encoded Unicode code points.\n func Map(mapping func(r rune) rune, s []byte) []byte {\n \t// In the worst case, the slice can grow when mapped, making\n-\t// things unpleasant.  But it's so rare we barge in assuming it's\n-\t// fine.  It could also shrink but that falls out naturally.\n+\t// things unpleasant. But it's so rare we barge in assuming it's\n+\t// fine. It could also shrink but that falls out naturally.\n \tmaxbytes := len(s) // length of b\n \tnbytes := 0        // number of bytes encoded in b\n \tb := make([]byte, maxbytes)\n@@ -697,7 +707,7 @@ func EqualFold(s, t []byte) bool {\n \t\t\treturn false\n \t\t}\n \n-\t\t// General case.  SimpleFold(x) returns the next equivalent rune > x\n+\t\t// General case. SimpleFold(x) returns the next equivalent rune > x\n \t\t// or wraps around to smaller values.\n \t\tr := unicode.SimpleFold(sr)\n \t\tfor r != sr && r < tr {\n@@ -709,6 +719,6 @@ func EqualFold(s, t []byte) bool {\n \t\treturn false\n \t}\n \n-\t// One string is empty.  Are both?\n+\t// One string is empty. Are both?\n \treturn len(s) == len(t)\n }"}, {"sha": "df0614fed0df019de85f7dcaca42f59c64e39429", "filename": "libgo/go/bytes/bytes_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_decl.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "c48f662e10d595341b5d413f1fe3aae38f8a2ffb", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 233, "deletions": 194, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"fmt\"\n \t\"math/rand\"\n \t\"reflect\"\n \t\"testing\"\n@@ -47,32 +48,6 @@ type BinOpTest struct {\n \ti int\n }\n \n-var equalTests = []struct {\n-\ta, b []byte\n-\ti    int\n-}{\n-\t{[]byte(\"\"), []byte(\"\"), 0},\n-\t{[]byte(\"a\"), []byte(\"\"), 1},\n-\t{[]byte(\"\"), []byte(\"a\"), -1},\n-\t{[]byte(\"abc\"), []byte(\"abc\"), 0},\n-\t{[]byte(\"ab\"), []byte(\"abc\"), -1},\n-\t{[]byte(\"abc\"), []byte(\"ab\"), 1},\n-\t{[]byte(\"x\"), []byte(\"ab\"), 1},\n-\t{[]byte(\"ab\"), []byte(\"x\"), -1},\n-\t{[]byte(\"x\"), []byte(\"a\"), 1},\n-\t{[]byte(\"b\"), []byte(\"x\"), -1},\n-\t// test runtime\u00b7memeq's chunked implementation\n-\t{[]byte(\"abcdefgh\"), []byte(\"abcdefgh\"), 0},\n-\t{[]byte(\"abcdefghi\"), []byte(\"abcdefghi\"), 0},\n-\t{[]byte(\"abcdefghi\"), []byte(\"abcdefghj\"), -1},\n-\t// nil tests\n-\t{nil, nil, 0},\n-\t{[]byte(\"\"), nil, 0},\n-\t{nil, []byte(\"\"), 0},\n-\t{[]byte(\"a\"), nil, 1},\n-\t{nil, []byte(\"a\"), -1},\n-}\n-\n func TestEqual(t *testing.T) {\n \tfor _, tt := range compareTests {\n \t\teql := Equal(tt.a, tt.b)\n@@ -113,7 +88,7 @@ func TestEqualExhaustive(t *testing.T) {\n \t}\n }\n \n-// make sure Equal returns false for minimally different strings.  The data\n+// make sure Equal returns false for minimally different strings. The data\n // is all zeros except for a single one in one location.\n func TestNotEqual(t *testing.T) {\n \tvar size = 128\n@@ -335,6 +310,41 @@ func TestIndexByteBig(t *testing.T) {\n \t}\n }\n \n+// test a small index across all page offsets\n+func TestIndexByteSmall(t *testing.T) {\n+\tb := make([]byte, 5015) // bigger than a page\n+\t// Make sure we find the correct byte even when straddling a page.\n+\tfor i := 0; i <= len(b)-15; i++ {\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tb[i+j] = byte(100 + j)\n+\t\t}\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tp := IndexByte(b[i:i+15], byte(100+j))\n+\t\t\tif p != j {\n+\t\t\t\tt.Errorf(\"IndexByte(%q, %d) = %d\", b[i:i+15], 100+j, p)\n+\t\t\t}\n+\t\t}\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tb[i+j] = 0\n+\t\t}\n+\t}\n+\t// Make sure matches outside the slice never trigger.\n+\tfor i := 0; i <= len(b)-15; i++ {\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tb[i+j] = 1\n+\t\t}\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tp := IndexByte(b[i:i+15], byte(0))\n+\t\t\tif p != -1 {\n+\t\t\t\tt.Errorf(\"IndexByte(%q, %d) = %d\", b[i:i+15], 0, p)\n+\t\t\t}\n+\t\t}\n+\t\tfor j := 0; j < 15; j++ {\n+\t\t\tb[i+j] = 0\n+\t\t}\n+\t}\n+}\n+\n func TestIndexRune(t *testing.T) {\n \tfor _, tt := range indexRuneTests {\n \t\ta := []byte(tt.a)\n@@ -348,165 +358,152 @@ func TestIndexRune(t *testing.T) {\n \n var bmbuf []byte\n \n-func BenchmarkIndexByte32(b *testing.B)          { bmIndexByte(b, IndexByte, 32) }\n-func BenchmarkIndexByte4K(b *testing.B)          { bmIndexByte(b, IndexByte, 4<<10) }\n-func BenchmarkIndexByte4M(b *testing.B)          { bmIndexByte(b, IndexByte, 4<<20) }\n-func BenchmarkIndexByte64M(b *testing.B)         { bmIndexByte(b, IndexByte, 64<<20) }\n-func BenchmarkIndexBytePortable32(b *testing.B)  { bmIndexByte(b, IndexBytePortable, 32) }\n-func BenchmarkIndexBytePortable4K(b *testing.B)  { bmIndexByte(b, IndexBytePortable, 4<<10) }\n-func BenchmarkIndexBytePortable4M(b *testing.B)  { bmIndexByte(b, IndexBytePortable, 4<<20) }\n-func BenchmarkIndexBytePortable64M(b *testing.B) { bmIndexByte(b, IndexBytePortable, 64<<20) }\n-\n-func bmIndexByte(b *testing.B, index func([]byte, byte) int, n int) {\n-\tif len(bmbuf) < n {\n-\t\tbmbuf = make([]byte, n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf := bmbuf[0:n]\n-\tbuf[n-1] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\tj := index(buf, 'x')\n-\t\tif j != n-1 {\n-\t\t\tb.Fatal(\"bad index\", j)\n-\t\t}\n+func valName(x int) string {\n+\tif s := x >> 20; s<<20 == x {\n+\t\treturn fmt.Sprintf(\"%dM\", s)\n+\t}\n+\tif s := x >> 10; s<<10 == x {\n+\t\treturn fmt.Sprintf(\"%dK\", s)\n \t}\n-\tbuf[n-1] = '\\x00'\n+\treturn fmt.Sprint(x)\n }\n \n-func BenchmarkEqual0(b *testing.B) {\n-\tvar buf [4]byte\n-\tbuf1 := buf[0:0]\n-\tbuf2 := buf[1:1]\n-\tfor i := 0; i < b.N; i++ {\n-\t\teq := Equal(buf1, buf2)\n-\t\tif !eq {\n-\t\t\tb.Fatal(\"bad equal\")\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkEqual1(b *testing.B)           { bmEqual(b, Equal, 1) }\n-func BenchmarkEqual6(b *testing.B)           { bmEqual(b, Equal, 6) }\n-func BenchmarkEqual9(b *testing.B)           { bmEqual(b, Equal, 9) }\n-func BenchmarkEqual15(b *testing.B)          { bmEqual(b, Equal, 15) }\n-func BenchmarkEqual16(b *testing.B)          { bmEqual(b, Equal, 16) }\n-func BenchmarkEqual20(b *testing.B)          { bmEqual(b, Equal, 20) }\n-func BenchmarkEqual32(b *testing.B)          { bmEqual(b, Equal, 32) }\n-func BenchmarkEqual4K(b *testing.B)          { bmEqual(b, Equal, 4<<10) }\n-func BenchmarkEqual4M(b *testing.B)          { bmEqual(b, Equal, 4<<20) }\n-func BenchmarkEqual64M(b *testing.B)         { bmEqual(b, Equal, 64<<20) }\n-func BenchmarkEqualPort1(b *testing.B)       { bmEqual(b, EqualPortable, 1) }\n-func BenchmarkEqualPort6(b *testing.B)       { bmEqual(b, EqualPortable, 6) }\n-func BenchmarkEqualPort32(b *testing.B)      { bmEqual(b, EqualPortable, 32) }\n-func BenchmarkEqualPort4K(b *testing.B)      { bmEqual(b, EqualPortable, 4<<10) }\n-func BenchmarkEqualPortable4M(b *testing.B)  { bmEqual(b, EqualPortable, 4<<20) }\n-func BenchmarkEqualPortable64M(b *testing.B) { bmEqual(b, EqualPortable, 64<<20) }\n-\n-func bmEqual(b *testing.B, equal func([]byte, []byte) bool, n int) {\n-\tif len(bmbuf) < 2*n {\n-\t\tbmbuf = make([]byte, 2*n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf1 := bmbuf[0:n]\n-\tbuf2 := bmbuf[n : 2*n]\n-\tbuf1[n-1] = 'x'\n-\tbuf2[n-1] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\teq := equal(buf1, buf2)\n-\t\tif !eq {\n-\t\t\tb.Fatal(\"bad equal\")\n-\t\t}\n+func benchBytes(b *testing.B, sizes []int, f func(b *testing.B, n int)) {\n+\tfor _, n := range sizes {\n+\t\tb.Run(valName(n), func(b *testing.B) {\n+\t\t\tif len(bmbuf) < n {\n+\t\t\t\tbmbuf = make([]byte, n)\n+\t\t\t}\n+\t\t\tb.SetBytes(int64(n))\n+\t\t\tf(b, n)\n+\t\t})\n \t}\n-\tbuf1[n-1] = '\\x00'\n-\tbuf2[n-1] = '\\x00'\n }\n \n-func BenchmarkIndex32(b *testing.B)  { bmIndex(b, Index, 32) }\n-func BenchmarkIndex4K(b *testing.B)  { bmIndex(b, Index, 4<<10) }\n-func BenchmarkIndex4M(b *testing.B)  { bmIndex(b, Index, 4<<20) }\n-func BenchmarkIndex64M(b *testing.B) { bmIndex(b, Index, 64<<20) }\n+var indexSizes = []int{10, 32, 4 << 10, 4 << 20, 64 << 20}\n \n-func bmIndex(b *testing.B, index func([]byte, []byte) int, n int) {\n-\tif len(bmbuf) < n {\n-\t\tbmbuf = make([]byte, n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf := bmbuf[0:n]\n-\tbuf[n-1] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\tj := index(buf, buf[n-7:])\n-\t\tif j != n-7 {\n-\t\t\tb.Fatal(\"bad index\", j)\n-\t\t}\n-\t}\n-\tbuf[n-1] = '\\x00'\n+func BenchmarkIndexByte(b *testing.B) {\n+\tbenchBytes(b, indexSizes, bmIndexByte(IndexByte))\n }\n \n-func BenchmarkIndexEasy32(b *testing.B)  { bmIndexEasy(b, Index, 32) }\n-func BenchmarkIndexEasy4K(b *testing.B)  { bmIndexEasy(b, Index, 4<<10) }\n-func BenchmarkIndexEasy4M(b *testing.B)  { bmIndexEasy(b, Index, 4<<20) }\n-func BenchmarkIndexEasy64M(b *testing.B) { bmIndexEasy(b, Index, 64<<20) }\n+func BenchmarkIndexBytePortable(b *testing.B) {\n+\tbenchBytes(b, indexSizes, bmIndexByte(IndexBytePortable))\n+}\n \n-func bmIndexEasy(b *testing.B, index func([]byte, []byte) int, n int) {\n-\tif len(bmbuf) < n {\n-\t\tbmbuf = make([]byte, n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf := bmbuf[0:n]\n-\tbuf[n-1] = 'x'\n-\tbuf[n-7] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\tj := index(buf, buf[n-7:])\n-\t\tif j != n-7 {\n-\t\t\tb.Fatal(\"bad index\", j)\n+func bmIndexByte(index func([]byte, byte) int) func(b *testing.B, n int) {\n+\treturn func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := index(buf, 'x')\n+\t\t\tif j != n-1 {\n+\t\t\t\tb.Fatal(\"bad index\", j)\n+\t\t\t}\n \t\t}\n+\t\tbuf[n-1] = '\\x00'\n \t}\n-\tbuf[n-1] = '\\x00'\n-\tbuf[n-7] = '\\x00'\n }\n \n-func BenchmarkCount32(b *testing.B)  { bmCount(b, Count, 32) }\n-func BenchmarkCount4K(b *testing.B)  { bmCount(b, Count, 4<<10) }\n-func BenchmarkCount4M(b *testing.B)  { bmCount(b, Count, 4<<20) }\n-func BenchmarkCount64M(b *testing.B) { bmCount(b, Count, 64<<20) }\n-\n-func bmCount(b *testing.B, count func([]byte, []byte) int, n int) {\n-\tif len(bmbuf) < n {\n-\t\tbmbuf = make([]byte, n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf := bmbuf[0:n]\n-\tbuf[n-1] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\tj := count(buf, buf[n-7:])\n-\t\tif j != 1 {\n-\t\t\tb.Fatal(\"bad count\", j)\n+func BenchmarkEqual(b *testing.B) {\n+\tb.Run(\"0\", func(b *testing.B) {\n+\t\tvar buf [4]byte\n+\t\tbuf1 := buf[0:0]\n+\t\tbuf2 := buf[1:1]\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\teq := Equal(buf1, buf2)\n+\t\t\tif !eq {\n+\t\t\t\tb.Fatal(\"bad equal\")\n+\t\t\t}\n \t\t}\n-\t}\n-\tbuf[n-1] = '\\x00'\n+\t})\n+\n+\tsizes := []int{1, 6, 9, 15, 16, 20, 32, 4 << 10, 4 << 20, 64 << 20}\n+\tbenchBytes(b, sizes, bmEqual(Equal))\n }\n \n-func BenchmarkCountEasy32(b *testing.B)  { bmCountEasy(b, Count, 32) }\n-func BenchmarkCountEasy4K(b *testing.B)  { bmCountEasy(b, Count, 4<<10) }\n-func BenchmarkCountEasy4M(b *testing.B)  { bmCountEasy(b, Count, 4<<20) }\n-func BenchmarkCountEasy64M(b *testing.B) { bmCountEasy(b, Count, 64<<20) }\n+func BenchmarkEqualPort(b *testing.B) {\n+\tsizes := []int{1, 6, 32, 4 << 10, 4 << 20, 64 << 20}\n+\tbenchBytes(b, sizes, bmEqual(EqualPortable))\n+}\n \n-func bmCountEasy(b *testing.B, count func([]byte, []byte) int, n int) {\n-\tif len(bmbuf) < n {\n-\t\tbmbuf = make([]byte, n)\n-\t}\n-\tb.SetBytes(int64(n))\n-\tbuf := bmbuf[0:n]\n-\tbuf[n-1] = 'x'\n-\tbuf[n-7] = 'x'\n-\tfor i := 0; i < b.N; i++ {\n-\t\tj := count(buf, buf[n-7:])\n-\t\tif j != 1 {\n-\t\t\tb.Fatal(\"bad count\", j)\n+func bmEqual(equal func([]byte, []byte) bool) func(b *testing.B, n int) {\n+\treturn func(b *testing.B, n int) {\n+\t\tif len(bmbuf) < 2*n {\n+\t\t\tbmbuf = make([]byte, 2*n)\n+\t\t}\n+\t\tbuf1 := bmbuf[0:n]\n+\t\tbuf2 := bmbuf[n : 2*n]\n+\t\tbuf1[n-1] = 'x'\n+\t\tbuf2[n-1] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\teq := equal(buf1, buf2)\n+\t\t\tif !eq {\n+\t\t\t\tb.Fatal(\"bad equal\")\n+\t\t\t}\n \t\t}\n+\t\tbuf1[n-1] = '\\x00'\n+\t\tbuf2[n-1] = '\\x00'\n \t}\n-\tbuf[n-1] = '\\x00'\n-\tbuf[n-7] = '\\x00'\n+}\n+\n+func BenchmarkIndex(b *testing.B) {\n+\tbenchBytes(b, indexSizes, func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := Index(buf, buf[n-7:])\n+\t\t\tif j != n-7 {\n+\t\t\t\tb.Fatal(\"bad index\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-1] = '\\x00'\n+\t})\n+}\n+\n+func BenchmarkIndexEasy(b *testing.B) {\n+\tbenchBytes(b, indexSizes, func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tbuf[n-7] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := Index(buf, buf[n-7:])\n+\t\t\tif j != n-7 {\n+\t\t\t\tb.Fatal(\"bad index\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-1] = '\\x00'\n+\t\tbuf[n-7] = '\\x00'\n+\t})\n+}\n+\n+func BenchmarkCount(b *testing.B) {\n+\tbenchBytes(b, indexSizes, func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := Count(buf, buf[n-7:])\n+\t\t\tif j != 1 {\n+\t\t\t\tb.Fatal(\"bad count\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-1] = '\\x00'\n+\t})\n+}\n+\n+func BenchmarkCountEasy(b *testing.B) {\n+\tbenchBytes(b, indexSizes, func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tbuf[n-1] = 'x'\n+\t\tbuf[n-7] = 'x'\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := Count(buf, buf[n-7:])\n+\t\t\tif j != 1 {\n+\t\t\t\tb.Fatal(\"bad count\", j)\n+\t\t\t}\n+\t\t}\n+\t\tbuf[n-1] = '\\x00'\n+\t\tbuf[n-7] = '\\x00'\n+\t})\n }\n \n type ExplodeTest struct {\n@@ -760,7 +757,7 @@ func TestMap(t *testing.T) {\n \t// Run a couple of awful growth/shrinkage tests\n \ta := tenRunes('a')\n \n-\t// 1.  Grow.  This triggers two reallocations in Map.\n+\t// 1.  Grow. This triggers two reallocations in Map.\n \tmaxRune := func(r rune) rune { return unicode.MaxRune }\n \tm := Map(maxRune, []byte(a))\n \texpect := tenRunes(unicode.MaxRune)\n@@ -1207,6 +1204,57 @@ func TestContains(t *testing.T) {\n \t}\n }\n \n+var ContainsAnyTests = []struct {\n+\tb        []byte\n+\tsubstr   string\n+\texpected bool\n+}{\n+\t{[]byte(\"\"), \"\", false},\n+\t{[]byte(\"\"), \"a\", false},\n+\t{[]byte(\"\"), \"abc\", false},\n+\t{[]byte(\"a\"), \"\", false},\n+\t{[]byte(\"a\"), \"a\", true},\n+\t{[]byte(\"aaa\"), \"a\", true},\n+\t{[]byte(\"abc\"), \"xyz\", false},\n+\t{[]byte(\"abc\"), \"xcz\", true},\n+\t{[]byte(\"a\u263ab\u263bc\u2639d\"), \"uvw\u263bxyz\", true},\n+\t{[]byte(\"aRegExp*\"), \".(|)*+?^$[]\", true},\n+\t{[]byte(dots + dots + dots), \" \", false},\n+}\n+\n+func TestContainsAny(t *testing.T) {\n+\tfor _, ct := range ContainsAnyTests {\n+\t\tif ContainsAny(ct.b, ct.substr) != ct.expected {\n+\t\t\tt.Errorf(\"ContainsAny(%s, %s) = %v, want %v\",\n+\t\t\t\tct.b, ct.substr, !ct.expected, ct.expected)\n+\t\t}\n+\t}\n+}\n+\n+var ContainsRuneTests = []struct {\n+\tb        []byte\n+\tr        rune\n+\texpected bool\n+}{\n+\t{[]byte(\"\"), 'a', false},\n+\t{[]byte(\"a\"), 'a', true},\n+\t{[]byte(\"aaa\"), 'a', true},\n+\t{[]byte(\"abc\"), 'y', false},\n+\t{[]byte(\"abc\"), 'c', true},\n+\t{[]byte(\"a\u263ab\u263bc\u2639d\"), 'x', false},\n+\t{[]byte(\"a\u263ab\u263bc\u2639d\"), '\u263b', true},\n+\t{[]byte(\"aRegExp*\"), '*', true},\n+}\n+\n+func TestContainsRune(t *testing.T) {\n+\tfor _, ct := range ContainsRuneTests {\n+\t\tif ContainsRune(ct.b, ct.r) != ct.expected {\n+\t\t\tt.Errorf(\"ContainsRune(%q, %q) = %v, want %v\",\n+\t\t\t\tct.b, ct.r, !ct.expected, ct.expected)\n+\t\t}\n+\t}\n+}\n+\n var makeFieldsInput = func() []byte {\n \tx := make([]byte, 1<<20)\n \t// Input is ~10% space, ~10% 2-byte UTF-8, rest ASCII non-space.\n@@ -1256,33 +1304,24 @@ func BenchmarkRepeat(b *testing.B) {\n \t}\n }\n \n-func benchmarkBytesCompare(b *testing.B, n int) {\n-\tvar x = make([]byte, n)\n-\tvar y = make([]byte, n)\n+func BenchmarkBytesCompare(b *testing.B) {\n+\tfor n := 1; n <= 2048; n <<= 1 {\n+\t\tb.Run(fmt.Sprint(n), func(b *testing.B) {\n+\t\t\tvar x = make([]byte, n)\n+\t\t\tvar y = make([]byte, n)\n \n-\tfor i := 0; i < n; i++ {\n-\t\tx[i] = 'a'\n-\t}\n+\t\t\tfor i := 0; i < n; i++ {\n+\t\t\t\tx[i] = 'a'\n+\t\t\t}\n \n-\tfor i := 0; i < n; i++ {\n-\t\ty[i] = 'a'\n-\t}\n+\t\t\tfor i := 0; i < n; i++ {\n+\t\t\t\ty[i] = 'a'\n+\t\t\t}\n \n-\tb.ResetTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tCompare(x, y)\n-\t}\n-}\n-\n-func BenchmarkBytesCompare1(b *testing.B)    { benchmarkBytesCompare(b, 1) }\n-func BenchmarkBytesCompare2(b *testing.B)    { benchmarkBytesCompare(b, 2) }\n-func BenchmarkBytesCompare4(b *testing.B)    { benchmarkBytesCompare(b, 4) }\n-func BenchmarkBytesCompare8(b *testing.B)    { benchmarkBytesCompare(b, 8) }\n-func BenchmarkBytesCompare16(b *testing.B)   { benchmarkBytesCompare(b, 16) }\n-func BenchmarkBytesCompare32(b *testing.B)   { benchmarkBytesCompare(b, 32) }\n-func BenchmarkBytesCompare64(b *testing.B)   { benchmarkBytesCompare(b, 64) }\n-func BenchmarkBytesCompare128(b *testing.B)  { benchmarkBytesCompare(b, 128) }\n-func BenchmarkBytesCompare256(b *testing.B)  { benchmarkBytesCompare(b, 256) }\n-func BenchmarkBytesCompare512(b *testing.B)  { benchmarkBytesCompare(b, 512) }\n-func BenchmarkBytesCompare1024(b *testing.B) { benchmarkBytesCompare(b, 1024) }\n-func BenchmarkBytesCompare2048(b *testing.B) { benchmarkBytesCompare(b, 2048) }\n+\t\t\tb.ResetTimer()\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tCompare(x, y)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "35088a1b2e9b26691a6f0a0bed6611e0bb6b563e", "filename": "libgo/go/bytes/compare_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -62,7 +62,7 @@ func TestCompareBytes(t *testing.T) {\n \ta := make([]byte, n+1)\n \tb := make([]byte, n+1)\n \tfor len := 0; len < 128; len++ {\n-\t\t// randomish but deterministic data.  No 0 or 255.\n+\t\t// randomish but deterministic data. No 0 or 255.\n \t\tfor i := 0; i < len; i++ {\n \t\t\ta[i] = byte(1 + 31*i%254)\n \t\t\tb[i] = byte(1 + 31*i%254)"}, {"sha": "9fdead8a6040a968104da61755edced2775a40de", "filename": "libgo/go/bytes/equal_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fequal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Fequal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fequal_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -14,11 +14,11 @@ import (\n )\n \n // This file tests the situation where memeq is checking\n-// data very near to a page boundary.  We want to make sure\n+// data very near to a page boundary. We want to make sure\n // equal does not read across the boundary and cause a page\n // fault where it shouldn't.\n \n-// This test runs only on linux.  The code being tested is\n+// This test runs only on linux. The code being tested is\n // not OS-specific, so it does not need to be tested on all\n // operating systems.\n "}, {"sha": "28cfc7a97884a7d448c585f6b6d866fcfe9c914d", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -36,9 +36,6 @@ func (r *Reader) Len() int {\n func (r *Reader) Size() int64 { return int64(len(r.s)) }\n \n func (r *Reader) Read(b []byte) (n int, err error) {\n-\tif len(b) == 0 {\n-\t\treturn 0, nil\n-\t}\n \tif r.i >= int64(len(r.s)) {\n \t\treturn 0, io.EOF\n \t}\n@@ -63,14 +60,14 @@ func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {\n \treturn\n }\n \n-func (r *Reader) ReadByte() (b byte, err error) {\n+func (r *Reader) ReadByte() (byte, error) {\n \tr.prevRune = -1\n \tif r.i >= int64(len(r.s)) {\n \t\treturn 0, io.EOF\n \t}\n-\tb = r.s[r.i]\n+\tb := r.s[r.i]\n \tr.i++\n-\treturn\n+\treturn b, nil\n }\n \n func (r *Reader) UnreadByte() error {\n@@ -111,11 +108,11 @@ func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n \tr.prevRune = -1\n \tvar abs int64\n \tswitch whence {\n-\tcase 0:\n+\tcase io.SeekStart:\n \t\tabs = offset\n-\tcase 1:\n-\t\tabs = int64(r.i) + offset\n-\tcase 2:\n+\tcase io.SeekCurrent:\n+\t\tabs = r.i + offset\n+\tcase io.SeekEnd:\n \t\tabs = int64(len(r.s)) + offset\n \tdefault:\n \t\treturn 0, errors.New(\"bytes.Reader.Seek: invalid whence\")\n@@ -146,5 +143,8 @@ func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \treturn\n }\n \n+// Reset resets the Reader to be reading from b.\n+func (r *Reader) Reset(b []byte) { *r = Reader{b, 0, -1} }\n+\n // NewReader returns a new Reader reading from b.\n func NewReader(b []byte) *Reader { return &Reader{b, 0, -1} }"}, {"sha": "7b3034d4e0d90cec3e8b001f38150a5f679e7e50", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"sync\"\n \t\"testing\"\n )\n@@ -22,17 +21,18 @@ func TestReader(t *testing.T) {\n \t\tn       int\n \t\twant    string\n \t\twantpos int64\n+\t\treaderr error\n \t\tseekerr string\n \t}{\n-\t\t{seek: os.SEEK_SET, off: 0, n: 20, want: \"0123456789\"},\n-\t\t{seek: os.SEEK_SET, off: 1, n: 1, want: \"1\"},\n-\t\t{seek: os.SEEK_CUR, off: 1, wantpos: 3, n: 2, want: \"34\"},\n-\t\t{seek: os.SEEK_SET, off: -1, seekerr: \"bytes.Reader.Seek: negative position\"},\n-\t\t{seek: os.SEEK_SET, off: 1 << 33, wantpos: 1 << 33},\n-\t\t{seek: os.SEEK_CUR, off: 1, wantpos: 1<<33 + 1},\n-\t\t{seek: os.SEEK_SET, n: 5, want: \"01234\"},\n-\t\t{seek: os.SEEK_CUR, n: 5, want: \"56789\"},\n-\t\t{seek: os.SEEK_END, off: -1, n: 1, wantpos: 9, want: \"9\"},\n+\t\t{seek: io.SeekStart, off: 0, n: 20, want: \"0123456789\"},\n+\t\t{seek: io.SeekStart, off: 1, n: 1, want: \"1\"},\n+\t\t{seek: io.SeekCurrent, off: 1, wantpos: 3, n: 2, want: \"34\"},\n+\t\t{seek: io.SeekStart, off: -1, seekerr: \"bytes.Reader.Seek: negative position\"},\n+\t\t{seek: io.SeekStart, off: 1 << 33, wantpos: 1 << 33, readerr: io.EOF},\n+\t\t{seek: io.SeekCurrent, off: 1, wantpos: 1<<33 + 1, readerr: io.EOF},\n+\t\t{seek: io.SeekStart, n: 5, want: \"01234\"},\n+\t\t{seek: io.SeekCurrent, n: 5, want: \"56789\"},\n+\t\t{seek: io.SeekEnd, off: -1, n: 1, wantpos: 9, want: \"9\"},\n \t}\n \n \tfor i, tt := range tests {\n@@ -50,8 +50,8 @@ func TestReader(t *testing.T) {\n \t\t}\n \t\tbuf := make([]byte, tt.n)\n \t\tn, err := r.Read(buf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%d. read = %v\", i, err)\n+\t\tif err != tt.readerr {\n+\t\t\tt.Errorf(\"%d. read = %v; want %v\", i, err, tt.readerr)\n \t\t\tcontinue\n \t\t}\n \t\tgot := string(buf[:n])\n@@ -63,7 +63,7 @@ func TestReader(t *testing.T) {\n \n func TestReadAfterBigSeek(t *testing.T) {\n \tr := NewReader([]byte(\"0123456789\"))\n-\tif _, err := r.Seek(1<<31+5, os.SEEK_SET); err != nil {\n+\tif _, err := r.Seek(1<<31+5, io.SeekStart); err != nil {\n \t\tt.Fatal(err)\n \t}\n \tif n, err := r.Read(make([]byte, 10)); n != 0 || err != io.EOF {\n@@ -174,7 +174,7 @@ func TestReaderLen(t *testing.T) {\n \t\tt.Errorf(\"r.Len(): got %d, want %d\", got, want)\n \t}\n \tif n, err := r.Read(make([]byte, 1)); err != nil || n != 1 {\n-\t\tt.Errorf(\"Read failed: read %d %v\", n, err)\n+\t\tt.Errorf(\"Read failed: read %d %v; want 1, nil\", n, err)\n \t}\n \tif got, want := r.Len(), 0; got != want {\n \t\tt.Errorf(\"r.Len(): got %d, want %d\", got, want)\n@@ -188,7 +188,7 @@ var UnreadRuneErrorTests = []struct {\n \t{\"Read\", func(r *Reader) { r.Read([]byte{0}) }},\n \t{\"ReadByte\", func(r *Reader) { r.ReadByte() }},\n \t{\"UnreadRune\", func(r *Reader) { r.UnreadRune() }},\n-\t{\"Seek\", func(r *Reader) { r.Seek(0, 1) }},\n+\t{\"Seek\", func(r *Reader) { r.Seek(0, io.SeekCurrent) }},\n \t{\"WriteTo\", func(r *Reader) { r.WriteTo(&Buffer{}) }},\n }\n \n@@ -256,3 +256,23 @@ func TestReaderLenSize(t *testing.T) {\n \t\tt.Errorf(\"Size = %d; want 3\", r.Size())\n \t}\n }\n+\n+func TestReaderReset(t *testing.T) {\n+\tr := NewReader([]byte(\"\u4e16\u754c\"))\n+\tif _, _, err := r.ReadRune(); err != nil {\n+\t\tt.Errorf(\"ReadRune: unexpected error: %v\", err)\n+\t}\n+\n+\tconst want = \"abcdef\"\n+\tr.Reset([]byte(want))\n+\tif err := r.UnreadRune(); err == nil {\n+\t\tt.Errorf(\"UnreadRune: expected error, got nil\")\n+\t}\n+\tbuf, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Errorf(\"ReadAll: unexpected error: %v\", err)\n+\t}\n+\tif got := string(buf); got != want {\n+\t\tt.Errorf(\"ReadAll: got %q, want %q\", got, want)\n+\t}\n+}"}, {"sha": "000ecd446855c47b2befdd94783c6e6e5b88099b", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -40,7 +40,7 @@ func sourceLine(n ast.Node) int {\n }\n \n // ReadGo populates f with information learned from reading the\n-// Go source file with the given file name.  It gathers the C preamble\n+// Go source file with the given file name. It gathers the C preamble\n // attached to the import \"C\" comment, a list of references to C.xxx,\n // a list of exported functions, and the actual AST, to be rewritten and\n // printed.\n@@ -73,7 +73,7 @@ func (f *File) ReadGo(name string) {\n \t\t}\n \t\tfor _, spec := range d.Specs {\n \t\t\ts, ok := spec.(*ast.ImportSpec)\n-\t\t\tif !ok || string(s.Path.Value) != `\"C\"` {\n+\t\t\tif !ok || s.Path.Value != `\"C\"` {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tsawC = true\n@@ -106,7 +106,7 @@ func (f *File) ReadGo(name string) {\n \t\tws := 0\n \t\tfor _, spec := range d.Specs {\n \t\t\ts, ok := spec.(*ast.ImportSpec)\n-\t\t\tif !ok || string(s.Path.Value) != `\"C\"` {\n+\t\t\tif !ok || s.Path.Value != `\"C\"` {\n \t\t\t\td.Specs[ws] = spec\n \t\t\t\tws++\n \t\t\t}\n@@ -147,7 +147,7 @@ func commentText(g *ast.CommentGroup) string {\n \t}\n \tvar pieces []string\n \tfor _, com := range g.List {\n-\t\tc := string(com.Text)\n+\t\tc := com.Text\n \t\t// Remove comment markers.\n \t\t// The parser has given us exactly the comment text.\n \t\tswitch c[1] {\n@@ -172,7 +172,7 @@ func (f *File) saveExprs(x interface{}, context string) {\n \t\t\tf.saveRef(x, context)\n \t\t}\n \tcase *ast.CallExpr:\n-\t\tf.saveCall(x)\n+\t\tf.saveCall(x, context)\n \t}\n }\n \n@@ -220,15 +220,16 @@ func (f *File) saveRef(n *ast.Expr, context string) {\n }\n \n // Save calls to C.xxx for later processing.\n-func (f *File) saveCall(call *ast.CallExpr) {\n+func (f *File) saveCall(call *ast.CallExpr, context string) {\n \tsel, ok := call.Fun.(*ast.SelectorExpr)\n \tif !ok {\n \t\treturn\n \t}\n \tif l, ok := sel.X.(*ast.Ident); !ok || l.Name != \"C\" {\n \t\treturn\n \t}\n-\tf.Calls = append(f.Calls, call)\n+\tc := &Call{Call: call, Deferred: context == \"defer\"}\n+\tf.Calls = append(f.Calls, c)\n }\n \n // If a function should be exported add it to ExpFunc.\n@@ -242,11 +243,11 @@ func (f *File) saveExport(x interface{}, context string) {\n \t\treturn\n \t}\n \tfor _, c := range n.Doc.List {\n-\t\tif !strings.HasPrefix(string(c.Text), \"//export \") {\n+\t\tif !strings.HasPrefix(c.Text, \"//export \") {\n \t\t\tcontinue\n \t\t}\n \n-\t\tname := strings.TrimSpace(string(c.Text[9:]))\n+\t\tname := strings.TrimSpace(c.Text[9:])\n \t\tif name == \"\" {\n \t\t\terror_(c.Pos(), \"export missing name\")\n \t\t}\n@@ -401,7 +402,7 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \tcase *ast.GoStmt:\n \t\tf.walk(n.Call, \"expr\", visit)\n \tcase *ast.DeferStmt:\n-\t\tf.walk(n.Call, \"expr\", visit)\n+\t\tf.walk(n.Call, \"defer\", visit)\n \tcase *ast.ReturnStmt:\n \t\tf.walk(n.Results, \"expr\", visit)\n \tcase *ast.BranchStmt:\n@@ -447,7 +448,11 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \tcase *ast.ImportSpec:\n \tcase *ast.ValueSpec:\n \t\tf.walk(&n.Type, \"type\", visit)\n-\t\tf.walk(n.Values, \"expr\", visit)\n+\t\tif len(n.Names) == 2 && len(n.Values) == 1 {\n+\t\t\tf.walk(&n.Values[0], \"as2\", visit)\n+\t\t} else {\n+\t\t\tf.walk(n.Values, \"expr\", visit)\n+\t\t}\n \tcase *ast.TypeSpec:\n \t\tf.walk(&n.Type, \"type\", visit)\n "}, {"sha": "d3a7b6d2a7385447ff64bd538b7bfe4b8f9a486c", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -31,9 +31,9 @@ See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples.  See\n \"C? Go? Cgo!\" for an introduction to using cgo:\n https://golang.org/doc/articles/c_go_cgo.html.\n \n-CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS may be defined with pseudo #cgo\n-directives within these comments to tweak the behavior of the C or C++\n-compiler.  Values defined in multiple directives are concatenated\n+CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS and LDFLAGS may be defined with pseudo\n+#cgo directives within these comments to tweak the behavior of the C, C++\n+or Fortran compiler.  Values defined in multiple directives are concatenated\n together.  The directive can include a list of build constraints limiting its\n effect to systems satisfying one of the constraints\n (see https://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).\n@@ -53,7 +53,7 @@ For example:\n \t// #include <png.h>\n \timport \"C\"\n \n-When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS and\n+When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and\n CGO_LDFLAGS environment variables are added to the flags derived from\n these directives.  Package-specific flags should be set using the\n directives, not the environment variables, so that builds work in\n@@ -62,10 +62,11 @@ unmodified environments.\n All the cgo CPPFLAGS and CFLAGS directives in a package are concatenated and\n used to compile C files in that package.  All the CPPFLAGS and CXXFLAGS\n directives in a package are concatenated and used to compile C++ files in that\n-package.  All the LDFLAGS directives in any package in the program are\n-concatenated and used at link time.  All the pkg-config directives are\n-concatenated and sent to pkg-config simultaneously to add to each appropriate\n-set of command-line flags.\n+package.  All the CPPFLAGS and FFLAGS directives in a package are concatenated\n+and used to compile Fortran files in that package.  All the LDFLAGS directives\n+in any package in the program are concatenated and used at link time.  All the\n+pkg-config directives are concatenated and sent to pkg-config simultaneously\n+to add to each appropriate set of command-line flags.\n \n When the cgo directives are parsed, any occurrence of the string ${SRCDIR}\n will be replaced by the absolute path to the directory containing the source\n@@ -83,7 +84,8 @@ When the Go tool sees that one or more Go files use the special import\n \"C\", it will look for other non-Go files in the directory and compile\n them as part of the Go package.  Any .c, .s, or .S files will be\n compiled with the C compiler.  Any .cc, .cpp, or .cxx files will be\n-compiled with the C++ compiler.  Any .h, .hh, .hpp, or .hxx files will\n+compiled with the C++ compiler.  Any .f, .F, .for or .f90 files will be\n+compiled with the fortran compiler. Any .h, .hh, .hpp, or .hxx files will\n not be compiled separately, but, if these header files are changed,\n the C and C++ files will be recompiled.  The default C and C++\n compilers may be changed by the CC and CXX environment variables,\n@@ -133,7 +135,7 @@ C's union types are represented as a Go byte array with the same length.\n \n Go structs cannot embed fields with C types.\n \n-Go code can not refer to zero-sized fields that occur at the end of\n+Go code cannot refer to zero-sized fields that occur at the end of\n non-empty C structs.  To get the address of such a field (which is the\n only operation you can do with a zero-sized field) you must take the\n address of the struct and add the size of the struct.\n@@ -148,8 +150,9 @@ assignment context to retrieve both the return value (if any) and the\n C errno variable as an error (use _ to skip the result value if the\n function returns void).  For example:\n \n-\tn, err := C.sqrt(-1)\n+\tn, err = C.sqrt(-1)\n \t_, err := C.voidFunc()\n+\tvar n, err = C.sqrt(1)\n \n Calling C function pointers is currently not supported, however you can\n declare Go variables which hold C function pointers and pass them\n@@ -195,6 +198,13 @@ by making copies of the data.  In pseudo-Go definitions:\n \t// if C.free is needed).\n \tfunc C.CString(string) *C.char\n \n+\t// Go []byte slice to C array\n+\t// The C array is allocated in the C heap using malloc.\n+\t// It is the caller's responsibility to arrange for it to be\n+\t// freed, such as by calling C.free (be sure to include stdlib.h\n+\t// if C.free is needed).\n+\tfunc C.CBytes([]byte) unsafe.Pointer\n+\n \t// C string to Go string\n \tfunc C.GoString(*C.char) string\n \n@@ -501,7 +511,6 @@ file compiled by gcc, the file x.cgo2.c:\n \tvoid\n \t_cgo_be59f0f25121_Cfunc_puts(void *v)\n \t{\n-\t\t_cgo_wait_runtime_init_done();\n \t\tstruct {\n \t\t\tchar* p0;\n \t\t\tint r;\n@@ -510,8 +519,7 @@ file compiled by gcc, the file x.cgo2.c:\n \t\ta->r = puts((void*)a->p0);\n \t}\n \n-It waits for Go runtime to be initialized (required for shared libraries),\n-extracts the arguments from the pointer to _Cfunc_puts's argument\n+It extracts the arguments from the pointer to _Cfunc_puts's argument\n frame, invokes the system C function (in this case, puts), stores the\n result in the frame, and returns.\n \n@@ -529,8 +537,8 @@ linkage to the desired libraries. The main function is provided by\n _cgo_main.c:\n \n \tint main() { return 0; }\n-\tvoid crosscall2(void(*fn)(void*, int), void *a, int c) { }\n-\tvoid _cgo_wait_runtime_init_done() { }\n+\tvoid crosscall2(void(*fn)(void*, int, uintptr_t), void *a, int c, uintptr_t ctxt) { }\n+\tuintptr_t _cgo_wait_runtime_init_done() { }\n \tvoid _cgo_allocate(void *a, int c) { }\n \tvoid _cgo_panic(void *a, int c) { }\n "}, {"sha": "fc1d01100d2ad1dd7ddddc7c341b8d80fdadb315", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 182, "deletions": 74, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -83,7 +83,7 @@ func (f *File) DiscardCgoDirectives() {\n \tf.Preamble = strings.Join(linesOut, \"\\n\")\n }\n \n-// addToFlag appends args to flag.  All flags are later written out onto the\n+// addToFlag appends args to flag. All flags are later written out onto the\n // _cgo_flags file for the build system to use.\n func (p *Package) addToFlag(flag string, args []string) {\n \tp.CgoFlags[flag] = append(p.CgoFlags[flag], args...)\n@@ -99,7 +99,7 @@ func (p *Package) addToFlag(flag string, args []string) {\n // Single quotes and double quotes are recognized to prevent splitting within the\n // quoted region, and are removed from the resulting substrings. If a quote in s\n // isn't closed err will be set and r will have the unclosed argument as the\n-// last element.  The backslash is used for escaping.\n+// last element. The backslash is used for escaping.\n //\n // For example, the following string:\n //\n@@ -236,7 +236,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tif isConst {\n \t\t\t\tn.Kind = \"const\"\n \t\t\t\t// Turn decimal into hex, just for consistency\n-\t\t\t\t// with enum-derived constants.  Otherwise\n+\t\t\t\t// with enum-derived constants. Otherwise\n \t\t\t\t// in the cgo -godefs output half the constants\n \t\t\t\t// are in hex and half are in whatever the #define used.\n \t\t\t\ti, err := strconv.ParseInt(n.Define, 0, 64)\n@@ -385,7 +385,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \tif nerrors > 0 {\n \t\t// Check if compiling the preamble by itself causes any errors,\n \t\t// because the messages we've printed out so far aren't helpful\n-\t\t// to users debugging preamble mistakes.  See issue 8442.\n+\t\t// to users debugging preamble mistakes. See issue 8442.\n \t\tpreambleErrors := p.gccErrors([]byte(f.Preamble))\n \t\tif len(preambleErrors) > 0 {\n \t\t\terror_(token.NoPos, \"\\n%s errors for preamble:\\n%s\", p.gccBaseCmd()[0], preambleErrors)\n@@ -403,7 +403,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n // being referred to as C.xxx.\n func (p *Package) loadDWARF(f *File, names []*Name) {\n \t// Extract the types from the DWARF section of an object\n-\t// from a well-formed C program.  Gcc only generates DWARF info\n+\t// from a well-formed C program. Gcc only generates DWARF info\n \t// for symbols in the object file, so it is not enough to print the\n \t// preamble and hope the symbols we care about will be there.\n \t// Instead, emit\n@@ -421,7 +421,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t}\n \n \t// Apple's LLVM-based gcc does not include the enumeration\n-\t// names and values in its DWARF debug output.  In case we're\n+\t// names and values in its DWARF debug output. In case we're\n \t// using such a gcc, create a data block initialized with the values.\n \t// We can read them out of the object file.\n \tfmt.Fprintf(&b, \"long long __cgodebug_data[] = {\\n\")\n@@ -432,7 +432,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\tfmt.Fprintf(&b, \"\\t0,\\n\")\n \t\t}\n \t}\n-\t// for the last entry, we can not use 0, otherwise\n+\t// for the last entry, we cannot use 0, otherwise\n \t// in case all __cgodebug_data is zero initialized,\n \t// LLVM-based gcc will place the it in the __DATA.__common\n \t// zero-filled section (our debug/macho doesn't support\n@@ -581,7 +581,7 @@ func (p *Package) mangleName(n *Name) {\n func (p *Package) rewriteCalls(f *File) {\n \tfor _, call := range f.Calls {\n \t\t// This is a call to C.xxx; set goname to \"xxx\".\n-\t\tgoname := call.Fun.(*ast.SelectorExpr).Sel.Name\n+\t\tgoname := call.Call.Fun.(*ast.SelectorExpr).Sel.Name\n \t\tif goname == \"malloc\" {\n \t\t\tcontinue\n \t\t}\n@@ -594,39 +594,62 @@ func (p *Package) rewriteCalls(f *File) {\n \t}\n }\n \n-// rewriteCall rewrites one call to add pointer checks.  We replace\n+// rewriteCall rewrites one call to add pointer checks. We replace\n // each pointer argument x with _cgoCheckPointer(x).(T).\n-func (p *Package) rewriteCall(f *File, call *ast.CallExpr, name *Name) {\n+func (p *Package) rewriteCall(f *File, call *Call, name *Name) {\n+\t// Avoid a crash if the number of arguments is\n+\t// less than the number of parameters.\n+\t// This will be caught when the generated file is compiled.\n+\tif len(call.Call.Args) < len(name.FuncType.Params) {\n+\t\treturn\n+\t}\n+\n+\tany := false\n \tfor i, param := range name.FuncType.Params {\n-\t\tif len(call.Args) <= i {\n-\t\t\t// Avoid a crash; this will be caught when the\n-\t\t\t// generated file is compiled.\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// An untyped nil does not need a pointer check, and\n-\t\t// when _cgoCheckPointer returns the untyped nil the\n-\t\t// type assertion we are going to insert will fail.\n-\t\t// Easier to just skip nil arguments.\n-\t\t// TODO: Note that this fails if nil is shadowed.\n-\t\tif id, ok := call.Args[i].(*ast.Ident); ok && id.Name == \"nil\" {\n-\t\t\tcontinue\n+\t\tif p.needsPointerCheck(f, param.Go, call.Call.Args[i]) {\n+\t\t\tany = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif !any {\n+\t\treturn\n+\t}\n+\n+\t// We need to rewrite this call.\n+\t//\n+\t// We are going to rewrite C.f(p) to C.f(_cgoCheckPointer(p)).\n+\t// If the call to C.f is deferred, that will check p at the\n+\t// point of the defer statement, not when the function is called, so\n+\t// rewrite to func(_cgo0 ptype) { C.f(_cgoCheckPointer(_cgo0)) }(p)\n+\n+\tvar dargs []ast.Expr\n+\tif call.Deferred {\n+\t\tdargs = make([]ast.Expr, len(name.FuncType.Params))\n+\t}\n+\tfor i, param := range name.FuncType.Params {\n+\t\torigArg := call.Call.Args[i]\n+\t\tdarg := origArg\n+\n+\t\tif call.Deferred {\n+\t\t\tdargs[i] = darg\n+\t\t\tdarg = ast.NewIdent(fmt.Sprintf(\"_cgo%d\", i))\n+\t\t\tcall.Call.Args[i] = darg\n \t\t}\n \n-\t\tif !p.needsPointerCheck(f, param.Go) {\n+\t\tif !p.needsPointerCheck(f, param.Go, origArg) {\n \t\t\tcontinue\n \t\t}\n \n \t\tc := &ast.CallExpr{\n \t\t\tFun: ast.NewIdent(\"_cgoCheckPointer\"),\n \t\t\tArgs: []ast.Expr{\n-\t\t\t\tcall.Args[i],\n+\t\t\t\tdarg,\n \t\t\t},\n \t\t}\n \n \t\t// Add optional additional arguments for an address\n \t\t// expression.\n-\t\tc.Args = p.checkAddrArgs(f, c.Args, call.Args[i])\n+\t\tc.Args = p.checkAddrArgs(f, c.Args, origArg)\n \n \t\t// _cgoCheckPointer returns interface{}.\n \t\t// We need to type assert that to the type we want.\n@@ -636,19 +659,19 @@ func (p *Package) rewriteCall(f *File, call *ast.CallExpr, name *Name) {\n \t\t// Instead we use a local variant of _cgoCheckPointer.\n \n \t\tvar arg ast.Expr\n-\t\tif n := p.unsafeCheckPointerName(param.Go); n != \"\" {\n+\t\tif n := p.unsafeCheckPointerName(param.Go, call.Deferred); n != \"\" {\n \t\t\tc.Fun = ast.NewIdent(n)\n \t\t\targ = c\n \t\t} else {\n \t\t\t// In order for the type assertion to succeed,\n \t\t\t// we need it to match the actual type of the\n-\t\t\t// argument.  The only type we have is the\n-\t\t\t// type of the function parameter.  We know\n+\t\t\t// argument. The only type we have is the\n+\t\t\t// type of the function parameter. We know\n \t\t\t// that the argument type must be assignable\n \t\t\t// to the function parameter type, or the code\n \t\t\t// would not compile, but there is nothing\n \t\t\t// requiring that the types be exactly the\n-\t\t\t// same.  Add a type conversion to the\n+\t\t\t// same. Add a type conversion to the\n \t\t\t// argument so that the type assertion will\n \t\t\t// succeed.\n \t\t\tc.Args[0] = &ast.CallExpr{\n@@ -664,18 +687,77 @@ func (p *Package) rewriteCall(f *File, call *ast.CallExpr, name *Name) {\n \t\t\t}\n \t\t}\n \n-\t\tcall.Args[i] = arg\n+\t\tcall.Call.Args[i] = arg\n+\t}\n+\n+\tif call.Deferred {\n+\t\tparams := make([]*ast.Field, len(name.FuncType.Params))\n+\t\tfor i, param := range name.FuncType.Params {\n+\t\t\tptype := param.Go\n+\t\t\tif p.hasUnsafePointer(ptype) {\n+\t\t\t\t// Avoid generating unsafe.Pointer by using\n+\t\t\t\t// interface{}. This works because we are\n+\t\t\t\t// going to call a _cgoCheckPointer function\n+\t\t\t\t// anyhow.\n+\t\t\t\tptype = &ast.InterfaceType{\n+\t\t\t\t\tMethods: &ast.FieldList{},\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tparams[i] = &ast.Field{\n+\t\t\t\tNames: []*ast.Ident{\n+\t\t\t\t\tast.NewIdent(fmt.Sprintf(\"_cgo%d\", i)),\n+\t\t\t\t},\n+\t\t\t\tType: ptype,\n+\t\t\t}\n+\t\t}\n+\n+\t\tdbody := &ast.CallExpr{\n+\t\t\tFun:  call.Call.Fun,\n+\t\t\tArgs: call.Call.Args,\n+\t\t}\n+\t\tcall.Call.Fun = &ast.FuncLit{\n+\t\t\tType: &ast.FuncType{\n+\t\t\t\tParams: &ast.FieldList{\n+\t\t\t\t\tList: params,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tBody: &ast.BlockStmt{\n+\t\t\t\tList: []ast.Stmt{\n+\t\t\t\t\t&ast.ExprStmt{\n+\t\t\t\t\t\tX: dbody,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tcall.Call.Args = dargs\n+\t\tcall.Call.Lparen = token.NoPos\n+\t\tcall.Call.Rparen = token.NoPos\n+\n+\t\t// There is a Ref pointing to the old call.Call.Fun.\n+\t\tfor _, ref := range f.Ref {\n+\t\t\tif ref.Expr == &call.Call.Fun {\n+\t\t\t\tref.Expr = &dbody.Fun\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n // needsPointerCheck returns whether the type t needs a pointer check.\n // This is true if t is a pointer and if the value to which it points\n // might contain a pointer.\n-func (p *Package) needsPointerCheck(f *File, t ast.Expr) bool {\n+func (p *Package) needsPointerCheck(f *File, t ast.Expr, arg ast.Expr) bool {\n+\t// An untyped nil does not need a pointer check, and when\n+\t// _cgoCheckPointer returns the untyped nil the type assertion we\n+\t// are going to insert will fail.  Easier to just skip nil arguments.\n+\t// TODO: Note that this fails if nil is shadowed.\n+\tif id, ok := arg.(*ast.Ident); ok && id.Name == \"nil\" {\n+\t\treturn false\n+\t}\n+\n \treturn p.hasPointer(f, t, true)\n }\n \n-// hasPointer is used by needsPointerCheck.  If top is true it returns\n+// hasPointer is used by needsPointerCheck. If top is true it returns\n // whether t is or contains a pointer that might point to a pointer.\n // If top is false it returns whether t is or contains a pointer.\n // f may be nil.\n@@ -732,7 +814,7 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n \t\tif goTypes[t.Name] != nil {\n \t\t\treturn false\n \t\t}\n-\t\t// We can't figure out the type.  Conservative\n+\t\t// We can't figure out the type. Conservative\n \t\t// approach is to assume it has a pointer.\n \t\treturn true\n \tcase *ast.SelectorExpr:\n@@ -750,7 +832,7 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n \t\tif name != nil && name.Kind == \"type\" && name.Type != nil && name.Type.Go != nil {\n \t\t\treturn p.hasPointer(f, name.Type.Go, top)\n \t\t}\n-\t\t// We can't figure out the type.  Conservative\n+\t\t// We can't figure out the type. Conservative\n \t\t// approach is to assume it has a pointer.\n \t\treturn true\n \tdefault:\n@@ -760,14 +842,14 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n }\n \n // checkAddrArgs tries to add arguments to the call of\n-// _cgoCheckPointer when the argument is an address expression.  We\n+// _cgoCheckPointer when the argument is an address expression. We\n // pass true to mean that the argument is an address operation of\n // something other than a slice index, which means that it's only\n // necessary to check the specific element pointed to, not the entire\n-// object.  This is for &s.f, where f is a field in a struct.  We can\n+// object. This is for &s.f, where f is a field in a struct. We can\n // pass a slice or array, meaning that we should check the entire\n // slice or array but need not check any other part of the object.\n-// This is for &s.a[i], where we need to check all of a.  However, we\n+// This is for &s.a[i], where we need to check all of a. However, we\n // only pass the slice or array if we can refer to it without side\n // effects.\n func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr {\n@@ -786,7 +868,7 @@ func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr\n \tindex, ok := u.X.(*ast.IndexExpr)\n \tif !ok {\n \t\t// This is the address of something that is not an\n-\t\t// index expression.  We only need to examine the\n+\t\t// index expression. We only need to examine the\n \t\t// single value to which it points.\n \t\t// TODO: what if true is shadowed?\n \t\treturn append(args, ast.NewIdent(\"true\"))\n@@ -819,14 +901,17 @@ func (p *Package) hasSideEffects(f *File, x ast.Expr) bool {\n func (p *Package) isType(t ast.Expr) bool {\n \tswitch t := t.(type) {\n \tcase *ast.SelectorExpr:\n-\t\tif t.Sel.Name != \"Pointer\" {\n-\t\t\treturn false\n-\t\t}\n \t\tid, ok := t.X.(*ast.Ident)\n \t\tif !ok {\n \t\t\treturn false\n \t\t}\n-\t\treturn id.Name == \"unsafe\"\n+\t\tif id.Name == \"unsafe\" && t.Sel.Name == \"Pointer\" {\n+\t\t\treturn true\n+\t\t}\n+\t\tif id.Name == \"C\" && typedef[\"_Ctype_\"+t.Sel.Name] != nil {\n+\t\t\treturn true\n+\t\t}\n+\t\treturn false\n \tcase *ast.Ident:\n \t\t// TODO: This ignores shadowing.\n \t\tswitch t.Name {\n@@ -850,26 +935,37 @@ func (p *Package) isType(t ast.Expr) bool {\n \treturn false\n }\n \n-// unsafeCheckPointerName is given the Go version of a C type.  If the\n+// unsafeCheckPointerName is given the Go version of a C type. If the\n // type uses unsafe.Pointer, we arrange to build a version of\n-// _cgoCheckPointer that returns that type.  This avoids using a type\n-// assertion to unsafe.Pointer in our copy of user code.  We return\n+// _cgoCheckPointer that returns that type. This avoids using a type\n+// assertion to unsafe.Pointer in our copy of user code. We return\n // the name of the _cgoCheckPointer function we are going to build, or\n // the empty string if the type does not use unsafe.Pointer.\n-func (p *Package) unsafeCheckPointerName(t ast.Expr) string {\n+//\n+// The deferred parameter is true if this check is for the argument of\n+// a deferred function. In that case we need to use an empty interface\n+// as the argument type, because the deferred function we introduce in\n+// rewriteCall will use an empty interface type, and we can't add a\n+// type assertion. This is handled by keeping a separate list, and\n+// writing out the lists separately in writeDefs.\n+func (p *Package) unsafeCheckPointerName(t ast.Expr, deferred bool) string {\n \tif !p.hasUnsafePointer(t) {\n \t\treturn \"\"\n \t}\n \tvar buf bytes.Buffer\n \tconf.Fprint(&buf, fset, t)\n \ts := buf.String()\n-\tfor i, t := range p.CgoChecks {\n+\tchecks := &p.CgoChecks\n+\tif deferred {\n+\t\tchecks = &p.DeferredCgoChecks\n+\t}\n+\tfor i, t := range *checks {\n \t\tif s == t {\n-\t\t\treturn p.unsafeCheckPointerNameIndex(i)\n+\t\t\treturn p.unsafeCheckPointerNameIndex(i, deferred)\n \t\t}\n \t}\n-\tp.CgoChecks = append(p.CgoChecks, s)\n-\treturn p.unsafeCheckPointerNameIndex(len(p.CgoChecks) - 1)\n+\t*checks = append(*checks, s)\n+\treturn p.unsafeCheckPointerNameIndex(len(*checks)-1, deferred)\n }\n \n // hasUnsafePointer returns whether the Go type t uses unsafe.Pointer.\n@@ -897,13 +993,16 @@ func (p *Package) hasUnsafePointer(t ast.Expr) bool {\n \n // unsafeCheckPointerNameIndex returns the name to use for a\n // _cgoCheckPointer variant based on the index in the CgoChecks slice.\n-func (p *Package) unsafeCheckPointerNameIndex(i int) string {\n+func (p *Package) unsafeCheckPointerNameIndex(i int, deferred bool) string {\n+\tif deferred {\n+\t\treturn fmt.Sprintf(\"_cgoCheckPointerInDefer%d\", i)\n+\t}\n \treturn fmt.Sprintf(\"_cgoCheckPointer%d\", i)\n }\n \n // rewriteRef rewrites all the C.xxx references in f.AST to refer to the\n // Go equivalents, now that we have figured out the meaning of all\n-// the xxx.  In *godefs mode, rewriteRef replaces the names\n+// the xxx. In *godefs mode, rewriteRef replaces the names\n // with full definitions instead of mangled names.\n func (p *Package) rewriteRef(f *File) {\n \t// Keep a list of all the functions, to remove the ones\n@@ -926,7 +1025,7 @@ func (p *Package) rewriteRef(f *File) {\n \n \t// Now that we have all the name types filled in,\n \t// scan through the Refs to identify the ones that\n-\t// are trying to do a ,err call.  Also check that\n+\t// are trying to do a ,err call. Also check that\n \t// functions are only used in calls.\n \tfor _, r := range f.Ref {\n \t\tif r.Name.Kind == \"const\" && r.Name.Const == \"\" {\n@@ -984,7 +1083,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\t\tf.Name[fpName] = name\n \t\t\t\t}\n \t\t\t\tr.Name = name\n-\t\t\t\t// Rewrite into call to _Cgo_ptr to prevent assignments.  The _Cgo_ptr\n+\t\t\t\t// Rewrite into call to _Cgo_ptr to prevent assignments. The _Cgo_ptr\n \t\t\t\t// function is defined in out.go and simply returns its argument. See\n \t\t\t\t// issue 7757.\n \t\t\t\texpr = &ast.CallExpr{\n@@ -1006,7 +1105,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\tif r.Name.Kind == \"var\" {\n \t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n \t\t\t} else {\n-\t\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression\", fixGo(r.Name.Go))\n+\t\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression %s\", fixGo(r.Name.Go))\n \t\t\t}\n \n \t\tcase \"type\":\n@@ -1086,6 +1185,8 @@ func (p *Package) gccMachine() []string {\n \t\treturn []string{\"-m31\"}\n \tcase \"s390x\":\n \t\treturn []string{\"-m64\"}\n+\tcase \"mips64\", \"mips64le\":\n+\t\treturn []string{\"-mabi=64\"}\n \t}\n \treturn nil\n }\n@@ -1152,7 +1253,7 @@ func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte)\n \t\t\tfor i := range f.Symtab.Syms {\n \t\t\t\ts := &f.Symtab.Syms[i]\n \t\t\t\tif isDebugData(s.Name) {\n-\t\t\t\t\t// Found it.  Now find data section.\n+\t\t\t\t\t// Found it. Now find data section.\n \t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n \t\t\t\t\t\tsect := f.Sections[i]\n \t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n@@ -1179,7 +1280,7 @@ func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte)\n \t\t\tfor i := range symtab {\n \t\t\t\ts := &symtab[i]\n \t\t\t\tif isDebugData(s.Name) {\n-\t\t\t\t\t// Found it.  Now find data section.\n+\t\t\t\t\t// Found it. Now find data section.\n \t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n \t\t\t\t\t\tsect := f.Sections[i]\n \t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n@@ -1232,18 +1333,26 @@ func (p *Package) gccDefines(stdin []byte) string {\n }\n \n // gccErrors runs gcc over the C program stdin and returns\n-// the errors that gcc prints.  That is, this function expects\n+// the errors that gcc prints. That is, this function expects\n // gcc to fail.\n func (p *Package) gccErrors(stdin []byte) string {\n \t// TODO(rsc): require failure\n \targs := p.gccCmd()\n \n+\t// Optimization options can confuse the error messages; remove them.\n+\tnargs := make([]string, 0, len(args))\n+\tfor _, arg := range args {\n+\t\tif !strings.HasPrefix(arg, \"-O\") {\n+\t\t\tnargs = append(nargs, arg)\n+\t\t}\n+\t}\n+\n \tif *debugGcc {\n-\t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(args, \" \"))\n+\t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(nargs, \" \"))\n \t\tos.Stderr.Write(stdin)\n \t\tfmt.Fprint(os.Stderr, \"EOF\\n\")\n \t}\n-\tstdout, stderr, _ := run(stdin, args)\n+\tstdout, stderr, _ := run(stdin, nargs)\n \tif *debugGcc {\n \t\tos.Stderr.Write(stdout)\n \t\tos.Stderr.Write(stderr)\n@@ -1279,8 +1388,7 @@ func runGcc(stdin []byte, args []string) (string, string) {\n // with equivalent memory layout.\n type typeConv struct {\n \t// Cache of already-translated or in-progress types.\n-\tm       map[dwarf.Type]*Type\n-\ttypedef map[string]ast.Expr\n+\tm map[dwarf.Type]*Type\n \n \t// Map from types to incomplete pointers to those types.\n \tptrs map[dwarf.Type][]*Type\n@@ -1372,7 +1480,7 @@ var dwarfToName = map[string]string{\n \n const signedDelta = 64\n \n-// String returns the current type representation.  Format arguments\n+// String returns the current type representation. Format arguments\n // are assembled within this method so that any changes in mutable\n // values are taken into account.\n func (tr *TypeRepr) String() string {\n@@ -1812,7 +1920,7 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t}\n \tcase *dwarf.TypedefType:\n \t\t// C has much more relaxed rules than Go for\n-\t\t// implicit type conversions.  When the parameter\n+\t\t// implicit type conversions. When the parameter\n \t\t// is type T defined as *X, simulate a little of the\n \t\t// laxness of C by making the argument *X instead of T.\n \t\tif ptr, ok := base(dt.Type).(*dwarf.PtrType); ok {\n@@ -1828,7 +1936,7 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t}\n \n \t\t\t// Remember the C spelling, in case the struct\n-\t\t\t// has __attribute__((unavailable)) on it.  See issue 2888.\n+\t\t\t// has __attribute__((unavailable)) on it. See issue 2888.\n \t\t\tt.Typedef = dt.Name\n \t\t}\n \t}\n@@ -1843,7 +1951,7 @@ func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType {\n \tfor i, f := range dtype.ParamType {\n \t\t// gcc's DWARF generator outputs a single DotDotDotType parameter for\n \t\t// function pointers that specify no parameters (e.g. void\n-\t\t// (*__cgo_0)()).  Treat this special case as void.  This case is\n+\t\t// (*__cgo_0)()).  Treat this special case as void. This case is\n \t\t// invalid according to ISO C anyway (i.e. void (*__cgo_1)(...) is not\n \t\t// legal).\n \t\tif _, ok := f.(*dwarf.DotDotDotType); ok && i == 0 {\n@@ -1914,8 +2022,8 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \toff := int64(0)\n \n \t// Rename struct fields that happen to be named Go keywords into\n-\t// _{keyword}.  Create a map from C ident -> Go ident.  The Go ident will\n-\t// be mangled.  Any existing identifier that already has the same name on\n+\t// _{keyword}.  Create a map from C ident -> Go ident. The Go ident will\n+\t// be mangled. Any existing identifier that already has the same name on\n \t// the C-side will cause the Go-mangled version to be prefixed with _.\n \t// (e.g. in a struct with fields '_type' and 'type', the latter would be\n \t// rendered as '__type' in Go).\n@@ -1955,7 +2063,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \n \t\t// In godefs mode, if this field is a C11\n \t\t// anonymous union then treat the first field in the\n-\t\t// union as the field in the struct.  This handles\n+\t\t// union as the field in the struct. This handles\n \t\t// cases like the glibc <sys/resource.h> file; see\n \t\t// issue 6677.\n \t\tif *godefs {\n@@ -2025,7 +2133,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t// We can't permit that, because then the size of the Go\n \t// struct will not be the same as the size of the C struct.\n \t// Our only option in such a case is to remove the field,\n-\t// which means that it can not be referenced from Go.\n+\t// which means that it cannot be referenced from Go.\n \tfor off > 0 && sizes[len(sizes)-1] == 0 {\n \t\tn := len(sizes)\n \t\tfld = fld[0 : n-1]\n@@ -2079,7 +2187,7 @@ func godefsFields(fld []*ast.Field) {\n }\n \n // fieldPrefix returns the prefix that should be removed from all the\n-// field names when generating the C or Go code.  For generated\n+// field names when generating the C or Go code. For generated\n // C, we leave the names as is (tv_sec, tv_usec), since that's what\n // people are used to seeing in C.  For generated Go code, such as\n // package syscall's data structures, we drop a common prefix\n@@ -2089,7 +2197,7 @@ func fieldPrefix(fld []*ast.Field) string {\n \tfor _, f := range fld {\n \t\tfor _, n := range f.Names {\n \t\t\t// Ignore field names that don't have the prefix we're\n-\t\t\t// looking for.  It is common in C headers to have fields\n+\t\t\t// looking for. It is common in C headers to have fields\n \t\t\t// named, say, _pad in an otherwise prefixed header.\n \t\t\t// If the struct has 3 fields tv_sec, tv_usec, _pad1, then we\n \t\t\t// still want to remove the tv_ prefix."}, {"sha": "6d638f064422a726a84f3232aa53bc388eee9afe", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "219b25273236350cf3a9f3477565baaf0d2e71e1", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -42,7 +42,10 @@ type Package struct {\n \tGoFiles     []string // list of Go files\n \tGccFiles    []string // list of gcc output files\n \tPreamble    string   // collected preamble for _cgo_export.h\n-\tCgoChecks   []string // see unsafeCheckPointerName\n+\n+\t// See unsafeCheckPointerName.\n+\tCgoChecks         []string\n+\tDeferredCgoChecks []string\n }\n \n // A File collects information about a single Go input file.\n@@ -52,7 +55,7 @@ type File struct {\n \tPackage  string              // Package name\n \tPreamble string              // C preamble (doc comment on import \"C\")\n \tRef      []*Ref              // all references to C.xxx in AST\n-\tCalls    []*ast.CallExpr     // all calls to C.xxx in AST\n+\tCalls    []*Call             // all calls to C.xxx in AST\n \tExpFunc  []*ExpFunc          // exported functions for this file\n \tName     map[string]*Name    // map from Go name to Name\n }\n@@ -66,6 +69,12 @@ func nameKeys(m map[string]*Name) []string {\n \treturn ks\n }\n \n+// A Call refers to a call of a C.xxx function in the AST.\n+type Call struct {\n+\tCall     *ast.CallExpr\n+\tDeferred bool\n+}\n+\n // A Ref refers to an expression of the form C.xxx in the AST.\n type Ref struct {\n \tName    *Name\n@@ -208,9 +217,9 @@ func main() {\n \n \tif *dynobj != \"\" {\n \t\t// cgo -dynimport is essentially a separate helper command\n-\t\t// built into the cgo binary.  It scans a gcc-produced executable\n+\t\t// built into the cgo binary. It scans a gcc-produced executable\n \t\t// and dumps information about the imported symbols and the\n-\t\t// imported libraries.  The 'go build' rules for cgo prepare an\n+\t\t// imported libraries. The 'go build' rules for cgo prepare an\n \t\t// appropriate executable and then use its import information\n \t\t// instead of needing to make the linkers duplicate all the\n \t\t// specialized knowledge gcc has about where to look for imported\n@@ -245,6 +254,12 @@ func main() {\n \n \tgoFiles := args[i:]\n \n+\tfor _, arg := range args[:i] {\n+\t\tif arg == \"-fsanitize=thread\" {\n+\t\t\ttsanProlog = yesTsanProlog\n+\t\t}\n+\t}\n+\n \tp := newPackage(args[:i])\n \n \t// Record CGO_LDFLAGS from the environment for external linking."}, {"sha": "842b1c5ef8081c25b178c56450e7e6f774b8538a", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 189, "deletions": 35, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -50,14 +50,16 @@ func (p *Package) writeDefs() {\n \t// Write C main file for using gcc to resolve imports.\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n-\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c) { }\\n\")\n-\t\tfmt.Fprintf(fm, \"void _cgo_wait_runtime_init_done() { }\\n\")\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done() { return 0; }\\n\")\n+\t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__ ctxt) { }\\n\")\n \t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n-\t\t// which provides these functions.  We just need a prototype.\n-\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c);\\n\")\n-\t\tfmt.Fprintf(fm, \"void _cgo_wait_runtime_init_done();\\n\")\n+\t\t// which provides these functions. We just need a prototype.\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt);\\n\")\n+\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done();\\n\")\n+\t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__);\\n\")\n \t}\n \tfmt.Fprintf(fm, \"void _cgo_allocate(void *a, int c) { }\\n\")\n \tfmt.Fprintf(fm, \"void _cgo_panic(void *a, int c) { }\\n\")\n@@ -110,7 +112,13 @@ func (p *Package) writeDefs() {\n \t}\n \n \tfor i, t := range p.CgoChecks {\n-\t\tn := p.unsafeCheckPointerNameIndex(i)\n+\t\tn := p.unsafeCheckPointerNameIndex(i, false)\n+\t\tfmt.Fprintf(fgo2, \"\\nfunc %s(p %s, args ...interface{}) %s {\\n\", n, t, t)\n+\t\tfmt.Fprintf(fgo2, \"\\treturn _cgoCheckPointer(p, args...).(%s)\\n\", t)\n+\t\tfmt.Fprintf(fgo2, \"}\\n\")\n+\t}\n+\tfor i, t := range p.DeferredCgoChecks {\n+\t\tn := p.unsafeCheckPointerNameIndex(i, true)\n \t\tfmt.Fprintf(fgo2, \"\\nfunc %s(p interface{}, args ...interface{}) %s {\\n\", n, t)\n \t\tfmt.Fprintf(fgo2, \"\\treturn _cgoCheckPointer(p, args...).(%s)\\n\", t)\n \t\tfmt.Fprintf(fgo2, \"}\\n\")\n@@ -173,10 +181,11 @@ func (p *Package) writeDefs() {\n \t}\n \tfmt.Fprintf(fgo2, \"\\n\")\n \n+\tcallsMalloc := false\n \tfor _, key := range nameKeys(p.Name) {\n \t\tn := p.Name[key]\n \t\tif n.FuncType != nil {\n-\t\t\tp.writeDefsFunc(fgo2, n)\n+\t\t\tp.writeDefsFunc(fgo2, n, &callsMalloc)\n \t\t}\n \t}\n \n@@ -187,6 +196,12 @@ func (p *Package) writeDefs() {\n \t} else {\n \t\tp.writeExports(fgo2, fm, fgcc, fgcch)\n \t}\n+\n+\tif callsMalloc && !*gccgo {\n+\t\tfmt.Fprint(fgo2, strings.Replace(cMallocDefGo, \"PREFIX\", cPrefix, -1))\n+\t\tfmt.Fprint(fgcc, strings.Replace(strings.Replace(cMallocDefC, \"PREFIX\", cPrefix, -1), \"PACKED\", p.packedAttribute(), -1))\n+\t}\n+\n \tif err := fgcc.Close(); err != nil {\n \t\tfatalf(\"%s\", err)\n \t}\n@@ -350,7 +365,7 @@ func (p *Package) structType(n *Name) (string, int64) {\n \treturn buf.String(), off\n }\n \n-func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n+func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name, callsMalloc *bool) {\n \tname := n.Go\n \tgtype := n.FuncType.Go\n \tvoid := gtype.Results == nil || len(gtype.Results.List) == 0\n@@ -439,6 +454,9 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n \n \tif inProlog {\n \t\tfmt.Fprint(fgo2, builtinDefs[name])\n+\t\tif strings.Contains(builtinDefs[name], \"_cgo_cmalloc\") {\n+\t\t\t*callsMalloc = true\n+\t\t}\n \t\treturn\n \t}\n \n@@ -458,6 +476,7 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n \t}\n \n \tfmt.Fprint(fgo2, \"\\n\")\n+\tfmt.Fprint(fgo2, \"//go:cgo_unsafe_args\\n\")\n \tconf.Fprint(fgo2, fset, d)\n \tfmt.Fprint(fgo2, \" {\\n\")\n \n@@ -507,6 +526,7 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \t// Gcc output starts with the preamble.\n \tfmt.Fprintf(fgcc, \"%s\\n\", f.Preamble)\n \tfmt.Fprintf(fgcc, \"%s\\n\", gccProlog)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n \n \tfor _, key := range nameKeys(f.Name) {\n \t\tn := f.Name[key]\n@@ -531,6 +551,7 @@ func fixGo(name string) string {\n \n var isBuiltin = map[string]bool{\n \t\"_Cfunc_CString\":   true,\n+\t\"_Cfunc_CBytes\":    true,\n \t\"_Cfunc_GoString\":  true,\n \t\"_Cfunc_GoStringN\": true,\n \t\"_Cfunc_GoBytes\":   true,\n@@ -555,6 +576,7 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \n \t// Gcc wrapper unpacks the C argument struct\n \t// and calls the actual C function.\n+\tfmt.Fprintf(fgcc, \"CGO_NO_SANITIZE_THREAD\\n\")\n \tif n.AddError {\n \t\tfmt.Fprintf(fgcc, \"int\\n\")\n \t} else {\n@@ -563,7 +585,7 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \tfmt.Fprintf(fgcc, \"_cgo%s%s(void *v)\\n\", cPrefix, n.Mangle)\n \tfmt.Fprintf(fgcc, \"{\\n\")\n \tif n.AddError {\n-\t\tfmt.Fprintf(fgcc, \"\\terrno = 0;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\tint _cgo_errno;\\n\")\n \t}\n \t// We're trying to write a gcc struct that matches gc's layout.\n \t// Use packed attribute to force no padding in this struct in case\n@@ -573,10 +595,18 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\t// Save the stack top for use below.\n \t\tfmt.Fprintf(fgcc, \"\\tchar *stktop = _cgo_topofstack();\\n\")\n \t}\n+\ttr := n.FuncType.Result\n+\tif tr != nil {\n+\t\tfmt.Fprintf(fgcc, \"\\t__typeof__(a->r) r;\\n\")\n+\t}\n+\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgcc, \"\\terrno = 0;\\n\")\n+\t}\n \tfmt.Fprintf(fgcc, \"\\t\")\n-\tif t := n.FuncType.Result; t != nil {\n-\t\tfmt.Fprintf(fgcc, \"__typeof__(a->r) r = \")\n-\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\tif tr != nil {\n+\t\tfmt.Fprintf(fgcc, \"r = \")\n+\t\tif c := tr.C.String(); c[len(c)-1] == '*' {\n \t\t\tfmt.Fprint(fgcc, \"(__typeof__(a->r)) \")\n \t\t}\n \t}\n@@ -589,7 +619,7 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\t// the Go equivalents had good type params.\n \t\t// However, our version of the type omits the magic\n \t\t// words const and volatile, which can provoke\n-\t\t// C compiler warnings.  Silence them by casting\n+\t\t// C compiler warnings. Silence them by casting\n \t\t// all pointers to void*.  (Eventually that will produce\n \t\t// other warnings.)\n \t\tif c := t.C.String(); c[len(c)-1] == '*' {\n@@ -598,6 +628,10 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n \t}\n \tfmt.Fprintf(fgcc, \");\\n\")\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_errno = errno;\\n\")\n+\t}\n+\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n \tif n.FuncType.Result != nil {\n \t\t// The cgo call may have caused a stack copy (via a callback).\n \t\t// Adjust the return value pointer appropriately.\n@@ -606,18 +640,19 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\tfmt.Fprintf(fgcc, \"\\ta->r = r;\\n\")\n \t}\n \tif n.AddError {\n-\t\tfmt.Fprintf(fgcc, \"\\treturn errno;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\treturn _cgo_errno;\\n\")\n \t}\n \tfmt.Fprintf(fgcc, \"}\\n\")\n \tfmt.Fprintf(fgcc, \"\\n\")\n }\n \n-// Write out a wrapper for a function when using gccgo.  This is a\n-// simple wrapper that just calls the real function.  We only need a\n+// Write out a wrapper for a function when using gccgo. This is a\n+// simple wrapper that just calls the real function. We only need a\n // wrapper to support static functions in the prologue--without a\n // wrapper, we can't refer to the function, since the reference is in\n // a different file.\n func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n+\tfmt.Fprintf(fgcc, \"CGO_NO_SANITIZE_THREAD\\n\")\n \tif t := n.FuncType.Result; t != nil {\n \t\tfmt.Fprintf(fgcc, \"%s\\n\", t.C.String())\n \t} else {\n@@ -636,9 +671,13 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \t}\n \tfmt.Fprintf(fgcc, \")\\n\")\n \tfmt.Fprintf(fgcc, \"{\\n\")\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", t.C.String())\n+\t}\n+\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n \tfmt.Fprintf(fgcc, \"\\t\")\n \tif t := n.FuncType.Result; t != nil {\n-\t\tfmt.Fprintf(fgcc, \"return \")\n+\t\tfmt.Fprintf(fgcc, \"r = \")\n \t\t// Cast to void* to avoid warnings due to omitted qualifiers.\n \t\tif c := t.C.String(); c[len(c)-1] == '*' {\n \t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n@@ -656,6 +695,16 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \t\tfmt.Fprintf(fgcc, \"p%d\", i)\n \t}\n \tfmt.Fprintf(fgcc, \");\\n\")\n+\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tfmt.Fprintf(fgcc, \"\\treturn \")\n+\t\t// Cast to void* to avoid warnings due to omitted qualifiers\n+\t\t// and explicit incompatible struct types.\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"r;\\n\")\n+\t}\n \tfmt.Fprintf(fgcc, \"}\\n\")\n \tfmt.Fprintf(fgcc, \"\\n\")\n }\n@@ -679,16 +728,20 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tp.writeExportHeader(fgcch)\n \n \tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcc, \"#include <stdlib.h>\\n\")\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\\n\")\n \n-\tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *, int), void *, int);\\n\")\n-\tfmt.Fprintf(fgcc, \"extern void _cgo_wait_runtime_init_done();\\n\\n\")\n+\tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *, int, __SIZE_TYPE__), void *, int, __SIZE_TYPE__);\\n\")\n+\tfmt.Fprintf(fgcc, \"extern __SIZE_TYPE__ _cgo_wait_runtime_init_done();\\n\")\n+\tfmt.Fprintf(fgcc, \"extern void _cgo_release_context(__SIZE_TYPE__);\\n\\n\")\n+\tfmt.Fprintf(fgcc, \"extern char* _cgo_topofstack(void);\")\n+\tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n \n \t\t// Construct a gcc struct matching the gc argument and\n-\t\t// result frame.  The gcc struct will be compiled with\n+\t\t// result frame. The gcc struct will be compiled with\n \t\t// __attribute__((packed)) so all padding must be accounted\n \t\t// for explicitly.\n \t\tctype := \"struct {\\n\"\n@@ -783,10 +836,11 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t}\n \t\tfmt.Fprintf(fgcch, \"\\nextern %s;\\n\", s)\n \n-\t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int);\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int, __SIZE_TYPE__);\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgcc, \"\\nCGO_NO_SANITIZE_THREAD\")\n \t\tfmt.Fprintf(fgcc, \"\\n%s\\n\", s)\n \t\tfmt.Fprintf(fgcc, \"{\\n\")\n-\t\tfmt.Fprintf(fgcc, \"\\t_cgo_wait_runtime_init_done();\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t__SIZE_TYPE__ _cgo_ctxt = _cgo_wait_runtime_init_done();\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t%s %v a;\\n\", ctype, p.packedAttribute())\n \t\tif gccResult != \"void\" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {\n \t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", gccResult)\n@@ -798,7 +852,10 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t\tfunc(i int, aname string, atype ast.Expr) {\n \t\t\t\tfmt.Fprintf(fgcc, \"\\ta.p%d = p%d;\\n\", i, i)\n \t\t\t})\n-\t\tfmt.Fprintf(fgcc, \"\\tcrosscall2(_cgoexp%s_%s, &a, %d);\\n\", cPrefix, exp.ExpName, off)\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\tcrosscall2(_cgoexp%s_%s, &a, %d, _cgo_ctxt);\\n\", cPrefix, exp.ExpName, off)\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_release_context(_cgo_ctxt);\\n\")\n \t\tif gccResult != \"void\" {\n \t\t\tif len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {\n \t\t\t\tfmt.Fprintf(fgcc, \"\\treturn a.r0;\\n\")\n@@ -823,10 +880,10 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\tfmt.Fprintf(fgo2, \"//go:cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgo2, \"//go:nosplit\\n\") // no split stack, so no use of m or g\n \t\tfmt.Fprintf(fgo2, \"//go:norace\\n\")  // must not have race detector calls inserted\n-\t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a unsafe.Pointer, n int32) {\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a unsafe.Pointer, n int32, ctxt uintptr) {\\n\", cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgo2, \"\\tfn := %s\\n\", goname)\n \t\t// The indirect here is converting from a Go function pointer to a C function pointer.\n-\t\tfmt.Fprintf(fgo2, \"\\t_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n));\\n\")\n+\t\tfmt.Fprintf(fgo2, \"\\t_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n), ctxt);\\n\")\n \t\tfmt.Fprintf(fgo2, \"}\\n\")\n \n \t\tfmt.Fprintf(fm, \"int _cgoexp%s_%s;\\n\", cPrefix, exp.ExpName)\n@@ -915,6 +972,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n \n \tfmt.Fprintf(fgcc, \"%s\\n\", gccgoExportFileProlog)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n@@ -983,13 +1041,17 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\tfmt.Fprintf(fgcc, `extern %s %s %s __asm__(\"%s.%s\");`, cRet, goName, cParams, gccgoSymbolPrefix, goName)\n \t\tfmt.Fprint(fgcc, \"\\n\")\n \n-\t\tfmt.Fprint(fgcc, \"\\n\")\n+\t\tfmt.Fprint(fgcc, \"\\nCGO_NO_SANITIZE_THREAD\\n\")\n \t\tfmt.Fprintf(fgcc, \"%s %s %s {\\n\", cRet, exp.ExpName, cParams)\n+\t\tif resultCount > 0 {\n+\t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", cRet)\n+\t\t}\n \t\tfmt.Fprintf(fgcc, \"\\tif(_cgo_wait_runtime_init_done)\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t\\t_cgo_wait_runtime_init_done();\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n \t\tfmt.Fprint(fgcc, \"\\t\")\n \t\tif resultCount > 0 {\n-\t\t\tfmt.Fprint(fgcc, \"return \")\n+\t\t\tfmt.Fprint(fgcc, \"r = \")\n \t\t}\n \t\tfmt.Fprintf(fgcc, \"%s(\", goName)\n \t\tif fn.Recv != nil {\n@@ -1003,6 +1065,10 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t\t\tfmt.Fprintf(fgcc, \"p%d\", i)\n \t\t\t})\n \t\tfmt.Fprint(fgcc, \");\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_acquire();\\n\")\n+\t\tif resultCount > 0 {\n+\t\t\tfmt.Fprint(fgcc, \"\\treturn r;\\n\")\n+\t\t}\n \t\tfmt.Fprint(fgcc, \"}\\n\")\n \n \t\t// Dummy declaration for _cgo_main.c\n@@ -1257,6 +1323,36 @@ extern char* _cgo_topofstack(void);\n #include <string.h>\n `\n \n+// Prologue defining TSAN functions in C.\n+const noTsanProlog = `\n+#define CGO_NO_SANITIZE_THREAD\n+#define _cgo_tsan_acquire()\n+#define _cgo_tsan_release()\n+`\n+\n+// This must match the TSAN code in runtime/cgo/libcgo.h.\n+const yesTsanProlog = `\n+#define CGO_NO_SANITIZE_THREAD __attribute__ ((no_sanitize_thread))\n+\n+long long _cgo_sync __attribute__ ((common));\n+\n+extern void __tsan_acquire(void*);\n+extern void __tsan_release(void*);\n+\n+__attribute__ ((unused))\n+static void _cgo_tsan_acquire() {\n+\t__tsan_acquire(&_cgo_sync);\n+}\n+\n+__attribute__ ((unused))\n+static void _cgo_tsan_release() {\n+\t__tsan_release(&_cgo_sync);\n+}\n+`\n+\n+// Set to yesTsanProlog if we see -fsanitize=thread in the flags for gcc.\n+var tsanProlog = noTsanProlog\n+\n const builtinProlog = `\n #include <stddef.h> /* for ptrdiff_t and size_t below */\n \n@@ -1269,18 +1365,16 @@ _GoString_ GoString(char *p);\n _GoString_ GoStringN(char *p, int l);\n _GoBytes_ GoBytes(void *p, int n);\n char *CString(_GoString_);\n+void *CBytes(_GoBytes_);\n void *_CMalloc(size_t);\n `\n \n const goProlog = `\n //go:linkname _cgo_runtime_cgocall runtime.cgocall\n func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32\n \n-//go:linkname _cgo_runtime_cmalloc runtime.cmalloc\n-func _cgo_runtime_cmalloc(uintptr) unsafe.Pointer\n-\n //go:linkname _cgo_runtime_cgocallback runtime.cgocallback\n-func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr)\n+func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr, uintptr)\n \n //go:linkname _cgoCheckPointer runtime.cgoCheckPointer\n func _cgoCheckPointer(interface{}, ...interface{}) interface{}\n@@ -1324,17 +1418,26 @@ func _Cfunc_GoBytes(p unsafe.Pointer, l _Ctype_int) []byte {\n \n const cStringDef = `\n func _Cfunc_CString(s string) *_Ctype_char {\n-\tp := _cgo_runtime_cmalloc(uintptr(len(s)+1))\n+\tp := _cgo_cmalloc(uint64(len(s)+1))\n \tpp := (*[1<<30]byte)(p)\n \tcopy(pp[:], s)\n \tpp[len(s)] = 0\n \treturn (*_Ctype_char)(p)\n }\n `\n \n+const cBytesDef = `\n+func _Cfunc_CBytes(b []byte) unsafe.Pointer {\n+\tp := _cgo_cmalloc(uint64(len(b)))\n+\tpp := (*[1<<30]byte)(p)\n+\tcopy(pp[:], b)\n+\treturn p\n+}\n+`\n+\n const cMallocDef = `\n func _Cfunc__CMalloc(n _Ctype_size_t) unsafe.Pointer {\n-\treturn _cgo_runtime_cmalloc(uintptr(n))\n+\treturn _cgo_cmalloc(uint64(n))\n }\n `\n \n@@ -1343,9 +1446,54 @@ var builtinDefs = map[string]string{\n \t\"GoStringN\": goStringNDef,\n \t\"GoBytes\":   goBytesDef,\n \t\"CString\":   cStringDef,\n+\t\"CBytes\":    cBytesDef,\n \t\"_CMalloc\":  cMallocDef,\n }\n \n+// Definitions for C.malloc in Go and in C. We define it ourselves\n+// since we call it from functions we define, such as C.CString.\n+// Also, we have historically ensured that C.malloc does not return\n+// nil even for an allocation of 0.\n+\n+const cMallocDefGo = `\n+//go:cgo_import_static _cgoPREFIX_Cfunc__Cmalloc\n+//go:linkname __cgofn__cgoPREFIX_Cfunc__Cmalloc _cgoPREFIX_Cfunc__Cmalloc\n+var __cgofn__cgoPREFIX_Cfunc__Cmalloc byte\n+var _cgoPREFIX_Cfunc__Cmalloc = unsafe.Pointer(&__cgofn__cgoPREFIX_Cfunc__Cmalloc)\n+\n+//go:cgo_unsafe_args\n+func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) {\n+\t_cgo_runtime_cgocall(_cgoPREFIX_Cfunc__Cmalloc, uintptr(unsafe.Pointer(&p0)))\n+\treturn\n+}\n+`\n+\n+// cMallocDefC defines the C version of C.malloc for the gc compiler.\n+// It is defined here because C.CString and friends need a definition.\n+// We define it by hand, rather than simply inventing a reference to\n+// C.malloc, because <stdlib.h> may not have been included.\n+// This is approximately what writeOutputFunc would generate, but\n+// skips the cgo_topofstack code (which is only needed if the C code\n+// calls back into Go). This also avoids returning nil for an\n+// allocation of 0 bytes.\n+const cMallocDefC = `\n+CGO_NO_SANITIZE_THREAD\n+void _cgoPREFIX_Cfunc__Cmalloc(void *v) {\n+\tstruct {\n+\t\tunsigned long long p0;\n+\t\tvoid *r1;\n+\t} PACKED *a = v;\n+\tvoid *ret;\n+\t_cgo_tsan_acquire();\n+\tret = malloc(a->p0);\n+\tif (ret == 0 && a->p0 == 0) {\n+\t\tret = malloc(1);\n+\t}\n+\ta->r1 = ret;\n+\t_cgo_tsan_release();\n+}\n+`\n+\n func (p *Package) cPrologGccgo() string {\n \treturn strings.Replace(strings.Replace(cPrologGccgo, \"PREFIX\", cPrefix, -1),\n \t\t\"GCCGOSYMBOLPREF\", p.gccgoSymbolPrefix(), -1)\n@@ -1380,6 +1528,12 @@ const char *_cgoPREFIX_Cfunc_CString(struct __go_string s) {\n \treturn p;\n }\n \n+void *_cgoPREFIX_Cfunc_CBytes(struct __go_open_array b) {\n+\tchar *p = malloc(b.__count);\n+\tmemmove(p, b.__values, b.__count);\n+\treturn p;\n+}\n+\n struct __go_string _cgoPREFIX_Cfunc_GoString(char *p) {\n \tintgo len = (p != NULL) ? strlen(p) : 0;\n \treturn __go_byte_array_to_string(p, len);\n@@ -1505,5 +1659,5 @@ static void GoInit(void) {\n \t\truntime_iscgo = 1;\n }\n \n-extern void _cgo_wait_runtime_init_done() __attribute__ ((weak));\n+extern __SIZE_TYPE__ _cgo_wait_runtime_init_done() __attribute__ ((weak));\n `"}, {"sha": "4f5c48864e997329301bf976b6ddf84102a38123", "filename": "libgo/go/cmd/cgo/util.go", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"go/token\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n )\n@@ -16,6 +17,43 @@ import (\n // It returns the output to standard output and standard error.\n // ok indicates whether the command exited successfully.\n func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {\n+\tif i := find(argv, \"-xc\"); i >= 0 && argv[len(argv)-1] == \"-\" {\n+\t\t// Some compilers have trouble with standard input.\n+\t\t// Others have trouble with -xc.\n+\t\t// Avoid both problems by writing a file with a .c extension.\n+\t\tf, err := ioutil.TempFile(\"\", \"cgo-gcc-input-\")\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tname := f.Name()\n+\t\tf.Close()\n+\t\tif err := ioutil.WriteFile(name+\".c\", stdin, 0666); err != nil {\n+\t\t\tos.Remove(name)\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tdefer os.Remove(name)\n+\t\tdefer os.Remove(name + \".c\")\n+\n+\t\t// Build new argument list without -xc and trailing -.\n+\t\tnew := append(argv[:i:i], argv[i+1:len(argv)-1]...)\n+\n+\t\t// Since we are going to write the file to a temporary directory,\n+\t\t// we will need to add -I . explicitly to the command line:\n+\t\t// any #include \"foo\" before would have looked in the current\n+\t\t// directory as the directory \"holding\" standard input, but now\n+\t\t// the temporary directory holds the input.\n+\t\t// We've also run into compilers that reject \"-I.\" but allow \"-I\", \".\",\n+\t\t// so be sure to use two arguments.\n+\t\t// This matters mainly for people invoking cgo -godefs by hand.\n+\t\tnew = append(new, \"-I\", \".\")\n+\n+\t\t// Finish argument list with path to C file.\n+\t\tnew = append(new, name+\".c\")\n+\n+\t\targv = new\n+\t\tstdin = nil\n+\t}\n+\n \tp := exec.Command(argv[0], argv[1:]...)\n \tp.Stdin = bytes.NewReader(stdin)\n \tvar bout, berr bytes.Buffer\n@@ -30,14 +68,23 @@ func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {\n \treturn\n }\n \n+func find(argv []string, target string) int {\n+\tfor i, arg := range argv {\n+\t\tif arg == target {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n func lineno(pos token.Pos) string {\n \treturn fset.Position(pos).String()\n }\n \n // Die with an error message.\n func fatalf(msg string, args ...interface{}) {\n \t// If we've already printed other errors, they might have\n-\t// caused the fatal condition.  Assume they're enough.\n+\t// caused the fatal condition. Assume they're enough.\n \tif nerrors == 0 {\n \t\tfmt.Fprintf(os.Stderr, msg+\"\\n\", args...)\n \t}"}, {"sha": "58b0d16b2b0af951e69180cf3500b4510d4ef839", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 1584, "deletions": 1568, "changes": 3152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "caa96769d841a5a9ff1528196ca43ea3e13a7d3b", "filename": "libgo/go/cmd/go/bootstrap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "10116f282f012adea5db46e7a2e545912140aa39", "filename": "libgo/go/cmd/go/build.go", "status": "modified", "additions": 226, "deletions": 133, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -48,6 +48,8 @@ When compiling multiple packages or a single non-main package,\n build compiles the packages but discards the resulting object,\n serving only as a check that the packages can be built.\n \n+When compiling packages, build ignores files that end in '_test.go'.\n+\n The -o flag, only allowed when compiling a single package,\n forces build to write the resulting executable or object\n to the named output file, instead of the default behavior described\n@@ -65,8 +67,7 @@ and test commands:\n \t-p n\n \t\tthe number of programs, such as build commands or\n \t\ttest binaries, that can be run in parallel.\n-\t\tThe default is the number of CPUs available, except\n-\t\ton darwin/arm which defaults to 1.\n+\t\tThe default is the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n@@ -145,17 +146,6 @@ func init() {\n \n \taddBuildFlags(cmdBuild)\n \taddBuildFlags(cmdInstall)\n-\n-\tif buildContext.GOOS == \"darwin\" {\n-\t\tswitch buildContext.GOARCH {\n-\t\tcase \"arm\", \"arm64\":\n-\t\t\t// darwin/arm cannot run multiple tests simultaneously.\n-\t\t\t// Parallelism is limited in go_darwin_arm_exec, but\n-\t\t\t// also needs to be limited here so go test std does not\n-\t\t\t// timeout tests that waiting to run.\n-\t\t\tbuildP = 1\n-\t\t}\n-\t}\n }\n \n // Flags set by multiple commands.\n@@ -352,6 +342,11 @@ func buildModeInit() {\n \t\t\t}\n \t\t\treturn p\n \t\t}\n+\t\tswitch platform {\n+\t\tcase \"darwin/arm\", \"darwin/arm64\":\n+\t\t\tcodegenArg = \"-shared\"\n+\t\tdefault:\n+\t\t}\n \t\texeSuffix = \".a\"\n \t\tldBuildmode = \"c-archive\"\n \tcase \"c-shared\":\n@@ -374,6 +369,9 @@ func buildModeInit() {\n \t\tcase \"android/arm\", \"android/arm64\", \"android/amd64\", \"android/386\":\n \t\t\tcodegenArg = \"-shared\"\n \t\t\tldBuildmode = \"pie\"\n+\t\tcase \"darwin/arm\", \"darwin/arm64\":\n+\t\t\tcodegenArg = \"-shared\"\n+\t\t\tfallthrough\n \t\tdefault:\n \t\t\tldBuildmode = \"exe\"\n \t\t}\n@@ -385,7 +383,7 @@ func buildModeInit() {\n \t\t\tfatalf(\"-buildmode=pie not supported by gccgo\")\n \t\t} else {\n \t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\",\n+\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n \t\t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\":\n \t\t\t\tcodegenArg = \"-shared\"\n \t\t\tdefault:\n@@ -399,7 +397,7 @@ func buildModeInit() {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n \t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\":\n+\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\":\n \t\t\tdefault:\n \t\t\t\tfatalf(\"-buildmode=shared not supported on %s\\n\", platform)\n \t\t\t}\n@@ -417,7 +415,7 @@ func buildModeInit() {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n \t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\":\n+\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\":\n \t\t\t\tbuildAsmflags = append(buildAsmflags, \"-D=GOBUILDMODE_shared=1\")\n \t\t\tdefault:\n \t\t\t\tfatalf(\"-linkshared not supported on %s\\n\", platform)\n@@ -483,6 +481,7 @@ func runBuild(cmd *Command, args []string) {\n \t\tp := pkgs[0]\n \t\tp.target = *buildO\n \t\tp.Stale = true // must build - not up to date\n+\t\tp.StaleReason = \"build -o flag in use\"\n \t\ta := b.action(modeInstall, depMode, p)\n \t\tb.do(a)\n \t\treturn\n@@ -525,7 +524,7 @@ func isMetaPackage(name string) bool {\n }\n \n // libname returns the filename to use for the shared library when using\n-// -buildmode=shared.  The rules we use are:\n+// -buildmode=shared. The rules we use are:\n // Use arguments for special 'meta' packages:\n //\tstd --> libstd.so\n //\tstd cmd --> libstd,cmd.so\n@@ -681,6 +680,7 @@ var (\n func init() {\n \tgoarch = buildContext.GOARCH\n \tgoos = buildContext.GOOS\n+\n \tif goos == \"windows\" {\n \t\texeSuffix = \".exe\"\n \t}\n@@ -694,6 +694,7 @@ type builder struct {\n \twork        string               // the temporary work directory (ends in filepath.Separator)\n \tactionCache map[cacheKey]*action // a cache of already-constructed actions\n \tmkdirCache  map[string]bool      // a cache of created directories\n+\tflagCache   map[string]bool      // a cache of supported compiler flags\n \tprint       func(args ...interface{}) (int, error)\n \n \toutput    sync.Mutex\n@@ -795,7 +796,7 @@ func goFilesPackage(gofiles []string) *Package {\n \n \t// Synthesize fake \"directory\" that only shows the named files,\n \t// to make it look like this is a standard package or\n-\t// command directory.  So that local imports resolve\n+\t// command directory. So that local imports resolve\n \t// consistently, the files must all be in the same directory.\n \tvar dirent []os.FileInfo\n \tvar dir string\n@@ -853,6 +854,7 @@ func goFilesPackage(gofiles []string) *Package {\n \n \tpkg.Target = pkg.target\n \tpkg.Stale = true\n+\tpkg.StaleReason = \"files named on command line\"\n \n \tcomputeStale(pkg)\n \treturn pkg\n@@ -957,7 +959,7 @@ func (b *builder) action1(mode buildMode, depMode buildMode, p *Package, looksha\n \t// If we are not doing a cross-build, then record the binary we'll\n \t// generate for cgo as a dependency of the build of any package\n \t// using cgo, to make sure we do not overwrite the binary while\n-\t// a package is using it.  If this is a cross-build, then the cgo we\n+\t// a package is using it. If this is a cross-build, then the cgo we\n \t// are writing is not the cgo we need to use.\n \tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace && !buildMSan && reqStdPkgSrc {\n \t\tif (len(p.CgoFiles) > 0 || p.Standard && p.ImportPath == \"runtime/cgo\") && !buildLinkshared && buildBuildmode != \"shared\" {\n@@ -993,7 +995,7 @@ func (b *builder) action1(mode buildMode, depMode buildMode, p *Package, looksha\n \t}\n \n \tif p.local && p.target == \"\" {\n-\t\t// Imported via local path.  No permanent target.\n+\t\t// Imported via local path. No permanent target.\n \t\tmode = modeBuild\n \t}\n \twork := p.pkgdir\n@@ -1041,7 +1043,7 @@ func (b *builder) action1(mode buildMode, depMode buildMode, p *Package, looksha\n \t\t\t// the name will show up in ps listings. If the caller has specified\n \t\t\t// a name, use that instead of a.out. The binary is generated\n \t\t\t// in an otherwise empty subdirectory named exe to avoid\n-\t\t\t// naming conflicts.  The only possible conflict is if we were\n+\t\t\t// naming conflicts. The only possible conflict is if we were\n \t\t\t// to create a top-level package named exe.\n \t\t\tname := \"a.out\"\n \t\t\tif p.exeName != \"\" {\n@@ -1227,14 +1229,22 @@ func allArchiveActions(root *action) []*action {\n \n // do runs the action graph rooted at root.\n func (b *builder) do(root *action) {\n+\t/* Commented out for gccgo, which does not have osArchSupportsCgo.\n+\n+\tif _, ok := osArchSupportsCgo[goos+\"/\"+goarch]; !ok && buildContext.Compiler == \"gc\" {\n+\t\tfmt.Fprintf(os.Stderr, \"cmd/go: unsupported GOOS/GOARCH pair %s/%s\\n\", goos, goarch)\n+\t\tos.Exit(2)\n+\t}\n+\t*/\n+\n \t// Build list of all actions, assigning depth-first post-order priority.\n \t// The original implementation here was a true queue\n \t// (using a channel) but it had the effect of getting\n \t// distracted by low-level leaf actions to the detriment\n-\t// of completing higher-level actions.  The order of\n+\t// of completing higher-level actions. The order of\n \t// work does not matter much to overall execution time,\n \t// but when running \"go test std\" it is nice to see each test\n-\t// results as soon as possible.  The priorities assigned\n+\t// results as soon as possible. The priorities assigned\n \t// ensure that, all else being equal, the execution prefers\n \t// to do what it would have done first in a simple depth-first\n \t// dependency order traversal.\n@@ -1331,18 +1341,15 @@ func (b *builder) do(root *action) {\n \twg.Wait()\n }\n \n-// hasString reports whether s appears in the list of strings.\n-func hasString(strings []string, s string) bool {\n-\tfor _, t := range strings {\n-\t\tif s == t {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n // build is the action for building a single package or command.\n func (b *builder) build(a *action) (err error) {\n+\t// Return an error for binary-only package.\n+\t// We only reach this if isStale believes the binary form is\n+\t// either not present or not usable.\n+\tif a.p.BinaryOnly {\n+\t\treturn fmt.Errorf(\"missing or invalid package binary for binary-only package %s\", a.p.ImportPath)\n+\t}\n+\n \t// Return an error if the package has CXX files but it's not using\n \t// cgo nor SWIG, since the CXX files can only be processed by cgo\n \t// and SWIG.\n@@ -1355,6 +1362,12 @@ func (b *builder) build(a *action) (err error) {\n \t\treturn fmt.Errorf(\"can't build package %s because it contains Objective-C files (%s) but it's not using cgo nor SWIG\",\n \t\t\ta.p.ImportPath, strings.Join(a.p.MFiles, \",\"))\n \t}\n+\t// Same as above for Fortran files\n+\tif len(a.p.FFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {\n+\t\treturn fmt.Errorf(\"can't build package %s because it contains Fortran files (%s) but it's not using cgo nor SWIG\",\n+\t\t\ta.p.ImportPath, strings.Join(a.p.FFiles, \",\"))\n+\t}\n+\n \tdefer func() {\n \t\tif err != nil && err != errPrintedOutput {\n \t\t\terr = fmt.Errorf(\"go build %s: %v\", a.p.ImportPath, err)\n@@ -1421,6 +1434,8 @@ func (b *builder) build(a *action) (err error) {\n \t\t// cgo and non-cgo worlds, so it necessarily has files in both.\n \t\t// In that case gcc only gets the gcc_* files.\n \t\tvar gccfiles []string\n+\t\tgccfiles = append(gccfiles, cfiles...)\n+\t\tcfiles = nil\n \t\tif a.p.Standard && a.p.ImportPath == \"runtime/cgo\" {\n \t\t\tfilter := func(files, nongcc, gcc []string) ([]string, []string) {\n \t\t\t\tfor _, f := range files {\n@@ -1432,19 +1447,17 @@ func (b *builder) build(a *action) (err error) {\n \t\t\t\t}\n \t\t\t\treturn nongcc, gcc\n \t\t\t}\n-\t\t\tcfiles, gccfiles = filter(cfiles, cfiles[:0], gccfiles)\n \t\t\tsfiles, gccfiles = filter(sfiles, sfiles[:0], gccfiles)\n \t\t} else {\n-\t\t\tgccfiles = append(cfiles, sfiles...)\n-\t\t\tcfiles = nil\n+\t\t\tgccfiles = append(gccfiles, sfiles...)\n \t\t\tsfiles = nil\n \t\t}\n \n \t\tcgoExe := tool(\"cgo\")\n \t\tif a.cgo != nil && a.cgo.target != \"\" {\n \t\t\tcgoExe = a.cgo.target\n \t\t}\n-\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, cxxfiles, a.p.MFiles)\n+\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, cxxfiles, a.p.MFiles, a.p.FFiles)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1552,7 +1565,7 @@ func (b *builder) build(a *action) (err error) {\n \n \t// NOTE(rsc): On Windows, it is critically important that the\n \t// gcc-compiled objects (cgoObjects) be listed after the ordinary\n-\t// objects in the archive.  I do not know why this is.\n+\t// objects in the archive. I do not know why this is.\n \t// https://golang.org/issue/2601\n \tobjects = append(objects, cgoObjects...)\n \n@@ -1658,7 +1671,7 @@ func (b *builder) install(a *action) (err error) {\n \t}\n \n \t// remove object dir to keep the amount of\n-\t// garbage down in a large build.  On an operating system\n+\t// garbage down in a large build. On an operating system\n \t// with aggressive buffering, cleaning incrementally like\n \t// this keeps the intermediate objects from hitting the disk.\n \tif !buildWork {\n@@ -1803,7 +1816,7 @@ func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode, force b\n \tdf, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \tif err != nil && toolIsWindows {\n \t\t// Windows does not allow deletion of a binary file\n-\t\t// while it is executing.  Try to move it out of the way.\n+\t\t// while it is executing. Try to move it out of the way.\n \t\t// If the move fails, which is likely, we'll try again the\n \t\t// next time we do an install of this binary.\n \t\tif err := os.Rename(dst, dst+\"~\"); err == nil {\n@@ -1933,7 +1946,7 @@ func (b *builder) showcmd(dir string, format string, args ...interface{}) {\n // The output is expected to contain references to 'dir', usually\n // the source directory for the package that has failed to build.\n // showOutput rewrites mentions of dir with a relative path to dir\n-// when the relative path is shorter.  This is usually more pleasant.\n+// when the relative path is shorter. This is usually more pleasant.\n // For example, if fmt doesn't compile and we are in src/html,\n // the output is\n //\n@@ -1991,7 +2004,7 @@ func relPaths(paths []string) []string {\n // errPrintedOutput is a special error indicating that a command failed\n // but that it generated output as well, and that output has already\n // been printed, so there's no point showing 'exit status 1' or whatever\n-// the wait status was.  The main executor, builder.do, knows not to\n+// the wait status was. The main executor, builder.do, knows not to\n // print this error.\n var errPrintedOutput = errors.New(\"already printed output - no need to show error\")\n \n@@ -2060,7 +2073,7 @@ func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...inter\n \t\terr := cmd.Run()\n \n \t\t// cmd.Run will fail on Unix if some other process has the binary\n-\t\t// we want to run open for writing.  This can happen here because\n+\t\t// we want to run open for writing. This can happen here because\n \t\t// we build and install the cgo command and then run it.\n \t\t// If another command was kicked off while we were writing the\n \t\t// cgo binary, the child process for that command may be holding\n@@ -2072,27 +2085,27 @@ func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...inter\n \t\t// The answer is that running a command is fork and exec.\n \t\t// A child forked while the cgo fd is open inherits that fd.\n \t\t// Until the child has called exec, it holds the fd open and the\n-\t\t// kernel will not let us run cgo.  Even if the child were to close\n+\t\t// kernel will not let us run cgo. Even if the child were to close\n \t\t// the fd explicitly, it would still be open from the time of the fork\n \t\t// until the time of the explicit close, and the race would remain.\n \t\t//\n \t\t// On Unix systems, this results in ETXTBSY, which formats\n \t\t// as \"text file busy\".  Rather than hard-code specific error cases,\n-\t\t// we just look for that string.  If this happens, sleep a little\n-\t\t// and try again.  We let this happen three times, with increasing\n+\t\t// we just look for that string. If this happens, sleep a little\n+\t\t// and try again. We let this happen three times, with increasing\n \t\t// sleep lengths: 100+200+400 ms = 0.7 seconds.\n \t\t//\n \t\t// An alternate solution might be to split the cmd.Run into\n \t\t// separate cmd.Start and cmd.Wait, and then use an RWLock\n \t\t// to make sure that copyFile only executes when no cmd.Start\n-\t\t// call is in progress.  However, cmd.Start (really syscall.forkExec)\n+\t\t// call is in progress. However, cmd.Start (really syscall.forkExec)\n \t\t// only guarantees that when it returns, the exec is committed to\n-\t\t// happen and succeed.  It uses a close-on-exec file descriptor\n+\t\t// happen and succeed. It uses a close-on-exec file descriptor\n \t\t// itself to determine this, so we know that when cmd.Start returns,\n \t\t// at least one close-on-exec file descriptor has been closed.\n \t\t// However, we cannot be sure that all of them have been closed,\n \t\t// so the program might still encounter ETXTBSY even with such\n-\t\t// an RWLock.  The race window would be smaller, perhaps, but not\n+\t\t// an RWLock. The race window would be smaller, perhaps, but not\n \t\t// guaranteed to be gone.\n \t\t//\n \t\t// Sleeping when we observe the race seems to be the most reliable\n@@ -2142,7 +2155,7 @@ func (b *builder) mkdir(dir string) error {\n \tb.exec.Lock()\n \tdefer b.exec.Unlock()\n \t// We can be a little aggressive about being\n-\t// sure directories exist.  Skip repeated calls.\n+\t// sure directories exist. Skip repeated calls.\n \tif b.mkdirCache[dir] {\n \t\treturn nil\n \t}\n@@ -2180,7 +2193,6 @@ func mkAbs(dir, f string) string {\n type toolchain interface {\n \t// gc runs the compiler in a specific directory on a set of files\n \t// and returns the name of the generated output file.\n-\t// The compiler runs in the directory dir.\n \tgc(b *builder, p *Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error)\n \t// cc runs the toolchain's C compiler in a directory on a C file\n \t// to produce an output file.\n@@ -2282,7 +2294,7 @@ func (gcToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool,\n \t// so that it can give good error messages about forward declarations.\n \t// Exceptions: a few standard packages have forward declarations for\n \t// pieces supplied behind-the-scenes by package runtime.\n-\textFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)\n+\textFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.FFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)\n \tif p.Standard {\n \t\tswitch p.ImportPath {\n \t\tcase \"bytes\", \"net\", \"os\", \"runtime/pprof\", \"sync\", \"time\":\n@@ -2334,7 +2346,15 @@ func (gcToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n \tinc := filepath.Join(goroot, \"pkg\", \"include\")\n \tsfile = mkAbs(p.Dir, sfile)\n-\targs := []interface{}{buildToolExec, tool(\"asm\"), \"-o\", ofile, \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch, buildAsmflags, sfile}\n+\targs := []interface{}{buildToolExec, tool(\"asm\"), \"-o\", ofile, \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch, buildAsmflags}\n+\tif p.ImportPath == \"runtime\" && goarch == \"386\" {\n+\t\tfor _, arg := range buildAsmflags {\n+\t\t\tif arg == \"-dynlink\" {\n+\t\t\t\targs = append(args, \"-D=GOBUILDMODE_shared=1\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\targs = append(args, sfile)\n \tif err := b.run(p.Dir, p.ImportPath, nil, args...); err != nil {\n \t\treturn err\n \t}\n@@ -2381,8 +2401,10 @@ func (gcToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []s\n \n \t// The archive file should have been created by the compiler.\n \t// Since it used to not work that way, verify.\n-\tif _, err := os.Stat(absAfile); err != nil {\n-\t\tfatalf(\"os.Stat of archive file failed: %v\", err)\n+\tif !buildN {\n+\t\tif _, err := os.Stat(absAfile); err != nil {\n+\t\t\tfatalf(\"os.Stat of archive file failed: %v\", err)\n+\t\t}\n \t}\n \n \tif buildN || buildX {\n@@ -2629,18 +2651,23 @@ func (gccgoToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles\n \treturn b.run(p.Dir, p.ImportPath, nil, \"ar\", \"rc\", mkAbs(objDir, afile), absOfiles)\n }\n \n-func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+func (tools gccgoToolchain) link(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string, buildmode, desc string) error {\n \t// gccgo needs explicit linking with all package dependencies,\n \t// and all LDFLAGS from cgo dependencies.\n-\tapackagesSeen := make(map[*Package]bool)\n+\tapackagePathsSeen := make(map[string]bool)\n \tafiles := []string{}\n \tshlibs := []string{}\n-\txfiles := []string{}\n \tldflags := b.gccArchArgs()\n \tcgoldflags := []string{}\n \tusesCgo := false\n-\tcxx := len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0\n-\tobjc := len(root.p.MFiles) > 0\n+\tcxx := false\n+\tobjc := false\n+\tfortran := false\n+\tif root.p != nil {\n+\t\tcxx = len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0\n+\t\tobjc = len(root.p.MFiles) > 0\n+\t\tfortran = len(root.p.FFiles) > 0\n+\t}\n \n \treadCgoFlags := func(flagsFile string) error {\n \t\tflags, err := ioutil.ReadFile(flagsFile)\n@@ -2687,11 +2714,11 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t\t}\n \n \t\tnewarchive := newa.Name()\n-\t\terr = b.run(b.work, root.p.ImportPath, nil, \"ar\", \"x\", newarchive, \"_cgo_flags\")\n+\t\terr = b.run(b.work, desc, nil, \"ar\", \"x\", newarchive, \"_cgo_flags\")\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n-\t\terr = b.run(\".\", root.p.ImportPath, nil, \"ar\", \"d\", newarchive, \"_cgo_flags\")\n+\t\terr = b.run(\".\", desc, nil, \"ar\", \"d\", newarchive, \"_cgo_flags\")\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -2723,28 +2750,18 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t\t\t// rather than the 'build' location (which may not exist any\n \t\t\t// more). We still need to traverse the dependencies of the\n \t\t\t// build action though so saying\n-\t\t\t// if apackagesSeen[a.p] { return }\n+\t\t\t// if apackagePathsSeen[a.p.ImportPath] { return }\n \t\t\t// doesn't work.\n-\t\t\tif !apackagesSeen[a.p] {\n-\t\t\t\tapackagesSeen[a.p] = true\n+\t\t\tif !apackagePathsSeen[a.p.ImportPath] {\n+\t\t\t\tapackagePathsSeen[a.p.ImportPath] = true\n \t\t\t\ttarget := a.target\n \t\t\t\tif len(a.p.CgoFiles) > 0 {\n \t\t\t\t\ttarget, err = readAndRemoveCgoFlags(target)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif a.p.fake && a.p.external {\n-\t\t\t\t\t// external _tests, if present must come before\n-\t\t\t\t\t// internal _tests. Store these on a separate list\n-\t\t\t\t\t// and place them at the head after this loop.\n-\t\t\t\t\txfiles = append(xfiles, target)\n-\t\t\t\t} else if a.p.fake {\n-\t\t\t\t\t// move _test files to the top of the link order\n-\t\t\t\t\tafiles = append([]string{target}, afiles...)\n-\t\t\t\t} else {\n-\t\t\t\t\tafiles = append(afiles, target)\n-\t\t\t\t}\n+\t\t\t\tafiles = append(afiles, target)\n \t\t\t}\n \t\t}\n \t\tif strings.HasSuffix(a.target, \".so\") {\n@@ -2764,7 +2781,6 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t\t\treturn err\n \t\t}\n \t}\n-\tafiles = append(xfiles, afiles...)\n \n \tfor _, a := range allactions {\n \t\t// Gather CgoLDFLAGS, but not from standard packages.\n@@ -2789,6 +2805,9 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t\tif len(a.p.MFiles) > 0 {\n \t\t\tobjc = true\n \t\t}\n+\t\tif len(a.p.FFiles) > 0 {\n+\t\t\tfortran = true\n+\t\t}\n \t}\n \n \tfor i, o := range ofiles {\n@@ -2805,7 +2824,9 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \n \tldflags = append(ldflags, cgoldflags...)\n \tldflags = append(ldflags, envList(\"CGO_LDFLAGS\", \"\")...)\n-\tldflags = append(ldflags, root.p.CgoLDFLAGS...)\n+\tif root.p != nil {\n+\t\tldflags = append(ldflags, root.p.CgoLDFLAGS...)\n+\t}\n \n \tldflags = stringList(\"-Wl,-(\", ldflags, \"-Wl,-)\")\n \n@@ -2820,7 +2841,7 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t}\n \n \tvar realOut string\n-\tswitch ldBuildmode {\n+\tswitch buildmode {\n \tcase \"exe\":\n \t\tif usesCgo && goos == \"linux\" {\n \t\t\tldflags = append(ldflags, \"-Wl,-E\")\n@@ -2836,7 +2857,7 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \t\t// initialization code.\n \t\t//\n \t\t// The user remains responsible for linking against\n-\t\t// -lgo -lpthread -lm in the final link.  We can't use\n+\t\t// -lgo -lpthread -lm in the final link. We can't use\n \t\t// -r to pick them up because we can't combine\n \t\t// split-stack and non-split-stack code in a single -r\n \t\t// link, and libgo picks up non-split-stack code from\n@@ -2855,56 +2876,55 @@ func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions\n \n \tcase \"c-shared\":\n \t\tldflags = append(ldflags, \"-shared\", \"-nostdlib\", \"-Wl,--whole-archive\", \"-lgolibbegin\", \"-Wl,--no-whole-archive\", \"-lgo\", \"-lgcc_s\", \"-lgcc\", \"-lc\", \"-lgcc\")\n+\tcase \"shared\":\n+\t\tldflags = append(ldflags, \"-zdefs\", \"-shared\", \"-nostdlib\", \"-lgo\", \"-lgcc_s\", \"-lgcc\", \"-lc\")\n \n \tdefault:\n-\t\tfatalf(\"-buildmode=%s not supported for gccgo\", ldBuildmode)\n+\t\tfatalf(\"-buildmode=%s not supported for gccgo\", buildmode)\n \t}\n \n-\tswitch ldBuildmode {\n+\tswitch buildmode {\n \tcase \"exe\", \"c-shared\":\n \t\tif cxx {\n \t\t\tldflags = append(ldflags, \"-lstdc++\")\n \t\t}\n \t\tif objc {\n \t\t\tldflags = append(ldflags, \"-lobjc\")\n \t\t}\n+\t\tif fortran {\n+\t\t\tfc := os.Getenv(\"FC\")\n+\t\t\tif fc == \"\" {\n+\t\t\t\tfc = \"gfortran\"\n+\t\t\t}\n+\t\t\t// support gfortran out of the box and let others pass the correct link options\n+\t\t\t// via CGO_LDFLAGS\n+\t\t\tif strings.Contains(fc, \"gfortran\") {\n+\t\t\t\tldflags = append(ldflags, \"-lgfortran\")\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tif err := b.run(\".\", root.p.ImportPath, nil, tools.linker(), \"-o\", out, ofiles, ldflags, buildGccgoflags); err != nil {\n+\tif err := b.run(\".\", desc, nil, tools.linker(), \"-o\", out, ofiles, ldflags, buildGccgoflags); err != nil {\n \t\treturn err\n \t}\n \n-\tswitch ldBuildmode {\n+\tswitch buildmode {\n \tcase \"c-archive\":\n-\t\tif err := b.run(\".\", root.p.ImportPath, nil, \"ar\", \"rc\", realOut, out); err != nil {\n+\t\tif err := b.run(\".\", desc, nil, \"ar\", \"rc\", realOut, out); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n \treturn nil\n }\n \n+func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+\treturn tools.link(b, root, out, allactions, mainpkg, ofiles, ldBuildmode, root.p.ImportPath)\n+}\n+\n func (tools gccgoToolchain) ldShared(b *builder, toplevelactions []*action, out string, allactions []*action) error {\n-\targs := []string{\"-o\", out, \"-shared\", \"-nostdlib\", \"-zdefs\", \"-Wl,--whole-archive\"}\n-\tfor _, a := range toplevelactions {\n-\t\targs = append(args, a.target)\n-\t}\n-\targs = append(args, \"-Wl,--no-whole-archive\", \"-shared\", \"-nostdlib\", \"-lgo\", \"-lgcc_s\", \"-lgcc\", \"-lc\")\n-\tshlibs := []string{}\n-\tfor _, a := range allactions {\n-\t\tif strings.HasSuffix(a.target, \".so\") {\n-\t\t\tshlibs = append(shlibs, a.target)\n-\t\t}\n-\t}\n-\tfor _, shlib := range shlibs {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\t\"-L\"+filepath.Dir(shlib),\n-\t\t\t\"-Wl,-rpath=\"+filepath.Dir(shlib),\n-\t\t\t\"-l\"+strings.TrimSuffix(\n-\t\t\t\tstrings.TrimPrefix(filepath.Base(shlib), \"lib\"),\n-\t\t\t\t\".so\"))\n-\t}\n-\treturn b.run(\".\", out, nil, tools.linker(), args, buildGccgoflags)\n+\tfakeRoot := &action{}\n+\tfakeRoot.deps = toplevelactions\n+\treturn tools.link(b, fakeRoot, out, allactions, \"\", nil, \"shared\", out)\n }\n \n func (tools gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n@@ -2962,6 +2982,11 @@ func (b *builder) gxx(p *Package, out string, flags []string, cxxfile string) er\n \treturn b.ccompile(p, out, flags, cxxfile, b.gxxCmd(p.Dir))\n }\n \n+// gfortran runs the gfortran Fortran compiler to create an object from a single Fortran file.\n+func (b *builder) gfortran(p *Package, out string, flags []string, ffile string) error {\n+\treturn b.ccompile(p, out, flags, ffile, b.gfortranCmd(p.Dir))\n+}\n+\n // ccompile runs the given C or C++ compiler and creates an object from a single source file.\n func (b *builder) ccompile(p *Package, out string, flags []string, file string, compiler []string) error {\n \tfile = mkAbs(p.Dir, file)\n@@ -2991,6 +3016,11 @@ func (b *builder) gxxCmd(objdir string) []string {\n \treturn b.ccompilerCmd(\"CXX\", defaultCXX, objdir)\n }\n \n+// gfortranCmd returns a gfortran command line prefix.\n+func (b *builder) gfortranCmd(objdir string) []string {\n+\treturn b.ccompilerCmd(\"FC\", \"gfortran\", objdir)\n+}\n+\n // ccompilerCmd returns a command line prefix for the given environment\n // variable and using the default command when the variable is empty.\n func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n@@ -3028,6 +3058,17 @@ func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n \t// disable word wrapping in error messages\n \ta = append(a, \"-fmessage-length=0\")\n \n+\t// Tell gcc not to include the work directory in object files.\n+\tif b.gccSupportsFlag(\"-fdebug-prefix-map=a=b\") {\n+\t\ta = append(a, \"-fdebug-prefix-map=\"+b.work+\"=/tmp/go-build\")\n+\t}\n+\n+\t// Tell gcc not to include flags in object files, which defeats the\n+\t// point of -fdebug-prefix-map above.\n+\tif b.gccSupportsFlag(\"-gno-record-gcc-switches\") {\n+\t\ta = append(a, \"-gno-record-gcc-switches\")\n+\t}\n+\n \t// On OS X, some of the compilers behave as if -fno-common\n \t// is always set, and the Mach-O linker in 6l/8l assumes this.\n \t// See https://golang.org/issue/3253.\n@@ -3042,19 +3083,24 @@ func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n // -no-pie must be passed when doing a partial link with -Wl,-r. But -no-pie is\n // not supported by all compilers.\n func (b *builder) gccSupportsNoPie() bool {\n-\tif goos != \"linux\" {\n-\t\t// On some BSD platforms, error messages from the\n-\t\t// compiler make it to the console despite cmd.Std*\n-\t\t// all being nil. As -no-pie is only required on linux\n-\t\t// systems so far, we only test there.\n-\t\treturn false\n+\treturn b.gccSupportsFlag(\"-no-pie\")\n+}\n+\n+// gccSupportsFlag checks to see if the compiler supports a flag.\n+func (b *builder) gccSupportsFlag(flag string) bool {\n+\tb.exec.Lock()\n+\tdefer b.exec.Unlock()\n+\tif b, ok := b.flagCache[flag]; ok {\n+\t\treturn b\n \t}\n-\tsrc := filepath.Join(b.work, \"trivial.c\")\n-\tif err := ioutil.WriteFile(src, []byte{}, 0666); err != nil {\n-\t\treturn false\n+\tif b.flagCache == nil {\n+\t\tsrc := filepath.Join(b.work, \"trivial.c\")\n+\t\tif err := ioutil.WriteFile(src, []byte{}, 0666); err != nil {\n+\t\t\treturn false\n+\t\t}\n+\t\tb.flagCache = make(map[string]bool)\n \t}\n-\tcmdArgs := b.gccCmd(b.work)\n-\tcmdArgs = append(cmdArgs, \"-no-pie\", \"-c\", \"trivial.c\")\n+\tcmdArgs := append(envList(\"CC\", defaultCC), flag, \"-c\", \"trivial.c\")\n \tif buildN || buildX {\n \t\tb.showcmd(b.work, \"%s\", joinUnambiguously(cmdArgs))\n \t\tif buildN {\n@@ -3063,9 +3109,11 @@ func (b *builder) gccSupportsNoPie() bool {\n \t}\n \tcmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)\n \tcmd.Dir = b.work\n-\tcmd.Env = envForDir(cmd.Dir, os.Environ())\n+\tcmd.Env = mergeEnvLists([]string{\"LC_ALL=C\"}, envForDir(cmd.Dir, os.Environ()))\n \tout, err := cmd.CombinedOutput()\n-\treturn err == nil && !bytes.Contains(out, []byte(\"unrecognized\"))\n+\tsupported := err == nil && !bytes.Contains(out, []byte(\"unrecognized\"))\n+\tb.flagCache[flag] = supported\n+\treturn supported\n }\n \n // gccArchArgs returns arguments to pass to gcc based on the architecture.\n@@ -3077,6 +3125,10 @@ func (b *builder) gccArchArgs() []string {\n \t\treturn []string{\"-m64\"}\n \tcase \"arm\":\n \t\treturn []string{\"-marm\"} // not thumb\n+\tcase \"s390x\":\n+\t\treturn []string{\"-m64\", \"-march=z196\"}\n+\tcase \"mips64\", \"mips64le\":\n+\t\treturn []string{\"-mabi=64\"}\n \t}\n \treturn nil\n }\n@@ -3091,8 +3143,8 @@ func envList(key, def string) []string {\n \treturn strings.Fields(v)\n }\n \n-// Return the flags to use when invoking the C or C++ compilers, or cgo.\n-func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, ldflags []string) {\n+// Return the flags to use when invoking the C, C++ or Fortran compilers, or cgo.\n+func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, fflags, ldflags []string) {\n \tvar defaults string\n \tif def {\n \t\tdefaults = \"-g -O2\"\n@@ -3101,22 +3153,36 @@ func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, ldfl\n \tcppflags = stringList(envList(\"CGO_CPPFLAGS\", \"\"), p.CgoCPPFLAGS)\n \tcflags = stringList(envList(\"CGO_CFLAGS\", defaults), p.CgoCFLAGS)\n \tcxxflags = stringList(envList(\"CGO_CXXFLAGS\", defaults), p.CgoCXXFLAGS)\n+\tfflags = stringList(envList(\"CGO_FFLAGS\", defaults), p.CgoFFLAGS)\n \tldflags = stringList(envList(\"CGO_LDFLAGS\", defaults), p.CgoLDFLAGS)\n \treturn\n }\n \n var cgoRe = regexp.MustCompile(`[/\\\\:]`)\n \n-func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := b.cflags(p, true)\n-\t_, cgoexeCFLAGS, _, _ := b.cflags(p, false)\n+func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS := b.cflags(p, true)\n+\t_, cgoexeCFLAGS, _, _, _ := b.cflags(p, false)\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)\n \tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n \t// If we are compiling Objective-C code, then we need to link against libobjc\n \tif len(mfiles) > 0 {\n \t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-lobjc\")\n \t}\n \n+\t// Likewise for Fortran, except there are many Fortran compilers.\n+\t// Support gfortran out of the box and let others pass the correct link options\n+\t// via CGO_LDFLAGS\n+\tif len(ffiles) > 0 {\n+\t\tfc := os.Getenv(\"FC\")\n+\t\tif fc == \"\" {\n+\t\t\tfc = \"gfortran\"\n+\t\t}\n+\t\tif strings.Contains(fc, \"gfortran\") {\n+\t\t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-lgfortran\")\n+\t\t}\n+\t}\n+\n \tif buildMSan && p.ImportPath != \"runtime/cgo\" {\n \t\tcgoCFLAGS = append([]string{\"-fsanitize=memory\"}, cgoCFLAGS...)\n \t\tcgoLDFLAGS = append([]string{\"-fsanitize=memory\"}, cgoLDFLAGS...)\n@@ -3221,7 +3287,7 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\n \t\tcase strings.HasPrefix(f, \"-fsanitize=\"):\n \t\t\tcontinue\n \t\t// runpath flags not applicable unless building a shared\n-\t\t// object or executable; see issue 12115 for details.  This\n+\t\t// object or executable; see issue 12115 for details. This\n \t\t// is necessary as Go currently does not offer a way to\n \t\t// specify the set of LDFLAGS that only apply to shared\n \t\t// objects.\n@@ -3284,6 +3350,17 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofi\n \t\toutObj = append(outObj, ofile)\n \t}\n \n+\tfflags := stringList(cgoCPPFLAGS, cgoFFLAGS)\n+\tfor _, file := range ffiles {\n+\t\t// Append .o to the file, just in case the pkg has file.c and file.f\n+\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tif err := b.gfortran(p, ofile, fflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tlinkobj = append(linkobj, ofile)\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n \tlinkobj = append(linkobj, p.SysoFiles...)\n \tdynobj := obj + \"_cgo_.o\"\n \tpie := (goarch == \"arm\" && goos == \"linux\") || goos == \"android\"\n@@ -3449,15 +3526,22 @@ func (b *builder) swigVersionCheck() error {\n \treturn swigCheck\n }\n \n+// Find the value to pass for the -intgosize option to swig.\n+var (\n+\tswigIntSizeOnce  sync.Once\n+\tswigIntSize      string\n+\tswigIntSizeError error\n+)\n+\n // This code fails to build if sizeof(int) <= 32\n const swigIntSizeCode = `\n package main\n const i int = 1 << 32\n `\n \n // Determine the size of int on the target system for the -intgosize option\n-// of swig >= 2.0.9\n-func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n+// of swig >= 2.0.9.  Run only once.\n+func (b *builder) swigDoIntSize(obj string) (intsize string, err error) {\n \tif buildN {\n \t\treturn \"$INTBITS\", nil\n \t}\n@@ -3475,9 +3559,18 @@ func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n \treturn \"64\", nil\n }\n \n+// Determine the size of int on the target system for the -intgosize option\n+// of swig >= 2.0.9.\n+func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n+\tswigIntSizeOnce.Do(func() {\n+\t\tswigIntSize, swigIntSizeError = b.swigDoIntSize(obj)\n+\t})\n+\treturn swigIntSize, swigIntSizeError\n+}\n+\n // Run SWIG on one SWIG input file.\n func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _ := b.cflags(p, true)\n \tvar cflags []string\n \tif cxx {\n \t\tcflags = stringList(cgoCPPFLAGS, pcCFLAGS, cgoCXXFLAGS)\n@@ -3545,12 +3638,12 @@ func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx b\n \n // disableBuildID adjusts a linker command line to avoid creating a\n // build ID when creating an object file rather than an executable or\n-// shared library.  Some systems, such as Ubuntu, always add\n+// shared library. Some systems, such as Ubuntu, always add\n // --build-id to every link, but we don't want a build ID when we are\n-// producing an object file.  On some of those system a plain -r (not\n+// producing an object file. On some of those system a plain -r (not\n // -Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a\n-// plain -r.  I don't know how to turn off --build-id when using clang\n-// other than passing a trailing --build-id=none.  So that is what we\n+// plain -r. I don't know how to turn off --build-id when using clang\n+// other than passing a trailing --build-id=none. So that is what we\n // do, but only on systems likely to support it, which is to say,\n // systems that normally use gold or the GNU linker.\n func (b *builder) disableBuildID(ldflags []string) []string {"}, {"sha": "7b07150743a4a4b635c85d13c223e7aec73d8511", "filename": "libgo/go/cmd/go/clean.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "94cd54d00d8a474057ab1e6d974533b858e1c739", "filename": "libgo/go/cmd/go/context.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -26,6 +26,7 @@ func newContext(c *build.Context) *Context {\n \t\tGOARCH:        c.GOARCH,\n \t\tGOOS:          c.GOOS,\n \t\tGOROOT:        c.GOROOT,\n+\t\tGOPATH:        c.GOPATH,\n \t\tCgoEnabled:    c.CgoEnabled,\n \t\tUseAllFiles:   c.UseAllFiles,\n \t\tCompiler:      c.Compiler,"}, {"sha": "b60eaef739815a59f3ee5dd920d7158e94b2b27a", "filename": "libgo/go/cmd/go/discovery.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "829983950f8094f823e27ef7244ddd24cb81ffdb", "filename": "libgo/go/cmd/go/doc.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,7 +1,9 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:generate ./mkalldocs.sh\n+\n package main\n \n var cmdDoc = &Command{"}, {"sha": "8aaaf463292257b2856db26a2e316aaa7415df30", "filename": "libgo/go/cmd/go/env.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -33,11 +33,6 @@ func mkEnv() []envVar {\n \tvar b builder\n \tb.init()\n \n-\tvendorExpValue := \"0\"\n-\tif go15VendorExperiment {\n-\t\tvendorExpValue = \"1\"\n-\t}\n-\n \tenv := []envVar{\n \t\t{\"GOARCH\", goarch},\n \t\t{\"GOBIN\", gobin},\n@@ -49,7 +44,6 @@ func mkEnv() []envVar {\n \t\t{\"GORACE\", os.Getenv(\"GORACE\")},\n \t\t{\"GOROOT\", goroot},\n \t\t{\"GOTOOLDIR\", toolDir},\n-\t\t{\"GO15VENDOREXPERIMENT\", vendorExpValue},\n \n \t\t// disable escape codes in clang errors\n \t\t{\"TERM\", \"dumb\"},"}, {"sha": "3af7adb4e1c54227acebad280e8469b9fcc00b06", "filename": "libgo/go/cmd/go/fix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "4ed7722575e5ee28dcb3fd774e0b48a89bf5e72f", "filename": "libgo/go/cmd/go/fmt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "3c6065e89aafa75f57835862e3bdc2d338e43250", "filename": "libgo/go/cmd/go/generate.go", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -14,10 +14,8 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n-\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"unicode\"\n )\n \n var cmdGenerate = &Command{\n@@ -277,8 +275,8 @@ func isGoGenerate(buf []byte) bool {\n // single go:generate command.\n func (g *Generator) setEnv() {\n \tg.env = []string{\n-\t\t\"GOARCH=\" + runtime.GOARCH,\n-\t\t\"GOOS=\" + runtime.GOOS,\n+\t\t\"GOARCH=\" + buildContext.GOARCH,\n+\t\t\"GOOS=\" + buildContext.GOOS,\n \t\t\"GOFILE=\" + g.file,\n \t\t\"GOLINE=\" + strconv.Itoa(g.lineNum),\n \t\t\"GOPACKAGE=\" + g.pkg,\n@@ -371,17 +369,6 @@ func (g *Generator) expandVar(word string) string {\n \treturn os.Getenv(word)\n }\n \n-// identLength returns the length of the identifier beginning the string.\n-func (g *Generator) identLength(word string) int {\n-\tfor i, r := range word {\n-\t\tif r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r) {\n-\t\t\tcontinue\n-\t\t}\n-\t\treturn i\n-\t}\n-\treturn len(word)\n-}\n-\n // setShorthand installs a new shorthand as defined by a -command directive.\n func (g *Generator) setShorthand(words []string) {\n \t// Create command shorthand."}, {"sha": "dd116e6cc614fbb0bfe36a9202656f96b95c4f23", "filename": "libgo/go/cmd/go/generate_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "19858f7e55db928bbaaef5961f2229f59a1f9bdd", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -19,8 +19,8 @@ var cmdGet = &Command{\n \tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n-Get downloads and installs the packages named by the import paths,\n-along with their dependencies.\n+Get downloads the packages named by the import paths, along with their\n+dependencies. It then installs the named packages, like 'go install'.\n \n The -d flag instructs get to stop after downloading the packages; that is,\n it instructs get not to install the packages.\n@@ -45,7 +45,7 @@ missing packages but does not use it to look for updates to existing packages.\n \n Get also accepts build flags to control the installation. See 'go help build'.\n \n-When checking out a new package, get creates the target directory \n+When checking out a new package, get creates the target directory\n GOPATH/src/<import-path>. If the GOPATH contains multiple entries,\n get uses the first one. See 'go help gopath'.\n \n@@ -55,8 +55,7 @@ rule is that if the local installation is running version \"go1\", get\n searches for a branch or tag named \"go1\". If no such version exists it\n retrieves the most recent version of the package.\n \n-Unless vendoring support is disabled (see 'go help gopath'),\n-when go get checks out or updates a Git repository,\n+When go get checks out or updates a Git repository,\n it also updates any git submodules referenced by the repository.\n \n Get never checks out or updates code stored in vendor directories.\n@@ -112,13 +111,21 @@ func runGet(cmd *Command, args []string) {\n \n \t// Code we downloaded and all code that depends on it\n \t// needs to be evicted from the package cache so that\n-\t// the information will be recomputed.  Instead of keeping\n+\t// the information will be recomputed. Instead of keeping\n \t// track of the reverse dependency information, evict\n \t// everything.\n \tfor name := range packageCache {\n \t\tdelete(packageCache, name)\n \t}\n \n+\t// In order to rebuild packages information completely,\n+\t// we need to clear commands cache. Command packages are\n+\t// referring to evicted packages from the package cache.\n+\t// This leads to duplicated loads of the standard packages.\n+\tfor name := range cmdCache {\n+\t\tdelete(cmdCache, name)\n+\t}\n+\n \targs = importPaths(args)\n \tpackagesForBuild(args)\n \n@@ -134,7 +141,7 @@ func runGet(cmd *Command, args []string) {\n }\n \n // downloadPaths prepares the list of paths to pass to download.\n-// It expands ... patterns that can be expanded.  If there is no match\n+// It expands ... patterns that can be expanded. If there is no match\n // for a particular pattern, downloadPaths leaves it in the result list,\n // in the hope that we can figure out the repository from the\n // initial ...-free prefix.\n@@ -145,7 +152,7 @@ func downloadPaths(args []string) []string {\n \t\tif strings.Contains(a, \"...\") {\n \t\t\tvar expand []string\n \t\t\t// Use matchPackagesInFS to avoid printing\n-\t\t\t// warnings.  They will be printed by the\n+\t\t\t// warnings. They will be printed by the\n \t\t\t// eventual call to importPaths instead.\n \t\t\tif build.IsLocalImport(a) {\n \t\t\t\texpand = matchPackagesInFS(a)\n@@ -228,16 +235,6 @@ func download(arg string, parent *Package, stk *importStack, mode int) {\n \t\t\tstk.pop()\n \t\t\treturn\n \t\t}\n-\n-\t\t// Warn that code.google.com is shutting down.  We\n-\t\t// issue the warning here because this is where we\n-\t\t// have the import stack.\n-\t\tif strings.HasPrefix(p.ImportPath, \"code.google.com\") {\n-\t\t\tfmt.Fprintf(os.Stderr, \"warning: code.google.com is shutting down; import path %v will stop working\\n\", p.ImportPath)\n-\t\t\tif len(*stk) > 1 {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: package %v\\n\", strings.Join(*stk, \"\\n\\timports \"))\n-\t\t\t}\n-\t\t}\n \t\tstk.pop()\n \n \t\targs := []string{arg}\n@@ -347,16 +344,16 @@ func downloadPackage(p *Package) error {\n \t}\n \n \tif p.build.SrcRoot != \"\" {\n-\t\t// Directory exists.  Look for checkout along path to src.\n-\t\tvcs, rootPath, err = vcsForDir(p)\n+\t\t// Directory exists. Look for checkout along path to src.\n+\t\tvcs, rootPath, err = vcsFromDir(p.Dir, p.build.SrcRoot)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\trepo = \"<local>\" // should be unused; make distinctive\n \n \t\t// Double-check where it came from.\n \t\tif *getU && vcs.remoteRepo != nil {\n-\t\t\tdir := filepath.Join(p.build.SrcRoot, rootPath)\n+\t\t\tdir := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))\n \t\t\tremote, err := vcs.remoteRepo(vcs, dir)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n@@ -391,7 +388,7 @@ func downloadPackage(p *Package) error {\n \t}\n \n \tif p.build.SrcRoot == \"\" {\n-\t\t// Package not found.  Put in first directory of $GOPATH.\n+\t\t// Package not found. Put in first directory of $GOPATH.\n \t\tlist := filepath.SplitList(buildContext.GOPATH)\n \t\tif len(list) == 0 {\n \t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: go help gopath\")\n@@ -403,7 +400,7 @@ func downloadPackage(p *Package) error {\n \t\tp.build.SrcRoot = filepath.Join(list[0], \"src\")\n \t\tp.build.PkgRoot = filepath.Join(list[0], \"pkg\")\n \t}\n-\troot := filepath.Join(p.build.SrcRoot, rootPath)\n+\troot := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))\n \t// If we've considered this repository already, don't do it again.\n \tif downloadRootCache[root] {\n \t\treturn nil\n@@ -422,7 +419,7 @@ func downloadPackage(p *Package) error {\n \t\treturn fmt.Errorf(\"%s exists but is not a directory\", meta)\n \t}\n \tif err != nil {\n-\t\t// Metadata directory does not exist.  Prepare to checkout new copy.\n+\t\t// Metadata directory does not exist. Prepare to checkout new copy.\n \t\t// Some version control tools require the target directory not to exist.\n \t\t// We require that too, just to avoid stepping on existing work.\n \t\tif _, err := os.Stat(root); err == nil {"}, {"sha": "7e383f4b5b0e73578b623f4d07c93ef6747ebef7", "filename": "libgo/go/cmd/go/go11.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "66c641347cb27b5e8fd68d7aaf282c354b64a07b", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 349, "deletions": 154, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -109,7 +109,7 @@ func TestMain(m *testing.M) {\n \tos.Exit(r)\n }\n \n-// The length of an mtime tick on this system.  This is an estimate of\n+// The length of an mtime tick on this system. This is an estimate of\n // how long we need to sleep to ensure that the mtime of two files is\n // different.\n // We used to try to be clever but that didn't always work (see golang.org/issue/12205).\n@@ -181,7 +181,7 @@ func (tg *testgoData) pwd() string {\n \treturn wd\n }\n \n-// cd changes the current directory to the named directory.  Note that\n+// cd changes the current directory to the named directory. Note that\n // using this means that the test must not be run in parallel with any\n // other tests.\n func (tg *testgoData) cd(dir string) {\n@@ -325,7 +325,7 @@ func (tg *testgoData) getStderr() string {\n }\n \n // doGrepMatch looks for a regular expression in a buffer, and returns\n-// whether it is found.  The regular expression is matched against\n+// whether it is found. The regular expression is matched against\n // each line separately, as with the grep command.\n func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n \tif !tg.ran {\n@@ -341,7 +341,7 @@ func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n }\n \n // doGrep looks for a regular expression in a buffer and fails if it\n-// is not found.  The name argument is the name of the output we are\n+// is not found. The name argument is the name of the output we are\n // searching, \"output\" or \"error\".  The msg argument is logged on\n // failure.\n func (tg *testgoData) doGrep(match string, b *bytes.Buffer, name, msg string) {\n@@ -375,7 +375,7 @@ func (tg *testgoData) grepBoth(match, msg string) {\n }\n \n // doGrepNot looks for a regular expression in a buffer and fails if\n-// it is found.  The name and msg arguments are as for doGrep.\n+// it is found. The name and msg arguments are as for doGrep.\n func (tg *testgoData) doGrepNot(match string, b *bytes.Buffer, name, msg string) {\n \tif tg.doGrepMatch(match, b) {\n \t\ttg.t.Log(msg)\n@@ -421,27 +421,15 @@ func (tg *testgoData) doGrepCount(match string, b *bytes.Buffer) int {\n \treturn c\n }\n \n-// grepCountStdout returns the number of times a regexp is seen in\n-// standard output.\n-func (tg *testgoData) grepCountStdout(match string) int {\n-\treturn tg.doGrepCount(match, &tg.stdout)\n-}\n-\n-// grepCountStderr returns the number of times a regexp is seen in\n-// standard error.\n-func (tg *testgoData) grepCountStderr(match string) int {\n-\treturn tg.doGrepCount(match, &tg.stderr)\n-}\n-\n // grepCountBoth returns the number of times a regexp is seen in both\n // standard output and standard error.\n func (tg *testgoData) grepCountBoth(match string) int {\n \treturn tg.doGrepCount(match, &tg.stdout) + tg.doGrepCount(match, &tg.stderr)\n }\n \n // creatingTemp records that the test plans to create a temporary file\n-// or directory.  If the file or directory exists already, it will be\n-// removed.  When the test completes, the file or directory will be\n+// or directory. If the file or directory exists already, it will be\n+// removed. When the test completes, the file or directory will be\n // removed if it exists.\n func (tg *testgoData) creatingTemp(path string) {\n \tif filepath.IsAbs(path) && !strings.HasPrefix(path, tg.tempdir) {\n@@ -457,7 +445,7 @@ func (tg *testgoData) creatingTemp(path string) {\n \ttg.temps = append(tg.temps, path)\n }\n \n-// makeTempdir makes a temporary directory for a run of testgo.  If\n+// makeTempdir makes a temporary directory for a run of testgo. If\n // the temporary directory was already created, this does nothing.\n func (tg *testgoData) makeTempdir() {\n \tif tg.tempdir == \"\" {\n@@ -501,6 +489,16 @@ func (tg *testgoData) path(name string) string {\n \treturn filepath.Join(tg.tempdir, name)\n }\n \n+// mustExist fails if path does not exist.\n+func (tg *testgoData) mustExist(path string) {\n+\tif _, err := os.Stat(path); err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\ttg.t.Fatalf(\"%s does not exist but should\", path)\n+\t\t}\n+\t\ttg.t.Fatalf(\"%s stat failed: %v\", path, err)\n+\t}\n+}\n+\n // mustNotExist fails if path exists.\n func (tg *testgoData) mustNotExist(path string) {\n \tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n@@ -536,32 +534,43 @@ func (tg *testgoData) wantArchive(path string) {\n \t}\n }\n \n-// isStale returns whether pkg is stale.\n-func (tg *testgoData) isStale(pkg string) bool {\n-\ttg.run(\"list\", \"-f\", \"{{.Stale}}\", pkg)\n-\tswitch v := strings.TrimSpace(tg.getStdout()); v {\n-\tcase \"true\":\n-\t\treturn true\n-\tcase \"false\":\n-\t\treturn false\n-\tdefault:\n-\t\ttg.t.Fatalf(\"unexpected output checking staleness of package %v: %v\", pkg, v)\n-\t\tpanic(\"unreachable\")\n+// isStale reports whether pkg is stale, and why\n+func (tg *testgoData) isStale(pkg string) (bool, string) {\n+\ttg.run(\"list\", \"-f\", \"{{.Stale}}:{{.StaleReason}}\", pkg)\n+\tv := strings.TrimSpace(tg.getStdout())\n+\tf := strings.SplitN(v, \":\", 2)\n+\tif len(f) == 2 {\n+\t\tswitch f[0] {\n+\t\tcase \"true\":\n+\t\t\treturn true, f[1]\n+\t\tcase \"false\":\n+\t\t\treturn false, f[1]\n+\t\t}\n \t}\n+\ttg.t.Fatalf(\"unexpected output checking staleness of package %v: %v\", pkg, v)\n+\tpanic(\"unreachable\")\n }\n \n // wantStale fails with msg if pkg is not stale.\n-func (tg *testgoData) wantStale(pkg, msg string) {\n-\tif !tg.isStale(pkg) {\n+func (tg *testgoData) wantStale(pkg, reason, msg string) {\n+\tstale, why := tg.isStale(pkg)\n+\tif !stale {\n \t\ttg.t.Fatal(msg)\n \t}\n+\tif reason == \"\" && why != \"\" || !strings.Contains(why, reason) {\n+\t\ttg.t.Errorf(\"wrong reason for Stale=true: %q, want %q\", why, reason)\n+\t}\n }\n \n // wantNotStale fails with msg if pkg is stale.\n-func (tg *testgoData) wantNotStale(pkg, msg string) {\n-\tif tg.isStale(pkg) {\n+func (tg *testgoData) wantNotStale(pkg, reason, msg string) {\n+\tstale, why := tg.isStale(pkg)\n+\tif stale {\n \t\ttg.t.Fatal(msg)\n \t}\n+\tif reason == \"\" && why != \"\" || !strings.Contains(why, reason) {\n+\t\ttg.t.Errorf(\"wrong reason for Stale=false: %q, want %q\", why, reason)\n+\t}\n }\n \n // cleanup cleans up a test that runs testgo.\n@@ -581,32 +590,6 @@ func (tg *testgoData) cleanup() {\n \t}\n }\n \n-// resetReadOnlyFlagAll resets windows read-only flag\n-// set on path and any children it contains.\n-// The flag is set by git and has to be removed.\n-// os.Remove refuses to remove files with read-only flag set.\n-func (tg *testgoData) resetReadOnlyFlagAll(path string) {\n-\tfi, err := os.Stat(path)\n-\tif err != nil {\n-\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n-\t}\n-\tif !fi.IsDir() {\n-\t\terr := os.Chmod(path, 0666)\n-\t\tif err != nil {\n-\t\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n-\t\t}\n-\t}\n-\tfd, err := os.Open(path)\n-\tif err != nil {\n-\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n-\t}\n-\tdefer fd.Close()\n-\tnames, _ := fd.Readdirnames(-1)\n-\tfor _, name := range names {\n-\t\ttg.resetReadOnlyFlagAll(path + string(filepath.Separator) + name)\n-\t}\n-}\n-\n // failSSH puts an ssh executable in the PATH that always fails.\n // This is to stub out uses of ssh by go get.\n func (tg *testgoData) failSSH() {\n@@ -720,7 +703,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \ttg.tempFile(\"d1/src/p1/p1.go\", `package p1`)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n \ttg.run(\"install\", \"-a\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly\")\n \ttg.sleep()\n \n \t// Changing mtime and content of runtime/internal/sys/sys.go\n@@ -729,28 +712,28 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \tsys := runtime.GOROOT() + \"/src/runtime/internal/sys/sys.go\"\n \trestore := addNL(sys)\n \tdefer restore()\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after updating runtime/internal/sys/sys.go\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after updating runtime/internal/sys/sys.go\")\n \trestore()\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after restoring runtime/internal/sys/sys.go\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after restoring runtime/internal/sys/sys.go\")\n \n \t// But changing runtime/internal/sys/zversion.go should have an effect:\n \t// that's how we tell when we flip from one release to another.\n \tzversion := runtime.GOROOT() + \"/src/runtime/internal/sys/zversion.go\"\n \trestore = addNL(zversion)\n \tdefer restore()\n-\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to new release\")\n+\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to new release\")\n \trestore()\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after changing back to old release\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after changing back to old release\")\n \taddNL(zversion)\n-\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing again to new release\")\n+\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing again to new release\")\n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after building with new release\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with new release\")\n \n \t// Restore to \"old\" release.\n \trestore()\n-\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to old release after new build\")\n+\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to old release after new build\")\n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after building with old release\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with old release\")\n \n \t// Everything is out of date. Rebuild to leave things in a better state.\n \ttg.run(\"install\", \"std\")\n@@ -833,8 +816,8 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\")+sep+tg.path(\"d2\"))\n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly\")\n-\ttg.wantNotStale(\"p2\", \"./testgo list claims p2 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale, incorrectly\")\n \ttg.sleep()\n \tif f, err := os.OpenFile(tg.path(\"d2/src/p2/p2.go\"), os.O_WRONLY|os.O_APPEND, 0); err != nil {\n \t\tt.Fatal(err)\n@@ -843,12 +826,12 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \t} else {\n \t\ttg.must(f.Close())\n \t}\n-\ttg.wantStale(\"p2\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n-\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p2\", \"newer source file\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p1\", \"stale dependency\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n \n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p2\", \"./testgo list claims p2 is stale after reinstall, incorrectly\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after reinstall, incorrectly\")\n+\ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale after reinstall, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after reinstall, incorrectly\")\n }\n \n func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n@@ -862,13 +845,13 @@ func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n \t\tpackage mypkg`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"install\", \"mypkg\")\n-\ttg.wantNotStale(\"mypkg\", \"./testgo list mypkg claims mypkg is stale, incorrectly\")\n+\ttg.wantNotStale(\"mypkg\", \"\", \"./testgo list mypkg claims mypkg is stale, incorrectly\")\n \t// z.go was not part of the build; removing it is okay.\n \ttg.must(os.Remove(tg.path(\"src/mypkg/z.go\")))\n-\ttg.wantNotStale(\"mypkg\", \"./testgo list mypkg claims mypkg is stale after removing z.go; should not be stale\")\n+\ttg.wantNotStale(\"mypkg\", \"\", \"./testgo list mypkg claims mypkg is stale after removing z.go; should not be stale\")\n \t// y.go was part of the package; removing it should be detected.\n \ttg.must(os.Remove(tg.path(\"src/mypkg/y.go\")))\n-\ttg.wantStale(\"mypkg\", \"./testgo list mypkg claims mypkg is NOT stale after removing y.go; should be stale\")\n+\ttg.wantStale(\"mypkg\", \"build ID mismatch\", \"./testgo list mypkg claims mypkg is NOT stale after removing y.go; should be stale\")\n }\n \n func TestWildcardMatchesSyntaxErrorDirs(t *testing.T) {\n@@ -931,13 +914,13 @@ func TestGoInstallDetectsRemovedFilesInPackageMain(t *testing.T) {\n \t\tpackage main`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"install\", \"mycmd\")\n-\ttg.wantNotStale(\"mycmd\", \"./testgo list mypkg claims mycmd is stale, incorrectly\")\n+\ttg.wantNotStale(\"mycmd\", \"\", \"./testgo list mypkg claims mycmd is stale, incorrectly\")\n \t// z.go was not part of the build; removing it is okay.\n \ttg.must(os.Remove(tg.path(\"src/mycmd/z.go\")))\n-\ttg.wantNotStale(\"mycmd\", \"./testgo list mycmd claims mycmd is stale after removing z.go; should not be stale\")\n+\ttg.wantNotStale(\"mycmd\", \"\", \"./testgo list mycmd claims mycmd is stale after removing z.go; should not be stale\")\n \t// y.go was part of the package; removing it should be detected.\n \ttg.must(os.Remove(tg.path(\"src/mycmd/y.go\")))\n-\ttg.wantStale(\"mycmd\", \"./testgo list mycmd claims mycmd is NOT stale after removing y.go; should be stale\")\n+\ttg.wantStale(\"mycmd\", \"build ID mismatch\", \"./testgo list mycmd claims mycmd is NOT stale after removing y.go; should be stale\")\n }\n \n func testLocalRun(tg *testgoData, exepath, local, match string) {\n@@ -1105,8 +1088,8 @@ func testMove(t *testing.T, vcs, url, base, config string) {\n \t}\n \tif vcs == \"git\" {\n \t\t// git will ask for a username and password when we\n-\t\t// run go get -d -f -u.  An empty username and\n-\t\t// password will work.  Prevent asking by setting\n+\t\t// run go get -d -f -u. An empty username and\n+\t\t// password will work. Prevent asking by setting\n \t\t// GIT_ASKPASS.\n \t\ttg.creatingTemp(\"sink\" + exeSuffix)\n \t\ttg.tempFile(\"src/sink/sink.go\", `package main; func main() {}`)\n@@ -1178,7 +1161,7 @@ func TestImportCommentConflict(t *testing.T) {\n \ttg.grepStderr(\"found import comments\", \"go build did not mention comment conflict\")\n }\n \n-// cmd/go: custom import path checking should not apply to github.com/xxx/yyy.\n+// cmd/go: custom import path checking should not apply to Go packages without import comment.\n func TestIssue10952(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \tif _, err := exec.LookPath(\"git\"); err != nil {\n@@ -1193,11 +1176,38 @@ func TestIssue10952(t *testing.T) {\n \tconst importPath = \"github.com/zombiezen/go-get-issue-10952\"\n \ttg.run(\"get\", \"-d\", \"-u\", importPath)\n \trepoDir := tg.path(\"src/\" + importPath)\n-\tdefer tg.resetReadOnlyFlagAll(repoDir)\n \ttg.runGit(repoDir, \"remote\", \"set-url\", \"origin\", \"https://\"+importPath+\".git\")\n \ttg.run(\"get\", \"-d\", \"-u\", importPath)\n }\n \n+// Test git clone URL that uses SCP-like syntax and custom import path checking.\n+func TestIssue11457(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\tconst importPath = \"github.com/rsc/go-get-issue-11457\"\n+\ttg.run(\"get\", \"-d\", \"-u\", importPath)\n+\trepoDir := tg.path(\"src/\" + importPath)\n+\ttg.runGit(repoDir, \"remote\", \"set-url\", \"origin\", \"git@github.com:rsc/go-get-issue-11457\")\n+\n+\t// At this time, custom import path checking compares remotes verbatim (rather than\n+\t// just the host and path, skipping scheme and user), so we expect go get -u to fail.\n+\t// However, the goal of this test is to verify that gitRemoteRepo correctly parsed\n+\t// the SCP-like syntax, and we expect it to appear in the error message.\n+\ttg.runFail(\"get\", \"-d\", \"-u\", importPath)\n+\twant := \" is checked out from ssh://git@github.com/rsc/go-get-issue-11457\"\n+\tif !strings.HasSuffix(strings.TrimSpace(tg.getStderr()), want) {\n+\t\tt.Error(\"expected clone URL to appear in stderr\")\n+\t}\n+}\n+\n func TestGetGitDefaultBranch(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \tif _, err := exec.LookPath(\"git\"); err != nil {\n@@ -1217,7 +1227,6 @@ func TestGetGitDefaultBranch(t *testing.T) {\n \n \ttg.run(\"get\", \"-d\", importPath)\n \trepoDir := tg.path(\"src/\" + importPath)\n-\tdefer tg.resetReadOnlyFlagAll(repoDir)\n \ttg.runGit(repoDir, \"branch\", \"--contains\", \"HEAD\")\n \ttg.grepStdout(`\\* another-branch`, \"not on correct default branch\")\n \n@@ -1226,14 +1235,6 @@ func TestGetGitDefaultBranch(t *testing.T) {\n \ttg.grepStdout(`\\* another-branch`, \"not on correct default branch\")\n }\n \n-func TestDisallowedCSourceFiles(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"badc\")\n-\ttg.grepStderr(\"C source files not allowed\", \"go test did not say C source files not allowed\")\n-}\n-\n func TestErrorMessageForSyntaxErrorInTestGoFileSaysFAIL(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1337,19 +1338,35 @@ func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n \ttg.sleep()\n \ttg.run(\"test\", \"main_test\")\n \ttg.run(\"install\", \"main_test\")\n-\ttg.wantNotStale(\"main_test\", \"after go install, main listed as stale\")\n+\ttg.wantNotStale(\"main_test\", \"\", \"after go install, main listed as stale\")\n \ttg.run(\"test\", \"main_test\")\n }\n \n+// The runtime version string takes one of two forms:\n+// \"go1.X[.Y]\" for Go releases, and \"devel +hash\" at tip.\n+// Determine whether we are in a released copy by\n+// inspecting the version.\n+var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n+\n // Issue 12690\n func TestPackageNotStaleWithTrailingSlash(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\n+\t// Make sure the packages below are not stale.\n+\ttg.run(\"install\", \"runtime\", \"os\", \"io\")\n+\n \tgoroot := runtime.GOROOT()\n \ttg.setenv(\"GOROOT\", goroot+\"/\")\n-\ttg.wantNotStale(\"runtime\", \"with trailing slash in GOROOT, runtime listed as stale\")\n-\ttg.wantNotStale(\"os\", \"with trailing slash in GOROOT, os listed as stale\")\n-\ttg.wantNotStale(\"io\", \"with trailing slash in GOROOT, io listed as stale\")\n+\n+\twant := \"\"\n+\tif isGoRelease {\n+\t\twant = \"standard package in Go release distribution\"\n+\t}\n+\n+\ttg.wantNotStale(\"runtime\", want, \"with trailing slash in GOROOT, runtime listed as stale\")\n+\ttg.wantNotStale(\"os\", want, \"with trailing slash in GOROOT, os listed as stale\")\n+\ttg.wantNotStale(\"io\", want, \"with trailing slash in GOROOT, io listed as stale\")\n }\n \n // With $GOBIN set, binaries get installed to $GOBIN.\n@@ -1397,28 +1414,6 @@ func TestInstallToGOBINCommandLinePackage(t *testing.T) {\n \ttg.wantExecutable(\"testdata/bin1/helloworld\"+exeSuffix, \"go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld\")\n }\n \n-func TestGodocInstalls(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\t// godoc installs into GOBIN\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempDir(\"gobin\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n-\ttg.run(\"get\", \"golang.org/x/tools/cmd/godoc\")\n-\ttg.wantExecutable(tg.path(\"gobin/godoc\"), \"did not install godoc to $GOBIN\")\n-\ttg.unsetenv(\"GOBIN\")\n-\n-\t// godoc installs into GOROOT\n-\tgoroot := runtime.GOROOT()\n-\ttg.setenv(\"GOROOT\", goroot)\n-\ttg.check(os.RemoveAll(filepath.Join(goroot, \"bin\", \"godoc\")))\n-\ttg.run(\"install\", \"golang.org/x/tools/cmd/godoc\")\n-\ttg.wantExecutable(filepath.Join(goroot, \"bin\", \"godoc\"), \"did not install godoc to $GOROOT/bin\")\n-}\n-\n func TestGoGetNonPkg(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n@@ -1508,7 +1503,7 @@ func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.run(\"test\", \"errors\", \"errors\", \"errors\", \"errors\", \"errors\")\n-\tif strings.Index(strings.TrimSpace(tg.getStdout()), \"\\n\") != -1 {\n+\tif strings.Contains(strings.TrimSpace(tg.getStdout()), \"\\n\") {\n \t\tt.Error(\"go test errors errors errors errors errors tested the same package multiple times\")\n \t}\n }\n@@ -1537,7 +1532,7 @@ func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n \ttg.run(\"list\", \"cmd\")\n \tout := strings.TrimSpace(tg.getStdout())\n \tfor _, line := range strings.Split(out, \"\\n\") {\n-\t\tif strings.Index(line, \"cmd/\") == -1 {\n+\t\tif !strings.Contains(line, \"cmd/\") {\n \t\t\tt.Error(\"go list cmd shows non-commands\")\n \t\t\tbreak\n \t\t}\n@@ -1657,8 +1652,8 @@ func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n \t\tfunc main() {\n \t\t\tprintln(extern)\n \t\t}`)\n-\ttg.run(\"run\", \"-ldflags\", `-X main.extern \"hello world\"`, tg.path(\"main.go\"))\n-\ttg.grepStderr(\"^hello world\", `ldflags -X main.extern 'hello world' failed`)\n+\ttg.run(\"run\", \"-ldflags\", `-X \"main.extern=hello world\"`, tg.path(\"main.go\"))\n+\ttg.grepStderr(\"^hello world\", `ldflags -X \"main.extern=hello world\"' failed`)\n }\n \n func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n@@ -1726,7 +1721,6 @@ func TestSymlinksVendor(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.tempDir(\"gopath/src/dir1/vendor/v\")\n \ttg.tempFile(\"gopath/src/dir1/p.go\", \"package main\\nimport _ `v`\\nfunc main(){}\")\n \ttg.tempFile(\"gopath/src/dir1/vendor/v/v.go\", \"package v\")\n@@ -1879,7 +1873,9 @@ func TestShadowingLogic(t *testing.T) {\n \t}\n \t// The output will have makeImportValid applies, but we only\n \t// bother to deal with characters we might reasonably see.\n-\tpwdForwardSlash = strings.Replace(pwdForwardSlash, \":\", \"_\", -1)\n+\tfor _, r := range \" :\" {\n+\t\tpwdForwardSlash = strings.Replace(pwdForwardSlash, string(r), \"_\", -1)\n+\t}\n \twant := \"(_\" + pwdForwardSlash + \"/testdata/shadow/root1/src/math) (\" + filepath.Join(runtime.GOROOT(), \"src\", \"math\") + \")\"\n \tif strings.TrimSpace(tg.getStdout()) != want {\n \t\tt.Error(\"shadowed math is not shadowed; looking for\", want)\n@@ -2001,6 +1997,27 @@ func TestCoverageUsesActualSettingToOverrideEvenForRace(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n+func TestBuildDryRunWithCgo(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"foo.go\", `package main\n+\n+/*\n+#include <limits.h>\n+*/\n+import \"C\"\n+\n+func main() {\n+        println(C.INT_MAX)\n+}`)\n+\ttg.run(\"build\", \"-n\", tg.path(\"foo.go\"))\n+\ttg.grepStderrNot(`os.Stat .* no such file or directory`, \"unexpected stat of archive file\")\n+}\n+\n func TestCoverageWithCgo(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n@@ -2106,10 +2123,33 @@ func main() { C.f() }`)\n \ttg.grepStderr(`gccgo.*\\-L alibpath \\-lalib`, `no Go-inline \"#cgo LDFLAGS:\" (\"-L alibpath -lalib\") passed to gccgo linking stage`)\n }\n \n-func TestListTemplateCanUseContextFunction(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"list\", \"-f\", \"GOARCH: {{context.GOARCH}}\")\n+func TestListTemplateContextFunction(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tfor _, tt := range []struct {\n+\t\tv    string\n+\t\twant string\n+\t}{\n+\t\t{\"GOARCH\", runtime.GOARCH},\n+\t\t{\"GOOS\", runtime.GOOS},\n+\t\t{\"GOROOT\", filepath.Clean(runtime.GOROOT())},\n+\t\t{\"GOPATH\", os.Getenv(\"GOPATH\")},\n+\t\t{\"CgoEnabled\", \"\"},\n+\t\t{\"UseAllFiles\", \"\"},\n+\t\t{\"Compiler\", \"\"},\n+\t\t{\"BuildTags\", \"\"},\n+\t\t{\"ReleaseTags\", \"\"},\n+\t\t{\"InstallSuffix\", \"\"},\n+\t} {\n+\t\ttmpl := \"{{context.\" + tt.v + \"}}\"\n+\t\ttg.run(\"list\", \"-f\", tmpl)\n+\t\tif tt.want == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got := strings.TrimSpace(tg.getStdout()); got != tt.want {\n+\t\t\tt.Errorf(\"go list -f %q: got %q; want %q\", tmpl, got, tt.want)\n+\t\t}\n+\t}\n }\n \n // cmd/go: \"go test\" should fail if package does not build\n@@ -2123,7 +2163,7 @@ func TestIssue7108(t *testing.T) {\n // cmd/go: go test -a foo does not rebuild regexp.\n func TestIssue6844(t *testing.T) {\n \tif testing.Short() {\n-\t\tt.Skip(\"don't rebuild the standard libary in short mode\")\n+\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n \t}\n \n \ttg := testgo(t)\n@@ -2295,8 +2335,7 @@ func TestGoVetWithExternalTests(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"golang.org/x/tools/cmd/vet\")\n+\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"vetpkg\")\n \ttg.grepBoth(\"missing argument for Printf\", \"go vet vetpkg did not find missing argument for Printf\")\n@@ -2308,8 +2347,7 @@ func TestGoVetWithTags(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"golang.org/x/tools/cmd/vet\")\n+\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"-tags\", \"tagtest\", \"vetpkg\")\n \ttg.grepBoth(`c\\.go.*wrong number of args for format`, \"go get vetpkg did not run scan tagged file\")\n@@ -2330,6 +2368,11 @@ func TestGoGetRscIoToolstash(t *testing.T) {\n // Issue 13037: Was not parsing <meta> tags in 404 served over HTTPS\n func TestGoGetHTTPS404(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\", \"linux\", \"freebsd\":\n+\tdefault:\n+\t\tt.Skipf(\"test case does not work on %s\", runtime.GOOS)\n+\t}\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2338,7 +2381,7 @@ func TestGoGetHTTPS404(t *testing.T) {\n \ttg.run(\"get\", \"bazil.org/fuse/fs/fstestutil\")\n }\n \n-// Test that you can not import a main package.\n+// Test that you cannot import a main package.\n func TestIssue4210(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2359,6 +2402,8 @@ func TestIssue4210(t *testing.T) {\n func TestGoGetInsecure(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n+\tt.Skip(\"golang.org/issue/15410\")\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n@@ -2414,22 +2459,6 @@ func TestGoGetInsecureCustomDomain(t *testing.T) {\n \ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n }\n \n-func TestIssue10193(t *testing.T) {\n-\tt.Skip(\"depends on code.google.com\")\n-\ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"hg\"); err != nil {\n-\t\tt.Skip(\"skipping because hg binary not found\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempDir(\"src\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.runFail(\"get\", \"code.google.com/p/rsc/pdf\")\n-\ttg.grepStderr(\"is shutting down\", \"missed warning about code.google.com\")\n-}\n-\n func TestGoRunDirs(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2759,3 +2788,169 @@ func TestParallelTest(t *testing.T) {\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"test\", \"-p=4\", \"p1\", \"p2\", \"p3\", \"p4\")\n }\n+\n+func TestCgoConsistentResults(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\tif runtime.GOOS == \"solaris\" {\n+\t\t// See https://golang.org/issue/13247\n+\t\tt.Skip(\"skipping because Solaris builds are known to be inconsistent; see #13247\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\texe1 := tg.path(\"cgotest1\" + exeSuffix)\n+\texe2 := tg.path(\"cgotest2\" + exeSuffix)\n+\ttg.run(\"build\", \"-o\", exe1, \"cgotest\")\n+\ttg.run(\"build\", \"-x\", \"-o\", exe2, \"cgotest\")\n+\tb1, err := ioutil.ReadFile(exe1)\n+\ttg.must(err)\n+\tb2, err := ioutil.ReadFile(exe2)\n+\ttg.must(err)\n+\n+\tif !tg.doGrepMatch(`-fdebug-prefix-map=\\$WORK`, &tg.stderr) {\n+\t\tt.Skip(\"skipping because C compiler does not support -fdebug-prefix-map\")\n+\t}\n+\tif !bytes.Equal(b1, b2) {\n+\t\tt.Error(\"building cgotest twice did not produce the same output\")\n+\t}\n+}\n+\n+// Issue 14444: go get -u .../ duplicate loads errors\n+func TestGoGetUpdateAllDoesNotTryToLoadDuplicates(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-u\", \".../\")\n+\ttg.grepStderrNot(\"duplicate loads of\", \"did not remove old packages from cache\")\n+}\n+\n+func TestFatalInBenchmarkCauseNonZeroExitStatus(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"test\", \"-bench\", \".\", \"./testdata/src/benchfatal\")\n+\ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n+\ttg.grepBoth(\"FAIL.*benchfatal\", \"test did not run everything\")\n+}\n+\n+func TestBinaryOnlyPackages(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\ttg.tempFile(\"src/p1/p1.go\", `//go:binary-only-package\n+\n+\t\tpackage p1\n+\t`)\n+\ttg.wantStale(\"p1\", \"cannot access install target\", \"p1 is binary-only but has no binary, should be stale\")\n+\ttg.runFail(\"install\", \"p1\")\n+\ttg.grepStderr(\"missing or invalid package binary\", \"did not report attempt to compile binary-only package\")\n+\n+\ttg.tempFile(\"src/p1/p1.go\", `\n+\t\tpackage p1\n+\t\timport \"fmt\"\n+\t\tfunc F(b bool) { fmt.Printf(\"hello from p1\\n\"); if b { F(false) } }\n+\t`)\n+\ttg.run(\"install\", \"p1\")\n+\tos.Remove(tg.path(\"src/p1/p1.go\"))\n+\ttg.mustNotExist(tg.path(\"src/p1/p1.go\"))\n+\n+\ttg.tempFile(\"src/p2/p2.go\", `//go:binary-only-packages-are-not-great\n+\n+\t\tpackage p2\n+\t\timport \"p1\"\n+\t\tfunc F() { p1.F(true) }\n+\t`)\n+\ttg.runFail(\"install\", \"p2\")\n+\ttg.grepStderr(\"no buildable Go source files\", \"did not complain about missing sources\")\n+\n+\ttg.tempFile(\"src/p1/missing.go\", `//go:binary-only-package\n+\n+\t\tpackage p1\n+\t\tfunc G()\n+\t`)\n+\ttg.wantNotStale(\"p1\", \"no source code\", \"should NOT want to rebuild p1 (first)\")\n+\ttg.run(\"install\", \"-x\", \"p1\") // no-op, up to date\n+\ttg.grepBothNot(\"/compile\", \"should not have run compiler\")\n+\ttg.run(\"install\", \"p2\") // does not rebuild p1 (or else p2 will fail)\n+\ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n+\n+\t// changes to the non-source-code do not matter,\n+\t// and only one file needs the special comment.\n+\ttg.tempFile(\"src/p1/missing2.go\", `\n+\t\tpackage p1\n+\t\tfunc H()\n+\t`)\n+\ttg.wantNotStale(\"p1\", \"no source code\", \"should NOT want to rebuild p1 (second)\")\n+\ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n+\n+\ttg.tempFile(\"src/p3/p3.go\", `\n+\t\tpackage main\n+\t\timport (\n+\t\t\t\"p1\"\n+\t\t\t\"p2\"\n+\t\t)\n+\t\tfunc main() {\n+\t\t\tp1.F(false)\n+\t\t\tp2.F()\n+\t\t}\n+\t`)\n+\ttg.run(\"install\", \"p3\")\n+\n+\ttg.run(\"run\", tg.path(\"src/p3/p3.go\"))\n+\ttg.grepStdout(\"hello from p1\", \"did not see message from p1\")\n+}\n+\n+// Issue 16050.\n+func TestAlwaysLinkSysoFiles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src/syso\")\n+\ttg.tempFile(\"src/syso/a.syso\", ``)\n+\ttg.tempFile(\"src/syso/b.go\", `package syso`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\t// We should see the .syso file regardless of the setting of\n+\t// CGO_ENABLED.\n+\n+\ttg.setenv(\"CGO_ENABLED\", \"1\")\n+\ttg.run(\"list\", \"-f\", \"{{.SysoFiles}}\", \"syso\")\n+\ttg.grepStdout(\"a.syso\", \"missing syso file with CGO_ENABLED=1\")\n+\n+\ttg.setenv(\"CGO_ENABLED\", \"0\")\n+\ttg.run(\"list\", \"-f\", \"{{.SysoFiles}}\", \"syso\")\n+\ttg.grepStdout(\"a.syso\", \"missing syso file with CGO_ENABLED=0\")\n+}\n+\n+// Issue 16120.\n+func TestGenerateUsesBuildContext(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"this test won't run under Windows\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src/gen\")\n+\ttg.tempFile(\"src/gen/gen.go\", \"package gen\\n//go:generate echo $GOOS $GOARCH\\n\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\ttg.setenv(\"GOOS\", \"linux\")\n+\ttg.setenv(\"GOARCH\", \"amd64\")\n+\ttg.run(\"generate\", \"gen\")\n+\ttg.grepStdout(\"linux amd64\", \"unexpected GOOS/GOARCH combination\")\n+\n+\ttg.setenv(\"GOOS\", \"darwin\")\n+\ttg.setenv(\"GOARCH\", \"386\")\n+\ttg.run(\"generate\", \"gen\")\n+\ttg.grepStdout(\"darwin 386\", \"unexpected GOOS/GOARCH combination\")\n+}"}, {"sha": "c445a2ec73b1b844bf3f346059e8f66698a33db6", "filename": "libgo/go/cmd/go/go_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "056a0af1125b6ed6688577199caae17013a1d7cd", "filename": "libgo/go/cmd/go/help.go", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -149,14 +149,6 @@ A few common code hosting sites have special syntax:\n \t\timport \"github.com/user/project\"\n \t\timport \"github.com/user/project/sub/directory\"\n \n-\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n-\n-\t\timport \"code.google.com/p/project\"\n-\t\timport \"code.google.com/p/project/sub/directory\"\n-\n-\t\timport \"code.google.com/p/project.subrepository\"\n-\t\timport \"code.google.com/p/project.subrepository/sub/directory\"\n-\n \tLaunchpad (Bazaar)\n \n \t\timport \"launchpad.net/project\"\n@@ -269,10 +261,9 @@ unless it is being referred to by that import path. In this way, import comments\n let package authors make sure the custom import path is used and not a\n direct path to the underlying code hosting site.\n \n-If vendoring is enabled (see 'go help gopath'), then import path checking is\n-disabled for code found within vendor trees. This makes it possible to copy\n-code into alternate locations in vendor trees without needing to update import\n-comments.\n+Import path checking is disabled for code found within vendor trees.\n+This makes it possible to copy code into alternate locations in vendor trees\n+without needing to update import comments.\n \n See https://golang.org/s/go14customimport for details.\n \t`,\n@@ -421,12 +412,6 @@ Vendor directories do not affect the placement of new repositories\n being checked out for the first time by 'go get': those are always\n placed in the main GOPATH, never in a vendor subtree.\n \n-In Go 1.5, as an experiment, setting the environment variable\n-GO15VENDOREXPERIMENT=1 enabled these features.\n-As of Go 1.6 they are on by default. To turn them off, set\n-GO15VENDOREXPERIMENT=0. In Go 1.7, the environment\n-variable will stop having any effect.\n-\n See https://golang.org/s/go15vendor for details.\n \t`,\n }\n@@ -497,8 +482,6 @@ Special-purpose environment variables:\n \t\tinstalled in a location other than where it is built.\n \t\tFile names in stack traces are rewritten from GOROOT to\n \t\tGOROOT_FINAL.\n-\tGO15VENDOREXPERIMENT\n-\t\tSet to 0 to disable vendoring semantics.\n \tGO_EXTLINK_ENABLED\n \t\tWhether the linker should use external linking mode\n \t\twhen using -linkmode=auto with code that uses cgo.\n@@ -540,7 +523,15 @@ the extension of the file name. These extensions are:\n Files of each of these types except .syso may contain build\n constraints, but the go command stops scanning for build constraints\n at the first item in the file that is not a blank line or //-style\n-line comment.\n+line comment. See the go/build package documentation for\n+more details.\n+\n+Non-test Go source files can also include a //go:binary-only-package\n+comment, indicating that the package sources are included\n+for documentation only and must not be used to build the\n+package binary. This enables distribution of Go packages in\n+their compiled form alone. See the go/build package documentation\n+for more details.\n \t`,\n }\n "}, {"sha": "05ea50304998d6bebf89f13d29310634f1054ee3", "filename": "libgo/go/cmd/go/http.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -30,7 +30,7 @@ var httpClient = http.DefaultClient\n // when we're connecting to https servers that might not be there\n // or might be using self-signed certificates.\n var impatientInsecureHTTPClient = &http.Client{\n-\tTimeout: time.Duration(5 * time.Second),\n+\tTimeout: 5 * time.Second,\n \tTransport: &http.Transport{\n \t\tTLSClientConfig: &tls.Config{\n \t\t\tInsecureSkipVerify: true,"}, {"sha": "48678e73955faba79de53b518f618657978f97ca", "filename": "libgo/go/cmd/go/list.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -41,7 +41,10 @@ syntax of package template.  The default output is equivalent to -f\n         Goroot        bool   // is this package in the Go root?\n         Standard      bool   // is this package part of the standard Go library?\n         Stale         bool   // would 'go install' do anything for this package?\n+        StaleReason   string // explanation for Stale==true\n         Root          string // Go root or Go path dir containing this package\n+        ConflictDir   string // this directory shadows Dir in $GOPATH\n+        BinaryOnly    bool   // binary-only package: cannot be recompiled from sources\n \n         // Source files\n         GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n@@ -51,6 +54,7 @@ syntax of package template.  The default output is equivalent to -f\n         CXXFiles       []string // .cc, .cxx and .cpp source files\n         MFiles         []string // .m source files\n         HFiles         []string // .h, .hh, .hpp and .hxx source files\n+        FFiles         []string // .f, .F, .for and .f90 Fortran source files\n         SFiles         []string // .s source files\n         SwigFiles      []string // .swig files\n         SwigCXXFiles   []string // .swigcxx files\n@@ -60,6 +64,7 @@ syntax of package template.  The default output is equivalent to -f\n         CgoCFLAGS    []string // cgo: flags for C compiler\n         CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n         CgoCXXFLAGS  []string // cgo: flags for C++ compiler\n+        CgoFFLAGS    []string // cgo: flags for Fortran compiler\n         CgoLDFLAGS   []string // cgo: flags for linker\n         CgoPkgConfig []string // cgo: pkg-config names\n "}, {"sha": "65ec61bd7dbf20416723e80d3ce34ae9070e3dca", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -214,15 +214,7 @@ var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}\n {{end}}{{.Long | trim}}\n `\n \n-var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\n-// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\n-\n-/*\n-{{range .}}{{if .Short}}{{.Short | capitalize}}\n+var documentationTemplate = `{{range .}}{{if .Short}}{{.Short | capitalize}}\n \n {{end}}{{if .Runnable}}Usage:\n \n@@ -231,9 +223,39 @@ var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reser\n {{end}}{{.Long | trim}}\n \n \n-{{end}}*/\n-package main\n-`\n+{{end}}`\n+\n+// commentWriter writes a Go comment to the underlying io.Writer,\n+// using line comment form (//).\n+type commentWriter struct {\n+\tW            io.Writer\n+\twroteSlashes bool // Wrote \"//\" at the beginning of the current line.\n+}\n+\n+func (c *commentWriter) Write(p []byte) (int, error) {\n+\tvar n int\n+\tfor i, b := range p {\n+\t\tif !c.wroteSlashes {\n+\t\t\ts := \"//\"\n+\t\t\tif b != '\\n' {\n+\t\t\t\ts = \"// \"\n+\t\t\t}\n+\t\t\tif _, err := io.WriteString(c.W, s); err != nil {\n+\t\t\t\treturn n, err\n+\t\t\t}\n+\t\t\tc.wroteSlashes = true\n+\t\t}\n+\t\tn0, err := c.W.Write(p[i : i+1])\n+\t\tn += n0\n+\t\tif err != nil {\n+\t\t\treturn n, err\n+\t\t}\n+\t\tif b == '\\n' {\n+\t\t\tc.wroteSlashes = false\n+\t\t}\n+\t}\n+\treturn len(p), nil\n+}\n \n // An errWriter wraps a writer, recording whether a write error occurred.\n type errWriter struct {\n@@ -310,10 +332,18 @@ func help(args []string) {\n \n \t// 'go help documentation' generates doc.go.\n \tif arg == \"documentation\" {\n+\t\tfmt.Println(\"// Copyright 2011 The Go Authors. All rights reserved.\")\n+\t\tfmt.Println(\"// Use of this source code is governed by a BSD-style\")\n+\t\tfmt.Println(\"// license that can be found in the LICENSE file.\")\n+\t\tfmt.Println()\n+\t\tfmt.Println(\"// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\")\n+\t\tfmt.Println(\"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n+\t\tfmt.Println()\n \t\tbuf := new(bytes.Buffer)\n \t\tprintUsage(buf)\n \t\tusage := &Command{Long: buf.String()}\n-\t\ttmpl(os.Stdout, documentationTemplate, append([]*Command{usage}, commands...))\n+\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, append([]*Command{usage}, commands...))\n+\t\tfmt.Println(\"package main\")\n \t\treturn\n \t}\n \n@@ -339,7 +369,7 @@ func importPathsNoDotExpansion(args []string) []string {\n \tfor _, a := range args {\n \t\t// Arguments are supposed to be import paths, but\n \t\t// as a courtesy to Windows developers, rewrite \\ to /\n-\t\t// in command-line arguments.  Handles .\\... and so on.\n+\t\t// in command-line arguments. Handles .\\... and so on.\n \t\tif filepath.Separator == '\\\\' {\n \t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n \t\t}\n@@ -403,8 +433,6 @@ func errorf(format string, args ...interface{}) {\n \tsetExitStatus(1)\n }\n \n-var logf = log.Printf\n-\n func exitIfErrors() {\n \tif exitStatus != 0 {\n \t\texit()\n@@ -428,19 +456,6 @@ func run(cmdargs ...interface{}) {\n \t}\n }\n \n-func runOut(dir string, cmdargs ...interface{}) []byte {\n-\tcmdline := stringList(cmdargs...)\n-\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\tcmd.Dir = dir\n-\tout, err := cmd.CombinedOutput()\n-\tif err != nil {\n-\t\tos.Stderr.Write(out)\n-\t\terrorf(\"%v\", err)\n-\t\tout = nil\n-\t}\n-\treturn out\n-}\n-\n // envForDir returns a copy of the environment\n // suitable for running in the given directory.\n // The environment is the current process's environment\n@@ -472,7 +487,7 @@ NextVar:\n }\n \n // matchPattern(pattern)(name) reports whether\n-// name matches pattern.  Pattern is a limited glob\n+// name matches pattern. Pattern is a limited glob\n // pattern in which '...' means 'any string' and there\n // is no other special syntax.\n func matchPattern(pattern string) func(name string) bool {\n@@ -629,7 +644,7 @@ func matchPackages(pattern string) []string {\n \n // allPackagesInFS is like allPackages but is passed a pattern\n // beginning ./ or ../, meaning it should scan the tree rooted\n-// at the given directory.  There are ... in the pattern too.\n+// at the given directory. There are ... in the pattern too.\n func allPackagesInFS(pattern string) []string {\n \tpkgs := matchPackagesInFS(pattern)\n \tif len(pkgs) == 0 {"}, {"sha": "e0ad562384db15e5a74b18bfecf1854349f66363", "filename": "libgo/go/cmd/go/match_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "fae9536d13fb936bcfef43e6f70c4cfcc97ebf9d", "filename": "libgo/go/cmd/go/note.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -71,7 +71,7 @@ func readELFNote(filename, name string, typ int32) ([]byte, error) {\n var elfGoNote = []byte(\"Go\\x00\\x00\")\n \n // The Go build ID is stored in a note described by an ELF PT_NOTE prog\n-// header.  The caller has already opened filename, to get f, and read\n+// header. The caller has already opened filename, to get f, and read\n // at least 4 kB out, in data.\n func readELFGoBuildID(filename string, f *os.File, data []byte) (buildid string, err error) {\n \t// Assume the note content is in the data, already read.\n@@ -110,7 +110,7 @@ func readELFGoBuildID(filename string, f *os.File, data []byte) (buildid string,\n \t\t\t// or even the first few megabytes of the file\n \t\t\t// due to differences in note segment placement;\n \t\t\t// in that case, extract the note data manually.\n-\t\t\t_, err = f.Seek(int64(p.Off), 0)\n+\t\t\t_, err = f.Seek(int64(p.Off), io.SeekStart)\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}"}, {"sha": "2ee013faf39a6d89da04222190391a23e7c73ec0", "filename": "libgo/go/cmd/go/note_test.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -47,8 +47,6 @@ func testNoteReading(t *testing.T) {\n \t\tt.Skipf(\"skipping - no cgo, so assuming external linking not available\")\n \tcase runtime.GOOS == \"linux\" && (runtime.GOARCH == \"ppc64le\" || runtime.GOARCH == \"ppc64\"):\n \t\tt.Skipf(\"skipping - external linking not supported, golang.org/issue/11184\")\n-\tcase runtime.GOOS == \"linux\" && (runtime.GOARCH == \"mips64le\" || runtime.GOARCH == \"mips64\"):\n-\t\tt.Skipf(\"skipping - external linking not supported, golang.org/issue/12560\")\n \tcase runtime.GOOS == \"openbsd\" && runtime.GOARCH == \"arm\":\n \t\tt.Skipf(\"skipping - external linking not supported, golang.org/issue/10619\")\n \tcase runtime.GOOS == \"plan9\":"}, {"sha": "6d5d97f5c07163884748f987602a62b6a9379629", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 95, "deletions": 70, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -27,8 +27,8 @@ import (\n // A Package describes a single package found in a directory.\n type Package struct {\n \t// Note: These fields are part of the go command's public API.\n-\t// See list.go.  It is okay to add fields, but not to change or\n-\t// remove existing ones.  Keep in sync with list.go\n+\t// See list.go. It is okay to add fields, but not to change or\n+\t// remove existing ones. Keep in sync with list.go\n \tDir           string `json:\",omitempty\"` // directory containing package sources\n \tImportPath    string `json:\",omitempty\"` // import path of package in dir\n \tImportComment string `json:\",omitempty\"` // path in import comment on package statement\n@@ -39,8 +39,10 @@ type Package struct {\n \tGoroot        bool   `json:\",omitempty\"` // is this package found in the Go root?\n \tStandard      bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n \tStale         bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n+\tStaleReason   string `json:\",omitempty\"` // why is Stale true?\n \tRoot          string `json:\",omitempty\"` // Go root or Go path dir containing this package\n \tConflictDir   string `json:\",omitempty\"` // Dir is hidden by this other directory\n+\tBinaryOnly    bool   `json:\",omitempty\"` // package cannot be recompiled\n \n \t// Source files\n \tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n@@ -50,6 +52,7 @@ type Package struct {\n \tCXXFiles       []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n \tMFiles         []string `json:\",omitempty\"` // .m source files\n \tHFiles         []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n+\tFFiles         []string `json:\",omitempty\"` // .f, .F, .for and .f90 Fortran source files\n \tSFiles         []string `json:\",omitempty\"` // .s source files\n \tSwigFiles      []string `json:\",omitempty\"` // .swig files\n \tSwigCXXFiles   []string `json:\",omitempty\"` // .swigcxx files\n@@ -59,6 +62,7 @@ type Package struct {\n \tCgoCFLAGS    []string `json:\",omitempty\"` // cgo: flags for C compiler\n \tCgoCPPFLAGS  []string `json:\",omitempty\"` // cgo: flags for C preprocessor\n \tCgoCXXFLAGS  []string `json:\",omitempty\"` // cgo: flags for C++ compiler\n+\tCgoFFLAGS    []string `json:\",omitempty\"` // cgo: flags for Fortran compiler\n \tCgoLDFLAGS   []string `json:\",omitempty\"` // cgo: flags for linker\n \tCgoPkgConfig []string `json:\",omitempty\"` // cgo: pkg-config names\n \n@@ -88,7 +92,6 @@ type Package struct {\n \ttarget       string               // installed file for this package (may be executable)\n \tfake         bool                 // synthesized package\n \texternal     bool                 // synthesized external test package\n-\tforceBuild   bool                 // this package must be rebuilt\n \tforceLibrary bool                 // this package is a library (even if named \"main\")\n \tcmdline      bool                 // defined by files listed on command line\n \tlocal        bool                 // imported via local path (./ or ../)\n@@ -151,6 +154,8 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.Doc = pp.Doc\n \tp.Root = pp.Root\n \tp.ConflictDir = pp.ConflictDir\n+\tp.BinaryOnly = pp.BinaryOnly\n+\n \t// TODO? Target\n \tp.Goroot = pp.Goroot\n \tif buildContext.Compiler == \"gccgo\" {\n@@ -165,6 +170,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.CXXFiles = pp.CXXFiles\n \tp.MFiles = pp.MFiles\n \tp.HFiles = pp.HFiles\n+\tp.FFiles = pp.FFiles\n \tp.SFiles = pp.SFiles\n \tp.SwigFiles = pp.SwigFiles\n \tp.SwigCXXFiles = pp.SwigCXXFiles\n@@ -209,7 +215,7 @@ func (p *PackageError) Error() string {\n \t\treturn fmt.Sprintf(\"%s\\npackage %s\\n\", p.Err, strings.Join(p.ImportStack, \"\\n\\timports \"))\n \t}\n \tif p.Pos != \"\" {\n-\t\t// Omit import stack.  The full path to the file where the error\n+\t\t// Omit import stack. The full path to the file where the error\n \t\t// is the most important thing.\n \t\treturn p.Pos + \": \" + p.Err\n \t}\n@@ -267,18 +273,9 @@ func reloadPackage(arg string, stk *importStack) *Package {\n \treturn loadPackage(arg, stk)\n }\n \n-// The Go 1.5 vendoring experiment was enabled by setting GO15VENDOREXPERIMENT=1.\n-// In Go 1.6 this is on by default and is disabled by setting GO15VENDOREXPERIMENT=0.\n-// In Go 1.7 the variable will stop having any effect.\n-// The variable is obnoxiously long so that years from now when people find it in\n-// their profiles and wonder what it does, there is some chance that a web search\n-// might answer the question.\n-// There is a copy of this variable in src/go/build/build.go. Delete that one when this one goes away.\n-var go15VendorExperiment = os.Getenv(\"GO15VENDOREXPERIMENT\") != \"0\"\n-\n // dirToImportPath returns the pseudo-import path we use for a package\n-// outside the Go path.  It begins with _/ and then contains the full path\n-// to the directory.  If the package lives in c:\\home\\gopher\\my\\pkg then\n+// outside the Go path. It begins with _/ and then contains the full path\n+// to the directory. If the package lives in c:\\home\\gopher\\my\\pkg then\n // the pseudo-import path is _/c_/home/gopher/my/pkg.\n // Using a pseudo-import path like this makes the ./ imports no longer\n // a special case, so that all the code to deal with ordinary imports works\n@@ -365,7 +362,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n \t// See issue 3268 for mistakes to avoid.\n \tbuildMode := build.ImportComment\n-\tif !go15VendorExperiment || mode&useVendor == 0 || path != origPath {\n+\tif mode&useVendor == 0 || path != origPath {\n \t\t// Not vendoring, or we already found the vendored path.\n \t\tbuildMode |= build.IgnoreVendor\n \t}\n@@ -375,7 +372,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \t\tbp.BinDir = gobin\n \t}\n \tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n-\t\t(!go15VendorExperiment || (!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\"))) {\n+\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n \t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n \t}\n \tp.load(stk, bp, err)\n@@ -416,7 +413,7 @@ func isDir(path string) bool {\n // x/vendor/path, vendor/path, or else stay path if none of those exist.\n // vendoredImportPath returns the expanded path or, if no expansion is found, the original.\n func vendoredImportPath(parent *Package, path string) (found string) {\n-\tif parent == nil || parent.Root == \"\" || !go15VendorExperiment {\n+\tif parent == nil || parent.Root == \"\" {\n \t\treturn path\n \t}\n \n@@ -445,6 +442,12 @@ func vendoredImportPath(parent *Package, path string) (found string) {\n \t\t}\n \t\ttarg := filepath.Join(dir[:i], vpath)\n \t\tif isDir(targ) && hasGoFiles(targ) {\n+\t\t\timportPath := parent.ImportPath\n+\t\t\tif importPath == \"command-line-arguments\" {\n+\t\t\t\t// If parent.ImportPath is 'command-line-arguments'.\n+\t\t\t\t// set to relative directory to root (also chopped root directory)\n+\t\t\t\timportPath = dir[len(root)+1:]\n+\t\t\t}\n \t\t\t// We started with parent's dir c:\\gopath\\src\\foo\\bar\\baz\\quux\\xyzzy.\n \t\t\t// We know the import path for parent's dir.\n \t\t\t// We chopped off some number of path elements and\n@@ -454,14 +457,14 @@ func vendoredImportPath(parent *Package, path string) (found string) {\n \t\t\t// (actually the same number of bytes) from parent's import path\n \t\t\t// and then append /vendor/path.\n \t\t\tchopped := len(dir) - i\n-\t\t\tif chopped == len(parent.ImportPath)+1 {\n+\t\t\tif chopped == len(importPath)+1 {\n \t\t\t\t// We walked up from c:\\gopath\\src\\foo\\bar\n \t\t\t\t// and found c:\\gopath\\src\\vendor\\path.\n \t\t\t\t// We chopped \\foo\\bar (length 8) but the import path is \"foo/bar\" (length 7).\n \t\t\t\t// Use \"vendor/path\" without any prefix.\n \t\t\t\treturn vpath\n \t\t\t}\n-\t\t\treturn parent.ImportPath[:len(parent.ImportPath)-chopped] + \"/\" + vpath\n+\t\t\treturn importPath[:len(importPath)-chopped] + \"/\" + vpath\n \t\t}\n \t}\n \treturn path\n@@ -482,7 +485,7 @@ func hasGoFiles(dir string) bool {\n }\n \n // reusePackage reuses package p to satisfy the import at the top\n-// of the import stack stk.  If this use causes an import loop,\n+// of the import stack stk. If this use causes an import loop,\n // reusePackage updates p's error information to record the loop.\n func reusePackage(p *Package, stk *importStack) *Package {\n \t// We use p.imports==nil to detect a package that\n@@ -528,7 +531,7 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t\treturn p\n \t}\n \n-\t// Check for \"internal\" element: four cases depending on begin of string and/or end of string.\n+\t// Check for \"internal\" element: three cases depending on begin of string and/or end of string.\n \ti, ok := findInternal(p.ImportPath)\n \tif !ok {\n \t\treturn p\n@@ -565,7 +568,7 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n // If there isn't one, findInternal returns ok=false.\n // Otherwise, findInternal returns ok=true and the index of the \"internal\".\n func findInternal(path string) (index int, ok bool) {\n-\t// Four cases, depending on internal at start/end of string or not.\n+\t// Three cases, depending on internal at start/end of string or not.\n \t// The order matters: we must return the index of the final element,\n \t// because the final one produces the most restrictive requirement\n \t// on the importer.\n@@ -584,10 +587,6 @@ func findInternal(path string) (index int, ok bool) {\n // If the import is allowed, disallowVendor returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n func disallowVendor(srcDir, path string, p *Package, stk *importStack) *Package {\n-\tif !go15VendorExperiment {\n-\t\treturn p\n-\t}\n-\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -667,7 +666,7 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Pack\n \n // findVendor looks for the last non-terminating \"vendor\" path element in the given import path.\n // If there isn't one, findVendor returns ok=false.\n-// Otherwise, findInternal returns ok=true and the index of the \"vendor\".\n+// Otherwise, findVendor returns ok=true and the index of the \"vendor\".\n //\n // Note that terminating \"vendor\" elements don't count: \"x/vendor\" is its own package,\n // not the vendored copy of an import \"\" (the empty import path).\n@@ -691,7 +690,6 @@ type targetDir int\n const (\n \ttoRoot    targetDir = iota // to bin dir inside package root (default)\n \ttoTool                     // GOROOT/pkg/tool\n-\ttoBin                      // GOROOT/bin\n \tstalePath                  // the old import path; fail to build\n )\n \n@@ -715,7 +713,6 @@ var goTools = map[string]targetDir{\n \t\"cmd/trace\":                            toTool,\n \t\"cmd/vet\":                              toTool,\n \t\"cmd/yacc\":                             toTool,\n-\t\"golang.org/x/tools/cmd/godoc\":         toBin,\n \t\"code.google.com/p/go.tools/cmd/cover\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/godoc\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/vet\":   stalePath,\n@@ -729,7 +726,7 @@ func expandScanner(err error) error {\n \t\t// Prepare error with \\n before each message.\n \t\t// When printed in something like context: %v\n \t\t// this will put the leading file positions each on\n-\t\t// its own line.  It will also show all the errors\n+\t\t// its own line. It will also show all the errors\n \t\t// instead of just the first, as err.Error does.\n \t\tvar buf bytes.Buffer\n \t\tfor _, e := range err {\n@@ -802,12 +799,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t\t// Install cross-compiled binaries to subdirectories of bin.\n \t\t\telem = full\n \t\t}\n-\t\tif p.build.BinDir != gobin && goTools[p.ImportPath] == toBin {\n-\t\t\t// Override BinDir.\n-\t\t\t// This is from a subrepo but installs to $GOROOT/bin\n-\t\t\t// by default anyway (like godoc).\n-\t\t\tp.target = filepath.Join(gorootBin, elem)\n-\t\t} else if p.build.BinDir != \"\" {\n+\t\tif p.build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n \t\t\tp.target = filepath.Join(p.build.BinDir, elem)\n \t\t\tif !p.Goroot && strings.Contains(elem, \"/\") && gobin != \"\" {\n@@ -930,6 +922,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tp.CXXFiles,\n \t\tp.MFiles,\n \t\tp.HFiles,\n+\t\tp.FFiles,\n \t\tp.SFiles,\n \t\tp.SysoFiles,\n \t\tp.SwigFiles,\n@@ -1032,6 +1025,20 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \tp.Target = p.target\n \n+\t// If cgo is not enabled, ignore cgo supporting sources\n+\t// just as we ignore go files containing import \"C\".\n+\tif !buildContext.CgoEnabled {\n+\t\tp.CFiles = nil\n+\t\tp.CXXFiles = nil\n+\t\tp.MFiles = nil\n+\t\tp.SwigFiles = nil\n+\t\tp.SwigCXXFiles = nil\n+\t\t// Note that SFiles are okay (they go to the Go assembler)\n+\t\t// and HFiles are okay (they might be used by the SFiles).\n+\t\t// Also Sysofiles are okay (they might not contain object\n+\t\t// code; see issue #16050).\n+\t}\n+\n \t// The gc toolchain only permits C source files with cgo.\n \tif len(p.CFiles) > 0 && !p.usesCgo() && !p.usesSwig() && buildContext.Compiler == \"gc\" {\n \t\tp.Error = &PackageError{\n@@ -1054,7 +1061,15 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t}\n \t}\n \n-\tcomputeBuildID(p)\n+\tif p.BinaryOnly {\n+\t\t// For binary-only package, use build ID from supplied package binary.\n+\t\tbuildID, err := readBuildID(p)\n+\t\tif err == nil {\n+\t\t\tp.buildID = buildID\n+\t\t}\n+\t} else {\n+\t\tcomputeBuildID(p)\n+\t}\n \treturn p\n }\n \n@@ -1094,7 +1109,7 @@ func packageList(roots []*Package) []*Package {\n // at the named pkgs (command-line arguments).\n func computeStale(pkgs ...*Package) {\n \tfor _, p := range packageList(pkgs) {\n-\t\tp.Stale = isStale(p)\n+\t\tp.Stale, p.StaleReason = isStale(p)\n \t}\n }\n \n@@ -1240,7 +1255,7 @@ var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n // an explicit data comparison. Specifically, we build a list of the\n // inputs to the build, compute its SHA1 hash, and record that as the\n // ``build ID'' in the generated object. At the next build, we can\n-// recompute the buid ID and compare it to the one in the generated\n+// recompute the build ID and compare it to the one in the generated\n // object. If they differ, the list of inputs has changed, so the object\n // is out of date and must be rebuilt.\n //\n@@ -1365,40 +1380,50 @@ var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n // standard library, even in release versions. This makes\n // 'go build -tags netgo' work, among other things.\n \n-// isStale reports whether package p needs to be rebuilt.\n-func isStale(p *Package) bool {\n+// isStale reports whether package p needs to be rebuilt,\n+// along with the reason why.\n+func isStale(p *Package) (bool, string) {\n \tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n \t\t// fake, builtin package\n-\t\treturn false\n+\t\treturn false, \"builtin package\"\n \t}\n \tif p.Error != nil {\n-\t\treturn true\n+\t\treturn true, \"errors loading package\"\n+\t}\n+\tif p.Stale {\n+\t\treturn true, p.StaleReason\n \t}\n \n-\t// A package without Go sources means we only found\n-\t// the installed .a file.  Since we don't know how to rebuild\n-\t// it, it can't be stale, even if -a is set.  This enables binary-only\n-\t// distributions of Go packages, although such binaries are\n-\t// only useful with the specific version of the toolchain that\n-\t// created them.\n-\tif len(p.gofiles) == 0 && !p.usesSwig() {\n-\t\treturn false\n+\t// If this is a package with no source code, it cannot be rebuilt.\n+\t// If the binary is missing, we mark the package stale so that\n+\t// if a rebuild is needed, that rebuild attempt will produce a useful error.\n+\t// (Some commands, such as 'go list', do not attempt to rebuild.)\n+\tif p.BinaryOnly {\n+\t\tif p.target == \"\" {\n+\t\t\t// Fail if a build is attempted.\n+\t\t\treturn true, \"no source code for package, but no install target\"\n+\t\t}\n+\t\tif _, err := os.Stat(p.target); err != nil {\n+\t\t\t// Fail if a build is attempted.\n+\t\t\treturn true, \"no source code for package, but cannot access install target: \" + err.Error()\n+\t\t}\n+\t\treturn false, \"no source code for package\"\n \t}\n \n \t// If the -a flag is given, rebuild everything.\n \tif buildA {\n-\t\treturn true\n+\t\treturn true, \"build -a flag in use\"\n \t}\n \n-\t// If there's no install target or it's already marked stale, we have to rebuild.\n-\tif p.target == \"\" || p.Stale {\n-\t\treturn true\n+\t// If there's no install target, we have to rebuild.\n+\tif p.target == \"\" {\n+\t\treturn true, \"no install target\"\n \t}\n \n \t// Package is stale if completely unbuilt.\n \tfi, err := os.Stat(p.target)\n \tif err != nil {\n-\t\treturn true\n+\t\treturn true, \"cannot stat install target\"\n \t}\n \n \t// Package is stale if the expected build ID differs from the\n@@ -1411,13 +1436,13 @@ func isStale(p *Package) bool {\n \t// See issue 8290 and issue 10702.\n \ttargetBuildID, err := readBuildID(p)\n \tif err == nil && targetBuildID != p.buildID {\n-\t\treturn true\n+\t\treturn true, \"build ID mismatch\"\n \t}\n \n \t// Package is stale if a dependency is.\n \tfor _, p1 := range p.deps {\n \t\tif p1.Stale {\n-\t\t\treturn true\n+\t\t\treturn true, \"stale dependency\"\n \t\t}\n \t}\n \n@@ -1440,7 +1465,7 @@ func isStale(p *Package) bool {\n \t// install is to run make.bash, which will remove the old package archives\n \t// before rebuilding.)\n \tif p.Standard && isGoRelease {\n-\t\treturn false\n+\t\treturn false, \"standard package in Go release distribution\"\n \t}\n \n \t// Time-based staleness.\n@@ -1455,14 +1480,14 @@ func isStale(p *Package) bool {\n \t// Package is stale if a dependency is, or if a dependency is newer.\n \tfor _, p1 := range p.deps {\n \t\tif p1.target != \"\" && olderThan(p1.target) {\n-\t\t\treturn true\n+\t\t\treturn true, \"newer dependency\"\n \t\t}\n \t}\n \n \t// As a courtesy to developers installing new versions of the compiler\n \t// frequently, define that packages are stale if they are\n \t// older than the compiler, and commands if they are older than\n-\t// the linker.  This heuristic will not work if the binaries are\n+\t// the linker. This heuristic will not work if the binaries are\n \t// back-dated, as some binary distributions may do, but it does handle\n \t// a very common case.\n \t// See issue 3036.\n@@ -1474,10 +1499,10 @@ func isStale(p *Package) bool {\n \t// taken care of above (at least when the installed Go is a released version).\n \tif p.Root != goroot {\n \t\tif olderThan(buildToolchain.compiler()) {\n-\t\t\treturn true\n+\t\t\treturn true, \"newer compiler\"\n \t\t}\n \t\tif p.build.IsCommand() && olderThan(buildToolchain.linker()) {\n-\t\t\treturn true\n+\t\t\treturn true, \"newer linker\"\n \t\t}\n \t}\n \n@@ -1519,14 +1544,14 @@ func isStale(p *Package) bool {\n \t// to test for write access, and then skip GOPATH roots we don't have write\n \t// access to. But hopefully we can just use the mtimes always.\n \n-\tsrcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n+\tsrcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.FFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n \tfor _, src := range srcs {\n \t\tif olderThan(filepath.Join(p.Dir, src)) {\n-\t\t\treturn true\n+\t\t\treturn true, \"newer source file\"\n \t\t}\n \t}\n \n-\treturn false\n+\treturn false, \"\"\n }\n \n // computeBuildID computes the build ID for p, leaving it in p.buildID.\n@@ -1584,7 +1609,7 @@ var cwd, _ = os.Getwd()\n var cmdCache = map[string]*Package{}\n \n // loadPackage is like loadImport but is used for command-line arguments,\n-// not for paths found in import statements.  In addition to ordinary import paths,\n+// not for paths found in import statements. In addition to ordinary import paths,\n // loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n // in the Go command directory, as well as paths to those directories.\n func loadPackage(arg string, stk *importStack) *Package {\n@@ -1648,7 +1673,7 @@ func loadPackage(arg string, stk *importStack) *Package {\n // command line arguments 'args'.  If a named package\n // cannot be loaded at all (for example, if the directory does not exist),\n // then packages prints an error and does not include that\n-// package in the results.  However, if errors occur trying\n+// package in the results. However, if errors occur trying\n // to load dependencies of a named package, the named\n // package is still returned, with p.Incomplete = true\n // and details in p.DepsErrors."}, {"sha": "fba13636cdd195bfd63a10840592d37c5287a638", "filename": "libgo/go/cmd/go/pkg_test.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -161,9 +161,12 @@ func TestSharedLibName(t *testing.T) {\n \t\t\t\t}\n \t\t\t\toldGopath := buildContext.GOPATH\n \t\t\t\tdefer func() {\n-\t\t\t\t\tos.RemoveAll(tmpGopath)\n \t\t\t\t\tbuildContext.GOPATH = oldGopath\n \t\t\t\t\tos.Chdir(cwd)\n+\t\t\t\t\terr := os.RemoveAll(tmpGopath)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Error(err)\n+\t\t\t\t\t}\n \t\t\t\t}()\n \t\t\t\troot := filepath.Join(tmpGopath, \"src\", data.rootedAt)\n \t\t\t\terr = os.MkdirAll(root, 0755)"}, {"sha": "18387b5eafab46ebe9072b79f6bfd4cb37ec992a", "filename": "libgo/go/cmd/go/run.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -128,7 +128,7 @@ func runRun(cmd *Command, args []string) {\n }\n \n // runProgram is the action for running a binary that has already\n-// been compiled.  We ignore exit status.\n+// been compiled. We ignore exit status.\n func (b *builder) runProgram(a *action) error {\n \tcmdline := stringList(findExecCmd(), a.deps[0].target, a.args)\n \tif buildN || buildX {"}, {"sha": "6649bd6195248c2cb3fb40ec17fc949cb24d27d6", "filename": "libgo/go/cmd/go/tag_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "1de915a25336169ffd803ec371e18d1f4edf7b9b", "filename": "libgo/go/cmd/go/test.go", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -59,6 +59,9 @@ Each listed package causes the execution of a separate test binary.\n Test files that declare a package with the suffix \"_test\" will be compiled as a\n separate package, and then linked and run with the main test binary.\n \n+The go tool will ignore a directory named \"testdata\", making it available\n+to hold ancillary data needed by the tests.\n+\n By default, go test needs no arguments.  It compiles and tests the package\n with source in the current directory, including tests, and runs the tests.\n \n@@ -125,7 +128,10 @@ control the execution of any test:\n \n const testFlag2 = `\n \t-bench regexp\n-\t    Run benchmarks matching the regular expression.\n+\t    Run (sub)benchmarks matching a regular expression.\n+\t    The given regular expression is split into smaller ones by\n+\t    top-level '/', where each must match the corresponding part of a\n+\t    benchmark's identifier.\n \t    By default, no benchmarks run. To run all benchmarks,\n \t    use '-bench .' or '-bench=.'.\n \n@@ -213,8 +219,10 @@ const testFlag2 = `\n \t    (see 'go help build').\n \n \t-run regexp\n-\t    Run only those tests and examples matching the regular\n-\t    expression.\n+\t    Run only those tests and examples matching the regular expression.\n+\t    For tests the regular expression is split into smaller ones by\n+\t    top-level '/', where each must match the corresponding part of a\n+\t    test's identifier.\n \n \t-short\n \t    Tell long-running tests to shorten their run time.\n@@ -228,7 +236,6 @@ const testFlag2 = `\n \n \t-trace trace.out\n \t    Write an execution trace to the specified file before exiting.\n-\t    Writes test binary as -c would.\n \n \t-v\n \t    Verbose output: log all tests as they are run. Also print all\n@@ -256,7 +263,7 @@ execution, not to the test itself.)\n The test flags that generate profiles (other than for coverage) also\n leave the test binary in pkg.test for use when analyzing the profiles.\n \n-When 'go test' runs a test binary, it does so from within the \n+When 'go test' runs a test binary, it does so from within the\n corresponding package's source code directory. Depending on the test,\n it may be necessary to do the same when invoking a generated test\n binary directly.\n@@ -311,10 +318,11 @@ A benchmark function is one named BenchmarkXXX and should have the signature,\n \n An example function is similar to a test function but, instead of using\n *testing.T to report success or failure, prints output to os.Stdout.\n-That output is compared against the function's \"Output:\" comment, which\n-must be the last comment in the function body (see example below). An\n-example with no such comment, or with no text after \"Output:\" is compiled\n-but not executed.\n+If the last comment in the function starts with \"Output:\" then the output\n+is compared exactly against the comment (see examples below). If the last\n+comment begins with \"Unordered output:\" then the output is compared to the\n+comment, however the order of the lines is ignored. An example with no such\n+comment, or with no text after \"Output:\" is compiled but not executed.\n \n Godoc displays the body of ExampleXXX to demonstrate the use\n of the function, constant, or variable XXX.  An example of a method M with\n@@ -330,6 +338,20 @@ Here is an example of an example:\n \t\t// this example.\n \t}\n \n+Here is another example where the ordering of the output is ignored:\n+\n+\tfunc ExamplePerm() {\n+\t\tfor _, value := range Perm(4) {\n+\t\t\tfmt.Println(value)\n+\t\t}\n+\n+\t\t// Unordered output: 4\n+\t\t// 2\n+\t\t// 1\n+\t\t// 3\n+\t\t// 0\n+\t}\n+\n The entire test file is presented as the example when it contains a single\n example function, at least one other function, type, variable, or constant\n declaration, and no test or benchmark functions.\n@@ -388,7 +410,7 @@ func runTest(cmd *Command, args []string) {\n \t}\n \n \t// If a test timeout was given and is parseable, set our kill timeout\n-\t// to that timeout plus one minute.  This is a backup alarm in case\n+\t// to that timeout plus one minute. This is a backup alarm in case\n \t// the test wedges with a goroutine spinning and its background\n \t// timer does not get a chance to fire.\n \tif dt, err := time.ParseDuration(testTimeout); err == nil && dt > 0 {\n@@ -495,7 +517,8 @@ func runTest(cmd *Command, args []string) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tp.Stale = true // rebuild\n-\t\t\tp.fake = true  // do not warn about rebuild\n+\t\t\tp.StaleReason = \"rebuild for coverage\"\n+\t\t\tp.fake = true // do not warn about rebuild\n \t\t\tp.coverMode = testCoverMode\n \t\t\tvar coverFiles []string\n \t\t\tcoverFiles = append(coverFiles, p.GoFiles...)\n@@ -700,7 +723,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t// the usual place in the temporary tree, because then\n \t// other tests will see it as the real package.\n \t// Instead we make a _test directory under the import path\n-\t// and then repeat the import path there.  We tell the\n+\t// and then repeat the import path there. We tell the\n \t// compiler and linker to look in that _test directory first.\n \t//\n \t// That is, if the package under test is unicode/utf8,\n@@ -738,6 +761,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\tptest.fake = true\n \t\tptest.forceLibrary = true\n \t\tptest.Stale = true\n+\t\tptest.StaleReason = \"rebuild for test\"\n \t\tptest.build = new(build.Package)\n \t\t*ptest.build = *p.build\n \t\tm := map[string][]token.Position{}\n@@ -1019,6 +1043,7 @@ func recompileForTest(pmain, preal, ptest *Package, testDir string) {\n \t\t\t\tp.target = \"\"\n \t\t\t\tp.fake = true\n \t\t\t\tp.Stale = true\n+\t\t\t\tp.StaleReason = \"depends on package being tested\"\n \t\t\t}\n \t\t}\n \n@@ -1218,11 +1243,11 @@ func (b *builder) notest(a *action) error {\n \treturn nil\n }\n \n-// isTestMain tells whether fn is a TestMain(m *testing.M) function.\n-func isTestMain(fn *ast.FuncDecl) bool {\n-\tif fn.Name.String() != \"TestMain\" ||\n-\t\tfn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||\n-\t\tfn.Type.Params == nil ||\n+// isTestFunc tells whether fn has the type of a testing function. arg\n+// specifies the parameter type we look for: B, M or T.\n+func isTestFunc(fn *ast.FuncDecl, arg string) bool {\n+\tif fn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||\n+\t\tfn.Type.Params.List == nil ||\n \t\tlen(fn.Type.Params.List) != 1 ||\n \t\tlen(fn.Type.Params.List[0].Names) > 1 {\n \t\treturn false\n@@ -1234,10 +1259,11 @@ func isTestMain(fn *ast.FuncDecl) bool {\n \t// We can't easily check that the type is *testing.M\n \t// because we don't know how testing has been imported,\n \t// but at least check that it's *M or *something.M.\n-\tif name, ok := ptr.X.(*ast.Ident); ok && name.Name == \"M\" {\n+\t// Same applies for B and T.\n+\tif name, ok := ptr.X.(*ast.Ident); ok && name.Name == arg {\n \t\treturn true\n \t}\n-\tif sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == \"M\" {\n+\tif sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == arg {\n \t\treturn true\n \t}\n \treturn false\n@@ -1334,9 +1360,10 @@ func (t *testFuncs) Tested() string {\n }\n \n type testFunc struct {\n-\tPackage string // imported package name (_test or _xtest)\n-\tName    string // function name\n-\tOutput  string // output, for examples\n+\tPackage   string // imported package name (_test or _xtest)\n+\tName      string // function name\n+\tOutput    string // output, for examples\n+\tUnordered bool   // output is allowed to be unordered.\n }\n \n var testFileSet = token.NewFileSet()\n@@ -1356,17 +1383,25 @@ func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \t\t}\n \t\tname := n.Name.String()\n \t\tswitch {\n-\t\tcase isTestMain(n):\n+\t\tcase name == \"TestMain\" && isTestFunc(n, \"M\"):\n \t\t\tif t.TestMain != nil {\n \t\t\t\treturn errors.New(\"multiple definitions of TestMain\")\n \t\t\t}\n-\t\t\tt.TestMain = &testFunc{pkg, name, \"\"}\n+\t\t\tt.TestMain = &testFunc{pkg, name, \"\", false}\n \t\t\t*doImport, *seen = true, true\n \t\tcase isTest(name, \"Test\"):\n-\t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\"})\n+\t\t\terr := checkTestFunc(n, \"T\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\", false})\n \t\t\t*doImport, *seen = true, true\n \t\tcase isTest(name, \"Benchmark\"):\n-\t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\"})\n+\t\t\terr := checkTestFunc(n, \"B\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\", false})\n \t\t\t*doImport, *seen = true, true\n \t\t}\n \t}\n@@ -1378,12 +1413,21 @@ func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \t\t\t// Don't run examples with no output.\n \t\t\tcontinue\n \t\t}\n-\t\tt.Examples = append(t.Examples, testFunc{pkg, \"Example\" + e.Name, e.Output})\n+\t\tt.Examples = append(t.Examples, testFunc{pkg, \"Example\" + e.Name, e.Output, e.Unordered})\n \t\t*seen = true\n \t}\n \treturn nil\n }\n \n+func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n+\tif !isTestFunc(fn, arg) {\n+\t\tname := fn.Name.String()\n+\t\tpos := testFileSet.Position(fn.Pos())\n+\t\treturn fmt.Errorf(\"%s: wrong signature for %s, must be: func %s(%s *testing.%s)\", pos, name, name, strings.ToLower(arg), arg)\n+\t}\n+\treturn nil\n+}\n+\n type byOrder []*doc.Example\n \n func (x byOrder) Len() int           { return len(x) }\n@@ -1429,7 +1473,7 @@ var benchmarks = []testing.InternalBenchmark{\n \n var examples = []testing.InternalExample{\n {{range .Examples}}\n-\t{\"{{.Name}}\", {{.Package}}.{{.Name}}, {{.Output | printf \"%q\"}}},\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}, {{.Output | printf \"%q\"}}, {{.Unordered}}},\n {{end}}\n }\n "}, {"sha": "ac39a5bb1c2166e99534828aaa0672c6f6140d52", "filename": "libgo/go/cmd/go/testdata/dep_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "87e6c0acfaa91c6192fe08baf08d4e251b01425a", "filename": "libgo/go/cmd/go/testdata/example1_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "5d134260051dfc07cd527b5e9d157635e803264c", "filename": "libgo/go/cmd/go/testdata/example2_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "168cfb74fbf4783e5ceb56ba0d0e635c6ff191fd", "filename": "libgo/go/cmd/go/testdata/generate/test1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "829244a1663eff1cfb1ed3a816d36f8df22db917", "filename": "libgo/go/cmd/go/testdata/generate/test2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "e950da591a7da5743219607d2bded9855634f6e1", "filename": "libgo/go/cmd/go/testdata/generate/test3.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "6dae0486eb45300eec1842a3bacb561d89f3184c", "filename": "libgo/go/cmd/go/testdata/generate/test4.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "8d3a5deced86161f16d113e16049508cb03ce251", "filename": "libgo/go/cmd/go/testdata/src/benchfatal/x_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,7 @@\n+package benchfatal\n+\n+import \"testing\"\n+\n+func BenchmarkThatCallsFatal(b *testing.B) {\n+\tb.Fatal(\"called by benchmark\")\n+}"}, {"sha": "a65ed1f3840293c4df906664b50121cd4a98357e", "filename": "libgo/go/cmd/go/testflag.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -149,9 +149,11 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\t\ttestBench = true\n \t\t\tcase \"timeout\":\n \t\t\t\ttestTimeout = value\n-\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"trace\":\n+\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\":\n \t\t\t\ttestProfile = true\n \t\t\t\ttestNeedBinary = true\n+\t\t\tcase \"trace\":\n+\t\t\t\ttestProfile = true\n \t\t\tcase \"coverpkg\":\n \t\t\t\ttestCover = true\n \t\t\t\tif value == \"\" {"}, {"sha": "e507f34be695dd8e50cf673972ba807a14682aad", "filename": "libgo/go/cmd/go/testgo.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "65bf1ff33b09360e0ffc7555baa22d026f577795", "filename": "libgo/go/cmd/go/tool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "53ddbe694eec327b9de156823aba2aa0e24a39d8", "filename": "libgo/go/cmd/go/vcs.go", "status": "modified", "additions": 39, "deletions": 81, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -93,7 +93,7 @@ var vcsHg = &vcsCmd{\n \tdownloadCmd: []string{\"pull\"},\n \n \t// We allow both tag and branch names as 'tags'\n-\t// for selecting a version.  This lets people have\n+\t// for selecting a version. This lets people have\n \t// a go.release.r60 branch and a go1 branch\n \t// and make changes in both, without constantly\n \t// editing .hgtags.\n@@ -171,10 +171,10 @@ func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error\n \t\t// Eg, \"git@github.com:user/repo\" becomes\n \t\t// \"ssh://git@github.com/user/repo\".\n \t\trepoURL = &url.URL{\n-\t\t\tScheme:  \"ssh\",\n-\t\t\tUser:    url.User(m[1]),\n-\t\t\tHost:    m[2],\n-\t\t\tRawPath: m[3],\n+\t\t\tScheme: \"ssh\",\n+\t\t\tUser:   url.User(m[1]),\n+\t\t\tHost:   m[2],\n+\t\t\tPath:   m[3],\n \t\t}\n \t} else {\n \t\trepoURL, err = url.Parse(out)\n@@ -253,7 +253,7 @@ func bzrResolveRepo(vcsBzr *vcsCmd, rootDir, remoteRepo string) (realRepo string\n \t\treturn \"\", fmt.Errorf(\"unable to parse output of bzr info\")\n \t}\n \tout = out[:i]\n-\treturn strings.TrimSpace(string(out)), nil\n+\treturn strings.TrimSpace(out), nil\n }\n \n // vcsSvn describes how to use Subversion.\n@@ -294,7 +294,7 @@ func svnRemoteRepo(vcsSvn *vcsCmd, rootDir string) (remoteRepo string, err error\n \t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n \t}\n \tout = out[:i]\n-\treturn strings.TrimSpace(string(out)), nil\n+\treturn strings.TrimSpace(out), nil\n }\n \n func (v *vcsCmd) String() string {\n@@ -383,9 +383,6 @@ func (v *vcsCmd) ping(scheme, repo string) error {\n // The parent of dir must exist; dir must not.\n func (v *vcsCmd) create(dir, repo string) error {\n \tfor _, cmd := range v.createCmd {\n-\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n-\t\t\tcontinue\n-\t\t}\n \t\tif err := v.run(\".\", cmd, \"dir\", dir, \"repo\", repo); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -396,9 +393,6 @@ func (v *vcsCmd) create(dir, repo string) error {\n // download downloads any new changes for the repo in dir.\n func (v *vcsCmd) download(dir string) error {\n \tfor _, cmd := range v.downloadCmd {\n-\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n-\t\t\tcontinue\n-\t\t}\n \t\tif err := v.run(dir, cmd); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -445,9 +439,6 @@ func (v *vcsCmd) tagSync(dir, tag string) error {\n \n \tif tag == \"\" && v.tagSyncDefault != nil {\n \t\tfor _, cmd := range v.tagSyncDefault {\n-\t\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tif err := v.run(dir, cmd); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -456,9 +447,6 @@ func (v *vcsCmd) tagSync(dir, tag string) error {\n \t}\n \n \tfor _, cmd := range v.tagSyncCmd {\n-\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n-\t\t\tcontinue\n-\t\t}\n \t\tif err := v.run(dir, cmd, \"tag\", tag); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -479,15 +467,14 @@ type vcsPath struct {\n \tregexp *regexp.Regexp // cached compiled form of re\n }\n \n-// vcsForDir inspects dir and its parents to determine the\n+// vcsFromDir inspects dir and its parents to determine the\n // version control system and code repository to use.\n // On return, root is the import path\n-// corresponding to the root of the repository\n-// (thus root is a prefix of importPath).\n-func vcsForDir(p *Package) (vcs *vcsCmd, root string, err error) {\n+// corresponding to the root of the repository.\n+func vcsFromDir(dir, srcRoot string) (vcs *vcsCmd, root string, err error) {\n \t// Clean and double-check that dir is in (a subdirectory of) srcRoot.\n-\tdir := filepath.Clean(p.Dir)\n-\tsrcRoot := filepath.Clean(p.build.SrcRoot)\n+\tdir = filepath.Clean(dir)\n+\tsrcRoot = filepath.Clean(srcRoot)\n \tif len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {\n \t\treturn nil, \"\", fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n \t}\n@@ -496,7 +483,7 @@ func vcsForDir(p *Package) (vcs *vcsCmd, root string, err error) {\n \tfor len(dir) > len(srcRoot) {\n \t\tfor _, vcs := range vcsList {\n \t\t\tif fi, err := os.Stat(filepath.Join(dir, \".\"+vcs.cmd)); err == nil && fi.IsDir() {\n-\t\t\t\treturn vcs, dir[len(srcRoot)+1:], nil\n+\t\t\t\treturn vcs, filepath.ToSlash(dir[len(srcRoot)+1:]), nil\n \t\t\t}\n \t\t}\n \n@@ -780,15 +767,31 @@ type metaImport struct {\n // errNoMatch is returned from matchGoImport when there's no applicable match.\n var errNoMatch = errors.New(\"no import match\")\n \n+func splitPathHasPrefix(path, prefix []string) bool {\n+\tif len(path) < len(prefix) {\n+\t\treturn false\n+\t}\n+\tfor i, p := range prefix {\n+\t\tif path[i] != p {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // matchGoImport returns the metaImport from imports matching importPath.\n // An error is returned if there are multiple matches.\n // errNoMatch is returned if none match.\n func matchGoImport(imports []metaImport, importPath string) (_ metaImport, err error) {\n \tmatch := -1\n+\timp := strings.Split(importPath, \"/\")\n \tfor i, im := range imports {\n-\t\tif !strings.HasPrefix(importPath, im.Prefix) {\n+\t\tpre := strings.Split(im.Prefix, \"/\")\n+\n+\t\tif !splitPathHasPrefix(imp, pre) {\n \t\t\tcontinue\n \t\t}\n+\n \t\tif match != -1 {\n \t\t\terr = fmt.Errorf(\"multiple meta tags match import path %q\", importPath)\n \t\t\treturn\n@@ -815,20 +818,6 @@ func expand(match map[string]string, s string) string {\n // and import paths referring to a fully-qualified importPath\n // containing a VCS type (foo.com/repo.git/dir)\n var vcsPaths = []*vcsPath{\n-\t// Google Code - new syntax\n-\t{\n-\t\tprefix: \"code.google.com/\",\n-\t\tre:     `^(?P<root>code\\.google\\.com/p/(?P<project>[a-z0-9\\-]+)(\\.(?P<subrepo>[a-z0-9\\-]+))?)(/[A-Za-z0-9_.\\-]+)*$`,\n-\t\trepo:   \"https://{root}\",\n-\t\tcheck:  googleCodeVCS,\n-\t},\n-\n-\t// Google Code - old syntax\n-\t{\n-\t\tre:    `^(?P<project>[a-z0-9_\\-.]+)\\.googlecode\\.com/(git|hg|svn)(?P<path>/.*)?$`,\n-\t\tcheck: oldGoogleCode,\n-\t},\n-\n \t// Github\n \t{\n \t\tprefix: \"github.com/\",\n@@ -863,6 +852,14 @@ var vcsPaths = []*vcsPath{\n \t\trepo:   \"https://{root}\",\n \t},\n \n+\t// Git at OpenStack\n+\t{\n+\t\tprefix: \"git.openstack.org\",\n+\t\tre:     `^(?P<root>git\\.openstack\\.org/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(\\.git)?(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"git\",\n+\t\trepo:   \"https://{root}\",\n+\t},\n+\n \t// General syntax for any server.\n \t// Must be last.\n \t{\n@@ -911,45 +908,6 @@ func noVCSSuffix(match map[string]string) error {\n \treturn nil\n }\n \n-var googleCheckout = regexp.MustCompile(`id=\"checkoutcmd\">(hg|git|svn)`)\n-\n-// googleCodeVCS determines the version control system for\n-// a code.google.com repository, by scraping the project's\n-// /source/checkout page.\n-func googleCodeVCS(match map[string]string) error {\n-\tif err := noVCSSuffix(match); err != nil {\n-\t\treturn err\n-\t}\n-\tdata, err := httpGET(expand(match, \"https://code.google.com/p/{project}/source/checkout?repo={subrepo}\"))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif m := googleCheckout.FindSubmatch(data); m != nil {\n-\t\tif vcs := vcsByCmd(string(m[1])); vcs != nil {\n-\t\t\t// Subversion requires the old URLs.\n-\t\t\t// TODO: Test.\n-\t\t\tif vcs == vcsSvn {\n-\t\t\t\tif match[\"subrepo\"] != \"\" {\n-\t\t\t\t\treturn fmt.Errorf(\"sub-repositories not supported in Google Code Subversion projects\")\n-\t\t\t\t}\n-\t\t\t\tmatch[\"repo\"] = expand(match, \"https://{project}.googlecode.com/svn\")\n-\t\t\t}\n-\t\t\tmatch[\"vcs\"] = vcs.cmd\n-\t\t\treturn nil\n-\t\t}\n-\t}\n-\n-\treturn fmt.Errorf(\"unable to detect version control system for code.google.com/ path\")\n-}\n-\n-// oldGoogleCode is invoked for old-style foo.googlecode.com paths.\n-// It prints an error giving the equivalent new path.\n-func oldGoogleCode(match map[string]string) error {\n-\treturn fmt.Errorf(\"invalid Google Code import path: use %s instead\",\n-\t\texpand(match, \"code.google.com/p/{project}{path}\"))\n-}\n-\n // bitbucketVCS determines the version control system for a\n // Bitbucket repository, by using the Bitbucket API.\n func bitbucketVCS(match map[string]string) error {"}, {"sha": "25e3866df06d771e59139d40e09e97dde8ae0a90", "filename": "libgo/go/cmd/go/vcs_test.go", "status": "modified", "additions": 163, "deletions": 15, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,11 +1,16 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n package main\n \n import (\n+\t\"errors\"\n \t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n )\n \n@@ -18,20 +23,6 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\tpath string\n \t\twant *repoRoot\n \t}{\n-\t\t/*{\n-\t\t\t\"code.google.com/p/go\",\n-\t\t\t&repoRoot{\n-\t\t\t\tvcs:  vcsHg,\n-\t\t\t\trepo: \"https://code.google.com/p/go\",\n-\t\t\t},\n-\t\t},\n-\t\t{\n-\t\t        \"code.google.com/r/go\",\n-\t\t        &repoRoot{\n-\t\t                vcs:  vcsHg,\n-\t\t                repo: \"https://code.google.com/r/go\",\n-\t\t        },\n-\t\t},*/\n \t\t{\n \t\t\t\"github.com/golang/groupcache\",\n \t\t\t&repoRoot{\n@@ -96,6 +87,39 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\"hub.jazz.net/git/USER/pkgname\",\n \t\t\tnil,\n \t\t},\n+\t\t// OpenStack tests\n+\t\t{\n+\t\t\t\"git.openstack.org/openstack/swift\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t},\n+\t\t},\n+\t\t// Trailing .git is less preferred but included for\n+\t\t// compatibility purposes while the same source needs to\n+\t\t// be compilable on both old and new go\n+\t\t{\n+\t\t\t\"git.openstack.org/openstack/swift.git\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"git.openstack.org/openstack/swift/go/hummingbird\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://git.openstack.org/openstack/swift\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"git.openstack.org\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"git.openstack.org/openstack\",\n+\t\t\tnil,\n+\t\t},\n \t\t// Spaces are not valid in package name\n \t\t{\n \t\t\t\"git.apache.org/package name/path/to/lib\",\n@@ -142,6 +166,37 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t}\n }\n \n+// Test that vcsFromDir correctly inspects a given directory and returns the right VCS and root.\n+func TestFromDir(t *testing.T) {\n+\ttempDir, err := ioutil.TempDir(\"\", \"vcstest\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tempDir)\n+\n+\tfor _, vcs := range vcsList {\n+\t\tdir := filepath.Join(tempDir, \"example.com\", vcs.name, \".\"+vcs.cmd)\n+\t\terr := os.MkdirAll(dir, 0755)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\twant := repoRoot{\n+\t\t\tvcs:  vcs,\n+\t\t\troot: path.Join(\"example.com\", vcs.name),\n+\t\t}\n+\t\tvar got repoRoot\n+\t\tgot.vcs, got.root, err = vcsFromDir(dir, tempDir)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"FromDir(%q, %q): %v\", dir, tempDir, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got.vcs.name != want.vcs.name || got.root != want.root {\n+\t\t\tt.Errorf(\"FromDir(%q, %q) = VCS(%s) Root(%s), want VCS(%s) Root(%s)\", dir, tempDir, got.vcs, got.root, want.vcs, want.root)\n+\t\t}\n+\t}\n+}\n+\n func TestIsSecure(t *testing.T) {\n \ttests := []struct {\n \t\tvcs    *vcsCmd\n@@ -173,3 +228,96 @@ func TestIsSecure(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestMatchGoImport(t *testing.T) {\n+\ttests := []struct {\n+\t\timports []metaImport\n+\t\tpath    string\n+\t\tmi      metaImport\n+\t\terr     error\n+\t}{\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo\",\n+\t\t\tmi:   metaImport{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo/\",\n+\t\t\tmi:   metaImport{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/fooa\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo\",\n+\t\t\tmi:   metaImport{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/fooa\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/fooa\",\n+\t\t\tmi:   metaImport{Prefix: \"example.com/user/fooa\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/foo/bar\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo/bar\",\n+\t\t\terr:  errors.New(\"should not be allowed to create nested repo\"),\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/foo/bar\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo/bar/baz\",\n+\t\t\terr:  errors.New(\"should not be allowed to create nested repo\"),\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/foo/bar\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo/bar/baz/qux\",\n+\t\t\terr:  errors.New(\"should not be allowed to create nested repo\"),\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/foo/bar\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com/user/foo/bar/baz/\",\n+\t\t\terr:  errors.New(\"should not be allowed to create nested repo\"),\n+\t\t},\n+\t\t{\n+\t\t\timports: []metaImport{\n+\t\t\t\t{Prefix: \"example.com/user/foo\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t\t{Prefix: \"example.com/user/foo/bar\", VCS: \"git\", RepoRoot: \"https://example.com/repo/target\"},\n+\t\t\t},\n+\t\t\tpath: \"example.com\",\n+\t\t\terr:  errors.New(\"pathologically short path\"),\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\tmi, err := matchGoImport(test.imports, test.path)\n+\t\tif mi != test.mi {\n+\t\t\tt.Errorf(\"unexpected metaImport; got %v, want %v\", mi, test.mi)\n+\t\t}\n+\n+\t\tgot := err\n+\t\twant := test.err\n+\t\tif (got == nil) != (want == nil) {\n+\t\t\tt.Errorf(\"unexpected error; got %v, want %v\", got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "226b5377b985b835e72051cb61eb3deab1faee9b", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -20,7 +20,6 @@ func TestVendorImports(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"list\", \"-f\", \"{{.ImportPath}} {{.Imports}}\", \"vend/...\")\n \twant := `\n \t\tvend [vend/vendor/p r]\n@@ -51,15 +50,13 @@ func TestVendorBuild(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"build\", \"vend/x\")\n }\n \n func TestVendorRun(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n \ttg.run(\"run\", \"hello.go\")\n \ttg.grepStdout(\"hello, world\", \"missing hello world output\")\n@@ -74,7 +71,6 @@ func TestVendorGOPATH(t *testing.T) {\n \t}\n \tgopath := changeVolume(filepath.Join(tg.pwd(), \"testdata\"), strings.ToLower)\n \ttg.setenv(\"GOPATH\", gopath)\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \tcd := changeVolume(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"), strings.ToUpper)\n \ttg.cd(cd)\n \ttg.run(\"run\", \"hello.go\")\n@@ -85,7 +81,6 @@ func TestVendorTest(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n \ttg.run(\"test\", \"-v\")\n \ttg.grepStdout(\"TestMsgInternal\", \"missing use in internal test\")\n@@ -96,7 +91,6 @@ func TestVendorInvalid(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \n \ttg.runFail(\"build\", \"vend/x/invalid\")\n \ttg.grepStderr(\"must be imported as foo\", \"missing vendor import error\")\n@@ -106,7 +100,6 @@ func TestVendorImportError(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \n \ttg.runFail(\"build\", \"vend/x/vendor/p/p\")\n \n@@ -173,7 +166,6 @@ func TestVendorGet(t *testing.T) {\n \t\tpackage p\n \t\tconst C = 1`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.cd(tg.path(\"src/v\"))\n \ttg.run(\"run\", \"m.go\")\n \ttg.run(\"test\")\n@@ -192,7 +184,6 @@ func TestVendorGetUpdate(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n \ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n }\n@@ -204,16 +195,15 @@ func TestGetSubmodules(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"get\", \"-d\", \"github.com/rsc/go-get-issue-12612\")\n \ttg.run(\"get\", \"-u\", \"-d\", \"github.com/rsc/go-get-issue-12612\")\n+\ttg.mustExist(tg.path(\"src/github.com/rsc/go-get-issue-12612/vendor/golang.org/x/crypto/.git\"))\n }\n \n func TestVendorCache(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.runFail(\"build\", \"p\")\n \ttg.grepStderr(\"must be imported as x\", \"did not fail to build p\")\n }\n@@ -225,7 +215,6 @@ func TestVendorTest2(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n \n \t// build -i should work\n@@ -244,14 +233,39 @@ func TestVendorTest2(t *testing.T) {\n \ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx2\")\n }\n \n+func TestVendorTest3(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"github.com/clsung/go-vendor-issue-14613\")\n+\n+\ttg.run(\"build\", \"-o\", tg.path(\"a.out\"), \"-i\", \"github.com/clsung/go-vendor-issue-14613\")\n+\n+\t// test folder should work\n+\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613\")\n+\ttg.run(\"test\", \"github.com/clsung/go-vendor-issue-14613\")\n+\n+\t// test with specified _test.go should work too\n+\ttg.cd(filepath.Join(tg.path(\".\"), \"src\"))\n+\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613/vendor_test.go\")\n+\ttg.run(\"test\", \"github.com/clsung/go-vendor-issue-14613/vendor_test.go\")\n+\n+\t// test with imported and not used\n+\ttg.run(\"test\", \"-i\", \"github.com/clsung/go-vendor-issue-14613/vendor/mylibtesttest/myapp/myapp_test.go\")\n+\ttg.runFail(\"test\", \"github.com/clsung/go-vendor-issue-14613/vendor/mylibtesttest/myapp/myapp_test.go\")\n+\ttg.grepStderr(\"imported and not used:\", `should say \"imported and not used\"`)\n+}\n+\n func TestVendorList(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n \n \ttg.run(\"list\", \"-f\", `{{join .TestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/t\")\n@@ -272,7 +286,6 @@ func TestVendor12156(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor2\"))\n-\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n \ttg.cd(filepath.Join(tg.pwd(), \"testdata/testvendor2/src/p\"))\n \ttg.runFail(\"build\", \"p.go\")\n \ttg.grepStderrNot(\"panic\", \"panicked\")"}, {"sha": "3045f350d7dc39f92fca775926f0ba2c0d648d2d", "filename": "libgo/go/cmd/go/version.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "8e296c8572e3bee248fa6a4a1138a0eec4ac569a", "filename": "libgo/go/cmd/go/vet.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "f29b6cb83d995695b9c606c64716553e51bc8e4a", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -55,7 +55,6 @@ func report(err error) {\n func usage() {\n \tfmt.Fprintf(os.Stderr, \"usage: gofmt [flags] [path ...]\\n\")\n \tflag.PrintDefaults()\n-\tos.Exit(2)\n }\n \n func initParserMode() {\n@@ -143,7 +142,9 @@ func visitFile(path string, f os.FileInfo, err error) error {\n \tif err == nil && isGoFile(f) {\n \t\terr = processFile(path, nil, os.Stdout, false)\n \t}\n-\tif err != nil {\n+\t// Don't complain if a file was deleted in the meantime (i.e.\n+\t// the directory changed concurrently while running gofmt).\n+\tif err != nil && !os.IsNotExist(err) {\n \t\treport(err)\n \t}\n \treturn nil"}, {"sha": "dea012764b38308a43d12ed7db8ff63c62aa4662", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -159,15 +159,15 @@ func TestCRLF(t *testing.T) {\n \tif err != nil {\n \t\tt.Error(err)\n \t}\n-\tif bytes.Index(data, []byte(\"\\r\\n\")) < 0 {\n+\tif !bytes.Contains(data, []byte(\"\\r\\n\")) {\n \t\tt.Errorf(\"%s contains no CR/LF's\", input)\n \t}\n \n \tdata, err = ioutil.ReadFile(golden)\n \tif err != nil {\n \t\tt.Error(err)\n \t}\n-\tif bytes.Index(data, []byte(\"\\r\")) >= 0 {\n+\tif bytes.Contains(data, []byte(\"\\r\")) {\n \t\tt.Errorf(\"%s contains CR's\", golden)\n \t}\n }"}, {"sha": "cbc6983b6126c2561caf98467e773f6af11959bc", "filename": "libgo/go/cmd/gofmt/internal.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Finternal.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -28,9 +28,9 @@ func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n ) {\n \t// Try as whole source file.\n \tfile, err = parser.ParseFile(fset, filename, src, parserMode)\n-\t// If there's no error, return.  If the error is that the source file didn't begin with a\n+\t// If there's no error, return. If the error is that the source file didn't begin with a\n \t// package line and source fragments are ok, fall through to\n-\t// try as a source fragment.  Stop and return on any other error.\n+\t// try as a source fragment. Stop and return on any other error.\n \tif err == nil || !fragmentOk || !strings.Contains(err.Error(), \"expected 'package'\") {\n \t\treturn\n \t}\n@@ -59,7 +59,7 @@ func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n \n \t// If this is a statement list, make it a source file\n \t// by inserting a package clause and turning the list\n-\t// into a function body.  This handles expressions too.\n+\t// into a function body. This handles expressions too.\n \t// Insert using a ;, not a newline, so that the line numbers\n \t// in fsrc match the ones in src. Add an extra '\\n' before the '}'\n \t// to make sure comments are flushed before the '}'."}, {"sha": "550492bf29a4b61160d86863e28b9db952b3355b", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -158,7 +158,7 @@ func isWildcard(s string) bool {\n // recording wildcard submatches in m.\n // If m == nil, match checks whether pattern == val.\n func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {\n-\t// Wildcard matches any expression.  If it appears multiple\n+\t// Wildcard matches any expression. If it appears multiple\n \t// times in the pattern, it must match the same expression\n \t// each time.\n \tif m != nil && pattern.IsValid() && pattern.Type() == identType {"}, {"sha": "2ebf4cde0beb1d0b2b8bb718eed12e96ebb2eb3b", "filename": "libgo/go/cmd/gofmt/simplify.go", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -10,11 +10,9 @@ import (\n \t\"reflect\"\n )\n \n-type simplifier struct {\n-\thasDotImport bool // package file contains: import . \"some/import/path\"\n-}\n+type simplifier struct{}\n \n-func (s *simplifier) Visit(node ast.Node) ast.Visitor {\n+func (s simplifier) Visit(node ast.Node) ast.Visitor {\n \tswitch n := node.(type) {\n \tcase *ast.CompositeLit:\n \t\t// array, slice, and map composite literals may be simplified\n@@ -68,10 +66,13 @@ func (s *simplifier) Visit(node ast.Node) ast.Visitor {\n \t\t// a slice expression of the form: s[a:len(s)]\n \t\t// can be simplified to: s[a:]\n \t\t// if s is \"simple enough\" (for now we only accept identifiers)\n-\t\tif n.Max != nil || s.hasDotImport {\n+\t\t//\n+\t\t// Note: This may not be correct because len may have been redeclared in another\n+\t\t//       file belonging to the same package. However, this is extremely unlikely\n+\t\t//       and so far (April 2016, after years of supporting this rewrite feature)\n+\t\t//       has never come up, so let's keep it working as is (see also #15153).\n+\t\tif n.Max != nil {\n \t\t\t// - 3-index slices always require the 2nd and 3rd index\n-\t\t\t// - if dot imports are present, we cannot be certain that an\n-\t\t\t//   unresolved \"len\" identifier refers to the predefined len()\n \t\t\tbreak\n \t\t}\n \t\tif s, _ := n.X.(*ast.Ident); s != nil && s.Obj != nil {\n@@ -118,20 +119,11 @@ func isBlank(x ast.Expr) bool {\n }\n \n func simplify(f *ast.File) {\n-\tvar s simplifier\n-\n-\t// determine if f contains dot imports\n-\tfor _, imp := range f.Imports {\n-\t\tif imp.Name != nil && imp.Name.Name == \".\" {\n-\t\t\ts.hasDotImport = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n \t// remove empty declarations such as \"const ()\", etc\n \tremoveEmptyDeclGroups(f)\n \n-\tast.Walk(&s, f)\n+\tvar s simplifier\n+\tast.Walk(s, f)\n }\n \n func removeEmptyDeclGroups(f *ast.File) {"}, {"sha": "ab657004e64accaae1c2b1258e3b795fef78bcf0", "filename": "libgo/go/cmd/gofmt/testdata/slices2.golden", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden?ref=9d04a3af4c6491536badf6bde9707c907e4d196b", "patch": "@@ -1,63 +0,0 @@\n-//gofmt -s\n-\n-// Test cases for slice expression simplification.\n-// Because of a dot import, these slices must remain untouched.\n-package p\n-\n-import . \"math\"\n-\n-var (\n-\ta [10]byte\n-\tb [20]float32\n-\ts []int\n-\tt struct {\n-\t\ts []byte\n-\t}\n-\n-\t_ = a[0:]\n-\t_ = a[1:10]\n-\t_ = a[2:len(a)]\n-\t_ = a[3:(len(a))]\n-\t_ = a[len(a) : len(a)-1]\n-\t_ = a[0:len(b)]\n-\n-\t_ = a[:]\n-\t_ = a[:10]\n-\t_ = a[:len(a)]\n-\t_ = a[:(len(a))]\n-\t_ = a[:len(a)-1]\n-\t_ = a[:len(b)]\n-\n-\t_ = s[0:]\n-\t_ = s[1:10]\n-\t_ = s[2:len(s)]\n-\t_ = s[3:(len(s))]\n-\t_ = s[len(a) : len(s)-1]\n-\t_ = s[0:len(b)]\n-\n-\t_ = s[:]\n-\t_ = s[:10]\n-\t_ = s[:len(s)]\n-\t_ = s[:(len(s))]\n-\t_ = s[:len(s)-1]\n-\t_ = s[:len(b)]\n-\n-\t_ = t.s[0:]\n-\t_ = t.s[1:10]\n-\t_ = t.s[2:len(t.s)]\n-\t_ = t.s[3:(len(t.s))]\n-\t_ = t.s[len(a) : len(t.s)-1]\n-\t_ = t.s[0:len(b)]\n-\n-\t_ = t.s[:]\n-\t_ = t.s[:10]\n-\t_ = t.s[:len(t.s)]\n-\t_ = t.s[:(len(t.s))]\n-\t_ = t.s[:len(t.s)-1]\n-\t_ = t.s[:len(b)]\n-)\n-\n-func _() {\n-\ts := s[0:len(s)]\n-\t_ = s\n-}"}, {"sha": "ab657004e64accaae1c2b1258e3b795fef78bcf0", "filename": "libgo/go/cmd/gofmt/testdata/slices2.input", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input?ref=9d04a3af4c6491536badf6bde9707c907e4d196b", "patch": "@@ -1,63 +0,0 @@\n-//gofmt -s\n-\n-// Test cases for slice expression simplification.\n-// Because of a dot import, these slices must remain untouched.\n-package p\n-\n-import . \"math\"\n-\n-var (\n-\ta [10]byte\n-\tb [20]float32\n-\ts []int\n-\tt struct {\n-\t\ts []byte\n-\t}\n-\n-\t_ = a[0:]\n-\t_ = a[1:10]\n-\t_ = a[2:len(a)]\n-\t_ = a[3:(len(a))]\n-\t_ = a[len(a) : len(a)-1]\n-\t_ = a[0:len(b)]\n-\n-\t_ = a[:]\n-\t_ = a[:10]\n-\t_ = a[:len(a)]\n-\t_ = a[:(len(a))]\n-\t_ = a[:len(a)-1]\n-\t_ = a[:len(b)]\n-\n-\t_ = s[0:]\n-\t_ = s[1:10]\n-\t_ = s[2:len(s)]\n-\t_ = s[3:(len(s))]\n-\t_ = s[len(a) : len(s)-1]\n-\t_ = s[0:len(b)]\n-\n-\t_ = s[:]\n-\t_ = s[:10]\n-\t_ = s[:len(s)]\n-\t_ = s[:(len(s))]\n-\t_ = s[:len(s)-1]\n-\t_ = s[:len(b)]\n-\n-\t_ = t.s[0:]\n-\t_ = t.s[1:10]\n-\t_ = t.s[2:len(t.s)]\n-\t_ = t.s[3:(len(t.s))]\n-\t_ = t.s[len(a) : len(t.s)-1]\n-\t_ = t.s[0:len(b)]\n-\n-\t_ = t.s[:]\n-\t_ = t.s[:10]\n-\t_ = t.s[:len(t.s)]\n-\t_ = t.s[:(len(t.s))]\n-\t_ = t.s[:len(t.s)-1]\n-\t_ = t.s[:len(b)]\n-)\n-\n-func _() {\n-\ts := s[0:len(s)]\n-\t_ = s\n-}"}, {"sha": "42788443bcf5ff59e3c5944a82ffe77d0638de95", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -27,9 +27,8 @@ type reader struct {\n \tblockCRC     uint32\n \twantBlockCRC uint32\n \tsetupDone    bool // true if we have parsed the bzip2 header.\n-\tblockSize    int  // blockSize in bytes, i.e. 900 * 1024.\n+\tblockSize    int  // blockSize in bytes, i.e. 900 * 1000.\n \teof          bool\n-\tbuf          []byte    // stores Burrows-Wheeler transformed data.\n \tc            [256]uint // the `C' array for the inverse BWT.\n \ttt           []uint32  // mirrors the `tt' array in the bzip2 source and contains the P array in the upper 24 bits.\n \ttPos         uint32    // Index of the next output byte in tt.\n@@ -76,7 +75,7 @@ func (bz2 *reader) setup(needMagic bool) error {\n \t}\n \n \tbz2.fileCRC = 0\n-\tbz2.blockSize = 100 * 1024 * (int(level) - '0')\n+\tbz2.blockSize = 100 * 1000 * (level - '0')\n \tif bz2.blockSize > len(bz2.tt) {\n \t\tbz2.tt = make([]uint32, bz2.blockSize)\n \t}\n@@ -294,7 +293,7 @@ func (bz2 *reader) readBlock() (err error) {\n \t\tif c >= numHuffmanTrees {\n \t\t\treturn StructuralError(\"tree index too large\")\n \t\t}\n-\t\ttreeIndexes[i] = uint8(mtfTreeDecoder.Decode(c))\n+\t\ttreeIndexes[i] = mtfTreeDecoder.Decode(c)\n \t}\n \n \t// The list of symbols for the move-to-front transform is taken from\n@@ -319,6 +318,9 @@ func (bz2 *reader) readBlock() (err error) {\n \t\tlength := br.ReadBits(5)\n \t\tfor j := range lengths {\n \t\t\tfor {\n+\t\t\t\tif length < 1 || length > 20 {\n+\t\t\t\t\treturn StructuralError(\"Huffman length out of range\")\n+\t\t\t\t}\n \t\t\t\tif !br.ReadBit() {\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -328,9 +330,6 @@ func (bz2 *reader) readBlock() (err error) {\n \t\t\t\t\tlength++\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif length < 0 || length > 20 {\n-\t\t\t\treturn StructuralError(\"Huffman length out of range\")\n-\t\t\t}\n \t\t\tlengths[j] = uint8(length)\n \t\t}\n \t\thuffmanTrees[i], err = newHuffmanTree(lengths)\n@@ -400,7 +399,7 @@ func (bz2 *reader) readBlock() (err error) {\n \t\t\t\treturn StructuralError(\"repeats past end of block\")\n \t\t\t}\n \t\t\tfor i := 0; i < repeat; i++ {\n-\t\t\t\tb := byte(mtf.First())\n+\t\t\t\tb := mtf.First()\n \t\t\t\tbz2.tt[bufIndex] = uint32(b)\n \t\t\t\tbz2.c[b]++\n \t\t\t\tbufIndex++\n@@ -421,7 +420,7 @@ func (bz2 *reader) readBlock() (err error) {\n \t\t// it's always referenced with a run-length of 1. Thus 0\n \t\t// doesn't need to be encoded and we have |v-1| in the next\n \t\t// line.\n-\t\tb := byte(mtf.Decode(int(v - 1)))\n+\t\tb := mtf.Decode(int(v - 1))\n \t\tif bufIndex >= bz2.blockSize {\n \t\t\treturn StructuralError(\"data exceeds block size\")\n \t\t}"}, {"sha": "a6c3080db3efe5f49467b28e703aed888e560b02", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 186, "deletions": 377, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -6,193 +6,221 @@ package bzip2\n \n import (\n \t\"bytes\"\n-\t\"encoding/base64\"\n \t\"encoding/hex\"\n+\t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n )\n \n-func TestBitReader(t *testing.T) {\n-\tbuf := bytes.NewReader([]byte{0xaa})\n-\tbr := newBitReader(buf)\n-\tif n := br.ReadBits(1); n != 1 {\n-\t\tt.Errorf(\"read 1 wrong\")\n-\t}\n-\tif n := br.ReadBits(1); n != 0 {\n-\t\tt.Errorf(\"read 2 wrong\")\n-\t}\n-\tif n := br.ReadBits(1); n != 1 {\n-\t\tt.Errorf(\"read 3 wrong\")\n-\t}\n-\tif n := br.ReadBits(1); n != 0 {\n-\t\tt.Errorf(\"read 4 wrong\")\n-\t}\n-}\n-\n-func TestBitReaderLarge(t *testing.T) {\n-\tbuf := bytes.NewReader([]byte{0x12, 0x34, 0x56, 0x78})\n-\tbr := newBitReader(buf)\n-\tif n := br.ReadBits(32); n != 0x12345678 {\n-\t\tt.Errorf(\"got: %x want: %x\", n, 0x12345678)\n-\t}\n-}\n-\n-func readerFromHex(s string) io.Reader {\n-\tdata, err := hex.DecodeString(s)\n-\tif err != nil {\n-\t\tpanic(\"readerFromHex: bad input\")\n-\t}\n-\treturn bytes.NewReader(data)\n-}\n-\n-func decompressHex(s string) (out []byte, err error) {\n-\tr := NewReader(readerFromHex(s))\n-\treturn ioutil.ReadAll(r)\n-}\n-\n-func TestHelloWorldBZ2(t *testing.T) {\n-\tout, err := decompressHex(helloWorldBZ2Hex)\n+func mustDecodeHex(s string) []byte {\n+\tb, err := hex.DecodeString(s)\n \tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\tif !bytes.Equal(helloWorld, out) {\n-\t\tt.Errorf(\"got %x, want %x\", out, helloWorld)\n+\t\tpanic(err)\n \t}\n+\treturn b\n }\n \n-func TestConcat(t *testing.T) {\n-\tout, err := decompressHex(helloWorldBZ2Hex + helloWorldBZ2Hex)\n+func mustLoadFile(f string) []byte {\n+\tb, err := ioutil.ReadFile(f)\n \tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\thello2 := bytes.Repeat(helloWorld, 2)\n-\tif !bytes.Equal(hello2, out) {\n-\t\tt.Errorf(\"got %x, want %x\", out, hello2)\n-\t}\n-}\n-\n-func testZeros(t *testing.T, inHex string, n int) {\n-\tout, err := decompressHex(inHex)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\texpected := make([]byte, n)\n-\n-\tif !bytes.Equal(expected, out) {\n-\t\tallZeros := true\n-\t\tfor _, b := range out {\n-\t\t\tif b != 0 {\n-\t\t\t\tallZeros = false\n-\t\t\t\tbreak\n+\t\tpanic(err)\n+\t}\n+\treturn b\n+}\n+\n+func trim(b []byte) string {\n+\tconst limit = 1024\n+\tif len(b) < limit {\n+\t\treturn fmt.Sprintf(\"%q\", b)\n+\t}\n+\treturn fmt.Sprintf(\"%q...\", b[:limit])\n+}\n+\n+func TestReader(t *testing.T) {\n+\tvar vectors = []struct {\n+\t\tdesc   string\n+\t\tinput  []byte\n+\t\toutput []byte\n+\t\tfail   bool\n+\t}{{\n+\t\tdesc: \"hello world\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a68393141592653594eece83600000251800010400006449080200031064c\" +\n+\t\t\t\"4101a7a9a580bb9431f8bb9229c28482776741b0\",\n+\t\t),\n+\t\toutput: []byte(\"hello world\\n\"),\n+\t}, {\n+\t\tdesc: \"concatenated files\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a68393141592653594eece83600000251800010400006449080200031064c\" +\n+\t\t\t\"4101a7a9a580bb9431f8bb9229c28482776741b0425a68393141592653594eec\" +\n+\t\t\t\"e83600000251800010400006449080200031064c4101a7a9a580bb9431f8bb92\" +\n+\t\t\t\"29c28482776741b0\",\n+\t\t),\n+\t\toutput: []byte(\"hello world\\nhello world\\n\"),\n+\t}, {\n+\t\tdesc: \"32B zeros\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a6839314159265359b5aa5098000000600040000004200021008283177245\" +\n+\t\t\t\"385090b5aa5098\",\n+\t\t),\n+\t\toutput: make([]byte, 32),\n+\t}, {\n+\t\tdesc: \"1MiB zeros\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a683931415926535938571ce50008084000c0040008200030cc0529a60806\" +\n+\t\t\t\"c4201e2ee48a70a12070ae39ca\",\n+\t\t),\n+\t\toutput: make([]byte, 1<<20),\n+\t}, {\n+\t\tdesc:   \"random data\",\n+\t\tinput:  mustLoadFile(\"testdata/pass-random1.bz2\"),\n+\t\toutput: mustLoadFile(\"testdata/pass-random1.bin\"),\n+\t}, {\n+\t\tdesc:   \"random data - full symbol range\",\n+\t\tinput:  mustLoadFile(\"testdata/pass-random2.bz2\"),\n+\t\toutput: mustLoadFile(\"testdata/pass-random2.bin\"),\n+\t}, {\n+\t\tdesc: \"random data - uses RLE1 stage\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a6839314159265359d992d0f60000137dfe84020310091c1e280e100e0428\" +\n+\t\t\t\"01099210094806c0110002e70806402000546034000034000000f28300000320\" +\n+\t\t\t\"00d3403264049270eb7a9280d308ca06ad28f6981bee1bf8160727c7364510d7\" +\n+\t\t\t\"3a1e123083421b63f031f63993a0f40051fbf177245385090d992d0f60\",\n+\t\t),\n+\t\toutput: mustDecodeHex(\"\" +\n+\t\t\t\"92d5652616ac444a4a04af1a8a3964aca0450d43d6cf233bd03233f4ba92f871\" +\n+\t\t\t\"9e6c2a2bd4f5f88db07ecd0da3a33b263483db9b2c158786ad6363be35d17335\" +\n+\t\t\t\"ba\",\n+\t\t),\n+\t}, {\n+\t\tdesc:  \"1MiB sawtooth\",\n+\t\tinput: mustLoadFile(\"testdata/pass-sawtooth.bz2\"),\n+\t\toutput: func() []byte {\n+\t\t\tb := make([]byte, 1<<20)\n+\t\t\tfor i := range b {\n+\t\t\t\tb[i] = byte(i)\n+\t\t\t}\n+\t\t\treturn b\n+\t\t}(),\n+\t}, {\n+\t\tdesc:  \"RLE2 buffer overrun - issue 5747\",\n+\t\tinput: mustLoadFile(\"testdata/fail-issue5747.bz2\"),\n+\t\tfail:  true,\n+\t}, {\n+\t\tdesc: \"out-of-range selector - issue 8363\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a68393141592653594eece83600000251800010400006449080200031064c\" +\n+\t\t\t\"4101a7a9a580bb943117724538509000000000\",\n+\t\t),\n+\t\tfail: true,\n+\t}, {\n+\t\tdesc: \"bad block size - issue 13941\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a683131415926535936dc55330063ffc0006000200020a40830008b0008b8\" +\n+\t\t\t\"bb9229c28481b6e2a998\",\n+\t\t),\n+\t\tfail: true,\n+\t}, {\n+\t\tdesc: \"bad huffman delta\",\n+\t\tinput: mustDecodeHex(\"\" +\n+\t\t\t\"425a6836314159265359b1f7404b000000400040002000217d184682ee48a70a\" +\n+\t\t\t\"12163ee80960\",\n+\t\t),\n+\t\tfail: true,\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\trd := NewReader(bytes.NewReader(v.input))\n+\t\tbuf, err := ioutil.ReadAll(rd)\n+\n+\t\tif fail := bool(err != nil); fail != v.fail {\n+\t\t\tif fail {\n+\t\t\t\tt.Errorf(\"test %d (%s), unexpected failure: %v\", i, v.desc, err)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"test %d (%s), unexpected success\", i, v.desc)\n \t\t\t}\n \t\t}\n-\t\tt.Errorf(\"incorrect result, got %d bytes (allZeros: %t)\", len(out), allZeros)\n+\t\tif !v.fail && !bytes.Equal(buf, v.output) {\n+\t\t\tt.Errorf(\"test %d (%s), output mismatch:\\ngot  %s\\nwant %s\", i, v.desc, trim(buf), trim(v.output))\n+\t\t}\n \t}\n }\n \n-func Test32Zeros(t *testing.T) {\n-\ttestZeros(t, thirtyTwoZerosBZ2Hex, 32)\n-}\n-\n-func Test1MBZeros(t *testing.T) {\n-\ttestZeros(t, oneMBZerosBZ2Hex, 1024*1024)\n-}\n-\n-func testRandomData(t *testing.T, compressedHex, uncompressedHex string) {\n-\tout, err := decompressHex(compressedHex)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\texpected, _ := hex.DecodeString(uncompressedHex)\n-\n-\tif !bytes.Equal(out, expected) {\n-\t\tt.Errorf(\"incorrect result\\ngot:  %x\\nwant: %x\", out, expected)\n+func TestBitReader(t *testing.T) {\n+\tvar vectors = []struct {\n+\t\tnbits uint // Number of bits to read\n+\t\tvalue int  // Expected output value (0 for error)\n+\t\tfail  bool // Expected operation failure?\n+\t}{\n+\t\t{nbits: 1, value: 1},\n+\t\t{nbits: 1, value: 0},\n+\t\t{nbits: 1, value: 1},\n+\t\t{nbits: 5, value: 11},\n+\t\t{nbits: 32, value: 0x12345678},\n+\t\t{nbits: 15, value: 14495},\n+\t\t{nbits: 3, value: 6},\n+\t\t{nbits: 6, value: 13},\n+\t\t{nbits: 1, fail: true},\n+\t}\n+\n+\trd := bytes.NewReader([]byte{0xab, 0x12, 0x34, 0x56, 0x78, 0x71, 0x3f, 0x8d})\n+\tbr := newBitReader(rd)\n+\tfor i, v := range vectors {\n+\t\tval := br.ReadBits(v.nbits)\n+\t\tif fail := bool(br.err != nil); fail != v.fail {\n+\t\t\tif fail {\n+\t\t\t\tt.Errorf(\"test %d, unexpected failure: ReadBits(%d) = %v\", i, v.nbits, br.err)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"test %d, unexpected success: ReadBits(%d) = nil\", i, v.nbits)\n+\t\t\t}\n+\t\t}\n+\t\tif !v.fail && val != v.value {\n+\t\t\tt.Errorf(\"test %d, mismatching value: ReadBits(%d) = %d, want %d\", i, v.nbits, val, v.value)\n+\t\t}\n \t}\n }\n \n-func TestRandomData1(t *testing.T) {\n-\ttestRandomData(t, randBZ2Hex, randHex)\n-}\n-\n-func TestRandomData2(t *testing.T) {\n-\t// This test involves several repeated bytes in the output, but they\n-\t// should trigger RLE decoding.\n-\ttestRandomData(t, rand2BZ2Hex, rand2Hex)\n-}\n-\n-func TestRandomData3(t *testing.T) {\n-\t// This test uses the full range of symbols.\n-\ttestRandomData(t, rand3BZ2Hex, rand3Hex)\n-}\n-\n-func Test1MBSawtooth(t *testing.T) {\n-\tout, err := decompressHex(oneMBSawtoothBZ2Hex)\n-\tif err != nil {\n-\t\tt.Errorf(\"error from Read: %s\", err)\n-\t\treturn\n-\t}\n-\n-\texpected := make([]byte, 1024*1024)\n-\n-\tfor i := range expected {\n-\t\texpected[i] = byte(i)\n+func TestMTF(t *testing.T) {\n+\tvar vectors = []struct {\n+\t\tidx int   // Input index\n+\t\tsym uint8 // Expected output symbol\n+\t}{\n+\t\t{idx: 1, sym: 1}, // [1 0 2 3 4]\n+\t\t{idx: 0, sym: 1}, // [1 0 2 3 4]\n+\t\t{idx: 1, sym: 0}, // [0 1 2 3 4]\n+\t\t{idx: 4, sym: 4}, // [4 0 1 2 3]\n+\t\t{idx: 1, sym: 0}, // [0 4 1 2 3]\n \t}\n \n-\tif !bytes.Equal(out, expected) {\n-\t\tt.Error(\"incorrect result\")\n+\tmtf := newMTFDecoderWithRange(5)\n+\tfor i, v := range vectors {\n+\t\tsym := mtf.Decode(v.idx)\n+\t\tt.Log(mtf)\n+\t\tif sym != v.sym {\n+\t\t\tt.Errorf(\"test %d, symbol mismatch: Decode(%d) = %d, want %d\", i, v.idx, sym, v.sym)\n+\t\t}\n \t}\n }\n \n-const helloWorldBZ2Hex = \"425a68393141592653594eece83600000251800010400006449080200031064c4101a7a9a580bb9431f8bb9229c28482776741b0\"\n-\n-var helloWorld = []byte(\"hello world\\n\")\n-\n-const thirtyTwoZerosBZ2Hex = \"425a6839314159265359b5aa5098000000600040000004200021008283177245385090b5aa5098\"\n-const oneMBZerosBZ2Hex = \"425a683931415926535938571ce50008084000c0040008200030cc0529a60806c4201e2ee48a70a12070ae39ca\"\n-\n-const randBZ2Hex = \"425a6839314159265359905d990d0001957fffffffffffafffffffffffffffffbfff6fffdfffffffffffffffffffffffffffffc002b6dd75676ed5b77720098320d11a64626981323d4da47a83131a13d09e8040f534cd4f4d27a464d193008cd09804601347a980026350c9886234d36864193d1351b44c136919e90340d26127a4cd264c32023009898981310c0344c340027a8303427a99a04c00003534c230d034f5006468d268cf54d36a3009a69a62626261311b40026013d34201a6934c9a604c98ca6c8460989fa9346234d30d3469a2604fd4131a7aa6d0046043d4c62098479269e89e835190d018d4c046001a11e801a0264792321932308c43a130688c260d46686804cd01a9e80981193684c6a68c00000004c4c20c04627a4c0000260003400d04c0681a01334026009a6f48041466132581ec5212b081d96b0effc16543e2228b052fcd30f2567ee8d970e0f10aabca68dd8270591c376cfc1baae0dba00aaff2d6caf6b211322c997cc18eaee5927f75185336bf907021324c71626c1dd20e22b9b0977f05d0f901eaa51db9fbaf7c603b4c87bc82890e6dd7e61d0079e27ec050dd788fd958152061cd01e222f9547cb9efc465d775b6fc98bac7d387bffd151ae09dadf19494f7a638e2eae58e550faba5fe6820ea520eb986096de4e527d80def3ba625e71fbefdcf7e7844e0a25d29b52dcd1344fca083737d42692aab38d230485f3c8ed54c2ed31f15cf0270c8143765b10b92157233fa1dfe0d7ce8ffe70b8b8f7250071701dfe9f1c94de362c9031455951c93eb098a6b50ee45c6131fefc3b6f9643e21f4adc59497138e246f5c57d834aa67c4f10d8bd8b3908d8130dd7388409c299a268eab3664fa4907c5c31574874bd8d388a4ab22b339660804e53e1b8d05867d40e3082560608d35d5d2c6054e8bab23da28f61f83efd41d25529ad6ea15fb50505cacfabb0902166427354ca3830a2c8415f21b19e592690fbe447020d685a4bcd16ecc4ff1a1c0e572627d0ef6265c008a43fc243240541061ed7840606be466d1c0dac2c53250ed567507d926c844154560d631960c65e15157829b2c7f16859f111a3a8cb72bf24ffa57a680c3be67b1be67c8dd8aea73ac2437a78df5b686d427080ebc01bd30b71a49f6ea31dc0f08e4849e38face96717690239538bc08b6cc5aa8d467cb9c36aa83d40ac7e58bddbfa185b22065e89a86c0145569d9e23726651aec49e31588d70f40fe9a4449dcf4f89eac220171e9c938e803dc195679651004b79ad33cc0c13aeeba5941b33ffeeb8fbe16e76c7811445c67b4269c90479433ddf9e8ed1d00c166b6c17217fb22c3ef1b0c1c7e28e185446a111c37f1ea6c07a59fbcc6546ecc6968d36ba58bc5489a5640647e426b0c39350cb6f07d5dc7a717648c4ec7f841467597ae1f65f408fd2d9940a4b1b860b3c9ae351dcae0b4425f7e8538710f2e40b7f70d13b51ac05ccc6ecda8264a88cad2d721d18132a9b9110a9e759c2483c77dcefc7e464ec88588174cb0c9abff93230ea0bed8decdd8ed8bfe2b5df0a253803678df04fab44c03b9ab7cc97d6e6d6fd0c4c840ce0efc498436f453bbb181603459471f2b588724592b222ec990614db530e10cadd84705621cfdd9261fa44a5f5806a2d74b575056b3c915255c65678f9c16e6dc00a99180fef1a840aff0e842ac02731080cc92782538360a60a727991013984da4fad95f79d5030677b7528d076b2483685fca4429edf804682fdc110dfc2f7c30e23e20a72e039108a0ad6fdee2f76985a4b4be4f5afc6101bf9d5042b657a05dc914e1424241766434\"\n-const randHex = \"c95138082bdf2b9bfa5b1072b23f729735d42c785eeb94320fb14c265b9c2ca421d01a3db986df1ac2acde5a0e6bf955d6f95e61261540905928e195f1a66644cc7f37281744fff4dc6df35566a494c41a8167151950eb74f5fc45f85ad0e5ed28b49adfe218aa7ec1707e8e1d55825f61f72beda3b4c006b8c9188d7336a5d875329b1b58c27cc4e89ecbae02c7712400c39dd131d2c6de82e2863da51d472bdfb21ecce62cc9cf769ed28aedc7583d755da45a0d90874bda269dd53283a9bdfd05f95fc8e9a304bb338ea1a2111894678c18134f17d31a15d9bfc1237894650f3e715e2548639ecbddb845cfe4a46a7b3a3c540f48629488e8c869f1e9f3f4c552243a8105b20eb8e264994214349dae83b165fd6c2a5b8e83fce09fc0a80d3281c8d53a9a08095bd19cbc1388df23975646ed259e003d39261ee68cbece8bcf32971f7fe7e588e8ba8f5e8597909abaea693836a79a1964050ed910a45a0f13a58cd2d3ae18992c5b23082407fd920d0bf01e33118a017bb5e39f44931346845af52128f7965206759433a346034ea481671f501280067567619f5ecef6cded077f92ed7f3b3ce8e308c80f34ba06939e9303f91b4318c8c1dd4cc223c1f057ac0c91211c629cd30e46ee9ec1d9fd493086b7bc2bc83e33f08749a5d430b0ed4f79d70f481940c9b0930b16321886a0df4fa5a1465d5208c7d3494a7987d9a5e42aa256f0c9523947f8318d0ef0af3d59a45cfc2418d0785c9a548b32b81e7de18be7d55a69a4c156bbb3d7579c0ac8e9c72b24646e54b0d0e8725f8f49fb44ae3c6b9d0287be118586255a90a4a83483ed0328518037e52aa959c5748ed83e13023e532306be98b8288da306bbb040bcf5d92176f84a9306dc6b274b040370b61d71fde58dd6d20e6fee348eae0c54bd0a5a487b2d005f329794f2a902c296af0a4c1f638f63292a1fa18e006c1b1838636f4de71c73635b25660d32e88a0917e1a5677f6a02ca65585b82cbd99fb4badbfa97a585da1e6cadf6737b4ec6ca33f245d66ee6a9fae6785d69b003c17b9fc6ec34fe5824ab8caae5e8e14dc6f9e116e7bf4a60c04388783c8ae929e1b46b3ef3bbe81b38f2fa6da771bf39dfba2374d3d2ed356b8e2c42081d885a91a3afb2f31986d2f9873354c48cf5448492c32e62385af423aa4f83db6d1b2669650379a1134b0a04cbca0862d6f9743c791cbb527d36cd5d1f0fc7f503831c8bd1b7a0ef8ae1a5ed1155dfdd9e32b6bb33138112d3d476b802179cb85a2a6c354ccfed2f31604fbd8d6ec4baf9f1c8454f72c6588c06a7df3178c43a6970bfa02dd6f74cb5ec3b63f9eddaa17db5cbf27fac6de8e57c384afd0954179f7b5690c3bee42abc4fa79b4b12101a9cf5f0b9aecdda945def0bd04163237247d3539850e123fe18139f316fa0256d5bd2faa8\"\n-\n-const oneMBSawtoothBZ2Hex = \"425a683931415926535971931ea00006ddffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe007de00000000000000024c00130001300000000000000000000000000000000000000000000000000000000126000980009800000000000000000000000000000000000000000000000000000000930004c0004c000000000000000000000000000000000000000000000000000000004980026000260000000000000000000000000000000000000000000000000000000009aaaaa0000000000000000000000000000000000000000000000000000000000000000498002600026000000000000000000000000000000000000000000000000000000007fc42271980d044c0a822607411304a08982d044c1a82260f411308a08984d044c2a82261741130ca08986d044c3a82261f411310a08988d044c4a822627411314a0898ad044c5a82262f411318a0898cd044c6a82263741131ca0898ed044c7a82263f411320a08990d044c8a822647411324a08992d044c9a82264f411328a08994d044caa82265741132ca08996d044cba82265f411330a08998d044cca822667411334a0899ad044cda82266f411338a0899cd044cea82267741133ca0899ed044cfa82267f411340a089a0d044d0a822687411344a089a2d044d1a82268f411348a089a4d044d2a82269741134ca089a6d044d3a82269f411350a089a8d044d4a8226a7411354a089aad044d5a8226af411358a089acd044d6a8226b741135ca089aed044d7a8226bf411360a089b0d044d8a8226c7411364a089b2d044d9a8226cf411368a089b4d044daa8226d741136ca089b6d044dba8226df411370a089b8d044dca8226e7411374a089bad044dda8226ef411378a089bcd044dea8226f741137ca089bed044dfa8226ff411380a089c0d044e0a822707411384a089c2d044e1a82270f411388a089c4d044e2a82271741138ca089c59089c69089c71089c79089c81089c89089c91089c99089ca1089ca9089cb1089cb9089cc1089cc9089cd1089cd9089ce1089ce9089cf1089cf9089d01089d09089d11089d19089d21089d29089d31089d39089d41089d49089d51089d59089d61089d69089d71089d79089d81089d89089d91089d99089da1089da9089db1089db9089dc1089dc9089dd1089dd9089de1089de9089df1089df9089e01089e09089e11089e19089e21089e29089e31089e39089e41089e49089e51089e59089e61089e69089e71089e79089e81089e89089e91089e99089ea1089ea9089eb1089eb9089ec1089ec9089ed1089ed9089ee1089ee9089ef1089ef9089f01089f09089f11089f19089f21089f29089f31089f39089f41089f49089f51089f59089f61089f69089f71089f79089f81089f89089f91089f99089fa1089fa9089fb1089fb9089fc1089fc9089fd1089fd9089fe1089fe9089ff1089ff98a0ac9329acf23ba884804fdd3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0034f800000000000024c00130001300000000000000000000000000000000000000000000000000000000126000980009800000000000000000000000000000000000000000000000000000000930004c0004c000000000000000000000000000000000000000000000000000000004980026000260000000000000000000000000000000000000000000000000000000024c0013000130000000000000000000000000000000000000000000000000000000002955540000000000000000000000000000000000000000000000000000000000000001ff108c00846024230221181908c108460a4230621183908c20846124230a21185908c308461a4230e21187908c40846224231221189908c508462a423162118b908c60846324231a2118d908c708463a4231e2118f908c80846424232221191908c908464a4232621193908ca0846524232a21195908cb08465a4232e21197908cc0846624233221199908cd08466a423362119b908ce0846724233a2119d908cf08467a4233e2119f908d008468242342211a1908d108468a42346211a3908d20846924234a211a5908d308469a4234e211a7908d40846a242352211a9908d50846aa42356211ab908d60846b24235a211ad908d70846ba4235e211af908d80846c242362211b1908d90846ca42366211b3908da0846d24236a211b5908db0846da4236e211b7908dc0846e242372211b9908dd0846ea42376211bb908de0846f24237a211bd908df0846fa4237e211bf908e008470242382211c1908e108470a42386211c3908e20847124238a211c5908e2f8c211c6c8471d211c7c84721211c8c84725211c9c84729211cac8472d211cbc84731211ccc84735211cdc84739211cec8473d211cfc84741211d0c84745211d1c84749211d2c8474d211d3c84751211d4c84755211d5c84759211d6c8475d211d7c84761211d8c84765211d9c84769211dac8476d211dbc84771211dcc84775211ddc84779211dec8477d211dfc84781211e0c84785211e1c84789211e2c8478d211e3c84791211e4c84795211e5c84799211e6c8479d211e7c847a1211e8c847a5211e9c847a9211eac847ad211ebc847b1211ecc847b5211edc847b9211eec847bd211efc847c1211f0c847c5211f1c847c9211f2c847cd211f3c847d1211f4c847d5211f5c847d9211f6c847dd211f7c847e1211f8c847e5211f9c847e9211fac847ed211fbc847f1211fcc847f5211fdc847f9211fec847fd211ff8bb9229c284803a8b6248\"\n-\n-const rand2BZ2Hex = \"425a6839314159265359d992d0f60000137dfe84020310091c1e280e100e042801099210094806c0110002e70806402000546034000034000000f2830000032000d3403264049270eb7a9280d308ca06ad28f6981bee1bf8160727c7364510d73a1e123083421b63f031f63993a0f40051fbf177245385090d992d0f60\"\n-const rand2Hex = \"92d5652616ac444a4a04af1a8a3964aca0450d43d6cf233bd03233f4ba92f8719e6c2a2bd4f5f88db07ecd0da3a33b263483db9b2c158786ad6363be35d17335ba\"\n-\n-const rand3BZ2Hex = \"425a68393141592653593be669d00000327ffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffc002b3b2b1b6e2bae400004c00132300004c0d268c004c08c0130026001a008683234c0684c34008c230261a04c0260064d07a8d00034000d27a1268c9931a8d327a3427a41faa69ea0da264c1a34219326869b51b49a6469a3268c689fa53269a62794687a9a68f5189994c9e487a8f534fd49a3d34043629e8c93d04da4f4648d30d4f44d3234c4d3023d0840680984d309934c234d3131a000640984f536a6132601300130130c8d00d04d1841ea7a8d31a02609b40023460010c01a34d4c1a0d04d3069306810034d0d0d4c0046130d034d0131a9a64d321804c68003400098344c13000991808c0001a00000000098004d3d4da4604c47a13012140aadf8d673c922c607ef6212a8c0403adea4b28aee578900e653b9cdeb8d11e6b838815f3ebaad5a01c5408d84a332170aff8734d4e06612d3c2889f31925fb89e33561f5100ae89b1f7047102e729373d3667e58d73aaa80fa7be368a1cc2dadd81d81ec8e1b504bd772ca31d03649269b01ceddaca07bf3d4eba24de141be3f86f93601e03714c0f64654671684f9f9528626fd4e1b76753dc0c54b842486b8d59d8ab314e86ca818e7a1f079463cbbd70d9b79b283c7edc419406311022e4be98c2c1374df9cdde2d008ce1d00e5f06ad1024baf555631f70831fc1023034e62be7c4bcb648caf276963ffa20e96bb50377fe1c113da0db4625b50741c35a058edb009c6ee5dbf93b8a6b060eec568180e8db791b82aab96cbf4326ca98361461379425ba8dcc347be670bdba7641883e5526ae3d833f6e9cb9bac9557747c79e206151072f7f0071dff3880411846f66bf4075c7462f302b53cb3400a74cf35652ad5641ed33572fd54e7ed7f85f58a0acba89327e7c6be5c58cb71528b99df2431f1d0358f8d28d81d95292da631fb06701decabb205fac59ff0fb1df536afc681eece6ea658c4d9eaa45f1342aa1ff70bdaff2ddaf25ec88c22f12829a0553db1ec2505554cb17d7b282e213a5a2aa30431ded2bce665bb199d023840832fedb2c0c350a27291407ff77440792872137df281592e82076a05c64c345ffb058c64f7f7c207ef78420b7010520610f17e302cc4dfcfaef72a0ed091aab4b541eb0531bbe941ca2f792bf7b31ca6162882b68054a8470115bc2c19f2df2023f7800432b39b04d3a304e8085ba3f1f0ca5b1ba4d38d339e6084de979cdea6d0e244c6c9fa0366bd890621e3d30846f5e8497e21597b8f29bbf52c961a485dfbea647600da0fc1f25ce4d203a8352ece310c39073525044e7ac46acf2ed9120bae1b4f6f02364abfe343f80b290983160c103557af1c68416480d024cc31b6c06cfec011456f1e95c420a12b48b1c3fe220c2879a982fb099948ac440db844b9a112a5188c7783fd3b19593290785f908d95c9db4b280bafe89c1313aeec24772046d9bc089645f0d182a21184e143823c5f52de50e5d7e98d3d7ab56f5413bbccd1415c9bcff707def475b643fb7f29842582104d4cc1dbaaca8f10a2f44273c339e0984f2b1e06ab2f0771db01fafa8142298345f3196f23e5847bda024034b6f59b11c29e981c881456e40d211929fd4f766200258aad8212016322bd5c605790dcfdf1bd2a93d99c9b8f498722d311d7eae7ff420496a31804c55f4759a7b13aaaf5f7ce006c3a8a998897d5e0a504398c2b627852545baf440798bcc5cc049357cf3f17d9771e4528a1af3d77dc794a11346e1bdf5efe37a405b127b4c43b616d61fbc5dc914e14240ef99a7400\"\n-const rand3Hex = \"1744b384d68c042371244e13500d4bfb98c6244e3d71a5b700224420b59c593553f33bd786e3d0ce31626f511bc985f59d1a88aa38ba8ad6218d306abee60dd9172540232b95be1af146c69e72e5fde667a090dc3f93bdc5c5af0ab80acdbaa7a505f628c59dc0247b31a439cacf5010a94376d71521df08c178b02fb96fdb1809144ea38c68536187c53201fea8631fb0a880b4451ccdca7cc61f6aafca21cc7449d920599db61789ac3b1e164b3390124f95022aeea39ccca3ec1053f4fa10de2978e2861ea58e477085c2220021a0927aa94c5d0006b5055abba340e4f9eba22e969978dfd18e278a8b89d877328ae34268bc0174cfe211954c0036f078025217d1269fac1932a03b05a0b616012271bbe1fb554171c7a59b196d8a4479f45a77931b5d97aaf6c0c673cbe597b79b96e2a0c1eae2e66e46ccc8c85798e23ffe972ebdaa3f6caea243c004e60321eb47cd79137d78fd0613be606feacc5b3637bdc96a89c13746db8cad886f3ccf912b2178c823bcac395f06d28080269bdca2debf3419c66c690fd1adcfbd53e32e79443d7a42511a84cb22ca94fffad9149275a075b2f8ae0b021dcde9bf62b102db920733b897560518b06e1ad7f4b03458493ddaa7f4fa2c1609f7a1735aeeb1b3e2cea3ab45fc376323cc91873b7e9c90d07c192e38d3f5dfc9bfab1fd821c854da9e607ea596c391c7ec4161c6c4493929a8176badaa5a5af7211c623f29643a937677d3df0da9266181b7c4da5dd40376db677fe8f4a1dc456adf6f33c1e37cec471dd318c2647644fe52f93707a77da7d1702380a80e14cc0fdce7bf2eed48a529090bae0388ee277ce6c7018c5fb00b88362554362205c641f0d0fab94fd5b8357b5ff08b207fee023709bc126ec90cfb17c006754638f8186aaeb1265e80be0c1189ec07d01d5f6f96cb9ce82744147d18490de7dc72862f42f024a16968891a356f5e7e0e695d8c933ba5b5e43ad4c4ade5399bc2cae9bb6189b7870d7f22956194d277f28b10e01c10c6ffe3e065f7e2d6d056aa790db5649ca84dc64c35566c0af1b68c32b5b7874aaa66467afa44f40e9a0846a07ae75360a641dd2acc69d93219b2891f190621511e62a27f5e4fbe641ece1fa234fc7e9a74f48d2a760d82160d9540f649256b169d1fed6fbefdc491126530f3cbad7913e19fbd7aa53b1e243fbf28d5f38c10ebd77c8b986775975cc1d619efb27cdcd733fa1ca36cffe9c0a33cc9f02463c91a886601fd349efee85ef1462065ef9bd2c8f533220ad93138b8382d5938103ab25b2d9af8ae106e1211eb9b18793fba033900c809c02cd6d17e2f3e6fc84dae873411f8e87c3f0a8f1765b7825d185ce3730f299c3028d4a62da9ee95c2b870fb70c79370d485f9d5d9acb78926d20444033d960524d2776dc31988ec7c0dbf23b9905d\"\n-\n-const (\n-\tdigits = iota\n-\ttwain\n-\trandom\n+var (\n+\tdigits = mustLoadFile(\"testdata/e.txt.bz2\")\n+\ttwain  = mustLoadFile(\"testdata/Mark.Twain-Tom.Sawyer.txt.bz2\")\n+\trandom = mustLoadFile(\"testdata/random.data.bz2\")\n )\n \n-var testfiles = []string{\n-\t// Digits is the digits of the irrational number e. Its decimal representation\n-\t// does not repeat, but there are only 10 possible digits, so it should be\n-\t// reasonably compressible.\n-\tdigits: \"testdata/e.txt.bz2\",\n-\t// Twain is Mark Twain's classic English novel.\n-\ttwain: \"testdata/Mark.Twain-Tom.Sawyer.txt.bz2\",\n-\t// 16KB of random data from /dev/urandom\n-\trandom: \"testdata/random.data.bz2\",\n-}\n-\n-func benchmarkDecode(b *testing.B, testfile int) {\n-\tcompressed, err := ioutil.ReadFile(testfiles[testfile])\n+func benchmarkDecode(b *testing.B, compressed []byte) {\n+\t// Determine the uncompressed size of testfile.\n+\tuncompressedSize, err := io.Copy(ioutil.Discard, NewReader(bytes.NewReader(compressed)))\n \tif err != nil {\n \t\tb.Fatal(err)\n \t}\n-\tb.SetBytes(int64(len(compressed)))\n+\n+\tb.SetBytes(uncompressedSize)\n+\tb.ReportAllocs()\n+\tb.ResetTimer()\n+\n \tfor i := 0; i < b.N; i++ {\n \t\tr := bytes.NewReader(compressed)\n \t\tio.Copy(ioutil.Discard, NewReader(r))\n@@ -202,222 +230,3 @@ func benchmarkDecode(b *testing.B, testfile int) {\n func BenchmarkDecodeDigits(b *testing.B) { benchmarkDecode(b, digits) }\n func BenchmarkDecodeTwain(b *testing.B)  { benchmarkDecode(b, twain) }\n func BenchmarkDecodeRand(b *testing.B)   { benchmarkDecode(b, random) }\n-\n-func TestBufferOverrun(t *testing.T) {\n-\t// Tests https://golang.org/issue/5747.\n-\tbuffer := bytes.NewReader([]byte(bufferOverrunBase64))\n-\tdecoder := base64.NewDecoder(base64.StdEncoding, buffer)\n-\tdecompressor := NewReader(decoder)\n-\t// This shouldn't panic.\n-\tioutil.ReadAll(decompressor)\n-}\n-\n-func TestOutOfRangeSelector(t *testing.T) {\n-\t// Tests https://golang.org/issue/8363.\n-\tbuffer := bytes.NewReader(outOfRangeSelector)\n-\tdecompressor := NewReader(buffer)\n-\t// This shouldn't panic.\n-\tioutil.ReadAll(decompressor)\n-}\n-\n-func TestMTF(t *testing.T) {\n-\tmtf := newMTFDecoderWithRange(5)\n-\n-\t// 0 1 2 3 4\n-\texpect := byte(1)\n-\tx := mtf.Decode(1)\n-\tif x != expect {\n-\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n-\t}\n-\n-\t// 1 0 2 3 4\n-\tx = mtf.Decode(0)\n-\tif x != expect {\n-\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n-\t}\n-\n-\t// 1 0 2 3 4\n-\texpect = byte(0)\n-\tx = mtf.Decode(1)\n-\tif x != expect {\n-\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n-\t}\n-\n-\t// 0 1 2 3 4\n-\texpect = byte(4)\n-\tx = mtf.Decode(4)\n-\tif x != expect {\n-\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n-\t}\n-\n-\t// 4 0 1 2 3\n-\texpect = byte(0)\n-\tx = mtf.Decode(1)\n-\tif x != expect {\n-\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n-\t}\n-}\n-\n-var bufferOverrunBase64 string = `\n-QlpoNTFBWSZTWTzyiGcACMP/////////////////////////////////3/7f3///\n-////4N/fCZODak2Xo44GIHZgkGzDRbFAuwAAKoFV7T6AO6qwA6APb6s2rOoAkAAD\n-oACUoDtndh0iQAPkAAAAaPWihQoCgr5t97Obju21ChQB0NBm3RbA7apXrRoBooAA\n-AhA+IAHWl2Us3O7t9yieb3udvd76+4+fd33nd3HO1bVvfcGRne6+3vfPvfc++995\n-w7k973eJhasLVec970tzDNXdX28LoPXZ3H3K9z0s5ufWAfes49d5594c3dUYtI+2\n-+h1dvtpRa+uvrVEAG9bl893RVEN7cWvroSqWjPMGgAQi7Gq8TJSgKKdjKFBIB9Ae\n-LqWxleu715eXe7ml9e5098Z6G1vr7t1QZ6ot76YzPd3j7333t2ql2Chm7XrA9ICQ\n-VF77z3rVBWqkSXtlfb099hyezAr6USbGpICTSCFAaqHrKo+tUnm32rpE4Ue+t2mj\n-bKUeipEqwc93EdhhTwmQpOhhesC9iqDSPNTWYNSnUtBdm1nsA0nqqNd7OWwDXtFL\n-ONmmA6Ubke26I9UblvWIPR5VOWOnctai443URunnDy77uVC59OfRvezlDu33Z7Ly\n-3NNuuHW63088xu3t3NHZhkZbG7tXRlj00qOtbaXTJUUdspTbABR9R6EUwQAEAAAA\n-EMEwRpoAAAABMmhoAAjBNNAaCMhponpoGpgJpk9TEyp6niGKZkAaAEfqMQ09U80p\n-+pMGSCKngIAAAAgAAg0AAJhGgABGCEaaTyTKeNI1PE0wkj01GajMSNPSZGnqbU9T\n-anlPUNAHqGQ0DQAMg9TamgAAYRU/IAAICAmjQJgjQBMEwp5DTSaaYmhTeqfplPID\n-U1T9TynoU82pT1NPU/VP0j1NHqRpk9TTR7SnqaNNGmmQAaAD1Aeo0PSAAAAaaBiK\n-eBAQBGgIABGQA0AmBNNBoaAgaJmpglPEyYap6npiTT0agGjJjUaaDTQAAAAAAM1A\n-9QAaAAAADU8iEAQAEyAJk0NNNJgIZTJ5E00YSemiaZNGm1MpGNJ+lPU9qm9U2RDM\n-oY0EzJB6h6nqDID1NMBDDRpo1AGNAjCMmhkMgaYSJIgAAAQyAAEyBoATECCNhTT0\n-U/IZAmCM1DSTxkzUE8p6NDaGiZGJqntTFHvUyU9qPQp7Kn5GgKNPU9QAGg9QAAA3\n-wz0Pk/g/m/m9P9H4vxv2+dH3gCS8nhbbbbbYxtgNsBsG0m2MbG0NNtsbYNsaY0wb\n-bBibGmm22mxptNpsaGNDTY02JsG0MY0xg2MaYNNDbGwG0L5vsK/F9DO+EAA447Kq\n-p7Wdf6Y+5c20T7DfHyMXIzRKrZexw72uiQI+y55vOe52xpqbCLC2uR20JdER7Zvr\n-7ufuKb6zhiBxLuj0eA27v8RpMLucw9Ohwcizi2wrpt+yU1FdpM7ZYPcwS3XTef+A\n-Wzjxwhdrgw3aH1LeC1eZW900x8V9Nv4hTPXp4l067P/4ANVZFF/imOe/d5bdueam\n-/DFFokQWnFaU+ZqLBCM+d0PialJQWnLqRQZk/KhfbbYc2pCUTgffcSYbrCM1N+8l\n-HU6gSz+h2GJXs+tbrNviL83M97X0vcTn/F82P8wen8/3/h3sHY+sf9CSej9ThYTV\n-3lQ+FUHpfpGD4kv7dYMV995dpDX/y3xR8FoXx1bjUxBTNxuutwQ/h/Eedn9wpn6w\n-E3+ND8YhN1HSriIxRE/6uFyMv6/oC6Elarw3aHMMqHJkGiiz6tejmvnYLQa+Qm6G\n-deZ7jXTZV6NlpocgDnRdimS06bTYSkvPAL/xoWNLkX6N6VljU0dfKSBmm2uZE/xu\n-sutQ1EdP7GdjhglIq4xlOFUFEQpmX+xx7R8y6c0GSAaqusOjNZwxZRudOvmXm1tZ\n-T+YnbeB2ir9eiHNrtJNSLD/J/WDyuQpwBUtLKo0krccY/wIILP7f86teb9Z/9oyz\n-OX05qEWbObfhpRw+9+rCvp/35ML8KX3aHaI0n+tudbFRsV5FLW+Oa8ruLN4peyVL\n-DWjTHrXNthq/s7zAJYMeFJZkZt5mT9rfpH+5g3nc+piOSZ+J5nHtOnKI7Ff8Xl+j\n-0t76XTNucCHQ6whav1OHdF53TY5wuv5OzvrdnxoId8fTyUvERr0ERINu/8XxZZ5f\n-B5/kTZ8bBO0wv54Jp+ED/GQI8lZHzIQCP3vfQhwnCTj9TvITic7P4mYLDbH3fyzR\n-i+6EajCcpXLWSGf+ZXkOrWspDWDhXtEKas0v3UqWksqgY1rTj45krX4KihN+daXs\n-pZl5WPlta5p06CX6Xm2SfzqkMw12/3ix1bpnnZ+kFeBNX7A+E9zzG6OZaN78GOpl\n-9Ht/eZn9PqWdav852zr0zqkDK2H5IjdvNah+b1YVGdQGzwR4Nw+f13yEKnV+y66W\n-djfq7zWp7m5w+hzfv+Ly8O7oet5Vvd8/wQvO7qzOZ2vjf9X8Tj8PnMb/nc/nKqRR\n-+ml4UEhOOwfCeJEEI109CMYSh91iAJqPjMyH6KjrPD7W25llZVcREYNCTg6htbQt\n-M38wYoquCWP6tdKYlVIv14xTNUeUf4El/FunCf6csZkmv+9tfWx7t59wuKIa3saU\n-tZs9M+3HFOZtz3OLg/Unoaj9BYazYqA78xBU9tZzrtmF/rQL9CGJt90o/oYnSfcS\n-SL3haaw351LXWQ1XOsv1SmH3v6ymuxEpPPnEDmBELaTYsvvMIWJsmPZFFww++Kd7\n-s/Jo0JFeUU7uNtI+gVosAIpVVuWfI/9tOIycz7I5Z7zjV+NR2OuZbYtW5F08KX4o\n-2k/xuJIchcNFPtxPfw9dkDgscRbMckyFMrzuZ3IvrcGzk0J6iI5ytrv37bGpAXMz\n-WK9mMMPebepNevmLjjo/QWoM968Sjv7ldlPS5AinHcXwsFv6dmmh8lJt7UOJWoKu\n-lMD1cB2ksIGpMdv8iuqR42Rn/kn+17BhhUZcwDBaUXVdX6bKW7fxlUYbq+mlqIcf\n-a9v8HF87M9ANbi9bq9onf9TD7nQ6Xf6vZci8TBPX+/GI0He6j31fTVQYW+NsQxvO\n-J8xrx+e58CCLQNjxeIyPt+F+qk/QMiXw+LyxGVkV/XcGQT9X03jSDP6beJ5QG1JW\n-9Q3qLv/YixWI7gPV9Mrhf2oRYTc/9KLFRhkE3SjKOTKuSSBKQ24fI+hEznamH71D\n-66Hwez8/0et7AtTv9zvamv2OD5He6fMV4k+ePl6+qPfO5CdHtK+eCDZL5+4f5yrl\n-gTcRFiq8fXbc5IaI5fbbc1KMM/2T0Mr7+Hwaco6FtXm0fmhCgTZRqY4pKiEIfmaz\n-QwHNOOCrtMJ2VwsyMumt7xsOolGnizRev6lILH43qPcczQM7Gc5zRin80YvFt1Qm\n-h/57Z0auR2h0fuX50MBO4XQ+26y5l6v4j902R66c0j3z2KHstKQ04J/h6LbuNQE4\n-D6cu/lyfK69DxxX8wb8XaQkMUcJdo1LzqUGDAb3Kfn/A3P/JYc99MO9qv67+SxWb\n-wYTyqKdWTd+1KbR/Rcn0Io5zI/QquX7FA1bxfMytjQ/X+l0fh0Pf+Hx97meH4fQL\n-7/T8/sdTm9Tn8nELvedyhydLlPPTScINdXyLIq9wgIJr4fWPbp9ZhFh/56fdSgOG\n-HDXg+gkXsN2Rddr4HQ5P3u+RhLzmSjhzoqY5EsPC4QvRlX9JXjB84rPV5USR66qa\n-/kjw4156GJnzoXtydKJE53t6PHfZWO+3ujsfI6iAdshc7OFzGXiZB9PtItKodhYq\n-nABkTKdcpu4+TOpf9h5piX5slsaBjkeTnj/Ba02ilboQfcDVigxrYn/iTH5ySWUW\n-/lHtg78s5UZM8sErwhNe3N3w+6ZOMnU+5i86/xFNtqZfDdXTGy1H3PzGbdtZXYT+\n-Ixx2vpwBYzbPVYHxKosM5rPiVmcTllI9nuoSfeh9ib4foFWauOpvdmhBDqpTpKTX\n-u8EO2l2Z195G2RIV7TlKSxGWjR5sl/nALu1uzBeLd9zpSujzMTd1uTX9Qk/Q1S+r\n-vaW6bm8qqPO4jb6Wx6XIkm321nrIF6Ae25d1+Dpv/P5G4NoLd2j6/EtENC3FeR5z\n-oo7bA+tI8yEQRhiF0z1FlJXLD5ZbhNNWQm/j/IbzRfh8JtOFZU7ruShLvHXysW9S\n-9V909tr9jn8/E/Hb5N/1NVNHnZu2HIUvJvHJiHd2ucmeI9PWUMnppmE65GQ5E9xV\n-ZRlGEH0X85EvmHyEupkMrCC0oMv9RCq+/H8gcfpe00Hs/S+regT5p58cyYomh93v\n-qvuw/A06BE/wzJESuYbN9pqYpoXqXFemW1NksHEJ2w+PYMJ27WJyD5FpaXB85VaW\n-qMOhDfO8E3QdH8ybyKt/UgI8/tDGpFbyOlaVdIv1FXJhoLp8soAA4Djg6/KZ066N\n-ZFYuS8WdjpSZGP4/Lw+1yaXlzNznc/k2uHe2uXP3uFuPcHx+Dm44utxldoO1uBPy\n-+jzOs14+MIgOjOHMVNqAbMd8fUedLlhJMCfMtm4uz01enLNKcMrtLlPIR37Yukh1\n-YEMXYpm7eU4XU+j+Jj3pDyaXtXs+p1fWfTN/cy9/Oxs4umUXQ4uHh1kObtayDJ56\n-/QMxiHobjHNKuKfMxsrYEwN+QVIyVjAwMDYuMjQ1AAA9IwJniiBLRkZDAAAXt0Ja\n-aDQxQVkmU1lZtwytAACLf///////////////////+//////v//////////bv78//\n-/+AXO133uwO2xB2UxIvbKXrCqCoURUBL2ytFI82AFdcOwMhVTHtk5rD3szEVNYD4\n-aIQINCaMRoTaSn7SbSMJiYmEwieTEp+psqbMCp+VNPaFNpqbBNR7UmanlPUeKfqm\n-j1PU0/VPU08o9Q9EeKHlPJtKbYqeTCYhN6U9T1NH6mp+lPyoGNTI/Knkyg1MggAg\n-CaMEyQnqZoaaRtRtJpppppoDaTR6hpphGh6mmgHpMQBpkGTTEAAaAAAA00AZDag0\n-ADIBkGgABqemiRNTI0k8aU0PRGRoAZlP0UAAAGgAAAyAADQaAAAaAAAAAAAAAAAA\n-AaAAAAM0kgRBJ5MlPFP1Gj0jTTTUaekxNAbUGjTQMgaZANNAAAAaAADTQAAAAAAA\n-ANAA0AAANADQ0QAAAAAAAAAaGgAAAAAAABoA0AAA0AAAAAAAAAAAAANAAAAAkSEI\n-aTRpomp5DUxNNDTJPTKaep6T09Kemmo2JG0aTQ9ENogaaGhkABo0NHqaBoDTI0DC\n-Gj0gNAMhoDQ9QMQNAGQAaDDwyMPIMlbG1vhRBTFo6JksSupgpAjPbY0ec02IGXjb\n-eS+FBsh01+O4ZOaD+srUZCFaT4DRjVDLx7uKIsFtESIDUg1ZkhyCSYov05C00MtR\n-BdNNa/AYPGOQZWcs+VegXOPrkushFbZ3mBoRD6WamClkpBaHZrUhUl02bIfRXX4w\n-b3/9cW9nHDVxh2qFBxqgRKfmq7/Jc/tdJk05nVrGbckGVy2PnIy30CDhpWmqrSot\n-K2bOnX0NbP1iy2cd0Na0ZmbRstm4MzMzbbMySTd35F7f+zPP8DC+NJLYcakkkkRd\n-NZlupJt3OMFoDAD2g+N3FAMCydhIpoRHRQAdFI5nNg4ugEXHCYxkMyGCwtaJmial\n-y0IMlpSYYM/weXNJAhFqS0GNmvaPEtYGjbvaucMdklOTmBX1vfVAkTYB1uXCSK64\n-UNIixOqRKLuRCFtqIQtgwqaFrCkIYbbewErWABa+VGADWsJXJjfx5SJViLuwiGXq\n-Ru6vCuwmU5CJiJz3UiBpmLv0r2wskxUhY4tzPVGQ9RMXJl65eLSNwZVwaSyGZ9Cm\n-A3jztQUUpFeUryBTskW95iVwRMFrhBCwZBAFJBZvhMEMNoDJJlUoIhQkAkjbExp2\n-YZio+ZYeAZUwmH1qUbdQixmxf0+61+aVgJ1hwxsO1yG3hFx4pfjc09ITVht0pG8u\n-FtVFhPa1KE0gTRUSVXywkITucqk0Waz5Fs6qJpVHYdNrbYRFxnFsQGY1qmsTLjK6\n-4QX5Rddo6krM/Bx9CqIAKq4CzVQYHrmIAd2EBhYmwVYwLvhzKIUrc2EirnGIvyuD\n-O4YZDSwsVTA0BpVvUOjDErkCraBoSutcKwUSSLGhVvNYHLz3klgZD++wWsa/swLw\n-gvNDY2De+sncOv8X2lq4HD95ZdwPuTIMXCwSbg4RrIqv+L0y6F17pqDecyQYPEj3\n-iN/0BBeWZlJAyBMi5U3Q1zAlsK8IlDhaXGmvZrgISq5CfNjmUgxDeMggOKqxu4sI\n-OrilS49Lkl1J3u3GjXTuH+rX+4ccyFAQnizCpPClcY77F59j63S6fr5vr+y99tuO\n-7Ox7Wg/ljwhdyaK4xMmXczeJbx7x07htJNtC4xcQfAtvzeznLrN6MN/ILIBOI65I\n-qIA2D5fHHj1XN4aN6TvOjWDaSbSWqxCSCvXUpzkNJAkWXAuTwF8k5uSJvQj/rVo0\n-hAhEMEIYkCRGx9AX+byIuXWlLMbbVeliHNUL5AQYmNwLFu4SkmGD+UWtBMyVHQOQ\n-ss0ggoVKSKOBUgnVS6ljt7WE1qXqJJ4QA1pEwYNLEaguEE1LtPNoVr5WzjbSbWPk\n-V9OW3y9IneUDLoIV5pAkEFTEFGFVjeTFxtpzBBfGgycBxVCdz8eESBIzsamRchAa\n-TQunQH8DHnpfod9QuAuRvc7JBlKUCYmCjMvynLcxIFohxCaYrDvGw4QbXZB7oWQ7\n-hpoGlz23ayDfB8NrRRzdilsEQyQniu9ASLQg7RrGZnoTr1ai12IbCEUCGdFq03P5\n-nBnRFAGmisQGcyykV9gKtcVMWLhCuVmXg86dndn7slUpRNSSEAU20oaWIm1maFTu\n-E0DT4gTbg0nuhjtz3kNOz+i7sBm0bkXjxQWuLqlZEmp60ZTyRZJDUqKSEKg6hqcy\n-ERxdU22CSNOO10RYUUiDVpKhPNdKTOIE1thp02sBNoNTFSht8WJtaBQ09qN3jd5r\n-dOLX4IA5fevRyCCzDgRXfV4wzik4KROjmxmTMglBySlIMEzcXehnDXCRiZSlvwA2\n-0YsIOROcm4UrIRFxJHctJH7OdN5u1aHVHb5UaLHpv48NgmFRE56KTSoaWunqm2st\n-S0mrAdOiqcR12PWVbdVRJKcQ0DQuhwlAPcRtpxN3D4kbXJjToSYJIFw406G2CSaK\n-jQMIJPZGlQmgyFhoCSzeGS1VSq5SKKQQxs5RqKUcVUNY57YUETb4mXzV84SPngKi\n-nsce0mXByZq5BKUA9puHZWLNwQIYuDaJUNgG+E01E3pDYVNLKYQ0hsVesgV5gZY0\n-htDsRdGtm0+iGnkN6+Ea9YJtUZNAkx2GgSoix12nTW0avTUfxR3oYcpvZ7IdtABE\n-UhBcjG4qZtDZsS1JQHys243vhLaDTSvvTeBiJA2tmokqECTBcSOCAGkAxMKlVAva\n-4IsLRaBBqhxDbcGtgdw03mFcLUaFuhtKuuEIEkUleJQwby/zwu9uvvZK4xTV+ECM\n-a8lmzxKmqkBggYK1+xPdbmJclm6tSZhE/OSJtCEjs+unJIQkT9hCWgBJqGMS07Eh\n-AJNmBiuVEVdTyjkIJkavuZmx2sJF13htgEZUCC23lZFOE6gWbM9WyYNJTM8yCQrb\n-0Sx3OQvBML5cRATAQkSQkAJOAhoxpQkNi4ZiEVDbdtJAME0RXNDXGHA3M3Q0mm1o\n-IEwbWpaM1DQCSMbGRCAu3iRIQiT6RlBpT1n3tfwvUXz3gIVlx3mEximY/kZW1kNG\n-sgEJIrBisaEoGYPJ+1CQUYFBw+eGEHJQBpNHjErXUJY2iWHQ30hXwFBuMSxQ2lB5\n-bg+/LX3euG6HsHUB1lFvBvaiaBrITVwkCTa1d0s9CHZCiDZjbWReKyrpPE2oSa7o\n-LPrR4BJvys9ttjUpzETSSMxh8vsr9dXTwKBtK+1xCTGDQmNIaE29HmHdS5GSxpya\n-MismcAUSEgSxHBrKtgsZzduG7vHZn16l3kFkVITtENIzS2JsiBwFTDlhgexsjBHv\n-5HXOYxHBzoSDCcPZ0ctvkY9aS5XpoQuFYkGJgCsqjJZeUMNUEpDSbKcnUc1PifIA\n-CbR2UoXawBlspkEBr9HBfvUi/MUakZVOf1WKYrqSaIXce62JOyhJLq3qJBloTA0F\n-VbILEtM+heFmNRCFt70GJrExVJri0ArYbCRbADSGDBpBXxxb/6fo+s3C7uaL7RjM\n-LV2IQBNrAJrKFeJwTsPnxbAsemirUx2lk1kaxschzdK4TQNJN5wQnolIFg401OZ4\n-2na11LnT3lR+1k1TMJhiAjXMk0F1ooHnYlt9LKfJ3ZIOmeY+2l9bUQHWFNGyEyfj\n-EAcu3kpGLq0Ez7XOS+EpAASRQTAYMATfVQibHLTT30zG732+pNe9za1JNt8sNJYn\n-RjWuJ6jL5ILV0rcd9vT7X9fObvcXitpvJ2XBJE+PhX2HaTkyWeF9pwnlQNrTe9hV\n-tzhA+ihZrDrHNmLcQjZbnv/IMubqq8egxY80t5n6vZ6U5TR6U9uZJvai1xtqAyCR\n-NWkW52m00rDTEuO6BA4q2RHDWwbETF55rRsWLIgNW9qJCyMHPbTM/dMBmWMQSMxz\n-4M2pRzt47SICxA327UqSCEERqMFybmYi3nUxePtLgHYplqRiw4ynMbXd/kiQ0LE0\n-PKJSSCXA42ymziCpAxNWflzpzQdJZusahRFr6t6m+4p273/Taj7k+hZyNgBAgXAY\n-8F7pTts6orLb8IA6o4TOwkwQYmKvKu9VwMrE7+GUhVIAgY9a8DyQMiDBkEAwh7S1\n-KgCBfao8DK1CwSS8Z3WjL5MEgt93z2koUQCD/YxMBppiCMp7SDVSmkkIHptfGpeh\n-t+M13Ccv1tavIASFiaQl6rBz3K4N3DSGwNkCibrvEAC0fQirOWnc4NVbcLKpFG1l\n-NQXF/eqdT79wq1Mvlap3QSCLhcD2D3fCkKVWid4aSjtp9FOX1Uaf7P9eT93zd9Sv\n-mj2yNLRUGzyI/0oONNSzmmkvJ5Cq2X2CdldIWMGZO57RJ8oyATAWTQmRmNkfh0Sx\n-uuR/J9oUsomVy1AEntc0dlPivkqBkBqrxU3j5PnWkaI3ZRGc0gg9spCQEISh4xEU\n-pMhVrnmDQLfLP8Ouqpx917MAw7hkjQk6BJFTAbXDsz3LSHIxo/gB8qrA1vbvdZZh\n-LtR0frJdfdppX8nAQX/TAxOQ8+H6yw8a9i7/zJEfSYIhop59N/fhcWW2F14cj2Xc\n-fyHaZ04lTO4uPnly91jwuFPaREuZVp8AxImIhlkxkAN61tWdWG7tEbaCgszh6VIz\n-ThFnHo2Vi8SQXPrXCN7J9Tc9ZYiAYqoThV/u6SYsea5aZL8deOvKBQCgZZuIxX1z\n-4EnfcqG176vY4VqMBIC4pMJz0WcHJYqN+j7BiwGoMBwExrIdTB7q4XIFLotcIpS0\n-1MqyVsesvoQq7WObmGQXdMliMirSLcDuSx8Qy+4pIBgGDIyMp1qbonnGdcHYvU8S\n-O0A8s/iua5oFdNZTWvbVI4FUH9sKcLiB3/fIAF+sB4n8q6L+UCfmbPcAo/crQ6b3\n-HqhDBMY9J0q/jdz9GNYZ/1fbXdkUqAQKFePhtzJDRBZba27+LPQNMCcrHMq06F1T\n-4QmLmkHt7LxB2pAczUO+T2O9bHEw/HWw+dYf2MoRDUw=\n-`\n-\n-var outOfRangeSelector = []byte{\n-\t0x42, 0x5a, 0x68, 0x39, 0x31, 0x41, 0x59, 0x26,\n-\t0x53, 0x59, 0x4e, 0xec, 0xe8, 0x36, 0x00, 0x00,\n-\t0x02, 0x51, 0x80, 0x00, 0x10, 0x40, 0x00, 0x06,\n-\t0x44, 0x90, 0x80, 0x20, 0x00, 0x31, 0x06, 0x4c,\n-\t0x41, 0x01, 0xa7, 0xa9, 0xa5, 0x80, 0xbb, 0x94,\n-\t0x31, 0x17, 0x72, 0x45, 0x38, 0x50, 0x90, 0x00,\n-\t0x00, 0x00, 0x00,\n-}"}, {"sha": "eac2b0571b8c2b3df6445e135cd70a8193a9774b", "filename": "libgo/go/compress/bzip2/testdata/Mark.Twain-Tom.Sawyer.txt.bz2", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2FMark.Twain-Tom.Sawyer.txt.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "2bf2b6ad99f473b6a1b61c5b049eb5be89c61057", "filename": "libgo/go/compress/bzip2/testdata/fail-issue5747.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Ffail-issue5747.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Ffail-issue5747.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Ffail-issue5747.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "6e178792e1ec4367661a4be690744e1222e98cd5", "filename": "libgo/go/compress/bzip2/testdata/pass-random1.bin", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bin?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "f6a9dc71667f8f12b611ce1c4b9a7f6d47574638", "filename": "libgo/go/compress/bzip2/testdata/pass-random1.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random1.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "f152d40064f49075702c138ddcc2cc3fbacacb50", "filename": "libgo/go/compress/bzip2/testdata/pass-random2.bin", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bin?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+\ufffd\ufffde&\u0016\ufffdDJJ\u0004\ufffd\u001a\ufffd9d\ufffd\ufffdE\rC\ufffd\ufffd#;\ufffd23\ufffd\ufffdq\ufffdl*+\ufffd\ufffd\ufffd~\ufffd\r\ufffd\ufffd;&4\ufffd\u06db,\u0015\ufffd\ufffd\ufffdcc\ufffd5\ufffds5\ufffd\n\\ No newline at end of file"}, {"sha": "91ef775ccd91ed97685004d80cebe7015365c96a", "filename": "libgo/go/compress/bzip2/testdata/pass-random2.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-random2.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "579a3782b6594809778a6ab99e73d9a503ef35eb", "filename": "libgo/go/compress/bzip2/testdata/pass-sawtooth.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-sawtooth.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-sawtooth.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Fpass-sawtooth.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "1ef23001668181e139bee59ebe5f5cd9e9b8b8c9", "filename": "libgo/go/compress/bzip2/testdata/random.data.bz2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Frandom.data.bz2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Frandom.data.bz2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Ftestdata%2Frandom.data.bz2?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "a3200a8f49e8cf106cbc77b0c1029c69877f797a", "filename": "libgo/go/compress/flate/copy.go", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy.go?ref=9d04a3af4c6491536badf6bde9707c907e4d196b", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package flate\n-\n-// forwardCopy is like the built-in copy function except that it always goes\n-// forward from the start, even if the dst and src overlap.\n-// It is equivalent to:\n-//   for i := 0; i < n; i++ {\n-//     mem[dst+i] = mem[src+i]\n-//   }\n-func forwardCopy(mem []byte, dst, src, n int) {\n-\tif dst <= src {\n-\t\tcopy(mem[dst:dst+n], mem[src:src+n])\n-\t\treturn\n-\t}\n-\tfor {\n-\t\tif dst >= src+n {\n-\t\t\tcopy(mem[dst:dst+n], mem[src:src+n])\n-\t\t\treturn\n-\t\t}\n-\t\t// There is some forward overlap.  The destination\n-\t\t// will be filled with a repeated pattern of mem[src:src+k].\n-\t\t// We copy one instance of the pattern here, then repeat.\n-\t\t// Each time around this loop k will double.\n-\t\tk := dst - src\n-\t\tcopy(mem[dst:dst+k], mem[src:src+k])\n-\t\tn -= k\n-\t\tdst += k\n-\t}\n-}"}, {"sha": "2011b1547c934cccae2540cd378b600ce789a0e8", "filename": "libgo/go/compress/flate/copy_test.go", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fcopy_test.go?ref=9d04a3af4c6491536badf6bde9707c907e4d196b", "patch": "@@ -1,54 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package flate\n-\n-import (\n-\t\"testing\"\n-)\n-\n-func TestForwardCopy(t *testing.T) {\n-\ttestCases := []struct {\n-\t\tdst0, dst1 int\n-\t\tsrc0, src1 int\n-\t\twant       string\n-\t}{\n-\t\t{0, 9, 0, 9, \"012345678\"},\n-\t\t{0, 5, 4, 9, \"45678\"},\n-\t\t{4, 9, 0, 5, \"01230\"},\n-\t\t{1, 6, 3, 8, \"34567\"},\n-\t\t{3, 8, 1, 6, \"12121\"},\n-\t\t{0, 9, 3, 6, \"345\"},\n-\t\t{3, 6, 0, 9, \"012\"},\n-\t\t{1, 6, 0, 9, \"00000\"},\n-\t\t{0, 4, 7, 8, \"7\"},\n-\t\t{0, 1, 6, 8, \"6\"},\n-\t\t{4, 4, 6, 9, \"\"},\n-\t\t{2, 8, 6, 6, \"\"},\n-\t\t{0, 0, 0, 0, \"\"},\n-\t}\n-\tfor _, tc := range testCases {\n-\t\tb := []byte(\"0123456789\")\n-\t\tn := tc.dst1 - tc.dst0\n-\t\tif tc.src1-tc.src0 < n {\n-\t\t\tn = tc.src1 - tc.src0\n-\t\t}\n-\t\tforwardCopy(b, tc.dst0, tc.src0, n)\n-\t\tgot := string(b[tc.dst0 : tc.dst0+n])\n-\t\tif got != tc.want {\n-\t\t\tt.Errorf(\"dst=b[%d:%d], src=b[%d:%d]: got %q, want %q\",\n-\t\t\t\ttc.dst0, tc.dst1, tc.src0, tc.src1, got, tc.want)\n-\t\t}\n-\t\t// Check that the bytes outside of dst[:n] were not modified.\n-\t\tfor i, x := range b {\n-\t\t\tif i >= tc.dst0 && i < tc.dst0+n {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif int(x) != '0'+i {\n-\t\t\t\tt.Errorf(\"dst=b[%d:%d], src=b[%d:%d]: copy overrun at b[%d]: got '%c', want '%c'\",\n-\t\t\t\t\ttc.dst0, tc.dst1, tc.src0, tc.src1, i, x, '0'+i)\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "8a085ba34740f9ed9152615dad3e339b30f9bd0b", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 264, "deletions": 108, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -13,54 +13,65 @@ import (\n const (\n \tNoCompression      = 0\n \tBestSpeed          = 1\n-\tfastCompression    = 3\n \tBestCompression    = 9\n \tDefaultCompression = -1\n-\tlogWindowSize      = 15\n-\twindowSize         = 1 << logWindowSize\n-\twindowMask         = windowSize - 1\n-\tlogMaxOffsetSize   = 15  // Standard DEFLATE\n-\tminMatchLength     = 3   // The smallest match that the compressor looks for\n-\tmaxMatchLength     = 258 // The longest match for the compressor\n-\tminOffsetSize      = 1   // The shortest offset that makes any sense\n-\n-\t// The maximum number of tokens we put into a single flat block, just to\n+\tHuffmanOnly        = -2 // Disables match search and only does Huffman entropy reduction.\n+)\n+\n+const (\n+\tlogWindowSize = 15\n+\twindowSize    = 1 << logWindowSize\n+\twindowMask    = windowSize - 1\n+\n+\t// The LZ77 step produces a sequence of literal tokens and <length, offset>\n+\t// pair tokens. The offset is also known as distance. The underlying wire\n+\t// format limits the range of lengths and offsets. For example, there are\n+\t// 256 legitimate lengths: those in the range [3, 258]. This package's\n+\t// compressor uses a higher minimum match length, enabling optimizations\n+\t// such as finding matches via 32-bit loads and compares.\n+\tbaseMatchLength = 3       // The smallest match length per the RFC section 3.2.5\n+\tminMatchLength  = 4       // The smallest match length that the compressor actually emits\n+\tmaxMatchLength  = 258     // The largest match length\n+\tbaseMatchOffset = 1       // The smallest match offset\n+\tmaxMatchOffset  = 1 << 15 // The largest match offset\n+\n+\t// The maximum number of tokens we put into a single flate block, just to\n \t// stop things from getting too large.\n \tmaxFlateBlockTokens = 1 << 14\n \tmaxStoreBlockSize   = 65535\n-\thashBits            = 17\n+\thashBits            = 17 // After 17 performance degrades\n \thashSize            = 1 << hashBits\n \thashMask            = (1 << hashBits) - 1\n-\thashShift           = (hashBits + minMatchLength - 1) / minMatchLength\n \tmaxHashOffset       = 1 << 24\n \n \tskipNever = math.MaxInt32\n )\n \n type compressionLevel struct {\n-\tgood, lazy, nice, chain, fastSkipHashing int\n+\tlevel, good, lazy, nice, chain, fastSkipHashing int\n }\n \n var levels = []compressionLevel{\n-\t{}, // 0\n-\t// For levels 1-3 we don't bother trying with lazy matches\n-\t{3, 0, 8, 4, 4},\n-\t{3, 0, 16, 8, 5},\n-\t{3, 0, 32, 32, 6},\n+\t{0, 0, 0, 0, 0, 0}, // NoCompression.\n+\t{1, 0, 0, 0, 0, 0}, // BestSpeed uses a custom algorithm; see deflatefast.go.\n+\t// For levels 2-3 we don't bother trying with lazy matches.\n+\t{2, 4, 0, 16, 8, 5},\n+\t{3, 4, 0, 32, 32, 6},\n \t// Levels 4-9 use increasingly more lazy matching\n \t// and increasingly stringent conditions for \"good enough\".\n-\t{4, 4, 16, 16, skipNever},\n-\t{8, 16, 32, 32, skipNever},\n-\t{8, 16, 128, 128, skipNever},\n-\t{8, 32, 128, 256, skipNever},\n-\t{32, 128, 258, 1024, skipNever},\n-\t{32, 258, 258, 4096, skipNever},\n+\t{4, 4, 4, 16, 16, skipNever},\n+\t{5, 8, 16, 32, 32, skipNever},\n+\t{6, 8, 16, 128, 128, skipNever},\n+\t{7, 8, 32, 128, 256, skipNever},\n+\t{8, 32, 128, 258, 1024, skipNever},\n+\t{9, 32, 258, 258, 4096, skipNever},\n }\n \n type compressor struct {\n \tcompressionLevel\n \n-\tw *huffmanBitWriter\n+\tw          *huffmanBitWriter\n+\tbulkHasher func([]byte, []uint32)\n \n \t// compression algorithm\n \tfill func(*compressor, []byte) int // copy data to window\n@@ -73,8 +84,8 @@ type compressor struct {\n \t// hashPrev[hashHead[hashValue] & windowMask] contains the previous index\n \t// with the same hash value.\n \tchainHead  int\n-\thashHead   []int\n-\thashPrev   []int\n+\thashHead   [hashSize]uint32\n+\thashPrev   [windowSize]uint32\n \thashOffset int\n \n \t// input window: unprocessed data is window[index:windowEnd]\n@@ -90,9 +101,12 @@ type compressor struct {\n \t// deflate state\n \tlength         int\n \toffset         int\n-\thash           int\n+\thash           uint32\n \tmaxInsertIndex int\n \terr            error\n+\n+\t// hashMatch must be able to contain hashes for the maximum match length.\n+\thashMatch [maxMatchLength - 1]uint32\n }\n \n func (d *compressor) fillDeflate(b []byte) int {\n@@ -112,15 +126,15 @@ func (d *compressor) fillDeflate(b []byte) int {\n \t\t\td.hashOffset -= delta\n \t\t\td.chainHead -= delta\n \t\t\tfor i, v := range d.hashPrev {\n-\t\t\t\tif v > delta {\n-\t\t\t\t\td.hashPrev[i] -= delta\n+\t\t\t\tif int(v) > delta {\n+\t\t\t\t\td.hashPrev[i] = uint32(int(v) - delta)\n \t\t\t\t} else {\n \t\t\t\t\td.hashPrev[i] = 0\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor i, v := range d.hashHead {\n-\t\t\t\tif v > delta {\n-\t\t\t\t\td.hashHead[i] -= delta\n+\t\t\t\tif int(v) > delta {\n+\t\t\t\t\td.hashHead[i] = uint32(int(v) - delta)\n \t\t\t\t} else {\n \t\t\t\t\td.hashHead[i] = 0\n \t\t\t\t}\n@@ -132,19 +146,74 @@ func (d *compressor) fillDeflate(b []byte) int {\n \treturn n\n }\n \n-func (d *compressor) writeBlock(tokens []token, index int, eof bool) error {\n-\tif index > 0 || eof {\n+func (d *compressor) writeBlock(tokens []token, index int) error {\n+\tif index > 0 {\n \t\tvar window []byte\n \t\tif d.blockStart <= index {\n \t\t\twindow = d.window[d.blockStart:index]\n \t\t}\n \t\td.blockStart = index\n-\t\td.w.writeBlock(tokens, eof, window)\n+\t\td.w.writeBlock(tokens, false, window)\n \t\treturn d.w.err\n \t}\n \treturn nil\n }\n \n+// fillWindow will fill the current window with the supplied\n+// dictionary and calculate all hashes.\n+// This is much faster than doing a full encode.\n+// Should only be used after a reset.\n+func (d *compressor) fillWindow(b []byte) {\n+\t// Do not fill window if we are in store-only mode.\n+\tif d.compressionLevel.level < 2 {\n+\t\treturn\n+\t}\n+\tif d.index != 0 || d.windowEnd != 0 {\n+\t\tpanic(\"internal error: fillWindow called with stale data\")\n+\t}\n+\n+\t// If we are given too much, cut it.\n+\tif len(b) > windowSize {\n+\t\tb = b[len(b)-windowSize:]\n+\t}\n+\t// Add all to window.\n+\tn := copy(d.window, b)\n+\n+\t// Calculate 256 hashes at the time (more L1 cache hits)\n+\tloops := (n + 256 - minMatchLength) / 256\n+\tfor j := 0; j < loops; j++ {\n+\t\tindex := j * 256\n+\t\tend := index + 256 + minMatchLength - 1\n+\t\tif end > n {\n+\t\t\tend = n\n+\t\t}\n+\t\ttoCheck := d.window[index:end]\n+\t\tdstSize := len(toCheck) - minMatchLength + 1\n+\n+\t\tif dstSize <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tdst := d.hashMatch[:dstSize]\n+\t\td.bulkHasher(toCheck, dst)\n+\t\tvar newH uint32\n+\t\tfor i, val := range dst {\n+\t\t\tdi := i + index\n+\t\t\tnewH = val\n+\t\t\thh := &d.hashHead[newH&hashMask]\n+\t\t\t// Get previous value with the same hash.\n+\t\t\t// Our chain should point to the previous value.\n+\t\t\td.hashPrev[di&windowMask] = *hh\n+\t\t\t// Set the head of the hash chain to us.\n+\t\t\t*hh = uint32(di + d.hashOffset)\n+\t\t}\n+\t\td.hash = newH\n+\t}\n+\t// Update window information.\n+\td.windowEnd = n\n+\td.index = n\n+}\n+\n // Try to find a match starting at index whose length is greater than prevSize.\n // We only look at chainCount possibilities before giving up.\n func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length, offset int, ok bool) {\n@@ -168,20 +237,15 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \t\ttries >>= 2\n \t}\n \n-\tw0 := win[pos]\n-\tw1 := win[pos+1]\n \twEnd := win[pos+length]\n+\twPos := win[pos:]\n \tminIndex := pos - windowSize\n \n \tfor i := prevHead; tries > 0; tries-- {\n-\t\tif w0 == win[i] && w1 == win[i+1] && wEnd == win[i+length] {\n-\t\t\t// The hash function ensures that if win[i] and win[i+1] match, win[i+2] matches\n+\t\tif wEnd == win[i+length] {\n+\t\t\tn := matchLen(win[i:], wPos, minMatchLook)\n \n-\t\t\tn := 3\n-\t\t\tfor pos+n < len(win) && win[i+n] == win[pos+n] {\n-\t\t\t\tn++\n-\t\t\t}\n-\t\t\tif n > length && (n > 3 || pos-i <= 4096) {\n+\t\t\tif n > length && (n > minMatchLength || pos-i <= 4096) {\n \t\t\t\tlength = n\n \t\t\t\toffset = pos - i\n \t\t\t\tok = true\n@@ -196,7 +260,8 @@ func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead\n \t\t\t// hashPrev[i & windowMask] has already been overwritten, so stop now.\n \t\t\tbreak\n \t\t}\n-\t\tif i = d.hashPrev[i&windowMask] - d.hashOffset; i < minIndex || i < 0 {\n+\t\ti = int(d.hashPrev[i&windowMask]) - d.hashOffset\n+\t\tif i < minIndex || i < 0 {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -211,9 +276,84 @@ func (d *compressor) writeStoredBlock(buf []byte) error {\n \treturn d.w.err\n }\n \n+const hashmul = 0x1e35a7bd\n+\n+// hash4 returns a hash representation of the first 4 bytes\n+// of the supplied slice.\n+// The caller must ensure that len(b) >= 4.\n+func hash4(b []byte) uint32 {\n+\treturn ((uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24) * hashmul) >> (32 - hashBits)\n+}\n+\n+// bulkHash4 will compute hashes using the same\n+// algorithm as hash4\n+func bulkHash4(b []byte, dst []uint32) {\n+\tif len(b) < minMatchLength {\n+\t\treturn\n+\t}\n+\thb := uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24\n+\tdst[0] = (hb * hashmul) >> (32 - hashBits)\n+\tend := len(b) - minMatchLength + 1\n+\tfor i := 1; i < end; i++ {\n+\t\thb = (hb << 8) | uint32(b[i+3])\n+\t\tdst[i] = (hb * hashmul) >> (32 - hashBits)\n+\t}\n+}\n+\n+// matchLen returns the number of matching bytes in a and b\n+// up to length 'max'. Both slices must be at least 'max'\n+// bytes in size.\n+func matchLen(a, b []byte, max int) int {\n+\ta = a[:max]\n+\tb = b[:len(a)]\n+\tfor i, av := range a {\n+\t\tif b[i] != av {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn max\n+}\n+\n+// encSpeed will compress and store the currently added data,\n+// if enough has been accumulated or we at the end of the stream.\n+// Any error that occurred will be in d.err\n+func (d *compressor) encSpeed() {\n+\t// We only compress if we have maxStoreBlockSize.\n+\tif d.windowEnd < maxStoreBlockSize {\n+\t\tif !d.sync {\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Handle small sizes.\n+\t\tif d.windowEnd < 128 {\n+\t\t\tswitch {\n+\t\t\tcase d.windowEnd == 0:\n+\t\t\t\treturn\n+\t\t\tcase d.windowEnd <= 16:\n+\t\t\t\td.err = d.writeStoredBlock(d.window[:d.windowEnd])\n+\t\t\tdefault:\n+\t\t\t\td.w.writeBlockHuff(false, d.window[:d.windowEnd])\n+\t\t\t\td.err = d.w.err\n+\t\t\t}\n+\t\t\td.windowEnd = 0\n+\t\t\treturn\n+\t\t}\n+\n+\t}\n+\t// Encode the block.\n+\td.tokens = encodeBestSpeed(d.tokens[:0], d.window[:d.windowEnd])\n+\n+\t// If we removed less than 1/16th, Huffman compress the block.\n+\tif len(d.tokens) > d.windowEnd-(d.windowEnd>>4) {\n+\t\td.w.writeBlockHuff(false, d.window[:d.windowEnd])\n+\t} else {\n+\t\td.w.writeBlockDynamic(d.tokens, false, d.window[:d.windowEnd])\n+\t}\n+\td.err = d.w.err\n+\td.windowEnd = 0\n+}\n+\n func (d *compressor) initDeflate() {\n-\td.hashHead = make([]int, hashSize)\n-\td.hashPrev = make([]int, windowSize)\n \td.window = make([]byte, 2*windowSize)\n \td.hashOffset = 1\n \td.tokens = make([]token, 0, maxFlateBlockTokens+1)\n@@ -223,6 +363,7 @@ func (d *compressor) initDeflate() {\n \td.index = 0\n \td.hash = 0\n \td.chainHead = -1\n+\td.bulkHasher = bulkHash4\n }\n \n func (d *compressor) deflate() {\n@@ -232,7 +373,7 @@ func (d *compressor) deflate() {\n \n \td.maxInsertIndex = d.windowEnd - (minMatchLength - 1)\n \tif d.index < d.maxInsertIndex {\n-\t\td.hash = int(d.window[d.index])<<hashShift + int(d.window[d.index+1])\n+\t\td.hash = hash4(d.window[d.index : d.index+minMatchLength])\n \t}\n \n Loop:\n@@ -256,7 +397,7 @@ Loop:\n \t\t\t\t\td.byteAvailable = false\n \t\t\t\t}\n \t\t\t\tif len(d.tokens) > 0 {\n-\t\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index, false); d.err != nil {\n+\t\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n \t\t\t\t\td.tokens = d.tokens[:0]\n@@ -266,10 +407,11 @@ Loop:\n \t\t}\n \t\tif d.index < d.maxInsertIndex {\n \t\t\t// Update the hash\n-\t\t\td.hash = (d.hash<<hashShift + int(d.window[d.index+2])) & hashMask\n-\t\t\td.chainHead = d.hashHead[d.hash]\n-\t\t\td.hashPrev[d.index&windowMask] = d.chainHead\n-\t\t\td.hashHead[d.hash] = d.index + d.hashOffset\n+\t\t\td.hash = hash4(d.window[d.index : d.index+minMatchLength])\n+\t\t\thh := &d.hashHead[d.hash&hashMask]\n+\t\t\td.chainHead = int(*hh)\n+\t\t\td.hashPrev[d.index&windowMask] = uint32(d.chainHead)\n+\t\t\t*hh = uint32(d.index + d.hashOffset)\n \t\t}\n \t\tprevLength := d.length\n \t\tprevOffset := d.offset\n@@ -293,9 +435,9 @@ Loop:\n \t\t\t// There was a match at the previous step, and the current match is\n \t\t\t// not better. Output the previous match.\n \t\t\tif d.fastSkipHashing != skipNever {\n-\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(d.length-minMatchLength), uint32(d.offset-minOffsetSize)))\n+\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(d.length-baseMatchLength), uint32(d.offset-baseMatchOffset)))\n \t\t\t} else {\n-\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(prevLength-minMatchLength), uint32(prevOffset-minOffsetSize)))\n+\t\t\t\td.tokens = append(d.tokens, matchToken(uint32(prevLength-baseMatchLength), uint32(prevOffset-baseMatchOffset)))\n \t\t\t}\n \t\t\t// Insert in the hash table all strings up to the end of the match.\n \t\t\t// index and index-1 are already inserted. If there is not enough\n@@ -310,12 +452,13 @@ Loop:\n \t\t\t\t}\n \t\t\t\tfor d.index++; d.index < newIndex; d.index++ {\n \t\t\t\t\tif d.index < d.maxInsertIndex {\n-\t\t\t\t\t\td.hash = (d.hash<<hashShift + int(d.window[d.index+2])) & hashMask\n+\t\t\t\t\t\td.hash = hash4(d.window[d.index : d.index+minMatchLength])\n \t\t\t\t\t\t// Get previous value with the same hash.\n \t\t\t\t\t\t// Our chain should point to the previous value.\n-\t\t\t\t\t\td.hashPrev[d.index&windowMask] = d.hashHead[d.hash]\n+\t\t\t\t\t\thh := &d.hashHead[d.hash&hashMask]\n+\t\t\t\t\t\td.hashPrev[d.index&windowMask] = *hh\n \t\t\t\t\t\t// Set the head of the hash chain to us.\n-\t\t\t\t\t\td.hashHead[d.hash] = d.index + d.hashOffset\n+\t\t\t\t\t\t*hh = uint32(d.index + d.hashOffset)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif d.fastSkipHashing == skipNever {\n@@ -327,12 +470,12 @@ Loop:\n \t\t\t\t// item into the table.\n \t\t\t\td.index += d.length\n \t\t\t\tif d.index < d.maxInsertIndex {\n-\t\t\t\t\td.hash = (int(d.window[d.index])<<hashShift + int(d.window[d.index+1]))\n+\t\t\t\t\td.hash = hash4(d.window[d.index : d.index+minMatchLength])\n \t\t\t\t}\n \t\t\t}\n \t\t\tif len(d.tokens) == maxFlateBlockTokens {\n \t\t\t\t// The block includes the current character\n-\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index, false); d.err != nil {\n+\t\t\t\tif d.err = d.writeBlock(d.tokens, d.index); d.err != nil {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\td.tokens = d.tokens[:0]\n@@ -345,7 +488,7 @@ Loop:\n \t\t\t\t}\n \t\t\t\td.tokens = append(d.tokens, literalToken(uint32(d.window[i])))\n \t\t\t\tif len(d.tokens) == maxFlateBlockTokens {\n-\t\t\t\t\tif d.err = d.writeBlock(d.tokens, i+1, false); d.err != nil {\n+\t\t\t\t\tif d.err = d.writeBlock(d.tokens, i+1); d.err != nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n \t\t\t\t\td.tokens = d.tokens[:0]\n@@ -372,17 +515,37 @@ func (d *compressor) store() {\n \td.windowEnd = 0\n }\n \n+// storeHuff compresses and stores the currently added data\n+// when the d.window is full or we are at the end of the stream.\n+// Any error that occurred will be in d.err\n+func (d *compressor) storeHuff() {\n+\tif d.windowEnd < len(d.window) && !d.sync || d.windowEnd == 0 {\n+\t\treturn\n+\t}\n+\td.w.writeBlockHuff(false, d.window[:d.windowEnd])\n+\td.err = d.w.err\n+\td.windowEnd = 0\n+}\n+\n func (d *compressor) write(b []byte) (n int, err error) {\n+\tif d.err != nil {\n+\t\treturn 0, d.err\n+\t}\n \tn = len(b)\n-\tb = b[d.fill(d, b):]\n \tfor len(b) > 0 {\n \t\td.step(d)\n \t\tb = b[d.fill(d, b):]\n+\t\tif d.err != nil {\n+\t\t\treturn 0, d.err\n+\t\t}\n \t}\n-\treturn n, d.err\n+\treturn n, nil\n }\n \n func (d *compressor) syncFlush() error {\n+\tif d.err != nil {\n+\t\treturn d.err\n+\t}\n \td.sync = true\n \td.step(d)\n \tif d.err == nil {\n@@ -402,56 +565,51 @@ func (d *compressor) init(w io.Writer, level int) (err error) {\n \t\td.window = make([]byte, maxStoreBlockSize)\n \t\td.fill = (*compressor).fillStore\n \t\td.step = (*compressor).store\n+\tcase level == HuffmanOnly:\n+\t\td.window = make([]byte, maxStoreBlockSize)\n+\t\td.fill = (*compressor).fillStore\n+\t\td.step = (*compressor).storeHuff\n+\tcase level == BestSpeed:\n+\t\td.compressionLevel = levels[level]\n+\t\td.window = make([]byte, maxStoreBlockSize)\n+\t\td.fill = (*compressor).fillStore\n+\t\td.step = (*compressor).encSpeed\n+\t\td.tokens = make([]token, maxStoreBlockSize)\n \tcase level == DefaultCompression:\n \t\tlevel = 6\n \t\tfallthrough\n-\tcase 1 <= level && level <= 9:\n+\tcase 2 <= level && level <= 9:\n \t\td.compressionLevel = levels[level]\n \t\td.initDeflate()\n \t\td.fill = (*compressor).fillDeflate\n \t\td.step = (*compressor).deflate\n \tdefault:\n-\t\treturn fmt.Errorf(\"flate: invalid compression level %d: want value in range [-1, 9]\", level)\n+\t\treturn fmt.Errorf(\"flate: invalid compression level %d: want value in range [-2, 9]\", level)\n \t}\n \treturn nil\n }\n \n-var zeroes [32]int\n-var bzeroes [256]byte\n-\n func (d *compressor) reset(w io.Writer) {\n \td.w.reset(w)\n \td.sync = false\n \td.err = nil\n-\tswitch d.compressionLevel.chain {\n-\tcase 0:\n-\t\t// level was NoCompression.\n-\t\tfor i := range d.window {\n-\t\t\td.window[i] = 0\n-\t\t}\n+\tswitch d.compressionLevel.level {\n+\tcase NoCompression:\n+\t\td.windowEnd = 0\n+\tcase BestSpeed:\n \t\td.windowEnd = 0\n+\t\td.tokens = d.tokens[:0]\n \tdefault:\n \t\td.chainHead = -1\n-\t\tfor s := d.hashHead; len(s) > 0; {\n-\t\t\tn := copy(s, zeroes[:])\n-\t\t\ts = s[n:]\n+\t\tfor i := range d.hashHead {\n+\t\t\td.hashHead[i] = 0\n \t\t}\n-\t\tfor s := d.hashPrev; len(s) > 0; s = s[len(zeroes):] {\n-\t\t\tcopy(s, zeroes[:])\n+\t\tfor i := range d.hashPrev {\n+\t\t\td.hashPrev[i] = 0\n \t\t}\n \t\td.hashOffset = 1\n-\n \t\td.index, d.windowEnd = 0, 0\n-\t\tfor s := d.window; len(s) > 0; {\n-\t\t\tn := copy(s, bzeroes[:])\n-\t\t\ts = s[n:]\n-\t\t}\n \t\td.blockStart, d.byteAvailable = 0, false\n-\n-\t\td.tokens = d.tokens[:maxFlateBlockTokens+1]\n-\t\tfor i := 0; i <= maxFlateBlockTokens; i++ {\n-\t\t\td.tokens[i] = 0\n-\t\t}\n \t\td.tokens = d.tokens[:0]\n \t\td.length = minMatchLength - 1\n \t\td.offset = 0\n@@ -461,6 +619,9 @@ func (d *compressor) reset(w io.Writer) {\n }\n \n func (d *compressor) close() error {\n+\tif d.err != nil {\n+\t\treturn d.err\n+\t}\n \td.sync = true\n \td.step(d)\n \tif d.err != nil {\n@@ -477,10 +638,14 @@ func (d *compressor) close() error {\n // Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\n // higher levels typically run slower but compress more. Level 0\n // (NoCompression) does not attempt any compression; it only adds the\n-// necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default\n-// compression level.\n+// necessary DEFLATE framing.\n+// Level -1 (DefaultCompression) uses the default compression level.\n+// Level -2 (HuffmanOnly) will use Huffman compression only, giving\n+// a very fast compression for all types of input, but sacrificing considerable\n+// compression efficiency.\n //\n-// If level is in the range [-1, 9] then the error returned will be nil.\n+//\n+// If level is in the range [-2, 9] then the error returned will be nil.\n // Otherwise the error returned will be non-nil.\n func NewWriter(w io.Writer, level int) (*Writer, error) {\n \tvar dw Writer\n@@ -491,34 +656,28 @@ func NewWriter(w io.Writer, level int) (*Writer, error) {\n }\n \n // NewWriterDict is like NewWriter but initializes the new\n-// Writer with a preset dictionary.  The returned Writer behaves\n+// Writer with a preset dictionary. The returned Writer behaves\n // as if the dictionary had been written to it without producing\n-// any compressed output.  The compressed data written to w\n+// any compressed output. The compressed data written to w\n // can only be decompressed by a Reader initialized with the\n // same dictionary.\n func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n-\tdw := &dictWriter{w, false}\n+\tdw := &dictWriter{w}\n \tzw, err := NewWriter(dw, level)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tzw.Write(dict)\n-\tzw.Flush()\n-\tdw.enabled = true\n+\tzw.d.fillWindow(dict)\n \tzw.dict = append(zw.dict, dict...) // duplicate dictionary for Reset method.\n \treturn zw, err\n }\n \n type dictWriter struct {\n-\tw       io.Writer\n-\tenabled bool\n+\tw io.Writer\n }\n \n func (w *dictWriter) Write(b []byte) (n int, err error) {\n-\tif w.enabled {\n-\t\treturn w.w.Write(b)\n-\t}\n-\treturn len(b), nil\n+\treturn w.w.Write(b)\n }\n \n // A Writer takes data written to it and writes the compressed\n@@ -560,10 +719,7 @@ func (w *Writer) Reset(dst io.Writer) {\n \t\t// w was created with NewWriterDict\n \t\tdw.w = dst\n \t\tw.d.reset(dw)\n-\t\tdw.enabled = false\n-\t\tw.Write(w.dict)\n-\t\tw.Flush()\n-\t\tdw.enabled = true\n+\t\tw.d.fillWindow(w.dict)\n \t} else {\n \t\t// w was created with NewWriter\n \t\tw.d.reset(dst)"}, {"sha": "27a3b3823a649401df3c58f8be497328feb6e7a5", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 150, "deletions": 15, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -42,10 +42,10 @@ var deflateTests = []*deflateTest{\n \t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 0,\n \t\t[]byte{0, 8, 0, 247, 255, 17, 17, 17, 17, 17, 17, 17, 17, 1, 0, 0, 255, 255},\n \t},\n-\t{[]byte{}, 1, []byte{1, 0, 0, 255, 255}},\n-\t{[]byte{0x11}, 1, []byte{18, 4, 4, 0, 0, 255, 255}},\n-\t{[]byte{0x11, 0x12}, 1, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n-\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 1, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n+\t{[]byte{}, 2, []byte{1, 0, 0, 255, 255}},\n+\t{[]byte{0x11}, 2, []byte{18, 4, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x12}, 2, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n+\t{[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}, 2, []byte{18, 132, 2, 64, 0, 0, 0, 255, 255}},\n \t{[]byte{}, 9, []byte{1, 0, 0, 255, 255}},\n \t{[]byte{0x11}, 9, []byte{18, 4, 4, 0, 0, 255, 255}},\n \t{[]byte{0x11, 0x12}, 9, []byte{18, 20, 2, 4, 0, 0, 255, 255}},\n@@ -80,6 +80,32 @@ func largeDataChunk() []byte {\n \treturn result\n }\n \n+func TestBulkHash4(t *testing.T) {\n+\tfor _, x := range deflateTests {\n+\t\ty := x.out\n+\t\tif len(y) < minMatchLength {\n+\t\t\tcontinue\n+\t\t}\n+\t\ty = append(y, y...)\n+\t\tfor j := 4; j < len(y); j++ {\n+\t\t\ty := y[:j]\n+\t\t\tdst := make([]uint32, len(y)-minMatchLength+1)\n+\t\t\tfor i := range dst {\n+\t\t\t\tdst[i] = uint32(i + 100)\n+\t\t\t}\n+\t\t\tbulkHash4(y, dst)\n+\t\t\tfor i, got := range dst {\n+\t\t\t\twant := hash4(y[i:])\n+\t\t\t\tif got != want && got == uint32(i)+100 {\n+\t\t\t\t\tt.Errorf(\"Len:%d Index:%d, want 0x%08x but not modified\", len(y), i, want)\n+\t\t\t\t} else if got != want {\n+\t\t\t\t\tt.Errorf(\"Len:%d Index:%d, got 0x%08x want:0x%08x\", len(y), i, got, want)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func TestDeflate(t *testing.T) {\n \tfor _, h := range deflateTests {\n \t\tvar buf bytes.Buffer\n@@ -91,7 +117,7 @@ func TestDeflate(t *testing.T) {\n \t\tw.Write(h.in)\n \t\tw.Close()\n \t\tif !bytes.Equal(buf.Bytes(), h.out) {\n-\t\t\tt.Errorf(\"Deflate(%d, %x) = %x, want %x\", h.level, h.in, buf.Bytes(), h.out)\n+\t\t\tt.Errorf(\"Deflate(%d, %x) = \\n%#v, want \\n%#v\", h.level, h.in, buf.Bytes(), h.out)\n \t\t}\n \t}\n }\n@@ -247,7 +273,7 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t\t// not necessarily the case: the write Flush may emit\n \t\t// some extra framing bits that are not necessary\n \t\t// to process to obtain the first half of the uncompressed\n-\t\t// data.  The test ran correctly most of the time, because\n+\t\t// data. The test ran correctly most of the time, because\n \t\t// the background goroutine had usually read even\n \t\t// those extra bits by now, but it's not a useful thing to\n \t\t// check.\n@@ -289,6 +315,9 @@ func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name str\n \t\tt.Errorf(\"level: %d, len(compress(data)) = %d > limit = %d\", level, buffer.Len(), limit)\n \t\treturn\n \t}\n+\tif limit > 0 {\n+\t\tt.Logf(\"level: %d, size:%.2f%%, %d b\\n\", level, float64(buffer.Len()*100)/float64(limit), buffer.Len())\n+\t}\n \tr := NewReader(&buffer)\n \tout, err := ioutil.ReadAll(r)\n \tif err != nil {\n@@ -303,15 +332,17 @@ func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name str\n \ttestSync(t, level, input, name)\n }\n \n-func testToFromWithLimit(t *testing.T, input []byte, name string, limit [10]int) {\n+func testToFromWithLimit(t *testing.T, input []byte, name string, limit [11]int) {\n \tfor i := 0; i < 10; i++ {\n \t\ttestToFromWithLevelAndLimit(t, i, input, name, limit[i])\n \t}\n+\t// Test HuffmanCompression\n+\ttestToFromWithLevelAndLimit(t, -2, input, name, limit[10])\n }\n \n func TestDeflateInflate(t *testing.T) {\n \tfor i, h := range deflateInflateTests {\n-\t\ttestToFromWithLimit(t, h.in, fmt.Sprintf(\"#%d\", i), [10]int{})\n+\t\ttestToFromWithLimit(t, h.in, fmt.Sprintf(\"#%d\", i), [11]int{})\n \t}\n }\n \n@@ -327,19 +358,19 @@ func TestReverseBits(t *testing.T) {\n type deflateInflateStringTest struct {\n \tfilename string\n \tlabel    string\n-\tlimit    [10]int\n+\tlimit    [11]int\n }\n \n var deflateInflateStringTests = []deflateInflateStringTest{\n \t{\n \t\t\"../testdata/e.txt\",\n \t\t\"2.718281828...\",\n-\t\t[...]int{100018, 50650, 50960, 51150, 50930, 50790, 50790, 50790, 50790, 50790},\n+\t\t[...]int{100018, 50650, 50960, 51150, 50930, 50790, 50790, 50790, 50790, 50790, 43683},\n \t},\n \t{\n \t\t\"../testdata/Mark.Twain-Tom.Sawyer.txt\",\n \t\t\"Mark.Twain-Tom.Sawyer\",\n-\t\t[...]int{407330, 187598, 180361, 172974, 169160, 163476, 160936, 160506, 160295, 160295},\n+\t\t[...]int{407330, 187598, 180361, 172974, 169160, 163476, 160936, 160506, 160295, 160295, 233460},\n \t},\n }\n \n@@ -457,6 +488,17 @@ func TestWriterReset(t *testing.T) {\n \t\t// DeepEqual doesn't compare functions.\n \t\tw.d.fill, wref.d.fill = nil, nil\n \t\tw.d.step, wref.d.step = nil, nil\n+\t\tw.d.bulkHasher, wref.d.bulkHasher = nil, nil\n+\t\t// hashMatch is always overwritten when used.\n+\t\tcopy(w.d.hashMatch[:], wref.d.hashMatch[:])\n+\t\tif len(w.d.tokens) != 0 {\n+\t\t\tt.Errorf(\"level %d Writer not reset after Reset. %d tokens were present\", level, len(w.d.tokens))\n+\t\t}\n+\t\t// As long as the length is 0, we don't care about the content.\n+\t\tw.d.tokens = wref.d.tokens\n+\n+\t\t// We don't care if there are values in the window, as long as it is at d.index is 0\n+\t\tw.d.window = wref.d.window\n \t\tif !reflect.DeepEqual(w, wref) {\n \t\t\tt.Errorf(\"level %d Writer not reset after Reset\", level)\n \t\t}\n@@ -481,18 +523,111 @@ func testResetOutput(t *testing.T, newWriter func(w io.Writer) (*Writer, error))\n \t\tw.Write(b)\n \t}\n \tw.Close()\n-\tout1 := buf.String()\n+\tout1 := buf.Bytes()\n \n \tbuf2 := new(bytes.Buffer)\n \tw.Reset(buf2)\n \tfor i := 0; i < 1024; i++ {\n \t\tw.Write(b)\n \t}\n \tw.Close()\n-\tout2 := buf2.String()\n+\tout2 := buf2.Bytes()\n \n-\tif out1 != out2 {\n-\t\tt.Errorf(\"got %q, expected %q\", out2, out1)\n+\tif len(out1) != len(out2) {\n+\t\tt.Errorf(\"got %d, expected %d bytes\", len(out2), len(out1))\n+\t\treturn\n+\t}\n+\tif !bytes.Equal(out1, out2) {\n+\t\tmm := 0\n+\t\tfor i, b := range out1[:len(out2)] {\n+\t\t\tif b != out2[i] {\n+\t\t\t\tt.Errorf(\"mismatch index %d: %#02x, expected %#02x\", i, out2[i], b)\n+\t\t\t}\n+\t\t\tmm++\n+\t\t\tif mm == 10 {\n+\t\t\t\tt.Fatal(\"Stopping\")\n+\t\t\t}\n+\t\t}\n \t}\n \tt.Logf(\"got %d bytes\", len(out1))\n }\n+\n+// TestBestSpeed tests that round-tripping through deflate and then inflate\n+// recovers the original input. The Write sizes are near the thresholds in the\n+// compressor.encSpeed method (0, 16, 128), as well as near maxStoreBlockSize\n+// (65535).\n+func TestBestSpeed(t *testing.T) {\n+\tabc := make([]byte, 128)\n+\tfor i := range abc {\n+\t\tabc[i] = byte(i)\n+\t}\n+\tabcabc := bytes.Repeat(abc, 131072/len(abc))\n+\tvar want []byte\n+\n+\ttestCases := [][]int{\n+\t\t{65536, 0},\n+\t\t{65536, 1},\n+\t\t{65536, 1, 256},\n+\t\t{65536, 1, 65536},\n+\t\t{65536, 14},\n+\t\t{65536, 15},\n+\t\t{65536, 16},\n+\t\t{65536, 16, 256},\n+\t\t{65536, 16, 65536},\n+\t\t{65536, 127},\n+\t\t{65536, 128},\n+\t\t{65536, 128, 256},\n+\t\t{65536, 128, 65536},\n+\t\t{65536, 129},\n+\t\t{65536, 65536, 256},\n+\t\t{65536, 65536, 65536},\n+\t}\n+\n+\tfor i, tc := range testCases {\n+\t\tfor _, firstN := range []int{1, 65534, 65535, 65536, 65537, 131072} {\n+\t\t\ttc[0] = firstN\n+\t\touter:\n+\t\t\tfor _, flush := range []bool{false, true} {\n+\t\t\t\tbuf := new(bytes.Buffer)\n+\t\t\t\twant = want[:0]\n+\n+\t\t\t\tw, err := NewWriter(buf, BestSpeed)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: NewWriter: %v\", i, firstN, flush, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tfor _, n := range tc {\n+\t\t\t\t\twant = append(want, abcabc[:n]...)\n+\t\t\t\t\tif _, err := w.Write(abcabc[:n]); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: Write: %v\", i, firstN, flush, err)\n+\t\t\t\t\t\tcontinue outer\n+\t\t\t\t\t}\n+\t\t\t\t\tif !flush {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tif err := w.Flush(); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: Flush: %v\", i, firstN, flush, err)\n+\t\t\t\t\t\tcontinue outer\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif err := w.Close(); err != nil {\n+\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: Close: %v\", i, firstN, flush, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tr := NewReader(buf)\n+\t\t\t\tgot, err := ioutil.ReadAll(r)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: ReadAll: %v\", i, firstN, flush, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tr.Close()\n+\n+\t\t\t\tif !bytes.Equal(got, want) {\n+\t\t\t\t\tt.Errorf(\"i=%d, firstN=%d, flush=%t: corruption during deflate-then-inflate\", i, firstN, flush)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6b881a477c4e2afcd5735ec686327dc6ced893fa", "filename": "libgo/go/compress/flate/deflatefast.go", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+// This encoding algorithm, which prioritizes speed over output size, is\n+// based on Snappy's LZ77-style encoder: github.com/golang/snappy\n+\n+const (\n+\ttableBits  = 14             // Bits used in the table.\n+\ttableSize  = 1 << tableBits // Size of the table.\n+\ttableMask  = tableSize - 1  // Mask for table indices. Redundant, but can eliminate bounds checks.\n+\ttableShift = 32 - tableBits // Right-shift to get the tableBits most significant bits of a uint32.\n+)\n+\n+func load32(b []byte, i int) uint32 {\n+\tb = b[i : i+4 : len(b)] // Help the compiler eliminate bounds checks on the next line.\n+\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+}\n+\n+func load64(b []byte, i int) uint64 {\n+\tb = b[i : i+8 : len(b)] // Help the compiler eliminate bounds checks on the next line.\n+\treturn uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |\n+\t\tuint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n+}\n+\n+func hash(u uint32) uint32 {\n+\treturn (u * 0x1e35a7bd) >> tableShift\n+}\n+\n+// These constants are defined by the Snappy implementation so that its\n+// assembly implementation can fast-path some 16-bytes-at-a-time copies. They\n+// aren't necessary in the pure Go implementation, as we don't use those same\n+// optimizations, but using the same thresholds doesn't really hurt.\n+const (\n+\tinputMargin            = 16 - 1\n+\tminNonLiteralBlockSize = 1 + 1 + inputMargin\n+)\n+\n+func encodeBestSpeed(dst []token, src []byte) []token {\n+\t// This check isn't in the Snappy implementation, but there, the caller\n+\t// instead of the callee handles this case.\n+\tif len(src) < minNonLiteralBlockSize {\n+\t\treturn emitLiteral(dst, src)\n+\t}\n+\n+\t// Initialize the hash table.\n+\t//\n+\t// The table element type is uint16, as s < sLimit and sLimit < len(src)\n+\t// and len(src) <= maxStoreBlockSize and maxStoreBlockSize == 65535.\n+\tvar table [tableSize]uint16\n+\n+\t// sLimit is when to stop looking for offset/length copies. The inputMargin\n+\t// lets us use a fast path for emitLiteral in the main loop, while we are\n+\t// looking for copies.\n+\tsLimit := len(src) - inputMargin\n+\n+\t// nextEmit is where in src the next emitLiteral should start from.\n+\tnextEmit := 0\n+\n+\t// The encoded form must start with a literal, as there are no previous\n+\t// bytes to copy, so we start looking for hash matches at s == 1.\n+\ts := 1\n+\tnextHash := hash(load32(src, s))\n+\n+\tfor {\n+\t\t// Copied from the C++ snappy implementation:\n+\t\t//\n+\t\t// Heuristic match skipping: If 32 bytes are scanned with no matches\n+\t\t// found, start looking only at every other byte. If 32 more bytes are\n+\t\t// scanned (or skipped), look at every third byte, etc.. When a match\n+\t\t// is found, immediately go back to looking at every byte. This is a\n+\t\t// small loss (~5% performance, ~0.1% density) for compressible data\n+\t\t// due to more bookkeeping, but for non-compressible data (such as\n+\t\t// JPEG) it's a huge win since the compressor quickly \"realizes\" the\n+\t\t// data is incompressible and doesn't bother looking for matches\n+\t\t// everywhere.\n+\t\t//\n+\t\t// The \"skip\" variable keeps track of how many bytes there are since\n+\t\t// the last match; dividing it by 32 (ie. right-shifting by five) gives\n+\t\t// the number of bytes to move ahead for each iteration.\n+\t\tskip := 32\n+\n+\t\tnextS := s\n+\t\tcandidate := 0\n+\t\tfor {\n+\t\t\ts = nextS\n+\t\t\tbytesBetweenHashLookups := skip >> 5\n+\t\t\tnextS = s + bytesBetweenHashLookups\n+\t\t\tskip += bytesBetweenHashLookups\n+\t\t\tif nextS > sLimit {\n+\t\t\t\tgoto emitRemainder\n+\t\t\t}\n+\t\t\tcandidate = int(table[nextHash&tableMask])\n+\t\t\ttable[nextHash&tableMask] = uint16(s)\n+\t\t\tnextHash = hash(load32(src, nextS))\n+\t\t\t// TODO: < should be <=, and add a test for that.\n+\t\t\tif s-candidate < maxMatchOffset && load32(src, s) == load32(src, candidate) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\t// A 4-byte match has been found. We'll later see if more than 4 bytes\n+\t\t// match. But, prior to the match, src[nextEmit:s] are unmatched. Emit\n+\t\t// them as literal bytes.\n+\t\tdst = emitLiteral(dst, src[nextEmit:s])\n+\n+\t\t// Call emitCopy, and then see if another emitCopy could be our next\n+\t\t// move. Repeat until we find no match for the input immediately after\n+\t\t// what was consumed by the last emitCopy call.\n+\t\t//\n+\t\t// If we exit this loop normally then we need to call emitLiteral next,\n+\t\t// though we don't yet know how big the literal will be. We handle that\n+\t\t// by proceeding to the next iteration of the main loop. We also can\n+\t\t// exit this loop via goto if we get close to exhausting the input.\n+\t\tfor {\n+\t\t\t// Invariant: we have a 4-byte match at s, and no need to emit any\n+\t\t\t// literal bytes prior to s.\n+\t\t\tbase := s\n+\n+\t\t\t// Extend the 4-byte match as long as possible.\n+\t\t\t//\n+\t\t\t// This is an inlined version of Snappy's:\n+\t\t\t//\ts = extendMatch(src, candidate+4, s+4)\n+\t\t\ts += 4\n+\t\t\ts1 := base + maxMatchLength\n+\t\t\tif s1 > len(src) {\n+\t\t\t\ts1 = len(src)\n+\t\t\t}\n+\t\t\tfor i := candidate + 4; s < s1 && src[i] == src[s]; i, s = i+1, s+1 {\n+\t\t\t}\n+\n+\t\t\t// matchToken is flate's equivalent of Snappy's emitCopy.\n+\t\t\tdst = append(dst, matchToken(uint32(s-base-baseMatchLength), uint32(base-candidate-baseMatchOffset)))\n+\t\t\tnextEmit = s\n+\t\t\tif s >= sLimit {\n+\t\t\t\tgoto emitRemainder\n+\t\t\t}\n+\n+\t\t\t// We could immediately start working at s now, but to improve\n+\t\t\t// compression we first update the hash table at s-1 and at s. If\n+\t\t\t// another emitCopy is not our next move, also calculate nextHash\n+\t\t\t// at s+1. At least on GOARCH=amd64, these three hash calculations\n+\t\t\t// are faster as one load64 call (with some shifts) instead of\n+\t\t\t// three load32 calls.\n+\t\t\tx := load64(src, s-1)\n+\t\t\tprevHash := hash(uint32(x >> 0))\n+\t\t\ttable[prevHash&tableMask] = uint16(s - 1)\n+\t\t\tcurrHash := hash(uint32(x >> 8))\n+\t\t\tcandidate = int(table[currHash&tableMask])\n+\t\t\ttable[currHash&tableMask] = uint16(s)\n+\t\t\t// TODO: >= should be >, and add a test for that.\n+\t\t\tif s-candidate >= maxMatchOffset || uint32(x>>8) != load32(src, candidate) {\n+\t\t\t\tnextHash = hash(uint32(x >> 16))\n+\t\t\t\ts++\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+emitRemainder:\n+\tif nextEmit < len(src) {\n+\t\tdst = emitLiteral(dst, src[nextEmit:])\n+\t}\n+\treturn dst\n+}\n+\n+func emitLiteral(dst []token, lit []byte) []token {\n+\tfor _, v := range lit {\n+\t\tdst = append(dst, token(v))\n+\t}\n+\treturn dst\n+}"}, {"sha": "71c75a065ea7f7620a36bc10bb16abeda9873577", "filename": "libgo/go/compress/flate/dict_decoder.go", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+// dictDecoder implements the LZ77 sliding dictionary as used in decompression.\n+// LZ77 decompresses data through sequences of two forms of commands:\n+//\n+//\t* Literal insertions: Runs of one or more symbols are inserted into the data\n+//\tstream as is. This is accomplished through the writeByte method for a\n+//\tsingle symbol, or combinations of writeSlice/writeMark for multiple symbols.\n+//\tAny valid stream must start with a literal insertion if no preset dictionary\n+//\tis used.\n+//\n+//\t* Backward copies: Runs of one or more symbols are copied from previously\n+//\temitted data. Backward copies come as the tuple (dist, length) where dist\n+//\tdetermines how far back in the stream to copy from and length determines how\n+//\tmany bytes to copy. Note that it is valid for the length to be greater than\n+//\tthe distance. Since LZ77 uses forward copies, that situation is used to\n+//\tperform a form of run-length encoding on repeated runs of symbols.\n+//\tThe writeCopy and tryWriteCopy are used to implement this command.\n+//\n+// For performance reasons, this implementation performs little to no sanity\n+// checks about the arguments. As such, the invariants documented for each\n+// method call must be respected.\n+type dictDecoder struct {\n+\thist []byte // Sliding window history\n+\n+\t// Invariant: 0 <= rdPos <= wrPos <= len(hist)\n+\twrPos int  // Current output position in buffer\n+\trdPos int  // Have emitted hist[:rdPos] already\n+\tfull  bool // Has a full window length been written yet?\n+}\n+\n+// init initializes dictDecoder to have a sliding window dictionary of the given\n+// size. If a preset dict is provided, it will initialize the dictionary with\n+// the contents of dict.\n+func (dd *dictDecoder) init(size int, dict []byte) {\n+\t*dd = dictDecoder{hist: dd.hist}\n+\n+\tif cap(dd.hist) < size {\n+\t\tdd.hist = make([]byte, size)\n+\t}\n+\tdd.hist = dd.hist[:size]\n+\n+\tif len(dict) > len(dd.hist) {\n+\t\tdict = dict[len(dict)-len(dd.hist):]\n+\t}\n+\tdd.wrPos = copy(dd.hist, dict)\n+\tif dd.wrPos == len(dd.hist) {\n+\t\tdd.wrPos = 0\n+\t\tdd.full = true\n+\t}\n+\tdd.rdPos = dd.wrPos\n+}\n+\n+// histSize reports the total amount of historical data in the dictionary.\n+func (dd *dictDecoder) histSize() int {\n+\tif dd.full {\n+\t\treturn len(dd.hist)\n+\t}\n+\treturn dd.wrPos\n+}\n+\n+// availRead reports the number of bytes that can be flushed by readFlush.\n+func (dd *dictDecoder) availRead() int {\n+\treturn dd.wrPos - dd.rdPos\n+}\n+\n+// availWrite reports the available amount of output buffer space.\n+func (dd *dictDecoder) availWrite() int {\n+\treturn len(dd.hist) - dd.wrPos\n+}\n+\n+// writeSlice returns a slice of the available buffer to write data to.\n+//\n+// This invariant will be kept: len(s) <= availWrite()\n+func (dd *dictDecoder) writeSlice() []byte {\n+\treturn dd.hist[dd.wrPos:]\n+}\n+\n+// writeMark advances the writer pointer by cnt.\n+//\n+// This invariant must be kept: 0 <= cnt <= availWrite()\n+func (dd *dictDecoder) writeMark(cnt int) {\n+\tdd.wrPos += cnt\n+}\n+\n+// writeByte writes a single byte to the dictionary.\n+//\n+// This invariant must be kept: 0 < availWrite()\n+func (dd *dictDecoder) writeByte(c byte) {\n+\tdd.hist[dd.wrPos] = c\n+\tdd.wrPos++\n+}\n+\n+// writeCopy copies a string at a given (dist, length) to the output.\n+// This returns the number of bytes copied and may be less than the requested\n+// length if the available space in the output buffer is too small.\n+//\n+// This invariant must be kept: 0 < dist <= histSize()\n+func (dd *dictDecoder) writeCopy(dist, length int) int {\n+\tdstBase := dd.wrPos\n+\tdstPos := dstBase\n+\tsrcPos := dstPos - dist\n+\tendPos := dstPos + length\n+\tif endPos > len(dd.hist) {\n+\t\tendPos = len(dd.hist)\n+\t}\n+\n+\t// Copy non-overlapping section after destination position.\n+\t//\n+\t// This section is non-overlapping in that the copy length for this section\n+\t// is always less than or equal to the backwards distance. This can occur\n+\t// if a distance refers to data that wraps-around in the buffer.\n+\t// Thus, a backwards copy is performed here; that is, the exact bytes in\n+\t// the source prior to the copy is placed in the destination.\n+\tif srcPos < 0 {\n+\t\tsrcPos += len(dd.hist)\n+\t\tdstPos += copy(dd.hist[dstPos:endPos], dd.hist[srcPos:])\n+\t\tsrcPos = 0\n+\t}\n+\n+\t// Copy possibly overlapping section before destination position.\n+\t//\n+\t// This section can overlap if the copy length for this section is larger\n+\t// than the backwards distance. This is allowed by LZ77 so that repeated\n+\t// strings can be succinctly represented using (dist, length) pairs.\n+\t// Thus, a forwards copy is performed here; that is, the bytes copied is\n+\t// possibly dependent on the resulting bytes in the destination as the copy\n+\t// progresses along. This is functionally equivalent to the following:\n+\t//\n+\t//\tfor i := 0; i < endPos-dstPos; i++ {\n+\t//\t\tdd.hist[dstPos+i] = dd.hist[srcPos+i]\n+\t//\t}\n+\t//\tdstPos = endPos\n+\t//\n+\tfor dstPos < endPos {\n+\t\tdstPos += copy(dd.hist[dstPos:endPos], dd.hist[srcPos:dstPos])\n+\t}\n+\n+\tdd.wrPos = dstPos\n+\treturn dstPos - dstBase\n+}\n+\n+// tryWriteCopy tries to copy a string at a given (distance, length) to the\n+// output. This specialized version is optimized for short distances.\n+//\n+// This method is designed to be inlined for performance reasons.\n+//\n+// This invariant must be kept: 0 < dist <= histSize()\n+func (dd *dictDecoder) tryWriteCopy(dist, length int) int {\n+\tdstPos := dd.wrPos\n+\tendPos := dstPos + length\n+\tif dstPos < dist || endPos > len(dd.hist) {\n+\t\treturn 0\n+\t}\n+\tdstBase := dstPos\n+\tsrcPos := dstPos - dist\n+\n+\t// Copy possibly overlapping section before destination position.\n+loop:\n+\tdstPos += copy(dd.hist[dstPos:endPos], dd.hist[srcPos:dstPos])\n+\tif dstPos < endPos {\n+\t\tgoto loop // Avoid for-loop so that this function can be inlined\n+\t}\n+\n+\tdd.wrPos = dstPos\n+\treturn dstPos - dstBase\n+}\n+\n+// readFlush returns a slice of the historical buffer that is ready to be\n+// emitted to the user. The data returned by readFlush must be fully consumed\n+// before calling any other dictDecoder methods.\n+func (dd *dictDecoder) readFlush() []byte {\n+\ttoRead := dd.hist[dd.rdPos:dd.wrPos]\n+\tdd.rdPos = dd.wrPos\n+\tif dd.wrPos == len(dd.hist) {\n+\t\tdd.wrPos, dd.rdPos = 0, 0\n+\t\tdd.full = true\n+\t}\n+\treturn toRead\n+}"}, {"sha": "9275cff7911b120ce73096b7cbbca33d633cabf7", "filename": "libgo/go/compress/flate/dict_decoder_test.go", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdict_decoder_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestDictDecoder(t *testing.T) {\n+\tconst (\n+\t\tabc  = \"ABC\\n\"\n+\t\tfox  = \"The quick brown fox jumped over the lazy dog!\\n\"\n+\t\tpoem = \"The Road Not Taken\\nRobert Frost\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"Two roads diverged in a yellow wood,\\n\" +\n+\t\t\t\"And sorry I could not travel both\\n\" +\n+\t\t\t\"And be one traveler, long I stood\\n\" +\n+\t\t\t\"And looked down one as far as I could\\n\" +\n+\t\t\t\"To where it bent in the undergrowth;\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"Then took the other, as just as fair,\\n\" +\n+\t\t\t\"And having perhaps the better claim,\\n\" +\n+\t\t\t\"Because it was grassy and wanted wear;\\n\" +\n+\t\t\t\"Though as for that the passing there\\n\" +\n+\t\t\t\"Had worn them really about the same,\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"And both that morning equally lay\\n\" +\n+\t\t\t\"In leaves no step had trodden black.\\n\" +\n+\t\t\t\"Oh, I kept the first for another day!\\n\" +\n+\t\t\t\"Yet knowing how way leads on to way,\\n\" +\n+\t\t\t\"I doubted if I should ever come back.\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"I shall be telling this with a sigh\\n\" +\n+\t\t\t\"Somewhere ages and ages hence:\\n\" +\n+\t\t\t\"Two roads diverged in a wood, and I-\\n\" +\n+\t\t\t\"I took the one less traveled by,\\n\" +\n+\t\t\t\"And that has made all the difference.\\n\"\n+\t)\n+\n+\tvar poemRefs = []struct {\n+\t\tdist   int // Backward distance (0 if this is an insertion)\n+\t\tlength int // Length of copy or insertion\n+\t}{\n+\t\t{0, 38}, {33, 3}, {0, 48}, {79, 3}, {0, 11}, {34, 5}, {0, 6}, {23, 7},\n+\t\t{0, 8}, {50, 3}, {0, 2}, {69, 3}, {34, 5}, {0, 4}, {97, 3}, {0, 4},\n+\t\t{43, 5}, {0, 6}, {7, 4}, {88, 7}, {0, 12}, {80, 3}, {0, 2}, {141, 4},\n+\t\t{0, 1}, {196, 3}, {0, 3}, {157, 3}, {0, 6}, {181, 3}, {0, 2}, {23, 3},\n+\t\t{77, 3}, {28, 5}, {128, 3}, {110, 4}, {70, 3}, {0, 4}, {85, 6}, {0, 2},\n+\t\t{182, 6}, {0, 4}, {133, 3}, {0, 7}, {47, 5}, {0, 20}, {112, 5}, {0, 1},\n+\t\t{58, 3}, {0, 8}, {59, 3}, {0, 4}, {173, 3}, {0, 5}, {114, 3}, {0, 4},\n+\t\t{92, 5}, {0, 2}, {71, 3}, {0, 2}, {76, 5}, {0, 1}, {46, 3}, {96, 4},\n+\t\t{130, 4}, {0, 3}, {360, 3}, {0, 3}, {178, 5}, {0, 7}, {75, 3}, {0, 3},\n+\t\t{45, 6}, {0, 6}, {299, 6}, {180, 3}, {70, 6}, {0, 1}, {48, 3}, {66, 4},\n+\t\t{0, 3}, {47, 5}, {0, 9}, {325, 3}, {0, 1}, {359, 3}, {318, 3}, {0, 2},\n+\t\t{199, 3}, {0, 1}, {344, 3}, {0, 3}, {248, 3}, {0, 10}, {310, 3}, {0, 3},\n+\t\t{93, 6}, {0, 3}, {252, 3}, {157, 4}, {0, 2}, {273, 5}, {0, 14}, {99, 4},\n+\t\t{0, 1}, {464, 4}, {0, 2}, {92, 4}, {495, 3}, {0, 1}, {322, 4}, {16, 4},\n+\t\t{0, 3}, {402, 3}, {0, 2}, {237, 4}, {0, 2}, {432, 4}, {0, 1}, {483, 5},\n+\t\t{0, 2}, {294, 4}, {0, 2}, {306, 3}, {113, 5}, {0, 1}, {26, 4}, {164, 3},\n+\t\t{488, 4}, {0, 1}, {542, 3}, {248, 6}, {0, 5}, {205, 3}, {0, 8}, {48, 3},\n+\t\t{449, 6}, {0, 2}, {192, 3}, {328, 4}, {9, 5}, {433, 3}, {0, 3}, {622, 25},\n+\t\t{615, 5}, {46, 5}, {0, 2}, {104, 3}, {475, 10}, {549, 3}, {0, 4}, {597, 8},\n+\t\t{314, 3}, {0, 1}, {473, 6}, {317, 5}, {0, 1}, {400, 3}, {0, 3}, {109, 3},\n+\t\t{151, 3}, {48, 4}, {0, 4}, {125, 3}, {108, 3}, {0, 2},\n+\t}\n+\n+\tvar got, want bytes.Buffer\n+\tvar dd dictDecoder\n+\tdd.init(1<<11, nil)\n+\n+\tvar writeCopy = func(dist, length int) {\n+\t\tfor length > 0 {\n+\t\t\tcnt := dd.tryWriteCopy(dist, length)\n+\t\t\tif cnt == 0 {\n+\t\t\t\tcnt = dd.writeCopy(dist, length)\n+\t\t\t}\n+\n+\t\t\tlength -= cnt\n+\t\t\tif dd.availWrite() == 0 {\n+\t\t\t\tgot.Write(dd.readFlush())\n+\t\t\t}\n+\t\t}\n+\t}\n+\tvar writeString = func(str string) {\n+\t\tfor len(str) > 0 {\n+\t\t\tcnt := copy(dd.writeSlice(), str)\n+\t\t\tstr = str[cnt:]\n+\t\t\tdd.writeMark(cnt)\n+\t\t\tif dd.availWrite() == 0 {\n+\t\t\t\tgot.Write(dd.readFlush())\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\twriteString(\".\")\n+\twant.WriteByte('.')\n+\n+\tstr := poem\n+\tfor _, ref := range poemRefs {\n+\t\tif ref.dist == 0 {\n+\t\t\twriteString(str[:ref.length])\n+\t\t} else {\n+\t\t\twriteCopy(ref.dist, ref.length)\n+\t\t}\n+\t\tstr = str[ref.length:]\n+\t}\n+\twant.WriteString(poem)\n+\n+\twriteCopy(dd.histSize(), 33)\n+\twant.Write(want.Bytes()[:33])\n+\n+\twriteString(abc)\n+\twriteCopy(len(abc), 59*len(abc))\n+\twant.WriteString(strings.Repeat(abc, 60))\n+\n+\twriteString(fox)\n+\twriteCopy(len(fox), 9*len(fox))\n+\twant.WriteString(strings.Repeat(fox, 10))\n+\n+\twriteString(\".\")\n+\twriteCopy(1, 9)\n+\twant.WriteString(strings.Repeat(\".\", 10))\n+\n+\twriteString(strings.ToUpper(poem))\n+\twriteCopy(len(poem), 7*len(poem))\n+\twant.WriteString(strings.Repeat(strings.ToUpper(poem), 8))\n+\n+\twriteCopy(dd.histSize(), 10)\n+\twant.Write(want.Bytes()[want.Len()-dd.histSize():][:10])\n+\n+\tgot.Write(dd.readFlush())\n+\tif got.String() != want.String() {\n+\t\tt.Errorf(\"final string mismatch:\\ngot  %q\\nwant %q\", got.String(), want.String())\n+\t}\n+}"}, {"sha": "83c20498cc490d547add9c401f0c49619cc6a1b2", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -272,3 +272,81 @@ func TestTruncatedStreams(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Verify that flate.Reader.Read returns (n, io.EOF) instead\n+// of (n, nil) + (0, io.EOF) when possible.\n+//\n+// This helps net/http.Transport reuse HTTP/1 connections more\n+// aggressively.\n+//\n+// See https://github.com/google/go-github/pull/317 for background.\n+func TestReaderEarlyEOF(t *testing.T) {\n+\ttestSizes := []int{\n+\t\t1, 2, 3, 4, 5, 6, 7, 8,\n+\t\t100, 1000, 10000, 100000,\n+\t\t128, 1024, 16384, 131072,\n+\n+\t\t// Testing multiples of windowSize triggers the case\n+\t\t// where Read will fail to return an early io.EOF.\n+\t\twindowSize * 1, windowSize * 2, windowSize * 3,\n+\t}\n+\n+\tvar maxSize int\n+\tfor _, n := range testSizes {\n+\t\tif maxSize < n {\n+\t\t\tmaxSize = n\n+\t\t}\n+\t}\n+\n+\treadBuf := make([]byte, 40)\n+\tdata := make([]byte, maxSize)\n+\tfor i := range data {\n+\t\tdata[i] = byte(i)\n+\t}\n+\n+\tfor _, sz := range testSizes {\n+\t\tif testing.Short() && sz > windowSize {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, flush := range []bool{true, false} {\n+\t\t\tearlyEOF := true // Do we expect early io.EOF?\n+\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tw, _ := NewWriter(&buf, 5)\n+\t\t\tw.Write(data[:sz])\n+\t\t\tif flush {\n+\t\t\t\t// If a Flush occurs after all the actual data, the flushing\n+\t\t\t\t// semantics dictate that we will observe a (0, io.EOF) since\n+\t\t\t\t// Read must return data before it knows that the stream ended.\n+\t\t\t\tw.Flush()\n+\t\t\t\tearlyEOF = false\n+\t\t\t}\n+\t\t\tw.Close()\n+\n+\t\t\tr := NewReader(&buf)\n+\t\t\tfor {\n+\t\t\t\tn, err := r.Read(readBuf)\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\t// If the availWrite == windowSize, then that means that the\n+\t\t\t\t\t// previous Read returned because the write buffer was full\n+\t\t\t\t\t// and it just so happened that the stream had no more data.\n+\t\t\t\t\t// This situation is rare, but unavoidable.\n+\t\t\t\t\tif r.(*decompressor).dict.availWrite() == windowSize {\n+\t\t\t\t\t\tearlyEOF = false\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif n == 0 && earlyEOF {\n+\t\t\t\t\t\tt.Errorf(\"On size:%d flush:%v, Read() = (0, io.EOF), want (n, io.EOF)\", sz, flush)\n+\t\t\t\t\t}\n+\t\t\t\t\tif n != 0 && !earlyEOF {\n+\t\t\t\t\t\tt.Errorf(\"On size:%d flush:%v, Read() = (%d, io.EOF), want (0, io.EOF)\", sz, flush, n)\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "c4adef9ff53010b6db8d86f824bf235dc8b87ffd", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 352, "deletions": 172, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -6,7 +6,6 @@ package flate\n \n import (\n \t\"io\"\n-\t\"math\"\n )\n \n const (\n@@ -22,6 +21,17 @@ const (\n \t// The number of codegen codes.\n \tcodegenCodeCount = 19\n \tbadCode          = 255\n+\n+\t// bufferFlushSize indicates the buffer size\n+\t// after which bytes are flushed to the writer.\n+\t// Should preferably be a multiple of 6, since\n+\t// we accumulate 6 bytes between writes to the buffer.\n+\tbufferFlushSize = 240\n+\n+\t// bufferSize is the actual output byte buffer size.\n+\t// It must have additional headroom for a flush\n+\t// which can contain up to 8 bytes.\n+\tbufferSize = bufferFlushSize + 8\n )\n \n // The number of extra bits needed by length code X - LENGTH_CODES_START.\n@@ -70,14 +80,14 @@ type huffmanBitWriter struct {\n \tw io.Writer\n \t// Data waiting to be written is bytes[0:nbytes]\n \t// and then the low nbits of bits.\n-\tbits            uint32\n-\tnbits           uint32\n-\tbytes           [64]byte\n+\tbits            uint64\n+\tnbits           uint\n+\tbytes           [bufferSize]byte\n+\tcodegenFreq     [codegenCodeCount]int32\n \tnbytes          int\n \tliteralFreq     []int32\n \toffsetFreq      []int32\n \tcodegen         []uint8\n-\tcodegenFreq     []int32\n \tliteralEncoding *huffmanEncoder\n \toffsetEncoding  *huffmanEncoder\n \tcodegenEncoding *huffmanEncoder\n@@ -90,54 +100,16 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \t\tliteralFreq:     make([]int32, maxNumLit),\n \t\toffsetFreq:      make([]int32, offsetCodeCount),\n \t\tcodegen:         make([]uint8, maxNumLit+offsetCodeCount+1),\n-\t\tcodegenFreq:     make([]int32, codegenCodeCount),\n \t\tliteralEncoding: newHuffmanEncoder(maxNumLit),\n-\t\toffsetEncoding:  newHuffmanEncoder(offsetCodeCount),\n \t\tcodegenEncoding: newHuffmanEncoder(codegenCodeCount),\n+\t\toffsetEncoding:  newHuffmanEncoder(offsetCodeCount),\n \t}\n }\n \n func (w *huffmanBitWriter) reset(writer io.Writer) {\n \tw.w = writer\n \tw.bits, w.nbits, w.nbytes, w.err = 0, 0, 0, nil\n-\tw.bytes = [64]byte{}\n-\tfor i := range w.codegen {\n-\t\tw.codegen[i] = 0\n-\t}\n-\tfor _, s := range [...][]int32{w.literalFreq, w.offsetFreq, w.codegenFreq} {\n-\t\tfor i := range s {\n-\t\t\ts[i] = 0\n-\t\t}\n-\t}\n-\tfor _, enc := range [...]*huffmanEncoder{\n-\t\tw.literalEncoding,\n-\t\tw.offsetEncoding,\n-\t\tw.codegenEncoding} {\n-\t\tfor i := range enc.code {\n-\t\t\tenc.code[i] = 0\n-\t\t}\n-\t\tfor i := range enc.codeBits {\n-\t\t\tenc.codeBits[i] = 0\n-\t\t}\n-\t}\n-}\n-\n-func (w *huffmanBitWriter) flushBits() {\n-\tif w.err != nil {\n-\t\tw.nbits = 0\n-\t\treturn\n-\t}\n-\tbits := w.bits\n-\tw.bits >>= 16\n-\tw.nbits -= 16\n-\tn := w.nbytes\n-\tw.bytes[n] = byte(bits)\n-\tw.bytes[n+1] = byte(bits >> 8)\n-\tif n += 2; n >= len(w.bytes) {\n-\t\t_, w.err = w.w.Write(w.bytes[0:])\n-\t\tn = 0\n-\t}\n-\tw.nbytes = n\n+\tw.bytes = [bufferSize]byte{}\n }\n \n func (w *huffmanBitWriter) flush() {\n@@ -146,26 +118,42 @@ func (w *huffmanBitWriter) flush() {\n \t\treturn\n \t}\n \tn := w.nbytes\n-\tif w.nbits > 8 {\n+\tfor w.nbits != 0 {\n \t\tw.bytes[n] = byte(w.bits)\n \t\tw.bits >>= 8\n-\t\tw.nbits -= 8\n-\t\tn++\n-\t}\n-\tif w.nbits > 0 {\n-\t\tw.bytes[n] = byte(w.bits)\n-\t\tw.nbits = 0\n+\t\tif w.nbits > 8 { // Avoid underflow\n+\t\t\tw.nbits -= 8\n+\t\t} else {\n+\t\t\tw.nbits = 0\n+\t\t}\n \t\tn++\n \t}\n \tw.bits = 0\n-\t_, w.err = w.w.Write(w.bytes[0:n])\n+\t_, w.err = w.w.Write(w.bytes[:n])\n \tw.nbytes = 0\n }\n \n-func (w *huffmanBitWriter) writeBits(b, nb int32) {\n-\tw.bits |= uint32(b) << w.nbits\n-\tif w.nbits += uint32(nb); w.nbits >= 16 {\n-\t\tw.flushBits()\n+func (w *huffmanBitWriter) writeBits(b int32, nb uint) {\n+\tw.bits |= uint64(b) << w.nbits\n+\tw.nbits += nb\n+\tif w.nbits >= 48 {\n+\t\tbits := w.bits\n+\t\tw.bits >>= 48\n+\t\tw.nbits -= 48\n+\t\tn := w.nbytes\n+\t\tbytes := w.bytes[n : n+6]\n+\t\tbytes[0] = byte(bits)\n+\t\tbytes[1] = byte(bits >> 8)\n+\t\tbytes[2] = byte(bits >> 16)\n+\t\tbytes[3] = byte(bits >> 24)\n+\t\tbytes[4] = byte(bits >> 32)\n+\t\tbytes[5] = byte(bits >> 40)\n+\t\tn += 6\n+\t\tif n >= bufferFlushSize {\n+\t\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\t\tn = 0\n+\t\t}\n+\t\tw.nbytes = n\n \t}\n }\n \n@@ -174,17 +162,18 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {\n \t\treturn\n \t}\n \tn := w.nbytes\n-\tif w.nbits == 8 {\n-\t\tw.bytes[n] = byte(w.bits)\n-\t\tw.nbits = 0\n-\t\tn++\n-\t}\n-\tif w.nbits != 0 {\n+\tif w.nbits&7 != 0 {\n \t\tw.err = InternalError(\"writeBytes with unfinished bits\")\n \t\treturn\n \t}\n+\tfor w.nbits != 0 {\n+\t\tw.bytes[n] = byte(w.bits)\n+\t\tw.bits >>= 8\n+\t\tw.nbits -= 8\n+\t\tn++\n+\t}\n \tif n != 0 {\n-\t\t_, w.err = w.w.Write(w.bytes[0:n])\n+\t\t_, w.err = w.w.Write(w.bytes[:n])\n \t\tif w.err != nil {\n \t\t\treturn\n \t\t}\n@@ -200,11 +189,12 @@ func (w *huffmanBitWriter) writeBytes(bytes []byte) {\n // The result is written into the codegen array, and the frequencies\n // of each code is written into the codegenFreq array.\n // Codes 0-15 are single byte codes. Codes 16-18 are followed by additional\n-// information.  Code badCode is an end marker\n+// information. Code badCode is an end marker\n //\n //  numLiterals      The number of literals in literalEncoding\n //  numOffsets       The number of offsets in offsetEncoding\n-func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n+//  litenc, offenc   The literal and offset encoder to use\n+func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int, litEnc, offEnc *huffmanEncoder) {\n \tfor i := range w.codegenFreq {\n \t\tw.codegenFreq[i] = 0\n \t}\n@@ -213,9 +203,16 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n \t// This is fine because the output is always shorter than the input used\n \t// so far.\n \tcodegen := w.codegen // cache\n-\t// Copy the concatenated code sizes to codegen.  Put a marker at the end.\n-\tcopy(codegen[0:numLiterals], w.literalEncoding.codeBits)\n-\tcopy(codegen[numLiterals:numLiterals+numOffsets], w.offsetEncoding.codeBits)\n+\t// Copy the concatenated code sizes to codegen. Put a marker at the end.\n+\tcgnl := codegen[:numLiterals]\n+\tfor i := range cgnl {\n+\t\tcgnl[i] = uint8(litEnc.codes[i].len)\n+\t}\n+\n+\tcgnl = codegen[numLiterals : numLiterals+numOffsets]\n+\tfor i := range cgnl {\n+\t\tcgnl[i] = uint8(offEnc.codes[i].len)\n+\t}\n \tcodegen[numLiterals+numOffsets] = badCode\n \n \tsize := codegen[0]\n@@ -284,11 +281,71 @@ func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int) {\n \tcodegen[outIndex] = badCode\n }\n \n-func (w *huffmanBitWriter) writeCode(code *huffmanEncoder, literal uint32) {\n+// dynamicSize returns the size of dynamically encoded data in bits.\n+func (w *huffmanBitWriter) dynamicSize(litEnc, offEnc *huffmanEncoder, extraBits int) (size, numCodegens int) {\n+\tnumCodegens = len(w.codegenFreq)\n+\tfor numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens-1]] == 0 {\n+\t\tnumCodegens--\n+\t}\n+\theader := 3 + 5 + 5 + 4 + (3 * numCodegens) +\n+\t\tw.codegenEncoding.bitLength(w.codegenFreq[:]) +\n+\t\tint(w.codegenFreq[16])*2 +\n+\t\tint(w.codegenFreq[17])*3 +\n+\t\tint(w.codegenFreq[18])*7\n+\tsize = header +\n+\t\tlitEnc.bitLength(w.literalFreq) +\n+\t\toffEnc.bitLength(w.offsetFreq) +\n+\t\textraBits\n+\n+\treturn size, numCodegens\n+}\n+\n+// fixedSize returns the size of dynamically encoded data in bits.\n+func (w *huffmanBitWriter) fixedSize(extraBits int) int {\n+\treturn 3 +\n+\t\tfixedLiteralEncoding.bitLength(w.literalFreq) +\n+\t\tfixedOffsetEncoding.bitLength(w.offsetFreq) +\n+\t\textraBits\n+}\n+\n+// storedSize calculates the stored size, including header.\n+// The function returns the size in bits and whether the block\n+// fits inside a single block.\n+func (w *huffmanBitWriter) storedSize(in []byte) (int, bool) {\n+\tif in == nil {\n+\t\treturn 0, false\n+\t}\n+\tif len(in) <= maxStoreBlockSize {\n+\t\treturn (len(in) + 5) * 8, true\n+\t}\n+\treturn 0, false\n+}\n+\n+func (w *huffmanBitWriter) writeCode(c hcode) {\n \tif w.err != nil {\n \t\treturn\n \t}\n-\tw.writeBits(int32(code.code[literal]), int32(code.codeBits[literal]))\n+\tw.bits |= uint64(c.code) << w.nbits\n+\tw.nbits += uint(c.len)\n+\tif w.nbits >= 48 {\n+\t\tbits := w.bits\n+\t\tw.bits >>= 48\n+\t\tw.nbits -= 48\n+\t\tn := w.nbytes\n+\t\tbytes := w.bytes[n : n+6]\n+\t\tbytes[0] = byte(bits)\n+\t\tbytes[1] = byte(bits >> 8)\n+\t\tbytes[2] = byte(bits >> 16)\n+\t\tbytes[3] = byte(bits >> 24)\n+\t\tbytes[4] = byte(bits >> 32)\n+\t\tbytes[5] = byte(bits >> 40)\n+\t\tn += 6\n+\t\tif n >= bufferFlushSize {\n+\t\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\t\tn = 0\n+\t\t}\n+\t\tw.nbytes = n\n+\t}\n }\n \n // Write the header of a dynamic Huffman block to the output stream.\n@@ -310,7 +367,7 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n\n \tw.writeBits(int32(numCodegens-4), 4)\n \n \tfor i := 0; i < numCodegens; i++ {\n-\t\tvalue := w.codegenEncoding.codeBits[codegenOrder[i]]\n+\t\tvalue := uint(w.codegenEncoding.codes[codegenOrder[i]].len)\n \t\tw.writeBits(int32(value), 3)\n \t}\n \n@@ -321,8 +378,7 @@ func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, n\n \t\tif codeWord == badCode {\n \t\t\tbreak\n \t\t}\n-\t\t// The low byte contains the actual code to generate.\n-\t\tw.writeCode(w.codegenEncoding, uint32(codeWord))\n+\t\tw.writeCode(w.codegenEncoding.codes[uint32(codeWord)])\n \n \t\tswitch codeWord {\n \t\tcase 16:\n@@ -367,40 +423,138 @@ func (w *huffmanBitWriter) writeFixedHeader(isEof bool) {\n \tw.writeBits(value, 3)\n }\n \n+// writeBlock will write a block of tokens with the smallest encoding.\n+// The original input can be supplied, and if the huffman encoded data\n+// is larger than the original bytes, the data will be written as a\n+// stored block.\n+// If the input is nil, the tokens will always be Huffman encoded.\n func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \tif w.err != nil {\n \t\treturn\n \t}\n+\n+\ttokens = append(tokens, endBlockMarker)\n+\tnumLiterals, numOffsets := w.indexTokens(tokens)\n+\n+\tvar extraBits int\n+\tstoredSize, storable := w.storedSize(input)\n+\tif storable {\n+\t\t// We only bother calculating the costs of the extra bits required by\n+\t\t// the length of offset fields (which will be the same for both fixed\n+\t\t// and dynamic encoding), if we need to compare those two encodings\n+\t\t// against stored encoding.\n+\t\tfor lengthCode := lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++ {\n+\t\t\t// First eight length codes have extra size = 0.\n+\t\t\textraBits += int(w.literalFreq[lengthCode]) * int(lengthExtraBits[lengthCode-lengthCodesStart])\n+\t\t}\n+\t\tfor offsetCode := 4; offsetCode < numOffsets; offsetCode++ {\n+\t\t\t// First four offset codes have extra size = 0.\n+\t\t\textraBits += int(w.offsetFreq[offsetCode]) * int(offsetExtraBits[offsetCode])\n+\t\t}\n+\t}\n+\n+\t// Figure out smallest code.\n+\t// Fixed Huffman baseline.\n+\tvar literalEncoding = fixedLiteralEncoding\n+\tvar offsetEncoding = fixedOffsetEncoding\n+\tvar size = w.fixedSize(extraBits)\n+\n+\t// Dynamic Huffman?\n+\tvar numCodegens int\n+\n+\t// Generate codegen and codegenFrequencies, which indicates how to encode\n+\t// the literalEncoding and the offsetEncoding.\n+\tw.generateCodegen(numLiterals, numOffsets, w.literalEncoding, w.offsetEncoding)\n+\tw.codegenEncoding.generate(w.codegenFreq[:], 7)\n+\tdynamicSize, numCodegens := w.dynamicSize(w.literalEncoding, w.offsetEncoding, extraBits)\n+\n+\tif dynamicSize < size {\n+\t\tsize = dynamicSize\n+\t\tliteralEncoding = w.literalEncoding\n+\t\toffsetEncoding = w.offsetEncoding\n+\t}\n+\n+\t// Stored bytes?\n+\tif storable && storedSize < size {\n+\t\tw.writeStoredHeader(len(input), eof)\n+\t\tw.writeBytes(input)\n+\t\treturn\n+\t}\n+\n+\t// Huffman.\n+\tif literalEncoding == fixedLiteralEncoding {\n+\t\tw.writeFixedHeader(eof)\n+\t} else {\n+\t\tw.writeDynamicHeader(numLiterals, numOffsets, numCodegens, eof)\n+\t}\n+\n+\t// Write the tokens.\n+\tw.writeTokens(tokens, literalEncoding.codes, offsetEncoding.codes)\n+}\n+\n+// writeBlockDynamic encodes a block using a dynamic Huffman table.\n+// This should be used if the symbols used have a disproportionate\n+// histogram distribution.\n+// If input is supplied and the compression savings are below 1/16th of the\n+// input size the block is stored.\n+func (w *huffmanBitWriter) writeBlockDynamic(tokens []token, eof bool, input []byte) {\n+\tif w.err != nil {\n+\t\treturn\n+\t}\n+\n+\ttokens = append(tokens, endBlockMarker)\n+\tnumLiterals, numOffsets := w.indexTokens(tokens)\n+\n+\t// Generate codegen and codegenFrequencies, which indicates how to encode\n+\t// the literalEncoding and the offsetEncoding.\n+\tw.generateCodegen(numLiterals, numOffsets, w.literalEncoding, w.offsetEncoding)\n+\tw.codegenEncoding.generate(w.codegenFreq[:], 7)\n+\tsize, numCodegens := w.dynamicSize(w.literalEncoding, huffOffset, 0)\n+\n+\t// Store bytes, if we don't get a reasonable improvement.\n+\tif ssize, storable := w.storedSize(input); storable && ssize < (size+size>>4) {\n+\t\tw.writeStoredHeader(len(input), eof)\n+\t\tw.writeBytes(input)\n+\t\treturn\n+\t}\n+\n+\t// Write Huffman table.\n+\tw.writeDynamicHeader(numLiterals, numOffsets, numCodegens, eof)\n+\n+\t// Write the tokens.\n+\tw.writeTokens(tokens, w.literalEncoding.codes, w.offsetEncoding.codes)\n+}\n+\n+// indexTokens indexes a slice of tokens, and updates\n+// literalFreq and offsetFreq, and generates literalEncoding\n+// and offsetEncoding.\n+// The number of literal and offset tokens is returned.\n+func (w *huffmanBitWriter) indexTokens(tokens []token) (numLiterals, numOffsets int) {\n \tfor i := range w.literalFreq {\n \t\tw.literalFreq[i] = 0\n \t}\n \tfor i := range w.offsetFreq {\n \t\tw.offsetFreq[i] = 0\n \t}\n \n-\tn := len(tokens)\n-\ttokens = tokens[0 : n+1]\n-\ttokens[n] = endBlockMarker\n-\n \tfor _, t := range tokens {\n-\t\tswitch t.typ() {\n-\t\tcase literalType:\n+\t\tif t < matchType {\n \t\t\tw.literalFreq[t.literal()]++\n-\t\tcase matchType:\n-\t\t\tlength := t.length()\n-\t\t\toffset := t.offset()\n-\t\t\tw.literalFreq[lengthCodesStart+lengthCode(length)]++\n-\t\t\tw.offsetFreq[offsetCode(offset)]++\n+\t\t\tcontinue\n \t\t}\n+\t\tlength := t.length()\n+\t\toffset := t.offset()\n+\t\tw.literalFreq[lengthCodesStart+lengthCode(length)]++\n+\t\tw.offsetFreq[offsetCode(offset)]++\n \t}\n \n \t// get the number of literals\n-\tnumLiterals := len(w.literalFreq)\n+\tnumLiterals = len(w.literalFreq)\n \tfor w.literalFreq[numLiterals-1] == 0 {\n \t\tnumLiterals--\n \t}\n \t// get the number of offsets\n-\tnumOffsets := len(w.offsetFreq)\n+\tnumOffsets = len(w.offsetFreq)\n \tfor numOffsets > 0 && w.offsetFreq[numOffsets-1] == 0 {\n \t\tnumOffsets--\n \t}\n@@ -410,108 +564,134 @@ func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte) {\n \t\tw.offsetFreq[0] = 1\n \t\tnumOffsets = 1\n \t}\n-\n \tw.literalEncoding.generate(w.literalFreq, 15)\n \tw.offsetEncoding.generate(w.offsetFreq, 15)\n+\treturn\n+}\n \n-\tstoredBytes := 0\n-\tif input != nil {\n-\t\tstoredBytes = len(input)\n-\t}\n-\tvar extraBits int64\n-\tvar storedSize int64 = math.MaxInt64\n-\tif storedBytes <= maxStoreBlockSize && input != nil {\n-\t\tstoredSize = int64((storedBytes + 5) * 8)\n-\t\t// We only bother calculating the costs of the extra bits required by\n-\t\t// the length of offset fields (which will be the same for both fixed\n-\t\t// and dynamic encoding), if we need to compare those two encodings\n-\t\t// against stored encoding.\n-\t\tfor lengthCode := lengthCodesStart + 8; lengthCode < numLiterals; lengthCode++ {\n-\t\t\t// First eight length codes have extra size = 0.\n-\t\t\textraBits += int64(w.literalFreq[lengthCode]) * int64(lengthExtraBits[lengthCode-lengthCodesStart])\n+// writeTokens writes a slice of tokens to the output.\n+// codes for literal and offset encoding must be supplied.\n+func (w *huffmanBitWriter) writeTokens(tokens []token, leCodes, oeCodes []hcode) {\n+\tfor _, t := range tokens {\n+\t\tif t < matchType {\n+\t\t\tw.writeCode(leCodes[t.literal()])\n+\t\t\tcontinue\n \t\t}\n-\t\tfor offsetCode := 4; offsetCode < numOffsets; offsetCode++ {\n-\t\t\t// First four offset codes have extra size = 0.\n-\t\t\textraBits += int64(w.offsetFreq[offsetCode]) * int64(offsetExtraBits[offsetCode])\n+\t\t// Write the length\n+\t\tlength := t.length()\n+\t\tlengthCode := lengthCode(length)\n+\t\tw.writeCode(leCodes[lengthCode+lengthCodesStart])\n+\t\textraLengthBits := uint(lengthExtraBits[lengthCode])\n+\t\tif extraLengthBits > 0 {\n+\t\t\textraLength := int32(length - lengthBase[lengthCode])\n+\t\t\tw.writeBits(extraLength, extraLengthBits)\n+\t\t}\n+\t\t// Write the offset\n+\t\toffset := t.offset()\n+\t\toffsetCode := offsetCode(offset)\n+\t\tw.writeCode(oeCodes[offsetCode])\n+\t\textraOffsetBits := uint(offsetExtraBits[offsetCode])\n+\t\tif extraOffsetBits > 0 {\n+\t\t\textraOffset := int32(offset - offsetBase[offsetCode])\n+\t\t\tw.writeBits(extraOffset, extraOffsetBits)\n \t\t}\n \t}\n+}\n \n-\t// Figure out smallest code.\n-\t// Fixed Huffman baseline.\n-\tvar size = int64(3) +\n-\t\tfixedLiteralEncoding.bitLength(w.literalFreq) +\n-\t\tfixedOffsetEncoding.bitLength(w.offsetFreq) +\n-\t\textraBits\n-\tvar literalEncoding = fixedLiteralEncoding\n-\tvar offsetEncoding = fixedOffsetEncoding\n+// huffOffset is a static offset encoder used for huffman only encoding.\n+// It can be reused since we will not be encoding offset values.\n+var huffOffset *huffmanEncoder\n \n-\t// Dynamic Huffman?\n-\tvar numCodegens int\n+func init() {\n+\tw := newHuffmanBitWriter(nil)\n+\tw.offsetFreq[0] = 1\n+\thuffOffset = newHuffmanEncoder(offsetCodeCount)\n+\thuffOffset.generate(w.offsetFreq, 15)\n+}\n \n-\t// Generate codegen and codegenFrequencies, which indicates how to encode\n-\t// the literalEncoding and the offsetEncoding.\n-\tw.generateCodegen(numLiterals, numOffsets)\n-\tw.codegenEncoding.generate(w.codegenFreq, 7)\n-\tnumCodegens = len(w.codegenFreq)\n-\tfor numCodegens > 4 && w.codegenFreq[codegenOrder[numCodegens-1]] == 0 {\n-\t\tnumCodegens--\n+// writeBlockHuff encodes a block of bytes as either\n+// Huffman encoded literals or uncompressed bytes if the\n+// results only gains very little from compression.\n+func (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte) {\n+\tif w.err != nil {\n+\t\treturn\n \t}\n-\tdynamicHeader := int64(3+5+5+4+(3*numCodegens)) +\n-\t\tw.codegenEncoding.bitLength(w.codegenFreq) +\n-\t\tint64(extraBits) +\n-\t\tint64(w.codegenFreq[16]*2) +\n-\t\tint64(w.codegenFreq[17]*3) +\n-\t\tint64(w.codegenFreq[18]*7)\n-\tdynamicSize := dynamicHeader +\n-\t\tw.literalEncoding.bitLength(w.literalFreq) +\n-\t\tw.offsetEncoding.bitLength(w.offsetFreq)\n \n-\tif dynamicSize < size {\n-\t\tsize = dynamicSize\n-\t\tliteralEncoding = w.literalEncoding\n-\t\toffsetEncoding = w.offsetEncoding\n+\t// Clear histogram\n+\tfor i := range w.literalFreq {\n+\t\tw.literalFreq[i] = 0\n \t}\n \n-\t// Stored bytes?\n-\tif storedSize < size {\n-\t\tw.writeStoredHeader(storedBytes, eof)\n-\t\tw.writeBytes(input[0:storedBytes])\n+\t// Add everything as literals\n+\thistogram(input, w.literalFreq)\n+\n+\tw.literalFreq[endBlockMarker] = 1\n+\n+\tconst numLiterals = endBlockMarker + 1\n+\tconst numOffsets = 1\n+\n+\tw.literalEncoding.generate(w.literalFreq, 15)\n+\n+\t// Figure out smallest code.\n+\t// Always use dynamic Huffman or Store\n+\tvar numCodegens int\n+\n+\t// Generate codegen and codegenFrequencies, which indicates how to encode\n+\t// the literalEncoding and the offsetEncoding.\n+\tw.generateCodegen(numLiterals, numOffsets, w.literalEncoding, huffOffset)\n+\tw.codegenEncoding.generate(w.codegenFreq[:], 7)\n+\tsize, numCodegens := w.dynamicSize(w.literalEncoding, huffOffset, 0)\n+\n+\t// Store bytes, if we don't get a reasonable improvement.\n+\tif ssize, storable := w.storedSize(input); storable && ssize < (size+size>>4) {\n+\t\tw.writeStoredHeader(len(input), eof)\n+\t\tw.writeBytes(input)\n \t\treturn\n \t}\n \n \t// Huffman.\n-\tif literalEncoding == fixedLiteralEncoding {\n-\t\tw.writeFixedHeader(eof)\n-\t} else {\n-\t\tw.writeDynamicHeader(numLiterals, numOffsets, numCodegens, eof)\n-\t}\n-\tfor _, t := range tokens {\n-\t\tswitch t.typ() {\n-\t\tcase literalType:\n-\t\t\tw.writeCode(literalEncoding, t.literal())\n-\t\t\tbreak\n-\t\tcase matchType:\n-\t\t\t// Write the length\n-\t\t\tlength := t.length()\n-\t\t\tlengthCode := lengthCode(length)\n-\t\t\tw.writeCode(literalEncoding, lengthCode+lengthCodesStart)\n-\t\t\textraLengthBits := int32(lengthExtraBits[lengthCode])\n-\t\t\tif extraLengthBits > 0 {\n-\t\t\t\textraLength := int32(length - lengthBase[lengthCode])\n-\t\t\t\tw.writeBits(extraLength, extraLengthBits)\n-\t\t\t}\n-\t\t\t// Write the offset\n-\t\t\toffset := t.offset()\n-\t\t\toffsetCode := offsetCode(offset)\n-\t\t\tw.writeCode(offsetEncoding, offsetCode)\n-\t\t\textraOffsetBits := int32(offsetExtraBits[offsetCode])\n-\t\t\tif extraOffsetBits > 0 {\n-\t\t\t\textraOffset := int32(offset - offsetBase[offsetCode])\n-\t\t\t\tw.writeBits(extraOffset, extraOffsetBits)\n-\t\t\t}\n-\t\t\tbreak\n-\t\tdefault:\n-\t\t\tpanic(\"unknown token type: \" + string(t))\n+\tw.writeDynamicHeader(numLiterals, numOffsets, numCodegens, eof)\n+\tencoding := w.literalEncoding.codes[:257]\n+\tn := w.nbytes\n+\tfor _, t := range input {\n+\t\t// Bitwriting inlined, ~30% speedup\n+\t\tc := encoding[t]\n+\t\tw.bits |= uint64(c.code) << w.nbits\n+\t\tw.nbits += uint(c.len)\n+\t\tif w.nbits < 48 {\n+\t\t\tcontinue\n \t\t}\n+\t\t// Store 6 bytes\n+\t\tbits := w.bits\n+\t\tw.bits >>= 48\n+\t\tw.nbits -= 48\n+\t\tbytes := w.bytes[n : n+6]\n+\t\tbytes[0] = byte(bits)\n+\t\tbytes[1] = byte(bits >> 8)\n+\t\tbytes[2] = byte(bits >> 16)\n+\t\tbytes[3] = byte(bits >> 24)\n+\t\tbytes[4] = byte(bits >> 32)\n+\t\tbytes[5] = byte(bits >> 40)\n+\t\tn += 6\n+\t\tif n < bufferFlushSize {\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, w.err = w.w.Write(w.bytes[:n])\n+\t\tif w.err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn = 0\n+\t}\n+\tw.nbytes = n\n+\tw.writeCode(encoding[endBlockMarker])\n+}\n+\n+// histogram accumulates a histogram of b in h.\n+//\n+// len(h) must be >= 256, and h's elements must be all zeroes.\n+func histogram(b []byte, h []int32) {\n+\th = h[:256]\n+\tfor _, t := range b {\n+\t\th[t]++\n \t}\n }"}, {"sha": "882d3abec18bf0a70acf67d470aabfce2da1a657", "filename": "libgo/go/compress/flate/huffman_bit_writer_test.go", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,366 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var update = flag.Bool(\"update\", false, \"update reference files\")\n+\n+// TestBlockHuff tests huffman encoding against reference files\n+// to detect possible regressions.\n+// If encoding/bit allocation changes you can regenerate these files\n+// by using the -update flag.\n+func TestBlockHuff(t *testing.T) {\n+\t// determine input files\n+\tmatch, err := filepath.Glob(\"testdata/huffman-*.in\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tfor _, in := range match {\n+\t\tout := in // for files where input and output are identical\n+\t\tif strings.HasSuffix(in, \".in\") {\n+\t\t\tout = in[:len(in)-len(\".in\")] + \".golden\"\n+\t\t}\n+\t\ttestBlockHuff(t, in, out)\n+\t}\n+}\n+\n+func testBlockHuff(t *testing.T, in, out string) {\n+\tall, err := ioutil.ReadFile(in)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tvar buf bytes.Buffer\n+\tbw := newHuffmanBitWriter(&buf)\n+\tbw.writeBlockHuff(false, all)\n+\tbw.flush()\n+\tgot := buf.Bytes()\n+\n+\twant, err := ioutil.ReadFile(out)\n+\tif err != nil && !*update {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tt.Logf(\"Testing %q\", in)\n+\tif !bytes.Equal(got, want) {\n+\t\tif *update {\n+\t\t\tif in != out {\n+\t\t\t\tt.Logf(\"Updating %q\", out)\n+\t\t\t\tif err := ioutil.WriteFile(out, got, 0666); err != nil {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// in == out: don't accidentally destroy input\n+\t\t\tt.Errorf(\"WARNING: -update did not rewrite input file %s\", in)\n+\t\t}\n+\n+\t\tt.Errorf(\"%q != %q (see %q)\", in, out, in+\".got\")\n+\t\tif err := ioutil.WriteFile(in+\".got\", got, 0666); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tt.Log(\"Output ok\")\n+\n+\t// Test if the writer produces the same output after reset.\n+\tbuf.Reset()\n+\tbw.reset(&buf)\n+\tbw.writeBlockHuff(false, all)\n+\tbw.flush()\n+\tgot = buf.Bytes()\n+\tif !bytes.Equal(got, want) {\n+\t\tt.Errorf(\"after reset %q != %q (see %q)\", in, out, in+\".reset.got\")\n+\t\tif err := ioutil.WriteFile(in+\".reset.got\", got, 0666); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tt.Log(\"Reset ok\")\n+\ttestWriterEOF(t, \"huff\", huffTest{input: in}, true)\n+}\n+\n+type huffTest struct {\n+\ttokens      []token\n+\tinput       string // File name of input data matching the tokens.\n+\twant        string // File name of data with the expected output with input available.\n+\twantNoInput string // File name of the expected output when no input is available.\n+}\n+\n+const ml = 0x7fc00000 // Maximum length token. Used to reduce the size of writeBlockTests\n+\n+var writeBlockTests = []huffTest{\n+\t{\n+\t\tinput:       \"testdata/huffman-null-max.in\",\n+\t\twant:        \"testdata/huffman-null-max.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-null-max.%s.expect-noinput\",\n+\t\ttokens:      []token{0x0, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, 0x0, 0x0},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-pi.in\",\n+\t\twant:        \"testdata/huffman-pi.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-pi.%s.expect-noinput\",\n+\t\ttokens:      []token{0x33, 0x2e, 0x31, 0x34, 0x31, 0x35, 0x39, 0x32, 0x36, 0x35, 0x33, 0x35, 0x38, 0x39, 0x37, 0x39, 0x33, 0x32, 0x33, 0x38, 0x34, 0x36, 0x32, 0x36, 0x34, 0x33, 0x33, 0x38, 0x33, 0x32, 0x37, 0x39, 0x35, 0x30, 0x32, 0x38, 0x38, 0x34, 0x31, 0x39, 0x37, 0x31, 0x36, 0x39, 0x33, 0x39, 0x39, 0x33, 0x37, 0x35, 0x31, 0x30, 0x35, 0x38, 0x32, 0x30, 0x39, 0x37, 0x34, 0x39, 0x34, 0x34, 0x35, 0x39, 0x32, 0x33, 0x30, 0x37, 0x38, 0x31, 0x36, 0x34, 0x30, 0x36, 0x32, 0x38, 0x36, 0x32, 0x30, 0x38, 0x39, 0x39, 0x38, 0x36, 0x32, 0x38, 0x30, 0x33, 0x34, 0x38, 0x32, 0x35, 0x33, 0x34, 0x32, 0x31, 0x31, 0x37, 0x30, 0x36, 0x37, 0x39, 0x38, 0x32, 0x31, 0x34, 0x38, 0x30, 0x38, 0x36, 0x35, 0x31, 0x33, 0x32, 0x38, 0x32, 0x33, 0x30, 0x36, 0x36, 0x34, 0x37, 0x30, 0x39, 0x33, 0x38, 0x34, 0x34, 0x36, 0x30, 0x39, 0x35, 0x35, 0x30, 0x35, 0x38, 0x32, 0x32, 0x33, 0x31, 0x37, 0x32, 0x35, 0x33, 0x35, 0x39, 0x34, 0x30, 0x38, 0x31, 0x32, 0x38, 0x34, 0x38, 0x31, 0x31, 0x31, 0x37, 0x34, 0x4040007e, 0x34, 0x31, 0x30, 0x32, 0x37, 0x30, 0x31, 0x39, 0x33, 0x38, 0x35, 0x32, 0x31, 0x31, 0x30, 0x35, 0x35, 0x35, 0x39, 0x36, 0x34, 0x34, 0x36, 0x32, 0x32, 0x39, 0x34, 0x38, 0x39, 0x35, 0x34, 0x39, 0x33, 0x30, 0x33, 0x38, 0x31, 0x40400012, 0x32, 0x38, 0x38, 0x31, 0x30, 0x39, 0x37, 0x35, 0x36, 0x36, 0x35, 0x39, 0x33, 0x33, 0x34, 0x34, 0x36, 0x40400047, 0x37, 0x35, 0x36, 0x34, 0x38, 0x32, 0x33, 0x33, 0x37, 0x38, 0x36, 0x37, 0x38, 0x33, 0x31, 0x36, 0x35, 0x32, 0x37, 0x31, 0x32, 0x30, 0x31, 0x39, 0x30, 0x39, 0x31, 0x34, 0x4040001a, 0x35, 0x36, 0x36, 0x39, 0x32, 0x33, 0x34, 0x36, 0x404000b2, 0x36, 0x31, 0x30, 0x34, 0x35, 0x34, 0x33, 0x32, 0x36, 0x40400032, 0x31, 0x33, 0x33, 0x39, 0x33, 0x36, 0x30, 0x37, 0x32, 0x36, 0x30, 0x32, 0x34, 0x39, 0x31, 0x34, 0x31, 0x32, 0x37, 0x33, 0x37, 0x32, 0x34, 0x35, 0x38, 0x37, 0x30, 0x30, 0x36, 0x36, 0x30, 0x36, 0x33, 0x31, 0x35, 0x35, 0x38, 0x38, 0x31, 0x37, 0x34, 0x38, 0x38, 0x31, 0x35, 0x32, 0x30, 0x39, 0x32, 0x30, 0x39, 0x36, 0x32, 0x38, 0x32, 0x39, 0x32, 0x35, 0x34, 0x30, 0x39, 0x31, 0x37, 0x31, 0x35, 0x33, 0x36, 0x34, 0x33, 0x36, 0x37, 0x38, 0x39, 0x32, 0x35, 0x39, 0x30, 0x33, 0x36, 0x30, 0x30, 0x31, 0x31, 0x33, 0x33, 0x30, 0x35, 0x33, 0x30, 0x35, 0x34, 0x38, 0x38, 0x32, 0x30, 0x34, 0x36, 0x36, 0x35, 0x32, 0x31, 0x33, 0x38, 0x34, 0x31, 0x34, 0x36, 0x39, 0x35, 0x31, 0x39, 0x34, 0x31, 0x35, 0x31, 0x31, 0x36, 0x30, 0x39, 0x34, 0x33, 0x33, 0x30, 0x35, 0x37, 0x32, 0x37, 0x30, 0x33, 0x36, 0x35, 0x37, 0x35, 0x39, 0x35, 0x39, 0x31, 0x39, 0x35, 0x33, 0x30, 0x39, 0x32, 0x31, 0x38, 0x36, 0x31, 0x31, 0x37, 0x404000e9, 0x33, 0x32, 0x40400009, 0x39, 0x33, 0x31, 0x30, 0x35, 0x31, 0x31, 0x38, 0x35, 0x34, 0x38, 0x30, 0x37, 0x4040010e, 0x33, 0x37, 0x39, 0x39, 0x36, 0x32, 0x37, 0x34, 0x39, 0x35, 0x36, 0x37, 0x33, 0x35, 0x31, 0x38, 0x38, 0x35, 0x37, 0x35, 0x32, 0x37, 0x32, 0x34, 0x38, 0x39, 0x31, 0x32, 0x32, 0x37, 0x39, 0x33, 0x38, 0x31, 0x38, 0x33, 0x30, 0x31, 0x31, 0x39, 0x34, 0x39, 0x31, 0x32, 0x39, 0x38, 0x33, 0x33, 0x36, 0x37, 0x33, 0x33, 0x36, 0x32, 0x34, 0x34, 0x30, 0x36, 0x35, 0x36, 0x36, 0x34, 0x33, 0x30, 0x38, 0x36, 0x30, 0x32, 0x31, 0x33, 0x39, 0x34, 0x39, 0x34, 0x36, 0x33, 0x39, 0x35, 0x32, 0x32, 0x34, 0x37, 0x33, 0x37, 0x31, 0x39, 0x30, 0x37, 0x30, 0x32, 0x31, 0x37, 0x39, 0x38, 0x40800099, 0x37, 0x30, 0x32, 0x37, 0x37, 0x30, 0x35, 0x33, 0x39, 0x32, 0x31, 0x37, 0x31, 0x37, 0x36, 0x32, 0x39, 0x33, 0x31, 0x37, 0x36, 0x37, 0x35, 0x40800232, 0x37, 0x34, 0x38, 0x31, 0x40400006, 0x36, 0x36, 0x39, 0x34, 0x30, 0x404001e7, 0x30, 0x30, 0x30, 0x35, 0x36, 0x38, 0x31, 0x32, 0x37, 0x31, 0x34, 0x35, 0x32, 0x36, 0x33, 0x35, 0x36, 0x30, 0x38, 0x32, 0x37, 0x37, 0x38, 0x35, 0x37, 0x37, 0x31, 0x33, 0x34, 0x32, 0x37, 0x35, 0x37, 0x37, 0x38, 0x39, 0x36, 0x40400129, 0x33, 0x36, 0x33, 0x37, 0x31, 0x37, 0x38, 0x37, 0x32, 0x31, 0x34, 0x36, 0x38, 0x34, 0x34, 0x30, 0x39, 0x30, 0x31, 0x32, 0x32, 0x34, 0x39, 0x35, 0x33, 0x34, 0x33, 0x30, 0x31, 0x34, 0x36, 0x35, 0x34, 0x39, 0x35, 0x38, 0x35, 0x33, 0x37, 0x31, 0x30, 0x35, 0x30, 0x37, 0x39, 0x404000ca, 0x36, 0x40400153, 0x38, 0x39, 0x32, 0x33, 0x35, 0x34, 0x404001c9, 0x39, 0x35, 0x36, 0x31, 0x31, 0x32, 0x31, 0x32, 0x39, 0x30, 0x32, 0x31, 0x39, 0x36, 0x30, 0x38, 0x36, 0x34, 0x30, 0x33, 0x34, 0x34, 0x31, 0x38, 0x31, 0x35, 0x39, 0x38, 0x31, 0x33, 0x36, 0x32, 0x39, 0x37, 0x37, 0x34, 0x40400074, 0x30, 0x39, 0x39, 0x36, 0x30, 0x35, 0x31, 0x38, 0x37, 0x30, 0x37, 0x32, 0x31, 0x31, 0x33, 0x34, 0x39, 0x40800000, 0x38, 0x33, 0x37, 0x32, 0x39, 0x37, 0x38, 0x30, 0x34, 0x39, 0x39, 0x404002da, 0x39, 0x37, 0x33, 0x31, 0x37, 0x33, 0x32, 0x38, 0x4040018a, 0x36, 0x33, 0x31, 0x38, 0x35, 0x40400301, 0x404002e8, 0x34, 0x35, 0x35, 0x33, 0x34, 0x36, 0x39, 0x30, 0x38, 0x33, 0x30, 0x32, 0x36, 0x34, 0x32, 0x35, 0x32, 0x32, 0x33, 0x30, 0x404002e3, 0x40400267, 0x38, 0x35, 0x30, 0x33, 0x35, 0x32, 0x36, 0x31, 0x39, 0x33, 0x31, 0x31, 0x40400212, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x33, 0x31, 0x33, 0x37, 0x38, 0x33, 0x38, 0x37, 0x35, 0x32, 0x38, 0x38, 0x36, 0x35, 0x38, 0x37, 0x35, 0x33, 0x33, 0x32, 0x30, 0x38, 0x33, 0x38, 0x31, 0x34, 0x32, 0x30, 0x36, 0x40400140, 0x4040012b, 0x31, 0x34, 0x37, 0x33, 0x30, 0x33, 0x35, 0x39, 0x4080032e, 0x39, 0x30, 0x34, 0x32, 0x38, 0x37, 0x35, 0x35, 0x34, 0x36, 0x38, 0x37, 0x33, 0x31, 0x31, 0x35, 0x39, 0x35, 0x40400355, 0x33, 0x38, 0x38, 0x32, 0x33, 0x35, 0x33, 0x37, 0x38, 0x37, 0x35, 0x4080037f, 0x39, 0x4040013a, 0x31, 0x40400148, 0x38, 0x30, 0x35, 0x33, 0x4040018a, 0x32, 0x32, 0x36, 0x38, 0x30, 0x36, 0x36, 0x31, 0x33, 0x30, 0x30, 0x31, 0x39, 0x32, 0x37, 0x38, 0x37, 0x36, 0x36, 0x31, 0x31, 0x31, 0x39, 0x35, 0x39, 0x40400237, 0x36, 0x40800124, 0x38, 0x39, 0x33, 0x38, 0x30, 0x39, 0x35, 0x32, 0x35, 0x37, 0x32, 0x30, 0x31, 0x30, 0x36, 0x35, 0x34, 0x38, 0x35, 0x38, 0x36, 0x33, 0x32, 0x37, 0x4040009a, 0x39, 0x33, 0x36, 0x31, 0x35, 0x33, 0x40400220, 0x4080015c, 0x32, 0x33, 0x30, 0x33, 0x30, 0x31, 0x39, 0x35, 0x32, 0x30, 0x33, 0x35, 0x33, 0x30, 0x31, 0x38, 0x35, 0x32, 0x40400171, 0x40400075, 0x33, 0x36, 0x32, 0x32, 0x35, 0x39, 0x39, 0x34, 0x31, 0x33, 0x40400254, 0x34, 0x39, 0x37, 0x32, 0x31, 0x37, 0x404000de, 0x33, 0x34, 0x37, 0x39, 0x31, 0x33, 0x31, 0x35, 0x31, 0x35, 0x35, 0x37, 0x34, 0x38, 0x35, 0x37, 0x32, 0x34, 0x32, 0x34, 0x35, 0x34, 0x31, 0x35, 0x30, 0x36, 0x39, 0x4040013f, 0x38, 0x32, 0x39, 0x35, 0x33, 0x33, 0x31, 0x31, 0x36, 0x38, 0x36, 0x31, 0x37, 0x32, 0x37, 0x38, 0x40400337, 0x39, 0x30, 0x37, 0x35, 0x30, 0x39, 0x4040010d, 0x37, 0x35, 0x34, 0x36, 0x33, 0x37, 0x34, 0x36, 0x34, 0x39, 0x33, 0x39, 0x33, 0x31, 0x39, 0x32, 0x35, 0x35, 0x30, 0x36, 0x30, 0x34, 0x30, 0x30, 0x39, 0x4040026b, 0x31, 0x36, 0x37, 0x31, 0x31, 0x33, 0x39, 0x30, 0x30, 0x39, 0x38, 0x40400335, 0x34, 0x30, 0x31, 0x32, 0x38, 0x35, 0x38, 0x33, 0x36, 0x31, 0x36, 0x30, 0x33, 0x35, 0x36, 0x33, 0x37, 0x30, 0x37, 0x36, 0x36, 0x30, 0x31, 0x30, 0x34, 0x40400172, 0x38, 0x31, 0x39, 0x34, 0x32, 0x39, 0x4080041e, 0x404000ef, 0x4040028b, 0x37, 0x38, 0x33, 0x37, 0x34, 0x404004a8, 0x38, 0x32, 0x35, 0x35, 0x33, 0x37, 0x40800209, 0x32, 0x36, 0x38, 0x4040002e, 0x34, 0x30, 0x34, 0x37, 0x404001d1, 0x34, 0x404004b5, 0x4040038d, 0x38, 0x34, 0x404003a8, 0x36, 0x40c0031f, 0x33, 0x33, 0x31, 0x33, 0x36, 0x37, 0x37, 0x30, 0x32, 0x38, 0x39, 0x38, 0x39, 0x31, 0x35, 0x32, 0x40400062, 0x35, 0x32, 0x31, 0x36, 0x32, 0x30, 0x35, 0x36, 0x39, 0x36, 0x40400411, 0x30, 0x35, 0x38, 0x40400477, 0x35, 0x40400498, 0x35, 0x31, 0x31, 0x40400209, 0x38, 0x32, 0x34, 0x33, 0x30, 0x30, 0x33, 0x35, 0x35, 0x38, 0x37, 0x36, 0x34, 0x30, 0x32, 0x34, 0x37, 0x34, 0x39, 0x36, 0x34, 0x37, 0x33, 0x32, 0x36, 0x33, 0x4040043e, 0x39, 0x39, 0x32, 0x4040044b, 0x34, 0x32, 0x36, 0x39, 0x40c002c5, 0x37, 0x404001d6, 0x34, 0x4040053d, 0x4040041d, 0x39, 0x33, 0x34, 0x31, 0x37, 0x404001ad, 0x31, 0x32, 0x4040002a, 0x34, 0x4040019e, 0x31, 0x35, 0x30, 0x33, 0x30, 0x32, 0x38, 0x36, 0x31, 0x38, 0x32, 0x39, 0x37, 0x34, 0x35, 0x35, 0x35, 0x37, 0x30, 0x36, 0x37, 0x34, 0x40400135, 0x35, 0x30, 0x35, 0x34, 0x39, 0x34, 0x35, 0x38, 0x404001c5, 0x39, 0x40400051, 0x35, 0x36, 0x404001ec, 0x37, 0x32, 0x31, 0x30, 0x37, 0x39, 0x40400159, 0x33, 0x30, 0x4040010a, 0x33, 0x32, 0x31, 0x31, 0x36, 0x35, 0x33, 0x34, 0x34, 0x39, 0x38, 0x37, 0x32, 0x30, 0x32, 0x37, 0x4040011b, 0x30, 0x32, 0x33, 0x36, 0x34, 0x4040022e, 0x35, 0x34, 0x39, 0x39, 0x31, 0x31, 0x39, 0x38, 0x40400418, 0x34, 0x4040011b, 0x35, 0x33, 0x35, 0x36, 0x36, 0x33, 0x36, 0x39, 0x40400450, 0x32, 0x36, 0x35, 0x404002e4, 0x37, 0x38, 0x36, 0x32, 0x35, 0x35, 0x31, 0x404003da, 0x31, 0x37, 0x35, 0x37, 0x34, 0x36, 0x37, 0x32, 0x38, 0x39, 0x30, 0x39, 0x37, 0x37, 0x37, 0x37, 0x40800453, 0x30, 0x30, 0x30, 0x404005fd, 0x37, 0x30, 0x404004df, 0x36, 0x404003e9, 0x34, 0x39, 0x31, 0x4040041e, 0x40400297, 0x32, 0x31, 0x34, 0x37, 0x37, 0x32, 0x33, 0x35, 0x30, 0x31, 0x34, 0x31, 0x34, 0x40400643, 0x33, 0x35, 0x36, 0x404004af, 0x31, 0x36, 0x31, 0x33, 0x36, 0x31, 0x31, 0x35, 0x37, 0x33, 0x35, 0x32, 0x35, 0x40400504, 0x33, 0x34, 0x4040005b, 0x31, 0x38, 0x4040047b, 0x38, 0x34, 0x404005e7, 0x33, 0x33, 0x32, 0x33, 0x39, 0x30, 0x37, 0x33, 0x39, 0x34, 0x31, 0x34, 0x33, 0x33, 0x33, 0x34, 0x35, 0x34, 0x37, 0x37, 0x36, 0x32, 0x34, 0x40400242, 0x32, 0x35, 0x31, 0x38, 0x39, 0x38, 0x33, 0x35, 0x36, 0x39, 0x34, 0x38, 0x35, 0x35, 0x36, 0x32, 0x30, 0x39, 0x39, 0x32, 0x31, 0x39, 0x32, 0x32, 0x32, 0x31, 0x38, 0x34, 0x32, 0x37, 0x4040023e, 0x32, 0x404000ba, 0x36, 0x38, 0x38, 0x37, 0x36, 0x37, 0x31, 0x37, 0x39, 0x30, 0x40400055, 0x30, 0x40800106, 0x36, 0x36, 0x404003e7, 0x38, 0x38, 0x36, 0x32, 0x37, 0x32, 0x404006dc, 0x31, 0x37, 0x38, 0x36, 0x30, 0x38, 0x35, 0x37, 0x40400073, 0x33, 0x408002fc, 0x37, 0x39, 0x37, 0x36, 0x36, 0x38, 0x31, 0x404002bd, 0x30, 0x30, 0x39, 0x35, 0x33, 0x38, 0x38, 0x40400638, 0x33, 0x404006a5, 0x30, 0x36, 0x38, 0x30, 0x30, 0x36, 0x34, 0x32, 0x32, 0x35, 0x31, 0x32, 0x35, 0x32, 0x4040057b, 0x37, 0x33, 0x39, 0x32, 0x40400297, 0x40400474, 0x34, 0x408006b3, 0x38, 0x36, 0x32, 0x36, 0x39, 0x34, 0x35, 0x404001e5, 0x34, 0x31, 0x39, 0x36, 0x35, 0x32, 0x38, 0x35, 0x30, 0x40400099, 0x4040039c, 0x31, 0x38, 0x36, 0x33, 0x404001be, 0x34, 0x40800154, 0x32, 0x30, 0x33, 0x39, 0x4040058b, 0x34, 0x35, 0x404002bc, 0x32, 0x33, 0x37, 0x4040042c, 0x36, 0x40400510, 0x35, 0x36, 0x40400638, 0x37, 0x31, 0x39, 0x31, 0x37, 0x32, 0x38, 0x40400171, 0x37, 0x36, 0x34, 0x36, 0x35, 0x37, 0x35, 0x37, 0x33, 0x39, 0x40400101, 0x33, 0x38, 0x39, 0x40400748, 0x38, 0x33, 0x32, 0x36, 0x34, 0x35, 0x39, 0x39, 0x35, 0x38, 0x404006a7, 0x30, 0x34, 0x37, 0x38, 0x404001de, 0x40400328, 0x39, 0x4040002d, 0x36, 0x34, 0x30, 0x37, 0x38, 0x39, 0x35, 0x31, 0x4040008e, 0x36, 0x38, 0x33, 0x4040012f, 0x32, 0x35, 0x39, 0x35, 0x37, 0x30, 0x40400468, 0x38, 0x32, 0x32, 0x404002c8, 0x32, 0x4040061b, 0x34, 0x30, 0x37, 0x37, 0x32, 0x36, 0x37, 0x31, 0x39, 0x34, 0x37, 0x38, 0x40400319, 0x38, 0x32, 0x36, 0x30, 0x31, 0x34, 0x37, 0x36, 0x39, 0x39, 0x30, 0x39, 0x404004e8, 0x30, 0x31, 0x33, 0x36, 0x33, 0x39, 0x34, 0x34, 0x33, 0x4040027f, 0x33, 0x30, 0x40400105, 0x32, 0x30, 0x33, 0x34, 0x39, 0x36, 0x32, 0x35, 0x32, 0x34, 0x35, 0x31, 0x37, 0x404003b5, 0x39, 0x36, 0x35, 0x31, 0x34, 0x33, 0x31, 0x34, 0x32, 0x39, 0x38, 0x30, 0x39, 0x31, 0x39, 0x30, 0x36, 0x35, 0x39, 0x32, 0x40400282, 0x37, 0x32, 0x32, 0x31, 0x36, 0x39, 0x36, 0x34, 0x36, 0x40400419, 0x4040007a, 0x35, 0x4040050e, 0x34, 0x40800565, 0x38, 0x40400559, 0x39, 0x37, 0x4040057b, 0x35, 0x34, 0x4040049d, 0x4040023e, 0x37, 0x4040065a, 0x38, 0x34, 0x36, 0x38, 0x31, 0x33, 0x4040008c, 0x36, 0x38, 0x33, 0x38, 0x36, 0x38, 0x39, 0x34, 0x32, 0x37, 0x37, 0x34, 0x31, 0x35, 0x35, 0x39, 0x39, 0x31, 0x38, 0x35, 0x4040005a, 0x32, 0x34, 0x35, 0x39, 0x35, 0x33, 0x39, 0x35, 0x39, 0x34, 0x33, 0x31, 0x404005b7, 0x37, 0x40400012, 0x36, 0x38, 0x30, 0x38, 0x34, 0x35, 0x404002e7, 0x37, 0x33, 0x4040081e, 0x39, 0x35, 0x38, 0x34, 0x38, 0x36, 0x35, 0x33, 0x38, 0x404006e8, 0x36, 0x32, 0x404000f2, 0x36, 0x30, 0x39, 0x404004b6, 0x36, 0x30, 0x38, 0x30, 0x35, 0x31, 0x32, 0x34, 0x33, 0x38, 0x38, 0x34, 0x4040013a, 0x4040000b, 0x34, 0x31, 0x33, 0x4040030f, 0x37, 0x36, 0x32, 0x37, 0x38, 0x40400341, 0x37, 0x31, 0x35, 0x4040059b, 0x33, 0x35, 0x39, 0x39, 0x37, 0x37, 0x30, 0x30, 0x31, 0x32, 0x39, 0x40400472, 0x38, 0x39, 0x34, 0x34, 0x31, 0x40400277, 0x36, 0x38, 0x35, 0x35, 0x4040005f, 0x34, 0x30, 0x36, 0x33, 0x404008e6, 0x32, 0x30, 0x37, 0x32, 0x32, 0x40400158, 0x40800203, 0x34, 0x38, 0x31, 0x35, 0x38, 0x40400205, 0x404001fe, 0x4040027a, 0x40400298, 0x33, 0x39, 0x34, 0x35, 0x32, 0x32, 0x36, 0x37, 0x40c00496, 0x38, 0x4040058a, 0x32, 0x31, 0x404002ea, 0x32, 0x40400387, 0x35, 0x34, 0x36, 0x36, 0x36, 0x4040051b, 0x32, 0x33, 0x39, 0x38, 0x36, 0x34, 0x35, 0x36, 0x404004c4, 0x31, 0x36, 0x33, 0x35, 0x40800253, 0x40400811, 0x37, 0x404008ad, 0x39, 0x38, 0x4040045e, 0x39, 0x33, 0x36, 0x33, 0x34, 0x4040075b, 0x37, 0x34, 0x33, 0x32, 0x34, 0x4040047b, 0x31, 0x35, 0x30, 0x37, 0x36, 0x404004bb, 0x37, 0x39, 0x34, 0x35, 0x31, 0x30, 0x39, 0x4040003e, 0x30, 0x39, 0x34, 0x30, 0x404006a6, 0x38, 0x38, 0x37, 0x39, 0x37, 0x31, 0x30, 0x38, 0x39, 0x33, 0x404008f0, 0x36, 0x39, 0x31, 0x33, 0x36, 0x38, 0x36, 0x37, 0x32, 0x4040025b, 0x404001fe, 0x35, 0x4040053f, 0x40400468, 0x40400801, 0x31, 0x37, 0x39, 0x32, 0x38, 0x36, 0x38, 0x404008cc, 0x38, 0x37, 0x34, 0x37, 0x4080079e, 0x38, 0x32, 0x34, 0x4040097a, 0x38, 0x4040025b, 0x37, 0x31, 0x34, 0x39, 0x30, 0x39, 0x36, 0x37, 0x35, 0x39, 0x38, 0x404006ef, 0x33, 0x36, 0x35, 0x40400134, 0x38, 0x31, 0x4040005c, 0x40400745, 0x40400936, 0x36, 0x38, 0x32, 0x39, 0x4040057e, 0x38, 0x37, 0x32, 0x32, 0x36, 0x35, 0x38, 0x38, 0x30, 0x40400611, 0x35, 0x40400249, 0x34, 0x32, 0x37, 0x30, 0x34, 0x37, 0x37, 0x35, 0x35, 0x4040081e, 0x33, 0x37, 0x39, 0x36, 0x34, 0x31, 0x34, 0x35, 0x31, 0x35, 0x32, 0x404005fd, 0x32, 0x33, 0x34, 0x33, 0x36, 0x34, 0x35, 0x34, 0x404005de, 0x34, 0x34, 0x34, 0x37, 0x39, 0x35, 0x4040003c, 0x40400523, 0x408008e6, 0x34, 0x31, 0x4040052a, 0x33, 0x40400304, 0x35, 0x32, 0x33, 0x31, 0x40800841, 0x31, 0x36, 0x36, 0x31, 0x404008b2, 0x35, 0x39, 0x36, 0x39, 0x35, 0x33, 0x36, 0x32, 0x33, 0x31, 0x34, 0x404005ff, 0x32, 0x34, 0x38, 0x34, 0x39, 0x33, 0x37, 0x31, 0x38, 0x37, 0x31, 0x31, 0x30, 0x31, 0x34, 0x35, 0x37, 0x36, 0x35, 0x34, 0x40400761, 0x30, 0x32, 0x37, 0x39, 0x39, 0x33, 0x34, 0x34, 0x30, 0x33, 0x37, 0x34, 0x32, 0x30, 0x30, 0x37, 0x4040093f, 0x37, 0x38, 0x35, 0x33, 0x39, 0x30, 0x36, 0x32, 0x31, 0x39, 0x40800299, 0x40400345, 0x38, 0x34, 0x37, 0x408003d2, 0x38, 0x33, 0x33, 0x32, 0x31, 0x34, 0x34, 0x35, 0x37, 0x31, 0x40400284, 0x40400776, 0x34, 0x33, 0x35, 0x30, 0x40400928, 0x40400468, 0x35, 0x33, 0x31, 0x39, 0x31, 0x30, 0x34, 0x38, 0x34, 0x38, 0x31, 0x30, 0x30, 0x35, 0x33, 0x37, 0x30, 0x36, 0x404008bc, 0x4080059d, 0x40800781, 0x31, 0x40400559, 0x37, 0x4040031b, 0x35, 0x404007ec, 0x4040040c, 0x36, 0x33, 0x408007dc, 0x34, 0x40400971, 0x4080034e, 0x408003f5, 0x38, 0x4080052d, 0x40800887, 0x39, 0x40400187, 0x39, 0x31, 0x404008ce, 0x38, 0x31, 0x34, 0x36, 0x37, 0x35, 0x31, 0x4040062b, 0x31, 0x32, 0x33, 0x39, 0x40c001a9, 0x39, 0x30, 0x37, 0x31, 0x38, 0x36, 0x34, 0x39, 0x34, 0x32, 0x33, 0x31, 0x39, 0x36, 0x31, 0x35, 0x36, 0x404001ec, 0x404006bc, 0x39, 0x35, 0x40400926, 0x40400469, 0x4040011b, 0x36, 0x30, 0x33, 0x38, 0x40400a25, 0x4040016f, 0x40400384, 0x36, 0x32, 0x4040045a, 0x35, 0x4040084c, 0x36, 0x33, 0x38, 0x39, 0x33, 0x37, 0x37, 0x38, 0x37, 0x404008c5, 0x404000f8, 0x39, 0x37, 0x39, 0x32, 0x30, 0x37, 0x37, 0x33, 0x404005d7, 0x32, 0x31, 0x38, 0x32, 0x35, 0x36, 0x404007df, 0x36, 0x36, 0x404006d6, 0x34, 0x32, 0x4080067e, 0x36, 0x404006e6, 0x34, 0x34, 0x40400024, 0x35, 0x34, 0x39, 0x32, 0x30, 0x32, 0x36, 0x30, 0x35, 0x40400ab3, 0x408003e4, 0x32, 0x30, 0x31, 0x34, 0x39, 0x404004d2, 0x38, 0x35, 0x30, 0x37, 0x33, 0x40400599, 0x36, 0x36, 0x36, 0x30, 0x40400194, 0x32, 0x34, 0x33, 0x34, 0x30, 0x40400087, 0x30, 0x4040076b, 0x38, 0x36, 0x33, 0x40400956, 0x404007e4, 0x4040042b, 0x40400174, 0x35, 0x37, 0x39, 0x36, 0x32, 0x36, 0x38, 0x35, 0x36, 0x40400140, 0x35, 0x30, 0x38, 0x40400523, 0x35, 0x38, 0x37, 0x39, 0x36, 0x39, 0x39, 0x40400711, 0x35, 0x37, 0x34, 0x40400a18, 0x38, 0x34, 0x30, 0x404008b3, 0x31, 0x34, 0x35, 0x39, 0x31, 0x4040078c, 0x37, 0x30, 0x40400234, 0x30, 0x31, 0x40400be7, 0x31, 0x32, 0x40400c74, 0x30, 0x404003c3, 0x33, 0x39, 0x40400b2a, 0x40400112, 0x37, 0x31, 0x35, 0x404003b0, 0x34, 0x32, 0x30, 0x40800bf2, 0x39, 0x40400bc2, 0x30, 0x37, 0x40400341, 0x40400795, 0x40400aaf, 0x40400c62, 0x32, 0x31, 0x40400960, 0x32, 0x35, 0x31, 0x4040057b, 0x40400944, 0x39, 0x32, 0x404001b2, 0x38, 0x32, 0x36, 0x40400b66, 0x32, 0x40400278, 0x33, 0x32, 0x31, 0x35, 0x37, 0x39, 0x31, 0x39, 0x38, 0x34, 0x31, 0x34, 0x4080087b, 0x39, 0x31, 0x36, 0x34, 0x408006e8, 0x39, 0x40800b58, 0x404008db, 0x37, 0x32, 0x32, 0x40400321, 0x35, 0x404008a4, 0x40400141, 0x39, 0x31, 0x30, 0x404000bc, 0x40400c5b, 0x35, 0x32, 0x38, 0x30, 0x31, 0x37, 0x40400231, 0x37, 0x31, 0x32, 0x40400914, 0x38, 0x33, 0x32, 0x40400373, 0x31, 0x40400589, 0x30, 0x39, 0x33, 0x35, 0x33, 0x39, 0x36, 0x35, 0x37, 0x4040064b, 0x31, 0x30, 0x38, 0x33, 0x40400069, 0x35, 0x31, 0x4040077a, 0x40400d5a, 0x31, 0x34, 0x34, 0x34, 0x32, 0x31, 0x30, 0x30, 0x40400202, 0x30, 0x33, 0x4040019c, 0x31, 0x31, 0x30, 0x33, 0x40400c81, 0x40400009, 0x40400026, 0x40c00602, 0x35, 0x31, 0x36, 0x404005d9, 0x40800883, 0x4040092a, 0x35, 0x40800c42, 0x38, 0x35, 0x31, 0x37, 0x31, 0x34, 0x33, 0x37, 0x40400605, 0x4040006d, 0x31, 0x35, 0x35, 0x36, 0x35, 0x30, 0x38, 0x38, 0x404003b9, 0x39, 0x38, 0x39, 0x38, 0x35, 0x39, 0x39, 0x38, 0x32, 0x33, 0x38, 0x404001cf, 0x404009ba, 0x33, 0x4040016c, 0x4040043e, 0x404009c3, 0x38, 0x40800e05, 0x33, 0x32, 0x40400107, 0x35, 0x40400305, 0x33, 0x404001ca, 0x39, 0x4040041b, 0x39, 0x38, 0x4040087d, 0x34, 0x40400cb8, 0x37, 0x4040064b, 0x30, 0x37, 0x404000e5, 0x34, 0x38, 0x31, 0x34, 0x31, 0x40400539, 0x38, 0x35, 0x39, 0x34, 0x36, 0x31, 0x40400bc9, 0x38, 0x30},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-rand-1k.in\",\n+\t\twant:        \"testdata/huffman-rand-1k.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-rand-1k.%s.expect-noinput\",\n+\t\ttokens:      []token{0xf8, 0x8b, 0x96, 0x76, 0x48, 0xd, 0x85, 0x94, 0x25, 0x80, 0xaf, 0xc2, 0xfe, 0x8d, 0xe8, 0x20, 0xeb, 0x17, 0x86, 0xc9, 0xb7, 0xc5, 0xde, 0x6, 0xea, 0x7d, 0x18, 0x8b, 0xe7, 0x3e, 0x7, 0xda, 0xdf, 0xff, 0x6c, 0x73, 0xde, 0xcc, 0xe7, 0x6d, 0x8d, 0x4, 0x19, 0x49, 0x7f, 0x47, 0x1f, 0x48, 0x15, 0xb0, 0xe8, 0x9e, 0xf2, 0x31, 0x59, 0xde, 0x34, 0xb4, 0x5b, 0xe5, 0xe0, 0x9, 0x11, 0x30, 0xc2, 0x88, 0x5b, 0x7c, 0x5d, 0x14, 0x13, 0x6f, 0x23, 0xa9, 0xd, 0xbc, 0x2d, 0x23, 0xbe, 0xd9, 0xed, 0x75, 0x4, 0x6c, 0x99, 0xdf, 0xfd, 0x70, 0x66, 0xe6, 0xee, 0xd9, 0xb1, 0x9e, 0x6e, 0x83, 0x59, 0xd5, 0xd4, 0x80, 0x59, 0x98, 0x77, 0x89, 0x43, 0x38, 0xc9, 0xaf, 0x30, 0x32, 0x9a, 0x20, 0x1b, 0x46, 0x3d, 0x67, 0x6e, 0xd7, 0x72, 0x9e, 0x4e, 0x21, 0x4f, 0xc6, 0xe0, 0xd4, 0x7b, 0x4, 0x8d, 0xa5, 0x3, 0xf6, 0x5, 0x9b, 0x6b, 0xdc, 0x2a, 0x93, 0x77, 0x28, 0xfd, 0xb4, 0x62, 0xda, 0x20, 0xe7, 0x1f, 0xab, 0x6b, 0x51, 0x43, 0x39, 0x2f, 0xa0, 0x92, 0x1, 0x6c, 0x75, 0x3e, 0xf4, 0x35, 0xfd, 0x43, 0x2e, 0xf7, 0xa4, 0x75, 0xda, 0xea, 0x9b, 0xa, 0x64, 0xb, 0xe0, 0x23, 0x29, 0xbd, 0xf7, 0xe7, 0x83, 0x3c, 0xfb, 0xdf, 0xb3, 0xae, 0x4f, 0xa4, 0x47, 0x55, 0x99, 0xde, 0x2f, 0x96, 0x6e, 0x1c, 0x43, 0x4c, 0x87, 0xe2, 0x7c, 0xd9, 0x5f, 0x4c, 0x7c, 0xe8, 0x90, 0x3, 0xdb, 0x30, 0x95, 0xd6, 0x22, 0xc, 0x47, 0xb8, 0x4d, 0x6b, 0xbd, 0x24, 0x11, 0xab, 0x2c, 0xd7, 0xbe, 0x6e, 0x7a, 0xd6, 0x8, 0xa3, 0x98, 0xd8, 0xdd, 0x15, 0x6a, 0xfa, 0x93, 0x30, 0x1, 0x25, 0x1d, 0xa2, 0x74, 0x86, 0x4b, 0x6a, 0x95, 0xe8, 0xe1, 0x4e, 0xe, 0x76, 0xb9, 0x49, 0xa9, 0x5f, 0xa0, 0xa6, 0x63, 0x3c, 0x7e, 0x7e, 0x20, 0x13, 0x4f, 0xbb, 0x66, 0x92, 0xb8, 0x2e, 0xa4, 0xfa, 0x48, 0xcb, 0xae, 0xb9, 0x3c, 0xaf, 0xd3, 0x1f, 0xe1, 0xd5, 0x8d, 0x42, 0x6d, 0xf0, 0xfc, 0x8c, 0xc, 0x0, 0xde, 0x40, 0xab, 0x8b, 0x47, 0x97, 0x4e, 0xa8, 0xcf, 0x8e, 0xdb, 0xa6, 0x8b, 0x20, 0x9, 0x84, 0x7a, 0x66, 0xe5, 0x98, 0x29, 0x2, 0x95, 0xe6, 0x38, 0x32, 0x60, 0x3, 0xe3, 0x9a, 0x1e, 0x54, 0xe8, 0x63, 0x80, 0x48, 0x9c, 0xe7, 0x63, 0x33, 0x6e, 0xa0, 0x65, 0x83, 0xfa, 0xc6, 0xba, 0x7a, 0x43, 0x71, 0x5, 0xf5, 0x68, 0x69, 0x85, 0x9c, 0xba, 0x45, 0xcd, 0x6b, 0xb, 0x19, 0xd1, 0xbb, 0x7f, 0x70, 0x85, 0x92, 0xd1, 0xb4, 0x64, 0x82, 0xb1, 0xe4, 0x62, 0xc5, 0x3c, 0x46, 0x1f, 0x92, 0x31, 0x1c, 0x4e, 0x41, 0x77, 0xf7, 0xe7, 0x87, 0xa2, 0xf, 0x6e, 0xe8, 0x92, 0x3, 0x6b, 0xa, 0xe7, 0xa9, 0x3b, 0x11, 0xda, 0x66, 0x8a, 0x29, 0xda, 0x79, 0xe1, 0x64, 0x8d, 0xe3, 0x54, 0xd4, 0xf5, 0xef, 0x64, 0x87, 0x3b, 0xf4, 0xc2, 0xf4, 0x71, 0x13, 0xa9, 0xe9, 0xe0, 0xa2, 0x6, 0x14, 0xab, 0x5d, 0xa7, 0x96, 0x0, 0xd6, 0xc3, 0xcc, 0x57, 0xed, 0x39, 0x6a, 0x25, 0xcd, 0x76, 0xea, 0xba, 0x3a, 0xf2, 0xa1, 0x95, 0x5d, 0xe5, 0x71, 0xcf, 0x9c, 0x62, 0x9e, 0x6a, 0xfa, 0xd5, 0x31, 0xd1, 0xa8, 0x66, 0x30, 0x33, 0xaa, 0x51, 0x17, 0x13, 0x82, 0x99, 0xc8, 0x14, 0x60, 0x9f, 0x4d, 0x32, 0x6d, 0xda, 0x19, 0x26, 0x21, 0xdc, 0x7e, 0x2e, 0x25, 0x67, 0x72, 0xca, 0xf, 0x92, 0xcd, 0xf6, 0xd6, 0xcb, 0x97, 0x8a, 0x33, 0x58, 0x73, 0x70, 0x91, 0x1d, 0xbf, 0x28, 0x23, 0xa3, 0xc, 0xf1, 0x83, 0xc3, 0xc8, 0x56, 0x77, 0x68, 0xe3, 0x82, 0xba, 0xb9, 0x57, 0x56, 0x57, 0x9c, 0xc3, 0xd6, 0x14, 0x5, 0x3c, 0xb1, 0xaf, 0x93, 0xc8, 0x8a, 0x57, 0x7f, 0x53, 0xfa, 0x2f, 0xaa, 0x6e, 0x66, 0x83, 0xfa, 0x33, 0xd1, 0x21, 0xab, 0x1b, 0x71, 0xb4, 0x7c, 0xda, 0xfd, 0xfb, 0x7f, 0x20, 0xab, 0x5e, 0xd5, 0xca, 0xfd, 0xdd, 0xe0, 0xee, 0xda, 0xba, 0xa8, 0x27, 0x99, 0x97, 0x69, 0xc1, 0x3c, 0x82, 0x8c, 0xa, 0x5c, 0x2d, 0x5b, 0x88, 0x3e, 0x34, 0x35, 0x86, 0x37, 0x46, 0x79, 0xe1, 0xaa, 0x19, 0xfb, 0xaa, 0xde, 0x15, 0x9, 0xd, 0x1a, 0x57, 0xff, 0xb5, 0xf, 0xf3, 0x2b, 0x5a, 0x6a, 0x4d, 0x19, 0x77, 0x71, 0x45, 0xdf, 0x4f, 0xb3, 0xec, 0xf1, 0xeb, 0x18, 0x53, 0x3e, 0x3b, 0x47, 0x8, 0x9a, 0x73, 0xa0, 0x5c, 0x8c, 0x5f, 0xeb, 0xf, 0x3a, 0xc2, 0x43, 0x67, 0xb4, 0x66, 0x67, 0x80, 0x58, 0xe, 0xc1, 0xec, 0x40, 0xd4, 0x22, 0x94, 0xca, 0xf9, 0xe8, 0x92, 0xe4, 0x69, 0x38, 0xbe, 0x67, 0x64, 0xca, 0x50, 0xc7, 0x6, 0x67, 0x42, 0x6e, 0xa3, 0xf0, 0xb7, 0x6c, 0xf2, 0xe8, 0x5f, 0xb1, 0xaf, 0xe7, 0xdb, 0xbb, 0x77, 0xb5, 0xf8, 0xcb, 0x8, 0xc4, 0x75, 0x7e, 0xc0, 0xf9, 0x1c, 0x7f, 0x3c, 0x89, 0x2f, 0xd2, 0x58, 0x3a, 0xe2, 0xf8, 0x91, 0xb6, 0x7b, 0x24, 0x27, 0xe9, 0xae, 0x84, 0x8b, 0xde, 0x74, 0xac, 0xfd, 0xd9, 0xb7, 0x69, 0x2a, 0xec, 0x32, 0x6f, 0xf0, 0x92, 0x84, 0xf1, 0x40, 0xc, 0x8a, 0xbc, 0x39, 0x6e, 0x2e, 0x73, 0xd4, 0x6e, 0x8a, 0x74, 0x2a, 0xdc, 0x60, 0x1f, 0xa3, 0x7, 0xde, 0x75, 0x8b, 0x74, 0xc8, 0xfe, 0x63, 0x75, 0xf6, 0x3d, 0x63, 0xac, 0x33, 0x89, 0xc3, 0xf0, 0xf8, 0x2d, 0x6b, 0xb4, 0x9e, 0x74, 0x8b, 0x5c, 0x33, 0xb4, 0xca, 0xa8, 0xe4, 0x99, 0xb6, 0x90, 0xa1, 0xef, 0xf, 0xd3, 0x61, 0xb2, 0xc6, 0x1a, 0x94, 0x7c, 0x44, 0x55, 0xf4, 0x45, 0xff, 0x9e, 0xa5, 0x5a, 0xc6, 0xa0, 0xe8, 0x2a, 0xc1, 0x8d, 0x6f, 0x34, 0x11, 0xb9, 0xbe, 0x4e, 0xd9, 0x87, 0x97, 0x73, 0xcf, 0x3d, 0x23, 0xae, 0xd5, 0x1a, 0x5e, 0xae, 0x5d, 0x6a, 0x3, 0xf9, 0x22, 0xd, 0x10, 0xd9, 0x47, 0x69, 0x15, 0x3f, 0xee, 0x52, 0xa3, 0x8, 0xd2, 0x3c, 0x51, 0xf4, 0xf8, 0x9d, 0xe4, 0x98, 0x89, 0xc8, 0x67, 0x39, 0xd5, 0x5e, 0x35, 0x78, 0x27, 0xe8, 0x3c, 0x80, 0xae, 0x79, 0x71, 0xd2, 0x93, 0xf4, 0xaa, 0x51, 0x12, 0x1c, 0x4b, 0x1b, 0xe5, 0x6e, 0x15, 0x6f, 0xe4, 0xbb, 0x51, 0x9b, 0x45, 0x9f, 0xf9, 0xc4, 0x8c, 0x2a, 0xfb, 0x1a, 0xdf, 0x55, 0xd3, 0x48, 0x93, 0x27, 0x1, 0x26, 0xc2, 0x6b, 0x55, 0x6d, 0xa2, 0xfb, 0x84, 0x8b, 0xc9, 0x9e, 0x28, 0xc2, 0xef, 0x1a, 0x24, 0xec, 0x9b, 0xae, 0xbd, 0x60, 0xe9, 0x15, 0x35, 0xee, 0x42, 0xa4, 0x33, 0x5b, 0xfa, 0xf, 0xb6, 0xf7, 0x1, 0xa6, 0x2, 0x4c, 0xca, 0x90, 0x58, 0x3a, 0x96, 0x41, 0xe7, 0xcb, 0x9, 0x8c, 0xdb, 0x85, 0x4d, 0xa8, 0x89, 0xf3, 0xb5, 0x8e, 0xfd, 0x75, 0x5b, 0x4f, 0xed, 0xde, 0x3f, 0xeb, 0x38, 0xa3, 0xbe, 0xb0, 0x73, 0xfc, 0xb8, 0x54, 0xf7, 0x4c, 0x30, 0x67, 0x2e, 0x38, 0xa2, 0x54, 0x18, 0xba, 0x8, 0xbf, 0xf2, 0x39, 0xd5, 0xfe, 0xa5, 0x41, 0xc6, 0x66, 0x66, 0xba, 0x81, 0xef, 0x67, 0xe4, 0xe6, 0x3c, 0xc, 0xca, 0xa4, 0xa, 0x79, 0xb3, 0x57, 0x8b, 0x8a, 0x75, 0x98, 0x18, 0x42, 0x2f, 0x29, 0xa3, 0x82, 0xef, 0x9f, 0x86, 0x6, 0x23, 0xe1, 0x75, 0xfa, 0x8, 0xb1, 0xde, 0x17, 0x4a},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-rand-limit.in\",\n+\t\twant:        \"testdata/huffman-rand-limit.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-rand-limit.%s.expect-noinput\",\n+\t\ttokens:      []token{0x61, 0x51c00000, 0xa, 0xf8, 0x8b, 0x96, 0x76, 0x48, 0xa, 0x85, 0x94, 0x25, 0x80, 0xaf, 0xc2, 0xfe, 0x8d, 0xe8, 0x20, 0xeb, 0x17, 0x86, 0xc9, 0xb7, 0xc5, 0xde, 0x6, 0xea, 0x7d, 0x18, 0x8b, 0xe7, 0x3e, 0x7, 0xda, 0xdf, 0xff, 0x6c, 0x73, 0xde, 0xcc, 0xe7, 0x6d, 0x8d, 0x4, 0x19, 0x49, 0x7f, 0x47, 0x1f, 0x48, 0x15, 0xb0, 0xe8, 0x9e, 0xf2, 0x31, 0x59, 0xde, 0x34, 0xb4, 0x5b, 0xe5, 0xe0, 0x9, 0x11, 0x30, 0xc2, 0x88, 0x5b, 0x7c, 0x5d, 0x14, 0x13, 0x6f, 0x23, 0xa9, 0xa, 0xbc, 0x2d, 0x23, 0xbe, 0xd9, 0xed, 0x75, 0x4, 0x6c, 0x99, 0xdf, 0xfd, 0x70, 0x66, 0xe6, 0xee, 0xd9, 0xb1, 0x9e, 0x6e, 0x83, 0x59, 0xd5, 0xd4, 0x80, 0x59, 0x98, 0x77, 0x89, 0x43, 0x38, 0xc9, 0xaf, 0x30, 0x32, 0x9a, 0x20, 0x1b, 0x46, 0x3d, 0x67, 0x6e, 0xd7, 0x72, 0x9e, 0x4e, 0x21, 0x4f, 0xc6, 0xe0, 0xd4, 0x7b, 0x4, 0x8d, 0xa5, 0x3, 0xf6, 0x5, 0x9b, 0x6b, 0xdc, 0x2a, 0x93, 0x77, 0x28, 0xfd, 0xb4, 0x62, 0xda, 0x20, 0xe7, 0x1f, 0xab, 0x6b, 0x51, 0x43, 0x39, 0x2f, 0xa0, 0x92, 0x1, 0x6c, 0x75, 0x3e, 0xf4, 0x35, 0xfd, 0x43, 0x2e, 0xf7, 0xa4, 0x75, 0xda, 0xea, 0x9b, 0xa},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-shifts.in\",\n+\t\twant:        \"testdata/huffman-shifts.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-shifts.%s.expect-noinput\",\n+\t\ttokens:      []token{0x31, 0x30, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x52400001, 0xd, 0xa, 0x32, 0x33, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7fc00001, 0x7f400001},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-text-shift.in\",\n+\t\twant:        \"testdata/huffman-text-shift.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-text-shift.%s.expect-noinput\",\n+\t\ttokens:      []token{0x2f, 0x2f, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x32, 0x30, 0x30, 0x39, 0x54, 0x68, 0x47, 0x6f, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x2e, 0x41, 0x6c, 0x6c, 0x40800016, 0x72, 0x72, 0x76, 0x64, 0x2e, 0xd, 0xa, 0x2f, 0x2f, 0x55, 0x6f, 0x66, 0x74, 0x68, 0x69, 0x6f, 0x75, 0x72, 0x63, 0x63, 0x6f, 0x64, 0x69, 0x67, 0x6f, 0x76, 0x72, 0x6e, 0x64, 0x62, 0x79, 0x42, 0x53, 0x44, 0x2d, 0x74, 0x79, 0x6c, 0x40400020, 0x6c, 0x69, 0x63, 0x6e, 0x74, 0x68, 0x74, 0x63, 0x6e, 0x62, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x69, 0x6e, 0x74, 0x68, 0x4c, 0x49, 0x43, 0x45, 0x4e, 0x53, 0x45, 0x66, 0x69, 0x6c, 0x2e, 0xd, 0xa, 0xd, 0xa, 0x70, 0x63, 0x6b, 0x67, 0x6d, 0x69, 0x6e, 0x4040000a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x22, 0x6f, 0x22, 0x4040000c, 0x66, 0x75, 0x6e, 0x63, 0x6d, 0x69, 0x6e, 0x28, 0x29, 0x7b, 0xd, 0xa, 0x9, 0x76, 0x72, 0x62, 0x3d, 0x6d, 0x6b, 0x28, 0x5b, 0x5d, 0x62, 0x79, 0x74, 0x2c, 0x36, 0x35, 0x35, 0x33, 0x35, 0x29, 0xd, 0xa, 0x9, 0x66, 0x2c, 0x5f, 0x3a, 0x3d, 0x6f, 0x2e, 0x43, 0x72, 0x74, 0x28, 0x22, 0x68, 0x75, 0x66, 0x66, 0x6d, 0x6e, 0x2d, 0x6e, 0x75, 0x6c, 0x6c, 0x2d, 0x6d, 0x78, 0x2e, 0x69, 0x6e, 0x22, 0x40800021, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x28, 0x62, 0x29, 0xd, 0xa, 0x7d, 0xd, 0xa, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x58, 0x78, 0x79, 0x7a, 0x21, 0x22, 0x23, 0xc2, 0xa4, 0x25, 0x26, 0x2f, 0x3f, 0x22},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-text.in\",\n+\t\twant:        \"testdata/huffman-text.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-text.%s.expect-noinput\",\n+\t\ttokens:      []token{0x2f, 0x2f, 0x20, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30, 0x30, 0x39, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x6f, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x4080001e, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0xd, 0xa, 0x2f, 0x2f, 0x20, 0x55, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x6f, 0x76, 0x65, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x42, 0x53, 0x44, 0x2d, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x40800036, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4c, 0x49, 0x43, 0x45, 0x4e, 0x53, 0x45, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0xd, 0xa, 0xd, 0xa, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x4040000f, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x22, 0x6f, 0x73, 0x22, 0x4040000e, 0x66, 0x75, 0x6e, 0x63, 0x4080001b, 0x28, 0x29, 0x20, 0x7b, 0xd, 0xa, 0x9, 0x76, 0x61, 0x72, 0x20, 0x62, 0x20, 0x3d, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x28, 0x5b, 0x5d, 0x62, 0x79, 0x74, 0x65, 0x2c, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x29, 0xd, 0xa, 0x9, 0x66, 0x2c, 0x20, 0x5f, 0x20, 0x3a, 0x3d, 0x20, 0x6f, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x28, 0x22, 0x68, 0x75, 0x66, 0x66, 0x6d, 0x61, 0x6e, 0x2d, 0x6e, 0x75, 0x6c, 0x6c, 0x2d, 0x6d, 0x61, 0x78, 0x2e, 0x69, 0x6e, 0x22, 0x4080002a, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x28, 0x62, 0x29, 0xd, 0xa, 0x7d, 0xd, 0xa},\n+\t},\n+\t{\n+\t\tinput:       \"testdata/huffman-zero.in\",\n+\t\twant:        \"testdata/huffman-zero.%s.expect\",\n+\t\twantNoInput: \"testdata/huffman-zero.%s.expect-noinput\",\n+\t\ttokens:      []token{0x30, ml, 0x4b800000},\n+\t},\n+\t{\n+\t\tinput:       \"\",\n+\t\twant:        \"\",\n+\t\twantNoInput: \"testdata/null-long-match.%s.expect-noinput\",\n+\t\ttokens:      []token{0x0, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, ml, 0x41400000},\n+\t},\n+}\n+\n+// TestWriteBlock tests if the writeBlock encoding has changed.\n+// To update the reference files use the \"-update\" flag on the test.\n+func TestWriteBlock(t *testing.T) {\n+\tfor _, test := range writeBlockTests {\n+\t\ttestBlock(t, test, \"wb\")\n+\t}\n+}\n+\n+// TestWriteBlockDynamic tests if the writeBlockDynamic encoding has changed.\n+// To update the reference files use the \"-update\" flag on the test.\n+func TestWriteBlockDynamic(t *testing.T) {\n+\tfor _, test := range writeBlockTests {\n+\t\ttestBlock(t, test, \"dyn\")\n+\t}\n+}\n+\n+// testBlock tests a block against its references,\n+// or regenerate the references, if \"-update\" flag is set.\n+func testBlock(t *testing.T, test huffTest, ttype string) {\n+\tif test.want != \"\" {\n+\t\ttest.want = fmt.Sprintf(test.want, ttype)\n+\t}\n+\ttest.wantNoInput = fmt.Sprintf(test.wantNoInput, ttype)\n+\tif *update {\n+\t\tif test.input != \"\" {\n+\t\t\tt.Logf(\"Updating %q\", test.want)\n+\t\t\tinput, err := ioutil.ReadFile(test.input)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tf, err := os.Create(test.want)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer f.Close()\n+\t\t\tbw := newHuffmanBitWriter(f)\n+\t\t\twriteToType(t, ttype, bw, test.tokens, input)\n+\t\t}\n+\n+\t\tt.Logf(\"Updating %q\", test.wantNoInput)\n+\t\tf, err := os.Create(test.wantNoInput)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tbw := newHuffmanBitWriter(f)\n+\t\twriteToType(t, ttype, bw, test.tokens, nil)\n+\t\treturn\n+\t}\n+\n+\tif test.input != \"\" {\n+\t\tt.Logf(\"Testing %q\", test.want)\n+\t\tinput, err := ioutil.ReadFile(test.input)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\twant, err := ioutil.ReadFile(test.want)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvar buf bytes.Buffer\n+\t\tbw := newHuffmanBitWriter(&buf)\n+\t\twriteToType(t, ttype, bw, test.tokens, input)\n+\n+\t\tgot := buf.Bytes()\n+\t\tif !bytes.Equal(got, want) {\n+\t\t\tt.Errorf(\"writeBlock did not yield expected result for file %q with input. See %q\", test.want, test.want+\".got\")\n+\t\t\tif err := ioutil.WriteFile(test.want+\".got\", got, 0666); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\t}\n+\t\tt.Log(\"Output ok\")\n+\n+\t\t// Test if the writer produces the same output after reset.\n+\t\tbuf.Reset()\n+\t\tbw.reset(&buf)\n+\t\twriteToType(t, ttype, bw, test.tokens, input)\n+\t\tbw.flush()\n+\t\tgot = buf.Bytes()\n+\t\tif !bytes.Equal(got, want) {\n+\t\t\tt.Errorf(\"reset: writeBlock did not yield expected result for file %q with input. See %q\", test.want, test.want+\".reset.got\")\n+\t\t\tif err := ioutil.WriteFile(test.want+\".reset.got\", got, 0666); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tt.Log(\"Reset ok\")\n+\t\ttestWriterEOF(t, \"wb\", test, true)\n+\t}\n+\tt.Logf(\"Testing %q\", test.wantNoInput)\n+\twantNI, err := ioutil.ReadFile(test.wantNoInput)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tvar buf bytes.Buffer\n+\tbw := newHuffmanBitWriter(&buf)\n+\twriteToType(t, ttype, bw, test.tokens, nil)\n+\n+\tgot := buf.Bytes()\n+\tif !bytes.Equal(got, wantNI) {\n+\t\tt.Errorf(\"writeBlock did not yield expected result for file %q with input. See %q\", test.wantNoInput, test.wantNoInput+\".got\")\n+\t\tif err := ioutil.WriteFile(test.want+\".got\", got, 0666); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t} else if got[0]&1 == 1 {\n+\t\tt.Error(\"got unexpected EOF\")\n+\t\treturn\n+\t}\n+\n+\tt.Log(\"Output ok\")\n+\n+\t// Test if the writer produces the same output after reset.\n+\tbuf.Reset()\n+\tbw.reset(&buf)\n+\twriteToType(t, ttype, bw, test.tokens, nil)\n+\tbw.flush()\n+\tgot = buf.Bytes()\n+\tif !bytes.Equal(got, wantNI) {\n+\t\tt.Errorf(\"reset: writeBlock did not yield expected result for file %q without input. See %q\", test.want, test.want+\".reset.got\")\n+\t\tif err := ioutil.WriteFile(test.want+\".reset.got\", got, 0666); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tt.Log(\"Reset ok\")\n+\ttestWriterEOF(t, \"wb\", test, false)\n+}\n+\n+func writeToType(t *testing.T, ttype string, bw *huffmanBitWriter, tok []token, input []byte) {\n+\tswitch ttype {\n+\tcase \"wb\":\n+\t\tbw.writeBlock(tok, false, input)\n+\tcase \"dyn\":\n+\t\tbw.writeBlockDynamic(tok, false, input)\n+\tdefault:\n+\t\tpanic(\"unknown test type\")\n+\t}\n+\n+\tif bw.err != nil {\n+\t\tt.Error(bw.err)\n+\t\treturn\n+\t}\n+\n+\tbw.flush()\n+\tif bw.err != nil {\n+\t\tt.Error(bw.err)\n+\t\treturn\n+\t}\n+}\n+\n+// testWriterEOF tests if the written block contains an EOF marker.\n+func testWriterEOF(t *testing.T, ttype string, test huffTest, useInput bool) {\n+\tif useInput && test.input == \"\" {\n+\t\treturn\n+\t}\n+\tvar input []byte\n+\tif useInput {\n+\t\tvar err error\n+\t\tinput, err = ioutil.ReadFile(test.input)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tvar buf bytes.Buffer\n+\tbw := newHuffmanBitWriter(&buf)\n+\tswitch ttype {\n+\tcase \"wb\":\n+\t\tbw.writeBlock(test.tokens, true, input)\n+\tcase \"dyn\":\n+\t\tbw.writeBlockDynamic(test.tokens, true, input)\n+\tcase \"huff\":\n+\t\tbw.writeBlockHuff(true, input)\n+\tdefault:\n+\t\tpanic(\"unknown test type\")\n+\t}\n+\tif bw.err != nil {\n+\t\tt.Error(bw.err)\n+\t\treturn\n+\t}\n+\n+\tbw.flush()\n+\tif bw.err != nil {\n+\t\tt.Error(bw.err)\n+\t\treturn\n+\t}\n+\tb := buf.Bytes()\n+\tif len(b) == 0 {\n+\t\tt.Error(\"no output received\")\n+\t\treturn\n+\t}\n+\tif b[0]&1 != 1 {\n+\t\tt.Errorf(\"block not marked with EOF for input %q\", test.input)\n+\t\treturn\n+\t}\n+\tt.Log(\"EOF ok\")\n+}"}, {"sha": "bdcbd823b00a79efd79fa9ef2a040f7c01d57edb", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 70, "deletions": 49, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -9,9 +9,17 @@ import (\n \t\"sort\"\n )\n \n+// hcode is a huffman code with a bit code and bit length.\n+type hcode struct {\n+\tcode, len uint16\n+}\n+\n type huffmanEncoder struct {\n-\tcodeBits []uint8\n-\tcode     []uint16\n+\tcodes     []hcode\n+\tfreqcache []literalNode\n+\tbitCount  [17]int32\n+\tlns       byLiteral // stored to avoid repeated allocation in generate\n+\tlfs       byFreq    // stored to avoid repeated allocation in generate\n }\n \n type literalNode struct {\n@@ -39,21 +47,26 @@ type levelInfo struct {\n \tneeded int32\n }\n \n+// set sets the code and length of an hcode.\n+func (h *hcode) set(code uint16, length uint16) {\n+\th.len = length\n+\th.code = code\n+}\n+\n func maxNode() literalNode { return literalNode{math.MaxUint16, math.MaxInt32} }\n \n func newHuffmanEncoder(size int) *huffmanEncoder {\n-\treturn &huffmanEncoder{make([]uint8, size), make([]uint16, size)}\n+\treturn &huffmanEncoder{codes: make([]hcode, size)}\n }\n \n // Generates a HuffmanCode corresponding to the fixed literal table\n func generateFixedLiteralEncoding() *huffmanEncoder {\n \th := newHuffmanEncoder(maxNumLit)\n-\tcodeBits := h.codeBits\n-\tcode := h.code\n+\tcodes := h.codes\n \tvar ch uint16\n \tfor ch = 0; ch < maxNumLit; ch++ {\n \t\tvar bits uint16\n-\t\tvar size uint8\n+\t\tvar size uint16\n \t\tswitch {\n \t\tcase ch < 144:\n \t\t\t// size 8, 000110000  .. 10111111\n@@ -75,31 +88,28 @@ func generateFixedLiteralEncoding() *huffmanEncoder {\n \t\t\tbits = ch + 192 - 280\n \t\t\tsize = 8\n \t\t}\n-\t\tcodeBits[ch] = size\n-\t\tcode[ch] = reverseBits(bits, size)\n+\t\tcodes[ch] = hcode{code: reverseBits(bits, byte(size)), len: size}\n \t}\n \treturn h\n }\n \n func generateFixedOffsetEncoding() *huffmanEncoder {\n \th := newHuffmanEncoder(30)\n-\tcodeBits := h.codeBits\n-\tcode := h.code\n-\tfor ch := uint16(0); ch < 30; ch++ {\n-\t\tcodeBits[ch] = 5\n-\t\tcode[ch] = reverseBits(ch, 5)\n+\tcodes := h.codes\n+\tfor ch := range codes {\n+\t\tcodes[ch] = hcode{code: reverseBits(uint16(ch), 5), len: 5}\n \t}\n \treturn h\n }\n \n var fixedLiteralEncoding *huffmanEncoder = generateFixedLiteralEncoding()\n var fixedOffsetEncoding *huffmanEncoder = generateFixedOffsetEncoding()\n \n-func (h *huffmanEncoder) bitLength(freq []int32) int64 {\n-\tvar total int64\n+func (h *huffmanEncoder) bitLength(freq []int32) int {\n+\tvar total int\n \tfor i, f := range freq {\n \t\tif f != 0 {\n-\t\t\ttotal += int64(f) * int64(h.codeBits[i])\n+\t\t\ttotal += int(f) * int(h.codes[i].len)\n \t\t}\n \t}\n \treturn total\n@@ -113,7 +123,7 @@ const maxBitsLimit = 16\n // The cases of 0, 1, and 2 literals are handled by special case code.\n //\n // list  An array of the literals with non-zero frequencies\n-//             and their associated frequencies.  The array is in order of increasing\n+//             and their associated frequencies. The array is in order of increasing\n //             frequency, and has as its last element a special element with frequency\n //             MaxInt32\n // maxBits     The maximum number of bits that should be used to encode any literal.\n@@ -128,7 +138,7 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n \tlist = list[0 : n+1]\n \tlist[n] = maxNode()\n \n-\t// The tree can't have greater depth than n - 1, no matter what.  This\n+\t// The tree can't have greater depth than n - 1, no matter what. This\n \t// saves a little bit of work in some small cases\n \tif maxBits > n-1 {\n \t\tmaxBits = n - 1\n@@ -197,7 +207,7 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n \n \t\tif l.needed--; l.needed == 0 {\n \t\t\t// We've done everything we need to do for this level.\n-\t\t\t// Continue calculating one level up.  Fill in nextPairFreq\n+\t\t\t// Continue calculating one level up. Fill in nextPairFreq\n \t\t\t// of that level with the sum of the two nodes we've just calculated on\n \t\t\t// this level.\n \t\t\tif l.level == maxBits {\n@@ -220,7 +230,7 @@ func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32 {\n \t\tpanic(\"leafCounts[maxBits][maxBits] != n\")\n \t}\n \n-\tbitCount := make([]int32, maxBits+1)\n+\tbitCount := h.bitCount[:maxBits+1]\n \tbits := 1\n \tcounts := &leafCounts[maxBits]\n \tfor level := maxBits; level > 0; level-- {\n@@ -246,10 +256,10 @@ func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalN\n \t\t// code, code + 1, ....  The code values are\n \t\t// assigned in literal order (not frequency order).\n \t\tchunk := list[len(list)-int(bits):]\n-\t\tsortByLiteral(chunk)\n+\n+\t\th.lns.sort(chunk)\n \t\tfor _, node := range chunk {\n-\t\t\th.codeBits[node.literal] = uint8(n)\n-\t\t\th.code[node.literal] = reverseBits(code, uint8(n))\n+\t\t\th.codes[node.literal] = hcode{code: reverseBits(code, uint8(n)), len: uint16(n)}\n \t\t\tcode++\n \t\t}\n \t\tlist = list[0 : len(list)-int(bits)]\n@@ -261,7 +271,13 @@ func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalN\n // freq  An array of frequencies, in which frequency[i] gives the frequency of literal i.\n // maxBits  The maximum number of bits to use for any literal.\n func (h *huffmanEncoder) generate(freq []int32, maxBits int32) {\n-\tlist := make([]literalNode, len(freq)+1)\n+\tif h.freqcache == nil {\n+\t\t// Allocate a reusable buffer with the longest possible frequency table.\n+\t\t// Possible lengths are codegenCodeCount, offsetCodeCount and maxNumLit.\n+\t\t// The largest of these is maxNumLit, so we allocate for that case.\n+\t\th.freqcache = make([]literalNode, maxNumLit+1)\n+\t}\n+\tlist := h.freqcache[:len(freq)+1]\n \t// Number of non-zero literals\n \tcount := 0\n \t// Set list to be the set of all non-zero literals and their frequencies\n@@ -270,54 +286,59 @@ func (h *huffmanEncoder) generate(freq []int32, maxBits int32) {\n \t\t\tlist[count] = literalNode{uint16(i), f}\n \t\t\tcount++\n \t\t} else {\n-\t\t\th.codeBits[i] = 0\n+\t\t\tlist[count] = literalNode{}\n+\t\t\th.codes[i].len = 0\n \t\t}\n \t}\n-\t// If freq[] is shorter than codeBits[], fill rest of codeBits[] with zeros\n-\th.codeBits = h.codeBits[0:len(freq)]\n-\tlist = list[0:count]\n+\tlist[len(freq)] = literalNode{}\n+\n+\tlist = list[:count]\n \tif count <= 2 {\n-\t\t// Handle the small cases here, because they are awkward for the general case code.  With\n+\t\t// Handle the small cases here, because they are awkward for the general case code. With\n \t\t// two or fewer literals, everything has bit length 1.\n \t\tfor i, node := range list {\n \t\t\t// \"list\" is in order of increasing literal value.\n-\t\t\th.codeBits[node.literal] = 1\n-\t\t\th.code[node.literal] = uint16(i)\n+\t\t\th.codes[node.literal].set(uint16(i), 1)\n \t\t}\n \t\treturn\n \t}\n-\tsortByFreq(list)\n+\th.lfs.sort(list)\n \n \t// Get the number of literals for each bit count\n \tbitCount := h.bitCounts(list, maxBits)\n \t// And do the assignment\n \th.assignEncodingAndSize(bitCount, list)\n }\n \n-type literalNodeSorter struct {\n-\ta    []literalNode\n-\tless func(i, j int) bool\n+type byLiteral []literalNode\n+\n+func (s *byLiteral) sort(a []literalNode) {\n+\t*s = byLiteral(a)\n+\tsort.Sort(s)\n }\n \n-func (s literalNodeSorter) Len() int { return len(s.a) }\n+func (s byLiteral) Len() int { return len(s) }\n \n-func (s literalNodeSorter) Less(i, j int) bool {\n-\treturn s.less(i, j)\n+func (s byLiteral) Less(i, j int) bool {\n+\treturn s[i].literal < s[j].literal\n }\n \n-func (s literalNodeSorter) Swap(i, j int) { s.a[i], s.a[j] = s.a[j], s.a[i] }\n+func (s byLiteral) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n \n-func sortByFreq(a []literalNode) {\n-\ts := &literalNodeSorter{a, func(i, j int) bool {\n-\t\tif a[i].freq == a[j].freq {\n-\t\t\treturn a[i].literal < a[j].literal\n-\t\t}\n-\t\treturn a[i].freq < a[j].freq\n-\t}}\n+type byFreq []literalNode\n+\n+func (s *byFreq) sort(a []literalNode) {\n+\t*s = byFreq(a)\n \tsort.Sort(s)\n }\n \n-func sortByLiteral(a []literalNode) {\n-\ts := &literalNodeSorter{a, func(i, j int) bool { return a[i].literal < a[j].literal }}\n-\tsort.Sort(s)\n+func (s byFreq) Len() int { return len(s) }\n+\n+func (s byFreq) Less(i, j int) bool {\n+\tif s[i].freq == s[j].freq {\n+\t\treturn s[i].literal < s[j].literal\n+\t}\n+\treturn s[i].freq < s[j].freq\n }\n+\n+func (s byFreq) Swap(i, j int) { s[i], s[j] = s[j], s[i] }"}, {"sha": "68cc232052bc328c6c55165e9e49cc1241a6eacf", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 91, "deletions": 136, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -15,8 +15,7 @@ import (\n )\n \n const (\n-\tmaxCodeLen = 16    // max length of Huffman code\n-\tmaxHist    = 32768 // max history required\n+\tmaxCodeLen = 16 // max length of Huffman code\n \t// The next three numbers come from the RFC section 3.2.7, with the\n \t// additional proviso in section 3.2.5 which implies that distance codes\n \t// 30 and 31 should never occur in compressed data.\n@@ -115,7 +114,7 @@ type huffmanDecoder struct {\n // trees are permitted.\n func (h *huffmanDecoder) init(bits []int) bool {\n \t// Sanity enables additional runtime tests during Huffman\n-\t// table construction.  It's intended to be used during\n+\t// table construction. It's intended to be used during\n \t// development to supplement the currently ad-hoc unit tests.\n \tconst sanity = false\n \n@@ -162,7 +161,7 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t// Check that the coding is complete (i.e., that we've\n \t// assigned all 2-to-the-max possible bit sequences).\n \t// Exception: To be compatible with zlib, we also need to\n-\t// accept degenerate single-code codings.  See also\n+\t// accept degenerate single-code codings. See also\n \t// TestDegenerateHuffmanCoding.\n \tif code != 1<<uint(max) && !(code == 1 && max == 1) {\n \t\treturn false\n@@ -200,7 +199,7 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\tif n <= huffmanChunkBits {\n \t\t\tfor off := reverse; off < len(h.chunks); off += 1 << uint(n) {\n \t\t\t\t// We should never need to overwrite\n-\t\t\t\t// an existing chunk.  Also, 0 is\n+\t\t\t\t// an existing chunk. Also, 0 is\n \t\t\t\t// never a valid chunk, because the\n \t\t\t\t// lower 4 \"count\" bits should be\n \t\t\t\t// between 1 and 15.\n@@ -230,7 +229,7 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \n \tif sanity {\n \t\t// Above we've sanity checked that we never overwrote\n-\t\t// an existing entry.  Here we additionally check that\n+\t\t// an existing entry. Here we additionally check that\n \t\t// we filled the tables completely.\n \t\tfor i, chunk := range h.chunks {\n \t\t\tif chunk == 0 {\n@@ -268,7 +267,6 @@ type decompressor struct {\n \t// Input source.\n \tr       Reader\n \troffset int64\n-\twoffset int64\n \n \t// Input bits, in top of b.\n \tb  uint32\n@@ -282,34 +280,24 @@ type decompressor struct {\n \tcodebits *[numCodes]int\n \n \t// Output history, buffer.\n-\thist  *[maxHist]byte\n-\thp    int  // current output position in buffer\n-\thw    int  // have written hist[0:hw] already\n-\thfull bool // buffer has filled at least once\n+\tdict dictDecoder\n \n \t// Temporary buffer (avoids repeated allocation).\n \tbuf [4]byte\n \n \t// Next step in the decompression,\n \t// and decompression state.\n-\tstep     func(*decompressor)\n-\tfinal    bool\n-\terr      error\n-\ttoRead   []byte\n-\thl, hd   *huffmanDecoder\n-\tcopyLen  int\n-\tcopyDist int\n+\tstep      func(*decompressor)\n+\tstepState int\n+\tfinal     bool\n+\terr       error\n+\ttoRead    []byte\n+\thl, hd    *huffmanDecoder\n+\tcopyLen   int\n+\tcopyDist  int\n }\n \n func (f *decompressor) nextBlock() {\n-\tif f.final {\n-\t\tif f.hw != f.hp {\n-\t\t\tf.flush((*decompressor).nextBlock)\n-\t\t\treturn\n-\t\t}\n-\t\tf.err = io.EOF\n-\t\treturn\n-\t}\n \tfor f.nb < 1+2 {\n \t\tif f.err = f.moreBits(); f.err != nil {\n \t\t\treturn\n@@ -347,6 +335,9 @@ func (f *decompressor) Read(b []byte) (int, error) {\n \t\tif len(f.toRead) > 0 {\n \t\t\tn := copy(b, f.toRead)\n \t\t\tf.toRead = f.toRead[n:]\n+\t\t\tif len(f.toRead) == 0 {\n+\t\t\t\treturn n, f.err\n+\t\t\t}\n \t\t\treturn n, nil\n \t\t}\n \t\tif f.err != nil {\n@@ -478,10 +469,24 @@ func (f *decompressor) readHuffman() error {\n \n // Decode a single Huffman block from f.\n // hl and hd are the Huffman states for the lit/length values\n-// and the distance values, respectively.  If hd == nil, using the\n+// and the distance values, respectively. If hd == nil, using the\n // fixed distance encoding associated with fixed Huffman blocks.\n func (f *decompressor) huffmanBlock() {\n-\tfor {\n+\tconst (\n+\t\tstateInit = iota // Zero value must be stateInit\n+\t\tstateDict\n+\t)\n+\n+\tswitch f.stepState {\n+\tcase stateInit:\n+\t\tgoto readLiteral\n+\tcase stateDict:\n+\t\tgoto copyHistory\n+\t}\n+\n+readLiteral:\n+\t// Read literal and/or (length, distance) according to RFC section 3.2.3.\n+\t{\n \t\tv, err := f.huffSym(f.hl)\n \t\tif err != nil {\n \t\t\tf.err = err\n@@ -491,17 +496,16 @@ func (f *decompressor) huffmanBlock() {\n \t\tvar length int\n \t\tswitch {\n \t\tcase v < 256:\n-\t\t\tf.hist[f.hp] = byte(v)\n-\t\t\tf.hp++\n-\t\t\tif f.hp == len(f.hist) {\n-\t\t\t\t// After the flush, continue this loop.\n-\t\t\t\tf.flush((*decompressor).huffmanBlock)\n+\t\t\tf.dict.writeByte(byte(v))\n+\t\t\tif f.dict.availWrite() == 0 {\n+\t\t\t\tf.toRead = f.dict.readFlush()\n+\t\t\t\tf.step = (*decompressor).huffmanBlock\n+\t\t\t\tf.stepState = stateInit\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tcontinue\n+\t\t\tgoto readLiteral\n \t\tcase v == 256:\n-\t\t\t// Done with huffman block; read next block.\n-\t\t\tf.step = (*decompressor).nextBlock\n+\t\t\tf.finishBlock()\n \t\t\treturn\n \t\t// otherwise, reference to older data\n \t\tcase v < 265:\n@@ -581,61 +585,33 @@ func (f *decompressor) huffmanBlock() {\n \t\t\treturn\n \t\t}\n \n-\t\t// Copy history[-dist:-dist+length] into output.\n-\t\tif dist > len(f.hist) {\n-\t\t\tf.err = InternalError(\"bad history distance\")\n-\t\t\treturn\n-\t\t}\n-\n \t\t// No check on length; encoding can be prescient.\n-\t\tif !f.hfull && dist > f.hp {\n+\t\tif dist > f.dict.histSize() {\n \t\t\tf.err = CorruptInputError(f.roffset)\n \t\t\treturn\n \t\t}\n \n \t\tf.copyLen, f.copyDist = length, dist\n-\t\tif f.copyHist() {\n-\t\t\treturn\n-\t\t}\n+\t\tgoto copyHistory\n \t}\n-}\n \n-// copyHist copies f.copyLen bytes from f.hist (f.copyDist bytes ago) to itself.\n-// It reports whether the f.hist buffer is full.\n-func (f *decompressor) copyHist() bool {\n-\tp := f.hp - f.copyDist\n-\tif p < 0 {\n-\t\tp += len(f.hist)\n-\t}\n-\tfor f.copyLen > 0 {\n-\t\tn := f.copyLen\n-\t\tif x := len(f.hist) - f.hp; n > x {\n-\t\t\tn = x\n-\t\t}\n-\t\tif x := len(f.hist) - p; n > x {\n-\t\t\tn = x\n+copyHistory:\n+\t// Perform a backwards copy according to RFC section 3.2.3.\n+\t{\n+\t\tcnt := f.dict.tryWriteCopy(f.copyDist, f.copyLen)\n+\t\tif cnt == 0 {\n+\t\t\tcnt = f.dict.writeCopy(f.copyDist, f.copyLen)\n \t\t}\n-\t\tforwardCopy(f.hist[:], f.hp, p, n)\n-\t\tp += n\n-\t\tf.hp += n\n-\t\tf.copyLen -= n\n-\t\tif f.hp == len(f.hist) {\n-\t\t\t// After flush continue copying out of history.\n-\t\t\tf.flush((*decompressor).copyHuff)\n-\t\t\treturn true\n-\t\t}\n-\t\tif p == len(f.hist) {\n-\t\t\tp = 0\n-\t\t}\n-\t}\n-\treturn false\n-}\n+\t\tf.copyLen -= cnt\n \n-func (f *decompressor) copyHuff() {\n-\tif f.copyHist() {\n-\t\treturn\n+\t\tif f.dict.availWrite() == 0 || f.copyLen > 0 {\n+\t\t\tf.toRead = f.dict.readFlush()\n+\t\t\tf.step = (*decompressor).huffmanBlock // We need to continue this work\n+\t\t\tf.stepState = stateDict\n+\t\t\treturn\n+\t\t}\n+\t\tgoto readLiteral\n \t}\n-\tf.huffmanBlock()\n }\n \n // Copy a single uncompressed data block from input to output.\n@@ -663,8 +639,8 @@ func (f *decompressor) dataBlock() {\n \t}\n \n \tif n == 0 {\n-\t\t// 0-length block means sync\n-\t\tf.flush((*decompressor).nextBlock)\n+\t\tf.toRead = f.dict.readFlush()\n+\t\tf.finishBlock()\n \t\treturn\n \t}\n \n@@ -675,44 +651,39 @@ func (f *decompressor) dataBlock() {\n // copyData copies f.copyLen bytes from the underlying reader into f.hist.\n // It pauses for reads when f.hist is full.\n func (f *decompressor) copyData() {\n-\tn := f.copyLen\n-\tfor n > 0 {\n-\t\tm := len(f.hist) - f.hp\n-\t\tif m > n {\n-\t\t\tm = n\n-\t\t}\n-\t\tm, err := io.ReadFull(f.r, f.hist[f.hp:f.hp+m])\n-\t\tf.roffset += int64(m)\n-\t\tif err != nil {\n-\t\t\tif err == io.EOF {\n-\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t}\n-\t\t\tf.err = err\n-\t\t\treturn\n-\t\t}\n-\t\tn -= m\n-\t\tf.hp += m\n-\t\tif f.hp == len(f.hist) {\n-\t\t\tf.copyLen = n\n-\t\t\tf.flush((*decompressor).copyData)\n-\t\t\treturn\n+\tbuf := f.dict.writeSlice()\n+\tif len(buf) > f.copyLen {\n+\t\tbuf = buf[:f.copyLen]\n+\t}\n+\n+\tcnt, err := io.ReadFull(f.r, buf)\n+\tf.roffset += int64(cnt)\n+\tf.copyLen -= cnt\n+\tf.dict.writeMark(cnt)\n+\tif err != nil {\n+\t\tif err == io.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n+\t\tf.err = err\n+\t\treturn\n \t}\n-\tf.step = (*decompressor).nextBlock\n-}\n \n-func (f *decompressor) setDict(dict []byte) {\n-\tif len(dict) > len(f.hist) {\n-\t\t// Will only remember the tail.\n-\t\tdict = dict[len(dict)-len(f.hist):]\n+\tif f.dict.availWrite() == 0 || f.copyLen > 0 {\n+\t\tf.toRead = f.dict.readFlush()\n+\t\tf.step = (*decompressor).copyData\n+\t\treturn\n \t}\n+\tf.finishBlock()\n+}\n \n-\tf.hp = copy(f.hist[:], dict)\n-\tif f.hp == len(f.hist) {\n-\t\tf.hp = 0\n-\t\tf.hfull = true\n+func (f *decompressor) finishBlock() {\n+\tif f.final {\n+\t\tif f.dict.availRead() > 0 {\n+\t\t\tf.toRead = f.dict.readFlush()\n+\t\t}\n+\t\tf.err = io.EOF\n \t}\n-\tf.hw = f.hp\n+\tf.step = (*decompressor).nextBlock\n }\n \n func (f *decompressor) moreBits() error {\n@@ -760,19 +731,6 @@ func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n \t}\n }\n \n-// Flush any buffered output to the underlying writer.\n-func (f *decompressor) flush(step func(*decompressor)) {\n-\tf.toRead = f.hist[f.hw:f.hp]\n-\tf.woffset += int64(f.hp - f.hw)\n-\tf.hw = f.hp\n-\tif f.hp == len(f.hist) {\n-\t\tf.hp = 0\n-\t\tf.hw = 0\n-\t\tf.hfull = true\n-\t}\n-\tf.step = step\n-}\n-\n func makeReader(r io.Reader) Reader {\n \tif rr, ok := r.(Reader); ok {\n \t\treturn rr\n@@ -805,12 +763,10 @@ func (f *decompressor) Reset(r io.Reader, dict []byte) error {\n \t\tr:        makeReader(r),\n \t\tbits:     f.bits,\n \t\tcodebits: f.codebits,\n-\t\thist:     f.hist,\n+\t\tdict:     f.dict,\n \t\tstep:     (*decompressor).nextBlock,\n \t}\n-\tif dict != nil {\n-\t\tf.setDict(dict)\n-\t}\n+\tf.dict.init(maxMatchOffset, dict)\n \treturn nil\n }\n \n@@ -827,17 +783,17 @@ func NewReader(r io.Reader) io.ReadCloser {\n \n \tvar f decompressor\n \tf.r = makeReader(r)\n-\tf.hist = new([maxHist]byte)\n \tf.bits = new([maxNumLit + maxNumDist]int)\n \tf.codebits = new([numCodes]int)\n \tf.step = (*decompressor).nextBlock\n+\tf.dict.init(maxMatchOffset, nil)\n \treturn &f\n }\n \n // NewReaderDict is like NewReader but initializes the reader\n-// with a preset dictionary.  The returned Reader behaves as if\n+// with a preset dictionary. The returned Reader behaves as if\n // the uncompressed data stream started with the given dictionary,\n-// which has already been read.  NewReaderDict is typically used\n+// which has already been read. NewReaderDict is typically used\n // to read data compressed by NewWriterDict.\n //\n // The ReadCloser returned by NewReader also implements Resetter.\n@@ -846,10 +802,9 @@ func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \n \tvar f decompressor\n \tf.r = makeReader(r)\n-\tf.hist = new([maxHist]byte)\n \tf.bits = new([maxNumLit + maxNumDist]int)\n \tf.codebits = new([numCodes]int)\n \tf.step = (*decompressor).nextBlock\n-\tf.setDict(dict)\n+\tf.dict.init(maxMatchOffset, dict)\n \treturn &f\n }"}, {"sha": "e0bce71d6f2d9eda8795c95dd2df93c00df0ee3f", "filename": "libgo/go/compress/flate/inflate_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -37,3 +37,33 @@ func TestReset(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestResetDict(t *testing.T) {\n+\tdict := []byte(\"the lorem fox\")\n+\tss := []string{\n+\t\t\"lorem ipsum izzle fo rizzle\",\n+\t\t\"the quick brown fox jumped over\",\n+\t}\n+\n+\tdeflated := make([]bytes.Buffer, len(ss))\n+\tfor i, s := range ss {\n+\t\tw, _ := NewWriterDict(&deflated[i], DefaultCompression, dict)\n+\t\tw.Write([]byte(s))\n+\t\tw.Close()\n+\t}\n+\n+\tinflated := make([]bytes.Buffer, len(ss))\n+\n+\tf := NewReader(nil)\n+\tfor i := range inflated {\n+\t\tf.(Resetter).Reset(&deflated[i], dict)\n+\t\tio.Copy(&inflated[i], f)\n+\t}\n+\tf.Close()\n+\n+\tfor i, s := range ss {\n+\t\tif s != inflated[i].String() {\n+\t\t\tt.Errorf(\"inflated[%d]:\\ngot  %q\\nwant %q\", i, inflated[i], s)\n+\t\t}\n+\t}\n+}"}, {"sha": "b0a16ce18b98d637063eb3d9ff843466999f9cf9", "filename": "libgo/go/compress/flate/reader_test.go", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -22,75 +22,77 @@ func TestNlitOutOfRange(t *testing.T) {\n \t\t\t\"\\x75\\xc4\\xf8\\x0f\\x12\\x11\\xb9\\xb4\\x4b\\x09\\xa0\\xbe\\x8b\\x91\\x4c\")))\n }\n \n-const (\n-\tdigits = iota\n-\ttwain\n-)\n-\n-var testfiles = []string{\n+var suites = []struct{ name, file string }{\n \t// Digits is the digits of the irrational number e. Its decimal representation\n \t// does not repeat, but there are only 10 possible digits, so it should be\n \t// reasonably compressible.\n-\tdigits: \"../testdata/e.txt\",\n+\t{\"Digits\", \"../testdata/e.txt\"},\n \t// Twain is Mark Twain's classic English novel.\n-\ttwain: \"../testdata/Mark.Twain-Tom.Sawyer.txt\",\n+\t{\"Twain\", \"../testdata/Mark.Twain-Tom.Sawyer.txt\"},\n }\n \n-func benchmarkDecode(b *testing.B, testfile, level, n int) {\n-\tb.ReportAllocs()\n-\tb.StopTimer()\n-\tb.SetBytes(int64(n))\n-\tbuf0, err := ioutil.ReadFile(testfiles[testfile])\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tif len(buf0) == 0 {\n-\t\tb.Fatalf(\"test file %q has no data\", testfiles[testfile])\n-\t}\n-\tcompressed := new(bytes.Buffer)\n-\tw, err := NewWriter(compressed, level)\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tfor i := 0; i < n; i += len(buf0) {\n-\t\tif len(buf0) > n-i {\n-\t\t\tbuf0 = buf0[:n-i]\n+func BenchmarkDecode(b *testing.B) {\n+\tdoBench(b, func(b *testing.B, buf0 []byte, level, n int) {\n+\t\tb.ReportAllocs()\n+\t\tb.StopTimer()\n+\t\tb.SetBytes(int64(n))\n+\n+\t\tcompressed := new(bytes.Buffer)\n+\t\tw, err := NewWriter(compressed, level)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n \t\t}\n-\t\tio.Copy(w, bytes.NewReader(buf0))\n-\t}\n-\tw.Close()\n-\tbuf1 := compressed.Bytes()\n-\tbuf0, compressed, w = nil, nil, nil\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewReader(buf1)))\n-\t}\n+\t\tfor i := 0; i < n; i += len(buf0) {\n+\t\t\tif len(buf0) > n-i {\n+\t\t\t\tbuf0 = buf0[:n-i]\n+\t\t\t}\n+\t\t\tio.Copy(w, bytes.NewReader(buf0))\n+\t\t}\n+\t\tw.Close()\n+\t\tbuf1 := compressed.Bytes()\n+\t\tbuf0, compressed, w = nil, nil, nil\n+\t\truntime.GC()\n+\t\tb.StartTimer()\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewReader(buf1)))\n+\t\t}\n+\t})\n }\n \n-// These short names are so that gofmt doesn't break the BenchmarkXxx function\n-// bodies below over multiple lines.\n-const (\n-\tspeed    = BestSpeed\n-\tdefault_ = DefaultCompression\n-\tcompress = BestCompression\n-)\n+var levelTests = []struct {\n+\tname  string\n+\tlevel int\n+}{\n+\t{\"Huffman\", HuffmanOnly},\n+\t{\"Speed\", BestSpeed},\n+\t{\"Default\", DefaultCompression},\n+\t{\"Compression\", BestCompression},\n+}\n \n-func BenchmarkDecodeDigitsSpeed1e4(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e4) }\n-func BenchmarkDecodeDigitsSpeed1e5(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e5) }\n-func BenchmarkDecodeDigitsSpeed1e6(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e6) }\n-func BenchmarkDecodeDigitsDefault1e4(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e4) }\n-func BenchmarkDecodeDigitsDefault1e5(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e5) }\n-func BenchmarkDecodeDigitsDefault1e6(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e6) }\n-func BenchmarkDecodeDigitsCompress1e4(b *testing.B) { benchmarkDecode(b, digits, compress, 1e4) }\n-func BenchmarkDecodeDigitsCompress1e5(b *testing.B) { benchmarkDecode(b, digits, compress, 1e5) }\n-func BenchmarkDecodeDigitsCompress1e6(b *testing.B) { benchmarkDecode(b, digits, compress, 1e6) }\n-func BenchmarkDecodeTwainSpeed1e4(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e4) }\n-func BenchmarkDecodeTwainSpeed1e5(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e5) }\n-func BenchmarkDecodeTwainSpeed1e6(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e6) }\n-func BenchmarkDecodeTwainDefault1e4(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e4) }\n-func BenchmarkDecodeTwainDefault1e5(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e5) }\n-func BenchmarkDecodeTwainDefault1e6(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e6) }\n-func BenchmarkDecodeTwainCompress1e4(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e4) }\n-func BenchmarkDecodeTwainCompress1e5(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e5) }\n-func BenchmarkDecodeTwainCompress1e6(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e6) }\n+var sizes = []struct {\n+\tname string\n+\tn    int\n+}{\n+\t{\"1e4\", 1e4},\n+\t{\"1e5\", 1e5},\n+\t{\"1e6\", 1e6},\n+}\n+\n+func doBench(b *testing.B, f func(b *testing.B, buf []byte, level, n int)) {\n+\tfor _, suite := range suites {\n+\t\tbuf, err := ioutil.ReadFile(suite.file)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t\tif len(buf) == 0 {\n+\t\t\tb.Fatalf(\"test file %q has no data\", suite.file)\n+\t\t}\n+\t\tfor _, l := range levelTests {\n+\t\t\tfor _, s := range sizes {\n+\t\t\t\tb.Run(suite.name+\"/\"+l.name+\"/\"+s.name, func(b *testing.B) {\n+\t\t\t\t\tf(b, buf, l.level, s.n)\n+\t\t\t\t})\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6b222900c1ec9deab163ca98e0bdcafd7c869fbb", "filename": "libgo/go/compress/flate/reverse_bits.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -44,5 +44,5 @@ func reverseUint16(v uint16) uint16 {\n }\n \n func reverseBits(number uint16, bitLength byte) uint16 {\n-\treturn reverseUint16(number << uint8(16-bitLength))\n+\treturn reverseUint16(number << (16 - bitLength))\n }"}, {"sha": "c08165143f2c570013c4916cbac5addfe9622a55", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "c08165143f2c570013c4916cbac5addfe9622a55", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "db422ca3983d12e71e31979d7b3dddd080dcbca7", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "5dfddf075bed03499414ae453f0d6f30fe79da3d", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.in", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "c08165143f2c570013c4916cbac5addfe9622a55", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "c08165143f2c570013c4916cbac5addfe9622a55", "filename": "libgo/go/compress/flate/testdata/huffman-null-max.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-null-max.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "e4396ac6fe5e34609ccb7ea0bc359e6adb48c7f4", "filename": "libgo/go/compress/flate/testdata/huffman-pi.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "e4396ac6fe5e34609ccb7ea0bc359e6adb48c7f4", "filename": "libgo/go/compress/flate/testdata/huffman-pi.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "23d8f7f98b5906e3fd0f811cb6561d7a67ec9a56", "filename": "libgo/go/compress/flate/testdata/huffman-pi.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "efaed43431adecaa32c5d843afacbef275c58db8", "filename": "libgo/go/compress/flate/testdata/huffman-pi.in", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863278865936153381827968230301952035301852968995773622599413891249721775283479131515574857242454150695950829533116861727855889075098381754637464939319255060400927701671139009848824012858361603563707660104710181942955596198946767837449448255379774726847104047534646208046684259069491293313677028989152104752162056966024058038150193511253382430035587640247496473263914199272604269922796782354781636009341721641219924586315030286182974555706749838505494588586926995690927210797509302955321165344987202755960236480665499119881834797753566369807426542527862551818417574672890977772793800081647060016145249192173217214772350141441973568548161361157352552133475741849468438523323907394143334547762416862518983569485562099219222184272550254256887671790494601653466804988627232791786085784383827967976681454100953883786360950680064225125205117392984896084128488626945604241965285022210661186306744278622039194945047123713786960956364371917287467764657573962413890865832645995813390478027590099465764078951269468398352595709825822620522489407726719478268482601476990902640136394437455305068203496252451749399651431429809190659250937221696461515709858387410597885959772975498930161753928468138268683868942774155991855925245953959431049972524680845987273644695848653836736222626099124608051243884390451244136549762780797715691435997700129616089441694868555848406353422072225828488648158456028506016842739452267467678895252138522549954666727823986456596116354886230577456498035593634568174324112515076069479451096596094025228879710893145669136867228748940560101503308617928680920874760917824938589009714909675985261365549781893129784821682998948722658804857564014270477555132379641451523746234364542858444795265867821051141354735739523113427166102135969536231442952484937187110145765403590279934403742007310578539062198387447808478489683321445713868751943506430218453191048481005370614680674919278191197939952061419663428754440643745123718192179998391015919561814675142691239748940907186494231961567945208095146550225231603881930142093762137855956638937787083039069792077346722182562599661501421503068038447734549202605414665925201497442850732518666002132434088190710486331734649651453905796268561005508106658796998163574736384052571459102897064140110971206280439039759515677157700420337869936007230558763176359421873125147120532928191826186125867321579198414848829164470609575270695722091756711672291098169091528017350671274858322287183520935396572512108357915136988209144421006751033467110314126711136990865851639831501970165151168517143765761835155650884909989859982387345528331635507647918535893226185489632132933089857064204675259070915481416549859461637180\n\\ No newline at end of file"}, {"sha": "e4396ac6fe5e34609ccb7ea0bc359e6adb48c7f4", "filename": "libgo/go/compress/flate/testdata/huffman-pi.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "e4396ac6fe5e34609ccb7ea0bc359e6adb48c7f4", "filename": "libgo/go/compress/flate/testdata/huffman-pi.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-pi.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "09dc798ee37df82176b8b7c9998c88a14207c1ad", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "0c24742fde2487e3a454ec3364f15e541693c37c", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "09dc798ee37df82176b8b7c9998c88a14207c1ad", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ce038ebb5bd911cd054b86c044fd26e6003225e2", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.in", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "09dc798ee37df82176b8b7c9998c88a14207c1ad", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "0c24742fde2487e3a454ec3364f15e541693c37c", "filename": "libgo/go/compress/flate/testdata/huffman-rand-1k.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-1k.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "2d6527934e98300d744c7558a025250f67e0f1c9", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "2d6527934e98300d744c7558a025250f67e0f1c9", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "57e59322e9884ed96ccace7d6054ca9223128a33", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "fb5b1be6198e4b2e17d70d67ea06156a06f9ae9e", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.in", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,4 @@\n+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\ufffdvH\n+\ufffd\ufffd%\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\u0017\ufffd\u0277\ufffd\ufffd\u0006\ufffd}\u0018\ufffd\ufffd>\u0007\ufffd\ufffd\ufffdls\ufffd\ufffd\ufffdm\ufffd\u0004\u0019I\u007fG\u001fH\u0015\ufffd\ufffd\ufffd1Y\ufffd4\ufffd[\ufffd\ufffd\t\u00110\u0088[|]\u0014\u0013o#\ufffd\n+\ufffd-#\ufffd\ufffd\ufffdu\u0004l\ufffd\ufffd\ufffdpf\ufffd\ufffd\u0671\ufffdn\ufffdY\ufffd\u0500Y\ufffdw\ufffdC8\u026f02\ufffd \u001bF=gn\ufffdr\ufffdN!O\ufffd\ufffd\ufffd{\u0004\ufffd\ufffd\u0003\ufffd\u0005\ufffdk\ufffd*\ufffdw(\ufffdb\ufffd \ufffd\u001f\ufffdkQC9/\ufffd\ufffd\u0001lu>\ufffd5\ufffdC.\ufffdu\ufffd\ufffd"}, {"sha": "881e59c9ab9bb356c5f1b8f2e188818bd42dbcf0", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "881e59c9ab9bb356c5f1b8f2e188818bd42dbcf0", "filename": "libgo/go/compress/flate/testdata/huffman-rand-limit.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-limit.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "47d53c89c077d0e62aeaf818154f60921960de5c", "filename": "libgo/go/compress/flate/testdata/huffman-rand-max.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "8418633d2ac9791cc75a316d53c8490a328daa39", "filename": "libgo/go/compress/flate/testdata/huffman-rand-max.in", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-rand-max.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "7812c1c62da3cbaeb6399e9aa8ab65ae7efa9b08", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "7812c1c62da3cbaeb6399e9aa8ab65ae7efa9b08", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "f5133778e1c783a6da12f76fec3f04014c77694e", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "7c7a50d158326b04cda8b60bbec46c3bd042cefa", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.in", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,2 @@\n+101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010\r\n+232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323\n\\ No newline at end of file"}, {"sha": "7812c1c62da3cbaeb6399e9aa8ab65ae7efa9b08", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "7812c1c62da3cbaeb6399e9aa8ab65ae7efa9b08", "filename": "libgo/go/compress/flate/testdata/huffman-shifts.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-shifts.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "71ce3aeb75a86e8375d9ac4350b7d83b9229a3ed", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "71ce3aeb75a86e8375d9ac4350b7d83b9229a3ed", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ff023114bbc8f62921df38438fbb0c415f04f220", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "cc5c3ad69d241ec6595e2f3ee53fc52a39e78331", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.in", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,14 @@\n+//Copyright2009ThGoAuthor.Allrightrrvd.\r\n+//UofthiourccodigovrndbyBSD-tyl\r\n+//licnthtcnbfoundinthLICENSEfil.\r\n+\r\n+pckgmin\r\n+\r\n+import\"o\"\r\n+\r\n+funcmin(){\r\n+\tvrb=mk([]byt,65535)\r\n+\tf,_:=o.Crt(\"huffmn-null-mx.in\")\r\n+\tf.Writ(b)\r\n+}\r\n+ABCDEFGHIJKLMNOPQRSTUVXxyz!\"#\u00a4%&/?\"\n\\ No newline at end of file"}, {"sha": "71ce3aeb75a86e8375d9ac4350b7d83b9229a3ed", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "71ce3aeb75a86e8375d9ac4350b7d83b9229a3ed", "filename": "libgo/go/compress/flate/testdata/huffman-text-shift.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text-shift.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "d448727c323cafd73bdefa0b3752980f60b6bf7f", "filename": "libgo/go/compress/flate/testdata/huffman-text.dyn.expect", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+\u001c\ufffd_K\ufffd0\u001c\ufffd\ufffd\ufffd\u0005\ufffd\u001e\u000e\ufffd\ufffd`K\ufffd\ufffd0Aa\u0017s\u000e\u0011\u011b)^\ufffdH\ufffd\ufffd\ufffd\ufffd\ufffdI\u025fb\u0011\u07fb\ufffd\ufffd_>\ufffd4\r\u000ea\ufffd\ufffd=\ufffd\ufffd\u007f\ufffd\ufffd-^\r\ufffd1`_\ufffd\t1\t\ufffd\ufffd\ufffd\t\ufffd\u0012\u0151:\ufffdY\ufffd\ufffd-\u0011\ufffdF66!\ufffd\u0012\u0015A\ufffd\ufffd`\u0013\ufffda\ufffd\ufffdC;A\ufffd\ufffd\ufffdNyr4\u07dcU\ufffd\u0013!\u001b\ufffd\ufffd\ufffdGK\u0421\ufffd\u000e\ufffd#\u001b\ufffd\ufffd\ufffd\ufffd\ufffdr:B[G\ufffd3\ufffd\u0006\ufffd.\ufffdL\ufffd\ufffd\u05f6\ufffd\u0010bF\u0015RuM]\ufffd\ufffd\ufffd^\u21f3\ufffd(#Z\ufffd\ufffd\ufffd\u000b\ufffd\u001f\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffd\ufffdB\ufffd\ufffd\u001dB\u0012\ufffdH2S]\ufffd\ufffdu/\ufffd\ufffd\u0017\ufffd\u05bd\ufffd\u0016\ufffdW\ufffdT\ufffdG\ufffd\ufffdn\ufffd\ufffd\ufffdr\ufffd\u0007\n\\ No newline at end of file"}, {"sha": "d448727c323cafd73bdefa0b3752980f60b6bf7f", "filename": "libgo/go/compress/flate/testdata/huffman-text.dyn.expect-noinput", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+\u001c\ufffd_K\ufffd0\u001c\ufffd\ufffd\ufffd\u0005\ufffd\u001e\u000e\ufffd\ufffd`K\ufffd\ufffd0Aa\u0017s\u000e\u0011\u011b)^\ufffdH\ufffd\ufffd\ufffd\ufffd\ufffdI\u025fb\u0011\u07fb\ufffd\ufffd_>\ufffd4\r\u000ea\ufffd\ufffd=\ufffd\ufffd\u007f\ufffd\ufffd-^\r\ufffd1`_\ufffd\t1\t\ufffd\ufffd\ufffd\t\ufffd\u0012\u0151:\ufffdY\ufffd\ufffd-\u0011\ufffdF66!\ufffd\u0012\u0015A\ufffd\ufffd`\u0013\ufffda\ufffd\ufffdC;A\ufffd\ufffd\ufffdNyr4\u07dcU\ufffd\u0013!\u001b\ufffd\ufffd\ufffdGK\u0421\ufffd\u000e\ufffd#\u001b\ufffd\ufffd\ufffd\ufffd\ufffdr:B[G\ufffd3\ufffd\u0006\ufffd.\ufffdL\ufffd\ufffd\u05f6\ufffd\u0010bF\u0015RuM]\ufffd\ufffd\ufffd^\u21f3\ufffd(#Z\ufffd\ufffd\ufffd\u000b\ufffd\u001f\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffd\ufffdB\ufffd\ufffd\u001dB\u0012\ufffdH2S]\ufffd\ufffdu/\ufffd\ufffd\u0017\ufffd\u05bd\ufffd\u0016\ufffdW\ufffdT\ufffdG\ufffd\ufffdn\ufffd\ufffd\ufffdr\ufffd\u0007\n\\ No newline at end of file"}, {"sha": "6d34c61fe0d54ea9ea13046c34302d2f386cbe2f", "filename": "libgo/go/compress/flate/testdata/huffman-text.golden", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,3 @@\n+\u0004\ufffdAK\ufffd0\u0018\u0007\ufffd\ufffd\u001ex\ufffd\u00df\ufffdZ\ufffd\ufffd\ufffdLP\ufffda\ufffd!\ufffdx\ufffd\ufffdAD\ufffd\ufffdI\u0013\ufffd&#I\ufffdE\ufffd\ufffd\ufffd\ufffd\u0006\ufffdp]\ufffd\u001dL\u01bf\ufffd\ufffd\u0016\ufffdF\ufffd\u0018p\ufffd\ufffd\t1\ufffd88\ufffdh\u0007\ufffd\u0013\ufffd$\ufffd\ufffd\ufffd5S\ufffd\ufffd-\t\ufffdF66!\ufffd)v\ufffd.\ufffd\u0002\ufffd0\ufffdY\ufffd\ufffd\u001e\ufffd\u0002\ufffd\ufffd\ufffd\ufffd&\ufffd\ufffd\tS\ufffd\ufffd\ufffdN|\u0012d\ufffd2:\ufffd\ufffd\n+t\ufffd|\u000f\ub44d\ufffd\ufffd\ufffdxz9\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u9aba\ufffd\u001a\u0004\ufffd\ufffd\ufffd\ufffd\u024e\ufffd\u00103\ufffd\ufffd\n+&&=\ufffd\u000e\ufffd\ufffd\ufffd\ufffd\ufffd\u00f4\ufffdUD\ufffd=Fu\ufffd\ufffd\ufffd]\ufffd\ufffdq\ufffd\ufffd\ufffd\ufffdUL+\ufffd\ufffd\u0017\ufffd\ufffd\b\ufffd>FQY\ufffd\ufffdLZ\ufffd\ufffdo\ufffd\ufffd\ufffdfT\u07f5\ufffdE\u0174\ufffd\ufffd{\ufffdY\u02b6b\ufffde\ufffd\u0003\n\\ No newline at end of file"}, {"sha": "73398b98b54554718b5ace738438beb02b5d306f", "filename": "libgo/go/compress/flate/testdata/huffman-text.in", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\r\n+// Use of this source code is governed by a BSD-style\r\n+// license that can be found in the LICENSE file.\r\n+\r\n+package main\r\n+\r\n+import \"os\"\r\n+\r\n+func main() {\r\n+\tvar b = make([]byte, 65535)\r\n+\tf, _ := os.Create(\"huffman-null-max.in\")\r\n+\tf.Write(b)\r\n+}\r"}, {"sha": "d448727c323cafd73bdefa0b3752980f60b6bf7f", "filename": "libgo/go/compress/flate/testdata/huffman-text.wb.expect", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+\u001c\ufffd_K\ufffd0\u001c\ufffd\ufffd\ufffd\u0005\ufffd\u001e\u000e\ufffd\ufffd`K\ufffd\ufffd0Aa\u0017s\u000e\u0011\u011b)^\ufffdH\ufffd\ufffd\ufffd\ufffd\ufffdI\u025fb\u0011\u07fb\ufffd\ufffd_>\ufffd4\r\u000ea\ufffd\ufffd=\ufffd\ufffd\u007f\ufffd\ufffd-^\r\ufffd1`_\ufffd\t1\t\ufffd\ufffd\ufffd\t\ufffd\u0012\u0151:\ufffdY\ufffd\ufffd-\u0011\ufffdF66!\ufffd\u0012\u0015A\ufffd\ufffd`\u0013\ufffda\ufffd\ufffdC;A\ufffd\ufffd\ufffdNyr4\u07dcU\ufffd\u0013!\u001b\ufffd\ufffd\ufffdGK\u0421\ufffd\u000e\ufffd#\u001b\ufffd\ufffd\ufffd\ufffd\ufffdr:B[G\ufffd3\ufffd\u0006\ufffd.\ufffdL\ufffd\ufffd\u05f6\ufffd\u0010bF\u0015RuM]\ufffd\ufffd\ufffd^\u21f3\ufffd(#Z\ufffd\ufffd\ufffd\u000b\ufffd\u001f\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffd\ufffdB\ufffd\ufffd\u001dB\u0012\ufffdH2S]\ufffd\ufffdu/\ufffd\ufffd\u0017\ufffd\u05bd\ufffd\u0016\ufffdW\ufffdT\ufffdG\ufffd\ufffdn\ufffd\ufffd\ufffdr\ufffd\u0007\n\\ No newline at end of file"}, {"sha": "d448727c323cafd73bdefa0b3752980f60b6bf7f", "filename": "libgo/go/compress/flate/testdata/huffman-text.wb.expect-noinput", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-text.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+\u001c\ufffd_K\ufffd0\u001c\ufffd\ufffd\ufffd\u0005\ufffd\u001e\u000e\ufffd\ufffd`K\ufffd\ufffd0Aa\u0017s\u000e\u0011\u011b)^\ufffdH\ufffd\ufffd\ufffd\ufffd\ufffdI\u025fb\u0011\u07fb\ufffd\ufffd_>\ufffd4\r\u000ea\ufffd\ufffd=\ufffd\ufffd\u007f\ufffd\ufffd-^\r\ufffd1`_\ufffd\t1\t\ufffd\ufffd\ufffd\t\ufffd\u0012\u0151:\ufffdY\ufffd\ufffd-\u0011\ufffdF66!\ufffd\u0012\u0015A\ufffd\ufffd`\u0013\ufffda\ufffd\ufffdC;A\ufffd\ufffd\ufffdNyr4\u07dcU\ufffd\u0013!\u001b\ufffd\ufffd\ufffdGK\u0421\ufffd\u000e\ufffd#\u001b\ufffd\ufffd\ufffd\ufffd\ufffdr:B[G\ufffd3\ufffd\u0006\ufffd.\ufffdL\ufffd\ufffd\u05f6\ufffd\u0010bF\u0015RuM]\ufffd\ufffd\ufffd^\u21f3\ufffd(#Z\ufffd\ufffd\ufffd\u000b\ufffd\u001f\ufffd\ufffdi\ufffd\ufffd\ufffd\ufffd\ufffdv\ufffd\ufffdB\ufffd\ufffd\u001dB\u0012\ufffdH2S]\ufffd\ufffdu/\ufffd\ufffd\u0017\ufffd\u05bd\ufffd\u0016\ufffdW\ufffdT\ufffdG\ufffd\ufffdn\ufffd\ufffd\ufffdr\ufffd\u0007\n\\ No newline at end of file"}, {"sha": "830348a79ad9ab38d0edc449e8335c056f7d185f", "filename": "libgo/go/compress/flate/testdata/huffman-zero.dyn.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "830348a79ad9ab38d0edc449e8335c056f7d185f", "filename": "libgo/go/compress/flate/testdata/huffman-zero.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "5abdbaff9a69ad9c71178ba3641fa548818c9030", "filename": "libgo/go/compress/flate/testdata/huffman-zero.golden", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.golden?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "349be0e6ec663ce09e6c2ed9c4efa27ebbbcca3a", "filename": "libgo/go/compress/flate/testdata/huffman-zero.in", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.in?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1 @@\n+00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\\ No newline at end of file"}, {"sha": "dbe401c54c4b6f45f3169376185a476dcf00dde9", "filename": "libgo/go/compress/flate/testdata/huffman-zero.wb.expect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "dbe401c54c4b6f45f3169376185a476dcf00dde9", "filename": "libgo/go/compress/flate/testdata/huffman-zero.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fhuffman-zero.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "8b92d9fc20f1ee1fea5e4cc84d18aeea26a6fdaa", "filename": "libgo/go/compress/flate/testdata/null-long-match.dyn.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.dyn.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.dyn.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.dyn.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "8b92d9fc20f1ee1fea5e4cc84d18aeea26a6fdaa", "filename": "libgo/go/compress/flate/testdata/null-long-match.wb.expect-noinput", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.wb.expect-noinput", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.wb.expect-noinput", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftestdata%2Fnull-long-match.wb.expect-noinput?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ae01391f9cfc3d7b8c4f8623fed3472776b7801b", "filename": "libgo/go/compress/flate/token.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ftoken.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -75,9 +75,6 @@ func matchToken(xlength uint32, xoffset uint32) token {\n \treturn token(matchType + xlength<<lengthShift + xoffset)\n }\n \n-// Returns the type of a token\n-func (t token) typ() uint32 { return uint32(t) & typeMask }\n-\n // Returns the literal of a literal token\n func (t token) literal() uint32 { return uint32(t - literalType) }\n "}, {"sha": "21cd0b22eef5fe6e6185635f74de712c82b59fd9", "filename": "libgo/go/compress/flate/writer_test.go", "status": "modified", "additions": 152, "deletions": 40, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fwriter_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -5,56 +5,168 @@\n package flate\n \n import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"math/rand\"\n \t\"runtime\"\n \t\"testing\"\n )\n \n-func benchmarkEncoder(b *testing.B, testfile, level, n int) {\n-\tb.StopTimer()\n-\tb.SetBytes(int64(n))\n-\tbuf0, err := ioutil.ReadFile(testfiles[testfile])\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tif len(buf0) == 0 {\n-\t\tb.Fatalf(\"test file %q has no data\", testfiles[testfile])\n-\t}\n-\tbuf1 := make([]byte, n)\n-\tfor i := 0; i < n; i += len(buf0) {\n-\t\tif len(buf0) > n-i {\n-\t\t\tbuf0 = buf0[:n-i]\n+func BenchmarkEncode(b *testing.B) {\n+\tdoBench(b, func(b *testing.B, buf0 []byte, level, n int) {\n+\t\tb.StopTimer()\n+\t\tb.SetBytes(int64(n))\n+\n+\t\tbuf1 := make([]byte, n)\n+\t\tfor i := 0; i < n; i += len(buf0) {\n+\t\t\tif len(buf0) > n-i {\n+\t\t\t\tbuf0 = buf0[:n-i]\n+\t\t\t}\n+\t\t\tcopy(buf1[i:], buf0)\n \t\t}\n-\t\tcopy(buf1[i:], buf0)\n-\t}\n-\tbuf0 = nil\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n+\t\tbuf0 = nil\n \t\tw, err := NewWriter(ioutil.Discard, level)\n \t\tif err != nil {\n \t\t\tb.Fatal(err)\n \t\t}\n-\t\tw.Write(buf1)\n-\t\tw.Close()\n+\t\truntime.GC()\n+\t\tb.StartTimer()\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tw.Reset(ioutil.Discard)\n+\t\t\tw.Write(buf1)\n+\t\t\tw.Close()\n+\t\t}\n+\t})\n+}\n+\n+// errorWriter is a writer that fails after N writes.\n+type errorWriter struct {\n+\tN int\n+}\n+\n+func (e *errorWriter) Write(b []byte) (int, error) {\n+\tif e.N <= 0 {\n+\t\treturn 0, io.ErrClosedPipe\n \t}\n+\te.N--\n+\treturn len(b), nil\n }\n \n-func BenchmarkEncodeDigitsSpeed1e4(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e4) }\n-func BenchmarkEncodeDigitsSpeed1e5(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e5) }\n-func BenchmarkEncodeDigitsSpeed1e6(b *testing.B)    { benchmarkEncoder(b, digits, speed, 1e6) }\n-func BenchmarkEncodeDigitsDefault1e4(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e4) }\n-func BenchmarkEncodeDigitsDefault1e5(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e5) }\n-func BenchmarkEncodeDigitsDefault1e6(b *testing.B)  { benchmarkEncoder(b, digits, default_, 1e6) }\n-func BenchmarkEncodeDigitsCompress1e4(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e4) }\n-func BenchmarkEncodeDigitsCompress1e5(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e5) }\n-func BenchmarkEncodeDigitsCompress1e6(b *testing.B) { benchmarkEncoder(b, digits, compress, 1e6) }\n-func BenchmarkEncodeTwainSpeed1e4(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e4) }\n-func BenchmarkEncodeTwainSpeed1e5(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e5) }\n-func BenchmarkEncodeTwainSpeed1e6(b *testing.B)     { benchmarkEncoder(b, twain, speed, 1e6) }\n-func BenchmarkEncodeTwainDefault1e4(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e4) }\n-func BenchmarkEncodeTwainDefault1e5(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e5) }\n-func BenchmarkEncodeTwainDefault1e6(b *testing.B)   { benchmarkEncoder(b, twain, default_, 1e6) }\n-func BenchmarkEncodeTwainCompress1e4(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e4) }\n-func BenchmarkEncodeTwainCompress1e5(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e5) }\n-func BenchmarkEncodeTwainCompress1e6(b *testing.B)  { benchmarkEncoder(b, twain, compress, 1e6) }\n+// Test if errors from the underlying writer is passed upwards.\n+func TestWriteError(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\tn := 65536\n+\tif !testing.Short() {\n+\t\tn *= 4\n+\t}\n+\tfor i := 0; i < n; i++ {\n+\t\tfmt.Fprintf(buf, \"asdasfasf%d%dfghfgujyut%dyutyu\\n\", i, i, i)\n+\t}\n+\tin := buf.Bytes()\n+\t// We create our own buffer to control number of writes.\n+\tcopyBuffer := make([]byte, 128)\n+\tfor l := 0; l < 10; l++ {\n+\t\tfor fail := 1; fail <= 256; fail *= 2 {\n+\t\t\t// Fail after 'fail' writes\n+\t\t\tew := &errorWriter{N: fail}\n+\t\t\tw, err := NewWriter(ew, l)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"NewWriter: level %d: %v\", l, err)\n+\t\t\t}\n+\t\t\tn, err := io.CopyBuffer(w, bytes.NewBuffer(in), copyBuffer)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatalf(\"Level %d: Expected an error, writer was %#v\", l, ew)\n+\t\t\t}\n+\t\t\tn2, err := w.Write([]byte{1, 2, 2, 3, 4, 5})\n+\t\t\tif n2 != 0 {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Expected 0 length write, got\", n)\n+\t\t\t}\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Expected an error\")\n+\t\t\t}\n+\t\t\terr = w.Flush()\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Expected an error on flush\")\n+\t\t\t}\n+\t\t\terr = w.Close()\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Expected an error on close\")\n+\t\t\t}\n+\n+\t\t\tw.Reset(ioutil.Discard)\n+\t\t\tn2, err = w.Write([]byte{1, 2, 3, 4, 5, 6})\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Got unexpected error after reset:\", err)\n+\t\t\t}\n+\t\t\tif n2 == 0 {\n+\t\t\t\tt.Fatal(\"Level\", l, \"Got 0 length write, expected > 0\")\n+\t\t\t}\n+\t\t\tif testing.Short() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// Test if two runs produce identical results\n+// even when writing different sizes to the Writer.\n+func TestDeterministic(t *testing.T) {\n+\tfor i := 0; i <= 9; i++ {\n+\t\tt.Run(fmt.Sprint(\"L\", i), func(t *testing.T) { testDeterministic(i, t) })\n+\t}\n+\tt.Run(\"LM2\", func(t *testing.T) { testDeterministic(-2, t) })\n+}\n+\n+func testDeterministic(i int, t *testing.T) {\n+\t// Test so much we cross a good number of block boundaries.\n+\tvar length = maxStoreBlockSize*30 + 500\n+\tif testing.Short() {\n+\t\tlength /= 10\n+\t}\n+\n+\t// Create a random, but compressible stream.\n+\trng := rand.New(rand.NewSource(1))\n+\tt1 := make([]byte, length)\n+\tfor i := range t1 {\n+\t\tt1[i] = byte(rng.Int63() & 7)\n+\t}\n+\n+\t// Do our first encode.\n+\tvar b1 bytes.Buffer\n+\tbr := bytes.NewBuffer(t1)\n+\tw, err := NewWriter(&b1, i)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Use a very small prime sized buffer.\n+\tcbuf := make([]byte, 787)\n+\t_, err = io.CopyBuffer(w, br, cbuf)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tw.Close()\n+\n+\t// We choose a different buffer size,\n+\t// bigger than a maximum block, and also a prime.\n+\tvar b2 bytes.Buffer\n+\tcbuf = make([]byte, 81761)\n+\tbr2 := bytes.NewBuffer(t1)\n+\tw2, err := NewWriter(&b2, i)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = io.CopyBuffer(w2, br2, cbuf)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tw2.Close()\n+\n+\tb1b := b1.Bytes()\n+\tb2b := b2.Bytes()\n+\n+\tif !bytes.Equal(b1b, b2b) {\n+\t\tt.Errorf(\"level %d did not produce deterministic result, result mismatch, len(a) = %d, len(b) = %d\", i, len(b1b), len(b2b))\n+\t}\n+}"}, {"sha": "7e640692f3f265376f5383f6b41b88563f764308", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 97, "deletions": 119, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -9,8 +9,8 @@ package gzip\n import (\n \t\"bufio\"\n \t\"compress/flate\"\n+\t\"encoding/binary\"\n \t\"errors\"\n-\t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n \t\"time\"\n@@ -27,20 +27,23 @@ const (\n \tflagComment = 1 << 4\n )\n \n-func makeReader(r io.Reader) flate.Reader {\n-\tif rr, ok := r.(flate.Reader); ok {\n-\t\treturn rr\n-\t}\n-\treturn bufio.NewReader(r)\n-}\n-\n var (\n \t// ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n \tErrChecksum = errors.New(\"gzip: invalid checksum\")\n \t// ErrHeader is returned when reading GZIP data that has an invalid header.\n \tErrHeader = errors.New(\"gzip: invalid header\")\n )\n \n+var le = binary.LittleEndian\n+\n+// noEOF converts io.EOF to io.ErrUnexpectedEOF.\n+func noEOF(err error) error {\n+\tif err == io.EOF {\n+\t\treturn io.ErrUnexpectedEOF\n+\t}\n+\treturn err\n+}\n+\n // The gzip file stores a header giving metadata about the compressed file.\n // That header is exposed as the fields of the Writer and Reader structs.\n //\n@@ -58,23 +61,22 @@ type Header struct {\n // uncompressed data from a gzip-format compressed file.\n //\n // In general, a gzip file can be a concatenation of gzip files,\n-// each with its own header.  Reads from the Reader\n+// each with its own header. Reads from the Reader\n // return the concatenation of the uncompressed data of each.\n // Only the first header is recorded in the Reader fields.\n //\n // Gzip files store a length and checksum of the uncompressed data.\n // The Reader will return a ErrChecksum when Read\n // reaches the end of the uncompressed data if it does not\n-// have the expected length or checksum.  Clients should treat data\n+// have the expected length or checksum. Clients should treat data\n // returned by Read as tentative until they receive the io.EOF\n // marking the end of the data.\n type Reader struct {\n \tHeader       // valid after NewReader or Reader.Reset\n \tr            flate.Reader\n \tdecompressor io.ReadCloser\n-\tdigest       hash.Hash32\n-\tsize         uint32\n-\tflg          byte\n+\tdigest       uint32 // CRC-32, IEEE polynomial (section 8)\n+\tsize         uint32 // Uncompressed size (section 2.3.1)\n \tbuf          [512]byte\n \terr          error\n \tmultistream  bool\n@@ -89,10 +91,7 @@ type Reader struct {\n // The Reader.Header fields will be valid in the Reader returned.\n func NewReader(r io.Reader) (*Reader, error) {\n \tz := new(Reader)\n-\tz.r = makeReader(r)\n-\tz.multistream = true\n-\tz.digest = crc32.NewIEEE()\n-\tif err := z.readHeader(true); err != nil {\n+\tif err := z.Reset(r); err != nil {\n \t\treturn nil, err\n \t}\n \treturn z, nil\n@@ -102,16 +101,17 @@ func NewReader(r io.Reader) (*Reader, error) {\n // result of its original state from NewReader, but reading from r instead.\n // This permits reusing a Reader rather than allocating a new one.\n func (z *Reader) Reset(r io.Reader) error {\n-\tz.r = makeReader(r)\n-\tif z.digest == nil {\n-\t\tz.digest = crc32.NewIEEE()\n+\t*z = Reader{\n+\t\tdecompressor: z.decompressor,\n+\t\tmultistream:  true,\n+\t}\n+\tif rr, ok := r.(flate.Reader); ok {\n+\t\tz.r = rr\n \t} else {\n-\t\tz.digest.Reset()\n+\t\tz.r = bufio.NewReader(r)\n \t}\n-\tz.size = 0\n-\tz.err = nil\n-\tz.multistream = true\n-\treturn z.readHeader(true)\n+\tz.Header, z.err = z.readHeader()\n+\treturn z.err\n }\n \n // Multistream controls whether the reader supports multistream files.\n@@ -134,14 +134,13 @@ func (z *Reader) Multistream(ok bool) {\n \tz.multistream = ok\n }\n \n-// GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).\n-func get4(p []byte) uint32 {\n-\treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24\n-}\n-\n+// readString reads a NUL-terminated string from z.r.\n+// It treats the bytes read as being encoded as ISO 8859-1 (Latin-1) and\n+// will output a string encoded using UTF-8.\n+// This method always updates z.digest with the data read.\n func (z *Reader) readString() (string, error) {\n \tvar err error\n-\tneedconv := false\n+\tneedConv := false\n \tfor i := 0; ; i++ {\n \t\tif i >= len(z.buf) {\n \t\t\treturn \"\", ErrHeader\n@@ -151,159 +150,138 @@ func (z *Reader) readString() (string, error) {\n \t\t\treturn \"\", err\n \t\t}\n \t\tif z.buf[i] > 0x7f {\n-\t\t\tneedconv = true\n+\t\t\tneedConv = true\n \t\t}\n \t\tif z.buf[i] == 0 {\n-\t\t\t// GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1).\n-\t\t\tif needconv {\n+\t\t\t// Digest covers the NUL terminator.\n+\t\t\tz.digest = crc32.Update(z.digest, crc32.IEEETable, z.buf[:i+1])\n+\n+\t\t\t// Strings are ISO 8859-1, Latin-1 (RFC 1952, section 2.3.1).\n+\t\t\tif needConv {\n \t\t\t\ts := make([]rune, 0, i)\n-\t\t\t\tfor _, v := range z.buf[0:i] {\n+\t\t\t\tfor _, v := range z.buf[:i] {\n \t\t\t\t\ts = append(s, rune(v))\n \t\t\t\t}\n \t\t\t\treturn string(s), nil\n \t\t\t}\n-\t\t\treturn string(z.buf[0:i]), nil\n-\t\t}\n-\t}\n-}\n-\n-func (z *Reader) read2() (uint32, error) {\n-\t_, err := io.ReadFull(z.r, z.buf[0:2])\n-\tif err != nil {\n-\t\tif err == io.EOF {\n-\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\treturn string(z.buf[:i]), nil\n \t\t}\n-\t\treturn 0, err\n \t}\n-\treturn uint32(z.buf[0]) | uint32(z.buf[1])<<8, nil\n }\n \n-func (z *Reader) readHeader(save bool) error {\n-\t_, err := io.ReadFull(z.r, z.buf[0:10])\n-\tif err != nil {\n-\t\t// RFC1952 section 2.2 says the following:\n+// readHeader reads the GZIP header according to section 2.3.1.\n+// This method does not set z.err.\n+func (z *Reader) readHeader() (hdr Header, err error) {\n+\tif _, err = io.ReadFull(z.r, z.buf[:10]); err != nil {\n+\t\t// RFC 1952, section 2.2, says the following:\n \t\t//\tA gzip file consists of a series of \"members\" (compressed data sets).\n \t\t//\n \t\t// Other than this, the specification does not clarify whether a\n \t\t// \"series\" is defined as \"one or more\" or \"zero or more\". To err on the\n \t\t// side of caution, Go interprets this to mean \"zero or more\".\n \t\t// Thus, it is okay to return io.EOF here.\n-\t\treturn err\n+\t\treturn hdr, err\n \t}\n \tif z.buf[0] != gzipID1 || z.buf[1] != gzipID2 || z.buf[2] != gzipDeflate {\n-\t\treturn ErrHeader\n-\t}\n-\tz.flg = z.buf[3]\n-\tif save {\n-\t\tz.ModTime = time.Unix(int64(get4(z.buf[4:8])), 0)\n-\t\t// z.buf[8] is xfl, ignored\n-\t\tz.OS = z.buf[9]\n+\t\treturn hdr, ErrHeader\n \t}\n-\tz.digest.Reset()\n-\tz.digest.Write(z.buf[0:10])\n+\tflg := z.buf[3]\n+\thdr.ModTime = time.Unix(int64(le.Uint32(z.buf[4:8])), 0)\n+\t// z.buf[8] is XFL and is currently ignored.\n+\thdr.OS = z.buf[9]\n+\tz.digest = crc32.ChecksumIEEE(z.buf[:10])\n \n-\tif z.flg&flagExtra != 0 {\n-\t\tn, err := z.read2()\n-\t\tif err != nil {\n-\t\t\treturn err\n+\tif flg&flagExtra != 0 {\n+\t\tif _, err = io.ReadFull(z.r, z.buf[:2]); err != nil {\n+\t\t\treturn hdr, noEOF(err)\n \t\t}\n-\t\tdata := make([]byte, n)\n+\t\tz.digest = crc32.Update(z.digest, crc32.IEEETable, z.buf[:2])\n+\t\tdata := make([]byte, le.Uint16(z.buf[:2]))\n \t\tif _, err = io.ReadFull(z.r, data); err != nil {\n-\t\t\tif err == io.EOF {\n-\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t}\n-\t\t\treturn err\n-\t\t}\n-\t\tif save {\n-\t\t\tz.Extra = data\n+\t\t\treturn hdr, noEOF(err)\n \t\t}\n+\t\tz.digest = crc32.Update(z.digest, crc32.IEEETable, data)\n+\t\thdr.Extra = data\n \t}\n \n \tvar s string\n-\tif z.flg&flagName != 0 {\n+\tif flg&flagName != 0 {\n \t\tif s, err = z.readString(); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif save {\n-\t\t\tz.Name = s\n+\t\t\treturn hdr, err\n \t\t}\n+\t\thdr.Name = s\n \t}\n \n-\tif z.flg&flagComment != 0 {\n+\tif flg&flagComment != 0 {\n \t\tif s, err = z.readString(); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif save {\n-\t\t\tz.Comment = s\n+\t\t\treturn hdr, err\n \t\t}\n+\t\thdr.Comment = s\n \t}\n \n-\tif z.flg&flagHdrCrc != 0 {\n-\t\tn, err := z.read2()\n-\t\tif err != nil {\n-\t\t\treturn err\n+\tif flg&flagHdrCrc != 0 {\n+\t\tif _, err = io.ReadFull(z.r, z.buf[:2]); err != nil {\n+\t\t\treturn hdr, noEOF(err)\n \t\t}\n-\t\tsum := z.digest.Sum32() & 0xFFFF\n-\t\tif n != sum {\n-\t\t\treturn ErrHeader\n+\t\tdigest := le.Uint16(z.buf[:2])\n+\t\tif digest != uint16(z.digest) {\n+\t\t\treturn hdr, ErrHeader\n \t\t}\n \t}\n \n-\tz.digest.Reset()\n+\tz.digest = 0\n \tif z.decompressor == nil {\n \t\tz.decompressor = flate.NewReader(z.r)\n \t} else {\n \t\tz.decompressor.(flate.Resetter).Reset(z.r, nil)\n \t}\n-\treturn nil\n+\treturn hdr, nil\n }\n \n func (z *Reader) Read(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n-\tif len(p) == 0 {\n-\t\treturn 0, nil\n-\t}\n \n-\tn, err = z.decompressor.Read(p)\n-\tz.digest.Write(p[0:n])\n+\tn, z.err = z.decompressor.Read(p)\n+\tz.digest = crc32.Update(z.digest, crc32.IEEETable, p[:n])\n \tz.size += uint32(n)\n-\tif n != 0 || err != io.EOF {\n-\t\tz.err = err\n-\t\treturn\n+\tif z.err != io.EOF {\n+\t\t// In the normal case we return here.\n+\t\treturn n, z.err\n \t}\n \n-\t// Finished file; check checksum + size.\n-\tif _, err := io.ReadFull(z.r, z.buf[0:8]); err != nil {\n-\t\tif err == io.EOF {\n-\t\t\terr = io.ErrUnexpectedEOF\n-\t\t}\n-\t\tz.err = err\n-\t\treturn 0, err\n+\t// Finished file; check checksum and size.\n+\tif _, err := io.ReadFull(z.r, z.buf[:8]); err != nil {\n+\t\tz.err = noEOF(err)\n+\t\treturn n, z.err\n \t}\n-\tcrc32, isize := get4(z.buf[0:4]), get4(z.buf[4:8])\n-\tsum := z.digest.Sum32()\n-\tif sum != crc32 || isize != z.size {\n+\tdigest := le.Uint32(z.buf[:4])\n+\tsize := le.Uint32(z.buf[4:8])\n+\tif digest != z.digest || size != z.size {\n \t\tz.err = ErrChecksum\n-\t\treturn 0, z.err\n+\t\treturn n, z.err\n \t}\n+\tz.digest, z.size = 0, 0\n \n-\t// File is ok; is there another?\n+\t// File is ok; check if there is another.\n \tif !z.multistream {\n-\t\treturn 0, io.EOF\n+\t\treturn n, io.EOF\n \t}\n+\tz.err = nil // Remove io.EOF\n \n-\tif err = z.readHeader(false); err != nil {\n-\t\tz.err = err\n-\t\treturn\n+\tif _, z.err = z.readHeader(); z.err != nil {\n+\t\treturn n, z.err\n \t}\n \n-\t// Yes.  Reset and read from it.\n-\tz.digest.Reset()\n-\tz.size = 0\n+\t// Read from next file, if necessary.\n+\tif n > 0 {\n+\t\treturn n, nil\n+\t}\n \treturn z.Read(p)\n }\n \n // Close closes the Reader. It does not close the underlying io.Reader.\n+// In order for the GZIP checksum to be verified, the reader must be\n+// fully consumed until the io.EOF.\n func (z *Reader) Close() error { return z.decompressor.Close() }"}, {"sha": "fdce91989a614027bf30aab668a3a9b1f053467b", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 81, "deletions": 31, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -36,6 +36,17 @@ var gunzipTests = []gunzipTest{\n \t\t},\n \t\tnil,\n \t},\n+\t{\n+\t\t\"\",\n+\t\t\"empty - with no file name\",\n+\t\t\"\",\n+\t\t[]byte{\n+\t\t\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88,\n+\t\t\t0x00, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x00,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t},\n+\t\tnil,\n+\t},\n \t{ // has 1 non-empty fixed huffman block\n \t\t\"hello.txt\",\n \t\t\"hello.txt\",\n@@ -281,49 +292,102 @@ var gunzipTests = []gunzipTest{\n \t\t},\n \t\tErrChecksum,\n \t},\n+\t{\n+\t\t\"f1l3n4m3.tXt\",\n+\t\t\"header with all fields used\",\n+\t\t\"\",\n+\t\t[]byte{\n+\t\t\t0x1f, 0x8b, 0x08, 0x1e, 0x70, 0xf0, 0xf9, 0x4a,\n+\t\t\t0x00, 0xaa, 0x09, 0x00, 0x7a, 0x7a, 0x05, 0x00,\n+\t\t\t0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x31, 0x6c,\n+\t\t\t0x33, 0x6e, 0x34, 0x6d, 0x33, 0x2e, 0x74, 0x58,\n+\t\t\t0x74, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n+\t\t\t0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,\n+\t\t\t0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n+\t\t\t0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,\n+\t\t\t0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n+\t\t\t0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,\n+\t\t\t0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n+\t\t\t0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,\n+\t\t\t0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,\n+\t\t\t0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e,\n+\t\t\t0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,\n+\t\t\t0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e,\n+\t\t\t0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\n+\t\t\t0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,\n+\t\t\t0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\n+\t\t\t0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,\n+\t\t\t0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,\n+\t\t\t0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,\n+\t\t\t0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n+\t\t\t0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e,\n+\t\t\t0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,\n+\t\t\t0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae,\n+\t\t\t0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n+\t\t\t0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe,\n+\t\t\t0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,\n+\t\t\t0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce,\n+\t\t\t0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,\n+\t\t\t0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,\n+\t\t\t0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,\n+\t\t\t0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee,\n+\t\t\t0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,\n+\t\t\t0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe,\n+\t\t\t0xff, 0x00, 0x92, 0xfd, 0x01, 0x00, 0x00, 0xff,\n+\t\t\t0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00,\n+\t\t},\n+\t\tnil,\n+\t},\n }\n \n func TestDecompressor(t *testing.T) {\n+\t// Keep resetting this reader.\n+\t// It is intended behavior that Reader.Reset can be called on a zero-value\n+\t// Reader and be the equivalent as if NewReader was used instead.\n+\tr1 := new(Reader)\n+\n \tb := new(bytes.Buffer)\n \tfor _, tt := range gunzipTests {\n+\t\t// Test NewReader.\n \t\tin := bytes.NewReader(tt.gzip)\n-\t\tgzip, err := NewReader(in)\n+\t\tr2, err := NewReader(in)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: NewReader: %s\", tt.name, err)\n+\t\t\tt.Errorf(\"%s: NewReader: %s\", tt.desc, err)\n \t\t\tcontinue\n \t\t}\n-\t\tdefer gzip.Close()\n-\t\tif tt.name != gzip.Name {\n-\t\t\tt.Errorf(\"%s: got name %s\", tt.name, gzip.Name)\n+\t\tdefer r2.Close()\n+\t\tif tt.name != r2.Name {\n+\t\t\tt.Errorf(\"%s: got name %s\", tt.desc, r2.Name)\n \t\t}\n \t\tb.Reset()\n-\t\tn, err := io.Copy(b, gzip)\n+\t\tn, err := io.Copy(b, r2)\n \t\tif err != tt.err {\n-\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.name, err, tt.err)\n+\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n \t\t}\n \t\ts := b.String()\n \t\tif s != tt.raw {\n-\t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.name, n, s, len(tt.raw), tt.raw)\n+\t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.desc, n, s, len(tt.raw), tt.raw)\n \t\t}\n \n-\t\t// Test Reader Reset.\n+\t\t// Test Reader.Reset.\n \t\tin = bytes.NewReader(tt.gzip)\n-\t\terr = gzip.Reset(in)\n+\t\terr = r1.Reset(in)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: Reset: %s\", tt.name, err)\n+\t\t\tt.Errorf(\"%s: Reset: %s\", tt.desc, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif tt.name != gzip.Name {\n-\t\t\tt.Errorf(\"%s: got name %s\", tt.name, gzip.Name)\n+\t\tif tt.name != r1.Name {\n+\t\t\tt.Errorf(\"%s: got name %s\", tt.desc, r1.Name)\n \t\t}\n \t\tb.Reset()\n-\t\tn, err = io.Copy(b, gzip)\n+\t\tn, err = io.Copy(b, r1)\n \t\tif err != tt.err {\n-\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.name, err, tt.err)\n+\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n \t\t}\n \t\ts = b.String()\n \t\tif s != tt.raw {\n-\t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.name, n, s, len(tt.raw), tt.raw)\n+\t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.desc, n, s, len(tt.raw), tt.raw)\n \t\t}\n \t}\n }\n@@ -356,20 +420,6 @@ func TestIssue6550(t *testing.T) {\n \t}\n }\n \n-func TestInitialReset(t *testing.T) {\n-\tvar r Reader\n-\tif err := r.Reset(bytes.NewReader(gunzipTests[1].gzip)); err != nil {\n-\t\tt.Error(err)\n-\t}\n-\tvar buf bytes.Buffer\n-\tif _, err := io.Copy(&buf, &r); err != nil {\n-\t\tt.Error(err)\n-\t}\n-\tif s := buf.String(); s != gunzipTests[1].raw {\n-\t\tt.Errorf(\"got %q want %q\", s, gunzipTests[1].raw)\n-\t}\n-}\n-\n func TestMultistreamFalse(t *testing.T) {\n \t// Find concatenation test.\n \tvar tt gunzipTest\n@@ -411,7 +461,7 @@ Found:\n }\n \n func TestNilStream(t *testing.T) {\n-\t// Go liberally interprets RFC1952 section 2.2 to mean that a gzip file\n+\t// Go liberally interprets RFC 1952 section 2.2 to mean that a gzip file\n \t// consist of zero or more members. Thus, we test that a nil stream is okay.\n \t_, err := NewReader(bytes.NewReader(nil))\n \tif err != io.EOF {"}, {"sha": "c702c493c11ef20861d49c531e59062011465224", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"compress/flate\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n )\n@@ -30,8 +29,8 @@ type Writer struct {\n \tlevel       int\n \twroteHeader bool\n \tcompressor  *flate.Writer\n-\tdigest      hash.Hash32\n-\tsize        uint32\n+\tdigest      uint32 // CRC-32, IEEE polynomial (section 8)\n+\tsize        uint32 // Uncompressed size (section 2.3.1)\n \tclosed      bool\n \tbuf         [10]byte\n \terr         error\n@@ -66,12 +65,6 @@ func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n }\n \n func (z *Writer) init(w io.Writer, level int) {\n-\tdigest := z.digest\n-\tif digest != nil {\n-\t\tdigest.Reset()\n-\t} else {\n-\t\tdigest = crc32.NewIEEE()\n-\t}\n \tcompressor := z.compressor\n \tif compressor != nil {\n \t\tcompressor.Reset(w)\n@@ -82,7 +75,6 @@ func (z *Writer) init(w io.Writer, level int) {\n \t\t},\n \t\tw:          w,\n \t\tlevel:      level,\n-\t\tdigest:     digest,\n \t\tcompressor: compressor,\n \t}\n }\n@@ -95,26 +87,13 @@ func (z *Writer) Reset(w io.Writer) {\n \tz.init(w, z.level)\n }\n \n-// GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).\n-func put2(p []byte, v uint16) {\n-\tp[0] = uint8(v >> 0)\n-\tp[1] = uint8(v >> 8)\n-}\n-\n-func put4(p []byte, v uint32) {\n-\tp[0] = uint8(v >> 0)\n-\tp[1] = uint8(v >> 8)\n-\tp[2] = uint8(v >> 16)\n-\tp[3] = uint8(v >> 24)\n-}\n-\n // writeBytes writes a length-prefixed byte slice to z.w.\n func (z *Writer) writeBytes(b []byte) error {\n \tif len(b) > 0xffff {\n \t\treturn errors.New(\"gzip.Write: Extra data is too large\")\n \t}\n-\tput2(z.buf[0:2], uint16(len(b)))\n-\t_, err := z.w.Write(z.buf[0:2])\n+\tle.PutUint16(z.buf[:2], uint16(len(b)))\n+\t_, err := z.w.Write(z.buf[:2])\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -149,7 +128,7 @@ func (z *Writer) writeString(s string) (err error) {\n \t}\n \t// GZIP strings are NUL-terminated.\n \tz.buf[0] = 0\n-\t_, err = z.w.Write(z.buf[0:1])\n+\t_, err = z.w.Write(z.buf[:1])\n \treturn err\n }\n \n@@ -176,7 +155,7 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t\tif z.Comment != \"\" {\n \t\t\tz.buf[3] |= 0x10\n \t\t}\n-\t\tput4(z.buf[4:8], uint32(z.ModTime.Unix()))\n+\t\tle.PutUint32(z.buf[4:8], uint32(z.ModTime.Unix()))\n \t\tif z.level == BestCompression {\n \t\t\tz.buf[8] = 2\n \t\t} else if z.level == BestSpeed {\n@@ -185,7 +164,7 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t\t\tz.buf[8] = 0\n \t\t}\n \t\tz.buf[9] = z.OS\n-\t\tn, z.err = z.w.Write(z.buf[0:10])\n+\t\tn, z.err = z.w.Write(z.buf[:10])\n \t\tif z.err != nil {\n \t\t\treturn n, z.err\n \t\t}\n@@ -212,7 +191,7 @@ func (z *Writer) Write(p []byte) (int, error) {\n \t\t}\n \t}\n \tz.size += uint32(len(p))\n-\tz.digest.Write(p)\n+\tz.digest = crc32.Update(z.digest, crc32.IEEETable, p)\n \tn, z.err = z.compressor.Write(p)\n \treturn n, z.err\n }\n@@ -262,8 +241,8 @@ func (z *Writer) Close() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}\n-\tput4(z.buf[0:4], z.digest.Sum32())\n-\tput4(z.buf[4:8], z.size)\n-\t_, z.err = z.w.Write(z.buf[0:8])\n+\tle.PutUint32(z.buf[:4], z.digest)\n+\tle.PutUint32(z.buf[4:8], z.size)\n+\t_, z.err = z.w.Write(z.buf[:8])\n \treturn z.err\n }"}, {"sha": "432ad16b1c206606f6e25c89d6215fc0f3a4b315", "filename": "libgo/go/compress/gzip/issue14937_test.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fissue14937_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,59 @@\n+package gzip\n+\n+import (\n+\t\"internal/testenv\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+// Per golang.org/issue/14937, check that every .gz file\n+// in the tree has a zero mtime.\n+func TestGZIPFilesHaveZeroMTimes(t *testing.T) {\n+\tif testing.Short() && testenv.Builder() == \"\" {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\tvar files []string\n+\terr := filepath.Walk(runtime.GOROOT(), func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif !info.IsDir() && strings.HasSuffix(path, \".gz\") {\n+\t\t\tfiles = append(files, path)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\tt.Skipf(\"skipping: GOROOT directory not found: %s\", runtime.GOROOT())\n+\t\t}\n+\t\tt.Fatal(\"error collecting list of .gz files in GOROOT: \", err)\n+\t}\n+\tif len(files) == 0 {\n+\t\tt.Fatal(\"expected to find some .gz files under GOROOT\")\n+\t}\n+\tfor _, path := range files {\n+\t\tcheckZeroMTime(t, path)\n+\t}\n+}\n+\n+func checkZeroMTime(t *testing.T, path string) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tdefer f.Close()\n+\tgz, err := NewReader(f)\n+\tif err != nil {\n+\t\tt.Errorf(\"cannot read gzip file %s: %s\", path, err)\n+\t\treturn\n+\t}\n+\tdefer gz.Close()\n+\tif !gz.ModTime.Equal(time.Unix(0, 0)) {\n+\t\tt.Errorf(\"gzip file %s has non-zero mtime (%s)\", path, gz.ModTime)\n+\t}\n+}"}, {"sha": "6b9f9a3da7035ddc80203c5b4730bc0f5d93eda0", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -6,8 +6,10 @@ package lzw\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"math\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n@@ -118,42 +120,37 @@ func TestReader(t *testing.T) {\n \t}\n }\n \n-func benchmarkDecoder(b *testing.B, n int) {\n-\tb.StopTimer()\n-\tb.SetBytes(int64(n))\n-\tbuf0, err := ioutil.ReadFile(\"../testdata/e.txt\")\n+func BenchmarkDecoder(b *testing.B) {\n+\tbuf, err := ioutil.ReadFile(\"../testdata/e.txt\")\n \tif err != nil {\n \t\tb.Fatal(err)\n \t}\n-\tif len(buf0) == 0 {\n+\tif len(buf) == 0 {\n \t\tb.Fatalf(\"test file has no data\")\n \t}\n-\tcompressed := new(bytes.Buffer)\n-\tw := NewWriter(compressed, LSB, 8)\n-\tfor i := 0; i < n; i += len(buf0) {\n-\t\tif len(buf0) > n-i {\n-\t\t\tbuf0 = buf0[:n-i]\n-\t\t}\n-\t\tw.Write(buf0)\n-\t}\n-\tw.Close()\n-\tbuf1 := compressed.Bytes()\n-\tbuf0, compressed, w = nil, nil, nil\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewReader(buf1), LSB, 8))\n-\t}\n-}\n-\n-func BenchmarkDecoder1e4(b *testing.B) {\n-\tbenchmarkDecoder(b, 1e4)\n-}\n \n-func BenchmarkDecoder1e5(b *testing.B) {\n-\tbenchmarkDecoder(b, 1e5)\n-}\n-\n-func BenchmarkDecoder1e6(b *testing.B) {\n-\tbenchmarkDecoder(b, 1e6)\n+\tfor e := 4; e <= 6; e++ {\n+\t\tn := int(math.Pow10(e))\n+\t\tb.Run(fmt.Sprint(\"1e\", e), func(b *testing.B) {\n+\t\t\tb.StopTimer()\n+\t\t\tb.SetBytes(int64(n))\n+\t\t\tbuf0 := buf\n+\t\t\tcompressed := new(bytes.Buffer)\n+\t\t\tw := NewWriter(compressed, LSB, 8)\n+\t\t\tfor i := 0; i < n; i += len(buf0) {\n+\t\t\t\tif len(buf0) > n-i {\n+\t\t\t\t\tbuf0 = buf0[:n-i]\n+\t\t\t\t}\n+\t\t\t\tw.Write(buf0)\n+\t\t\t}\n+\t\t\tw.Close()\n+\t\t\tbuf1 := compressed.Bytes()\n+\t\t\tbuf0, compressed, w = nil, nil, nil\n+\t\t\truntime.GC()\n+\t\t\tb.StartTimer()\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewReader(buf1), LSB, 8))\n+\t\t\t}\n+\t\t})\n+\t}\n }"}, {"sha": "6ddb335f31523ba7b3d2ec45a37490663fa9a9fc", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -119,7 +119,7 @@ func (e *encoder) incHi() error {\n \t\tif err := e.write(e, clear); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\te.width = uint(e.litWidth) + 1\n+\t\te.width = e.litWidth + 1\n \t\te.hi = clear + 1\n \t\te.overflow = clear << 1\n \t\tfor i := range e.table {"}, {"sha": "4979f8b35211397dddaa3d8d2b665e5967b457c8", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -5,9 +5,11 @@\n package lzw\n \n import (\n+\t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"math\"\n \t\"os\"\n \t\"runtime\"\n \t\"testing\"\n@@ -122,41 +124,34 @@ func TestSmallLitWidth(t *testing.T) {\n \t}\n }\n \n-func benchmarkEncoder(b *testing.B, n int) {\n-\tb.StopTimer()\n-\tb.SetBytes(int64(n))\n-\tbuf0, err := ioutil.ReadFile(\"../testdata/e.txt\")\n+func BenchmarkEncoder(b *testing.B) {\n+\tbuf, err := ioutil.ReadFile(\"../testdata/e.txt\")\n \tif err != nil {\n \t\tb.Fatal(err)\n \t}\n-\tif len(buf0) == 0 {\n+\tif len(buf) == 0 {\n \t\tb.Fatalf(\"test file has no data\")\n \t}\n-\tbuf1 := make([]byte, n)\n-\tfor i := 0; i < n; i += len(buf0) {\n-\t\tif len(buf0) > n-i {\n-\t\t\tbuf0 = buf0[:n-i]\n+\n+\tfor e := 4; e <= 6; e++ {\n+\t\tn := int(math.Pow10(e))\n+\t\tbuf0 := buf\n+\t\tbuf1 := make([]byte, n)\n+\t\tfor i := 0; i < n; i += len(buf0) {\n+\t\t\tif len(buf0) > n-i {\n+\t\t\t\tbuf0 = buf0[:n-i]\n+\t\t\t}\n+\t\t\tcopy(buf1[i:], buf0)\n \t\t}\n-\t\tcopy(buf1[i:], buf0)\n-\t}\n-\tbuf0 = nil\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tw := NewWriter(ioutil.Discard, LSB, 8)\n-\t\tw.Write(buf1)\n-\t\tw.Close()\n+\t\tbuf0 = nil\n+\t\truntime.GC()\n+\t\tb.Run(fmt.Sprint(\"1e\", e), func(b *testing.B) {\n+\t\t\tb.SetBytes(int64(n))\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tw := NewWriter(ioutil.Discard, LSB, 8)\n+\t\t\t\tw.Write(buf1)\n+\t\t\t\tw.Close()\n+\t\t\t}\n+\t\t})\n \t}\n }\n-\n-func BenchmarkEncoder1e4(b *testing.B) {\n-\tbenchmarkEncoder(b, 1e4)\n-}\n-\n-func BenchmarkEncoder1e5(b *testing.B) {\n-\tbenchmarkEncoder(b, 1e5)\n-}\n-\n-func BenchmarkEncoder1e6(b *testing.B) {\n-\tbenchmarkEncoder(b, 1e6)\n-}"}, {"sha": "2efa1930354585aaa02367b37c1e9025457abae6", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -62,7 +62,8 @@ type Resetter interface {\n \n // NewReader creates a new ReadCloser.\n // Reads from the returned ReadCloser read and decompress data from r.\n-// The implementation buffers input and may read more data than necessary from r.\n+// If r does not implement io.ByteReader, the decompressor may read more\n+// data than necessary from r.\n // It is the caller's responsibility to call Close on the ReadCloser when done.\n //\n // The ReadCloser returned by NewReader also implements Resetter.\n@@ -84,19 +85,17 @@ func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error) {\n \treturn z, nil\n }\n \n-func (z *reader) Read(p []byte) (n int, err error) {\n+func (z *reader) Read(p []byte) (int, error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n-\tif len(p) == 0 {\n-\t\treturn 0, nil\n-\t}\n \n-\tn, err = z.decompressor.Read(p)\n+\tvar n int\n+\tn, z.err = z.decompressor.Read(p)\n \tz.digest.Write(p[0:n])\n-\tif n != 0 || err != io.EOF {\n-\t\tz.err = err\n-\t\treturn\n+\tif z.err != io.EOF {\n+\t\t// In the normal case we return here.\n+\t\treturn n, z.err\n \t}\n \n \t// Finished file; check checksum.\n@@ -105,57 +104,65 @@ func (z *reader) Read(p []byte) (n int, err error) {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n \t\tz.err = err\n-\t\treturn 0, err\n+\t\treturn n, z.err\n \t}\n \t// ZLIB (RFC 1950) is big-endian, unlike GZIP (RFC 1952).\n \tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n \tif checksum != z.digest.Sum32() {\n \t\tz.err = ErrChecksum\n-\t\treturn 0, z.err\n+\t\treturn n, z.err\n \t}\n-\treturn\n+\treturn n, io.EOF\n }\n \n // Calling Close does not close the wrapped io.Reader originally passed to NewReader.\n+// In order for the ZLIB checksum to be verified, the reader must be\n+// fully consumed until the io.EOF.\n func (z *reader) Close() error {\n-\tif z.err != nil {\n+\tif z.err != nil && z.err != io.EOF {\n \t\treturn z.err\n \t}\n \tz.err = z.decompressor.Close()\n \treturn z.err\n }\n \n func (z *reader) Reset(r io.Reader, dict []byte) error {\n+\t*z = reader{decompressor: z.decompressor}\n \tif fr, ok := r.(flate.Reader); ok {\n \t\tz.r = fr\n \t} else {\n \t\tz.r = bufio.NewReader(r)\n \t}\n-\t_, err := io.ReadFull(z.r, z.scratch[0:2])\n-\tif err != nil {\n-\t\tif err == io.EOF {\n-\t\t\terr = io.ErrUnexpectedEOF\n+\n+\t// Read the header (RFC 1950 section 2.2.).\n+\t_, z.err = io.ReadFull(z.r, z.scratch[0:2])\n+\tif z.err != nil {\n+\t\tif z.err == io.EOF {\n+\t\t\tz.err = io.ErrUnexpectedEOF\n \t\t}\n-\t\treturn err\n+\t\treturn z.err\n \t}\n \th := uint(z.scratch[0])<<8 | uint(z.scratch[1])\n \tif (z.scratch[0]&0x0f != zlibDeflate) || (h%31 != 0) {\n-\t\treturn ErrHeader\n+\t\tz.err = ErrHeader\n+\t\treturn z.err\n \t}\n \thaveDict := z.scratch[1]&0x20 != 0\n \tif haveDict {\n-\t\t_, err = io.ReadFull(z.r, z.scratch[0:4])\n-\t\tif err != nil {\n-\t\t\tif err == io.EOF {\n-\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t_, z.err = io.ReadFull(z.r, z.scratch[0:4])\n+\t\tif z.err != nil {\n+\t\t\tif z.err == io.EOF {\n+\t\t\t\tz.err = io.ErrUnexpectedEOF\n \t\t\t}\n-\t\t\treturn err\n+\t\t\treturn z.err\n \t\t}\n \t\tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n \t\tif checksum != adler32.Checksum(dict) {\n-\t\t\treturn ErrDictionary\n+\t\t\tz.err = ErrDictionary\n+\t\t\treturn z.err\n \t\t}\n \t}\n+\n \tif z.decompressor == nil {\n \t\tif haveDict {\n \t\t\tz.decompressor = flate.NewReaderDict(z.r, dict)"}, {"sha": "f74bff1f3cc6e9acce076d8eb8cd595b5b03f9b2", "filename": "libgo/go/compress/zlib/reader_test.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -127,16 +127,18 @@ func TestDecompressor(t *testing.T) {\n \tb := new(bytes.Buffer)\n \tfor _, tt := range zlibTests {\n \t\tin := bytes.NewReader(tt.compressed)\n-\t\tzlib, err := NewReaderDict(in, tt.dict)\n+\t\tzr, err := NewReaderDict(in, tt.dict)\n \t\tif err != nil {\n \t\t\tif err != tt.err {\n \t\t\t\tt.Errorf(\"%s: NewReader: %s\", tt.desc, err)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\tdefer zlib.Close()\n+\t\tdefer zr.Close()\n+\n+\t\t// Read and verify correctness of data.\n \t\tb.Reset()\n-\t\tn, err := io.Copy(b, zlib)\n+\t\tn, err := io.Copy(b, zr)\n \t\tif err != nil {\n \t\t\tif err != tt.err {\n \t\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n@@ -147,5 +149,13 @@ func TestDecompressor(t *testing.T) {\n \t\tif s != tt.raw {\n \t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.desc, n, s, len(tt.raw), tt.raw)\n \t\t}\n+\n+\t\t// Check for sticky errors.\n+\t\tif n, err := zr.Read([]byte{0}); n != 0 || err != io.EOF {\n+\t\t\tt.Errorf(\"%s: Read() = (%d, %v), want (0, io.EOF)\", tt.desc, n, err)\n+\t\t}\n+\t\tif err := zr.Close(); err != nil {\n+\t\t\tt.Errorf(\"%s: Close() = %v, want nil\", tt.desc, err)\n+\t\t}\n \t}\n }"}, {"sha": "5fe23b95372bd42e835a81e2989438e39ed7242f", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -25,7 +25,7 @@ import \"sort\"\n //\t!h.Less(j, i) for 0 <= i < h.Len() and 2*i+1 <= j <= 2*i+2 and j < h.Len()\n //\n // Note that Push and Pop in this interface are for package heap's\n-// implementation to call.  To add and remove things from the heap,\n+// implementation to call. To add and remove things from the heap,\n // use heap.Push and heap.Pop.\n type Interface interface {\n \tsort.Interface"}, {"sha": "d41110422e9fe2c9f140bb8df64578ac89e9196f", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -173,7 +173,7 @@ func TestRemove2(t *testing.T) {\n \n func BenchmarkDup(b *testing.B) {\n \tconst n = 10000\n-\th := make(myHeap, n)\n+\th := make(myHeap, 0, n)\n \tfor i := 0; i < b.N; i++ {\n \t\tfor j := 0; j < n; j++ {\n \t\t\tPush(&h, 0) // all elements are the same"}, {"sha": "e3bfe53a4981fad9950aed2dba320227b5c39be5", "filename": "libgo/go/container/list/list_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -326,7 +326,7 @@ func TestInsertAfterUnknownMark(t *testing.T) {\n }\n \n // Test that a list l is not modified when calling MoveAfter or MoveBefore with a mark that is not an element of l.\n-func TestMoveUnkownMark(t *testing.T) {\n+func TestMoveUnknownMark(t *testing.T) {\n \tvar l1 List\n \te1 := l1.PushBack(1)\n "}, {"sha": "f8ce9ccdb85254b38e7dbadb7163b62a793750a4", "filename": "libgo/go/context/context.go", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,473 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package context defines the Context type, which carries deadlines,\n+// cancelation signals, and other request-scoped values across API boundaries\n+// and between processes.\n+//\n+// Incoming requests to a server should create a Context, and outgoing\n+// calls to servers should accept a Context. The chain of function\n+// calls between them must propagate the Context, optionally replacing\n+// it with a derived Context created using WithCancel, WithDeadline,\n+// WithTimeout, or WithValue. When a Context is canceled, all\n+// Contexts derived from it are also canceled.\n+//\n+// The WithCancel, WithDeadline, and WithTimeout functions take a\n+// Context (the parent) and return a derived Context (the child) and a\n+// CancelFunc. Calling the CancelFunc cancels the child and its\n+// children, removes the parent's reference to the child, and stops\n+// any associated timers. Failing to call the CancelFunc leaks the\n+// child and its children until the parent is canceled or the timer\n+// fires. The go vet tool checks that CancelFuncs are used on all\n+// control-flow paths.\n+//\n+// Programs that use Contexts should follow these rules to keep interfaces\n+// consistent across packages and enable static analysis tools to check context\n+// propagation:\n+//\n+// Do not store Contexts inside a struct type; instead, pass a Context\n+// explicitly to each function that needs it. The Context should be the first\n+// parameter, typically named ctx:\n+//\n+// \tfunc DoSomething(ctx context.Context, arg Arg) error {\n+// \t\t// ... use ctx ...\n+// \t}\n+//\n+// Do not pass a nil Context, even if a function permits it. Pass context.TODO\n+// if you are unsure about which Context to use.\n+//\n+// Use context Values only for request-scoped data that transits processes and\n+// APIs, not for passing optional parameters to functions.\n+//\n+// The same Context may be passed to functions running in different goroutines;\n+// Contexts are safe for simultaneous use by multiple goroutines.\n+//\n+// See https://blog.golang.org/context for example code for a server that uses\n+// Contexts.\n+package context\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+// A Context carries a deadline, a cancelation signal, and other values across\n+// API boundaries.\n+//\n+// Context's methods may be called by multiple goroutines simultaneously.\n+type Context interface {\n+\t// Deadline returns the time when work done on behalf of this context\n+\t// should be canceled. Deadline returns ok==false when no deadline is\n+\t// set. Successive calls to Deadline return the same results.\n+\tDeadline() (deadline time.Time, ok bool)\n+\n+\t// Done returns a channel that's closed when work done on behalf of this\n+\t// context should be canceled. Done may return nil if this context can\n+\t// never be canceled. Successive calls to Done return the same value.\n+\t//\n+\t// WithCancel arranges for Done to be closed when cancel is called;\n+\t// WithDeadline arranges for Done to be closed when the deadline\n+\t// expires; WithTimeout arranges for Done to be closed when the timeout\n+\t// elapses.\n+\t//\n+\t// Done is provided for use in select statements:\n+\t//\n+\t//  // Stream generates values with DoSomething and sends them to out\n+\t//  // until DoSomething returns an error or ctx.Done is closed.\n+\t//  func Stream(ctx context.Context, out chan<- Value) error {\n+\t//  \tfor {\n+\t//  \t\tv, err := DoSomething(ctx)\n+\t//  \t\tif err != nil {\n+\t//  \t\t\treturn err\n+\t//  \t\t}\n+\t//  \t\tselect {\n+\t//  \t\tcase <-ctx.Done():\n+\t//  \t\t\treturn ctx.Err()\n+\t//  \t\tcase out <- v:\n+\t//  \t\t}\n+\t//  \t}\n+\t//  }\n+\t//\n+\t// See https://blog.golang.org/pipelines for more examples of how to use\n+\t// a Done channel for cancelation.\n+\tDone() <-chan struct{}\n+\n+\t// Err returns a non-nil error value after Done is closed. Err returns\n+\t// Canceled if the context was canceled or DeadlineExceeded if the\n+\t// context's deadline passed. No other values for Err are defined.\n+\t// After Done is closed, successive calls to Err return the same value.\n+\tErr() error\n+\n+\t// Value returns the value associated with this context for key, or nil\n+\t// if no value is associated with key. Successive calls to Value with\n+\t// the same key returns the same result.\n+\t//\n+\t// Use context values only for request-scoped data that transits\n+\t// processes and API boundaries, not for passing optional parameters to\n+\t// functions.\n+\t//\n+\t// A key identifies a specific value in a Context. Functions that wish\n+\t// to store values in Context typically allocate a key in a global\n+\t// variable then use that key as the argument to context.WithValue and\n+\t// Context.Value. A key can be any type that supports equality;\n+\t// packages should define keys as an unexported type to avoid\n+\t// collisions.\n+\t//\n+\t// Packages that define a Context key should provide type-safe accessors\n+\t// for the values stored using that key:\n+\t//\n+\t// \t// Package user defines a User type that's stored in Contexts.\n+\t// \tpackage user\n+\t//\n+\t// \timport \"context\"\n+\t//\n+\t// \t// User is the type of value stored in the Contexts.\n+\t// \ttype User struct {...}\n+\t//\n+\t// \t// key is an unexported type for keys defined in this package.\n+\t// \t// This prevents collisions with keys defined in other packages.\n+\t// \ttype key int\n+\t//\n+\t// \t// userKey is the key for user.User values in Contexts. It is\n+\t// \t// unexported; clients use user.NewContext and user.FromContext\n+\t// \t// instead of using this key directly.\n+\t// \tvar userKey key = 0\n+\t//\n+\t// \t// NewContext returns a new Context that carries value u.\n+\t// \tfunc NewContext(ctx context.Context, u *User) context.Context {\n+\t// \t\treturn context.WithValue(ctx, userKey, u)\n+\t// \t}\n+\t//\n+\t// \t// FromContext returns the User value stored in ctx, if any.\n+\t// \tfunc FromContext(ctx context.Context) (*User, bool) {\n+\t// \t\tu, ok := ctx.Value(userKey).(*User)\n+\t// \t\treturn u, ok\n+\t// \t}\n+\tValue(key interface{}) interface{}\n+}\n+\n+// Canceled is the error returned by Context.Err when the context is canceled.\n+var Canceled = errors.New(\"context canceled\")\n+\n+// DeadlineExceeded is the error returned by Context.Err when the context's\n+// deadline passes.\n+var DeadlineExceeded error = deadlineExceededError{}\n+\n+type deadlineExceededError struct{}\n+\n+func (deadlineExceededError) Error() string { return \"context deadline exceeded\" }\n+\n+func (deadlineExceededError) Timeout() bool { return true }\n+\n+// An emptyCtx is never canceled, has no values, and has no deadline. It is not\n+// struct{}, since vars of this type must have distinct addresses.\n+type emptyCtx int\n+\n+func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {\n+\treturn\n+}\n+\n+func (*emptyCtx) Done() <-chan struct{} {\n+\treturn nil\n+}\n+\n+func (*emptyCtx) Err() error {\n+\treturn nil\n+}\n+\n+func (*emptyCtx) Value(key interface{}) interface{} {\n+\treturn nil\n+}\n+\n+func (e *emptyCtx) String() string {\n+\tswitch e {\n+\tcase background:\n+\t\treturn \"context.Background\"\n+\tcase todo:\n+\t\treturn \"context.TODO\"\n+\t}\n+\treturn \"unknown empty Context\"\n+}\n+\n+var (\n+\tbackground = new(emptyCtx)\n+\ttodo       = new(emptyCtx)\n+)\n+\n+// Background returns a non-nil, empty Context. It is never canceled, has no\n+// values, and has no deadline. It is typically used by the main function,\n+// initialization, and tests, and as the top-level Context for incoming\n+// requests.\n+func Background() Context {\n+\treturn background\n+}\n+\n+// TODO returns a non-nil, empty Context. Code should use context.TODO when\n+// it's unclear which Context to use or it is not yet available (because the\n+// surrounding function has not yet been extended to accept a Context\n+// parameter). TODO is recognized by static analysis tools that determine\n+// whether Contexts are propagated correctly in a program.\n+func TODO() Context {\n+\treturn todo\n+}\n+\n+// A CancelFunc tells an operation to abandon its work.\n+// A CancelFunc does not wait for the work to stop.\n+// After the first call, subsequent calls to a CancelFunc do nothing.\n+type CancelFunc func()\n+\n+// WithCancel returns a copy of parent with a new Done channel. The returned\n+// context's Done channel is closed when the returned cancel function is called\n+// or when the parent context's Done channel is closed, whichever happens first.\n+//\n+// Canceling this context releases resources associated with it, so code should\n+// call cancel as soon as the operations running in this Context complete.\n+func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n+\tc := newCancelCtx(parent)\n+\tpropagateCancel(parent, &c)\n+\treturn &c, func() { c.cancel(true, Canceled) }\n+}\n+\n+// newCancelCtx returns an initialized cancelCtx.\n+func newCancelCtx(parent Context) cancelCtx {\n+\treturn cancelCtx{\n+\t\tContext: parent,\n+\t\tdone:    make(chan struct{}),\n+\t}\n+}\n+\n+// propagateCancel arranges for child to be canceled when parent is.\n+func propagateCancel(parent Context, child canceler) {\n+\tif parent.Done() == nil {\n+\t\treturn // parent is never canceled\n+\t}\n+\tif p, ok := parentCancelCtx(parent); ok {\n+\t\tp.mu.Lock()\n+\t\tif p.err != nil {\n+\t\t\t// parent has already been canceled\n+\t\t\tchild.cancel(false, p.err)\n+\t\t} else {\n+\t\t\tif p.children == nil {\n+\t\t\t\tp.children = make(map[canceler]bool)\n+\t\t\t}\n+\t\t\tp.children[child] = true\n+\t\t}\n+\t\tp.mu.Unlock()\n+\t} else {\n+\t\tgo func() {\n+\t\t\tselect {\n+\t\t\tcase <-parent.Done():\n+\t\t\t\tchild.cancel(false, parent.Err())\n+\t\t\tcase <-child.Done():\n+\t\t\t}\n+\t\t}()\n+\t}\n+}\n+\n+// parentCancelCtx follows a chain of parent references until it finds a\n+// *cancelCtx. This function understands how each of the concrete types in this\n+// package represents its parent.\n+func parentCancelCtx(parent Context) (*cancelCtx, bool) {\n+\tfor {\n+\t\tswitch c := parent.(type) {\n+\t\tcase *cancelCtx:\n+\t\t\treturn c, true\n+\t\tcase *timerCtx:\n+\t\t\treturn &c.cancelCtx, true\n+\t\tcase *valueCtx:\n+\t\t\tparent = c.Context\n+\t\tdefault:\n+\t\t\treturn nil, false\n+\t\t}\n+\t}\n+}\n+\n+// removeChild removes a context from its parent.\n+func removeChild(parent Context, child canceler) {\n+\tp, ok := parentCancelCtx(parent)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tp.mu.Lock()\n+\tif p.children != nil {\n+\t\tdelete(p.children, child)\n+\t}\n+\tp.mu.Unlock()\n+}\n+\n+// A canceler is a context type that can be canceled directly. The\n+// implementations are *cancelCtx and *timerCtx.\n+type canceler interface {\n+\tcancel(removeFromParent bool, err error)\n+\tDone() <-chan struct{}\n+}\n+\n+// A cancelCtx can be canceled. When canceled, it also cancels any children\n+// that implement canceler.\n+type cancelCtx struct {\n+\tContext\n+\n+\tdone chan struct{} // closed by the first cancel call.\n+\n+\tmu       sync.Mutex\n+\tchildren map[canceler]bool // set to nil by the first cancel call\n+\terr      error             // set to non-nil by the first cancel call\n+}\n+\n+func (c *cancelCtx) Done() <-chan struct{} {\n+\treturn c.done\n+}\n+\n+func (c *cancelCtx) Err() error {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\treturn c.err\n+}\n+\n+func (c *cancelCtx) String() string {\n+\treturn fmt.Sprintf(\"%v.WithCancel\", c.Context)\n+}\n+\n+// cancel closes c.done, cancels each of c's children, and, if\n+// removeFromParent is true, removes c from its parent's children.\n+func (c *cancelCtx) cancel(removeFromParent bool, err error) {\n+\tif err == nil {\n+\t\tpanic(\"context: internal error: missing cancel error\")\n+\t}\n+\tc.mu.Lock()\n+\tif c.err != nil {\n+\t\tc.mu.Unlock()\n+\t\treturn // already canceled\n+\t}\n+\tc.err = err\n+\tclose(c.done)\n+\tfor child := range c.children {\n+\t\t// NOTE: acquiring the child's lock while holding parent's lock.\n+\t\tchild.cancel(false, err)\n+\t}\n+\tc.children = nil\n+\tc.mu.Unlock()\n+\n+\tif removeFromParent {\n+\t\tremoveChild(c.Context, c)\n+\t}\n+}\n+\n+// WithDeadline returns a copy of the parent context with the deadline adjusted\n+// to be no later than d. If the parent's deadline is already earlier than d,\n+// WithDeadline(parent, d) is semantically equivalent to parent. The returned\n+// context's Done channel is closed when the deadline expires, when the returned\n+// cancel function is called, or when the parent context's Done channel is\n+// closed, whichever happens first.\n+//\n+// Canceling this context releases resources associated with it, so code should\n+// call cancel as soon as the operations running in this Context complete.\n+func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {\n+\tif cur, ok := parent.Deadline(); ok && cur.Before(deadline) {\n+\t\t// The current deadline is already sooner than the new one.\n+\t\treturn WithCancel(parent)\n+\t}\n+\tc := &timerCtx{\n+\t\tcancelCtx: newCancelCtx(parent),\n+\t\tdeadline:  deadline,\n+\t}\n+\tpropagateCancel(parent, c)\n+\td := deadline.Sub(time.Now())\n+\tif d <= 0 {\n+\t\tc.cancel(true, DeadlineExceeded) // deadline has already passed\n+\t\treturn c, func() { c.cancel(true, Canceled) }\n+\t}\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif c.err == nil {\n+\t\tc.timer = time.AfterFunc(d, func() {\n+\t\t\tc.cancel(true, DeadlineExceeded)\n+\t\t})\n+\t}\n+\treturn c, func() { c.cancel(true, Canceled) }\n+}\n+\n+// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to\n+// implement Done and Err. It implements cancel by stopping its timer then\n+// delegating to cancelCtx.cancel.\n+type timerCtx struct {\n+\tcancelCtx\n+\ttimer *time.Timer // Under cancelCtx.mu.\n+\n+\tdeadline time.Time\n+}\n+\n+func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {\n+\treturn c.deadline, true\n+}\n+\n+func (c *timerCtx) String() string {\n+\treturn fmt.Sprintf(\"%v.WithDeadline(%s [%s])\", c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))\n+}\n+\n+func (c *timerCtx) cancel(removeFromParent bool, err error) {\n+\tc.cancelCtx.cancel(false, err)\n+\tif removeFromParent {\n+\t\t// Remove this timerCtx from its parent cancelCtx's children.\n+\t\tremoveChild(c.cancelCtx.Context, c)\n+\t}\n+\tc.mu.Lock()\n+\tif c.timer != nil {\n+\t\tc.timer.Stop()\n+\t\tc.timer = nil\n+\t}\n+\tc.mu.Unlock()\n+}\n+\n+// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n+//\n+// Canceling this context releases resources associated with it, so code should\n+// call cancel as soon as the operations running in this Context complete:\n+//\n+// \tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n+// \t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n+// \t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n+// \t\treturn slowOperation(ctx)\n+// \t}\n+func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n+\treturn WithDeadline(parent, time.Now().Add(timeout))\n+}\n+\n+// WithValue returns a copy of parent in which the value associated with key is\n+// val.\n+//\n+// Use context Values only for request-scoped data that transits processes and\n+// APIs, not for passing optional parameters to functions.\n+//\n+// The provided key must be comparable.\n+func WithValue(parent Context, key, val interface{}) Context {\n+\tif key == nil {\n+\t\tpanic(\"nil key\")\n+\t}\n+\tif !reflect.TypeOf(key).Comparable() {\n+\t\tpanic(\"key is not comparable\")\n+\t}\n+\treturn &valueCtx{parent, key, val}\n+}\n+\n+// A valueCtx carries a key-value pair. It implements Value for that key and\n+// delegates all other calls to the embedded Context.\n+type valueCtx struct {\n+\tContext\n+\tkey, val interface{}\n+}\n+\n+func (c *valueCtx) String() string {\n+\treturn fmt.Sprintf(\"%v.WithValue(%#v, %#v)\", c.Context, c.key, c.val)\n+}\n+\n+func (c *valueCtx) Value(key interface{}) interface{} {\n+\tif c.key == key {\n+\t\treturn c.val\n+\t}\n+\treturn c.Context.Value(key)\n+}"}, {"sha": "90e78e57ecc42e83623587c5c8dc9a2204ea3df0", "filename": "libgo/go/context/context_test.go", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,608 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package context\n+\n+import (\n+\t\"fmt\"\n+\t\"math/rand\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+// otherContext is a Context that's not one of the types defined in context.go.\n+// This lets us test code paths that differ based on the underlying type of the\n+// Context.\n+type otherContext struct {\n+\tContext\n+}\n+\n+func TestBackground(t *testing.T) {\n+\tc := Background()\n+\tif c == nil {\n+\t\tt.Fatalf(\"Background returned nil\")\n+\t}\n+\tselect {\n+\tcase x := <-c.Done():\n+\t\tt.Errorf(\"<-c.Done() == %v want nothing (it should block)\", x)\n+\tdefault:\n+\t}\n+\tif got, want := fmt.Sprint(c), \"context.Background\"; got != want {\n+\t\tt.Errorf(\"Background().String() = %q want %q\", got, want)\n+\t}\n+}\n+\n+func TestTODO(t *testing.T) {\n+\tc := TODO()\n+\tif c == nil {\n+\t\tt.Fatalf(\"TODO returned nil\")\n+\t}\n+\tselect {\n+\tcase x := <-c.Done():\n+\t\tt.Errorf(\"<-c.Done() == %v want nothing (it should block)\", x)\n+\tdefault:\n+\t}\n+\tif got, want := fmt.Sprint(c), \"context.TODO\"; got != want {\n+\t\tt.Errorf(\"TODO().String() = %q want %q\", got, want)\n+\t}\n+}\n+\n+func TestWithCancel(t *testing.T) {\n+\tc1, cancel := WithCancel(Background())\n+\n+\tif got, want := fmt.Sprint(c1), \"context.Background.WithCancel\"; got != want {\n+\t\tt.Errorf(\"c1.String() = %q want %q\", got, want)\n+\t}\n+\n+\to := otherContext{c1}\n+\tc2, _ := WithCancel(o)\n+\tcontexts := []Context{c1, o, c2}\n+\n+\tfor i, c := range contexts {\n+\t\tif d := c.Done(); d == nil {\n+\t\t\tt.Errorf(\"c[%d].Done() == %v want non-nil\", i, d)\n+\t\t}\n+\t\tif e := c.Err(); e != nil {\n+\t\t\tt.Errorf(\"c[%d].Err() == %v want nil\", i, e)\n+\t\t}\n+\n+\t\tselect {\n+\t\tcase x := <-c.Done():\n+\t\t\tt.Errorf(\"<-c.Done() == %v want nothing (it should block)\", x)\n+\t\tdefault:\n+\t\t}\n+\t}\n+\n+\tcancel()\n+\ttime.Sleep(100 * time.Millisecond) // let cancelation propagate\n+\n+\tfor i, c := range contexts {\n+\t\tselect {\n+\t\tcase <-c.Done():\n+\t\tdefault:\n+\t\t\tt.Errorf(\"<-c[%d].Done() blocked, but shouldn't have\", i)\n+\t\t}\n+\t\tif e := c.Err(); e != Canceled {\n+\t\t\tt.Errorf(\"c[%d].Err() == %v want %v\", i, e, Canceled)\n+\t\t}\n+\t}\n+}\n+\n+func TestParentFinishesChild(t *testing.T) {\n+\t// Context tree:\n+\t// parent -> cancelChild\n+\t// parent -> valueChild -> timerChild\n+\tparent, cancel := WithCancel(Background())\n+\tcancelChild, stop := WithCancel(parent)\n+\tdefer stop()\n+\tvalueChild := WithValue(parent, \"key\", \"value\")\n+\ttimerChild, stop := WithTimeout(valueChild, 10000*time.Hour)\n+\tdefer stop()\n+\n+\tselect {\n+\tcase x := <-parent.Done():\n+\t\tt.Errorf(\"<-parent.Done() == %v want nothing (it should block)\", x)\n+\tcase x := <-cancelChild.Done():\n+\t\tt.Errorf(\"<-cancelChild.Done() == %v want nothing (it should block)\", x)\n+\tcase x := <-timerChild.Done():\n+\t\tt.Errorf(\"<-timerChild.Done() == %v want nothing (it should block)\", x)\n+\tcase x := <-valueChild.Done():\n+\t\tt.Errorf(\"<-valueChild.Done() == %v want nothing (it should block)\", x)\n+\tdefault:\n+\t}\n+\n+\t// The parent's children should contain the two cancelable children.\n+\tpc := parent.(*cancelCtx)\n+\tcc := cancelChild.(*cancelCtx)\n+\ttc := timerChild.(*timerCtx)\n+\tpc.mu.Lock()\n+\tif len(pc.children) != 2 || !pc.children[cc] || !pc.children[tc] {\n+\t\tt.Errorf(\"bad linkage: pc.children = %v, want %v and %v\",\n+\t\t\tpc.children, cc, tc)\n+\t}\n+\tpc.mu.Unlock()\n+\n+\tif p, ok := parentCancelCtx(cc.Context); !ok || p != pc {\n+\t\tt.Errorf(\"bad linkage: parentCancelCtx(cancelChild.Context) = %v, %v want %v, true\", p, ok, pc)\n+\t}\n+\tif p, ok := parentCancelCtx(tc.Context); !ok || p != pc {\n+\t\tt.Errorf(\"bad linkage: parentCancelCtx(timerChild.Context) = %v, %v want %v, true\", p, ok, pc)\n+\t}\n+\n+\tcancel()\n+\n+\tpc.mu.Lock()\n+\tif len(pc.children) != 0 {\n+\t\tt.Errorf(\"pc.cancel didn't clear pc.children = %v\", pc.children)\n+\t}\n+\tpc.mu.Unlock()\n+\n+\t// parent and children should all be finished.\n+\tcheck := func(ctx Context, name string) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tdefault:\n+\t\t\tt.Errorf(\"<-%s.Done() blocked, but shouldn't have\", name)\n+\t\t}\n+\t\tif e := ctx.Err(); e != Canceled {\n+\t\t\tt.Errorf(\"%s.Err() == %v want %v\", name, e, Canceled)\n+\t\t}\n+\t}\n+\tcheck(parent, \"parent\")\n+\tcheck(cancelChild, \"cancelChild\")\n+\tcheck(valueChild, \"valueChild\")\n+\tcheck(timerChild, \"timerChild\")\n+\n+\t// WithCancel should return a canceled context on a canceled parent.\n+\tprecanceledChild := WithValue(parent, \"key\", \"value\")\n+\tselect {\n+\tcase <-precanceledChild.Done():\n+\tdefault:\n+\t\tt.Errorf(\"<-precanceledChild.Done() blocked, but shouldn't have\")\n+\t}\n+\tif e := precanceledChild.Err(); e != Canceled {\n+\t\tt.Errorf(\"precanceledChild.Err() == %v want %v\", e, Canceled)\n+\t}\n+}\n+\n+func TestChildFinishesFirst(t *testing.T) {\n+\tcancelable, stop := WithCancel(Background())\n+\tdefer stop()\n+\tfor _, parent := range []Context{Background(), cancelable} {\n+\t\tchild, cancel := WithCancel(parent)\n+\n+\t\tselect {\n+\t\tcase x := <-parent.Done():\n+\t\t\tt.Errorf(\"<-parent.Done() == %v want nothing (it should block)\", x)\n+\t\tcase x := <-child.Done():\n+\t\t\tt.Errorf(\"<-child.Done() == %v want nothing (it should block)\", x)\n+\t\tdefault:\n+\t\t}\n+\n+\t\tcc := child.(*cancelCtx)\n+\t\tpc, pcok := parent.(*cancelCtx) // pcok == false when parent == Background()\n+\t\tif p, ok := parentCancelCtx(cc.Context); ok != pcok || (ok && pc != p) {\n+\t\t\tt.Errorf(\"bad linkage: parentCancelCtx(cc.Context) = %v, %v want %v, %v\", p, ok, pc, pcok)\n+\t\t}\n+\n+\t\tif pcok {\n+\t\t\tpc.mu.Lock()\n+\t\t\tif len(pc.children) != 1 || !pc.children[cc] {\n+\t\t\t\tt.Errorf(\"bad linkage: pc.children = %v, cc = %v\", pc.children, cc)\n+\t\t\t}\n+\t\t\tpc.mu.Unlock()\n+\t\t}\n+\n+\t\tcancel()\n+\n+\t\tif pcok {\n+\t\t\tpc.mu.Lock()\n+\t\t\tif len(pc.children) != 0 {\n+\t\t\t\tt.Errorf(\"child's cancel didn't remove self from pc.children = %v\", pc.children)\n+\t\t\t}\n+\t\t\tpc.mu.Unlock()\n+\t\t}\n+\n+\t\t// child should be finished.\n+\t\tselect {\n+\t\tcase <-child.Done():\n+\t\tdefault:\n+\t\t\tt.Errorf(\"<-child.Done() blocked, but shouldn't have\")\n+\t\t}\n+\t\tif e := child.Err(); e != Canceled {\n+\t\t\tt.Errorf(\"child.Err() == %v want %v\", e, Canceled)\n+\t\t}\n+\n+\t\t// parent should not be finished.\n+\t\tselect {\n+\t\tcase x := <-parent.Done():\n+\t\t\tt.Errorf(\"<-parent.Done() == %v want nothing (it should block)\", x)\n+\t\tdefault:\n+\t\t}\n+\t\tif e := parent.Err(); e != nil {\n+\t\t\tt.Errorf(\"parent.Err() == %v want nil\", e)\n+\t\t}\n+\t}\n+}\n+\n+func testDeadline(c Context, name string, failAfter time.Duration, t *testing.T) {\n+\tselect {\n+\tcase <-time.After(failAfter):\n+\t\tt.Fatalf(\"%s: context should have timed out\", name)\n+\tcase <-c.Done():\n+\t}\n+\tif e := c.Err(); e != DeadlineExceeded {\n+\t\tt.Errorf(\"%s: c.Err() == %v; want %v\", name, e, DeadlineExceeded)\n+\t}\n+}\n+\n+func TestDeadline(t *testing.T) {\n+\tc, _ := WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n+\t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n+\t}\n+\ttestDeadline(c, \"WithDeadline\", time.Second, t)\n+\n+\tc, _ = WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\to := otherContext{c}\n+\ttestDeadline(o, \"WithDeadline+otherContext\", time.Second, t)\n+\n+\tc, _ = WithDeadline(Background(), time.Now().Add(50*time.Millisecond))\n+\to = otherContext{c}\n+\tc, _ = WithDeadline(o, time.Now().Add(4*time.Second))\n+\ttestDeadline(c, \"WithDeadline+otherContext+WithDeadline\", 2*time.Second, t)\n+}\n+\n+func TestTimeout(t *testing.T) {\n+\tc, _ := WithTimeout(Background(), 50*time.Millisecond)\n+\tif got, prefix := fmt.Sprint(c), \"context.Background.WithDeadline(\"; !strings.HasPrefix(got, prefix) {\n+\t\tt.Errorf(\"c.String() = %q want prefix %q\", got, prefix)\n+\t}\n+\ttestDeadline(c, \"WithTimeout\", time.Second, t)\n+\n+\tc, _ = WithTimeout(Background(), 50*time.Millisecond)\n+\to := otherContext{c}\n+\ttestDeadline(o, \"WithTimeout+otherContext\", time.Second, t)\n+\n+\tc, _ = WithTimeout(Background(), 50*time.Millisecond)\n+\to = otherContext{c}\n+\tc, _ = WithTimeout(o, 3*time.Second)\n+\ttestDeadline(c, \"WithTimeout+otherContext+WithTimeout\", 2*time.Second, t)\n+}\n+\n+func TestCanceledTimeout(t *testing.T) {\n+\tc, _ := WithTimeout(Background(), time.Second)\n+\to := otherContext{c}\n+\tc, cancel := WithTimeout(o, 2*time.Second)\n+\tcancel()\n+\ttime.Sleep(100 * time.Millisecond) // let cancelation propagate\n+\tselect {\n+\tcase <-c.Done():\n+\tdefault:\n+\t\tt.Errorf(\"<-c.Done() blocked, but shouldn't have\")\n+\t}\n+\tif e := c.Err(); e != Canceled {\n+\t\tt.Errorf(\"c.Err() == %v want %v\", e, Canceled)\n+\t}\n+}\n+\n+type key1 int\n+type key2 int\n+\n+var k1 = key1(1)\n+var k2 = key2(1) // same int as k1, different type\n+var k3 = key2(3) // same type as k2, different int\n+\n+func TestValues(t *testing.T) {\n+\tcheck := func(c Context, nm, v1, v2, v3 string) {\n+\t\tif v, ok := c.Value(k1).(string); ok == (len(v1) == 0) || v != v1 {\n+\t\t\tt.Errorf(`%s.Value(k1).(string) = %q, %t want %q, %t`, nm, v, ok, v1, len(v1) != 0)\n+\t\t}\n+\t\tif v, ok := c.Value(k2).(string); ok == (len(v2) == 0) || v != v2 {\n+\t\t\tt.Errorf(`%s.Value(k2).(string) = %q, %t want %q, %t`, nm, v, ok, v2, len(v2) != 0)\n+\t\t}\n+\t\tif v, ok := c.Value(k3).(string); ok == (len(v3) == 0) || v != v3 {\n+\t\t\tt.Errorf(`%s.Value(k3).(string) = %q, %t want %q, %t`, nm, v, ok, v3, len(v3) != 0)\n+\t\t}\n+\t}\n+\n+\tc0 := Background()\n+\tcheck(c0, \"c0\", \"\", \"\", \"\")\n+\n+\tc1 := WithValue(Background(), k1, \"c1k1\")\n+\tcheck(c1, \"c1\", \"c1k1\", \"\", \"\")\n+\n+\tif got, want := fmt.Sprint(c1), `context.Background.WithValue(1, \"c1k1\")`; got != want {\n+\t\tt.Errorf(\"c.String() = %q want %q\", got, want)\n+\t}\n+\n+\tc2 := WithValue(c1, k2, \"c2k2\")\n+\tcheck(c2, \"c2\", \"c1k1\", \"c2k2\", \"\")\n+\n+\tc3 := WithValue(c2, k3, \"c3k3\")\n+\tcheck(c3, \"c2\", \"c1k1\", \"c2k2\", \"c3k3\")\n+\n+\tc4 := WithValue(c3, k1, nil)\n+\tcheck(c4, \"c4\", \"\", \"c2k2\", \"c3k3\")\n+\n+\to0 := otherContext{Background()}\n+\tcheck(o0, \"o0\", \"\", \"\", \"\")\n+\n+\to1 := otherContext{WithValue(Background(), k1, \"c1k1\")}\n+\tcheck(o1, \"o1\", \"c1k1\", \"\", \"\")\n+\n+\to2 := WithValue(o1, k2, \"o2k2\")\n+\tcheck(o2, \"o2\", \"c1k1\", \"o2k2\", \"\")\n+\n+\to3 := otherContext{c4}\n+\tcheck(o3, \"o3\", \"\", \"c2k2\", \"c3k3\")\n+\n+\to4 := WithValue(o3, k3, nil)\n+\tcheck(o4, \"o4\", \"\", \"c2k2\", \"\")\n+}\n+\n+func TestAllocs(t *testing.T) {\n+\tbg := Background()\n+\tfor _, test := range []struct {\n+\t\tdesc       string\n+\t\tf          func()\n+\t\tlimit      float64\n+\t\tgccgoLimit float64\n+\t}{\n+\t\t{\n+\t\t\tdesc:       \"Background()\",\n+\t\t\tf:          func() { Background() },\n+\t\t\tlimit:      0,\n+\t\t\tgccgoLimit: 0,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: fmt.Sprintf(\"WithValue(bg, %v, nil)\", k1),\n+\t\t\tf: func() {\n+\t\t\t\tc := WithValue(bg, k1, nil)\n+\t\t\t\tc.Value(k1)\n+\t\t\t},\n+\t\t\tlimit:      3,\n+\t\t\tgccgoLimit: 3,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"WithTimeout(bg, 15*time.Millisecond)\",\n+\t\t\tf: func() {\n+\t\t\t\tc, _ := WithTimeout(bg, 15*time.Millisecond)\n+\t\t\t\t<-c.Done()\n+\t\t\t},\n+\t\t\tlimit:      8,\n+\t\t\tgccgoLimit: 15,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"WithCancel(bg)\",\n+\t\t\tf: func() {\n+\t\t\t\tc, cancel := WithCancel(bg)\n+\t\t\t\tcancel()\n+\t\t\t\t<-c.Done()\n+\t\t\t},\n+\t\t\tlimit:      5,\n+\t\t\tgccgoLimit: 8,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"WithTimeout(bg, 5*time.Millisecond)\",\n+\t\t\tf: func() {\n+\t\t\t\tc, cancel := WithTimeout(bg, 5*time.Millisecond)\n+\t\t\t\tcancel()\n+\t\t\t\t<-c.Done()\n+\t\t\t},\n+\t\t\tlimit:      8,\n+\t\t\tgccgoLimit: 25,\n+\t\t},\n+\t} {\n+\t\tlimit := test.limit\n+\t\tif runtime.Compiler == \"gccgo\" {\n+\t\t\t// gccgo does not yet do escape analysis.\n+\t\t\t// TOOD(iant): Remove this when gccgo does do escape analysis.\n+\t\t\tlimit = test.gccgoLimit\n+\t\t}\n+\t\tnumRuns := 100\n+\t\tif testing.Short() {\n+\t\t\tnumRuns = 10\n+\t\t}\n+\t\tif n := testing.AllocsPerRun(numRuns, test.f); n > limit {\n+\t\t\tt.Errorf(\"%s allocs = %f want %d\", test.desc, n, int(limit))\n+\t\t}\n+\t}\n+}\n+\n+func TestSimultaneousCancels(t *testing.T) {\n+\troot, cancel := WithCancel(Background())\n+\tm := map[Context]CancelFunc{root: cancel}\n+\tq := []Context{root}\n+\t// Create a tree of contexts.\n+\tfor len(q) != 0 && len(m) < 100 {\n+\t\tparent := q[0]\n+\t\tq = q[1:]\n+\t\tfor i := 0; i < 4; i++ {\n+\t\t\tctx, cancel := WithCancel(parent)\n+\t\t\tm[ctx] = cancel\n+\t\t\tq = append(q, ctx)\n+\t\t}\n+\t}\n+\t// Start all the cancels in a random order.\n+\tvar wg sync.WaitGroup\n+\twg.Add(len(m))\n+\tfor _, cancel := range m {\n+\t\tgo func(cancel CancelFunc) {\n+\t\t\tcancel()\n+\t\t\twg.Done()\n+\t\t}(cancel)\n+\t}\n+\t// Wait on all the contexts in a random order.\n+\tfor ctx := range m {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase <-time.After(1 * time.Second):\n+\t\t\tbuf := make([]byte, 10<<10)\n+\t\t\tn := runtime.Stack(buf, true)\n+\t\t\tt.Fatalf(\"timed out waiting for <-ctx.Done(); stacks:\\n%s\", buf[:n])\n+\t\t}\n+\t}\n+\t// Wait for all the cancel functions to return.\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\twg.Wait()\n+\t\tclose(done)\n+\t}()\n+\tselect {\n+\tcase <-done:\n+\tcase <-time.After(1 * time.Second):\n+\t\tbuf := make([]byte, 10<<10)\n+\t\tn := runtime.Stack(buf, true)\n+\t\tt.Fatalf(\"timed out waiting for cancel functions; stacks:\\n%s\", buf[:n])\n+\t}\n+}\n+\n+func TestInterlockedCancels(t *testing.T) {\n+\tparent, cancelParent := WithCancel(Background())\n+\tchild, cancelChild := WithCancel(parent)\n+\tgo func() {\n+\t\tparent.Done()\n+\t\tcancelChild()\n+\t}()\n+\tcancelParent()\n+\tselect {\n+\tcase <-child.Done():\n+\tcase <-time.After(1 * time.Second):\n+\t\tbuf := make([]byte, 10<<10)\n+\t\tn := runtime.Stack(buf, true)\n+\t\tt.Fatalf(\"timed out waiting for child.Done(); stacks:\\n%s\", buf[:n])\n+\t}\n+}\n+\n+func TestLayersCancel(t *testing.T) {\n+\ttestLayers(t, time.Now().UnixNano(), false)\n+}\n+\n+func TestLayersTimeout(t *testing.T) {\n+\ttestLayers(t, time.Now().UnixNano(), true)\n+}\n+\n+func testLayers(t *testing.T, seed int64, testTimeout bool) {\n+\trand.Seed(seed)\n+\terrorf := func(format string, a ...interface{}) {\n+\t\tt.Errorf(fmt.Sprintf(\"seed=%d: %s\", seed, format), a...)\n+\t}\n+\tconst (\n+\t\ttimeout   = 200 * time.Millisecond\n+\t\tminLayers = 30\n+\t)\n+\ttype value int\n+\tvar (\n+\t\tvals      []*value\n+\t\tcancels   []CancelFunc\n+\t\tnumTimers int\n+\t\tctx       = Background()\n+\t)\n+\tfor i := 0; i < minLayers || numTimers == 0 || len(cancels) == 0 || len(vals) == 0; i++ {\n+\t\tswitch rand.Intn(3) {\n+\t\tcase 0:\n+\t\t\tv := new(value)\n+\t\t\tctx = WithValue(ctx, v, v)\n+\t\t\tvals = append(vals, v)\n+\t\tcase 1:\n+\t\t\tvar cancel CancelFunc\n+\t\t\tctx, cancel = WithCancel(ctx)\n+\t\t\tcancels = append(cancels, cancel)\n+\t\tcase 2:\n+\t\t\tvar cancel CancelFunc\n+\t\t\tctx, cancel = WithTimeout(ctx, timeout)\n+\t\t\tcancels = append(cancels, cancel)\n+\t\t\tnumTimers++\n+\t\t}\n+\t}\n+\tcheckValues := func(when string) {\n+\t\tfor _, key := range vals {\n+\t\t\tif val := ctx.Value(key).(*value); key != val {\n+\t\t\t\terrorf(\"%s: ctx.Value(%p) = %p want %p\", when, key, val, key)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\terrorf(\"ctx should not be canceled yet\")\n+\tdefault:\n+\t}\n+\tif s, prefix := fmt.Sprint(ctx), \"context.Background.\"; !strings.HasPrefix(s, prefix) {\n+\t\tt.Errorf(\"ctx.String() = %q want prefix %q\", s, prefix)\n+\t}\n+\tt.Log(ctx)\n+\tcheckValues(\"before cancel\")\n+\tif testTimeout {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase <-time.After(timeout + time.Second):\n+\t\t\terrorf(\"ctx should have timed out\")\n+\t\t}\n+\t\tcheckValues(\"after timeout\")\n+\t} else {\n+\t\tcancel := cancels[rand.Intn(len(cancels))]\n+\t\tcancel()\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tdefault:\n+\t\t\terrorf(\"ctx should be canceled\")\n+\t\t}\n+\t\tcheckValues(\"after cancel\")\n+\t}\n+}\n+\n+func TestCancelRemoves(t *testing.T) {\n+\tcheckChildren := func(when string, ctx Context, want int) {\n+\t\tif got := len(ctx.(*cancelCtx).children); got != want {\n+\t\t\tt.Errorf(\"%s: context has %d children, want %d\", when, got, want)\n+\t\t}\n+\t}\n+\n+\tctx, _ := WithCancel(Background())\n+\tcheckChildren(\"after creation\", ctx, 0)\n+\t_, cancel := WithCancel(ctx)\n+\tcheckChildren(\"with WithCancel child \", ctx, 1)\n+\tcancel()\n+\tcheckChildren(\"after cancelling WithCancel child\", ctx, 0)\n+\n+\tctx, _ = WithCancel(Background())\n+\tcheckChildren(\"after creation\", ctx, 0)\n+\t_, cancel = WithTimeout(ctx, 60*time.Minute)\n+\tcheckChildren(\"with WithTimeout child \", ctx, 1)\n+\tcancel()\n+\tcheckChildren(\"after cancelling WithTimeout child\", ctx, 0)\n+}\n+\n+func TestWithValueChecksKey(t *testing.T) {\n+\tpanicVal := recoveredValue(func() { WithValue(Background(), []byte(\"foo\"), \"bar\") })\n+\tif panicVal == nil {\n+\t\tt.Error(\"expected panic\")\n+\t}\n+\tpanicVal = recoveredValue(func() { WithValue(Background(), nil, \"bar\") })\n+\tif got, want := fmt.Sprint(panicVal), \"nil key\"; got != want {\n+\t\tt.Errorf(\"panic = %q; want %q\", got, want)\n+\t}\n+}\n+\n+func recoveredValue(fn func()) (v interface{}) {\n+\tdefer func() { v = recover() }()\n+\tfn()\n+\treturn\n+}\n+\n+func TestDeadlineExceededSupportsTimeout(t *testing.T) {\n+\ti, ok := DeadlineExceeded.(interface {\n+\t\tTimeout() bool\n+\t})\n+\tif !ok {\n+\t\tt.Fatal(\"DeadlineExceeded does not support Timeout interface\")\n+\t}\n+\tif !i.Timeout() {\n+\t\tt.Fatal(\"wrong value for timeout\")\n+\t}\n+}"}, {"sha": "c74600b47b4561711d1fc54a20d5d65495fb7feb", "filename": "libgo/go/context/withtimeout_test.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fwithtimeout_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package context_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+func ExampleWithTimeout() {\n+\t// Pass a context with a timeout to tell a blocking function that it\n+\t// should abandon its work after the timeout elapses.\n+\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n+\n+\tselect {\n+\tcase <-time.After(1 * time.Second):\n+\t\tfmt.Println(\"overslept\")\n+\tcase <-ctx.Done():\n+\t\tfmt.Println(ctx.Err()) // prints \"context deadline exceeded\"\n+\t}\n+\n+\t// Even though ctx should have expired already, it is good\n+\t// practice to call its cancelation function in any case.\n+\t// Failure to do so may keep the context and its parent alive\n+\t// longer than necessary.\n+\tcancel()\n+\n+\t// Output:\n+\t// context deadline exceeded\n+}"}, {"sha": "a894a68293e185e77337c6583ff7cecf1cbdbaeb", "filename": "libgo/go/crypto/aes/aes_gcm.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_gcm.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -45,9 +45,12 @@ var errOpen = errors.New(\"cipher: message authentication failed\")\n // will use the optimised implementation in this file when possible. Instances\n // of this type only exist when hasGCMAsm returns true.\n type aesCipherGCM struct {\n-\taesCipher\n+\taesCipherAsm\n }\n \n+// Assert that aesCipherGCM implements the gcmAble interface.\n+var _ gcmAble = (*aesCipherGCM)(nil)\n+\n // NewGCM returns the AES cipher wrapped in Galois Counter Mode. This is only\n // called by crypto/cipher.NewGCM via the gcmAble interface.\n func (c *aesCipherGCM) NewGCM(nonceSize int) (cipher.AEAD, error) {"}, {"sha": "28144968fcfd258d889840782bff0c25b81b407f", "filename": "libgo/go/crypto/aes/aes_test.go", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Faes_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -280,42 +280,6 @@ var encryptTests = []CryptTest{\n \t},\n }\n \n-// Test encryptBlock against FIPS 197 examples.\n-func TestEncryptBlock(t *testing.T) {\n-\tfor i, tt := range encryptTests {\n-\t\tn := len(tt.key) + 28\n-\t\tenc := make([]uint32, n)\n-\t\tdec := make([]uint32, n)\n-\t\texpandKey(tt.key, enc, dec)\n-\t\tout := make([]byte, len(tt.in))\n-\t\tencryptBlock(enc, out, tt.in)\n-\t\tfor j, v := range out {\n-\t\t\tif v != tt.out[j] {\n-\t\t\t\tt.Errorf(\"encryptBlock %d: out[%d] = %#x, want %#x\", i, j, v, tt.out[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Test decryptBlock against FIPS 197 examples.\n-func TestDecryptBlock(t *testing.T) {\n-\tfor i, tt := range encryptTests {\n-\t\tn := len(tt.key) + 28\n-\t\tenc := make([]uint32, n)\n-\t\tdec := make([]uint32, n)\n-\t\texpandKey(tt.key, enc, dec)\n-\t\tplain := make([]byte, len(tt.in))\n-\t\tdecryptBlock(dec, plain, tt.out)\n-\t\tfor j, v := range plain {\n-\t\t\tif v != tt.in[j] {\n-\t\t\t\tt.Errorf(\"decryptBlock %d: plain[%d] = %#x, want %#x\", i, j, v, tt.in[j])\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n // Test Cipher Encrypt method against FIPS 197 examples.\n func TestCipherEncrypt(t *testing.T) {\n \tfor i, tt := range encryptTests {"}, {"sha": "41ea9cf95ed7c9c323f6bda9ef29a847debc667a", "filename": "libgo/go/crypto/aes/block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fblock.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -137,7 +137,7 @@ func subw(w uint32) uint32 {\n // Rotate\n func rotw(w uint32) uint32 { return w<<8 | w>>24 }\n \n-// Key expansion algorithm.  See FIPS-197, Figure 11.\n+// Key expansion algorithm. See FIPS-197, Figure 11.\n // Their rcon[i] is our powx[i-1] << 24.\n func expandKeyGo(key []byte, enc, dec []uint32) {\n \t// Encryption key setup."}, {"sha": "427b30b2a7023ca2af4fdad9a76e13492ca141ff", "filename": "libgo/go/crypto/aes/cbc_s390x.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcbc_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+)\n+\n+// Assert that aesCipherAsm implements the cbcEncAble and cbcDecAble interfaces.\n+var _ cbcEncAble = (*aesCipherAsm)(nil)\n+var _ cbcDecAble = (*aesCipherAsm)(nil)\n+\n+type cbc struct {\n+\tb  *aesCipherAsm\n+\tc  code\n+\tiv [BlockSize]byte\n+}\n+\n+func (b *aesCipherAsm) NewCBCEncrypter(iv []byte) cipher.BlockMode {\n+\tvar c cbc\n+\tc.b = b\n+\tc.c = b.function\n+\tcopy(c.iv[:], iv)\n+\treturn &c\n+}\n+\n+func (b *aesCipherAsm) NewCBCDecrypter(iv []byte) cipher.BlockMode {\n+\tvar c cbc\n+\tc.b = b\n+\tc.c = b.function + 128 // decrypt function code is encrypt + 128\n+\tcopy(c.iv[:], iv)\n+\treturn &c\n+}\n+\n+func (x *cbc) BlockSize() int { return BlockSize }\n+\n+// cryptBlocksChain invokes the cipher message with chaining (KMC) instruction\n+// with the given function code. The length must be a multiple of BlockSize (16).\n+//go:noescape\n+func cryptBlocksChain(c code, iv, key, dst, src *byte, length int)\n+\n+func (x *cbc) CryptBlocks(dst, src []byte) {\n+\tif len(src)%BlockSize != 0 {\n+\t\tpanic(\"crypto/cipher: input not full blocks\")\n+\t}\n+\tif len(dst) < len(src) {\n+\t\tpanic(\"crypto/cipher: output smaller than input\")\n+\t}\n+\tcryptBlocksChain(x.c, &x.iv[0], &x.b.key[0], &dst[0], &src[0], len(src))\n+}\n+\n+func (x *cbc) SetIV(iv []byte) {\n+\tif len(iv) != BlockSize {\n+\t\tpanic(\"cipher: incorrect length IV\")\n+\t}\n+\tcopy(x.iv[:], iv)\n+}"}, {"sha": "c5a8e91d009b790da6d790edc04e26e175dcb736", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -36,15 +36,15 @@ func NewCipher(key []byte) (cipher.Block, error) {\n \tcase 16, 24, 32:\n \t\tbreak\n \t}\n+\treturn newCipher(key)\n+}\n \n-\tn := k + 28\n+// newCipherGeneric creates and returns a new cipher.Block\n+// implemented in pure Go.\n+func newCipherGeneric(key []byte) (cipher.Block, error) {\n+\tn := len(key) + 28\n \tc := aesCipher{make([]uint32, n), make([]uint32, n)}\n-\texpandKey(key, c.enc, c.dec)\n-\n-\tif hasGCMAsm() {\n-\t\treturn &aesCipherGCM{c}, nil\n-\t}\n-\n+\texpandKeyGo(key, c.enc, c.dec)\n \treturn &c, nil\n }\n \n@@ -57,7 +57,7 @@ func (c *aesCipher) Encrypt(dst, src []byte) {\n \tif len(dst) < BlockSize {\n \t\tpanic(\"crypto/aes: output not full block\")\n \t}\n-\tencryptBlock(c.enc, dst, src)\n+\tencryptBlockGo(c.enc, dst, src)\n }\n \n func (c *aesCipher) Decrypt(dst, src []byte) {\n@@ -67,5 +67,5 @@ func (c *aesCipher) Decrypt(dst, src []byte) {\n \tif len(dst) < BlockSize {\n \t\tpanic(\"crypto/aes: output not full block\")\n \t}\n-\tdecryptBlock(c.dec, dst, src)\n+\tdecryptBlockGo(c.dec, dst, src)\n }"}, {"sha": "b33c8ff251ac7cbdf89f3c927e41fe9288241064", "filename": "libgo/go/crypto/aes/cipher_amd64.go", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_amd64.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+)\n+\n+// defined in asm_amd64.s\n+func hasAsm() bool\n+func encryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n+func decryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n+func expandKeyAsm(nr int, key *byte, enc *uint32, dec *uint32)\n+\n+type aesCipherAsm struct {\n+\taesCipher\n+}\n+\n+var useAsm = hasAsm()\n+\n+func newCipher(key []byte) (cipher.Block, error) {\n+\tif !useAsm {\n+\t\treturn newCipherGeneric(key)\n+\t}\n+\tn := len(key) + 28\n+\tc := aesCipherAsm{aesCipher{make([]uint32, n), make([]uint32, n)}}\n+\trounds := 10\n+\tswitch len(key) {\n+\tcase 128 / 8:\n+\t\trounds = 10\n+\tcase 192 / 8:\n+\t\trounds = 12\n+\tcase 256 / 8:\n+\t\trounds = 14\n+\t}\n+\texpandKeyAsm(rounds, &key[0], &c.enc[0], &c.dec[0])\n+\tif hasGCMAsm() {\n+\t\treturn &aesCipherGCM{c}, nil\n+\t}\n+\n+\treturn &c, nil\n+}\n+\n+func (c *aesCipherAsm) BlockSize() int { return BlockSize }\n+\n+func (c *aesCipherAsm) Encrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\tencryptBlockAsm(len(c.enc)/4-1, &c.enc[0], &dst[0], &src[0])\n+}\n+\n+func (c *aesCipherAsm) Decrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\tdecryptBlockAsm(len(c.dec)/4-1, &c.dec[0], &dst[0], &src[0])\n+}\n+\n+// expandKey is used by BenchmarkExpand to ensure that the asm implementation\n+// of key expansion is used for the benchmark when it is available.\n+func expandKey(key []byte, enc, dec []uint32) {\n+\tif useAsm {\n+\t\trounds := 10 // rounds needed for AES128\n+\t\tswitch len(key) {\n+\t\tcase 192 / 8:\n+\t\t\trounds = 12\n+\t\tcase 256 / 8:\n+\t\t\trounds = 14\n+\t\t}\n+\t\texpandKeyAsm(rounds, &key[0], &enc[0], &dec[0])\n+\t} else {\n+\t\texpandKeyGo(key, enc, dec)\n+\t}\n+}"}, {"sha": "964eaaa6f886f9f474be72e1832fa5a7c95d7e1f", "filename": "libgo/go/crypto/aes/cipher_asm.go", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d04a3af4c6491536badf6bde9707c907e4d196b/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_asm.go?ref=9d04a3af4c6491536badf6bde9707c907e4d196b", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build amd64\n-\n-package aes\n-\n-// defined in asm_$GOARCH.s\n-func hasAsm() bool\n-func encryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n-func decryptBlockAsm(nr int, xk *uint32, dst, src *byte)\n-func expandKeyAsm(nr int, key *byte, enc *uint32, dec *uint32)\n-\n-var useAsm = hasAsm()\n-\n-func encryptBlock(xk []uint32, dst, src []byte) {\n-\tif useAsm {\n-\t\tencryptBlockAsm(len(xk)/4-1, &xk[0], &dst[0], &src[0])\n-\t} else {\n-\t\tencryptBlockGo(xk, dst, src)\n-\t}\n-}\n-\n-func decryptBlock(xk []uint32, dst, src []byte) {\n-\tif useAsm {\n-\t\tdecryptBlockAsm(len(xk)/4-1, &xk[0], &dst[0], &src[0])\n-\t} else {\n-\t\tdecryptBlockGo(xk, dst, src)\n-\t}\n-}\n-\n-func expandKey(key []byte, enc, dec []uint32) {\n-\tif useAsm {\n-\t\trounds := 10\n-\t\tswitch len(key) {\n-\t\tcase 128 / 8:\n-\t\t\trounds = 10\n-\t\tcase 192 / 8:\n-\t\t\trounds = 12\n-\t\tcase 256 / 8:\n-\t\t\trounds = 14\n-\t\t}\n-\t\texpandKeyAsm(rounds, &key[0], &enc[0], &dec[0])\n-\t} else {\n-\t\texpandKeyGo(key, enc, dec)\n-\t}\n-}"}, {"sha": "f8070346e38c5d2885bc2f7ca17e6eb92111e9c6", "filename": "libgo/go/crypto/aes/cipher_generic.go", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,26 +2,25 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64\n+// +build !amd64,!s390x\n \n package aes\n \n-func encryptBlock(xk []uint32, dst, src []byte) {\n-\tencryptBlockGo(xk, dst, src)\n-}\n+import (\n+\t\"crypto/cipher\"\n+)\n \n-func decryptBlock(xk []uint32, dst, src []byte) {\n-\tdecryptBlockGo(xk, dst, src)\n+// newCipher calls the newCipherGeneric function\n+// directly. Platforms with hardware accelerated\n+// implementations of AES should implement their\n+// own version of newCipher (which may then call\n+// newCipherGeneric if needed).\n+func newCipher(key []byte) (cipher.Block, error) {\n+\treturn newCipherGeneric(key)\n }\n \n+// expandKey is used by BenchmarkExpand and should\n+// call an assembly implementation if one is available.\n func expandKey(key []byte, enc, dec []uint32) {\n \texpandKeyGo(key, enc, dec)\n }\n-\n-func hasGCMAsm() bool {\n-\treturn false\n-}\n-\n-type aesCipherGCM struct {\n-\taesCipher\n-}"}, {"sha": "bec59330132c52bf0f458ab83bf674afd2be7702", "filename": "libgo/go/crypto/aes/cipher_s390x.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+)\n+\n+type code int\n+\n+// Function codes for the cipher message family of instructions.\n+const (\n+\taes128 code = 18\n+\taes192      = 19\n+\taes256      = 20\n+)\n+\n+type aesCipherAsm struct {\n+\tfunction code      // code for cipher message instruction\n+\tkey      []byte    // key (128, 192 or 256 bytes)\n+\tstorage  [256]byte // array backing key slice\n+}\n+\n+// hasAsm reports whether the AES-128, AES-192 and AES-256\n+// cipher message (KM) function codes are supported.\n+// Note: this function call is expensive.\n+func hasAsm() bool\n+\n+// cryptBlocks invokes the cipher message (KM) instruction with\n+// the given function code. This is equivalent to AES in ECB\n+// mode. The length must be a multiple of BlockSize (16).\n+//go:noesape\n+func cryptBlocks(c code, key, dst, src *byte, length int)\n+\n+var useAsm = hasAsm()\n+\n+func newCipher(key []byte) (cipher.Block, error) {\n+\tif !useAsm {\n+\t\treturn newCipherGeneric(key)\n+\t}\n+\n+\tvar function code\n+\tswitch len(key) {\n+\tcase 128 / 8:\n+\t\tfunction = aes128\n+\tcase 192 / 8:\n+\t\tfunction = aes192\n+\tcase 256 / 8:\n+\t\tfunction = aes256\n+\tdefault:\n+\t\treturn nil, KeySizeError(len(key))\n+\t}\n+\n+\tvar c aesCipherAsm\n+\tc.function = function\n+\tc.key = c.storage[:len(key)]\n+\tcopy(c.key, key)\n+\treturn &c, nil\n+}\n+\n+func (c *aesCipherAsm) BlockSize() int { return BlockSize }\n+\n+func (c *aesCipherAsm) Encrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\tcryptBlocks(c.function, &c.key[0], &dst[0], &src[0], BlockSize)\n+}\n+\n+func (c *aesCipherAsm) Decrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\t// The decrypt function code is equal to the function code + 128.\n+\tcryptBlocks(c.function+128, &c.key[0], &dst[0], &src[0], BlockSize)\n+}\n+\n+// expandKey is used by BenchmarkExpand. cipher message (KM) does not need key\n+// expansion so there is no assembly equivalent.\n+func expandKey(key []byte, enc, dec []uint32) {\n+\texpandKeyGo(key, enc, dec)\n+}"}, {"sha": "94dea5ccdfee08159a96b790856c91abc38144e5", "filename": "libgo/go/crypto/aes/ctr_s390x.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fctr_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"unsafe\"\n+)\n+\n+// Assert that aesCipherAsm implements the ctrAble interface.\n+var _ ctrAble = (*aesCipherAsm)(nil)\n+\n+// xorBytes xors the contents of a and b and places the resulting values into\n+// dst. If a and b are not the same length then the number of bytes processed\n+// will be equal to the length of shorter of the two. Returns the number\n+// of bytes processed.\n+//go:noescape\n+func xorBytes(dst, a, b []byte) int\n+\n+// streamBufferSize is the number of bytes of encrypted counter values to cache.\n+const streamBufferSize = 32 * BlockSize\n+\n+type aesctr struct {\n+\tblock   *aesCipherAsm          // block cipher\n+\tctr     [2]uint64              // next value of the counter (big endian)\n+\tbuffer  []byte                 // buffer for the encrypted counter values\n+\tstorage [streamBufferSize]byte // array backing buffer slice\n+}\n+\n+// NewCTR returns a Stream which encrypts/decrypts using the AES block\n+// cipher in counter mode. The length of iv must be the same as BlockSize.\n+func (c *aesCipherAsm) NewCTR(iv []byte) cipher.Stream {\n+\tif len(iv) != BlockSize {\n+\t\tpanic(\"cipher.NewCTR: IV length must equal block size\")\n+\t}\n+\tvar ac aesctr\n+\tac.block = c\n+\tac.ctr[0] = *(*uint64)(unsafe.Pointer((&iv[0]))) // high bits\n+\tac.ctr[1] = *(*uint64)(unsafe.Pointer((&iv[8]))) // low bits\n+\tac.buffer = ac.storage[:0]\n+\treturn &ac\n+}\n+\n+func (c *aesctr) refill() {\n+\t// Fill up the buffer with an incrementing count.\n+\tc.buffer = c.storage[:streamBufferSize]\n+\tc0, c1 := c.ctr[0], c.ctr[1]\n+\tfor i := 0; i < streamBufferSize; i += BlockSize {\n+\t\tb0 := (*uint64)(unsafe.Pointer(&c.buffer[i]))\n+\t\tb1 := (*uint64)(unsafe.Pointer(&c.buffer[i+BlockSize/2]))\n+\t\t*b0, *b1 = c0, c1\n+\t\t// Increment in big endian: c0 is high, c1 is low.\n+\t\tc1++\n+\t\tif c1 == 0 {\n+\t\t\t// add carry\n+\t\t\tc0++\n+\t\t}\n+\t}\n+\tc.ctr[0], c.ctr[1] = c0, c1\n+\t// Encrypt the buffer using AES in ECB mode.\n+\tcryptBlocks(c.block.function, &c.block.key[0], &c.buffer[0], &c.buffer[0], streamBufferSize)\n+}\n+\n+func (c *aesctr) XORKeyStream(dst, src []byte) {\n+\tfor len(src) > 0 {\n+\t\tif len(c.buffer) == 0 {\n+\t\t\tc.refill()\n+\t\t}\n+\t\tn := xorBytes(dst, src, c.buffer)\n+\t\tc.buffer = c.buffer[n:]\n+\t\tsrc = src[n:]\n+\t\tdst = dst[n:]\n+\t}\n+}"}, {"sha": "1623fc16e22bdfc2da4df5c9c55bc19d1dedb5a2", "filename": "libgo/go/crypto/aes/modes.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+)\n+\n+// gcmAble is implemented by cipher.Blocks that can provide an optimized\n+// implementation of GCM through the AEAD interface.\n+// See crypto/cipher/gcm.go.\n+type gcmAble interface {\n+\tNewGCM(size int) (cipher.AEAD, error)\n+}\n+\n+// cbcEncAble is implemented by cipher.Blocks that can provide an optimized\n+// implementation of CBC encryption through the cipher.BlockMode interface.\n+// See crypto/cipher/cbc.go.\n+type cbcEncAble interface {\n+\tNewCBCEncrypter(iv []byte) cipher.BlockMode\n+}\n+\n+// cbcDecAble is implemented by cipher.Blocks that can provide an optimized\n+// implementation of CBC decryption through the cipher.BlockMode interface.\n+// See crypto/cipher/cbc.go.\n+type cbcDecAble interface {\n+\tNewCBCDecrypter(iv []byte) cipher.BlockMode\n+}\n+\n+// ctrAble is implemented by cipher.Blocks that can provide an optimized\n+// implementation of CTR through the cipher.Stream interface.\n+// See crypto/cipher/ctr.go.\n+type ctrAble interface {\n+\tNewCTR(iv []byte) cipher.Stream\n+}"}, {"sha": "8c2e5f0560a4f3bb2411915566efc68271520d93", "filename": "libgo/go/crypto/aes/modes_test.go", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fmodes_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"testing\"\n+)\n+\n+// Check that the optimized implementations of cipher modes will\n+// be picked up correctly.\n+\n+// testInterface can be asserted to check that a type originates\n+// from this test group.\n+type testInterface interface {\n+\tInAESPackage() bool\n+}\n+\n+// testBlock implements the cipher.Block interface and any *Able\n+// interfaces that need to be tested.\n+type testBlock struct{}\n+\n+func (*testBlock) BlockSize() int      { return 0 }\n+func (*testBlock) Encrypt(a, b []byte) {}\n+func (*testBlock) Decrypt(a, b []byte) {}\n+func (*testBlock) NewGCM(int) (cipher.AEAD, error) {\n+\treturn &testAEAD{}, nil\n+}\n+func (*testBlock) NewCBCEncrypter([]byte) cipher.BlockMode {\n+\treturn &testBlockMode{}\n+}\n+func (*testBlock) NewCBCDecrypter([]byte) cipher.BlockMode {\n+\treturn &testBlockMode{}\n+}\n+func (*testBlock) NewCTR([]byte) cipher.Stream {\n+\treturn &testStream{}\n+}\n+\n+// testAEAD implements the cipher.AEAD interface.\n+type testAEAD struct{}\n+\n+func (*testAEAD) NonceSize() int                         { return 0 }\n+func (*testAEAD) Overhead() int                          { return 0 }\n+func (*testAEAD) Seal(a, b, c, d []byte) []byte          { return []byte{} }\n+func (*testAEAD) Open(a, b, c, d []byte) ([]byte, error) { return []byte{}, nil }\n+func (*testAEAD) InAESPackage() bool                     { return true }\n+\n+// Test the gcmAble interface is detected correctly by the cipher package.\n+func TestGCMAble(t *testing.T) {\n+\tb := cipher.Block(&testBlock{})\n+\tif _, ok := b.(gcmAble); !ok {\n+\t\tt.Fatalf(\"testBlock does not implement the gcmAble interface\")\n+\t}\n+\taead, err := cipher.NewGCM(b)\n+\tif err != nil {\n+\t\tt.Fatalf(\"%v\", err)\n+\t}\n+\tif _, ok := aead.(testInterface); !ok {\n+\t\tt.Fatalf(\"cipher.NewGCM did not use gcmAble interface\")\n+\t}\n+}\n+\n+// testBlockMode implements the cipher.BlockMode interface.\n+type testBlockMode struct{}\n+\n+func (*testBlockMode) BlockSize() int          { return 0 }\n+func (*testBlockMode) CryptBlocks(a, b []byte) {}\n+func (*testBlockMode) InAESPackage() bool      { return true }\n+\n+// Test the cbcEncAble interface is detected correctly by the cipher package.\n+func TestCBCEncAble(t *testing.T) {\n+\tb := cipher.Block(&testBlock{})\n+\tif _, ok := b.(cbcEncAble); !ok {\n+\t\tt.Fatalf(\"testBlock does not implement the cbcEncAble interface\")\n+\t}\n+\tbm := cipher.NewCBCEncrypter(b, []byte{})\n+\tif _, ok := bm.(testInterface); !ok {\n+\t\tt.Fatalf(\"cipher.NewCBCEncrypter did not use cbcEncAble interface\")\n+\t}\n+}\n+\n+// Test the cbcDecAble interface is detected correctly by the cipher package.\n+func TestCBCDecAble(t *testing.T) {\n+\tb := cipher.Block(&testBlock{})\n+\tif _, ok := b.(cbcDecAble); !ok {\n+\t\tt.Fatalf(\"testBlock does not implement the cbcDecAble interface\")\n+\t}\n+\tbm := cipher.NewCBCDecrypter(b, []byte{})\n+\tif _, ok := bm.(testInterface); !ok {\n+\t\tt.Fatalf(\"cipher.NewCBCDecrypter did not use cbcDecAble interface\")\n+\t}\n+}\n+\n+// testStream implements the cipher.Stream interface.\n+type testStream struct{}\n+\n+func (*testStream) XORKeyStream(a, b []byte) {}\n+func (*testStream) InAESPackage() bool       { return true }\n+\n+// Test the ctrAble interface is detected correctly by the cipher package.\n+func TestCTRAble(t *testing.T) {\n+\tb := cipher.Block(&testBlock{})\n+\tif _, ok := b.(ctrAble); !ok {\n+\t\tt.Fatalf(\"testBlock does not implement the ctrAble interface\")\n+\t}\n+\ts := cipher.NewCTR(b, []byte{})\n+\tif _, ok := s.(testInterface); !ok {\n+\t\tt.Fatalf(\"cipher.NewCTR did not use ctrAble interface\")\n+\t}\n+}"}, {"sha": "0367d5971a6b803404de46b1e7837c439ae2509a", "filename": "libgo/go/crypto/cipher/cbc.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -29,13 +29,24 @@ func newCBC(b Block, iv []byte) *cbc {\n \n type cbcEncrypter cbc\n \n+// cbcEncAble is an interface implemented by ciphers that have a specific\n+// optimized implementation of CBC encryption, like crypto/aes.\n+// NewCBCEncrypter will check for this interface and return the specific\n+// BlockMode if found.\n+type cbcEncAble interface {\n+\tNewCBCEncrypter(iv []byte) BlockMode\n+}\n+\n // NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\n // mode, using the given Block. The length of iv must be the same as the\n // Block's block size.\n func NewCBCEncrypter(b Block, iv []byte) BlockMode {\n \tif len(iv) != b.BlockSize() {\n \t\tpanic(\"cipher.NewCBCEncrypter: IV length must equal block size\")\n \t}\n+\tif cbc, ok := b.(cbcEncAble); ok {\n+\t\treturn cbc.NewCBCEncrypter(iv)\n+\t}\n \treturn (*cbcEncrypter)(newCBC(b, iv))\n }\n \n@@ -75,13 +86,24 @@ func (x *cbcEncrypter) SetIV(iv []byte) {\n \n type cbcDecrypter cbc\n \n+// cbcDecAble is an interface implemented by ciphers that have a specific\n+// optimized implementation of CBC decryption, like crypto/aes.\n+// NewCBCDecrypter will check for this interface and return the specific\n+// BlockMode if found.\n+type cbcDecAble interface {\n+\tNewCBCDecrypter(iv []byte) BlockMode\n+}\n+\n // NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\n // mode, using the given Block. The length of iv must be the same as the\n // Block's block size and must match the iv used to encrypt the data.\n func NewCBCDecrypter(b Block, iv []byte) BlockMode {\n \tif len(iv) != b.BlockSize() {\n \t\tpanic(\"cipher.NewCBCDecrypter: IV length must equal block size\")\n \t}\n+\tif cbc, ok := b.(cbcDecAble); ok {\n+\t\treturn cbc.NewCBCDecrypter(iv)\n+\t}\n \treturn (*cbcDecrypter)(newCBC(b, iv))\n }\n "}, {"sha": "531ecad9ac00febd80a85475b27f4a209e751fa4", "filename": "libgo/go/crypto/cipher/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -9,8 +9,8 @@\n package cipher\n \n // A Block represents an implementation of block cipher\n-// using a given key.  It provides the capability to encrypt\n-// or decrypt individual blocks.  The mode implementations\n+// using a given key. It provides the capability to encrypt\n+// or decrypt individual blocks. The mode implementations\n // extend that capability to streams of blocks.\n type Block interface {\n \t// BlockSize returns the cipher's block size."}, {"sha": "1faa7b87e526a0313d8838c77ef40239b56763bc", "filename": "libgo/go/crypto/cipher/cipher_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "75f46cfe512a97502a887f80c25f2a3ea0876526", "filename": "libgo/go/crypto/cipher/ctr.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -21,9 +21,19 @@ type ctr struct {\n \n const streamBufferSize = 512\n \n+// ctrAble is an interface implemented by ciphers that have a specific optimized\n+// implementation of CTR, like crypto/aes. NewCTR will check for this interface\n+// and return the specific Stream if found.\n+type ctrAble interface {\n+\tNewCTR(iv []byte) Stream\n+}\n+\n // NewCTR returns a Stream which encrypts/decrypts using the given Block in\n // counter mode. The length of iv must be the same as the Block's block size.\n func NewCTR(block Block, iv []byte) Stream {\n+\tif ctr, ok := block.(ctrAble); ok {\n+\t\treturn ctr.NewCTR(iv)\n+\t}\n \tif len(iv) != block.BlockSize() {\n \t\tpanic(\"cipher.NewCTR: IV length must equal block size\")\n \t}"}, {"sha": "9abe782bca54aec85416bb8a72ea64127b934adb", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -44,9 +44,9 @@ func ExampleNewGCMDecrypter() {\n \t// The key argument should be the AES key, either 16 or 32 bytes\n \t// to select AES-128 or AES-256.\n \tkey := []byte(\"AES256Key-32Characters1234567890\")\n-\tciphertext, _ := hex.DecodeString(\"f90fbef747e7212ad7410d0eee2d965de7e890471695cddd2a5bc0ef5da1d04ad8147b62141ad6e4914aee8c512f64fba9037603d41de0d50b718bd665f019cdcd\")\n+\tciphertext, _ := hex.DecodeString(\"1019aa66cd7c024f9efd0038899dae1973ee69427f5a6579eba292ffe1b5a260\")\n \n-\tnonce, _ := hex.DecodeString(\"bb8ef84243d2ee95a41c6c57\")\n+\tnonce, _ := hex.DecodeString(\"37b8e8a308c354048d245f6d\")\n \n \tblock, err := aes.NewCipher(key)\n \tif err != nil {\n@@ -63,7 +63,8 @@ func ExampleNewGCMDecrypter() {\n \t\tpanic(err.Error())\n \t}\n \n-\tfmt.Printf(\"%s\\n\", string(plaintext))\n+\tfmt.Printf(\"%s\\n\", plaintext)\n+\t// Output: exampleplaintext\n }\n \n func ExampleNewCBCDecrypter() {"}, {"sha": "01ca0a9f086f8bf8bda27460b088c2c23a7d43bf", "filename": "libgo/go/crypto/cipher/xor.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -10,7 +10,7 @@ import (\n )\n \n const wordSize = int(unsafe.Sizeof(uintptr(0)))\n-const supportsUnaligned = runtime.GOARCH == \"386\" || runtime.GOARCH == \"amd64\"\n+const supportsUnaligned = runtime.GOARCH == \"386\" || runtime.GOARCH == \"amd64\" || runtime.GOARCH == \"ppc64\" || runtime.GOARCH == \"ppc64le\" || runtime.GOARCH == \"s390x\"\n \n // fastXORBytes xors in bulk. It only works on architectures that\n // support unaligned read/writes."}, {"sha": "d9187eb72638508dfa14baab795d338cc7bc463a", "filename": "libgo/go/crypto/cipher/xor_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fxor_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -19,7 +19,7 @@ func TestXOR(t *testing.T) {\n \t\t\t\td2 := make([]byte, 1024+alignD)[alignD:]\n \t\t\t\txorBytes(d1, p, q)\n \t\t\t\tsafeXORBytes(d2, p, q)\n-\t\t\t\tif bytes.Compare(d1, d2) != 0 {\n+\t\t\t\tif !bytes.Equal(d1, d2) {\n \t\t\t\t\tt.Error(\"not equal\")\n \t\t\t\t}\n \t\t\t}"}, {"sha": "99338d62a6e0d35bdfb6bb61d44ce27d0151880d", "filename": "libgo/go/crypto/des/block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -72,7 +72,7 @@ func init() {\n \t\tfor i := 0; i < 4; i++ {\n \t\t\tfor j := 0; j < 16; j++ {\n \t\t\t\tf := uint64(sBoxes[s][i][j]) << (4 * (7 - uint(s)))\n-\t\t\t\tf = permuteBlock(uint64(f), permutationFunction[:])\n+\t\t\t\tf = permuteBlock(f, permutationFunction[:])\n \t\t\t\tfeistelBox[s][16*i+j] = uint32(f)\n \t\t\t}\n \t\t}"}, {"sha": "e9b6a0c25328a000a24066de31a1d7588e426754", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -52,7 +52,7 @@ const numMRTests = 64\n \n // GenerateParameters puts a random, valid set of DSA parameters into params.\n // This function can take many seconds, even on fast machines.\n-func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) (err error) {\n+func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error {\n \t// This function doesn't follow FIPS 186-3 exactly in that it doesn't\n \t// use a verification seed to generate the primes. The verification\n \t// seed doesn't appear to be exported or used by other code and\n@@ -87,9 +87,8 @@ func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes\n \n GeneratePrimes:\n \tfor {\n-\t\t_, err = io.ReadFull(rand, qBytes)\n-\t\tif err != nil {\n-\t\t\treturn\n+\t\tif _, err := io.ReadFull(rand, qBytes); err != nil {\n+\t\t\treturn err\n \t\t}\n \n \t\tqBytes[len(qBytes)-1] |= 1\n@@ -101,9 +100,8 @@ GeneratePrimes:\n \t\t}\n \n \t\tfor i := 0; i < 4*L; i++ {\n-\t\t\t_, err = io.ReadFull(rand, pBytes)\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n+\t\t\tif _, err := io.ReadFull(rand, pBytes); err != nil {\n+\t\t\t\treturn err\n \t\t\t}\n \n \t\t\tpBytes[len(pBytes)-1] |= 1\n@@ -142,7 +140,7 @@ GeneratePrimes:\n \t\t}\n \n \t\tparams.G = g\n-\t\treturn\n+\t\treturn nil\n \t}\n }\n "}, {"sha": "72fb49934fcc63e540fc21638397ed0c8e5f126f", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -97,17 +97,17 @@ func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error)\n }\n \n // GenerateKey generates a public and private key pair.\n-func GenerateKey(c elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error) {\n+func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {\n \tk, err := randFieldElement(c, rand)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n-\tpriv = new(PrivateKey)\n+\tpriv := new(PrivateKey)\n \tpriv.PublicKey.Curve = c\n \tpriv.D = k\n \tpriv.PublicKey.X, priv.PublicKey.Y = c.ScalarBaseMult(k.Bytes())\n-\treturn\n+\treturn priv, nil\n }\n \n // hashToInt converts a hash value to an integer. There is some disagreement\n@@ -143,10 +143,11 @@ func fermatInverse(k, N *big.Int) *big.Int {\n \n var errZeroParam = errors.New(\"zero parameter\")\n \n-// Sign signs an arbitrary length hash (which should be the result of hashing a\n-// larger message) using the private key, priv. It returns the signature as a\n-// pair of integers. The security of the private key depends on the entropy of\n-// rand.\n+// Sign signs a hash (which should be the result of hashing a larger message)\n+// using the private key, priv. If the hash is longer than the bit-length of the\n+// private key's curve order, the hash will be truncated to that length.  It\n+// returns the signature as a pair of integers. The security of the private key\n+// depends on the entropy of rand.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n \t// Get max(log2(q) / 2, 256) bits of entropy from rand.\n \tentropylen := (priv.Curve.Params().BitSize + 7) / 16\n@@ -228,7 +229,7 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \tc := pub.Curve\n \tN := c.Params().N\n \n-\tif r.Sign() == 0 || s.Sign() == 0 {\n+\tif r.Sign() <= 0 || s.Sign() <= 0 {\n \t\treturn false\n \t}\n \tif r.Cmp(N) >= 0 || s.Cmp(N) >= 0 {"}, {"sha": "fc25fd74a78ce7285bcdf96972fcdbdd577e7888", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -130,7 +130,7 @@ func testNonceSafety(t *testing.T, c elliptic.Curve, tag string) {\n \t}\n \n \tif r0.Cmp(r1) == 0 {\n-\t\tt.Errorf(\"%s: the nonce used for two diferent messages was the same\", tag)\n+\t\tt.Errorf(\"%s: the nonce used for two different messages was the same\", tag)\n \t}\n }\n \n@@ -296,3 +296,26 @@ func TestVectors(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func testNegativeInputs(t *testing.T, curve elliptic.Curve, tag string) {\n+\tkey, err := GenerateKey(curve, rand.Reader)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to generate key for %q\", tag)\n+\t}\n+\n+\tvar hash [32]byte\n+\tr := new(big.Int).SetInt64(1)\n+\tr.Lsh(r, 550 /* larger than any supported curve */)\n+\tr.Neg(r)\n+\n+\tif Verify(&key.PublicKey, hash[:], r, r) {\n+\t\tt.Errorf(\"bogus signature accepted for %q\", tag)\n+\t}\n+}\n+\n+func TestNegativeInputs(t *testing.T) {\n+\ttestNegativeInputs(t, elliptic.P224(), \"p224\")\n+\ttestNegativeInputs(t, elliptic.P256(), \"p256\")\n+\ttestNegativeInputs(t, elliptic.P384(), \"p384\")\n+\ttestNegativeInputs(t, elliptic.P521(), \"p521\")\n+}"}, {"sha": "de266ca77a773efd404da2668c666d0b79b738b8", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "8b4fa0483b6a04bceb0164c0b64f6ee3a035f848", "filename": "libgo/go/crypto/elliptic/p224_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "05a3311b2903c1fcd0ba796712169586175f1932", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -1056,7 +1056,7 @@ func p256ScalarBaseMult(xOut, yOut, zOut *[p256Limbs]uint32, scalar *[32]uint8)\n \t\t\tp256CopyConditional(yOut, &ty, mask)\n \t\t\tp256CopyConditional(zOut, &tz, mask)\n \t\t\t// If p was not zero, then n is now non-zero.\n-\t\t\tnIsInfinityMask &= ^pIsNoninfiniteMask\n+\t\t\tnIsInfinityMask &^= pIsNoninfiniteMask\n \t\t}\n \t}\n }\n@@ -1136,7 +1136,7 @@ func p256ScalarMult(xOut, yOut, zOut, x, y *[p256Limbs]uint32, scalar *[32]uint8\n \t\tp256CopyConditional(xOut, &tx, mask)\n \t\tp256CopyConditional(yOut, &ty, mask)\n \t\tp256CopyConditional(zOut, &tz, mask)\n-\t\tnIsInfinityMask &= ^pIsNoninfiniteMask\n+\t\tnIsInfinityMask &^= pIsNoninfiniteMask\n \t}\n }\n "}, {"sha": "66b7cf8dc512a4948ab68a1bce75834377e93573", "filename": "libgo/go/crypto/elliptic/p256_amd64.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256_amd64.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -66,7 +66,7 @@ func p256NegCond(val []uint64, cond int)\n // if cond == 0 res <- b; else res <- a\n func p256MovCond(res, a, b []uint64, cond int)\n \n-// Endianess swap\n+// Endianness swap\n func p256BigToLittle(res []uint64, in []byte)\n func p256LittleToBig(res []byte, in []uint64)\n \n@@ -93,10 +93,14 @@ func p256PointAddAsm(res, in1, in2 []uint64)\n func p256PointDoubleAsm(res, in []uint64)\n \n func (curve p256Curve) Inverse(k *big.Int) *big.Int {\n+\tif k.Sign() < 0 {\n+\t\t// This should never happen.\n+\t\tk = new(big.Int).Neg(k)\n+\t}\n+\n \tif k.Cmp(p256.N) >= 0 {\n \t\t// This should never happen.\n-\t\treducedK := new(big.Int).Mod(k, p256.N)\n-\t\tk = reducedK\n+\t\tk = new(big.Int).Mod(k, p256.N)\n \t}\n \n \t// table will store precomputed powers of x. The four words at index"}, {"sha": "a7481078388240a6b6ca86159d44022e06182092", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -37,26 +37,16 @@ import (\n type hmac struct {\n \tsize         int\n \tblocksize    int\n-\tkey, tmp     []byte\n+\topad, ipad   []byte\n \touter, inner hash.Hash\n }\n \n-func (h *hmac) tmpPad(xor byte) {\n-\tfor i, k := range h.key {\n-\t\th.tmp[i] = xor ^ k\n-\t}\n-\tfor i := len(h.key); i < h.blocksize; i++ {\n-\t\th.tmp[i] = xor\n-\t}\n-}\n-\n func (h *hmac) Sum(in []byte) []byte {\n \torigLen := len(in)\n \tin = h.inner.Sum(in)\n-\th.tmpPad(0x5c)\n-\tcopy(h.tmp[h.blocksize:], in[origLen:])\n \th.outer.Reset()\n-\th.outer.Write(h.tmp)\n+\th.outer.Write(h.opad)\n+\th.outer.Write(in[origLen:])\n \treturn h.outer.Sum(in[:origLen])\n }\n \n@@ -70,8 +60,7 @@ func (h *hmac) BlockSize() int { return h.blocksize }\n \n func (h *hmac) Reset() {\n \th.inner.Reset()\n-\th.tmpPad(0x36)\n-\th.inner.Write(h.tmp[:h.blocksize])\n+\th.inner.Write(h.ipad)\n }\n \n // New returns a new HMAC hash using the given hash.Hash type and key.\n@@ -81,15 +70,22 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \thm.inner = h()\n \thm.size = hm.inner.Size()\n \thm.blocksize = hm.inner.BlockSize()\n-\thm.tmp = make([]byte, hm.blocksize+hm.size)\n+\thm.ipad = make([]byte, hm.blocksize)\n+\thm.opad = make([]byte, hm.blocksize)\n \tif len(key) > hm.blocksize {\n \t\t// If key is too big, hash it.\n \t\thm.outer.Write(key)\n \t\tkey = hm.outer.Sum(nil)\n \t}\n-\thm.key = make([]byte, len(key))\n-\tcopy(hm.key, key)\n-\thm.Reset()\n+\tcopy(hm.ipad, key)\n+\tcopy(hm.opad, key)\n+\tfor i := range hm.ipad {\n+\t\thm.ipad[i] ^= 0x36\n+\t}\n+\tfor i := range hm.opad {\n+\t\thm.opad[i] ^= 0x5c\n+\t}\n+\thm.inner.Write(hm.ipad)\n \treturn hm\n }\n "}, {"sha": "aac9aa96a8ece496e4af4120ea556b51dbfdac34", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -568,3 +568,29 @@ func TestEqual(t *testing.T) {\n \t\tt.Error(\"Equal accepted unequal slices\")\n \t}\n }\n+\n+func BenchmarkHMACSHA256_1K(b *testing.B) {\n+\tkey := make([]byte, 32)\n+\tbuf := make([]byte, 1024)\n+\th := New(sha256.New, key)\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\th.Write(buf)\n+\t\th.Reset()\n+\t\tmac := h.Sum(nil)\n+\t\tbuf[0] = mac[0]\n+\t}\n+}\n+\n+func BenchmarkHMACSHA256_32(b *testing.B) {\n+\tkey := make([]byte, 32)\n+\tbuf := make([]byte, 32)\n+\th := New(sha256.New, key)\n+\tb.SetBytes(int64(len(buf)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\th.Write(buf)\n+\t\th.Reset()\n+\t\tmac := h.Sum(nil)\n+\t\tbuf[0] = mac[0]\n+\t}\n+}"}, {"sha": "178fad18285730cea71a658458cd56c9a55259f7", "filename": "libgo/go/crypto/md5/gen.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Go Authors.  All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "ce58d5e713a55a43777c9a879fd84cf38eeb7ed6", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -89,7 +89,7 @@ func (d0 *digest) Sum(in []byte) []byte {\n }\n \n func (d *digest) checkSum() [Size]byte {\n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n+\t// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tlen := d.len\n \tvar tmp [64]byte\n \ttmp[0] = 0x80"}, {"sha": "1e6f6e60544648e7ec0a7a3c9c7e07b397bf4c50", "filename": "libgo/go/crypto/md5/md5block_decl.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_decl.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,8 +1,8 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 amd64p32 386 arm\n+// +build amd64 amd64p32 386 arm ppc64le s390x\n \n package md5\n "}, {"sha": "726e09b985ceba41af509929a23194d465da922a", "filename": "libgo/go/crypto/md5/md5block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block_generic.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!386,!arm\n+// +build !amd64,!amd64p32,!386,!arm,!ppc64le,!s390x\n \n package md5\n "}, {"sha": "7ed2f47ea6621a2cb01b2b8fb9af13475a940709", "filename": "libgo/go/crypto/rand/eagain.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "6f7523d9d733853d8f1722a53b7466ad8e7de5c5", "filename": "libgo/go/crypto/rand/rand.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -11,8 +11,9 @@ import \"io\"\n // Reader is a global, shared instance of a cryptographically\n // strong pseudo-random generator.\n //\n-// On Unix-like systems, Reader reads from /dev/urandom.\n // On Linux, Reader uses getrandom(2) if available, /dev/urandom otherwise.\n+// On OpenBSD, Reader uses getentropy(2).\n+// On other Unix-like systems, Reader reads from /dev/urandom.\n // On Windows systems, Reader uses the CryptGenRandom API.\n var Reader io.Reader\n "}, {"sha": "472daa7650b7a2ce869e63441994a345bb6e0844", "filename": "libgo/go/crypto/rand/rand_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n+// Copyright 2014 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "9cc39f72d1d9b221563ab37717dd1931daab0f28", "filename": "libgo/go/crypto/rand/rand_openbsd.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_openbsd.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rand\n+\n+import (\n+\t\"internal/syscall/unix\"\n+)\n+\n+func init() {\n+\taltGetRandom = getRandomOpenBSD\n+}\n+\n+func getRandomOpenBSD(p []byte) (ok bool) {\n+\t// getentropy(2) returns a maximum of 256 bytes per call\n+\tfor i := 0; i < len(p); i += 256 {\n+\t\tend := i + 256\n+\t\tif len(p) < end {\n+\t\t\tend = len(p)\n+\t\t}\n+\t\terr := unix.GetEntropy(p[i:end])\n+\t\tif err != nil {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "e45f58e4e7a1982374bb0ab0327f11337983965d", "filename": "libgo/go/crypto/rand/rand_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "631972b92ac5e889870eed11e22ef680ff042333", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -84,7 +84,7 @@ func (hr hideAgainReader) Read(p []byte) (n int, err error) {\n // systems without a reliable /dev/urandom.\n \n // newReader returns a new pseudorandom generator that\n-// seeds itself by reading from entropy.  If entropy == nil,\n+// seeds itself by reading from entropy. If entropy == nil,\n // the generator seeds itself by reading from the system's\n // random number generator, typically /dev/random.\n // The Read method on the returned reader always returns"}, {"sha": "4d7511a84004100a20f6615cb1d8a5ee8efb8597", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "592c57e76386e97859580e70bb2854759e2cbef9", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -70,7 +70,7 @@ func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \n \t\tp.SetBytes(bytes)\n \n-\t\t// Calculate the value mod the product of smallPrimes.  If it's\n+\t\t// Calculate the value mod the product of smallPrimes. If it's\n \t\t// a multiple of any of these primes we add two until it isn't.\n \t\t// The probability of overflowing is minimal and can be ignored\n \t\t// because we still perform Miller-Rabin tests on the result."}, {"sha": "7b076896767f554d39b0b019596aab823569e96e", "filename": "libgo/go/crypto/rand/util_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "bd04aee69559dd4f8e54d88ded2909391f8222fb", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -23,7 +23,7 @@ func (k KeySizeError) Error() string {\n \treturn \"crypto/rc4: invalid key size \" + strconv.Itoa(int(k))\n }\n \n-// NewCipher creates and returns a new Cipher.  The key argument should be the\n+// NewCipher creates and returns a new Cipher. The key argument should be the\n // RC4 key, at least 1 byte and at most 256 bytes.\n func NewCipher(key []byte) (*Cipher, error) {\n \tk := len(key)\n@@ -52,7 +52,7 @@ func (c *Cipher) Reset() {\n }\n \n // xorKeyStreamGeneric sets dst to the result of XORing src with the\n-// key stream.  Dst and src may be the same slice but otherwise should\n+// key stream. Dst and src may be the same slice but otherwise should\n // not overlap.\n //\n // This is the pure Go version. rc4_{amd64,386,arm}* contain assembly"}, {"sha": "3517a8c776c668d31299cf2f3d0beceaeceab381", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -24,31 +24,32 @@ type PKCS1v15DecryptOptions struct {\n \tSessionKeyLen int\n }\n \n-// EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5.\n-// The message must be no longer than the length of the public modulus minus 11 bytes.\n+// EncryptPKCS1v15 encrypts the given message with RSA and the padding\n+// scheme from PKCS#1 v1.5.  The message must be no longer than the\n+// length of the public modulus minus 11 bytes.\n //\n-// The rand parameter is used as a source of entropy to ensure that encrypting\n-// the same message twice doesn't result in the same ciphertext.\n+// The rand parameter is used as a source of entropy to ensure that\n+// encrypting the same message twice doesn't result in the same\n+// ciphertext.\n //\n-// WARNING: use of this function to encrypt plaintexts other than session keys\n-// is dangerous. Use RSA OAEP in new protocols.\n-func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error) {\n+// WARNING: use of this function to encrypt plaintexts other than\n+// session keys is dangerous. Use RSA OAEP in new protocols.\n+func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error) {\n \tif err := checkPub(pub); err != nil {\n \t\treturn nil, err\n \t}\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-11 {\n-\t\terr = ErrMessageTooLong\n-\t\treturn\n+\t\treturn nil, ErrMessageTooLong\n \t}\n \n \t// EM = 0x00 || 0x02 || PS || 0x00 || M\n \tem := make([]byte, k)\n \tem[1] = 2\n \tps, mm := em[2:len(em)-len(msg)-1], em[len(em)-len(msg):]\n-\terr = nonZeroRandomBytes(ps, rand)\n+\terr := nonZeroRandomBytes(ps, rand)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \tem[len(em)-len(msg)-1] = 0\n \tcopy(mm, msg)\n@@ -57,8 +58,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n \tc := encrypt(new(big.Int), pub, m)\n \n \tcopyWithLeftPad(em, c.Bytes())\n-\tout = em\n-\treturn\n+\treturn em, nil\n }\n \n // DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\n@@ -69,19 +69,18 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n // learn whether each instance returned an error then they can decrypt and\n // forge signatures as if they had the private key. See\n // DecryptPKCS1v15SessionKey for a way of solving this problem.\n-func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error) {\n+func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error) {\n \tif err := checkPub(&priv.PublicKey); err != nil {\n \t\treturn nil, err\n \t}\n \tvalid, out, index, err := decryptPKCS1v15(rand, priv, ciphertext)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \tif valid == 0 {\n \t\treturn nil, ErrDecryption\n \t}\n-\tout = out[index:]\n-\treturn\n+\treturn out[index:], nil\n }\n \n // DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\n@@ -103,7 +102,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [\n // a random value was used (because it'll be different for the same ciphertext)\n // and thus whether the padding was correct. This defeats the point of this\n // function. Using at least a 16-byte key will protect against this attack.\n-func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err error) {\n+func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error {\n \tif err := checkPub(&priv.PublicKey); err != nil {\n \t\treturn err\n \t}\n@@ -114,7 +113,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by\n \n \tvalid, em, index, err := decryptPKCS1v15(rand, priv, ciphertext)\n \tif err != nil {\n-\t\treturn\n+\t\treturn err\n \t}\n \n \tif len(em) != k {\n@@ -125,7 +124,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by\n \n \tvalid &= subtle.ConstantTimeEq(int32(len(em)-index), int32(len(key)))\n \tsubtle.ConstantTimeCopy(valid, key, em[len(em)-len(key):])\n-\treturn\n+\treturn nil\n }\n \n // decryptPKCS1v15 decrypts ciphertext using priv and blinds the operation if\n@@ -213,21 +212,23 @@ var hashPrefixes = map[crypto.Hash][]byte{\n \tcrypto.RIPEMD160: {0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14},\n }\n \n-// SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.\n-// Note that hashed must be the result of hashing the input message using the\n-// given hash function. If hash is zero, hashed is signed directly. This isn't\n+// SignPKCS1v15 calculates the signature of hashed using\n+// RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\n+// be the result of hashing the input message using the given hash\n+// function. If hash is zero, hashed is signed directly. This isn't\n // advisable except for interoperability.\n //\n-// If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.\n+// If rand is not nil then RSA blinding will be used to avoid timing\n+// side-channel attacks.\n //\n-// This function is deterministic. Thus, if the set of possible messages is\n-// small, an attacker may be able to build a map from messages to signatures\n-// and identify the signed messages. As ever, signatures provide authenticity,\n-// not confidentiality.\n-func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err error) {\n+// This function is deterministic. Thus, if the set of possible\n+// messages is small, an attacker may be able to build a map from\n+// messages to signatures and identify the signed messages. As ever,\n+// signatures provide authenticity, not confidentiality.\n+func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error) {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n \ttLen := len(prefix) + hashLen\n@@ -248,30 +249,28 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []b\n \tm := new(big.Int).SetBytes(em)\n \tc, err := decryptAndCheck(rand, priv, m)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n \tcopyWithLeftPad(em, c.Bytes())\n-\ts = em\n-\treturn\n+\treturn em, nil\n }\n \n // VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\n // hashed is the result of hashing the input message using the given hash\n // function and sig is the signature. A valid signature is indicated by\n // returning a nil error. If hash is zero then hashed is used directly. This\n // isn't advisable except for interoperability.\n-func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err error) {\n+func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n-\t\treturn\n+\t\treturn err\n \t}\n \n \ttLen := len(prefix) + hashLen\n \tk := (pub.N.BitLen() + 7) / 8\n \tif k < tLen+11 {\n-\t\terr = ErrVerification\n-\t\treturn\n+\t\treturn ErrVerification\n \t}\n \n \tc := new(big.Int).SetBytes(sig)"}, {"sha": "1ba194a4ad2c5ded862701f2ebbee0ea14e5a059", "filename": "libgo/go/crypto/rsa/pss.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -64,7 +64,7 @@ func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byt\n \thash.Reset()\n \n \t// 7.  Generate an octet string PS consisting of emLen - sLen - hLen - 2\n-\t//     zero octets.  The length of PS may be 0.\n+\t//     zero octets. The length of PS may be 0.\n \t//\n \t// 8.  Let DB = PS || 0x01 || salt; DB is an octet string of length\n \t//     emLen - hLen - 1.\n@@ -246,7 +246,7 @@ func (opts *PSSOptions) saltLength() int {\n // Note that hashed must be the result of hashing the input message using the\n // given hash function. The opts argument may be nil, in which case sensible\n // defaults are used.\n-func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) (s []byte, err error) {\n+func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error) {\n \tsaltLength := opts.saltLength()\n \tswitch saltLength {\n \tcase PSSSaltLengthAuto:\n@@ -260,8 +260,8 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte,\n \t}\n \n \tsalt := make([]byte, saltLength)\n-\tif _, err = io.ReadFull(rand, salt); err != nil {\n-\t\treturn\n+\tif _, err := io.ReadFull(rand, salt); err != nil {\n+\t\treturn nil, err\n \t}\n \treturn signPSSWithSalt(rand, priv, hash, hashed, salt)\n }"}, {"sha": "594305631b8731dea8fae11dc91c528509099d87", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -14,7 +14,7 @@\n // possible.\n //\n // Two sets of interfaces are included in this package. When a more abstract\n-// interface isn't neccessary, there are functions for encrypting/decrypting\n+// interface isn't necessary, there are functions for encrypting/decrypting\n // with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\n // over the public-key primitive, the PrivateKey struct implements the\n // Decrypter and Signer interfaces from the crypto package.\n@@ -191,7 +191,7 @@ func (priv *PrivateKey) Validate() error {\n \n // GenerateKey generates an RSA keypair of the given bit size using the\n // random source random (for example, crypto/rand.Reader).\n-func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error) {\n+func GenerateKey(random io.Reader, bits int) (*PrivateKey, error) {\n \treturn GenerateMultiPrimeKey(random, 2, bits)\n }\n \n@@ -206,8 +206,8 @@ func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error) {\n //\n // [1] US patent 4405829 (1972, expired)\n // [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n-func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *PrivateKey, err error) {\n-\tpriv = new(PrivateKey)\n+func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {\n+\tpriv := new(PrivateKey)\n \tpriv.E = 65537\n \n \tif nprimes < 2 {\n@@ -234,6 +234,7 @@ NextSetOfPrimes:\n \t\t\ttodo += (nprimes - 2) / 5\n \t\t}\n \t\tfor i := 0; i < nprimes; i++ {\n+\t\t\tvar err error\n \t\t\tprimes[i], err = rand.Prime(random, todo/(nprimes-i))\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n@@ -283,7 +284,7 @@ NextSetOfPrimes:\n \t}\n \n \tpriv.Precompute()\n-\treturn\n+\treturn priv, nil\n }\n \n // incCounter increments a four byte, big-endian counter.\n@@ -348,15 +349,14 @@ func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n //\n // The message must be no longer than the length of the public modulus less\n // twice the hash length plus 2.\n-func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error) {\n+func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error) {\n \tif err := checkPub(pub); err != nil {\n \t\treturn nil, err\n \t}\n \thash.Reset()\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-2*hash.Size()-2 {\n-\t\terr = ErrMessageTooLong\n-\t\treturn\n+\t\treturn nil, ErrMessageTooLong\n \t}\n \n \thash.Write(label)\n@@ -371,9 +371,9 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \tdb[len(db)-len(msg)-1] = 1\n \tcopy(db[len(db)-len(msg):], msg)\n \n-\t_, err = io.ReadFull(random, seed)\n+\t_, err := io.ReadFull(random, seed)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n \tmgf1XOR(db, hash, seed)\n@@ -382,7 +382,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \tm := new(big.Int)\n \tm.SetBytes(em)\n \tc := encrypt(new(big.Int), pub, m)\n-\tout = c.Bytes()\n+\tout := c.Bytes()\n \n \tif len(out) < k {\n \t\t// If the output is too small, we need to left-pad with zeros.\n@@ -391,7 +391,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \t\tout = t\n \t}\n \n-\treturn\n+\treturn out, nil\n }\n \n // ErrDecryption represents a failure to decrypt a message.\n@@ -565,22 +565,21 @@ func decryptAndCheck(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int\n //\n // The label parameter must match the value given when encrypting. See\n // EncryptOAEP for details.\n-func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err error) {\n+func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error) {\n \tif err := checkPub(&priv.PublicKey); err != nil {\n \t\treturn nil, err\n \t}\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||\n \t\tk < hash.Size()*2+2 {\n-\t\terr = ErrDecryption\n-\t\treturn\n+\t\treturn nil, ErrDecryption\n \t}\n \n \tc := new(big.Int).SetBytes(ciphertext)\n \n \tm, err := decrypt(random, priv, c)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n \thash.Write(label)\n@@ -628,12 +627,10 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \t}\n \n \tif firstByteIsZero&lHash2Good&^invalid&^lookingForIndex != 1 {\n-\t\terr = ErrDecryption\n-\t\treturn\n+\t\treturn nil, ErrDecryption\n \t}\n \n-\tmsg = rest[index+1:]\n-\treturn\n+\treturn rest[index+1:], nil\n }\n \n // leftPad returns a new slice of length size. The contents of input are right"}, {"sha": "08acd044d019d55474219482847f61a459a88f2c", "filename": "libgo/go/crypto/sha1/fallback_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Ffallback_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build s390x\n+\n+package sha1\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+// Tests the fallback code path in case the optimized asm\n+// implementation cannot be used.\n+// See also TestBlockGeneric.\n+func TestGenericPath(t *testing.T) {\n+\tif useAsm == false {\n+\t\tt.Skipf(\"assembly implementation unavailable\")\n+\t}\n+\tuseAsm = false\n+\tdefer func() { useAsm = true }()\n+\tc := New()\n+\tin := \"\u0391\u0392\u0393\u0394\u0395\u03dc\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03fa\u03d8\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\"\n+\tgold := \"0f58c2bb130f8182375f325c18342215255387e5\"\n+\tif _, err := io.WriteString(c, in); err != nil {\n+\t\tt.Fatalf(\"could not write to c: %v\", err)\n+\t}\n+\tout := fmt.Sprintf(\"%x\", c.Sum(nil))\n+\tif out != gold {\n+\t\tt.Fatalf(\"mismatch: got %s, wanted %s\", out, gold)\n+\t}\n+}"}, {"sha": "98038e58077c2ff0ebc74419a257cc611fe541e1", "filename": "libgo/go/crypto/sha1/issue15617_test.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fissue15617_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fissue15617_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fissue15617_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,28 @@\n+// +build amd64\n+// +build linux darwin\n+\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sha1_test\n+\n+import (\n+\t\"crypto/sha1\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+func TestOutOfBoundsRead(t *testing.T) {\n+\tconst pageSize = 4 << 10\n+\tdata, err := syscall.Mmap(0, 0, 2*pageSize, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_ANON|syscall.MAP_PRIVATE)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif err := syscall.Mprotect(data[pageSize:], syscall.PROT_NONE); err != nil {\n+\t\tpanic(err)\n+\t}\n+\tfor i := 0; i < pageSize; i++ {\n+\t\tsha1.Sum(data[pageSize-i : pageSize])\n+\t}\n+}"}, {"sha": "ac593b1bf0d30b8fdfd715e7e6b4f3230b8bd43c", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -90,7 +90,7 @@ func (d0 *digest) Sum(in []byte) []byte {\n \n func (d *digest) checkSum() [Size]byte {\n \tlen := d.len\n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n+\t// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tvar tmp [64]byte\n \ttmp[0] = 0x80\n \tif len%64 < 56 {"}, {"sha": "214afc51e1fa6466b07701f46cb3ae38e06a8db0", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// SHA1 hash algorithm.  See RFC 3174.\n+// SHA1 hash algorithm. See RFC 3174.\n \n package sha1\n \n@@ -19,6 +19,7 @@ type sha1Test struct {\n }\n \n var golden = []sha1Test{\n+\t{\"76245dbf96f661bd221046197ab8b9f063f11bad\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"},\n \t{\"da39a3ee5e6b4b0d3255bfef95601890afd80709\", \"\"},\n \t{\"86f7e437faa5a7fce15d1ddcb9eaeaea377667b8\", \"a\"},\n \t{\"da23614e02469a0d7c7bd1bdab5c9c474b1904dc\", \"ab\"},\n@@ -91,15 +92,17 @@ func TestBlockSize(t *testing.T) {\n \t}\n }\n \n-// Tests that blockGeneric (pure Go) and block (in assembly for amd64, 386, arm) match.\n+// Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.\n func TestBlockGeneric(t *testing.T) {\n-\tgen, asm := New().(*digest), New().(*digest)\n-\tbuf := make([]byte, BlockSize*20) // arbitrary factor\n-\trand.Read(buf)\n-\tblockGeneric(gen, buf)\n-\tblock(asm, buf)\n-\tif *gen != *asm {\n-\t\tt.Error(\"block and blockGeneric resulted in different states\")\n+\tfor i := 1; i < 30; i++ { // arbitrary factor\n+\t\tgen, asm := New().(*digest), New().(*digest)\n+\t\tbuf := make([]byte, BlockSize*i)\n+\t\trand.Read(buf)\n+\t\tblockGeneric(gen, buf)\n+\t\tblock(asm, buf)\n+\t\tif *gen != *asm {\n+\t\t\tt.Errorf(\"For %#v block and blockGeneric resulted in different states\", buf)\n+\t\t}\n \t}\n }\n \n@@ -120,6 +123,10 @@ func BenchmarkHash8Bytes(b *testing.B) {\n \tbenchmarkSize(b, 8)\n }\n \n+func BenchmarkHash320Bytes(b *testing.B) {\n+\tbenchmarkSize(b, 320)\n+}\n+\n func BenchmarkHash1K(b *testing.B) {\n \tbenchmarkSize(b, 1024)\n }"}, {"sha": "fd85a4262be21abbc170a560b41a873f34389214", "filename": "libgo/go/crypto/sha1/sha1block_amd64.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sha1\n+\n+//go:noescape\n+\n+func blockAVX2(dig *digest, p []byte)\n+\n+//go:noescape\n+func blockAMD64(dig *digest, p []byte)\n+func checkAVX2() bool\n+\n+var hasAVX2 = checkAVX2()\n+\n+func block(dig *digest, p []byte) {\n+\tif hasAVX2 && len(p) >= 256 {\n+\t\t// blockAVX2 calculates sha1 for 2 block per iteration\n+\t\t// it also interleaves precalculation for next block.\n+\t\t// So it may read up-to 192 bytes past end of p\n+\t\t// We may add checks inside blockAVX2, but this will\n+\t\t// just turn it into a copy of blockAMD64,\n+\t\t// so call it directly, instead.\n+\t\tsafeLen := len(p) - 128\n+\t\tif safeLen%128 != 0 {\n+\t\t\tsafeLen -= 64\n+\t\t}\n+\t\tblockAVX2(dig, p[:safeLen])\n+\t\tblockAMD64(dig, p[safeLen:])\n+\t} else {\n+\t\tblockAMD64(dig, p)\n+\t}\n+}"}, {"sha": "6d2d073d13733157422f2e0cd2b180d6ae1c0537", "filename": "libgo/go/crypto/sha1/sha1block_decl.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_decl.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,8 +1,8 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 amd64p32 arm 386\n+// +build amd64p32 arm 386 s390x\n \n package sha1\n "}, {"sha": "f0194626a6f24dca6b24f4998ab991767b9e1217", "filename": "libgo/go/crypto/sha1/sha1block_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_generic.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!386,!arm\n+// +build !amd64,!amd64p32,!386,!arm,!s390x\n \n package sha1\n "}, {"sha": "aac7c1182d44d53a804e351174fbb8163586ffa7", "filename": "libgo/go/crypto/sha1/sha1block_s390x.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sha1\n+\n+// featureCheck reports whether the CPU supports the\n+// SHA1 compute intermediate message digest (KIMD)\n+// function code.\n+func featureCheck() bool\n+\n+var useAsm = featureCheck()"}, {"sha": "5917a4862af1b21179aed28109415170f41c8314", "filename": "libgo/go/crypto/sha256/fallback_test.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Ffallback_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Ffallback_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Ffallback_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build s390x\n+\n+package sha256\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+// Tests the fallback code path in case the optimized asm\n+// implementation cannot be used.\n+// See also TestBlockGeneric.\n+func TestGenericPath(t *testing.T) {\n+\tif useAsm == false {\n+\t\tt.Skipf(\"assembly implementation unavailable\")\n+\t}\n+\tuseAsm = false\n+\tdefer func() { useAsm = true }()\n+\tc := New()\n+\tin := \"\u0391\u0392\u0393\u0394\u0395\u03dc\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03fa\u03d8\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\"\n+\tgold := \"e93d84ec2b22383123be9f713697fb25\" +\n+\t\t\"338c86e2f7d8d1ddc2d89d332dd9d76c\"\n+\tif _, err := io.WriteString(c, in); err != nil {\n+\t\tt.Fatalf(\"could not write to c: %v\", err)\n+\t}\n+\tout := fmt.Sprintf(\"%x\", c.Sum(nil))\n+\tif out != gold {\n+\t\tt.Fatalf(\"mismatch: got %s, wanted %s\", out, gold)\n+\t}\n+}"}, {"sha": "74b05b92d770f613864a5b381944c4965c27f422", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -137,7 +137,7 @@ func (d0 *digest) Sum(in []byte) []byte {\n \n func (d *digest) checkSum() [Size]byte {\n \tlen := d.len\n-\t// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n+\t// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.\n \tvar tmp [64]byte\n \ttmp[0] = 0x80\n \tif len%64 < 56 {"}, {"sha": "279cf5ad407a065923def977e2df0cf4707abb05", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,11 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// SHA256 hash algorithm.  See FIPS 180-2.\n+// SHA256 hash algorithm. See FIPS 180-2.\n \n package sha256\n \n import (\n+\t\"crypto/rand\"\n \t\"fmt\"\n \t\"io\"\n \t\"testing\"\n@@ -150,6 +151,18 @@ func TestBlockSize(t *testing.T) {\n \t}\n }\n \n+// Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.\n+func TestBlockGeneric(t *testing.T) {\n+\tgen, asm := New().(*digest), New().(*digest)\n+\tbuf := make([]byte, BlockSize*20) // arbitrary factor\n+\trand.Read(buf)\n+\tblockGeneric(gen, buf)\n+\tblock(asm, buf)\n+\tif *gen != *asm {\n+\t\tt.Error(\"block and blockGeneric resulted in different states\")\n+\t}\n+}\n+\n var bench = New()\n var buf = make([]byte, 8192)\n "}, {"sha": "d43bbf02453a7cd08727e08d9a189daaef945669", "filename": "libgo/go/crypto/sha256/sha256block.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !386,!amd64\n-\n // SHA256 block step.\n // In its own file so that a faster assembly or C version\n // can be substituted easily.\n@@ -77,7 +75,7 @@ var _K = []uint32{\n \t0xc67178f2,\n }\n \n-func block(dig *digest, p []byte) {\n+func blockGeneric(dig *digest, p []byte) {\n \tvar w [64]uint32\n \th0, h1, h2, h3, h4, h5, h6, h7 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7]\n \tfor len(p) >= chunk {"}, {"sha": "e6caff9a74652ee39806644dce7994ad3339ca15", "filename": "libgo/go/crypto/sha256/sha256block_decl.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_decl.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,8 +1,8 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build 386 amd64\n+// +build 386 amd64 s390x\n \n package sha256\n "}, {"sha": "1a01969b0dcfee88c14666adae064e4d5aa12635", "filename": "libgo/go/crypto/sha256/sha256block_generic.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_generic.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !amd64,!386,!s390x\n+\n+package sha256\n+\n+var block = blockGeneric"}, {"sha": "b7beefef0c61f2d3f244b85875e9f34c2bfbedf6", "filename": "libgo/go/crypto/sha256/sha256block_s390x.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sha256\n+\n+// featureCheck reports whether the CPU supports the\n+// SHA256 compute intermediate message digest (KIMD)\n+// function code.\n+func featureCheck() bool\n+\n+var useAsm = featureCheck()"}, {"sha": "9024ce668a0be8a4fe5295f64ba0d3b4bcf493e3", "filename": "libgo/go/crypto/sha512/fallback_test.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Ffallback_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build s390x\n+\n+package sha512\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+// Tests the fallback code path in case the optimized asm\n+// implementation cannot be used.\n+// See also TestBlockGeneric.\n+func TestGenericPath(t *testing.T) {\n+\tif useAsm == false {\n+\t\tt.Skipf(\"assembly implementation unavailable\")\n+\t}\n+\tuseAsm = false\n+\tdefer func() { useAsm = true }()\n+\tc := New()\n+\tin := \"\u0391\u0392\u0393\u0394\u0395\u03dc\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03fa\u03d8\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\"\n+\tgold := \"6922e319366d677f34c504af31bfcb29\" +\n+\t\t\"e531c125ecd08679362bffbd6b6ebfb9\" +\n+\t\t\"0dcc27dfc1f3d3b16a16c0763cf43b91\" +\n+\t\t\"40bbf9bbb7233724e9a0c6655b185d76\"\n+\tif _, err := io.WriteString(c, in); err != nil {\n+\t\tt.Fatalf(\"could not write to c: %v\", err)\n+\t}\n+\tout := fmt.Sprintf(\"%x\", c.Sum(nil))\n+\tif out != gold {\n+\t\tt.Fatalf(\"mismatch: got %s, wanted %s\", out, gold)\n+\t}\n+}"}, {"sha": "5603c90fb74516257ab1f48a46fde6e498f330a3", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -208,7 +208,7 @@ func (d0 *digest) Sum(in []byte) []byte {\n }\n \n func (d *digest) checkSum() [Size]byte {\n-\t// Padding.  Add a 1 bit and 0 bits until 112 bytes mod 128.\n+\t// Padding. Add a 1 bit and 0 bits until 112 bytes mod 128.\n \tlen := d.len\n \tvar tmp [128]byte\n \ttmp[0] = 0x80"}, {"sha": "a3a136a19f820c48833b2164b1f2ece6495884e9", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,11 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// SHA512 hash algorithm.  See FIPS 180-4.\n+// SHA512 hash algorithm. See FIPS 180-4.\n \n package sha512\n \n import (\n+\t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"hash\"\n \t\"io\"\n@@ -304,6 +305,18 @@ func TestBlockSize(t *testing.T) {\n \t}\n }\n \n+// Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.\n+func TestBlockGeneric(t *testing.T) {\n+\tgen, asm := New().(*digest), New().(*digest)\n+\tbuf := make([]byte, BlockSize*20) // arbitrary factor\n+\trand.Read(buf)\n+\tblockGeneric(gen, buf)\n+\tblock(asm, buf)\n+\tif *gen != *asm {\n+\t\tt.Error(\"block and blockGeneric resulted in different states\")\n+\t}\n+}\n+\n var bench = New()\n var buf = make([]byte, 8192)\n "}, {"sha": "42e8d19fe8c850c87e9dbb78facf7c292acab8c6", "filename": "libgo/go/crypto/sha512/sha512block.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64\n-\n // SHA512 block step.\n // In its own file so that a faster assembly or C version\n // can be substituted easily.\n@@ -93,7 +91,7 @@ var _K = []uint64{\n \t0x6c44198c4a475817,\n }\n \n-func block(dig *digest, p []byte) {\n+func blockGeneric(dig *digest, p []byte) {\n \tvar w [80]uint64\n \th0, h1, h2, h3, h4, h5, h6, h7 := dig.h[0], dig.h[1], dig.h[2], dig.h[3], dig.h[4], dig.h[5], dig.h[6], dig.h[7]\n \tfor len(p) >= chunk {"}, {"sha": "47d656a7e4a1aaaae78c358037babd770ab4074f", "filename": "libgo/go/crypto/sha512/sha512block_decl.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -1,8 +1,8 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n+// Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64\n+// +build amd64 s390x\n \n package sha512\n "}, {"sha": "2c691baa3d92d5b6fddfb35a646250bf3be8eb83", "filename": "libgo/go/crypto/sha512/sha512block_generic.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_generic.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !amd64,!s390x\n+\n+package sha512\n+\n+var block = blockGeneric"}, {"sha": "f05dc18e124a2d66cc3d97e8d02b02c6f78e9a12", "filename": "libgo/go/crypto/sha512/sha512block_s390x.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_s390x.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sha512\n+\n+// featureCheck reports whether the CPU supports the\n+// SHA512 compute intermediate message digest (KIMD)\n+// function code.\n+func featureCheck() bool\n+\n+var useAsm = featureCheck()"}, {"sha": "11312b8dd444018e2e7feb9803b55d8b64d7d124", "filename": "libgo/go/crypto/subtle/constant_time.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -6,7 +6,7 @@\n // code but require careful thought to use correctly.\n package subtle\n \n-// ConstantTimeCompare returns 1 iff the two slices, x\n+// ConstantTimeCompare returns 1 if and only if the two slices, x\n // and y, have equal contents. The time taken is a function of the length of\n // the slices and is independent of the contents.\n func ConstantTimeCompare(x, y []byte) int {"}, {"sha": "9cf99224f5d21f67bdacd1184108d438a61119b1", "filename": "libgo/go/crypto/tls/alert.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -69,9 +69,9 @@ var alertText = map[alert]string{\n func (e alert) String() string {\n \ts, ok := alertText[e]\n \tif ok {\n-\t\treturn s\n+\t\treturn \"tls: \" + s\n \t}\n-\treturn \"alert(\" + strconv.Itoa(int(e)) + \")\"\n+\treturn \"tls: alert(\" + strconv.Itoa(int(e)) + \")\"\n }\n \n func (e alert) Error() string {"}, {"sha": "e69f5f966e34578534ab1328014cfea872d6cf34", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -74,7 +74,7 @@ type cipherSuite struct {\n \n var cipherSuites = []*cipherSuite{\n \t// Ciphersuite order is chosen so that ECDHE comes before plain RSA\n-\t// and RC4 comes before AES (because of the Lucky13 attack).\n+\t// and RC4 comes before AES-CBC (because of the Lucky13 attack).\n \t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n@@ -261,8 +261,10 @@ func mutualCipherSuite(have []uint16, want uint16) *cipherSuite {\n \treturn nil\n }\n \n-// A list of the possible cipher suite ids. Taken from\n-// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n+// A list of cipher suite IDs that are, or have been, implemented by this\n+// package.\n+//\n+// Taken from http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n const (\n \tTLS_RSA_WITH_RC4_128_SHA                uint16 = 0x0005\n \tTLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a\n@@ -284,6 +286,6 @@ const (\n \n \t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n \t// that the client is doing version fallback. See\n-\t// https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.\n+\t// https://tools.ietf.org/html/rfc7507.\n \tTLS_FALLBACK_SCSV uint16 = 0x5600\n )"}, {"sha": "9fc742008205dcb663e23ce229ec816c3671e762", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -48,6 +48,7 @@ const (\n \n // TLS handshake message types.\n const (\n+\ttypeHelloRequest       uint8 = 0\n \ttypeClientHello        uint8 = 1\n \ttypeServerHello        uint8 = 2\n \ttypeNewSessionTicket   uint8 = 4\n@@ -114,7 +115,7 @@ const (\n \tcertTypeRSAFixedDH = 3 // A certificate containing a static DH key\n \tcertTypeDSSFixedDH = 4 // A certificate containing a static DH key\n \n-\t// See RFC4492 sections 3 and 5.5.\n+\t// See RFC 4492 sections 3 and 5.5.\n \tcertTypeECDSASign      = 64 // A certificate containing an ECDSA-capable public key, signed with ECDSA.\n \tcertTypeRSAFixedECDH   = 65 // A certificate containing an ECDH-capable public key, signed with RSA.\n \tcertTypeECDSAFixedECDH = 66 // A certificate containing an ECDH-capable public key, signed with ECDSA.\n@@ -238,6 +239,33 @@ type ClientHelloInfo struct {\n \tSupportedPoints []uint8\n }\n \n+// RenegotiationSupport enumerates the different levels of support for TLS\n+// renegotiation. TLS renegotiation is the act of performing subsequent\n+// handshakes on a connection after the first. This significantly complicates\n+// the state machine and has been the source of numerous, subtle security\n+// issues. Initiating a renegotiation is not supported, but support for\n+// accepting renegotiation requests may be enabled.\n+//\n+// Even when enabled, the server may not change its identity between handshakes\n+// (i.e. the leaf certificate must be the same). Additionally, concurrent\n+// handshake and application data flow is not permitted so renegotiation can\n+// only be used with protocols that synchronise with the renegotiation, such as\n+// HTTPS.\n+type RenegotiationSupport int\n+\n+const (\n+\t// RenegotiateNever disables renegotiation.\n+\tRenegotiateNever RenegotiationSupport = iota\n+\n+\t// RenegotiateOnceAsClient allows a remote server to request\n+\t// renegotiation once per connection.\n+\tRenegotiateOnceAsClient\n+\n+\t// RenegotiateFreelyAsClient allows a remote server to repeatedly\n+\t// request renegotiation.\n+\tRenegotiateFreelyAsClient\n+)\n+\n // A Config structure is used to configure a TLS client or server.\n // After one has been passed to a TLS function it must not be\n // modified. A Config may be reused; the tls package will also not\n@@ -349,6 +377,16 @@ type Config struct {\n \t// be used.\n \tCurvePreferences []CurveID\n \n+\t// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n+\t// When true, the largest possible TLS record size is always used. When\n+\t// false, the size of TLS records may be adjusted in an attempt to\n+\t// improve latency.\n+\tDynamicRecordSizingDisabled bool\n+\n+\t// Renegotiation controls what types of renegotiation are supported.\n+\t// The default, none, is correct for the vast majority of applications.\n+\tRenegotiation RenegotiationSupport\n+\n \tserverInitOnce sync.Once // guards calling (*Config).serverInit\n \n \t// mutex protects sessionTicketKeys\n@@ -384,6 +422,33 @@ func ticketKeyFromBytes(b [32]byte) (key ticketKey) {\n \treturn key\n }\n \n+// clone returns a copy of c. Only the exported fields are copied.\n+func (c *Config) clone() *Config {\n+\treturn &Config{\n+\t\tRand:                        c.Rand,\n+\t\tTime:                        c.Time,\n+\t\tCertificates:                c.Certificates,\n+\t\tNameToCertificate:           c.NameToCertificate,\n+\t\tGetCertificate:              c.GetCertificate,\n+\t\tRootCAs:                     c.RootCAs,\n+\t\tNextProtos:                  c.NextProtos,\n+\t\tServerName:                  c.ServerName,\n+\t\tClientAuth:                  c.ClientAuth,\n+\t\tClientCAs:                   c.ClientCAs,\n+\t\tInsecureSkipVerify:          c.InsecureSkipVerify,\n+\t\tCipherSuites:                c.CipherSuites,\n+\t\tPreferServerCipherSuites:    c.PreferServerCipherSuites,\n+\t\tSessionTicketsDisabled:      c.SessionTicketsDisabled,\n+\t\tSessionTicketKey:            c.SessionTicketKey,\n+\t\tClientSessionCache:          c.ClientSessionCache,\n+\t\tMinVersion:                  c.MinVersion,\n+\t\tMaxVersion:                  c.MaxVersion,\n+\t\tCurvePreferences:            c.CurvePreferences,\n+\t\tDynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,\n+\t\tRenegotiation:               c.Renegotiation,\n+\t}\n+}\n+\n func (c *Config) serverInit() {\n \tif c.SessionTicketsDisabled {\n \t\treturn\n@@ -510,7 +575,7 @@ func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, err\n \t}\n \n \tif len(c.Certificates) == 0 {\n-\t\treturn nil, errors.New(\"crypto/tls: no certificates configured\")\n+\t\treturn nil, errors.New(\"tls: no certificates configured\")\n \t}\n \n \tif len(c.Certificates) == 1 || c.NameToCertificate == nil {\n@@ -584,13 +649,6 @@ type Certificate struct {\n \tLeaf *x509.Certificate\n }\n \n-// A TLS record.\n-type record struct {\n-\tcontentType  recordType\n-\tmajor, minor uint8\n-\tpayload      []byte\n-}\n-\n type handshakeMessage interface {\n \tmarshal() []byte\n \tunmarshal([]byte) bool"}, {"sha": "87bef23d91ff874625cefac2da3a15f6a1332881", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 279, "deletions": 73, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -28,34 +28,60 @@ type Conn struct {\n \tisClient bool\n \n \t// constant after handshake; protected by handshakeMutex\n-\thandshakeMutex    sync.Mutex // handshakeMutex < in.Mutex, out.Mutex, errMutex\n-\thandshakeErr      error      // error resulting from handshake\n-\tvers              uint16     // TLS version\n-\thaveVers          bool       // version has been negotiated\n-\tconfig            *Config    // configuration passed to constructor\n+\thandshakeMutex sync.Mutex // handshakeMutex < in.Mutex, out.Mutex, errMutex\n+\thandshakeErr   error      // error resulting from handshake\n+\tvers           uint16     // TLS version\n+\thaveVers       bool       // version has been negotiated\n+\tconfig         *Config    // configuration passed to constructor\n+\t// handshakeComplete is true if the connection is currently transfering\n+\t// application data (i.e. is not currently processing a handshake).\n \thandshakeComplete bool\n-\tdidResume         bool // whether this connection was a session resumption\n-\tcipherSuite       uint16\n-\tocspResponse      []byte   // stapled OCSP response\n-\tscts              [][]byte // signed certificate timestamps from server\n-\tpeerCertificates  []*x509.Certificate\n+\t// handshakes counts the number of handshakes performed on the\n+\t// connection so far. If renegotiation is disabled then this is either\n+\t// zero or one.\n+\thandshakes       int\n+\tdidResume        bool // whether this connection was a session resumption\n+\tcipherSuite      uint16\n+\tocspResponse     []byte   // stapled OCSP response\n+\tscts             [][]byte // signed certificate timestamps from server\n+\tpeerCertificates []*x509.Certificate\n \t// verifiedChains contains the certificate chains that we built, as\n \t// opposed to the ones presented by the server.\n \tverifiedChains [][]*x509.Certificate\n \t// serverName contains the server name indicated by the client, if any.\n \tserverName string\n-\t// firstFinished contains the first Finished hash sent during the\n-\t// handshake. This is the \"tls-unique\" channel binding value.\n-\tfirstFinished [12]byte\n+\t// secureRenegotiation is true if the server echoed the secure\n+\t// renegotiation extension. (This is meaningless as a server because\n+\t// renegotiation is not supported in that case.)\n+\tsecureRenegotiation bool\n+\n+\t// clientFinishedIsFirst is true if the client sent the first Finished\n+\t// message during the most recent handshake. This is recorded because\n+\t// the first transmitted Finished message is the tls-unique\n+\t// channel-binding value.\n+\tclientFinishedIsFirst bool\n+\t// clientFinished and serverFinished contain the Finished message sent\n+\t// by the client or server in the most recent handshake. This is\n+\t// retained to support the renegotiation extension and tls-unique\n+\t// channel-binding.\n+\tclientFinished [12]byte\n+\tserverFinished [12]byte\n \n \tclientProtocol         string\n \tclientProtocolFallback bool\n \n \t// input/output\n-\tin, out  halfConn     // in.Mutex < out.Mutex\n-\trawInput *block       // raw input, right off the wire\n-\tinput    *block       // application data waiting to be read\n-\thand     bytes.Buffer // handshake data waiting to be read\n+\tin, out   halfConn     // in.Mutex < out.Mutex\n+\trawInput  *block       // raw input, right off the wire\n+\tinput     *block       // application data waiting to be read\n+\thand      bytes.Buffer // handshake data waiting to be read\n+\tbuffering bool         // whether records are buffered in sendBuf\n+\tsendBuf   []byte       // a buffer of records waiting to be sent\n+\n+\t// bytesSent counts the bytes of application data sent.\n+\t// packetsSent counts packets.\n+\tbytesSent   int64\n+\tpacketsSent int64\n \n \t// activeCall is an atomic int32; the low bit is whether Close has\n \t// been called. the rest of the bits are the number of goroutines\n@@ -124,13 +150,6 @@ func (hc *halfConn) setErrorLocked(err error) error {\n \treturn err\n }\n \n-func (hc *halfConn) error() error {\n-\thc.Lock()\n-\terr := hc.err\n-\thc.Unlock()\n-\treturn err\n-}\n-\n // prepareCipherSpec sets the encryption and MAC states\n // that a subsequent changeCipherSpec will use.\n func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) {\n@@ -170,13 +189,6 @@ func (hc *halfConn) incSeq() {\n \tpanic(\"TLS: sequence number wraparound\")\n }\n \n-// resetSeq resets the sequence number to zero.\n-func (hc *halfConn) resetSeq() {\n-\tfor i := range hc.seq {\n-\t\thc.seq[i] = 0\n-\t}\n-}\n-\n // removePadding returns an unpadded slice, in constant time, which is a prefix\n // of the input. It also returns a byte which is equal to 255 if the padding\n // was valid and 0 otherwise. See RFC 2246, section 6.2.3.2\n@@ -535,20 +547,20 @@ func (c *Conn) newRecordHeaderError(msg string) (err RecordHeaderError) {\n func (c *Conn) readRecord(want recordType) error {\n \t// Caller must be in sync with connection:\n \t// handshake data if handshake not yet completed,\n-\t// else application data.  (We don't support renegotiation.)\n+\t// else application data.\n \tswitch want {\n \tdefault:\n \t\tc.sendAlert(alertInternalError)\n \t\treturn c.in.setErrorLocked(errors.New(\"tls: unknown record type requested\"))\n \tcase recordTypeHandshake, recordTypeChangeCipherSpec:\n \t\tif c.handshakeComplete {\n \t\t\tc.sendAlert(alertInternalError)\n-\t\t\treturn c.in.setErrorLocked(errors.New(\"tls: handshake or ChangeCipherSpec requested after handshake complete\"))\n+\t\t\treturn c.in.setErrorLocked(errors.New(\"tls: handshake or ChangeCipherSpec requested while not in handshake\"))\n \t\t}\n \tcase recordTypeApplicationData:\n \t\tif !c.handshakeComplete {\n \t\t\tc.sendAlert(alertInternalError)\n-\t\t\treturn c.in.setErrorLocked(errors.New(\"tls: application data record requested before handshake complete\"))\n+\t\t\treturn c.in.setErrorLocked(errors.New(\"tls: application data record requested while in handshake\"))\n \t\t}\n \t}\n \n@@ -672,7 +684,7 @@ Again:\n \n \tcase recordTypeHandshake:\n \t\t// TODO(rsc): Should at least pick off connection close.\n-\t\tif typ != want {\n+\t\tif typ != want && !(c.isClient && c.config.Renegotiation != RenegotiateNever) {\n \t\t\treturn c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))\n \t\t}\n \t\tc.hand.Write(data)\n@@ -694,12 +706,14 @@ func (c *Conn) sendAlertLocked(err alert) error {\n \t\tc.tmp[0] = alertLevelError\n \t}\n \tc.tmp[1] = byte(err)\n-\tc.writeRecord(recordTypeAlert, c.tmp[0:2])\n-\t// closeNotify is a special case in that it isn't an error:\n-\tif err != alertCloseNotify {\n-\t\treturn c.out.setErrorLocked(&net.OpError{Op: \"local error\", Err: err})\n+\n+\t_, writeErr := c.writeRecordLocked(recordTypeAlert, c.tmp[0:2])\n+\tif err == alertCloseNotify {\n+\t\t// closeNotify is a special case in that it isn't an error.\n+\t\treturn writeErr\n \t}\n-\treturn nil\n+\n+\treturn c.out.setErrorLocked(&net.OpError{Op: \"local error\", Err: err})\n }\n \n // sendAlert sends a TLS alert message.\n@@ -710,16 +724,120 @@ func (c *Conn) sendAlert(err alert) error {\n \treturn c.sendAlertLocked(err)\n }\n \n-// writeRecord writes a TLS record with the given type and payload\n-// to the connection and updates the record layer state.\n+const (\n+\t// tcpMSSEstimate is a conservative estimate of the TCP maximum segment\n+\t// size (MSS). A constant is used, rather than querying the kernel for\n+\t// the actual MSS, to avoid complexity. The value here is the IPv6\n+\t// minimum MTU (1280 bytes) minus the overhead of an IPv6 header (40\n+\t// bytes) and a TCP header with timestamps (32 bytes).\n+\ttcpMSSEstimate = 1208\n+\n+\t// recordSizeBoostThreshold is the number of bytes of application data\n+\t// sent after which the TLS record size will be increased to the\n+\t// maximum.\n+\trecordSizeBoostThreshold = 128 * 1024\n+)\n+\n+// maxPayloadSizeForWrite returns the maximum TLS payload size to use for the\n+// next application data record. There is the following trade-off:\n+//\n+//   - For latency-sensitive applications, such as web browsing, each TLS\n+//     record should fit in one TCP segment.\n+//   - For throughput-sensitive applications, such as large file transfers,\n+//     larger TLS records better amortize framing and encryption overheads.\n+//\n+// A simple heuristic that works well in practice is to use small records for\n+// the first 1MB of data, then use larger records for subsequent data, and\n+// reset back to smaller records after the connection becomes idle. See \"High\n+// Performance Web Networking\", Chapter 4, or:\n+// https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/\n+//\n+// In the interests of simplicity and determinism, this code does not attempt\n+// to reset the record size once the connection is idle, however.\n+//\n+// c.out.Mutex <= L.\n+func (c *Conn) maxPayloadSizeForWrite(typ recordType, explicitIVLen int) int {\n+\tif c.config.DynamicRecordSizingDisabled || typ != recordTypeApplicationData {\n+\t\treturn maxPlaintext\n+\t}\n+\n+\tif c.bytesSent >= recordSizeBoostThreshold {\n+\t\treturn maxPlaintext\n+\t}\n+\n+\t// Subtract TLS overheads to get the maximum payload size.\n+\tmacSize := 0\n+\tif c.out.mac != nil {\n+\t\tmacSize = c.out.mac.Size()\n+\t}\n+\n+\tpayloadBytes := tcpMSSEstimate - recordHeaderLen - explicitIVLen\n+\tif c.out.cipher != nil {\n+\t\tswitch ciph := c.out.cipher.(type) {\n+\t\tcase cipher.Stream:\n+\t\t\tpayloadBytes -= macSize\n+\t\tcase cipher.AEAD:\n+\t\t\tpayloadBytes -= ciph.Overhead()\n+\t\tcase cbcMode:\n+\t\t\tblockSize := ciph.BlockSize()\n+\t\t\t// The payload must fit in a multiple of blockSize, with\n+\t\t\t// room for at least one padding byte.\n+\t\t\tpayloadBytes = (payloadBytes & ^(blockSize - 1)) - 1\n+\t\t\t// The MAC is appended before padding so affects the\n+\t\t\t// payload size directly.\n+\t\t\tpayloadBytes -= macSize\n+\t\tdefault:\n+\t\t\tpanic(\"unknown cipher type\")\n+\t\t}\n+\t}\n+\n+\t// Allow packet growth in arithmetic progression up to max.\n+\tpkt := c.packetsSent\n+\tc.packetsSent++\n+\tif pkt > 1000 {\n+\t\treturn maxPlaintext // avoid overflow in multiply below\n+\t}\n+\n+\tn := payloadBytes * int(pkt+1)\n+\tif n > maxPlaintext {\n+\t\tn = maxPlaintext\n+\t}\n+\treturn n\n+}\n+\n // c.out.Mutex <= L.\n-func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n+func (c *Conn) write(data []byte) (int, error) {\n+\tif c.buffering {\n+\t\tc.sendBuf = append(c.sendBuf, data...)\n+\t\treturn len(data), nil\n+\t}\n+\n+\tn, err := c.conn.Write(data)\n+\tc.bytesSent += int64(n)\n+\treturn n, err\n+}\n+\n+func (c *Conn) flush() (int, error) {\n+\tif len(c.sendBuf) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\n+\tn, err := c.conn.Write(c.sendBuf)\n+\tc.bytesSent += int64(n)\n+\tc.sendBuf = nil\n+\tc.buffering = false\n+\treturn n, err\n+}\n+\n+// writeRecordLocked writes a TLS record with the given type and payload to the\n+// connection and updates the record layer state.\n+// c.out.Mutex <= L.\n+func (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error) {\n \tb := c.out.newBlock()\n+\tdefer c.out.freeBlock(b)\n+\n+\tvar n int\n \tfor len(data) > 0 {\n-\t\tm := len(data)\n-\t\tif m > maxPlaintext {\n-\t\t\tm = maxPlaintext\n-\t\t}\n \t\texplicitIVLen := 0\n \t\texplicitIVIsSeq := false\n \n@@ -742,6 +860,10 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n \t\t\t\texplicitIVIsSeq = true\n \t\t\t}\n \t\t}\n+\t\tm := len(data)\n+\t\tif maxPayload := c.maxPayloadSizeForWrite(typ, explicitIVLen); m > maxPayload {\n+\t\t\tm = maxPayload\n+\t\t}\n \t\tb.resize(recordHeaderLen + explicitIVLen + m)\n \t\tb.data[0] = byte(typ)\n \t\tvers := c.vers\n@@ -759,34 +881,37 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {\n \t\t\tif explicitIVIsSeq {\n \t\t\t\tcopy(explicitIV, c.out.seq[:])\n \t\t\t} else {\n-\t\t\t\tif _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil {\n-\t\t\t\t\tbreak\n+\t\t\t\tif _, err := io.ReadFull(c.config.rand(), explicitIV); err != nil {\n+\t\t\t\t\treturn n, err\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcopy(b.data[recordHeaderLen+explicitIVLen:], data)\n \t\tc.out.encrypt(b, explicitIVLen)\n-\t\t_, err = c.conn.Write(b.data)\n-\t\tif err != nil {\n-\t\t\tbreak\n+\t\tif _, err := c.write(b.data); err != nil {\n+\t\t\treturn n, err\n \t\t}\n \t\tn += m\n \t\tdata = data[m:]\n \t}\n-\tc.out.freeBlock(b)\n \n \tif typ == recordTypeChangeCipherSpec {\n-\t\terr = c.out.changeCipherSpec()\n-\t\tif err != nil {\n-\t\t\t// Cannot call sendAlert directly,\n-\t\t\t// because we already hold c.out.Mutex.\n-\t\t\tc.tmp[0] = alertLevelError\n-\t\t\tc.tmp[1] = byte(err.(alert))\n-\t\t\tc.writeRecord(recordTypeAlert, c.tmp[0:2])\n-\t\t\treturn n, c.out.setErrorLocked(&net.OpError{Op: \"local error\", Err: err})\n+\t\tif err := c.out.changeCipherSpec(); err != nil {\n+\t\t\treturn n, c.sendAlertLocked(err.(alert))\n \t\t}\n \t}\n-\treturn\n+\n+\treturn n, nil\n+}\n+\n+// writeRecord writes a TLS record with the given type and payload to the\n+// connection and updates the record layer state.\n+// L < c.out.Mutex.\n+func (c *Conn) writeRecord(typ recordType, data []byte) (int, error) {\n+\tc.out.Lock()\n+\tdefer c.out.Unlock()\n+\n+\treturn c.writeRecordLocked(typ, data)\n }\n \n // readHandshake reads the next handshake message from\n@@ -805,7 +930,8 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \tdata := c.hand.Bytes()\n \tn := int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n \tif n > maxHandshake {\n-\t\treturn nil, c.in.setErrorLocked(c.sendAlert(alertInternalError))\n+\t\tc.sendAlertLocked(alertInternalError)\n+\t\treturn nil, c.in.setErrorLocked(fmt.Errorf(\"tls: handshake message of length %d bytes exceeds maximum of %d bytes\", n, maxHandshake))\n \t}\n \tfor c.hand.Len() < 4+n {\n \t\tif err := c.in.err; err != nil {\n@@ -818,6 +944,8 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \tdata = c.hand.Next(4 + n)\n \tvar m handshakeMessage\n \tswitch data[0] {\n+\tcase typeHelloRequest:\n+\t\tm = new(helloRequestMsg)\n \tcase typeClientHello:\n \t\tm = new(clientHelloMsg)\n \tcase typeServerHello:\n@@ -861,7 +989,7 @@ func (c *Conn) readHandshake() (interface{}, error) {\n \treturn m, nil\n }\n \n-var errClosed = errors.New(\"crypto/tls: use of closed connection\")\n+var errClosed = errors.New(\"tls: use of closed connection\")\n \n // Write writes data to the connection.\n func (c *Conn) Write(b []byte) (int, error) {\n@@ -904,18 +1032,60 @@ func (c *Conn) Write(b []byte) (int, error) {\n \tvar m int\n \tif len(b) > 1 && c.vers <= VersionTLS10 {\n \t\tif _, ok := c.out.cipher.(cipher.BlockMode); ok {\n-\t\t\tn, err := c.writeRecord(recordTypeApplicationData, b[:1])\n+\t\t\tn, err := c.writeRecordLocked(recordTypeApplicationData, b[:1])\n \t\t\tif err != nil {\n \t\t\t\treturn n, c.out.setErrorLocked(err)\n \t\t\t}\n \t\t\tm, b = 1, b[1:]\n \t\t}\n \t}\n \n-\tn, err := c.writeRecord(recordTypeApplicationData, b)\n+\tn, err := c.writeRecordLocked(recordTypeApplicationData, b)\n \treturn n + m, c.out.setErrorLocked(err)\n }\n \n+// handleRenegotiation processes a HelloRequest handshake message.\n+// c.in.Mutex <= L\n+func (c *Conn) handleRenegotiation() error {\n+\tmsg, err := c.readHandshake()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, ok := msg.(*helloRequestMsg)\n+\tif !ok {\n+\t\tc.sendAlert(alertUnexpectedMessage)\n+\t\treturn alertUnexpectedMessage\n+\t}\n+\n+\tif !c.isClient {\n+\t\treturn c.sendAlert(alertNoRenegotiation)\n+\t}\n+\n+\tswitch c.config.Renegotiation {\n+\tcase RenegotiateNever:\n+\t\treturn c.sendAlert(alertNoRenegotiation)\n+\tcase RenegotiateOnceAsClient:\n+\t\tif c.handshakes > 1 {\n+\t\t\treturn c.sendAlert(alertNoRenegotiation)\n+\t\t}\n+\tcase RenegotiateFreelyAsClient:\n+\t\t// Ok.\n+\tdefault:\n+\t\tc.sendAlert(alertInternalError)\n+\t\treturn errors.New(\"tls: unknown Renegotiation value\")\n+\t}\n+\n+\tc.handshakeMutex.Lock()\n+\tdefer c.handshakeMutex.Unlock()\n+\n+\tc.handshakeComplete = false\n+\tif c.handshakeErr = c.clientHandshake(); c.handshakeErr == nil {\n+\t\tc.handshakes++\n+\t}\n+\treturn c.handshakeErr\n+}\n+\n // Read can be made to time out and return a net.Error with Timeout() == true\n // after a fixed time limit; see SetDeadline and SetReadDeadline.\n func (c *Conn) Read(b []byte) (n int, err error) {\n@@ -940,6 +1110,13 @@ func (c *Conn) Read(b []byte) (n int, err error) {\n \t\t\t\t// Soft error, like EAGAIN\n \t\t\t\treturn 0, err\n \t\t\t}\n+\t\t\tif c.hand.Len() > 0 {\n+\t\t\t\t// We received handshake bytes, indicating the\n+\t\t\t\t// start of a renegotiation.\n+\t\t\t\tif err := c.handleRenegotiation(); err != nil {\n+\t\t\t\t\treturn 0, err\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif err := c.in.err; err != nil {\n \t\t\treturn 0, err\n@@ -1020,20 +1197,45 @@ func (c *Conn) Close() error {\n // Most uses of this package need not call Handshake\n // explicitly: the first Read or Write will call it automatically.\n func (c *Conn) Handshake() error {\n+\t// c.handshakeErr and c.handshakeComplete are protected by\n+\t// c.handshakeMutex. In order to perform a handshake, we need to lock\n+\t// c.in also and c.handshakeMutex must be locked after c.in.\n+\t//\n+\t// However, if a Read() operation is hanging then it'll be holding the\n+\t// lock on c.in and so taking it here would cause all operations that\n+\t// need to check whether a handshake is pending (such as Write) to\n+\t// block.\n+\t//\n+\t// Thus we take c.handshakeMutex first and, if we find that a handshake\n+\t// is needed, then we unlock, acquire c.in and c.handshakeMutex in the\n+\t// correct order, and check again.\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n-\tif err := c.handshakeErr; err != nil {\n-\t\treturn err\n-\t}\n-\tif c.handshakeComplete {\n-\t\treturn nil\n+\n+\tfor i := 0; i < 2; i++ {\n+\t\tif i == 1 {\n+\t\t\tc.handshakeMutex.Unlock()\n+\t\t\tc.in.Lock()\n+\t\t\tdefer c.in.Unlock()\n+\t\t\tc.handshakeMutex.Lock()\n+\t\t}\n+\n+\t\tif err := c.handshakeErr; err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif c.handshakeComplete {\n+\t\t\treturn nil\n+\t\t}\n \t}\n \n \tif c.isClient {\n \t\tc.handshakeErr = c.clientHandshake()\n \t} else {\n \t\tc.handshakeErr = c.serverHandshake()\n \t}\n+\tif c.handshakeErr == nil {\n+\t\tc.handshakes++\n+\t}\n \treturn c.handshakeErr\n }\n \n@@ -1056,7 +1258,11 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.SignedCertificateTimestamps = c.scts\n \t\tstate.OCSPResponse = c.ocspResponse\n \t\tif !c.didResume {\n-\t\t\tstate.TLSUnique = c.firstFinished[:]\n+\t\t\tif c.clientFinishedIsFirst {\n+\t\t\t\tstate.TLSUnique = c.clientFinished[:]\n+\t\t\t} else {\n+\t\t\t\tstate.TLSUnique = c.serverFinished[:]\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -1073,7 +1279,7 @@ func (c *Conn) OCSPResponse() []byte {\n }\n \n // VerifyHostname checks that the peer certificate chain is valid for\n-// connecting to host.  If so, it returns nil; if not, it returns an error\n+// connecting to host. If so, it returns nil; if not, it returns an error\n // describing the problem.\n func (c *Conn) VerifyHostname(host string) error {\n \tc.handshakeMutex.Lock()"}, {"sha": "5cff7e7cdd4b50088093bfee851239184de94fc4", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -5,6 +5,9 @@\n package tls\n \n import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"net\"\n \t\"testing\"\n )\n \n@@ -116,3 +119,125 @@ func TestCertificateSelection(t *testing.T) {\n \t\tt.Errorf(\"foo.bar.baz.example.com returned certificate %d, not 0\", n)\n \t}\n }\n+\n+// Run with multiple crypto configs to test the logic for computing TLS record overheads.\n+func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n+\tclientConn, serverConn := net.Pipe()\n+\n+\tserverConfig := config.clone()\n+\tserverConfig.DynamicRecordSizingDisabled = false\n+\ttlsConn := Server(serverConn, serverConfig)\n+\n+\trecordSizesChan := make(chan []int, 1)\n+\tgo func() {\n+\t\t// This goroutine performs a TLS handshake over clientConn and\n+\t\t// then reads TLS records until EOF. It writes a slice that\n+\t\t// contains all the record sizes to recordSizesChan.\n+\t\tdefer close(recordSizesChan)\n+\t\tdefer clientConn.Close()\n+\n+\t\ttlsConn := Client(clientConn, config)\n+\t\tif err := tlsConn.Handshake(); err != nil {\n+\t\t\tt.Errorf(\"Error from client handshake: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar recordHeader [recordHeaderLen]byte\n+\t\tvar record []byte\n+\t\tvar recordSizes []int\n+\n+\t\tfor {\n+\t\t\tn, err := clientConn.Read(recordHeader[:])\n+\t\t\tif err == io.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif err != nil || n != len(recordHeader) {\n+\t\t\t\tt.Errorf(\"Error from client read: %s\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlength := int(recordHeader[3])<<8 | int(recordHeader[4])\n+\t\t\tif len(record) < length {\n+\t\t\t\trecord = make([]byte, length)\n+\t\t\t}\n+\n+\t\t\tn, err = clientConn.Read(record[:length])\n+\t\t\tif err != nil || n != length {\n+\t\t\t\tt.Errorf(\"Error from client read: %s\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// The last record will be a close_notify alert, which\n+\t\t\t// we don't wish to record.\n+\t\t\tif recordType(recordHeader[0]) == recordTypeApplicationData {\n+\t\t\t\trecordSizes = append(recordSizes, recordHeaderLen+length)\n+\t\t\t}\n+\t\t}\n+\n+\t\trecordSizesChan <- recordSizes\n+\t}()\n+\n+\tif err := tlsConn.Handshake(); err != nil {\n+\t\tt.Fatalf(\"Error from server handshake: %s\", err)\n+\t}\n+\n+\t// The server writes these plaintexts in order.\n+\tplaintext := bytes.Join([][]byte{\n+\t\tbytes.Repeat([]byte(\"x\"), recordSizeBoostThreshold),\n+\t\tbytes.Repeat([]byte(\"y\"), maxPlaintext*2),\n+\t\tbytes.Repeat([]byte(\"z\"), maxPlaintext),\n+\t}, nil)\n+\n+\tif _, err := tlsConn.Write(plaintext); err != nil {\n+\t\tt.Fatalf(\"Error from server write: %s\", err)\n+\t}\n+\tif err := tlsConn.Close(); err != nil {\n+\t\tt.Fatalf(\"Error from server close: %s\", err)\n+\t}\n+\n+\trecordSizes := <-recordSizesChan\n+\tif recordSizes == nil {\n+\t\tt.Fatalf(\"Client encountered an error\")\n+\t}\n+\n+\t// Drop the size of last record, which is likely to be truncated.\n+\trecordSizes = recordSizes[:len(recordSizes)-1]\n+\n+\t// recordSizes should contain a series of records smaller than\n+\t// tcpMSSEstimate followed by some larger than maxPlaintext.\n+\tseenLargeRecord := false\n+\tfor i, size := range recordSizes {\n+\t\tif !seenLargeRecord {\n+\t\t\tif size > (i+1)*tcpMSSEstimate {\n+\t\t\t\tt.Fatalf(\"Record #%d has size %d, which is too large too soon\", i, size)\n+\t\t\t}\n+\t\t\tif size >= maxPlaintext {\n+\t\t\t\tseenLargeRecord = true\n+\t\t\t}\n+\t\t} else if size <= maxPlaintext {\n+\t\t\tt.Fatalf(\"Record #%d has size %d but should be full sized\", i, size)\n+\t\t}\n+\t}\n+\n+\tif !seenLargeRecord {\n+\t\tt.Fatalf(\"No large records observed\")\n+\t}\n+}\n+\n+func TestDynamicRecordSizingWithStreamCipher(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}\n+\trunDynamicRecordSizingTest(t, config)\n+}\n+\n+func TestDynamicRecordSizingWithCBC(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.CipherSuites = []uint16{TLS_RSA_WITH_AES_256_CBC_SHA}\n+\trunDynamicRecordSizingTest(t, config)\n+}\n+\n+func TestDynamicRecordSizingWithAEAD(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}\n+\trunDynamicRecordSizingTest(t, config)\n+}"}, {"sha": "f789e6f888f9adc219abe97d6571935675a02f97", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 169, "deletions": 74, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"io\"\n \t\"net\"\n \t\"strconv\"\n+\t\"strings\"\n )\n \n type clientHandshakeState struct {\n@@ -28,11 +29,16 @@ type clientHandshakeState struct {\n \tsession      *ClientSessionState\n }\n \n+// c.out.Mutex <= L; c.handshakeMutex <= L.\n func (c *Conn) clientHandshake() error {\n \tif c.config == nil {\n \t\tc.config = defaultConfig()\n \t}\n \n+\t// This may be a renegotiation handshake, in which case some fields\n+\t// need to be reset.\n+\tc.didResume = false\n+\n \tif len(c.config.ServerName) == 0 && !c.config.InsecureSkipVerify {\n \t\treturn errors.New(\"tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config\")\n \t}\n@@ -49,25 +55,22 @@ func (c *Conn) clientHandshake() error {\n \t\treturn errors.New(\"tls: NextProtos values too large\")\n \t}\n \n-\tsni := c.config.ServerName\n-\t// IP address literals are not permitted as SNI values. See\n-\t// https://tools.ietf.org/html/rfc6066#section-3.\n-\tif net.ParseIP(sni) != nil {\n-\t\tsni = \"\"\n+\thello := &clientHelloMsg{\n+\t\tvers:                         c.config.maxVersion(),\n+\t\tcompressionMethods:           []uint8{compressionNone},\n+\t\trandom:                       make([]byte, 32),\n+\t\tocspStapling:                 true,\n+\t\tscts:                         true,\n+\t\tserverName:                   hostnameInSNI(c.config.ServerName),\n+\t\tsupportedCurves:              c.config.curvePreferences(),\n+\t\tsupportedPoints:              []uint8{pointFormatUncompressed},\n+\t\tnextProtoNeg:                 len(c.config.NextProtos) > 0,\n+\t\tsecureRenegotiationSupported: true,\n+\t\talpnProtocols:                c.config.NextProtos,\n \t}\n \n-\thello := &clientHelloMsg{\n-\t\tvers:                c.config.maxVersion(),\n-\t\tcompressionMethods:  []uint8{compressionNone},\n-\t\trandom:              make([]byte, 32),\n-\t\tocspStapling:        true,\n-\t\tscts:                true,\n-\t\tserverName:          sni,\n-\t\tsupportedCurves:     c.config.curvePreferences(),\n-\t\tsupportedPoints:     []uint8{pointFormatUncompressed},\n-\t\tnextProtoNeg:        len(c.config.NextProtos) > 0,\n-\t\tsecureRenegotiation: true,\n-\t\talpnProtocols:       c.config.NextProtos,\n+\tif c.handshakes > 0 {\n+\t\thello.secureRenegotiation = c.clientFinished[:]\n \t}\n \n \tpossibleCipherSuites := c.config.cipherSuites()\n@@ -108,7 +111,12 @@ NextCipherSuite:\n \n \tif sessionCache != nil {\n \t\thello.ticketSupported = true\n+\t}\n \n+\t// Session resumption is not allowed if renegotiating because\n+\t// renegotiation is primarily used to allow a client to send a client\n+\t// certificate, which would be skipped if session resumption occured.\n+\tif sessionCache != nil && c.handshakes == 0 {\n \t\t// Try to resume a previously negotiated TLS session, if\n \t\t// available.\n \t\tcacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config)\n@@ -144,7 +152,9 @@ NextCipherSuite:\n \t\t}\n \t}\n \n-\tc.writeRecord(recordTypeHandshake, hello.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, hello.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \tmsg, err := c.readHandshake()\n \tif err != nil {\n@@ -196,17 +206,22 @@ NextCipherSuite:\n \ths.finishedHash.Write(hs.hello.marshal())\n \ths.finishedHash.Write(hs.serverHello.marshal())\n \n+\tc.buffering = true\n \tif isResume {\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif err := hs.readSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(c.firstFinished[:]); err != nil {\n+\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tc.clientFinishedIsFirst = false\n+\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(nil); err != nil {\n+\t\tif _, err := c.flush(); err != nil {\n \t\t\treturn err\n \t\t}\n \t} else {\n@@ -216,13 +231,17 @@ NextCipherSuite:\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(c.firstFinished[:]); err != nil {\n+\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif _, err := c.flush(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tc.clientFinishedIsFirst = true\n \t\tif err := hs.readSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(nil); err != nil {\n+\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -251,47 +270,62 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t}\n \ths.finishedHash.Write(certMsg.marshal())\n \n-\tcerts := make([]*x509.Certificate, len(certMsg.certificates))\n-\tfor i, asn1Data := range certMsg.certificates {\n-\t\tcert, err := x509.ParseCertificate(asn1Data)\n-\t\tif err != nil {\n-\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn errors.New(\"tls: failed to parse certificate from server: \" + err.Error())\n+\tif c.handshakes == 0 {\n+\t\t// If this is the first handshake on a connection, process and\n+\t\t// (optionally) verify the server's certificates.\n+\t\tcerts := make([]*x509.Certificate, len(certMsg.certificates))\n+\t\tfor i, asn1Data := range certMsg.certificates {\n+\t\t\tcert, err := x509.ParseCertificate(asn1Data)\n+\t\t\tif err != nil {\n+\t\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\t\treturn errors.New(\"tls: failed to parse certificate from server: \" + err.Error())\n+\t\t\t}\n+\t\t\tcerts[i] = cert\n \t\t}\n-\t\tcerts[i] = cert\n-\t}\n \n-\tif !c.config.InsecureSkipVerify {\n-\t\topts := x509.VerifyOptions{\n-\t\t\tRoots:         c.config.RootCAs,\n-\t\t\tCurrentTime:   c.config.time(),\n-\t\t\tDNSName:       c.config.ServerName,\n-\t\t\tIntermediates: x509.NewCertPool(),\n-\t\t}\n+\t\tif !c.config.InsecureSkipVerify {\n+\t\t\topts := x509.VerifyOptions{\n+\t\t\t\tRoots:         c.config.RootCAs,\n+\t\t\t\tCurrentTime:   c.config.time(),\n+\t\t\t\tDNSName:       c.config.ServerName,\n+\t\t\t\tIntermediates: x509.NewCertPool(),\n+\t\t\t}\n \n-\t\tfor i, cert := range certs {\n-\t\t\tif i == 0 {\n-\t\t\t\tcontinue\n+\t\t\tfor i, cert := range certs {\n+\t\t\t\tif i == 0 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\topts.Intermediates.AddCert(cert)\n+\t\t\t}\n+\t\t\tc.verifiedChains, err = certs[0].Verify(opts)\n+\t\t\tif err != nil {\n+\t\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\t\treturn err\n \t\t\t}\n-\t\t\topts.Intermediates.AddCert(cert)\n \t\t}\n-\t\tc.verifiedChains, err = certs[0].Verify(opts)\n-\t\tif err != nil {\n-\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn err\n+\n+\t\tswitch certs[0].PublicKey.(type) {\n+\t\tcase *rsa.PublicKey, *ecdsa.PublicKey:\n+\t\t\tbreak\n+\t\tdefault:\n+\t\t\tc.sendAlert(alertUnsupportedCertificate)\n+\t\t\treturn fmt.Errorf(\"tls: server's certificate contains an unsupported type of public key: %T\", certs[0].PublicKey)\n \t\t}\n-\t}\n \n-\tswitch certs[0].PublicKey.(type) {\n-\tcase *rsa.PublicKey, *ecdsa.PublicKey:\n-\t\tbreak\n-\tdefault:\n-\t\tc.sendAlert(alertUnsupportedCertificate)\n-\t\treturn fmt.Errorf(\"tls: server's certificate contains an unsupported type of public key: %T\", certs[0].PublicKey)\n+\t\tc.peerCertificates = certs\n+\t} else {\n+\t\t// This is a renegotiation handshake. We require that the\n+\t\t// server's identity (i.e. leaf certificate) is unchanged and\n+\t\t// thus any previous trust decision is still valid.\n+\t\t//\n+\t\t// See https://mitls.org/pages/attacks/3SHAKE for the\n+\t\t// motivation behind this requirement.\n+\t\tif !bytes.Equal(c.peerCertificates[0].Raw, certMsg.certificates[0]) {\n+\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\treturn errors.New(\"tls: server's identity changed during renegotiation\")\n+\t\t}\n \t}\n \n-\tc.peerCertificates = certs\n-\n \tif hs.serverHello.ocspStapling {\n \t\tmsg, err = c.readHandshake()\n \t\tif err != nil {\n@@ -319,7 +353,7 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \tskx, ok := msg.(*serverKeyExchangeMsg)\n \tif ok {\n \t\ths.finishedHash.Write(skx.marshal())\n-\t\terr = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, certs[0], skx)\n+\t\terr = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertUnexpectedMessage)\n \t\t\treturn err\n@@ -425,17 +459,21 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t\tcertMsg.certificates = chainToSend.Certificate\n \t\t}\n \t\ths.finishedHash.Write(certMsg.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n-\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, certs[0])\n+\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[0])\n \tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n \t\treturn err\n \t}\n \tif ckx != nil {\n \t\ths.finishedHash.Write(ckx.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, ckx.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, ckx.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \tif chainToSend != nil {\n@@ -477,7 +515,9 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t}\n \n \t\ths.finishedHash.Write(certVerify.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, certVerify.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, certVerify.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.hello.random, hs.serverHello.random)\n@@ -524,24 +564,42 @@ func (hs *clientHandshakeState) processServerHello() (bool, error) {\n \t\treturn false, errors.New(\"tls: server selected unsupported compression format\")\n \t}\n \n+\tif c.handshakes == 0 && hs.serverHello.secureRenegotiationSupported {\n+\t\tc.secureRenegotiation = true\n+\t\tif len(hs.serverHello.secureRenegotiation) != 0 {\n+\t\t\tc.sendAlert(alertHandshakeFailure)\n+\t\t\treturn false, errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n+\t\t}\n+\t}\n+\n+\tif c.handshakes > 0 && c.secureRenegotiation {\n+\t\tvar expectedSecureRenegotiation [24]byte\n+\t\tcopy(expectedSecureRenegotiation[:], c.clientFinished[:])\n+\t\tcopy(expectedSecureRenegotiation[12:], c.serverFinished[:])\n+\t\tif !bytes.Equal(hs.serverHello.secureRenegotiation, expectedSecureRenegotiation[:]) {\n+\t\t\tc.sendAlert(alertHandshakeFailure)\n+\t\t\treturn false, errors.New(\"tls: incorrect renegotiation extension contents\")\n+\t\t}\n+\t}\n+\n \tclientDidNPN := hs.hello.nextProtoNeg\n \tclientDidALPN := len(hs.hello.alpnProtocols) > 0\n \tserverHasNPN := hs.serverHello.nextProtoNeg\n \tserverHasALPN := len(hs.serverHello.alpnProtocol) > 0\n \n \tif !clientDidNPN && serverHasNPN {\n \t\tc.sendAlert(alertHandshakeFailure)\n-\t\treturn false, errors.New(\"server advertised unrequested NPN extension\")\n+\t\treturn false, errors.New(\"tls: server advertised unrequested NPN extension\")\n \t}\n \n \tif !clientDidALPN && serverHasALPN {\n \t\tc.sendAlert(alertHandshakeFailure)\n-\t\treturn false, errors.New(\"server advertised unrequested ALPN extension\")\n+\t\treturn false, errors.New(\"tls: server advertised unrequested ALPN extension\")\n \t}\n \n \tif serverHasNPN && serverHasALPN {\n \t\tc.sendAlert(alertHandshakeFailure)\n-\t\treturn false, errors.New(\"server advertised both NPN and ALPN extensions\")\n+\t\treturn false, errors.New(\"tls: server advertised both NPN and ALPN extensions\")\n \t}\n \n \tif serverHasALPN {\n@@ -550,22 +608,33 @@ func (hs *clientHandshakeState) processServerHello() (bool, error) {\n \t}\n \tc.scts = hs.serverHello.scts\n \n-\tif hs.serverResumedSession() {\n-\t\t// Restore masterSecret and peerCerts from previous state\n-\t\ths.masterSecret = hs.session.masterSecret\n-\t\tc.peerCertificates = hs.session.serverCertificates\n-\t\tc.verifiedChains = hs.session.verifiedChains\n-\t\treturn true, nil\n+\tif !hs.serverResumedSession() {\n+\t\treturn false, nil\n+\t}\n+\n+\tif hs.session.vers != c.vers {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn false, errors.New(\"tls: server resumed a session with a different version\")\n+\t}\n+\n+\tif hs.session.cipherSuite != hs.suite.id {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn false, errors.New(\"tls: server resumed a session with a different cipher suite\")\n \t}\n-\treturn false, nil\n+\n+\t// Restore masterSecret and peerCerts from previous state\n+\ths.masterSecret = hs.session.masterSecret\n+\tc.peerCertificates = hs.session.serverCertificates\n+\tc.verifiedChains = hs.session.verifiedChains\n+\treturn true, nil\n }\n \n func (hs *clientHandshakeState) readFinished(out []byte) error {\n \tc := hs.c\n \n \tc.readRecord(recordTypeChangeCipherSpec)\n-\tif err := c.in.error(); err != nil {\n-\t\treturn err\n+\tif c.in.err != nil {\n+\t\treturn c.in.err\n \t}\n \n \tmsg, err := c.readHandshake()\n@@ -621,7 +690,9 @@ func (hs *clientHandshakeState) readSessionTicket() error {\n func (hs *clientHandshakeState) sendFinished(out []byte) error {\n \tc := hs.c\n \n-\tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n+\tif _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil {\n+\t\treturn err\n+\t}\n \tif hs.serverHello.nextProtoNeg {\n \t\tnextProto := new(nextProtoMsg)\n \t\tproto, fallback := mutualProtocol(c.config.NextProtos, hs.serverHello.nextProtos)\n@@ -630,13 +701,17 @@ func (hs *clientHandshakeState) sendFinished(out []byte) error {\n \t\tc.clientProtocolFallback = fallback\n \n \t\ths.finishedHash.Write(nextProto.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, nextProto.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, nextProto.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \tfinished := new(finishedMsg)\n \tfinished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)\n \ths.finishedHash.Write(finished.marshal())\n-\tc.writeRecord(recordTypeHandshake, finished.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \tcopy(out, finished.verifyData)\n \treturn nil\n }\n@@ -665,3 +740,23 @@ func mutualProtocol(protos, preferenceProtos []string) (string, bool) {\n \n \treturn protos[0], true\n }\n+\n+// hostnameInSNI converts name into an approriate hostname for SNI.\n+// Literal IP addresses and absolute FQDNs are not permitted as SNI values.\n+// See https://tools.ietf.org/html/rfc6066#section-3.\n+func hostnameInSNI(name string) string {\n+\thost := name\n+\tif len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {\n+\t\thost = host[1 : len(host)-1]\n+\t}\n+\tif i := strings.LastIndex(host, \"%\"); i > 0 {\n+\t\thost = host[:i]\n+\t}\n+\tif net.ParseIP(host) != nil {\n+\t\treturn \"\"\n+\t}\n+\tif len(name) > 0 && name[len(name)-1] == '.' {\n+\t\tname = name[:len(name)-1]\n+\t}\n+\treturn name\n+}"}, {"sha": "ce987f11c463fa4939b3bd9bdb1f7df9619ff80e", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 392, "deletions": 41, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"encoding/base64\"\n \t\"encoding/binary\"\n \t\"encoding/pem\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"net\"\n@@ -27,14 +28,80 @@ import (\n // Note: see comment in handshake_test.go for details of how the reference\n // tests work.\n \n-// blockingSource is an io.Reader that blocks a Read call until it's closed.\n-type blockingSource chan bool\n+// opensslInputEvent enumerates possible inputs that can be sent to an `openssl\n+// s_client` process.\n+type opensslInputEvent int\n+\n+const (\n+\t// opensslRenegotiate causes OpenSSL to request a renegotiation of the\n+\t// connection.\n+\topensslRenegotiate opensslInputEvent = iota\n+\n+\t// opensslSendBanner causes OpenSSL to send the contents of\n+\t// opensslSentinel on the connection.\n+\topensslSendSentinel\n+)\n+\n+const opensslSentinel = \"SENTINEL\\n\"\n+\n+type opensslInput chan opensslInputEvent\n+\n+func (i opensslInput) Read(buf []byte) (n int, err error) {\n+\tfor event := range i {\n+\t\tswitch event {\n+\t\tcase opensslRenegotiate:\n+\t\t\treturn copy(buf, []byte(\"R\\n\")), nil\n+\t\tcase opensslSendSentinel:\n+\t\t\treturn copy(buf, []byte(opensslSentinel)), nil\n+\t\tdefault:\n+\t\t\tpanic(\"unknown event\")\n+\t\t}\n+\t}\n \n-func (b blockingSource) Read([]byte) (n int, err error) {\n-\t<-b\n \treturn 0, io.EOF\n }\n \n+// opensslOutputSink is an io.Writer that receives the stdout and stderr from\n+// an `openssl` process and sends a value to handshakeComplete when it sees a\n+// log message from a completed server handshake.\n+type opensslOutputSink struct {\n+\thandshakeComplete chan struct{}\n+\tall               []byte\n+\tline              []byte\n+}\n+\n+func newOpensslOutputSink() *opensslOutputSink {\n+\treturn &opensslOutputSink{make(chan struct{}), nil, nil}\n+}\n+\n+// opensslEndOfHandshake is a message that the \u201copenssl s_server\u201d tool will\n+// print when a handshake completes if run with \u201c-state\u201d.\n+const opensslEndOfHandshake = \"SSL_accept:SSLv3 write finished A\"\n+\n+func (o *opensslOutputSink) Write(data []byte) (n int, err error) {\n+\to.line = append(o.line, data...)\n+\to.all = append(o.all, data...)\n+\n+\tfor {\n+\t\ti := bytes.Index(o.line, []byte{'\\n'})\n+\t\tif i < 0 {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif bytes.Equal([]byte(opensslEndOfHandshake), o.line[:i]) {\n+\t\t\to.handshakeComplete <- struct{}{}\n+\t\t}\n+\t\to.line = o.line[i+1:]\n+\t}\n+\n+\treturn len(data), nil\n+}\n+\n+func (o *opensslOutputSink) WriteTo(w io.Writer) (int64, error) {\n+\tn, err := w.Write(o.all)\n+\treturn int64(n), err\n+}\n+\n // clientTest represents a test of the TLS client handshake against a reference\n // implementation.\n type clientTest struct {\n@@ -60,15 +127,25 @@ type clientTest struct {\n \t// ConnectionState of the resulting connection. It returns a non-nil\n \t// error if the ConnectionState is unacceptable.\n \tvalidate func(ConnectionState) error\n+\t// numRenegotiations is the number of times that the connection will be\n+\t// renegotiated.\n+\tnumRenegotiations int\n+\t// renegotiationExpectedToFail, if not zero, is the number of the\n+\t// renegotiation attempt that is expected to fail.\n+\trenegotiationExpectedToFail int\n+\t// checkRenegotiationError, if not nil, is called with any error\n+\t// arising from renegotiation. It can map expected errors to nil to\n+\t// ignore them.\n+\tcheckRenegotiationError func(renegotiationNum int, err error) error\n }\n \n var defaultServerCommand = []string{\"openssl\", \"s_server\"}\n \n // connFromCommand starts the reference server process, connects to it and\n-// returns a recordingConn for the connection. The stdin return value is a\n-// blockingSource for the stdin of the child process. It must be closed before\n+// returns a recordingConn for the connection. The stdin return value is an\n+// opensslInput for the stdin of the child process. It must be closed before\n // Waiting for child.\n-func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin blockingSource, err error) {\n+func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin opensslInput, stdout *opensslOutputSink, err error) {\n \tcert := testRSACertificate\n \tif len(test.cert) > 0 {\n \t\tcert = test.cert\n@@ -131,14 +208,28 @@ func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd,\n \t\tcommand = append(command, \"-serverinfo\", serverInfoPath)\n \t}\n \n+\tif test.numRenegotiations > 0 {\n+\t\tfound := false\n+\t\tfor _, flag := range command[1:] {\n+\t\t\tif flag == \"-state\" {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !found {\n+\t\t\tpanic(\"-state flag missing to OpenSSL. You need this if testing renegotiation\")\n+\t\t}\n+\t}\n+\n \tcmd := exec.Command(command[0], command[1:]...)\n-\tstdin = blockingSource(make(chan bool))\n+\tstdin = opensslInput(make(chan opensslInputEvent))\n \tcmd.Stdin = stdin\n-\tvar out bytes.Buffer\n-\tcmd.Stdout = &out\n-\tcmd.Stderr = &out\n+\tout := newOpensslOutputSink()\n+\tcmd.Stdout = out\n+\tcmd.Stderr = out\n \tif err := cmd.Start(); err != nil {\n-\t\treturn nil, nil, nil, err\n+\t\treturn nil, nil, nil, nil, err\n \t}\n \n \t// OpenSSL does print an \"ACCEPT\" banner, but it does so *before*\n@@ -160,14 +251,14 @@ func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd,\n \t\tclose(stdin)\n \t\tout.WriteTo(os.Stdout)\n \t\tcmd.Process.Kill()\n-\t\treturn nil, nil, nil, cmd.Wait()\n+\t\treturn nil, nil, nil, nil, cmd.Wait()\n \t}\n \n \trecord := &recordingConn{\n \t\tConn: tcpConn,\n \t}\n \n-\treturn record, cmd, stdin, nil\n+\treturn record, cmd, stdin, out, nil\n }\n \n func (test *clientTest) dataPath() string {\n@@ -187,11 +278,12 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \tvar clientConn, serverConn net.Conn\n \tvar recordingConn *recordingConn\n \tvar childProcess *exec.Cmd\n-\tvar stdin blockingSource\n+\tvar stdin opensslInput\n+\tvar stdout *opensslOutputSink\n \n \tif write {\n \t\tvar err error\n-\t\trecordingConn, childProcess, stdin, err = test.connFromCommand()\n+\t\trecordingConn, childProcess, stdin, stdout, err = test.connFromCommand()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Failed to start subcommand: %s\", err)\n \t\t}\n@@ -208,17 +300,77 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \n \tdoneChan := make(chan bool)\n \tgo func() {\n+\t\tdefer func() { doneChan <- true }()\n+\t\tdefer clientConn.Close()\n+\t\tdefer client.Close()\n+\n \t\tif _, err := client.Write([]byte(\"hello\\n\")); err != nil {\n \t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n+\t\t\treturn\n \t\t}\n+\n+\t\tfor i := 1; i <= test.numRenegotiations; i++ {\n+\t\t\t// The initial handshake will generate a\n+\t\t\t// handshakeComplete signal which needs to be quashed.\n+\t\t\tif i == 1 && write {\n+\t\t\t\t<-stdout.handshakeComplete\n+\t\t\t}\n+\n+\t\t\t// OpenSSL will try to interleave application data and\n+\t\t\t// a renegotiation if we send both concurrently.\n+\t\t\t// Therefore: ask OpensSSL to start a renegotiation, run\n+\t\t\t// a goroutine to call client.Read and thus process the\n+\t\t\t// renegotiation request, watch for OpenSSL's stdout to\n+\t\t\t// indicate that the handshake is complete and,\n+\t\t\t// finally, have OpenSSL write something to cause\n+\t\t\t// client.Read to complete.\n+\t\t\tif write {\n+\t\t\t\tstdin <- opensslRenegotiate\n+\t\t\t}\n+\n+\t\t\tsignalChan := make(chan struct{})\n+\n+\t\t\tgo func() {\n+\t\t\t\tdefer func() { signalChan <- struct{}{} }()\n+\n+\t\t\t\tbuf := make([]byte, 256)\n+\t\t\t\tn, err := client.Read(buf)\n+\n+\t\t\t\tif test.checkRenegotiationError != nil {\n+\t\t\t\t\tnewErr := test.checkRenegotiationError(i, err)\n+\t\t\t\t\tif err != nil && newErr == nil {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\terr = newErr\n+\t\t\t\t}\n+\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"Client.Read failed after renegotiation #%d: %s\", i, err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tbuf = buf[:n]\n+\t\t\t\tif !bytes.Equal([]byte(opensslSentinel), buf) {\n+\t\t\t\t\tt.Errorf(\"Client.Read returned %q, but wanted %q\", string(buf), opensslSentinel)\n+\t\t\t\t}\n+\n+\t\t\t\tif expected := i + 1; client.handshakes != expected {\n+\t\t\t\t\tt.Errorf(\"client should have recorded %d handshakes, but believes that %d have occured\", expected, client.handshakes)\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tif write && test.renegotiationExpectedToFail != i {\n+\t\t\t\t<-stdout.handshakeComplete\n+\t\t\t\tstdin <- opensslSendSentinel\n+\t\t\t}\n+\t\t\t<-signalChan\n+\t\t}\n+\n \t\tif test.validate != nil {\n \t\t\tif err := test.validate(client.ConnectionState()); err != nil {\n \t\t\t\tt.Errorf(\"validate callback returned error: %s\", err)\n \t\t\t}\n \t\t}\n-\t\tclient.Close()\n-\t\tclientConn.Close()\n-\t\tdoneChan <- true\n \t}()\n \n \tif !write {\n@@ -357,14 +509,14 @@ func TestHandshakeClientAES256GCMSHA384(t *testing.T) {\n }\n \n func TestHandshakeClientCertRSA(t *testing.T) {\n-\tconfig := *testConfig\n+\tconfig := testConfig.clone()\n \tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n \tconfig.Certificates = []Certificate{cert}\n \n \ttest := &clientTest{\n \t\tname:    \"ClientCert-RSA-RSA\",\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"RC4-SHA\", \"-verify\", \"1\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t}\n \n \trunClientTestTLS10(t, test)\n@@ -373,7 +525,7 @@ func TestHandshakeClientCertRSA(t *testing.T) {\n \ttest = &clientTest{\n \t\tname:    \"ClientCert-RSA-ECDSA\",\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-verify\", \"1\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t\tcert:    testECDSACertificate,\n \t\tkey:     testECDSAPrivateKey,\n \t}\n@@ -384,7 +536,7 @@ func TestHandshakeClientCertRSA(t *testing.T) {\n \ttest = &clientTest{\n \t\tname:    \"ClientCert-RSA-AES256-GCM-SHA384\",\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-RSA-AES256-GCM-SHA384\", \"-verify\", \"1\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t\tcert:    testRSACertificate,\n \t\tkey:     testRSAPrivateKey,\n \t}\n@@ -393,14 +545,14 @@ func TestHandshakeClientCertRSA(t *testing.T) {\n }\n \n func TestHandshakeClientCertECDSA(t *testing.T) {\n-\tconfig := *testConfig\n+\tconfig := testConfig.clone()\n \tcert, _ := X509KeyPair([]byte(clientECDSACertificatePEM), []byte(clientECDSAKeyPEM))\n \tconfig.Certificates = []Certificate{cert}\n \n \ttest := &clientTest{\n \t\tname:    \"ClientCert-ECDSA-RSA\",\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"RC4-SHA\", \"-verify\", \"1\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t}\n \n \trunClientTestTLS10(t, test)\n@@ -409,7 +561,7 @@ func TestHandshakeClientCertECDSA(t *testing.T) {\n \ttest = &clientTest{\n \t\tname:    \"ClientCert-ECDSA-ECDSA\",\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-ECDSA-AES128-SHA\", \"-verify\", \"1\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t\tcert:    testECDSACertificate,\n \t\tkey:     testECDSAPrivateKey,\n \t}\n@@ -448,7 +600,7 @@ func TestClientResumption(t *testing.T) {\n \t\t\tt.Fatalf(\"%s resumed: %v, expected: %v\", test, hs.DidResume, didResume)\n \t\t}\n \t\tif didResume && (hs.PeerCertificates == nil || hs.VerifiedChains == nil) {\n-\t\t\tt.Fatalf(\"expected non-nil certificates after resumption. Got peerCertificates: %#v, verifedCertificates: %#v\", hs.PeerCertificates, hs.VerifiedChains)\n+\t\t\tt.Fatalf(\"expected non-nil certificates after resumption. Got peerCertificates: %#v, verifiedCertificates: %#v\", hs.PeerCertificates, hs.VerifiedChains)\n \t\t}\n \t}\n \n@@ -539,15 +691,15 @@ func TestLRUClientSessionCache(t *testing.T) {\n }\n \n func TestHandshakeClientALPNMatch(t *testing.T) {\n-\tconfig := *testConfig\n+\tconfig := testConfig.clone()\n \tconfig.NextProtos = []string{\"proto2\", \"proto1\"}\n \n \ttest := &clientTest{\n \t\tname: \"ALPN\",\n \t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n \t\t// version that supports the -alpn flag.\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-alpn\", \"proto1,proto2\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t\tvalidate: func(state ConnectionState) error {\n \t\t\t// The server's preferences should override the client.\n \t\t\tif state.NegotiatedProtocol != \"proto1\" {\n@@ -560,15 +712,15 @@ func TestHandshakeClientALPNMatch(t *testing.T) {\n }\n \n func TestHandshakeClientALPNNoMatch(t *testing.T) {\n-\tconfig := *testConfig\n+\tconfig := testConfig.clone()\n \tconfig.NextProtos = []string{\"proto3\"}\n \n \ttest := &clientTest{\n \t\tname: \"ALPN-NoMatch\",\n \t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n \t\t// version that supports the -alpn flag.\n \t\tcommand: []string{\"openssl\", \"s_server\", \"-alpn\", \"proto1,proto2\"},\n-\t\tconfig:  &config,\n+\t\tconfig:  config,\n \t\tvalidate: func(state ConnectionState) error {\n \t\t\t// There's no overlap so OpenSSL will not select a protocol.\n \t\t\tif state.NegotiatedProtocol != \"\" {\n@@ -584,7 +736,7 @@ func TestHandshakeClientALPNNoMatch(t *testing.T) {\n const sctsBase64 = \"ABIBaQFnAHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFHl5nuFgAABAMARjBEAiAcS4JdlW5nW9sElUv2zvQyPoZ6ejKrGGB03gjaBZFMLwIgc1Qbbn+hsH0RvObzhS+XZhr3iuQQJY8S9G85D9KeGPAAdgBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAUeX4bVwAAAEAwBHMEUCIDIhFDgG2HIuADBkGuLobU5a4dlCHoJLliWJ1SYT05z6AiEAjxIoZFFPRNWMGGIjskOTMwXzQ1Wh2e7NxXE1kd1J0QsAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMAxHuJeqj9ywAAAUhcZIqHAAAEAwBHMEUCICmJ1rBT09LpkbzxtUC+Hi7nXLR0J+2PmwLp+sJMuqK+AiEAr0NkUnEVKVhAkccIFpYDqHOlZaBsuEhWWrYpg2RtKp0=\"\n \n func TestHandshakClientSCTs(t *testing.T) {\n-\tconfig := *testConfig\n+\tconfig := testConfig.clone()\n \n \tscts, err := base64.StdEncoding.DecodeString(sctsBase64)\n \tif err != nil {\n@@ -596,7 +748,7 @@ func TestHandshakClientSCTs(t *testing.T) {\n \t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n \t\t// version that supports the -serverinfo flag.\n \t\tcommand:    []string{\"openssl\", \"s_server\"},\n-\t\tconfig:     &config,\n+\t\tconfig:     config,\n \t\textensions: [][]byte{scts},\n \t\tvalidate: func(state ConnectionState) error {\n \t\t\texpectedSCTs := [][]byte{\n@@ -618,14 +770,113 @@ func TestHandshakClientSCTs(t *testing.T) {\n \trunClientTestTLS12(t, test)\n }\n \n-func TestNoIPAddressesInSNI(t *testing.T) {\n-\tfor _, ipLiteral := range []string{\"1.2.3.4\", \"::1\"} {\n+func TestRenegotiationRejected(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\ttest := &clientTest{\n+\t\tname:                        \"RenegotiationRejected\",\n+\t\tcommand:                     []string{\"openssl\", \"s_server\", \"-state\"},\n+\t\tconfig:                      config,\n+\t\tnumRenegotiations:           1,\n+\t\trenegotiationExpectedToFail: 1,\n+\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n+\t\t\tif err == nil {\n+\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n+\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestRenegotiateOnce(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.Renegotiation = RenegotiateOnceAsClient\n+\n+\ttest := &clientTest{\n+\t\tname:              \"RenegotiateOnce\",\n+\t\tcommand:           []string{\"openssl\", \"s_server\", \"-state\"},\n+\t\tconfig:            config,\n+\t\tnumRenegotiations: 1,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestRenegotiateTwice(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.Renegotiation = RenegotiateFreelyAsClient\n+\n+\ttest := &clientTest{\n+\t\tname:              \"RenegotiateTwice\",\n+\t\tcommand:           []string{\"openssl\", \"s_server\", \"-state\"},\n+\t\tconfig:            config,\n+\t\tnumRenegotiations: 2,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestRenegotiateTwiceRejected(t *testing.T) {\n+\tconfig := testConfig.clone()\n+\tconfig.Renegotiation = RenegotiateOnceAsClient\n+\n+\ttest := &clientTest{\n+\t\tname:                        \"RenegotiateTwiceRejected\",\n+\t\tcommand:                     []string{\"openssl\", \"s_server\", \"-state\"},\n+\t\tconfig:                      config,\n+\t\tnumRenegotiations:           2,\n+\t\trenegotiationExpectedToFail: 2,\n+\t\tcheckRenegotiationError: func(renegotiationNum int, err error) error {\n+\t\t\tif renegotiationNum == 1 {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tif err == nil {\n+\t\t\t\treturn errors.New(\"expected error from renegotiation but got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"no renegotiation\") {\n+\t\t\t\treturn fmt.Errorf(\"expected renegotiation to be rejected but got %q\", err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n+}\n+\n+var hostnameInSNITests = []struct {\n+\tin, out string\n+}{\n+\t// Opaque string\n+\t{\"\", \"\"},\n+\t{\"localhost\", \"localhost\"},\n+\t{\"foo, bar, baz and qux\", \"foo, bar, baz and qux\"},\n+\n+\t// DNS hostname\n+\t{\"golang.org\", \"golang.org\"},\n+\t{\"golang.org.\", \"golang.org\"},\n+\n+\t// Literal IPv4 address\n+\t{\"1.2.3.4\", \"\"},\n+\n+\t// Literal IPv6 address\n+\t{\"::1\", \"\"},\n+\t{\"::1%lo0\", \"\"}, // with zone identifier\n+\t{\"[::1]\", \"\"},   // as per RFC 5952 we allow the [] style as IPv6 literal\n+\t{\"[::1%lo0]\", \"\"},\n+}\n+\n+func TestHostnameInSNI(t *testing.T) {\n+\tfor _, tt := range hostnameInSNITests {\n \t\tc, s := net.Pipe()\n \n-\t\tgo func() {\n-\t\t\tclient := Client(c, &Config{ServerName: ipLiteral})\n-\t\t\tclient.Handshake()\n-\t\t}()\n+\t\tgo func(host string) {\n+\t\t\tClient(c, &Config{ServerName: host, InsecureSkipVerify: true}).Handshake()\n+\t\t}(tt.in)\n \n \t\tvar header [5]byte\n \t\tif _, err := io.ReadFull(s, header[:]); err != nil {\n@@ -637,10 +888,20 @@ func TestNoIPAddressesInSNI(t *testing.T) {\n \t\tif _, err := io.ReadFull(s, record[:]); err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n+\n+\t\tc.Close()\n \t\ts.Close()\n \n-\t\tif bytes.Index(record, []byte(ipLiteral)) != -1 {\n-\t\t\tt.Errorf(\"IP literal %q found in ClientHello: %x\", ipLiteral, record)\n+\t\tvar m clientHelloMsg\n+\t\tif !m.unmarshal(record) {\n+\t\t\tt.Errorf(\"unmarshaling ClientHello for %q failed\", tt.in)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.in != tt.out && m.serverName == tt.in {\n+\t\t\tt.Errorf(\"prohibited %q found in ClientHello: %x\", tt.in, record)\n+\t\t}\n+\t\tif m.serverName != tt.out {\n+\t\t\tt.Errorf(\"expected %q not found in ClientHello: %x\", tt.out, record)\n \t\t}\n \t}\n }\n@@ -694,3 +955,93 @@ func TestServerSelectingUnconfiguredCipherSuite(t *testing.T) {\n \t\tt.Fatalf(\"Expected error about unconfigured cipher suite but got %q\", err)\n \t}\n }\n+\n+// brokenConn wraps a net.Conn and causes all Writes after a certain number to\n+// fail with brokenConnErr.\n+type brokenConn struct {\n+\tnet.Conn\n+\n+\t// breakAfter is the number of successful writes that will be allowed\n+\t// before all subsequent writes fail.\n+\tbreakAfter int\n+\n+\t// numWrites is the number of writes that have been done.\n+\tnumWrites int\n+}\n+\n+// brokenConnErr is the error that brokenConn returns once exhausted.\n+var brokenConnErr = errors.New(\"too many writes to brokenConn\")\n+\n+func (b *brokenConn) Write(data []byte) (int, error) {\n+\tif b.numWrites >= b.breakAfter {\n+\t\treturn 0, brokenConnErr\n+\t}\n+\n+\tb.numWrites++\n+\treturn b.Conn.Write(data)\n+}\n+\n+func TestFailedWrite(t *testing.T) {\n+\t// Test that a write error during the handshake is returned.\n+\tfor _, breakAfter := range []int{0, 1} {\n+\t\tc, s := net.Pipe()\n+\t\tdone := make(chan bool)\n+\n+\t\tgo func() {\n+\t\t\tServer(s, testConfig).Handshake()\n+\t\t\ts.Close()\n+\t\t\tdone <- true\n+\t\t}()\n+\n+\t\tbrokenC := &brokenConn{Conn: c, breakAfter: breakAfter}\n+\t\terr := Client(brokenC, testConfig).Handshake()\n+\t\tif err != brokenConnErr {\n+\t\t\tt.Errorf(\"#%d: expected error from brokenConn but got %q\", breakAfter, err)\n+\t\t}\n+\t\tbrokenC.Close()\n+\n+\t\t<-done\n+\t}\n+}\n+\n+// writeCountingConn wraps a net.Conn and counts the number of Write calls.\n+type writeCountingConn struct {\n+\tnet.Conn\n+\n+\t// numWrites is the number of writes that have been done.\n+\tnumWrites int\n+}\n+\n+func (wcc *writeCountingConn) Write(data []byte) (int, error) {\n+\twcc.numWrites++\n+\treturn wcc.Conn.Write(data)\n+}\n+\n+func TestBuffering(t *testing.T) {\n+\tc, s := net.Pipe()\n+\tdone := make(chan bool)\n+\n+\tclientWCC := &writeCountingConn{Conn: c}\n+\tserverWCC := &writeCountingConn{Conn: s}\n+\n+\tgo func() {\n+\t\tServer(serverWCC, testConfig).Handshake()\n+\t\tserverWCC.Close()\n+\t\tdone <- true\n+\t}()\n+\n+\terr := Client(clientWCC, testConfig).Handshake()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tclientWCC.Close()\n+\t<-done\n+\n+\tif n := clientWCC.numWrites; n != 2 {\n+\t\tt.Errorf(\"expected client handshake to complete with only two writes, but saw %d\", n)\n+\t}\n+\n+\tif n := serverWCC.numWrites; n != 2 {\n+\t\tt.Errorf(\"expected server handshake to complete with only two writes, but saw %d\", n)\n+\t}\n+}"}, {"sha": "ab8e60ae11640ae3a3c309881037be52a3eb715d", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 85, "deletions": 51, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -7,23 +7,24 @@ package tls\n import \"bytes\"\n \n type clientHelloMsg struct {\n-\traw                 []byte\n-\tvers                uint16\n-\trandom              []byte\n-\tsessionId           []byte\n-\tcipherSuites        []uint16\n-\tcompressionMethods  []uint8\n-\tnextProtoNeg        bool\n-\tserverName          string\n-\tocspStapling        bool\n-\tscts                bool\n-\tsupportedCurves     []CurveID\n-\tsupportedPoints     []uint8\n-\tticketSupported     bool\n-\tsessionTicket       []uint8\n-\tsignatureAndHashes  []signatureAndHash\n-\tsecureRenegotiation bool\n-\talpnProtocols       []string\n+\traw                          []byte\n+\tvers                         uint16\n+\trandom                       []byte\n+\tsessionId                    []byte\n+\tcipherSuites                 []uint16\n+\tcompressionMethods           []uint8\n+\tnextProtoNeg                 bool\n+\tserverName                   string\n+\tocspStapling                 bool\n+\tscts                         bool\n+\tsupportedCurves              []CurveID\n+\tsupportedPoints              []uint8\n+\tticketSupported              bool\n+\tsessionTicket                []uint8\n+\tsignatureAndHashes           []signatureAndHash\n+\tsecureRenegotiation          []byte\n+\tsecureRenegotiationSupported bool\n+\talpnProtocols                []string\n }\n \n func (m *clientHelloMsg) equal(i interface{}) bool {\n@@ -47,7 +48,8 @@ func (m *clientHelloMsg) equal(i interface{}) bool {\n \t\tm.ticketSupported == m1.ticketSupported &&\n \t\tbytes.Equal(m.sessionTicket, m1.sessionTicket) &&\n \t\teqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes) &&\n-\t\tm.secureRenegotiation == m1.secureRenegotiation &&\n+\t\tm.secureRenegotiationSupported == m1.secureRenegotiationSupported &&\n+\t\tbytes.Equal(m.secureRenegotiation, m1.secureRenegotiation) &&\n \t\teqStrings(m.alpnProtocols, m1.alpnProtocols)\n }\n \n@@ -86,8 +88,8 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\textensionsLength += 2 + 2*len(m.signatureAndHashes)\n \t\tnumExtensions++\n \t}\n-\tif m.secureRenegotiation {\n-\t\textensionsLength += 1\n+\tif m.secureRenegotiationSupported {\n+\t\textensionsLength += 1 + len(m.secureRenegotiation)\n \t\tnumExtensions++\n \t}\n \tif len(m.alpnProtocols) > 0 {\n@@ -214,7 +216,7 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\tz[4] = byte(l)\n \t\tz = z[5:]\n \t\tfor _, pointFormat := range m.supportedPoints {\n-\t\t\tz[0] = byte(pointFormat)\n+\t\t\tz[0] = pointFormat\n \t\t\tz = z[1:]\n \t\t}\n \t}\n@@ -248,12 +250,15 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\t\tz = z[2:]\n \t\t}\n \t}\n-\tif m.secureRenegotiation {\n+\tif m.secureRenegotiationSupported {\n \t\tz[0] = byte(extensionRenegotiationInfo >> 8)\n \t\tz[1] = byte(extensionRenegotiationInfo & 0xff)\n \t\tz[2] = 0\n-\t\tz[3] = 1\n+\t\tz[3] = byte(len(m.secureRenegotiation) + 1)\n+\t\tz[4] = byte(len(m.secureRenegotiation))\n \t\tz = z[5:]\n+\t\tcopy(z, m.secureRenegotiation)\n+\t\tz = z[len(m.secureRenegotiation):]\n \t}\n \tif len(m.alpnProtocols) > 0 {\n \t\tz[0] = byte(extensionALPN >> 8)\n@@ -316,7 +321,7 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \tfor i := 0; i < numCipherSuites; i++ {\n \t\tm.cipherSuites[i] = uint16(data[2+2*i])<<8 | uint16(data[3+2*i])\n \t\tif m.cipherSuites[i] == scsvRenegotiation {\n-\t\t\tm.secureRenegotiation = true\n+\t\t\tm.secureRenegotiationSupported = true\n \t\t}\n \t}\n \tdata = data[2+cipherSuiteLen:]\n@@ -448,10 +453,18 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\t\td = d[2:]\n \t\t\t}\n \t\tcase extensionRenegotiationInfo:\n-\t\t\tif length != 1 || data[0] != 0 {\n+\t\t\tif length == 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\td := data[:length]\n+\t\t\tl := int(d[0])\n+\t\t\td = d[1:]\n+\t\t\tif l != len(d) {\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tm.secureRenegotiation = true\n+\n+\t\t\tm.secureRenegotiation = d\n+\t\t\tm.secureRenegotiationSupported = true\n \t\tcase extensionALPN:\n \t\t\tif length < 2 {\n \t\t\t\treturn false\n@@ -483,19 +496,20 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n }\n \n type serverHelloMsg struct {\n-\traw                 []byte\n-\tvers                uint16\n-\trandom              []byte\n-\tsessionId           []byte\n-\tcipherSuite         uint16\n-\tcompressionMethod   uint8\n-\tnextProtoNeg        bool\n-\tnextProtos          []string\n-\tocspStapling        bool\n-\tscts                [][]byte\n-\tticketSupported     bool\n-\tsecureRenegotiation bool\n-\talpnProtocol        string\n+\traw                          []byte\n+\tvers                         uint16\n+\trandom                       []byte\n+\tsessionId                    []byte\n+\tcipherSuite                  uint16\n+\tcompressionMethod            uint8\n+\tnextProtoNeg                 bool\n+\tnextProtos                   []string\n+\tocspStapling                 bool\n+\tscts                         [][]byte\n+\tticketSupported              bool\n+\tsecureRenegotiation          []byte\n+\tsecureRenegotiationSupported bool\n+\talpnProtocol                 string\n }\n \n func (m *serverHelloMsg) equal(i interface{}) bool {\n@@ -523,7 +537,8 @@ func (m *serverHelloMsg) equal(i interface{}) bool {\n \t\teqStrings(m.nextProtos, m1.nextProtos) &&\n \t\tm.ocspStapling == m1.ocspStapling &&\n \t\tm.ticketSupported == m1.ticketSupported &&\n-\t\tm.secureRenegotiation == m1.secureRenegotiation &&\n+\t\tm.secureRenegotiationSupported == m1.secureRenegotiationSupported &&\n+\t\tbytes.Equal(m.secureRenegotiation, m1.secureRenegotiation) &&\n \t\tm.alpnProtocol == m1.alpnProtocol\n }\n \n@@ -551,8 +566,8 @@ func (m *serverHelloMsg) marshal() []byte {\n \tif m.ticketSupported {\n \t\tnumExtensions++\n \t}\n-\tif m.secureRenegotiation {\n-\t\textensionsLength += 1\n+\tif m.secureRenegotiationSupported {\n+\t\textensionsLength += 1 + len(m.secureRenegotiation)\n \t\tnumExtensions++\n \t}\n \tif alpnLen := len(m.alpnProtocol); alpnLen > 0 {\n@@ -589,7 +604,7 @@ func (m *serverHelloMsg) marshal() []byte {\n \tz := x[39+len(m.sessionId):]\n \tz[0] = uint8(m.cipherSuite >> 8)\n \tz[1] = uint8(m.cipherSuite)\n-\tz[2] = uint8(m.compressionMethod)\n+\tz[2] = m.compressionMethod\n \n \tz = z[3:]\n \tif numExtensions > 0 {\n@@ -624,12 +639,15 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\tz[1] = byte(extensionSessionTicket)\n \t\tz = z[4:]\n \t}\n-\tif m.secureRenegotiation {\n+\tif m.secureRenegotiationSupported {\n \t\tz[0] = byte(extensionRenegotiationInfo >> 8)\n \t\tz[1] = byte(extensionRenegotiationInfo & 0xff)\n \t\tz[2] = 0\n-\t\tz[3] = 1\n+\t\tz[3] = byte(len(m.secureRenegotiation) + 1)\n+\t\tz[4] = byte(len(m.secureRenegotiation))\n \t\tz = z[5:]\n+\t\tcopy(z, m.secureRenegotiation)\n+\t\tz = z[len(m.secureRenegotiation):]\n \t}\n \tif alpnLen := len(m.alpnProtocol); alpnLen > 0 {\n \t\tz[0] = byte(extensionALPN >> 8)\n@@ -744,10 +762,18 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\t\t}\n \t\t\tm.ticketSupported = true\n \t\tcase extensionRenegotiationInfo:\n-\t\t\tif length != 1 || data[0] != 0 {\n+\t\t\tif length == 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\td := data[:length]\n+\t\t\tl := int(d[0])\n+\t\t\td = d[1:]\n+\t\t\tif l != len(d) {\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tm.secureRenegotiation = true\n+\n+\t\t\tm.secureRenegotiation = d\n+\t\t\tm.secureRenegotiationSupported = true\n \t\tcase extensionALPN:\n \t\t\td := data[:length]\n \t\t\tif len(d) < 3 {\n@@ -1316,11 +1342,8 @@ func (m *certificateRequestMsg) unmarshal(data []byte) bool {\n \t\tm.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])\n \t\tcas = cas[caLen:]\n \t}\n-\tif len(data) > 0 {\n-\t\treturn false\n-\t}\n \n-\treturn true\n+\treturn len(data) == 0\n }\n \n type certificateVerifyMsg struct {\n@@ -1466,6 +1489,17 @@ func (m *newSessionTicketMsg) unmarshal(data []byte) bool {\n \treturn true\n }\n \n+type helloRequestMsg struct {\n+}\n+\n+func (*helloRequestMsg) marshal() []byte {\n+\treturn []byte{typeHelloRequest, 0, 0, 0}\n+}\n+\n+func (*helloRequestMsg) unmarshal(data []byte) bool {\n+\treturn len(data) == 4\n+}\n+\n func eqUint16s(x, y []uint16) bool {\n \tif len(x) != len(y) {\n \t\treturn false"}, {"sha": "1aac72956142d689c64e7fe661d4fbf42e9d67d0", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128", "patch": "@@ -35,6 +35,7 @@ type serverHandshakeState struct {\n }\n \n // serverHandshake performs a TLS handshake as a server.\n+// c.out.Mutex <= L; c.handshakeMutex <= L.\n func (c *Conn) serverHandshake() error {\n \tconfig := c.config\n \n@@ -51,6 +52,7 @@ func (c *Conn) serverHandshake() error {\n \t}\n \n \t// For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3\n+\tc.buffering = true\n \tif isResume {\n \t\t// The client has included a session ticket and so we do an abbreviated handshake.\n \t\tif err := hs.doResumeHandshake(); err != nil {\n@@ -67,9 +69,13 @@ func (c *Conn) serverHandshake() error {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n-\t\tif err := hs.sendFinished(c.firstFinished[:]); err != nil {\n+\t\tif err := hs.sendFinished(c.serverFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif _, err := c.flush(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tc.clientFinishedIsFirst = false\n \t\tif err := hs.readFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -83,15 +89,20 @@ func (c *Conn) serverHandshake() error {\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(c.firstFinished[:]); err != nil {\n+\t\tif err := hs.readFinished(c.clientFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tc.clientFinishedIsFirst = true\n+\t\tc.buffering = true\n \t\tif err := hs.sendSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif err := hs.sendFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif _, err := c.flush(); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \tc.handshakeComplete = true\n \n@@ -165,7 +176,13 @@ Curves:\n \t\tc.sendAlert(alertInternalError)\n \t\treturn false, err\n \t}\n-\ths.hello.secureRenegotiation = hs.clientHello.secureRenegotiation\n+\n+\tif len(hs.clientHello.secureRenegotiation) != 0 {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn false, errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n+\t}\n+\n+\ths.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported\n \ths.hello.compressionMethod = compressionNone\n \tif len(hs.clientHello.serverName) > 0 {\n \t\tc.serverName = hs.clientHello.serverName\n@@ -187,12 +204,13 @@ Curves:\n \t\t}\n \t}\n \n-\tif hs.cert, err = config.getCertificate(&ClientHelloInfo{\n+\ths.cert, err = config.getCertificate(&ClientHelloInfo{\n \t\tCipherSuites:    hs.clientHello.cipherSuites,\n \t\tServerName:      hs.clientHello.serverName,\n \t\tSupportedCurves: hs.clientHello.supportedCurves,\n \t\tSupportedPoints: hs.clientHello.supportedPoints,\n-\t}); err != nil {\n+\t})\n+\tif err != nil {\n \t\tc.sendAlert(alertInternalError)\n \t\treturn false, err\n \t}\n@@ -208,7 +226,7 @@ Curves:\n \t\t\ths.rsaSignOk = true\n \t\tdefault:\n \t\t\tc.sendAlert(alertInternalError)\n-\t\t\treturn false, fmt.Errorf(\"crypto/tls: unsupported signing key type (%T)\", priv.Public())\n+\t\t\treturn false, fmt.Errorf(\"tls: unsupported signing key type (%T)\", priv.Public())\n \t\t}\n \t}\n \tif priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {\n@@ -217,7 +235,7 @@ Curves:\n \t\t\ths.rsaDecryptOk = true\n \t\tdefault:\n \t\t\tc.sendAlert(alertInternalError)\n-\t\t\treturn false, fmt.Errorf(\"crypto/tls: unsupported decryption key type (%T)\", priv.Public())\n+\t\t\treturn false, fmt.Errorf(\"tls: unsupported decryption key type (%T)\", priv.Public())\n \t\t}\n \t}\n \n@@ -245,7 +263,7 @@ Curves:\n \t\treturn false, errors.New(\"tls: no cipher suite supported by both client and server\")\n \t}\n \n-\t// See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.\n+\t// See https://tools.ietf.org/html/rfc7507.\n \tfor _, id := range hs.clientHello.cipherSuites {\n \t\tif id == TLS_FALLBACK_SCSV {\n \t\t\t// The client is doing a fallback connection.\n@@ -274,10 +292,8 @@ func (hs *serverHandshakeState) checkForResumption() bool {\n \t\treturn false\n \t}\n \n-\tif hs.sessionState.vers > hs.clientHello.vers {\n-\t\treturn false\n-\t}\n-\tif vers, ok := c.config.mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers {\n+\t// Never resume a session for a different TLS version.\n+\tif c.vers != hs.sessionState.vers {\n \t\treturn false\n \t}\n \n@@ -322,7 +338,9 @@ func (hs *serverHandshakeState) doResumeHandshake() error {\n \ths.finishedHash.discardHandshakeBuffer()\n \ths.finishedHash.Write(hs.clientHello.marshal())\n \ths.finishedHash.Write(hs.hello.marshal())\n-\tc.writeRecord(recordTypeHandshake, hs.hello.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \tif len(hs.sessionState.certificates) > 0 {\n \t\tif _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil {\n@@ -354,19 +372,25 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t}\n \ths.finishedHash.Write(hs.clientHello.marshal())\n \ths.finishedHash.Write(hs.hello.marshal())\n-\tc.writeRecord(recordTypeHandshake, hs.hello.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \tcertMsg := new(certificateMsg)\n \tcertMsg.certificates = hs.cert.Certificate\n \ths.finishedHash.Write(certMsg.marshal())\n-\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \tif hs.hello.ocspStapling {\n \t\tcertStatus := new(certificateStatusMsg)\n \t\tcertStatus.statusType = statusTypeOCSP\n \t\tcertStatus.response = hs.cert.OCSPStaple\n \t\ths.finishedHash.Write(certStatus.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, certStatus.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, certStatus.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \tkeyAgreement := hs.suite.ka(c.vers)\n@@ -377,7 +401,9 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t}\n \tif skx != nil {\n \t\ths.finishedHash.Write(skx.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, skx.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, skx.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \tif config.ClientAuth >= RequestClientCert {\n@@ -401,12 +427,20 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\t\tcertReq.certificateAuthorities = config.ClientCAs.Subjects()\n \t\t}\n \t\ths.finishedHash.Write(certReq.marshal())\n-\t\tc.writeRecord(recordTypeHandshake, certReq.marshal())\n+\t\tif _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \thelloDone := new(serverHelloDoneMsg)\n \ths.finishedHash.Write(helloDone.marshal())\n-\tc.writeRecord(recordTypeHandshake, helloDone.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, helloDone.marshal()); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif _, err := c.flush(); err != nil {\n+\t\treturn err\n+\t}\n \n \tvar pub crypto.PublicKey // public key for client auth, if any\n \n@@ -462,7 +496,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \n \t// If we received a client cert in response to our certificate request message,\n \t// the client will send us a certificateVerifyMsg immediately after the\n-\t// clientKeyExchangeMsg.  This message is a digest of all preceding\n+\t// clientKeyExchangeMsg. This message is a digest of all preceding\n \t// handshake-layer messages that is signed using the private key corresponding\n \t// to the client's certificate. This allows us to verify that the client is in\n \t// possession of the private key of the certificate.\n@@ -499,27 +533,27 @@ func (hs *serverHandshakeState) doFullHandshake() error {\n \t\tswitch key := pub.(type) {\n \t\tcase *ecdsa.PublicKey:\n \t\t\tif signatureAndHash.signature != signatureECDSA {\n-\t\t\t\terr = errors.New(\"bad signature type for client's ECDSA certificate\")\n+\t\t\t\terr = errors.New(\"tls: bad signature type for client's ECDSA certificate\")\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tecdsaSig := new(ecdsaSignature)\n \t\t\tif _, err = asn1.Unmarshal(certVerify.signature, ecdsaSig); err != nil {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {\n-\t\t\t\terr = errors.New(\"ECDSA signature contained zero or negative values\")\n+\t\t\t\terr = errors.New(\"tls: ECDSA signature contained zero or negative values\")\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tvar digest []byte\n \t\t\tif digest, _, err = hs.finishedHash.hashForClientCertificate(signatureAndHash, hs.masterSecret); err != nil {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif !ecdsa.Verify(key, digest, ecdsaSig.R, ecdsaSig.S) {\n-\t\t\t\terr = errors.New(\"ECDSA verification failure\")\n+\t\t\t\terr = errors.New(\"tls: ECDSA verification failure\")\n \t\t\t}\n \t\tcase *rsa.PublicKey:\n \t\t\tif signatureAndHash.signature != signatureRSA {\n-\t\t\t\terr = errors.New(\"bad signature type for client's RSA certificate\")\n+\t\t\t\terr = errors.New(\"tls: bad signature type for client's RSA certificate\")\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tvar digest []byte\n@@ -571,8 +605,8 @@ func (hs *serverHandshakeState) readFinished(out []byte) error {\n \tc := hs.c\n \n \tc.readRecord(recordTypeChangeCipherSpec)\n-\tif err := c.in.error(); err != nil {\n-\t\treturn err\n+\tif c.in.err != nil {\n+\t\treturn c.in.err\n \t}\n \n \tif hs.hello.nextProtoNeg {\n@@ -632,20 +666,26 @@ func (hs *serverHandshakeState) sendSessionTicket() error {\n \t}\n \n \ths.finishedHash.Write(m.marshal())\n-\tc.writeRecord(recordTypeHandshake, m.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \treturn nil\n }\n \n func (hs *serverHandshakeState) sendFinished(out []byte) error {\n \tc := hs.c\n \n-\tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n+\tif _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil {\n+\t\treturn err\n+\t}\n \n \tfinished := new(finishedMsg)\n \tfinished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)\n \ths.finishedHash.Write(finished.marshal())\n-\tc.writeRecord(recordTypeHandshake, finished.marshal())\n+\tif _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {\n+\t\treturn err\n+\t}\n \n \tc.cipherSuite = hs.suite.id\n \tcopy(out, finished.verifyData)\n@@ -690,20 +730,20 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (c\n \t\tc.verifiedChains = chains\n \t}\n \n-\tif len(certs) > 0 {\n-\t\tvar pub crypto.PublicKey\n-\t\tswitch key := certs[0].PublicKey.(type) {\n-\t\tcase *ecdsa.PublicKey, *rsa.PublicKey:\n-\t\t\tpub = key\n-\t\tdefault:\n-\t\t\tc.sendAlert(alertUnsupportedCertificate)\n-\t\t\treturn nil, fmt.Errorf(\"tls: client's certificate contains an unsupported public key of type %T\", certs[0].PublicKey)\n-\t\t}\n-\t\tc.peerCertificates = certs\n-\t\treturn pub, nil\n+\tif len(certs) == 0 {\n+\t\treturn nil, nil\n \t}\n \n-\treturn nil, nil\n+\tvar pub crypto.PublicKey\n+\tswitch key := certs[0].PublicKey.(type) {\n+\tcase *ecdsa.PublicKey, *rsa.PublicKey:\n+\t\tpub = key\n+\tdefault:\n+\t\tc.sendAlert(alertUnsupportedCertificate)\n+\t\treturn nil, fmt.Errorf(\"tls: client's certificate contains an unsupported public key of type %T\", certs[0].PublicKey)\n+\t}\n+\tc.peerCertificates = certs\n+\treturn pub, nil\n }\n \n // setCipherSuite sets a cipherSuite with the given id as the serverHandshakeState"}, {"sha": "9ae5d11fc18fdef48d1387dd04c4db3f64533c26", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "467efb2bf5c261f2e8c583dd2411328ce5d54af6", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "5833fc19631e4e38f0ac5c9fbf7c4afc10df72e1", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "00d35f4290590584eb358af63236539559e69a7a", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateOnce", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateOnce?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "185dc6528c9337f133967eaefa07c4d601993f2f", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateTwice", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwice?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "fe2fa88a90e230e487eb7ace319162c66be2f6ec", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiateTwiceRejected", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiateTwiceRejected?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "90adc18fe928c45b1dd78491ac365df6b478e0db", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RenegotiationRejected", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RenegotiationRejected?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "3e7aa93c82a7f1eb0605b02967ad1eda22fa926d", "filename": "libgo/go/crypto/tls/ticket.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "8eef884a0f10eaeb4c18d69eb392c65a071350f6", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "48b46a003a63051a7d5b6071cdc2c2c3de646338", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 240, "deletions": 17, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "59ab8871054aef95e176c376409989b625ad7883", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "0388d63e1495396ca41c1985ce350b74e08bb622", "filename": "libgo/go/crypto/x509/pem_decrypt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "df20a4420498e458e080d08c3e491c86e5b828e1", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "b304a3f63c93dc2ff3d351d28321cdffcc28b8ee", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "faad4061fc71347f1459fa1ea665f0159e4af622", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "787d955be47db2e80be9416c20ea2c6613499f81", "filename": "libgo/go/crypto/x509/root.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "0e2fb357ee904034b46e96f8f06094bce2fad5b6", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "fc2488adc6fa56f25384c9da7021a0728af04679", "filename": "libgo/go/crypto/x509/root_darwin_arm_gen.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ad1c53d8a4262eae949ffa95cbbbee6cb1587b06", "filename": "libgo/go/crypto/x509/root_darwin_armx.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "2ac4666aff65b6c010fe94caefa2b485f8240f17", "filename": "libgo/go/crypto/x509/root_nocgo_darwin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nocgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nocgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nocgo_darwin.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ebeb7dfccd86c068c4b42bb6b7f84b58ca010637", "filename": "libgo/go/crypto/x509/root_plan9.go", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_plan9.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "7bcb3d63d1f935e2a9897dac62b5d4a10b3cab8b", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "392c869012d8fc2f5d4b6ef730b49043b828984d", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "33f376c072cf577d59b69b46a2782a176c939e25", "filename": "libgo/go/crypto/x509/sec1.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "85c083fbb2c9c40481c48cb84936cb2c1bf8d4de", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "bacf7ded29f532d1daba76e2a0c8f20710e9cde6", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "9ad3cf23f655a9c3ee25665162cc7f951e1e65c9", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "c6448d39ab53efbbf757727d2a21c25cf0331ebb", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 60, "deletions": 47, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "99aed2398e28b099dae92b78589db468549135ac", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ab81f2f65a27bc7bd87d03bb32a1f2a765174349", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "4dba85a6d343148912d00f12456117a37c8d38ea", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "e480e701a49e7c5357f59d1110169bf18cba8e0b", "filename": "libgo/go/database/sql/driver/types.go", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "5b238bfc5cbcff7510a1fb6bb9fa39310e35c6e9", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "09de1c34e826bdb7468dcd26c5d0393e3864f299", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "08df0c7666a357ae173a5d3b5918d3bcb1c9862a", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "24d266db10738be0b2a6e9ae6277a381042ab9c2", "filename": "libgo/go/debug/dwarf/buf.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "04d8c506b063cd5507c40613591d1436fca1df3a", "filename": "libgo/go/debug/dwarf/const.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "80bf14cb22fd6ec6c23ce8192123dae64e40ed9e", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 126, "deletions": 6, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "58a5d570be56da0a62b14ae5ef0e89ffcd7e59e3", "filename": "libgo/go/debug/dwarf/entry_test.go", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry_test.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}, {"sha": "ed82feef92b08137dae5f66a9ae8930206ea7992", "filename": "libgo/go/debug/dwarf/line.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22b955cca564a9a3a5b8c9d9dd1e295b7943c128/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go?ref=22b955cca564a9a3a5b8c9d9dd1e295b7943c128"}]}