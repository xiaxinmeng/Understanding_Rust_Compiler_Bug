{"sha": "7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY4MmU3YmMyZWIwYTdhMmE4MzlmYWJkN2M5ZmExMDNjMTE3Yjg3Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-04T22:05:19Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-04T22:05:19Z"}, "message": "tradcif.y: Move lexptr to top of file.\n\n        * tradcif.y: Move lexptr to top of file.  Add rule to handle\n        assertions in conditional expressions.\n        * tradcpp.c (parse_answer): Assertions do not need to go to\n        end of line in conditional directives.\n        (parse_assertion): Get first character of identifiers correct.\n        (test_assertion): New function.\n        * tradcpp.h (test_assertion): New prototype.\n\nFrom-SVN: r38011", "tree": {"sha": "bc7b3cf21ebfc2cd79f75c6f070954666bce9eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc7b3cf21ebfc2cd79f75c6f070954666bce9eef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/comments", "author": null, "committer": null, "parents": [{"sha": "23a535c4fff08a3224a41a118f1114d53256431b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a535c4fff08a3224a41a118f1114d53256431b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a535c4fff08a3224a41a118f1114d53256431b"}], "stats": {"total": 73, "additions": 65, "deletions": 8}, "files": [{"sha": "1941372aa1e0becd55b43503c4a33a079a8e6b8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "patch": "@@ -1,3 +1,13 @@\n+2000-12-04  Neil Booth  <neilb@earthling.net>\n+\n+        * tradcif.y: Move lexptr to top of file.  Add rule to handle\n+        assertions in conditional expressions.\n+        * tradcpp.c (parse_answer): Assertions do not need to go to\n+        end of line in conditional directives.\n+        (parse_assertion): Get first character of identifiers correct.\n+        (test_assertion): New function.\n+        * tradcpp.h (test_assertion): New prototype.\n+\n 2000-12-01  Rodney Brown  <RodneyBrown@mynd.com>\n \n \t* config.gcc: Fix typo for UnixWare 7."}, {"sha": "19e8b51598c8b8d5b2c01165d240deee69e8c47c", "filename": "gcc/tradcif.y", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcif.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcif.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.y?ref=7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "patch": "@@ -36,6 +36,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n   static int expression_value;\n   static jmp_buf parse_return_error;\n+\n+  /* During parsing of a C expression, the pointer to the next\n+     character is in this variable.  */\n+\n+  static const char *lexptr;\n %}\n \n %union {\n@@ -199,14 +204,11 @@ exp\t:\texp '*' exp\n \t|\tNAME\n \t\t\t{ $$.value = 0;\n \t\t\t  $$.unsignedp = 0; }\n+\t|\t'#'\t{ $$.value =\n+\t\t\t    test_assertion ((unsigned char **) &lexptr); }\n \t;\n %%\n \f\n-/* During parsing of a C expression, the pointer to the next character\n-   is in this variable.  */\n-\n-static const char *lexptr;\n-\n /* Take care of parsing a number (anything that starts with a digit).\n    Set yylval and return the token type; update lexptr.\n    LEN is the number of characters in it.  */\n@@ -389,6 +391,7 @@ yylex ()\n   case '{':\n   case '}':\n   case ',':\n+  case '#':\n     lexptr++;\n     return c;\n     "}, {"sha": "5db2a84086ea96c147fd517785962cfea341d007", "filename": "gcc/tradcpp.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "patch": "@@ -3057,11 +3057,14 @@ parse_answer (buf, limit, answerp, type)\n     buf++;\n \n   /* Parentheses are optional here.  */\n-  if (buf == limit && (type == T_IF || type == T_UNASSERT))\n+  if (buf == limit && type == T_UNASSERT)\n     return 0;\n \n   if (buf == limit || *buf++ != '(')\n     {\n+      if (type == T_IF)\n+\treturn 0;\n+\n       error (\"missing '(' after predicate\");\n       return 1;\n     }\n@@ -3118,8 +3121,12 @@ parse_assertion (buf, limit, answerp, type)\n   unsigned int len;\n \n   bp = symname;\n-  while (bp < climit && is_idchar[*bp])\n-    bp++;\n+  if (bp < climit && is_idstart[*bp])\n+    {\n+      do\n+\tbp++;\n+      while (bp < climit && is_idchar[*bp]);\n+    }\n   len = bp - symname;\n \n   *answerp = 0;\n@@ -3130,6 +3137,8 @@ parse_assertion (buf, limit, answerp, type)\n       else\n \terror (\"predicate must be an identifier\");\n     }\n+  /* Unfortunately, because of the way we handle #if, we don't avoid\n+     macro expansion in answers.  This is not easy to fix.  */\n   else if (parse_answer (bp, climit, answerp, type) == 0)\n     {\n       unsigned char *sym = alloca (len + 1);\n@@ -3148,6 +3157,40 @@ parse_assertion (buf, limit, answerp, type)\n   return result;\n }\n \n+/* Test an assertion within a preprocessor conditional.  Returns zero\n+   on error or failure, one on success.  */\n+int\n+test_assertion (pbuf)\n+     unsigned char **pbuf;\t/* NUL-terminated.  */\n+{\n+  unsigned char *buf = *pbuf;\n+  unsigned char *limit = buf + strlen ((char *) buf);\n+  struct answer *answer;\n+  HASHNODE *node;\n+  int result = 0;\n+\n+  node = parse_assertion (buf, limit, &answer, T_IF);\n+  if (node)\n+    {\n+      result = (node->type == T_ASSERT &&\n+\t\t(answer == 0 || *find_answer (node, answer) != 0));\n+\n+      /* Yuk.  We update pbuf to point after the assertion test.\n+\t First, move past the identifier.  */\n+      if (is_space[*buf])\n+\tbuf++;\n+      while (is_idchar[*buf])\n+\tbuf++;\n+      /* If we have an answer, we need to move past the parentheses.  */\n+      if (answer)\n+\twhile (*buf++ != ')')\n+\t  ;\n+      *pbuf = buf;\n+    }\n+\n+  return result;\n+}\n+\n /* Handle a #assert directive.  */\n static void\n do_assert (buf, limit, op)"}, {"sha": "b646939528e76a3ff05eddf02fc80e31aaf88210", "filename": "gcc/tradcpp.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7682e7bc2eb0a7a2a839fabd7c9fa103c117b876/gcc%2Ftradcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.h?ref=7682e7bc2eb0a7a2a839fabd7c9fa103c117b876", "patch": "@@ -34,6 +34,7 @@ extern void fancy_abort PARAMS ((int, const char *)) ATTRIBUTE_NORETURN;\n \n extern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\n extern int parse_c_expression PARAMS ((const char *));  /* in tradcif.y */\n+extern int test_assertion PARAMS ((unsigned char **));\n \n /* some external tables of character types */\n extern unsigned char is_idstart[], is_idchar[];"}]}