{"sha": "6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjMWVlNThjNjE3ZjkzNjE3ZWNlZWU0YTQ4YjdkYmM3Y2RkOWM4ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-05-30T16:43:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-05-30T16:43:59Z"}, "message": "* doc/invoke.texi (-flinker-output): Document\n\nFrom-SVN: r260965", "tree": {"sha": "d9bebfb7d6b2fcb93905ed591ccb292881f99882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9bebfb7d6b2fcb93905ed591ccb292881f99882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e/comments", "author": null, "committer": null, "parents": [{"sha": "2a58bcf2da472661cb75fcab1a5e7fa39f44dca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a58bcf2da472661cb75fcab1a5e7fa39f44dca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a58bcf2da472661cb75fcab1a5e7fa39f44dca2"}], "stats": {"total": 48, "additions": 48, "deletions": 0}, "files": [{"sha": "12f15ea9464f45826d4b1ba8e042f720188f8e7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "patch": "@@ -1,3 +1,7 @@\n+2018-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* doc/invoke.texi (-flinker-output): Document\n+\n 2018-05-30  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* passes.c (ipa_write_summaries): Only modify statements if body"}, {"sha": "f2c95248bb7798d6ddf62b8a6f517727a69904db", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6dc1ee58c617f93617eceee4a48b7dbc7cdd9c8e", "patch": "@@ -12294,6 +12294,50 @@ If any of these options is used, then the linker is not run, and\n object file names should not be used as arguments.  @xref{Overall\n Options}.\n \n+@item -flinker-output=@var{type}\n+@opindex -flinker-output\n+This option controls the code generation of the link time optimizer.  By\n+default the linker output is determined by the linker plugin automatically. For\n+debugging the compiler and in the case of incremental linking to non-lto object\n+file is desired, it may be useful to control the type manually.\n+\n+If @var{type} is @samp{exec} the code generation is configured to produce static\n+binary. In this case @option{-fpic} and @option{-fpie} are both disabled.\n+\n+If @var{type} is @samp{dyn} the code generation is configured to produce shared\n+library. In this case @option{-fpic} or @option{-fPIC} is preserved, but not\n+enabled automatically.  This makes it possible to build shared libraries without\n+position independent code on architectures this is possible, i.e. on x86.\n+\n+If @var{type} is @samp{pie} the code generation is configured to produce\n+@option{-fpie} executable. This result in similar optimizations as @samp{exec}\n+except that @option{-fpie} is not disabled if specified at compilation time.\n+\n+If @var{type} is @samp{rel} the compiler assumes that incremental linking is\n+done.  The sections containing intermediate code for link-time optimization are\n+merged, pre-optimized, and output to the resulting object file. In addition, if\n+@option{-ffat-lto-objects} is specified the binary code is produced for future\n+non-lto linking. The object file produced by incremental linking will be smaller\n+than a static library produced from the same object files.  At link-time the\n+result of incremental linking will also load faster to compiler than a static\n+library assuming that majority of objects in the library are used.\n+\n+Finally @samp{nolto-rel} configure compiler to for incremental linking where\n+code generation is forced, final binary is produced and the intermediate code\n+for later link-time optimization is stripped. When multiple object files are\n+linked together the resulting code will be optimized better than with link time\n+optimizations disabled (for example, the cross-module inlining will happen),\n+most of benefits of whole program optimizations are however lost. \n+\n+During the incremental link (by @option{-r}) the linker plugin will default to\n+@option{rel}. With current interfaces to GNU Binutils it is however not\n+possible to link incrementally LTO objects and non-LTO objects into a single\n+mixed object file.  In the case any of object files in incremental link can not\n+be used for link-time optimization the linker plugin will output warning and\n+use @samp{nolto-rel}. To maintain the whole program optimization it is\n+recommended to link such objects into static library instead. Alternatively it\n+is possible to use H.J. Lu's binutils with support for mixed objects.\n+\n @item -fuse-ld=bfd\n @opindex fuse-ld=bfd\n Use the @command{bfd} linker instead of the default linker."}]}