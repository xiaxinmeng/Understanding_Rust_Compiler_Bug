{"sha": "defb583203923bf4edeb0531e85fa28de5015ecb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVmYjU4MzIwMzkyM2JmNGVkZWIwNTMxZTg1ZmEyOGRlNTAxNWVjYg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-05T16:49:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-07-10T20:36:09Z"}, "message": "Add support for TypeAliases on Traits\n\nThis is the initial support for associated types, by creating placeholder\ntypes for each trait type alias.\n\nWhen it comes to checking for compatibility we are missing the piece to\nensure that the type is defintly the same as the associated type.\n\nAddresses #471 #456", "tree": {"sha": "7ab54899ba077da5d417b43520d12039fcbc5127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab54899ba077da5d417b43520d12039fcbc5127"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/defb583203923bf4edeb0531e85fa28de5015ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defb583203923bf4edeb0531e85fa28de5015ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defb583203923bf4edeb0531e85fa28de5015ecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defb583203923bf4edeb0531e85fa28de5015ecb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ebf5d62d208f52d8b63824165ae830c190d91b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ebf5d62d208f52d8b63824165ae830c190d91b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ebf5d62d208f52d8b63824165ae830c190d91b5"}], "stats": {"total": 497, "additions": 378, "deletions": 119}, "files": [{"sha": "1f1ff300476f0f02724f4fca4d65e99565bb6820", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 224, "deletions": 117, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=defb583203923bf4edeb0531e85fa28de5015ecb", "patch": "@@ -28,11 +28,168 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolveItem : public ResolverBase\n+class ResolveTraitItems : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n+  static void go (AST::TraitItem *item, const CanonicalPath &self)\n+  {\n+    ResolveTraitItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    // insert Self::type_alias for TypePath lookup\n+    auto path\n+      = self.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    resolver->get_type_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // FIXME this stops the erronious unused decls which will be fixed later on\n+    resolver->get_type_scope ().append_reference_for_def (type.get_node_id (),\n+\t\t\t\t\t\t\t  type.get_node_id ());\n+\n+    // TODO resolve the type-bounds\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemMethod &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // self turns into (self: Self) as a function param\n+    AST::SelfParam &self_param = function.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+\n+    // the mutability checker needs to verify for immutable decls the number\n+    // of assignments are <1. This marks an implicit assignment\n+    resolver->mark_decl_mutability (constant.get_node_id (), false);\n+    resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t       constant.get_node_id ());\n+  }\n+\n+private:\n+  ResolveTraitItems (const CanonicalPath &self)\n+    : ResolverBase (UNKNOWN_NODEID), self (self)\n+  {}\n+\n+  const CanonicalPath &self;\n+};\n+\n+class ResolveItem : public ResolverBase\n+{\n+public:\n+  using Rust::Resolver::ResolverBase::visit;\n+\n   static void go (AST::Item *item)\n   {\n     ResolveItem resolver;\n@@ -169,7 +326,10 @@ class ResolveItem : public ResolverBase\n   void visit (AST::InherentImpl &impl_block) override\n   {\n     NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     if (impl_block.has_generics ())\n       {\n@@ -186,6 +346,7 @@ class ResolveItem : public ResolverBase\n     if (resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n@@ -197,11 +358,15 @@ class ResolveItem : public ResolverBase\n       impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      impl_item->accept_vis (*this);\n+      {\n+\tresolve_impl_item (impl_item.get (), Self);\n+      }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n       Self, impl_block.get_type ()->get_node_id ());\n+\n     resolver->get_type_scope ().pop ();\n+    resolver->get_name_scope ().pop ();\n   }\n \n   void visit (AST::Method &method) override\n@@ -268,7 +433,10 @@ class ResolveItem : public ResolverBase\n   void visit (AST::TraitImpl &impl_block) override\n   {\n     NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     if (impl_block.has_generics ())\n       {\n@@ -286,6 +454,7 @@ class ResolveItem : public ResolverBase\n     if (trait_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n@@ -296,6 +465,7 @@ class ResolveItem : public ResolverBase\n     if (type_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n+\tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n@@ -307,7 +477,9 @@ class ResolveItem : public ResolverBase\n       impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      impl_item->accept_vis (*this);\n+      {\n+\tresolve_impl_item (impl_item.get (), Self);\n+      }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n       Self, impl_block.get_type ()->get_node_id ());\n@@ -317,150 +489,85 @@ class ResolveItem : public ResolverBase\n   void visit (AST::Trait &trait) override\n   {\n     NodeId scope_node_id = trait.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n     // we need to inject an implicit self TypeParam here\n     AST::TypeParam *implicit_self\n       = new AST::TypeParam (\"Self\", trait.get_locus ());\n     trait.insert_implict_self (\n       std::unique_ptr<AST::GenericParam> (implicit_self));\n+    CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n \n     for (auto &generic : trait.get_generic_params ())\n       {\n \tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n       }\n \n-    for (auto &item : trait.get_trait_items ())\n-      item->accept_vis (*this);\n+    // Self is an implicit TypeParam so lets mark it as such\n+    resolver->get_type_scope ().append_reference_for_def (\n+      Self.get_id (), implicit_self->get_node_id ());\n \n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemFunc &func) override\n-  {\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n+    for (auto &item : trait.get_trait_items ())\n       {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tResolveTraitItems::go (item.get (), Self);\n       }\n \n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n-\n-    resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n+    resolver->get_name_scope ().pop ();\n   }\n \n-  void visit (AST::TraitItemMethod &func) override\n-  {\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = function.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n-\n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+protected:\n+  void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &self);\n+  void resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t  const CanonicalPath &self);\n \n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n-      }\n-\n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n \n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n+class ResolveImplItems : public ResolveItem\n+{\n+  using Rust::Resolver::ResolveItem::visit;\n \n-  void visit (AST::TraitItemConst &constant) override\n+public:\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &self)\n   {\n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+    ResolveImplItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n \n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n-  }\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &self)\n+  {\n+    ResolveImplItems resolver (self);\n+    item->accept_vis (resolver);\n+  };\n \n-  void visit (AST::TraitItemType &alias) override\n+  void visit (AST::TypeAlias &alias) override\n   {\n-    // nothing to do here until we start supporting Type Bounds\n+    ResolveItem::visit (alias);\n+\n+    auto path\n+      = self.append (CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t     alias.get_new_type_name ()));\n+    resolver->get_type_scope ().insert (\n+      path, alias.get_node_id (), alias.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (alias.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // FIXME this stops the erronious unused decls which will be fixed later on\n+    resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n+\t\t\t\t\t\t\t  alias.get_node_id ());\n   }\n \n private:\n-  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveImplItems (const CanonicalPath &self) : ResolveItem (), self (self) {}\n+\n+  const CanonicalPath &self;\n };\n \n } // namespace Resolver"}, {"sha": "18047db89180f4ef2556880a1e891cd46424ebb5", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=defb583203923bf4edeb0531e85fa28de5015ecb", "patch": "@@ -619,5 +619,21 @@ ResolveType::visit (AST::ArrayType &type)\n   ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n }\n \n+// rust-ast-resolve-item.h\n+\n+void\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &self)\n+{\n+  ResolveImplItems::go (item, self);\n+}\n+\n+void\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &self)\n+{\n+  ResolveImplItems::go (item, self);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "b0264e504577bad0753b6628cc049b0cb4dc13d2", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=defb583203923bf4edeb0531e85fa28de5015ecb", "patch": "@@ -41,6 +41,14 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    TyTy::BaseType *actual_type\n+      = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+    context->insert_type (alias.get_mappings (), actual_type);\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n@@ -204,9 +212,85 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     return resolver.resolved_trait_item;\n   }\n \n-  void visit (HIR::ConstantItem &constant) override { gcc_unreachable (); }\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    TypeCheckImplItem::visit (constant);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\tconstant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n \n-  void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n+\t\t       constant.get_identifier ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    // check the types are compatible\n+    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+      {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  constant.get_identifier ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n+\n+  void visit (HIR::TypeAlias &type) override\n+  {\n+    TypeCheckImplItem::visit (type);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\ttype.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n+\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n+\t\t       type.get_new_type_name ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    // check the types are compatible\n+    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+      {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  type.get_new_type_name ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n \n   void visit (HIR::Function &function) override\n   {"}, {"sha": "1db5f32fed38fce9d1b8f557abf546dbe9783ca1", "filename": "gcc/testsuite/rust/compile/torture/traits4.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs?ref=defb583203923bf4edeb0531e85fa28de5015ecb", "patch": "@@ -0,0 +1,26 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    type B;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn new(a: Self::A, b: Self::B) -> Self;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .b.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Foo::new.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Baz(i32, f32);\n+\n+impl Foo for Baz {\n+    type A = i32;\n+    type B = f32;\n+\n+    fn new(a: Self::A, b: Self::B) -> Self {\n+        Baz(a, b)\n+    }\n+}\n+\n+fn main() {\n+    Baz::new(123, 456f32);\n+}"}, {"sha": "87c02831f134c7533feffa3d6259f9672516eb5f", "filename": "gcc/testsuite/rust/compile/torture/traits5.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb583203923bf4edeb0531e85fa28de5015ecb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs?ref=defb583203923bf4edeb0531e85fa28de5015ecb", "patch": "@@ -0,0 +1,26 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    type B;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn new(a: Self::A, b: Self::B) -> Self;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .b.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Foo::new.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Baz(i32, f32);\n+\n+impl Foo for Baz {\n+    type A = i32;\n+    type B = f32;\n+\n+    fn new(a: i32, b: f32) -> Self {\n+        Baz(a, b)\n+    }\n+}\n+\n+fn main() {\n+    Baz::new(123, 456f32);\n+}"}]}