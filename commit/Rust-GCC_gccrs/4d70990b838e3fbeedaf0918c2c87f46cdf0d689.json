{"sha": "4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "node_id": "C_kwDOANBUbNoAKDRkNzA5OTBiODM4ZTNmYmVlZGFmMDkxOGMyYzg3ZjQ2Y2RmMGQ2ODk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-16T10:53:26Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-16T13:02:40Z"}, "message": "Add mssing mappings to HIR::Pattern", "tree": {"sha": "df2bc819e07affe08e13d8f09f8448c00ae4722a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df2bc819e07affe08e13d8f09f8448c00ae4722a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8507a68883438060b3b8e828069ffe20a084b85a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8507a68883438060b3b8e828069ffe20a084b85a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8507a68883438060b3b8e828069ffe20a084b85a"}], "stats": {"total": 402, "additions": 325, "deletions": 77}, "files": [{"sha": "156f023281b9299f16ea87685c93627a80fcd32d", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -61,8 +61,13 @@ ASTLoweringPattern::visit (AST::TupleStructPattern &pattern)\n       break;\n     }\n \n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n   translated = new HIR::TupleStructPattern (\n-    *path, std::unique_ptr<HIR::TupleStructItems> (lowered));\n+    mapping, *path, std::unique_ptr<HIR::TupleStructItems> (lowered));\n }\n \n void\n@@ -96,19 +101,38 @@ ASTLoweringPattern::visit (AST::StructPattern &pattern)\n \t    AST::StructPatternFieldIdent &ident\n \t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n \n+\t    auto crate_num = mappings->get_current_crate ();\n+\t    Analysis::NodeMapping mapping (crate_num, ident.get_node_id (),\n+\t\t\t\t\t   mappings->get_next_hir_id (\n+\t\t\t\t\t     crate_num),\n+\t\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n \t    f = new HIR::StructPatternFieldIdent (\n-\t      ident.get_identifier (), ident.is_ref (),\n+\t      mapping, ident.get_identifier (), ident.is_ref (),\n \t      ident.is_mut () ? Mutability::Mut : Mutability::Imm,\n \t      ident.get_outer_attrs (), ident.get_locus ());\n \t  }\n \t  break;\n \t}\n \n+      // insert the reverse mappings and locations\n+      auto crate_num = f->get_mappings ().get_crate_num ();\n+      auto field_id = f->get_mappings ().get_hirid ();\n+      auto field_node_id = f->get_mappings ().get_nodeid ();\n+      mappings->insert_location (crate_num, field_id, f->get_locus ());\n+      mappings->insert_node_to_hir (crate_num, field_node_id, field_id);\n+\n+      // add it to the lowered fields list\n       fields.push_back (std::unique_ptr<HIR::StructPatternField> (f));\n     }\n \n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n   HIR::StructPatternElements elems (std::move (fields));\n-  translated = new HIR::StructPattern (*path, std::move (elems));\n+  translated = new HIR::StructPattern (mapping, *path, std::move (elems));\n }\n \n } // namespace HIR"}, {"sha": "bd25b83741e6c8e8e13d514f7c46272566720a1f", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -33,16 +33,32 @@ class ASTLoweringPattern : public ASTLoweringBase\n   {\n     ASTLoweringPattern resolver;\n     pattern->accept_vis (resolver);\n+\n     rust_assert (resolver.translated != nullptr);\n+\n+    resolver.mappings->insert_hir_pattern (\n+      resolver.translated->get_pattern_mappings ().get_crate_num (),\n+      resolver.translated->get_pattern_mappings ().get_hirid (),\n+      resolver.translated);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_pattern_mappings ().get_crate_num (),\n+      resolver.translated->get_pattern_mappings ().get_hirid (),\n+      pattern->get_locus ());\n+\n     return resolver.translated;\n   }\n \n   void visit (AST::IdentifierPattern &pattern) override\n   {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n     std::unique_ptr<Pattern> to_bind;\n     translated\n-      = new HIR::IdentifierPattern (pattern.get_ident (), pattern.get_locus (),\n-\t\t\t\t    pattern.get_is_ref (),\n+      = new HIR::IdentifierPattern (mapping, pattern.get_ident (),\n+\t\t\t\t    pattern.get_locus (), pattern.get_is_ref (),\n \t\t\t\t    pattern.get_is_mut () ? Mutability::Mut\n \t\t\t\t\t\t\t  : Mutability::Imm,\n \t\t\t\t    std::move (to_bind));"}, {"sha": "16e1be36181e6b6d3615d6e9b77eefc8680b442a", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -330,6 +330,11 @@ class PathInExpression : public PathPattern, public PathExpr\n \t   == 0;\n   }\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return get_mappings ();\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -824,6 +829,11 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   Location get_locus () { return locus; }\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return get_mappings ();\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "fd4960fd2336acd1410115bddeb8f646c21b25d9", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 200, "deletions": 50, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -24,38 +24,40 @@\n \n namespace Rust {\n namespace HIR {\n+\n // Literal pattern HIR node (comparing to a literal)\n class LiteralPattern : public Pattern\n {\n   Literal lit;\n-  /* make literal have a type given by enum, etc. rustc uses an extended form of\n-   * its literal token implementation */\n-  // TODO: literal representation - use LiteralExpr? or another thing?\n-\n-  // Minus prefixed to literal (if integer or floating-point)\n   bool has_minus;\n-  // Actually, this might be a good place to use a template.\n-\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor for a literal pattern\n-  LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n-    : lit (std::move (lit)), has_minus (has_minus), locus (locus)\n+  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus,\n+\t\t  bool has_minus = false)\n+    : lit (std::move (lit)), has_minus (has_minus), locus (locus),\n+      mappings (mappings)\n   {}\n \n-  LiteralPattern (std::string val, Literal::LitType type, Location locus,\n-\t\t  bool has_minus = false)\n+  LiteralPattern (Analysis::NodeMapping mappings, std::string val,\n+\t\t  Literal::LitType type, Location locus, bool has_minus = false)\n     : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n-      has_minus (has_minus), locus (locus)\n+      has_minus (has_minus), locus (locus), mappings (mappings)\n   {}\n \n   Location get_locus () const { return locus; }\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -73,6 +75,7 @@ class IdentifierPattern : public Pattern\n   Mutability mut;\n   std::unique_ptr<Pattern> to_bind;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n@@ -81,17 +84,18 @@ class IdentifierPattern : public Pattern\n   bool has_pattern_to_bind () const { return to_bind != nullptr; }\n \n   // Constructor\n-  IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n+  IdentifierPattern (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t     Location locus, bool is_ref = false,\n \t\t     Mutability mut = Mutability::Imm,\n \t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n     : variable_ident (std::move (ident)), is_ref (is_ref), mut (mut),\n-      to_bind (std::move (to_bind)), locus (locus)\n+      to_bind (std::move (to_bind)), locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n-      mut (other.mut), locus (other.locus)\n+      mut (other.mut), locus (other.locus), mappings (other.mappings)\n   {\n     // fix to get prevent null pointer dereference\n     if (other.to_bind != nullptr)\n@@ -105,6 +109,7 @@ class IdentifierPattern : public Pattern\n     is_ref = other.is_ref;\n     mut = other.mut;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     // fix to get prevent null pointer dereference\n     if (other.to_bind != nullptr)\n@@ -123,6 +128,11 @@ class IdentifierPattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n   Identifier get_identifier () const { return variable_ident; }\n \n protected:\n@@ -138,16 +148,24 @@ class IdentifierPattern : public Pattern\n class WildcardPattern : public Pattern\n {\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override { return std::string (1, '_'); }\n \n-  WildcardPattern (Location locus) : locus (locus) {}\n+  WildcardPattern (Analysis::NodeMapping mappings, Location locus)\n+    : locus (locus), mappings (mappings)\n+  {}\n \n   Location get_locus () const { return locus; }\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -278,23 +296,27 @@ class RangePattern : public Pattern\n   /* location only stored to avoid a dereference - lower pattern should give\n    * correct location so maybe change in future */\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor\n-  RangePattern (std::unique_ptr<RangePatternBound> lower,\n+  RangePattern (Analysis::NodeMapping mappings,\n+\t\tstd::unique_ptr<RangePatternBound> lower,\n \t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n \t\tbool has_ellipsis_syntax = false)\n     : lower (std::move (lower)), upper (std::move (upper)),\n-      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus),\n+      mappings (mappings)\n   {}\n \n   // Copy constructor with clone\n   RangePattern (RangePattern const &other)\n     : lower (other.lower->clone_range_pattern_bound ()),\n       upper (other.upper->clone_range_pattern_bound ()),\n-      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   // Overloaded assignment operator to clone\n@@ -304,6 +326,7 @@ class RangePattern : public Pattern\n     upper = other.upper->clone_range_pattern_bound ();\n     has_ellipsis_syntax = other.has_ellipsis_syntax;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -316,6 +339,11 @@ class RangePattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -332,20 +360,23 @@ class ReferencePattern : public Pattern\n   Mutability mut;\n   std::unique_ptr<Pattern> pattern;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n-  ReferencePattern (std::unique_ptr<Pattern> pattern, Mutability reference_mut,\n+  ReferencePattern (Analysis::NodeMapping mappings,\n+\t\t    std::unique_ptr<Pattern> pattern, Mutability reference_mut,\n \t\t    bool ref_has_two_amps, Location locus)\n     : has_two_amps (ref_has_two_amps), mut (reference_mut),\n-      pattern (std::move (pattern)), locus (locus)\n+      pattern (std::move (pattern)), locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor requires clone\n   ReferencePattern (ReferencePattern const &other)\n     : has_two_amps (other.has_two_amps), mut (other.mut),\n-      pattern (other.pattern->clone_pattern ()), locus (other.locus)\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   // Overload assignment operator to clone\n@@ -355,6 +386,7 @@ class ReferencePattern : public Pattern\n     mut = other.mut;\n     has_two_amps = other.has_two_amps;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -367,6 +399,11 @@ class ReferencePattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -381,8 +418,16 @@ class StructPatternField\n {\n   AST::AttrVec outer_attrs;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n+  enum ItemType\n+  {\n+    TUPLE_PAT,\n+    IDENT_PAT,\n+    IDENT\n+  };\n+\n   virtual ~StructPatternField () {}\n \n   // Unique pointer custom clone function\n@@ -393,14 +438,17 @@ class StructPatternField\n   }\n \n   virtual std::string as_string () const;\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+  virtual ItemType get_item_type () const = 0;\n \n   Location get_locus () const { return locus; }\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n+  Analysis::NodeMapping get_mappings () const { return mappings; };\n \n protected:\n-  StructPatternField (AST::AttrVec outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)), locus (locus)\n+  StructPatternField (Analysis::NodeMapping mappings,\n+\t\t      AST::AttrVec outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus),\n+      mappings (mappings)\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -414,11 +462,11 @@ class StructPatternFieldTuplePat : public StructPatternField\n   std::unique_ptr<Pattern> tuple_pattern;\n \n public:\n-  StructPatternFieldTuplePat (TupleIndex index,\n+  StructPatternFieldTuplePat (Analysis::NodeMapping mappings, TupleIndex index,\n \t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n \t\t\t      AST::AttrVec outer_attribs, Location locus)\n-    : StructPatternField (std::move (outer_attribs), locus), index (index),\n-      tuple_pattern (std::move (tuple_pattern))\n+    : StructPatternField (mappings, std::move (outer_attribs), locus),\n+      index (index), tuple_pattern (std::move (tuple_pattern))\n   {}\n \n   // Copy constructor requires clone\n@@ -448,6 +496,8 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  ItemType get_item_type () const override final { return ItemType::TUPLE_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -464,10 +514,10 @@ class StructPatternFieldIdentPat : public StructPatternField\n   std::unique_ptr<Pattern> ident_pattern;\n \n public:\n-  StructPatternFieldIdentPat (Identifier ident,\n+  StructPatternFieldIdentPat (Analysis::NodeMapping mappings, Identifier ident,\n \t\t\t      std::unique_ptr<Pattern> ident_pattern,\n \t\t\t      AST::AttrVec outer_attrs, Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus),\n+    : StructPatternField (mappings, std::move (outer_attrs), locus),\n       ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n   {}\n \n@@ -498,6 +548,8 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  ItemType get_item_type () const override final { return ItemType::IDENT_PAT; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -515,10 +567,11 @@ class StructPatternFieldIdent : public StructPatternField\n   Identifier ident;\n \n public:\n-  StructPatternFieldIdent (Identifier ident, bool is_ref, Mutability mut,\n+  StructPatternFieldIdent (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t\t   bool is_ref, Mutability mut,\n \t\t\t   AST::AttrVec outer_attrs, Location locus)\n-    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n-      mut (mut), ident (std::move (ident))\n+    : StructPatternField (mappings, std::move (outer_attrs), locus),\n+      has_ref (is_ref), mut (mut), ident (std::move (ident))\n   {}\n \n   std::string as_string () const override;\n@@ -527,6 +580,10 @@ class StructPatternFieldIdent : public StructPatternField\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  ItemType get_item_type () const override final { return ItemType::IDENT; }\n+\n+  Identifier get_identifier () const { return ident; };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -586,19 +643,28 @@ struct StructPatternElements\n   }\n \n   std::string as_string () const;\n+\n+  std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields ()\n+  {\n+    return fields;\n+  }\n };\n \n // Struct pattern HIR node representation\n class StructPattern : public Pattern\n {\n   PathInExpression path;\n   StructPatternElements elems;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n-  StructPattern (PathInExpression struct_path, StructPatternElements elems)\n-    : path (std::move (struct_path)), elems (std::move (elems))\n+  StructPattern (Analysis::NodeMapping mappings, PathInExpression struct_path,\n+\t\t StructPatternElements elems)\n+    : path (std::move (struct_path)), elems (std::move (elems)),\n+      mappings (mappings)\n   {}\n \n   bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n@@ -607,6 +673,14 @@ class StructPattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  PathInExpression &get_path () { return path; }\n+  StructPatternElements &get_struct_pattern_elems () { return elems; }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -620,6 +694,12 @@ class StructPattern : public Pattern\n class TupleStructItems\n {\n public:\n+  enum ItemType\n+  {\n+    RANGE,\n+    NO_RANGE\n+  };\n+\n   virtual ~TupleStructItems () {}\n \n   // TODO: should this store location data?\n@@ -634,6 +714,8 @@ class TupleStructItems\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual ItemType get_item_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n@@ -676,6 +758,14 @@ class TupleStructItemsNoRange : public TupleStructItems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::NO_RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -732,6 +822,27 @@ class TupleStructItemsRange : public TupleStructItems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::RANGE; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -746,28 +857,33 @@ class TupleStructPattern : public Pattern\n {\n   PathInExpression path;\n   std::unique_ptr<TupleStructItems> items;\n+  Analysis::NodeMapping mappings;\n \n   /* TOOD: should this store location data? current accessor uses path location\n    * data */\n \n public:\n   std::string as_string () const override;\n \n-  TupleStructPattern (PathInExpression tuple_struct_path,\n+  TupleStructPattern (Analysis::NodeMapping mappings,\n+\t\t      PathInExpression tuple_struct_path,\n \t\t      std::unique_ptr<TupleStructItems> items)\n-    : path (std::move (tuple_struct_path)), items (std::move (items))\n+    : path (std::move (tuple_struct_path)), items (std::move (items)),\n+      mappings (mappings)\n   {}\n \n   // Copy constructor required to clone\n   TupleStructPattern (TupleStructPattern const &other)\n-    : path (other.path), items (other.items->clone_tuple_struct_items ())\n+    : path (other.path), items (other.items->clone_tuple_struct_items ()),\n+      mappings (other.mappings)\n   {}\n \n   // Operator overload assignment operator to clone\n   TupleStructPattern &operator= (TupleStructPattern const &other)\n   {\n     path = other.path;\n     items = other.items->clone_tuple_struct_items ();\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -780,6 +896,15 @@ class TupleStructPattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  PathInExpression &get_path () { return path; }\n+\n+  std::unique_ptr<TupleStructItems> &get_items () { return items; }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -955,31 +1080,33 @@ class TuplePatternItemsRanged : public TuplePatternItems\n // HIR node representing a tuple pattern\n class TuplePattern : public Pattern\n {\n-  // bool has_tuple_pattern_items;\n   std::unique_ptr<TuplePatternItems> items;\n-\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n   // Returns true if the tuple pattern has items\n   bool has_tuple_pattern_items () const { return items != nullptr; }\n \n-  TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n-    : items (std::move (items)), locus (locus)\n+  TuplePattern (Analysis::NodeMapping mappings,\n+\t\tstd::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor requires clone\n   TuplePattern (TuplePattern const &other)\n-    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n+    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   // Overload assignment operator to clone\n   TuplePattern &operator= (TuplePattern const &other)\n   {\n     items = other.items->clone_tuple_pattern_items ();\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -988,6 +1115,11 @@ class TuplePattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1002,28 +1134,32 @@ class GroupedPattern : public Pattern\n {\n   std::unique_ptr<Pattern> pattern_in_parens;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override\n   {\n     return \"(\" + pattern_in_parens->as_string () + \")\";\n   }\n \n-  GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n-    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus)\n+  GroupedPattern (Analysis::NodeMapping mappings,\n+\t\t  std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus),\n+      mappings (mappings)\n   {}\n \n   // Copy constructor uses clone\n   GroupedPattern (GroupedPattern const &other)\n     : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n-      locus (other.locus)\n+      locus (other.locus), mappings (other.mappings)\n   {}\n \n   // Overload assignment operator to clone\n   GroupedPattern &operator= (GroupedPattern const &other)\n   {\n     pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1036,6 +1172,11 @@ class GroupedPattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1050,16 +1191,19 @@ class SlicePattern : public Pattern\n {\n   std::vector<std::unique_ptr<Pattern> > items;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n-  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n-    : items (std::move (items)), locus (locus)\n+  SlicePattern (Analysis::NodeMapping mappings,\n+\t\tstd::vector<std::unique_ptr<Pattern> > items, Location locus)\n+    : items (std::move (items)), locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor with vector clone\n-  SlicePattern (SlicePattern const &other) : locus (other.locus)\n+  SlicePattern (SlicePattern const &other)\n+    : locus (other.locus), mappings (other.mappings)\n   {\n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1070,6 +1214,7 @@ class SlicePattern : public Pattern\n   SlicePattern &operator= (SlicePattern const &other)\n   {\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1086,6 +1231,11 @@ class SlicePattern : public Pattern\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "8b5f3bb2deafd31221fe5a4b83b8cef6f767c6e0", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -328,6 +328,8 @@ class Pattern\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual Analysis::NodeMapping get_pattern_mappings () const = 0;\n+\n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;"}, {"sha": "a8606084d9f6869f3667f5a999f3e08746e63bc0", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -100,8 +100,14 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n \t// get the name as well required for later on\n \tauto param_tyty = TypeCheckType::Resolve (param.get_type ().get ());\n \n+\t// these are implicit mappings and not used\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n \tHIR::IdentifierPattern *param_pattern = new HIR::IdentifierPattern (\n-\t  param.get_param_name (), Location (), false, Mutability::Imm,\n+\t  mapping, param.get_param_name (), Location (), false, Mutability::Imm,\n \t  std::unique_ptr<HIR::Pattern> (nullptr));\n \n \tparams.push_back (\n@@ -223,12 +229,18 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n     if (function.is_method ())\n       {\n+\t// these are implicit mappings and not used\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n \t// add the synthetic self param at the front, this is a placeholder for\n \t// compilation to know parameter names. The types are ignored but we\n \t// reuse the HIR identifier pattern which requires it\n \tHIR::SelfParam &self_param = function.get_self_param ();\n \tHIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n-\t  \"self\", self_param.get_locus (), self_param.is_ref (),\n+\t  mapping, \"self\", self_param.get_locus (), self_param.is_ref (),\n \t  self_param.get_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n \n \t// might have a specified type"}, {"sha": "d2da20eb52dfd13aa00e29a2f093e717eef15644", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -276,12 +276,19 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n   std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n   if (function.is_method ())\n     {\n+      // these are implicit mappings and not used\n+      auto mappings = Analysis::Mappings::get ();\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n       // add the synthetic self param at the front, this is a placeholder\n       // for compilation to know parameter names. The types are ignored\n       // but we reuse the HIR identifier pattern which requires it\n       HIR::SelfParam &self_param = function.get_self ();\n       HIR::IdentifierPattern *self_pattern\n-\t= new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n+\t= new HIR::IdentifierPattern (mapping, \"self\", self_param.get_locus (),\n \t\t\t\t      self_param.is_ref (),\n \t\t\t\t      self_param.is_mut () ? Mutability::Mut\n \t\t\t\t\t\t\t   : Mutability::Imm,"}, {"sha": "4b713128b0f15d38146da597ac5de38a8e8207f8", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -565,6 +565,29 @@ Mappings::lookup_hir_struct_field (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_pattern (CrateNum crateNum, HirId id,\n+\t\t\t      HIR::Pattern *pattern)\n+{\n+  hirPatternMappings[crateNum][id] = pattern;\n+  nodeIdToHirMappings[crateNum][pattern->get_pattern_mappings ().get_nodeid ()]\n+    = id;\n+}\n+\n+HIR::Pattern *\n+Mappings::lookup_hir_pattern (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirPatternMappings.find (crateNum);\n+  if (it == hirPatternMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n \t\t\t\t      HIR::Item *item)"}, {"sha": "f1f723bda46a16fa8ae50b0d1a9f852858637309", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d70990b838e3fbeedaf0918c2c87f46cdf0d689/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=4d70990b838e3fbeedaf0918c2c87f46cdf0d689", "patch": "@@ -347,6 +347,9 @@ class Mappings\n \t\t\t\tHIR::StructExprField *type);\n   HIR::StructExprField *lookup_hir_struct_field (CrateNum crateNum, HirId id);\n \n+  void insert_hir_pattern (CrateNum crateNum, HirId id, HIR::Pattern *pattern);\n+  HIR::Pattern *lookup_hir_pattern (CrateNum crateNum, HirId id);\n+\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n@@ -479,43 +482,44 @@ class Mappings\n   std::map<CrateNum, HIR::Crate *> hirCrateMappings;\n \n   std::map<DefId, HIR::Item *> defIdMappings;\n-  std::map<CrateNum, std::map<LocalDefId, HIR::Item *> > localDefIdMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::Module *> > hirModuleMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::Item *> > hirItemMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::Type *> > hirTypeMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::Stmt *> > hirStmtMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::StructExprField *> >\n+  std::map<CrateNum, std::map<LocalDefId, HIR::Item *>> localDefIdMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Module *>> hirModuleMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Item *>> hirItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Type *>> hirTypeMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Expr *>> hirExprMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Stmt *>> hirStmtMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::FunctionParam *>> hirParamMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::StructExprField *>>\n     hirStructFieldMappings;\n-  std::map<CrateNum, std::map<HirId, std::pair<HirId, HIR::ImplItem *> > >\n+  std::map<CrateNum, std::map<HirId, std::pair<HirId, HIR::ImplItem *>>>\n     hirImplItemMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::SelfParam *> > hirSelfParamMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::SelfParam *>> hirSelfParamMappings;\n   std::map<HirId, HIR::ImplBlock *> hirImplItemsToImplMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::ImplBlock *> > hirImplBlockMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::TraitItem *> > hirTraitItemMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::ExternalItem *> >\n+  std::map<CrateNum, std::map<HirId, HIR::ImplBlock *>> hirImplBlockMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::TraitItem *>> hirTraitItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::ExternalItem *>>\n     hirExternItemMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::PathExprSegment *> >\n+  std::map<CrateNum, std::map<HirId, HIR::PathExprSegment *>>\n     hirPathSegMappings;\n-  std::map<CrateNum, std::map<HirId, HIR::GenericParam *> >\n+  std::map<CrateNum, std::map<HirId, HIR::GenericParam *>>\n     hirGenericParamMappings;\n   std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Pattern *>> hirPatternMappings;\n \n   // this maps the lang=<item_type> to DefId mappings\n   std::map<RustLangItem::ItemType, DefId> lang_item_mappings;\n \n   // canonical paths\n-  std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath> > paths;\n+  std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath>> paths;\n \n   // location info\n-  std::map<CrateNum, std::map<NodeId, Location> > locations;\n+  std::map<CrateNum, std::map<NodeId, Location>> locations;\n \n   // reverse mappings\n-  std::map<CrateNum, std::map<NodeId, HirId> > nodeIdToHirMappings;\n+  std::map<CrateNum, std::map<NodeId, HirId>> nodeIdToHirMappings;\n \n   // all hirid nodes\n-  std::map<CrateNum, std::set<HirId> > hirNodesWithinCrate;\n+  std::map<CrateNum, std::set<HirId>> hirNodesWithinCrate;\n \n   // crate names\n   std::map<CrateNum, std::string> crate_names;"}]}