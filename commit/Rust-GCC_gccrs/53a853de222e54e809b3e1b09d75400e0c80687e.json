{"sha": "53a853de222e54e809b3e1b09d75400e0c80687e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNhODUzZGUyMjJlNTRlODA5YjNlMWIwOWQ3NTQwMGUwYzgwNjg3ZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-04-02T03:44:25Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-04-02T03:44:25Z"}, "message": "ebitmap.h: New file\n\n2007-04-01  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* ebitmap.h: New file\n\t* ebitmap.c: New file\n\t* Makefile.in (ebitmap.o): New target.\n\nFrom-SVN: r123415", "tree": {"sha": "892ba7dacf76228a11c792f5f87a791e8c4ea580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/892ba7dacf76228a11c792f5f87a791e8c4ea580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53a853de222e54e809b3e1b09d75400e0c80687e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a853de222e54e809b3e1b09d75400e0c80687e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53a853de222e54e809b3e1b09d75400e0c80687e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a853de222e54e809b3e1b09d75400e0c80687e/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb0179fe817ac66458a29f78a2713ac1bb2e5118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb0179fe817ac66458a29f78a2713ac1bb2e5118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb0179fe817ac66458a29f78a2713ac1bb2e5118"}], "stats": {"total": 1194, "additions": 1194, "deletions": 0}, "files": [{"sha": "7509a81e2701eee2fcfd77dd93d27a7058ccfbc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53a853de222e54e809b3e1b09d75400e0c80687e", "patch": "@@ -1,3 +1,9 @@\n+2007-04-01  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* ebitmap.h: New file\n+\t* ebitmap.c: New file\n+\t* Makefile.in (ebitmap.o): New target.\n+\n 2007-04-01  Jan Hubicka  <jh@suse.cz>\n \n \t* emit-rtl.c (emit_insn_before_setloc): Do not ICE when asked to emit"}, {"sha": "eeca0dc20a3e57ab31340d075cddc6656ef0f6cc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=53a853de222e54e809b3e1b09d75400e0c80687e", "patch": "@@ -789,6 +789,7 @@ TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n TREE_INLINE_H = tree-inline.h $(VARRAY_H) pointer-set.h\n REAL_H = real.h $(MACHMODE_H)\n+EBIMAP_H = ebitmap.h sbitmap.h\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -988,6 +989,7 @@ OBJS-common = \\\n \tdouble-int.o \\\n \tdwarf2asm.o \\\n \tdwarf2out.o \\\n+\tebitmap.o \\\n \temit-rtl.o \\\n \tet-forest.o \\\n \texcept.o \\\n@@ -1746,6 +1748,8 @@ graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(FLAGS_H) output.h \\\n     $(RTL_H) $(FUNCTION_H) hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(OBSTACK_H)\n sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n     $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H)\n+ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\t$(EBITMAP_H)\n \n COLLECT2_OBJS = collect2.o tlink.o intl.o version.o\n COLLECT2_LIBS = @COLLECT2_LIBS@"}, {"sha": "39386b787c229f36d59e6fd4b1ee851a6e53e641", "filename": "gcc/ebitmap.c", "status": "added", "additions": 1019, "deletions": 0, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=53a853de222e54e809b3e1b09d75400e0c80687e", "patch": "@@ -0,0 +1,1019 @@\n+/* Sparse array-based bitmaps.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"obstack.h\"\n+#include \"ebitmap.h\"\n+\n+/* The ebitmap data structure is a sparse bitmap structure that works\n+   by having two pieces:\n+   1. An array of all non-zero words in the structures, organized as\n+   an array of HOST_WIDE_INT's.\n+   2. A non-sparse bitmap saying which bitmap words are present in the\n+   array.\n+\n+   As a consequence of this representation, testing whether a bit\n+   exists in the bitmap is faster than linked-list bitmaps.  For bits\n+   in words that are all zero, the time to test is O(1).  For bits in\n+   words that exist, it requires O(n/sizeof(word)) time to perform the\n+   test (ignoring the one element cache).  It also has much better\n+   locality than linked-list bitmaps.\n+\n+   To test whether a bit exists, we do the following:\n+   1. Test whether the word the bit would appear in exists in the\n+   bitmap (O(1) check of the mask).  If not, fail.\n+\n+   2. Population count the mask up to the word containing the bit, to\n+   find the place in the array the word would be (popcount is cached,\n+   but this is just as slow as the linked-list bitmap)\n+   3. Test the word to see if the bit exists.\n+\n+   Just like linked-list bitmaps, we cache the last element that has\n+   been tested in order to speed up common access patterns.\n+\n+   Most of the other speedups are simply due to better locality of the\n+   single contiguous array.\n+\n+   As would be expected in a structure like this, insertion into an\n+   empty word in the middle requires moving bits to make room for the\n+   new word.   As most operations that perform sets perform them in\n+   order, this is rarely a problem.  We also take advantage of the\n+   same element cache to make repeated sets to the same word O(1).\n+\n+   Operations on the entire bitmap are also more efficient than linked\n+   list bitmaps, as they are all operating on contiguous memory, and\n+   can be easily vectorized.  They are all O(number of words) +\n+   O(number of bits that may end up in the destination), as the\n+   appropriate operation is first performed on the word mask, and then\n+   only those elements that may generate results are touched.\n+\n+   Memory wise, the ebitmap starts out using less memory than the\n+   linked-list bitmap, but its size in memory is technically bounded\n+   by ((index of the highest bit set) / (size of a word) + (index of\n+   the highest bit set) / ((size of a word) * (size of a word))) This\n+   is because the mask is non-sparse.  The mask could be transformed\n+   into a sparse bitmap at the cost of making bit testing\n+   *theoretically* slower (real world numbers have not been computed\n+   yet as to whether it matters or not).  */\n+\n+/* #define EBITMAP_DEBUGGING  */\n+\n+/* Find the last set bit in ebitmap MAP.  */\n+\n+int\n+ebitmap_last_set_bit (ebitmap map)\n+{\n+  unsigned int i = 0;\n+  ebitmap_iterator ebi;\n+  bool foundbit = false;\n+  \n+  /* This is not the fastest way to do this, we could simply look for\n+     the popcount, and start there, but this function is not used\n+     anywhere speed critical.  */\n+  EXECUTE_IF_SET_IN_EBITMAP (map, 0, i, ebi)\n+    {\n+      foundbit = true;\n+    }\n+  \n+\n+  if (foundbit)\n+    return i;\n+  return -1;\n+}\n+\n+/* Grow or shrink the internal word array for MAP to NEWSIZE\n+   elements.  */\n+\n+static inline void\n+ebitmap_array_grow (ebitmap map, unsigned int newsize)\n+{\n+  if (newsize <= map->n_elts)\n+    {\n+      map->n_elts = newsize;\n+      return;\n+    }\n+\n+  newsize += newsize / 4;\n+\n+  map->n_elts = newsize;\n+  map->elts = xrealloc (map->elts, sizeof (EBITMAP_ELT_TYPE) * newsize);\n+}\n+\n+/* Grow the internal word array for MAP so it is at least SIZE\n+   elements.  Will not shrink the array if it is already big\n+   enough.  */\n+\n+static inline void\n+ebitmap_array_maybe_grow (ebitmap map, unsigned int size)\n+{\n+  if (size >= map->n_elts)\n+    ebitmap_array_grow (map, size + 1);\n+}\n+\n+/* Retrieve the IDX'th element from the word array for MAP.  */\n+\n+static inline EBITMAP_ELT_TYPE\n+ebitmap_array_get (ebitmap map, unsigned int idx)\n+{\n+  gcc_assert (idx < map->n_elts);\n+  return map->elts[idx];\n+}\n+\n+/* Retrieve a pointer to the IDX'th element from the word array for\n+   MAP.  If the element index is greater than the size of the array,\n+   the array will be grown to the correct size.  */\n+\n+static inline EBITMAP_ELT_TYPE *\n+ebitmap_array_grow_get (ebitmap map, unsigned int idx)\n+{\n+  if (idx >= map->n_elts)\n+    ebitmap_array_grow (map, idx + 1);\n+  return &map->elts[idx];\n+}\n+\n+/* Initialize the internal word array for MAP, so that it is SIZE\n+   elements.  */\n+\n+static inline void\n+ebitmap_array_init (ebitmap map, unsigned int size)\n+{\n+  if (size > 0)\n+    {\n+      map->elts = xmalloc (sizeof (EBITMAP_ELT_TYPE) * size);\n+      map->n_elts = size;\n+    }\n+  else\n+    {\n+      map->n_elts = 0;\n+      map->elts = NULL;\n+    }\n+}\n+\n+/* Free the internal word array for MAP.  */\n+\n+static inline void\n+ebitmap_array_clear (ebitmap map)\n+{\n+  if (map->elts) \n+    {\n+      free (map->elts);\n+      map->elts = NULL;\n+    }\n+  map->n_elts = 0;\n+}\n+\n+/* Clear ebitmap MAP.  */\n+\n+void\n+ebitmap_clear (ebitmap map)\n+{\n+  ebitmap_array_clear (map);\n+  sbitmap_zero (map->wordmask);\n+  map->wordmask = sbitmap_resize (map->wordmask, 1, 0);\n+  map->numwords = 0;\n+  map->cache = NULL;\n+  map->cacheindex = 0;\n+}\n+\n+/* Allocate an ebitmap with enough room for SIZE bits to start out.  */\n+\n+ebitmap\n+ebitmap_alloc (unsigned int size)\n+{\n+  ebitmap ret = xmalloc (sizeof (struct ebitmap_def));\n+  if (size == 0)\n+    size = EBITMAP_ELT_BITS;\n+  ebitmap_array_init (ret, (size + EBITMAP_ELT_BITS - 1) / EBITMAP_ELT_BITS);\n+  ret->wordmask = sbitmap_alloc_with_popcount (size);\n+  sbitmap_zero (ret->wordmask);\n+  ret->numwords = 0;\n+  ret->cache = NULL;\n+  ret->cacheindex = 0;\n+\n+  return ret;\n+}\n+\n+/* Clear BIT from ebitmap MAP.  */\n+\n+void\n+ebitmap_clear_bit (ebitmap map, unsigned int bit)\n+{\n+  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n+  unsigned int eltwordindex = 0;\n+  unsigned int bitindex, shift;\n+  bool have_eltwordindex = false;\n+  EBITMAP_ELT_TYPE *elt_ptr;\n+  \n+  /* If the bit can't exist in our bitmap, just return.  */\n+  if (map->numwords == 0)\n+    return;\n+\n+  if (wordindex >= map->wordmask->n_bits\n+      || !TEST_BIT (map->wordmask, wordindex))\n+    return;\n+  \n+  if (map->cache != NULL && map->cacheindex == wordindex)\n+    elt_ptr = map->cache;\n+  else\n+    {\n+      eltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n+      elt_ptr = &map->elts[eltwordindex];\n+      have_eltwordindex = true;\n+    }\n+  \n+  bitindex = bit % EBITMAP_ELT_BITS;\n+  shift = bitindex;\n+  \n+  *(elt_ptr) &= ~(((EBITMAP_ELT_TYPE)1) << shift);\n+\n+  /* Clear out the empty words.  */\n+  if (*(elt_ptr) == 0)\n+    {\n+      if (!have_eltwordindex)\n+\teltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n+      \n+      if (map->cache != NULL && map->cacheindex == eltwordindex)\n+\tmap->cache = NULL;\n+\n+      RESET_BIT (map->wordmask, wordindex);\n+\n+      memmove(&map->elts[eltwordindex], &map->elts[eltwordindex + 1],\n+\t      sizeof (EBITMAP_ELT_TYPE) * (map->numwords - eltwordindex));\n+      map->numwords--;\n+    }\n+}\n+\n+/* Set BIT in ebitmap MAP.  */\n+\n+void\n+ebitmap_set_bit (ebitmap map, unsigned int bit)\n+{\n+  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n+  unsigned int eltwordindex;\n+  unsigned int bitindex =   bit % EBITMAP_ELT_BITS;\n+\n+  /* If we have this element cached, just set the bit in it.  */\n+  if (map->cache && map->cacheindex == wordindex)\n+    {\n+      (*map->cache) |= (EBITMAP_ELT_TYPE)1 << bitindex;\n+      return;\n+    }\n+\n+  /* Resize the wordmask if necessary.  */\n+  if (wordindex >= map->wordmask->n_bits)\n+    map->wordmask = sbitmap_resize (map->wordmask, wordindex + 1, 0);\n+\n+  /* Allocate a new word in the array and move whatever is in it's\n+     place, if necessary. */\n+  if (!TEST_BIT (map->wordmask, wordindex))\n+    {\n+      unsigned long count;\n+      unsigned int i;\n+\n+      SET_BIT (map->wordmask, wordindex);\n+      count = sbitmap_popcount (map->wordmask, wordindex);\n+      gcc_assert (count <= map->numwords);\n+\n+      for (i = map->numwords; i > count; i--)\n+\t{\n+\t  EBITMAP_ELT_TYPE *newelt;\n+\t  newelt = ebitmap_array_grow_get (map, i);\n+\t  *newelt = ebitmap_array_get (map, i - 1);\n+\t}\n+      map->numwords++;\n+      eltwordindex = count;\n+      ebitmap_array_maybe_grow (map, eltwordindex);\n+      map->elts[eltwordindex] = 0;\n+    }\n+  else\n+    {\n+      eltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n+    }\n+\n+  /* Set the actual bit.  */\n+  bitindex = bit % EBITMAP_ELT_BITS;\n+\n+  map->elts[eltwordindex] |= (EBITMAP_ELT_TYPE)1 << bitindex;\n+  map->cache = &map->elts[eltwordindex];\n+  map->cacheindex = wordindex;\n+}\n+\n+\n+/* Return true if MAP contains BIT.  */\n+\n+bool\n+ebitmap_bit_p (ebitmap map, unsigned int bit)\n+{\n+  unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n+  unsigned int bitindex= bit % EBITMAP_ELT_BITS;\n+\n+  /* Trivial empty ebitmap case.  */\n+  if (map->numwords == 0)\n+    return false;\n+\n+  if (map->cache && map->cacheindex == wordindex)\n+    return ((*map->cache) >> bitindex) & 1;\n+\n+  /* If the wordindex is greater than the size of the wordmask, *or*\n+     it's not set in the wordmask, this bit can't exist in our\n+     ebitmap.  */\n+  if (wordindex >= map->wordmask->n_bits\n+      || !TEST_BIT (map->wordmask, wordindex))\n+    return false;\n+\n+  /* Find the bit and test it.  */\n+  map->cacheindex = wordindex;\n+  wordindex = sbitmap_popcount (map->wordmask, wordindex);\n+  map->cache = &map->elts[wordindex];\n+\n+  return (map->elts[wordindex] >> bitindex) & 1;\n+}\n+\n+/* Copy ebitmap SRC to DST.  */\n+\n+void\n+ebitmap_copy (ebitmap dst, ebitmap src)\n+{\n+  /* Blow away any existing wordmask, and copy the new one.  */\n+  sbitmap_free (dst->wordmask);\n+  dst->wordmask = sbitmap_alloc_with_popcount (src->wordmask->n_bits);\n+  sbitmap_copy (dst->wordmask, src->wordmask);\n+\n+  /* Make sure our destination array is big enough, and then copy the\n+     actual words.  */\n+  ebitmap_array_grow (dst, src->numwords);\n+  memcpy (dst->elts, src->elts,\n+\t  src->numwords * sizeof (EBITMAP_ELT_TYPE));\n+  dst->numwords = src->numwords;\n+  dst->cache = NULL;\n+}\n+\n+/* Dump ebitmap BMAP to FILE.  */\n+\n+void\n+dump_ebitmap (FILE *file, ebitmap bmap)\n+{\n+  unsigned int pos;\n+  unsigned int i;\n+  int res;\n+  unsigned int size;\n+\n+  res = sbitmap_last_set_bit (bmap->wordmask);\n+  if (res == -1)\n+    size = 0;\n+  else\n+    size = (res + 1) * EBITMAP_ELT_BITS;\n+\n+  fprintf (file, \"n_words = %d, set = {\", bmap->numwords);\n+\n+  for (pos = 30, i = 0; i < size; i++)\n+    if (ebitmap_bit_p (bmap, i))\n+      {\n+\tif (pos > 70)\n+\t  {\n+\t    fprintf (file, \"\\n  \");\n+\t    pos = 0;\n+\t  }\n+\n+\tpos += fprintf (file, \"%d \", i);\n+      }\n+\n+  fprintf (file, \"}\\n\");\n+}\n+\n+/* Dump ebitmap BMAP to stderr.  */\n+\n+void\n+debug_ebitmap (ebitmap bmap)\n+{\n+  dump_ebitmap (stderr, bmap);\n+}\n+\n+/* Perform the operation DST &= SRC.  */\n+\n+void\n+ebitmap_and_into (ebitmap dst, ebitmap src)\n+{\n+  sbitmap_iterator sbi;\n+  unsigned int i;\n+  unsigned int neweltindex = 0;\n+  unsigned int dsteltindex = 0;\n+  unsigned int srceltindex = 0;\n+\n+  gcc_assert (dst != src);\n+\n+  dst->cache = NULL;\n+\n+  /* Short circuit the empty bitmap cases.  */\n+  if (src->numwords == 0 || dst->numwords == 0)\n+    {\n+      ebitmap_clear (dst);\n+      return;\n+    }\n+\n+  /* AND the masks, then walk the words that may actually appear in\n+     the result, AND'ing them.  */\n+  sbitmap_a_and_b (dst->wordmask, dst->wordmask, src->wordmask);\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (dst->wordmask, 0, i, sbi)\n+    {\n+      EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src, srceltindex++);\n+      tmpword &= ebitmap_array_get (dst, dsteltindex++);\n+      if (tmpword != 0)\n+\t{\n+\t  EBITMAP_ELT_TYPE *dstplace;\n+\t  dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n+\t  *dstplace = tmpword;\n+\t}\n+      else\n+\tRESET_BIT (dst->wordmask, i);\n+    }\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    unsigned int i;\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    verify_popcount (dst->wordmask);\n+    gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n+  }\n+#endif\n+  dst->numwords = neweltindex;\n+}\n+\n+/* Perform the operation DST = SRC1 & SRC2.  */\n+\n+void\n+ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n+{\n+  sbitmap_iterator sbi;\n+  unsigned int i;\n+  unsigned int neweltindex = 0;\n+  unsigned int src1eltindex = 0;\n+  unsigned int src2eltindex = 0;\n+\n+  dst->cache = NULL;\n+  if (src1->numwords == 0 || src2->numwords == 0)\n+    {\n+      ebitmap_clear (dst);\n+      return;\n+    }\n+\n+  dst->wordmask\n+    = sbitmap_resize (dst->wordmask,\n+\t\t      MIN (src1->wordmask->n_bits, src2->wordmask->n_bits),\n+\t\t      0);\n+  sbitmap_a_and_b (dst->wordmask, src1->wordmask, src2->wordmask);\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (dst->wordmask, 0, i, sbi)\n+    {\n+      bool src1hasword, src2hasword;\n+\n+      src1hasword = TEST_BIT (src1->wordmask, i);\n+      src2hasword = TEST_BIT (src2->wordmask, i);\n+\n+      if (src1hasword && src2hasword)\n+\t{\n+\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src1, src1eltindex++);\n+\t  tmpword &= ebitmap_array_get (src2, src2eltindex++);\n+\t  if (tmpword != 0)\n+\t    {\n+\t      EBITMAP_ELT_TYPE *dstplace;\n+\t      dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n+\t      *dstplace = tmpword;\n+\t    }\n+\t  else\n+\t    RESET_BIT (dst->wordmask, i);\n+\t}\n+      else if (src1hasword)\n+\tsrc1eltindex++;\n+      else\n+\tsrc2eltindex++;\n+    }\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    ebitmap_iterator ebi;\n+    unsigned int i;\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n+      if (ebitmap_bit_p (src2, i))\n+\tgcc_assert (ebitmap_bit_p (dst, i));\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    verify_popcount (dst->wordmask);\n+    gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n+  }\n+#endif\n+  dst->numwords = neweltindex;\n+}\n+\n+/* Perform the operation DST |= SRC.  Return true if any bits in DST\n+   changed.  */\n+\n+bool\n+ebitmap_ior_into (ebitmap dst, ebitmap src)\n+{\n+  unsigned int dstsize = dst->wordmask->n_bits;\n+  unsigned int srcsize = src->wordmask->n_bits;\n+  sbitmap_iterator sbi;\n+  unsigned int i;\n+  sbitmap tempmask;\n+  unsigned int neweltindex = 0;\n+  unsigned int dsteltindex = 0;\n+  unsigned int srceltindex = 0;\n+  bool changed = false;\n+  EBITMAP_ELT_TYPE *newarray;\n+  unsigned int newarraysize;\n+#ifdef EBITMAP_DEBUGGING\n+  ebitmap dstcopy = ebitmap_alloc (1);\n+  ebitmap_copy (dstcopy, dst);\n+#endif\n+\n+  dst->cache = NULL;\n+  if (dst == src)\n+    return false;\n+\n+  if (dst->numwords == 0 && src->numwords != 0)\n+    {\n+      ebitmap_copy (dst, src);\n+      return true;\n+    }\n+  else if (src->numwords == 0)\n+    return false;\n+\n+  /* We can do without the temp mask if it's faster, but it would mean\n+     touching more words in the actual dense vector.  */\n+  tempmask = sbitmap_alloc (MAX (srcsize, dstsize));\n+  sbitmap_zero (tempmask);\n+  if (srcsize == dstsize)\n+    {\n+      sbitmap_a_or_b (tempmask, dst->wordmask, src->wordmask);\n+    }\n+  else\n+    {\n+      dst->wordmask = sbitmap_resize (dst->wordmask, MAX (srcsize, dstsize),\n+\t\t\t\t      0);\n+      if (srcsize >= dstsize)\n+\t{\n+\t  sbitmap_copy_n (tempmask, dst->wordmask, dst->wordmask->size);\n+\t  sbitmap_a_or_b (tempmask, tempmask, src->wordmask);\n+\t}\n+      else\n+\t{\n+\t  sbitmap_copy_n (tempmask, src->wordmask, src->wordmask->size);\n+\t  sbitmap_a_or_b (tempmask, tempmask, dst->wordmask);\n+\t}\n+    }\n+  newarraysize = src->numwords + dst->numwords;\n+  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (tempmask, 0, i, sbi)\n+    {\n+      bool dsthasword, srchasword;\n+\n+      dsthasword = (i < dst->wordmask->n_bits\n+\t\t    && TEST_BIT (dst->wordmask, i));\n+      srchasword = (i < src->wordmask->n_bits\n+\t\t    && TEST_BIT (src->wordmask, i));\n+\n+      if (dsthasword && srchasword)\n+\t{\n+\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (src, srceltindex++);\n+\t  tmpword |= ebitmap_array_get (dst, dsteltindex);\n+\t  if (!changed)\n+\t    changed |= tmpword != ebitmap_array_get (dst, dsteltindex);\n+\t  dsteltindex++;\n+\t  newarray[neweltindex++] = tmpword;\n+\t}\n+      else if (dsthasword)\n+\t{\n+\t  newarray [neweltindex++] = ebitmap_array_get (dst, dsteltindex++);\n+\t}\n+      else\n+\t{\n+\t  newarray [neweltindex++] = ebitmap_array_get (src, srceltindex++);\n+\t  gcc_assert (i < dst->wordmask->n_bits);\n+\t  SET_BIT (dst->wordmask, i);\n+\t  changed |= true;\n+\t}\n+    }\n+\n+  sbitmap_free (tempmask);\n+  if (changed)\n+    {\n+      dst->numwords = neweltindex;\n+      free (dst->elts);\n+      dst->elts = newarray;\n+      dst->n_elts = newarraysize;\n+    }\n+  else\n+    free (newarray);\n+\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    ebitmap_iterator ebi;\n+    unsigned int i;\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (src, 0, i, ebi)\n+      gcc_assert (ebitmap_bit_p (dst, i));\n+    EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n+      gcc_assert (ebitmap_bit_p (dst, i));\n+\n+    verify_popcount (dst->wordmask);\n+    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+    gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n+  }\n+#endif\n+  return changed;\n+}\n+\n+/* Perform the operation DST = SRC1 | SRC2.  Return true if any bit\n+   in DST has changed.  */\n+\n+bool\n+ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n+{\n+  unsigned int src1size = src1->wordmask->n_bits;\n+  unsigned int src2size = src2->wordmask->n_bits;\n+  sbitmap_iterator sbi;\n+  unsigned int i;\n+  sbitmap tempmask;\n+  unsigned int neweltindex = 0;\n+  unsigned int src1eltindex = 0;\n+  unsigned int src2eltindex = 0;\n+  bool changed = false;\n+  EBITMAP_ELT_TYPE *newarray;\n+  unsigned int newarraysize;\n+#ifdef EBITMAP_DEBUGGING\n+  ebitmap dstcopy = ebitmap_alloc (1);\n+  ebitmap_copy (dstcopy, dst);\n+#endif\n+\n+  dst->cache = NULL;\n+  tempmask = sbitmap_alloc_with_popcount (MAX (src1size, src2size));\n+  sbitmap_zero (tempmask);\n+  if (src1size == src2size)\n+    {\n+      sbitmap_a_or_b (tempmask, src1->wordmask, src2->wordmask);\n+    }\n+  else\n+    {\n+      if (src1size >= src2size)\n+\t{\n+\t  sbitmap_copy_n (tempmask, src2->wordmask, src2->wordmask->size);\n+\t  sbitmap_a_or_b (tempmask, tempmask, src1->wordmask);\n+\t}\n+      else\n+\t{\n+\t  sbitmap_copy_n (tempmask, src1->wordmask, src1->wordmask->size);\n+\t  sbitmap_a_or_b (tempmask, tempmask, src2->wordmask);\n+\t}\n+    }\n+  newarraysize = src1->numwords + src2->numwords;\n+  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (tempmask, 0, i, sbi)\n+    {\n+      bool src1hasword, src2hasword;\n+      EBITMAP_ELT_TYPE tmpword;\n+      src1hasword = (i < src1->wordmask->n_bits\n+\t\t    && TEST_BIT (src1->wordmask, i));\n+      src2hasword = (i < src2->wordmask->n_bits\n+\t\t    && TEST_BIT (src2->wordmask, i));\n+\n+      if (src1hasword && src2hasword)\n+\t{\n+\t  tmpword = (ebitmap_array_get (src1, src1eltindex++)\n+\t\t     | ebitmap_array_get (src2, src2eltindex++));\n+\t  newarray[neweltindex++] = tmpword;\n+\t}\n+      else if (src1hasword)\n+\t{\n+\t  tmpword = ebitmap_array_get (src1, src1eltindex++);\n+\t  newarray [neweltindex++] = tmpword;\n+\t}\n+      else\n+\t{\n+\t  tmpword = ebitmap_array_get (src2, src2eltindex++);\n+\t  newarray [neweltindex++] = tmpword;\n+\t}\n+\n+      if (i >= dst->wordmask->n_bits || !TEST_BIT (dst->wordmask, i))\n+\t{\n+\t  changed = true;\n+\t}\n+      else if (!changed)\n+\t{\n+\t  unsigned int count = sbitmap_popcount (dst->wordmask, i);\n+\t  changed |= ebitmap_array_get (dst, count) != tmpword;\n+\t}\n+    }\n+\n+  if (changed)\n+    {\n+      sbitmap_free (dst->wordmask);\n+      dst->wordmask = tempmask;\n+      dst->numwords = neweltindex;\n+      free (dst->elts);\n+      dst->elts = newarray;\n+      dst->n_elts = newarraysize;\n+    }\n+  else\n+    {\n+      sbitmap_free (tempmask);\n+      free (newarray);\n+    }\n+\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    ebitmap_iterator ebi;\n+    unsigned int i;\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n+      gcc_assert (ebitmap_bit_p (dst, i));\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (src2, 0, i, ebi)\n+      gcc_assert (ebitmap_bit_p (dst, i));\n+  }\n+  verify_popcount (dst->wordmask);\n+  gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+  gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\tdst->wordmask->n_bits) == dst->numwords);\n+#endif\n+\n+  return changed;\n+}\n+\n+/* Perform the operation DST &= ~SRC.  Return true if any bit in DST\n+   has changed.  */\n+\n+bool\n+ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n+{\n+  bool changed = false;\n+  unsigned int i;\n+  unsigned int neweltindex = 0;\n+  unsigned int dsteltindex = 0;\n+  sbitmap_iterator sbi;\n+#ifdef EBITMAP_DEBUGGING\n+  ebitmap dstcopy = ebitmap_alloc (1);\n+  ebitmap_copy (dstcopy, dst);\n+#endif\n+\n+  gcc_assert (dst != src);\n+  dst->cache = NULL;\n+  if (src->numwords == 0)\n+    return false;\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (dst->wordmask, 0, i, sbi)\n+    {\n+      bool srchasword;\n+\n+      srchasword = (i < src->wordmask->n_bits\n+\t\t    && TEST_BIT (src->wordmask, i));\n+\n+      if (srchasword)\n+\t{\n+\t  unsigned int srccount = sbitmap_popcount (src->wordmask, i);\n+\t  EBITMAP_ELT_TYPE tmpword = ebitmap_array_get (dst, dsteltindex);\n+\t  tmpword &= ~(ebitmap_array_get (src, srccount));\n+\t  if (!changed)\n+\t    changed |= ebitmap_array_get (dst, dsteltindex) != tmpword;\n+\t  dsteltindex++;\n+\t  if (tmpword != 0)\n+\t    {\n+\t      EBITMAP_ELT_TYPE *dstplace;\n+\t      dstplace = ebitmap_array_grow_get (dst, neweltindex++);\n+\t      *dstplace = tmpword;\n+\t    }\n+\t  else\n+\t    RESET_BIT (dst->wordmask, i);\n+\t}\n+      else\n+\t{\n+\t  dsteltindex++;\n+\t  neweltindex++;\n+\t}\n+    }\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    unsigned int i;\n+    ebitmap_iterator ebi;\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n+      {\n+\tif (!ebitmap_bit_p (src, i))\n+\t  gcc_assert (ebitmap_bit_p (dst, i));\n+      }\n+\n+    for (i = 0; i <  dst->numwords; i++)\n+      gcc_assert (dst->elts[i] != 0);\n+\n+    gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\t  dst->wordmask->n_bits) == neweltindex);\n+    verify_popcount (dst->wordmask);\n+    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+    gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n+  }\n+#endif\n+  dst->numwords = neweltindex;\n+  /* sbitmap_popcount (dst->wordmask, -1); */\n+\n+  return changed;\n+}\n+\n+/* Perform the operation DST = SRC1 & ~SRC2.  Return true if any bit\n+   in DST has changed.  */\n+\n+bool\n+ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n+{\n+  unsigned int src1size = src1->wordmask->n_bits;\n+  sbitmap_iterator sbi;\n+  unsigned int i;\n+  sbitmap tempmask;\n+  unsigned int neweltindex = 0;\n+  unsigned int src1eltindex = 0;\n+  bool changed = false;\n+  EBITMAP_ELT_TYPE *newarray;\n+  unsigned int newarraysize;\n+\n+  /* XXX: Optimize like the into version.  */\n+  dst->cache = NULL;\n+  tempmask = sbitmap_alloc_with_popcount (src1size);\n+  sbitmap_zero (tempmask);\n+  sbitmap_copy (tempmask, src1->wordmask);\n+\n+  newarraysize = src1->numwords;\n+  newarray = xmalloc (newarraysize * sizeof (EBITMAP_ELT_TYPE));\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (src1->wordmask, 0, i, sbi)\n+    {\n+      bool src2hasword;\n+      EBITMAP_ELT_TYPE tmpword;\n+\n+      src2hasword = (i < src2->wordmask->n_bits\n+\t\t     && TEST_BIT (src2->wordmask, i));\n+\n+      if (src2hasword)\n+\t{\n+\t  unsigned int src2count = sbitmap_popcount (src2->wordmask, i);\n+\t  tmpword = ebitmap_array_get (src1, src1eltindex++)\n+\t            & ~(ebitmap_array_get (src2, src2count));\n+\t  if (tmpword)\n+\t    {\n+\t      newarray[neweltindex++] = tmpword;\n+\t    }\n+\t  else\n+\t    RESET_BIT (tempmask, i);\n+\n+\t}\n+      else\n+\t{\n+\t  tmpword = ebitmap_array_get (src1, src1eltindex++);\n+\t  gcc_assert (tmpword != 0);\n+\t  newarray[neweltindex++] = tmpword;\n+\t}\n+\n+      if (i >= dst->wordmask->n_bits || !TEST_BIT (dst->wordmask, i))\n+\t{\n+\t  changed = true;\n+\t}\n+      else if (!changed)\n+\t{\n+\t  unsigned int count = sbitmap_popcount (dst->wordmask, i);\n+\t  changed |= ebitmap_array_get (dst, count) != tmpword;\n+\t}\n+    }\n+  if (changed)\n+    {\n+      sbitmap_free (dst->wordmask);\n+      dst->wordmask = tempmask;\n+      dst->numwords = neweltindex;\n+      free (dst->elts);\n+      dst->elts = newarray;\n+      dst->n_elts = newarraysize;\n+    }\n+  else\n+    {\n+      free (tempmask);\n+      free (newarray);\n+    }\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    unsigned int i;\n+    ebitmap_iterator ebi;\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n+      {\n+\tif (!ebitmap_bit_p (src2, i))\n+\t  gcc_assert (ebitmap_bit_p (dst, i));\n+      }\n+  for (i = 0; i <  dst->numwords; i++)\n+    gcc_assert (dst->elts[i] != 0);\n+\n+  verify_popcount (dst->wordmask);\n+  gcc_assert (sbitmap_popcount (dst->wordmask,\n+\t\t\t\tdst->wordmask->n_bits) == dst->numwords);\n+  }\n+#endif\n+  return changed;\n+}\n+\n+/* Perform the operation DST = A | (B & ~C).  */\n+\n+bool\n+ebitmap_ior_and_compl (ebitmap dst, ebitmap a, ebitmap b, ebitmap c)\n+{\n+  bool changed;\n+  ebitmap temp = ebitmap_alloc (1);\n+#ifdef EBITMAP_DEBUGGING\n+  ebitmap dstcopy = ebitmap_alloc (1);\n+  ebitmap_copy (dstcopy, dst);\n+#endif\n+\n+  dst->cache = NULL;\n+  ebitmap_and_compl (temp, b, c);\n+  changed = ebitmap_ior (dst, a, temp);\n+#ifdef EBITMAP_DEBUGGING\n+  {\n+    ebitmap_iterator ebi;\n+    unsigned int i;\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (a, 0, i, ebi)\n+      gcc_assert (ebitmap_bit_p (dst, i));\n+\n+    EXECUTE_IF_SET_IN_EBITMAP (b, 0, i, ebi)\n+      if (!ebitmap_bit_p (c, i))\n+\tgcc_assert (ebitmap_bit_p (dst, i));\n+    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+  }\n+#endif\n+  ebitmap_free (temp);\n+\n+  return changed;\n+}\n+\n+/* Return true if ebitmap DST is equal to ebitmap SRC.  */\n+\n+bool\n+ebitmap_equal_p (ebitmap dst, ebitmap src)\n+{\n+  unsigned int which = MIN (dst->wordmask->size, src->wordmask->size);\n+\n+  if (dst->numwords != src->numwords)\n+    return false;\n+\n+  /* sbitmap_equal compares up to the size of the first argument, so\n+     if the two sbitmaps are not equally sized, we need to pass the\n+     smaller one as the first argument, or it will crash.  */\n+  if (which == dst->wordmask->size\n+      && !sbitmap_equal (dst->wordmask, src->wordmask))\n+    return false;\n+  else if (which == src->wordmask->size\n+\t   && !sbitmap_equal (src->wordmask, dst->wordmask))\n+    return false;\n+\n+  return memcmp (dst->elts, src->elts,\n+\t\t dst->numwords * sizeof (EBITMAP_ELT_TYPE)) == 0;\n+  return true;\n+}"}, {"sha": "175c9110912ddb21070e4ea0eebffb1f6f5d46bc", "filename": "gcc/ebitmap.h", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a853de222e54e809b3e1b09d75400e0c80687e/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=53a853de222e54e809b3e1b09d75400e0c80687e", "patch": "@@ -0,0 +1,165 @@\n+/* Sparse array based bitmaps.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef GCC_EBITMAP_H\n+#define GCC_EBITMAP_H\n+\n+#include \"sbitmap.h\"\n+\n+#define EBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n+#define EBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n+\n+typedef struct ebitmap_def\n+{  \n+  unsigned int n_elts;\t\t/* number of elements in the array.  */\n+  sbitmap wordmask;\t\t/* wordmask saying which words are\n+\t\t\t\t   non-zero.  */\n+  unsigned int numwords;\t/* number of non-zero words.  */\n+  unsigned int cacheindex;\t/* which word cache is.  */\n+  EBITMAP_ELT_TYPE *elts;\t/* non-zero element array.  */\n+  EBITMAP_ELT_TYPE *cache;\t/* last tested element, or NULL.  */\n+} *ebitmap;\n+\n+\n+#define ebitmap_empty_p(MAP) ((MAP)->numwords == 0)\n+#define ebitmap_free(MAP)  (free((MAP)->elts), \\\n+\t\t\t    sbitmap_free ((MAP)->wordmask),\t\\\n+\t\t\t    free((MAP)))\n+\n+extern void ebitmap_set_bit (ebitmap, unsigned int);\n+extern void ebitmap_clear_bit (ebitmap, unsigned int);\n+extern bool ebitmap_bit_p (ebitmap, unsigned int);\n+extern void dump_ebitmap (FILE *, ebitmap);\n+extern void dump_ebitmap_file (FILE *, ebitmap);\n+extern void dump_ebitmap_vector (FILE *, const char *, const char *, ebitmap *,\n+\t\t\t\t int);\n+extern ebitmap ebitmap_alloc (unsigned int);\n+extern ebitmap *ebitmap_vector_alloc (unsigned int, unsigned int);\n+extern void ebitmap_copy (ebitmap, ebitmap);\n+extern void ebitmap_and (ebitmap, ebitmap, ebitmap);\n+extern void ebitmap_and_into (ebitmap, ebitmap);\n+extern bool ebitmap_and_compl (ebitmap, ebitmap, ebitmap);\n+extern bool ebitmap_and_compl_into (ebitmap, ebitmap);\n+extern bool ebitmap_ior_into (ebitmap, ebitmap);\n+extern bool ebitmap_ior (ebitmap, ebitmap, ebitmap);\n+extern bool ebitmap_ior_and_compl (ebitmap, ebitmap, ebitmap, ebitmap);\n+extern bool ebitmap_ior_and_compl_into (ebitmap, ebitmap, ebitmap);\n+extern bool ebitmap_equal_p (ebitmap, ebitmap);\n+extern void ebitmap_clear (ebitmap);\n+extern int ebitmap_last_set_bit (ebitmap);\n+extern void debug_ebitmap (ebitmap);\n+extern void dump_ebitmap (FILE *, ebitmap);\n+extern unsigned long ebitmap_popcount(ebitmap, unsigned long);\n+\n+/* The iterator for ebitmap.  */\n+typedef struct {\n+  /* The pointer to the first word of the bitmap.  */\n+  EBITMAP_ELT_TYPE *ptr;\n+\n+  /* Element number inside ptr that we are at.  */\n+  unsigned int eltnum;\n+\n+  /* The size of the bitmap.  */\n+  unsigned int size;\n+\n+  /* Current bit index.  */\n+  unsigned int bit_num;\n+\n+  /* The words currently visited.  */\n+  EBITMAP_ELT_TYPE word;\n+\n+  /* The word mask iterator.  */\n+  sbitmap_iterator maskiter;\n+} ebitmap_iterator;\n+  \n+static inline void\n+ebitmap_iter_init (ebitmap_iterator *i, ebitmap bmp, unsigned int min)\n+{\n+  sbitmap_iter_init (&i->maskiter, bmp->wordmask, \n+\t\t     min / EBITMAP_ELT_BITS);\n+  i->size = bmp->numwords;\n+  if (i->size == 0)\n+    return;\n+  i->ptr = bmp->elts;\n+  i->bit_num = min;\n+  i->eltnum = 0;\n+\n+  if ((min / EBITMAP_ELT_BITS) >= bmp->wordmask->n_bits)\n+    {\n+      i->word = 0;\n+    }\n+  else\n+    {\n+      if (TEST_BIT (bmp->wordmask, min / EBITMAP_ELT_BITS) == 0)\n+\ti->word = 0;\n+      else\n+\t{\n+\t  unsigned int wordindex = min / EBITMAP_ELT_BITS;\n+\t  unsigned int count = sbitmap_popcount (bmp->wordmask, wordindex);\n+\t  i->word = i->ptr[count] >> (i->bit_num % (unsigned int)EBITMAP_ELT_BITS);\n+\t  i->eltnum = count + 1;\n+\t}\n+    }\n+}\n+\n+static inline bool\n+ebitmap_iter_cond (ebitmap_iterator *i, unsigned int *n)\n+{\n+  unsigned int ourn;\n+\n+  if (i->size == 0)\n+    return false;\n+\n+  if (i->word == 0)\n+    {\n+      sbitmap_iter_next (&i->maskiter);\n+      if (!sbitmap_iter_cond (&i->maskiter, &ourn))\n+\treturn false;\n+      i->bit_num = ourn * EBITMAP_ELT_BITS;\n+      i->word = i->ptr[i->eltnum++];\n+    }\n+\n+  /* Skip bits that are zero.  */\n+\n+  for (; (i->word & 1) == 0; i->word >>= 1)\n+    i->bit_num++;\n+\n+  *n = i->bit_num;\n+  return true;\n+}\n+\n+static inline void\n+ebitmap_iter_next (ebitmap_iterator *i)\n+{\n+  i->word >>= 1;\n+  i->bit_num++;\n+}\n+\n+/* Loop over all elements of EBITMAP, starting with MIN.  In each\n+   iteration, N is set to the index of the bit being visited.  ITER is\n+   an instance of ebitmap_iterator used to iterate the bitmap.  */\n+\n+#define EXECUTE_IF_SET_IN_EBITMAP(EBITMAP, MIN, N, ITER)\t\\\n+  for (ebitmap_iter_init (&(ITER), (EBITMAP), (MIN));\t\t\\\n+       ebitmap_iter_cond (&(ITER), &(N));\t\t\t\\\n+       ebitmap_iter_next (&(ITER)))\n+\n+\n+#endif /* ! GCC_EBITMAP_H */"}]}