{"sha": "4250754eea1c10c88f49c9f11b9f912f992b7c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI1MDc1NGVlYTFjMTBjODhmNDljOWYxMWI5ZjkxMmY5OTJiN2M0Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-12-02T19:04:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-12-02T19:04:38Z"}, "message": "Define c_fully_fold separately for C and C++.\n\ngcc/c-family/\n\t* c-common.c (c_disable_warnings, c_enable_warnings, c_fully_fold)\n\t(c_fully_fold_internal, decl_constant_value_for_optimization):\n\tMove to c/c-fold.c.\n\t* c-common.h: Don't declare decl_constant_value_for_optimization.\ngcc/c/\n\t* c-fold.c (c_disable_warnings, c_enable_warnings, c_fully_fold)\n\t(c_fully_fold_internal, decl_constant_value_for_optimization):\n\tMove from c-common.c.\n\t* c-tree.h: Declare decl_constant_value_for_optimization.\n\t* Make-lang.in (C_AND_OBJC_OBJS): Add c-fold.o.\ngcc/cp/\n\t* cp-gimplify.c (c_fully_fold): Define.\n\nFrom-SVN: r231196", "tree": {"sha": "08c85cdc811c8da6f75b43930fc94de70352d1ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08c85cdc811c8da6f75b43930fc94de70352d1ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4250754eea1c10c88f49c9f11b9f912f992b7c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4250754eea1c10c88f49c9f11b9f912f992b7c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4250754eea1c10c88f49c9f11b9f912f992b7c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4250754eea1c10c88f49c9f11b9f912f992b7c42/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9ea372d08324b38acbc7234e803f8f128c439b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ea372d08324b38acbc7234e803f8f128c439b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ea372d08324b38acbc7234e803f8f128c439b8"}], "stats": {"total": 1200, "additions": 621, "deletions": 579}, "files": [{"sha": "e32635fe5b14e1e443c788118e5e25753b50e73d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -1,3 +1,10 @@\n+2015-12-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-common.c (c_disable_warnings, c_enable_warnings, c_fully_fold)\n+\t(c_fully_fold_internal, decl_constant_value_for_optimization):\n+\tMove to c/c-fold.c.\n+\t* c-common.h: Don't declare decl_constant_value_for_optimization.\n+\n 2015-12-02  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/68162"}, {"sha": "40f86e3ab55231da2c373d8a1306a1d66f333fa9", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 577, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -299,7 +299,6 @@ const struct fname_var_t fname_vars[] =\n /* Global visibility options.  */\n struct visibility_flags visibility_options;\n \n-static tree c_fully_fold_internal (tree expr, bool, bool *, bool *, bool);\n static tree check_case_value (location_t, tree);\n static bool check_case_bounds (location_t, tree, tree, tree *, tree *,\n \t\t\t       bool *);\n@@ -1095,582 +1094,6 @@ fix_string_type (tree value)\n   return value;\n }\n \f\n-/* If DISABLE is true, stop issuing warnings.  This is used when\n-   parsing code that we know will not be executed.  This function may\n-   be called multiple times, and works as a stack.  */\n-\n-static void\n-c_disable_warnings (bool disable)\n-{\n-  if (disable)\n-    {\n-      ++c_inhibit_evaluation_warnings;\n-      fold_defer_overflow_warnings ();\n-    }\n-}\n-\n-/* If ENABLE is true, reenable issuing warnings.  */\n-\n-static void\n-c_enable_warnings (bool enable)\n-{\n-  if (enable)\n-    {\n-      --c_inhibit_evaluation_warnings;\n-      fold_undefer_and_ignore_overflow_warnings ();\n-    }\n-}\n-\n-/* Fully fold EXPR, an expression that was not folded (beyond integer\n-   constant expressions and null pointer constants) when being built\n-   up.  If IN_INIT, this is in a static initializer and certain\n-   changes are made to the folding done.  Clear *MAYBE_CONST if\n-   MAYBE_CONST is not NULL and EXPR is definitely not a constant\n-   expression because it contains an evaluated operator (in C99) or an\n-   operator outside of sizeof returning an integer constant (in C90)\n-   not permitted in constant expressions, or because it contains an\n-   evaluated arithmetic overflow.  (*MAYBE_CONST should typically be\n-   set to true by callers before calling this function.)  Return the\n-   folded expression.  Function arguments have already been folded\n-   before calling this function, as have the contents of SAVE_EXPR,\n-   TARGET_EXPR, BIND_EXPR, VA_ARG_EXPR, OBJ_TYPE_REF and\n-   C_MAYBE_CONST_EXPR.  */\n-\n-tree\n-c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n-{\n-  tree ret;\n-  tree eptype = NULL_TREE;\n-  bool dummy = true;\n-  bool maybe_const_itself = true;\n-  location_t loc = EXPR_LOCATION (expr);\n-\n-  /* This function is not relevant to C++ because C++ folds while\n-     parsing, and may need changes to be correct for C++ when C++\n-     stops folding while parsing.  */\n-  if (c_dialect_cxx ())\n-    gcc_unreachable ();\n-\n-  if (!maybe_const)\n-    maybe_const = &dummy;\n-  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n-    {\n-      eptype = TREE_TYPE (expr);\n-      expr = TREE_OPERAND (expr, 0);\n-    }\n-  ret = c_fully_fold_internal (expr, in_init, maybe_const,\n-\t\t\t       &maybe_const_itself, false);\n-  if (eptype)\n-    ret = fold_convert_loc (loc, eptype, ret);\n-  *maybe_const &= maybe_const_itself;\n-  return ret;\n-}\n-\n-/* Internal helper for c_fully_fold.  EXPR and IN_INIT are as for\n-   c_fully_fold.  *MAYBE_CONST_OPERANDS is cleared because of operands\n-   not permitted, while *MAYBE_CONST_ITSELF is cleared because of\n-   arithmetic overflow (for C90, *MAYBE_CONST_OPERANDS is carried from\n-   both evaluated and unevaluated subexpressions while\n-   *MAYBE_CONST_ITSELF is carried from only evaluated\n-   subexpressions).  FOR_INT_CONST indicates if EXPR is an expression\n-   with integer constant operands, and if any of the operands doesn't\n-   get folded to an integer constant, don't fold the expression itself.  */\n-\n-static tree\n-c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n-\t\t       bool *maybe_const_itself, bool for_int_const)\n-{\n-  tree ret = expr;\n-  enum tree_code code = TREE_CODE (expr);\n-  enum tree_code_class kind = TREE_CODE_CLASS (code);\n-  location_t loc = EXPR_LOCATION (expr);\n-  tree op0, op1, op2, op3;\n-  tree orig_op0, orig_op1, orig_op2;\n-  bool op0_const = true, op1_const = true, op2_const = true;\n-  bool op0_const_self = true, op1_const_self = true, op2_const_self = true;\n-  bool nowarning = TREE_NO_WARNING (expr);\n-  bool unused_p;\n-  source_range old_range;\n-\n-  /* This function is not relevant to C++ because C++ folds while\n-     parsing, and may need changes to be correct for C++ when C++\n-     stops folding while parsing.  */\n-  if (c_dialect_cxx ())\n-    gcc_unreachable ();\n-\n-  /* Constants, declarations, statements, errors, SAVE_EXPRs and\n-     anything else not counted as an expression cannot usefully be\n-     folded further at this point.  */\n-  if (!IS_EXPR_CODE_CLASS (kind)\n-      || kind == tcc_statement\n-      || code == SAVE_EXPR)\n-    return expr;\n-\n-  if (IS_EXPR_CODE_CLASS (kind))\n-    old_range = EXPR_LOCATION_RANGE (expr);\n-\n-  /* Operands of variable-length expressions (function calls) have\n-     already been folded, as have __builtin_* function calls, and such\n-     expressions cannot occur in constant expressions.  */\n-  if (kind == tcc_vl_exp)\n-    {\n-      *maybe_const_operands = false;\n-      ret = fold (expr);\n-      goto out;\n-    }\n-\n-  if (code == C_MAYBE_CONST_EXPR)\n-    {\n-      tree pre = C_MAYBE_CONST_EXPR_PRE (expr);\n-      tree inner = C_MAYBE_CONST_EXPR_EXPR (expr);\n-      if (C_MAYBE_CONST_EXPR_NON_CONST (expr))\n-\t*maybe_const_operands = false;\n-      if (C_MAYBE_CONST_EXPR_INT_OPERANDS (expr))\n-\t{\n-\t  *maybe_const_itself = false;\n-\t  inner = c_fully_fold_internal (inner, in_init, maybe_const_operands,\n-\t\t\t\t\t maybe_const_itself, true);\n-\t}\n-      if (pre && !in_init)\n-\tret = build2 (COMPOUND_EXPR, TREE_TYPE (expr), pre, inner);\n-      else\n-\tret = inner;\n-      goto out;\n-    }\n-\n-  /* Assignment, increment, decrement, function call and comma\n-     operators, and statement expressions, cannot occur in constant\n-     expressions if evaluated / outside of sizeof.  (Function calls\n-     were handled above, though VA_ARG_EXPR is treated like a function\n-     call here, and statement expressions are handled through\n-     C_MAYBE_CONST_EXPR to avoid folding inside them.)  */\n-  switch (code)\n-    {\n-    case MODIFY_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case COMPOUND_EXPR:\n-      *maybe_const_operands = false;\n-      break;\n-\n-    case VA_ARG_EXPR:\n-    case TARGET_EXPR:\n-    case BIND_EXPR:\n-    case OBJ_TYPE_REF:\n-      *maybe_const_operands = false;\n-      ret = fold (expr);\n-      goto out;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Fold individual tree codes as appropriate.  */\n-  switch (code)\n-    {\n-    case COMPOUND_LITERAL_EXPR:\n-      /* Any non-constancy will have been marked in a containing\n-\t C_MAYBE_CONST_EXPR; there is no more folding to do here.  */\n-      goto out;\n-\n-    case COMPONENT_REF:\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      op1 = TREE_OPERAND (expr, 1);\n-      op2 = TREE_OPERAND (expr, 2);\n-      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n-\t\t\t\t   maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op0);\n-      if (op0 != orig_op0)\n-\tret = build3 (COMPONENT_REF, TREE_TYPE (expr), op0, op1, op2);\n-      if (ret != expr)\n-\t{\n-\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n-\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n-\t}\n-      goto out;\n-\n-    case ARRAY_REF:\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n-      op2 = TREE_OPERAND (expr, 2);\n-      op3 = TREE_OPERAND (expr, 3);\n-      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n-\t\t\t\t   maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op0);\n-      op1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n-\t\t\t\t   maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op1);\n-      op1 = decl_constant_value_for_optimization (op1);\n-      if (op0 != orig_op0 || op1 != orig_op1)\n-\tret = build4 (ARRAY_REF, TREE_TYPE (expr), op0, op1, op2, op3);\n-      if (ret != expr)\n-\t{\n-\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n-\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n-\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n-\t}\n-      ret = fold (ret);\n-      goto out;\n-\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case POINTER_PLUS_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case RDIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case BIT_AND_EXPR:\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case COMPLEX_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case UNORDERED_EXPR:\n-    case ORDERED_EXPR:\n-    case UNLT_EXPR:\n-    case UNLE_EXPR:\n-    case UNGT_EXPR:\n-    case UNGE_EXPR:\n-    case UNEQ_EXPR:\n-      /* Binary operations evaluating both arguments (increment and\n-\t decrement are binary internally in GCC).  */\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n-      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n-\t\t\t\t   maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op0);\n-      if (code != MODIFY_EXPR\n-\t  && code != PREDECREMENT_EXPR\n-\t  && code != PREINCREMENT_EXPR\n-\t  && code != POSTDECREMENT_EXPR\n-\t  && code != POSTINCREMENT_EXPR)\n-\top0 = decl_constant_value_for_optimization (op0);\n-      /* The RHS of a MODIFY_EXPR was fully folded when building that\n-\t expression for the sake of conversion warnings.  */\n-      if (code != MODIFY_EXPR)\n-\top1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n-\t\t\t\t     maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op1);\n-      op1 = decl_constant_value_for_optimization (op1);\n-\n-      if (for_int_const && (TREE_CODE (op0) != INTEGER_CST\n-\t\t\t    || TREE_CODE (op1) != INTEGER_CST))\n-\tgoto out;\n-\n-      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n-\tret = in_init\n-\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n-\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n-      else\n-\tret = fold (expr);\n-      if (TREE_OVERFLOW_P (ret)\n-\t  && !TREE_OVERFLOW_P (op0)\n-\t  && !TREE_OVERFLOW_P (op1))\n-\toverflow_warning (EXPR_LOC_OR_LOC (expr, input_location), ret);\n-      if (code == LSHIFT_EXPR\n-\t  && TREE_CODE (orig_op0) != INTEGER_CST\n-\t  && TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n-\t  && TREE_CODE (op0) == INTEGER_CST\n-\t  && c_inhibit_evaluation_warnings == 0\n-\t  && tree_int_cst_sgn (op0) < 0)\n-\twarning_at (loc, OPT_Wshift_negative_value,\n-\t\t    \"left shift of negative value\");\n-      if ((code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n-\t  && TREE_CODE (orig_op1) != INTEGER_CST\n-\t  && TREE_CODE (op1) == INTEGER_CST\n-\t  && (TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n-\t      || TREE_CODE (TREE_TYPE (orig_op0)) == FIXED_POINT_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE\n-\t  && c_inhibit_evaluation_warnings == 0)\n-\t{\n-\t  if (tree_int_cst_sgn (op1) < 0)\n-\t    warning_at (loc, OPT_Wshift_count_negative,\n-\t\t\t(code == LSHIFT_EXPR\n-\t\t\t ? G_(\"left shift count is negative\")\n-\t\t\t : G_(\"right shift count is negative\")));\n-\t  else if (compare_tree_int (op1,\n-\t\t\t\t     TYPE_PRECISION (TREE_TYPE (orig_op0)))\n-\t\t   >= 0)\n-\t    warning_at (loc, OPT_Wshift_count_overflow,\n-\t\t\t(code == LSHIFT_EXPR\n-\t\t\t ? G_(\"left shift count >= width of type\")\n-\t\t\t : G_(\"right shift count >= width of type\")));\n-\t}\n-      if (code == LSHIFT_EXPR\n-\t  /* If either OP0 has been folded to INTEGER_CST...  */\n-\t  && ((TREE_CODE (orig_op0) != INTEGER_CST\n-\t       && TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n-\t       && TREE_CODE (op0) == INTEGER_CST)\n-\t      /* ...or if OP1 has been folded to INTEGER_CST...  */\n-\t      || (TREE_CODE (orig_op1) != INTEGER_CST\n-\t\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE\n-\t\t  && TREE_CODE (op1) == INTEGER_CST))\n-\t  && c_inhibit_evaluation_warnings == 0)\n-\t/* ...then maybe we can detect an overflow.  */\n-\tmaybe_warn_shift_overflow (loc, op0, op1);\n-      if ((code == TRUNC_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == TRUNC_MOD_EXPR)\n-\t  && TREE_CODE (orig_op1) != INTEGER_CST\n-\t  && TREE_CODE (op1) == INTEGER_CST\n-\t  && (TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n-\t      || TREE_CODE (TREE_TYPE (orig_op0)) == FIXED_POINT_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE)\n-\twarn_for_div_by_zero (loc, op1);\n-      goto out;\n-\n-    case INDIRECT_REF:\n-    case FIX_TRUNC_EXPR:\n-    case FLOAT_EXPR:\n-    CASE_CONVERT:\n-    case ADDR_SPACE_CONVERT_EXPR:\n-    case VIEW_CONVERT_EXPR:\n-    case NON_LVALUE_EXPR:\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case ADDR_EXPR:\n-    case CONJ_EXPR:\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      /* Unary operations.  */\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n-\t\t\t\t   maybe_const_itself, for_int_const);\n-      STRIP_TYPE_NOPS (op0);\n-      if (code != ADDR_EXPR && code != REALPART_EXPR && code != IMAGPART_EXPR)\n-\top0 = decl_constant_value_for_optimization (op0);\n-\n-      if (for_int_const && TREE_CODE (op0) != INTEGER_CST)\n-\tgoto out;\n-\n-      /* ??? Cope with user tricks that amount to offsetof.  The middle-end is\n-\t not prepared to deal with them if they occur in initializers.  */\n-      if (op0 != orig_op0\n-\t  && code == ADDR_EXPR\n-\t  && (op1 = get_base_address (op0)) != NULL_TREE\n-\t  && INDIRECT_REF_P (op1)\n-\t  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))\n-\tret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));\n-      else if (op0 != orig_op0 || in_init)\n-\tret = in_init\n-\t  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)\n-\t  : fold_build1_loc (loc, code, TREE_TYPE (expr), op0);\n-      else\n-\tret = fold (expr);\n-      if (code == INDIRECT_REF\n-\t  && ret != expr\n-\t  && INDIRECT_REF_P (ret))\n-\t{\n-\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n-\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n-\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n-\t}\n-      switch (code)\n-\t{\n-\tcase FIX_TRUNC_EXPR:\n-\tcase FLOAT_EXPR:\n-\tCASE_CONVERT:\n-\t  /* Don't warn about explicit conversions.  We will already\n-\t     have warned about suspect implicit conversions.  */\n-\t  break;\n-\n-\tdefault:\n-\t  if (TREE_OVERFLOW_P (ret) && !TREE_OVERFLOW_P (op0))\n-\t    overflow_warning (EXPR_LOCATION (expr), ret);\n-\t  break;\n-\t}\n-      goto out;\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-      /* Binary operations not necessarily evaluating both\n-\t arguments.  */\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n-      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self,\n-\t\t\t\t   for_int_const);\n-      STRIP_TYPE_NOPS (op0);\n-\n-      unused_p = (op0 == (code == TRUTH_ANDIF_EXPR\n-\t\t\t  ? truthvalue_false_node\n-\t\t\t  : truthvalue_true_node));\n-      c_disable_warnings (unused_p);\n-      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self,\n-\t\t\t\t   for_int_const);\n-      STRIP_TYPE_NOPS (op1);\n-      c_enable_warnings (unused_p);\n-\n-      if (for_int_const\n-\t  && (TREE_CODE (op0) != INTEGER_CST\n-\t      /* Require OP1 be an INTEGER_CST only if it's evaluated.  */\n-\t      || (!unused_p && TREE_CODE (op1) != INTEGER_CST)))\n-\tgoto out;\n-\n-      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n-\tret = in_init\n-\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n-\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n-      else\n-\tret = fold (expr);\n-      *maybe_const_operands &= op0_const;\n-      *maybe_const_itself &= op0_const_self;\n-      if (!(flag_isoc99\n-\t    && op0_const\n-\t    && op0_const_self\n-\t    && (code == TRUTH_ANDIF_EXPR\n-\t\t? op0 == truthvalue_false_node\n-\t\t: op0 == truthvalue_true_node)))\n-\t*maybe_const_operands &= op1_const;\n-      if (!(op0_const\n-\t    && op0_const_self\n-\t    && (code == TRUTH_ANDIF_EXPR\n-\t\t? op0 == truthvalue_false_node\n-\t\t: op0 == truthvalue_true_node)))\n-\t*maybe_const_itself &= op1_const_self;\n-      goto out;\n-\n-    case COND_EXPR:\n-      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n-      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n-      orig_op2 = op2 = TREE_OPERAND (expr, 2);\n-      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self,\n-\t\t\t\t   for_int_const);\n-\n-      STRIP_TYPE_NOPS (op0);\n-      c_disable_warnings (op0 == truthvalue_false_node);\n-      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self,\n-\t\t\t\t   for_int_const);\n-      STRIP_TYPE_NOPS (op1);\n-      c_enable_warnings (op0 == truthvalue_false_node);\n-\n-      c_disable_warnings (op0 == truthvalue_true_node);\n-      op2 = c_fully_fold_internal (op2, in_init, &op2_const, &op2_const_self,\n-\t\t\t\t   for_int_const);\n-      STRIP_TYPE_NOPS (op2);\n-      c_enable_warnings (op0 == truthvalue_true_node);\n-\n-      if (for_int_const\n-\t  && (TREE_CODE (op0) != INTEGER_CST\n-\t      /* Only the evaluated operand must be an INTEGER_CST.  */\n-\t      || (op0 == truthvalue_true_node\n-\t\t  ? TREE_CODE (op1) != INTEGER_CST\n-\t\t  : TREE_CODE (op2) != INTEGER_CST)))\n-\tgoto out;\n-\n-      if (op0 != orig_op0 || op1 != orig_op1 || op2 != orig_op2)\n-\tret = fold_build3_loc (loc, code, TREE_TYPE (expr), op0, op1, op2);\n-      else\n-\tret = fold (expr);\n-      *maybe_const_operands &= op0_const;\n-      *maybe_const_itself &= op0_const_self;\n-      if (!(flag_isoc99\n-\t    && op0_const\n-\t    && op0_const_self\n-\t    && op0 == truthvalue_false_node))\n-\t*maybe_const_operands &= op1_const;\n-      if (!(op0_const\n-\t    && op0_const_self\n-\t    && op0 == truthvalue_false_node))\n-\t*maybe_const_itself &= op1_const_self;\n-      if (!(flag_isoc99\n-\t    && op0_const\n-\t    && op0_const_self\n-\t    && op0 == truthvalue_true_node))\n-\t*maybe_const_operands &= op2_const;\n-      if (!(op0_const\n-\t    && op0_const_self\n-\t    && op0 == truthvalue_true_node))\n-\t*maybe_const_itself &= op2_const_self;\n-      goto out;\n-\n-    case EXCESS_PRECISION_EXPR:\n-      /* Each case where an operand with excess precision may be\n-\t encountered must remove the EXCESS_PRECISION_EXPR around\n-\t inner operands and possibly put one around the whole\n-\t expression or possibly convert to the semantic type (which\n-\t c_fully_fold does); we cannot tell at this stage which is\n-\t appropriate in any particular case.  */\n-      gcc_unreachable ();\n-\n-    default:\n-      /* Various codes may appear through folding built-in functions\n-\t and their arguments.  */\n-      goto out;\n-    }\n-\n- out:\n-  /* Some folding may introduce NON_LVALUE_EXPRs; all lvalue checks\n-     have been done by this point, so remove them again.  */\n-  nowarning |= TREE_NO_WARNING (ret);\n-  STRIP_TYPE_NOPS (ret);\n-  if (nowarning && !TREE_NO_WARNING (ret))\n-    {\n-      if (!CAN_HAVE_LOCATION_P (ret))\n-\tret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n-      TREE_NO_WARNING (ret) = 1;\n-    }\n-  if (ret != expr)\n-    {\n-      protected_set_expr_location (ret, loc);\n-      if (IS_EXPR_CODE_CLASS (kind))\n-\tset_source_range (ret, old_range.m_start, old_range.m_finish);\n-    }\n-  return ret;\n-}\n-\n-/* If not optimizing, EXP is not a VAR_DECL, or EXP has array type,\n-   return EXP.  Otherwise, return either EXP or its known constant\n-   value (if it has one), but return EXP if EXP has mode BLKmode.  ???\n-   Is the BLKmode test appropriate?  */\n-\n-tree\n-decl_constant_value_for_optimization (tree exp)\n-{\n-  tree ret;\n-\n-  /* This function is only used by C, for c_fully_fold and other\n-     optimization, and may not be correct for C++.  */\n-  if (c_dialect_cxx ())\n-    gcc_unreachable ();\n-\n-  if (!optimize\n-      || !VAR_P (exp)\n-      || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n-      || DECL_MODE (exp) == BLKmode)\n-    return exp;\n-\n-  ret = decl_constant_value (exp);\n-  /* Avoid unwanted tree sharing between the initializer and current\n-     function's body where the tree can be modified e.g. by the\n-     gimplifier.  */\n-  if (ret != exp && TREE_STATIC (exp))\n-    ret = unshare_expr (ret);\n-  return ret;\n-}\n-\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n    requires to be a constant expression."}, {"sha": "ef64e6b1b4280d988e2810610c6a6b612dae8a55", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -809,7 +809,6 @@ extern enum conversion_safety unsafe_conversion_p (location_t, tree, tree,\n \t\t\t\t\t\t   bool);\n extern bool decl_with_nonnull_addr_p (const_tree);\n extern tree c_fully_fold (tree, bool, bool *);\n-extern tree decl_constant_value_for_optimization (tree);\n extern tree c_wrap_maybe_const (tree, bool);\n extern tree c_save_expr (tree);\n extern tree c_common_truthvalue_conversion (location_t, tree);"}, {"sha": "213c407b75eabb057cc6d91745339d523efdbf28", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -1,3 +1,11 @@\n+2015-12-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-fold.c (c_disable_warnings, c_enable_warnings, c_fully_fold)\n+\t(c_fully_fold_internal, decl_constant_value_for_optimization):\n+\tMove from c-common.c.\n+\t* c-tree.h: Declare decl_constant_value_for_optimization.\n+\t* Make-lang.in (C_AND_OBJC_OBJS): Add c-fold.o.\n+\n 2015-12-02  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/68162"}, {"sha": "b1d0e91b0ad8eb6b2baa83ca00d35c3b761a1629", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -51,7 +51,7 @@ CFLAGS-c/gccspec.o += $(DRIVER_DEFINES)\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c/c-errors.o c/c-decl.o c/c-typeck.o \\\n   c/c-convert.o c/c-aux-info.o c/c-objc-common.o c/c-parser.o \\\n-  c/c-array-notation.o $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n+  c/c-array-notation.o c/c-fold.o $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n C_OBJS = c/c-lang.o c-family/stub-objc.o $(C_AND_OBJC_OBJS)"}, {"sha": "c554e179d5598ececa3086e05ee994eec35a76e6", "filename": "gcc/c/c-fold.c", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2Fc-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2Fc-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-fold.c?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -0,0 +1,589 @@\n+/* Support for fully folding sub-trees of an expression for C compiler.\n+   Copyright (C) 1992-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"function.h\"\n+#include \"bitmap.h\"\n+#include \"c-tree.h\"\n+#include \"intl.h\"\n+#include \"gimplify.h\"\n+\n+static tree c_fully_fold_internal (tree expr, bool, bool *, bool *, bool);\n+\n+/* If DISABLE is true, stop issuing warnings.  This is used when\n+   parsing code that we know will not be executed.  This function may\n+   be called multiple times, and works as a stack.  */\n+\n+static void\n+c_disable_warnings (bool disable)\n+{\n+  if (disable)\n+    {\n+      ++c_inhibit_evaluation_warnings;\n+      fold_defer_overflow_warnings ();\n+    }\n+}\n+\n+/* If ENABLE is true, reenable issuing warnings.  */\n+\n+static void\n+c_enable_warnings (bool enable)\n+{\n+  if (enable)\n+    {\n+      --c_inhibit_evaluation_warnings;\n+      fold_undefer_and_ignore_overflow_warnings ();\n+    }\n+}\n+\n+/* Fully fold EXPR, an expression that was not folded (beyond integer\n+   constant expressions and null pointer constants) when being built\n+   up.  If IN_INIT, this is in a static initializer and certain\n+   changes are made to the folding done.  Clear *MAYBE_CONST if\n+   MAYBE_CONST is not NULL and EXPR is definitely not a constant\n+   expression because it contains an evaluated operator (in C99) or an\n+   operator outside of sizeof returning an integer constant (in C90)\n+   not permitted in constant expressions, or because it contains an\n+   evaluated arithmetic overflow.  (*MAYBE_CONST should typically be\n+   set to true by callers before calling this function.)  Return the\n+   folded expression.  Function arguments have already been folded\n+   before calling this function, as have the contents of SAVE_EXPR,\n+   TARGET_EXPR, BIND_EXPR, VA_ARG_EXPR, OBJ_TYPE_REF and\n+   C_MAYBE_CONST_EXPR.  */\n+\n+tree\n+c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n+{\n+  tree ret;\n+  tree eptype = NULL_TREE;\n+  bool dummy = true;\n+  bool maybe_const_itself = true;\n+  location_t loc = EXPR_LOCATION (expr);\n+\n+  if (!maybe_const)\n+    maybe_const = &dummy;\n+  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (expr);\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n+  ret = c_fully_fold_internal (expr, in_init, maybe_const,\n+\t\t\t       &maybe_const_itself, false);\n+  if (eptype)\n+    ret = fold_convert_loc (loc, eptype, ret);\n+  *maybe_const &= maybe_const_itself;\n+  return ret;\n+}\n+\n+/* Internal helper for c_fully_fold.  EXPR and IN_INIT are as for\n+   c_fully_fold.  *MAYBE_CONST_OPERANDS is cleared because of operands\n+   not permitted, while *MAYBE_CONST_ITSELF is cleared because of\n+   arithmetic overflow (for C90, *MAYBE_CONST_OPERANDS is carried from\n+   both evaluated and unevaluated subexpressions while\n+   *MAYBE_CONST_ITSELF is carried from only evaluated\n+   subexpressions).  FOR_INT_CONST indicates if EXPR is an expression\n+   with integer constant operands, and if any of the operands doesn't\n+   get folded to an integer constant, don't fold the expression itself.  */\n+\n+static tree\n+c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n+\t\t       bool *maybe_const_itself, bool for_int_const)\n+{\n+  tree ret = expr;\n+  enum tree_code code = TREE_CODE (expr);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n+  location_t loc = EXPR_LOCATION (expr);\n+  tree op0, op1, op2, op3;\n+  tree orig_op0, orig_op1, orig_op2;\n+  bool op0_const = true, op1_const = true, op2_const = true;\n+  bool op0_const_self = true, op1_const_self = true, op2_const_self = true;\n+  bool nowarning = TREE_NO_WARNING (expr);\n+  bool unused_p;\n+  source_range old_range;\n+\n+  /* Constants, declarations, statements, errors, SAVE_EXPRs and\n+     anything else not counted as an expression cannot usefully be\n+     folded further at this point.  */\n+  if (!IS_EXPR_CODE_CLASS (kind)\n+      || kind == tcc_statement\n+      || code == SAVE_EXPR)\n+    return expr;\n+\n+  if (IS_EXPR_CODE_CLASS (kind))\n+    old_range = EXPR_LOCATION_RANGE (expr);\n+\n+  /* Operands of variable-length expressions (function calls) have\n+     already been folded, as have __builtin_* function calls, and such\n+     expressions cannot occur in constant expressions.  */\n+  if (kind == tcc_vl_exp)\n+    {\n+      *maybe_const_operands = false;\n+      ret = fold (expr);\n+      goto out;\n+    }\n+\n+  if (code == C_MAYBE_CONST_EXPR)\n+    {\n+      tree pre = C_MAYBE_CONST_EXPR_PRE (expr);\n+      tree inner = C_MAYBE_CONST_EXPR_EXPR (expr);\n+      if (C_MAYBE_CONST_EXPR_NON_CONST (expr))\n+\t*maybe_const_operands = false;\n+      if (C_MAYBE_CONST_EXPR_INT_OPERANDS (expr))\n+\t{\n+\t  *maybe_const_itself = false;\n+\t  inner = c_fully_fold_internal (inner, in_init, maybe_const_operands,\n+\t\t\t\t\t maybe_const_itself, true);\n+\t}\n+      if (pre && !in_init)\n+\tret = build2 (COMPOUND_EXPR, TREE_TYPE (expr), pre, inner);\n+      else\n+\tret = inner;\n+      goto out;\n+    }\n+\n+  /* Assignment, increment, decrement, function call and comma\n+     operators, and statement expressions, cannot occur in constant\n+     expressions if evaluated / outside of sizeof.  (Function calls\n+     were handled above, though VA_ARG_EXPR is treated like a function\n+     call here, and statement expressions are handled through\n+     C_MAYBE_CONST_EXPR to avoid folding inside them.)  */\n+  switch (code)\n+    {\n+    case MODIFY_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case COMPOUND_EXPR:\n+      *maybe_const_operands = false;\n+      break;\n+\n+    case VA_ARG_EXPR:\n+    case TARGET_EXPR:\n+    case BIND_EXPR:\n+    case OBJ_TYPE_REF:\n+      *maybe_const_operands = false;\n+      ret = fold (expr);\n+      goto out;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Fold individual tree codes as appropriate.  */\n+  switch (code)\n+    {\n+    case COMPOUND_LITERAL_EXPR:\n+      /* Any non-constancy will have been marked in a containing\n+\t C_MAYBE_CONST_EXPR; there is no more folding to do here.  */\n+      goto out;\n+\n+    case COMPONENT_REF:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+      op2 = TREE_OPERAND (expr, 2);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op0);\n+      if (op0 != orig_op0)\n+\tret = build3 (COMPONENT_REF, TREE_TYPE (expr), op0, op1, op2);\n+      if (ret != expr)\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      goto out;\n+\n+    case ARRAY_REF:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op2 = TREE_OPERAND (expr, 2);\n+      op3 = TREE_OPERAND (expr, 3);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op0);\n+      op1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op1);\n+      op1 = decl_constant_value_for_optimization (op1);\n+      if (op0 != orig_op0 || op1 != orig_op1)\n+\tret = build4 (ARRAY_REF, TREE_TYPE (expr), op0, op1, op2, op3);\n+      if (ret != expr)\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      ret = fold (ret);\n+      goto out;\n+\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case COMPLEX_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+      /* Binary operations evaluating both arguments (increment and\n+\t decrement are binary internally in GCC).  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op0);\n+      if (code != MODIFY_EXPR\n+\t  && code != PREDECREMENT_EXPR\n+\t  && code != PREINCREMENT_EXPR\n+\t  && code != POSTDECREMENT_EXPR\n+\t  && code != POSTINCREMENT_EXPR)\n+\top0 = decl_constant_value_for_optimization (op0);\n+      /* The RHS of a MODIFY_EXPR was fully folded when building that\n+\t expression for the sake of conversion warnings.  */\n+      if (code != MODIFY_EXPR)\n+\top1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n+\t\t\t\t     maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op1);\n+      op1 = decl_constant_value_for_optimization (op1);\n+\n+      if (for_int_const && (TREE_CODE (op0) != INTEGER_CST\n+\t\t\t    || TREE_CODE (op1) != INTEGER_CST))\n+\tgoto out;\n+\n+      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n+\tret = in_init\n+\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n+      else\n+\tret = fold (expr);\n+      if (TREE_OVERFLOW_P (ret)\n+\t  && !TREE_OVERFLOW_P (op0)\n+\t  && !TREE_OVERFLOW_P (op1))\n+\toverflow_warning (EXPR_LOC_OR_LOC (expr, input_location), ret);\n+      if (code == LSHIFT_EXPR\n+\t  && TREE_CODE (orig_op0) != INTEGER_CST\n+\t  && TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n+\t  && TREE_CODE (op0) == INTEGER_CST\n+\t  && c_inhibit_evaluation_warnings == 0\n+\t  && tree_int_cst_sgn (op0) < 0)\n+\twarning_at (loc, OPT_Wshift_negative_value,\n+\t\t    \"left shift of negative value\");\n+      if ((code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+\t  && TREE_CODE (orig_op1) != INTEGER_CST\n+\t  && TREE_CODE (op1) == INTEGER_CST\n+\t  && (TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (orig_op0)) == FIXED_POINT_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE\n+\t  && c_inhibit_evaluation_warnings == 0)\n+\t{\n+\t  if (tree_int_cst_sgn (op1) < 0)\n+\t    warning_at (loc, OPT_Wshift_count_negative,\n+\t\t\t(code == LSHIFT_EXPR\n+\t\t\t ? G_(\"left shift count is negative\")\n+\t\t\t : G_(\"right shift count is negative\")));\n+\t  else if (compare_tree_int (op1,\n+\t\t\t\t     TYPE_PRECISION (TREE_TYPE (orig_op0)))\n+\t\t   >= 0)\n+\t    warning_at (loc, OPT_Wshift_count_overflow,\n+\t\t\t(code == LSHIFT_EXPR\n+\t\t\t ? G_(\"left shift count >= width of type\")\n+\t\t\t : G_(\"right shift count >= width of type\")));\n+\t}\n+      if (code == LSHIFT_EXPR\n+\t  /* If either OP0 has been folded to INTEGER_CST...  */\n+\t  && ((TREE_CODE (orig_op0) != INTEGER_CST\n+\t       && TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n+\t       && TREE_CODE (op0) == INTEGER_CST)\n+\t      /* ...or if OP1 has been folded to INTEGER_CST...  */\n+\t      || (TREE_CODE (orig_op1) != INTEGER_CST\n+\t\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE\n+\t\t  && TREE_CODE (op1) == INTEGER_CST))\n+\t  && c_inhibit_evaluation_warnings == 0)\n+\t/* ...then maybe we can detect an overflow.  */\n+\tmaybe_warn_shift_overflow (loc, op0, op1);\n+      if ((code == TRUNC_DIV_EXPR\n+\t   || code == CEIL_DIV_EXPR\n+\t   || code == FLOOR_DIV_EXPR\n+\t   || code == EXACT_DIV_EXPR\n+\t   || code == TRUNC_MOD_EXPR)\n+\t  && TREE_CODE (orig_op1) != INTEGER_CST\n+\t  && TREE_CODE (op1) == INTEGER_CST\n+\t  && (TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (orig_op0)) == FIXED_POINT_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (orig_op1)) == INTEGER_TYPE)\n+\twarn_for_div_by_zero (loc, op1);\n+      goto out;\n+\n+    case INDIRECT_REF:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    CASE_CONVERT:\n+    case ADDR_SPACE_CONVERT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case CONJ_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      /* Unary operations.  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself, for_int_const);\n+      STRIP_TYPE_NOPS (op0);\n+      if (code != ADDR_EXPR && code != REALPART_EXPR && code != IMAGPART_EXPR)\n+\top0 = decl_constant_value_for_optimization (op0);\n+\n+      if (for_int_const && TREE_CODE (op0) != INTEGER_CST)\n+\tgoto out;\n+\n+      /* ??? Cope with user tricks that amount to offsetof.  The middle-end is\n+\t not prepared to deal with them if they occur in initializers.  */\n+      if (op0 != orig_op0\n+\t  && code == ADDR_EXPR\n+\t  && (op1 = get_base_address (op0)) != NULL_TREE\n+\t  && INDIRECT_REF_P (op1)\n+\t  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))\n+\tret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));\n+      else if (op0 != orig_op0 || in_init)\n+\tret = in_init\n+\t  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)\n+\t  : fold_build1_loc (loc, code, TREE_TYPE (expr), op0);\n+      else\n+\tret = fold (expr);\n+      if (code == INDIRECT_REF\n+\t  && ret != expr\n+\t  && INDIRECT_REF_P (ret))\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      switch (code)\n+\t{\n+\tcase FIX_TRUNC_EXPR:\n+\tcase FLOAT_EXPR:\n+\tCASE_CONVERT:\n+\t  /* Don't warn about explicit conversions.  We will already\n+\t     have warned about suspect implicit conversions.  */\n+\t  break;\n+\n+\tdefault:\n+\t  if (TREE_OVERFLOW_P (ret) && !TREE_OVERFLOW_P (op0))\n+\t    overflow_warning (EXPR_LOCATION (expr), ret);\n+\t  break;\n+\t}\n+      goto out;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      /* Binary operations not necessarily evaluating both\n+\t arguments.  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self,\n+\t\t\t\t   for_int_const);\n+      STRIP_TYPE_NOPS (op0);\n+\n+      unused_p = (op0 == (code == TRUTH_ANDIF_EXPR\n+\t\t\t  ? truthvalue_false_node\n+\t\t\t  : truthvalue_true_node));\n+      c_disable_warnings (unused_p);\n+      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self,\n+\t\t\t\t   for_int_const);\n+      STRIP_TYPE_NOPS (op1);\n+      c_enable_warnings (unused_p);\n+\n+      if (for_int_const\n+\t  && (TREE_CODE (op0) != INTEGER_CST\n+\t      /* Require OP1 be an INTEGER_CST only if it's evaluated.  */\n+\t      || (!unused_p && TREE_CODE (op1) != INTEGER_CST)))\n+\tgoto out;\n+\n+      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n+\tret = in_init\n+\t  ? fold_build2_initializer_loc (loc, code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2_loc (loc, code, TREE_TYPE (expr), op0, op1);\n+      else\n+\tret = fold (expr);\n+      *maybe_const_operands &= op0_const;\n+      *maybe_const_itself &= op0_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && (code == TRUTH_ANDIF_EXPR\n+\t\t? op0 == truthvalue_false_node\n+\t\t: op0 == truthvalue_true_node)))\n+\t*maybe_const_operands &= op1_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && (code == TRUTH_ANDIF_EXPR\n+\t\t? op0 == truthvalue_false_node\n+\t\t: op0 == truthvalue_true_node)))\n+\t*maybe_const_itself &= op1_const_self;\n+      goto out;\n+\n+    case COND_EXPR:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      orig_op2 = op2 = TREE_OPERAND (expr, 2);\n+      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self,\n+\t\t\t\t   for_int_const);\n+\n+      STRIP_TYPE_NOPS (op0);\n+      c_disable_warnings (op0 == truthvalue_false_node);\n+      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self,\n+\t\t\t\t   for_int_const);\n+      STRIP_TYPE_NOPS (op1);\n+      c_enable_warnings (op0 == truthvalue_false_node);\n+\n+      c_disable_warnings (op0 == truthvalue_true_node);\n+      op2 = c_fully_fold_internal (op2, in_init, &op2_const, &op2_const_self,\n+\t\t\t\t   for_int_const);\n+      STRIP_TYPE_NOPS (op2);\n+      c_enable_warnings (op0 == truthvalue_true_node);\n+\n+      if (for_int_const\n+\t  && (TREE_CODE (op0) != INTEGER_CST\n+\t      /* Only the evaluated operand must be an INTEGER_CST.  */\n+\t      || (op0 == truthvalue_true_node\n+\t\t  ? TREE_CODE (op1) != INTEGER_CST\n+\t\t  : TREE_CODE (op2) != INTEGER_CST)))\n+\tgoto out;\n+\n+      if (op0 != orig_op0 || op1 != orig_op1 || op2 != orig_op2)\n+\tret = fold_build3_loc (loc, code, TREE_TYPE (expr), op0, op1, op2);\n+      else\n+\tret = fold (expr);\n+      *maybe_const_operands &= op0_const;\n+      *maybe_const_itself &= op0_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_false_node))\n+\t*maybe_const_operands &= op1_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_false_node))\n+\t*maybe_const_itself &= op1_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_true_node))\n+\t*maybe_const_operands &= op2_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_true_node))\n+\t*maybe_const_itself &= op2_const_self;\n+      goto out;\n+\n+    case EXCESS_PRECISION_EXPR:\n+      /* Each case where an operand with excess precision may be\n+\t encountered must remove the EXCESS_PRECISION_EXPR around\n+\t inner operands and possibly put one around the whole\n+\t expression or possibly convert to the semantic type (which\n+\t c_fully_fold does); we cannot tell at this stage which is\n+\t appropriate in any particular case.  */\n+      gcc_unreachable ();\n+\n+    default:\n+      /* Various codes may appear through folding built-in functions\n+\t and their arguments.  */\n+      goto out;\n+    }\n+\n+ out:\n+  /* Some folding may introduce NON_LVALUE_EXPRs; all lvalue checks\n+     have been done by this point, so remove them again.  */\n+  nowarning |= TREE_NO_WARNING (ret);\n+  STRIP_TYPE_NOPS (ret);\n+  if (nowarning && !TREE_NO_WARNING (ret))\n+    {\n+      if (!CAN_HAVE_LOCATION_P (ret))\n+\tret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n+      TREE_NO_WARNING (ret) = 1;\n+    }\n+  if (ret != expr)\n+    {\n+      protected_set_expr_location (ret, loc);\n+      if (IS_EXPR_CODE_CLASS (kind))\n+\tset_source_range (ret, old_range.m_start, old_range.m_finish);\n+    }\n+  return ret;\n+}\n+\n+/* If not optimizing, EXP is not a VAR_DECL, or EXP has array type,\n+   return EXP.  Otherwise, return either EXP or its known constant\n+   value (if it has one), but return EXP if EXP has mode BLKmode.  ???\n+   Is the BLKmode test appropriate?  */\n+\n+tree\n+decl_constant_value_for_optimization (tree exp)\n+{\n+  tree ret;\n+\n+  if (!optimize\n+      || !VAR_P (exp)\n+      || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n+      || DECL_MODE (exp) == BLKmode)\n+    return exp;\n+\n+  ret = decl_constant_value (exp);\n+  /* Avoid unwanted tree sharing between the initializer and current\n+     function's body where the tree can be modified e.g. by the\n+     gimplifier.  */\n+  if (ret != exp && TREE_STATIC (exp))\n+    ret = unshare_expr (ret);\n+  return ret;\n+}"}, {"sha": "1c07065896aa5bb046d32fa1b89a2e3a02273190", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -728,4 +728,7 @@ extern void\n set_c_expr_source_range (c_expr *expr,\n \t\t\t source_range src_range);\n \n+/* In c-fold.c */\n+extern tree decl_constant_value_for_optimization (tree);\n+\n #endif /* ! GCC_C_TREE_H */"}, {"sha": "2f406bc39de7d9d19616adac994de433dbc0c21c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -1,5 +1,7 @@\n 2015-12-02  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-gimplify.c (c_fully_fold): Define.\n+\n \t* cp-gimplify.c (cp_fold): Use fold_build*.\n \n 2015-12-02  Joseph Myers  <joseph@codesourcery.com>"}, {"sha": "2c54d85248256cfb524a094c4ad16a68dbb55bf7", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4250754eea1c10c88f49c9f11b9f912f992b7c42/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4250754eea1c10c88f49c9f11b9f912f992b7c42", "patch": "@@ -1883,6 +1883,17 @@ cp_fully_fold (tree x)\n   return cp_fold (x);\n }\n \n+/* c-common interface to cp_fold.  If IN_INIT, this is in a static initializer\n+   and certain changes are made to the folding done.  Or should be (FIXME).  We\n+   never touch maybe_const, as it is only used for the C front-end\n+   C_MAYBE_CONST_EXPR.  */\n+\n+tree\n+c_fully_fold (tree x, bool /*in_init*/, bool */*maybe_const*/)\n+{\n+  return cp_fold (x);\n+}\n+\n static GTY((cache, deletable)) cache_map fold_cache;\n \n /*  This function tries to fold an expression X."}]}