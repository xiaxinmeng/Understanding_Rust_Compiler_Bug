{"sha": "2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQzY2Q1ZDVhYmNlZWY5M2UwMzJiN2Q5Y2Q3ODJiNzQwMTk0YWUwZQ==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-03-28T13:15:00Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-03-28T13:15:00Z"}, "message": "fold-const.c (tree_unary_nonnegative_warnv_p): Make it public.\n\n2008-03-28  Rafael Espindola  <espindola@google.com>\n\n\t* fold-const.c (tree_unary_nonnegative_warnv_p): Make it public.\n\t(tree_binary_nonnegative_warnv_p): Make it public.\n\t(tree_single_nonnegative_warnv_p): Make it public.\n\t(tree_invalid_nonnegative_warnv_p): Make it public.\n\t(tree_unary_nonzero_warnv_p): Make it public.\n\t(tree_binary_nonzero_warnv_p): Make it public\n\t(tree_single_nonzero_warnv_p): Make it public.\n\t* tree-vrp.c (vrp_evaluate_conditional_warnv_with_ops): New function.\n\t(extract_range_from_binary_expr): Split the expr argument.\n\t(extract_range_from_unary_expr): Split the expr argument.\n\t(extract_range_from_comparison): Split the expr argument.\n\t(extract_range_from_expr): Use the new aux functions.\n\t(vrp_evaluate_conditional_warnv): Use\n\tvrp_evaluate_conditional_warnv_with_ops.\n\t* tree.h (tree_unary_nonzero_warnv_p): Declare.\n\t(tree_binary_nonzero_warnv_p): Declare.\n\t(tree_single_nonzero_warnv_p): Declare.\n\t(tree_expr_nonzero_warnv_p): Declare.\n\t(tree_unary_nonnegative_warnv_p): Declare.\n\t(tree_binary_nonnegative_warnv_p): Declare.\n\t(tree_single_nonnegative_warnv_p): Declare.\n\t(tree_invalid_nonnegative_warnv_p): Declare.\n\nFrom-SVN: r133681", "tree": {"sha": "fa5450ccea2db5d27ae7d3c89e75865a446bf5d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa5450ccea2db5d27ae7d3c89e75865a446bf5d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/comments", "author": null, "committer": null, "parents": [{"sha": "2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab8dbf48ee7c2eba910ee25ee37afd40e259738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab8dbf48ee7c2eba910ee25ee37afd40e259738"}], "stats": {"total": 313, "additions": 183, "deletions": 130}, "files": [{"sha": "16590e4a9327f4c43cc545694044c99bbe0fd2eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "patch": "@@ -1,3 +1,28 @@\n+2008-03-28  Rafael Espindola  <espindola@google.com>\n+\n+\t* fold-const.c (tree_unary_nonnegative_warnv_p): Make it public.\n+\t(tree_binary_nonnegative_warnv_p): Make it public.\n+\t(tree_single_nonnegative_warnv_p): Make it public.\n+\t(tree_invalid_nonnegative_warnv_p): Make it public.\n+\t(tree_unary_nonzero_warnv_p): Make it public.\n+\t(tree_binary_nonzero_warnv_p): Make it public\n+\t(tree_single_nonzero_warnv_p): Make it public.\n+\t* tree-vrp.c (vrp_evaluate_conditional_warnv_with_ops): New function.\n+\t(extract_range_from_binary_expr): Split the expr argument.\n+\t(extract_range_from_unary_expr): Split the expr argument.\n+\t(extract_range_from_comparison): Split the expr argument.\n+\t(extract_range_from_expr): Use the new aux functions.\n+\t(vrp_evaluate_conditional_warnv): Use\n+\tvrp_evaluate_conditional_warnv_with_ops.\n+\t* tree.h (tree_unary_nonzero_warnv_p): Declare.\n+\t(tree_binary_nonzero_warnv_p): Declare.\n+\t(tree_single_nonzero_warnv_p): Declare.\n+\t(tree_expr_nonzero_warnv_p): Declare.\n+\t(tree_unary_nonnegative_warnv_p): Declare.\n+\t(tree_binary_nonnegative_warnv_p): Declare.\n+\t(tree_single_nonnegative_warnv_p): Declare.\n+\t(tree_invalid_nonnegative_warnv_p): Declare.\n+\n 2008-03-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/30317"}, {"sha": "5d5d7cf2b976c370c5f7f3c745d6953dcdc96225", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "patch": "@@ -13743,7 +13743,7 @@ tree_simple_nonnegative_warnv_p (enum tree_code code, tree type)\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \t\t\t\tbool *strict_overflow_p)\n {\n@@ -13813,7 +13813,7 @@ tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \t\t\t\t      tree op1, bool *strict_overflow_p)\n {\n@@ -13914,7 +13914,7 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n {\n   if (TYPE_UNSIGNED (TREE_TYPE (t)))\n@@ -13954,7 +13954,7 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n {\n   enum tree_code code = TREE_CODE (t);\n@@ -14243,7 +14243,7 @@ tree_expr_nonnegative_p (tree t)\n    is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n    change *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_unary_nonzero_warnv_p (enum tree_code code, tree type, tree op0,\n \t\t\t\t bool *strict_overflow_p)\n {\n@@ -14283,7 +14283,7 @@ tree_unary_nonzero_warnv_p (enum tree_code code, tree type, tree op0,\n    is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n    change *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_binary_nonzero_warnv_p (enum tree_code code,\n \t\t\t     tree type,\n \t\t\t     tree op0,\n@@ -14391,7 +14391,7 @@ tree_binary_nonzero_warnv_p (enum tree_code code,\n    is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n    change *STRICT_OVERFLOW_P.  */\n \n-static bool\n+bool\n tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n {\n   bool sub_strict_overflow_p;"}, {"sha": "cef22b20648a71aceb11edf41f2f136016b9f3ae", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 141, "deletions": 123, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "patch": "@@ -47,6 +47,8 @@ static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n static tree vrp_evaluate_conditional_warnv (tree, bool, bool *);\n+static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n+\t\t\t\t\t\t     tree, tree, bool, bool *);\n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n@@ -1792,11 +1794,12 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n    the ranges of each of its operands and the expression code.  */\n \n static void\n-extract_range_from_binary_expr (value_range_t *vr, tree expr)\n+extract_range_from_binary_expr (value_range_t *vr,\n+\t\t\t\tenum tree_code code,\n+\t\t\t\ttree expr_type, tree op0, tree op1)\n {\n-  enum tree_code code = TREE_CODE (expr);\n   enum value_range_type type;\n-  tree op0, op1, min, max;\n+  tree min, max;\n   int cmp;\n   value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n   value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n@@ -1827,15 +1830,13 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  op0 = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n     set_value_range_to_varying (&vr0);\n \n-  op1 = TREE_OPERAND (expr, 1);\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n@@ -1872,7 +1873,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n     }\n \n   /* Now evaluate the expression to determine the new range.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (expr))\n+  if (POINTER_TYPE_P (expr_type)\n       || POINTER_TYPE_P (TREE_TYPE (op0))\n       || POINTER_TYPE_P (TREE_TYPE (op1)))\n     {\n@@ -1883,9 +1884,9 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t     If both are null, then the result is null. Otherwise they\n \t     are varying.  */\n \t  if (range_is_nonnull (&vr0) && range_is_nonnull (&vr1))\n-\t    set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+\t    set_value_range_to_nonnull (vr, expr_type);\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n-\t    set_value_range_to_null (vr, TREE_TYPE (expr));\n+\t    set_value_range_to_null (vr, expr_type);\n \t  else\n \t    set_value_range_to_varying (vr);\n \n@@ -1895,9 +1896,9 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n       /* For pointer types, we are really only interested in asserting\n \t whether the expression evaluates to non-NULL.  */\n       if (range_is_nonnull (&vr0) || range_is_nonnull (&vr1))\n-\tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+\tset_value_range_to_nonnull (vr, expr_type);\n       else if (range_is_null (&vr0) && range_is_null (&vr1))\n-\tset_value_range_to_null (vr, TREE_TYPE (expr));\n+\tset_value_range_to_null (vr, expr_type);\n       else\n \tset_value_range_to_varying (vr);\n \n@@ -1922,7 +1923,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t\t  && integer_zerop (vr1.max))))\n \t{\n \t  type = VR_RANGE;\n-\t  min = max = build_int_cst (TREE_TYPE (expr), 0);\n+\t  min = max = build_int_cst (expr_type, 0);\n \t}\n       /* If one of the operands is one, we know that the whole\n \t expression evaluates one.  */\n@@ -1935,7 +1936,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t\t       && integer_onep (vr1.max))))\n \t{\n \t  type = VR_RANGE;\n-\t  min = max = build_int_cst (TREE_TYPE (expr), 1);\n+\t  min = max = build_int_cst (expr_type, 1);\n \t}\n       else if (vr0.type != VR_VARYING\n \t       && vr1.type != VR_VARYING\n@@ -1946,13 +1947,13 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t       && !overflow_infinity_range_p (&vr1))\n \t{\n \t  /* Boolean expressions cannot be folded with int_const_binop.  */\n-\t  min = fold_binary (code, TREE_TYPE (expr), vr0.min, vr1.min);\n-\t  max = fold_binary (code, TREE_TYPE (expr), vr0.max, vr1.max);\n+\t  min = fold_binary (code, expr_type, vr0.min, vr1.min);\n+\t  max = fold_binary (code, expr_type, vr0.max, vr1.max);\n \t}\n       else\n \t{\n \t  /* The result of a TRUTH_*_EXPR is always true or false.  */\n-\t  set_value_range_to_truthvalue (vr, TREE_TYPE (expr));\n+\t  set_value_range_to_truthvalue (vr, expr_type);\n \t  return;\n \t}\n     }\n@@ -2018,7 +2019,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t      || !vrp_expr_computes_nonnegative (op1, &sop)\n \t      || (operand_less_p\n \t\t  (build_int_cst (TREE_TYPE (vr1.max),\n-\t\t\t\t  TYPE_PRECISION (TREE_TYPE (expr)) - 1),\n+\t\t\t\t  TYPE_PRECISION (expr_type) - 1),\n \t\t   vr1.max) != 0))\n \t    {\n \t      set_value_range_to_varying (vr);\n@@ -2147,7 +2148,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t  && !TREE_OVERFLOW (vr0.max)\n \t  && tree_int_cst_sgn (vr0.max) >= 0)\n \t{\n-\t  min = build_int_cst (TREE_TYPE (expr), 0);\n+\t  min = build_int_cst (expr_type, 0);\n \t  max = vr0.max;\n \t}\n       else if (vr1.type == VR_RANGE\n@@ -2157,7 +2158,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t       && tree_int_cst_sgn (vr1.max) >= 0)\n \t{\n \t  type = VR_RANGE;\n-\t  min = build_int_cst (TREE_TYPE (expr), 0);\n+\t  min = build_int_cst (expr_type, 0);\n \t  max = vr1.max;\n \t}\n       else\n@@ -2215,10 +2216,10 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n    the range of its operand and the expression code.  */\n \n static void\n-extract_range_from_unary_expr (value_range_t *vr, tree expr)\n+extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n+\t\t\t       tree type, tree op0)\n {\n-  enum tree_code code = TREE_CODE (expr);\n-  tree min, max, op0;\n+  tree min, max;\n   int cmp;\n   value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n \n@@ -2236,7 +2237,6 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \n   /* Get value ranges for the operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  op0 = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n@@ -2264,17 +2264,17 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \n   /* If the expression involves pointers, we are only interested in\n      determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n-  if (POINTER_TYPE_P (TREE_TYPE (expr)) || POINTER_TYPE_P (TREE_TYPE (op0)))\n+  if (POINTER_TYPE_P (type) || POINTER_TYPE_P (TREE_TYPE (op0)))\n     {\n       bool sop;\n \n       sop = false;\n       if (range_is_nonnull (&vr0)\n-\t  || (tree_expr_nonzero_warnv_p (expr, &sop)\n+\t  || (tree_unary_nonzero_warnv_p (code, type, op0, &sop)\n \t      && !sop))\n-\tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+\tset_value_range_to_nonnull (vr, type);\n       else if (range_is_null (&vr0))\n-\tset_value_range_to_null (vr, TREE_TYPE (expr));\n+\tset_value_range_to_null (vr, type);\n       else\n \tset_value_range_to_varying (vr);\n \n@@ -2285,7 +2285,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n   if (code == NOP_EXPR || code == CONVERT_EXPR)\n     {\n       tree inner_type = TREE_TYPE (op0);\n-      tree outer_type = TREE_TYPE (expr);\n+      tree outer_type = type;\n \n       /* If VR0 represents a simple range, then try to convert\n \t the min and max values for the range to the same type\n@@ -2362,73 +2362,73 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n   /* Apply the operation to each end of the range and see what we end\n      up with.  */\n   if (code == NEGATE_EXPR\n-      && !TYPE_UNSIGNED (TREE_TYPE (expr)))\n+      && !TYPE_UNSIGNED (type))\n     {\n       /* NEGATE_EXPR flips the range around.  We need to treat\n \t TYPE_MIN_VALUE specially.  */\n       if (is_positive_overflow_infinity (vr0.max))\n-\tmin = negative_overflow_infinity (TREE_TYPE (expr));\n+\tmin = negative_overflow_infinity (type);\n       else if (is_negative_overflow_infinity (vr0.max))\n-\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmin = positive_overflow_infinity (type);\n       else if (!vrp_val_is_min (vr0.max))\n-\tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n-      else if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\tmin = fold_unary_to_constant (code, type, vr0.max);\n+      else if (needs_overflow_infinity (type))\n \t{\n-\t  if (supports_overflow_infinity (TREE_TYPE (expr))\n+\t  if (supports_overflow_infinity (type)\n \t      && !is_overflow_infinity (vr0.min)\n \t      && !vrp_val_is_min (vr0.min))\n-\t    min = positive_overflow_infinity (TREE_TYPE (expr));\n+\t    min = positive_overflow_infinity (type);\n \t  else\n \t    {\n \t      set_value_range_to_varying (vr);\n \t      return;\n \t    }\n \t}\n       else\n-\tmin = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\tmin = TYPE_MIN_VALUE (type);\n \n       if (is_positive_overflow_infinity (vr0.min))\n-\tmax = negative_overflow_infinity (TREE_TYPE (expr));\n+\tmax = negative_overflow_infinity (type);\n       else if (is_negative_overflow_infinity (vr0.min))\n-\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmax = positive_overflow_infinity (type);\n       else if (!vrp_val_is_min (vr0.min))\n-\tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n-      else if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\tmax = fold_unary_to_constant (code, type, vr0.min);\n+      else if (needs_overflow_infinity (type))\n \t{\n-\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n-\t    max = positive_overflow_infinity (TREE_TYPE (expr));\n+\t  if (supports_overflow_infinity (type))\n+\t    max = positive_overflow_infinity (type);\n \t  else\n \t    {\n \t      set_value_range_to_varying (vr);\n \t      return;\n \t    }\n \t}\n       else\n-\tmax = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\tmax = TYPE_MIN_VALUE (type);\n     }\n   else if (code == NEGATE_EXPR\n-\t   && TYPE_UNSIGNED (TREE_TYPE (expr)))\n+\t   && TYPE_UNSIGNED (type))\n     {\n       if (!range_includes_zero_p (&vr0))\n \t{\n-\t  max = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n-\t  min = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+\t  max = fold_unary_to_constant (code, type, vr0.min);\n+\t  min = fold_unary_to_constant (code, type, vr0.max);\n \t}\n       else\n \t{\n \t  if (range_is_null (&vr0))\n-\t    set_value_range_to_null (vr, TREE_TYPE (expr));\n+\t    set_value_range_to_null (vr, type);\n \t  else\n \t    set_value_range_to_varying (vr);\n \t  return;\n \t}\n     }\n   else if (code == ABS_EXPR\n-           && !TYPE_UNSIGNED (TREE_TYPE (expr)))\n+           && !TYPE_UNSIGNED (type))\n     {\n       /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n          useful range.  */\n-      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (expr))\n+      if (!TYPE_OVERFLOW_UNDEFINED (type)\n \t  && ((vr0.type == VR_RANGE\n \t       && vrp_val_is_min (vr0.min))\n \t      || (vr0.type == VR_ANTI_RANGE\n@@ -2442,27 +2442,27 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n       /* ABS_EXPR may flip the range around, if the original range\n \t included negative values.  */\n       if (is_overflow_infinity (vr0.min))\n-\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmin = positive_overflow_infinity (type);\n       else if (!vrp_val_is_min (vr0.min))\n-\tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n-      else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n-\tmin = TYPE_MAX_VALUE (TREE_TYPE (expr));\n-      else if (supports_overflow_infinity (TREE_TYPE (expr)))\n-\tmin = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmin = fold_unary_to_constant (code, type, vr0.min);\n+      else if (!needs_overflow_infinity (type))\n+\tmin = TYPE_MAX_VALUE (type);\n+      else if (supports_overflow_infinity (type))\n+\tmin = positive_overflow_infinity (type);\n       else\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n \n       if (is_overflow_infinity (vr0.max))\n-\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmax = positive_overflow_infinity (type);\n       else if (!vrp_val_is_min (vr0.max))\n-\tmax = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n-      else if (!needs_overflow_infinity (TREE_TYPE (expr)))\n-\tmax = TYPE_MAX_VALUE (TREE_TYPE (expr));\n-      else if (supports_overflow_infinity (TREE_TYPE (expr)))\n-\tmax = positive_overflow_infinity (TREE_TYPE (expr));\n+\tmax = fold_unary_to_constant (code, type, vr0.max);\n+      else if (!needs_overflow_infinity (type))\n+\tmax = TYPE_MAX_VALUE (type);\n+      else if (supports_overflow_infinity (type))\n+\tmax = positive_overflow_infinity (type);\n       else\n \t{\n \t  set_value_range_to_varying (vr);\n@@ -2485,9 +2485,9 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when\n \t\t flag_wrapv is set and the original anti-range doesn't include\n \t         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */\n-\t      if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n+\t      if (TYPE_OVERFLOW_WRAPS (type))\n \t\t{\n-\t\t  tree type_min_value = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\t\t  tree type_min_value = TYPE_MIN_VALUE (type);\n \n \t\t  min = (vr0.min != type_min_value\n \t\t\t ? int_const_binop (PLUS_EXPR, type_min_value,\n@@ -2497,9 +2497,9 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t      else\n \t\t{\n \t\t  if (overflow_infinity_range_p (&vr0))\n-\t\t    min = negative_overflow_infinity (TREE_TYPE (expr));\n+\t\t    min = negative_overflow_infinity (type);\n \t\t  else\n-\t\t    min = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+\t\t    min = TYPE_MIN_VALUE (type);\n \t\t}\n \t    }\n \t  else\n@@ -2508,19 +2508,19 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t         flag_wrapv since TYPE_MIN_VALUE is in the original\n \t         anti-range.  */\n \t      vr0.type = VR_RANGE;\n-\t      min = build_int_cst (TREE_TYPE (expr), 0);\n-\t      if (needs_overflow_infinity (TREE_TYPE (expr)))\n+\t      min = build_int_cst (type, 0);\n+\t      if (needs_overflow_infinity (type))\n \t\t{\n-\t\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n-\t\t    max = positive_overflow_infinity (TREE_TYPE (expr));\n+\t\t  if (supports_overflow_infinity (type))\n+\t\t    max = positive_overflow_infinity (type);\n \t\t  else\n \t\t    {\n \t\t      set_value_range_to_varying (vr);\n \t\t      return;\n \t\t    }\n \t\t}\n \t      else\n-\t\tmax = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+\t\tmax = TYPE_MAX_VALUE (type);\n \t    }\n \t}\n \n@@ -2530,7 +2530,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t{\n \t  if (cmp == 1)\n \t    max = min;\n-\t  min = build_int_cst (TREE_TYPE (expr), 0);\n+\t  min = build_int_cst (type, 0);\n \t}\n       else\n \t{\n@@ -2546,10 +2546,10 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n   else\n     {\n       /* Otherwise, operate on each end of the range.  */\n-      min = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n-      max = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+      min = fold_unary_to_constant (code, type, vr0.min);\n+      max = fold_unary_to_constant (code, type, vr0.max);\n \n-      if (needs_overflow_infinity (TREE_TYPE (expr)))\n+      if (needs_overflow_infinity (type))\n \t{\n \t  gcc_assert (code != NEGATE_EXPR && code != ABS_EXPR);\n \n@@ -2568,7 +2568,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t    min = vr0.min;\n \t  else if (TREE_OVERFLOW (min))\n \t    {\n-\t      if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t      if (supports_overflow_infinity (type))\n \t\tmin = (tree_int_cst_sgn (min) >= 0\n \t\t       ? positive_overflow_infinity (TREE_TYPE (min))\n \t\t       : negative_overflow_infinity (TREE_TYPE (min)));\n@@ -2583,7 +2583,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t    max = vr0.max;\n \t  else if (TREE_OVERFLOW (max))\n \t    {\n-\t      if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t      if (supports_overflow_infinity (type))\n \t\tmax = (tree_int_cst_sgn (max) >= 0\n \t\t       ? positive_overflow_infinity (TREE_TYPE (max))\n \t\t       : negative_overflow_infinity (TREE_TYPE (max)));\n@@ -2647,10 +2647,14 @@ extract_range_from_cond_expr (value_range_t *vr, tree expr)\n    on the range of its operand and the expression code.  */\n \n static void\n-extract_range_from_comparison (value_range_t *vr, tree expr)\n+extract_range_from_comparison (value_range_t *vr, enum tree_code code,\n+\t\t\t       tree type, tree op0, tree op1)\n {\n   bool sop = false;\n-  tree val = vrp_evaluate_conditional_warnv (expr, false, &sop);\n+  tree val = vrp_evaluate_conditional_warnv_with_ops (code,\n+\t\t\t\t\t\t      op0,\n+\t\t\t\t\t\t      op1,\n+\t\t\t\t\t\t      false, &sop);\n \n   /* A disadvantage of using a special infinity as an overflow\n      representation is that we lose the ability to record overflow\n@@ -2662,15 +2666,15 @@ extract_range_from_comparison (value_range_t *vr, tree expr)\n       /* Since this expression was found on the RHS of an assignment,\n \t its type may be different from _Bool.  Convert VAL to EXPR's\n \t type.  */\n-      val = fold_convert (TREE_TYPE (expr), val);\n+      val = fold_convert (type, val);\n       if (is_gimple_min_invariant (val))\n \tset_value_range_to_value (vr, val, vr->equiv);\n       else\n \tset_value_range (vr, VR_RANGE, val, val, vr->equiv);\n     }\n   else\n     /* The result of a comparison is always true or false.  */\n-    set_value_range_to_truthvalue (vr, TREE_TYPE (expr));\n+    set_value_range_to_truthvalue (vr, type);\n }\n \n \n@@ -2692,13 +2696,18 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n \t   || code == TRUTH_AND_EXPR\n \t   || code == TRUTH_OR_EXPR\n \t   || code == TRUTH_XOR_EXPR)\n-    extract_range_from_binary_expr (vr, expr);\n+    extract_range_from_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t\t    TREE_OPERAND (expr, 0),\n+\t\t\t\t    TREE_OPERAND (expr, 1));\n   else if (TREE_CODE_CLASS (code) == tcc_unary)\n-    extract_range_from_unary_expr (vr, expr);\n+    extract_range_from_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t\t   TREE_OPERAND (expr, 0));\n   else if (code == COND_EXPR)\n     extract_range_from_cond_expr (vr, expr);\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n-    extract_range_from_comparison (vr, expr);\n+    extract_range_from_comparison (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t\t   TREE_OPERAND (expr, 0),\n+\t\t\t\t   TREE_OPERAND (expr, 1));\n   else if (is_gimple_min_invariant (expr))\n     set_value_range_to_value (vr, expr, NULL);\n   else\n@@ -5111,6 +5120,51 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n   return NULL_TREE;\n }\n \n+/* Helper function for vrp_evaluate_conditional_warnv. */\n+\n+static tree\n+vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n+\t\t\t\t\t tree op1, bool use_equiv_p,\n+\t\t\t\t\t bool *strict_overflow_p)\n+{\n+  /* We only deal with integral and pointer types.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+      && !POINTER_TYPE_P (TREE_TYPE (op0)))\n+    return NULL_TREE;\n+\n+  if (use_equiv_p)\n+    {\n+      if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)\n+\treturn compare_names (code, op0, op1,\n+\t\t\t      strict_overflow_p);\n+      else if (TREE_CODE (op0) == SSA_NAME)\n+\treturn compare_name_with_value (code, op0, op1,\n+\t\t\t\t\tstrict_overflow_p);\n+      else if (TREE_CODE (op1) == SSA_NAME)\n+\treturn (compare_name_with_value\n+\t\t(swap_tree_comparison (code), op1, op0,\n+\t\t strict_overflow_p));\n+    }\n+  else\n+    {\n+      value_range_t *vr0, *vr1;\n+\n+      vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n+      vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n+\n+      if (vr0 && vr1)\n+\treturn compare_ranges (code, vr0, vr1,\n+\t\t\t       strict_overflow_p);\n+      else if (vr0 && vr1 == NULL)\n+\treturn compare_range_with_value (code, vr0, op1,\n+\t\t\t\t\t strict_overflow_p);\n+      else if (vr0 == NULL && vr1)\n+\treturn (compare_range_with_value\n+\t\t(swap_tree_comparison (code), vr1, op0,\n+\t\t strict_overflow_p));\n+    }\n+  return NULL_TREE;\n+}\n \n /* Given a conditional predicate COND, try to determine if COND yields\n    true or false based on the value ranges of its operands.  Return\n@@ -5159,47 +5213,11 @@ vrp_evaluate_conditional_warnv (tree cond, bool use_equiv_p,\n \treturn vr->min;\n     }\n   else\n-    {\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      tree op1 = TREE_OPERAND (cond, 1);\n-\n-      /* We only deal with integral and pointer types.  */\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t  && !POINTER_TYPE_P (TREE_TYPE (op0)))\n-\treturn NULL_TREE;\n-\n-      if (use_equiv_p)\n-\t{\n-\t  if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)\n-\t    return compare_names (TREE_CODE (cond), op0, op1,\n-\t\t\t\t  strict_overflow_p);\n-\t  else if (TREE_CODE (op0) == SSA_NAME)\n-\t    return compare_name_with_value (TREE_CODE (cond), op0, op1,\n-\t\t\t\t\t    strict_overflow_p);\n-\t  else if (TREE_CODE (op1) == SSA_NAME)\n-\t    return (compare_name_with_value\n-\t\t    (swap_tree_comparison (TREE_CODE (cond)), op1, op0,\n-\t\t     strict_overflow_p));\n-\t}\n-      else\n-\t{\n-\t  value_range_t *vr0, *vr1;\n-\n-\t  vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n-\t  vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n-\n-\t  if (vr0 && vr1)\n-\t    return compare_ranges (TREE_CODE (cond), vr0, vr1,\n-\t\t\t\t   strict_overflow_p);\n-\t  else if (vr0 && vr1 == NULL)\n-\t    return compare_range_with_value (TREE_CODE (cond), vr0, op1,\n-\t\t\t\t\t     strict_overflow_p);\n-\t  else if (vr0 == NULL && vr1)\n-\t    return (compare_range_with_value\n-\t\t    (swap_tree_comparison (TREE_CODE (cond)), vr1, op0,\n-\t\t     strict_overflow_p));\n-\t}\n-    }\n+    return vrp_evaluate_conditional_warnv_with_ops (TREE_CODE (cond),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 0),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 1),\n+\t\t\t\t\t\t    use_equiv_p,\n+\t\t\t\t\t\t    strict_overflow_p);\n \n   /* Anything else cannot be computed statically.  */\n   return NULL_TREE;"}, {"sha": "d3093c7536bc7c61251ceceb34906c52004646fc", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d3cd5d5abceef93e032b7d9cd782b740194ae0e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2d3cd5d5abceef93e032b7d9cd782b740194ae0e", "patch": "@@ -4841,6 +4841,16 @@ extern bool ptr_difference_const (tree, tree, HOST_WIDE_INT *);\n extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n \n extern bool tree_expr_nonzero_p (tree);\n+extern bool tree_unary_nonzero_warnv_p (enum tree_code, tree, tree, bool *);\n+extern bool tree_binary_nonzero_warnv_p (enum tree_code, tree, tree, tree op1,\n+                                         bool *);\n+extern bool tree_single_nonzero_warnv_p (tree, bool *);\n+extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n+extern bool tree_unary_nonnegative_warnv_p (enum tree_code, tree, tree, bool *);\n+extern bool tree_binary_nonnegative_warnv_p (enum tree_code, tree, tree, tree,\n+                                             bool *);\n+extern bool tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n+extern bool tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n \n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);"}]}