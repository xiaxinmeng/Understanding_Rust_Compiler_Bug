{"sha": "c0b290997fa10dd3978c43c1dcdef8838fb15e98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBiMjkwOTk3ZmExMGRkMzk3OGM0M2MxZGNkZWY4ODM4ZmIxNWU5OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-09-17T21:51:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-09-17T21:51:50Z"}, "message": "re PR fortran/37536 (a mfcr is produced instead of branches for DO loops)\n\n\tPR fortran/37536\n\t* trans-stmt.c (gfc_trans_do): Optimize integer type non-simple\n\tdo loop initialization.\n\nFrom-SVN: r140433", "tree": {"sha": "2016a5da182f79af8af85bf56085593a2b20fbcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2016a5da182f79af8af85bf56085593a2b20fbcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0b290997fa10dd3978c43c1dcdef8838fb15e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0b290997fa10dd3978c43c1dcdef8838fb15e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0b290997fa10dd3978c43c1dcdef8838fb15e98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0b290997fa10dd3978c43c1dcdef8838fb15e98/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a8c909ebd0bbd58ed5308bc66dc923ec5cfaafd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8c909ebd0bbd58ed5308bc66dc923ec5cfaafd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8c909ebd0bbd58ed5308bc66dc923ec5cfaafd"}], "stats": {"total": 107, "additions": 72, "deletions": 35}, "files": [{"sha": "a41515d5efeeed396abef09dacb790c9a3bb3c55", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0b290997fa10dd3978c43c1dcdef8838fb15e98/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0b290997fa10dd3978c43c1dcdef8838fb15e98/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c0b290997fa10dd3978c43c1dcdef8838fb15e98", "patch": "@@ -1,3 +1,9 @@\n+2008-09-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/37536\n+\t* trans-stmt.c (gfc_trans_do): Optimize integer type non-simple\n+\tdo loop initialization.\n+\n 2008-09-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \t    Tobias Burnus  <burnus@net.b.de>\n "}, {"sha": "26ea70ce3d814f78a5c716809ba126a38de5f267", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 66, "deletions": 35, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0b290997fa10dd3978c43c1dcdef8838fb15e98/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0b290997fa10dd3978c43c1dcdef8838fb15e98/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c0b290997fa10dd3978c43c1dcdef8838fb15e98", "patch": "@@ -834,7 +834,6 @@ gfc_trans_do (gfc_code * code)\n   tree from;\n   tree to;\n   tree step;\n-  tree empty;\n   tree countm1;\n   tree type;\n   tree utype;\n@@ -875,56 +874,88 @@ gfc_trans_do (gfc_code * code)\n       && (integer_onep (step)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n     return gfc_trans_simple_do (code, &block, dovar, from, to, step);\n-      \n-  /* We need a special check for empty loops:\n-     empty = (step > 0 ? to < from : to > from);  */\n+\n   pos_step = fold_build2 (GT_EXPR, boolean_type_node, step,\n \t\t\t  fold_convert (type, integer_zero_node));\n-  empty = fold_build3 (COND_EXPR, boolean_type_node, pos_step,\n-\t\t       fold_build2 (LT_EXPR, boolean_type_node, to, from),\n-\t\t       fold_build2 (GT_EXPR, boolean_type_node, to, from));\n \n-  /* Initialize loop count. This code is executed before we enter the\n-     loop body. We generate: countm1 = abs(to - from) / abs(step).  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n-    {\n-      tree ustep;\n+    utype = unsigned_type_for (type);\n+  else\n+    utype = unsigned_type_for (gfc_array_index_type);\n+  countm1 = gfc_create_var (utype, \"countm1\");\n+\n+  /* Cycle and exit statements are implemented with gotos.  */\n+  cycle_label = gfc_build_label_decl (NULL_TREE);\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  TREE_USED (exit_label) = 1;\n+\n+  /* Initialize the DO variable: dovar = from.  */\n+  gfc_add_modify (&block, dovar, from);\n \n-      utype = unsigned_type_for (type);\n+  /* Initialize loop count and jump to exit label if the loop is empty.\n+     This code is executed before we enter the loop body. We generate:\n+     if (step > 0)\n+       {\n+\t if (to < from) goto exit_label;\n+\t countm1 = (to - from) / step;\n+       }\n+     else\n+       {\n+\t if (to > from) goto exit_label;\n+\t countm1 = (from - to) / -step;\n+       }  */\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      tree pos, neg;\n \n-      /* tmp = abs(to - from) / abs(step) */\n-      ustep = fold_convert (utype, fold_build1 (ABS_EXPR, type, step));\n-      tmp = fold_build3 (COND_EXPR, type, pos_step,\n-\t\t\t fold_build2 (MINUS_EXPR, type, to, from),\n-\t\t\t fold_build2 (MINUS_EXPR, type, from, to));\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, fold_convert (utype, tmp),\n-\t\t\t ustep);\n+      tmp = fold_build2 (LT_EXPR, boolean_type_node, to, from);\n+      pos = fold_build3 (COND_EXPR, void_type_node, tmp,\n+\t\t\t build1_v (GOTO_EXPR, exit_label),\n+\t\t\t build_empty_stmt ());\n+      tmp = fold_build2 (MINUS_EXPR, type, to, from);\n+      tmp = fold_convert (utype, tmp);\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n+\t\t\t fold_convert (utype, step));\n+      tmp = build2 (MODIFY_EXPR, void_type_node, countm1, tmp);\n+      pos = build2 (COMPOUND_EXPR, void_type_node, pos, tmp);\n+\n+      tmp = fold_build2 (GT_EXPR, boolean_type_node, to, from);\n+      neg = fold_build3 (COND_EXPR, void_type_node, tmp,\n+\t\t\t build1_v (GOTO_EXPR, exit_label),\n+\t\t\t build_empty_stmt ());\n+      tmp = fold_build2 (MINUS_EXPR, type, from, to);\n+      tmp = fold_convert (utype, tmp);\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n+\t\t\t fold_convert (utype, fold_build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t\t   type, step)));\n+      tmp = build2 (MODIFY_EXPR, void_type_node, countm1, tmp);\n+      neg = build2 (COMPOUND_EXPR, void_type_node, neg, tmp);\n+\n+      tmp = fold_build3 (COND_EXPR, void_type_node, pos_step, pos, neg);\n+      gfc_add_expr_to_block (&block, tmp);\n     }\n   else\n     {\n       /* TODO: We could use the same width as the real type.\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n-      utype = unsigned_type_for (gfc_array_index_type);\n+\n       tmp = fold_build2 (MINUS_EXPR, type, to, from);\n       tmp = fold_build2 (RDIV_EXPR, type, tmp, step);\n       tmp = fold_build1 (FIX_TRUNC_EXPR, utype, tmp);\n+      gfc_add_modify (&block, countm1, tmp);\n+\n+      /* We need a special check for empty loops:\n+\t empty = (step > 0 ? to < from : to > from);  */\n+      tmp = fold_build3 (COND_EXPR, boolean_type_node, pos_step,\n+\t\t\t fold_build2 (LT_EXPR, boolean_type_node, to, from),\n+\t\t\t fold_build2 (GT_EXPR, boolean_type_node, to, from));\n+      /* If the loop is empty, go directly to the exit label.  */\n+      tmp = fold_build3 (COND_EXPR, void_type_node, tmp,\n+\t\t\t build1_v (GOTO_EXPR, exit_label),\n+\t\t\t build_empty_stmt ());\n+      gfc_add_expr_to_block (&block, tmp);\n     }\n-  countm1 = gfc_create_var (utype, \"countm1\");\n-  gfc_add_modify (&block, countm1, tmp);\n-\n-  /* Cycle and exit statements are implemented with gotos.  */\n-  cycle_label = gfc_build_label_decl (NULL_TREE);\n-  exit_label = gfc_build_label_decl (NULL_TREE);\n-  TREE_USED (exit_label) = 1;\n-\n-  /* Initialize the DO variable: dovar = from.  */\n-  gfc_add_modify (&block, dovar, from);\n-\n-  /* If the loop is empty, go directly to the exit label.  */\n-  tmp = fold_build3 (COND_EXPR, void_type_node, empty,\n-\t\t     build1_v (GOTO_EXPR, exit_label), build_empty_stmt ());\n-  gfc_add_expr_to_block (&block, tmp);\n \n   /* Loop body.  */\n   gfc_start_block (&body);"}]}