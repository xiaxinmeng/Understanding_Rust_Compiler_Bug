{"sha": "b12cbf2cc559fa466b854d89bc4069d7282a881f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyY2JmMmNjNTU5ZmE0NjZiODU0ZDg5YmM0MDY5ZDcyODJhODgxZg==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2006-04-17T01:59:41Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2006-04-17T01:59:41Z"}, "message": "target.h (struct gcc_target): Add mode_rep_extended.\n\n\t* target.h (struct gcc_target): Add mode_rep_extended.\n\t* rtlanal.c (num_sign_bit_copies_in_rep): New global.\n\t(init_num_sign_bit_copies_in_rep): Initialize it using\n\tmode_rep_extended.\n\t(truncate_to_mode): Use it.\n\t(init_rtlanal): Call init_num_sign_bit_copies_in_rep.\n\t* targhooks.h (default_mode_rep_extended): Declare it.\n\t* targhooks.c (default_mode_rep_extended): Define it.\n\t* target-def.h (TARGET_MODE_REP_EXTENDED): New macro.  Default to\n\tdefault_mode_rep_extended.\n\t(TARGET_INITIALIZER): Include it.\n\t* doc/tm.texi (Misc): Document it.\n\t* config/mips/mips.c (TARGET_TRUNCATED_TO_MODE): Override it.\n\t(mips_truncated_to_mode): New function.\n\nFrom-SVN: r112998", "tree": {"sha": "58a07ed2ef2fe0457a23ba7f949c521901afd762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a07ed2ef2fe0457a23ba7f949c521901afd762"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b12cbf2cc559fa466b854d89bc4069d7282a881f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12cbf2cc559fa466b854d89bc4069d7282a881f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12cbf2cc559fa466b854d89bc4069d7282a881f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12cbf2cc559fa466b854d89bc4069d7282a881f/comments", "author": null, "committer": null, "parents": [{"sha": "ca8b30c8d14e272af6129abc5c7df4a1f2961889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8b30c8d14e272af6129abc5c7df4a1f2961889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8b30c8d14e272af6129abc5c7df4a1f2961889"}], "stats": {"total": 159, "additions": 157, "deletions": 2}, "files": [{"sha": "2afcfc14272ebdcca2d78aa21332437a9029c625", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -1,3 +1,20 @@\n+2006-04-16  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\t* target.h (struct gcc_target): Add mode_rep_extended.\n+\t* rtlanal.c (num_sign_bit_copies_in_rep): New global.\n+\t(init_num_sign_bit_copies_in_rep): Initialize it using\n+\tmode_rep_extended.\n+\t(truncate_to_mode): Use it.\n+\t(init_rtlanal): Call init_num_sign_bit_copies_in_rep.\n+\t* targhooks.h (default_mode_rep_extended): Declare it.\n+\t* targhooks.c (default_mode_rep_extended): Define it.\n+\t* target-def.h (TARGET_MODE_REP_EXTENDED): New macro.  Default to\n+\tdefault_mode_rep_extended.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* doc/tm.texi (Misc): Document it.\n+\t* config/mips/mips.c (TARGET_TRUNCATED_TO_MODE): Override it.\n+\t(mips_truncated_to_mode): New function.\n+\n 2006-04-16  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/25474"}, {"sha": "f66cdc255afc4f111d51b3e4df6d8488fa2e1865", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -409,6 +409,7 @@ static rtx mips_expand_builtin_compare (enum mips_builtin_type,\n static rtx mips_expand_builtin_bposge (enum mips_builtin_type, rtx);\n static void mips_encode_section_info (tree, rtx, int);\n static void mips_extra_live_on_entry (bitmap);\n+static int mips_mode_rep_extended (enum machine_mode, enum machine_mode);\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -1139,6 +1140,9 @@ static struct mips_rtx_cost_data const mips_rtx_cost_data[PROCESSOR_MAX] =\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES mips_arg_partial_bytes\n \n+#undef TARGET_MODE_REP_EXTENDED\n+#define TARGET_MODE_REP_EXTENDED mips_mode_rep_extended\n+\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P mips_vector_mode_supported_p\n \n@@ -10725,5 +10729,15 @@ mips_extra_live_on_entry (bitmap regs)\n     bitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n }\n \n+/* SImode values are represented as sign-extended to DImode.  */\n+\n+int\n+mips_mode_rep_extended (enum machine_mode mode, enum machine_mode mode_rep)\n+{\n+  if (TARGET_64BIT && mode == SImode && mode_rep == DImode)\n+    return SIGN_EXTEND;\n+\n+  return UNKNOWN;\n+}\n \f\n #include \"gt-mips.h\""}, {"sha": "639e9e98842c3acd9e3f3319539788d65896e76d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -9143,6 +9143,34 @@ If this is the case, making @code{TRULY_NOOP_TRUNCATION} return 0 in\n such cases may improve things.\n @end defmac\n \n+@deftypefn {Target Hook} int TARGET_MODE_REP_EXTENDED (enum machine_mode @var{mode}, enum machine_mode @var{rep_mode})\n+The representation of an intergral mode can be such that the values\n+are always extended to a wider integral mode.  Return\n+@code{SIGN_EXTEND} if values of @var{mode} are represented in\n+sign-extended form to @var{rep_mode}.  Return @code{UNKNOWN}\n+otherwise.  (Currently, none of the targets use zero-extended\n+representation this way so unlike @code{LOAD_EXTEND_OP},\n+@code{TARGET_MODE_REP_EXTENDED} is expected to return either\n+@code{SIGN_EXTEND} or @code{UNKNOWN}.  Also no target extends\n+@var{mode} to @var{mode_rep} so that @var{mode_rep} is not the next\n+widest integral mode and currently we take advantage of this fact.)\n+\n+Similarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN}\n+value even if the extension is not performed on certain hard registers\n+as long as for the @code{REGNO_REG_CLASS} of these hard registers\n+@code{CANNOT_CHANGE_MODE_CLASS} returns nonzero.\n+\n+Note that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP}\n+describe two related properties.  If you define\n+@code{TARGET_MODE_REP_EXTENDED (mode, word_mode)} you probably also want\n+to define @code{LOAD_EXTEND_OP (mode)} to return the same type of\n+extension.\n+\n+In order to enforce the representation of @code{mode},\n+@code{TRULY_NOOP_TRUNCATION} should return false when truncating to\n+@code{mode}.\n+@end deftypefn\n+\n @defmac STORE_FLAG_VALUE\n A C expression describing the value returned by a comparison operator\n with an integral mode and stored by a store-flag instruction"}, {"sha": "6a7a696914cf5238170e6d7eded01d1090eb770b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -67,6 +67,22 @@ static int non_rtx_starting_operands[NUM_RTX_CODE];\n    and set by `-m...' switches.  Must be defined in rtlanal.c.  */\n \n int target_flags;\n+\n+/* Truncation narrows the mode from SOURCE mode to DESTINATION mode.\n+   If TARGET_MODE_REP_EXTENDED (DESTINATION, DESTINATION_REP) is\n+   SIGN_EXTEND then while narrowing we also have to enforce the\n+   representation and sign-extend the value to mode DESTINATION_REP.\n+\n+   If the value is already sign-extended to DESTINATION_REP mode we\n+   can just switch to DESTINATION mode on it.  For each pair of\n+   integral modes SOURCE and DESTINATION, when truncating from SOURCE\n+   to DESTINATION, NUM_SIGN_BIT_COPIES_IN_REP[SOURCE][DESTINATION]\n+   contains the number of high-order bits in SOURCE that have to be\n+   copies of the sign-bit so that we can do this mode-switch to\n+   DESTINATION.  */\n+\n+static unsigned int\n+num_sign_bit_copies_in_rep[MAX_MODE_INT + 1][MAX_MODE_INT + 1];\n \f\n /* Return 1 if the value of X is unstable\n    (would be different at a different point in the program).\n@@ -4632,16 +4648,71 @@ get_condition (rtx jump, rtx *earliest, int allow_cc_mode, int valid_at_insn_p)\n \t\t\t\t allow_cc_mode, valid_at_insn_p);\n }\n \n+/* Initialize the table NUM_SIGN_BIT_COPIES_IN_REP based on\n+   TARGET_MODE_REP_EXTENDED.\n+\n+   Note that we assume that the property of\n+   TARGET_MODE_REP_EXTENDED(B, C) is sticky to the integral modes\n+   narrower than mode B.  I.e., if A is a mode narrower than B then in\n+   order to be able to operate on it in mode B, mode A needs to\n+   satisfy the requirements set by the representation of mode B.  */\n+\n+static void\n+init_num_sign_bit_copies_in_rep (void)\n+{\n+  enum machine_mode mode, in_mode;\n+\n+  for (in_mode = GET_CLASS_NARROWEST_MODE (MODE_INT); in_mode != VOIDmode;\n+       in_mode = GET_MODE_WIDER_MODE (mode))\n+    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != in_mode;\n+\t mode = GET_MODE_WIDER_MODE (mode))\n+      {\n+\tenum machine_mode i;\n+\n+\t/* Currently, it is assumed that TARGET_MODE_REP_EXTENDED\n+\t   extends to the next widest mode.  */\n+\tgcc_assert (targetm.mode_rep_extended (mode, in_mode) == UNKNOWN\n+\t\t    || GET_MODE_WIDER_MODE (mode) == in_mode);\n+\n+\t/* We are in in_mode.  Count how many bits outside of mode\n+\t   have to be copies of the sign-bit.  */\n+\tfor (i = mode; i != in_mode; i = GET_MODE_WIDER_MODE (i))\n+\t  {\n+\t    enum machine_mode wider = GET_MODE_WIDER_MODE (i);\n+\n+\t    if (targetm.mode_rep_extended (i, wider) == SIGN_EXTEND\n+\t\t/* We can only check sign-bit copies starting from the\n+\t\t   top-bit.  In order to be able to check the bits we\n+\t\t   have already seen we pretend that subsequent bits\n+\t\t   have to be sign-bit copies too.  */\n+\t\t|| num_sign_bit_copies_in_rep [in_mode][mode])\n+\t      num_sign_bit_copies_in_rep [in_mode][mode]\n+\t\t+= GET_MODE_BITSIZE (wider) - GET_MODE_BITSIZE (i);\n+\t  }\n+      }\n+}\n+\n /* Suppose that truncation from the machine mode of X to MODE is not a\n    no-op.  See if there is anything special about X so that we can\n    assume it already contains a truncated value of MODE.  */\n \n bool\n truncated_to_mode (enum machine_mode mode, rtx x)\n {\n-  return REG_P (x) && rtl_hooks.reg_truncated_to_mode (mode, x);\n-}\n+  /* This register has already been used in MODE without explicit\n+     truncation.  */\n+  if (REG_P (x) && rtl_hooks.reg_truncated_to_mode (mode, x))\n+    return true;\n+\n+  /* See if we already satisfy the requirements of MODE.  If yes we\n+     can just switch to MODE.  */\n+  if (num_sign_bit_copies_in_rep[GET_MODE (x)][mode]\n+      && (num_sign_bit_copies (x, GET_MODE (x))\n+\t  >= num_sign_bit_copies_in_rep[GET_MODE (x)][mode] + 1))\n+    return true;\n \n+  return false;\n+}\n \f\n /* Initialize non_rtx_starting_operands, which is used to speed up\n    for_each_rtx.  */\n@@ -4655,6 +4726,8 @@ init_rtlanal (void)\n       const char *first = strpbrk (format, \"eEV\");\n       non_rtx_starting_operands[i] = first ? first - format : -1;\n     }\n+\n+  init_num_sign_bit_copies_in_rep ();\n }\n \f\n /* Check whether this is a constant pool constant.  */"}, {"sha": "3fd22f495ee55ecc45f8987e5e31d6e884ff29a2", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -373,6 +373,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_MIN_DIVISIONS_FOR_RECIP_MUL default_min_divisions_for_recip_mul\n #endif\n \n+#ifndef TARGET_MODE_REP_EXTENDED\n+#define TARGET_MODE_REP_EXTENDED default_mode_rep_extended\n+#endif\n+\n #ifndef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n@@ -637,6 +641,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_SHIFT_TRUNCATION_MASK,\t\t\t\\\n   TARGET_MIN_DIVISIONS_FOR_RECIP_MUL,\t\t\\\n+  TARGET_MODE_REP_EXTENDED,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\"}, {"sha": "f0287545d7ec6160c5fe9d6ad7006e716d75e25d", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -520,6 +520,14 @@ struct gcc_target\n      the reciprocal.  */\n   unsigned int (* min_divisions_for_recip_mul) (enum machine_mode mode);\n \n+  /* If the representation of integral MODE is such that values are\n+     always sign-extended to a wider mode MODE_REP then return\n+     SIGN_EXTEND.  Return UNKNOWN otherwise.  */\n+  /* Note that the return type ought to be RTX_CODE, but that's not\n+     necessarily defined at this point.  */\n+  int (* mode_rep_extended) (enum machine_mode mode,\n+\t\t\t     enum machine_mode mode_rep);\n+\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n "}, {"sha": "a12d6b557ba213fb447c4138c174b34faefe04fe", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -156,6 +156,15 @@ default_min_divisions_for_recip_mul (enum machine_mode mode ATTRIBUTE_UNUSED)\n   return have_insn_for (DIV, mode) ? 3 : 2;\n }\n \n+/* The default implementation of TARGET_MODE_REP_EXTENDED.  */\n+\n+int\n+default_mode_rep_extended (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode_rep ATTRIBUTE_UNUSED)\n+{\n+  return UNKNOWN;\n+}\n+\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */\n \n bool"}, {"sha": "f6d50ddf6e2a01aa26c484a9e9e8d359d573a199", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cbf2cc559fa466b854d89bc4069d7282a881f/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=b12cbf2cc559fa466b854d89bc4069d7282a881f", "patch": "@@ -34,6 +34,7 @@ extern enum machine_mode default_eh_return_filter_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (enum machine_mode);\n extern unsigned int default_min_divisions_for_recip_mul (enum machine_mode);\n+extern int default_mode_rep_extended (enum machine_mode, enum machine_mode);\n \n extern tree default_stack_protect_guard (void);\n extern tree default_external_stack_protect_fail (void);"}]}