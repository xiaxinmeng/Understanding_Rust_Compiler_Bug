{"sha": "5e038cad0bb468177c7adad1faebf3465ecda0fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwMzhjYWQwYmI0NjgxNzdjN2FkYWQxZmFlYmYzNDY1ZWNkYTBmZA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-09-22T07:55:39Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-09-22T07:55:39Z"}, "message": "re PR tree-optimization/37482 (definition in block 51 follows the use for SSA_NAME with -maltivec)\n\n\tPR tree-optimization/37482\n\t* tree-vectorizer.h (struct _slp_instance): Add new field.\n\t(SLP_INSTANCE_FIRST_LOAD_STMT): New.\n\t(get_earlier_stmt): New function.\n\t* tree-vect-analyze.c (vect_find_first_load_in_slp_instance): New\n\tfunction.\n\t(vect_analyze_slp_instance): Set SLP_INSTANCE_FIRST_LOAD_STMT.\n\t* tree-vect-transform.c (vect_finish_stmt_generation): Remove the\n\tasserts that GSI points to the scalar statement being vectorized.\n\tSet new statement location according to GSI.\n\t(vect_schedule_slp_instance): Use GSI of\n\tSLP_INSTANCE_FIRST_LOAD_STMT when vectorizing loads.\n\nFrom-SVN: r140544", "tree": {"sha": "083ed4affd0a185e5e877ef640693c7f6195fbb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/083ed4affd0a185e5e877ef640693c7f6195fbb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e038cad0bb468177c7adad1faebf3465ecda0fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e038cad0bb468177c7adad1faebf3465ecda0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e038cad0bb468177c7adad1faebf3465ecda0fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e038cad0bb468177c7adad1faebf3465ecda0fd/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c801c273a6b8080f3fce824b3872fae899385618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c801c273a6b8080f3fce824b3872fae899385618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c801c273a6b8080f3fce824b3872fae899385618"}], "stats": {"total": 123, "additions": 114, "deletions": 9}, "files": [{"sha": "0987ef03723aa6d5f3c69816ceb4a276be43e1de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -1,3 +1,18 @@\n+2008-09-22  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37482\n+\t* tree-vectorizer.h (struct _slp_instance): Add new field.\n+\t(SLP_INSTANCE_FIRST_LOAD_STMT): New.\n+\t(get_earlier_stmt): New function.\n+\t* tree-vect-analyze.c (vect_find_first_load_in_slp_instance): New\n+\tfunction.\n+\t(vect_analyze_slp_instance): Set SLP_INSTANCE_FIRST_LOAD_STMT.\n+\t* tree-vect-transform.c (vect_finish_stmt_generation): Remove the\n+\tasserts that GSI points to the scalar statement being vectorized.\n+\tSet new statement location according to GSI.\n+\t(vect_schedule_slp_instance): Use GSI of\n+\tSLP_INSTANCE_FIRST_LOAD_STMT when vectorizing loads.\n+\n 2008-09-21  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-cp.c (ipcp_estimate_growth): Check recursive calls."}, {"sha": "2af0a0e182fc76e68f91aadc5259d6c4ff91dfd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -1,3 +1,8 @@\n+2008-09-22  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37482\n+\t* gcc.dg/vect/pr37482.c: New test.\n+\n 2008-09-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR middle-end/37170"}, {"sha": "0b3bed33afae9622fbc8ffad1382f44feab46a3d", "filename": "gcc/testsuite/gcc.dg/vect/pr37482.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37482.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37482.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37482.c?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+void SexiALI_Convert(void *vdest, void *vsrc, unsigned int frames)\n+{\n+ unsigned int x;\n+ short *src = vsrc;\n+ unsigned char *dest = vdest;\n+ for(x=0;x<256;x++)\n+ {\n+  int tmp;\n+  tmp = *src;\n+  src++;\n+  tmp += *src;\n+  src++;\n+  *dest++ = tmp;\n+  *dest++ = tmp;\n+ }\n+}\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "c97b3fa10142df4a062920a6a6acd521c6b10b32", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -3228,6 +3228,32 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   return false; \n }\n \n+\n+/* Find the first load in the loop that belongs to INSTANCE. \n+   When loads are in several SLP nodes, there can be a case in which the first\n+   load does not appear in the first SLP node to be transformed, causing \n+   incorrect order of statements. Since we generate all the loads together,\n+   they must be inserted before the first load of the SLP instance and not\n+   before the first load of the first node of the instance.  */\n+static gimple \n+vect_find_first_load_in_slp_instance (slp_instance instance) \n+{\n+  int i, j;\n+  slp_tree load_node;\n+  gimple first_load = NULL, load;\n+\n+  for (i = 0; \n+       VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (instance), i, load_node); \n+       i++)\n+    for (j = 0; \n+         VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (load_node), j, load);\n+         j++)\n+      first_load = get_earlier_stmt (load, first_load);\n+  \n+  return first_load;\n+}\n+\n+\n /* Analyze an SLP instance starting from a group of strided stores. Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.  \n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n@@ -3312,6 +3338,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n       SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n+      SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n       SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n       if (VEC_length (slp_tree, loads))\n         {\n@@ -3328,6 +3355,9 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n               vect_free_slp_instance (new_instance);\n               return false;\n             }\n+\n+          SLP_INSTANCE_FIRST_LOAD_STMT (new_instance)\n+             = vect_find_first_load_in_slp_instance (new_instance);\n         }\n       else\n         VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (new_instance));"}, {"sha": "d004aadee7bb0ef6bbfbfbc3a82bf5d52e87f791", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -2155,7 +2155,6 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n-  gcc_assert (stmt == gsi_stmt (*gsi));\n   gcc_assert (gimple_code (stmt) != GIMPLE_LABEL);\n \n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n@@ -2168,10 +2167,7 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n       print_gimple_stmt (vect_dump, vec_stmt, 0, TDF_SLIM);\n     }\n \n-  /* Make sure gsi points to the stmt that is being vectorized.  */\n-  gcc_assert (stmt == gsi_stmt (*gsi));\n-\n-  gimple_set_location (vec_stmt, gimple_location (stmt));\n+  gimple_set_location (vec_stmt, gimple_location (gsi_stmt (*gsi)));\n }\n \n \n@@ -8156,7 +8152,7 @@ vect_remove_stores (gimple first_stmt)\n \n static bool\n vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n-                            unsigned int vectorization_factor)\n+                            unsigned int vectorization_factor) \n {\n   gimple stmt;\n   bool strided_store, is_store;\n@@ -8177,6 +8173,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   \n   stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n   stmt_info = vinfo_for_stmt (stmt);\n+\n   /* VECTYPE is the type of the destination.  */\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (gimple_assign_lhs (stmt)));\n   nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (vectype);\n@@ -8218,7 +8215,14 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n     }\t\n \n-  si = gsi_for_stmt (stmt);\n+  /* Loads should be inserted before the first load.  */\n+  if (SLP_INSTANCE_FIRST_LOAD_STMT (instance)\n+      && STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+      && !REFERENCE_CLASS_P (gimple_get_lhs (stmt)))\n+    si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n+  else\n+    si = gsi_for_stmt (stmt);\n+\n   is_store = vect_transform_stmt (stmt, &si, &strided_store, node, instance);\n   if (is_store)\n     {\n@@ -8252,8 +8256,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo)\n     {\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n-                                          instance,\n-                                          LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+                            instance, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n \t\t\t  \n       if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS)\n \t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))"}, {"sha": "84bd8ccd04df09ed78713784f65701f9fad7ddf2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e038cad0bb468177c7adad1faebf3465ecda0fd/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5e038cad0bb468177c7adad1faebf3465ecda0fd", "patch": "@@ -133,6 +133,10 @@ typedef struct _slp_instance {\n \n   /* The group of nodes that contain loads of this SLP instance.  */\n   VEC (slp_tree, heap) *loads;\n+\n+  /* The first scalar load of the instance. The created vector loads will be\n+     inserted before this statement.  */\n+  gimple first_load;\n } *slp_instance;\n \n DEF_VEC_P(slp_instance);\n@@ -146,6 +150,7 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_INSTANCE_INSIDE_OF_LOOP_COST(S)      (S)->cost.inside_of_loop\n #define SLP_INSTANCE_LOAD_PERMUTATION(S)         (S)->load_permutation\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n+#define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n \n #define SLP_TREE_LEFT(S)                         (S)->left\n #define SLP_TREE_RIGHT(S)                        (S)->right\n@@ -578,6 +583,32 @@ set_vinfo_for_stmt (gimple stmt, stmt_vec_info info)\n     VEC_replace (vec_void_p, stmt_vec_info_vec, uid - 1, (vec_void_p) info);\n }\n \n+static inline gimple\n+get_earlier_stmt (gimple stmt1, gimple stmt2)\n+{\n+  unsigned int uid1, uid2;\n+\n+  if (stmt1 == NULL)\n+    return stmt2;\n+\n+  if (stmt2 == NULL)\n+    return stmt1;\n+\n+  uid1 = gimple_uid (stmt1);\n+  uid2 = gimple_uid (stmt2);\n+\n+  if (uid1 == 0 || uid2 == 0)\n+    return NULL;\n+\n+  gcc_assert (uid1 <= VEC_length (vec_void_p, stmt_vec_info_vec));\n+  gcc_assert (uid2 <= VEC_length (vec_void_p, stmt_vec_info_vec));\n+\n+  if (uid1 < uid2)\n+    return stmt1;\n+  else\n+    return stmt2;\n+}\n+\n static inline bool\n is_pattern_stmt_p (stmt_vec_info stmt_info)\n {"}]}