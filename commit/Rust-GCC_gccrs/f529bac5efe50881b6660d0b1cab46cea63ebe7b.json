{"sha": "f529bac5efe50881b6660d0b1cab46cea63ebe7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUyOWJhYzVlZmU1MDg4MWI2NjYwZDBiMWNhYjQ2Y2VhNjNlYmU3Yg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonber@gnat.com", "date": "2004-10-27T13:40:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T13:40:08Z"}, "message": "sem_attr.adb (Resolve_Attribute, [...]): Apply proper accessibility check to prefix that is a protected operation.\n\n2004-10-26  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_attr.adb (Resolve_Attribute, case 'Access): Apply proper\n\taccessibility check to prefix that is a protected operation.\n\nFrom-SVN: r89665", "tree": {"sha": "68744e82d40be5b0c1ea4958e4ce8f4dd12c99f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68744e82d40be5b0c1ea4958e4ce8f4dd12c99f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f529bac5efe50881b6660d0b1cab46cea63ebe7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f529bac5efe50881b6660d0b1cab46cea63ebe7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f529bac5efe50881b6660d0b1cab46cea63ebe7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f529bac5efe50881b6660d0b1cab46cea63ebe7b/comments", "author": null, "committer": null, "parents": [{"sha": "282c6a893499762fecad905c5ffdc4161af395f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282c6a893499762fecad905c5ffdc4161af395f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282c6a893499762fecad905c5ffdc4161af395f8"}], "stats": {"total": 138, "additions": 87, "deletions": 51}, "files": [{"sha": "cc9017331e709de4b4b4f0cbd5d60c51e5b8fca0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 87, "deletions": 51, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f529bac5efe50881b6660d0b1cab46cea63ebe7b/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f529bac5efe50881b6660d0b1cab46cea63ebe7b/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f529bac5efe50881b6660d0b1cab46cea63ebe7b", "patch": "@@ -1537,7 +1537,7 @@ package body Sem_Attr is\n       --   unanalyzed copy for tree transformation. The analyzed copy is used\n       --   for its semantic information (whether prefix is a remote subprogram\n       --   name), the unanalyzed copy is used to construct new subtree rooted\n-      --   with N_aggregate which represents a fat pointer aggregate.\n+      --   with N_Aggregate which represents a fat pointer aggregate.\n \n       if Aname = Name_Access then\n          Discard_Node (Copy_Separate_Tree (N));\n@@ -6414,6 +6414,63 @@ package body Sem_Attr is\n       It       : Interp;\n       Nom_Subt : Entity_Id;\n \n+      procedure Accessibility_Message;\n+      --  Error, or warning within an instance, if the static accessibility\n+      --  rules of 3.10.2 are violated.\n+\n+      ---------------------------\n+      -- Accessibility_Message --\n+      ---------------------------\n+\n+      procedure Accessibility_Message is\n+         Indic : Node_Id := Parent (Parent (N));\n+\n+      begin\n+         --  In an instance, this is a runtime check, but one we\n+         --  know will fail, so generate an appropriate warning.\n+\n+         if In_Instance_Body then\n+            Error_Msg_N\n+              (\"?non-local pointer cannot point to local object\", P);\n+            Error_Msg_N\n+              (\"?Program_Error will be raised at run time\", P);\n+            Rewrite (N,\n+              Make_Raise_Program_Error (Loc,\n+                Reason => PE_Accessibility_Check_Failed));\n+            Set_Etype (N, Typ);\n+            return;\n+\n+         else\n+            Error_Msg_N\n+              (\"non-local pointer cannot point to local object\", P);\n+\n+            --  Check for case where we have a missing access definition\n+\n+            if Is_Record_Type (Current_Scope)\n+              and then\n+                (Nkind (Parent (N)) = N_Discriminant_Association\n+                   or else\n+                 Nkind (Parent (N)) = N_Index_Or_Discriminant_Constraint)\n+            then\n+               Indic := Parent (Parent (N));\n+               while Present (Indic)\n+                 and then Nkind (Indic) /= N_Subtype_Indication\n+               loop\n+                  Indic := Parent (Indic);\n+               end loop;\n+\n+               if Present (Indic) then\n+                  Error_Msg_NE\n+                    (\"\\use an access definition for\" &\n+                      \" the access discriminant of&\", N,\n+                         Entity (Subtype_Mark (Indic)));\n+               end if;\n+            end if;\n+         end if;\n+      end Accessibility_Message;\n+\n+   --  Start of processing for Resolve_Attribute\n+\n    begin\n       --  If error during analysis, no point in continuing, except for\n       --  array types, where we get  better recovery by using unconstrained\n@@ -6579,9 +6636,14 @@ package body Sem_Attr is\n                   --  outside a generic body when the subprogram is declared\n                   --  within that generic body.\n \n+                  --  Ada2005: If the expected type is for an access\n+                  --  parameter, this clause does not apply.\n+\n                   elsif Present (Enclosing_Generic_Body (Entity (P)))\n                     and then Enclosing_Generic_Body (Entity (P)) /=\n                              Enclosing_Generic_Body (Btyp)\n+                    and then\n+                      Ekind (Btyp) /= E_Anonymous_Access_Subprogram_Type\n                   then\n                      Error_Msg_N\n                        (\"access type must not be outside generic body\", P);\n@@ -6802,60 +6864,34 @@ package body Sem_Attr is\n                  and then Object_Access_Level (P) > Type_Access_Level (Btyp)\n                  and then Ekind (Btyp) = E_General_Access_Type\n                then\n-                  --  In an instance, this is a runtime check, but one we\n-                  --  know will fail, so generate an appropriate warning.\n-\n-                  if In_Instance_Body then\n-                     Error_Msg_N\n-                       (\"?non-local pointer cannot point to local object\", P);\n-                     Error_Msg_N\n-                       (\"?Program_Error will be raised at run time\", P);\n-                     Rewrite (N,\n-                       Make_Raise_Program_Error (Loc,\n-                         Reason => PE_Accessibility_Check_Failed));\n-                     Set_Etype (N, Typ);\n-                     return;\n-\n-                  else\n-                     Error_Msg_N\n-                       (\"non-local pointer cannot point to local object\", P);\n-\n-                     if Is_Record_Type (Current_Scope)\n-                       and then (Nkind (Parent (N)) =\n-                                  N_Discriminant_Association\n-                                   or else\n-                                 Nkind (Parent (N)) =\n-                                   N_Index_Or_Discriminant_Constraint)\n-                     then\n-                        declare\n-                           Indic : Node_Id := Parent (Parent (N));\n-\n-                        begin\n-                           while Present (Indic)\n-                             and then Nkind (Indic) /= N_Subtype_Indication\n-                           loop\n-                              Indic := Parent (Indic);\n-                           end loop;\n-\n-                           if Present (Indic) then\n-                              Error_Msg_NE\n-                                (\"\\use an access definition for\" &\n-                                  \" the access discriminant of&\", N,\n-                                  Entity (Subtype_Mark (Indic)));\n-                           end if;\n-                        end;\n-                     end if;\n-                  end if;\n+                  Accessibility_Message;\n+                  return;\n                end if;\n             end if;\n \n-            if (Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n-                  or else\n-                Ekind (Btyp) = E_Anonymous_Access_Protected_Subprogram_Type)\n-              and then Is_Entity_Name (P)\n-              and then not Is_Protected_Type (Scope (Entity (P)))\n+            if Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n+                 or else\n+               Ekind (Btyp) = E_Anonymous_Access_Protected_Subprogram_Type\n             then\n-               Error_Msg_N (\"context requires a protected subprogram\", P);\n+               if Is_Entity_Name (P)\n+                 and then not Is_Protected_Type (Scope (Entity (P)))\n+               then\n+                  Error_Msg_N (\"context requires a protected subprogram\", P);\n+\n+               --  Check accessibility of protected object against that\n+               --  of the access type, but only on user code, because\n+               --  the expander creates access references for handlers.\n+               --  If the context is an anonymous_access_to_protected,\n+               --  there are no accessibility checks either.\n+\n+               elsif Object_Access_Level (P) > Type_Access_Level (Btyp)\n+                 and then Comes_From_Source (N)\n+                 and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n+                 and then No (Original_Access_Type (Typ))\n+               then\n+                  Accessibility_Message;\n+                  return;\n+               end if;\n \n             elsif (Ekind (Btyp) = E_Access_Subprogram_Type\n                      or else"}]}