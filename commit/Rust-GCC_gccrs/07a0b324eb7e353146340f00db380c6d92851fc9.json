{"sha": "07a0b324eb7e353146340f00db380c6d92851fc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdhMGIzMjRlYjdlMzUzMTQ2MzQwZjAwZGIzODBjNmQ5Mjg1MWZjOQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2011-10-17T09:59:27Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-10-17T09:59:27Z"}, "message": "Emit macro expansion related diagnostics\n\nIn this third instalment the diagnostic machinery -- when faced with\nthe virtual location of a token resulting from macro expansion -- uses\nthe new linemap APIs to unwind the stack of macro expansions that led\nto that token and emits a [hopefully] more useful message than what we\nhave today.\n\ndiagnostic_report_current_module has been slightly changed to use the\nlocation given by client code instead of the global input_location\nvariable.  This results in more precise diagnostic locations in\ngeneral but then the patch adjusts some C++ tests which output changed\nas a result of this.\n\nThree new regression tests have been added.\n\nThe mandatory screenshot goes like this:\n\n[dodji@adjoa gcc]$ cat -n test.c\n     1    #define OPERATE(OPRD1, OPRT, OPRD2) \\\n     2      OPRD1 OPRT OPRD2;\n     3\n     4    #define SHIFTL(A,B) \\\n     5      OPERATE (A,<<,B)\n     6\n     7    #define MULT(A) \\\n     8      SHIFTL (A,1)\n     9\n    10    void\n    11    g ()\n    12    {\n    13      MULT (1.0);/* 1.0 << 1; <-- so this is an error.  */\n    14    }\n\n[dodji@adjoa gcc]$ ./cc1 -quiet -ftrack-macro-expansion test.c\ntest.c: In function 'g':\ntest.c:5:14: erreur: invalid operands to binary << (have 'double' and 'int')\ntest.c:2:9: note: in expansion of macro 'OPERATE'\ntest.c:5:3: note: expanded from here\ntest.c:5:14: note: in expansion of macro 'SHIFTL'\ntest.c:8:3: note: expanded from here\ntest.c:8:3: note: in expansion of macro 'MULT2'\ntest.c:13:3: note: expanded from here\n\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r180083", "tree": {"sha": "f61c52285dfb7b5d1466077cc0069c8ecc04e810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f61c52285dfb7b5d1466077cc0069c8ecc04e810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07a0b324eb7e353146340f00db380c6d92851fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a0b324eb7e353146340f00db380c6d92851fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a0b324eb7e353146340f00db380c6d92851fc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a0b324eb7e353146340f00db380c6d92851fc9/comments", "author": null, "committer": null, "parents": [{"sha": "92582b753e34fd574b6a5672b2f82979c966187a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92582b753e34fd574b6a5672b2f82979c966187a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92582b753e34fd574b6a5672b2f82979c966187a"}], "stats": {"total": 354, "additions": 343, "deletions": 11}, "files": [{"sha": "ed680173a1fe75e30a4b1f17036bb5a11067bbff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -1,3 +1,24 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* gcc/diagnostic.h (diagnostic_report_current_module): Add a\n+\tlocation parameter.\n+\t* diagnostic.c (diagnostic_report_current_module): Add a location\n+\tparameter to the function definition.  Use it instead of\n+\tinput_location.  Resolve the virtual location rather than just\n+\tlooking up its map and risking to touch a resulting macro map.\n+\t(default_diagnostic_starter): Pass the relevant diagnostic\n+\tlocation to diagnostic_report_current_module.\n+\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): New.\n+\t(virt_loc_aware_diagnostic_finalizer): Likewise.\n+\t(diagnostic_report_current_function): Pass the\n+\trelevant location to diagnostic_report_current_module.\n+\t* tree-diagnostic.h (virt_loc_aware_diagnostic_finalizer): Declare\n+\tnew function.\n+\t* toplev.c (general_init): By default, use the new\n+\tvirt_loc_aware_diagnostic_finalizer as diagnostic finalizer.\n+\t* Makefile.in: Add vec.h dependency to tree-diagnostic.c.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "6e3fecd40af7ea863e1a6202fdc3dfe9d0f84f71", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -2805,7 +2805,8 @@ tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TM_H) coretypes.h tree-iterator.h $(SCEV_H) langhooks.h \\\n    $(TREE_PASS_H) value-prof.h output.h tree-pretty-print.h\n tree-diagnostic.o : tree-diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_H) $(DIAGNOSTIC_H) tree-diagnostic.h langhooks.h $(LANGHOOKS_DEF_H)\n+   $(TREE_H) $(DIAGNOSTIC_H) tree-diagnostic.h langhooks.h $(LANGHOOKS_DEF_H) \\\n+   $(VEC_H)\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h $(TARGET_H) \\"}, {"sha": "7e80282a7f5615a90f082130cc5b2fc3cc8a2293", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -1,3 +1,10 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* error.c (cp_diagnostic_starter): Pass the relevant location to\n+\tdiagnostic_report_current_module.\n+\t(cp_diagnostic_finalizer): Call virt_loc_aware_diagnostic_finalizer.\n+\n 2011-10-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/48489"}, {"sha": "c6110b220fa58d93065b22f1b32a3d5a4af38ff4", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -2769,7 +2769,7 @@ static void\n cp_diagnostic_starter (diagnostic_context *context,\n \t\t       diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context);\n+  diagnostic_report_current_module (context, diagnostic->location);\n   cp_print_error_function (context, diagnostic);\n   maybe_print_instantiation_context (context);\n   maybe_print_constexpr_context (context);\n@@ -2779,8 +2779,9 @@ cp_diagnostic_starter (diagnostic_context *context,\n \n static void\n cp_diagnostic_finalizer (diagnostic_context *context,\n-\t\t\t diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n+\t\t\t diagnostic_info *diagnostic)\n {\n+  virt_loc_aware_diagnostic_finalizer (context, diagnostic);\n   pp_base_destroy_prefix (context->printer);\n }\n "}, {"sha": "a8c0e6693520430b5f0736c02d8f2bf5f1725c6e", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -255,20 +255,23 @@ diagnostic_action_after_output (diagnostic_context *context,\n }\n \n void\n-diagnostic_report_current_module (diagnostic_context *context)\n+diagnostic_report_current_module (diagnostic_context *context, location_t where)\n {\n-  const struct line_map *map;\n+  const struct line_map *map = NULL;\n \n   if (pp_needs_newline (context->printer))\n     {\n       pp_newline (context->printer);\n       pp_needs_newline (context->printer) = false;\n     }\n \n-  if (input_location <= BUILTINS_LOCATION)\n+  if (where <= BUILTINS_LOCATION)\n     return;\n \n-  map = linemap_lookup (line_table, input_location);\n+  linemap_resolve_location (line_table, where,\n+\t\t\t    LRK_MACRO_DEFINITION_LOCATION,\n+\t\t\t    &map);\n+\n   if (map && diagnostic_last_module_changed (context, map))\n     {\n       diagnostic_set_last_module (context, map);\n@@ -301,7 +304,7 @@ void\n default_diagnostic_starter (diagnostic_context *context,\n \t\t\t    diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context);\n+  diagnostic_report_current_module (context, diagnostic->location);\n   pp_set_prefix (context->printer, diagnostic_build_prefix (context,\n \t\t\t\t\t\t\t    diagnostic));\n }"}, {"sha": "4b1265b78868e3f995f8dd67e79a81b6636b1bab", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -253,7 +253,7 @@ extern diagnostic_context *global_dc;\n /* Diagnostic related functions.  */\n extern void diagnostic_initialize (diagnostic_context *, int);\n extern void diagnostic_finish (diagnostic_context *);\n-extern void diagnostic_report_current_module (diagnostic_context *);\n+extern void diagnostic_report_current_module (diagnostic_context *, location_t);\n \n /* Force diagnostics controlled by OPTIDX to be kind KIND.  */\n extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,"}, {"sha": "1215af60e6448be961283e84f90b2c79409120e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -1,3 +1,13 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* lib/prune.exp (prune_gcc_output):  Prune output referring to\n+\tincluded files.\n+\t* gcc.dg/cpp/macro-exp-tracking-1.c: New test.\n+\t* gcc.dg/cpp/macro-exp-tracking-2.c: Likewise.\n+\t* gcc.dg/cpp/macro-exp-tracking-3.c: Likewise.\n+\t* gcc.dg/cpp/pragma-diagnostic-2.c: Likewise.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "d975c8cee97f2b8986d146db8bd4334243f7538d", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -0,0 +1,21 @@\n+/*\n+   { dg-options \"-ftrack-macro-expansion=1\" }\n+   { dg-do compile }\n+*/\n+\n+#define OPERATE(OPRD1, OPRT, OPRD2) \\\n+do \\\n+{ \\\n+  OPRD1 OPRT OPRD2; /* { dg-message \"expansion\" }*/ \t   \\\n+} while (0)\n+\n+#define SHIFTL(A,B) \\\n+  OPERATE (A,<<,B) /* { dg-message \"expanded|expansion\" } */\n+\n+void\n+foo ()\n+{\n+  SHIFTL (0.1,0.2); /* { dg-message \"expanded\" } */\n+}\n+\n+/* { dg-error \"invalid operands\" \"\" { target *-*-* } 13 } */"}, {"sha": "684af4c7507af1df15319220f4b9a295f7321355", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -0,0 +1,21 @@\n+/* \n+   { dg-options \"-ftrack-macro-expansion=1\" }\n+   { dg-do compile }\n+*/\n+\n+#define OPERATE(OPRD1, OPRT, OPRD2) \\\n+ OPRD1 OPRT OPRD2;\t\t/* { dg-message \"expansion\" } */\n+\n+#define SHIFTL(A,B) \\\n+  OPERATE (A,<<,B) /* { dg-message \"expanded|expansion\" } */\n+\n+#define MULT(A) \\\n+  SHIFTL (A,1)\t\t\t/* { dg-message \"expanded|expansion\" } */\n+\n+void\n+foo ()\n+{\n+  MULT (1.0);\t\t\t/* { dg-message \"expanded\" } */\n+}\n+\n+/* { dg-error \"invalid operands to binary <<\" \"\" { target *-*-* } { 10 } } */"}, {"sha": "119053ef9fbcfbd85a527f908c8172a1288b198f", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -0,0 +1,14 @@\n+/*\n+  { dg-options \"-fshow-column -ftrack-macro-expansion=1\" }\n+  { dg-do compile }\n+ */\n+\n+#define SQUARE(A) A * A\t\t/* { dg-message \"expansion\" } */\n+\n+void\n+foo()\n+{\n+  SQUARE (1 << 0.1);\t\t/* { dg-message \"expanded\" } */\n+}\n+\n+/* { dg-error \"16:invalid operands to binary <<\" \"\" {target *-*-* } { 11 } } */"}, {"sha": "1f9fe6ad26c51525a1905fb92bcc3abb97f7af7f", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -0,0 +1,14 @@\n+/*\n+  { dg-options \"-fshow-column -ftrack-macro-expansion=2\" }\n+  { dg-do compile }\n+ */\n+\n+#define SQUARE(A) A * A\t\t/* { dg-message \"expansion\" } */\n+\n+void\n+foo()\n+{\n+  SQUARE (1 << 0.1);\t\t/* { dg-message \"expanded\" } */\n+}\n+\n+/* { dg-error \"13:invalid operands to binary <<\" \"\" { target *-*-* } { 11 } } */"}, {"sha": "7ab95b0c63bf6c3ad4416c3d39bcbadc52710081", "filename": "gcc/testsuite/gcc.dg/cpp/pragma-diagnostic-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -0,0 +1,34 @@\n+/*\n+  { dg-options \"-Wuninitialized -ftrack-macro-expansion=2\" }\n+  { dg-do compile }\n+*/\n+\n+void f (unsigned);\n+\n+#define CODE_WITH_WARNING \\\n+  int a; /* { dg-message \"expansion|declared here\" } */  \\\n+  f (a)\t /* { dg-message \"expansion\" } */\n+\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+\n+void\n+g (void)\n+{\n+  CODE_WITH_WARNING;\n+}\n+\n+#pragma GCC diagnostic push\n+\n+#pragma GCC diagnostic error \"-Wuninitialized\"\n+\n+void\n+h (void)\n+{\n+  CODE_WITH_WARNING;\t\t/* { dg-message \"expanded\" } */\n+}\n+\n+/*\n+  { dg-message \"some warnings being treated as errors\" \"\" {target *-*-*} 0 }\n+*/\n+\n+/* { dg-error \"uninitialized\" \"\" { target *-*-* } { 10 } } */"}, {"sha": "09d25811106376b2f233e9f5a5cc8710a02e4854", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -29,6 +29,7 @@ proc prune_gcc_output { text } {\n     regsub -all \"(^|\\n)collect: re(compiling|linking)\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)Please submit.*instructions\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[0-9\\]\\[0-9\\]* errors\\.\" $text \"\" text\n+    regsub -all \"(^|\\n)(In file included|\\[ \\]+from)\\[^\\n\\]*\" $text \"\" text\n \n     # Ignore informational notes.\n     regsub -all \"(^|\\n)\\[^\\n\\]*: note: \\[^\\n\\]*\" $text \"\" text"}, {"sha": "c43869c3b31efc4739d3ee6f9cc817187f7db9c4", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -1171,6 +1171,9 @@ general_init (const char *argv0)\n      can give warnings and errors.  */\n   diagnostic_initialize (global_dc, N_OPTS);\n   diagnostic_starter (global_dc) = default_tree_diagnostic_starter;\n+  /* By default print macro expansion contexts in the diagnostic\n+     finalizer -- for tokens resulting from macro macro expansion.  */\n+  diagnostic_finalizer (global_dc) = virt_loc_aware_diagnostic_finalizer;\n   /* Set a default printer.  Language specific initializations will\n      override it later.  */\n   pp_format_decoder (global_dc->printer) = &default_tree_printer;"}, {"sha": "53b350b54181e694331fe6b1d8655cae3189c094", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 181, "deletions": 1, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -28,14 +28,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-diagnostic.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"vec.h\"\n \n /* Prints out, if necessary, the name of the current function\n    that caused an error.  Called from all error and warning functions.  */\n void\n diagnostic_report_current_function (diagnostic_context *context,\n \t\t\t\t    diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context);\n+  diagnostic_report_current_module (context, diagnostic->location);\n   lang_hooks.print_error_function (context, input_filename, diagnostic);\n }\n \n@@ -47,3 +48,182 @@ default_tree_diagnostic_starter (diagnostic_context *context,\n   pp_set_prefix (context->printer, diagnostic_build_prefix (context,\n \t\t\t\t\t\t\t    diagnostic));\n }\n+\n+/* This is a pair made of a location and the line map it originated\n+   from.  It's used in the maybe_unwind_expanded_macro_loc function\n+   below.  */\n+typedef struct\n+{\n+  const struct line_map *map;\n+  source_location where;\n+} loc_t;\n+\n+DEF_VEC_O (loc_t);\n+DEF_VEC_ALLOC_O (loc_t, heap);\n+\n+/* Unwind the different macro expansions that lead to the token which\n+   location is WHERE and emit diagnostics showing the resulting\n+   unwound macro expansion trace.  Let's look at an example to see how\n+   the trace looks like.  Suppose we have this piece of code,\n+   artificially annotated with the line numbers to increase\n+   legibility:\n+\n+    $ cat -n test.c\n+      1    #define OPERATE(OPRD1, OPRT, OPRD2) \\\n+      2      OPRD1 OPRT OPRD2;\n+      3\n+      4    #define SHIFTL(A,B) \\\n+      5      OPERATE (A,<<,B)\n+      6\n+      7    #define MULT(A) \\\n+      8      SHIFTL (A,1)\n+      9\n+     10    void\n+     11    g ()\n+     12    {\n+     13      MULT (1.0);// 1.0 << 1; <-- so this is an error.\n+     14    }\n+\n+   Here is the diagnostic that we want the compiler to generate:\n+\n+    test.c: In function 'g':\n+    test.c:5:14: error: invalid operands to binary << (have 'double' and 'int')\n+    test.c:2:9: note: in expansion of macro 'OPERATE'\n+    test.c:5:3: note: expanded from here\n+    test.c:5:14: note: in expansion of macro 'SHIFTL'\n+    test.c:8:3: note: expanded from here\n+    test.c:8:3: note: in expansion of macro 'MULT2'\n+    test.c:13:3: note: expanded from here\n+\n+   The part that goes from the third to the eighth line of this\n+   diagnostic (the lines containing the 'note:' string) is called the\n+   unwound macro expansion trace.  That's the part generated by this\n+   function.\n+\n+   If FIRST_EXP_POINT_MAP is non-null, *FIRST_EXP_POINT_MAP is set to\n+   the map of the location in the source that first triggered the\n+   macro expansion.  This must be an ordinary map.  */\n+\n+static void\n+maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n+                                 diagnostic_info *diagnostic,\n+                                 source_location where,\n+                                 const struct line_map **first_exp_point_map)\n+{\n+  const struct line_map *map;\n+  VEC(loc_t,heap) *loc_vec = NULL;\n+  unsigned ix;\n+  loc_t loc, *iter;\n+\n+  map = linemap_lookup (line_table, where);\n+  if (!linemap_macro_expansion_map_p (map))\n+    return;\n+\n+  /* Let's unwind the macros that got expanded and led to the token\n+     which location is WHERE.  We are going to store these macros into\n+     LOC_VEC, so that we can later walk it at our convenience to\n+     display a somewhat meaningful trace of the macro expansion\n+     history to the user.  Note that the first macro of the trace\n+     (which is OPERATE in the example above) is going to be stored at\n+     the beginning of LOC_VEC.  */\n+\n+  do\n+    {\n+      loc.where = where;\n+      loc.map = map;\n+\n+      VEC_safe_push (loc_t, heap, loc_vec, &loc);\n+\n+      /* WHERE is the location of a token inside the expansion of a\n+         macro.  MAP is the map holding the locations of that macro\n+         expansion.  Let's get the location of the token inside the\n+         context that triggered the expansion of this macro.\n+         This is basically how we go \"down\" in the trace of macro\n+         expansions that led to WHERE.  */\n+      where = linemap_unwind_toward_expansion (line_table, where, &map);\n+    } while (linemap_macro_expansion_map_p (map));\n+\n+  if (first_exp_point_map)\n+    *first_exp_point_map = map;\n+\n+  /* Walk LOC_VEC and print the macro expansion trace, unless the\n+     first macro which expansion triggered this trace was expanded\n+     inside a system header.  */\n+  if (!LINEMAP_SYSP (map))\n+    FOR_EACH_VEC_ELT (loc_t, loc_vec, ix, iter)\n+      {\n+        source_location resolved_def_loc = 0, resolved_exp_loc = 0;\n+        diagnostic_t saved_kind;\n+        const char *saved_prefix;\n+        source_location saved_location;\n+\n+        /* Okay, now here is what we want.  For each token resulting\n+           from macro expansion we want to show: 1/ where in the\n+           definition of the macro the token comes from; 2/ where the\n+           macro got expanded.  */\n+\n+        /* Resolve the location iter->where into the locus 1/ of the\n+           comment above.  */\n+        resolved_def_loc =\n+          linemap_resolve_location (line_table, iter->where,\n+                                    LRK_MACRO_DEFINITION_LOCATION, NULL);\n+\n+        /* Resolve the location of the expansion point of the macro\n+           which expansion gave the token represented by def_loc.\n+           This is the locus 2/ of the earlier comment.  */\n+        resolved_exp_loc =\n+          linemap_resolve_location (line_table,\n+                                    MACRO_MAP_EXPANSION_POINT_LOCATION (iter->map),\n+                                    LRK_MACRO_DEFINITION_LOCATION, NULL);\n+\n+        saved_kind = diagnostic->kind;\n+        saved_prefix = context->printer->prefix;\n+        saved_location = diagnostic->location;\n+\n+        diagnostic->kind = DK_NOTE;\n+        diagnostic->location = resolved_def_loc;\n+        pp_base_set_prefix (context->printer,\n+                            diagnostic_build_prefix (context,\n+                                                     diagnostic));\n+        pp_newline (context->printer);\n+        pp_printf (context->printer, \"in expansion of macro '%s'\",\n+                   linemap_map_get_macro_name (iter->map));\n+        pp_destroy_prefix (context->printer);\n+\n+        diagnostic->location = resolved_exp_loc;\n+        pp_base_set_prefix (context->printer,\n+                            diagnostic_build_prefix (context,\n+                                                     diagnostic));\n+        pp_newline (context->printer);\n+        pp_printf (context->printer, \"expanded from here\");\n+        pp_destroy_prefix (context->printer);\n+\n+        diagnostic->kind = saved_kind;\n+        diagnostic->location = saved_location;\n+        context->printer->prefix = saved_prefix;\n+      }\n+\n+  VEC_free (loc_t, heap, loc_vec);\n+}\n+\n+/*  This is a diagnostic finalizer implementation that is aware of\n+    virtual locations produced by libcpp.\n+\n+    It has to be called by the diagnostic finalizer of front ends that\n+    uses libcpp and wish to get diagnostics involving tokens resulting\n+    from macro expansion.\n+\n+    For a given location, if said location belongs to a token\n+    resulting from a macro expansion, this starter prints the context\n+    of the token.  E.g, for multiply nested macro expansion, it\n+    unwinds the nested macro expansions and prints them in a manner\n+    that is similar to what is done for function call stacks, or\n+    template instantiation contexts.  */\n+void\n+virt_loc_aware_diagnostic_finalizer (diagnostic_context *context,\n+\t\t\t\t     diagnostic_info *diagnostic)\n+{\n+  maybe_unwind_expanded_macro_loc (context, diagnostic,\n+\t\t\t\t   diagnostic->location,\n+\t\t\t\t   NULL);\n+}"}, {"sha": "6b8e8e6e4375f0267471dda94dbca4b02563540e", "filename": "gcc/tree-diagnostic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftree-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a0b324eb7e353146340f00db380c6d92851fc9/gcc%2Ftree-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.h?ref=07a0b324eb7e353146340f00db380c6d92851fc9", "patch": "@@ -52,5 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n void default_tree_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n extern void diagnostic_report_current_function (diagnostic_context *,\n \t\t\t\t\t\tdiagnostic_info *);\n-\n+void virt_loc_aware_diagnostic_finalizer (diagnostic_context *,\n+\t\t\t\t\t  diagnostic_info *);\n #endif /* ! GCC_TREE_DIAGNOSTIC_H */"}]}