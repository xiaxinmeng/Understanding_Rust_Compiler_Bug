{"sha": "0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVkOWEzZTMxNDNlMDBhZjFlZDNmMTc5M2RkMTBjZDhkNjUwN2RlNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-11-19T11:29:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-11-19T11:29:10Z"}, "message": "re PR middle-end/23294 (fold does not fold a*C+a to a*(C+1) or a*C-a to a*(C-1))\n\n2005-11-19  Richard Guenther  <rguenther@suse.de>\n\n        PR middle-end/23294\n\t* fold-const.c (fold_plusminus_mult_expr): New function.\n\t(fold_binary): Use to canonicalize PLUS_EXPR and MINUS_EXPR\n\tcases, remove now unnecessary code.\n\n\t* gcc.dg/tree-ssa/pr23294.c: New testcase.\n\nFrom-SVN: r107218", "tree": {"sha": "21498ed60c2bf5fd17466e15a033794c45a3a290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21498ed60c2bf5fd17466e15a033794c45a3a290"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e32f9bcd598f6e2fef33a2278bd65f656ebf806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e32f9bcd598f6e2fef33a2278bd65f656ebf806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e32f9bcd598f6e2fef33a2278bd65f656ebf806"}], "stats": {"total": 300, "additions": 167, "deletions": 133}, "files": [{"sha": "1200433e317e3926355f969f900925e7cc1d9dce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "patch": "@@ -1,3 +1,10 @@\n+2005-11-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/23294\n+\t* fold-const.c (fold_plusminus_mult_expr): New function.\n+\t(fold_binary): Use to canonicalize PLUS_EXPR and MINUS_EXPR\n+\tcases, remove now unnecessary code.\n+\n 2005-11-19  Paolo Bonzini  <bonzini@gcc.gnu.org>\n \n \t* gensupport.c (old_preds): Rename to std_preds, add special field."}, {"sha": "b8576fc31b80aa0c6357288a74d39d82741b269f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 117, "deletions": 133, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "patch": "@@ -6556,6 +6556,104 @@ fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n   return fold_build2 (GE_EXPR, type, a, y);\n }\n \n+/* Fold a sum or difference of at least one multiplication.\n+   Returns the folded tree or NULL if no simplification could be made.  */\n+\n+static tree\n+fold_plusminus_mult_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n+{\n+  tree arg00, arg01, arg10, arg11;\n+  tree alt0 = NULL_TREE, alt1 = NULL_TREE, same;\n+\n+  /* (A * C) +- (B * C) -> (A+-B) * C.\n+     (A * C) +- A -> A * (C+-1).\n+     We are most concerned about the case where C is a constant,\n+     but other combinations show up during loop reduction.  Since\n+     it is not difficult, try all four possibilities.  */\n+\n+  if (TREE_CODE (arg0) == MULT_EXPR)\n+    {\n+      arg00 = TREE_OPERAND (arg0, 0);\n+      arg01 = TREE_OPERAND (arg0, 1);\n+    }\n+  else\n+    {\n+      arg00 = arg0;\n+      if (!FLOAT_TYPE_P (type))\n+\targ01 = build_int_cst (type, 1);\n+      else\n+\targ01 = build_real (type, dconst1);\n+    }\n+  if (TREE_CODE (arg1) == MULT_EXPR)\n+    {\n+      arg10 = TREE_OPERAND (arg1, 0);\n+      arg11 = TREE_OPERAND (arg1, 1);\n+    }\n+  else\n+    {\n+      arg10 = arg1;\n+      if (!FLOAT_TYPE_P (type))\n+\targ11 = build_int_cst (type, 1);\n+      else\n+\targ11 = build_real (type, dconst1);\n+    }\n+  same = NULL_TREE;\n+\n+  if (operand_equal_p (arg01, arg11, 0))\n+    same = arg01, alt0 = arg00, alt1 = arg10;\n+  else if (operand_equal_p (arg00, arg10, 0))\n+    same = arg00, alt0 = arg01, alt1 = arg11;\n+  else if (operand_equal_p (arg00, arg11, 0))\n+    same = arg00, alt0 = arg01, alt1 = arg10;\n+  else if (operand_equal_p (arg01, arg10, 0))\n+    same = arg01, alt0 = arg00, alt1 = arg11;\n+\n+  /* No identical multiplicands; see if we can find a common\n+     power-of-two factor in non-power-of-two multiplies.  This\n+     can help in multi-dimensional array access.  */\n+  else if (host_integerp (arg01, 0)\n+\t   && host_integerp (arg11, 0))\n+    {\n+      HOST_WIDE_INT int01, int11, tmp;\n+      bool swap = false;\n+      tree maybe_same;\n+      int01 = TREE_INT_CST_LOW (arg01);\n+      int11 = TREE_INT_CST_LOW (arg11);\n+\n+      /* Move min of absolute values to int11.  */\n+      if ((int01 >= 0 ? int01 : -int01)\n+\t  < (int11 >= 0 ? int11 : -int11))\n+        {\n+\t  tmp = int01, int01 = int11, int11 = tmp;\n+\t  alt0 = arg00, arg00 = arg10, arg10 = alt0;\n+\t  maybe_same = arg01;\n+\t  swap = true;\n+\t}\n+      else\n+\tmaybe_same = arg11;\n+\n+      if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n+        {\n+\t  alt0 = fold_build2 (MULT_EXPR, TREE_TYPE (arg00), arg00,\n+\t\t\t      build_int_cst (TREE_TYPE (arg00),\n+\t\t\t\t\t     int01 / int11));\n+\t  alt1 = arg10;\n+\t  same = maybe_same;\n+\t  if (swap)\n+\t    maybe_same = alt0, alt0 = alt1, alt1 = maybe_same;\n+\t}\n+    }\n+\n+  if (same)\n+    return fold_build2 (MULT_EXPR, type,\n+\t\t\tfold_build2 (code, type,\n+\t\t\t\t     fold_convert (type, alt0),\n+\t\t\t\t     fold_convert (type, alt1)),\n+\t\t\tfold_convert (type, same));\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a unary expression of code CODE and type TYPE with operand\n    OP0.  Return the folded expression if folding is successful.\n    Otherwise, return NULL_TREE.  */\n@@ -7205,6 +7303,17 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && integer_onep (arg1))\n \treturn fold_build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0));\n \n+      /* Handle (A1 * C1) + (A2 * C2) with A1, A2 or C1, C2 being the\n+\t same or one.  */\n+      if ((TREE_CODE (arg0) == MULT_EXPR\n+\t   || TREE_CODE (arg1) == MULT_EXPR)\n+\t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n+        {\n+\t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -7266,70 +7375,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t\t\t       parg1)));\n \t    }\n \n-\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n-\t    {\n-\t      tree arg00, arg01, arg10, arg11;\n-\t      tree alt0 = NULL_TREE, alt1 = NULL_TREE, same;\n-\n-\t      /* (A * C) + (B * C) -> (A+B) * C.\n-\t\t We are most concerned about the case where C is a constant,\n-\t\t but other combinations show up during loop reduction.  Since\n-\t\t it is not difficult, try all four possibilities.  */\n-\n-\t      arg00 = TREE_OPERAND (arg0, 0);\n-\t      arg01 = TREE_OPERAND (arg0, 1);\n-\t      arg10 = TREE_OPERAND (arg1, 0);\n-\t      arg11 = TREE_OPERAND (arg1, 1);\n-\t      same = NULL_TREE;\n-\n-\t      if (operand_equal_p (arg01, arg11, 0))\n-\t\tsame = arg01, alt0 = arg00, alt1 = arg10;\n-\t      else if (operand_equal_p (arg00, arg10, 0))\n-\t\tsame = arg00, alt0 = arg01, alt1 = arg11;\n-\t      else if (operand_equal_p (arg00, arg11, 0))\n-\t\tsame = arg00, alt0 = arg01, alt1 = arg10;\n-\t      else if (operand_equal_p (arg01, arg10, 0))\n-\t\tsame = arg01, alt0 = arg00, alt1 = arg11;\n-\n-\t      /* No identical multiplicands; see if we can find a common\n-\t\t power-of-two factor in non-power-of-two multiplies.  This\n-\t\t can help in multi-dimensional array access.  */\n-\t      else if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t       && TREE_CODE (arg11) == INTEGER_CST\n-\t\t       && TREE_INT_CST_HIGH (arg01) == 0\n-\t\t       && TREE_INT_CST_HIGH (arg11) == 0)\n-\t\t{\n-\t\t  HOST_WIDE_INT int01, int11, tmp;\n-\t\t  int01 = TREE_INT_CST_LOW (arg01);\n-\t\t  int11 = TREE_INT_CST_LOW (arg11);\n-\n-\t\t  /* Move min of absolute values to int11.  */\n-\t\t  if ((int01 >= 0 ? int01 : -int01)\n-\t\t      < (int11 >= 0 ? int11 : -int11))\n-\t\t    {\n-\t\t      tmp = int01, int01 = int11, int11 = tmp;\n-\t\t      alt0 = arg00, arg00 = arg10, arg10 = alt0;\n-\t\t      alt0 = arg01, arg01 = arg11, arg11 = alt0;\n-\t\t    }\n-\n-\t\t  if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n-\t\t    {\n-\t\t      alt0 = fold_build2 (MULT_EXPR, type, arg00,\n-\t\t\t\t\t  build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t int01 / int11));\n-\t\t      alt1 = arg10;\n-\t\t      same = arg11;\n-\t\t    }\n-\t\t}\n-\n-\t      if (same)\n-\t\treturn fold_build2 (MULT_EXPR, type,\n-\t\t\t\t    fold_build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t fold_convert (type, alt0),\n-\t\t\t\t\t\t fold_convert (type, alt1)),\n-\t\t\t\t    fold_convert (type, same));\n-\t    }\n-\n \t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n \t     of the array.  Loop optimizer sometimes produce this type of\n \t     expressions.  */\n@@ -7379,56 +7424,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    return fold_build2 (MULT_EXPR, type, arg0,\n \t\t\t\tbuild_real (type, dconst2));\n \n-\t  /* Convert x*c+x into x*(c+1).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg0) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c;\n-\n-\t      c = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n-\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold_build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t  build_real (type, c));\n-\t    }\n-\n-\t  /* Convert x+x*c into x*(c+1).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg1, 0), arg0, 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c;\n-\n-\t      c = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n-\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold_build2 (MULT_EXPR, type, arg0,\n-\t\t\t\t  build_real (type, c));\n-\t    }\n-\n-\t  /* Convert x*c1+x*c2 into x*(c1+c2).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg0) == MULT_EXPR\n-\t      && TREE_CODE (arg1) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c1, c2;\n-\n-\t      c1 = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n-\t      c2 = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n-\t      real_arithmetic (&c1, PLUS_EXPR, &c1, &c2);\n-\t      return fold_build2 (MULT_EXPR, type,\n-\t\t\t\t  TREE_OPERAND (arg0, 0),\n-\t\t\t\t  build_real (type, c1));\n-\t    }\n           /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  */\n           if (flag_unsafe_math_optimizations\n               && TREE_CODE (arg1) == PLUS_EXPR\n@@ -7771,26 +7766,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && (tem = distribute_real_division (code, type, arg0, arg1)))\n \treturn tem;\n \n-      if (TREE_CODE (arg0) == MULT_EXPR\n-\t  && TREE_CODE (arg1) == MULT_EXPR\n+      /* Handle (A1 * C1) - (A2 * C2) with A1, A2 or C1, C2 being the\n+\t same or one.  */\n+      if ((TREE_CODE (arg0) == MULT_EXPR\n+\t   || TREE_CODE (arg1) == MULT_EXPR)\n \t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n-\t{\n-          /* (A * C) - (B * C) -> (A-B) * C.  */\n-\t  if (operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t       TREE_OPERAND (arg1, 1), 0))\n-\t    return fold_build2 (MULT_EXPR, type,\n-\t\t\t\tfold_build2 (MINUS_EXPR, type,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 0)),\n-\t\t\t\tTREE_OPERAND (arg0, 1));\n-          /* (A * C1) - (A * C2) -> A * (C1-C2).  */\n-\t  if (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t       TREE_OPERAND (arg1, 0), 0))\n-\t    return fold_build2 (MULT_EXPR, type,\n-\t\t\t\tTREE_OPERAND (arg0, 0),\n-\t\t\t\tfold_build2 (MINUS_EXPR, type,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 1)));\n+        {\n+\t  tree tem = fold_plusminus_mult_expr (code, type, arg0, arg1);\n+\t  if (tem)\n+\t    return tem;\n \t}\n \n       goto associate;"}, {"sha": "3c79b1e854f3095aeed2ad2b0606a7d6e3405ac9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "patch": "@@ -1,3 +1,8 @@\n+2005-11-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/23294\n+\t* gcc.dg/tree-ssa/pr23294.c: New testcase.\n+\n 2005-11-19  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* gcc.dg/fold-overflow-1.c: Adjust for float output for mmix-*-*."}, {"sha": "0ab4ed2f85db7e42fa5f97d662d0d45a729cdbe4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23294.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23294.c?ref=0ed9a3e3143e00af1ed3f1793dd10cd8d6507de4", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-vars\" } */\n+\n+int f1(int a)\n+{\n+  return a*6-a;\n+}\n+\n+int f2(int a)\n+{\n+  return a*4+a;\n+}\n+\n+int f3(int a)\n+{\n+  return 2*a + 3*a;\n+}\n+\n+int f4(int a, int b)\n+{\n+  return 2*a + 6*b;\n+}\n+\n+int f5(int a, int b)\n+{\n+  return 2*a - 6*b;\n+}\n+\n+int f6(int a, int b)\n+{\n+  return 6*a - 2*b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"a \\\\\\* 5\" 3 \"vars\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\\\(b \\\\\\* 3 \\\\\\+ a\\\\\\) \\\\\\* 2\" \"vars\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\\\(a - b \\\\\\* 3\\\\\\) \\\\\\* 2\" \"vars\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\\\(a \\\\\\* 3 - b\\\\\\) \\\\\\* 2\" \"vars\" } } */\n+/* { dg-final { cleanup-tree-dump \"vars\" } } */"}]}