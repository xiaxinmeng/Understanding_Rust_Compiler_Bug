{"sha": "b972e036f40c12b106f9070c3e8adea0eb8a45fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3MmUwMzZmNDBjMTJiMTA2ZjkwNzBjM2U4YWRlYTBlYjhhNDVmYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-15T11:03:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-26T09:04:00Z"}, "message": "Move gimplify_buildN API local to only remaining user\n\nThis moves the legacy gimplify_buildN API to tree-vect-generic.c,\nits only user and elides the gimplification step, making it a wrapper\naround gimple_build, adjusting tree_vec_extract for this.\n\nI've noticed that vector CTOR expansion doesn't deal with unfolded\n{} and thus this makes it more resilent.  I've also adjusted the\nmatch.pd vector CTOR extraction code to make sure it doesn't\nproduce a CTOR when folding would make it a vector constant.\n\n2021-04-15  Richard Biener  <rguenther@suse.de>\n\n\t* tree-cfg.h (gimplify_build1): Remove.\n\t(gimplify_build2): Likewise.\n\t(gimplify_build3): Likewise.\n\t* tree-cfg.c (gimplify_build1): Move to tree-vect-generic.c.\n\t(gimplify_build2): Likewise.\n\t(gimplify_build3): Likewise.\n\t* tree-vect-generic.c (gimplify_build1): Move from tree-cfg.c.\n\tModernize.\n\t(gimplify_build2): Likewise.\n\t(gimplify_build3): Likewise.\n\t(tree_vec_extract): Use resimplify with following SSA edges.\n\t(expand_vector_parallel): Avoid passing NULL size/bitpos\n\tto tree_vec_extract.\n\t* expr.c (store_constructor): Deal with zero-element CTORs.\n\t* match.pd (bit_field_ref <vector CTOR>): Make sure to\n\tproduce vector constants when possible.", "tree": {"sha": "c7ea13fc150948db248df196e567eac1c4ddd729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7ea13fc150948db248df196e567eac1c4ddd729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b972e036f40c12b106f9070c3e8adea0eb8a45fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b972e036f40c12b106f9070c3e8adea0eb8a45fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b972e036f40c12b106f9070c3e8adea0eb8a45fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b972e036f40c12b106f9070c3e8adea0eb8a45fa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "152334cfb7a17bb3f1356f31a2e808d3ee459605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152334cfb7a17bb3f1356f31a2e808d3ee459605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152334cfb7a17bb3f1356f31a2e808d3ee459605"}], "stats": {"total": 158, "additions": 84, "deletions": 74}, "files": [{"sha": "5ed716cc8fa7a331cf76bd671e1d238feb8f4412", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b972e036f40c12b106f9070c3e8adea0eb8a45fa", "patch": "@@ -7019,7 +7019,9 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t/* Compute the size of the elements in the CTOR.  It differs\n \t   from the size of the vector type elements only when the\n \t   CTOR elements are vectors themselves.  */\n-\ttree val_type = TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value);\n+\ttree val_type = (CONSTRUCTOR_NELTS (exp) != 0\n+\t\t\t ? TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value)\n+\t\t\t : elttype);\n \tif (VECTOR_TYPE_P (val_type))\n \t  bitsize = tree_to_uhwi (TYPE_SIZE (val_type));\n \telse"}, {"sha": "66788ba6a86c86f8c70ff51e56ae3b8450ecda43", "filename": "gcc/match.pd", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b972e036f40c12b106f9070c3e8adea0eb8a45fa", "patch": "@@ -6203,7 +6203,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       /* We keep an exact subset of the constructor elements.  */\n       (if (multiple_p (idx, k, &elt) && multiple_p (n, k, &count))\n        (if (CONSTRUCTOR_NELTS (ctor) == 0)\n-        { build_constructor (type, NULL); }\n+        { build_zero_cst (type); }\n \t(if (count == 1)\n \t (if (elt < CONSTRUCTOR_NELTS (ctor))\n \t  (view_convert { CONSTRUCTOR_ELT (ctor, elt)->value; })\n@@ -6212,15 +6212,24 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t    ???  Eventually allow this if the CTOR ends up constant or\n \t    uniform.  */\n \t (if (single_use (@0))\n-\t  {\n-\t    vec<constructor_elt, va_gc> *vals;\n-\t    vec_alloc (vals, count);\n-\t    for (unsigned i = 0;\n-\t\t i < count && elt + i < CONSTRUCTOR_NELTS (ctor); ++i)\n-\t      CONSTRUCTOR_APPEND_ELT (vals, NULL_TREE,\n-\t\t\t\t      CONSTRUCTOR_ELT (ctor, elt + i)->value);\n-\t    build_constructor (type, vals);\n-\t  }))))\n+\t  (with\n+\t    {\n+\t      vec<constructor_elt, va_gc> *vals;\n+\t      vec_alloc (vals, count);\n+\t      bool constant_p = true;\n+\t      tree res;\n+\t      for (unsigned i = 0;\n+\t\t   i < count && elt + i < CONSTRUCTOR_NELTS (ctor); ++i)\n+\t\t{\n+\t\t  tree e = CONSTRUCTOR_ELT (ctor, elt + i)->value;\n+\t\t  CONSTRUCTOR_APPEND_ELT (vals, NULL_TREE, e);\n+\t\t  if (!CONSTANT_CLASS_P (e))\n+\t\t    constant_p = false;\n+\t\t}\n+\t      res = (constant_p ? build_vector_from_ctor (type, vals)\n+\t\t     : build_constructor (type, vals));\n+\t    }\n+\t    { res; })))))\n       /* The bitfield references a single constructor element.  */\n       (if (k.is_constant (&const_k)\n \t   && idx + n <= (idx / const_k + 1) * const_k)"}, {"sha": "f8d15ff979fc128da1bfb2ab477252de0a9f986c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b972e036f40c12b106f9070c3e8adea0eb8a45fa", "patch": "@@ -9198,49 +9198,6 @@ insert_cond_bb (basic_block bb, gimple *stmt, gimple *cond,\n   return new_bb;\n }\n \n-/* Build a ternary operation and gimplify it.  Emit code before GSI.\n-   Return the gimple_val holding the result.  */\n-\n-tree\n-gimplify_build3 (gimple_stmt_iterator *gsi, enum tree_code code,\n-\t\t tree type, tree a, tree b, tree c)\n-{\n-  tree ret;\n-  location_t loc = gimple_location (gsi_stmt (*gsi));\n-\n-  ret = fold_build3_loc (loc, code, type, a, b, c);\n-  return force_gimple_operand_gsi (gsi, ret, true, NULL, true,\n-                                   GSI_SAME_STMT);\n-}\n-\n-/* Build a binary operation and gimplify it.  Emit code before GSI.\n-   Return the gimple_val holding the result.  */\n-\n-tree\n-gimplify_build2 (gimple_stmt_iterator *gsi, enum tree_code code,\n-\t\t tree type, tree a, tree b)\n-{\n-  tree ret;\n-\n-  ret = fold_build2_loc (gimple_location (gsi_stmt (*gsi)), code, type, a, b);\n-  return force_gimple_operand_gsi (gsi, ret, true, NULL, true,\n-                                   GSI_SAME_STMT);\n-}\n-\n-/* Build a unary operation and gimplify it.  Emit code before GSI.\n-   Return the gimple_val holding the result.  */\n-\n-tree\n-gimplify_build1 (gimple_stmt_iterator *gsi, enum tree_code code, tree type,\n-\t\t tree a)\n-{\n-  tree ret;\n-\n-  ret = fold_build1_loc (gimple_location (gsi_stmt (*gsi)), code, type, a);\n-  return force_gimple_operand_gsi (gsi, ret, true, NULL, true,\n-                                   GSI_SAME_STMT);\n-}\n-\n \n \f\n /* Given a basic block B which ends with a conditional and has"}, {"sha": "5d16aac9ef6aeebf81490038f0e973ee8630c8e0", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=b972e036f40c12b106f9070c3e8adea0eb8a45fa", "patch": "@@ -95,12 +95,6 @@ extern bool gimple_purge_dead_eh_edges (basic_block);\n extern bool gimple_purge_all_dead_eh_edges (const_bitmap);\n extern bool gimple_purge_dead_abnormal_call_edges (basic_block);\n extern bool gimple_purge_all_dead_abnormal_call_edges (const_bitmap);\n-extern tree gimplify_build3 (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t     tree, tree, tree, tree);\n-extern tree gimplify_build2 (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t     tree, tree, tree);\n-extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t     tree, tree);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern tree find_case_label_for_value (const gswitch *switch_stmt, tree val);\n extern edge find_taken_edge_switch_expr (const gswitch *switch_stmt, tree val);"}, {"sha": "751f181118ca69a79837b8ed89b4956e2d844012", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 62, "deletions": 14, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b972e036f40c12b106f9070c3e8adea0eb8a45fa/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=b972e036f40c12b106f9070c3e8adea0eb8a45fa", "patch": "@@ -41,9 +41,54 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec-perm-indices.h\"\n #include \"insn-config.h\"\n #include \"tree-ssa-dce.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-match.h\"\n #include \"recog.h\"\t\t/* FIXME: for insn_data */\n \n \n+/* Build a ternary operation and gimplify it.  Emit code before GSI.\n+   Return the gimple_val holding the result.  */\n+\n+static tree\n+gimplify_build3 (gimple_stmt_iterator *gsi, enum tree_code code,\n+\t\t tree type, tree a, tree b, tree c)\n+{\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n+  gimple_seq stmts = NULL;\n+  tree ret = gimple_build (&stmts, loc, code, type, a, b, c);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  return ret;\n+}\n+\n+/* Build a binary operation and gimplify it.  Emit code before GSI.\n+   Return the gimple_val holding the result.  */\n+\n+static tree\n+gimplify_build2 (gimple_stmt_iterator *gsi, enum tree_code code,\n+\t\t tree type, tree a, tree b)\n+{\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n+  gimple_seq stmts = NULL;\n+  tree ret = gimple_build (&stmts, loc, code, type, a, b);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  return ret;\n+}\n+\n+/* Build a unary operation and gimplify it.  Emit code before GSI.\n+   Return the gimple_val holding the result.  */\n+\n+static tree\n+gimplify_build1 (gimple_stmt_iterator *gsi, enum tree_code code, tree type,\n+\t\t tree a)\n+{\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n+  gimple_seq stmts = NULL;\n+  tree ret = gimple_build (&stmts, loc, code, type, a);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  return ret;\n+}\n+\n+\n static void expand_vector_operations_1 (gimple_stmt_iterator *, bitmap);\n \n /* Return the number of elements in a vector type TYPE that we have\n@@ -122,23 +167,25 @@ typedef tree (*elem_op_func) (gimple_stmt_iterator *,\n \t\t\t      tree, tree, tree, tree, tree, enum tree_code,\n \t\t\t      tree);\n \n+/* Extract the vector element of type TYPE at BITPOS with BITSIZE from T\n+   and return it.  */\n+\n tree\n tree_vec_extract (gimple_stmt_iterator *gsi, tree type,\n \t\t  tree t, tree bitsize, tree bitpos)\n {\n-  if (TREE_CODE (t) == SSA_NAME)\n-    {\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n-      if (is_gimple_assign (def_stmt)\n-\t  && (gimple_assign_rhs_code (def_stmt) == VECTOR_CST\n-\t      || (bitpos\n-\t\t  && gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR)))\n-\tt = gimple_assign_rhs1 (def_stmt);\n-    }\n-  if (bitpos)\n-    return gimplify_build3 (gsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n-  else\n-    return gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, t);\n+  /* We're using the resimplify API and maybe_push_res_to_seq to\n+     simplify the BIT_FIELD_REF but restrict the simplification to\n+     a single stmt while at the same time following SSA edges for\n+     simplification with already emitted CTORs.  */\n+  gimple_match_op opr;\n+  opr.set_op (BIT_FIELD_REF, type, t, bitsize, bitpos);\n+  opr.resimplify (NULL, follow_all_ssa_edges);\n+  gimple_seq stmts = NULL;\n+  tree res = maybe_push_res_to_seq (&opr, &stmts);\n+  gcc_assert (res);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  return res;\n }\n \n static tree\n@@ -327,7 +374,8 @@ expand_vector_parallel (gimple_stmt_iterator *gsi, elem_op_func f, tree type,\n       scalar_int_mode mode\n \t= int_mode_for_size (tree_to_uhwi (TYPE_SIZE (type)), 0).require ();\n       compute_type = lang_hooks.types.type_for_mode (mode, 1);\n-      result = f (gsi, compute_type, a, b, NULL_TREE, NULL_TREE, code, type);\n+      result = f (gsi, compute_type, a, b, bitsize_zero_node,\n+\t\t  TYPE_SIZE (compute_type), code, type);\n       warning_at (loc, OPT_Wvector_operation_performance,\n \t          \"vector operation will be expanded with a \"\n \t\t  \"single scalar operation\");"}]}