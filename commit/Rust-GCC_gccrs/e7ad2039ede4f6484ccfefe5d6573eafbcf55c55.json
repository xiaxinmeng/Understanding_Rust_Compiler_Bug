{"sha": "e7ad2039ede4f6484ccfefe5d6573eafbcf55c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhZDIwMzllZGU0ZjY0ODRjY2ZlZmU1ZDY1NzNlYWZiY2Y1NWM1NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-06-06T10:50:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:50:46Z"}, "message": "tracebak.c (FRAME_OFFSET): Add parameter FP.\n\n2007-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* tracebak.c (FRAME_OFFSET): Add parameter FP. On SPARC/Solaris, do not\n\tadd the stack bias if the offset is computed from a frame address.\n\t(__gnat_backtrace): Adjust for above change.\n\nFrom-SVN: r125472", "tree": {"sha": "cf17ce1d24179926c078cbe0624f445ff19e1382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf17ce1d24179926c078cbe0624f445ff19e1382"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55/comments", "author": null, "committer": null, "parents": [{"sha": "c956c1be72ecbe929fce84221c683442f4497f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c956c1be72ecbe929fce84221c683442f4497f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c956c1be72ecbe929fce84221c683442f4497f00"}], "stats": {"total": 25, "additions": 13, "deletions": 12}, "files": [{"sha": "80d1a78f67cb55449397caacdb41ad8dd498427e", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ad2039ede4f6484ccfefe5d6573eafbcf55c55/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=e7ad2039ede4f6484ccfefe5d6573eafbcf55c55", "patch": "@@ -34,6 +34,7 @@\n    functions.\n    It has been tested on the following configurations:\n    PowerPC/AiX\n+   PowerPC/Darwin\n    PowerPC/VxWorks\n    SPARC/Solaris\n    i386/GNU/Linux\n@@ -115,7 +116,7 @@ extern void (*Unlock_Task) (void);\n    we store in the tracebacks array. The latter allows us to loop over the\n    successive frames in the chain.\n \n-   To initiate the process, we retrieve an initial frame pointer using the\n+   To initiate the process, we retrieve an initial frame address using the\n    appropriate GCC builtin (__builtin_frame_address).\n \n    This scheme is unfortunately not applicable on every target because the\n@@ -125,8 +126,8 @@ extern void (*Unlock_Task) (void);\n    o struct layout, describing the expected stack data layout relevant to the\n      information we are interested in,\n \n-   o FRAME_OFFSET, the offset, from a given frame pointer, at which this\n-     layout will be found,\n+   o FRAME_OFFSET, the offset, from a given frame address or frame pointer\n+     value, at which this layout will be found,\n \n    o FRAME_LEVEL, controls how many frames up we get at to start with,\n      from the initial frame pointer we compute by way of the GCC builtin,\n@@ -205,7 +206,7 @@ struct layout\n   void *return_address;\n };\n \n-#define FRAME_OFFSET 0\n+#define FRAME_OFFSET(FP) 0\n #define PC_ADJUST -4\n #define STOP_FRAME(CURRENT, TOP_STACK) ((void *) (CURRENT) < (TOP_STACK))\n \n@@ -237,7 +238,7 @@ struct layout\n #define FRAME_LEVEL 1\n /* See the PPC AIX case for an explanation of these values.  */\n \n-#define FRAME_OFFSET 0\n+#define FRAME_OFFSET(FP) 0\n #define PC_ADJUST -4\n #define STOP_FRAME(CURRENT, TOP_STACK) ((CURRENT)->next == 0)\n \n@@ -265,13 +266,13 @@ struct layout\n #endif\n \n #define FRAME_LEVEL 0\n-#define FRAME_OFFSET (14 * sizeof (void*) + STACK_BIAS)\n+#define FRAME_OFFSET(FP) (14 * sizeof (void*) + (FP ? STACK_BIAS : 0))\n #define PC_ADJUST 0\n #define STOP_FRAME(CURRENT, TOP_STACK) \\\n   ((CURRENT)->return_address == 0|| (CURRENT)->next == 0 \\\n    || (void *) (CURRENT) < (TOP_STACK))\n \n-/* The sparc register windows need to be flushed before we may access them\n+/* The SPARC register windows need to be flushed before we may access them\n    from the stack. This is achieved by way of builtin_frame_address only\n    when the \"count\" argument is positive, so force at least one such call.  */\n #define FETCH_UP_FRAME_ADDRESS\n@@ -306,7 +307,7 @@ struct layout\n    return the soft stack pointer, which does not designate a location where a\n    backchain and a return address might be found.  */\n \n-#define FRAME_OFFSET 0\n+#define FRAME_OFFSET(FP) 0\n #define PC_ADJUST -2\n #define STOP_FRAME(CURRENT, TOP_STACK) \\\n   (IS_BAD_PTR((long)(CURRENT)->return_address) \\\n@@ -432,15 +433,15 @@ __gnat_backtrace (void **array,\n     forced_callee ();\n \n   /* Force a call to builtin_frame_address with a positive argument\n-     if required. This is necessary e.g. on sparc to have the register\n+     if required. This is necessary e.g. on SPARC to have the register\n      windows flushed before we attempt to access them on the stack.  */\n #if defined (FETCH_UP_FRAME_ADDRESS) && (FRAME_LEVEL == 0)\n   __builtin_frame_address (1);\n #endif\n \n   top_frame = __builtin_frame_address (FRAME_LEVEL);\n   top_stack = CURRENT_STACK_FRAME;\n-  current = (struct layout *) ((size_t) top_frame + FRAME_OFFSET);\n+  current = (struct layout *) ((size_t) top_frame + FRAME_OFFSET (0));\n \n   /* Skip the number of calls we have been requested to skip, accounting for\n      the BASE_SKIP parameter.\n@@ -453,7 +454,7 @@ __gnat_backtrace (void **array,\n \n   while (cnt < skip_frames)\n     {\n-      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET);\n+      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET (1));\n       cnt++;\n     }\n \n@@ -468,7 +469,7 @@ __gnat_backtrace (void **array,\n \t  || current->return_address > exclude_max)\n         array[cnt++] = current->return_address + PC_ADJUST;\n \n-      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET);\n+      current = (struct layout *) ((size_t) current->next + FRAME_OFFSET (1));\n     }\n \n   return cnt;"}]}