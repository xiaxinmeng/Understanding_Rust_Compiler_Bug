{"sha": "98da680f69333ca2cfeab62cd7aa96209e3382c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkYTY4MGY2OTMzM2NhMmNmZWFiNjJjZDdhYTk2MjA5ZTMzODJjNg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-03-02T08:46:43Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-10T06:59:31Z"}, "message": "AVX512FP16: Add testcase for vmaxph/vmaxsh/vminph/vminsh.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/avx512fp16-vmaxph-1a.c: New test.\n\t* gcc.target/i386/avx512fp16-vmaxph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vmaxsh-1.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vmaxsh-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vminph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vminph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vminsh-1.c: Ditto.\n\t* gcc.target/i386/avx512fp16-vminsh-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vmaxph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vmaxph-1b.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vminph-1a.c: Ditto.\n\t* gcc.target/i386/avx512fp16vl-vminph-1b.c: Ditto.", "tree": {"sha": "dbbbcb1c70fcbf1a97dfbb15a8b8832a2274724c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbbbcb1c70fcbf1a97dfbb15a8b8832a2274724c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98da680f69333ca2cfeab62cd7aa96209e3382c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98da680f69333ca2cfeab62cd7aa96209e3382c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98da680f69333ca2cfeab62cd7aa96209e3382c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98da680f69333ca2cfeab62cd7aa96209e3382c6/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b96cb2caa973d26c4f27da91c44e35796f411e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b96cb2caa973d26c4f27da91c44e35796f411e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b96cb2caa973d26c4f27da91c44e35796f411e4a"}], "stats": {"total": 527, "additions": 527, "deletions": 0}, "files": [{"sha": "b91f4bd1154e74699966a711eebe84563bbe0810", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmaxph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1a.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_max_ph (x1, x2);\n+  res1 = _mm512_mask_max_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_max_ph (m32, x1, x2);\n+\n+  res = _mm512_max_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_max_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_max_round_ph (m32, x1, x2, 8);\n+}"}, {"sha": "0dd4c11e9aa9208470017beb45efccab9ad51bbf", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmaxph-1b.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxph-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(max_ph) (V512 * dest, V512 op1, V512 op2,\n+\t       __mmask32 k, int zero_mask)\n+{   \n+  V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+  int i;\n+  __mmask16 m1, m2;\n+\n+  m1 = k & 0xffff; \n+  m2 = (k >> 16) & 0xffff;\n+\n+  unpack_ph_2twops(op1, &v1, &v2);\n+  unpack_ph_2twops(op2, &v3, &v4);\n+  unpack_ph_2twops(*dest, &v7, &v8);\n+\n+  for (i = 0; i < 16; i++) { \n+      if (((1 << i) & m1) == 0) {\n+\t  if (zero_mask) {\n+\t      v5.f32[i] = 0;\n+\t  }\n+\t  else {\n+\t      v5.u32[i] = v7.u32[i];\n+\t  }\n+      }\n+      else {\n+\t  v5.f32[i] = v1.f32[i] > v3.f32[i] ? v1.f32[i] : v3.f32[i];\n+      }\n+\n+      if (((1 << i) & m2) == 0) {\n+\t  if (zero_mask) {\n+\t      v6.f32[i] = 0;\n+\t  }\n+\t  else {\n+\t      v6.u32[i] = v8.u32[i];\n+\t  }\n+      }\n+      else {\n+\t  v6.f32[i] = v2.f32[i] > v4.f32[i] ? v2.f32[i] : v4.f32[i];\n+      }\n+  }\n+  *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  EMULATE(max_ph) (&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_max_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _max_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(max_ph) (&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_max_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_max_ph);\n+\n+  EMULATE(max_ph) (&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_max_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_max_ph);\n+\n+#if AVX512F_LEN == 512\n+  EMULATE(max_ph) (&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_max_round_ph) (HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _max_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(max_ph) (&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_max_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_max_ph);\n+\n+  EMULATE(max_ph) (&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_max_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_max_ph);\n+\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}\n+"}, {"sha": "d5198dcebdc19cc82832a89d8ac3282d4dc707d7", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmaxsh-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m128h res;\n+volatile __m128h x1, x2;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm_max_sh (x1, x2);\n+  res = _mm_mask_max_sh (res, m8, x1, x2);\n+  res = _mm_maskz_max_sh (m8, x1, x2);\n+\n+  res = _mm_max_round_sh (x1, x2, 8);\n+  res = _mm_mask_max_round_sh (res, m8, x1, x2, 8);\n+  res = _mm_maskz_max_round_sh (m8, x1, x2, 8);\n+}"}, {"sha": "fe49de3147fb52685e8e3ecb09eefe2934b3f673", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vmaxsh-1b.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vmaxsh-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS 8\n+\n+void NOINLINE\n+emulate_max_sh(V512 * dest, V512 op1, V512 op2,\n+                __mmask8 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    if ((k&1) || !k)\n+      v5.f32[i] = v1.f32[i] > v3.f32[i] ? v1.f32[i] : v3.f32[i];\n+    else if (zero_mask)\n+      v5.f32[0] = 0;\n+    else\n+      v5.f32[0] = v7.f32[0];\n+   \n+    for (i = 1; i < 8; i++)\n+      v5.f32[i] = v1.f32[i];\n+\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+test_512 (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  emulate_max_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_max_sh(src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_max_sh\");\n+\n+  init_dest(&res, &exp);\n+  emulate_max_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_mask_max_sh(res.xmmh[0], 0x1, src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_mask_max_sh\");\n+\n+  emulate_max_sh(&exp, src1, src2,  0x3, 1);\n+  res.xmmh[0] = _mm_maskz_max_sh(0x3, src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_maskz_max_sh\");\n+\n+  emulate_max_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_max_round_sh(src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_max_round_sh\");\n+\n+  init_dest(&res, &exp);\n+  emulate_max_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_mask_max_round_sh(res.xmmh[0], 0x1, src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_mask_max_round_sh\");\n+\n+  emulate_max_sh(&exp, src1, src2,  0x3, 1);\n+  res.xmmh[0] = _mm_maskz_max_round_sh(0x3, src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_maskz_max_round_sh\");\n+\n+  if (n_errs != 0)\n+      abort ();\n+}\n+\n+"}, {"sha": "810a93e3870a90bbad6e1c5752421dbafcf980e8", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vminph-1a.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1a.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\[^\\n\\r]*%zmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m512h res, res1, res2;\n+volatile __m512h x1, x2;\n+volatile __mmask32 m32;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm512_min_ph (x1, x2);\n+  res1 = _mm512_mask_min_ph (res1, m32, x1, x2);\n+  res2 = _mm512_maskz_min_ph (m32, x1, x2);\n+\n+  res = _mm512_min_round_ph (x1, x2, 8);\n+  res1 = _mm512_mask_min_round_ph (res1, m32, x1, x2, 8);\n+  res2 = _mm512_maskz_min_round_ph (m32, x1, x2, 8);\n+}"}, {"sha": "3315ce13813d0fa0d6be0b653ff41949782f8c12", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vminph-1b.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminph-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS (AVX512F_LEN / 16)\n+\n+void NOINLINE\n+EMULATE(min_ph) (V512 * dest, V512 op1, V512 op2,\n+                __mmask32 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+    __mmask16 m1, m2;\n+\n+    m1 = k & 0xffff;\n+    m2 = (k >> 16) & 0xffff;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    for (i = 0; i < 16; i++) {\n+        if (((1 << i) & m1) == 0) {\n+            if (zero_mask) {\n+               v5.f32[i] = 0;\n+            }\n+            else {\n+               v5.u32[i] = v7.u32[i];\n+            }\n+        }\n+        else {\n+           v5.f32[i] = v1.f32[i] < v3.f32[i] ? v1.f32[i] : v3.f32[i];\n+        }\n+\n+        if (((1 << i) & m2) == 0) {\n+            if (zero_mask) {\n+               v6.f32[i] = 0;\n+            }\n+            else {\n+               v6.u32[i] = v8.u32[i];\n+            }\n+        }\n+        else {\n+            v6.f32[i] = v2.f32[i] < v4.f32[i] ? v2.f32[i] : v4.f32[i];\n+        }\n+    }\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+TEST (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  EMULATE(min_ph) (&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_min_ph) (HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _min_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(min_ph) (&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_min_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_min_ph);\n+\n+  EMULATE(min_ph) (&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_min_ph) (ZMASK_VALUE, HF(src1), HF(src2));\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_min_ph);\n+\n+#if AVX512F_LEN == 512\n+  EMULATE(min_ph) (&exp, src1, src2,  NET_MASK, 0);\n+  HF(res) = INTRINSIC (_min_round_ph) (HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _min_ph);\n+\n+  init_dest(&res, &exp);\n+  EMULATE(min_ph) (&exp, src1, src2,  MASK_VALUE, 0);\n+  HF(res) = INTRINSIC (_mask_min_round_ph) (HF(res), MASK_VALUE, HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _mask_min_ph);\n+\n+  EMULATE(min_ph) (&exp, src1, src2,  ZMASK_VALUE, 1);\n+  HF(res) = INTRINSIC (_maskz_min_round_ph) (ZMASK_VALUE, HF(src1), HF(src2), 8);\n+  CHECK_RESULT (&res, &exp, N_ELEMS, _maskz_min_ph);\n+#endif\n+\n+  if (n_errs != 0) {\n+      abort ();\n+  }\n+}\n+"}, {"sha": "9f1d6e7da4b9fa8915ca233f0f2b83c326d3913f", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vminsh-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -O2\" } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminsh\\[ \\\\t\\]+\\{sae\\}\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m128h res;\n+volatile __m128h x1, x2;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res = _mm_min_sh (x1, x2);\n+  res = _mm_mask_min_sh (res, m8, x1, x2);\n+  res = _mm_maskz_min_sh (m8, x1, x2);\n+\n+  res = _mm_min_round_sh (x1, x2, 8);\n+  res = _mm_mask_min_round_sh (res, m8, x1, x2, 8);\n+  res = _mm_maskz_min_round_sh (m8, x1, x2, 8);\n+}"}, {"sha": "13b8d86689cffe53976394dd61b10e24d9bd9835", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16-vminsh-1b.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16-vminsh-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512dq\" } */\n+\n+\n+#define AVX512FP16\n+#include \"avx512fp16-helper.h\"\n+\n+#define N_ELEMS 8\n+\n+void NOINLINE\n+emulate_min_sh(V512 * dest, V512 op1, V512 op2,\n+                __mmask8 k, int zero_mask)\n+{\n+    V512 v1, v2, v3, v4, v5, v6, v7, v8;\n+    int i;\n+\n+    unpack_ph_2twops(op1, &v1, &v2);\n+    unpack_ph_2twops(op2, &v3, &v4);\n+    unpack_ph_2twops(*dest, &v7, &v8);\n+\n+    if ((k&1) || !k)\n+      v5.f32[i] = v1.f32[i] < v3.f32[i] ? v1.f32[i] : v3.f32[i];\n+    else if (zero_mask)\n+      v5.f32[0] = 0;\n+    else\n+      v5.f32[0] = v7.f32[0];\n+   \n+    for (i = 1; i < 8; i++)\n+      v5.f32[i] = v1.f32[i];\n+\n+    *dest = pack_twops_2ph(v5, v6);\n+}\n+\n+void\n+test_512 (void)\n+{\n+  V512 res;\n+  V512 exp;\n+\n+  init_src();\n+\n+  emulate_min_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_min_sh(src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_min_sh\");\n+\n+  init_dest(&res, &exp);\n+  emulate_min_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_mask_min_sh(res.xmmh[0], 0x1, src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_mask_min_sh\");\n+\n+  emulate_min_sh(&exp, src1, src2,  0x3, 1);\n+  res.xmmh[0] = _mm_maskz_min_sh(0x3, src1.xmmh[0], src2.xmmh[0]);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_maskz_min_sh\");\n+\n+  emulate_min_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_min_round_sh(src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_min_round_sh\");\n+\n+  init_dest(&res, &exp);\n+  emulate_min_sh(&exp, src1, src2,  0x1, 0);\n+  res.xmmh[0] = _mm_mask_min_round_sh(res.xmmh[0], 0x1, src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_mask_min_round_sh\");\n+\n+  emulate_min_sh(&exp, src1, src2,  0x3, 1);\n+  res.xmmh[0] = _mm_maskz_min_round_sh(0x3, src1.xmmh[0], src2.xmmh[0], 8);\n+  check_results(&res, &exp, N_ELEMS, \"_mm_maskz_min_round_sh\");\n+\n+  if (n_errs != 0)\n+      abort ();\n+}\n+\n+"}, {"sha": "adadc4ed8d0e88d33714d3bd34cfec514980bdf8", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vmaxph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1a.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmaxph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_max_ph (x1, x2);\n+  res1 = _mm256_mask_max_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_max_ph (m16, x1, x2);\n+\n+  res2 = _mm_max_ph (x3, x4);\n+  res2 = _mm_mask_max_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_max_ph (m8, x3, x4);\n+}"}, {"sha": "f9a3b70d47c3aa9fe6e835a979f2a9860ecbede7", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vmaxph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vmaxph-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vmaxph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vmaxph-1b.c\"\n+"}, {"sha": "7909541aa34f7abb8452bf399638b650d9506c1e", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vminph-1a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1a.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512fp16 -mavx512vl -O2\" } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\[^\\n\\r]*%ymm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vminph\\[ \\\\t\\]+%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\[^\\n\\r]*%xmm\\[0-9\\]+\\{%k\\[0-9\\]\\}\\{z\\}\\[^\\n\\r]*(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+\n+#include <immintrin.h>\n+\n+volatile __m256h res1;\n+volatile __m128h res2;\n+volatile __m256h x1,x2;\n+volatile __m128h x3, x4;\n+volatile __mmask16 m16;\n+volatile __mmask8 m8;\n+\n+void extern\n+avx512f_test (void)\n+{\n+  res1 = _mm256_min_ph (x1, x2);\n+  res1 = _mm256_mask_min_ph (res1, m16, x1, x2);\n+  res1 = _mm256_maskz_min_ph (m16, x1, x2);\n+\n+  res2 = _mm_min_ph (x3, x4);\n+  res2 = _mm_mask_min_ph (res2, m8, x3, x4);\n+  res2 = _mm_maskz_min_ph (m8, x3, x4);\n+}"}, {"sha": "98808b0edddd7ffa959b1d7427b908a84c357d9d", "filename": "gcc/testsuite/gcc.target/i386/avx512fp16vl-vminph-1b.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98da680f69333ca2cfeab62cd7aa96209e3382c6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512fp16vl-vminph-1b.c?ref=98da680f69333ca2cfeab62cd7aa96209e3382c6", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run { target avx512fp16 } } */\n+/* { dg-options \"-O2 -mavx512fp16 -mavx512vl -mavx512dq\" } */\n+\n+#define DEBUG\n+#define AVX512VL\n+#define AVX512F_LEN 256      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vminph-1b.c\"\n+                             \n+#undef AVX512F_LEN           \n+#undef AVX512F_LEN_HALF      \n+                             \n+#define AVX512F_LEN 128      \n+#define AVX512F_LEN_HALF 128 \n+#include \"avx512fp16-vminph-1b.c\"\n+"}]}