{"sha": "214ece2920ee4e27aca97c1fef963d1d0f61921e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE0ZWNlMjkyMGVlNGUyN2FjYTk3YzFmZWY5NjNkMWQwZjYxOTIxZQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2008-04-23T07:20:58Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2008-04-23T07:20:58Z"}, "message": "2008-04-23  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/multiway_merge.h\n        (multiway_merge_loser_tree):\n        Leave checks to callers, add precondition instead.\n        (multiway_merge_loser_tree_unguarded): Likewise.\n        (multiway_merge_loser_tree_sentinel): Likewise.\n        (sequential_multiway_merge): Added checks for total length 0.\n        (parallel_multiway_merge): Skip empty sequences.\n        (multiway_merge, all variants):\n        Remove temporary variable, return directly.\n        (stable_multiway_merge, all variants): Likewise.\n        (multiway_merge_sentinels, all variants):  Likewise.\n        (stable_multiway_merge_sentinels, all variants): Likewise.\n        * include/parallel/multiseq_selection.h\n        (multiseq_partition): More detailed assertions.\n\nFrom-SVN: r134580", "tree": {"sha": "e2955acdc0c808a97b62265e1d9f4bab5dd6ae3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2955acdc0c808a97b62265e1d9f4bab5dd6ae3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/214ece2920ee4e27aca97c1fef963d1d0f61921e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214ece2920ee4e27aca97c1fef963d1d0f61921e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214ece2920ee4e27aca97c1fef963d1d0f61921e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214ece2920ee4e27aca97c1fef963d1d0f61921e/comments", "author": null, "committer": null, "parents": [{"sha": "7edc89d4c168867a240e54533b2214bbc2a1987c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edc89d4c168867a240e54533b2214bbc2a1987c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7edc89d4c168867a240e54533b2214bbc2a1987c"}], "stats": {"total": 344, "additions": 181, "deletions": 163}, "files": [{"sha": "8405db634ef82d3c09c8b59e38fce1483d79c0b8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=214ece2920ee4e27aca97c1fef963d1d0f61921e", "patch": "@@ -1,3 +1,20 @@\n+2008-04-23  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/multiway_merge.h\n+        (multiway_merge_loser_tree):\n+        Leave checks to callers, add precondition instead.\n+        (multiway_merge_loser_tree_unguarded): Likewise.\n+        (multiway_merge_loser_tree_sentinel): Likewise.\n+        (sequential_multiway_merge): Added checks for total length 0.\n+        (parallel_multiway_merge): Skip empty sequences.\n+        (multiway_merge, all variants):\n+        Remove temporary variable, return directly.\n+        (stable_multiway_merge, all variants): Likewise.\n+        (multiway_merge_sentinels, all variants):  Likewise.\n+        (stable_multiway_merge_sentinels, all variants): Likewise.\n+        * include/parallel/multiseq_selection.h\n+        (multiseq_partition): More detailed assertions.\n+\n 2008-04-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* acinclude.m4 (GLIBCXX_CHECK_SETRLIMIT, GLIBCXX_ENABLE_C99)"}, {"sha": "662204526c9eb545ecca2247c8ba676f3c802420", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=214ece2920ee4e27aca97c1fef963d1d0f61921e", "patch": "@@ -124,22 +124,22 @@ namespace __gnu_parallel\n    *  @param comp The ordering functor, defaults to std::less<T>. \n    */\n   template<typename RanSeqs, typename RankType, typename RankIterator,\n-\t   typename Comparator>\n+            typename Comparator>\n     void\n     multiseq_partition(RanSeqs begin_seqs, RanSeqs end_seqs,\n-\t\t       RankType rank,\n-\t\t       RankIterator begin_offsets,\n-\t\t       Comparator comp = std::less<\n-\t\t       typename std::iterator_traits<typename\n-\t\t       std::iterator_traits<RanSeqs>::value_type::\n-\t\t       first_type>::value_type>()) // std::less<T>\n+                       RankType rank,\n+                       RankIterator begin_offsets,\n+                       Comparator comp = std::less<\n+                       typename std::iterator_traits<typename\n+                       std::iterator_traits<RanSeqs>::value_type::\n+                       first_type>::value_type>()) // std::less<T>\n     {\n       _GLIBCXX_CALL(end_seqs - begin_seqs)\n \n       typedef typename std::iterator_traits<RanSeqs>::value_type::first_type\n-\tIt;\n+        It;\n       typedef typename std::iterator_traits<It>::difference_type\n-\tdifference_type;\n+\t       difference_type;\n       typedef typename std::iterator_traits<It>::value_type value_type;\n \n       lexicographic<value_type, int, Comparator> lcomp(comp);\n@@ -148,19 +148,27 @@ namespace __gnu_parallel\n       // Number of sequences, number of elements in total (possibly\n       // including padding).\n       difference_type m = std::distance(begin_seqs, end_seqs), N = 0,\n-\tnmax, n, r;\n+                      nmax, n, r;\n \n       for (int i = 0; i < m; i++)\n-\tN += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+        {\n+          N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+          _GLIBCXX_PARALLEL_ASSERT(\n+            std::distance(begin_seqs[i].first, begin_seqs[i].second) > 0);\n+        }\n \n       if (rank == N)\n-\t{\n-\t  for (int i = 0; i < m; i++)\n-\t    begin_offsets[i] = begin_seqs[i].second; // Very end.\n-\t  // Return m - 1;\n-\t}\n-\n-      _GLIBCXX_PARALLEL_ASSERT(m != 0 && N != 0 && rank >= 0 && rank < N);\n+        {\n+          for (int i = 0; i < m; i++)\n+            begin_offsets[i] = begin_seqs[i].second; // Very end.\n+          // Return m - 1;\n+          return;\n+        }\n+\n+      _GLIBCXX_PARALLEL_ASSERT(m != 0);\n+      _GLIBCXX_PARALLEL_ASSERT(N != 0);\n+      _GLIBCXX_PARALLEL_ASSERT(rank >= 0);\n+      _GLIBCXX_PARALLEL_ASSERT(rank < N);\n \n       difference_type* ns = new difference_type[m];\n       difference_type* a = new difference_type[m];"}, {"sha": "0505722c8a43ca5f88cd13faa31f368bd7040e5c", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 138, "deletions": 145, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214ece2920ee4e27aca97c1fef963d1d0f61921e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=214ece2920ee4e27aca97c1fef963d1d0f61921e", "patch": "@@ -282,7 +282,8 @@ template<typename RandomAccessIterator, typename Comparator>\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, less equal than the\n+ * total number of elements available.\n  *\n  * @return End iterator of output sequence.\n  */\n@@ -401,7 +402,8 @@ template<template<typename RAI, typename C> class iterator,\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, less equal than the\n+ * total number of elements available.\n  *\n  * @return End iterator of output sequence.\n  */\n@@ -518,11 +520,14 @@ template<template<typename RAI, typename C> class iterator,\n  *\n  * Stability is selected through the used LoserTree class <tt>LT</tt>.\n  *\n+ * At least one non-empty sequence is required.\n+ *\n  * @param seqs_begin Begin iterator of iterator pair input sequence.\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, less equal than the\n+ * total number of elements available.\n  *\n  * @return End iterator of output sequence.\n  */\n@@ -551,22 +556,16 @@ template<typename LT,\n \n     LT lt(k, comp);\n \n-    difference_type total_length = 0;\n-\n     // Default value for potentially non-default-constructible types.\n     value_type* arbitrary_element = NULL;\n \n     for (int t = 0; t < k; ++t)\n       {\n         if(arbitrary_element == NULL\n-\t   && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n+            && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n           arbitrary_element = &(*seqs_begin[t].first);\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n \n-    if(total_length == 0)\n-      return target;\n-\n     for (int t = 0; t < k; ++t)\n       {\n         if (seqs_begin[t].first == seqs_begin[t].second)\n@@ -577,11 +576,9 @@ template<typename LT,\n \n     lt.init();\n \n-    const difference_type const_total_length(std::min(total_length, length));\n-\n     int source;\n \n-    for (difference_type i = 0; i < const_total_length; ++i)\n+    for (difference_type i = 0; i < length; ++i)\n       {\n         //take out\n         source = lt.get_min_source();\n@@ -612,7 +609,8 @@ template<typename LT,\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, less equal than the\n+ * total number of elements available.\n  *\n  * @return End iterator of output sequence.\n  */\n@@ -644,23 +642,16 @@ template<typename LT,\n \n     LT lt(k, sentinel, comp);\n \n-    difference_type total_length = 0;\n-\n     for (int t = 0; t < k; ++t)\n       {\n #if _GLIBCXX_ASSERTIONS\n         _GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n #endif\n         lt.insert_start(*seqs_begin[t].first, t, false);\n-\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n \n     lt.init();\n \n-    // Do not go past end.\n-    length = std::min(total_length, length);\n-\n     int source;\n \n #if _GLIBCXX_ASSERTIONS\n@@ -698,6 +689,7 @@ template<typename LT,\n \n /** @brief Multi-way merging procedure for a high branching factor,\n  *         requiring sentinels to exist.\n+ *\n  * @param stable The value must the same as for the used LoserTrees.\n  * @param UnguardedLoserTree Loser Tree variant to use for the unguarded\n  *   merging.\n@@ -708,7 +700,8 @@ template<typename LT,\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, less equal than the\n+ * total number of elements available.\n  *\n  * @return End iterator of output sequence.\n  */\n@@ -737,23 +730,16 @@ template<\n \n     RandomAccessIterator3 target_end;\n \n-    difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      {\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n-\n-        // Move the sequends end behind the sentinel spots.  This has the\n-        // effect that the sentinel appears to be within the sequence. Then,\n-        // we can use the unguarded variant if we merge out as many\n-        // non-sentinel elements as we have.\n-        ++((*s).second);\n-      }\n+      // Move the sequends end behind the sentinel spots.  This has the\n+      // effect that the sentinel appears to be within the sequence. Then,\n+      // we can use the unguarded variant if we merge out as many\n+      // non-sentinel elements as we have.\n+      ++((*s).second);\n \n-    difference_type unguarded_length =\n-         std::min(length, total_length);\n     target_end = multiway_merge_loser_tree_unguarded\n         <UnguardedLoserTree>\n-      (seqs_begin, seqs_end, target, 0, comp, unguarded_length);\n+      (seqs_begin, seqs_end, target, 0, comp, length);\n \n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n@@ -763,7 +749,7 @@ template<\n     // Restore the sequence ends so the sentinels are not contained in the\n     // sequence any more (see comment in loop above).\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      { --((*s).second); }\n+      --((*s).second);\n \n     return target_end;\n   }\n@@ -977,7 +963,8 @@ struct multiway_merge_k_variant_sentinel_switch\n  *  @param seqs_end End iterator of iterator pair input sequence.\n  *  @param target Begin iterator out output sequence.\n  *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n+ *  @param length Maximum length to merge, possibly larger than the\n+ *  number of elements available.\n  *  @param stable Stable merging incurs a performance penalty.\n  *  @param sentinel The sequences have a sentinel element.\n  *  @return End iterator of output sequence. */\n@@ -1010,7 +997,16 @@ template<\n       }\n #endif\n \n-      RandomAccessIterator3 return_target = target;\n+    _DifferenceTp total_length = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n+      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n+\n+    length = std::min<_DifferenceTp>(length, total_length);\n+\n+    if(length == 0)\n+      return target;\n+\n+    RandomAccessIterator3 return_target = target;\n     int k = static_cast<int>(seqs_end - seqs_begin);\n \n     switch (k)\n@@ -1079,7 +1075,7 @@ struct sampling_sorter\n /**\n  * @brief Non-stable sorting functor.\n  *\n- * Used to reduce code instanciation in multiway_merge_sampling_splitting.\n+ * Used to reduce code instantiation in multiway_merge_sampling_splitting.\n  */\n template<class RandomAccessIterator, class StrictWeakOrdering>\n struct sampling_sorter<false, RandomAccessIterator, StrictWeakOrdering>\n@@ -1126,11 +1122,11 @@ void multiway_merge_sampling_splitting(\n       {\n         difference_type sample_index =\n             static_cast<difference_type>(\n-                _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s]) * (double(i + 1) /\n-                (num_samples + 1)) * (double(length)\n-                / total_length));\n-        new(&(samples[s * num_samples + i])) value_type(\n-            seqs_begin[s].first[sample_index]);\n+                _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s])\n+                    * (double(i + 1) / (num_samples + 1))\n+                    * (double(length) / total_length));\n+        new(&(samples[s * num_samples + i]))\n+            value_type(seqs_begin[s].first[sample_index]);\n       }\n \n   // Sort stable or non-stable, depending on value of template parameter\n@@ -1152,10 +1148,8 @@ void multiway_merge_sampling_splitting(\n                   comp)\n               - seqs_begin[seq].first;\n         else\n-          {\n-            // Absolute beginning.\n-            pieces[slab][seq].first = 0;\n-          }\n+          // Absolute beginning.\n+          pieces[slab][seq].first = 0;\n         if ((slab + 1) < num_threads)\n           pieces[slab][seq].second =\n               std::upper_bound(\n@@ -1165,13 +1159,16 @@ void multiway_merge_sampling_splitting(\n                       num_threads], comp)\n               - seqs_begin[seq].first;\n         else\n-        pieces[slab][seq].second = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n+            // Absolute end.\n+          pieces[slab][seq].second = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n       }\n     ::operator delete(samples);\n }\n \n /**\n  * @brief Exact splitting for parallel multiway-merge routine.\n+ *\n+ * None of the passed sequences may be empty.\n  */\n template<\n     bool stable\n@@ -1269,7 +1266,8 @@ void multiway_merge_exact_splitting(\n  * @param seqs_end End iterator of iterator pair input sequence.\n  * @param target Begin iterator out output sequence.\n  * @param comp Comparator.\n- * @param length Maximum length to merge.\n+ * @param length Maximum length to merge, possibly larger than the\n+ * number of elements available.\n  * @param stable Stable merging incurs a performance penalty.\n  * @param sentinel Ignored.\n  * @return End iterator of output sequence.\n@@ -1304,23 +1302,41 @@ template<\n       typedef typename\n         std::iterator_traits<RandomAccessIterator1>::value_type value_type;\n \n-      // k sequences.\n-      int k = static_cast<int>(seqs_end - seqs_begin);\n-\n+      // Leave only non-empty sequences.\n+      std::pair<RandomAccessIterator1, RandomAccessIterator1>* ne_seqs =\n+        static_cast<std::pair<RandomAccessIterator1, RandomAccessIterator1>*>(\n+        ::operator new(\n+            sizeof(std::pair<RandomAccessIterator1, RandomAccessIterator1>)\n+              * (seqs_end - seqs_begin)));\n+      int k = 0;\n       difference_type total_length = 0;\n       for (RandomAccessIteratorIterator raii = seqs_begin;\n            raii != seqs_end; ++raii)\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(*raii);\n+        {\n+          _DifferenceTp seq_length = _GLIBCXX_PARALLEL_LENGTH(*raii);\n+          if(seq_length > 0)\n+            {\n+              total_length += seq_length;\n+              //ne_seqs[k] = *raii;\n+              new(&(ne_seqs[k++]))\n+                std::pair<RandomAccessIterator1, RandomAccessIterator1>(*raii);\n+            }\n+        }\n \n       _GLIBCXX_CALL(total_length)\n \n+      length = std::min<_DifferenceTp>(length, total_length);\n+\n       if (total_length == 0 || k == 0)\n+      {\n+        ::operator delete(ne_seqs);\n         return target;\n+      }\n \n       std::vector<std::pair<difference_type, difference_type> >* pieces;\n \n-      thread_index_t num_threads = static_cast<thread_index_t>(\n-      \tstd::min<difference_type>(get_max_threads(), total_length));\n+      thread_index_t num_threads = static_cast<thread_index_t>\n+        (std::min<difference_type>(get_max_threads(), total_length));\n \n #     pragma omp parallel num_threads (num_threads)\n         {\n@@ -1337,7 +1353,7 @@ template<\n                   __gnu_parallel::_Settings::get().merge_oversampling *\n                     num_threads;\n \n-              splitter(seqs_begin, seqs_end, comp, length, total_length,\n+              splitter(ne_seqs, ne_seqs + k, comp, length, total_length,\n                        pieces);\n             } //single\n \n@@ -1348,50 +1364,37 @@ template<\n           for (int c = 0; c < k; ++c)\n             target_position += pieces[iam][c].first;\n \n-          if (k > 2)\n-            {\n-              std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks\n-                = new\n-                  std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n-\n-              difference_type local_length = 0;\n-              for (int s = 0; s < k; ++s)\n-                {\n-                  chunks[s] = std::make_pair(\n-                  seqs_begin[s].first + pieces[iam][s].first,\n-                  seqs_begin[s].first + pieces[iam][s].second);\n-                  local_length += _GLIBCXX_PARALLEL_LENGTH(chunks[s]);\n-                }\n-\n-              sequential_multiway_merge<stable, sentinels>(\n-                    chunks, chunks + k, target + target_position, comp,\n-                    std::min(local_length, length - target_position));\n-\n-              delete[] chunks;\n-            }\n-          else if (k == 2)\n+          std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks\n+            = new std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n+\n+          for (int s = 0; s < k; ++s)\n             {\n-              RandomAccessIterator1\n-                  begin0 = seqs_begin[0].first + pieces[iam][0].first,\n-                  begin1 = seqs_begin[1].first + pieces[iam][1].first;\n-              merge_advance(begin0,\n-\t\t\t    seqs_begin[0].first + pieces[iam][0].second,\n-\t\t\t    begin1,\n-\t\t\t    seqs_begin[1].first + pieces[iam][1].second,\n-\t\t\t    target + target_position,\n-\t\t\t    (pieces[iam][0].second - pieces[iam][0].first) +\n-\t\t\t    (pieces[iam][1].second - pieces[iam][1].first),\n-\t\t\t    comp);\n+              chunks[s] = std::make_pair(\n+                ne_seqs[s].first + pieces[iam][s].first,\n+                ne_seqs[s].first + pieces[iam][s].second);\n             }\n+\n+          if(length > target_position)\n+            sequential_multiway_merge<stable, sentinels>(\n+              chunks, chunks + k, target + target_position, comp,\n+              length - target_position);\n+\n+          delete[] chunks;\n         } // parallel\n \n #if _GLIBCXX_ASSERTIONS\n       _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n #endif\n \n+      k = 0;\n       // Update ends of sequences.\n-      for (int s = 0; s < k; ++s)\n-        seqs_begin[s].first += pieces[num_threads - 1][s].second;\n+      for (RandomAccessIteratorIterator raii = seqs_begin;\n+           raii != seqs_end; ++raii)\n+        {\n+          _DifferenceTp length = _GLIBCXX_PARALLEL_LENGTH(*raii);\n+          if(length > 0)\n+            (*raii).first += pieces[num_threads - 1][k++].second;\n+        }\n \n       delete[] pieces;\n \n@@ -1430,12 +1433,12 @@ template<\n  *   for (int i = 0; i < 10; ++i)\n  *     for (int j = 0; i < 10; ++j)\n  *       sequences[i][j] = j;\n- *   \n+ *\n  *   int out[33];\n  *   std::vector<std::pair<int*> > seqs;\n  *   for (int i = 0; i < 10; ++i)\n  *     { seqs.push(std::make_pair<int*>(sequences[i], sequences[i] + 10)) }\n- *   \n+ *\n  *   multiway_merge(seqs.begin(), seqs.end(), target, std::less<int>(), 33);\n  * </pre>\n  *\n@@ -1461,10 +1464,12 @@ template<\n  * @param seqs_end    end of sequence sequence\n  * @param target      target sequence to merge to.\n  * @param comp        strict weak ordering to use for element comparison.\n- * @param length      the number of elements to merge into target.\n+ * @param length Maximum length to merge, possibly larger than the\n+ * number of elements available.\n  *\n  * @return end iterator of output sequence\n  */\n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1486,28 +1491,26 @@ multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n   // Execute merge; maybe parallel, depending on the number of merged\n   // elements and the number of sequences and global thresholds in\n   // Settings.\n-  RandomAccessIteratorOut target_end;\n   if ((seqs_end - seqs_begin > 1) &&\n         _GLIBCXX_PARALLEL_CONDITION(\n         ((seqs_end - seqs_begin) >=\n         __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n         && ((sequence_index_t)length >=\n         __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-    target_end = parallel_multiway_merge\n+    return parallel_multiway_merge\n       </* stable = */ false, /* sentinels = */ false>\n         (seqs_begin, seqs_end, target, comp,\n         multiway_merge_sampling_splitting</* stable = */ false,\n           RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n         static_cast<difference_type>(length));\n   else\n-    target_end = sequential_multiway_merge\n+    return sequential_multiway_merge\n       </* stable = */false, /* sentinels = */ false>(\n         seqs_begin, seqs_end,\n         target, comp, length);\n-\n-  return target_end;\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1533,6 +1536,7 @@ multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n       (seqs_begin, seqs_end, target, comp, length);\n }\n \n+//public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1555,29 +1559,27 @@ multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n              __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n                     </* stable = */ false, /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp,\n           multiway_merge_exact_splitting</* stable = */ false,\n             RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n                       </* stable = */ false, /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1599,29 +1601,27 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ true, /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp,\n           multiway_merge_sampling_splitting</* stable = */ true,\n           RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n         </* stable = */ true, /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1639,14 +1639,15 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute multiway merge *sequentially*.\n     return sequential_multiway_merge\n       </* stable = */ true, /* sentinels = */ false>\n         (seqs_begin, seqs_end, target, comp, length);\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1664,19 +1665,18 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ true, /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp, \n@@ -1685,12 +1685,10 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n              Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge</* stable = */ true,\n+      return sequential_multiway_merge</* stable = */ true,\n         /* sentinels = */ false>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n /**\n@@ -1706,7 +1704,7 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n  * that breaks ties by sequence number but is slower.\n  *\n  * The first entries of the pairs (i.e. the begin iterators) will be moved\n- * forward.\n+ * forward accordingly.\n  *\n  * The output sequence has to provide enough space for all elements\n  * that are written to it.\n@@ -1763,10 +1761,12 @@ stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n  * @param seqs_end    end of sequence sequence\n  * @param target      target sequence to merge to.\n  * @param comp        strict weak ordering to use for element comparison.\n- * @param length      the number of elements to merge into target.\n+ * @param length Maximum length to merge, possibly larger than the\n+ * number of elements available.\n  *\n  * @return end iterator of output sequence\n  */\n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1783,34 +1783,32 @@ multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ false, /* sentinels = */ true>\n           (seqs_begin, seqs_end, target, comp,\n           multiway_merge_sampling_splitting\n             </* stable = */ false, RandomAccessIteratorPairIterator,\n              Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n         </* stable = */false, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n+//public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1828,14 +1826,15 @@ multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute multiway merge *sequentially*.\n     return sequential_multiway_merge\n       </* stable = */ false, /* sentinels = */ true>\n         (seqs_begin, seqs_end, target, comp, length);\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1853,19 +1852,18 @@ multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ false, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp,\n@@ -1874,14 +1872,13 @@ multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n               Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n         </* stable = */ false, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1898,19 +1895,18 @@ stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n             __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ true, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp,\n@@ -1919,14 +1915,13 @@ stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n             Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n         </* stable = */ true, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1944,14 +1939,15 @@ stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute multiway merge *sequentially*.\n     return sequential_multiway_merge\n       </* stable = */ true, /* sentinels = */ true>\n         (seqs_begin, seqs_end, target, comp, length);\n }\n \n+// public interface\n template<\n     typename RandomAccessIteratorPairIterator\n   , typename RandomAccessIteratorOut\n@@ -1969,19 +1965,18 @@ stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n \n     // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n-      { return target; }\n+      return target;\n \n     // Execute merge; maybe parallel, depending on the number of merged\n     // elements and the number of sequences and global thresholds in\n     // Settings.\n-    RandomAccessIteratorOut target_end;\n     if ((seqs_end - seqs_begin > 1) &&\n           _GLIBCXX_PARALLEL_CONDITION(\n           ((seqs_end - seqs_begin) >=\n           __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n           && ((sequence_index_t)length >=\n           __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge\n+      return parallel_multiway_merge\n         </* stable = */ true, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp, \n@@ -1990,12 +1985,10 @@ stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n             Comparator, _DifferenceTp>,\n           static_cast<difference_type>(length));\n     else\n-      target_end = sequential_multiway_merge\n+      return sequential_multiway_merge\n         </* stable = */ true, /* sentinels = */ true>(\n           seqs_begin, seqs_end,\n           target, comp, length);\n-\n-    return target_end;\n }\n \n }; // namespace __gnu_parallel"}]}