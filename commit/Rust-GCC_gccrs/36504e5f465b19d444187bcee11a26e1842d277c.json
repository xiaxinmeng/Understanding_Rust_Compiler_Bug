{"sha": "36504e5f465b19d444187bcee11a26e1842d277c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY1MDRlNWY0NjViMTlkNDQ0MTg3YmNlZTExYTI2ZTE4NDJkMjc3Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-02T09:47:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-02T09:47:18Z"}, "message": "[multiple changes]\n\n2012-04-02  Yannick Moy  <moy@adacore.com>\n\n\t* osint.adb, osint.ads (Add_Default_Search_Dirs): Add library\n\tsearch dirs in file specified with option -gnateO.\n\n2012-04-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb, exp_util.adb, sem_util.adb, exp_ch4.adb: Minor\n\treformatting.\n\n2012-04-02  Olivier Hainque  <hainque@adacore.com>\n\n\t* g-sse.ads: Add x86-solaris and x86_64-darwin to the set of\n\tplatforms where the use of this spec is supported. Add current\n\tyear to the copyright notice.\n\t* gcc-interfaces/Makefile.in: Add g-sse.o and g-ssvety.o to\n\tEXTRA_GNATRTL_NONTASKING_OBJS on x86 32/64 targets that support\n\tit and where they were missing (x86-solaris, x86-freebsd,\n\tx86_64-freebsd, and x86-darwin).\n\n2012-04-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* bindgen.adb (Gen_Ada_Init): When compiling for the AAMP small\n\tlibrary, where we no longer suppress the Standard_Library,\n\tgenerate an empty body rather than the usual generation of\n\tassignments to imported globals, since those aren't present in\n\tthe small library.\n\n2012-04-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sinfo.ads: Minor documentation fix.\n\n2012-04-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_res.adb (Resolve_Conditional_Expression): Add local variables\n\tElse_Typ and Then_Typ. Add missing type conversions to the \"then\" and\n\t\"else\" expressions when their respective types are scalar.\n\n2012-04-02  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch9.adb: Reordering of the local subprograms. New Table\n\tfor the lock free implementation that maps each protected\n\tsubprograms with the protected component it references.\n\t(Allow_Lock_Free_Implementation): New routine. Check if\n\tthe protected body enables the lock free implementation.\n\t(Build_Lock_Free_Protected_Subprogram_Body): New routine.\n\t(Build_Lock_Free_Unprotected_Subprogram_Body): New routine.\n\t(Comp_Of): New routine.\n\t* Makefile.rtl: Add s-atopri.o\n\t* debug.adb: New compiler debug flag -gnatd9 for lock free\n\timplementation.\n\t* rtsfind.ads: RE_Atomic_Compare_Exchange_8,\n\tRE_Atomic_Compare_Exchange_16, RE_Atomic_Compare_Exchange_32,\n\tRE_Atomic_Compare_Exchange_64, RE_Atomic_Load_8,\n\tRE_Atomic_Load_16, RE_Atomic_Load_32, RE_Atomic_Load_64, RE_Uint8,\n\tRE_Uint16, RE_Uint32, RE_Uint64 added.\n\t* s-atropi.ads: New file. Defines atomic primitives used\n\tby the lock free implementation.\n\nFrom-SVN: r186076", "tree": {"sha": "893cbf6d87b25d83e94a3593cf5409f73678e794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/893cbf6d87b25d83e94a3593cf5409f73678e794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36504e5f465b19d444187bcee11a26e1842d277c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36504e5f465b19d444187bcee11a26e1842d277c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36504e5f465b19d444187bcee11a26e1842d277c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36504e5f465b19d444187bcee11a26e1842d277c/comments", "author": null, "committer": null, "parents": [{"sha": "804670f120cd78a0304b630e7e53b1e13c9f5bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804670f120cd78a0304b630e7e53b1e13c9f5bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804670f120cd78a0304b630e7e53b1e13c9f5bfb"}], "stats": {"total": 1788, "additions": 1455, "deletions": 333}, "files": [{"sha": "26f77b8e5780bdaa3fe7f4eb004f874d5189b7c6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -1,3 +1,62 @@\n+2012-04-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* osint.adb, osint.ads (Add_Default_Search_Dirs): Add library\n+\tsearch dirs in file specified with option -gnateO.\n+\n+2012-04-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb, exp_util.adb, sem_util.adb, exp_ch4.adb: Minor\n+\treformatting.\n+\n+2012-04-02  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* g-sse.ads: Add x86-solaris and x86_64-darwin to the set of\n+\tplatforms where the use of this spec is supported. Add current\n+\tyear to the copyright notice.\n+\t* gcc-interfaces/Makefile.in: Add g-sse.o and g-ssvety.o to\n+\tEXTRA_GNATRTL_NONTASKING_OBJS on x86 32/64 targets that support\n+\tit and where they were missing (x86-solaris, x86-freebsd,\n+\tx86_64-freebsd, and x86-darwin).\n+\n+2012-04-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* bindgen.adb (Gen_Ada_Init): When compiling for the AAMP small\n+\tlibrary, where we no longer suppress the Standard_Library,\n+\tgenerate an empty body rather than the usual generation of\n+\tassignments to imported globals, since those aren't present in\n+\tthe small library.\n+\n+2012-04-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sinfo.ads: Minor documentation fix.\n+\n+2012-04-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Conditional_Expression): Add local variables\n+\tElse_Typ and Then_Typ. Add missing type conversions to the \"then\" and\n+\t\"else\" expressions when their respective types are scalar.\n+\n+2012-04-02  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch9.adb: Reordering of the local subprograms. New Table\n+\tfor the lock free implementation that maps each protected\n+\tsubprograms with the protected component it references.\n+\t(Allow_Lock_Free_Implementation): New routine. Check if\n+\tthe protected body enables the lock free implementation.\n+\t(Build_Lock_Free_Protected_Subprogram_Body): New routine.\n+\t(Build_Lock_Free_Unprotected_Subprogram_Body): New routine.\n+\t(Comp_Of): New routine.\n+\t* Makefile.rtl: Add s-atopri.o\n+\t* debug.adb: New compiler debug flag -gnatd9 for lock free\n+\timplementation.\n+\t* rtsfind.ads: RE_Atomic_Compare_Exchange_8,\n+\tRE_Atomic_Compare_Exchange_16, RE_Atomic_Compare_Exchange_32,\n+\tRE_Atomic_Compare_Exchange_64, RE_Atomic_Load_8,\n+\tRE_Atomic_Load_16, RE_Atomic_Load_32, RE_Atomic_Load_64, RE_Uint8,\n+\tRE_Uint16, RE_Uint32, RE_Uint64 added.\n+\t* s-atropi.ads: New file. Defines atomic primitives used\n+\tby the lock free implementation.\n+\n 2012-04-02  Emmanuel Briot  <briot@adacore.com>\n \n \t* g-expect.adb (Expect_Internal): Fix leak of the input file descriptor."}, {"sha": "d3212b20559e016ba087e609daf98f0e39e1126c", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -479,6 +479,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-assert$(objext) \\\n   s-atacco$(objext) \\\n   s-atocou$(objext) \\\n+  s-atopri$(objext) \\\n   s-auxdec$(objext) \\\n   s-bitops$(objext) \\\n   s-boarop$(objext) \\"}, {"sha": "c44a648e2109cb018e73cb60af98ba74af3a32ef", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -511,6 +511,14 @@ package body Bindgen is\n       if CodePeer_Mode then\n          WBI (\"   begin\");\n \n+      --  When compiling for the AAMP small library, where the standard library\n+      --  is no longer suppressed, we still want to exclude the setting of the\n+      --  various imported globals, which aren't present for that library.\n+\n+      elsif AAMP_On_Target and then Configurable_Run_Time_On_Target then\n+         WBI (\"   begin\");\n+         WBI (\"      null;\");\n+\n       --  If the standard library is suppressed, then the only global variables\n       --  that might be needed (by the Ravenscar profile) are the priority and\n       --  the processor for the environment task."}, {"sha": "cbcdf0cbb5121df5b8bc3491e06b95005aaf5dd9", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -153,7 +153,7 @@ package body Debug is\n    --  d6   Default access unconstrained to thin pointers\n    --  d7   Do not output version & file time stamp in -gnatv or -gnatl mode\n    --  d8   Force opposite endianness in packed stuff\n-   --  d9\n+   --  d9   Allow lock free implementation\n \n    --  Debug flags for binder (GNATBIND)\n \n@@ -710,6 +710,9 @@ package body Debug is\n    --       opposite endianness from the actual correct value. Useful in\n    --       testing out code generation from the packed routines.\n \n+   --  d9   This allows lock free implementation for protected objects\n+   --       (see Exp_Ch9).\n+\n    ------------------------------------------\n    -- Documentation for Binder Debug Flags --\n    ------------------------------------------"}, {"sha": "02a733cee8897332354d7824574b9338a17a9839", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -7832,9 +7832,7 @@ package body Exp_Ch4 is\n    begin\n       --  Do validity check if validity checking operands\n \n-      if Validity_Checks_On\n-        and then Validity_Check_Operands\n-      then\n+      if Validity_Checks_On and then Validity_Check_Operands then\n          Ensure_Valid (Operand);\n       end if;\n \n@@ -7866,7 +7864,7 @@ package body Exp_Ch4 is\n    --           end if;\n    --        end loop;\n \n-   --  Conversely, an existentially quantified expression:\n+   --  Similarly, an existentially quantified expression:\n \n    --    for some X in range => Cond\n \n@@ -7957,7 +7955,6 @@ package body Exp_Ch4 is\n         Make_Expression_With_Actions (Loc,\n           Expression => New_Occurrence_Of (Flag, Loc),\n           Actions    => Actions));\n-\n       Analyze_And_Resolve (N, Standard_Boolean);\n    end Expand_N_Quantified_Expression;\n "}, {"sha": "212ed30cebddf7577c2f5657990b8dc37b7be912", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1169, "deletions": 308, "changes": 1477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -60,6 +61,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Table;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -75,6 +77,34 @@ package body Exp_Ch9 is\n \n    Entry_Family_Bound : constant Int := 2**16;\n \n+   ------------------------------\n+   -- Lock Free Data Structure --\n+   ------------------------------\n+\n+   --  A data structure used for the Lock Free (LF) implementation of protected\n+   --  objects. Since a protected subprogram can only access a single protected\n+   --  component in the LF implementation, this structure stores each protected\n+   --  subprogram and its accessed protected component when the protected\n+   --  object allows the LF implementation.\n+\n+   type Lock_Free_Sub_Type is record\n+      Sub_Body : Node_Id;\n+      Comp_Id  : Entity_Id;\n+   end record;\n+\n+   subtype Subprogram_Id is Nat;\n+\n+   --  The following table used for the Lock Free implementation of protected\n+   --  objects maps Lock_Free_Sub_Type to Subprogram_Id.\n+\n+   package LF_Sub_Table is new Table.Table (\n+     Table_Component_Type => Lock_Free_Sub_Type,\n+     Table_Index_Type     => Subprogram_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 5,\n+     Table_Increment      => 5,\n+     Table_Name           => \"LF_Sub_Table\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -109,6 +139,10 @@ package body Exp_Ch9 is\n    --    Decls is the list of declarations to be enhanced.\n    --    Ent is the entity for the original entry body.\n \n+   function Allow_Lock_Free_Implementation (N : Node_Id) return Boolean;\n+   --  Given a protected body N, return True if N permits a lock free\n+   --  implementation.\n+\n    function Build_Accept_Body (Astat : Node_Id) return Node_Id;\n    --  Transform accept statement into a block with added exception handler.\n    --  Used both for simple accept statements and for accept alternatives in\n@@ -144,6 +178,32 @@ package body Exp_Ch9 is\n    --  of the range of each entry family. A single array with that size is\n    --  allocated for each concurrent object of the type.\n \n+   function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id;\n+   --  Build the function that translates the entry index in the call\n+   --  (which depends on the size of entry families) into an index into the\n+   --  Entry_Bodies_Array, to determine the body and barrier function used\n+   --  in a protected entry call. A pointer to this function appears in every\n+   --  protected object.\n+\n+   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id;\n+   --  Build subprogram declaration for previous one\n+\n+   function Build_Lock_Free_Protected_Subprogram_Body\n+     (N         : Node_Id;\n+      Pid       : Node_Id;\n+      N_Op_Spec : Node_Id) return Node_Id;\n+   --  This function is used to construct the lock free version of a protected\n+   --  subprogram when the protected type denoted by Pid allows the lock free\n+   --  implementation. It only contains a call to the unprotected version of\n+   --  the subprogram body.\n+\n+   function Build_Lock_Free_Unprotected_Subprogram_Body\n+     (N : Node_Id;\n+      Pid : Node_Id) return Node_Id;\n+   --  This function is used to construct the lock free version of an\n+   --  unprotected subprogram when the protected type denoted by Pid allows the\n+   --  lock free implementation.\n+\n    function Build_Parameter_Block\n      (Loc     : Source_Ptr;\n       Actuals : List_Id;\n@@ -169,49 +229,6 @@ package body Exp_Ch9 is\n    --  and Decl is the enclosing synchronized type declaration at whose\n    --  freeze point the generated body is analyzed.\n \n-   function Build_Renamed_Formal_Declaration\n-     (New_F          : Entity_Id;\n-      Formal         : Entity_Id;\n-      Comp           : Entity_Id;\n-      Renamed_Formal : Node_Id) return Node_Id;\n-   --  Create a renaming declaration for a formal, within a protected entry\n-   --  body or an accept body. The renamed object is a component of the\n-   --  parameter block that is a parameter in the entry call.\n-\n-   --  In Ada 2012, if the formal is an incomplete tagged type, the renaming\n-   --  does not dereference the corresponding component to prevent an illegal\n-   --  use of the incomplete type (AI05-0151).\n-\n-   procedure Build_Wrapper_Bodies\n-     (Loc : Source_Ptr;\n-      Typ : Entity_Id;\n-      N   : Node_Id);\n-   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n-   --  record of a concurrent type. N is the insertion node where all bodies\n-   --  will be placed. This routine builds the bodies of the subprograms which\n-   --  serve as an indirection mechanism to overriding primitives of concurrent\n-   --  types, entries and protected procedures. Any new body is analyzed.\n-\n-   procedure Build_Wrapper_Specs\n-     (Loc : Source_Ptr;\n-      Typ : Entity_Id;\n-      N   : in out Node_Id);\n-   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n-   --  record of a concurrent type. N is the insertion node where all specs\n-   --  will be placed. This routine builds the specs of the subprograms which\n-   --  serve as an indirection mechanism to overriding primitives of concurrent\n-   --  types, entries and protected procedures. Any new spec is analyzed.\n-\n-   function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id;\n-   --  Build the function that translates the entry index in the call\n-   --  (which depends on the size of entry families) into an index into the\n-   --  Entry_Bodies_Array, to determine the body and barrier function used\n-   --  in a protected entry call. A pointer to this function appears in every\n-   --  protected object.\n-\n-   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id;\n-   --  Build subprogram declaration for previous one\n-\n    function Build_Protected_Entry\n      (N   : Node_Id;\n       Ent : Entity_Id;\n@@ -252,6 +269,19 @@ package body Exp_Ch9 is\n    --  a cleanup handler that unlocks the object in all cases.\n    --  (see Exp_Ch7.Expand_Cleanup_Actions).\n \n+   function Build_Renamed_Formal_Declaration\n+     (New_F          : Entity_Id;\n+      Formal         : Entity_Id;\n+      Comp           : Entity_Id;\n+      Renamed_Formal : Node_Id) return Node_Id;\n+   --  Create a renaming declaration for a formal, within a protected entry\n+   --  body or an accept body. The renamed object is a component of the\n+   --  parameter block that is a parameter in the entry call.\n+   --\n+   --  In Ada 2012, if the formal is an incomplete tagged type, the renaming\n+   --  does not dereference the corresponding component to prevent an illegal\n+   --  use of the incomplete type (AI05-0151).\n+\n    function Build_Selected_Name\n      (Prefix      : Entity_Id;\n       Selector    : Entity_Id;\n@@ -291,6 +321,26 @@ package body Exp_Ch9 is\n    --  subprogram that is called from all protected operations on the same\n    --  object, including the protected version of the same subprogram.\n \n+   procedure Build_Wrapper_Bodies\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : Node_Id);\n+   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n+   --  record of a concurrent type. N is the insertion node where all bodies\n+   --  will be placed. This routine builds the bodies of the subprograms which\n+   --  serve as an indirection mechanism to overriding primitives of concurrent\n+   --  types, entries and protected procedures. Any new body is analyzed.\n+\n+   procedure Build_Wrapper_Specs\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : in out Node_Id);\n+   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n+   --  record of a concurrent type. N is the insertion node where all specs\n+   --  will be placed. This routine builds the specs of the subprograms which\n+   --  serve as an indirection mechanism to overriding primitives of concurrent\n+   --  types, entries and protected procedures. Any new spec is analyzed.\n+\n    procedure Collect_Entry_Families\n      (Loc          : Source_Ptr;\n       Cdecls       : List_Id;\n@@ -299,6 +349,10 @@ package body Exp_Ch9 is\n    --  For each entry family in a concurrent type, create an anonymous array\n    --  type of the right size, and add a component to the corresponding_record.\n \n+   function Comp_Of (Sub_Body : Node_Id) return Entity_Id;\n+   --  For the lock free implementation, return the protected component entity\n+   --  referenced in Sub_Body using LF_Sub_Table.\n+\n    function Concurrent_Object\n      (Spec_Id  : Entity_Id;\n       Conc_Typ : Entity_Id) return Entity_Id;\n@@ -322,6 +376,26 @@ package body Exp_Ch9 is\n    --  step of the expansion must to be done after private data has been moved\n    --  to its final resting scope to ensure proper visibility of debug objects.\n \n+   procedure Extract_Dispatching_Call\n+     (N        : Node_Id;\n+      Call_Ent : out Entity_Id;\n+      Object   : out Entity_Id;\n+      Actuals  : out List_Id;\n+      Formals  : out List_Id);\n+   --  Given a dispatching call, extract the entity of the name of the call,\n+   --  its actual dispatching object, its actual parameters and the formal\n+   --  parameters of the overridden interface-level version. If the type of\n+   --  the dispatching object is an access type then an explicit dereference\n+   --  is returned in Object.\n+\n+   procedure Extract_Entry\n+     (N       : Node_Id;\n+      Concval : out Node_Id;\n+      Ename   : out Node_Id;\n+      Index   : out Node_Id);\n+   --  Given an entry call, returns the associated concurrent object,\n+   --  the entry name, and the entry family index.\n+\n    function Family_Offset\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n@@ -358,26 +432,6 @@ package body Exp_Ch9 is\n    --  the scope of Context_Id and Context_Decls is the declarative list of\n    --  Context.\n \n-   procedure Extract_Dispatching_Call\n-     (N        : Node_Id;\n-      Call_Ent : out Entity_Id;\n-      Object   : out Entity_Id;\n-      Actuals  : out List_Id;\n-      Formals  : out List_Id);\n-   --  Given a dispatching call, extract the entity of the name of the call,\n-   --  its actual dispatching object, its actual parameters and the formal\n-   --  parameters of the overridden interface-level version. If the type of\n-   --  the dispatching object is an access type then an explicit dereference\n-   --  is returned in Object.\n-\n-   procedure Extract_Entry\n-     (N       : Node_Id;\n-      Concval : out Node_Id;\n-      Ename   : out Node_Id;\n-      Index   : out Node_Id);\n-   --  Given an entry call, returns the associated concurrent object,\n-   --  the entry name, and the entry family index.\n-\n    function Find_Task_Or_Protected_Pragma\n      (T : Node_Id;\n       P : Name_Id) return Node_Id;\n@@ -393,6 +447,9 @@ package body Exp_Ch9 is\n    --  Task_Body_Procedure of Spec_Id. The returned entity denotes formal\n    --  parameter _E.\n \n+   function Is_Exception_Safe (Subprogram : Node_Id) return Boolean;\n+   --  Tell whether a given subprogram cannot raise an exception\n+\n    function Is_Potentially_Large_Family\n      (Base_Index : Entity_Id;\n       Conctyp    : Entity_Id;\n@@ -762,6 +819,263 @@ package body Exp_Ch9 is\n       Prepend_To (Decls, Decl);\n    end Add_Object_Pointer;\n \n+   ------------------------------------\n+   -- Allow_Lock_Free_Implementation --\n+   ------------------------------------\n+\n+   --  Here are the restrictions for the Lock Free implementation\n+\n+   --    Implementation Restrictions on protected declaration\n+\n+   --       There must be only protected scalar components (at least one)\n+\n+   --       Component types must support an atomic compare_exchange primitive\n+   --       (size equals to 1, 2, 4 or 8 bytes).\n+\n+   --       No entries\n+\n+   --    Implementation Restrictions on protected operations\n+\n+   --       Cannot refer to non-constant outside of the scope of the protected\n+   --       operation.\n+\n+   --       Can only access a single protected component: all protected\n+   --       component names appearing in a scope (including nested scopes)\n+   --       must statically denote the same protected component.\n+\n+   --    Fundamental Restrictions on protected operations\n+\n+   --      No loop and procedure call statements\n+\n+   --      Any function call and attribute reference must be static\n+\n+   function Allow_Lock_Free_Implementation (N : Node_Id) return Boolean is\n+      Decls     : constant List_Id := Declarations (N);\n+      Spec      : constant Entity_Id := Corresponding_Spec (N);\n+      Pro_Def   : constant Node_Id := Protected_Definition (Parent (Spec));\n+      Pri_Decls : constant List_Id := Private_Declarations (Pro_Def);\n+      Vis_Decls : constant List_Id := Visible_Declarations (Pro_Def);\n+\n+      Comp_Id      : Entity_Id;\n+      Comp_Size    : Int;\n+      Comp_Type    : Entity_Id;\n+      No_Component : Boolean := True;\n+      N_Decl       : Node_Id;\n+\n+      function Permit_Lock_Free (Sub_Body : Node_Id) return Boolean;\n+      --  Return True if the protected subprogram body Sub_Body doesn't\n+      --  prevent the lock free code expansion, i.e. Sub_Body meets all the\n+      --  restrictions listed below that allow the lock free implementation.\n+      --\n+      --    Can only access a single protected component\n+      --\n+      --    No loop and procedure call statements\n+\n+      --    Any function call and attribute reference must be static\n+\n+      --    Cannot refer to non-constant outside of the scope of the protected\n+      --    subprogram.\n+\n+      ----------------------\n+      -- Permit_Lock_Free --\n+      ----------------------\n+\n+      function Permit_Lock_Free (Sub_Body : Node_Id) return Boolean is\n+         Sub_Id  : constant Entity_Id := Corresponding_Spec (Sub_Body);\n+         Comp_Id : Entity_Id := Empty;\n+         LF_Sub  : Lock_Free_Sub_Type;\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result;\n+         --  Check the node N meet the lock free restrictions\n+\n+         function Check_All_Nodes is new Traverse_Func (Check_Node);\n+\n+         ----------------\n+         -- Check_Node --\n+         ----------------\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result is\n+            Comp_Decl : Node_Id;\n+            Id        : Entity_Id;\n+\n+         begin\n+            case Nkind (N) is\n+\n+               --  Function call or attribute reference case\n+\n+               when N_Function_Call | N_Attribute_Reference =>\n+\n+                  --  Any function call and attribute reference must be static\n+\n+                  if not Is_Static_Expression (N) then\n+                     return Abandon;\n+                  end if;\n+\n+               --  Loop and procedure call statement case\n+\n+               when N_Procedure_Call_Statement | N_Loop_Statement =>\n+                  --  No loop and procedure call statements\n+                  return Abandon;\n+\n+               --  Identifier case\n+\n+               when N_Identifier =>\n+                  if Present (Entity (N)) then\n+                     Id := Entity (N);\n+\n+                     --  Cannot refer to non-constant entities outside of the\n+                     --  scope of the protected subprogram.\n+\n+                     if Ekind (Id) in Assignable_Kind\n+                       and then Sloc (Scope (Id)) > No_Location\n+                       and then not Scope_Within_Or_Same (Scope (Id), Sub_Id)\n+                       and then not Scope_Within_Or_Same (Scope (Id),\n+                                      Protected_Body_Subprogram (Sub_Id))\n+                     then\n+                        return Abandon;\n+                     end if;\n+\n+                     --  Can only access a single protected component\n+\n+                     if Ekind_In (Id, E_Constant, E_Variable)\n+                       and then Present (Prival_Link (Id))\n+                     then\n+                        Comp_Decl := Parent (Prival_Link (Id));\n+\n+                        if Nkind (Comp_Decl) = N_Component_Declaration\n+                          and then Is_List_Member (Comp_Decl)\n+                          and then List_Containing (Comp_Decl) = Pri_Decls\n+                        then\n+                           --  Check if another protected component has already\n+                           --  been accessed by the subprogram body.\n+\n+                           if Present (Comp_Id)\n+                             and then Comp_Id /= Prival_Link (Id)\n+                           then\n+                              return Abandon;\n+\n+                           elsif not Present (Comp_Id) then\n+                              Comp_Id := Prival_Link (Id);\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+               --  Ok for all other nodes\n+\n+               when others => return OK;\n+            end case;\n+\n+            return OK;\n+         end Check_Node;\n+\n+      --  Start of processing for Permit_Lock_Free\n+\n+      begin\n+         if Check_All_Nodes (Sub_Body) = OK then\n+\n+            --  Fill LF_Sub with Sub_Body and its corresponding protected\n+            --  component entity and then store LF_Sub in the lock free\n+            --  subprogram table LF_Sub_Table.\n+\n+            LF_Sub.Sub_Body := Sub_Body;\n+            LF_Sub.Comp_Id := Comp_Id;\n+            LF_Sub_Table.Append (LF_Sub);\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Permit_Lock_Free;\n+\n+   --  Start of processing for Allow_Lock_Free_Implementation\n+\n+   begin\n+      --  Debug switch -gnatd9 enables Lock Free implementation\n+\n+      if not Debug_Flag_9 then\n+         return False;\n+      end if;\n+\n+      --  Look for any entries declared in the visible part of the protected\n+      --  declaration.\n+\n+      N_Decl := First (Vis_Decls);\n+      while Present (N_Decl) loop\n+         if Nkind (N_Decl) = N_Entry_Declaration then\n+            return False;\n+         end if;\n+\n+         N_Decl := Next (N_Decl);\n+      end loop;\n+\n+      --  Look for any entry, plus look for any scalar component declared in\n+      --  the private part of the protected declaration.\n+\n+      N_Decl := First (Pri_Decls);\n+      while Present (N_Decl) loop\n+\n+         --  Check at least one scalar component is declared\n+\n+         if Nkind (N_Decl) = N_Component_Declaration then\n+            if No_Component then\n+               No_Component := False;\n+            end if;\n+\n+            Comp_Id := Defining_Identifier (N_Decl);\n+            Comp_Type := Etype (Comp_Id);\n+\n+            --  Verify the component is a scalar\n+\n+            if not Is_Scalar_Type (Comp_Type) then\n+               return False;\n+            end if;\n+\n+            Comp_Size := UI_To_Int (Esize (Base_Type (Comp_Type)));\n+\n+            --  Check the size of the component is 8, 16, 32 or 64 bits\n+\n+            case Comp_Size is\n+               when 8 | 16 | 32 | 64 =>\n+                  null;\n+               when others           =>\n+                  return False;\n+            end case;\n+\n+         --  Check there is no entry declared in the private part.\n+\n+         else\n+            if Nkind (N_Decl) = N_Entry_Declaration then\n+               return False;\n+            end if;\n+         end if;\n+\n+         N_Decl := Next (N_Decl);\n+      end loop;\n+\n+      --  One scalar component must be present\n+\n+      if No_Component then\n+         return False;\n+      end if;\n+\n+      --  Ensure all protected subprograms meet the restrictions that allow the\n+      --  lock free implementation.\n+\n+      N_Decl := First (Decls);\n+      while Present (N_Decl) loop\n+         if Nkind (N_Decl) = N_Subprogram_Body\n+           and then not Permit_Lock_Free (N_Decl)\n+         then\n+            return False;\n+         end if;\n+\n+         Next (N_Decl);\n+      end loop;\n+\n+      return True;\n+   end Allow_Lock_Free_Implementation;\n+\n    -----------------------\n    -- Build_Accept_Body --\n    -----------------------\n@@ -2696,180 +3010,700 @@ package body Exp_Ch9 is\n       begin\n          --  Index for current entry body\n \n-         Index := Index + 1;\n+         Index := Index + 1;\n+\n+         --  Compute total length of entry queues so far\n+\n+         if No (Siz) then\n+            Siz := Expr;\n+         else\n+            Siz :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd => Siz,\n+                Right_Opnd => Expr);\n+         end if;\n+\n+         Cond :=\n+           Make_Op_Le (Loc,\n+             Left_Opnd  => Make_Identifier (Loc, Name_uE),\n+             Right_Opnd => Siz);\n+\n+         --  Map entry queue indexes in the range of the current family\n+         --  into the current index, that designates the entry body.\n+\n+         if No (If_St) then\n+            If_St :=\n+              Make_Implicit_If_Statement (Typ,\n+                Condition       => Cond,\n+                Then_Statements => Stats,\n+                Elsif_Parts     => New_List);\n+            Ret := If_St;\n+\n+         else\n+            Append_To (Elsif_Parts (If_St),\n+              Make_Elsif_Part (Loc,\n+                Condition => Cond,\n+                Then_Statements => Stats));\n+         end if;\n+      end Add_If_Clause;\n+\n+      ------------------------------\n+      -- Convert_Discriminant_Ref --\n+      ------------------------------\n+\n+      function Convert_Discriminant_Ref (Bound : Node_Id) return Node_Id is\n+         B   : Node_Id;\n+\n+      begin\n+         if Is_Entity_Name (Bound)\n+           and then Ekind (Entity (Bound)) = E_Discriminant\n+         then\n+            B :=\n+              Make_Selected_Component (Loc,\n+               Prefix =>\n+                 Unchecked_Convert_To (Corresponding_Record_Type (Typ),\n+                   Make_Explicit_Dereference (Loc,\n+                     Make_Identifier (Loc, Name_uObject))),\n+               Selector_Name => Make_Identifier (Loc, Chars (Bound)));\n+            Set_Etype (B, Etype (Entity (Bound)));\n+         else\n+            B := New_Copy_Tree (Bound);\n+         end if;\n+\n+         return B;\n+      end Convert_Discriminant_Ref;\n+\n+   --  Start of processing for Build_Find_Body_Index\n+\n+   begin\n+      Spec := Build_Find_Body_Index_Spec (Typ);\n+\n+      Ent := First_Entity (Typ);\n+      while Present (Ent) loop\n+         if Ekind (Ent) = E_Entry_Family then\n+            Has_F := True;\n+            exit;\n+         end if;\n+\n+         Next_Entity (Ent);\n+      end loop;\n+\n+      if not Has_F then\n+\n+         --  If the protected type has no entry families, there is a one-one\n+         --  correspondence between entry queue and entry body.\n+\n+         Ret :=\n+           Make_Simple_Return_Statement (Loc,\n+             Expression => Make_Identifier (Loc, Name_uE));\n+\n+      else\n+         --  Suppose entries e1, e2, ... have size l1, l2, ... we generate\n+         --  the following:\n+\n+         --  if E <= l1 then return 1;\n+         --  elsif E <= l1 + l2 then return 2;\n+         --  ...\n+\n+         Index := 0;\n+         Siz   := Empty;\n+         Ent   := First_Entity (Typ);\n+\n+         Add_Object_Pointer (Loc, Typ, Decls);\n+\n+         while Present (Ent) loop\n+            if Ekind (Ent) = E_Entry then\n+               Add_If_Clause (Make_Integer_Literal (Loc, 1));\n+\n+            elsif Ekind (Ent) = E_Entry_Family then\n+               E_Typ := Etype (Discrete_Subtype_Definition (Parent (Ent)));\n+               Hi := Convert_Discriminant_Ref (Type_High_Bound (E_Typ));\n+               Lo := Convert_Discriminant_Ref (Type_Low_Bound  (E_Typ));\n+               Add_If_Clause (Family_Size (Loc, Hi, Lo, Typ, False));\n+            end if;\n+\n+            Next_Entity (Ent);\n+         end loop;\n+\n+         if Index = 1 then\n+            Decls := New_List;\n+            Ret :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression => Make_Integer_Literal (Loc, 1));\n+\n+         elsif Nkind (Ret) = N_If_Statement then\n+\n+            --  Ranges are in increasing order, so last one doesn't need guard\n+\n+            declare\n+               Nod : constant Node_Id := Last (Elsif_Parts (Ret));\n+            begin\n+               Remove (Nod);\n+               Set_Else_Statements (Ret, Then_Statements (Nod));\n+            end;\n+         end if;\n+      end if;\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Spec,\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Ret)));\n+   end Build_Find_Body_Index;\n+\n+   --------------------------------\n+   -- Build_Find_Body_Index_Spec --\n+   --------------------------------\n+\n+   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id is\n+      Loc   : constant Source_Ptr := Sloc (Typ);\n+      Id    : constant Entity_Id :=\n+               Make_Defining_Identifier (Loc,\n+                 Chars => New_External_Name (Chars (Typ), 'F'));\n+      Parm1 : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uO);\n+      Parm2 : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uE);\n+\n+   begin\n+      return\n+        Make_Function_Specification (Loc,\n+          Defining_Unit_Name       => Id,\n+          Parameter_Specifications => New_List (\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier => Parm1,\n+              Parameter_Type      =>\n+                New_Reference_To (RTE (RE_Address), Loc)),\n+\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier => Parm2,\n+              Parameter_Type      =>\n+                New_Reference_To (RTE (RE_Protected_Entry_Index), Loc))),\n+\n+          Result_Definition        => New_Occurrence_Of (\n+            RTE (RE_Protected_Entry_Index), Loc));\n+   end Build_Find_Body_Index_Spec;\n+\n+   -----------------------------------------------\n+   -- Build_Lock_Free_Protected_Subprogram_Body --\n+   -----------------------------------------------\n+\n+   function Build_Lock_Free_Protected_Subprogram_Body\n+     (N         : Node_Id;\n+      Pid       : Node_Id;\n+      N_Op_Spec : Node_Id) return Node_Id\n+   is\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Op_Spec      : Node_Id;\n+      P_Op_Spec    : Node_Id;\n+      Uactuals     : List_Id;\n+      Pformal      : Node_Id;\n+      Unprot_Call  : Node_Id;\n+      R            : Node_Id;\n+      Return_Stmt  : Node_Id := Empty;    -- init to avoid gcc 3 warning\n+      Exc_Safe     : Boolean;\n+\n+   begin\n+      Op_Spec := Specification (N);\n+      Exc_Safe := Is_Exception_Safe (N);\n+\n+      P_Op_Spec :=\n+        Build_Protected_Sub_Specification (N, Pid, Protected_Mode);\n+\n+      --  Build a list of the formal parameters of the protected version of\n+      --  the subprogram to use as the actual parameters of the unprotected\n+      --  version.\n+\n+      Uactuals := New_List;\n+      Pformal := First (Parameter_Specifications (P_Op_Spec));\n+      while Present (Pformal) loop\n+         Append_To (Uactuals,\n+           Make_Identifier (Loc, Chars (Defining_Identifier (Pformal))));\n+         Next (Pformal);\n+      end loop;\n+\n+      --  Make a call to the unprotected version of the subprogram built above\n+      --  for use by the protected version built below.\n+\n+      if Nkind (Op_Spec) = N_Function_Specification then\n+         if Exc_Safe then\n+            R := Make_Temporary (Loc, 'R');\n+            Unprot_Call :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => R,\n+                Constant_Present => True,\n+                Object_Definition => New_Copy (Result_Definition (N_Op_Spec)),\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name => Make_Identifier (Loc,\n+                      Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                    Parameter_Associations => Uactuals));\n+\n+            Return_Stmt :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression => New_Reference_To (R, Loc));\n+\n+         else\n+            Unprot_Call := Make_Simple_Return_Statement (Loc,\n+              Expression => Make_Function_Call (Loc,\n+                Name =>\n+                  Make_Identifier (Loc,\n+                    Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                Parameter_Associations => Uactuals));\n+         end if;\n+\n+      else\n+         Unprot_Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               Make_Identifier (Loc, Chars (Defining_Unit_Name (N_Op_Spec))),\n+             Parameter_Associations => Uactuals);\n+      end if;\n+\n+      if Nkind (Op_Spec) = N_Function_Specification\n+        and then Exc_Safe\n+      then\n+         Unprot_Call :=\n+           Make_Block_Statement (Loc,\n+             Declarations               => New_List (Unprot_Call),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Return_Stmt)));\n+      end if;\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Declarations => Empty_List,\n+          Specification => P_Op_Spec,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Unprot_Call)));\n+   end Build_Lock_Free_Protected_Subprogram_Body;\n+\n+   -------------------------------------------------\n+   -- Build_Lock_Free_Unprotected_Subprogram_Body --\n+   -------------------------------------------------\n+\n+   function Build_Lock_Free_Unprotected_Subprogram_Body\n+     (N : Node_Id;\n+      Pid : Node_Id) return Node_Id\n+   is\n+      Decls        : constant List_Id := Declarations (N);\n+      Is_Procedure : constant Boolean :=\n+                       Ekind (Corresponding_Spec (N)) = E_Procedure;\n+      Loc          : constant Source_Ptr := Sloc (N);\n+\n+      function Ren_Comp_Id (Decls : List_Id) return Entity_Id;\n+      --  Given the list of delaration Decls, return the renamed entity\n+      --  of the protected component accessed by the subprogram body.\n+\n+      -----------------\n+      -- Ren_Comp_Id --\n+      -----------------\n+\n+      function Ren_Comp_Id (Decls : List_Id) return Entity_Id is\n+         N_Decl       : Node_Id;\n+         Pri_Link     : Node_Id;\n+\n+      begin\n+         N_Decl := First (Decls);\n+         while Present (N_Decl) loop\n+\n+            --  Look for a renaming declaration\n+\n+            if Nkind (N_Decl) = N_Object_Renaming_Declaration then\n+               Pri_Link := Prival_Link (Defining_Identifier (N_Decl));\n+\n+               --  Compare the renamed entity and the accessed component entity\n+               --  in the LF_Sub_Table.\n+\n+               if Present (Pri_Link) and then Pri_Link = Comp_Of (N) then\n+                  return Defining_Identifier (N_Decl);\n+               end if;\n+            end if;\n+\n+            Next (N_Decl);\n+         end loop;\n+\n+         return Empty;\n+      end Ren_Comp_Id;\n+\n+      Obj_Id      : constant Entity_Id := Ren_Comp_Id (Decls);\n+      At_Comp_Id  : Entity_Id;\n+      At_Load_Id  : Entity_Id;\n+      Copy_Id     : Entity_Id;\n+      Exit_Stmt   : Node_Id;\n+      Label       : Node_Id := Empty;\n+      Label_Id    : Entity_Id;\n+      New_Body    : Node_Id;\n+      New_Decls   : List_Id;\n+      New_Stmts   : List_Id;\n+      Obj_Typ     : Entity_Id;\n+      Old_Id      : Entity_Id;\n+      Typ_Size    : Int;\n+      Unsigned_Id : Entity_Id;\n+\n+      function Make_If (Stmt : Node_Id) return Node_Id;\n+      --  Given the statement Stmt, return an if statement with Stmt at the end\n+      --  of the list of statements.\n+\n+      procedure Process_Stmts (Stmts : List_Id);\n+      --  Wrap each return and raise statements in Stmts into an if statement\n+      --  generated by Make_If. Replace all references to the protected object\n+      --  Obj by a reference to its copy Obj_Copy.\n+\n+      -------------\n+      -- Make_If --\n+      -------------\n+\n+      function Make_If (Stmt : Node_Id) return Node_Id is\n+      begin\n+         --  Generate (for Typ_Size = 32):\n+\n+         --  if System.Atomic_Primitives.Atomic_Compare_Exchange_32\n+         --       (Obj'Address,\n+         --        Interfaces.Unsigned_32! (Obj_Old),\n+         --        Interfaces.Unsigned_32! (Obj_Copy));\n+         --  then\n+         --     < Stmt >\n+         --  else\n+         --     goto L0;\n+         --  end if;\n+\n+         --  Check whether a label has already been created\n+\n+         if not Present (Label) then\n+\n+            --  Create a label which will point just after the last\n+            --  statement of the loop statement generated in step 3.\n+\n+            --  Generate:\n+\n+            --  L0 : Label;\n+\n+            Label_Id :=\n+              Make_Identifier (Loc, New_External_Name ('L', 0));\n+\n+            Set_Entity (Label_Id,\n+              Make_Defining_Identifier (Loc, Chars (Label_Id)));\n+            Label := Make_Label (Loc, Label_Id);\n+\n+            Append_To (Decls,\n+              Make_Implicit_Label_Declaration (Loc,\n+                Defining_Identifier => Entity (Label_Id),\n+                Label_Construct     => Label));\n+         end if;\n+\n+         return\n+           Make_If_Statement (Loc,\n+             Condition       =>\n+               Make_Function_Call (Loc,\n+                 Name                   => New_Reference_To (At_Comp_Id, Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => New_Reference_To (Obj_Id, Loc),\n+                     Attribute_Name => Name_Address),\n+                   Unchecked_Convert_To (Unsigned_Id,\n+                     New_Reference_To (Old_Id, Loc)),\n+                   Unchecked_Convert_To (Unsigned_Id,\n+                     New_Reference_To (Copy_Id, Loc)))),\n+\n+             Then_Statements => New_List (\n+               Relocate_Node (Stmt)),\n+\n+             Else_Statements => New_List (\n+               Make_Goto_Statement (Loc,\n+                 Name => New_Reference_To (Entity (Label_Id), Loc))));\n+      end Make_If;\n+\n+      -------------------\n+      -- Process_Stmts --\n+      -------------------\n+\n+      procedure Process_Stmts (Stmts : List_Id) is\n+         Stmt : Node_Id;\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result;\n+         --  Recognize a return and raise statement and wrap it into an if\n+         --  statement. Replace all references to the protected object by\n+         --  a reference to its copy. Reset all Analyzed flags in order to\n+         --  reanalyze statments inside the new unprotected subprogram body.\n+\n+         procedure Process_Nodes is\n+           new Traverse_Proc (Check_Node);\n+\n+         ----------------\n+         -- Check_Node --\n+         ----------------\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  In case of a procedure, wrap each return and raise statements\n+            --  inside an if statement created by Make_If.\n+\n+            if Is_Procedure\n+             and then Nkind_In (N, N_Simple_Return_Statement,\n+                                   N_Extended_Return_Statement,\n+                                   N_Raise_Statement)\n+             and then\n+               (Nkind (N) /= N_Simple_Return_Statement\n+                 or else N /= Last (Stmts))\n+            then\n+               Rewrite (N, Make_If (N));\n+               return Skip;\n+\n+            --  Replace all references to the protected object by a reference\n+            --  to the new copy.\n+\n+            elsif Nkind (N) = N_Identifier\n+              and then Present (Entity (N))\n+              and then Entity (N) = Obj_Id\n+            then\n+               Rewrite (N, Make_Identifier (Loc, Chars (Copy_Id)));\n+               return Skip;\n+            end if;\n+\n+            --  We mark the node as unanalyzed in order to reanalyze it inside\n+            --  the unprotected subprogram body.\n+\n+            Set_Analyzed (N, False);\n+\n+            return OK;\n+         end Check_Node;\n+\n+      --  Start of processing for Process_Stmts\n+\n+      begin\n+         --  Process_Nodes for each statement in Stmts\n+\n+         Stmt := First (Stmts);\n+         while Present (Stmt) loop\n+            Process_Nodes (Stmt);\n+            Next (Stmt);\n+         end loop;\n+      end Process_Stmts;\n+\n+   --  Start of processing for Build_Lock_Free_Unprotected_Subprogram_Body\n+\n+   begin\n+      New_Stmts := New_Copy_List (Statements (Handled_Statement_Sequence (N)));\n+\n+      --  Do the transformation only if the subprogram accesses a protected\n+      --  component.\n+\n+      if not Present (Obj_Id) then\n+         goto Continue;\n+      end if;\n+\n+      Copy_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Obj_Id), Suffix => \"_copy\"));\n+\n+      Obj_Typ  := Etype (Obj_Id);\n+      Typ_Size := UI_To_Int (Esize (Base_Type (Obj_Typ)));\n+\n+      Process_Stmts (New_Stmts);\n+\n+      --  Procedure case\n+\n+      if Is_Procedure then\n+         case Typ_Size is\n+            when 8 =>\n+               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_8);\n+               At_Load_Id  := RTE (RE_Atomic_Load_8);\n+               Unsigned_Id := RTE (RE_Uint8);\n+\n+            when 16 =>\n+               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_16);\n+               At_Load_Id  := RTE (RE_Atomic_Load_16);\n+               Unsigned_Id := RTE (RE_Uint16);\n \n-         --  Compute total length of entry queues so far\n+            when 32 =>\n+               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_32);\n+               At_Load_Id  := RTE (RE_Atomic_Load_32);\n+               Unsigned_Id := RTE (RE_Uint32);\n \n-         if No (Siz) then\n-            Siz := Expr;\n-         else\n-            Siz :=\n-              Make_Op_Add (Loc,\n-                Left_Opnd => Siz,\n-                Right_Opnd => Expr);\n-         end if;\n+            when 64 =>\n+               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_64);\n+               At_Load_Id  := RTE (RE_Atomic_Load_64);\n+               Unsigned_Id := RTE (RE_Uint64);\n+            when others => null;\n+         end case;\n \n-         Cond :=\n-           Make_Op_Le (Loc,\n-             Left_Opnd  => Make_Identifier (Loc, Name_uE),\n-             Right_Opnd => Siz);\n+         --  Generate (e.g. for Typ_Size = 32):\n+\n+         --  begin\n+         --     loop\n+         --        declare\n+         --           Obj_Old  : constant Obj_Typ :=\n+         --                        Obj_Typ!\n+         --                          (System.Atomic_Primitives.Atomic_Load_32\n+         --                            (Obj'Address));\n+         --           Obj_Copy : Obj_Typ := Obj_Old;\n+         --        begin\n+         --           < New_Stmts >\n+         --           exit when\n+         --             System.Atomic_Primitives.Atomic_Compare_Exchange_32\n+         --               (Obj'Address,\n+         --                Interfaces.Unsigned_32! (Obj_Old),\n+         --                Interfaces.Unsigned_32! (Obj_Copy));\n+         --        end;\n+         --     end loop;\n+         --  end;\n+\n+         --  Step 1: Define a copy and save the old value of the protected\n+         --  object. The copy replaces all the references to the object present\n+         --  in the body of the procedure.\n \n-         --  Map entry queue indexes in the range of the current family\n-         --  into the current index, that designates the entry body.\n+         --  Generate:\n \n-         if No (If_St) then\n-            If_St :=\n-              Make_Implicit_If_Statement (Typ,\n-                Condition => Cond,\n-                Then_Statements => Stats,\n-                Elsif_Parts   => New_List);\n+         --  Obj_Old  : constant Obj_Typ :=\n+         --               Obj_Typ!\n+         --                 (System.Atomic_Primitives.Atomic_Load_32\n+         --                   (Obj'Address));\n+         --  Obj_Copy : Obj_Typ := Obj_Old;\n \n-            Ret := If_St;\n+         Old_Id   := Make_Defining_Identifier (Loc,\n+                       New_External_Name (Chars (Obj_Id), Suffix => \"_old\"));\n \n-         else\n-            Append (\n-              Make_Elsif_Part (Loc,\n-                Condition => Cond,\n-                Then_Statements => Stats),\n-              Elsif_Parts (If_St));\n-         end if;\n-      end Add_If_Clause;\n+         New_Decls := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Old_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Obj_Typ, Loc),\n+             Expression          => Unchecked_Convert_To (Obj_Typ,\n+               Make_Function_Call (Loc,\n+                 Name                   => New_Reference_To (At_Load_Id, Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => New_Reference_To (Obj_Id, Loc),\n+                     Attribute_Name => Name_Address))))),\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Copy_Id,\n+             Object_Definition   => New_Reference_To (Obj_Typ, Loc),\n+             Expression          => New_Reference_To (Old_Id, Loc)));\n \n-      ------------------------------\n-      -- Convert_Discriminant_Ref --\n-      ------------------------------\n+         --  Step 2: Create an exit statement of the loop statement generated\n+         --  in step 3.\n \n-      function Convert_Discriminant_Ref (Bound : Node_Id) return Node_Id is\n-         B   : Node_Id;\n+         --  Generate (for Typ_Size = 32):\n \n-      begin\n-         if Is_Entity_Name (Bound)\n-           and then Ekind (Entity (Bound)) = E_Discriminant\n-         then\n-            B :=\n-              Make_Selected_Component (Loc,\n-               Prefix =>\n-                 Unchecked_Convert_To (Corresponding_Record_Type (Typ),\n-                   Make_Explicit_Dereference (Loc,\n-                     Make_Identifier (Loc, Name_uObject))),\n-               Selector_Name => Make_Identifier (Loc, Chars (Bound)));\n-            Set_Etype (B, Etype (Entity (Bound)));\n+         --  exit when System.Atomic_Primitives.Atomic_Compare_Exchange_32\n+         --              (Obj'Address,\n+         --               Interfaces.Unsigned_32! (Obj_Old),\n+         --               Interfaces.Unsigned_32! (Obj_Copy));\n+\n+         Exit_Stmt :=\n+           Make_Exit_Statement (Loc,\n+             Condition =>\n+               Make_Function_Call (Loc,\n+                 Name                   => New_Reference_To (At_Comp_Id, Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => New_Reference_To (Obj_Id, Loc),\n+                     Attribute_Name => Name_Address),\n+                   Unchecked_Convert_To (Unsigned_Id,\n+                     New_Reference_To (Old_Id, Loc)),\n+                   Unchecked_Convert_To (Unsigned_Id,\n+                     New_Reference_To (Copy_Id, Loc)))));\n+\n+         --  Check the last statement is a return statement\n+\n+         if Nkind (Last (New_Stmts)) = N_Simple_Return_Statement then\n+            Rewrite (Last (New_Stmts), Exit_Stmt);\n          else\n-            B := New_Copy_Tree (Bound);\n+            Append_To (New_Stmts, Exit_Stmt);\n          end if;\n \n-         return B;\n-      end Convert_Discriminant_Ref;\n-\n-   --  Start of processing for Build_Find_Body_Index\n+         --  Step 3: Create the loop statement which encloses a block\n+         --  declaration that contains all the statements of the original\n+         --  procedure body.\n \n-   begin\n-      Spec := Build_Find_Body_Index_Spec (Typ);\n+         --  Generate:\n \n-      Ent := First_Entity (Typ);\n-      while Present (Ent) loop\n-         if Ekind (Ent) = E_Entry_Family then\n-            Has_F := True;\n-            exit;\n-         end if;\n+         --  loop\n+         --     declare\n+         --        < New_Decls >\n+         --     begin\n+         --        < New_Stmts >\n+         --     end;\n+         --  end loop;\n \n-         Next_Entity (Ent);\n-      end loop;\n+         New_Stmts := New_List (\n+           Make_Loop_Statement (Loc,\n+             Statements => New_List (\n+               Make_Block_Statement (Loc,\n+                 Declarations               => New_Decls,\n+                 Handled_Statement_Sequence =>\n+                   Make_Handled_Sequence_Of_Statements (Loc,\n+                     Statements => New_Stmts))),\n+             End_Label  => Empty));\n \n-      if not Has_F then\n+         --  Append the label to the statements of the loop when needed\n \n-         --  If the protected type has no entry families, there is a one-one\n-         --  correspondence between entry queue and entry body.\n+         if Present (Label) then\n+            Append_To (Statements (First (New_Stmts)), Label);\n+         end if;\n \n-         Ret :=\n-           Make_Simple_Return_Statement (Loc,\n-             Expression => Make_Identifier (Loc, Name_uE));\n+      --  Function case\n \n       else\n-         --  Suppose entries e1, e2, ... have size l1, l2, ... we generate\n-         --  the following:\n-         --\n-         --  if E <= l1 then return 1;\n-         --  elsif E <= l1 + l2 then return 2;\n-         --  ...\n-\n-         Index := 0;\n-         Siz   := Empty;\n-         Ent   := First_Entity (Typ);\n+         case Typ_Size is\n+            when 8 =>\n+               At_Load_Id := RTE (RE_Atomic_Load_8);\n+            when 16 =>\n+               At_Load_Id := RTE (RE_Atomic_Load_16);\n+            when 32 =>\n+               At_Load_Id := RTE (RE_Atomic_Load_32);\n+            when 64 =>\n+               At_Load_Id := RTE (RE_Atomic_Load_64);\n+            when others => null;\n+         end case;\n \n-         Add_Object_Pointer (Loc, Typ, Decls);\n+         --  Define a copy of the protected object which replaces all the\n+         --  references to the object present in the body of the function.\n \n-         while Present (Ent) loop\n-            if Ekind (Ent) = E_Entry then\n-               Add_If_Clause (Make_Integer_Literal (Loc, 1));\n+         --  Generate:\n \n-            elsif Ekind (Ent) = E_Entry_Family then\n-               E_Typ := Etype (Discrete_Subtype_Definition (Parent (Ent)));\n-               Hi := Convert_Discriminant_Ref (Type_High_Bound (E_Typ));\n-               Lo := Convert_Discriminant_Ref (Type_Low_Bound  (E_Typ));\n-               Add_If_Clause (Family_Size (Loc, Hi, Lo, Typ, False));\n-            end if;\n+         --  Obj_Copy : constant Obj_Typ :=\n+         --               Obj_Typ!\n+         --                 (System.Atomic_Primitives.Atomic_Load_32\n+         --                   (Obj'Address));\n \n-            Next_Entity (Ent);\n-         end loop;\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Copy_Id,\n+             Constant_Present => True,\n+             Object_Definition => New_Reference_To (Obj_Typ, Loc),\n+             Expression => Unchecked_Convert_To (Obj_Typ,\n+               Make_Function_Call (Loc,\n+                 Name => New_Reference_To (At_Load_Id, Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Reference_To (Obj_Id, Loc),\n+                     Attribute_Name => Name_Address))))));\n+      end if;\n \n-         if Index = 1 then\n-            Decls := New_List;\n-            Ret :=\n-              Make_Simple_Return_Statement (Loc,\n-                Expression => Make_Integer_Literal (Loc, 1));\n+      << Continue >>\n \n-         elsif Nkind (Ret) = N_If_Statement then\n+      --  Add renamings for the Protection object, discriminals, privals and\n+      --  the entry index constant for use by debugger.\n \n-            --  Ranges are in increasing order, so last one doesn't need guard\n+      Debug_Private_Data_Declarations (Decls);\n \n-            declare\n-               Nod : constant Node_Id := Last (Elsif_Parts (Ret));\n-            begin\n-               Remove (Nod);\n-               Set_Else_Statements (Ret, Then_Statements (Nod));\n-            end;\n-         end if;\n-      end if;\n+      --  Make an unprotected version of the subprogram for use within the same\n+      --  object, with new name and extra parameter representing the object.\n \n-      return\n+      New_Body :=\n         Make_Subprogram_Body (Loc,\n-          Specification => Spec,\n-          Declarations  => Decls,\n+          Specification              =>\n+            Build_Protected_Sub_Specification (N, Pid, Unprotected_Mode),\n+          Declarations               => Decls,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Ret)));\n-   end Build_Find_Body_Index;\n-\n-   --------------------------------\n-   -- Build_Find_Body_Index_Spec --\n-   --------------------------------\n-\n-   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id is\n-      Loc   : constant Source_Ptr := Sloc (Typ);\n-      Id    : constant Entity_Id :=\n-               Make_Defining_Identifier (Loc,\n-                 Chars => New_External_Name (Chars (Typ), 'F'));\n-      Parm1 : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uO);\n-      Parm2 : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uE);\n-\n-   begin\n-      return\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name => Id,\n-          Parameter_Specifications => New_List (\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Parm1,\n-              Parameter_Type =>\n-                New_Reference_To (RTE (RE_Address), Loc)),\n-\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Parm2,\n-              Parameter_Type =>\n-                New_Reference_To (RTE (RE_Protected_Entry_Index), Loc))),\n-          Result_Definition => New_Occurrence_Of (\n-            RTE (RE_Protected_Entry_Index), Loc));\n-   end Build_Find_Body_Index_Spec;\n+              Statements => New_Stmts));\n+      return New_Body;\n+   end Build_Lock_Free_Unprotected_Subprogram_Body;\n \n    -------------------------\n    -- Build_Master_Entity --\n@@ -3442,102 +4276,6 @@ package body Exp_Ch9 is\n       Exc_Safe     : Boolean;\n       Lock_Kind    : RE_Id;\n \n-      function Is_Exception_Safe (Subprogram : Node_Id) return Boolean;\n-      --  Tell whether a given subprogram cannot raise an exception\n-\n-      -----------------------\n-      -- Is_Exception_Safe --\n-      -----------------------\n-\n-      function Is_Exception_Safe (Subprogram : Node_Id) return Boolean is\n-\n-         function Has_Side_Effect (N : Node_Id) return Boolean;\n-         --  Return True whenever encountering a subprogram call or raise\n-         --  statement of any kind in the sequence of statements\n-\n-         ---------------------\n-         -- Has_Side_Effect --\n-         ---------------------\n-\n-         --  What is this doing buried two levels down in exp_ch9. It seems\n-         --  like a generally useful function, and indeed there may be code\n-         --  duplication going on here ???\n-\n-         function Has_Side_Effect (N : Node_Id) return Boolean is\n-            Stmt : Node_Id;\n-            Expr : Node_Id;\n-\n-            function Is_Call_Or_Raise (N : Node_Id) return Boolean;\n-            --  Indicate whether N is a subprogram call or a raise statement\n-\n-            ----------------------\n-            -- Is_Call_Or_Raise --\n-            ----------------------\n-\n-            function Is_Call_Or_Raise (N : Node_Id) return Boolean is\n-            begin\n-               return Nkind_In (N, N_Procedure_Call_Statement,\n-                                   N_Function_Call,\n-                                   N_Raise_Statement,\n-                                   N_Raise_Constraint_Error,\n-                                   N_Raise_Program_Error,\n-                                   N_Raise_Storage_Error);\n-            end Is_Call_Or_Raise;\n-\n-         --  Start of processing for Has_Side_Effect\n-\n-         begin\n-            Stmt := N;\n-            while Present (Stmt) loop\n-               if Is_Call_Or_Raise (Stmt) then\n-                  return True;\n-               end if;\n-\n-               --  An object declaration can also contain a function call\n-               --  or a raise statement\n-\n-               if Nkind (Stmt) = N_Object_Declaration then\n-                  Expr := Expression (Stmt);\n-\n-                  if Present (Expr) and then Is_Call_Or_Raise (Expr) then\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next (Stmt);\n-            end loop;\n-\n-            return False;\n-         end Has_Side_Effect;\n-\n-      --  Start of processing for Is_Exception_Safe\n-\n-      begin\n-         --  If the checks handled by the back end are not disabled, we cannot\n-         --  ensure that no exception will be raised.\n-\n-         if not Access_Checks_Suppressed (Empty)\n-           or else not Discriminant_Checks_Suppressed (Empty)\n-           or else not Range_Checks_Suppressed (Empty)\n-           or else not Index_Checks_Suppressed (Empty)\n-           or else Opt.Stack_Checking_Enabled\n-         then\n-            return False;\n-         end if;\n-\n-         if Has_Side_Effect (First (Declarations (Subprogram)))\n-           or else\n-              Has_Side_Effect (\n-                First (Statements (Handled_Statement_Sequence (Subprogram))))\n-         then\n-            return False;\n-         else\n-            return True;\n-         end if;\n-      end Is_Exception_Safe;\n-\n-   --  Start of processing for Build_Protected_Subprogram_Body\n-\n    begin\n       Op_Spec := Specification (N);\n       Exc_Safe := Is_Exception_Safe (N);\n@@ -4698,6 +5436,21 @@ package body Exp_Ch9 is\n       end loop;\n    end Collect_Entry_Families;\n \n+   -------------\n+   -- Comp_Of --\n+   -------------\n+\n+   function Comp_Of (Sub_Body : Node_Id) return Entity_Id is\n+   begin\n+      for Sub_Id in 1 .. LF_Sub_Table.Last loop\n+         if Sub_Body = LF_Sub_Table.Table (Sub_Id).Sub_Body then\n+            return LF_Sub_Table.Table (Sub_Id).Comp_Id;\n+         end if;\n+      end loop;\n+\n+      return Empty;\n+   end Comp_Of;\n+\n    -----------------------\n    -- Concurrent_Object --\n    -----------------------\n@@ -7715,6 +8468,9 @@ package body Exp_Ch9 is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n \n+      Lock_Free_On : constant Boolean := Allow_Lock_Free_Implementation (N);\n+      --  This flag indicates whether the lock free implementation is active\n+\n       Current_Node : Node_Id;\n       Disp_Op_Body : Node_Id;\n       New_Op_Body  : Node_Id;\n@@ -7843,8 +8599,14 @@ package body Exp_Ch9 is\n                if not Is_Eliminated (Defining_Entity (Op_Body))\n                  and then not Is_Eliminated (Corresponding_Spec (Op_Body))\n                then\n-                  New_Op_Body :=\n-                    Build_Unprotected_Subprogram_Body (Op_Body, Pid);\n+                  if Lock_Free_On then\n+                     New_Op_Body :=\n+                       Build_Lock_Free_Unprotected_Subprogram_Body\n+                         (Op_Body, Pid);\n+                  else\n+                     New_Op_Body :=\n+                       Build_Unprotected_Subprogram_Body (Op_Body, Pid);\n+                  end if;\n \n                   Insert_After (Current_Node, New_Op_Body);\n                   Current_Node := New_Op_Body;\n@@ -7854,6 +8616,7 @@ package body Exp_Ch9 is\n                   --  appear that this is needed only if this is a visible\n                   --  operation of the type, or if it is an interrupt handler,\n                   --  and this was the strategy used previously in GNAT.\n+\n                   --  However, the operation may be exported through a 'Access\n                   --  to an external caller. This is the common idiom in code\n                   --  that uses the Ada 2005 Timing_Events package. As a result\n@@ -7863,9 +8626,15 @@ package body Exp_Ch9 is\n                   --  declaration in the protected body itself.\n \n                   if Present (Corresponding_Spec (Op_Body)) then\n-                     New_Op_Body :=\n-                       Build_Protected_Subprogram_Body (\n-                         Op_Body, Pid, Specification (New_Op_Body));\n+                     if Lock_Free_On then\n+                        New_Op_Body :=\n+                          Build_Lock_Free_Protected_Subprogram_Body\n+                            (Op_Body, Pid, Specification (New_Op_Body));\n+                     else\n+                        New_Op_Body :=\n+                          Build_Protected_Subprogram_Body\n+                            (Op_Body, Pid, Specification (New_Op_Body));\n+                     end if;\n \n                      Insert_After (Current_Node, New_Op_Body);\n                      Analyze (New_Op_Body);\n@@ -12688,6 +13457,97 @@ package body Exp_Ch9 is\n       end if;\n    end Install_Private_Data_Declarations;\n \n+   -----------------------\n+   -- Is_Exception_Safe --\n+   -----------------------\n+\n+   function Is_Exception_Safe (Subprogram : Node_Id) return Boolean is\n+\n+      function Has_Side_Effect (N : Node_Id) return Boolean;\n+      --  Return True whenever encountering a subprogram call or raise\n+      --  statement of any kind in the sequence of statements\n+\n+      ---------------------\n+      -- Has_Side_Effect --\n+      ---------------------\n+\n+      --  What is this doing buried two levels down in exp_ch9. It seems like a\n+      --  generally useful function, and indeed there may be code duplication\n+      --  going on here ???\n+\n+      function Has_Side_Effect (N : Node_Id) return Boolean is\n+         Stmt : Node_Id;\n+         Expr : Node_Id;\n+\n+         function Is_Call_Or_Raise (N : Node_Id) return Boolean;\n+         --  Indicate whether N is a subprogram call or a raise statement\n+\n+         ----------------------\n+         -- Is_Call_Or_Raise --\n+         ----------------------\n+\n+         function Is_Call_Or_Raise (N : Node_Id) return Boolean is\n+         begin\n+            return Nkind_In (N, N_Procedure_Call_Statement,\n+                                N_Function_Call,\n+                                N_Raise_Statement,\n+                                N_Raise_Constraint_Error,\n+                                N_Raise_Program_Error,\n+                                N_Raise_Storage_Error);\n+         end Is_Call_Or_Raise;\n+\n+      --  Start of processing for Has_Side_Effect\n+\n+      begin\n+         Stmt := N;\n+         while Present (Stmt) loop\n+            if Is_Call_Or_Raise (Stmt) then\n+               return True;\n+            end if;\n+\n+            --  An object declaration can also contain a function call or a\n+            --  raise statement.\n+\n+            if Nkind (Stmt) = N_Object_Declaration then\n+               Expr := Expression (Stmt);\n+\n+               if Present (Expr) and then Is_Call_Or_Raise (Expr) then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next (Stmt);\n+         end loop;\n+\n+         return False;\n+      end Has_Side_Effect;\n+\n+   --  Start of processing for Is_Exception_Safe\n+\n+   begin\n+      --  If the checks handled by the back end are not disabled, we cannot\n+      --  ensure that no exception will be raised.\n+\n+      if not Access_Checks_Suppressed (Empty)\n+        or else not Discriminant_Checks_Suppressed (Empty)\n+        or else not Range_Checks_Suppressed (Empty)\n+        or else not Index_Checks_Suppressed (Empty)\n+        or else Opt.Stack_Checking_Enabled\n+      then\n+         return False;\n+      end if;\n+\n+      if Has_Side_Effect (First (Declarations (Subprogram)))\n+        or else\n+          Has_Side_Effect\n+            (First (Statements (Handled_Statement_Sequence (Subprogram))))\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Is_Exception_Safe;\n+\n    ---------------------------------\n    -- Is_Potentially_Large_Family --\n    ---------------------------------\n@@ -12702,11 +13562,12 @@ package body Exp_Ch9 is\n       return Scope (Base_Index) = Standard_Standard\n         and then Base_Index = Base_Type (Standard_Integer)\n         and then Has_Discriminants (Conctyp)\n-        and then Present\n-          (Discriminant_Default_Value (First_Discriminant (Conctyp)))\n+        and then\n+          Present (Discriminant_Default_Value (First_Discriminant (Conctyp)))\n         and then\n           (Denotes_Discriminant (Lo, True)\n-            or else Denotes_Discriminant (Hi, True));\n+             or else\n+           Denotes_Discriminant (Hi, True));\n    end Is_Potentially_Large_Family;\n \n    -------------------------------------"}, {"sha": "ae5470f659ca0191db91307c1ba260df077fc9db", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -3948,8 +3948,7 @@ package body Exp_Util is\n      (Obj_Id : Entity_Id) return Boolean\n    is\n       function Is_Controlled_Function_Call (N : Node_Id) return Boolean;\n-      --  Determine whether a particular node denotes a controlled function\n-      --  call.\n+      --  Determine if particular node denotes a controlled function call\n \n       function Is_Displace_Call (N : Node_Id) return Boolean;\n       --  Determine whether a particular node is a call to Ada.Tags.Displace.\n@@ -4065,7 +4064,7 @@ package body Exp_Util is\n           and then Is_Displace_Call (Renamed_Object (Obj_Id))\n           and then\n             (Is_Controlled_Function_Call (Expression (Orig_Decl))\n-               or else Is_Source_Object (Expression (Orig_Decl)));\n+              or else Is_Source_Object (Expression (Orig_Decl)));\n    end Is_Displacement_Of_Object_Or_Function_Result;\n \n    ------------------------------"}, {"sha": "60d3577ad41633896dc62faba6f7bbb912d77de2", "filename": "gcc/ada/g-sse.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fg-sse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fg-sse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sse.ads?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,8 @@\n \n --     GNU/Linux x86 and x86_64\n --     Windows XP/Vista x86 and x86_64\n+--     Solaris x86\n+--     Darwin x86_64\n \n --  This unit exposes vector _component_ types together with general comments\n --  on the binding contents."}, {"sha": "5c4acda53882c7cc2b265b083dd87d788f8d3538", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -1083,6 +1083,8 @@ ifeq ($(strip $(filter-out %86 %x86_64 solaris2%,$(arch) $(osys))),)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb\n \n+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n+\n   EH_MECHANISM=-gcc\n   THREADSLIB = -lposix4 -lthread\n   MISCLIB = -lposix4 -lnsl -lsocket\n@@ -1175,6 +1177,8 @@ ifeq ($(strip $(filter-out %86 kfreebsd%,$(arch) $(osys))),)\n     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n     indepsw.adb<indepsw-gnu.adb\n \n+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n+\n   EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n@@ -1231,6 +1235,8 @@ ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n   GNATLIB_SHARED = gnatlib-shared-dual\n \n+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n+\n   EH_MECHANISM=-gcc\n   THREADSLIB= -lpthread\n   GMEM_LIB = gmemlib\n@@ -1259,6 +1265,8 @@ ifeq ($(strip $(filter-out %86_64 freebsd%,$(arch) $(osys))),)\n   mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n   GNATLIB_SHARED = gnatlib-shared-dual\n \n+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n+\n   EH_MECHANISM=-gcc\n   THREADSLIB= -lpthread\n   GMEM_LIB = gmemlib\n@@ -2160,6 +2168,8 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n         $(X86_TARGET_PAIRS) \\\n         system.ads<system-darwin-x86.ads\n     endif\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n   endif\n \n   ifeq ($(strip $(filter-out %x86_64,$(arch))),)\n@@ -2178,6 +2188,8 @@ ifeq ($(strip $(filter-out darwin%,$(osys))),)\n         $(X86_64_TARGET_PAIRS) \\\n         system.ads<system-darwin-x86_64.ads\n     endif\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o\n   endif\n \n   ifeq ($(strip $(filter-out powerpc%,$(arch))),)"}, {"sha": "9a2e7ee26f382ac093dc29d34dbe9f3511484c94", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -444,6 +444,15 @@ package body Osint is\n    --  Start of processing for Add_Default_Search_Dirs\n \n    begin\n+      --  If there was a -gnateO switch, add all object directories from the\n+      --  file given in argument to the library search list.\n+\n+      if Object_Path_File_Name /= null then\n+         Path_File_Name := String_Access (Object_Path_File_Name);\n+         pragma Assert (Path_File_Name'Length > 0);\n+         Get_Dirs_From_File (Additional_Source_Dir => False);\n+      end if;\n+\n       --  After the locations specified on the command line, the next places\n       --  to look for files are the directories specified by the appropriate\n       --  environment variable. Get this value, extract the directory names"}, {"sha": "48663f519e8dc2074ba0c4e61f50d03d9261a68d", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -324,7 +324,8 @@ package Osint is\n \n    procedure Add_Default_Search_Dirs;\n    --  This routine adds the default search dirs indicated by the environment\n-   --  variables and sdefault package.\n+   --  variables and sdefault package, as well as the library search dirs set\n+   --  by option -gnateO for GNAT2WHY.\n \n    procedure Add_Lib_Search_Dir (Dir : String);\n    --  Add Dir at the end of the library file search path"}, {"sha": "e02f575d7d5847138e27a684307f58b545297c6d", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -211,6 +211,7 @@ package Rtsfind is\n       System_Arith_64,\n       System_AST_Handling,\n       System_Assertions,\n+      System_Atomic_Primitives,\n       System_Aux_DEC,\n       System_Bit_Ops,\n       System_Boolean_Array_Operations,\n@@ -730,6 +731,19 @@ package Rtsfind is\n      RE_Assert_Failure,                  -- System.Assertions\n      RE_Raise_Assert_Failure,            -- System.Assertions\n \n+     RE_Atomic_Compare_Exchange_8,       -- System.Atomic_Primitives\n+     RE_Atomic_Compare_Exchange_16,      -- System.Atomic_Primitives\n+     RE_Atomic_Compare_Exchange_32,      -- System.Atomic_Primitives\n+     RE_Atomic_Compare_Exchange_64,      -- System.Atomic_Primitives\n+     RE_Atomic_Load_8,                   -- System.Atomic_Primitives\n+     RE_Atomic_Load_16,                  -- System.Atomic_Primitives\n+     RE_Atomic_Load_32,                  -- System.Atomic_Primitives\n+     RE_Atomic_Load_64,                  -- System.Atomic_Primitives\n+     RE_Uint8,                           -- System.Atomic_Primitives\n+     RE_Uint16,                          -- System.Atomic_Primitives\n+     RE_Uint32,                          -- System.Atomic_Primitives\n+     RE_Uint64,                          -- System.Atomic_Primitives\n+\n      RE_AST_Handler,                     -- System.Aux_DEC\n      RE_Import_Value,                    -- System.Aux_DEC\n      RE_No_AST_Handler,                  -- System.Aux_DEC\n@@ -1938,6 +1952,19 @@ package Rtsfind is\n      RE_Assert_Failure                   => System_Assertions,\n      RE_Raise_Assert_Failure             => System_Assertions,\n \n+     RE_Atomic_Compare_Exchange_8        => System_Atomic_Primitives,\n+     RE_Atomic_Compare_Exchange_16       => System_Atomic_Primitives,\n+     RE_Atomic_Compare_Exchange_32       => System_Atomic_Primitives,\n+     RE_Atomic_Compare_Exchange_64       => System_Atomic_Primitives,\n+     RE_Atomic_Load_8                    => System_Atomic_Primitives,\n+     RE_Atomic_Load_16                   => System_Atomic_Primitives,\n+     RE_Atomic_Load_32                   => System_Atomic_Primitives,\n+     RE_Atomic_Load_64                   => System_Atomic_Primitives,\n+     RE_Uint8                            => System_Atomic_Primitives,\n+     RE_Uint16                           => System_Atomic_Primitives,\n+     RE_Uint32                           => System_Atomic_Primitives,\n+     RE_Uint64                           => System_Atomic_Primitives,\n+\n      RE_AST_Handler                      => System_Aux_DEC,\n      RE_Import_Value                     => System_Aux_DEC,\n      RE_No_AST_Handler                   => System_Aux_DEC,"}, {"sha": "6f39cf0edb0ab0b4f639ab543f51dcf43695cc3f", "filename": "gcc/ada/s-atopri.ads", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fs-atopri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fs-atopri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atopri.ads?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -0,0 +1,120 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . A T O M I C _ P R I M I T I V E S            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--              Copyright (C) 2012, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System.Atomic_Primitives is\n+   pragma Preelaborate;\n+\n+   type uint8  is mod 2**8\n+     with Size => 8;\n+\n+   type uint16 is mod 2**16\n+     with Size => 16;\n+\n+   type uint32 is mod 2**32\n+     with Size => 32;\n+\n+   type uint64 is mod 2**64\n+     with Size => 64;\n+\n+   Relaxed : constant := 0;\n+   Consume : constant := 1;\n+   Acquire : constant := 2;\n+   Release : constant := 3;\n+   Acq_Rel : constant := 4;\n+   Seq_Cst : constant := 5;\n+   Last    : constant := 6;\n+\n+   subtype Mem_Model is Integer range Relaxed .. Last;\n+\n+   function Atomic_Compare_Exchange_8\n+     (X             : Address;\n+      X_Old         : uint8;\n+      X_Copy        : uint8) return Boolean;\n+   pragma Import (Intrinsic,\n+                  Atomic_Compare_Exchange_8,\n+                  \"__sync_bool_compare_and_swap_1\");\n+\n+   --  ??? Should use __atomic_compare_exchange_1 (doesn't work yet):\n+   --  function Atomic_Compare_Exchange_8\n+   --    (X             : Address;\n+   --     X_Old         : Address;\n+   --     X_Copy        : uint8;\n+   --     Success_Model : Mem_Model := Seq_Cst;\n+   --     Failure_Model : Mem_Model := Seq_Cst) return Boolean;\n+   --  pragma Import (Intrinsic,\n+   --                 Atomic_Compare_Exchange_8,\n+   --                 \"__atomic_compare_exchange_1\");\n+\n+   function Atomic_Compare_Exchange_16\n+     (X             : Address;\n+      X_Old         : uint16;\n+      X_Copy        : uint16) return Boolean;\n+   pragma Import (Intrinsic,\n+                  Atomic_Compare_Exchange_16,\n+                  \"__sync_bool_compare_and_swap_2\");\n+\n+   function Atomic_Compare_Exchange_32\n+     (X             : Address;\n+      X_Old         : uint32;\n+      X_Copy        : uint32) return Boolean;\n+   pragma Import (Intrinsic,\n+                  Atomic_Compare_Exchange_32,\n+                  \"__sync_bool_compare_and_swap_4\");\n+\n+   function Atomic_Compare_Exchange_64\n+     (X             : Address;\n+      X_Old         : uint64;\n+      X_Copy        : uint64) return Boolean;\n+   pragma Import (Intrinsic,\n+                  Atomic_Compare_Exchange_64,\n+                  \"__sync_bool_compare_and_swap_8\");\n+\n+   function Atomic_Load_8\n+     (X     : Address;\n+      Model : Mem_Model := Seq_Cst) return uint8;\n+   pragma Import (Intrinsic, Atomic_Load_8, \"__atomic_load_1\");\n+\n+   function Atomic_Load_16\n+     (X     : Address;\n+      Model : Mem_Model := Seq_Cst) return uint16;\n+   pragma Import (Intrinsic, Atomic_Load_16, \"__atomic_load_2\");\n+\n+   function Atomic_Load_32\n+     (X     : Address;\n+      Model : Mem_Model := Seq_Cst) return uint32;\n+   pragma Import (Intrinsic, Atomic_Load_32, \"__atomic_load_4\");\n+\n+   function Atomic_Load_64\n+     (X     : Address;\n+      Model : Mem_Model := Seq_Cst) return uint64;\n+   pragma Import (Intrinsic, Atomic_Load_64, \"__atomic_load_8\");\n+\n+end System.Atomic_Primitives;"}, {"sha": "6feb84cdefa2032c4567a9e72e9b43f17fe23fd5", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -1666,6 +1666,9 @@ package body Sem_Ch5 is\n \n       if not Is_Entity_Name (Iter_Name)\n         and then (Nkind (Parent (N)) /= N_Quantified_Expression\n+\n+                   --  The following two tests need comments ???\n+\n                    or else Operating_Mode = Check_Semantics\n                    or else Alfa_Mode)\n       then"}, {"sha": "ef5f8b4ed508dbbc787242caa4810a930bad3ff7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -2624,10 +2624,10 @@ package body Sem_Res is\n          --  an error. We can't do this earlier, because it would cause legal\n          --  cases to get errors (when some other type has an abstract \"+\").\n \n-         if Ada_Version >= Ada_2005 and then\n-           Nkind (N) in N_Op and then\n-           Is_Overloaded (N) and then\n-           Is_Universal_Numeric_Type (Etype (Entity (N)))\n+         if Ada_Version >= Ada_2005\n+           and then Nkind (N) in N_Op\n+           and then Is_Overloaded (N)\n+           and then Is_Universal_Numeric_Type (Etype (Entity (N)))\n          then\n             Get_First_Interp (N, I, It);\n             while Present (It.Typ) loop\n@@ -6118,15 +6118,36 @@ package body Sem_Res is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n       Else_Expr : Node_Id          := Next (Then_Expr);\n+      Else_Typ  : Entity_Id;\n+      Then_Typ  : Entity_Id;\n \n    begin\n       Resolve (Condition, Any_Boolean);\n       Resolve (Then_Expr, Typ);\n+      Then_Typ := Etype (Then_Expr);\n+\n+      --  When the \"then\" and \"else\" expressions are of a scalar type, insert\n+      --  a conversion to ensure the generation of a constraint check.\n+\n+      if Is_Scalar_Type (Then_Typ)\n+        and then Then_Typ /= Typ\n+      then\n+         Rewrite (Then_Expr, Convert_To (Typ, Then_Expr));\n+         Analyze_And_Resolve (Then_Expr, Typ);\n+      end if;\n \n       --  If ELSE expression present, just resolve using the determined type\n \n       if Present (Else_Expr) then\n          Resolve (Else_Expr, Typ);\n+         Else_Typ := Etype (Else_Expr);\n+\n+         if Is_Scalar_Type (Else_Typ)\n+           and then Else_Typ /= Typ\n+         then\n+            Rewrite (Else_Expr, Convert_To (Typ, Else_Expr));\n+            Analyze_And_Resolve (Else_Expr, Typ);\n+         end if;\n \n       --  If no ELSE expression is present, root type must be Standard.Boolean\n       --  and we provide a Standard.True result converted to the appropriate"}, {"sha": "b8e4d813c08be6e401e13bba8b4069fa5516b330", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -740,15 +740,16 @@ package body Sem_Util is\n       N : Node_Id) return Entity_Id\n    is\n       Loc  : constant Source_Ptr := Sloc (N);\n-      Bas  : Entity_Id;\n-      --  The base type that is to be constrained by the defaults.\n-\n       Disc : Entity_Id;\n \n+      Bas : Entity_Id;\n+      --  The base type that is to be constrained by the defaults\n+\n    begin\n       if not Has_Discriminants (T) or else Is_Constrained (T) then\n          return T;\n       end if;\n+\n       Bas := Base_Type (T);\n \n       --  If T is non-private but its base type is private, this is\n@@ -757,9 +758,7 @@ package body Sem_Util is\n       --  proper discriminants are to be found in the full view of\n       --  the base.\n \n-      if Is_Private_Type (Bas)\n-        and then Present (Full_View (Bas))\n-      then\n+      if Is_Private_Type (Bas) and then Present (Full_View (Bas)) then\n          Bas := Full_View (Bas);\n       end if;\n "}, {"sha": "e9f1c8ef6840acea2b9b206c002d15637dff0e22", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36504e5f465b19d444187bcee11a26e1842d277c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=36504e5f465b19d444187bcee11a26e1842d277c", "patch": "@@ -1252,7 +1252,7 @@ package Sinfo is\n    --    to the node for the spec of the instance, inserted as part of the\n    --    semantic processing for instantiations in Sem_Ch12.\n \n-   --  Is_Accessibility_Actual (Flag12-Sem)\n+   --  Is_Accessibility_Actual (Flag13-Sem)\n    --    Present in N_Parameter_Association nodes. True if the parameter is\n    --    an extra actual that carries the accessibility level of the actual\n    --    for an access parameter, in a function that dispatches on result and"}]}