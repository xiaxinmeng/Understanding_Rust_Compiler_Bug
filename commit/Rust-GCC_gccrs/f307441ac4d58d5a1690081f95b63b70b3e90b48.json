{"sha": "f307441ac4d58d5a1690081f95b63b70b3e90b48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwNzQ0MWFjNGQ1OGQ1YTE2OTAwODFmOTViNjNiNzBiM2U5MGI0OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:01:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:01:59Z"}, "message": "Add support for SVE scatter stores\n\nThis is mostly a mechanical extension of the previous gather load\nsupport to scatter stores.  The internal functions in this case are:\n\n  IFN_SCATTER_STORE (base, offsets, scale, values)\n  IFN_MASK_SCATTER_STORE (base, offsets, scale, values, mask)\n\nHowever, one nonobvious change is to vect_analyze_data_ref_access.\nIf we're treating an access as a gather load or scatter store\n(i.e. if STMT_VINFO_GATHER_SCATTER_P is true), the existing code\nwould create a dummy data_reference whose step is 0.  There's not\nreally much else it could do, since the whole point is that the\nstep isn't predictable from iteration to iteration.  We then\nwent into this code in vect_analyze_data_ref_access:\n\n  /* Allow loads with zero step in inner-loop vectorization.  */\n  if (loop_vinfo && integer_zerop (step))\n    {\n      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n      if (!nested_in_vect_loop_p (loop, stmt))\n\treturn DR_IS_READ (dr);\n\nI.e. we'd take the step literally and assume that this is a load\nor store to an invariant address.  Loads from invariant addresses\nare supported but stores to them aren't.\n\nThe code therefore had the effect of disabling all scatter stores.\nAFAICT this is true of AVX too: although tests like avx512f-scatter-1.c\ntest for the correctness of a scatter-like loop, they don't seem to\ncheck whether a scatter instruction is actually used.\n\nThe patch therefore makes vect_analyze_data_ref_access return true\nfor scatters.  We do seem to handle the aliasing correctly;\nthat's tested by other functions, and is symmetrical to the\nalready-working gather case.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (vect_scatter_store): Document.\n\t* optabs.def (scatter_store_optab, mask_scatter_store_optab): New\n\toptabs.\n\t* doc/md.texi (scatter_store@var{m}, mask_scatter_store@var{m}):\n\tDocument.\n\t* genopinit.c (main): Add supports_vec_scatter_store and\n\tsupports_vec_scatter_store_cached to target_optabs.\n\t* gimple.h (gimple_expr_type): Handle IFN_SCATTER_STORE and\n\tIFN_MASK_SCATTER_STORE.\n\t* internal-fn.def (SCATTER_STORE, MASK_SCATTER_STORE): New internal\n\tfunctions.\n\t* internal-fn.h (internal_store_fn_p): Declare.\n\t(internal_fn_stored_value_index): Likewise.\n\t* internal-fn.c (scatter_store_direct): New macro.\n\t(expand_scatter_store_optab_fn): New function.\n\t(direct_scatter_store_optab_supported_p): New macro.\n\t(internal_store_fn_p): New function.\n\t(internal_gather_scatter_fn_p): Handle IFN_SCATTER_STORE and\n\tIFN_MASK_SCATTER_STORE.\n\t(internal_fn_mask_index): Likewise.\n\t(internal_fn_stored_value_index): New function.\n\t(internal_gather_scatter_fn_supported_p): Adjust operand numbers\n\tfor scatter stores.\n\t* optabs-query.h (supports_vec_scatter_store_p): Declare.\n\t* optabs-query.c (supports_vec_scatter_store_p): New function.\n\t* tree-vectorizer.h (vect_get_store_rhs): Declare.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_access): Return\n\ttrue for scatter stores.\n\t(vect_gather_scatter_fn_p): Handle scatter stores too.\n\t(vect_check_gather_scatter): Consider using scatter stores if\n\tsupports_vec_scatter_store_p.\n\t* tree-vect-patterns.c (vect_try_gather_scatter_pattern): Handle\n\tscatter stores too.\n\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p): Use\n\tinternal_fn_stored_value_index.\n\t(check_load_store_masking): Handle scatter stores too.\n\t(vect_get_store_rhs): Make public.\n\t(vectorizable_call): Use internal_store_fn_p.\n\t(vectorizable_store): Handle scatter store internal functions.\n\t(vect_transform_stmt): Compare GROUP_STORE_COUNT with GROUP_SIZE\n\twhen deciding whether the end of the group has been reached.\n\t* config/aarch64/aarch64.md (UNSPEC_ST1_SCATTER): New unspec.\n\t* config/aarch64/aarch64-sve.md (scatter_store<mode>): New expander.\n\t(mask_scatter_store<mode>): New insns.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_scatter_store):\n\tNew proc.\n\t* gcc.dg/vect/pr25413a.c: Expect both loops to be optimized on\n\ttargets with scatter stores.\n\t* gcc.dg/vect/vect-71.c: Restrict XFAIL to targets without scatter\n\tstores.\n\t* gcc.target/aarch64/sve/mask_scatter_store_1.c: New test.\n\t* gcc.target/aarch64/sve/mask_scatter_store_2.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_1.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_2.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_3.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_4.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_5.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_6.c: Likewise.\n\t* gcc.target/aarch64/sve/scatter_store_7.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_1.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_2.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_3.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_4.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_5.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_6.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_store_7.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256643", "tree": {"sha": "9ca0c22b0248297a39205d4c22b9d5d778dd4f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ca0c22b0248297a39205d4c22b9d5d778dd4f4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f307441ac4d58d5a1690081f95b63b70b3e90b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f307441ac4d58d5a1690081f95b63b70b3e90b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f307441ac4d58d5a1690081f95b63b70b3e90b48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f307441ac4d58d5a1690081f95b63b70b3e90b48/comments", "author": null, "committer": null, "parents": [{"sha": "429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ef523f74bb85c20ba60b0f83ab7e73f82d74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429ef523f74bb85c20ba60b0f83ab7e73f82d74d"}], "stats": {"total": 891, "additions": 842, "deletions": 49}, "files": [{"sha": "2c6f9eb85d0ec75b74e61cb2bf76f01dcb68f0ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -1,3 +1,52 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/sourcebuild.texi (vect_scatter_store): Document.\n+\t* optabs.def (scatter_store_optab, mask_scatter_store_optab): New\n+\toptabs.\n+\t* doc/md.texi (scatter_store@var{m}, mask_scatter_store@var{m}):\n+\tDocument.\n+\t* genopinit.c (main): Add supports_vec_scatter_store and\n+\tsupports_vec_scatter_store_cached to target_optabs.\n+\t* gimple.h (gimple_expr_type): Handle IFN_SCATTER_STORE and\n+\tIFN_MASK_SCATTER_STORE.\n+\t* internal-fn.def (SCATTER_STORE, MASK_SCATTER_STORE): New internal\n+\tfunctions.\n+\t* internal-fn.h (internal_store_fn_p): Declare.\n+\t(internal_fn_stored_value_index): Likewise.\n+\t* internal-fn.c (scatter_store_direct): New macro.\n+\t(expand_scatter_store_optab_fn): New function.\n+\t(direct_scatter_store_optab_supported_p): New macro.\n+\t(internal_store_fn_p): New function.\n+\t(internal_gather_scatter_fn_p): Handle IFN_SCATTER_STORE and\n+\tIFN_MASK_SCATTER_STORE.\n+\t(internal_fn_mask_index): Likewise.\n+\t(internal_fn_stored_value_index): New function.\n+\t(internal_gather_scatter_fn_supported_p): Adjust operand numbers\n+\tfor scatter stores.\n+\t* optabs-query.h (supports_vec_scatter_store_p): Declare.\n+\t* optabs-query.c (supports_vec_scatter_store_p): New function.\n+\t* tree-vectorizer.h (vect_get_store_rhs): Declare.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_access): Return\n+\ttrue for scatter stores.\n+\t(vect_gather_scatter_fn_p): Handle scatter stores too.\n+\t(vect_check_gather_scatter): Consider using scatter stores if\n+\tsupports_vec_scatter_store_p.\n+\t* tree-vect-patterns.c (vect_try_gather_scatter_pattern): Handle\n+\tscatter stores too.\n+\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p): Use\n+\tinternal_fn_stored_value_index.\n+\t(check_load_store_masking): Handle scatter stores too.\n+\t(vect_get_store_rhs): Make public.\n+\t(vectorizable_call): Use internal_store_fn_p.\n+\t(vectorizable_store): Handle scatter store internal functions.\n+\t(vect_transform_stmt): Compare GROUP_STORE_COUNT with GROUP_SIZE\n+\twhen deciding whether the end of the group has been reached.\n+\t* config/aarch64/aarch64.md (UNSPEC_ST1_SCATTER): New unspec.\n+\t* config/aarch64/aarch64-sve.md (scatter_store<mode>): New expander.\n+\t(mask_scatter_store<mode>): New insns.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8da10c158a707ad620ab239ea0bd96f1dfdcbc02", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -246,6 +246,63 @@\n    ld1d\\t%0.d, %5/z, [%1, %2.d, lsl %p4]\"\n )\n \n+;; Unpredicated scatter store.\n+(define_expand \"scatter_store<mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(match_dup 5)\n+\t   (match_operand:DI 0 \"aarch64_reg_or_zero\")\n+\t   (match_operand:<V_INT_EQUIV> 1 \"register_operand\")\n+\t   (match_operand:DI 2 \"const_int_operand\")\n+\t   (match_operand:DI 3 \"aarch64_gather_scale_operand_<Vesize>\")\n+\t   (match_operand:SVE_SD 4 \"register_operand\")]\n+\t  UNSPEC_ST1_SCATTER))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[5] = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n+  }\n+)\n+\n+;; Predicated scatter stores for 32-bit elements.  Operand 2 is true for\n+;; unsigned extension and false for signed extension.\n+(define_insn \"mask_scatter_store<mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(match_operand:<VPRED> 5 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n+\t   (match_operand:DI 0 \"aarch64_reg_or_zero\" \"Z, rk, rk, rk, rk\")\n+\t   (match_operand:<V_INT_EQUIV> 1 \"register_operand\" \"w, w, w, w, w\")\n+\t   (match_operand:DI 2 \"const_int_operand\" \"i, Z, Ui1, Z, Ui1\")\n+\t   (match_operand:DI 3 \"aarch64_gather_scale_operand_w\" \"Ui1, Ui1, Ui1, i, i\")\n+\t   (match_operand:SVE_S 4 \"register_operand\" \"w, w, w, w, w\")]\n+\t  UNSPEC_ST1_SCATTER))]\n+  \"TARGET_SVE\"\n+  \"@\n+   st1w\\t%4.s, %5, [%1.s]\n+   st1w\\t%4.s, %5, [%0, %1.s, sxtw]\n+   st1w\\t%4.s, %5, [%0, %1.s, uxtw]\n+   st1w\\t%4.s, %5, [%0, %1.s, sxtw %p3]\n+   st1w\\t%4.s, %5, [%0, %1.s, uxtw %p3]\"\n+)\n+\n+;; Predicated scatter stores for 64-bit elements.  The value of operand 2\n+;; doesn't matter in this case.\n+(define_insn \"mask_scatter_store<mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(match_operand:<VPRED> 5 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (match_operand:DI 0 \"aarch64_reg_or_zero\" \"Z, rk, rk\")\n+\t   (match_operand:<V_INT_EQUIV> 1 \"register_operand\" \"w, w, w\")\n+\t   (match_operand:DI 2 \"const_int_operand\")\n+\t   (match_operand:DI 3 \"aarch64_gather_scale_operand_d\" \"Ui1, Ui1, i\")\n+\t   (match_operand:SVE_D 4 \"register_operand\" \"w, w, w\")]\n+\t  UNSPEC_ST1_SCATTER))]\n+  \"TARGET_SVE\"\n+  \"@\n+   st1d\\t%4.d, %5, [%1.d]\n+   st1d\\t%4.d, %5, [%0, %1.d]\n+   st1d\\t%4.d, %5, [%0, %1.d, lsl %p3]\"\n+)\n+\n ;; SVE structure moves.\n (define_expand \"mov<mode>\"\n   [(set (match_operand:SVE_STRUCT 0 \"nonimmediate_operand\")"}, {"sha": "edb6a7583338a924020d9f301aebc577f1fce63b", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -153,6 +153,7 @@\n     UNSPEC_ST1_SVE\n     UNSPEC_LD1RQ\n     UNSPEC_LD1_GATHER\n+    UNSPEC_ST1_SCATTER\n     UNSPEC_MERGE_PTRUE\n     UNSPEC_PTEST_PTRUE\n     UNSPEC_UNPACKSHI"}, {"sha": "f5167a1615533a6a91f942d7488da9a84c0e474c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -4937,6 +4937,35 @@ operand 5.  Bit @var{i} of the mask is set if element @var{i}\n of the result should be loaded from memory and clear if element @var{i}\n of the result should be set to zero.\n \n+@cindex @code{scatter_store@var{m}} instruction pattern\n+@item @samp{scatter_store@var{m}}\n+Store a vector of mode @var{m} into several distinct memory locations.\n+Operand 0 is a scalar base address and operand 1 is a vector of offsets\n+from that base.  Operand 4 is the vector of values that should be stored,\n+which has the same number of elements as the offset.  For each element\n+index @var{i}:\n+\n+@itemize @bullet\n+@item\n+extend the offset element @var{i} to address width, using zero\n+extension if operand 2 is 1 and sign extension if operand 2 is zero;\n+@item\n+multiply the extended offset by operand 3;\n+@item\n+add the result to the base; and\n+@item\n+store element @var{i} of operand 4 to that address.\n+@end itemize\n+\n+The value of operand 2 does not matter if the offsets are already\n+address width.\n+\n+@cindex @code{mask_scatter_store@var{m}} instruction pattern\n+@item @samp{mask_scatter_store@var{m}}\n+Like @samp{scatter_store@var{m}}, but takes an extra mask operand as\n+operand 5.  Bit @var{i} of the mask is set if element @var{i}\n+of the result should be stored to memory.\n+\n @cindex @code{vec_set@var{m}} instruction pattern\n @item @samp{vec_set@var{m}}\n Set given field in the vector value.  Operand 0 is the vector to modify,"}, {"sha": "f0233c9cca4ca32248db407bf00fb4c97eb740b1", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -1421,6 +1421,9 @@ so that vector loops can handle partial as well as full vectors.\n @item vect_masked_store\n Target supports vector masked stores.\n \n+@item vect_scatter_store\n+Target supports vector scatter stores.\n+\n @item vect_aligned_arrays\n Target aligns arrays to vector alignment boundary.\n "}, {"sha": "65a38d214bbc24095be2a6ccb97ca543f7231019", "filename": "gcc/genopinit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -239,6 +239,8 @@ main (int argc, const char **argv)\n \t   \"     mode.  */\\n\"\n \t   \"  bool supports_vec_gather_load;\\n\"\n \t   \"  bool supports_vec_gather_load_cached;\\n\"\n+\t   \"  bool supports_vec_scatter_store;\\n\"\n+\t   \"  bool supports_vec_scatter_store_cached;\\n\"\n \t   \"};\\n\"\n \t   \"extern void init_all_optabs (struct target_optabs *);\\n\"\n \t   \"\\n\""}, {"sha": "74605864a71a6e679128f2facebaa43ec5689aa1", "filename": "gcc/gimple.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -6355,11 +6355,18 @@ gimple_expr_type (const gimple *stmt)\n   if (code == GIMPLE_CALL)\n     {\n       const gcall *call_stmt = as_a <const gcall *> (stmt);\n-      if (gimple_call_internal_p (call_stmt)\n-          && gimple_call_internal_fn (call_stmt) == IFN_MASK_STORE)\n-        return TREE_TYPE (gimple_call_arg (call_stmt, 3));\n-      else\n-        return gimple_call_return_type (call_stmt);\n+      if (gimple_call_internal_p (call_stmt))\n+\tswitch (gimple_call_internal_fn (call_stmt))\n+\t  {\n+\t  case IFN_MASK_STORE:\n+\t  case IFN_SCATTER_STORE:\n+\t    return TREE_TYPE (gimple_call_arg (call_stmt, 3));\n+\t  case IFN_MASK_SCATTER_STORE:\n+\t    return TREE_TYPE (gimple_call_arg (call_stmt, 4));\n+\t  default:\n+\t    break;\n+\t  }\n+      return gimple_call_return_type (call_stmt);\n     }\n   else if (code == GIMPLE_ASSIGN)\n     {"}, {"sha": "88adaea4c862572b913b1e3db32571e61cf78027", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -87,6 +87,7 @@ init_internal_fns ()\n #define mask_store_direct { 3, 2, false }\n #define store_lanes_direct { 0, 0, false }\n #define mask_store_lanes_direct { 0, 0, false }\n+#define scatter_store_direct { 3, 3, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n #define cond_unary_direct { 1, 1, true }\n@@ -2730,6 +2731,42 @@ expand_LAUNDER (internal_fn, gcall *call)\n   expand_assignment (lhs, gimple_call_arg (call, 0), false);\n }\n \n+/* Expand {MASK_,}SCATTER_STORE{S,U} call CALL using optab OPTAB.  */\n+\n+static void\n+expand_scatter_store_optab_fn (internal_fn, gcall *stmt, direct_optab optab)\n+{\n+  internal_fn ifn = gimple_call_internal_fn (stmt);\n+  int rhs_index = internal_fn_stored_value_index (ifn);\n+  int mask_index = internal_fn_mask_index (ifn);\n+  tree base = gimple_call_arg (stmt, 0);\n+  tree offset = gimple_call_arg (stmt, 1);\n+  tree scale = gimple_call_arg (stmt, 2);\n+  tree rhs = gimple_call_arg (stmt, rhs_index);\n+\n+  rtx base_rtx = expand_normal (base);\n+  rtx offset_rtx = expand_normal (offset);\n+  HOST_WIDE_INT scale_int = tree_to_shwi (scale);\n+  rtx rhs_rtx = expand_normal (rhs);\n+\n+  struct expand_operand ops[6];\n+  int i = 0;\n+  create_address_operand (&ops[i++], base_rtx);\n+  create_input_operand (&ops[i++], offset_rtx, TYPE_MODE (TREE_TYPE (offset)));\n+  create_integer_operand (&ops[i++], TYPE_UNSIGNED (TREE_TYPE (offset)));\n+  create_integer_operand (&ops[i++], scale_int);\n+  create_input_operand (&ops[i++], rhs_rtx, TYPE_MODE (TREE_TYPE (rhs)));\n+  if (mask_index >= 0)\n+    {\n+      tree mask = gimple_call_arg (stmt, mask_index);\n+      rtx mask_rtx = expand_normal (mask);\n+      create_input_operand (&ops[i++], mask_rtx, TYPE_MODE (TREE_TYPE (mask)));\n+    }\n+\n+  insn_code icode = direct_optab_handler (optab, TYPE_MODE (TREE_TYPE (rhs)));\n+  expand_insn (icode, i, ops);\n+}\n+\n /* Expand {MASK_,}GATHER_LOAD call CALL using optab OPTAB.  */\n \n static void\n@@ -3016,6 +3053,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_scatter_store_optab_supported_p direct_optab_supported_p\n #define direct_while_optab_supported_p convert_optab_supported_p\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p\n #define direct_fold_left_optab_supported_p direct_optab_supported_p\n@@ -3202,6 +3240,25 @@ internal_load_fn_p (internal_fn fn)\n     }\n }\n \n+/* Return true if IFN is some form of store to memory.  */\n+\n+bool\n+internal_store_fn_p (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_MASK_STORE:\n+    case IFN_STORE_LANES:\n+    case IFN_MASK_STORE_LANES:\n+    case IFN_SCATTER_STORE:\n+    case IFN_MASK_SCATTER_STORE:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Return true if IFN is some form of gather load or scatter store.  */\n \n bool\n@@ -3211,6 +3268,8 @@ internal_gather_scatter_fn_p (internal_fn fn)\n     {\n     case IFN_GATHER_LOAD:\n     case IFN_MASK_GATHER_LOAD:\n+    case IFN_SCATTER_STORE:\n+    case IFN_MASK_SCATTER_STORE:\n       return true;\n \n     default:\n@@ -3235,6 +3294,27 @@ internal_fn_mask_index (internal_fn fn)\n     case IFN_MASK_GATHER_LOAD:\n       return 3;\n \n+    case IFN_MASK_SCATTER_STORE:\n+      return 4;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+\n+/* If FN takes a value that should be stored to memory, return the index\n+   of that argument, otherwise return -1.  */\n+\n+int\n+internal_fn_stored_value_index (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_MASK_STORE:\n+    case IFN_SCATTER_STORE:\n+    case IFN_MASK_SCATTER_STORE:\n+      return 3;\n+\n     default:\n       return -1;\n     }\n@@ -3259,9 +3339,12 @@ internal_gather_scatter_fn_supported_p (internal_fn ifn, tree vector_type,\n     return false;\n   optab optab = direct_internal_fn_optab (ifn);\n   insn_code icode = direct_optab_handler (optab, TYPE_MODE (vector_type));\n+  int output_ops = internal_load_fn_p (ifn) ? 1 : 0;\n   return (icode != CODE_FOR_nothing\n-\t  && insn_operand_matches (icode, 3, GEN_INT (offset_sign == UNSIGNED))\n-\t  && insn_operand_matches (icode, 4, GEN_INT (scale)));\n+\t  && insn_operand_matches (icode, 2 + output_ops,\n+\t\t\t\t   GEN_INT (offset_sign == UNSIGNED))\n+\t  && insn_operand_matches (icode, 3 + output_ops,\n+\t\t\t\t   GEN_INT (scale)));\n }\n \n /* Expand STMT as though it were a call to internal function FN.  */"}, {"sha": "5970d0e472cf685b71ec748a17c37940f4d11927", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n    - mask_store: currently just maskstore\n    - store_lanes: currently just vec_store_lanes\n    - mask_store_lanes: currently just vec_mask_store_lanes\n+   - scatter_store: used for {mask_,}scatter_store\n \n    - unary: a normal unary optab, such as vec_reverse_<mode>\n    - binary: a normal binary optab, such as vec_interleave_lo_<mode>\n@@ -123,6 +124,10 @@ DEF_INTERNAL_OPTAB_FN (GATHER_LOAD, ECF_PURE, gather_load, gather_load)\n DEF_INTERNAL_OPTAB_FN (MASK_GATHER_LOAD, ECF_PURE,\n \t\t       mask_gather_load, gather_load)\n \n+DEF_INTERNAL_OPTAB_FN (SCATTER_STORE, 0, scatter_store, scatter_store)\n+DEF_INTERNAL_OPTAB_FN (MASK_SCATTER_STORE, 0,\n+\t\t       mask_scatter_store, scatter_store)\n+\n DEF_INTERNAL_OPTAB_FN (MASK_STORE, 0, maskstore, mask_store)\n DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,"}, {"sha": "67102fdad76d7301cc959c0043b712f01d524219", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -193,8 +193,10 @@ extern bool set_edom_supported_p (void);\n extern internal_fn get_conditional_internal_fn (tree_code);\n \n extern bool internal_load_fn_p (internal_fn);\n+extern bool internal_store_fn_p (internal_fn);\n extern bool internal_gather_scatter_fn_p (internal_fn);\n extern int internal_fn_mask_index (internal_fn);\n+extern int internal_fn_stored_value_index (internal_fn);\n extern bool internal_gather_scatter_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t\t    tree, signop, int);\n "}, {"sha": "a8e10e6deccb85c08c032b0f88115341bc638e35", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -711,3 +711,21 @@ supports_vec_gather_load_p ()\n \n   return this_fn_optabs->supports_vec_gather_load;\n }\n+\n+/* Return true if vec_scatter_store is available for at least one vector\n+   mode.  */\n+\n+bool\n+supports_vec_scatter_store_p ()\n+{\n+  if (this_fn_optabs->supports_vec_scatter_store_cached)\n+    return this_fn_optabs->supports_vec_scatter_store;\n+\n+  this_fn_optabs->supports_vec_scatter_store_cached = true;\n+\n+  this_fn_optabs->supports_vec_scatter_store\n+    = supports_at_least_one_mode_p (scatter_store_optab);\n+\n+  return this_fn_optabs->supports_vec_scatter_store;\n+}\n+"}, {"sha": "a2574bb75faf23a852d2074e7ea5a30c528e4ff2", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -192,6 +192,7 @@ bool can_atomic_exchange_p (machine_mode, bool);\n bool can_atomic_load_p (machine_mode);\n bool lshift_cheap_p (bool);\n bool supports_vec_gather_load_p ();\n+bool supports_vec_scatter_store_p ();\n \n /* Version of find_widening_optab_handler_and_mode that operates on\n    specific mode types.  */"}, {"sha": "2c30f0eb39668f9e4c678305f754f3d1a3954bca", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -386,6 +386,8 @@ OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")\n \n OPTAB_D (gather_load_optab, \"gather_load$a\")\n OPTAB_D (mask_gather_load_optab, \"mask_gather_load$a\")\n+OPTAB_D (scatter_store_optab, \"scatter_store$a\")\n+OPTAB_D (mask_scatter_store_optab, \"mask_scatter_store$a\")\n \n OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)\n OPTAB_DC (vec_series_optab, \"vec_series$a\", VEC_SERIES)"}, {"sha": "995503780e04ee73188a6d27a3a80511d62a49ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -1,3 +1,30 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_scatter_store):\n+\tNew proc.\n+\t* gcc.dg/vect/pr25413a.c: Expect both loops to be optimized on\n+\ttargets with scatter stores.\n+\t* gcc.dg/vect/vect-71.c: Restrict XFAIL to targets without scatter\n+\tstores.\n+\t* gcc.target/aarch64/sve/mask_scatter_store_1.c: New test.\n+\t* gcc.target/aarch64/sve/mask_scatter_store_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/scatter_store_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_store_7.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e444b2c3e8ee24c4374453c95fb4e892323a3897", "filename": "gcc/testsuite/gcc.dg/vect/pr25413a.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -123,6 +123,7 @@ int main (void)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! vect_scatter_store } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_scatter_store } } } */\n /* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable  } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */"}, {"sha": "f15521176df55bef45fde880221bdfcd7aa17dbc", "filename": "gcc/testsuite/gcc.dg/vect/vect-71.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-71.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -36,4 +36,4 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { ! vect_scatter_store } } } } */"}, {"sha": "c799943425695070399f5ae5da4397609bc4eac3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_scatter_store_1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_1.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE, BITS)\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE\t\t\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\t\t\\\n+     CMP_TYPE *restrict cmp1, CMP_TYPE *restrict cmp2, \t\t\t\\\n+     INDEX##BITS *restrict indices, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[indices[i]] = src[i] + 1;\t\t\t\t\t\\\n+  }\n+\n+#define TEST32(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int32_t, 32)\t\t\\\n+  T (DATA_TYPE, uint32_t, 32)\t\t\\\n+  T (DATA_TYPE, float, 32)\n+\n+#define TEST64(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int64_t, 64)\t\t\\\n+  T (DATA_TYPE, uint64_t, 64)\t\t\\\n+  T (DATA_TYPE, double, 64)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST32 (T, int32_t)\t\t\t\\\n+  TEST32 (T, uint32_t)\t\t\t\\\n+  TEST32 (T, float)\t\t\t\\\n+  TEST64 (T, int64_t)\t\t\t\\\n+  TEST64 (T, uint64_t)\t\t\t\\\n+  TEST64 (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+\\.s, sxtw 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+\\.d, lsl 3\\]\\n} 9 } } */"}, {"sha": "ba8e67131c8e886e624b98ac4185952ea9d44e60", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_scatter_store_2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_scatter_store_2.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"mask_scatter_store_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+\\.s, uxtw 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+\\.d, lsl 3\\]\\n} 9 } } */"}, {"sha": "65be5e63a95c54233d71c6e3408d49cd8fcd767e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_1.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[indices[i]] = src[i] + 1;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 32)\t\t\t\t\\\n+  T (uint32_t, 32)\t\t\t\t\\\n+  T (float, 32)\t\t\t\t\t\\\n+  T (int64_t, 64)\t\t\t\t\\\n+  T (uint64_t, 64)\t\t\t\t\\\n+  T (double, 64)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 3 } } */"}, {"sha": "5cb507c37a15030c6e0c3114fd660e58ba408f0d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_2.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"scatter_store_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, uxtw 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 3 } } */"}, {"sha": "faa85dfe8b1a6d519eb40d6897c7e4ff3d19b59f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_3.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      *(DATA_TYPE *) ((char *) dest + indices[i]) = src[i] + 1;\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 32)\t\t\t\t\\\n+  T (uint32_t, 32)\t\t\t\t\\\n+  T (float, 32)\t\t\t\t\t\\\n+  T (int64_t, 64)\t\t\t\t\\\n+  T (uint64_t, 64)\t\t\t\t\\\n+  T (double, 64)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "8dff57c43f3acbae76324efe663c3d44f6d88557", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_4.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"scatter_store_3.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "0962a72af8b58e7d96c9451ce61416a12d717a0c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_5.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE)\t\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict *dest, DATA_TYPE *restrict src,\t\\\n+\t\t int n)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      *dest[i] = src[i] + 1;\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "ee31562440f90114553d63c1a9d1432432c3fd39", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_6.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fwrapv --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX16 int16_t\n+#define INDEX32 int32_t\n+#endif\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, INDEX##BITS mask, int n)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[(INDEX##BITS) (indices[i] | mask)] = src[i] + 1;\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 16)\t\t\t\t\\\n+  T (uint32_t, 16)\t\t\t\t\\\n+  T (float, 16)\t\t\t\t\t\\\n+  T (int64_t, 32)\t\t\t\t\\\n+  T (uint64_t, 32)\t\t\t\t\\\n+  T (double, 32)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tsunpkhi\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpklo\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 6 } } */"}, {"sha": "784921e5d3c94c5d9e772d949c5713088e120d77", "filename": "gcc/testsuite/gcc.target/aarch64/sve/scatter_store_7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fscatter_store_7.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX16 uint16_t\n+#define INDEX32 uint32_t\n+\n+#include \"scatter_store_6.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* Either extension type is OK here.  */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, [us]xtw 2\\]\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 6 } } */"}, {"sha": "4cd55ce74bff22a1198c0de56877c700c7623997", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_1.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX8\n+#define INDEX8 int8_t\n+#define INDEX16 int16_t\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##BITS (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src,\t\t\\\n+\t\t\t  INDEX##BITS stride, INDEX##BITS n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (INDEX##BITS i = 0; i < n; ++i)\t\t\t\t\\\n+      dest[i * stride] = src[i] + 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 8)\t\t\t\t\\\n+  T (DATA_TYPE, 16)\t\t\t\t\\\n+  T (DATA_TYPE, 32)\t\t\t\t\\\n+  T (DATA_TYPE, 64)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 12 } } */"}, {"sha": "f0ea58e38e23058ca95ba5da748f817aa6c43c44", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_2.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX8 uint8_t\n+#define INDEX16 uint16_t\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"strided_store_1.c\"\n+\n+/* 8 and 16 bits are signed because the multiplication promotes to int.\n+   Using uxtw for all 9 would be OK.  */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 6 } } */\n+/* The 32-bit loop needs to honor the defined overflow in uint32_t,\n+   so we vectorize the offset calculation.  This means that the\n+   64-bit version needs two copies.  */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, uxtw 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 15 } } */"}, {"sha": "68835af5fe8b8834d7004aa56aa871ba56a74303", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_3.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, OTHER_TYPE)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE##_##BITS (DATA_TYPE *restrict dest,\t\t\t\\\n+\t\t\t  DATA_TYPE *restrict src,\t\t\t\\\n+\t\t\t  OTHER_TYPE *restrict other,\t\t\t\\\n+\t\t\t  OTHER_TYPE mask,\t\t\t\t\\\n+\t\t\t  int stride, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[i * stride] = src[i] + (OTHER_TYPE) (other[i] | mask);\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, int16_t)\t\t\t\t\\\n+  T (uint32_t, int16_t)\t\t\t\t\\\n+  T (float, int16_t)\t\t\t\t\\\n+  T (int64_t, int32_t)\t\t\t\t\\\n+  T (uint64_t, int32_t)\t\t\t\t\\\n+  T (double, int32_t)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 1\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 6 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 6 } } */"}, {"sha": "48d83a3e6c3cadc543aa298f744dea7881721ab5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_4.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      dest[i * SCALE] = src[i] + 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 15 } } */"}, {"sha": "ea7756edf2c77fc3dd7dac83a3c5d5ab68aa8d37", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_5.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_5.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256 --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src, long n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (long i = 0; i < n; ++i)\t\t\t\t\\\n+      dest[i * SCALE] = src[i] + 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "111d52584d943df14954f14ea918c19af87a66d0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_6.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_6.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable --save-temps\" } */\n+\n+#include \"strided_store_5.c\"\n+\n+/* { dg-final { scan-assembler-not {\\[x[0-9]+, z[0-9]+\\.s} } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "9f7ce83270dc904fba103fc2218e31079ef62409", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_store_7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_store_7.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, NAME, SCALE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  f_##DATA_TYPE##_##NAME (DATA_TYPE *restrict dest,\t\t\\\n+\t\t\t  DATA_TYPE *restrict src)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (long i = 0; i < 1000; ++i)\t\t\t\t\\\n+      dest[i * SCALE] = src[i] + 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, 5, 5)\t\t\t\t\\\n+  T (DATA_TYPE, 7, 7)\t\t\t\t\\\n+  T (DATA_TYPE, 11, 11)\t\t\t\t\\\n+  T (DATA_TYPE, 200, 200)\t\t\t\\\n+  T (DATA_TYPE, m100, -100)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, int32_t)\t\t\t\\\n+  TEST_TYPE (T, uint32_t)\t\t\t\\\n+  TEST_TYPE (T, float)\t\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, z[0-9]+.d\\]\\n} 15 } } */"}, {"sha": "98a5eb75cbe42fbedde1c64b629c5498b971b5f8", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -6600,6 +6600,12 @@ proc check_effective_target_vect_masked_store { } {\n     return [check_effective_target_aarch64_sve]\n }\n \n+# Return 1 if the target supports vector scatter stores.\n+\n+proc check_effective_target_vect_scatter_store { } {\n+    return [check_effective_target_aarch64_sve]\n+}\n+\n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n \n proc check_effective_target_vect_condition { } {"}, {"sha": "c6bfe453fd84091a177baac248fd728b80304903", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -2648,6 +2648,9 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    return true;\n+\n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n@@ -3336,7 +3339,7 @@ vect_gather_scatter_fn_p (bool read_p, bool masked_p, tree vectype,\n   if (read_p)\n     ifn = masked_p ? IFN_MASK_GATHER_LOAD : IFN_GATHER_LOAD;\n   else\n-    return false;\n+    ifn = masked_p ? IFN_MASK_SCATTER_STORE : IFN_SCATTER_STORE;\n \n   /* Test whether the target supports this combination.  */\n   if (!internal_gather_scatter_fn_supported_p (ifn, vectype, memory_type,\n@@ -3408,7 +3411,8 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n   /* True if we should aim to use internal functions rather than\n      built-in functions.  */\n   bool use_ifn_p = (DR_IS_READ (dr)\n-\t\t    && supports_vec_gather_load_p ());\n+\t\t    ? supports_vec_gather_load_p ()\n+\t\t    : supports_vec_scatter_store_p ());\n \n   base = DR_REF (dr);\n   /* For masked loads/stores, DR_REF (dr) is an artificial MEM_REF,\n@@ -3727,7 +3731,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  bool maybe_scatter\n \t    = DR_IS_WRITE (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n-\t      && targetm.vectorize.builtin_scatter != NULL;\n+\t      && (targetm.vectorize.builtin_scatter != NULL\n+\t\t  || supports_vec_scatter_store_p ());\n \t  bool maybe_simd_lane_access\n \t    = is_a <loop_vec_info> (vinfo) && loop->simduid;\n "}, {"sha": "0831b7e6978b4655df84b62aed55e23ce174cf03", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -4235,10 +4235,6 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n   if (!dr || !STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     return NULL;\n \n-  /* Reject stores for now.  */\n-  if (!DR_IS_READ (dr))\n-    return NULL;\n-\n   /* Get the boolean that controls whether the load or store happens.\n      This is null if the operation is unconditional.  */\n   tree mask = vect_get_load_store_mask (stmt);\n@@ -4278,8 +4274,16 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n       gimple_call_set_lhs (pattern_stmt, load_lhs);\n     }\n   else\n-    /* Not yet supported.  */\n-    gcc_unreachable ();\n+    {\n+      tree rhs = vect_get_store_rhs (stmt);\n+      if (mask != NULL)\n+\tpattern_stmt = gimple_build_call_internal (IFN_MASK_SCATTER_STORE, 5,\n+\t\t\t\t\t\t   base, offset, scale, rhs,\n+\t\t\t\t\t\t   mask);\n+      else\n+\tpattern_stmt = gimple_build_call_internal (IFN_SCATTER_STORE, 4,\n+\t\t\t\t\t\t   base, offset, scale, rhs);\n+    }\n   gimple_call_set_nothrow (pattern_stmt, true);\n \n   /* Copy across relevant vectorization info and associate DR with the"}, {"sha": "0f74772fe7e16964c8c04a5b49b966dd0e3b5173", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 97, "deletions": 31, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -397,12 +397,13 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n \t  if (mask_index >= 0\n \t      && use == gimple_call_arg (stmt, mask_index))\n \t    return true;\n+\t  int stored_value_index = internal_fn_stored_value_index (ifn);\n+\t  if (stored_value_index >= 0\n+\t      && use == gimple_call_arg (stmt, stored_value_index))\n+\t    return true;\n \t  if (internal_gather_scatter_fn_p (ifn)\n \t      && use == gimple_call_arg (stmt, 1))\n \t    return true;\n-\t  if (ifn == IFN_MASK_STORE\n-\t      && use == gimple_call_arg (stmt, 3))\n-\t    return true;\n \t}\n       return false;\n     }\n@@ -1765,10 +1766,11 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \n   if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n-      gcc_assert (is_load);\n+      internal_fn ifn = (is_load\n+\t\t\t ? IFN_MASK_GATHER_LOAD\n+\t\t\t : IFN_MASK_SCATTER_STORE);\n       tree offset_type = TREE_TYPE (gs_info->offset);\n-      if (!internal_gather_scatter_fn_supported_p (IFN_MASK_GATHER_LOAD,\n-\t\t\t\t\t\t   vectype,\n+      if (!internal_gather_scatter_fn_supported_p (ifn, vectype,\n \t\t\t\t\t\t   gs_info->memory_type,\n \t\t\t\t\t\t   TYPE_SIGN (offset_type),\n \t\t\t\t\t\t   gs_info->scale))\n@@ -1777,7 +1779,7 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"can't use a fully-masked loop because the\"\n \t\t\t     \" target doesn't have an appropriate masked\"\n-\t\t\t     \" gather load instruction.\\n\");\n+\t\t\t     \" gather load or scatter store instruction.\\n\");\n \t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n \t  return;\n \t}\n@@ -2021,7 +2023,7 @@ perm_mask_for_reverse (tree vectype)\n /* STMT is either a masked or unconditional store.  Return the value\n    being stored.  */\n \n-static tree\n+tree\n vect_get_store_rhs (gimple *stmt)\n {\n   if (gassign *assign = dyn_cast <gassign *> (stmt))\n@@ -2032,8 +2034,9 @@ vect_get_store_rhs (gimple *stmt)\n   if (gcall *call = dyn_cast <gcall *> (stmt))\n     {\n       internal_fn ifn = gimple_call_internal_fn (call);\n-      gcc_assert (ifn == IFN_MASK_STORE);\n-      return gimple_call_arg (stmt, 3);\n+      int index = internal_fn_stored_value_index (ifn);\n+      gcc_assert (index >= 0);\n+      return gimple_call_arg (stmt, index);\n     }\n   gcc_unreachable ();\n }\n@@ -3023,7 +3026,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   if (gimple_call_internal_p (stmt)\n       && (internal_load_fn_p (gimple_call_internal_fn (stmt))\n-\t  || gimple_call_internal_fn (stmt) == IFN_MASK_STORE))\n+\t  || internal_store_fn_p (gimple_call_internal_fn (stmt))))\n     /* Handled by vectorizable_load and vectorizable_store.  */\n     return false;\n \n@@ -6109,7 +6112,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   else\n     {\n       gcall *call = dyn_cast <gcall *> (stmt);\n-      if (!call || !gimple_call_internal_p (call, IFN_MASK_STORE))\n+      if (!call || !gimple_call_internal_p (call))\n+\treturn false;\n+\n+      internal_fn ifn = gimple_call_internal_fn (call);\n+      if (!internal_store_fn_p (ifn))\n \treturn false;\n \n       if (slp_node != NULL)\n@@ -6120,10 +6127,13 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  return false;\n \t}\n \n-      ref_type = TREE_TYPE (gimple_call_arg (call, 1));\n-      mask = gimple_call_arg (call, 2);\n-      if (!vect_check_load_store_mask (stmt, mask, &mask_vectype))\n-\treturn false;\n+      int mask_index = internal_fn_mask_index (ifn);\n+      if (mask_index >= 0)\n+\t{\n+\t  mask = gimple_call_arg (call, mask_index);\n+\t  if (!vect_check_load_store_mask (stmt, mask, &mask_vectype))\n+\t    return false;\n+\t}\n     }\n \n   op = vect_get_store_rhs (stmt);\n@@ -6185,7 +6195,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t     TYPE_MODE (mask_vectype), false))\n \t    return false;\n \t}\n-      else if (memory_access_type != VMAT_LOAD_STORE_LANES)\n+      else if (memory_access_type != VMAT_LOAD_STORE_LANES\n+\t       && (memory_access_type != VMAT_GATHER_SCATTER || gs_info.decl))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6201,7 +6212,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \treturn false;\n     }\n \n-  grouped_store = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n+  grouped_store = (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+\t\t   && memory_access_type != VMAT_GATHER_SCATTER);\n   if (grouped_store)\n     {\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n@@ -6237,7 +6249,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   ensure_base_align (dr);\n \n-  if (memory_access_type == VMAT_GATHER_SCATTER)\n+  if (memory_access_type == VMAT_GATHER_SCATTER && gs_info.decl)\n     {\n       tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE, src;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n@@ -6387,10 +6399,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       return true;\n     }\n \n-  if (grouped_store)\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n-      GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n+      gimple *group_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      GROUP_STORE_COUNT (vinfo_for_stmt (group_stmt))++;\n+    }\n \n+  if (grouped_store)\n+    {\n       /* FORNOW */\n       gcc_assert (!loop || !nested_in_vect_loop_p (loop, stmt));\n \n@@ -6690,10 +6706,27 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       || memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n     offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n \n-  if (memory_access_type == VMAT_LOAD_STORE_LANES)\n-    aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n+  tree bump;\n+  tree vec_offset = NULL_TREE;\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    {\n+      aggr_type = NULL_TREE;\n+      bump = NULL_TREE;\n+    }\n+  else if (memory_access_type == VMAT_GATHER_SCATTER)\n+    {\n+      aggr_type = elem_type;\n+      vect_get_strided_load_store_ops (stmt, loop_vinfo, &gs_info,\n+\t\t\t\t       &bump, &vec_offset);\n+    }\n   else\n-    aggr_type = vectype;\n+    {\n+      if (memory_access_type == VMAT_LOAD_STORE_LANES)\n+\taggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n+      else\n+\taggr_type = vectype;\n+      bump = vect_get_data_ptr_increment (dr, aggr_type, memory_access_type);\n+    }\n \n   if (mask)\n     LOOP_VINFO_HAS_MASK_STORE (loop_vinfo) = true;\n@@ -6798,12 +6831,19 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      dataref_offset = build_int_cst (ref_type, 0);\n \t      inv_p = false;\n \t    }\n+\t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\t    {\n+\t      vect_get_gather_scatter_ops (loop, stmt, &gs_info,\n+\t\t\t\t\t   &dataref_ptr, &vec_offset);\n+\t      inv_p = false;\n+\t    }\n \t  else\n \t    dataref_ptr\n \t      = vect_create_data_ref_ptr (first_stmt, aggr_type,\n \t\t\t\t\t  simd_lane_access_p ? loop : NULL,\n \t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n-\t\t\t\t\t  simd_lane_access_p, &inv_p);\n+\t\t\t\t\t  simd_lane_access_p, &inv_p,\n+\t\t\t\t\t  NULL_TREE, bump);\n \t  gcc_assert (bb_vinfo || !inv_p);\n \t}\n       else\n@@ -6830,11 +6870,17 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  if (dataref_offset)\n \t    dataref_offset\n-\t      = int_const_binop (PLUS_EXPR, dataref_offset,\n-\t\t\t\t TYPE_SIZE_UNIT (aggr_type));\n+\t      = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n+\t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\t    {\n+\t      gimple *def_stmt;\n+\t      vect_def_type dt;\n+\t      vect_is_simple_use (vec_offset, loop_vinfo, &def_stmt, &dt);\n+\t      vec_offset = vect_get_vec_def_for_stmt_copy (dt, vec_offset);\n+\t    }\n \t  else\n \t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n-\t\t\t\t\t   TYPE_SIZE_UNIT (aggr_type));\n+\t\t\t\t\t   bump);\n \t}\n \n       if (memory_access_type == VMAT_LOAD_STORE_LANES)\n@@ -6906,10 +6952,28 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\tfinal_mask = prepare_load_store_mask (mask_vectype, final_mask,\n \t\t\t\t\t\t      vec_mask, gsi);\n \n+\t      if (memory_access_type == VMAT_GATHER_SCATTER)\n+\t\t{\n+\t\t  tree scale = size_int (gs_info.scale);\n+\t\t  gcall *call;\n+\t\t  if (masked_loop_p)\n+\t\t    call = gimple_build_call_internal\n+\t\t      (IFN_MASK_SCATTER_STORE, 5, dataref_ptr, vec_offset,\n+\t\t       scale, vec_oprnd, final_mask);\n+\t\t  else\n+\t\t    call = gimple_build_call_internal\n+\t\t      (IFN_SCATTER_STORE, 4, dataref_ptr, vec_offset,\n+\t\t       scale, vec_oprnd);\n+\t\t  gimple_call_set_nothrow (call, true);\n+\t\t  new_stmt = call;\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  break;\n+\t\t}\n+\n \t      if (i > 0)\n \t\t/* Bump the vector pointer.  */\n \t\tdataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n-\t\t\t\t\t       stmt, NULL_TREE);\n+\t\t\t\t\t       stmt, bump);\n \n \t      if (slp)\n \t\tvec_oprnd = vec_oprnds[i];\n@@ -9407,9 +9471,11 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \t     one are skipped, and there vec_stmt_info shouldn't be freed\n \t     meanwhile.  */\n \t  *grouped_store = true;\n-\t  if (STMT_VINFO_VEC_STMT (stmt_info))\n+\t  stmt_vec_info group_info\n+\t    = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n+\t  if (GROUP_STORE_COUNT (group_info) == GROUP_SIZE (group_info))\n \t    is_store = true;\n-\t  }\n+\t}\n       else\n \tis_store = true;\n       break;"}, {"sha": "d3dda52a041a87367a41b60987ddfe1dc37ba4ef", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f307441ac4d58d5a1690081f95b63b70b3e90b48/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f307441ac4d58d5a1690081f95b63b70b3e90b48", "patch": "@@ -1413,6 +1413,7 @@ extern void vect_finish_replace_stmt (gimple *, gimple *);\n extern void vect_finish_stmt_generation (gimple *, gimple *,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n+extern tree vect_get_store_rhs (gimple *);\n extern tree vect_get_vec_def_for_operand_1 (gimple *, enum vect_def_type);\n extern tree vect_get_vec_def_for_operand (tree, gimple *, tree = NULL);\n extern void vect_get_vec_defs (tree, tree, gimple *, vec<tree> *,"}]}