{"sha": "3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I4ZGQwNzE2ZmY3YzU0MTEzMzRjMWYwYWQ2MTMwNmVjOTdhYzZlOQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2007-05-31T19:52:24Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-05-31T19:52:24Z"}, "message": "config.gcc (i[34567]86-*-*): Add nmmintrin.h to extra_headers.\n\n2007-05-31  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config.gcc (i[34567]86-*-*): Add nmmintrin.h to\n\textra_headers.\n\t(x86_64-*-*): Likewise.\n\n\t* config/i386/i386.c (OPTION_MASK_ISA_MMX_UNSET): New.\n\t(OPTION_MASK_ISA_3DNOW_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE2_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE3_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSSE3_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE4_1_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE4_2_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE4): Likewise.\n\t(OPTION_MASK_ISA_SSE4_UNSET): Likewise.\n\t(OPTION_MASK_ISA_SSE4A_UNSET): Likewise.\n\t(ix86_handle_option): Use OPTION_MASK_ISA_*_UNSET.  Handle\n\tSSE4.2.\n\t(override_options): Support SSE4.2.\n\t(ix86_build_const_vector): Support SImode and DImode.\n\t(ix86_build_signbit_mask): Likewise.\n\t(ix86_expand_int_vcond): Support V2DImode.\n\t(IX86_BUILTIN_CRC32QI): New for SSE4.2.\n\t(IX86_BUILTIN_CRC32HI): Likewise.\n\t(IX86_BUILTIN_CRC32SI): Likewise.\n\t(IX86_BUILTIN_CRC32DI): Likewise.\n\t(IX86_BUILTIN_PCMPGTQ): Likewise.\n\t(bdesc_crc32): Likewise.\n\t(bdesc_sse_3arg): Likewise.\n\t(ix86_expand_crc32): Likewise.\n\t(ix86_init_mmx_sse_builtins): Support SSE4.2.\n\t(ix86_expand_builtin): Likewise.\n\n\t* config/i386/i386.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__SSE4_2__ for -msse4.2.\n\n\t* config/i386/i386.md (UNSPEC_CRC32): New for SSE4.2.\n\t(CRC32MODE): Likewise.\n\t(crc32modesuffix): Likewise.\n\t(crc32modeconstraint): Likewise.\n\t(sse4_2_crc32<mode>): Likewise.\n\t(sse4_2_crc32di): Likewise.\n\n\t* config/i386/i386.opt (msse4.2): New for SSE4.2.\n\t(msse4): Likewise.\n\n\t* config/i386/nmmintrin.h: New. The dummy SSE4.2 intrinsic header\n\tfile.\n\n\t* config/i386/smmintrin.h: Add SSE4.2 intrinsics.\n\n\t* config/i386/sse.md (sse4_2_gtv2di3): New pattern for\n\tSSE4.2.\n\t(vcond<mode>): Use SSEMODEI instead of SSEMODE124.\n\t(vcondu<mode>): Likewise.\n\n\t* doc/extend.texi: Document SSE4.2 built-in functions.\n\n\t* doc/invoke.texi: Document -msse4.2/-msse4.\n\nFrom-SVN: r125236", "tree": {"sha": "af5f8a80f0f784ca8b3ed00d982749ac5b74a6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af5f8a80f0f784ca8b3ed00d982749ac5b74a6e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccb4d26be0082d11486c820ca78699c9e1332d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb4d26be0082d11486c820ca78699c9e1332d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb4d26be0082d11486c820ca78699c9e1332d23"}], "stats": {"total": 769, "additions": 698, "deletions": 71}, "files": [{"sha": "839b9789dbd1b53837a0da1d063256ef4a8db139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -1,3 +1,64 @@\n+2007-05-31  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config.gcc (i[34567]86-*-*): Add nmmintrin.h to\n+\textra_headers.\n+\t(x86_64-*-*): Likewise.\n+\n+\t* config/i386/i386.c (OPTION_MASK_ISA_MMX_UNSET): New.\n+\t(OPTION_MASK_ISA_3DNOW_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE2_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE3_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSSE3_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE4_1_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE4_2_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE4): Likewise.\n+\t(OPTION_MASK_ISA_SSE4_UNSET): Likewise.\n+\t(OPTION_MASK_ISA_SSE4A_UNSET): Likewise.\n+\t(ix86_handle_option): Use OPTION_MASK_ISA_*_UNSET.  Handle\n+\tSSE4.2.\n+\t(override_options): Support SSE4.2.\n+\t(ix86_build_const_vector): Support SImode and DImode.\n+\t(ix86_build_signbit_mask): Likewise.\n+\t(ix86_expand_int_vcond): Support V2DImode.\n+\t(IX86_BUILTIN_CRC32QI): New for SSE4.2.\n+\t(IX86_BUILTIN_CRC32HI): Likewise.\n+\t(IX86_BUILTIN_CRC32SI): Likewise.\n+\t(IX86_BUILTIN_CRC32DI): Likewise.\n+\t(IX86_BUILTIN_PCMPGTQ): Likewise.\n+\t(bdesc_crc32): Likewise.\n+\t(bdesc_sse_3arg): Likewise.\n+\t(ix86_expand_crc32): Likewise.\n+\t(ix86_init_mmx_sse_builtins): Support SSE4.2.\n+\t(ix86_expand_builtin): Likewise.\n+\n+\t* config/i386/i386.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__SSE4_2__ for -msse4.2.\n+\n+\t* config/i386/i386.md (UNSPEC_CRC32): New for SSE4.2.\n+\t(CRC32MODE): Likewise.\n+\t(crc32modesuffix): Likewise.\n+\t(crc32modeconstraint): Likewise.\n+\t(sse4_2_crc32<mode>): Likewise.\n+\t(sse4_2_crc32di): Likewise.\n+\n+\t* config/i386/i386.opt (msse4.2): New for SSE4.2.\n+\t(msse4): Likewise.\n+\n+\t* config/i386/nmmintrin.h: New. The dummy SSE4.2 intrinsic header\n+\tfile.\n+\n+\t* config/i386/smmintrin.h: Add SSE4.2 intrinsics.\n+\n+\t* config/i386/sse.md (sse4_2_gtv2di3): New pattern for\n+\tSSE4.2.\n+\t(vcond<mode>): Use SSEMODEI instead of SSEMODE124.\n+\t(vcondu<mode>): Likewise.\n+\n+\t* doc/extend.texi: Document SSE4.2 built-in functions.\n+\n+\t* doc/invoke.texi: Document -msse4.2/-msse4.\n+\n 2007-05-31  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/32160"}, {"sha": "c4a47f9a5871abc260c509c12cc6ca49dd687d8d", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -276,12 +276,14 @@ xscale-*-*)\n i[34567]86-*-*)\n \tcpu_type=i386\n \textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n-\t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\"\n+\t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n+\t\t       nmmintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n \textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n-\t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\"\n+\t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n+\t\t       nmmintrin.h\"\n \tneed_64bit_hwint=yes\n \t;;\n ia64-*-*)"}, {"sha": "73261b0a7337366f3e1dc7392e78cc470ccce879", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 230, "deletions": 56, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -1551,6 +1551,33 @@ int ix86_isa_flags = TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_ISA_DEFAULT;\n    was set or cleared on the command line.  */\n static int ix86_isa_flags_explicit;\n \n+/* Define a set of ISAs which aren't available for a given ISA. MMX\n+   and SSE ISAs are handled separately.  */\n+\n+#define OPTION_MASK_ISA_MMX_UNSET \\\n+  (OPTION_MASK_ISA_3DNOW | OPTION_MASK_ISA_3DNOW_UNSET)\n+#define OPTION_MASK_ISA_3DNOW_UNSET OPTION_MASK_ISA_3DNOW_A\n+\n+#define OPTION_MASK_ISA_SSE_UNSET \\\n+  (OPTION_MASK_ISA_SSE2 | OPTION_MASK_ISA_SSE2_UNSET)\n+#define OPTION_MASK_ISA_SSE2_UNSET \\\n+  (OPTION_MASK_ISA_SSE3 | OPTION_MASK_ISA_SSE3_UNSET)\n+#define OPTION_MASK_ISA_SSE3_UNSET \\\n+  (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_SSSE3_UNSET)\n+#define OPTION_MASK_ISA_SSSE3_UNSET \\\n+  (OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4_1_UNSET)\n+#define OPTION_MASK_ISA_SSE4_1_UNSET \\\n+  (OPTION_MASK_ISA_SSE4_2 | OPTION_MASK_ISA_SSE4_2_UNSET)\n+#define OPTION_MASK_ISA_SSE4_2_UNSET OPTION_MASK_ISA_SSE4A\n+\n+/* SSE4 includes both SSE4.1 and SSE4.2. -msse4 should be the same\n+   as -msse4.1 -msse4.2.  -mno-sse4 should the same as -msse4.1. */\n+#define OPTION_MASK_ISA_SSE4 \\\n+  (OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4_2)\n+#define OPTION_MASK_ISA_SSE4_UNSET OPTION_MASK_ISA_SSE4_1_UNSET\n+\n+#define OPTION_MASK_ISA_SSE4A_UNSET OPTION_MASK_ISA_SSE4\n+\n /* Implement TARGET_HANDLE_OPTION.  */\n \n static bool\n@@ -1562,19 +1589,17 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_MMX;\n       if (!value)\n \t{\n-\t  ix86_isa_flags\n-\t    &= ~(OPTION_MASK_ISA_3DNOW | OPTION_MASK_ISA_3DNOW_A);\n-\t  ix86_isa_flags_explicit\n-\t    |= OPTION_MASK_ISA_3DNOW | OPTION_MASK_ISA_3DNOW_A;\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_MMX_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_MMX_UNSET;\n \t}\n       return true;\n \n     case OPT_m3dnow:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_3DNOW;\n       if (!value)\n \t{\n-\t  ix86_isa_flags &= ~OPTION_MASK_ISA_3DNOW_A;\n-\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_3DNOW_A;\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_3DNOW_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_3DNOW_UNSET;\n \t}\n       return true;\n \n@@ -1585,69 +1610,72 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE;\n       if (!value)\n \t{\n-\t  ix86_isa_flags\n-\t    &= ~(OPTION_MASK_ISA_SSE2 | OPTION_MASK_ISA_SSE3\n-\t\t | OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_SSE4_1\n-\t\t | OPTION_MASK_ISA_SSE4A);\n-\t  ix86_isa_flags_explicit\n-\t    |= (OPTION_MASK_ISA_SSE2 | OPTION_MASK_ISA_SSE3\n-\t\t| OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_SSE4_1\n-\t\t| OPTION_MASK_ISA_SSE4A);\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE_UNSET;\n \t}\n       return true;\n \n     case OPT_msse2:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE2;\n       if (!value)\n \t{\n-\t  ix86_isa_flags\n-\t    &= ~(OPTION_MASK_ISA_SSE3 | OPTION_MASK_ISA_SSSE3\n-\t\t | OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4A);\n-\t  ix86_isa_flags_explicit\n-\t    |= (OPTION_MASK_ISA_SSE3 | OPTION_MASK_ISA_SSSE3\n-\t\t| OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4A);\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE2_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE2_UNSET;\n \t}\n       return true;\n \n     case OPT_msse3:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE3;\n       if (!value)\n \t{\n-\t  ix86_isa_flags\n-\t    &= ~(OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_SSE4_1\n-\t\t | OPTION_MASK_ISA_SSE4A);\n-\t  ix86_isa_flags_explicit\n-\t    |= (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_SSE4_1\n-\t\t| OPTION_MASK_ISA_SSE4A);\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE3_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE3_UNSET;\n \t}\n       return true;\n \n     case OPT_mssse3:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSSE3;\n       if (!value)\n \t{\n-\t  ix86_isa_flags\n-\t    &= ~(OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4A);\n-\t  ix86_isa_flags_explicit\n-\t    |= OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE4A;\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSSE3_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSSE3_UNSET;\n \t}\n       return true;\n \n     case OPT_msse4_1:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_1;\n       if (!value)\n \t{\n-\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4A;\n-\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4A;\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4_1_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_1_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_msse4_2:\n+      ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_2;\n+      if (!value)\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4_2_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_2_UNSET;\n \t}\n       return true;\n \n+    case OPT_msse4:\n+      ix86_isa_flags |= OPTION_MASK_ISA_SSE4;\n+      ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4;\n+      return true;\n+\n+    case OPT_mno_sse4:\n+      ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4_UNSET;\n+      ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_UNSET;\n+      return true;\n+\n     case OPT_msse4a:\n       ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4A;\n       if (!value)\n \t{\n-\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4_1;\n-\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4_1;\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SSE4A_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE4A_UNSET;\n \t}\n       return true;\n \n@@ -1723,7 +1751,8 @@ override_options (void)\n \t  PTA_ABM = 1 << 11,\n  \t  PTA_SSE4A = 1 << 12,\n \t  PTA_NO_SAHF = 1 << 13,\n- \t  PTA_SSE4_1 = 1 << 14\n+ \t  PTA_SSE4_1 = 1 << 14,\n+ \t  PTA_SSE4_2 = 1 << 15\n \t} flags;\n     }\n   const processor_alias_table[] =\n@@ -2001,6 +2030,9 @@ override_options (void)\n \tif (processor_alias_table[i].flags & PTA_SSE4_1\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_1))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4_1;\n+\tif (processor_alias_table[i].flags & PTA_SSE4_2\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4_2))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4_2;\n \tif (processor_alias_table[i].flags & PTA_SSE4A\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE4A))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_SSE4A;\n@@ -2202,6 +2234,13 @@ override_options (void)\n   if (!TARGET_80387)\n     target_flags |= MASK_NO_FANCY_MATH_387;\n \n+  /* Turn on SSE4.1 builtins and popcnt instruction for -msse4.2.  */\n+  if (TARGET_SSE4_2)\n+    {\n+      ix86_isa_flags |= OPTION_MASK_ISA_SSE4_1;\n+      x86_popcnt = true;\n+    }\n+\n   /* Turn on SSSE3 builtins for -msse4.1.  */\n   if (TARGET_SSE4_1)\n     ix86_isa_flags |= OPTION_MASK_ISA_SSSE3;\n@@ -10481,6 +10520,16 @@ ix86_build_const_vector (enum machine_mode mode, bool vect, rtx value)\n   rtvec v;\n   switch (mode)\n     {\n+    case SImode:\n+      gcc_assert (vect);\n+      v = gen_rtvec (4, value, value, value, value);\n+      return gen_rtx_CONST_VECTOR (V4SImode, v);\n+\n+    case DImode:\n+      gcc_assert (vect);\n+      v = gen_rtvec (2, value, value);\n+      return gen_rtx_CONST_VECTOR (V2DImode, v);\n+\n     case SFmode:\n       if (vect)\n \tv = gen_rtvec (4, value, value, value, value);\n@@ -10501,37 +10550,53 @@ ix86_build_const_vector (enum machine_mode mode, bool vect, rtx value)\n     }\n }\n \n-/* A subroutine of ix86_expand_fp_absneg_operator and copysign expanders.\n-   Create a mask for the sign bit in MODE for an SSE register.  If VECT is\n-   true, then replicate the mask for all elements of the vector register.\n-   If INVERT is true, then create a mask excluding the sign bit.  */\n+/* A subroutine of ix86_expand_fp_absneg_operator, copysign expanders\n+   and ix86_expand_int_vcond.  Create a mask for the sign bit in MODE\n+   for an SSE register.  If VECT is true, then replicate the mask for\n+   all elements of the vector register.  If INVERT is true, then create\n+   a mask excluding the sign bit.  */\n \n rtx\n ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n {\n-  enum machine_mode vec_mode;\n+  enum machine_mode vec_mode, imode;\n   HOST_WIDE_INT hi, lo;\n   int shift = 63;\n   rtx v;\n   rtx mask;\n \n   /* Find the sign bit, sign extended to 2*HWI.  */\n-  if (mode == SFmode)\n-    lo = 0x80000000, hi = lo < 0;\n-  else if (HOST_BITS_PER_WIDE_INT >= 64)\n-    lo = (HOST_WIDE_INT)1 << shift, hi = -1;\n-  else\n-    lo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n+  switch (mode)\n+    {\n+    case SImode:\n+    case SFmode:\n+      imode = SImode;\n+      vec_mode = (mode == SImode) ? V4SImode : V4SFmode;\n+      lo = 0x80000000, hi = lo < 0;\n+      break;\n+\n+    case DImode:\n+    case DFmode:\n+      imode = DImode;\n+      vec_mode = (mode == DImode) ? V2DImode : V2DFmode;\n+      if (HOST_BITS_PER_WIDE_INT >= 64)\n+\tlo = (HOST_WIDE_INT)1 << shift, hi = -1;\n+      else\n+\tlo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   if (invert)\n     lo = ~lo, hi = ~hi;\n \n   /* Force this value into the low part of a fp vector constant.  */\n-  mask = immed_double_const (lo, hi, mode == SFmode ? SImode : DImode);\n+  mask = immed_double_const (lo, hi, imode);\n   mask = gen_lowpart (mode, mask);\n \n   v = ix86_build_const_vector (mode, vect, mask);\n-  vec_mode = (mode == SFmode) ? V4SFmode : V2DFmode;\n   return force_reg (vec_mode, v);\n }\n \n@@ -12739,7 +12804,7 @@ ix86_expand_fp_vcond (rtx operands[])\n   return true;\n }\n \n-/* Expand a signed integral vector conditional move.  */\n+/* Expand a signed/unsigned integral vector conditional move.  */\n \n bool\n ix86_expand_int_vcond (rtx operands[])\n@@ -12783,6 +12848,29 @@ ix86_expand_int_vcond (rtx operands[])\n       gcc_unreachable ();\n     }\n \n+  /* Only SSE4.1/SSE4.2 supports V2DImode.  */\n+  if (mode == V2DImode)\n+    {\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  /* SSE4.1 supports EQ.  */\n+\t  if (!TARGET_SSE4_1)\n+\t    return false;\n+\t  break;\n+\n+\tcase GT:\n+\tcase GTU:\n+\t  /* SSE4.2 supports GT/GTU.  */\n+\t  if (!TARGET_SSE4_2)\n+\t    return false;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n   /* Unsigned parallel compare is not supported by the hardware.  Play some\n      tricks to turn this into a signed comparison against 0.  */\n   if (code == GTU)\n@@ -12792,25 +12880,30 @@ ix86_expand_int_vcond (rtx operands[])\n       switch (mode)\n \t{\n \tcase V4SImode:\n+\tcase V2DImode:\n \t  {\n \t    rtx t1, t2, mask;\n \n \t    /* Perform a parallel modulo subtraction.  */\n \t    t1 = gen_reg_rtx (mode);\n-\t    emit_insn (gen_subv4si3 (t1, cop0, cop1));\n+\t    emit_insn ((mode == V4SImode\n+\t\t\t? gen_subv4si3\n+\t\t\t: gen_subv2di3) (t1, cop0, cop1));\n \n \t    /* Extract the original sign bit of op0.  */\n-\t    mask = GEN_INT (-0x80000000);\n-\t    mask = gen_rtx_CONST_VECTOR (mode,\n-\t\t\tgen_rtvec (4, mask, mask, mask, mask));\n-\t    mask = force_reg (mode, mask);\n+\t    mask = ix86_build_signbit_mask (GET_MODE_INNER (mode),\n+\t\t\t\t\t    true, false);\n \t    t2 = gen_reg_rtx (mode);\n-\t    emit_insn (gen_andv4si3 (t2, cop0, mask));\n+\t    emit_insn ((mode == V4SImode\n+\t\t\t? gen_andv4si3\n+\t\t\t: gen_andv2di3) (t2, cop0, mask));\n \n \t    /* XOR it back into the result of the subtraction.  This results\n \t       in the sign bit set iff we saw unsigned underflow.  */\n \t    x = gen_reg_rtx (mode);\n-\t    emit_insn (gen_xorv4si3 (x, t1, t2));\n+\t    emit_insn ((mode == V4SImode\n+\t\t\t? gen_xorv4si3\n+\t\t\t: gen_xorv2di3) (x, t1, t2));\n \n \t    code = GT;\n \t  }\n@@ -16637,6 +16730,14 @@ enum ix86_builtins\n   IX86_BUILTIN_VEC_SET_V4HI,\n   IX86_BUILTIN_VEC_SET_V16QI,\n \n+  /* SSE4.2.  */\n+  IX86_BUILTIN_CRC32QI,\n+  IX86_BUILTIN_CRC32HI,\n+  IX86_BUILTIN_CRC32SI,\n+  IX86_BUILTIN_CRC32DI,\n+\n+  IX86_BUILTIN_PCMPGTQ,\n+\n   IX86_BUILTIN_MAX\n };\n \n@@ -16728,6 +16829,15 @@ static const struct builtin_description bdesc_ptest[] =\n   { OPTION_MASK_ISA_SSE4_1, CODE_FOR_sse4_1_ptest, \"__builtin_ia32_ptestnzc128\", IX86_BUILTIN_PTESTNZC, GTU, 0 },\n };\n \n+static const struct builtin_description bdesc_crc32[] =\n+{\n+  /* SSE4.2 */\n+  { OPTION_MASK_ISA_SSE4_2 | OPTION_MASK_ISA_64BIT, CODE_FOR_sse4_2_crc32qi, 0, IX86_BUILTIN_CRC32QI, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_crc32hi, 0, IX86_BUILTIN_CRC32HI, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_crc32si, 0, IX86_BUILTIN_CRC32SI, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_crc32di, 0, IX86_BUILTIN_CRC32DI, 0, 0 },\n+};\n+\n /* SSE builtins with 3 arguments and the last argument must be a 8 bit\n    constant or xmm0.  */\n static const struct builtin_description bdesc_sse_3arg[] =\n@@ -17050,6 +17160,9 @@ static const struct builtin_description bdesc_2arg[] =\n   { OPTION_MASK_ISA_SSE4_1, CODE_FOR_uminv8hi3, \"__builtin_ia32_pminuw128\", IX86_BUILTIN_PMINUW128, 0, 0 },\n   { OPTION_MASK_ISA_SSE4_1, CODE_FOR_sse4_1_mulv2siv2di3, 0, IX86_BUILTIN_PMULDQ128, 0, 0 },\n   { OPTION_MASK_ISA_SSE4_1, CODE_FOR_mulv4si3, \"__builtin_ia32_pmulld128\", IX86_BUILTIN_PMULLD128, 0, 0 },\n+\n+  /* SSE4.2 */\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_gtv2di3, \"__builtin_ia32_pcmpgtq\", IX86_BUILTIN_PCMPGTQ, 0, 0 },\n };\n \n static const struct builtin_description bdesc_1arg[] =\n@@ -17881,6 +17994,28 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin_const (OPTION_MASK_ISA_SSE4_1, \"__builtin_ia32_roundsd\", v2df_ftype_v2df_v2df_int, IX86_BUILTIN_ROUNDSD);\n   def_builtin_const (OPTION_MASK_ISA_SSE4_1, \"__builtin_ia32_roundss\", v4sf_ftype_v4sf_v4sf_int, IX86_BUILTIN_ROUNDSS);\n \n+  /* SSE4.2. */\n+  ftype = build_function_type_list (unsigned_type_node,\n+\t\t\t\t    unsigned_type_node,\n+\t\t\t\t    unsigned_char_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (OPTION_MASK_ISA_SSE4_2, \"__builtin_ia32_crc32qi\", ftype, IX86_BUILTIN_CRC32QI);\n+  ftype = build_function_type_list (unsigned_type_node,\n+\t\t\t\t    unsigned_type_node,\n+\t\t\t\t    short_unsigned_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (OPTION_MASK_ISA_SSE4_2, \"__builtin_ia32_crc32hi\", ftype, IX86_BUILTIN_CRC32HI);\n+  ftype = build_function_type_list (unsigned_type_node,\n+\t\t\t\t    unsigned_type_node,\n+\t\t\t\t    unsigned_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (OPTION_MASK_ISA_SSE4_2, \"__builtin_ia32_crc32si\", ftype, IX86_BUILTIN_CRC32SI);\n+  ftype = build_function_type_list (long_long_unsigned_type_node,\n+\t\t\t\t    long_long_unsigned_type_node,\n+\t\t\t\t    long_long_unsigned_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (OPTION_MASK_ISA_SSE4_2, \"__builtin_ia32_crc32di\", ftype, IX86_BUILTIN_CRC32DI);\n+\n   /* AMDFAM10 SSE4A New built-ins  */\n   def_builtin (OPTION_MASK_ISA_SSE4A, \"__builtin_ia32_movntsd\", void_ftype_pdouble_v2df, IX86_BUILTIN_MOVNTSD);\n   def_builtin (OPTION_MASK_ISA_SSE4A, \"__builtin_ia32_movntss\", void_ftype_pfloat_v4sf, IX86_BUILTIN_MOVNTSS);\n@@ -18059,6 +18194,41 @@ ix86_expand_sse_4_operands_builtin (enum insn_code icode, tree exp,\n   return target;\n }\n \n+/* Subroutine of ix86_expand_builtin to take care of crc32 insns.  */\n+\n+static rtx\n+ix86_expand_crc32 (enum insn_code icode, tree exp, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+\n+  if (optimize\n+      || !target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    {\n+      op1 = copy_to_reg (op1);\n+      op1 = simplify_gen_subreg (mode1, op1, GET_MODE (op1), 0);\n+    }\n+\n+  pat = GEN_FCN (icode) (target, op0, op1);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n /* Subroutine of ix86_expand_builtin to take care of binop insns.  */\n \n static rtx\n@@ -19218,6 +19388,10 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     if (d->code == fcode)\n       return ix86_expand_sse_ptest (d, exp, target);\n \n+  for (i = 0, d = bdesc_crc32; i < ARRAY_SIZE (bdesc_crc32); i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_crc32 (d->icode, exp, target);\n+\n   gcc_unreachable ();\n }\n "}, {"sha": "9bdb3882623678dbcad34caaea2987f92d53736a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02110-1301, USA.  */\n #define TARGET_SSE3\tOPTION_ISA_SSE3\n #define TARGET_SSSE3\tOPTION_ISA_SSSE3\n #define TARGET_SSE4_1\tOPTION_ISA_SSE4_1\n+#define TARGET_SSE4_2\tOPTION_ISA_SSE4_2\n #define TARGET_SSE4A\tOPTION_ISA_SSE4A\n \n #include \"config/vxworks-dummy.h\"\n@@ -568,6 +569,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \tbuiltin_define (\"__SSSE3__\");\t\t\t\t\\\n       if (TARGET_SSE4_1)\t\t\t\t\t\\\n \tbuiltin_define (\"__SSE4_1__\");\t\t\t\t\\\n+      if (TARGET_SSE4_2)\t\t\t\t\t\\\n+\tbuiltin_define (\"__SSE4_2__\");\t\t\t\t\\\n       if (TARGET_SSE4A)\t\t\t\t\t\t\\\n  \tbuiltin_define (\"__SSE4A__\");\t\t                \\\n       if (TARGET_SSE_MATH && TARGET_SSE)\t\t\t\\"}, {"sha": "38e41bccb0856c852090aa1bcaa771d0d7de7bda", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -173,6 +173,9 @@\n    (UNSPEC_PTEST\t\t140)\n    (UNSPEC_ROUNDP\t\t141)\n    (UNSPEC_ROUNDS\t\t142)\n+\n+   ; For SSE4.2 support\n+   (UNSPEC_CRC32\t\t143)\n   ])\n \n (define_constants\n@@ -20895,6 +20898,36 @@\n   }\n   [(set_attr \"type\" \"multi\")])\n \n+(define_mode_macro CRC32MODE [QI HI SI])\n+(define_mode_attr crc32modesuffix [(QI \"b\") (HI \"w\") (SI \"l\")])\n+(define_mode_attr crc32modeconstraint [(QI \"qm\") (HI \"rm\") (SI \"rm\")])\n+\n+(define_insn \"sse4_2_crc32<mode>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI\n+\t  [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:CRC32MODE 2 \"nonimmediate_operand\" \"<crc32modeconstraint>\")]\n+\t  UNSPEC_CRC32))]\n+  \"TARGET_SSE4_2\"\n+  \"crc32<crc32modesuffix>\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"sse4_2_crc32di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI\n+\t  [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t   (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")]\n+\t  UNSPEC_CRC32))]\n+  \"TARGET_SSE4_2 && TARGET_64BIT\"\n+  \"crc32q\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "72b40c93987a3419ee3f9bb82b5bd6b41b7222c4", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -225,6 +225,18 @@ msse4.1\n Target Report Mask(ISA_SSE4_1) Var(ix86_isa_flags) VarExists\n Support MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 built-in functions and code generation\n \n+msse4.2\n+Target Report Mask(ISA_SSE4_2) Var(ix86_isa_flags) VarExists\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1 and SSE4.2 built-in functions and code generation\n+\n+msse4\n+Target RejectNegative Report Mask(ISA_SSE4_2) MaskExists Var(ix86_isa_flags) VarExists\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1 and SSE4.2 built-in functions and code generation\n+\n+mno-sse4\n+Target RejectNegative Report InverseMask(ISA_SSE4_1) MaskExists Var(ix86_isa_flags) VarExists\n+Do not support SSE4.1 and SSE4.2 built-in functions and code generation\n+\n msse4a\n Target Report Mask(ISA_SSE4A) Var(ix86_isa_flags) VarExists\n Support MMX, SSE, SSE2, SSE3 and SSE4A built-in functions and code generation"}, {"sha": "4b9614e6aeeeb282b52cebc1feddaf5a4cd464db", "filename": "gcc/config/i386/nmmintrin.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fnmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fnmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnmmintrin.h?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 10.0.  */\n+\n+#ifndef _NMMINTRIN_H_INCLUDED\n+#define _NMMINTRIN_H_INCLUDED\n+\n+#ifndef __SSE4_2__\n+# error \"SSE4.2 instruction set not enabled\"\n+#else\n+/* We just include SSE4.1 header file.  */\n+#include <smmintrin.h>\n+#endif /* __SSE4_2__ */\n+\n+#endif /* _NMMINTRIN_H_INCLUDED */"}, {"sha": "d0f365b1f847c3279c80c8047e7d600f889804a1", "filename": "gcc/config/i386/smmintrin.h", "status": "modified", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsmmintrin.h?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -573,6 +573,246 @@ _mm_stream_load_si128 (__m128i *__X)\n   return (__m128i) __builtin_ia32_movntdqa ((__v2di *) __X);\n }\n \n+#ifdef __SSE4_2__\n+\n+/* These macros specify the source data format.  */\n+#define SIDD_UBYTE_OPS\t\t\t0x00\n+#define SIDD_UWORD_OPS\t\t\t0x01\n+#define SIDD_SBYTE_OPS\t\t\t0x02\n+#define SIDD_SWORD_OPS\t\t\t0x03\n+\n+/* These macros specify the comparison operation.  */\n+#define SIDD_CMP_EQUAL_ANY\t\t0x00\n+#define SIDD_CMP_RANGES\t\t\t0x04\n+#define SIDD_CMP_EQUAL_EACH\t\t0x08\n+#define SIDD_CMP_EQUAL_ORDERED\t\t0x0c\n+\n+/* These macros specify the the polarity.  */\n+#define SIDD_POSITIVE_POLARITY\t\t0x00\n+#define SIDD_NEGATIVE_POLARITY\t\t0x10\n+#define SIDD_MASKED_POSITIVE_POLARITY\t0x20\n+#define SIDD_MASKED_NEGATIVE_POLARITY\t0x30\n+\n+/* These macros specify the output selection in _mm_cmpXstri ().  */\n+#define SIDD_LEAST_SIGNIFICANT\t\t0x00\n+#define SIDD_MOST_SIGNIFICANT\t\t0x40\n+\n+/* These macros specify the output selection in _mm_cmpXstrm ().  */\n+#define SIDD_BIT_MASK\t\t\t0x00\n+#define SIDD_UNIT_MASK\t\t\t0x40\n+\n+/* Intrinsics for text/string processing.  */\n+\n+#if 0\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_cmpistrm (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return (__m128i) __builtin_ia32_pcmpistrm128 ((__v16qi)__X,\n+\t\t\t\t\t\t(__v16qi)__Y,\n+\t\t\t\t\t\t__M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistri (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistri128 ((__v16qi)__X,\n+\t\t\t\t      (__v16qi)__Y,\n+\t\t\t\t      __M);\n+}\n+\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_cmpestrm (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return (__m128i) __builtin_ia32_pcmpestrm128 ((__v16qi)__X, __LX,\n+\t\t\t\t\t\t(__v16qi)__Y, __LY,\n+\t\t\t\t\t\t__M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestri (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestri128 ((__v16qi)__X, __LX,\n+\t\t\t\t      (__v16qi)__Y, __LY,\n+\t\t\t\t      __M);\n+}\n+#else\n+#define _mm_cmpistrm(X, Y, M) \\\n+  ((__m128i) __builtin_ia32_pcmpistrm128 ((__v16qi)(X), (__v16qi)(Y), (M)))\n+#define _mm_cmpistri(X, Y, M) \\\n+  __builtin_ia32_pcmpistri128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+\n+#define _mm_cmpestrm(X, LX, Y, LY, M) \\\n+  ((__m128i) __builtin_ia32_pcmpestrm128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t\t  (__v16qi)(Y), (int)(LY), (M)))\n+#define _mm_cmpestri(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestri128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t       (__v16qi)(Y), (int)(LY), (M))\n+#endif\n+\n+/* Intrinsics for text/string processing and reading values of\n+   EFlags.  */\n+\n+#if 0\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistra (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistria128 ((__v16qi)__X,\n+\t\t\t\t       (__v16qi)__Y,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistrc (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistric128 ((__v16qi)__X,\n+\t\t\t\t       (__v16qi)__Y,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistro (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistrio128 ((__v16qi)__X,\n+\t\t\t\t       (__v16qi)__Y,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistrs (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistris128 ((__v16qi)__X,\n+\t\t\t\t       (__v16qi)__Y,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpistrz (__m128i __X, __m128i __Y, const int __M)\n+{\n+  return __builtin_ia32_pcmpistriz128 ((__v16qi)__X,\n+\t\t\t\t       (__v16qi)__Y,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestra (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestria128 ((__v16qi)__X, __LX,\n+\t\t\t\t       (__v16qi)__Y, __LY,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestrc (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestric128 ((__v16qi)__X, __LX,\n+\t\t\t\t       (__v16qi)__Y, __LY,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestro (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestrio128 ((__v16qi)__X, __LX,\n+\t\t\t\t       (__v16qi)__Y, __LY,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestrs (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestris128 ((__v16qi)__X, __LX,\n+\t\t\t\t       (__v16qi)__Y, __LY,\n+\t\t\t\t       __M);\n+}\n+\n+static __inline int __attribute__((__always_inline__))\n+_mm_cmpestrz (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n+{\n+  return __builtin_ia32_pcmpestriz128 ((__v16qi)__X, __LX,\n+\t\t\t\t       (__v16qi)__Y, __LY,\n+\t\t\t\t       __M);\n+}\n+#else\n+#define _mm_cmpistra(X, Y, M) \\\n+  __builtin_ia32_pcmpistria128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+#define _mm_cmpistrc(X, Y, M) \\\n+  __builtin_ia32_pcmpistric128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+#define _mm_cmpistro(X, Y, M) \\\n+  __builtin_ia32_pcmpistrio128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+#define _mm_cmpistrs(X, Y, M) \\\n+  __builtin_ia32_pcmpistris128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+#define _mm_cmpistrz(X, Y, M) \\\n+  __builtin_ia32_pcmpistriz128 ((__v16qi)(X), (__v16qi)(Y), (M))\n+\n+#define _mm_cmpestra(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestria128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t(__v16qi)(Y), (int)(LY), (M))\n+#define _mm_cmpestrc(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestric128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t(__v16qi)(Y), (int)(LY), (M))\n+#define _mm_cmpestro(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestrio128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t(__v16qi)(Y), (int)(LY), (M))\n+#define _mm_cmpestrs(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestris128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t(__v16qi)(Y), (int)(LY), (M))\n+#define _mm_cmpestrz(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestriz128 ((__v16qi)(X), (int)(LX), \\\n+\t\t\t\t(__v16qi)(Y), (int)(LY), (M))\n+#endif\n+\n+/* Packed integer 64-bit comparison, zeroing or filling with ones\n+   corresponding parts of result.  */\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_cmpgt_epi64 (__m128i __X, __m128i __Y)\n+{\n+  return (__m128i) __builtin_ia32_pcmpgtq ((__v2di)__X, (__v2di)__Y);\n+}\n+\n+/* Calculate a number of bits set to 1.  */\n+static __inline int __attribute__((__always_inline__))\n+_mm_popcnt_u32 (unsigned int __X)\n+{\n+  return __builtin_popcount (__X);\n+}\n+\n+#ifdef __x86_64__\n+static __inline long long  __attribute__((__always_inline__))\n+_mm_popcnt_u64 (unsigned long long __X)\n+{\n+  return __builtin_popcountll (__X);\n+}\n+#endif\n+\n+/* Accumulate CRC32 (polynomial 0x11EDC6F41) value.  */\n+static __inline unsigned int __attribute__((__always_inline__))\n+_mm_crc32_u8 (unsigned int __C, unsigned char __V)\n+{\n+  return __builtin_ia32_crc32qi (__C, __V);\n+}\n+\n+static __inline unsigned int __attribute__((__always_inline__))\n+_mm_crc32_u16 (unsigned int __C, unsigned short __V)\n+{\n+  return __builtin_ia32_crc32hi (__C, __V);\n+}\n+\n+static __inline unsigned int __attribute__((__always_inline__))\n+_mm_crc32_u32 (unsigned int __C, unsigned int __V)\n+{\n+  return __builtin_ia32_crc32si (__C, __V);\n+}\n+\n+#ifdef __x86_64__\n+static __inline unsigned long long __attribute__((__always_inline__))\n+_mm_crc32_u64 (unsigned long long __C, unsigned long long __V)\n+{\n+  return __builtin_ia32_crc32di (__C, __V);\n+}\n+#endif\n+\n+#endif /* __SSE4_2__ */\n+\n #endif /* __SSE4_1__ */\n \n #endif /* _SMMINTRIN_H_INCLUDED */"}, {"sha": "76351926127b95ce82c995a4201b7818891ad113", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -3633,14 +3633,24 @@\n    (set_attr \"prefix_data16\" \"1\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_insn \"sse4_2_gtv2di3\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(gt:V2DI\n+\t  (match_operand:V2DI 1 \"nonimmediate_operand\" \"0\")\n+\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE4_2\"\n+  \"pcmpgtq\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"ssecmp\")\n+   (set_attr \"mode\" \"TI\")])\n+\n (define_expand \"vcond<mode>\"\n-  [(set (match_operand:SSEMODE124 0 \"register_operand\" \"\")\n-        (if_then_else:SSEMODE124\n+  [(set (match_operand:SSEMODEI 0 \"register_operand\" \"\")\n+        (if_then_else:SSEMODEI\n           (match_operator 3 \"\"\n-            [(match_operand:SSEMODE124 4 \"nonimmediate_operand\" \"\")\n-             (match_operand:SSEMODE124 5 \"nonimmediate_operand\" \"\")])\n-          (match_operand:SSEMODE124 1 \"general_operand\" \"\")\n-          (match_operand:SSEMODE124 2 \"general_operand\" \"\")))]\n+            [(match_operand:SSEMODEI 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:SSEMODEI 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:SSEMODEI 1 \"general_operand\" \"\")\n+          (match_operand:SSEMODEI 2 \"general_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n   if (ix86_expand_int_vcond (operands))\n@@ -3650,13 +3660,13 @@\n })\n \n (define_expand \"vcondu<mode>\"\n-  [(set (match_operand:SSEMODE124 0 \"register_operand\" \"\")\n-        (if_then_else:SSEMODE124\n+  [(set (match_operand:SSEMODEI 0 \"register_operand\" \"\")\n+        (if_then_else:SSEMODEI\n           (match_operator 3 \"\"\n-            [(match_operand:SSEMODE124 4 \"nonimmediate_operand\" \"\")\n-             (match_operand:SSEMODE124 5 \"nonimmediate_operand\" \"\")])\n-          (match_operand:SSEMODE124 1 \"general_operand\" \"\")\n-          (match_operand:SSEMODE124 2 \"general_operand\" \"\")))]\n+            [(match_operand:SSEMODEI 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:SSEMODEI 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:SSEMODEI 1 \"general_operand\" \"\")\n+          (match_operand:SSEMODEI 2 \"general_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n   if (ix86_expand_int_vcond (operands))"}, {"sha": "4217eaadb486dbe446f42faa1ff43b39a560ad01", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -7502,6 +7502,54 @@ Generates the @code{pextrd} machine instruction.\n Generates the @code{pextrq} machine instruction in 64bit mode.\n @end table\n \n+The following built-in functions are available when @option{-msse4.2} is\n+used.  All of them generate the machine instruction that is part of the\n+name.\n+\n+@smallexample\n+v16qi __builtin_ia32_pcmpestrm128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestri128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestria128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestric128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestrio128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestris128 (v16qi, int, v16qi, int, const int)\n+int __builtin_ia32_pcmpestriz128 (v16qi, int, v16qi, int, const int)\n+v16qi __builtin_ia32_pcmpistrm128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistri128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistria128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistric128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistrio128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistris128 (v16qi, v16qi, const int)\n+int __builtin_ia32_pcmpistriz128 (v16qi, v16qi, const int)\n+__v2di __builtin_ia32_pcmpgtq (__v2di, __v2di)\n+@end smallexample\n+\n+The following built-in functions are available when @option{-msse4.2} is\n+used.\n+\n+@table @code\n+unsigned int __builtin_ia32_crc32qi (unsigned int, unsigned char)\n+Generates the @code{crc32b} machine instruction.\n+unsigned int __builtin_ia32_crc32hi (unsigned int, unsigned short)\n+Generates the @code{crc32w} machine instruction.\n+unsigned int __builtin_ia32_crc32si (unsigned int, unsigned int)\n+Generates the @code{crc32l} machine instruction.\n+unsigned long long __builtin_ia32_crc32di (unsigned int, unsigned long long)\n+@end table\n+\n+The following built-in functions are changed to generate new SSE4.2\n+instructions when @option{-msse4.2} is used.\n+\n+@table @code\n+int __builtin_popcount (unsigned int)\n+Generates the @code{popcntl} machine instruction.\n+int __builtin_popcountl (unsigned long)\n+Generates the @code{popcntl} or @code{popcntq} machine instruction,\n+depending on the size of @code{unsigned long}.\n+int __builtin_popcountll (unsigned long long)\n+Generates the @code{popcntq} machine instruction.\n+@end table\n+\n The following built-in functions are available when @option{-msse4a} is used.\n \n @smallexample"}, {"sha": "4aedf300184e3945e35459d2bd72e1bf90ad10dc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3b8dd0716ff7c5411334c1f0ad61306ec97ac6e9", "patch": "@@ -548,7 +548,7 @@ Objective-C and Objective-C++ Dialects}.\n -mno-fp-ret-in-387  -msoft-float @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n -mpreferred-stack-boundary=@var{num} -mcx16 -msahf @gol\n--mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 @gol\n+-mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 @gol\n -msse4a -m3dnow -mpopcnt -mabm @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n@@ -10273,6 +10273,10 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-ssse3\n @item -msse4.1\n @itemx -mno-sse4.1\n+@item -msse4.2\n+@itemx -mno-sse4.2\n+@item -msse4\n+@itemx -mno-sse4\n @item -msse4a\n @item -mno-sse4a\n @item -m3dnow"}]}