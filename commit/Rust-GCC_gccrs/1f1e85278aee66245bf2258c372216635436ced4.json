{"sha": "1f1e85278aee66245bf2258c372216635436ced4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYxZTg1Mjc4YWVlNjYyNDViZjIyNThjMzcyMjE2NjM1NDM2Y2VkNA==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2005-03-29T11:45:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-03-29T11:45:51Z"}, "message": "Makefile.in (value-prof.o): New dependencies on $(DIAGNOSTIC_H) $(TREE_H) and $(COVERAGE_H).\n\n\t* Makefile.in (value-prof.o): New dependencies on $(DIAGNOSTIC_H)\n\t$(TREE_H) and $(COVERAGE_H).\n\t* coverage.c (compute_checksum): Use DECL_NAME not DECL_ASSEMBLER_NAME.\n\t* opts.c (common_handle_option): Enable tree-based value transforms.\n\t* toplev.c (process_options): Ditto.\n\t* value-prof.h (struct histogram_value_t): Redefine. \"Adjust\" below\n\trefers to references to this type.\n\t* tree-flow.h: (struct stmt_ann_d): Add histograms field.\n\t* rtl-profile.c (rtl_gen_interval_profiler): Adjust. Remove checks\n\tfor may_be_more, may_be_less.\n\t(rtl_gen_pow2_profiler): Adjust.\n\t(rtl_gen_one_value_profiler_no_edge_manip): Adjust.\n\t(rtl_gen_one_value_profiler): Adjust.\n\t(rtl_gen_const_delta_profiler): Adjust.\n\t* tree-profile.c (tree_gen_interval_profiler): Implement.\n\t(tree_gen_pow2_profiler): Ditto.\n\t(tree_gen_one_value_profiler): Ditto.\n\t(tree_profiling): New.\n\t(pass_tree_profile): Reference it.\n\t* value-prof.c: Include tree-flow.h, tree-flow-inline.h, diagnostic.h,\n\ttree.h, gcov-io.h.\n\t(insn_divmod_values_to_profile): Rename to\n\trtl_divmod_values_to_profile. Adjust.\n\t(insn_values_to_profile): Rename to rtl_values_to_profile. Adjust.\n\t(insn_prefetch_values_to_profile): Adjust.\n\t(rtl_value_profile_transformations): Adjust.\n\t(gen_divmod_fixed_value): Rename to rtl_divmod_fixed_value.\n\t(gen_mod_pow2): Rename to rtl_mod_pow2.\n\t(gen_mod_subtract): Rename to rtl_mod_subtract.\n\t(divmod_fixed_value_transform): Rename to\n\trtl_divmod_fixed_value_transform.\n\t(mod_pow2_value_transform): Rename to rtl_mod_pow2_value_transform.\n\t(mod_subtract_transform): Rename to rtl_mod_subtract_transform.\n\t(rtl_find_values_to_profile): Adjust.\n\t(tree_value_profile_transformations): Implement.\n\t(tree_divmod_values_to_profile): New.\n\t(tree_values_to_profile): New.\n\t(tree_divmod_fixed_value): New.\n\t(tree_mod_pow2): New.\n\t(tree_mod_subtract): New.\n\t(tree_divmod_fixed_value_transform): New.\n\t(tree_mod_pow2_value_transform): New.\n\t(tree_mod_subtract_transform): New.\n\t(tree_find_values_to_profile): Implement.\n\t* profile.c (instrument_values):  Free histograms.\n\t(compute_value_histograms): Adjust. Implement tree version.\n\nFrom-SVN: r97156", "tree": {"sha": "06715d5d420f0cc621f0ca883cf604ecc6862320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06715d5d420f0cc621f0ca883cf604ecc6862320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f1e85278aee66245bf2258c372216635436ced4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1e85278aee66245bf2258c372216635436ced4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f1e85278aee66245bf2258c372216635436ced4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1e85278aee66245bf2258c372216635436ced4/comments", "author": null, "committer": null, "parents": [{"sha": "82498ed4b96badc4fc2ccd9889657b628320877c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82498ed4b96badc4fc2ccd9889657b628320877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82498ed4b96badc4fc2ccd9889657b628320877c"}], "stats": {"total": 1667, "additions": 1435, "deletions": 232}, "files": [{"sha": "ef0ccbffbb47416b98990cf29e63f285be5f9e21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -1,3 +1,52 @@\n+2005-03-29  Dale Johannesen <dalej@apple.com>\n+\n+\t* Makefile.in (value-prof.o): New dependencies on $(DIAGNOSTIC_H)\n+\t$(TREE_H) and $(COVERAGE_H).\n+\t* coverage.c (compute_checksum): Use DECL_NAME not DECL_ASSEMBLER_NAME.\n+\t* opts.c (common_handle_option): Enable tree-based value transforms.\n+\t* toplev.c (process_options): Ditto.\n+\t* value-prof.h (struct histogram_value_t): Redefine. \"Adjust\" below\n+\trefers to references to this type.\n+\t* tree-flow.h: (struct stmt_ann_d): Add histograms field.\n+\t* rtl-profile.c (rtl_gen_interval_profiler): Adjust. Remove checks\n+\tfor may_be_more, may_be_less.\n+\t(rtl_gen_pow2_profiler): Adjust.\n+\t(rtl_gen_one_value_profiler_no_edge_manip): Adjust.\n+\t(rtl_gen_one_value_profiler): Adjust.\n+\t(rtl_gen_const_delta_profiler): Adjust.\n+\t* tree-profile.c (tree_gen_interval_profiler): Implement.\n+\t(tree_gen_pow2_profiler): Ditto.\n+\t(tree_gen_one_value_profiler): Ditto.\n+\t(tree_profiling): New.\n+\t(pass_tree_profile): Reference it.\n+\t* value-prof.c: Include tree-flow.h, tree-flow-inline.h, diagnostic.h,\n+\ttree.h, gcov-io.h.\n+\t(insn_divmod_values_to_profile): Rename to \n+\trtl_divmod_values_to_profile. Adjust.\n+\t(insn_values_to_profile): Rename to rtl_values_to_profile. Adjust.\n+\t(insn_prefetch_values_to_profile): Adjust.\n+\t(rtl_value_profile_transformations): Adjust.\n+\t(gen_divmod_fixed_value): Rename to rtl_divmod_fixed_value.\n+\t(gen_mod_pow2): Rename to rtl_mod_pow2.\n+\t(gen_mod_subtract): Rename to rtl_mod_subtract.\n+\t(divmod_fixed_value_transform): Rename to \n+\trtl_divmod_fixed_value_transform.\n+\t(mod_pow2_value_transform): Rename to rtl_mod_pow2_value_transform.\n+\t(mod_subtract_transform): Rename to rtl_mod_subtract_transform.\n+\t(rtl_find_values_to_profile): Adjust.\n+\t(tree_value_profile_transformations): Implement.\n+\t(tree_divmod_values_to_profile): New.\n+\t(tree_values_to_profile): New.\n+\t(tree_divmod_fixed_value): New.\n+\t(tree_mod_pow2): New.\n+\t(tree_mod_subtract): New.\n+\t(tree_divmod_fixed_value_transform): New.\n+\t(tree_mod_pow2_value_transform): New.\n+\t(tree_mod_subtract_transform): New.\n+\t(tree_find_values_to_profile): Implement.\n+\t* profile.c (instrument_values):  Free histograms.\n+\t(compute_value_histograms): Adjust. Implement tree version.\n+\n 2005-03-29  Uros Bizjak  <uros@kss-loka.si>\n \n \t* reg-stack.c (subst_stack_regs_pat): Handle <UNSPEC_FIST> case."}, {"sha": "003e4ac44c63c9e953590a5625050233ca84a176", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -2023,7 +2023,8 @@ rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h $(GGC_H)\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n-   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H)\n+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n+   $(TREE_H) $(COVERAGE_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h $(CFGLOOP_H) \\"}, {"sha": "25d14713408d8174a253675712222170d983b4cf", "filename": "gcc/profile.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -224,6 +224,7 @@ instrument_values (histogram_values values)\n \t  abort ();\n \t}\n     }\n+  VEC_free (histogram_value, values);\n }\n \f\n \n@@ -641,7 +642,7 @@ compute_branch_probabilities (void)\n }\n \n /* Load value histograms values whose description is stored in VALUES array\n-   from .da file.  */\n+   from .gcda file.  */\n \n static void\n compute_value_histograms (histogram_values values)\n@@ -688,21 +689,32 @@ compute_value_histograms (histogram_values values)\n       hist = VEC_index (histogram_value, values, i);\n       t = (int) hist->type;\n \n-      /* FIXME: make this work for trees.  */\n+      aact_count = act_count[t];\n+      act_count[t] += hist->n_counters;\n+\n       if (!ir_type ())\n \t{\n-\t  aact_count = act_count[t];\n-\t  act_count[t] += hist->n_counters;\n \t  for (j = hist->n_counters; j > 0; j--)\n \t    hist_list = alloc_EXPR_LIST (0, GEN_INT (aact_count[j - 1]), \n \t\t\t\t\thist_list);\n-\t      hist_list = alloc_EXPR_LIST (0, \n-\t\t\t    copy_rtx ((rtx) hist->value), hist_list);\n+\t  hist_list = alloc_EXPR_LIST (0, \n+\t\t\tcopy_rtx (hist->hvalue.rtl.value), hist_list);\n \t  hist_list = alloc_EXPR_LIST (0, GEN_INT (hist->type), hist_list);\n-\t      REG_NOTES ((rtx) hist->insn) =\n-\t\t  alloc_EXPR_LIST (REG_VALUE_PROFILE, hist_list,\n-\t\t\t\t   REG_NOTES ((rtx) hist->insn));\n+\t  REG_NOTES (hist->hvalue.rtl.insn) =\n+\t      alloc_EXPR_LIST (REG_VALUE_PROFILE, hist_list,\n+\t\t\t       REG_NOTES (hist->hvalue.rtl.insn));\n \t}\n+      else\n+\t{\n+\t  tree stmt = hist->hvalue.tree.stmt;\n+\t  stmt_ann_t ann = get_stmt_ann (stmt);\n+\t  hist->hvalue.tree.next = ann->histograms;\n+\t  ann->histograms = hist;\n+\t  hist->hvalue.tree.counters = \n+\t\txmalloc (sizeof (gcov_type) * hist->n_counters);\n+\t  for (j = 0; j < hist->n_counters; j++)\n+\t    hist->hvalue.tree.counters[j] = aact_count[j];\n+  \t}\n     }\n \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)"}, {"sha": "b6d597103f3bc490dfa8242e12cf189cc2fc73e0", "filename": "gcc/rtl-profile.c", "status": "modified", "additions": 39, "deletions": 78, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -23,30 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* Generate basic block profile instrumentation and auxiliary files.\n-   Profile generation is optimized, so that not all arcs in the basic\n-   block graph need instrumenting. First, the BB graph is closed with\n-   one entry (function start), and one exit (function exit).  Any\n-   ABNORMAL_EDGE cannot be instrumented (because there is no control\n-   path to place the code). We close the graph by inserting fake\n-   EDGE_FAKE edges to the EXIT_BLOCK, from the sources of abnormal\n-   edges that do not go to the exit_block. We ignore such abnormal\n-   edges.  Naturally these fake edges are never directly traversed,\n-   and so *cannot* be directly instrumented.  Some other graph\n-   massaging is done. To optimize the instrumentation we generate the\n-   BB minimal span tree, only edges that are not on the span tree\n-   (plus the entry point) need instrumenting. From that information\n-   all other edge counts can be deduced.  By construction all fake\n-   edges must be on the spanning tree. We also attempt to place\n-   EDGE_CRITICAL edges on the spanning tree.\n-\n-   The auxiliary file generated is <dumpbase>.bbg. The format is\n-   described in full in gcov-io.h.  */\n-\n-/* ??? Register allocation should use basic block execution counts to\n-   give preference to the most commonly executed blocks.  */\n-\n-/* ??? Should calculate branch probabilities before instrumenting code, since\n-   then we can use arc counts to help decide which arcs to instrument.  */\n+   RTL-based version.  See profile.c for overview.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -114,77 +91,61 @@ rtl_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n   rtx less_label = gen_label_rtx ();\n   rtx end_of_code_label = gen_label_rtx ();\n   int per_counter = gcov_size / BITS_PER_UNIT;\n-  edge e = split_block (BLOCK_FOR_INSN ((rtx)value->insn),\n-\t\t   PREV_INSN ((rtx)value->insn));\n+  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n+\t\t   PREV_INSN (value->hvalue.rtl.insn));\n \n   start_sequence ();\n \n-  if (value->seq)\n-    emit_insn (value->seq);\n+  if (value->hvalue.rtl.seq)\n+    emit_insn (value->hvalue.rtl.seq);\n \n   mr = gen_reg_rtx (Pmode);\n \n   tmp = rtl_coverage_counter_ref (tag, base);\n   tmp = force_reg (Pmode, XEXP (tmp, 0));\n \n-  val = expand_simple_binop (value->mode, MINUS,\n-\t\t\t     copy_rtx (value->value),\n+  val = expand_simple_binop (value->hvalue.rtl.mode, MINUS,\n+\t\t\t     copy_rtx (value->hvalue.rtl.value),\n \t\t\t     GEN_INT (value->hdata.intvl.int_start),\n \t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n \n-  if (value->hdata.intvl.may_be_more)\n     do_compare_rtx_and_jump (copy_rtx (val), GEN_INT (value->hdata.intvl.steps),\n-\t\t\t     GE, 0, value->mode, NULL_RTX, NULL_RTX, more_label);\n-  if (value->hdata.intvl.may_be_less)\n-    do_compare_rtx_and_jump (copy_rtx (val), const0_rtx, LT, 0, value->mode,\n+\t\t\t   GE, 0, value->hvalue.rtl.mode, NULL_RTX, NULL_RTX, \n+\t\t\t   more_label);\n+  do_compare_rtx_and_jump (copy_rtx (val), const0_rtx, LT, 0, \n+\t\t\t   value->hvalue.rtl.mode,\n \t\t\t     NULL_RTX, NULL_RTX, less_label);\n \n   /* We are in range.  */\n-  tmp1 = expand_simple_binop (value->mode, MULT,\n+  tmp1 = expand_simple_binop (value->hvalue.rtl.mode, MULT,\n \t\t\t      copy_rtx (val), GEN_INT (per_counter),\n \t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n   tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp), tmp1, mr,\n \t\t\t      0, OPTAB_WIDEN);\n   if (tmp1 != mr)\n     emit_move_insn (copy_rtx (mr), tmp1);\n \n-  if (value->hdata.intvl.may_be_more\n-      || value->hdata.intvl.may_be_less)\n-    {\n       emit_jump_insn (gen_jump (end_of_code_label));\n       emit_barrier ();\n-    }\n \n   /* Above the interval.  */\n-  if (value->hdata.intvl.may_be_more)\n-    {\n       emit_label (more_label);\n       tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n \t\t\t\t  GEN_INT (per_counter * value->hdata.intvl.steps),\n \t\t\t\t  mr, 0, OPTAB_WIDEN);\n       if (tmp1 != mr)\n \temit_move_insn (copy_rtx (mr), tmp1);\n-      if (value->hdata.intvl.may_be_less)\n-\t{\n \t  emit_jump_insn (gen_jump (end_of_code_label));\n \t  emit_barrier ();\n-\t}\n-    }\n \n   /* Below the interval.  */\n-  if (value->hdata.intvl.may_be_less)\n-    {\n       emit_label (less_label);\n       tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n-\t\tGEN_INT (per_counter * (value->hdata.intvl.steps\n-\t\t\t\t\t+ (value->hdata.intvl.may_be_more ? 1 : 0))),\n+\t\t\tGEN_INT (per_counter * (value->hdata.intvl.steps +1)),\n \t\tmr, 0, OPTAB_WIDEN);\n       if (tmp1 != mr)\n \temit_move_insn (copy_rtx (mr), tmp1);\n-    }\n \n-  if (value->hdata.intvl.may_be_more\n-      || value->hdata.intvl.may_be_less)\n     emit_label (end_of_code_label);\n \n   mem_ref = validize_mem (gen_rtx_MEM (mode, mr));\n@@ -215,32 +176,32 @@ rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   rtx end_of_code_label = gen_label_rtx ();\n   rtx loop_label = gen_label_rtx ();\n   int per_counter = gcov_size / BITS_PER_UNIT;\n-  edge e = split_block (BLOCK_FOR_INSN ((rtx)value->insn),\n-\t\t   PREV_INSN ((rtx)value->insn));\n+  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n+\t\t   PREV_INSN (value->hvalue.rtl.insn));\n \n   start_sequence ();\n \n-  if (value->seq)\n-    emit_insn (value->seq);\n+  if (value->hvalue.rtl.seq)\n+    emit_insn (value->hvalue.rtl.seq);\n \n   mr = gen_reg_rtx (Pmode);\n   tmp = rtl_coverage_counter_ref (tag, base);\n   tmp = force_reg (Pmode, XEXP (tmp, 0));\n   emit_move_insn (mr, tmp);\n \n-  uval = gen_reg_rtx (value->mode);\n-  emit_move_insn (uval, copy_rtx (value->value));\n+  uval = gen_reg_rtx (value->hvalue.rtl.mode);\n+  emit_move_insn (uval, copy_rtx (value->hvalue.rtl.value));\n \n   /* Check for non-power of 2.  */\n   if (value->hdata.pow2.may_be_other)\n     {\n-      do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->mode,\n+      do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->hvalue.rtl.mode,\n \t\t\t       NULL_RTX, NULL_RTX, end_of_code_label);\n-      tmp = expand_simple_binop (value->mode, PLUS, copy_rtx (uval),\n+      tmp = expand_simple_binop (value->hvalue.rtl.mode, PLUS, copy_rtx (uval),\n \t\t\t\t constm1_rtx, NULL_RTX, 0, OPTAB_WIDEN);\n-      tmp = expand_simple_binop (value->mode, AND, copy_rtx (uval), tmp,\n+      tmp = expand_simple_binop (value->hvalue.rtl.mode, AND, copy_rtx (uval), tmp,\n \t\t\t\t NULL_RTX, 0, OPTAB_WIDEN);\n-      do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->mode, NULL_RTX,\n+      do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->hvalue.rtl.mode, NULL_RTX,\n \t\t\t       NULL_RTX, end_of_code_label);\n     }\n \n@@ -251,12 +212,12 @@ rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   if (tmp != mr)\n     emit_move_insn (copy_rtx (mr), tmp);\n \n-  tmp = expand_simple_binop (value->mode, ASHIFTRT, copy_rtx (uval), const1_rtx,\n+  tmp = expand_simple_binop (value->hvalue.rtl.mode, ASHIFTRT, copy_rtx (uval), const1_rtx,\n \t\t\t     uval, 0, OPTAB_WIDEN);\n   if (tmp != uval)\n     emit_move_insn (copy_rtx (uval), tmp);\n \n-  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, NE, 0, value->mode,\n+  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, NE, 0, value->hvalue.rtl.mode,\n \t\t\t   NULL_RTX, NULL_RTX, loop_label);\n \n   /* Increase the counter.  */\n@@ -295,8 +256,8 @@ rtl_gen_one_value_profiler_no_edge_manipulation (histogram_value value,\n \n   start_sequence ();\n \n-  if (value->seq)\n-    emit_insn (value->seq);\n+  if (value->hvalue.rtl.seq)\n+    emit_insn (value->hvalue.rtl.seq);\n \n   stored_value_ref = rtl_coverage_counter_ref (tag, base);\n   counter_ref = rtl_coverage_counter_ref (tag, base + 1);\n@@ -306,7 +267,7 @@ rtl_gen_one_value_profiler_no_edge_manipulation (histogram_value value,\n   all = validize_mem (all_ref);\n \n   uval = gen_reg_rtx (mode);\n-  convert_move (uval, copy_rtx (value->value), 0);\n+  convert_move (uval, copy_rtx (value->hvalue.rtl.value), 0);\n \n   /* Check if the stored value matches.  */\n   do_compare_rtx_and_jump (copy_rtx (uval), copy_rtx (stored_value), EQ,\n@@ -362,8 +323,8 @@ rtl_gen_one_value_profiler_no_edge_manipulation (histogram_value value,\n static void\n rtl_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  edge e = split_block (BLOCK_FOR_INSN ((rtx)value->insn),\n-\t\t   PREV_INSN ((rtx)value->insn));\n+  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n+\t\t   PREV_INSN (value->hvalue.rtl.insn));\n   rtx sequence = rtl_gen_one_value_profiler_no_edge_manipulation (value, \n \t\t\ttag, base);\n   rebuild_jump_labels (sequence);\n@@ -383,28 +344,28 @@ rtl_gen_const_delta_profiler (histogram_value value, unsigned tag, unsigned base\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n   rtx stored_value_ref, stored_value, tmp, uval;\n   rtx sequence;\n-  edge e = split_block (BLOCK_FOR_INSN ((rtx)value->insn),\n-\t\t   PREV_INSN ((rtx)value->insn));\n+  edge e = split_block (BLOCK_FOR_INSN (value->hvalue.rtl.insn),\n+\t\t   PREV_INSN (value->hvalue.rtl.insn));\n \n   start_sequence ();\n \n-  if (value->seq)\n-    emit_insn (value->seq);\n+  if (value->hvalue.rtl.seq)\n+    emit_insn (value->hvalue.rtl.seq);\n \n   stored_value_ref = rtl_coverage_counter_ref (tag, base);\n   stored_value = validize_mem (stored_value_ref);\n \n   uval = gen_reg_rtx (mode);\n-  convert_move (uval, copy_rtx (value->value), 0);\n+  convert_move (uval, copy_rtx (value->hvalue.rtl.value), 0);\n   tmp = expand_simple_binop (mode, MINUS,\n \t\t\t     copy_rtx (uval), copy_rtx (stored_value),\n \t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n \n   one_value_delta = ggc_alloc (sizeof (*one_value_delta));\n-  one_value_delta->value = tmp;\n-  one_value_delta->mode = mode;\n-  one_value_delta->seq = NULL_RTX;\n-  one_value_delta->insn = value->insn;\n+  one_value_delta->hvalue.rtl.value = tmp;\n+  one_value_delta->hvalue.rtl.mode = mode;\n+  one_value_delta->hvalue.rtl.seq = NULL_RTX;\n+  one_value_delta->hvalue.rtl.insn = value->hvalue.rtl.insn;\n   one_value_delta->type = HIST_TYPE_SINGLE_VALUE;\n   emit_insn (rtl_gen_one_value_profiler_no_edge_manipulation (one_value_delta,\n \t\t\t\t\t\t\t      tag, base + 1));"}, {"sha": "7c8723ca5e3fd3a75367dbcf4cb8fde2035877a6", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -1773,9 +1773,6 @@ process_options (void)\n     warning (\"this target machine does not have delayed branches\");\n #endif\n \n-  if (flag_tree_based_profiling && flag_profile_values)\n-    sorry (\"value-based profiling not yet implemented in trees.\");\n-\n   user_label_prefix = USER_LABEL_PREFIX;\n   if (flag_leading_underscore != -1)\n     {"}, {"sha": "ea08f7ad79ef7abb5b63082c4eac72491b9d8274", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -309,6 +309,12 @@ struct stmt_ann_d GTY(())\n      by each pass on an as-needed basis in any order convenient for the\n      pass which needs statement UIDs.  */\n   unsigned int uid;\n+\n+  /* Linked list of histograms for value-based profiling.  This is really a\n+     struct histogram_value*.  We use void* to avoid having to export that\n+     everywhere, and to avoid having to put it in GC memory.  */\n+  \n+  void * GTY ((skip (\"\"))) histograms;\n };\n \n union tree_ann_d GTY((desc (\"ann_type ((tree_ann_t)&%h)\")))"}, {"sha": "4f6b792c3699f09acb91743f846cea8373b17fb2", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 473, "deletions": 50, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -24,30 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* Generate basic block profile instrumentation and auxiliary files.\n-   Profile generation is optimized, so that not all arcs in the basic\n-   block graph need instrumenting. First, the BB graph is closed with\n-   one entry (function start), and one exit (function exit).  Any\n-   ABNORMAL_EDGE cannot be instrumented (because there is no control\n-   path to place the code). We close the graph by inserting fake\n-   EDGE_FAKE edges to the EXIT_BLOCK, from the sources of abnormal\n-   edges that do not go to the exit_block. We ignore such abnormal\n-   edges.  Naturally these fake edges are never directly traversed,\n-   and so *cannot* be directly instrumented.  Some other graph\n-   massaging is done. To optimize the instrumentation we generate the\n-   BB minimal span tree, only edges that are not on the span tree\n-   (plus the entry point) need instrumenting. From that information\n-   all other edge counts can be deduced.  By construction all fake\n-   edges must be on the spanning tree. We also attempt to place\n-   EDGE_CRITICAL edges on the spanning tree.\n-\n-   The auxiliary file generated is <dumpbase>.bbg. The format is\n-   described in full in gcov-io.h.  */\n-\n-/* ??? Register allocation should use basic block execution counts to\n-   give preference to the most commonly executed blocks.  */\n-\n-/* ??? Should calculate branch probabilities before instrumenting code, since\n-   then we can use arc counts to help decide which arcs to instrument.  */\n+   Tree-based version.  See profile.c for overview.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -102,47 +79,477 @@ tree_gen_edge_profiler (int edgeno, edge e)\n    tag of the section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_interval_profiler (histogram_value value ATTRIBUTE_UNUSED, \n-\t\t\t    unsigned tag ATTRIBUTE_UNUSED, \n-\t\t\t    unsigned base ATTRIBUTE_UNUSED)\n+tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  /* FIXME implement this.  */\n-#ifdef ENABLE_CHECKING\n-  internal_error (\"unimplemented functionality\");\n-#endif\n-  gcc_unreachable ();\n+  tree op, op1, op2, op1copy, op2copy;\n+  tree tmp1, tmp2, tmp3, val, index;\n+  tree label_decl2, label_decl3, label_decl4, label_decl5, label_decl6;\n+  edge e12, e23, e34, e45, e56;\n+  tree label2, label3, label4, label5, label6;\n+  tree stmt1, stmt2, stmt3, stmt4;\n+  /* Initializations are to prevent bogus uninitialized warnings. */\n+  tree bb1end = NULL_TREE, bb2end = NULL_TREE, bb3end = NULL_TREE;\n+  tree bb4end = NULL_TREE, bb5end = NULL_TREE;\n+  tree ref = tree_coverage_counter_ref (tag, base), ref2;\n+  basic_block bb2, bb3, bb4, bb5, bb6;\n+  tree stmt = value->hvalue.tree.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  basic_block bb = bb_for_stmt (stmt);\n+  tree optype;\n+\n+  op = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    op = TREE_OPERAND (stmt, 0);\n+  /* op == MODIFY_EXPR */\n+  op = TREE_OPERAND (op, 1);\n+  /* op == TRUNC_DIV or TRUNC_MOD */\n+  op1 = TREE_OPERAND (op, 0);\n+  op2 = TREE_OPERAND (op, 1);\n+  optype = TREE_TYPE (op);\n+\n+  /* Blocks:\n+     Original = 1 \n+     For 2nd compare = 2\n+     Normal case, neither more nor less = 3\n+     More = 4\n+     Less = 5\n+     End = 6  */\n+  label_decl2 = create_artificial_label ();\n+  label_decl3 = create_artificial_label ();\n+  label_decl4 = create_artificial_label ();\n+  label_decl5 = create_artificial_label ();\n+  label_decl6 = create_artificial_label ();\n+\n+  /* Do not evaluate op1 or op2 more than once.  Probably\n+     volatile loads are the only things that could cause\n+     a problem, but this is harmless in any case.  */\n+  op1copy = create_tmp_var (optype, \"PROF\");\n+  op2copy = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, op1copy, op1);\n+  stmt2 = build2 (MODIFY_EXPR, optype, op2copy, op2);\n+  TREE_OPERAND (op, 0) = op1copy;\n+  TREE_OPERAND (op, 1) = op2copy;\n+\n+  val = create_tmp_var (optype, \"PROF\");\n+  stmt3 = build2 (MODIFY_EXPR, optype, val,\n+\t\t  build2 (TRUNC_DIV_EXPR, optype, op1copy, op2copy));\n+  stmt4 = build2 (MODIFY_EXPR, optype, val,\n+\t\t  build2 (MINUS_EXPR, optype, val,\n+\t\t\t\tbuild_int_cst (optype, value->hdata.intvl.int_start)));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+\n+  index = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+\n+  /* Check for too big.  */\n+  stmt1 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (GE_EXPR, boolean_type_node, val,\n+\t\t\tbuild_int_cst (optype, value->hdata.intvl.steps)),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl4),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl2));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb1end = stmt1;\n+\n+  /* Check for too small.  */\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  stmt1 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (LT_EXPR, boolean_type_node, val, integer_zero_node),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl5),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl3));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb2end = stmt1;\n+\n+  /* Normal case, within range. */\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, index, \n+\t\t    build1 (NOP_EXPR, GCOV_TYPE_NODE, val));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb3end = stmt1;\n+\n+  /* Too big */\n+  label4 = build1 (LABEL_EXPR, void_type_node, label_decl4);\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, index, \n+\t\t    build_int_cst (GCOV_TYPE_NODE, value->hdata.intvl.steps));\n+  bsi_insert_before (&bsi, label4, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb4end = stmt1;\n+\n+  /* Too small */\n+  label5 = build1 (LABEL_EXPR, void_type_node, label_decl5);\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, index, \n+\t\t    build_int_cst (GCOV_TYPE_NODE, value->hdata.intvl.steps + 1));\n+  bsi_insert_before (&bsi, label5, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb5end = stmt1;\n+\n+  /* Increment appropriate counter. */\n+  label6 = build1 (LABEL_EXPR, void_type_node, label_decl6);\n+  bsi_insert_before (&bsi, label6, BSI_SAME_STMT);\n+\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp3 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, \n+\t\t    build2 (PLUS_EXPR, GCOV_TYPE_NODE, index, \n+\t\t\t    TREE_OPERAND (ref, 1)));\n+  TREE_OPERAND (ref, 1) = tmp1;\n+  /* Make a copy to avoid sharing complaints. */\n+  ref2 = build4 (ARRAY_REF, TREE_TYPE (ref), TREE_OPERAND (ref, 0), \n+\t\tTREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2), \n+\t\tTREE_OPERAND (ref, 3));\n+\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2, ref);\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp3, \n+\t\t    build2 (PLUS_EXPR, GCOV_TYPE_NODE, tmp2, integer_one_node));\n+  stmt4 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref2, tmp3);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+\n+  /* Now fix up the CFG. */\n+  /* 1->2,4; 2->3,5; 3->6; 4->6; 5->6 */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  e23 = split_block (bb2, bb2end);\n+  bb3 = e23->dest;\n+  e34 = split_block (bb3, bb3end);\n+  bb4 = e34->dest;\n+  e45 = split_block (bb4, bb4end);\n+  bb5 = e45->dest;\n+  e56 = split_block (bb5, bb5end);\n+  bb6 = e56->dest;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb, bb4, EDGE_TRUE_VALUE);\n+  e23->flags &= ~EDGE_FALLTHRU;\n+  e23->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb2, bb5, EDGE_TRUE_VALUE);\n+  remove_edge (e34);\n+  make_edge (bb3, bb6, EDGE_FALLTHRU);\n+  remove_edge (e45);\n+  make_edge (bb4, bb6, EDGE_FALLTHRU);\n }\n \n /* Output instructions as GIMPLE trees to increment the power of two histogram \n    counter.  VALUE is the expression whose value is profiled.  TAG is the tag \n    of the section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_pow2_profiler (histogram_value value ATTRIBUTE_UNUSED, \n-\t\t\tunsigned tag ATTRIBUTE_UNUSED,\n-\t\t\tunsigned base ATTRIBUTE_UNUSED)\n+tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  /* FIXME implement this.  */\n-#ifdef ENABLE_CHECKING\n-  internal_error (\"unimplemented functionality\");\n-#endif\n-  gcc_unreachable ();\n+  tree op;\n+  tree tmp1, tmp2, tmp3;\n+  tree index, denom;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label1, label2, label3;\n+  tree stmt1, stmt2, stmt3, stmt4;\n+  tree bb1end, bb2end, bb3end;\n+  tree ref = tree_coverage_counter_ref (tag, base), ref2;\n+  basic_block bb2, bb3, bb4;\n+  tree stmt = value->hvalue.tree.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  basic_block bb = bb_for_stmt (stmt);\n+  tree optype, optypesigned, optypeunsigned;\n+\n+  op = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    op = TREE_OPERAND (stmt, 0);\n+  /* op == MODIFY_EXPR */\n+  op = TREE_OPERAND (op, 1);\n+  /* op == TRUNC_DIV or TRUNC_MOD */\n+  op = TREE_OPERAND (op, 1);\n+  /* op == denominator */\n+  optype = TREE_TYPE (op);\n+  if (TYPE_UNSIGNED (optype))\n+    {\n+      /* Right shift must be unsigned. */\n+      optypeunsigned = optype;\n+      optypesigned = build_distinct_type_copy (optype);\n+      TYPE_UNSIGNED (optypesigned) = false;\n+    }\n+  else\n+    {\n+      /* Compare to zero must be signed. */\n+      optypesigned = optype;\n+      optypeunsigned = build_distinct_type_copy (optype);\n+      TYPE_UNSIGNED (optypeunsigned) = true;\n+    }\n+\n+  /* Set up variables and check if denominator is negative when considered\n+     as signed.  */\n+  index = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  denom = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, index, integer_zero_node);\n+  stmt2 = build2 (MODIFY_EXPR, optype, denom, op);\n+  if (optypesigned == optype)\n+    {\n+      tmp1 = denom;\n+      stmt3 = NULL_TREE;\n+    }\n+  else\n+    {\n+      tmp1 = create_tmp_var (optypesigned, \"PROF\");\n+      stmt3 = build2 (MODIFY_EXPR, optypesigned, tmp1,\n+\t\t\t    build1 (NOP_EXPR, optypesigned, denom));\n+    }\n+  stmt4 = build3 (COND_EXPR, void_type_node,\n+\t\tbuild2 (LE_EXPR, boolean_type_node, tmp1, integer_zero_node),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  if (stmt3)\n+    bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+  bb1end = stmt4;\n+\n+  /* Nonnegative.  Check if denominator is power of 2. */\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  tmp2 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmp1,\n+\t\t    build2 (PLUS_EXPR, optype, denom, integer_minus_one_node));\n+  stmt2 = build2 (MODIFY_EXPR, optype, tmp2,\n+\t\t    build2 (BIT_AND_EXPR, optype, tmp1, denom));\n+  stmt3 = build3 (COND_EXPR, void_type_node, \n+\t\tbuild2 (NE_EXPR, boolean_type_node, tmp2, integer_zero_node),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb2end = stmt3;\n+\n+  /* Loop.  Increment index, shift denominator, repeat if denominator nonzero. */\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, index, \n+\t\t    build2 (PLUS_EXPR, GCOV_TYPE_NODE, index, integer_one_node));\n+  if (optypeunsigned == optype)\n+    {\n+      tmp1 = denom;\n+      stmt2 = NULL_TREE;\n+    }\n+  else\n+    {\n+      tmp1 = create_tmp_var (optypeunsigned, \"PROF\");\n+      stmt2 = build2 (MODIFY_EXPR, optypeunsigned, tmp1,\n+\t\t\tbuild1 (NOP_EXPR, optypeunsigned, denom));\n+    }\n+  stmt3 = build2 (MODIFY_EXPR, optype, denom,\n+\t\t    build2 (RSHIFT_EXPR, optype, tmp1, integer_one_node));\n+  stmt4 = build3 (COND_EXPR, void_type_node, \n+\t\tbuild2 (NE_EXPR, boolean_type_node, denom, integer_zero_node),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3));\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  if (stmt2)\n+    bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+  bb3end = stmt4;\n+\n+  /* Increment the appropriate counter.  */\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp3 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, \n+\t\t    build2 (PLUS_EXPR, GCOV_TYPE_NODE, index, TREE_OPERAND (ref, 1)));\n+  TREE_OPERAND (ref, 1) = tmp1;\n+  /* Make a copy to avoid sharing complaints. */\n+  ref2 = build4 (ARRAY_REF, TREE_TYPE (ref), TREE_OPERAND (ref, 0), \n+\t\tTREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2, ref);\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp3, \n+\t\t    build2 (PLUS_EXPR, GCOV_TYPE_NODE, tmp2, integer_one_node));\n+  stmt4 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref2, tmp3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+\n+  /* Now fix up the CFG. */\n+  bb2 = (split_block (bb, bb1end))->dest;\n+  bb3 = (split_block (bb2, bb2end))->dest;\n+  bb4 = (split_block (bb3, bb3end))->dest;\n+\n+  EDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n+  EDGE_SUCC (bb, 0)->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb, bb4, EDGE_TRUE_VALUE);\n+\n+  EDGE_SUCC (bb2, 0)->flags &= ~EDGE_FALLTHRU;\n+  EDGE_SUCC (bb2, 0)->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n+\n+  EDGE_SUCC (bb3, 0)->flags &= ~EDGE_FALLTHRU;\n+  EDGE_SUCC (bb3, 0)->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb3, bb3, EDGE_TRUE_VALUE);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value.\n    VALUE is the expression whose value is profiled.  TAG is the tag of the\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_one_value_profiler (histogram_value value ATTRIBUTE_UNUSED, \n-\t\t\t    unsigned tag ATTRIBUTE_UNUSED,\n-\t\t\t    unsigned base ATTRIBUTE_UNUSED)\n+tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  /* FIXME implement this.  */\n-#ifdef ENABLE_CHECKING\n-  internal_error (\"unimplemented functionality\");\n-#endif\n-  gcc_unreachable ();\n+  tree op;\n+  tree tmp1, tmp2, tmp3;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label_decl4 = create_artificial_label ();\n+  tree label_decl5 = create_artificial_label ();\n+  tree label1, label2, label3, label4, label5;\n+  tree stmt1, stmt2, stmt3, stmt4;\n+  tree bb1end, bb2end, bb3end, bb4end, bb5end;\n+  tree ref1 = tree_coverage_counter_ref (tag, base);\n+  tree ref2 = tree_coverage_counter_ref (tag, base + 1);\n+  tree ref3 = tree_coverage_counter_ref (tag, base + 2);\n+  basic_block bb2, bb3, bb4, bb5, bb6;\n+  tree stmt = value->hvalue.tree.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  basic_block bb = bb_for_stmt (stmt);\n+  tree optype;\n+\n+  op = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    op = TREE_OPERAND (stmt, 0);\n+  /* op == MODIFY_EXPR */\n+  op = TREE_OPERAND (op, 1);\n+  /* op == TRUNC_DIV or TRUNC_MOD */\n+  op = TREE_OPERAND (op, 1);\n+  /* op == denominator */\n+  optype = TREE_TYPE (op);\n+\n+  /* Check if the stored value matches. */\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (optype, \"PROF\");\n+  tmp3 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, ref1);\n+  stmt2 = build2 (MODIFY_EXPR, optype, tmp2, \n+\t\t    build1 (NOP_EXPR, optype, tmp1));\n+  stmt3 = build2 (MODIFY_EXPR, optype, tmp3, op);\n+  stmt4 = build3 (COND_EXPR, void_type_node, \n+\t\tbuild2 (EQ_EXPR, boolean_type_node, tmp2, tmp3),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl4),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+  bb1end = stmt4;\n+\n+  /* Does not match; check whether the counter is zero. */\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, ref2);\n+  stmt2 = build3 (COND_EXPR, void_type_node, \n+\t\tbuild2 (EQ_EXPR, boolean_type_node, tmp1, integer_zero_node),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3), \n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bb2end = stmt2;\n+\n+  /* Counter is not zero yet, decrement. */\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, ref2);\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2,\n+\t\t      build (MINUS_EXPR, GCOV_TYPE_NODE, \n+\t\t\t     tmp1, integer_one_node));\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref2, tmp2);\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb3end = stmt3;\n+\n+  /* Counter was zero, store new value. */\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmp1, op);\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2, \n+\t\t\tbuild1 (NOP_EXPR, GCOV_TYPE_NODE, tmp1));\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref1, tmp2);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb4end = stmt3;\n+  /* (fall through) */\n+\n+  /* Increment counter.  */\n+  label4 = build1 (LABEL_EXPR, void_type_node, label_decl4);\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, ref2);\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2,\n+\t\t      build (PLUS_EXPR, GCOV_TYPE_NODE, \n+\t\t\t     tmp1, integer_one_node));\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref2, tmp2);\n+  bsi_insert_before (&bsi, label4, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb5end = stmt3;\n+\n+  /* Increment the counter of all executions; this seems redundant given\n+     that we have counts for edges in cfg, but it may happen that some\n+     optimization will change the counts for the block (either because\n+     it is unable to update them correctly, or because it will duplicate\n+     the block or its part).  */\n+  label5 = build1 (LABEL_EXPR, void_type_node, label_decl5);\n+  tmp1 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  tmp2 = create_tmp_var (GCOV_TYPE_NODE, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp1, ref3);\n+  stmt2 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, tmp2,\n+\t\t      build (PLUS_EXPR, GCOV_TYPE_NODE, \n+\t\t\t     tmp1, integer_one_node));\n+  stmt3 = build2 (MODIFY_EXPR, GCOV_TYPE_NODE, ref3, tmp2);\n+  bsi_insert_before (&bsi, label5, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+\n+  /* Now fix up the CFG. */\n+  bb2 = (split_block (bb, bb1end))->dest;\n+  bb3 = (split_block (bb2, bb2end))->dest;\n+  bb4 = (split_block (bb3, bb3end))->dest;\n+  bb5 = (split_block (bb4, bb4end))->dest;\n+  bb6 = (split_block (bb5, bb5end))->dest;\n+\n+  EDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n+  EDGE_SUCC (bb, 0)->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb, bb5, EDGE_TRUE_VALUE);\n+\n+  EDGE_SUCC (bb2, 0)->flags &= ~EDGE_FALLTHRU;\n+  EDGE_SUCC (bb2, 0)->flags |= EDGE_FALSE_VALUE;\n+  make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n+\n+  remove_edge (EDGE_SUCC (bb3, 0));\n+  make_edge (bb3, bb6, EDGE_FALLTHRU);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value \n@@ -166,7 +573,8 @@ tree_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n    If it is, set up hooks for tree-based profiling.\n    Gate for pass_tree_profile.  */\n \n-static bool do_tree_profiling (void)\n+static bool\n+do_tree_profiling (void)\n {\n   if (flag_tree_based_profiling\n       && (profile_arc_flag || flag_test_coverage || flag_branch_probabilities))\n@@ -184,11 +592,26 @@ static FILE *tree_profile_dump_file (void) {\n   return dump_file;\n }\n \n+static void\n+tree_profiling (void)\n+{\n+  branch_prob ();\n+  if (flag_branch_probabilities\n+      && flag_profile_values\n+      && flag_value_profile_transformations)\n+    value_profile_transformations ();\n+  /* The above could hose dominator info.  Currently there is\n+     none coming in, this is a safety valve.  It should be\n+     easy to adjust it, if and when there is some.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n struct tree_opt_pass pass_tree_profile = \n {\n   \"tree_profile\",\t\t\t/* name */\n   do_tree_profiling,\t\t\t/* gate */\n-  branch_prob,\t\t\t\t/* execute */\n+  tree_profiling,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */"}, {"sha": "4712b523824e9d61bbae697cf43d0199e4bb2de5", "filename": "gcc/value-prof.c", "status": "modified", "additions": 825, "deletions": 80, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -34,9 +34,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"optabs.h\"\n #include \"regs.h\"\n #include \"ggc.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-flow-inline.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"gcov-io.h\"\n \n static struct value_prof_hooks *value_prof_hooks;\n \n+/* This is the vector of histograms.  Created in find_values_to_profile.\n+   During profile generation, freed by instrument_values.\n+   During profile use, freed by value_profile_transformations.  */\n+\n+static histogram_values static_values = NULL;\n+\n /* In this file value profile based optimizations are placed.  Currently the\n    following optimizations are implemented (for more detailed descriptions\n    see comments at value_profile_transformations):\n@@ -53,19 +64,38 @@ static struct value_prof_hooks *value_prof_hooks;\n    in profile.c and the requested values are instrumented by it in the first\n    compilation with -fprofile-arcs.  The optimization may then read the\n    gathered data in the second compilation with -fbranch-probabilities.\n-   The measured data is appended as REG_VALUE_PROFILE note to the instrumented\n-   insn.  The argument to the note consists of an EXPR_LIST where its\n-   members have the following meaning (from the first to the last):\n+\n+   There are currently two versions, RTL-based and tree-based.  Over time\n+   the RTL-based version may go away.  \n+\n+   In the RTL-based version, the measured data is appended as REG_VALUE_PROFILE \n+   note to the instrumented insn.  The argument to the note consists of an\n+   EXPR_LIST where its members have the following meaning (from the first to \n+   the last):\n    \n    -- type of information gathered (HIST_TYPE*)\n    -- the expression that is profiled\n-   -- list of counters starting from the first one.  */\n+   -- list of counters starting from the first one.\n+\n+   In the tree-based version, the measured data is pointed to from the histograms\n+   field of the statement annotation of the instrumented insns.  It is\n+   kept as a linked list of struct histogram_value_t's, which contain the\n+   same information as above.  */\n \n /* For speculative prefetching, the range in that we do not prefetch (because\n    we assume that it will be in cache anyway).  The asymmetry between min and\n    max range is trying to reflect the fact that the sequential prefetching\n    of the data is commonly done directly by hardware.  Nevertheless, these\n-   values are just a guess and should of course be target-specific.  */\n+   values are just a guess and should of course be target-specific.  \n+\n+   FIXME:  There is no tree form of speculative prefetching as yet.\n+\n+   FIXME:  A better approach to instrumentation in the profile-generation\n+   pass is to generate calls to magic library functions (to be added to\n+   libgcc) rather than inline code.  This approach will probably be\n+   necessary to get tree-based speculative prefetching working in a useful\n+   fashion, as inline code bloats things so much the rest of the compiler has\n+   serious problems dealing with it (judging from the rtl behavior).  */\n \n #ifndef NOPREFETCH_RANGE_MIN\n #define NOPREFETCH_RANGE_MIN (-16)\n@@ -74,34 +104,45 @@ static struct value_prof_hooks *value_prof_hooks;\n #define NOPREFETCH_RANGE_MAX 32\n #endif\n \n-static void insn_divmod_values_to_profile (rtx, histogram_values *);\n+static void rtl_divmod_values_to_profile (rtx, histogram_values *);\n #ifdef HAVE_prefetch\n static bool insn_prefetch_values_to_profile (rtx, histogram_values *);\n static int find_mem_reference_1 (rtx *, void *);\n static void find_mem_reference_2 (rtx, rtx, void *);\n static bool find_mem_reference (rtx, rtx *, int *);\n #endif\n \n-static void insn_values_to_profile (rtx, histogram_values *);\n-static rtx gen_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n+static void rtl_values_to_profile (rtx, histogram_values *);\n+static rtx rtl_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n \t\t\t\t   rtx, gcov_type, int);\n-static rtx gen_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx, int);\n-static rtx gen_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n+static rtx rtl_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx, int);\n+static rtx rtl_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n \t\t\t     int, int, int);\n #ifdef HAVE_prefetch\n static rtx gen_speculative_prefetch (rtx, gcov_type, int);\n #endif\n-static bool divmod_fixed_value_transform (rtx insn);\n-static bool mod_pow2_value_transform (rtx);\n-static bool mod_subtract_transform (rtx);\n+static bool rtl_divmod_fixed_value_transform (rtx);\n+static bool rtl_mod_pow2_value_transform (rtx);\n+static bool rtl_mod_subtract_transform (rtx);\n #ifdef HAVE_prefetch\n static bool speculative_prefetching_transform (rtx);\n #endif\n+static void tree_divmod_values_to_profile (tree, histogram_values *);\n+static void tree_values_to_profile (tree, histogram_values *);\n+static tree tree_divmod_fixed_value (tree, tree, tree, tree, \n+\t\t\t\t    tree, int, gcov_type, gcov_type);\n+static tree tree_mod_pow2 (tree, tree, tree, tree, int, gcov_type, gcov_type);\n+static tree tree_mod_subtract (tree, tree, tree, tree, int, int, int,\n+\t\t\t\tgcov_type, gcov_type, gcov_type);\n+static bool tree_divmod_fixed_value_transform (tree);\n+static bool tree_mod_pow2_value_transform (tree);\n+static bool tree_mod_subtract_transform (tree);\n+\n \f\n /* Find values inside INSN for that we want to measure histograms for\n    division/modulo optimization and stores them to VALUES.  */\n static void\n-insn_divmod_values_to_profile (rtx insn, histogram_values *values)\n+rtl_divmod_values_to_profile (rtx insn, histogram_values *values)\n {\n   rtx set, set_src, op1, op2;\n   enum machine_mode mode;\n@@ -134,10 +175,10 @@ insn_divmod_values_to_profile (rtx insn, histogram_values *values)\n       if ((GET_CODE (set_src) == UMOD) && !CONSTANT_P (op2))\n \t{\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->value = op2;\n-\t  hist->seq = NULL_RTX;\n-\t  hist->mode = mode;\n-\t  hist->insn = insn;\n+\t  hist->hvalue.rtl.value = op2;\n+\t  hist->hvalue.rtl.seq = NULL_RTX;\n+\t  hist->hvalue.rtl.mode = mode;\n+\t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_POW2;\n \t  hist->hdata.pow2.may_be_other = 1;\n \t  VEC_safe_push (histogram_value, *values, hist);\n@@ -147,10 +188,10 @@ insn_divmod_values_to_profile (rtx insn, histogram_values *values)\n       if (!CONSTANT_P (op2))\n \t{\n \t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->value = op2;\n-\t  hist->mode = mode;\n-\t  hist->seq = NULL_RTX;\n-\t  hist->insn = insn;\n+\t  hist->hvalue.rtl.value = op2;\n+\t  hist->hvalue.rtl.mode = mode;\n+\t  hist->hvalue.rtl.seq = NULL_RTX;\n+\t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_SINGLE_VALUE;\n \t  VEC_safe_push (histogram_value, *values, hist);\n \t}\n@@ -164,16 +205,14 @@ insn_divmod_values_to_profile (rtx insn, histogram_values *values)\n \t  hist = ggc_alloc (sizeof (*hist));\n \t  start_sequence ();\n \t  tmp = simplify_gen_binary (DIV, mode, copy_rtx (op1), copy_rtx (op2));\n-\t  hist->value = force_operand (tmp, NULL_RTX);\n-\t  hist->seq = get_insns ();\n+\t  hist->hvalue.rtl.value = force_operand (tmp, NULL_RTX);\n+\t  hist->hvalue.rtl.seq = get_insns ();\n \t  end_sequence ();\n-\t  hist->mode = mode;\n-\t  hist->insn = insn;\n+\t  hist->hvalue.rtl.mode = mode;\n+\t  hist->hvalue.rtl.insn = insn;\n \t  hist->type = HIST_TYPE_INTERVAL;\n \t  hist->hdata.intvl.int_start = 0;\n \t  hist->hdata.intvl.steps = 2;\n-\t  hist->hdata.intvl.may_be_less = 1;\n-\t  hist->hdata.intvl.may_be_more = 1;\n \t  VEC_safe_push (histogram_value, *values, hist);\n \t}\n       return;\n@@ -239,7 +278,7 @@ find_mem_reference (rtx insn, rtx *mem, int *write)\n    Returns true if such we found any such value, false otherwise.  */\n \n static bool\n-insn_prefetch_values_to_profile (rtx insn, histogram_values *values)\n+insn_prefetch_values_to_profile (rtx insn, histogram_values* values)\n {\n   rtx mem, address;\n   int write;\n@@ -260,10 +299,10 @@ insn_prefetch_values_to_profile (rtx insn, histogram_values *values)\n     return false;\n \n   hist = ggc_alloc (sizeof (*hist));\n-  hist->value = address;\n-  hist->mode = GET_MODE (address);\n-  hist->seq = NULL_RTX;\n-  hist->insn = insn;\n+  hist->hvalue.rtl.value = address;\n+  hist->hvalue.rtl.mode = GET_MODE (address);\n+  hist->hvalue.rtl.seq = NULL_RTX;\n+  hist->hvalue.rtl.insn = insn;\n   hist->type = HIST_TYPE_CONST_DELTA;\n   VEC_safe_push (histogram_value, *values, hist);\n \n@@ -273,10 +312,10 @@ insn_prefetch_values_to_profile (rtx insn, histogram_values *values)\n /* Find values inside INSN for that we want to measure histograms and adds\n    them to list VALUES (increasing the record of its length in N_VALUES).  */\n static void\n-insn_values_to_profile (rtx insn, histogram_values *values)\n+rtl_values_to_profile (rtx insn, histogram_values *values)\n {\n   if (flag_value_profile_transformations)\n-    insn_divmod_values_to_profile (insn, values);\n+    rtl_divmod_values_to_profile (insn, values);\n \n #ifdef HAVE_prefetch\n   if (flag_speculative_prefetching)\n@@ -296,23 +335,8 @@ rtl_find_values_to_profile (histogram_values *values)\n   *values = VEC_alloc (histogram_value, 0);\n   libcall_level = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\tlibcall_level++;\n-\n-      /* Do not instrument values inside libcalls (we are going to split block\n-\t due to instrumentation, and libcall blocks should be local to a single\n-\t basic block).  */\n-      if (!libcall_level)\n-\tinsn_values_to_profile (insn, values);\n-\n-      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t{\n-\t  gcc_assert (libcall_level > 0);\n-\t  libcall_level--;\n-\t}\n-    }\n-  gcc_assert (libcall_level == 0);\n+    rtl_values_to_profile (insn, values);\n+  static_values = *values;\n \n   for (i = 0; i < VEC_length (histogram_value, *values); i++)\n     {\n@@ -324,38 +348,36 @@ rtl_find_values_to_profile (histogram_values *values)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Interval counter for insn %d, range %d -- %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->insn),\n+\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn),\n \t\t     hist->hdata.intvl.int_start,\n \t\t     (hist->hdata.intvl.int_start\n \t\t      + hist->hdata.intvl.steps - 1));\n-\t  hist->n_counters = hist->hdata.intvl.steps +\n-\t\t  (hist->hdata.intvl.may_be_less ? 1 : 0) +\n-\t\t  (hist->hdata.intvl.may_be_more ? 1 : 0);\n+\t  hist->n_counters = hist->hdata.intvl.steps + 2;\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Pow2 counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->insn));\n+\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n \t  hist->n_counters \n-\t\t= GET_MODE_BITSIZE (hist->mode)\n+\t\t= GET_MODE_BITSIZE (hist->hvalue.rtl.mode)\n \t\t  +  (hist->hdata.pow2.may_be_other ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Single value counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->insn));\n+\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n \t  hist->n_counters = 3;\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Constant delta counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)hist->insn));\n+\t\t     INSN_UID ((rtx)hist->hvalue.rtl.insn));\n \t  hist->n_counters = 4;\n \t  break;\n \n@@ -493,9 +515,9 @@ rtl_value_profile_transformations (void)\n \n       /* Transformations:  */\n       if (flag_value_profile_transformations\n-\t  && (mod_subtract_transform (insn)\n-\t      || divmod_fixed_value_transform (insn)\n-\t      || mod_pow2_value_transform (insn)))\n+\t  && (rtl_mod_subtract_transform (insn)\n+\t      || rtl_divmod_fixed_value_transform (insn)\n+\t      || rtl_mod_pow2_value_transform (insn)))\n \tchanged = true;\n #ifdef HAVE_prefetch\n       if (flag_speculative_prefetching\n@@ -517,7 +539,7 @@ rtl_value_profile_transformations (void)\n    and OP2, whose value is expected to be VALUE, result TARGET and\n    probability of taking the optimal path PROB).  */\n static rtx\n-gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n+rtl_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n \t\t\trtx target, rtx op1, rtx op2, gcov_type value,\n \t\t\tint prob)\n {\n@@ -571,7 +593,7 @@ gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n \n /* Do transform 1) on INSN if applicable.  */\n static bool\n-divmod_fixed_value_transform (rtx insn)\n+rtl_divmod_fixed_value_transform (rtx insn)\n {\n   rtx set, set_src, set_dest, op1, op2, value, histogram;\n   enum rtx_code code;\n@@ -630,7 +652,7 @@ divmod_fixed_value_transform (rtx insn)\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_divmod_fixed_value (mode, code, set_dest,\n+\trtl_divmod_fixed_value (mode, code, set_dest,\n \t\t\t\top1, op2, val, prob), e);\n \n   return true;\n@@ -639,7 +661,7 @@ divmod_fixed_value_transform (rtx insn)\n /* Generate code for transformation 2 (with MODE and OPERATION, operands OP1\n    and OP2, result TARGET and probability of taking the optimal path PROB).  */\n static rtx\n-gen_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n+rtl_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n \t      rtx op1, rtx op2, int prob)\n {\n   rtx tmp, tmp1, tmp2, tmp3, jump;\n@@ -693,7 +715,7 @@ gen_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n \n /* Do transform 2) on INSN if applicable.  */\n static bool\n-mod_pow2_value_transform (rtx insn)\n+rtl_mod_pow2_value_transform (rtx insn)\n {\n   rtx set, set_src, set_dest, op1, op2, value, histogram;\n   enum rtx_code code;\n@@ -758,7 +780,7 @@ mod_pow2_value_transform (rtx insn)\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_mod_pow2 (mode, code, set_dest, op1, op2, prob), e);\n+\trtl_mod_pow2 (mode, code, set_dest, op1, op2, prob), e);\n \n   return true;\n }\n@@ -767,7 +789,7 @@ mod_pow2_value_transform (rtx insn)\n    operands OP1 and OP2, result TARGET, at most SUB subtractions, and\n    probability of taking the optimal path(s) PROB1 and PROB2).  */\n static rtx\n-gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n+rtl_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n \t\t  rtx target, rtx op1, rtx op2, int sub, int prob1, int prob2)\n {\n   rtx tmp, tmp1, jump;\n@@ -824,7 +846,7 @@ gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n \n /* Do transforms 3) and 4) on INSN if applicable.  */\n static bool\n-mod_subtract_transform (rtx insn)\n+rtl_mod_subtract_transform (rtx insn)\n {\n   rtx set, set_src, set_dest, op1, op2, histogram;\n   enum rtx_code code;\n@@ -897,7 +919,7 @@ mod_subtract_transform (rtx insn)\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_mod_subtract (mode, code, set_dest,\n+\trtl_mod_subtract (mode, code, set_dest,\n \t\t\t  op1, op2, i, prob1, prob2), e);\n \n   return true;\n@@ -1008,6 +1030,586 @@ speculative_prefetching_transform (rtx insn)\n   return true;\n }\n #endif  /* HAVE_prefetch */\n+\n+/* Tree based transformations. */\n+static bool\n+tree_value_profile_transformations (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  bool changed = false;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Ignore cold areas -- we are enlarging the code.  */\n+      if (!maybe_hot_bb_p (bb))\n+\tcontinue;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  stmt_ann_t ann = get_stmt_ann (stmt);\n+\t  histogram_value th = ann->histograms;\n+\t  if (!th)\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Trying transformations on insn \");\n+\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t    }\n+\n+\t  /* Transformations:  */\n+\t  /* The order of things in this conditional controls which\n+\t     transformation is used when more than one is applicable.  */\n+\t  /* It is expected that any code added by the transformations\n+\t     will be added before the current statement, and that the\n+\t     current statement remain valid (although possibly\n+\t     modified) upon return.  */\n+\t  if (flag_value_profile_transformations\n+\t      && (tree_mod_subtract_transform (stmt)\n+\t\t  || tree_divmod_fixed_value_transform (stmt)\n+\t\t  || tree_mod_pow2_value_transform (stmt)))\n+\t    {\n+\t      changed = true;\n+\t      /* Original statement may no longer be in the same block. */\n+\t      bb = bb_for_stmt (stmt);\n+\t    }\n+\n+\t  /* Free extra storage from compute_value_histograms.  */\n+\t  while (th)\n+\t    {\n+\t      free (th->hvalue.tree.counters);\n+\t      th = th->hvalue.tree.next;\n+\t    }\n+\t  ann->histograms = 0;\n+        }\n+    }\n+\n+  if (changed)\n+    {\n+      counts_to_freqs ();\n+    }\n+\n+  return changed;\n+}\n+\n+/* Generate code for transformation 1 (with OPERATION, operands OP1\n+   and OP2, whose value is expected to be VALUE, parent modify-expr STMT and\n+   probability of taking the optimal path PROB, which is equivalent to COUNT/ALL\n+   within roundoff error).  This generates the result into a temp and returns \n+   the temp; it does not replace or alter the original STMT.  */\n+static tree\n+tree_divmod_fixed_value (tree stmt, tree operation, \n+\t\t\t tree op1, tree op2, tree value, int prob, gcov_type count,\n+\t\t\t gcov_type all)\n+{\n+  tree stmt1, stmt2, stmt3;\n+  tree tmp1, tmp2, tmpv;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label1, label2, label3;\n+  tree bb1end, bb2end, bb3end;\n+  basic_block bb, bb2, bb3, bb4;\n+  tree optype = TREE_TYPE (operation);\n+  edge e12, e13, e23, e24, e34;\n+  block_stmt_iterator bsi;\n+\n+  bb = bb_for_stmt (stmt);\n+  bsi = bsi_for_stmt (stmt);\n+\n+  tmpv = create_tmp_var (optype, \"PROF\");\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmpv, fold_convert (optype, value));\n+  stmt2 = build2 (MODIFY_EXPR, optype, tmp1, op2);\n+  stmt3 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb1end = stmt3;\n+\n+  tmp2 = create_tmp_var (optype, \"PROF\");\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmp2,\n+\t\t  build2 (TREE_CODE (operation), optype, op1, tmpv));\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb2end = stmt1;\n+\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmp2,\n+\t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb3end = stmt1;\n+\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+\n+  /* Fix CFG. */\n+  /* Edge e23 connects bb2 to bb3, etc. */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  bb2->count = count;\n+  e23 = split_block (bb2, bb2end);\n+  bb3 = e23->dest;\n+  bb3->count = all - count;\n+  e34 = split_block (bb3, bb3end);\n+  bb4 = e34->dest;\n+  bb4->count = all;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  e12->probability = prob;\n+  e12->count = count;\n+\n+  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n+  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->count = all - count;\n+\n+  remove_edge (e23);\n+  \n+  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n+  e24->probability = REG_BR_PROB_BASE;\n+  e24->count = count;\n+\n+  e34->probability = REG_BR_PROB_BASE;\n+  e34->count = all - count;\n+\n+  return tmp2;\n+}\n+\n+/* Do transform 1) on INSN if applicable.  */\n+static bool\n+tree_divmod_fixed_value_transform (tree stmt)\n+{\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+  histogram_value histogram;\n+  enum tree_code code;\n+  gcov_type val, count, all;\n+  tree modify, op, op1, op2, result, value, tree_val;\n+  int prob;\n+\n+  modify = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    modify = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (modify) != MODIFY_EXPR)\n+    return false;\n+  op = TREE_OPERAND (modify, 1);\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+    return false;\n+  code = TREE_CODE (op);\n+  \n+  if (code != TRUNC_DIV_EXPR && code != TRUNC_MOD_EXPR)\n+    return false;\n+\n+  op1 = TREE_OPERAND (op, 0);\n+  op2 = TREE_OPERAND (op, 1);\n+  if (!ann->histograms)\n+    return false;\n+\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+    if (histogram->type == HIST_TYPE_SINGLE_VALUE)\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  value = histogram->hvalue.tree.value;\n+  val = histogram->hvalue.tree.counters[0];\n+  count = histogram->hvalue.tree.counters[1];\n+  all = histogram->hvalue.tree.counters[2];\n+\n+  /* We require that count is at least half of all; this means\n+     that for the transformation to fire the value must be constant\n+     at least 50% of time (and 75% gives the guarantee of usage).  */\n+  if (simple_cst_equal (op2, value) != 1 || 2 * count < all)\n+    return false;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Div/mod by constant transformation on insn \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+    }\n+\n+  /* Compute probability of taking the optimal path.  */\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+\n+  tree_val = build_int_cst_wide (GCOV_TYPE_NODE, val & 0xffffffffull, val >> 32);\n+  result = tree_divmod_fixed_value (stmt, op, op1, op2, tree_val, prob, count, all);\n+\n+  TREE_OPERAND (modify, 1) = result;\n+\n+  return true;\n+}\n+\n+/* Generate code for transformation 2 (with OPERATION, operands OP1\n+   and OP2, parent modify-expr STMT and probability of taking the optimal \n+   path PROB, which is equivalent to COUNT/ALL within roundoff error).  \n+   This generates the result into a temp and returns \n+   the temp; it does not replace or alter the original STMT.  */\n+static tree\n+tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob, \n+\t       gcov_type count, gcov_type all)\n+{\n+  tree stmt1, stmt2, stmt3, stmt4;\n+  tree tmp1, tmp2, tmp3;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label1, label2, label3;\n+  tree bb1end, bb2end, bb3end;\n+  basic_block bb, bb2, bb3, bb4;\n+  tree optype = TREE_TYPE (operation);\n+  edge e12, e13, e23, e24, e34;\n+  block_stmt_iterator bsi;\n+  tree result = create_tmp_var (optype, \"PROF\");\n+\n+  bb = bb_for_stmt (stmt);\n+  bsi = bsi_for_stmt (stmt);\n+\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  tmp2 = create_tmp_var (optype, \"PROF\");\n+  tmp3 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, tmp1, fold_convert (optype, op2));\n+  stmt2 = build2 (MODIFY_EXPR, optype, tmp2, \n+\t\t    build2 (PLUS_EXPR, optype, op2, integer_minus_one_node));\n+  stmt3 = build2 (MODIFY_EXPR, optype, tmp3,\n+\t\t    build2 (BIT_AND_EXPR, optype, tmp2, tmp1));\n+  stmt4 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (NE_EXPR, boolean_type_node, tmp3, integer_zero_node),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n+  bb1end = stmt4;\n+\n+  /* tmp2 == op2-1 inherited from previous block */\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+\t\t  build2 (BIT_AND_EXPR, optype, op1, tmp2));\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb2end = stmt1;\n+\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+\t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb3end = stmt1;\n+\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+\n+  /* Fix CFG. */\n+  /* Edge e23 connects bb2 to bb3, etc. */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  bb2->count = count;\n+  e23 = split_block (bb2, bb2end);\n+  bb3 = e23->dest;\n+  bb3->count = all - count;\n+  e34 = split_block (bb3, bb3end);\n+  bb4 = e34->dest;\n+  bb4->count = all;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  e12->probability = prob;\n+  e12->count = count;\n+\n+  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n+  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->count = all - count;\n+\n+  remove_edge (e23);\n+  \n+  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n+  e24->probability = REG_BR_PROB_BASE;\n+  e24->count = count;\n+\n+  e34->probability = REG_BR_PROB_BASE;\n+  e34->count = all - count;\n+\n+  return result;\n+}\n+\n+/* Do transform 2) on INSN if applicable.  */\n+static bool\n+tree_mod_pow2_value_transform (tree stmt)\n+{\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+  histogram_value histogram;\n+  enum tree_code code;\n+  gcov_type count, wrong_values, all;\n+  tree modify, op, op1, op2, result, value;\n+  int prob;\n+  unsigned int i;\n+\n+  modify = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    modify = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (modify) != MODIFY_EXPR)\n+    return false;\n+  op = TREE_OPERAND (modify, 1);\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+    return false;\n+  code = TREE_CODE (op);\n+  \n+  if (code != TRUNC_MOD_EXPR || !TYPE_UNSIGNED (TREE_TYPE (op)))\n+    return false;\n+\n+  op1 = TREE_OPERAND (op, 0);\n+  op2 = TREE_OPERAND (op, 1);\n+  if (!ann->histograms)\n+    return false;\n+\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+    if (histogram->type == HIST_TYPE_POW2)\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  value = histogram->hvalue.tree.value;\n+  wrong_values = histogram->hvalue.tree.counters[0];\n+  count = 0;\n+  for (i = 1; i <= TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (stmt))); i++)\n+    count += histogram->hvalue.tree.counters[i];\n+\n+  /* We require that we hit a power of 2 at least half of all evaluations.  */\n+  if (simple_cst_equal (op2, value) != 1 || count < wrong_values)\n+    return false;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Mod power of 2 transformation on insn \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+    }\n+\n+  /* Compute probability of taking the optimal path.  */\n+  all = count + wrong_values;\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+\n+  result = tree_mod_pow2 (stmt, op, op1, op2, prob, count, all);\n+\n+  TREE_OPERAND (modify, 1) = result;\n+\n+  return true;\n+}\n+\n+/* Generate code for transformations 3 and 4 (with OPERATION, operands OP1\n+   and OP2, parent modify-expr STMT, and NCOUNTS the number of cases to\n+   support.  Currently only NCOUNTS==0 or 1 is supported and this is\n+   built into this interface.  The probabilities of taking the optimal \n+   paths are PROB1 and PROB2, which are equivalent to COUNT1/ALL and\n+   COUNT2/ALL respectively within roundoff error).  This generates the \n+   result into a temp and returns the temp; it does not replace or alter \n+   the original STMT.  */\n+/* FIXME: Generalize the interface to handle NCOUNTS > 1.  */\n+\n+static tree\n+tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2, \n+\t\t    int prob1, int prob2, int ncounts,\n+\t\t    gcov_type count1, gcov_type count2, gcov_type all)\n+{\n+  tree stmt1, stmt2, stmt3;\n+  tree tmp1;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label1, label2, label3;\n+  tree bb1end, bb2end = NULL_TREE, bb3end;\n+  basic_block bb, bb2, bb3, bb4;\n+  tree optype = TREE_TYPE (operation);\n+  edge e12, e23 = 0, e24, e34, e14;\n+  block_stmt_iterator bsi;\n+  tree result = create_tmp_var (optype, \"PROF\");\n+\n+  bb = bb_for_stmt (stmt);\n+  bsi = bsi_for_stmt (stmt);\n+\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (MODIFY_EXPR, optype, result, op1);\n+  stmt2 = build2 (MODIFY_EXPR, optype, tmp1, op2);\n+  stmt3 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (LT_EXPR, boolean_type_node, result, tmp1),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl3),\n+\t    build1 (GOTO_EXPR, void_type_node, \n+\t\t    ncounts ? label_decl1 : label_decl2));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb1end = stmt3;\n+\n+  if (ncounts)\t/* Assumed to be 0 or 1 */\n+    {\n+      label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+      stmt1 = build2 (MODIFY_EXPR, optype, result,\n+\t\t      build2 (MINUS_EXPR, optype, result, tmp1));\n+      stmt2 = build3 (COND_EXPR, void_type_node,\n+\t\tbuild2 (LT_EXPR, boolean_type_node, result, tmp1),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n+\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n+      bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+      bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+      bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+      bb2end = stmt2;\n+    }\n+\n+  /* Fallback case. */\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  stmt1 = build2 (MODIFY_EXPR, optype, result,\n+\t\t    build2 (TREE_CODE (operation), optype, result, tmp1));\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb3end = stmt1;\n+\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+\n+  /* Fix CFG. */\n+  /* Edge e23 connects bb2 to bb3, etc. */\n+  /* However block 3 is optional; if it is not there, references\n+     to 3 really refer to block 2. */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  bb2->count = all - count1;\n+    \n+  if (ncounts)\t/* Assumed to be 0 or 1.  */\n+    {\n+      e23 = split_block (bb2, bb2end);\n+      bb3 = e23->dest;\n+      bb3->count = all - count1 - count2;\n+    }\n+\n+  e34 = split_block (ncounts ? bb3 : bb2, bb3end);\n+  bb4 = e34->dest;\n+  bb4->count = all;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  e12->probability = REG_BR_PROB_BASE - prob1;\n+  e12->count = count1;\n+\n+  e14 = make_edge (bb, bb4, EDGE_TRUE_VALUE);\n+  e14->probability = prob1;\n+  e14->count = all - count1;\n+\n+  if (ncounts)  /* Assumed to be 0 or 1.  */\n+    {\n+      e23->flags &= ~EDGE_FALLTHRU;\n+      e23->flags |= EDGE_FALSE_VALUE;\n+      e23->count = all - count1 - count2;\n+      e23->probability = REG_BR_PROB_BASE - prob2;\n+\n+      e24 = make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n+      e24->probability = prob2;\n+      e24->count = count2;\n+    }\n+\n+  e34->probability = REG_BR_PROB_BASE;\n+  e34->count = all - count1 - count2;\n+\n+  return result;\n+}\n+\n+/* Do transforms 3) and 4) on INSN if applicable.  */\n+static bool\n+tree_mod_subtract_transform (tree stmt)\n+{\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+  histogram_value histogram;\n+  enum tree_code code;\n+  gcov_type count, wrong_values, all;\n+  tree modify, op, op1, op2, result, value;\n+  int prob1, prob2;\n+  unsigned int i;\n+\n+  modify = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR\n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    modify = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (modify) != MODIFY_EXPR)\n+    return false;\n+  op = TREE_OPERAND (modify, 1);\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+    return false;\n+  code = TREE_CODE (op);\n+  \n+  if (code != TRUNC_MOD_EXPR || !TYPE_UNSIGNED (TREE_TYPE (op)))\n+    return false;\n+\n+  op1 = TREE_OPERAND (op, 0);\n+  op2 = TREE_OPERAND (op, 1);\n+  if (!ann->histograms)\n+    return false;\n+\n+  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.tree.next)\n+    if (histogram->type == HIST_TYPE_INTERVAL)\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  value = histogram->hvalue.tree.value;\n+  all = 0;\n+  wrong_values = 0;\n+  for (i = 0; i < histogram->hdata.intvl.steps; i++)\n+    all += histogram->hvalue.tree.counters[i];\n+\n+  wrong_values += histogram->hvalue.tree.counters[i];\n+  wrong_values += histogram->hvalue.tree.counters[i+1];\n+  all += wrong_values;\n+\n+  /* Sanity check. */\n+  if (simple_cst_equal (op2, value) != 1)\n+    return false;\n+\n+  /* We require that we use just subtractions in at least 50% of all\n+     evaluations.  */\n+  count = 0;\n+  for (i = 0; i < histogram->hdata.intvl.steps; i++)\n+    {\n+      count += histogram->hvalue.tree.counters[i];\n+      if (count * 2 >= all)\n+\tbreak;\n+    }\n+  if (i == histogram->hdata.intvl.steps)\n+    return false;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Mod subtract transformation on insn \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+    }\n+\n+  /* Compute probability of taking the optimal path(s).  */\n+  prob1 = (histogram->hvalue.tree.counters[0] * REG_BR_PROB_BASE + all / 2) / all;\n+  prob2 = (histogram->hvalue.tree.counters[1] * REG_BR_PROB_BASE + all / 2) / all;\n+\n+  /* In practice, \"steps\" is always 2.  This interface reflects this,\n+     and will need to be changed if \"steps\" can change.  */\n+  result = tree_mod_subtract (stmt, op, op1, op2, prob1, prob2, i,\n+\t\t\t    histogram->hvalue.tree.counters[0], \n+\t\t\t    histogram->hvalue.tree.counters[1], all);\n+\n+  TREE_OPERAND (modify, 1) = result;\n+\n+  return true;\n+}\n \f\n /* Connection to the outside world.  */\n /* Struct for IR-dependent hooks.  */\n@@ -1034,17 +1636,159 @@ rtl_register_value_prof_hooks (void)\n   gcc_assert (!ir_type ());\n }\n \f\n-/* Tree-based versions are stubs for now.  */\n+/* Find values inside INSN for that we want to measure histograms for\n+   division/modulo optimization.  */\n+static void\n+tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n+{\n+  tree op, op1, op2;\n+  histogram_value hist;\n+\n+  op = stmt;\n+  if (TREE_CODE (stmt) == RETURN_EXPR \n+      && TREE_OPERAND (stmt, 0)\n+      && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+    op = TREE_OPERAND (stmt, 0);\n+\n+  if (TREE_CODE (op) != MODIFY_EXPR)\n+    return;\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+    return;\n+  op = TREE_OPERAND (op, 1);\n+  switch (TREE_CODE (op))\n+    {\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      op1 = TREE_OPERAND (op, 0);\n+      op2 = TREE_OPERAND (op, 1);\n+\n+      /* Check for a special case where the divisor is power(s) of 2.\n+         This is more aggressive than the RTL version, under the\n+\t assumption that later phases will reduce / or % by power of 2\n+\t to something clever most of the time.  Signed or unsigned.  */\n+      if (TREE_CODE (op2) != INTEGER_CST)\n+\t{\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->hvalue.tree.value = op2;\n+\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->type = HIST_TYPE_POW2;\n+\t  hist->hdata.pow2.may_be_other = 1;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n+\t}\n+\n+      /* Check for the case where the divisor is the same value most\n+\t of the time.  */\n+      if (TREE_CODE (op2) != INTEGER_CST)\n+\t{\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->hvalue.tree.value = op2;\n+\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->type = HIST_TYPE_SINGLE_VALUE;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n+\t}\n+\n+      /* For mod, check whether it is not often a noop (or replaceable by\n+\t a few subtractions).  */\n+      if (TREE_CODE (op) == TRUNC_MOD_EXPR && TYPE_UNSIGNED (TREE_TYPE (op)))\n+\t{\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->hvalue.tree.value = op2;\n+\t  hist->type = HIST_TYPE_INTERVAL;\n+\t  hist->hdata.intvl.int_start = 0;\n+\t  hist->hdata.intvl.steps = 2;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n+\t}\n+      return;\n+\n+    default:\n+      return;\n+    }\n+}\n+\n+/* Find values inside INSN for that we want to measure histograms and adds\n+   them to list VALUES (increasing the record of its length in N_VALUES).  */\n static void\n-tree_find_values_to_profile (histogram_values *values ATTRIBUTE_UNUSED)\n+tree_values_to_profile (tree stmt, histogram_values *values)\n {\n-  gcc_unreachable ();\n+  if (flag_value_profile_transformations)\n+    tree_divmod_values_to_profile (stmt, values);\n }\n \n-static bool\n-tree_value_profile_transformations (void)\n+static void\n+tree_find_values_to_profile (histogram_values *values)\n {\n-  gcc_unreachable ();\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  unsigned int i;\n+\n+  *values = VEC_alloc (histogram_value, 0);\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+        tree stmt = bsi_stmt (bsi);\n+        tree_values_to_profile (stmt, values);\n+      }\n+  static_values = *values;\n+  \n+  for (i = 0; i < VEC_length (histogram_value, *values); i++)\n+    {\n+      histogram_value hist = VEC_index (histogram_value, *values, i);\n+\n+      switch (hist->type)\n+        {\n+\tcase HIST_TYPE_INTERVAL:\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Interval counter for tree \");\n+\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, \n+\t\t\t\t  TDF_SLIM);\n+\t      fprintf (dump_file, \", range %d -- %d.\\n\",\n+\t\t     hist->hdata.intvl.int_start,\n+\t\t     (hist->hdata.intvl.int_start\n+\t\t      + hist->hdata.intvl.steps - 1));\n+\t    }\n+\t  hist->n_counters = hist->hdata.intvl.steps + 2;\n+\t  break;\n+\n+\tcase HIST_TYPE_POW2:\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Pow2 counter for insn \");\n+\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      fprintf (dump_file, \".\\n\");\n+\t    }\n+\t  stmt = hist->hvalue.tree.stmt;\n+\t  hist->n_counters \n+\t\t= TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (stmt)))\n+\t\t  +  (hist->hdata.pow2.may_be_other ? 1 : 0);\n+\t  break;\n+\n+\tcase HIST_TYPE_SINGLE_VALUE:\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Single value counter for insn \");\n+\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      fprintf (dump_file, \".\\n\");\n+\t    }\n+\t  hist->n_counters = 3;\n+\t  break;\n+\n+\tcase HIST_TYPE_CONST_DELTA:\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Constant delta counter for insn \");\n+\t      print_generic_expr (dump_file, hist->hvalue.tree.stmt, TDF_SLIM);\n+\t      fprintf (dump_file, \".\\n\");\n+\t    }\n+\t  hist->n_counters = 4;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n }\n \n static struct value_prof_hooks tree_value_prof_hooks = {\n@@ -1069,6 +1813,7 @@ find_values_to_profile (histogram_values *values)\n bool\n value_profile_transformations (void)\n {\n-  return (value_prof_hooks->value_profile_transformations) ();\n+  bool retval = (value_prof_hooks->value_profile_transformations) ();\n+  VEC_free (histogram_value, static_values);\n+  return retval;\n }\n-"}, {"sha": "7742de2fab65e436c68d02b11d528ba5b1756676", "filename": "gcc/value-prof.h", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f1e85278aee66245bf2258c372216635436ced4/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=1f1e85278aee66245bf2258c372216635436ced4", "patch": "@@ -38,24 +38,33 @@ enum hist_type\n   ((enum hist_type) ((COUNTER) - GCOV_FIRST_VALUE_COUNTER))\n \n /* The value to measure.  */\n-/* The void *'s are either rtx or tree, depending on which IR is in use.  */\n-struct histogram_value_t GTY(())\n+struct histogram_value_t\n {\n-  PTR GTY ((skip (\"\"))) value;\t\t/* The value to profile.  */\n-  enum machine_mode mode;\t\t/* And its mode.  */\n-  PTR GTY ((skip (\"\"))) seq;\t\t/* Insns required to count the\n-\t\t\t\t\t   profiled value.  */\n-  PTR GTY ((skip (\"\"))) insn;\t\t/* Insn before that to measure.  */\n+  union \n+    {\n+      struct\n+\t{\n+\t  rtx value;\t\t/* The value to profile.  */\n+\t  rtx seq;\t\t/* Insns required to count the profiled value.  */\n+\t  rtx insn;\t\t/* Insn before that to measure.  */\n+\t  enum machine_mode mode;\t        /* Mode of value to profile.  */\n+\t} rtl;\n+      struct\n+\t{\n+\t  tree value;\t\t/* The value to profile.  */\n+\t  tree stmt;\t\t/* Insn containing the value.  */\n+\t  gcov_type *counters;\t\t        /* Pointer to first counter.  */\n+\t  struct histogram_value_t *next;\t\t/* Linked list pointer.  */\n+\t} tree;\n+    } hvalue;\n   enum hist_type type;\t\t\t/* Type of information to measure.  */\n   unsigned n_counters;\t\t\t/* Number of required counters.  */\n   union\n     {\n       struct\n \t{\n \t  int int_start;\t/* First value in interval.  */\n-\t  int steps;\t\t/* Number of values in it.  */\n-\t  int may_be_less;\t/* May the value be below?  */\n-\t  int may_be_more;\t/* Or above.  */\n+\t  unsigned int steps;\t/* Number of values in it.  */\n \t} intvl;\t/* Interval histogram data.  */\n       struct\n \t{\n@@ -66,7 +75,7 @@ struct histogram_value_t GTY(())\n \n typedef struct histogram_value_t *histogram_value;\n \n-DEF_VEC_GC_P(histogram_value);\n+DEF_VEC_MALLOC_P(histogram_value);\n \n typedef VEC(histogram_value) *histogram_values;\n "}]}