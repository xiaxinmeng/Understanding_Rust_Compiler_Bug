{"sha": "aa634f11e65d7630b96742a4f3d187d920e0c87e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2MzRmMTFlNjVkNzYzMGI5Njc0MmE0ZjNkMTg3ZDkyMGUwYzg3ZQ==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2003-02-10T19:18:42Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2003-02-10T19:18:42Z"}, "message": "Makefile.in (bb-reorder.o): Add dependency on $(FIBHEAP_H).\n\n\t* Makefile.in (bb-reorder.o): Add dependency on $(FIBHEAP_H).\n\t* bb-reorder.c (make_reorder_chain): Deleted.\n\t(make_reorder_chain_1): Deleted.\n\t(find_traces): New function.\n\t(rotate_loop): New function.\n\t(mark_bb_visited): New function.\n\t(find_traces_1_round): New function.\n\t(copy_bb): New function.\n\t(bb_to_key): New function.\n\t(better_edge_p): New function.\n\t(connect_traces): New function.\n\t(copy_bb_p): New function.\n\t(get_uncond_jump_length): New function.\n\t(reorder_basic_blocks): Use new functions (Software Trace Cache).\n\t* cfgcleanup.c (outgoing_edges_match): Enable crossjumping across loop\n\tboundaries.\n\nFrom-SVN: r62645", "tree": {"sha": "dccf4963c7714b07bfd684853d4bc9111711b32d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dccf4963c7714b07bfd684853d4bc9111711b32d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa634f11e65d7630b96742a4f3d187d920e0c87e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa634f11e65d7630b96742a4f3d187d920e0c87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa634f11e65d7630b96742a4f3d187d920e0c87e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa634f11e65d7630b96742a4f3d187d920e0c87e/comments", "author": null, "committer": null, "parents": [{"sha": "17edbda5792c20f9f11d77c829d5dae9ad9b0e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17edbda5792c20f9f11d77c829d5dae9ad9b0e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17edbda5792c20f9f11d77c829d5dae9ad9b0e24"}], "stats": {"total": 1221, "additions": 1026, "deletions": 195}, "files": [{"sha": "bbddb7d8571c1b658dcd55d7a42dc9798111b8b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa634f11e65d7630b96742a4f3d187d920e0c87e", "patch": "@@ -1,3 +1,22 @@\n+2003-02-10  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* Makefile.in (bb-reorder.o): Add dependency on $(FIBHEAP_H).\n+\t* bb-reorder.c (make_reorder_chain): Deleted.  \n+\t(make_reorder_chain_1): Deleted.\n+\t(find_traces): New function.\n+\t(rotate_loop): New function.\n+\t(mark_bb_visited): New function.\n+\t(find_traces_1_round): New function.\n+\t(copy_bb): New function.\n+\t(bb_to_key): New function.\n+\t(better_edge_p): New function.\n+\t(connect_traces): New function.\n+\t(copy_bb_p): New function.\n+\t(get_uncond_jump_length): New function.\n+\t(reorder_basic_blocks): Use new functions (Software Trace Cache).\n+\t* cfgcleanup.c (outgoing_edges_match): Enable crossjumping across loop\n+\tboundaries.\n+\n 2003-02-10  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.c (bdesc_2arg): Change spe_evxor to xorv2si3."}, {"sha": "3c5a4d90c28c308e028c5fabada58c3768bffa7b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=aa634f11e65d7630b96742a4f3d187d920e0c87e", "patch": "@@ -1691,8 +1691,9 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) sreal.h \\\n    $(PARAMS_H) $(TARGET_H) cfgloop.h\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) $(GGC_H)\n-bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)\n+bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) $(BASIC_BLOCK_H) flags.h output.h cfglayout.h $(FIBHEAP_H) \\\n+   $(TARGET_H)\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h flags.h \\\n    $(PARAMS_H) profile.h"}, {"sha": "0711f18670e3342c5b8813b7de09571a8ed0beb1", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1004, "deletions": 182, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=aa634f11e65d7630b96742a4f3d187d920e0c87e", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -18,250 +18,1048 @@\n    Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    02111-1307, USA.  */\n \n-/* References:\n-\n-   \"Profile Guided Code Positioning\"\n-   Pettis and Hanson; PLDI '90.\n-\n-   TODO:\n-\n-   (1) Consider:\n-\n-\t\tif (p) goto A;\t\t// predict taken\n-\t\tfoo ();\n-\t      A:\n-\t\tif (q) goto B;\t\t// predict taken\n-\t\tbar ();\n-\t      B:\n-\t\tbaz ();\n-\t\treturn;\n-\n-       We'll currently reorder this as\n-\n-\t\tif (!p) goto C;\n-\t      A:\n-\t\tif (!q) goto D;\n-\t      B:\n-\t\tbaz ();\n-\t\treturn;\n-\t      D:\n-\t\tbar ();\n-\t\tgoto B;\n-\t      C:\n-\t\tfoo ();\n-\t\tgoto A;\n-\n-       A better ordering is\n-\n-\t\tif (!p) goto C;\n-\t\tif (!q) goto D;\n-\t      B:\n-\t\tbaz ();\n-\t\treturn;\n-\t      C:\n-\t\tfoo ();\n-\t\tif (q) goto B;\n-\t      D:\n-\t\tbar ();\n-\t\tgoto B;\n-\n-       This requires that we be able to duplicate the jump at A, and\n-       adjust the graph traversal such that greedy placement doesn't\n-       fix D before C is considered.\n-\n-   (2) Coordinate with shorten_branches to minimize the number of\n-       long branches.\n-\n-   (3) Invent a method by which sufficiently non-predicted code can\n-       be moved to either the end of the section or another section\n-       entirely.  Some sort of NOTE_INSN note would work fine.\n-\n-       This completely scroggs all debugging formats, so the user\n-       would have to explicitly ask for it.\n+/* This (greedy) algorithm constructs traces in several rounds.\n+   The construction starts from \"seeds\".  The seed for the first round\n+   is the entry point of function.  When there are more than one seed\n+   that one is selected first that has the lowest key in the heap\n+   (see function bb_to_key).  Then the algorithm repeatedly adds the most\n+   probable successor to the end of a trace.  Finally it connects the traces.\n+\n+   There are two parameters: Branch Threshold and Exec Threshold.\n+   If the edge to a successor of the actual basic block is lower than\n+   Branch Threshold or the frequency of the successor is lower than\n+   Exec Threshold the successor will be the seed in one of the next rounds.\n+   Each round has these parameters lower than the previous one.\n+   The last round has to have these parameters set to zero\n+   so that the remaining blocks are picked up.\n+\n+   The algorithm selects the most probable successor from all unvisited\n+   successors and successors that have been added to this trace.\n+   The other successors (that has not been \"sent\" to the next round) will be\n+   other seeds for this round and the secondary traces will start in them.\n+   If the successor has not been visited in this trace it is added to the trace\n+   (however, there is some heuristic for simple branches).\n+   If the successor has been visited in this trace the loop has been found.\n+   If the loop has many iterations the loop is rotated so that the\n+   source block of the most probable edge going out from the loop\n+   is the last block of the trace.\n+   If the loop has few iterations and there is no edge from the last block of\n+   the loop going out from loop the loop header is duplicated.\n+   Finally, the construction of the trace is terminated.\n+\n+   When connecting traces it first checks whether there is an edge from the\n+   last block of one trace to the first block of another trace.\n+   When there are still some unconnected traces it checks whether there exists\n+   a basic block BB such that BB is a successor of the last bb of one trace\n+   and BB is a predecessor of the first block of another trace. In this case,\n+   BB is duplicated and the traces are connected through this duplicate.\n+   The rest of traces are simply connected so there will be a jump to the\n+   beginning of the rest of trace.\n+\n+\n+   References:\n+\n+   \"Software Trace Cache\"\n+   A. Ramirez, J. Larriba-Pey, C. Navarro, J. Torrellas and M. Valero; 1999\n+   http://citeseer.nj.nec.com/15361.html\n+\n */\n \n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"tree.h\"\n #include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"cfglayout.h\"\n+#include \"fibheap.h\"\n #include \"target.h\"\n \n+/* The number of rounds.  */\n+#define N_ROUNDS 4\n+\n+/* Branch thresholds in thousandths (per mille) of the REG_BR_PROB_BASE.  */\n+static int branch_threshold[N_ROUNDS] = {400, 200, 100, 0};\n+\n+/* Exec thresholds in thousandths (per mille) of the frequency of bb 0.  */\n+static int exec_threshold[N_ROUNDS] = {500, 200, 50, 0};\n+\n+/* If edge frequency is lower than DUPLICATION_THRESHOLD per mille of entry\n+   block the edge destination is not duplicated while connecting traces.  */\n+#define DUPLICATION_THRESHOLD 100\n+\n+/* Length of unconditional jump instruction.  */\n+static int uncond_jump_length;\n+\n+/* Structure to hold needed information for each basic block.  */\n+typedef struct bbro_basic_block_data_def\n+{\n+  /* Which trace is the bb start of (-1 means it is not a start of a trace).  */\n+  int start_of_trace;\n+\n+  /* Which trace is the bb end of (-1 means it is not an end of a trace).  */\n+  int end_of_trace;\n+\n+  /* Which heap is BB in (if any)?  */\n+  fibheap_t heap;\n+\n+  /* Which heap node is BB in (if any)?  */\n+  fibnode_t node;\n+} bbro_basic_block_data;\n+\n+/* The current size of the following dynamic array.  */\n+static int array_size;\n+\n+/* The array which holds needed information for basic blocks.  */\n+static bbro_basic_block_data *bbd;\n+\n+/* To avoid frequent reallocation the size of arrays is greater than needed,\n+   the number of elements is (not less than) 1.25 * size_wanted.  */\n+#define GET_ARRAY_SIZE(X) ((((X) / 4) + 1) * 5)\n+\n+/* Free the memory and set the pointer to NULL.  */\n+#define FREE(P) \\\n+  do { if (P) { free (P); P = 0; } else { abort (); } } while (0)\n+\n+/* Structure for holding information about a trace.  */\n+struct trace\n+{\n+  /* First and last basic block of the trace.  */\n+  basic_block first, last;\n+\n+  /* The round of the STC creation which this trace was found in.  */\n+  int round;\n+\n+  /* The length (i.e. the number of basic blocks) of the trace.  */\n+  int length;\n+};\n+\n+/* Maximum frequency and count of one of the entry blocks.  */\n+int max_entry_frequency;\n+gcov_type max_entry_count;\n+\n /* Local function prototypes.  */\n-static void make_reorder_chain\t\tPARAMS ((void));\n-static basic_block make_reorder_chain_1\tPARAMS ((basic_block, basic_block));\n+static void find_traces\t\t\tPARAMS ((int *, struct trace *));\n+static basic_block rotate_loop\t\tPARAMS ((edge, struct trace *, int));\n+static void mark_bb_visited\t\tPARAMS ((basic_block, int));\n+static void find_traces_1_round\t\tPARAMS ((int, int, gcov_type,\n+\t\t\t\t\t\t struct trace *, int *, int,\n+\t\t\t\t\t\t fibheap_t *));\n+static basic_block copy_bb\t\tPARAMS ((basic_block, edge,\n+\t\t\t\t\t\t basic_block, int));\n+static fibheapkey_t bb_to_key\t\tPARAMS ((basic_block));\n+static bool better_edge_p\t\tPARAMS ((basic_block, edge, int, int,\n+\t\t\t\t\t\t int, int));\n+static void connect_traces\t\tPARAMS ((int, struct trace *));\n+static bool copy_bb_p\t\t\tPARAMS ((basic_block, int));\n+static int get_uncond_jump_length\tPARAMS ((void));\n \f\n-/* Compute an ordering for a subgraph beginning with block BB.  Record the\n-   ordering in RBI()->index and chained through RBI()->next.  */\n+/* Find the traces for Software Trace Cache.  Chain each trace through\n+   RBI()->next.  Store the number of traces to N_TRACES and description of\n+   traces to TRACES.  */\n \n static void\n-make_reorder_chain ()\n+find_traces (n_traces, traces)\n+     int *n_traces;\n+     struct trace *traces;\n {\n-  basic_block prev = NULL;\n-  basic_block next, bb;\n+  int i;\n+  edge e;\n+  fibheap_t heap;\n+\n+  /* Insert entry points of function into heap.  */\n+  heap = fibheap_new ();\n+  max_entry_frequency = 0;\n+  max_entry_count = 0;\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    {\n+      bbd[e->dest->index].heap = heap;\n+      bbd[e->dest->index].node = fibheap_insert (heap, bb_to_key (e->dest),\n+\t\t\t\t\t\t    e->dest);\n+      if (e->dest->frequency > max_entry_frequency)\n+\tmax_entry_frequency = e->dest->frequency;\n+      if (e->dest->count > max_entry_count)\n+\tmax_entry_count = e->dest->count;\n+    }\n+\n+  /* Find the traces.  */\n+  for (i = 0; i < N_ROUNDS; i++)\n+    {\n+      gcov_type count_threshold;\n \n-  /* Loop until we've placed every block.  */\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"STC - round %d\\n\", i + 1);\n+\n+      if (max_entry_count < INT_MAX / 1000)\n+\tcount_threshold = max_entry_count * exec_threshold[i] / 1000;\n+      else\n+\tcount_threshold = max_entry_count / 1000 * exec_threshold[i];\n+\n+      find_traces_1_round (REG_BR_PROB_BASE * branch_threshold[i] / 1000,\n+\t\t\t   max_entry_frequency * exec_threshold[i] / 1000,\n+\t\t\t   count_threshold, traces, n_traces, i, &heap);\n+    }\n+  fibheap_delete (heap);\n+\n+  if (rtl_dump_file)\n+    {\n+      for (i = 0; i < *n_traces; i++)\n+\t{\n+\t  basic_block bb;\n+\t  fprintf (rtl_dump_file, \"Trace %d (round %d):  \", i + 1,\n+\t\t   traces[i].round + 1);\n+\t  for (bb = traces[i].first; bb != traces[i].last; bb = RBI (bb)->next)\n+\t    fprintf (rtl_dump_file, \"%d [%d] \", bb->index, bb->frequency);\n+\t  fprintf (rtl_dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n+\t}\n+      fflush (rtl_dump_file);\n+    }\n+}\n+\n+/* Rotate loop whose back edge is BACK_EDGE in the tail of trace TRACE\n+   (with sequential number TRACE_N).  */\n+\n+static basic_block\n+rotate_loop (back_edge, trace, trace_n)\n+     edge back_edge;\n+     struct trace *trace;\n+     int trace_n;\n+{\n+  basic_block bb;\n+\n+  /* Information about the best end (end after rotation) of the loop.  */\n+  basic_block best_bb = NULL;\n+  edge best_edge = NULL;\n+  int best_freq = -1;\n+  gcov_type best_count = -1;\n+  /* The best edge is preferred when its destination is not visited yet\n+     or is a start block of some trace.  */\n+  bool is_preferred = false;\n+\n+  /* Find the most frequent edge that goes out from current trace.  */\n+  bb = back_edge->dest;\n   do\n     {\n-      next = NULL;\n-\n-      /* Find the next unplaced block.  */\n-      /* ??? Get rid of this loop, and track which blocks are not yet\n-\t placed more directly, so as to avoid the O(N^2) worst case.\n-\t Perhaps keep a doubly-linked list of all to-be-placed blocks;\n-\t remove from the list as we place.  The head of that list is\n-\t what we're looking for here.  */\n-\n-      FOR_EACH_BB (bb)\n-\tif (! RBI (bb)->visited)\n-\t  {\n-\t    next = bb;\n-\t    break;\n-\t  }\n+      edge e;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (e->dest != EXIT_BLOCK_PTR\n+\t    && RBI (e->dest)->visited != trace_n\n+\t    && (e->flags & EDGE_CAN_FALLTHRU)\n+\t    && !(e->flags & EDGE_COMPLEX))\n+\t{\n+\t  if (is_preferred)\n+\t    {\n+\t      /* The best edge is preferred.  */\n+\t      if (!RBI (e->dest)->visited\n+\t\t  || bbd[e->dest->index].start_of_trace >= 0)\n+\t\t{\n+\t\t  /* The current edge E is also preferred.  */\n+\t\t  int freq = EDGE_FREQUENCY (e);\n+\t\t  if (freq > best_freq || e->count > best_count)\n+\t\t    {\n+\t\t      best_freq = freq;\n+\t\t      best_count = e->count;\n+\t\t      best_edge = e;\n+\t\t      best_bb = bb;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!RBI (e->dest)->visited\n+\t\t  || bbd[e->dest->index].start_of_trace >= 0)\n+\t\t{\n+\t\t  /* The current edge E is preferred.  */\n+\t\t  is_preferred = true;\n+\t\t  best_freq = EDGE_FREQUENCY (e);\n+\t\t  best_count = e->count;\n+\t\t  best_edge = e;\n+\t\t  best_bb = bb;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int freq = EDGE_FREQUENCY (e);\n+\t\t  if (!best_edge || freq > best_freq || e->count > best_count)\n+\t\t    {\n+\t\t      best_freq = freq;\n+\t\t      best_count = e->count;\n+\t\t      best_edge = e;\n+\t\t      best_bb = bb;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      bb = RBI (bb)->next;\n+    }\n+  while (bb != back_edge->dest);\n+\n+  if (best_bb)\n+    {\n+      /* Rotate the loop so that the BEST_EDGE goes out from the last block of\n+\t the trace.  */\n+      if (back_edge->dest == trace->first)\n+\t{\n+\t  trace->first = RBI (best_bb)->next;\n+\t}\n+      else\n+\t{\n+\t  basic_block prev_bb;\n \n-      if (next)\n-\tprev = make_reorder_chain_1 (next, prev);\n+\t  for (prev_bb = trace->first;\n+\t       RBI (prev_bb)->next != back_edge->dest;\n+\t       prev_bb = RBI (prev_bb)->next)\n+\t    ;\n+\t  RBI (prev_bb)->next = RBI (best_bb)->next;\n+\n+\t  /* Try to get rid of uncond jump to cond jump.  */\n+\t  if (prev_bb->succ && !prev_bb->succ->succ_next)\n+\t    {\n+\t      basic_block header = prev_bb->succ->dest;\n+\n+\t      /* Duplicate HEADER if it is a small block containing cond jump\n+\t\t in the end.  */\n+\t      if (any_condjump_p (header->end) && copy_bb_p (header, 0))\n+\t\t{\n+\t\t  copy_bb (header, prev_bb->succ, prev_bb, trace_n);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* We have not found suitable loop tail so do no rotation.  */\n+      best_bb = back_edge->src;\n     }\n-  while (next);\n-  RBI (prev)->next = NULL;\n+  RBI (best_bb)->next = NULL;\n+  return best_bb;\n }\n \n-/* A helper function for make_reorder_chain.\n+/* This function marks BB that it was visited in trace number TRACE.  */\n+\n+static void\n+mark_bb_visited (bb, trace)\n+     basic_block bb;\n+     int trace;\n+{\n+  RBI (bb)->visited = trace;\n+  if (bbd[bb->index].heap)\n+    {\n+      fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n+      bbd[bb->index].heap = NULL;\n+      bbd[bb->index].node = NULL;\n+    }\n+}\n+\n+/* One round of finding traces. Find traces for BRANCH_TH and EXEC_TH i.e. do\n+   not include basic blocks their probability is lower than BRANCH_TH or their\n+   frequency is lower than EXEC_TH into traces (or count is lower than\n+   COUNT_TH).  It stores the new traces into TRACES and modifies the number of\n+   traces *N_TRACES. Sets the round (which the trace belongs to) to ROUND. It\n+   expects that starting basic blocks are in *HEAP and at the end it deletes\n+   *HEAP and stores starting points for the next round into new *HEAP.  */\n+\n+static void\n+find_traces_1_round (branch_th, exec_th, count_th, traces, n_traces, round,\n+\t\t     heap)\n+     int branch_th;\n+     int exec_th;\n+     gcov_type count_th;\n+     struct trace *traces;\n+     int *n_traces;\n+     int round;\n+     fibheap_t *heap;\n+{\n+  /* Heap for discarded basic blocks which are possible starting points for\n+     the next round.  */\n+  fibheap_t new_heap = fibheap_new ();\n+\n+  while (!fibheap_empty (*heap))\n+    {\n+      basic_block bb;\n+      struct trace *trace;\n+      edge best_edge, e;\n+      fibheapkey_t key;\n+\n+      bb = fibheap_extract_min (*heap);\n+      bbd[bb->index].heap = NULL;\n+      bbd[bb->index].node = NULL;\n+\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Getting bb %d\\n\", bb->index);\n+\n+      /* If the BB's frequency is too low send BB to the next round.  */\n+      if (bb->frequency < exec_th || bb->count < count_th\n+\t  || ((round < N_ROUNDS - 1) && probably_never_executed_bb_p (bb)))\n+\t{\n+\t  int key = bb_to_key (bb);\n+\t  bbd[bb->index].heap = new_heap;\n+\t  bbd[bb->index].node = fibheap_insert (new_heap, key, bb);\n+\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"  Possible start point of next round: %d (key: %d)\\n\",\n+\t\t     bb->index, key);\n+\t  continue;\n+\t}\n+\n+      trace = traces + *n_traces;\n+      trace->first = bb;\n+      trace->round = round;\n+      trace->length = 0;\n+      (*n_traces)++;\n+\n+      do\n+\t{\n+\t  int prob, freq;\n+\n+\t  /* The probability and frequency of the best edge.  */\n+\t  int best_prob = INT_MIN / 2;\n+\t  int best_freq = INT_MIN / 2;\n+\n+\t  best_edge = NULL;\n+\t  mark_bb_visited (bb, *n_traces);\n+\t  trace->length++;\n+\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Basic block %d was visited in trace %d\\n\",\n+\t\t     bb->index, *n_traces - 1);\n+\n+\t  /* Select the successor that will be placed after BB.  */\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    {\n+\t      if (e->flags & EDGE_FAKE)\n+\t\tabort ();\n+\n+\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      if (RBI (e->dest)->visited\n+\t\t  && RBI (e->dest)->visited != *n_traces)\n+\t\tcontinue;\n+\n+\t      prob = e->probability;\n+\t      freq = EDGE_FREQUENCY (e);\n+\n+\t      /* Edge that cannot be fallthru or improbable or infrequent\n+\t\t successor (ie. it is unsuitable successor).  */\n+\t      if (!(e->flags & EDGE_CAN_FALLTHRU) || (e->flags & EDGE_COMPLEX)\n+\t\t  || prob < branch_th || freq < exec_th || e->count < count_th)\n+\t\tcontinue;\n+\n+\t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq))\n+\t\t{\n+\t\t  best_edge = e;\n+\t\t  best_prob = prob;\n+\t\t  best_freq = freq;\n+\t\t}\n+\t    }\n+\n+\t  /* Add all non-selected successors to the heaps.  */\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    {\n+\t      if (e == best_edge\n+\t\t  || e->dest == EXIT_BLOCK_PTR\n+\t\t  || RBI (e->dest)->visited)\n+\t\tcontinue;\n+\n+\t      key = bb_to_key (e->dest);\n+\n+\t      if (bbd[e->dest->index].heap)\n+\t\t{\n+\t\t  /* E->DEST is already in some heap.  */\n+\t\t  if (key != bbd[e->dest->index].node->key)\n+\t\t    {\n+\t\t      if (rtl_dump_file)\n+\t\t\t{\n+\t\t\t  fprintf (rtl_dump_file,\n+\t\t\t\t   \"Changing key for bb %d from %ld to %ld.\\n\",\n+\t\t\t\t   e->dest->index,\n+\t\t\t\t   (long) bbd[e->dest->index].node->key,\n+\t\t\t\t   key);\n+\t\t\t}\n+\t\t      fibheap_replace_key (bbd[e->dest->index].heap,\n+\t\t\t\t\t   bbd[e->dest->index].node, key);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fibheap_t which_heap = *heap;\n+\n+\t\t  prob = e->probability;\n+\t\t  freq = EDGE_FREQUENCY (e);\n+\n+\t\t  if (!(e->flags & EDGE_CAN_FALLTHRU)\n+\t\t      || (e->flags & EDGE_COMPLEX)\n+\t\t      || prob < branch_th || freq < exec_th\n+\t\t      || e->count < count_th)\n+\t\t    {\n+\t\t      if (round < N_ROUNDS - 1)\n+\t\t\twhich_heap = new_heap;\n+\t\t    }\n \n-   We do not follow EH edges, or non-fallthru edges to noreturn blocks.\n-   These are assumed to be the error condition and we wish to cluster\n-   all of them at the very end of the function for the benefit of cache\n-   locality for the rest of the function.\n+\t\t  bbd[e->dest->index].heap = which_heap;\n+\t\t  bbd[e->dest->index].node = fibheap_insert (which_heap,\n+\t\t\t\t\t\t\t\tkey, e->dest);\n \n-   ??? We could do slightly better by noticing earlier that some subgraph\n-   has all paths leading to noreturn functions, but for there to be more\n-   than one block in such a subgraph is rare.  */\n+\t\t  if (rtl_dump_file)\n+\t\t    {\n+\t\t      fprintf (rtl_dump_file,\n+\t\t\t       \"  Possible start of %s round: %d (key: %ld)\\n\",\n+\t\t\t       (which_heap == new_heap) ? \"next\" : \"this\",\n+\t\t\t       e->dest->index, (long) key);\n+\t\t    }\n+\n+\t\t}\n+\t    }\n+\n+\t  if (best_edge) /* Suitable successor was found.  */\n+\t    {\n+\t      if (RBI (best_edge->dest)->visited == *n_traces)\n+\t\t{\n+\t\t  /* We do nothing with one basic block loops.  */\n+\t\t  if (best_edge->dest != bb)\n+\t\t    {\n+\t\t      if (EDGE_FREQUENCY (best_edge)\n+\t\t\t  > 4 * best_edge->dest->frequency / 5)\n+\t\t\t{\n+\t\t\t  /* The loop has at least 4 iterations.  If the loop\n+\t\t\t     header is not the first block of the function\n+\t\t\t     we can rotate the loop.  */\n+\n+\t\t\t  if (best_edge->dest != ENTRY_BLOCK_PTR->next_bb)\n+\t\t\t    {\n+\t\t\t      if (rtl_dump_file)\n+\t\t\t\t{\n+\t\t\t\t  fprintf (rtl_dump_file,\n+\t\t\t\t\t   \"Rotating loop %d - %d\\n\",\n+\t\t\t\t\t   best_edge->dest->index, bb->index);\n+\t\t\t\t}\n+\t\t\t      RBI (bb)->next = best_edge->dest;\n+\t\t\t      bb = rotate_loop (best_edge, trace, *n_traces);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* The loop has less than 4 iterations.  */\n+\n+\t\t\t  /* Check whether there is another edge from BB.  */\n+\t\t\t  edge another_edge;\n+\t\t\t  for (another_edge = bb->succ;\n+\t\t\t       another_edge;\n+\t\t\t       another_edge = another_edge->succ_next)\n+\t\t\t    if (another_edge != best_edge)\n+\t\t\t      break;\n+\n+\t\t\t  if (!another_edge && copy_bb_p (best_edge->dest,\n+\t\t\t\t\t\t\t  !optimize_size))\n+\t\t\t    {\n+\t\t\t      bb = copy_bb (best_edge->dest, best_edge, bb,\n+\t\t\t\t\t    *n_traces);\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  /* Terminate the trace.  */\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Check for a situation\n+\n+\t\t    A\n+\t\t   /|\n+\t\t  B |\n+\t\t   \\|\n+\t\t    C\n+\n+\t\t  where\n+\t\t  EDGE_FREQUENCY (AB) + EDGE_FREQUENCY (BC)\n+\t\t    >= EDGE_FREQUENCY (AC).\n+\t\t  (i.e. 2 * B->frequency >= EDGE_FREQUENCY (AC) )\n+\t\t  Best ordering is then A B C.\n+\n+\t\t  This situation is created for example by:\n+\n+\t\t  if (A) B;\n+\t\t  C;\n+\n+\t\t  */\n+\n+\t\t  for (e = bb->succ; e; e = e->succ_next)\n+\t\t    if (e != best_edge\n+\t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n+\t\t\t&& !(e->flags & EDGE_COMPLEX)\n+\t\t\t&& !RBI (e->dest)->visited\n+\t\t\t&& !e->dest->pred->pred_next\n+\t\t\t&& e->dest->succ\n+\t\t\t&& (e->dest->succ->flags & EDGE_CAN_FALLTHRU)\n+\t\t\t&& !(e->dest->succ->flags & EDGE_COMPLEX)\n+\t\t\t&& !e->dest->succ->succ_next\n+\t\t\t&& e->dest->succ->dest == best_edge->dest\n+\t\t\t&& 2 * e->dest->frequency >= EDGE_FREQUENCY (best_edge))\n+\t\t      {\n+\t\t\tbest_edge = e;\n+\t\t\tif (rtl_dump_file)\n+\t\t\t  fprintf (rtl_dump_file, \"Selecting BB %d\\n\",\n+\t\t\t\t   best_edge->dest->index);\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t  RBI (bb)->next = best_edge->dest;\n+\t\t  bb = best_edge->dest;\n+\t\t}\n+\t    }\n+\t}\n+      while (best_edge);\n+      trace->last = bb;\n+      bbd[trace->first->index].start_of_trace = *n_traces - 1;\n+      bbd[trace->last->index].end_of_trace = *n_traces - 1;\n+\n+      /* The trace is terminated so we have to recount the keys in heap\n+\t (some block can have a lower key because now one of its predecessors\n+\t is an end of the trace).  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR\n+\t      || RBI (e->dest)->visited)\n+\t    continue;\n+\n+\t  if (bbd[e->dest->index].heap)\n+\t    {\n+\t      key = bb_to_key (e->dest);\n+\t      if (key != bbd[e->dest->index].node->key)\n+\t\t{\n+\t\t  if (rtl_dump_file)\n+\t\t    {\n+\t\t      fprintf (rtl_dump_file,\n+\t\t\t       \"Changing key for bb %d from %ld to %ld.\\n\",\n+\t\t\t       e->dest->index,\n+\t\t\t       (long) bbd[e->dest->index].node->key, key);\n+\t\t    }\n+\t\t  fibheap_replace_key (bbd[e->dest->index].heap,\n+\t\t\t\t       bbd[e->dest->index].node,\n+\t\t\t\t       key);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  fibheap_delete (*heap);\n+\n+  /* \"Return\" the new heap.  */\n+  *heap = new_heap;\n+}\n+\n+/* Create a duplicate of the basic block OLD_BB and redirect edge E to it, add\n+   it to trace after BB, mark OLD_BB visited and update pass' data structures\n+   (TRACE is a number of trace which OLD_BB is duplicated to).  */\n \n static basic_block\n-make_reorder_chain_1 (bb, prev)\n+copy_bb (old_bb, e, bb, trace)\n+     basic_block old_bb;\n+     edge e;\n      basic_block bb;\n-     basic_block prev;\n+     int trace;\n {\n-  edge e;\n-  basic_block next;\n-  rtx note;\n+  basic_block new_bb;\n+\n+  new_bb = cfg_layout_duplicate_bb (old_bb, e);\n+  if (e->dest != new_bb)\n+    abort ();\n+  if (RBI (e->dest)->visited)\n+    abort ();\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"Duplicated bb %d (created bb %d)\\n\",\n+\t     old_bb->index, new_bb->index);\n+  RBI (new_bb)->visited = trace;\n+  RBI (new_bb)->next = RBI (bb)->next;\n+  RBI (bb)->next = new_bb;\n \n-  /* Mark this block visited.  */\n-  if (prev)\n+  if (new_bb->index >= array_size || last_basic_block > array_size)\n     {\n- restart:\n-      RBI (prev)->next = bb;\n+      int i;\n+      int new_size;\n+\n+      new_size = MAX (last_basic_block, new_bb->index + 1);\n+      new_size = GET_ARRAY_SIZE (new_size);\n+      bbd = xrealloc (bbd, new_size * sizeof (bbro_basic_block_data));\n+      for (i = array_size; i < new_size; i++)\n+\t{\n+\t  bbd[i].start_of_trace = -1;\n+\t  bbd[i].end_of_trace = -1;\n+\t  bbd[i].heap = NULL;\n+\t  bbd[i].node = NULL;\n+\t}\n+      array_size = new_size;\n \n-      if (rtl_dump_file && prev->next_bb != bb)\n-\tfprintf (rtl_dump_file, \"Reordering block %d after %d\\n\",\n-\t\t bb->index, prev->index);\n+      if (rtl_dump_file)\n+\t{\n+\t  fprintf (rtl_dump_file,\n+\t\t   \"Growing the dynamic array to %d elements.\\n\",\n+\t\t   array_size);\n+\t}\n     }\n-  else\n+\n+  return new_bb;\n+}\n+\n+/* Compute and return the key (for the heap) of the basic block BB.  */\n+\n+static fibheapkey_t\n+bb_to_key (bb)\n+     basic_block bb;\n+{\n+  edge e;\n+\n+  int priority = 0;\n+\n+  /* Do not start in probably never executed blocks.  */\n+  if (probably_never_executed_bb_p (bb))\n+    return BB_FREQ_MAX;\n+\n+  /* Prefer blocks whose predecessor is an end of some trace\n+     or whose predecessor edge is EDGE_DFS_BACK.  */\n+  for (e = bb->pred; e; e = e->pred_next)\n     {\n-      if (bb->prev_bb != ENTRY_BLOCK_PTR)\n-\tabort ();\n+      if ((e->src != ENTRY_BLOCK_PTR && bbd[e->src->index].end_of_trace >= 0)\n+\t  || (e->flags & EDGE_DFS_BACK))\n+\t{\n+\t  int edge_freq = EDGE_FREQUENCY (e);\n+\n+\t  if (edge_freq > priority)\n+\t    priority = edge_freq;\n+\t}\n     }\n-  RBI (bb)->visited = 1;\n-  prev = bb;\n \n-  if (bb->succ == NULL)\n-    return prev;\n+  if (priority)\n+    /* The block with priority should have significantly lower key.  */\n+    return -(100 * BB_FREQ_MAX + 100 * priority + bb->frequency);\n+  return -bb->frequency;\n+}\n+\n+/* Return true when the edge E from basic block BB is better than the temporary\n+   best edge (details are in function).  The probability of edge E is PROB. The\n+   frequency of the successor is FREQ.  The current best probability is\n+   BEST_PROB, the best frequency is BEST_FREQ.\n+   The edge is considered to be equivalent when PROB does not differ much from\n+   BEST_PROB; similarly for frequency.  */\n+\n+static bool\n+better_edge_p (bb, e, prob, freq, best_prob, best_freq)\n+     basic_block bb;\n+     edge e;\n+     int prob;\n+     int freq;\n+     int best_prob;\n+     int best_freq;\n+{\n+  bool is_better_edge;\n \n-  /* Find the most probable block.  */\n+  /* The BEST_* values do not have to be best, but can be a bit smaller than\n+     maximum values.  */\n+  int diff_prob = best_prob / 10;\n+  int diff_freq = best_freq / 10;\n \n-  next = NULL;\n-  if (any_condjump_p (bb->end)\n-      && (note = find_reg_note (bb->end, REG_BR_PROB, 0)) != NULL)\n+  if (prob > best_prob + diff_prob)\n+    /* The edge has higher probability than the temporary best edge.  */\n+    is_better_edge = true;\n+  else if (prob < best_prob - diff_prob)\n+    /* The edge has lower probability than the temporary best edge.  */\n+    is_better_edge = false;\n+  else if (freq < best_freq - diff_freq)\n+    /* The edge and the temporary best edge  have almost equivalent\n+       probabilities.  The higher frequency of a successor now means\n+       that there is another edge going into that successor.\n+       This successor has lower frequency so it is better.  */\n+    is_better_edge = true;\n+  else if (freq > best_freq + diff_freq)\n+    /* This successor has higher frequency so it is worse.  */\n+    is_better_edge = false;\n+  else if (e->dest->prev_bb == bb)\n+    /* The edges have equivalent probabilities and the successors\n+       have equivalent frequencies.  Select the previous successor.  */\n+    is_better_edge = true;\n+  else\n+    is_better_edge = false;\n+\n+  return is_better_edge;\n+}\n+\n+/* Connect traces in array TRACES, N_TRACES is the count of traces.  */\n+\n+static void\n+connect_traces (n_traces, traces)\n+     int n_traces;\n+     struct trace *traces;\n+{\n+  int i;\n+  bool *connected;\n+  int last_trace;\n+  int freq_threshold;\n+  gcov_type count_threshold;\n+\n+  freq_threshold = max_entry_frequency * DUPLICATION_THRESHOLD / 1000;\n+  if (max_entry_count < INT_MAX / 1000)\n+    count_threshold = max_entry_count * DUPLICATION_THRESHOLD / 1000;\n+  else\n+    count_threshold = max_entry_count / 1000 * DUPLICATION_THRESHOLD;\n+\n+  connected = xcalloc (n_traces, sizeof (bool));\n+  last_trace = -1;\n+  for (i = 0; i < n_traces; i++)\n     {\n-      int taken, probability;\n-      edge e_taken, e_fall;\n+      int t = i;\n+      int t2;\n+      edge e, best;\n+      int best_len;\n \n-      probability = INTVAL (XEXP (note, 0));\n-      taken = probability > REG_BR_PROB_BASE / 2;\n+      if (connected[t])\n+\tcontinue;\n \n-      /* Find the normal taken edge and the normal fallthru edge.\n+      connected[t] = true;\n \n-\t Note, conditional jumps with other side effects may not\n-\t be fully optimized.  In this case it is possible for\n-\t the conditional jump to branch to the same location as\n-\t the fallthru path.\n+      /* Find the predecessor traces.  */\n+      for (t2 = t; t2 > 0;)\n+\t{\n+\t  best = NULL;\n+\t  best_len = 0;\n+\t  for (e = traces[t2].first->pred; e; e = e->pred_next)\n+\t    {\n+\t      int si = e->src->index;\n \n-\t We should probably work to improve optimization of that\n-\t case; however, it seems silly not to also deal with such\n-\t problems here if they happen to occur.  */\n+\t      if (e->src != ENTRY_BLOCK_PTR\n+\t\t  && (e->flags & EDGE_CAN_FALLTHRU)\n+\t\t  && !(e->flags & EDGE_COMPLEX)\n+\t\t  && bbd[si].end_of_trace >= 0\n+\t\t  && !connected[bbd[si].end_of_trace]\n+\t\t  && (!best\n+\t\t      || e->probability > best->probability\n+\t\t      || (e->probability == best->probability\n+\t\t\t  && traces[bbd[si].end_of_trace].length > best_len)))\n+\t\t{\n+\t\t  best = e;\n+\t\t  best_len = traces[bbd[si].end_of_trace].length;\n+\t\t}\n+\t    }\n+\t  if (best)\n+\t    {\n+\t      RBI (best->src)->next = best->dest;\n+\t      t2 = bbd[best->src->index].end_of_trace;\n+\t      connected[t2] = true;\n+\t      if (rtl_dump_file)\n+\t\t{\n+\t\t  fprintf (rtl_dump_file, \"Connection: %d %d\\n\",\n+\t\t\t   best->src->index, best->dest->index);\n+\t\t}\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n \n-      e_taken = e_fall = NULL;\n-      for (e = bb->succ; e ; e = e->succ_next)\n+      if (last_trace >= 0)\n+\tRBI (traces[last_trace].last)->next = traces[t2].first;\n+      last_trace = t;\n+\n+      /* Find the successor traces.  */\n+      while (1)\n \t{\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    e_fall = e;\n-\t  else if (! (e->flags & EDGE_EH))\n-\t    e_taken = e;\n+\t  /* Find the continuation of the chain.  */\n+\t  best = NULL;\n+\t  best_len = 0;\n+\t  for (e = traces[t].last->succ; e; e = e->succ_next)\n+\t    {\n+\t      int di = e->dest->index;\n+\n+\t      if (e->dest != EXIT_BLOCK_PTR\n+\t\t  && (e->flags & EDGE_CAN_FALLTHRU)\n+\t\t  && !(e->flags & EDGE_COMPLEX)\n+\t\t  && bbd[di].start_of_trace >= 0\n+\t\t  && !connected[bbd[di].start_of_trace]\n+\t\t  && (!best\n+\t\t      || e->probability > best->probability\n+\t\t      || (e->probability == best->probability\n+\t\t\t  && traces[bbd[di].start_of_trace].length > best_len)))\n+\t\t{\n+\t\t  best = e;\n+\t\t  best_len = traces[bbd[di].start_of_trace].length;\n+\t\t}\n+\t    }\n+\n+\t  if (best)\n+\t    {\n+\t      if (rtl_dump_file)\n+\t\t{\n+\t\t  fprintf (rtl_dump_file, \"Connection: %d %d\\n\",\n+\t\t\t   best->src->index, best->dest->index);\n+\t\t}\n+\t      t = bbd[best->dest->index].start_of_trace;\n+\t      RBI (traces[last_trace].last)->next = traces[t].first;\n+\t      connected[t] = true;\n+\t      last_trace = t;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Try to connect the traces by duplication of 1 block.  */\n+\t      edge e2;\n+\t      basic_block next_bb = NULL;\n+\n+\t      for (e = traces[t].last->succ; e; e = e->succ_next)\n+\t\tif (e->dest != EXIT_BLOCK_PTR\n+\t\t    && (e->flags & EDGE_CAN_FALLTHRU)\n+\t\t    && !(e->flags & EDGE_COMPLEX)\n+\t\t    && (EDGE_FREQUENCY (e) >= freq_threshold)\n+\t\t    && (e->count >= count_threshold)\n+\t\t    && (!best\n+\t\t\t|| e->probability > best->probability))\n+\t\t  {\n+\t\t    edge best2 = NULL;\n+\t\t    int best2_len = 0;\n+\n+\t\t    for (e2 = e->dest->succ; e2; e2 = e2->succ_next)\n+\t\t      {\n+\t\t\tint di = e2->dest->index;\n+\n+\t\t\tif (e2->dest == EXIT_BLOCK_PTR\n+\t\t\t    || ((e2->flags & EDGE_CAN_FALLTHRU)\n+\t\t\t\t&& !(e2->flags & EDGE_COMPLEX)\n+\t\t\t\t&& bbd[di].start_of_trace >= 0\n+\t\t\t\t&& !connected[bbd[di].start_of_trace]\n+\t\t\t\t&& (EDGE_FREQUENCY (e2) >= freq_threshold)\n+\t\t\t\t&& (e2->count >= count_threshold)\n+\t\t\t\t&& (!best2\n+\t\t\t\t    || e2->probability > best2->probability\n+\t\t\t\t    || (e2->probability == best2->probability\n+\t\t\t\t\t&& traces[bbd[di].start_of_trace].length\n+\t\t\t\t\t   > best2_len))))\n+\t\t\t  {\n+\t\t\t    best = e;\n+\t\t\t    best2 = e2;\n+\t\t\t    if (e2->dest != EXIT_BLOCK_PTR)\n+\t\t\t      best2_len = traces[bbd[di].start_of_trace].length;\n+\t\t\t    else\n+\t\t\t      best2_len = INT_MAX;\n+\t\t\t    next_bb = e2->dest;\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\t      if (best && next_bb && copy_bb_p (best->dest, !optimize_size))\n+\t\t{\n+\t\t  basic_block new_bb;\n+\n+\t\t  if (rtl_dump_file)\n+\t\t    {\n+\t\t      fprintf (rtl_dump_file, \"Connection: %d %d \",\n+\t\t\t       traces[t].last->index, best->dest->index);\n+\t\t      if (next_bb == EXIT_BLOCK_PTR)\n+\t\t\tfprintf (rtl_dump_file, \"exit\\n\");\n+\t\t      else\n+\t\t\tfprintf (rtl_dump_file, \"%d\\n\", next_bb->index);\n+\t\t    }\n+\n+\t\t  new_bb = copy_bb (best->dest, best, traces[t].last, t);\n+\t\t  traces[t].last = new_bb;\n+\t\t  if (next_bb != EXIT_BLOCK_PTR)\n+\t\t    {\n+\t\t      t = bbd[next_bb->index].start_of_trace;\n+\t\t      RBI (traces[last_trace].last)->next = traces[t].first;\n+\t\t      connected[t] = true;\n+\t\t      last_trace = t;\n+\t\t    }\n+\t\t  else\n+\t\t    break;\t/* Stop finding the successor traces.  */\n+\t\t}\n+\t      else\n+\t\tbreak;\t/* Stop finding the successor traces.  */\n+\t    }\n \t}\n+    }\n+\n+  if (rtl_dump_file)\n+    {\n+      basic_block bb;\n \n-      next = ((taken && e_taken) ? e_taken : e_fall)->dest;\n+      fprintf (rtl_dump_file, \"Final order:\\n\");\n+      for (bb = traces[0].first; bb; bb = RBI (bb)->next)\n+\tfprintf (rtl_dump_file, \"%d \", bb->index);\n+      fprintf (rtl_dump_file, \"\\n\");\n+      fflush (rtl_dump_file);\n     }\n \n-  /* In the absence of a prediction, disturb things as little as possible\n-     by selecting the old \"next\" block from the list of successors.  If\n-     there had been a fallthru edge, that will be the one.  */\n-  /* Note that the fallthru block may not be next any time we eliminate\n-     forwarder blocks.  */\n-  if (! next)\n+  FREE (connected);\n+}\n+\n+/* Return true when BB can and should be copied. CODE_MAY_GROW is true\n+   when code size is allowed to grow by duplication.  */\n+\n+static bool\n+copy_bb_p (bb, code_may_grow)\n+     basic_block bb;\n+     int code_may_grow;\n+{\n+  int size = 0;\n+  int max_size = uncond_jump_length;\n+  rtx insn;\n+\n+  if (!bb->frequency)\n+    return false;\n+  if (!bb->pred || !bb->pred->pred_next)\n+    return false;\n+  if (!cfg_layout_can_duplicate_bb_p (bb))\n+    return false;\n+\n+  if (code_may_grow && maybe_hot_bb_p (bb))\n+    max_size *= 8;\n+\n+  for (insn = bb->head; insn != NEXT_INSN (bb->end);\n+       insn = NEXT_INSN (insn))\n     {\n-      for (e = bb->succ; e ; e = e->succ_next)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  {\n-\t    next = e->dest;\n-\t    break;\n-\t  }\n-\telse if (e->dest == bb->next_bb)\n-\t  {\n-\t    if (! (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\t      next = e->dest;\n-\t  }\n+      if (INSN_P (insn))\n+\tsize += get_attr_length (insn);\n     }\n \n-  /* Make sure we didn't select a silly next block.  */\n-  if (! next || next == EXIT_BLOCK_PTR || RBI (next)->visited)\n-    next = NULL;\n-\n-  /* Recurse on the successors.  Unroll the last call, as the normal\n-     case is exactly one or two edges, and we can tail recurse.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n-    if (e->dest != EXIT_BLOCK_PTR\n-\t&& ! RBI (e->dest)->visited\n-\t&& e->dest->succ\n-\t&& ! (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-      {\n-\tif (next)\n-\t  {\n-\t    prev = make_reorder_chain_1 (next, prev);\n-\t    next = RBI (e->dest)->visited ? NULL : e->dest;\n-\t  }\n-\telse\n-\t  next = e->dest;\n-      }\n-  if (next)\n+  if (size <= max_size)\n+    return true;\n+\n+  if (rtl_dump_file)\n     {\n-      bb = next;\n-      goto restart;\n+      fprintf (rtl_dump_file,\n+\t       \"Block %d can't be copied because its size = %d.\\n\",\n+\t       bb->index, size);\n     }\n \n-  return prev;\n+  return false;\n+}\n+\n+/* Return the length of unconditional jump instruction.  */\n+\n+static int\n+get_uncond_jump_length ()\n+{\n+  rtx label, jump;\n+  int length;\n+\n+  label = emit_label_before (gen_label_rtx (), get_insns ());\n+  jump = emit_jump_insn (gen_jump (label));\n+\n+  length = get_attr_length (jump);\n+\n+  delete_insn (jump);\n+  delete_insn (label);\n+  return length;\n }\n \n /* Reorder basic blocks.  The main entry point to this file.  */\n \n void\n reorder_basic_blocks ()\n {\n+  int n_traces;\n+  int i;\n+  struct trace *traces;\n+\n   if (n_basic_blocks <= 1)\n     return;\n \n@@ -270,7 +1068,31 @@ reorder_basic_blocks ()\n \n   cfg_layout_initialize (NULL);\n \n-  make_reorder_chain ();\n+  set_edge_can_fallthru_flag ();\n+  mark_dfs_back_edges ();\n+\n+  /* We are estimating the lenght of uncond jump insn only once since the code\n+     for getting the insn lenght always returns the minimal length now.  */\n+  if (uncond_jump_length == 0) \n+    uncond_jump_length = get_uncond_jump_length ();\n+\n+  /* We need to know some information for each basic block.  */\n+  array_size = GET_ARRAY_SIZE (last_basic_block);\n+  bbd = xmalloc (array_size * sizeof (bbro_basic_block_data));\n+  for (i = 0; i < array_size; i++)\n+    {\n+      bbd[i].start_of_trace = -1;\n+      bbd[i].end_of_trace = -1;\n+      bbd[i].heap = NULL;\n+      bbd[i].node = NULL;\n+    }\n+\n+  traces = xmalloc (n_basic_blocks * sizeof (struct trace));\n+  n_traces = 0;\n+  find_traces (&n_traces, traces);\n+  connect_traces (n_traces, traces);\n+  FREE (traces);\n+  FREE (bbd);\n \n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);"}, {"sha": "2a23cc08fabf7727a88b25ed3cb1e9cac15862e0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa634f11e65d7630b96742a4f3d187d920e0c87e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=aa634f11e65d7630b96742a4f3d187d920e0c87e", "patch": "@@ -1143,17 +1143,6 @@ outgoing_edges_match (mode, bb1, bb2)\n \t  || !onlyjump_p (bb2->end))\n \treturn false;\n \n-      /* Do not crossjump across loop boundaries.  This is a temporary\n-\t workaround for the common scenario in which crossjumping results\n-\t in killing the duplicated loop condition, making bb-reorder rotate\n-\t the loop incorrectly, leaving an extra unconditional jump inside\n-\t the loop.\n-\n-\t This check should go away once bb-reorder knows how to duplicate\n-\t code in this case or rotate the loops to avoid this scenario.  */\n-      if (bb1->loop_depth != bb2->loop_depth)\n-\treturn false;\n-\n       b1 = BRANCH_EDGE (bb1);\n       b2 = BRANCH_EDGE (bb2);\n       f1 = FALLTHRU_EDGE (bb1);"}]}