{"sha": "159313d9b196502f062bb15192127a26a351f90c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5MzEzZDliMTk2NTAyZjA2MmJiMTUxOTIxMjdhMjZhMzUxZjkwYw==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:34:12Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:34:12Z"}, "message": "[AArch64] Simplify epilogue expansion using new helper functions.\n\nFrom-SVN: r212958", "tree": {"sha": "6c816fc732e352131de495a5e415987c2cc28f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c816fc732e352131de495a5e415987c2cc28f13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/159313d9b196502f062bb15192127a26a351f90c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159313d9b196502f062bb15192127a26a351f90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159313d9b196502f062bb15192127a26a351f90c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159313d9b196502f062bb15192127a26a351f90c/comments", "author": null, "committer": null, "parents": [{"sha": "80c11907f753eb86fe1b31538019cb2cc5355042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c11907f753eb86fe1b31538019cb2cc5355042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c11907f753eb86fe1b31538019cb2cc5355042"}], "stats": {"total": 122, "additions": 74, "deletions": 48}, "files": [{"sha": "ba91b9f210cfb6d9373f1bc78e99d8358deea260", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159313d9b196502f062bb15192127a26a351f90c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159313d9b196502f062bb15192127a26a351f90c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=159313d9b196502f062bb15192127a26a351f90c", "patch": "@@ -1,3 +1,10 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_popwb_pair_reg)\n+\t(aarch64_gen_loadwb_pair): New helper function.\n+\t(aarch64_expand_epilogue): Simplify code using new helper functions.\n+\t* config/aarch64/aarch64.md (loadwb_pair<GPF:mode>_<P:mode>): Define.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_pushwb_pair_reg)"}, {"sha": "5da7891e7a000de0c5d255a02d75590f8865ca97", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159313d9b196502f062bb15192127a26a351f90c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159313d9b196502f062bb15192127a26a351f90c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=159313d9b196502f062bb15192127a26a351f90c", "patch": "@@ -1951,6 +1951,46 @@ aarch64_pushwb_pair_reg (enum machine_mode mode, unsigned regno1,\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n+static rtx\n+aarch64_gen_loadwb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n+\t\t\t HOST_WIDE_INT adjustment)\n+{\n+  switch (mode)\n+    {\n+    case DImode:\n+      return gen_loadwb_pairdi_di (base, base, reg, reg2, GEN_INT (adjustment),\n+\t\t\t\t   GEN_INT (adjustment + UNITS_PER_WORD));\n+    case DFmode:\n+      return gen_loadwb_pairdf_di (base, base, reg, reg2, GEN_INT (adjustment),\n+\t\t\t\t   GEN_INT (adjustment + UNITS_PER_WORD));\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static void\n+aarch64_popwb_pair_reg (enum machine_mode mode, unsigned regno1,\n+\t\t\tunsigned regno2, HOST_WIDE_INT adjustment, rtx cfa)\n+{\n+  rtx insn;\n+  rtx reg1 = gen_rtx_REG (mode, regno1);\n+  rtx reg2 = gen_rtx_REG (mode, regno2);\n+\n+  insn = emit_insn (aarch64_gen_loadwb_pair (mode, stack_pointer_rtx, reg1,\n+\t\t\t\t\t     reg2, adjustment));\n+  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 2)) = 1;\n+  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (cfa)\n+    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t  (gen_rtx_SET (Pmode, stack_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, cfa, adjustment))));\n+\n+  add_reg_note (insn, REG_CFA_RESTORE, reg1);\n+  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n+}\n+\n static rtx\n aarch64_gen_store_pair (enum machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n \t\t\trtx reg2)\n@@ -2331,69 +2371,32 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfa_reg = stack_pointer_rtx;\n     }\n \n-  aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n-\t\t\t\tframe_pointer_needed ? R28_REGNUM : R30_REGNUM);\n   aarch64_restore_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM);\n \n-  /* Restore the frame pointer and lr if the frame pointer is needed.  */\n   if (offset > 0)\n     {\n       if (frame_pointer_needed)\n \t{\n-\t  rtx mem_fp, mem_lr;\n-\n-\t  if (fp_offset)\n-\t    {\n-\t      mem_fp = gen_frame_mem (DImode,\n-\t\t\t\t      plus_constant (Pmode,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     fp_offset));\n-\t      mem_lr = gen_frame_mem (DImode,\n-\t\t\t\t      plus_constant (Pmode,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     fp_offset\n-\t\t\t\t\t\t     + UNITS_PER_WORD));\n-\t      insn = emit_insn (gen_load_pairdi (hard_frame_pointer_rtx,\n-\t\t\t\t\t\t mem_fp,\n-\t\t\t\t\t\t gen_rtx_REG (DImode,\n-\t\t\t\t\t\t\t      LR_REGNUM),\n-\t\t\t\t\t\t mem_lr));\n-\t    }\n-\t  else\n-\t    {\n-\t      insn = emit_insn (gen_loadwb_pairdi_di\n-\t\t\t\t(stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t hard_frame_pointer_rtx,\n-\t\t\t\t gen_rtx_REG (DImode, LR_REGNUM),\n-\t\t\t\t GEN_INT (offset),\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (DImode) + offset)));\n-\t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 2)) = 1;\n-\t      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t\t    (gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t  plus_constant (Pmode, cfa_reg,\n-\t\t\t\t\t\t\t offset))));\n-\t    }\n-\n-\t  /* The first part of a frame-related parallel insn\n-\t     is always assumed to be relevant to the frame\n-\t     calculations; subsequent parts, are only\n-\t     frame-related if explicitly marked.  */\n-\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n-\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\tgen_rtx_REG (DImode, LR_REGNUM));\n-\n \t  if (fp_offset)\n \t    {\n+\t      aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t\t    R30_REGNUM);\n \t      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t       GEN_INT (offset)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n+\t  else\n+\t    {\n+\t      aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t\t    R28_REGNUM);\n+\t      aarch64_popwb_pair_reg (DImode, R29_REGNUM, R30_REGNUM, offset,\n+\t\t\t\t      cfa_reg);\n+\t    }\n \t}\n       else\n \t{\n+\t  aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t\tR30_REGNUM);\n \t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (offset)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;"}, {"sha": "85bf2a7a5319ef3486927691c2f837859cbda4ca", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159313d9b196502f062bb15192127a26a351f90c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159313d9b196502f062bb15192127a26a351f90c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=159313d9b196502f062bb15192127a26a351f90c", "patch": "@@ -1034,6 +1034,22 @@\n   [(set_attr \"type\" \"load2\")]\n )\n \n+(define_insn \"loadwb_pair<GPF:mode>_<P:mode>\"\n+  [(parallel\n+    [(set (match_operand:P 0 \"register_operand\" \"=k\")\n+          (plus:P (match_operand:P 1 \"register_operand\" \"0\")\n+                  (match_operand:P 4 \"const_int_operand\" \"n\")))\n+     (set (match_operand:GPF 2 \"register_operand\" \"=w\")\n+          (mem:GPF (plus:P (match_dup 1)\n+                   (match_dup 4))))\n+     (set (match_operand:GPF 3 \"register_operand\" \"=w\")\n+          (mem:GPF (plus:P (match_dup 1)\n+                   (match_operand:P 5 \"const_int_operand\" \"n\"))))])]\n+  \"INTVAL (operands[5]) == INTVAL (operands[4]) + GET_MODE_SIZE (<GPF:MODE>mode)\"\n+  \"ldp\\\\t%<w>2, %<w>3, [%1], %4\"\n+  [(set_attr \"type\" \"neon_load1_2reg\")]\n+)\n+\n ;; Store pair with writeback.  This is primarily used in function prologues\n ;; when saving [fp,lr]\n (define_insn \"storewb_pair<GPI:mode>_<P:mode>\""}]}