{"sha": "6f43c1574270007f27ed66cde3ea9679095d3334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY0M2MxNTc0MjcwMDA3ZjI3ZWQ2NmNkZTNlYTk2NzkwOTVkMzMzNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-11T01:15:31Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-11T01:15:31Z"}, "message": "(expand_binop): Fix typo, `mode' => `methods'.\n\n(expand_binop): Delete #ifdef GPC; complex code now uncond.\n\n(expand_binop): Fix typo, `mode' => `methods'.\n\nFrom-SVN: r2101", "tree": {"sha": "81b89654f73672c398b39ec25504608727d8d895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b89654f73672c398b39ec25504608727d8d895"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f43c1574270007f27ed66cde3ea9679095d3334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f43c1574270007f27ed66cde3ea9679095d3334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f43c1574270007f27ed66cde3ea9679095d3334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f43c1574270007f27ed66cde3ea9679095d3334/comments", "author": null, "committer": null, "parents": [{"sha": "f12b8918d7d396b7c46a689274c8a7163a94f1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12b8918d7d396b7c46a689274c8a7163a94f1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12b8918d7d396b7c46a689274c8a7163a94f1bf"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "390cb7297d2001686473f543e424f2448d10eaf2", "filename": "gcc/optabs.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f43c1574270007f27ed66cde3ea9679095d3334/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f43c1574270007f27ed66cde3ea9679095d3334/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6f43c1574270007f27ed66cde3ea9679095d3334", "patch": "@@ -443,7 +443,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n      wider mode as well.  */\n \n   if ((class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n-      && mode != OPTAB_DIRECT && mode != OPTAB_LIB)\n+      && methods != OPTAB_DIRECT && methods != OPTAB_LIB)\n     for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n@@ -829,20 +829,17 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       delete_insns_since (last);\n     }\n \n-#ifdef GPC\n   /* We need to open-code the complex type operations: '+, -, * and /' */\n \n   /* At this point we allow operations between two similar complex\n      numbers, and also if one of the operands is not a complex number\n      but rather of MODE_FLOAT or MODE_INT. However, the caller\n      must make sure that the MODE of the non-complex operand matches\n-     the SUBMODE of the complex operand.\n-     @@ Perhaps the conversion to complex numbers should be somewhere else.\n-     @@ This is not tested very much.\n-   */\n+     the SUBMODE of the complex operand.  */\n \n   if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n-    { rtx real0 = (rtx) 0;\n+    {\n+      rtx real0 = (rtx) 0;\n       rtx imag0 = (rtx) 0;\n       rtx real1 = (rtx) 0;\n       rtx imag1 = (rtx) 0;\n@@ -853,10 +850,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       rtx equiv_value;\n \n       /* Find the correct mode for the real and imaginary parts */\n-      enum machine_mode submode =\n-\tmode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n-\t\t       class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n-\t\t       0);\n+      enum machine_mode submode\n+\t= mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t\t class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n+\t\t\t 0);\n \n       if (submode == BLKmode)\n \tabort ();\n@@ -888,9 +885,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       if (! real0 || ! real1 || ! (imag0 || imag1))\n \tabort ();\n \n-      switch (binoptab->code) {\n-      case PLUS:\n-      case MINUS:\n+      switch (binoptab->code)\n+\t{\n+\tcase PLUS:\n+\tcase MINUS:\n \t  res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t      realr, unsignedp, methods);\n \t  if (res != realr)\n@@ -909,7 +907,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (res != imagr)\n \t    emit_move_insn (imagr, res);\n \t  break;\n-      case MULT:\n+\n+\tcase MULT:\n \t  /* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */\n \n \t  res = expand_binop (submode, binoptab, real0, real1,\n@@ -952,11 +951,13 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\temit_move_insn (imagr, res);\n \t    }\n \t  break;\n-      case DIV:\n+\n+\tcase DIV:\n \t  /* (c+id)/(a+ib) == ((c+id)*(a-ib))/(a*a+b*b) */\n \t  \n \t  if (! imag1)\n-\t    { /* Simply divide the real and imaginary parts by `a' */\n+\t    {\n+\t      /* Simply divide the real and imaginary parts by `a' */\n \t      res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t\t  realr, unsignedp, methods);\n \t      if (res != realr)\n@@ -967,8 +968,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      if (res != imagr)\n \t\temit_move_insn (imagr, res);\n \t    }\n-\t  else /* Divider is of complex type */\n-\t    {  /* X/(a+ib) */\n+\t  else\t\t\t/* Divider is of complex type */\n+\t    {\t\t\t/* X/(a+ib) */\n \n \t      rtx divider;\n \t      rtx real_t;\n@@ -978,27 +979,27 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t      /* Divider: a*a + b*b */\n \t      divider = expand_binop (submode, add_optab,\n-\t\t\t\t     expand_binop (submode, mulopt,\n-\t\t\t\t\t\t   real1, real1,\n-\t\t\t\t\t\t   0, unsignedp, methods),\n-\t\t\t\t     expand_binop (submode, mulopt,\n-\t\t\t\t\t\t   imag1, imag1,\n-\t\t\t\t\t\t   0, unsignedp, methods),\n-\t\t\t\t     0, unsignedp, methods);\n-\n-\t      if (! imag0) /* ((c)(a-ib))/divider */\n+\t\t\t\t      expand_binop (submode, mulopt,\n+\t\t\t\t\t\t    real1, real1,\n+\t\t\t\t\t\t    0, unsignedp, methods),\n+\t\t\t\t      expand_binop (submode, mulopt,\n+\t\t\t\t\t\t    imag1, imag1,\n+\t\t\t\t\t\t    0, unsignedp, methods),\n+\t\t\t\t      0, unsignedp, methods);\n+\n+\t      if (! imag0)\t/* ((c)(a-ib))/divider */\n \t\t{\n \t\t  /* Calculate the divident */\n \t\t  real_t = expand_binop (submode, mulopt, real0, real1,\n \t\t\t\t\t 0, unsignedp, methods);\n \t\t  \n-\t\t  imag_t =\n-\t\t    expand_unop (submode, neg_optab,\n-\t\t\t\t expand_binop (submode, mulopt, real0, imag1,\n-\t\t\t\t\t       0, unsignedp, methods),\n-\t\t\t\t 0, unsignedp);\n+\t\t  imag_t\n+\t\t    = expand_unop (submode, neg_optab,\n+\t\t\t\t   expand_binop (submode, mulopt, real0, imag1,\n+\t\t\t\t\t\t 0, unsignedp, methods),\n+\t\t\t\t   0, unsignedp);\n \t\t}\n-\t      else /* ((c+id)(a-ib))/divider */\n+\t      else\t\t/* ((c+id)(a-ib))/divider */\n \t\t{\n \t\t  /* Calculate the divident */\n \t\t  real_t = expand_binop (submode, add_optab,\n@@ -1049,7 +1050,6 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       \n       return target;\n     }\n-#endif /* GPC */\n \n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */"}]}