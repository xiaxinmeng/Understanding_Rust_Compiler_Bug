{"sha": "d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUxOWFlZGE4YjczYWI3YTk2OTdiMTgxN2VkNDY1NWRmYjViYmRiNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-18T14:51:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-18T14:51:13Z"}, "message": "libgo: remove old/regexp and old/template\n    \n    They were removed from the master Go library in 2012\n    (https://golang.org/cl/5979046) but somehow that was not reflected here.\n    \n    Reviewed-on: https://go-review.googlesource.com/33391\n\nFrom-SVN: r242592", "tree": {"sha": "961ed32b1c96704630ce1287a70d48e207773365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961ed32b1c96704630ce1287a70d48e207773365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/comments", "author": null, "committer": null, "parents": [{"sha": "151c204ff8673a9c7efd2e6492b3765b60229f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151c204ff8673a9c7efd2e6492b3765b60229f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151c204ff8673a9c7efd2e6492b3765b60229f6d"}], "stats": {"total": 4519, "additions": 13, "deletions": 4506}, "files": [{"sha": "ce86c8d6abf724c7a871fcb40651db1ab11e1b7f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "patch": "@@ -1,4 +1,4 @@\n-bc5ad6d10092d6238495357468ee093f7caf39f9\n+2ab785788691ad289f838a0b3a6bc9013d0fc337\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3a84c04dd6c203f1b6891b2a8b3e9aaf197fd6cc", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "patch": "@@ -325,12 +325,6 @@ toolexeclibgonetrpcdir = $(toolexeclibgonetdir)/rpc\n toolexeclibgonetrpc_DATA = \\\n \tnet/rpc/jsonrpc.gox\n \n-toolexeclibgoolddir = $(toolexeclibgodir)/old\n-\n-toolexeclibgoold_DATA = \\\n-\told/regexp.gox \\\n-\told/template.gox\n-\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n toolexeclibgoos_DATA = \\\n@@ -801,8 +795,6 @@ PACKAGES = \\\n \tnet/smtp \\\n \tnet/textproto \\\n \tnet/url \\\n-\told/regexp \\\n-\told/template \\\n \tos \\\n \tos/exec \\\n \tos/signal \\\n@@ -1260,8 +1252,6 @@ TEST_PACKAGES = \\\n \tnet/textproto/check \\\n \tnet/url/check \\\n \tnet/rpc/jsonrpc/check \\\n-\told/regexp/check \\\n-\told/template/check \\\n \tos/exec/check \\\n \tos/signal/check \\\n \tos/user/check \\"}, {"sha": "cf5a0e2022df9b6d42769bfc66267a2af1539d53", "filename": "libgo/Makefile.in", "status": "modified", "additions": 12, "deletions": 48, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=d519aeda8b73ab7a9697b1817ed4655dfb5bbdb4", "patch": "@@ -139,7 +139,6 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgonetdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgonethttpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgoolddir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoosdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgopathdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoregexpdir)\" \\\n@@ -264,12 +263,11 @@ DATA = $(noinst_DATA) $(toolexeclibgo_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n \t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n \t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n-\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoold_DATA) \\\n-\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n-\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n-\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoos_DATA) \\\n+\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n+\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -713,11 +711,6 @@ toolexeclibgonetrpcdir = $(toolexeclibgonetdir)/rpc\n toolexeclibgonetrpc_DATA = \\\n \tnet/rpc/jsonrpc.gox\n \n-toolexeclibgoolddir = $(toolexeclibgodir)/old\n-toolexeclibgoold_DATA = \\\n-\told/regexp.gox \\\n-\told/template.gox\n-\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n toolexeclibgoos_DATA = \\\n \tos/exec.gox \\\n@@ -967,8 +960,6 @@ PACKAGES = \\\n \tnet/smtp \\\n \tnet/textproto \\\n \tnet/url \\\n-\told/regexp \\\n-\told/template \\\n \tos \\\n \tos/exec \\\n \tos/signal \\\n@@ -1300,8 +1291,6 @@ TEST_PACKAGES = \\\n \tnet/textproto/check \\\n \tnet/url/check \\\n \tnet/rpc/jsonrpc/check \\\n-\told/regexp/check \\\n-\told/template/check \\\n \tos/exec/check \\\n \tos/signal/check \\\n \tos/user/check \\\n@@ -2563,27 +2552,6 @@ uninstall-toolexeclibgonetrpcDATA:\n \t@list='$(toolexeclibgonetrpc_DATA)'; test -n \"$(toolexeclibgonetrpcdir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \tdir='$(DESTDIR)$(toolexeclibgonetrpcdir)'; $(am__uninstall_files_from_dir)\n-install-toolexeclibgooldDATA: $(toolexeclibgoold_DATA)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toolexeclibgoold_DATA)'; test -n \"$(toolexeclibgoolddir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoolddir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoolddir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoolddir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoolddir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toolexeclibgooldDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgoold_DATA)'; test -n \"$(toolexeclibgoolddir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(toolexeclibgoolddir)'; $(am__uninstall_files_from_dir)\n install-toolexeclibgoosDATA: $(toolexeclibgoos_DATA)\n \t@$(NORMAL_INSTALL)\n \t@list='$(toolexeclibgoos_DATA)'; test -n \"$(toolexeclibgoosdir)\" || list=; \\\n@@ -2914,7 +2882,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodatabasedir)\" \"$(DESTDIR)$(toolexeclibgodatabasesqldir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoimagecolordir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -2997,9 +2965,8 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgonethttpDATA \\\n-\tinstall-toolexeclibgonetrpcDATA install-toolexeclibgooldDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n-\tinstall-toolexeclibgoregexpDATA \\\n+\tinstall-toolexeclibgonetrpcDATA install-toolexeclibgoosDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgoregexpDATA \\\n \tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotestingDATA install-toolexeclibgotextDATA \\\n \tinstall-toolexeclibgotexttemplateDATA \\\n@@ -3066,8 +3033,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgonethttpDATA \\\n \tuninstall-toolexeclibgonetrpcDATA \\\n-\tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n-\tuninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n \tuninstall-toolexeclibgoregexpDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n@@ -3110,9 +3076,8 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgologDATA install-toolexeclibgomathDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgonethttpDATA \\\n-\tinstall-toolexeclibgonetrpcDATA install-toolexeclibgooldDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n-\tinstall-toolexeclibgoregexpDATA \\\n+\tinstall-toolexeclibgonetrpcDATA install-toolexeclibgoosDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgoregexpDATA \\\n \tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotestingDATA install-toolexeclibgotextDATA \\\n \tinstall-toolexeclibgotexttemplateDATA \\\n@@ -3143,8 +3108,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgonethttpDATA \\\n \tuninstall-toolexeclibgonetrpcDATA \\\n-\tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n-\tuninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n \tuninstall-toolexeclibgoregexpDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\"}, {"sha": "180dac4d455db6ff0decf8c5df9de52f23c0daf9", "filename": "libgo/go/old/regexp/all_test.go", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Fall_test.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,421 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package regexp\n-\n-import (\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-var good_re = []string{\n-\t``,\n-\t`.`,\n-\t`^.$`,\n-\t`a`,\n-\t`a*`,\n-\t`a+`,\n-\t`a?`,\n-\t`a|b`,\n-\t`a*|b*`,\n-\t`(a*|b)(c*|d)`,\n-\t`[a-z]`,\n-\t`[a-abc-c\\-\\]\\[]`,\n-\t`[a-z]+`,\n-\t`[]`,\n-\t`[abc]`,\n-\t`[^1234]`,\n-\t`[^\\n]`,\n-\t`\\!\\\\`,\n-}\n-\n-type stringError struct {\n-\tre  string\n-\terr error\n-}\n-\n-var bad_re = []stringError{\n-\t{`*`, ErrBareClosure},\n-\t{`+`, ErrBareClosure},\n-\t{`?`, ErrBareClosure},\n-\t{`(abc`, ErrUnmatchedLpar},\n-\t{`abc)`, ErrUnmatchedRpar},\n-\t{`x[a-z`, ErrUnmatchedLbkt},\n-\t{`abc]`, ErrUnmatchedRbkt},\n-\t{`[z-a]`, ErrBadRange},\n-\t{`abc\\`, ErrExtraneousBackslash},\n-\t{`a**`, ErrBadClosure},\n-\t{`a*+`, ErrBadClosure},\n-\t{`a??`, ErrBadClosure},\n-\t{`\\x`, ErrBadBackslash},\n-}\n-\n-func compileTest(t *testing.T, expr string, error error) *Regexp {\n-\tre, err := Compile(expr)\n-\tif err != error {\n-\t\tt.Error(\"compiling `\", expr, \"`; unexpected error: \", err.Error())\n-\t}\n-\treturn re\n-}\n-\n-func TestGoodCompile(t *testing.T) {\n-\tfor i := 0; i < len(good_re); i++ {\n-\t\tcompileTest(t, good_re[i], nil)\n-\t}\n-}\n-\n-func TestBadCompile(t *testing.T) {\n-\tfor i := 0; i < len(bad_re); i++ {\n-\t\tcompileTest(t, bad_re[i].re, bad_re[i].err)\n-\t}\n-}\n-\n-func matchTest(t *testing.T, test *FindTest) {\n-\tre := compileTest(t, test.pat, nil)\n-\tif re == nil {\n-\t\treturn\n-\t}\n-\tm := re.MatchString(test.text)\n-\tif m != (len(test.matches) > 0) {\n-\t\tt.Errorf(\"MatchString failure on %s: %t should be %t\", test, m, len(test.matches) > 0)\n-\t}\n-\t// now try bytes\n-\tm = re.Match([]byte(test.text))\n-\tif m != (len(test.matches) > 0) {\n-\t\tt.Errorf(\"Match failure on %s: %t should be %t\", test, m, len(test.matches) > 0)\n-\t}\n-}\n-\n-func TestMatch(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tmatchTest(t, &test)\n-\t}\n-}\n-\n-func matchFunctionTest(t *testing.T, test *FindTest) {\n-\tm, err := MatchString(test.pat, test.text)\n-\tif err == nil {\n-\t\treturn\n-\t}\n-\tif m != (len(test.matches) > 0) {\n-\t\tt.Errorf(\"Match failure on %s: %t should be %t\", test, m, len(test.matches) > 0)\n-\t}\n-}\n-\n-func TestMatchFunction(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tmatchFunctionTest(t, &test)\n-\t}\n-}\n-\n-type ReplaceTest struct {\n-\tpattern, replacement, input, output string\n-}\n-\n-var replaceTests = []ReplaceTest{\n-\t// Test empty input and/or replacement, with pattern that matches the empty string.\n-\t{\"\", \"\", \"\", \"\"},\n-\t{\"\", \"x\", \"\", \"x\"},\n-\t{\"\", \"\", \"abc\", \"abc\"},\n-\t{\"\", \"x\", \"abc\", \"xaxbxcx\"},\n-\n-\t// Test empty input and/or replacement, with pattern that does not match the empty string.\n-\t{\"b\", \"\", \"\", \"\"},\n-\t{\"b\", \"x\", \"\", \"\"},\n-\t{\"b\", \"\", \"abc\", \"ac\"},\n-\t{\"b\", \"x\", \"abc\", \"axc\"},\n-\t{\"y\", \"\", \"\", \"\"},\n-\t{\"y\", \"x\", \"\", \"\"},\n-\t{\"y\", \"\", \"abc\", \"abc\"},\n-\t{\"y\", \"x\", \"abc\", \"abc\"},\n-\n-\t// Multibyte characters -- verify that we don't try to match in the middle\n-\t// of a character.\n-\t{\"[a-c]*\", \"x\", \"\\u65e5\", \"x\\u65e5x\"},\n-\t{\"[^\\u65e5]\", \"x\", \"abc\\u65e5def\", \"xxx\\u65e5xxx\"},\n-\n-\t// Start and end of a string.\n-\t{\"^[a-c]*\", \"x\", \"abcdabc\", \"xdabc\"},\n-\t{\"[a-c]*$\", \"x\", \"abcdabc\", \"abcdx\"},\n-\t{\"^[a-c]*$\", \"x\", \"abcdabc\", \"abcdabc\"},\n-\t{\"^[a-c]*\", \"x\", \"abc\", \"x\"},\n-\t{\"[a-c]*$\", \"x\", \"abc\", \"x\"},\n-\t{\"^[a-c]*$\", \"x\", \"abc\", \"x\"},\n-\t{\"^[a-c]*\", \"x\", \"dabce\", \"xdabce\"},\n-\t{\"[a-c]*$\", \"x\", \"dabce\", \"dabcex\"},\n-\t{\"^[a-c]*$\", \"x\", \"dabce\", \"dabce\"},\n-\t{\"^[a-c]*\", \"x\", \"\", \"x\"},\n-\t{\"[a-c]*$\", \"x\", \"\", \"x\"},\n-\t{\"^[a-c]*$\", \"x\", \"\", \"x\"},\n-\n-\t{\"^[a-c]+\", \"x\", \"abcdabc\", \"xdabc\"},\n-\t{\"[a-c]+$\", \"x\", \"abcdabc\", \"abcdx\"},\n-\t{\"^[a-c]+$\", \"x\", \"abcdabc\", \"abcdabc\"},\n-\t{\"^[a-c]+\", \"x\", \"abc\", \"x\"},\n-\t{\"[a-c]+$\", \"x\", \"abc\", \"x\"},\n-\t{\"^[a-c]+$\", \"x\", \"abc\", \"x\"},\n-\t{\"^[a-c]+\", \"x\", \"dabce\", \"dabce\"},\n-\t{\"[a-c]+$\", \"x\", \"dabce\", \"dabce\"},\n-\t{\"^[a-c]+$\", \"x\", \"dabce\", \"dabce\"},\n-\t{\"^[a-c]+\", \"x\", \"\", \"\"},\n-\t{\"[a-c]+$\", \"x\", \"\", \"\"},\n-\t{\"^[a-c]+$\", \"x\", \"\", \"\"},\n-\n-\t// Other cases.\n-\t{\"abc\", \"def\", \"abcdefg\", \"defdefg\"},\n-\t{\"bc\", \"BC\", \"abcbcdcdedef\", \"aBCBCdcdedef\"},\n-\t{\"abc\", \"\", \"abcdabc\", \"d\"},\n-\t{\"x\", \"xXx\", \"xxxXxxx\", \"xXxxXxxXxXxXxxXxxXx\"},\n-\t{\"abc\", \"d\", \"\", \"\"},\n-\t{\"abc\", \"d\", \"abc\", \"d\"},\n-\t{\".+\", \"x\", \"abc\", \"x\"},\n-\t{\"[a-c]*\", \"x\", \"def\", \"xdxexfx\"},\n-\t{\"[a-c]+\", \"x\", \"abcbcdcdedef\", \"xdxdedef\"},\n-\t{\"[a-c]*\", \"x\", \"abcbcdcdedef\", \"xdxdxexdxexfx\"},\n-}\n-\n-type ReplaceFuncTest struct {\n-\tpattern       string\n-\treplacement   func(string) string\n-\tinput, output string\n-}\n-\n-var replaceFuncTests = []ReplaceFuncTest{\n-\t{\"[a-c]\", func(s string) string { return \"x\" + s + \"y\" }, \"defabcdef\", \"defxayxbyxcydef\"},\n-\t{\"[a-c]+\", func(s string) string { return \"x\" + s + \"y\" }, \"defabcdef\", \"defxabcydef\"},\n-\t{\"[a-c]*\", func(s string) string { return \"x\" + s + \"y\" }, \"defabcdef\", \"xydxyexyfxabcydxyexyfxy\"},\n-}\n-\n-func TestReplaceAll(t *testing.T) {\n-\tfor _, tc := range replaceTests {\n-\t\tre, err := Compile(tc.pattern)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"Unexpected error compiling %q: %v\", tc.pattern, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tactual := re.ReplaceAllString(tc.input, tc.replacement)\n-\t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.Replace(%q,%q) = %q; want %q\",\n-\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n-\t\t}\n-\t\t// now try bytes\n-\t\tactual = string(re.ReplaceAll([]byte(tc.input), []byte(tc.replacement)))\n-\t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.Replace(%q,%q) = %q; want %q\",\n-\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n-\t\t}\n-\t}\n-}\n-\n-func TestReplaceAllFunc(t *testing.T) {\n-\tfor _, tc := range replaceFuncTests {\n-\t\tre, err := Compile(tc.pattern)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"Unexpected error compiling %q: %v\", tc.pattern, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tactual := re.ReplaceAllStringFunc(tc.input, tc.replacement)\n-\t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.ReplaceFunc(%q,%q) = %q; want %q\",\n-\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n-\t\t}\n-\t\t// now try bytes\n-\t\tactual = string(re.ReplaceAllFunc([]byte(tc.input), func(s []byte) []byte { return []byte(tc.replacement(string(s))) }))\n-\t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.ReplaceFunc(%q,%q) = %q; want %q\",\n-\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n-\t\t}\n-\t}\n-}\n-\n-type MetaTest struct {\n-\tpattern, output, literal string\n-\tisLiteral                bool\n-}\n-\n-var metaTests = []MetaTest{\n-\t{``, ``, ``, true},\n-\t{`foo`, `foo`, `foo`, true},\n-\t{`foo\\.\\$`, `foo\\\\\\.\\\\\\$`, `foo.$`, true}, // has meta but no operator\n-\t{`foo.\\$`, `foo\\.\\\\\\$`, `foo`, false},     // has escaped operators and real operators\n-\t{`!@#$%^&*()_+-=[{]}\\|,<.>/?~`, `!@#\\$%\\^&\\*\\(\\)_\\+-=\\[{\\]}\\\\\\|,<\\.>/\\?~`, `!@#`, false},\n-}\n-\n-func TestQuoteMeta(t *testing.T) {\n-\tfor _, tc := range metaTests {\n-\t\t// Verify that QuoteMeta returns the expected string.\n-\t\tquoted := QuoteMeta(tc.pattern)\n-\t\tif quoted != tc.output {\n-\t\t\tt.Errorf(\"QuoteMeta(`%s`) = `%s`; want `%s`\",\n-\t\t\t\ttc.pattern, quoted, tc.output)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Verify that the quoted string is in fact treated as expected\n-\t\t// by Compile -- i.e. that it matches the original, unquoted string.\n-\t\tif tc.pattern != \"\" {\n-\t\t\tre, err := Compile(quoted)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"Unexpected error compiling QuoteMeta(`%s`): %v\", tc.pattern, err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tsrc := \"abc\" + tc.pattern + \"def\"\n-\t\t\trepl := \"xyz\"\n-\t\t\treplaced := re.ReplaceAllString(src, repl)\n-\t\t\texpected := \"abcxyzdef\"\n-\t\t\tif replaced != expected {\n-\t\t\t\tt.Errorf(\"QuoteMeta(`%s`).Replace(`%s`,`%s`) = `%s`; want `%s`\",\n-\t\t\t\t\ttc.pattern, src, repl, replaced, expected)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestLiteralPrefix(t *testing.T) {\n-\tfor _, tc := range metaTests {\n-\t\t// Literal method needs to scan the pattern.\n-\t\tre := MustCompile(tc.pattern)\n-\t\tstr, complete := re.LiteralPrefix()\n-\t\tif complete != tc.isLiteral {\n-\t\t\tt.Errorf(\"LiteralPrefix(`%s`) = %t; want %t\", tc.pattern, complete, tc.isLiteral)\n-\t\t}\n-\t\tif str != tc.literal {\n-\t\t\tt.Errorf(\"LiteralPrefix(`%s`) = `%s`; want `%s`\", tc.pattern, str, tc.literal)\n-\t\t}\n-\t}\n-}\n-\n-type numSubexpCase struct {\n-\tinput    string\n-\texpected int\n-}\n-\n-var numSubexpCases = []numSubexpCase{\n-\t{``, 0},\n-\t{`.*`, 0},\n-\t{`abba`, 0},\n-\t{`ab(b)a`, 1},\n-\t{`ab(.*)a`, 1},\n-\t{`(.*)ab(.*)a`, 2},\n-\t{`(.*)(ab)(.*)a`, 3},\n-\t{`(.*)((a)b)(.*)a`, 4},\n-\t{`(.*)(\\(ab)(.*)a`, 3},\n-\t{`(.*)(\\(a\\)b)(.*)a`, 3},\n-}\n-\n-func TestNumSubexp(t *testing.T) {\n-\tfor _, c := range numSubexpCases {\n-\t\tre := MustCompile(c.input)\n-\t\tn := re.NumSubexp()\n-\t\tif n != c.expected {\n-\t\t\tt.Errorf(\"NumSubexp for %q returned %d, expected %d\", c.input, n, c.expected)\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkLiteral(b *testing.B) {\n-\tx := strings.Repeat(\"x\", 50) + \"y\"\n-\tb.StopTimer()\n-\tre := MustCompile(\"y\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif !re.MatchString(x) {\n-\t\t\tb.Fatal(\"no match!\")\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkNotLiteral(b *testing.B) {\n-\tx := strings.Repeat(\"x\", 50) + \"y\"\n-\tb.StopTimer()\n-\tre := MustCompile(\".y\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif !re.MatchString(x) {\n-\t\t\tb.Fatal(\"no match!\")\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkMatchClass(b *testing.B) {\n-\tb.StopTimer()\n-\tx := strings.Repeat(\"xxxx\", 20) + \"w\"\n-\tre := MustCompile(\"[abcdw]\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif !re.MatchString(x) {\n-\t\t\tb.Fatal(\"no match!\")\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkMatchClass_InRange(b *testing.B) {\n-\tb.StopTimer()\n-\t// 'b' is between 'a' and 'c', so the charclass\n-\t// range checking is no help here.\n-\tx := strings.Repeat(\"bbbb\", 20) + \"c\"\n-\tre := MustCompile(\"[ac]\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif !re.MatchString(x) {\n-\t\t\tb.Fatal(\"no match!\")\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkReplaceAll(b *testing.B) {\n-\tx := \"abcdefghijklmnopqrstuvwxyz\"\n-\tb.StopTimer()\n-\tre := MustCompile(\"[cjrw]\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tre.ReplaceAllString(x, \"\")\n-\t}\n-}\n-\n-func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B) {\n-\tb.StopTimer()\n-\tx := []byte(\"abcdefghijklmnopqrstuvwxyz\")\n-\tre := MustCompile(\"^zbc(d|e)\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tre.Match(x)\n-\t}\n-}\n-\n-func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B) {\n-\tb.StopTimer()\n-\tx := []byte(\"abcdefghijklmnopqrstuvwxyz\")\n-\tfor i := 0; i < 15; i++ {\n-\t\tx = append(x, x...)\n-\t}\n-\tre := MustCompile(\"^zbc(d|e)\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tre.Match(x)\n-\t}\n-}\n-\n-func BenchmarkAnchoredShortMatch(b *testing.B) {\n-\tb.StopTimer()\n-\tx := []byte(\"abcdefghijklmnopqrstuvwxyz\")\n-\tre := MustCompile(\"^.bc(d|e)\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tre.Match(x)\n-\t}\n-}\n-\n-func BenchmarkAnchoredLongMatch(b *testing.B) {\n-\tb.StopTimer()\n-\tx := []byte(\"abcdefghijklmnopqrstuvwxyz\")\n-\tfor i := 0; i < 15; i++ {\n-\t\tx = append(x, x...)\n-\t}\n-\tre := MustCompile(\"^.bc(d|e)\")\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tre.Match(x)\n-\t}\n-}"}, {"sha": "83b249e3cef686d7666098e5501c4958f6571d01", "filename": "libgo/go/old/regexp/find_test.go", "status": "removed", "additions": 0, "deletions": 472, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Ffind_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Ffind_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Ffind_test.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,472 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package regexp\n-\n-import (\n-\t\"fmt\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// For each pattern/text pair, what is the expected output of each function?\n-// We can derive the textual results from the indexed results, the non-submatch\n-// results from the submatched results, the single results from the 'all' results,\n-// and the byte results from the string results. Therefore the table includes\n-// only the FindAllStringSubmatchIndex result.\n-type FindTest struct {\n-\tpat     string\n-\ttext    string\n-\tmatches [][]int\n-}\n-\n-func (t FindTest) String() string {\n-\treturn fmt.Sprintf(\"pat: %#q text: %#q\", t.pat, t.text)\n-}\n-\n-var findTests = []FindTest{\n-\t{``, ``, build(1, 0, 0)},\n-\t{`^abcdefg`, \"abcdefg\", build(1, 0, 7)},\n-\t{`a+`, \"baaab\", build(1, 1, 4)},\n-\t{\"abcd..\", \"abcdef\", build(1, 0, 6)},\n-\t{`a`, \"a\", build(1, 0, 1)},\n-\t{`x`, \"y\", nil},\n-\t{`b`, \"abc\", build(1, 1, 2)},\n-\t{`.`, \"a\", build(1, 0, 1)},\n-\t{`.*`, \"abcdef\", build(1, 0, 6)},\n-\t{`^`, \"abcde\", build(1, 0, 0)},\n-\t{`$`, \"abcde\", build(1, 5, 5)},\n-\t{`^abcd$`, \"abcd\", build(1, 0, 4)},\n-\t{`^bcd'`, \"abcdef\", nil},\n-\t{`^abcd$`, \"abcde\", nil},\n-\t{`a+`, \"baaab\", build(1, 1, 4)},\n-\t{`a*`, \"baaab\", build(3, 0, 0, 1, 4, 5, 5)},\n-\t{`[a-z]+`, \"abcd\", build(1, 0, 4)},\n-\t{`[^a-z]+`, \"ab1234cd\", build(1, 2, 6)},\n-\t{`[a\\-\\]z]+`, \"az]-bcz\", build(2, 0, 4, 6, 7)},\n-\t{`[^\\n]+`, \"abcd\\n\", build(1, 0, 4)},\n-\t{`[\u65e5\u672c\u8a9e]+`, \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", build(1, 0, 18)},\n-\t{`\u65e5\u672c\u8a9e+`, \"\u65e5\u672c\u8a9e\", build(1, 0, 9)},\n-\t{`\u65e5\u672c\u8a9e+`, \"\u65e5\u672c\u8a9e\u8a9e\u8a9e\u8a9e\", build(1, 0, 18)},\n-\t{`()`, \"\", build(1, 0, 0, 0, 0)},\n-\t{`(a)`, \"a\", build(1, 0, 1, 0, 1)},\n-\t{`(.)(.)`, \"\u65e5a\", build(1, 0, 4, 0, 3, 3, 4)},\n-\t{`(.*)`, \"\", build(1, 0, 0, 0, 0)},\n-\t{`(.*)`, \"abcd\", build(1, 0, 4, 0, 4)},\n-\t{`(..)(..)`, \"abcd\", build(1, 0, 4, 0, 2, 2, 4)},\n-\t{`(([^xyz]*)(d))`, \"abcd\", build(1, 0, 4, 0, 4, 0, 3, 3, 4)},\n-\t{`((a|b|c)*(d))`, \"abcd\", build(1, 0, 4, 0, 4, 2, 3, 3, 4)},\n-\t{`(((a|b|c)*)(d))`, \"abcd\", build(1, 0, 4, 0, 4, 0, 3, 2, 3, 3, 4)},\n-\t{`\\a\\b\\f\\n\\r\\t\\v`, \"\\a\\b\\f\\n\\r\\t\\v\", build(1, 0, 7)},\n-\t{`[\\a\\b\\f\\n\\r\\t\\v]+`, \"\\a\\b\\f\\n\\r\\t\\v\", build(1, 0, 7)},\n-\n-\t{`a*(|(b))c*`, \"aacc\", build(1, 0, 4, 2, 2, -1, -1)},\n-\t{`(.*).*`, \"ab\", build(1, 0, 2, 0, 2)},\n-\t{`[.]`, \".\", build(1, 0, 1)},\n-\t{`/$`, \"/abc/\", build(1, 4, 5)},\n-\t{`/$`, \"/abc\", nil},\n-\n-\t// multiple matches\n-\t{`.`, \"abc\", build(3, 0, 1, 1, 2, 2, 3)},\n-\t{`(.)`, \"abc\", build(3, 0, 1, 0, 1, 1, 2, 1, 2, 2, 3, 2, 3)},\n-\t{`.(.)`, \"abcd\", build(2, 0, 2, 1, 2, 2, 4, 3, 4)},\n-\t{`ab*`, \"abbaab\", build(3, 0, 3, 3, 4, 4, 6)},\n-\t{`a(b*)`, \"abbaab\", build(3, 0, 3, 1, 3, 3, 4, 4, 4, 4, 6, 5, 6)},\n-\n-\t// fixed bugs\n-\t{`ab$`, \"cab\", build(1, 1, 3)},\n-\t{`axxb$`, \"axxcb\", nil},\n-\t{`data`, \"daXY data\", build(1, 5, 9)},\n-\t{`da(.)a$`, \"daXY data\", build(1, 5, 9, 7, 8)},\n-\t{`zx+`, \"zzx\", build(1, 1, 3)},\n-\n-\t// can backslash-escape any punctuation\n-\t{`\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\-\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\\\\\]\\^\\_\\{\\|\\}\\~`,\n-\t\t`!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~`, build(1, 0, 31)},\n-\t{`[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\-\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\\\\\]\\^\\_\\{\\|\\}\\~]+`,\n-\t\t`!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~`, build(1, 0, 31)},\n-\t{\"\\\\`\", \"`\", build(1, 0, 1)},\n-\t{\"[\\\\`]+\", \"`\", build(1, 0, 1)},\n-\n-\t// long set of matches (longer than startSize)\n-\t{\n-\t\t\".\",\n-\t\t\"qwertyuiopasdfghjklzxcvbnm1234567890\",\n-\t\tbuild(36, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,\n-\t\t\t10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20,\n-\t\t\t20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30,\n-\t\t\t30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36),\n-\t},\n-}\n-\n-// build is a helper to construct a [][]int by extracting n sequences from x.\n-// This represents n matches with len(x)/n submatches each.\n-func build(n int, x ...int) [][]int {\n-\tret := make([][]int, n)\n-\trunLength := len(x) / n\n-\tj := 0\n-\tfor i := range ret {\n-\t\tret[i] = make([]int, runLength)\n-\t\tcopy(ret[i], x[j:])\n-\t\tj += runLength\n-\t\tif j > len(x) {\n-\t\t\tpanic(\"invalid build entry\")\n-\t\t}\n-\t}\n-\treturn ret\n-}\n-\n-// First the simple cases.\n-\n-func TestFind(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tre := MustCompile(test.pat)\n-\t\tif re.String() != test.pat {\n-\t\t\tt.Errorf(\"String() = `%s`; should be `%s`\", re.String(), test.pat)\n-\t\t}\n-\t\tresult := re.Find([]byte(test.text))\n-\t\tswitch {\n-\t\tcase len(test.matches) == 0 && len(result) == 0:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\texpect := test.text[test.matches[0][0]:test.matches[0][1]]\n-\t\t\tif expect != string(result) {\n-\t\t\t\tt.Errorf(\"expected %q got %q: %s\", expect, result, test)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestFindString(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindString(test.text)\n-\t\tswitch {\n-\t\tcase len(test.matches) == 0 && len(result) == 0:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != \"\":\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == \"\":\n-\t\t\t// Tricky because an empty result has two meanings: no match or empty match.\n-\t\t\tif test.matches[0][0] != test.matches[0][1] {\n-\t\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\t\t}\n-\t\tcase test.matches != nil && result != \"\":\n-\t\t\texpect := test.text[test.matches[0][0]:test.matches[0][1]]\n-\t\t\tif expect != result {\n-\t\t\t\tt.Errorf(\"expected %q got %q: %s\", expect, result, test)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func testFindIndex(test *FindTest, result []int, t *testing.T) {\n-\tswitch {\n-\tcase len(test.matches) == 0 && len(result) == 0:\n-\t\t// ok\n-\tcase test.matches == nil && result != nil:\n-\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\tcase test.matches != nil && result == nil:\n-\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\tcase test.matches != nil && result != nil:\n-\t\texpect := test.matches[0]\n-\t\tif expect[0] != result[0] || expect[1] != result[1] {\n-\t\t\tt.Errorf(\"expected %v got %v: %s\", expect, result, test)\n-\t\t}\n-\t}\n-}\n-\n-func TestFindIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindIndex(&test, MustCompile(test.pat).FindIndex([]byte(test.text)), t)\n-\t}\n-}\n-\n-func TestFindStringIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindIndex(&test, MustCompile(test.pat).FindStringIndex(test.text), t)\n-\t}\n-}\n-\n-func TestFindReaderIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindIndex(&test, MustCompile(test.pat).FindReaderIndex(strings.NewReader(test.text)), t)\n-\t}\n-}\n-\n-// Now come the simple All cases.\n-\n-func TestFindAll(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindAll([]byte(test.text), -1)\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\tif len(test.matches) != len(result) {\n-\t\t\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfor k, e := range test.matches {\n-\t\t\t\texpect := test.text[e[0]:e[1]]\n-\t\t\t\tif expect != string(result[k]) {\n-\t\t\t\t\tt.Errorf(\"match %d: expected %q got %q: %s\", k, expect, result[k], test)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestFindAllString(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindAllString(test.text, -1)\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\tif len(test.matches) != len(result) {\n-\t\t\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfor k, e := range test.matches {\n-\t\t\t\texpect := test.text[e[0]:e[1]]\n-\t\t\t\tif expect != result[k] {\n-\t\t\t\t\tt.Errorf(\"expected %q got %q: %s\", expect, result, test)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func testFindAllIndex(test *FindTest, result [][]int, t *testing.T) {\n-\tswitch {\n-\tcase test.matches == nil && result == nil:\n-\t\t// ok\n-\tcase test.matches == nil && result != nil:\n-\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\tcase test.matches != nil && result == nil:\n-\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\tcase test.matches != nil && result != nil:\n-\t\tif len(test.matches) != len(result) {\n-\t\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\t\t\treturn\n-\t\t}\n-\t\tfor k, e := range test.matches {\n-\t\t\tif e[0] != result[k][0] || e[1] != result[k][1] {\n-\t\t\t\tt.Errorf(\"match %d: expected %v got %v: %s\", k, e, result[k], test)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestFindAllIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindAllIndex(&test, MustCompile(test.pat).FindAllIndex([]byte(test.text), -1), t)\n-\t}\n-}\n-\n-func TestFindAllStringIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindAllIndex(&test, MustCompile(test.pat).FindAllStringIndex(test.text, -1), t)\n-\t}\n-}\n-\n-// Now come the Submatch cases.\n-\n-func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T) {\n-\tif len(submatches) != len(result)*2 {\n-\t\tt.Errorf(\"match %d: expected %d submatches; got %d: %s\", n, len(submatches)/2, len(result), test)\n-\t\treturn\n-\t}\n-\tfor k := 0; k < len(submatches); k += 2 {\n-\t\tif submatches[k] == -1 {\n-\t\t\tif result[k/2] != nil {\n-\t\t\t\tt.Errorf(\"match %d: expected nil got %q: %s\", n, result, test)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\texpect := test.text[submatches[k]:submatches[k+1]]\n-\t\tif expect != string(result[k/2]) {\n-\t\t\tt.Errorf(\"match %d: expected %q got %q: %s\", n, expect, result, test)\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-func TestFindSubmatch(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindSubmatch([]byte(test.text))\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\ttestSubmatchBytes(&test, 0, test.matches[0], result, t)\n-\t\t}\n-\t}\n-}\n-\n-func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T) {\n-\tif len(submatches) != len(result)*2 {\n-\t\tt.Errorf(\"match %d: expected %d submatches; got %d: %s\", n, len(submatches)/2, len(result), test)\n-\t\treturn\n-\t}\n-\tfor k := 0; k < len(submatches); k += 2 {\n-\t\tif submatches[k] == -1 {\n-\t\t\tif result[k/2] != \"\" {\n-\t\t\t\tt.Errorf(\"match %d: expected nil got %q: %s\", n, result, test)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\texpect := test.text[submatches[k]:submatches[k+1]]\n-\t\tif expect != result[k/2] {\n-\t\t\tt.Errorf(\"match %d: expected %q got %q: %s\", n, expect, result, test)\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-func TestFindStringSubmatch(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindStringSubmatch(test.text)\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\ttestSubmatchString(&test, 0, test.matches[0], result, t)\n-\t\t}\n-\t}\n-}\n-\n-func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T) {\n-\tif len(expect) != len(result) {\n-\t\tt.Errorf(\"match %d: expected %d matches; got %d: %s\", n, len(expect)/2, len(result)/2, test)\n-\t\treturn\n-\t}\n-\tfor k, e := range expect {\n-\t\tif e != result[k] {\n-\t\t\tt.Errorf(\"match %d: submatch error: expected %v got %v: %s\", n, expect, result, test)\n-\t\t}\n-\t}\n-}\n-\n-func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T) {\n-\tswitch {\n-\tcase test.matches == nil && result == nil:\n-\t\t// ok\n-\tcase test.matches == nil && result != nil:\n-\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\tcase test.matches != nil && result == nil:\n-\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\tcase test.matches != nil && result != nil:\n-\t\ttestSubmatchIndices(test, 0, test.matches[0], result, t)\n-\t}\n-}\n-\n-func TestFindSubmatchIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindSubmatchIndex(&test, MustCompile(test.pat).FindSubmatchIndex([]byte(test.text)), t)\n-\t}\n-}\n-\n-func TestFindStringSubmatchIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindSubmatchIndex(&test, MustCompile(test.pat).FindStringSubmatchIndex(test.text), t)\n-\t}\n-}\n-\n-func TestFindReaderSubmatchIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindSubmatchIndex(&test, MustCompile(test.pat).FindReaderSubmatchIndex(strings.NewReader(test.text)), t)\n-\t}\n-}\n-\n-// Now come the monster AllSubmatch cases.\n-\n-func TestFindAllSubmatch(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindAllSubmatch([]byte(test.text), -1)\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase len(test.matches) != len(result):\n-\t\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\tfor k, match := range test.matches {\n-\t\t\t\ttestSubmatchBytes(&test, k, match, result[k], t)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestFindAllStringSubmatch(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\tresult := MustCompile(test.pat).FindAllStringSubmatch(test.text, -1)\n-\t\tswitch {\n-\t\tcase test.matches == nil && result == nil:\n-\t\t\t// ok\n-\t\tcase test.matches == nil && result != nil:\n-\t\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\t\tcase test.matches != nil && result == nil:\n-\t\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\t\tcase len(test.matches) != len(result):\n-\t\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\t\tcase test.matches != nil && result != nil:\n-\t\t\tfor k, match := range test.matches {\n-\t\t\t\ttestSubmatchString(&test, k, match, result[k], t)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T) {\n-\tswitch {\n-\tcase test.matches == nil && result == nil:\n-\t\t// ok\n-\tcase test.matches == nil && result != nil:\n-\t\tt.Errorf(\"expected no match; got one: %s\", test)\n-\tcase test.matches != nil && result == nil:\n-\t\tt.Errorf(\"expected match; got none: %s\", test)\n-\tcase len(test.matches) != len(result):\n-\t\tt.Errorf(\"expected %d matches; got %d: %s\", len(test.matches), len(result), test)\n-\tcase test.matches != nil && result != nil:\n-\t\tfor k, match := range test.matches {\n-\t\t\ttestSubmatchIndices(test, k, match, result[k], t)\n-\t\t}\n-\t}\n-}\n-\n-func TestFindAllSubmatchIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindAllSubmatchIndex(&test, MustCompile(test.pat).FindAllSubmatchIndex([]byte(test.text), -1), t)\n-\t}\n-}\n-\n-func TestFindAllStringSubmatchIndex(t *testing.T) {\n-\tfor _, test := range findTests {\n-\t\ttestFindAllSubmatchIndex(&test, MustCompile(test.pat).FindAllStringSubmatchIndex(test.text, -1), t)\n-\t}\n-}"}, {"sha": "d3044d0c1d767cf69ff94b78c48b8e8a8cfeed63", "filename": "libgo/go/old/regexp/regexp.go", "status": "removed", "additions": 0, "deletions": 1488, "changes": 1488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,1488 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package regexp implements a simple regular expression library.\n-//\n-// The syntax of the regular expressions accepted is:\n-//\n-//\tregexp:\n-//\t\tconcatenation { '|' concatenation }\n-//\tconcatenation:\n-//\t\t{ closure }\n-//\tclosure:\n-//\t\tterm [ '*' | '+' | '?' ]\n-//\tterm:\n-//\t\t'^'\n-//\t\t'$'\n-//\t\t'.'\n-//\t\tcharacter\n-//\t\t'[' [ '^' ] { character-range } ']'\n-//\t\t'(' regexp ')'\n-//\tcharacter-range:\n-//\t\tcharacter [ '-' character ]\n-//\n-// All characters are UTF-8-encoded code points.  Backslashes escape special\n-// characters, including inside character classes.  The standard Go character\n-// escapes are also recognized: \\a \\b \\f \\n \\r \\t \\v.\n-//\n-// There are 16 methods of Regexp that match a regular expression and identify\n-// the matched text.  Their names are matched by this regular expression:\n-//\n-//\tFind(All)?(String)?(Submatch)?(Index)?\n-//\n-// If 'All' is present, the routine matches successive non-overlapping\n-// matches of the entire expression.  Empty matches abutting a preceding\n-// match are ignored.  The return value is a slice containing the successive\n-// return values of the corresponding non-'All' routine.  These routines take\n-// an extra integer argument, n; if n >= 0, the function returns at most n\n-// matches/submatches.\n-//\n-// If 'String' is present, the argument is a string; otherwise it is a slice\n-// of bytes; return values are adjusted as appropriate.\n-//\n-// If 'Submatch' is present, the return value is a slice identifying the\n-// successive submatches of the expression.  Submatches are matches of\n-// parenthesized subexpressions within the regular expression, numbered from\n-// left to right in order of opening parenthesis.  Submatch 0 is the match of\n-// the entire expression, submatch 1 the match of the first parenthesized\n-// subexpression, and so on.\n-//\n-// If 'Index' is present, matches and submatches are identified by byte index\n-// pairs within the input string: result[2*n:2*n+1] identifies the indexes of\n-// the nth submatch.  The pair for n==0 identifies the match of the entire\n-// expression.  If 'Index' is not present, the match is identified by the\n-// text of the match/submatch.  If an index is negative, it means that\n-// subexpression did not match any string in the input.\n-//\n-// There is also a subset of the methods that can be applied to text read\n-// from a RuneReader:\n-//\n-//\tMatchReader, FindReaderIndex, FindReaderSubmatchIndex\n-//\n-// This set may grow.  Note that regular expression matches may need to\n-// examine text beyond the text returned by a match, so the methods that\n-// match text from a RuneReader may read arbitrarily far into the input\n-// before returning.\n-//\n-// (There are a few other methods that do not match this pattern.)\n-//\n-package regexp\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"strings\"\n-\t\"unicode/utf8\"\n-)\n-\n-var debug = false\n-\n-// Error is the local type for a parsing error.\n-type Error string\n-\n-func (e Error) Error() string {\n-\treturn string(e)\n-}\n-\n-// Error codes returned by failures to parse an expression.\n-var (\n-\tErrInternal            = Error(\"regexp: internal error\")\n-\tErrUnmatchedLpar       = Error(\"regexp: unmatched '('\")\n-\tErrUnmatchedRpar       = Error(\"regexp: unmatched ')'\")\n-\tErrUnmatchedLbkt       = Error(\"regexp: unmatched '['\")\n-\tErrUnmatchedRbkt       = Error(\"regexp: unmatched ']'\")\n-\tErrBadRange            = Error(\"regexp: bad range in character class\")\n-\tErrExtraneousBackslash = Error(\"regexp: extraneous backslash\")\n-\tErrBadClosure          = Error(\"regexp: repeated closure (**, ++, etc.)\")\n-\tErrBareClosure         = Error(\"regexp: closure applies to nothing\")\n-\tErrBadBackslash        = Error(\"regexp: illegal backslash escape\")\n-)\n-\n-const (\n-\tiStart     = iota // beginning of program\n-\tiEnd              // end of program: success\n-\tiBOT              // '^' beginning of text\n-\tiEOT              // '$' end of text\n-\tiChar             // 'a' regular character\n-\tiCharClass        // [a-z] character class\n-\tiAny              // '.' any character including newline\n-\tiNotNL            // [^\\n] special case: any character but newline\n-\tiBra              // '(' parenthesized expression: 2*braNum for left, 2*braNum+1 for right\n-\tiAlt              // '|' alternation\n-\tiNop              // do nothing; makes it easy to link without patching\n-)\n-\n-// An instruction executed by the NFA\n-type instr struct {\n-\tkind  int    // the type of this instruction: iChar, iAny, etc.\n-\tindex int    // used only in debugging; could be eliminated\n-\tnext  *instr // the instruction to execute after this one\n-\t// Special fields valid only for some items.\n-\tchar   rune       // iChar\n-\tbraNum int        // iBra, iEbra\n-\tcclass *charClass // iCharClass\n-\tleft   *instr     // iAlt, other branch\n-}\n-\n-func (i *instr) print() {\n-\tswitch i.kind {\n-\tcase iStart:\n-\t\tprint(\"start\")\n-\tcase iEnd:\n-\t\tprint(\"end\")\n-\tcase iBOT:\n-\t\tprint(\"bot\")\n-\tcase iEOT:\n-\t\tprint(\"eot\")\n-\tcase iChar:\n-\t\tprint(\"char \", string(i.char))\n-\tcase iCharClass:\n-\t\ti.cclass.print()\n-\tcase iAny:\n-\t\tprint(\"any\")\n-\tcase iNotNL:\n-\t\tprint(\"notnl\")\n-\tcase iBra:\n-\t\tif i.braNum&1 == 0 {\n-\t\t\tprint(\"bra\", i.braNum/2)\n-\t\t} else {\n-\t\t\tprint(\"ebra\", i.braNum/2)\n-\t\t}\n-\tcase iAlt:\n-\t\tprint(\"alt(\", i.left.index, \")\")\n-\tcase iNop:\n-\t\tprint(\"nop\")\n-\t}\n-}\n-\n-// Regexp is the representation of a compiled regular expression.\n-// The public interface is entirely through methods.\n-// A Regexp is safe for concurrent use by multiple goroutines.\n-type Regexp struct {\n-\texpr        string // the original expression\n-\tprefix      string // initial plain text string\n-\tprefixBytes []byte // initial plain text bytes\n-\tinst        []*instr\n-\tstart       *instr // first instruction of machine\n-\tprefixStart *instr // where to start if there is a prefix\n-\tnbra        int    // number of brackets in expression, for subexpressions\n-}\n-\n-type charClass struct {\n-\tnegate bool // is character class negated? ([^a-z])\n-\t// slice of int, stored pairwise: [a-z] is (a,z); x is (x,x):\n-\tranges     []rune\n-\tcmin, cmax rune\n-}\n-\n-func (cclass *charClass) print() {\n-\tprint(\"charclass\")\n-\tif cclass.negate {\n-\t\tprint(\" (negated)\")\n-\t}\n-\tfor i := 0; i < len(cclass.ranges); i += 2 {\n-\t\tl := cclass.ranges[i]\n-\t\tr := cclass.ranges[i+1]\n-\t\tif l == r {\n-\t\t\tprint(\" [\", string(l), \"]\")\n-\t\t} else {\n-\t\t\tprint(\" [\", string(l), \"-\", string(r), \"]\")\n-\t\t}\n-\t}\n-}\n-\n-func (cclass *charClass) addRange(a, b rune) {\n-\t// range is a through b inclusive\n-\tcclass.ranges = append(cclass.ranges, a, b)\n-\tif a < cclass.cmin {\n-\t\tcclass.cmin = a\n-\t}\n-\tif b > cclass.cmax {\n-\t\tcclass.cmax = b\n-\t}\n-}\n-\n-func (cclass *charClass) matches(c rune) bool {\n-\tif c < cclass.cmin || c > cclass.cmax {\n-\t\treturn cclass.negate\n-\t}\n-\tranges := cclass.ranges\n-\tfor i := 0; i < len(ranges); i = i + 2 {\n-\t\tif ranges[i] <= c && c <= ranges[i+1] {\n-\t\t\treturn !cclass.negate\n-\t\t}\n-\t}\n-\treturn cclass.negate\n-}\n-\n-func newCharClass() *instr {\n-\ti := &instr{kind: iCharClass}\n-\ti.cclass = new(charClass)\n-\ti.cclass.ranges = make([]rune, 0, 4)\n-\ti.cclass.cmin = 0x10FFFF + 1 // MaxRune + 1\n-\ti.cclass.cmax = -1\n-\treturn i\n-}\n-\n-func (re *Regexp) add(i *instr) *instr {\n-\ti.index = len(re.inst)\n-\tre.inst = append(re.inst, i)\n-\treturn i\n-}\n-\n-type parser struct {\n-\tre    *Regexp\n-\tnlpar int // number of unclosed lpars\n-\tpos   int\n-\tch    rune\n-}\n-\n-func (p *parser) error(err Error) {\n-\tpanic(err)\n-}\n-\n-const endOfText = -1\n-\n-func (p *parser) c() rune { return p.ch }\n-\n-func (p *parser) nextc() rune {\n-\tif p.pos >= len(p.re.expr) {\n-\t\tp.ch = endOfText\n-\t} else {\n-\t\tc, w := utf8.DecodeRuneInString(p.re.expr[p.pos:])\n-\t\tp.ch = c\n-\t\tp.pos += w\n-\t}\n-\treturn p.ch\n-}\n-\n-func newParser(re *Regexp) *parser {\n-\tp := new(parser)\n-\tp.re = re\n-\tp.nextc() // load p.ch\n-\treturn p\n-}\n-\n-func special(c rune) bool {\n-\tfor _, r := range `\\.+*?()|[]^$` {\n-\t\tif c == r {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-func ispunct(c rune) bool {\n-\tfor _, r := range \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\" {\n-\t\tif c == r {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-var escapes = []byte(\"abfnrtv\")\n-var escaped = []byte(\"\\a\\b\\f\\n\\r\\t\\v\")\n-\n-func escape(c rune) int {\n-\tfor i, b := range escapes {\n-\t\tif rune(b) == c {\n-\t\t\treturn i\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-func (p *parser) checkBackslash() rune {\n-\tc := p.c()\n-\tif c == '\\\\' {\n-\t\tc = p.nextc()\n-\t\tswitch {\n-\t\tcase c == endOfText:\n-\t\t\tp.error(ErrExtraneousBackslash)\n-\t\tcase ispunct(c):\n-\t\t\t// c is as delivered\n-\t\tcase escape(c) >= 0:\n-\t\t\tc = rune(escaped[escape(c)])\n-\t\tdefault:\n-\t\t\tp.error(ErrBadBackslash)\n-\t\t}\n-\t}\n-\treturn c\n-}\n-\n-func (p *parser) charClass() *instr {\n-\ti := newCharClass()\n-\tcc := i.cclass\n-\tif p.c() == '^' {\n-\t\tcc.negate = true\n-\t\tp.nextc()\n-\t}\n-\tleft := rune(-1)\n-\tfor {\n-\t\tswitch c := p.c(); c {\n-\t\tcase ']', endOfText:\n-\t\t\tif left >= 0 {\n-\t\t\t\tp.error(ErrBadRange)\n-\t\t\t}\n-\t\t\t// Is it [^\\n]?\n-\t\t\tif cc.negate && len(cc.ranges) == 2 &&\n-\t\t\t\tcc.ranges[0] == '\\n' && cc.ranges[1] == '\\n' {\n-\t\t\t\tnl := &instr{kind: iNotNL}\n-\t\t\t\tp.re.add(nl)\n-\t\t\t\treturn nl\n-\t\t\t}\n-\t\t\t// Special common case: \"[a]\" -> \"a\"\n-\t\t\tif !cc.negate && len(cc.ranges) == 2 && cc.ranges[0] == cc.ranges[1] {\n-\t\t\t\tc := &instr{kind: iChar, char: cc.ranges[0]}\n-\t\t\t\tp.re.add(c)\n-\t\t\t\treturn c\n-\t\t\t}\n-\t\t\tp.re.add(i)\n-\t\t\treturn i\n-\t\tcase '-': // do this before backslash processing\n-\t\t\tp.error(ErrBadRange)\n-\t\tdefault:\n-\t\t\tc = p.checkBackslash()\n-\t\t\tp.nextc()\n-\t\t\tswitch {\n-\t\t\tcase left < 0: // first of pair\n-\t\t\t\tif p.c() == '-' { // range\n-\t\t\t\t\tp.nextc()\n-\t\t\t\t\tleft = c\n-\t\t\t\t} else { // single char\n-\t\t\t\t\tcc.addRange(c, c)\n-\t\t\t\t}\n-\t\t\tcase left <= c: // second of pair\n-\t\t\t\tcc.addRange(left, c)\n-\t\t\t\tleft = -1\n-\t\t\tdefault:\n-\t\t\t\tp.error(ErrBadRange)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func (p *parser) term() (start, end *instr) {\n-\tswitch c := p.c(); c {\n-\tcase '|', endOfText:\n-\t\treturn nil, nil\n-\tcase '*', '+', '?':\n-\t\tp.error(ErrBareClosure)\n-\tcase ')':\n-\t\tif p.nlpar == 0 {\n-\t\t\tp.error(ErrUnmatchedRpar)\n-\t\t}\n-\t\treturn nil, nil\n-\tcase ']':\n-\t\tp.error(ErrUnmatchedRbkt)\n-\tcase '^':\n-\t\tp.nextc()\n-\t\tstart = p.re.add(&instr{kind: iBOT})\n-\t\treturn start, start\n-\tcase '$':\n-\t\tp.nextc()\n-\t\tstart = p.re.add(&instr{kind: iEOT})\n-\t\treturn start, start\n-\tcase '.':\n-\t\tp.nextc()\n-\t\tstart = p.re.add(&instr{kind: iAny})\n-\t\treturn start, start\n-\tcase '[':\n-\t\tp.nextc()\n-\t\tstart = p.charClass()\n-\t\tif p.c() != ']' {\n-\t\t\tp.error(ErrUnmatchedLbkt)\n-\t\t}\n-\t\tp.nextc()\n-\t\treturn start, start\n-\tcase '(':\n-\t\tp.nextc()\n-\t\tp.nlpar++\n-\t\tp.re.nbra++ // increment first so first subexpr is \\1\n-\t\tnbra := p.re.nbra\n-\t\tstart, end = p.regexp()\n-\t\tif p.c() != ')' {\n-\t\t\tp.error(ErrUnmatchedLpar)\n-\t\t}\n-\t\tp.nlpar--\n-\t\tp.nextc()\n-\t\tbra := &instr{kind: iBra, braNum: 2 * nbra}\n-\t\tp.re.add(bra)\n-\t\tebra := &instr{kind: iBra, braNum: 2*nbra + 1}\n-\t\tp.re.add(ebra)\n-\t\tif start == nil {\n-\t\t\tif end == nil {\n-\t\t\t\tp.error(ErrInternal)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tstart = ebra\n-\t\t} else {\n-\t\t\tend.next = ebra\n-\t\t}\n-\t\tbra.next = start\n-\t\treturn bra, ebra\n-\tdefault:\n-\t\tc = p.checkBackslash()\n-\t\tp.nextc()\n-\t\tstart = &instr{kind: iChar, char: c}\n-\t\tp.re.add(start)\n-\t\treturn start, start\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func (p *parser) closure() (start, end *instr) {\n-\tstart, end = p.term()\n-\tif start == nil {\n-\t\treturn\n-\t}\n-\tswitch p.c() {\n-\tcase '*':\n-\t\t// (start,end)*:\n-\t\talt := &instr{kind: iAlt}\n-\t\tp.re.add(alt)\n-\t\tend.next = alt   // after end, do alt\n-\t\talt.left = start // alternate brach: return to start\n-\t\tstart = alt      // alt becomes new (start, end)\n-\t\tend = alt\n-\tcase '+':\n-\t\t// (start,end)+:\n-\t\talt := &instr{kind: iAlt}\n-\t\tp.re.add(alt)\n-\t\tend.next = alt   // after end, do alt\n-\t\talt.left = start // alternate brach: return to start\n-\t\tend = alt        // start is unchanged; end is alt\n-\tcase '?':\n-\t\t// (start,end)?:\n-\t\talt := &instr{kind: iAlt}\n-\t\tp.re.add(alt)\n-\t\tnop := &instr{kind: iNop}\n-\t\tp.re.add(nop)\n-\t\talt.left = start // alternate branch is start\n-\t\talt.next = nop   // follow on to nop\n-\t\tend.next = nop   // after end, go to nop\n-\t\tstart = alt      // start is now alt\n-\t\tend = nop        // end is nop pointed to by both branches\n-\tdefault:\n-\t\treturn\n-\t}\n-\tswitch p.nextc() {\n-\tcase '*', '+', '?':\n-\t\tp.error(ErrBadClosure)\n-\t}\n-\treturn\n-}\n-\n-func (p *parser) concatenation() (start, end *instr) {\n-\tfor {\n-\t\tnstart, nend := p.closure()\n-\t\tswitch {\n-\t\tcase nstart == nil: // end of this concatenation\n-\t\t\tif start == nil { // this is the empty string\n-\t\t\t\tnop := p.re.add(&instr{kind: iNop})\n-\t\t\t\treturn nop, nop\n-\t\t\t}\n-\t\t\treturn\n-\t\tcase start == nil: // this is first element of concatenation\n-\t\t\tstart, end = nstart, nend\n-\t\tdefault:\n-\t\t\tend.next = nstart\n-\t\t\tend = nend\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func (p *parser) regexp() (start, end *instr) {\n-\tstart, end = p.concatenation()\n-\tfor {\n-\t\tswitch p.c() {\n-\t\tdefault:\n-\t\t\treturn\n-\t\tcase '|':\n-\t\t\tp.nextc()\n-\t\t\tnstart, nend := p.concatenation()\n-\t\t\talt := &instr{kind: iAlt}\n-\t\t\tp.re.add(alt)\n-\t\t\talt.left = start\n-\t\t\talt.next = nstart\n-\t\t\tnop := &instr{kind: iNop}\n-\t\t\tp.re.add(nop)\n-\t\t\tend.next = nop\n-\t\t\tnend.next = nop\n-\t\t\tstart, end = alt, nop\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-func unNop(i *instr) *instr {\n-\tfor i.kind == iNop {\n-\t\ti = i.next\n-\t}\n-\treturn i\n-}\n-\n-func (re *Regexp) eliminateNops() {\n-\tfor _, inst := range re.inst {\n-\t\tif inst.kind == iEnd {\n-\t\t\tcontinue\n-\t\t}\n-\t\tinst.next = unNop(inst.next)\n-\t\tif inst.kind == iAlt {\n-\t\t\tinst.left = unNop(inst.left)\n-\t\t}\n-\t}\n-}\n-\n-func (re *Regexp) dump() {\n-\tprint(\"prefix <\", re.prefix, \">\\n\")\n-\tfor _, inst := range re.inst {\n-\t\tprint(inst.index, \": \")\n-\t\tinst.print()\n-\t\tif inst.kind != iEnd {\n-\t\t\tprint(\" -> \", inst.next.index)\n-\t\t}\n-\t\tprint(\"\\n\")\n-\t}\n-}\n-\n-func (re *Regexp) doParse() {\n-\tp := newParser(re)\n-\tstart := &instr{kind: iStart}\n-\tre.add(start)\n-\ts, e := p.regexp()\n-\tstart.next = s\n-\tre.start = start\n-\te.next = re.add(&instr{kind: iEnd})\n-\n-\tif debug {\n-\t\tre.dump()\n-\t\tprintln()\n-\t}\n-\n-\tre.eliminateNops()\n-\tif debug {\n-\t\tre.dump()\n-\t\tprintln()\n-\t}\n-\tre.setPrefix()\n-\tif debug {\n-\t\tre.dump()\n-\t\tprintln()\n-\t}\n-}\n-\n-// Extract regular text from the beginning of the pattern,\n-// possibly after a leading iBOT.\n-// That text can be used by doExecute to speed up matching.\n-func (re *Regexp) setPrefix() {\n-\tvar b []byte\n-\tvar utf = make([]byte, utf8.UTFMax)\n-\tvar inst *instr\n-\t// First instruction is start; skip that.  Also skip any initial iBOT.\n-\tinst = re.inst[0].next\n-\tfor inst.kind == iBOT {\n-\t\tinst = inst.next\n-\t}\n-Loop:\n-\tfor ; inst.kind != iEnd; inst = inst.next {\n-\t\t// stop if this is not a char\n-\t\tif inst.kind != iChar {\n-\t\t\tbreak\n-\t\t}\n-\t\t// stop if this char can be followed by a match for an empty string,\n-\t\t// which includes closures, ^, and $.\n-\t\tswitch inst.next.kind {\n-\t\tcase iBOT, iEOT, iAlt:\n-\t\t\tbreak Loop\n-\t\t}\n-\t\tn := utf8.EncodeRune(utf, inst.char)\n-\t\tb = append(b, utf[0:n]...)\n-\t}\n-\t// point prefixStart instruction to first non-CHAR after prefix\n-\tre.prefixStart = inst\n-\tre.prefixBytes = b\n-\tre.prefix = string(b)\n-}\n-\n-// String returns the source text used to compile the regular expression.\n-func (re *Regexp) String() string {\n-\treturn re.expr\n-}\n-\n-// Compile parses a regular expression and returns, if successful, a Regexp\n-// object that can be used to match against text.\n-func Compile(str string) (regexp *Regexp, error error) {\n-\tregexp = new(Regexp)\n-\t// doParse will panic if there is a parse error.\n-\tdefer func() {\n-\t\tif e := recover(); e != nil {\n-\t\t\tregexp = nil\n-\t\t\terror = e.(Error) // Will re-panic if error was not an Error, e.g. nil-pointer exception\n-\t\t}\n-\t}()\n-\tregexp.expr = str\n-\tregexp.inst = make([]*instr, 0, 10)\n-\tregexp.doParse()\n-\treturn\n-}\n-\n-// MustCompile is like Compile but panics if the expression cannot be parsed.\n-// It simplifies safe initialization of global variables holding compiled regular\n-// expressions.\n-func MustCompile(str string) *Regexp {\n-\tregexp, error := Compile(str)\n-\tif error != nil {\n-\t\tpanic(`regexp: compiling \"` + str + `\": ` + error.Error())\n-\t}\n-\treturn regexp\n-}\n-\n-// NumSubexp returns the number of parenthesized subexpressions in this Regexp.\n-func (re *Regexp) NumSubexp() int { return re.nbra }\n-\n-// The match arena allows us to reduce the garbage generated by tossing\n-// match vectors away as we execute.  Matches are ref counted and returned\n-// to a free list when no longer active.  Increases a simple benchmark by 22X.\n-type matchArena struct {\n-\thead  *matchVec\n-\tlen   int // length of match vector\n-\tpos   int\n-\tatBOT bool // whether we're at beginning of text\n-\tatEOT bool // whether we're at end of text\n-}\n-\n-type matchVec struct {\n-\tm    []int // pairs of bracketing submatches. 0th is start,end\n-\tref  int\n-\tnext *matchVec\n-}\n-\n-func (a *matchArena) new() *matchVec {\n-\tif a.head == nil {\n-\t\tconst N = 10\n-\t\tblock := make([]matchVec, N)\n-\t\tfor i := 0; i < N; i++ {\n-\t\t\tb := &block[i]\n-\t\t\tb.next = a.head\n-\t\t\ta.head = b\n-\t\t}\n-\t}\n-\tm := a.head\n-\ta.head = m.next\n-\tm.ref = 0\n-\tif m.m == nil {\n-\t\tm.m = make([]int, a.len)\n-\t}\n-\treturn m\n-}\n-\n-func (a *matchArena) free(m *matchVec) {\n-\tm.ref--\n-\tif m.ref == 0 {\n-\t\tm.next = a.head\n-\t\ta.head = m\n-\t}\n-}\n-\n-func (a *matchArena) copy(m *matchVec) *matchVec {\n-\tm1 := a.new()\n-\tcopy(m1.m, m.m)\n-\treturn m1\n-}\n-\n-func (a *matchArena) noMatch() *matchVec {\n-\tm := a.new()\n-\tfor i := range m.m {\n-\t\tm.m[i] = -1 // no match seen; catches cases like \"a(b)?c\" on \"ac\"\n-\t}\n-\tm.ref = 1\n-\treturn m\n-}\n-\n-type state struct {\n-\tinst     *instr // next instruction to execute\n-\tprefixed bool   // this match began with a fixed prefix\n-\tmatch    *matchVec\n-}\n-\n-// Append new state to to-do list.  Leftmost-longest wins so avoid\n-// adding a state that's already active.  The matchVec will be inc-ref'ed\n-// if it is assigned to a state.\n-func (a *matchArena) addState(s []state, inst *instr, prefixed bool, match *matchVec) []state {\n-\tswitch inst.kind {\n-\tcase iBOT:\n-\t\tif a.atBOT {\n-\t\t\ts = a.addState(s, inst.next, prefixed, match)\n-\t\t}\n-\t\treturn s\n-\tcase iEOT:\n-\t\tif a.atEOT {\n-\t\t\ts = a.addState(s, inst.next, prefixed, match)\n-\t\t}\n-\t\treturn s\n-\tcase iBra:\n-\t\tmatch.m[inst.braNum] = a.pos\n-\t\ts = a.addState(s, inst.next, prefixed, match)\n-\t\treturn s\n-\t}\n-\tl := len(s)\n-\t// States are inserted in order so it's sufficient to see if we have the same\n-\t// instruction; no need to see if existing match is earlier (it is).\n-\tfor i := 0; i < l; i++ {\n-\t\tif s[i].inst == inst {\n-\t\t\treturn s\n-\t\t}\n-\t}\n-\ts = append(s, state{inst, prefixed, match})\n-\tmatch.ref++\n-\tif inst.kind == iAlt {\n-\t\ts = a.addState(s, inst.left, prefixed, a.copy(match))\n-\t\t// give other branch a copy of this match vector\n-\t\ts = a.addState(s, inst.next, prefixed, a.copy(match))\n-\t}\n-\treturn s\n-}\n-\n-// input abstracts different representations of the input text. It provides\n-// one-character lookahead.\n-type input interface {\n-\tstep(pos int) (r rune, width int) // advance one rune\n-\tcanCheckPrefix() bool             // can we look ahead without losing info?\n-\thasPrefix(re *Regexp) bool\n-\tindex(re *Regexp, pos int) int\n-}\n-\n-// inputString scans a string.\n-type inputString struct {\n-\tstr string\n-}\n-\n-func newInputString(str string) *inputString {\n-\treturn &inputString{str: str}\n-}\n-\n-func (i *inputString) step(pos int) (rune, int) {\n-\tif pos < len(i.str) {\n-\t\treturn utf8.DecodeRuneInString(i.str[pos:len(i.str)])\n-\t}\n-\treturn endOfText, 0\n-}\n-\n-func (i *inputString) canCheckPrefix() bool {\n-\treturn true\n-}\n-\n-func (i *inputString) hasPrefix(re *Regexp) bool {\n-\treturn strings.HasPrefix(i.str, re.prefix)\n-}\n-\n-func (i *inputString) index(re *Regexp, pos int) int {\n-\treturn strings.Index(i.str[pos:], re.prefix)\n-}\n-\n-// inputBytes scans a byte slice.\n-type inputBytes struct {\n-\tstr []byte\n-}\n-\n-func newInputBytes(str []byte) *inputBytes {\n-\treturn &inputBytes{str: str}\n-}\n-\n-func (i *inputBytes) step(pos int) (rune, int) {\n-\tif pos < len(i.str) {\n-\t\treturn utf8.DecodeRune(i.str[pos:len(i.str)])\n-\t}\n-\treturn endOfText, 0\n-}\n-\n-func (i *inputBytes) canCheckPrefix() bool {\n-\treturn true\n-}\n-\n-func (i *inputBytes) hasPrefix(re *Regexp) bool {\n-\treturn bytes.HasPrefix(i.str, re.prefixBytes)\n-}\n-\n-func (i *inputBytes) index(re *Regexp, pos int) int {\n-\treturn bytes.Index(i.str[pos:], re.prefixBytes)\n-}\n-\n-// inputReader scans a RuneReader.\n-type inputReader struct {\n-\tr     io.RuneReader\n-\tatEOT bool\n-\tpos   int\n-}\n-\n-func newInputReader(r io.RuneReader) *inputReader {\n-\treturn &inputReader{r: r}\n-}\n-\n-func (i *inputReader) step(pos int) (rune, int) {\n-\tif !i.atEOT && pos != i.pos {\n-\t\treturn endOfText, 0\n-\n-\t}\n-\tr, w, err := i.r.ReadRune()\n-\tif err != nil {\n-\t\ti.atEOT = true\n-\t\treturn endOfText, 0\n-\t}\n-\ti.pos += w\n-\treturn r, w\n-}\n-\n-func (i *inputReader) canCheckPrefix() bool {\n-\treturn false\n-}\n-\n-func (i *inputReader) hasPrefix(re *Regexp) bool {\n-\treturn false\n-}\n-\n-func (i *inputReader) index(re *Regexp, pos int) int {\n-\treturn -1\n-}\n-\n-// Search match starting from pos bytes into the input.\n-func (re *Regexp) doExecute(i input, pos int) []int {\n-\tvar s [2][]state\n-\ts[0] = make([]state, 0, 10)\n-\ts[1] = make([]state, 0, 10)\n-\tin, out := 0, 1\n-\tvar final state\n-\tfound := false\n-\tanchored := re.inst[0].next.kind == iBOT\n-\tif anchored && pos > 0 {\n-\t\treturn nil\n-\t}\n-\t// fast check for initial plain substring\n-\tif i.canCheckPrefix() && re.prefix != \"\" {\n-\t\tadvance := 0\n-\t\tif anchored {\n-\t\t\tif !i.hasPrefix(re) {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t} else {\n-\t\t\tadvance = i.index(re, pos)\n-\t\t\tif advance == -1 {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t}\n-\t\tpos += advance\n-\t}\n-\t// We look one character ahead so we can match $, which checks whether\n-\t// we are at EOT.\n-\tnextChar, nextWidth := i.step(pos)\n-\tarena := &matchArena{\n-\t\tlen:   2 * (re.nbra + 1),\n-\t\tpos:   pos,\n-\t\tatBOT: pos == 0,\n-\t\tatEOT: nextChar == endOfText,\n-\t}\n-\tfor c, startPos := rune(0), pos; c != endOfText; {\n-\t\tif !found && (pos == startPos || !anchored) {\n-\t\t\t// prime the pump if we haven't seen a match yet\n-\t\t\tmatch := arena.noMatch()\n-\t\t\tmatch.m[0] = pos\n-\t\t\ts[out] = arena.addState(s[out], re.start.next, false, match)\n-\t\t\tarena.free(match) // if addState saved it, ref was incremented\n-\t\t} else if len(s[out]) == 0 {\n-\t\t\t// machine has completed\n-\t\t\tbreak\n-\t\t}\n-\t\tin, out = out, in // old out state is new in state\n-\t\t// clear out old state\n-\t\told := s[out]\n-\t\tfor _, state := range old {\n-\t\t\tarena.free(state.match)\n-\t\t}\n-\t\ts[out] = old[0:0] // truncate state vector\n-\t\tc = nextChar\n-\t\tthisPos := pos\n-\t\tpos += nextWidth\n-\t\tnextChar, nextWidth = i.step(pos)\n-\t\tarena.atEOT = nextChar == endOfText\n-\t\tarena.atBOT = false\n-\t\tarena.pos = pos\n-\t\tfor _, st := range s[in] {\n-\t\t\tswitch st.inst.kind {\n-\t\t\tcase iBOT:\n-\t\t\tcase iEOT:\n-\t\t\tcase iChar:\n-\t\t\t\tif c == st.inst.char {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match)\n-\t\t\t\t}\n-\t\t\tcase iCharClass:\n-\t\t\t\tif st.inst.cclass.matches(c) {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match)\n-\t\t\t\t}\n-\t\t\tcase iAny:\n-\t\t\t\tif c != endOfText {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match)\n-\t\t\t\t}\n-\t\t\tcase iNotNL:\n-\t\t\t\tif c != endOfText && c != '\\n' {\n-\t\t\t\t\ts[out] = arena.addState(s[out], st.inst.next, st.prefixed, st.match)\n-\t\t\t\t}\n-\t\t\tcase iBra:\n-\t\t\tcase iAlt:\n-\t\t\tcase iEnd:\n-\t\t\t\t// choose leftmost longest\n-\t\t\t\tif !found || // first\n-\t\t\t\t\tst.match.m[0] < final.match.m[0] || // leftmost\n-\t\t\t\t\t(st.match.m[0] == final.match.m[0] && thisPos > final.match.m[1]) { // longest\n-\t\t\t\t\tif final.match != nil {\n-\t\t\t\t\t\tarena.free(final.match)\n-\t\t\t\t\t}\n-\t\t\t\t\tfinal = st\n-\t\t\t\t\tfinal.match.ref++\n-\t\t\t\t\tfinal.match.m[1] = thisPos\n-\t\t\t\t}\n-\t\t\t\tfound = true\n-\t\t\tdefault:\n-\t\t\t\tst.inst.print()\n-\t\t\t\tpanic(\"unknown instruction in execute\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif final.match == nil {\n-\t\treturn nil\n-\t}\n-\t// if match found, back up start of match by width of prefix.\n-\tif final.prefixed && len(final.match.m) > 0 {\n-\t\tfinal.match.m[0] -= len(re.prefix)\n-\t}\n-\treturn final.match.m\n-}\n-\n-// LiteralPrefix returns a literal string that must begin any match\n-// of the regular expression re.  It returns the boolean true if the\n-// literal string comprises the entire regular expression.\n-func (re *Regexp) LiteralPrefix() (prefix string, complete bool) {\n-\tc := make([]rune, len(re.inst)-2) // minus start and end.\n-\t// First instruction is start; skip that.\n-\ti := 0\n-\tfor inst := re.inst[0].next; inst.kind != iEnd; inst = inst.next {\n-\t\t// stop if this is not a char\n-\t\tif inst.kind != iChar {\n-\t\t\treturn string(c[:i]), false\n-\t\t}\n-\t\tc[i] = inst.char\n-\t\ti++\n-\t}\n-\treturn string(c[:i]), true\n-}\n-\n-// MatchReader returns whether the Regexp matches the text read by the\n-// RuneReader.  The return value is a boolean: true for match, false for no\n-// match.\n-func (re *Regexp) MatchReader(r io.RuneReader) bool {\n-\treturn len(re.doExecute(newInputReader(r), 0)) > 0\n-}\n-\n-// MatchString returns whether the Regexp matches the string s.\n-// The return value is a boolean: true for match, false for no match.\n-func (re *Regexp) MatchString(s string) bool { return len(re.doExecute(newInputString(s), 0)) > 0 }\n-\n-// Match returns whether the Regexp matches the byte slice b.\n-// The return value is a boolean: true for match, false for no match.\n-func (re *Regexp) Match(b []byte) bool { return len(re.doExecute(newInputBytes(b), 0)) > 0 }\n-\n-// MatchReader checks whether a textual regular expression matches the text\n-// read by the RuneReader.  More complicated queries need to use Compile and\n-// the full Regexp interface.\n-func MatchReader(pattern string, r io.RuneReader) (matched bool, error error) {\n-\tre, err := Compile(pattern)\n-\tif err != nil {\n-\t\treturn false, err\n-\t}\n-\treturn re.MatchReader(r), nil\n-}\n-\n-// MatchString checks whether a textual regular expression\n-// matches a string.  More complicated queries need\n-// to use Compile and the full Regexp interface.\n-func MatchString(pattern string, s string) (matched bool, error error) {\n-\tre, err := Compile(pattern)\n-\tif err != nil {\n-\t\treturn false, err\n-\t}\n-\treturn re.MatchString(s), nil\n-}\n-\n-// Match checks whether a textual regular expression\n-// matches a byte slice.  More complicated queries need\n-// to use Compile and the full Regexp interface.\n-func Match(pattern string, b []byte) (matched bool, error error) {\n-\tre, err := Compile(pattern)\n-\tif err != nil {\n-\t\treturn false, err\n-\t}\n-\treturn re.Match(b), nil\n-}\n-\n-// ReplaceAllString returns a copy of src in which all matches for the Regexp\n-// have been replaced by repl.  No support is provided for expressions\n-// (e.g. \\1 or $1) in the replacement string.\n-func (re *Regexp) ReplaceAllString(src, repl string) string {\n-\treturn re.ReplaceAllStringFunc(src, func(string) string { return repl })\n-}\n-\n-// ReplaceAllStringFunc returns a copy of src in which all matches for the\n-// Regexp have been replaced by the return value of of function repl (whose\n-// first argument is the matched string).  No support is provided for\n-// expressions (e.g. \\1 or $1) in the replacement string.\n-func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {\n-\tlastMatchEnd := 0 // end position of the most recent match\n-\tsearchPos := 0    // position where we next look for a match\n-\tbuf := new(bytes.Buffer)\n-\tfor searchPos <= len(src) {\n-\t\ta := re.doExecute(newInputString(src), searchPos)\n-\t\tif len(a) == 0 {\n-\t\t\tbreak // no more matches\n-\t\t}\n-\n-\t\t// Copy the unmatched characters before this match.\n-\t\tio.WriteString(buf, src[lastMatchEnd:a[0]])\n-\n-\t\t// Now insert a copy of the replacement string, but not for a\n-\t\t// match of the empty string immediately after another match.\n-\t\t// (Otherwise, we get double replacement for patterns that\n-\t\t// match both empty and nonempty strings.)\n-\t\tif a[1] > lastMatchEnd || a[0] == 0 {\n-\t\t\tio.WriteString(buf, repl(src[a[0]:a[1]]))\n-\t\t}\n-\t\tlastMatchEnd = a[1]\n-\n-\t\t// Advance past this match; always advance at least one character.\n-\t\t_, width := utf8.DecodeRuneInString(src[searchPos:])\n-\t\tif searchPos+width > a[1] {\n-\t\t\tsearchPos += width\n-\t\t} else if searchPos+1 > a[1] {\n-\t\t\t// This clause is only needed at the end of the input\n-\t\t\t// string.  In that case, DecodeRuneInString returns width=0.\n-\t\t\tsearchPos++\n-\t\t} else {\n-\t\t\tsearchPos = a[1]\n-\t\t}\n-\t}\n-\n-\t// Copy the unmatched characters after the last match.\n-\tio.WriteString(buf, src[lastMatchEnd:])\n-\n-\treturn buf.String()\n-}\n-\n-// ReplaceAll returns a copy of src in which all matches for the Regexp\n-// have been replaced by repl.  No support is provided for expressions\n-// (e.g. \\1 or $1) in the replacement text.\n-func (re *Regexp) ReplaceAll(src, repl []byte) []byte {\n-\treturn re.ReplaceAllFunc(src, func([]byte) []byte { return repl })\n-}\n-\n-// ReplaceAllFunc returns a copy of src in which all matches for the\n-// Regexp have been replaced by the return value of of function repl (whose\n-// first argument is the matched []byte).  No support is provided for\n-// expressions (e.g. \\1 or $1) in the replacement string.\n-func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {\n-\tlastMatchEnd := 0 // end position of the most recent match\n-\tsearchPos := 0    // position where we next look for a match\n-\tbuf := new(bytes.Buffer)\n-\tfor searchPos <= len(src) {\n-\t\ta := re.doExecute(newInputBytes(src), searchPos)\n-\t\tif len(a) == 0 {\n-\t\t\tbreak // no more matches\n-\t\t}\n-\n-\t\t// Copy the unmatched characters before this match.\n-\t\tbuf.Write(src[lastMatchEnd:a[0]])\n-\n-\t\t// Now insert a copy of the replacement string, but not for a\n-\t\t// match of the empty string immediately after another match.\n-\t\t// (Otherwise, we get double replacement for patterns that\n-\t\t// match both empty and nonempty strings.)\n-\t\tif a[1] > lastMatchEnd || a[0] == 0 {\n-\t\t\tbuf.Write(repl(src[a[0]:a[1]]))\n-\t\t}\n-\t\tlastMatchEnd = a[1]\n-\n-\t\t// Advance past this match; always advance at least one character.\n-\t\t_, width := utf8.DecodeRune(src[searchPos:])\n-\t\tif searchPos+width > a[1] {\n-\t\t\tsearchPos += width\n-\t\t} else if searchPos+1 > a[1] {\n-\t\t\t// This clause is only needed at the end of the input\n-\t\t\t// string.  In that case, DecodeRuneInString returns width=0.\n-\t\t\tsearchPos++\n-\t\t} else {\n-\t\t\tsearchPos = a[1]\n-\t\t}\n-\t}\n-\n-\t// Copy the unmatched characters after the last match.\n-\tbuf.Write(src[lastMatchEnd:])\n-\n-\treturn buf.Bytes()\n-}\n-\n-// QuoteMeta returns a string that quotes all regular expression metacharacters\n-// inside the argument text; the returned string is a regular expression matching\n-// the literal text.  For example, QuoteMeta(`[foo]`) returns `\\[foo\\]`.\n-func QuoteMeta(s string) string {\n-\tb := make([]byte, 2*len(s))\n-\n-\t// A byte loop is correct because all metacharacters are ASCII.\n-\tj := 0\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif special(rune(s[i])) {\n-\t\t\tb[j] = '\\\\'\n-\t\t\tj++\n-\t\t}\n-\t\tb[j] = s[i]\n-\t\tj++\n-\t}\n-\treturn string(b[0:j])\n-}\n-\n-// Find matches in slice b if b is non-nil, otherwise find matches in string s.\n-func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int)) {\n-\tvar end int\n-\tif b == nil {\n-\t\tend = len(s)\n-\t} else {\n-\t\tend = len(b)\n-\t}\n-\n-\tfor pos, i, prevMatchEnd := 0, 0, -1; i < n && pos <= end; {\n-\t\tvar in input\n-\t\tif b == nil {\n-\t\t\tin = newInputString(s)\n-\t\t} else {\n-\t\t\tin = newInputBytes(b)\n-\t\t}\n-\t\tmatches := re.doExecute(in, pos)\n-\t\tif len(matches) == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\taccept := true\n-\t\tif matches[1] == pos {\n-\t\t\t// We've found an empty match.\n-\t\t\tif matches[0] == prevMatchEnd {\n-\t\t\t\t// We don't allow an empty match right\n-\t\t\t\t// after a previous match, so ignore it.\n-\t\t\t\taccept = false\n-\t\t\t}\n-\t\t\tvar width int\n-\t\t\t// TODO: use step()\n-\t\t\tif b == nil {\n-\t\t\t\t_, width = utf8.DecodeRuneInString(s[pos:end])\n-\t\t\t} else {\n-\t\t\t\t_, width = utf8.DecodeRune(b[pos:end])\n-\t\t\t}\n-\t\t\tif width > 0 {\n-\t\t\t\tpos += width\n-\t\t\t} else {\n-\t\t\t\tpos = end + 1\n-\t\t\t}\n-\t\t} else {\n-\t\t\tpos = matches[1]\n-\t\t}\n-\t\tprevMatchEnd = matches[1]\n-\n-\t\tif accept {\n-\t\t\tdeliver(matches)\n-\t\t\ti++\n-\t\t}\n-\t}\n-}\n-\n-// Find returns a slice holding the text of the leftmost match in b of the regular expression.\n-// A return value of nil indicates no match.\n-func (re *Regexp) Find(b []byte) []byte {\n-\ta := re.doExecute(newInputBytes(b), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\treturn b[a[0]:a[1]]\n-}\n-\n-// FindIndex returns a two-element slice of integers defining the location of\n-// the leftmost match in b of the regular expression.  The match itself is at\n-// b[loc[0]:loc[1]].\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindIndex(b []byte) (loc []int) {\n-\ta := re.doExecute(newInputBytes(b), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\treturn a[0:2]\n-}\n-\n-// FindString returns a string holding the text of the leftmost match in s of the regular\n-// expression.  If there is no match, the return value is an empty string,\n-// but it will also be empty if the regular expression successfully matches\n-// an empty string.  Use FindStringIndex or FindStringSubmatch if it is\n-// necessary to distinguish these cases.\n-func (re *Regexp) FindString(s string) string {\n-\ta := re.doExecute(newInputString(s), 0)\n-\tif a == nil {\n-\t\treturn \"\"\n-\t}\n-\treturn s[a[0]:a[1]]\n-}\n-\n-// FindStringIndex returns a two-element slice of integers defining the\n-// location of the leftmost match in s of the regular expression.  The match\n-// itself is at s[loc[0]:loc[1]].\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindStringIndex(s string) []int {\n-\ta := re.doExecute(newInputString(s), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\treturn a[0:2]\n-}\n-\n-// FindReaderIndex returns a two-element slice of integers defining the\n-// location of the leftmost match of the regular expression in text read from\n-// the RuneReader.  The match itself is at s[loc[0]:loc[1]].  A return\n-// value of nil indicates no match.\n-func (re *Regexp) FindReaderIndex(r io.RuneReader) []int {\n-\ta := re.doExecute(newInputReader(r), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\treturn a[0:2]\n-}\n-\n-// FindSubmatch returns a slice of slices holding the text of the leftmost\n-// match of the regular expression in b and the matches, if any, of its\n-// subexpressions, as defined by the 'Submatch' descriptions in the package\n-// comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindSubmatch(b []byte) [][]byte {\n-\ta := re.doExecute(newInputBytes(b), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\tret := make([][]byte, len(a)/2)\n-\tfor i := range ret {\n-\t\tif a[2*i] >= 0 {\n-\t\t\tret[i] = b[a[2*i]:a[2*i+1]]\n-\t\t}\n-\t}\n-\treturn ret\n-}\n-\n-// FindSubmatchIndex returns a slice holding the index pairs identifying the\n-// leftmost match of the regular expression in b and the matches, if any, of\n-// its subexpressions, as defined by the 'Submatch' and 'Index' descriptions\n-// in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindSubmatchIndex(b []byte) []int {\n-\treturn re.doExecute(newInputBytes(b), 0)\n-}\n-\n-// FindStringSubmatch returns a slice of strings holding the text of the\n-// leftmost match of the regular expression in s and the matches, if any, of\n-// its subexpressions, as defined by the 'Submatch' description in the\n-// package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindStringSubmatch(s string) []string {\n-\ta := re.doExecute(newInputString(s), 0)\n-\tif a == nil {\n-\t\treturn nil\n-\t}\n-\tret := make([]string, len(a)/2)\n-\tfor i := range ret {\n-\t\tif a[2*i] >= 0 {\n-\t\t\tret[i] = s[a[2*i]:a[2*i+1]]\n-\t\t}\n-\t}\n-\treturn ret\n-}\n-\n-// FindStringSubmatchIndex returns a slice holding the index pairs\n-// identifying the leftmost match of the regular expression in s and the\n-// matches, if any, of its subexpressions, as defined by the 'Submatch' and\n-// 'Index' descriptions in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindStringSubmatchIndex(s string) []int {\n-\treturn re.doExecute(newInputString(s), 0)\n-}\n-\n-// FindReaderSubmatchIndex returns a slice holding the index pairs\n-// identifying the leftmost match of the regular expression of text read by\n-// the RuneReader, and the matches, if any, of its subexpressions, as defined\n-// by the 'Submatch' and 'Index' descriptions in the package comment.  A\n-// return value of nil indicates no match.\n-func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int {\n-\treturn re.doExecute(newInputReader(r), 0)\n-}\n-\n-const startSize = 10 // The size at which to start a slice in the 'All' routines.\n-\n-// FindAll is the 'All' version of Find; it returns a slice of all successive\n-// matches of the expression, as defined by the 'All' description in the\n-// package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAll(b []byte, n int) [][]byte {\n-\tif n < 0 {\n-\t\tn = len(b) + 1\n-\t}\n-\tresult := make([][]byte, 0, startSize)\n-\tre.allMatches(\"\", b, n, func(match []int) {\n-\t\tresult = append(result, b[match[0]:match[1]])\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllIndex is the 'All' version of FindIndex; it returns a slice of all\n-// successive matches of the expression, as defined by the 'All' description\n-// in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllIndex(b []byte, n int) [][]int {\n-\tif n < 0 {\n-\t\tn = len(b) + 1\n-\t}\n-\tresult := make([][]int, 0, startSize)\n-\tre.allMatches(\"\", b, n, func(match []int) {\n-\t\tresult = append(result, match[0:2])\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllString is the 'All' version of FindString; it returns a slice of all\n-// successive matches of the expression, as defined by the 'All' description\n-// in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllString(s string, n int) []string {\n-\tif n < 0 {\n-\t\tn = len(s) + 1\n-\t}\n-\tresult := make([]string, 0, startSize)\n-\tre.allMatches(s, nil, n, func(match []int) {\n-\t\tresult = append(result, s[match[0]:match[1]])\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllStringIndex is the 'All' version of FindStringIndex; it returns a\n-// slice of all successive matches of the expression, as defined by the 'All'\n-// description in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllStringIndex(s string, n int) [][]int {\n-\tif n < 0 {\n-\t\tn = len(s) + 1\n-\t}\n-\tresult := make([][]int, 0, startSize)\n-\tre.allMatches(s, nil, n, func(match []int) {\n-\t\tresult = append(result, match[0:2])\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice\n-// of all successive matches of the expression, as defined by the 'All'\n-// description in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte {\n-\tif n < 0 {\n-\t\tn = len(b) + 1\n-\t}\n-\tresult := make([][][]byte, 0, startSize)\n-\tre.allMatches(\"\", b, n, func(match []int) {\n-\t\tslice := make([][]byte, len(match)/2)\n-\t\tfor j := range slice {\n-\t\t\tif match[2*j] >= 0 {\n-\t\t\t\tslice[j] = b[match[2*j]:match[2*j+1]]\n-\t\t\t}\n-\t\t}\n-\t\tresult = append(result, slice)\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns\n-// a slice of all successive matches of the expression, as defined by the\n-// 'All' description in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int {\n-\tif n < 0 {\n-\t\tn = len(b) + 1\n-\t}\n-\tresult := make([][]int, 0, startSize)\n-\tre.allMatches(\"\", b, n, func(match []int) {\n-\t\tresult = append(result, match)\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it\n-// returns a slice of all successive matches of the expression, as defined by\n-// the 'All' description in the package comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string {\n-\tif n < 0 {\n-\t\tn = len(s) + 1\n-\t}\n-\tresult := make([][]string, 0, startSize)\n-\tre.allMatches(s, nil, n, func(match []int) {\n-\t\tslice := make([]string, len(match)/2)\n-\t\tfor j := range slice {\n-\t\t\tif match[2*j] >= 0 {\n-\t\t\t\tslice[j] = s[match[2*j]:match[2*j+1]]\n-\t\t\t}\n-\t\t}\n-\t\tresult = append(result, slice)\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}\n-\n-// FindAllStringSubmatchIndex is the 'All' version of\n-// FindStringSubmatchIndex; it returns a slice of all successive matches of\n-// the expression, as defined by the 'All' description in the package\n-// comment.\n-// A return value of nil indicates no match.\n-func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int {\n-\tif n < 0 {\n-\t\tn = len(s) + 1\n-\t}\n-\tresult := make([][]int, 0, startSize)\n-\tre.allMatches(s, nil, n, func(match []int) {\n-\t\tresult = append(result, match)\n-\t})\n-\tif len(result) == 0 {\n-\t\treturn nil\n-\t}\n-\treturn result\n-}"}, {"sha": "e778d801dab40b073c69f8ebf51ca71665d8eb56", "filename": "libgo/go/old/template/doc.go", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fdoc.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n-\tPackage template implements data-driven templates for generating textual\n-\toutput such as HTML.\n-\n-\tTemplates are executed by applying them to a data structure.\n-\tAnnotations in the template refer to elements of the data\n-\tstructure (typically a field of a struct or a key in a map)\n-\tto control execution and derive values to be displayed.\n-\tThe template walks the structure as it executes and the\n-\t\"cursor\" @ represents the value at the current location\n-\tin the structure.\n-\n-\tData items may be values or pointers; the interface hides the\n-\tindirection.\n-\n-\tIn the following, 'Field' is one of several things, according to the data.\n-\n-\t\t- The name of a field of a struct (result = data.Field),\n-\t\t- The value stored in a map under that key (result = data[\"Field\"]), or\n-\t\t- The result of invoking a niladic single-valued method with that name\n-\t\t  (result = data.Field())\n-\n-\tIf Field is a struct field or method name, it must be an exported\n-\t(capitalized) name.\n-\n-\tMajor constructs ({} are the default delimiters for template actions;\n-\t[] are the notation in this comment for optional elements):\n-\n-\t\t{# comment }\n-\n-\tA one-line comment.\n-\n-\t\t{.section field} XXX [ {.or} YYY ] {.end}\n-\n-\tSet @ to the value of the field.  It may be an explicit @\n-\tto stay at the same point in the data. If the field is nil\n-\tor empty, execute YYY; otherwise execute XXX.\n-\n-\t\t{.repeated section field} XXX [ {.alternates with} ZZZ ] [ {.or} YYY ] {.end}\n-\n-\tLike .section, but field must be an array or slice.  XXX\n-\tis executed for each element.  If the array is nil or empty,\n-\tYYY is executed instead.  If the {.alternates with} marker\n-\tis present, ZZZ is executed between iterations of XXX.\n-\n-\t\t{field}\n-\t\t{field1 field2 ...}\n-\t\t{field|formatter}\n-\t\t{field1 field2...|formatter}\n-\t\t{field|formatter1|formatter2}\n-\n-\tInsert the value of the fields into the output. Each field is\n-\tfirst looked for in the cursor, as in .section and .repeated.\n-\tIf it is not found, the search continues in outer sections\n-\tuntil the top level is reached.\n-\n-\tIf the field value is a pointer, leading asterisks indicate\n-\tthat the value to be inserted should be evaluated through the\n-\tpointer.  For example, if x.p is of type *int, {x.p} will\n-\tinsert the value of the pointer but {*x.p} will insert the\n-\tvalue of the underlying integer.  If the value is nil or not a\n-\tpointer, asterisks have no effect.\n-\n-\tIf a formatter is specified, it must be named in the formatter\n-\tmap passed to the template set up routines or in the default\n-\tset (\"html\",\"str\",\"\") and is used to process the data for\n-\toutput.  The formatter function has signature\n-\t\tfunc(wr io.Writer, formatter string, data ...interface{})\n-\twhere wr is the destination for output, data holds the field\n-\tvalues at the instantiation, and formatter is its name at\n-\tthe invocation site.  The default formatter just concatenates\n-\tthe string representations of the fields.\n-\n-\tMultiple formatters separated by the pipeline character | are\n-\texecuted sequentially, with each formatter receiving the bytes\n-\temitted by the one to its left.\n-\n-\tAs well as field names, one may use literals with Go syntax.\n-\tInteger, floating-point, and string literals are supported.\n-\tRaw strings may not span newlines.\n-\n-\tThe delimiter strings get their default value, \"{\" and \"}\", from\n-\tJSON-template.  They may be set to any non-empty, space-free\n-\tstring using the SetDelims method.  Their value can be printed\n-\tin the output using {.meta-left} and {.meta-right}.\n-*/\n-package template"}, {"sha": "464b620c98b9275faa5db64c6785121facd0e3c3", "filename": "libgo/go/old/template/execute.go", "status": "removed", "additions": 0, "deletions": 346, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fexecute.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fexecute.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fexecute.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,346 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Code to execute a parsed template.\n-\n-package template\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"reflect\"\n-\t\"strings\"\n-)\n-\n-// Internal state for executing a Template.  As we evaluate the struct,\n-// the data item descends into the fields associated with sections, etc.\n-// Parent is used to walk upwards to find variables higher in the tree.\n-type state struct {\n-\tparent *state          // parent in hierarchy\n-\tdata   reflect.Value   // the driver data for this section etc.\n-\twr     io.Writer       // where to send output\n-\tbuf    [2]bytes.Buffer // alternating buffers used when chaining formatters\n-}\n-\n-func (parent *state) clone(data reflect.Value) *state {\n-\treturn &state{parent: parent, data: data, wr: parent.wr}\n-}\n-\n-// Evaluate interfaces and pointers looking for a value that can look up the name, via a\n-// struct field, method, or map key, and return the result of the lookup.\n-func (t *Template) lookup(st *state, v reflect.Value, name string) reflect.Value {\n-\tfor v.IsValid() {\n-\t\ttyp := v.Type()\n-\t\tif n := v.Type().NumMethod(); n > 0 {\n-\t\t\tfor i := 0; i < n; i++ {\n-\t\t\t\tm := typ.Method(i)\n-\t\t\t\tmtyp := m.Type\n-\t\t\t\tif m.Name == name && mtyp.NumIn() == 1 && mtyp.NumOut() == 1 {\n-\t\t\t\t\tif !isExported(name) {\n-\t\t\t\t\t\tt.execError(st, t.linenum, \"name not exported: %s in type %s\", name, st.data.Type())\n-\t\t\t\t\t}\n-\t\t\t\t\treturn v.Method(i).Call(nil)[0]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tswitch av := v; av.Kind() {\n-\t\tcase reflect.Ptr:\n-\t\t\tv = av.Elem()\n-\t\tcase reflect.Interface:\n-\t\t\tv = av.Elem()\n-\t\tcase reflect.Struct:\n-\t\t\tif !isExported(name) {\n-\t\t\t\tt.execError(st, t.linenum, \"name not exported: %s in type %s\", name, st.data.Type())\n-\t\t\t}\n-\t\t\treturn av.FieldByName(name)\n-\t\tcase reflect.Map:\n-\t\t\tif v := av.MapIndex(reflect.ValueOf(name)); v.IsValid() {\n-\t\t\t\treturn v\n-\t\t\t}\n-\t\t\treturn reflect.Zero(typ.Elem())\n-\t\tdefault:\n-\t\t\treturn reflect.Value{}\n-\t\t}\n-\t}\n-\treturn v\n-}\n-\n-// indirectPtr returns the item numLevels levels of indirection below the value.\n-// It is forgiving: if the value is not a pointer, it returns it rather than giving\n-// an error.  If the pointer is nil, it is returned as is.\n-func indirectPtr(v reflect.Value, numLevels int) reflect.Value {\n-\tfor i := numLevels; v.IsValid() && i > 0; i++ {\n-\t\tif p := v; p.Kind() == reflect.Ptr {\n-\t\t\tif p.IsNil() {\n-\t\t\t\treturn v\n-\t\t\t}\n-\t\t\tv = p.Elem()\n-\t\t} else {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn v\n-}\n-\n-// Walk v through pointers and interfaces, extracting the elements within.\n-func indirect(v reflect.Value) reflect.Value {\n-loop:\n-\tfor v.IsValid() {\n-\t\tswitch av := v; av.Kind() {\n-\t\tcase reflect.Ptr:\n-\t\t\tv = av.Elem()\n-\t\tcase reflect.Interface:\n-\t\t\tv = av.Elem()\n-\t\tdefault:\n-\t\t\tbreak loop\n-\t\t}\n-\t}\n-\treturn v\n-}\n-\n-// If the data for this template is a struct, find the named variable.\n-// Names of the form a.b.c are walked down the data tree.\n-// The special name \"@\" (the \"cursor\") denotes the current data.\n-// The value coming in (st.data) might need indirecting to reach\n-// a struct while the return value is not indirected - that is,\n-// it represents the actual named field. Leading stars indicate\n-// levels of indirection to be applied to the value.\n-func (t *Template) findVar(st *state, s string) reflect.Value {\n-\tdata := st.data\n-\tflattenedName := strings.TrimLeft(s, \"*\")\n-\tnumStars := len(s) - len(flattenedName)\n-\ts = flattenedName\n-\tif s == \"@\" {\n-\t\treturn indirectPtr(data, numStars)\n-\t}\n-\tfor _, elem := range strings.Split(s, \".\") {\n-\t\t// Look up field; data must be a struct or map.\n-\t\tdata = t.lookup(st, data, elem)\n-\t\tif !data.IsValid() {\n-\t\t\treturn reflect.Value{}\n-\t\t}\n-\t}\n-\treturn indirectPtr(data, numStars)\n-}\n-\n-// Is there no data to look at?\n-func empty(v reflect.Value) bool {\n-\tv = indirect(v)\n-\tif !v.IsValid() {\n-\t\treturn true\n-\t}\n-\tswitch v.Kind() {\n-\tcase reflect.Bool:\n-\t\treturn v.Bool() == false\n-\tcase reflect.String:\n-\t\treturn v.String() == \"\"\n-\tcase reflect.Struct:\n-\t\treturn false\n-\tcase reflect.Map:\n-\t\treturn false\n-\tcase reflect.Array:\n-\t\treturn v.Len() == 0\n-\tcase reflect.Slice:\n-\t\treturn v.Len() == 0\n-\t}\n-\treturn false\n-}\n-\n-// Look up a variable or method, up through the parent if necessary.\n-func (t *Template) varValue(name string, st *state) reflect.Value {\n-\tfield := t.findVar(st, name)\n-\tif !field.IsValid() {\n-\t\tif st.parent == nil {\n-\t\t\tt.execError(st, t.linenum, \"name not found: %s in type %s\", name, st.data.Type())\n-\t\t}\n-\t\treturn t.varValue(name, st.parent)\n-\t}\n-\treturn field\n-}\n-\n-func (t *Template) format(wr io.Writer, fmt string, val []interface{}, v *variableElement, st *state) {\n-\tfn := t.formatter(fmt)\n-\tif fn == nil {\n-\t\tt.execError(st, v.linenum, \"missing formatter %s for variable\", fmt)\n-\t}\n-\tfn(wr, fmt, val...)\n-}\n-\n-// Evaluate a variable, looking up through the parent if necessary.\n-// If it has a formatter attached ({var|formatter}) run that too.\n-func (t *Template) writeVariable(v *variableElement, st *state) {\n-\t// Resolve field names\n-\tval := make([]interface{}, len(v.args))\n-\tfor i, arg := range v.args {\n-\t\tif name, ok := arg.(fieldName); ok {\n-\t\t\tval[i] = t.varValue(string(name), st).Interface()\n-\t\t} else {\n-\t\t\tval[i] = arg\n-\t\t}\n-\t}\n-\tfor i, fmt := range v.fmts[:len(v.fmts)-1] {\n-\t\tb := &st.buf[i&1]\n-\t\tb.Reset()\n-\t\tt.format(b, fmt, val, v, st)\n-\t\tval = val[0:1]\n-\t\tval[0] = b.Bytes()\n-\t}\n-\tt.format(st.wr, v.fmts[len(v.fmts)-1], val, v, st)\n-}\n-\n-// Execute element i.  Return next index to execute.\n-func (t *Template) executeElement(i int, st *state) int {\n-\tswitch elem := t.elems[i].(type) {\n-\tcase *textElement:\n-\t\tst.wr.Write(elem.text)\n-\t\treturn i + 1\n-\tcase *literalElement:\n-\t\tst.wr.Write(elem.text)\n-\t\treturn i + 1\n-\tcase *variableElement:\n-\t\tt.writeVariable(elem, st)\n-\t\treturn i + 1\n-\tcase *sectionElement:\n-\t\tt.executeSection(elem, st)\n-\t\treturn elem.end\n-\tcase *repeatedElement:\n-\t\tt.executeRepeated(elem, st)\n-\t\treturn elem.end\n-\t}\n-\te := t.elems[i]\n-\tt.execError(st, 0, \"internal error: bad directive in execute: %v %T\\n\", reflect.ValueOf(e).Interface(), e)\n-\treturn 0\n-}\n-\n-// Execute the template.\n-func (t *Template) execute(start, end int, st *state) {\n-\tfor i := start; i < end; {\n-\t\ti = t.executeElement(i, st)\n-\t}\n-}\n-\n-// Execute a .section\n-func (t *Template) executeSection(s *sectionElement, st *state) {\n-\t// Find driver data for this section.  It must be in the current struct.\n-\tfield := t.varValue(s.field, st)\n-\tif !field.IsValid() {\n-\t\tt.execError(st, s.linenum, \".section: cannot find field %s in %s\", s.field, st.data.Type())\n-\t}\n-\tst = st.clone(field)\n-\tstart, end := s.start, s.or\n-\tif !empty(field) {\n-\t\t// Execute the normal block.\n-\t\tif end < 0 {\n-\t\t\tend = s.end\n-\t\t}\n-\t} else {\n-\t\t// Execute the .or block.  If it's missing, do nothing.\n-\t\tstart, end = s.or, s.end\n-\t\tif start < 0 {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tfor i := start; i < end; {\n-\t\ti = t.executeElement(i, st)\n-\t}\n-}\n-\n-// Return the result of calling the Iter method on v, or nil.\n-func iter(v reflect.Value) reflect.Value {\n-\tfor j := 0; j < v.Type().NumMethod(); j++ {\n-\t\tmth := v.Type().Method(j)\n-\t\tfv := v.Method(j)\n-\t\tft := fv.Type()\n-\t\t// TODO(rsc): NumIn() should return 0 here, because ft is from a curried FuncValue.\n-\t\tif mth.Name != \"Iter\" || ft.NumIn() != 1 || ft.NumOut() != 1 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tct := ft.Out(0)\n-\t\tif ct.Kind() != reflect.Chan ||\n-\t\t\tct.ChanDir()&reflect.RecvDir == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\treturn fv.Call(nil)[0]\n-\t}\n-\treturn reflect.Value{}\n-}\n-\n-// Execute a .repeated section\n-func (t *Template) executeRepeated(r *repeatedElement, st *state) {\n-\t// Find driver data for this section.  It must be in the current struct.\n-\tfield := t.varValue(r.field, st)\n-\tif !field.IsValid() {\n-\t\tt.execError(st, r.linenum, \".repeated: cannot find field %s in %s\", r.field, st.data.Type())\n-\t}\n-\tfield = indirect(field)\n-\n-\tstart, end := r.start, r.or\n-\tif end < 0 {\n-\t\tend = r.end\n-\t}\n-\tif r.altstart >= 0 {\n-\t\tend = r.altstart\n-\t}\n-\tfirst := true\n-\n-\t// Code common to all the loops.\n-\tloopBody := func(newst *state) {\n-\t\t// .alternates between elements\n-\t\tif !first && r.altstart >= 0 {\n-\t\t\tfor i := r.altstart; i < r.altend; {\n-\t\t\t\ti = t.executeElement(i, newst)\n-\t\t\t}\n-\t\t}\n-\t\tfirst = false\n-\t\tfor i := start; i < end; {\n-\t\t\ti = t.executeElement(i, newst)\n-\t\t}\n-\t}\n-\n-\tif array := field; array.Kind() == reflect.Array || array.Kind() == reflect.Slice {\n-\t\tfor j := 0; j < array.Len(); j++ {\n-\t\t\tloopBody(st.clone(array.Index(j)))\n-\t\t}\n-\t} else if m := field; m.Kind() == reflect.Map {\n-\t\tfor _, key := range m.MapKeys() {\n-\t\t\tloopBody(st.clone(m.MapIndex(key)))\n-\t\t}\n-\t} else if ch := iter(field); ch.IsValid() {\n-\t\tfor {\n-\t\t\te, ok := ch.Recv()\n-\t\t\tif !ok {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tloopBody(st.clone(e))\n-\t\t}\n-\t} else {\n-\t\tt.execError(st, r.linenum, \".repeated: cannot repeat %s (type %s)\",\n-\t\t\tr.field, field.Type())\n-\t}\n-\n-\tif first {\n-\t\t// Empty. Execute the .or block, once.  If it's missing, do nothing.\n-\t\tstart, end := r.or, r.end\n-\t\tif start >= 0 {\n-\t\t\tnewst := st.clone(field)\n-\t\t\tfor i := start; i < end; {\n-\t\t\t\ti = t.executeElement(i, newst)\n-\t\t\t}\n-\t\t}\n-\t\treturn\n-\t}\n-}\n-\n-// A valid delimiter must contain no space and be non-empty.\n-func validDelim(d []byte) bool {\n-\tif len(d) == 0 {\n-\t\treturn false\n-\t}\n-\tfor _, c := range d {\n-\t\tif isSpace(c) {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}"}, {"sha": "9156b0808163e3536b1ebc9a23194d43ae47b342", "filename": "libgo/go/old/template/format.go", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fformat.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Template library: default formatters\n-\n-package template\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io\"\n-)\n-\n-// StringFormatter formats into the default string representation.\n-// It is stored under the name \"str\" and is the default formatter.\n-// You can override the default formatter by storing your default\n-// under the name \"\" in your custom formatter map.\n-func StringFormatter(w io.Writer, format string, value ...interface{}) {\n-\tif len(value) == 1 {\n-\t\tif b, ok := value[0].([]byte); ok {\n-\t\t\tw.Write(b)\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tfmt.Fprint(w, value...)\n-}\n-\n-var (\n-\tesc_quot = []byte(\"&#34;\") // shorter than \"&quot;\"\n-\tesc_apos = []byte(\"&#39;\") // shorter than \"&apos;\"\n-\tesc_amp  = []byte(\"&amp;\")\n-\tesc_lt   = []byte(\"&lt;\")\n-\tesc_gt   = []byte(\"&gt;\")\n-)\n-\n-// HTMLEscape writes to w the properly escaped HTML equivalent\n-// of the plain text data s.\n-func HTMLEscape(w io.Writer, s []byte) {\n-\tvar esc []byte\n-\tlast := 0\n-\tfor i, c := range s {\n-\t\tswitch c {\n-\t\tcase '\"':\n-\t\t\tesc = esc_quot\n-\t\tcase '\\'':\n-\t\t\tesc = esc_apos\n-\t\tcase '&':\n-\t\t\tesc = esc_amp\n-\t\tcase '<':\n-\t\t\tesc = esc_lt\n-\t\tcase '>':\n-\t\t\tesc = esc_gt\n-\t\tdefault:\n-\t\t\tcontinue\n-\t\t}\n-\t\tw.Write(s[last:i])\n-\t\tw.Write(esc)\n-\t\tlast = i + 1\n-\t}\n-\tw.Write(s[last:])\n-}\n-\n-// HTMLFormatter formats arbitrary values for HTML\n-func HTMLFormatter(w io.Writer, format string, value ...interface{}) {\n-\tok := false\n-\tvar b []byte\n-\tif len(value) == 1 {\n-\t\tb, ok = value[0].([]byte)\n-\t}\n-\tif !ok {\n-\t\tvar buf bytes.Buffer\n-\t\tfmt.Fprint(&buf, value...)\n-\t\tb = buf.Bytes()\n-\t}\n-\tHTMLEscape(w, b)\n-}"}, {"sha": "e1bfa4724996f1bd791b6f0e1e35801ae4729718", "filename": "libgo/go/old/template/parse.go", "status": "removed", "additions": 0, "deletions": 742, "changes": 742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,742 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Code to parse a template.\n-\n-package template\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"reflect\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"unicode\"\n-\t\"unicode/utf8\"\n-)\n-\n-// Errors returned during parsing and execution.  Users may extract the information and reformat\n-// if they desire.\n-type Error struct {\n-\tLine int\n-\tMsg  string\n-}\n-\n-func (e *Error) Error() string { return fmt.Sprintf(\"line %d: %s\", e.Line, e.Msg) }\n-\n-// checkError is a deferred function to turn a panic with type *Error into a plain error return.\n-// Other panics are unexpected and so are re-enabled.\n-func checkError(error *error) {\n-\tif v := recover(); v != nil {\n-\t\tif e, ok := v.(*Error); ok {\n-\t\t\t*error = e\n-\t\t} else {\n-\t\t\t// runtime errors should crash\n-\t\t\tpanic(v)\n-\t\t}\n-\t}\n-}\n-\n-// Most of the literals are aces.\n-var lbrace = []byte{'{'}\n-var rbrace = []byte{'}'}\n-var space = []byte{' '}\n-var tab = []byte{'\\t'}\n-\n-// The various types of \"tokens\", which are plain text or (usually) brace-delimited descriptors\n-const (\n-\ttokAlternates = iota\n-\ttokComment\n-\ttokEnd\n-\ttokLiteral\n-\ttokOr\n-\ttokRepeated\n-\ttokSection\n-\ttokText\n-\ttokVariable\n-)\n-\n-// FormatterMap is the type describing the mapping from formatter\n-// names to the functions that implement them.\n-type FormatterMap map[string]func(io.Writer, string, ...interface{})\n-\n-// Built-in formatters.\n-var builtins = FormatterMap{\n-\t\"html\": HTMLFormatter,\n-\t\"str\":  StringFormatter,\n-\t\"\":     StringFormatter,\n-}\n-\n-// The parsed state of a template is a vector of xxxElement structs.\n-// Sections have line numbers so errors can be reported better during execution.\n-\n-// Plain text.\n-type textElement struct {\n-\ttext []byte\n-}\n-\n-// A literal such as .meta-left or .meta-right\n-type literalElement struct {\n-\ttext []byte\n-}\n-\n-// A variable invocation to be evaluated\n-type variableElement struct {\n-\tlinenum int\n-\targs    []interface{} // The fields and literals in the invocation.\n-\tfmts    []string      // Names of formatters to apply. len(fmts) > 0\n-}\n-\n-// A variableElement arg to be evaluated as a field name\n-type fieldName string\n-\n-// A .section block, possibly with a .or\n-type sectionElement struct {\n-\tlinenum int    // of .section itself\n-\tfield   string // cursor field for this block\n-\tstart   int    // first element\n-\tor      int    // first element of .or block\n-\tend     int    // one beyond last element\n-}\n-\n-// A .repeated block, possibly with a .or and a .alternates\n-type repeatedElement struct {\n-\tsectionElement     // It has the same structure...\n-\taltstart       int // ... except for alternates\n-\taltend         int\n-}\n-\n-// Template is the type that represents a template definition.\n-// It is unchanged after parsing.\n-type Template struct {\n-\tfmap FormatterMap // formatters for variables\n-\t// Used during parsing:\n-\tldelim, rdelim []byte // delimiters; default {}\n-\tbuf            []byte // input text to process\n-\tp              int    // position in buf\n-\tlinenum        int    // position in input\n-\t// Parsed results:\n-\telems []interface{}\n-}\n-\n-// New creates a new template with the specified formatter map (which\n-// may be nil) to define auxiliary functions for formatting variables.\n-func New(fmap FormatterMap) *Template {\n-\tt := new(Template)\n-\tt.fmap = fmap\n-\tt.ldelim = lbrace\n-\tt.rdelim = rbrace\n-\tt.elems = make([]interface{}, 0, 16)\n-\treturn t\n-}\n-\n-// Report error and stop executing.  The line number must be provided explicitly.\n-func (t *Template) execError(st *state, line int, err string, args ...interface{}) {\n-\tpanic(&Error{line, fmt.Sprintf(err, args...)})\n-}\n-\n-// Report error, panic to terminate parsing.\n-// The line number comes from the template state.\n-func (t *Template) parseError(err string, args ...interface{}) {\n-\tpanic(&Error{t.linenum, fmt.Sprintf(err, args...)})\n-}\n-\n-// Is this an exported - upper case - name?\n-func isExported(name string) bool {\n-\tr, _ := utf8.DecodeRuneInString(name)\n-\treturn unicode.IsUpper(r)\n-}\n-\n-// -- Lexical analysis\n-\n-// Is c a space character?\n-func isSpace(c uint8) bool { return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n' }\n-\n-// Safely, does s[n:n+len(t)] == t?\n-func equal(s []byte, n int, t []byte) bool {\n-\tb := s[n:]\n-\tif len(t) > len(b) { // not enough space left for a match.\n-\t\treturn false\n-\t}\n-\tfor i, c := range t {\n-\t\tif c != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-// isQuote returns true if c is a string- or character-delimiting quote character.\n-func isQuote(c byte) bool {\n-\treturn c == '\"' || c == '`' || c == '\\''\n-}\n-\n-// endQuote returns the end quote index for the quoted string that\n-// starts at n, or -1 if no matching end quote is found before the end\n-// of the line.\n-func endQuote(s []byte, n int) int {\n-\tquote := s[n]\n-\tfor n++; n < len(s); n++ {\n-\t\tswitch s[n] {\n-\t\tcase '\\\\':\n-\t\t\tif quote == '\"' || quote == '\\'' {\n-\t\t\t\tn++\n-\t\t\t}\n-\t\tcase '\\n':\n-\t\t\treturn -1\n-\t\tcase quote:\n-\t\t\treturn n\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-// nextItem returns the next item from the input buffer.  If the returned\n-// item is empty, we are at EOF.  The item will be either a\n-// delimited string or a non-empty string between delimited\n-// strings. Tokens stop at (but include, if plain text) a newline.\n-// Action tokens on a line by themselves drop any space on\n-// either side, up to and including the newline.\n-func (t *Template) nextItem() []byte {\n-\tstartOfLine := t.p == 0 || t.buf[t.p-1] == '\\n'\n-\tstart := t.p\n-\tvar i int\n-\tnewline := func() {\n-\t\tt.linenum++\n-\t\ti++\n-\t}\n-\t// Leading space up to but not including newline\n-\tfor i = start; i < len(t.buf); i++ {\n-\t\tif t.buf[i] == '\\n' || !isSpace(t.buf[i]) {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tleadingSpace := i > start\n-\t// What's left is nothing, newline, delimited string, or plain text\n-\tswitch {\n-\tcase i == len(t.buf):\n-\t\t// EOF; nothing to do\n-\tcase t.buf[i] == '\\n':\n-\t\tnewline()\n-\tcase equal(t.buf, i, t.ldelim):\n-\t\tleft := i         // Start of left delimiter.\n-\t\tright := -1       // Will be (immediately after) right delimiter.\n-\t\thaveText := false // Delimiters contain text.\n-\t\ti += len(t.ldelim)\n-\t\t// Find the end of the action.\n-\t\tfor ; i < len(t.buf); i++ {\n-\t\t\tif t.buf[i] == '\\n' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif isQuote(t.buf[i]) {\n-\t\t\t\ti = endQuote(t.buf, i)\n-\t\t\t\tif i == -1 {\n-\t\t\t\t\tt.parseError(\"unmatched quote\")\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif equal(t.buf, i, t.rdelim) {\n-\t\t\t\ti += len(t.rdelim)\n-\t\t\t\tright = i\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\thaveText = true\n-\t\t}\n-\t\tif right < 0 {\n-\t\t\tt.parseError(\"unmatched opening delimiter\")\n-\t\t\treturn nil\n-\t\t}\n-\t\t// Is this a special action (starts with '.' or '#') and the only thing on the line?\n-\t\tif startOfLine && haveText {\n-\t\t\tfirstChar := t.buf[left+len(t.ldelim)]\n-\t\t\tif firstChar == '.' || firstChar == '#' {\n-\t\t\t\t// It's special and the first thing on the line. Is it the last?\n-\t\t\t\tfor j := right; j < len(t.buf) && isSpace(t.buf[j]); j++ {\n-\t\t\t\t\tif t.buf[j] == '\\n' {\n-\t\t\t\t\t\t// Yes it is. Drop the surrounding space and return the {.foo}\n-\t\t\t\t\t\tt.linenum++\n-\t\t\t\t\t\tt.p = j + 1\n-\t\t\t\t\t\treturn t.buf[left:right]\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// No it's not. If there's leading space, return that.\n-\t\tif leadingSpace {\n-\t\t\t// not trimming space: return leading space if there is some.\n-\t\t\tt.p = left\n-\t\t\treturn t.buf[start:left]\n-\t\t}\n-\t\t// Return the word, leave the trailing space.\n-\t\tstart = left\n-\t\tbreak\n-\tdefault:\n-\t\tfor ; i < len(t.buf); i++ {\n-\t\t\tif t.buf[i] == '\\n' {\n-\t\t\t\tnewline()\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif equal(t.buf, i, t.ldelim) {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\titem := t.buf[start:i]\n-\tt.p = i\n-\treturn item\n-}\n-\n-// Turn a byte array into a space-split array of strings,\n-// taking into account quoted strings.\n-func words(buf []byte) []string {\n-\ts := make([]string, 0, 5)\n-\tfor i := 0; i < len(buf); {\n-\t\t// One word per loop\n-\t\tfor i < len(buf) && isSpace(buf[i]) {\n-\t\t\ti++\n-\t\t}\n-\t\tif i == len(buf) {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Got a word\n-\t\tstart := i\n-\t\tif isQuote(buf[i]) {\n-\t\t\ti = endQuote(buf, i)\n-\t\t\tif i < 0 {\n-\t\t\t\ti = len(buf)\n-\t\t\t} else {\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t}\n-\t\t// Even with quotes, break on space only.  This handles input\n-\t\t// such as {\"\"|} and catches quoting mistakes.\n-\t\tfor i < len(buf) && !isSpace(buf[i]) {\n-\t\t\ti++\n-\t\t}\n-\t\ts = append(s, string(buf[start:i]))\n-\t}\n-\treturn s\n-}\n-\n-// Analyze an item and return its token type and, if it's an action item, an array of\n-// its constituent words.\n-func (t *Template) analyze(item []byte) (tok int, w []string) {\n-\t// item is known to be non-empty\n-\tif !equal(item, 0, t.ldelim) { // doesn't start with left delimiter\n-\t\ttok = tokText\n-\t\treturn\n-\t}\n-\tif !equal(item, len(item)-len(t.rdelim), t.rdelim) { // doesn't end with right delimiter\n-\t\tt.parseError(\"internal error: unmatched opening delimiter\") // lexing should prevent this\n-\t\treturn\n-\t}\n-\tif len(item) <= len(t.ldelim)+len(t.rdelim) { // no contents\n-\t\tt.parseError(\"empty directive\")\n-\t\treturn\n-\t}\n-\t// Comment\n-\tif item[len(t.ldelim)] == '#' {\n-\t\ttok = tokComment\n-\t\treturn\n-\t}\n-\t// Split into words\n-\tw = words(item[len(t.ldelim) : len(item)-len(t.rdelim)]) // drop final delimiter\n-\tif len(w) == 0 {\n-\t\tt.parseError(\"empty directive\")\n-\t\treturn\n-\t}\n-\tfirst := w[0]\n-\tif first[0] != '.' {\n-\t\ttok = tokVariable\n-\t\treturn\n-\t}\n-\tif len(first) > 1 && first[1] >= '0' && first[1] <= '9' {\n-\t\t// Must be a float.\n-\t\ttok = tokVariable\n-\t\treturn\n-\t}\n-\tswitch first {\n-\tcase \".meta-left\", \".meta-right\", \".space\", \".tab\":\n-\t\ttok = tokLiteral\n-\t\treturn\n-\tcase \".or\":\n-\t\ttok = tokOr\n-\t\treturn\n-\tcase \".end\":\n-\t\ttok = tokEnd\n-\t\treturn\n-\tcase \".section\":\n-\t\tif len(w) != 2 {\n-\t\t\tt.parseError(\"incorrect fields for .section: %s\", item)\n-\t\t\treturn\n-\t\t}\n-\t\ttok = tokSection\n-\t\treturn\n-\tcase \".repeated\":\n-\t\tif len(w) != 3 || w[1] != \"section\" {\n-\t\t\tt.parseError(\"incorrect fields for .repeated: %s\", item)\n-\t\t\treturn\n-\t\t}\n-\t\ttok = tokRepeated\n-\t\treturn\n-\tcase \".alternates\":\n-\t\tif len(w) != 2 || w[1] != \"with\" {\n-\t\t\tt.parseError(\"incorrect fields for .alternates: %s\", item)\n-\t\t\treturn\n-\t\t}\n-\t\ttok = tokAlternates\n-\t\treturn\n-\t}\n-\tt.parseError(\"bad directive: %s\", item)\n-\treturn\n-}\n-\n-// formatter returns the Formatter with the given name in the Template, or nil if none exists.\n-func (t *Template) formatter(name string) func(io.Writer, string, ...interface{}) {\n-\tif t.fmap != nil {\n-\t\tif fn := t.fmap[name]; fn != nil {\n-\t\t\treturn fn\n-\t\t}\n-\t}\n-\treturn builtins[name]\n-}\n-\n-// -- Parsing\n-\n-// newVariable allocates a new variable-evaluation element.\n-func (t *Template) newVariable(words []string) *variableElement {\n-\tformatters := extractFormatters(words)\n-\targs := make([]interface{}, len(words))\n-\n-\t// Build argument list, processing any literals\n-\tfor i, word := range words {\n-\t\tvar lerr error\n-\t\tswitch word[0] {\n-\t\tcase '\"', '`', '\\'':\n-\t\t\tv, err := strconv.Unquote(word)\n-\t\t\tif err == nil && word[0] == '\\'' {\n-\t\t\t\targs[i], _ = utf8.DecodeRuneInString(v)\n-\t\t\t} else {\n-\t\t\t\targs[i], lerr = v, err\n-\t\t\t}\n-\n-\t\tcase '.', '+', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n-\t\t\tv, err := strconv.ParseInt(word, 0, 64)\n-\t\t\tif err == nil {\n-\t\t\t\targs[i] = v\n-\t\t\t} else {\n-\t\t\t\tv, err := strconv.ParseFloat(word, 64)\n-\t\t\t\targs[i], lerr = v, err\n-\t\t\t}\n-\n-\t\tdefault:\n-\t\t\targs[i] = fieldName(word)\n-\t\t}\n-\t\tif lerr != nil {\n-\t\t\tt.parseError(\"invalid literal: %q: %s\", word, lerr)\n-\t\t}\n-\t}\n-\n-\t// We could remember the function address here and avoid the lookup later,\n-\t// but it's more dynamic to let the user change the map contents underfoot.\n-\t// We do require the name to be present, though.\n-\n-\t// Is it in user-supplied map?\n-\tfor _, f := range formatters {\n-\t\tif t.formatter(f) == nil {\n-\t\t\tt.parseError(\"unknown formatter: %q\", f)\n-\t\t}\n-\t}\n-\n-\treturn &variableElement{t.linenum, args, formatters}\n-}\n-\n-// extractFormatters extracts a list of formatters from words.\n-// After the final space-separated argument in a variable, formatters may be\n-// specified separated by pipe symbols. For example: {a b c|d|e}\n-// The words parameter still has the formatters joined by '|' in the last word.\n-// extractFormatters splits formatters, replaces the last word with the content\n-// found before the first '|' within it, and returns the formatters obtained.\n-// If no formatters are found in words, the default formatter is returned.\n-func extractFormatters(words []string) (formatters []string) {\n-\t// \"\" is the default formatter.\n-\tformatters = []string{\"\"}\n-\tif len(words) == 0 {\n-\t\treturn\n-\t}\n-\tvar bar int\n-\tlastWord := words[len(words)-1]\n-\tif isQuote(lastWord[0]) {\n-\t\tend := endQuote([]byte(lastWord), 0)\n-\t\tif end < 0 || end+1 == len(lastWord) || lastWord[end+1] != '|' {\n-\t\t\treturn\n-\t\t}\n-\t\tbar = end + 1\n-\t} else {\n-\t\tbar = strings.IndexRune(lastWord, '|')\n-\t\tif bar < 0 {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\twords[len(words)-1] = lastWord[0:bar]\n-\tformatters = strings.Split(lastWord[bar+1:], \"|\")\n-\treturn\n-}\n-\n-// Grab the next item.  If it's simple, just append it to the template.\n-// Otherwise return its details.\n-func (t *Template) parseSimple(item []byte) (done bool, tok int, w []string) {\n-\ttok, w = t.analyze(item)\n-\tdone = true // assume for simplicity\n-\tswitch tok {\n-\tcase tokComment:\n-\t\treturn\n-\tcase tokText:\n-\t\tt.elems = append(t.elems, &textElement{item})\n-\t\treturn\n-\tcase tokLiteral:\n-\t\tswitch w[0] {\n-\t\tcase \".meta-left\":\n-\t\t\tt.elems = append(t.elems, &literalElement{t.ldelim})\n-\t\tcase \".meta-right\":\n-\t\t\tt.elems = append(t.elems, &literalElement{t.rdelim})\n-\t\tcase \".space\":\n-\t\t\tt.elems = append(t.elems, &literalElement{space})\n-\t\tcase \".tab\":\n-\t\t\tt.elems = append(t.elems, &literalElement{tab})\n-\t\tdefault:\n-\t\t\tt.parseError(\"internal error: unknown literal: %s\", w[0])\n-\t\t}\n-\t\treturn\n-\tcase tokVariable:\n-\t\tt.elems = append(t.elems, t.newVariable(w))\n-\t\treturn\n-\t}\n-\treturn false, tok, w\n-}\n-\n-// parseRepeated and parseSection are mutually recursive\n-\n-func (t *Template) parseRepeated(words []string) *repeatedElement {\n-\tr := new(repeatedElement)\n-\tt.elems = append(t.elems, r)\n-\tr.linenum = t.linenum\n-\tr.field = words[2]\n-\t// Scan section, collecting true and false (.or) blocks.\n-\tr.start = len(t.elems)\n-\tr.or = -1\n-\tr.altstart = -1\n-\tr.altend = -1\n-Loop:\n-\tfor {\n-\t\titem := t.nextItem()\n-\t\tif len(item) == 0 {\n-\t\t\tt.parseError(\"missing .end for .repeated section\")\n-\t\t\tbreak\n-\t\t}\n-\t\tdone, tok, w := t.parseSimple(item)\n-\t\tif done {\n-\t\t\tcontinue\n-\t\t}\n-\t\tswitch tok {\n-\t\tcase tokEnd:\n-\t\t\tbreak Loop\n-\t\tcase tokOr:\n-\t\t\tif r.or >= 0 {\n-\t\t\t\tt.parseError(\"extra .or in .repeated section\")\n-\t\t\t\tbreak Loop\n-\t\t\t}\n-\t\t\tr.altend = len(t.elems)\n-\t\t\tr.or = len(t.elems)\n-\t\tcase tokSection:\n-\t\t\tt.parseSection(w)\n-\t\tcase tokRepeated:\n-\t\t\tt.parseRepeated(w)\n-\t\tcase tokAlternates:\n-\t\t\tif r.altstart >= 0 {\n-\t\t\t\tt.parseError(\"extra .alternates in .repeated section\")\n-\t\t\t\tbreak Loop\n-\t\t\t}\n-\t\t\tif r.or >= 0 {\n-\t\t\t\tt.parseError(\".alternates inside .or block in .repeated section\")\n-\t\t\t\tbreak Loop\n-\t\t\t}\n-\t\t\tr.altstart = len(t.elems)\n-\t\tdefault:\n-\t\t\tt.parseError(\"internal error: unknown repeated section item: %s\", item)\n-\t\t\tbreak Loop\n-\t\t}\n-\t}\n-\tif r.altend < 0 {\n-\t\tr.altend = len(t.elems)\n-\t}\n-\tr.end = len(t.elems)\n-\treturn r\n-}\n-\n-func (t *Template) parseSection(words []string) *sectionElement {\n-\ts := new(sectionElement)\n-\tt.elems = append(t.elems, s)\n-\ts.linenum = t.linenum\n-\ts.field = words[1]\n-\t// Scan section, collecting true and false (.or) blocks.\n-\ts.start = len(t.elems)\n-\ts.or = -1\n-Loop:\n-\tfor {\n-\t\titem := t.nextItem()\n-\t\tif len(item) == 0 {\n-\t\t\tt.parseError(\"missing .end for .section\")\n-\t\t\tbreak\n-\t\t}\n-\t\tdone, tok, w := t.parseSimple(item)\n-\t\tif done {\n-\t\t\tcontinue\n-\t\t}\n-\t\tswitch tok {\n-\t\tcase tokEnd:\n-\t\t\tbreak Loop\n-\t\tcase tokOr:\n-\t\t\tif s.or >= 0 {\n-\t\t\t\tt.parseError(\"extra .or in .section\")\n-\t\t\t\tbreak Loop\n-\t\t\t}\n-\t\t\ts.or = len(t.elems)\n-\t\tcase tokSection:\n-\t\t\tt.parseSection(w)\n-\t\tcase tokRepeated:\n-\t\t\tt.parseRepeated(w)\n-\t\tcase tokAlternates:\n-\t\t\tt.parseError(\".alternates not in .repeated\")\n-\t\tdefault:\n-\t\t\tt.parseError(\"internal error: unknown section item: %s\", item)\n-\t\t}\n-\t}\n-\ts.end = len(t.elems)\n-\treturn s\n-}\n-\n-func (t *Template) parse() {\n-\tfor {\n-\t\titem := t.nextItem()\n-\t\tif len(item) == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\tdone, tok, w := t.parseSimple(item)\n-\t\tif done {\n-\t\t\tcontinue\n-\t\t}\n-\t\tswitch tok {\n-\t\tcase tokOr, tokEnd, tokAlternates:\n-\t\t\tt.parseError(\"unexpected %s\", w[0])\n-\t\tcase tokSection:\n-\t\t\tt.parseSection(w)\n-\t\tcase tokRepeated:\n-\t\t\tt.parseRepeated(w)\n-\t\tdefault:\n-\t\t\tt.parseError(\"internal error: bad directive in parse: %s\", item)\n-\t\t}\n-\t}\n-}\n-\n-// -- Execution\n-\n-// -- Public interface\n-\n-// Parse initializes a Template by parsing its definition.  The string\n-// s contains the template text.  If any errors occur, Parse returns\n-// the error.\n-func (t *Template) Parse(s string) (err error) {\n-\tif t.elems == nil {\n-\t\treturn &Error{1, \"template not allocated with New\"}\n-\t}\n-\tif !validDelim(t.ldelim) || !validDelim(t.rdelim) {\n-\t\treturn &Error{1, fmt.Sprintf(\"bad delimiter strings %q %q\", t.ldelim, t.rdelim)}\n-\t}\n-\tdefer checkError(&err)\n-\tt.buf = []byte(s)\n-\tt.p = 0\n-\tt.linenum = 1\n-\tt.parse()\n-\treturn nil\n-}\n-\n-// ParseFile is like Parse but reads the template definition from the\n-// named file.\n-func (t *Template) ParseFile(filename string) (err error) {\n-\tb, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn t.Parse(string(b))\n-}\n-\n-// Execute applies a parsed template to the specified data object,\n-// generating output to wr.\n-func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n-\t// Extract the driver data.\n-\tval := reflect.ValueOf(data)\n-\tdefer checkError(&err)\n-\tt.p = 0\n-\tt.execute(0, len(t.elems), &state{parent: nil, data: val, wr: wr})\n-\treturn nil\n-}\n-\n-// SetDelims sets the left and right delimiters for operations in the\n-// template.  They are validated during parsing.  They could be\n-// validated here but it's better to keep the routine simple.  The\n-// delimiters are very rarely invalid and Parse has the necessary\n-// error-handling interface already.\n-func (t *Template) SetDelims(left, right string) {\n-\tt.ldelim = []byte(left)\n-\tt.rdelim = []byte(right)\n-}\n-\n-// Parse creates a Template with default parameters (such as {} for\n-// metacharacters).  The string s contains the template text while\n-// the formatter map fmap, which may be nil, defines auxiliary functions\n-// for formatting variables.  The template is returned. If any errors\n-// occur, err will be non-nil.\n-func Parse(s string, fmap FormatterMap) (t *Template, err error) {\n-\tt = New(fmap)\n-\terr = t.Parse(s)\n-\tif err != nil {\n-\t\tt = nil\n-\t}\n-\treturn\n-}\n-\n-// ParseFile is a wrapper function that creates a Template with default\n-// parameters (such as {} for metacharacters).  The filename identifies\n-// a file containing the template text, while the formatter map fmap, which\n-// may be nil, defines auxiliary functions for formatting variables.\n-// The template is returned. If any errors occur, err will be non-nil.\n-func ParseFile(filename string, fmap FormatterMap) (t *Template, err error) {\n-\tb, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn Parse(string(b), fmap)\n-}\n-\n-// MustParse is like Parse but panics if the template cannot be parsed.\n-func MustParse(s string, fmap FormatterMap) *Template {\n-\tt, err := Parse(s, fmap)\n-\tif err != nil {\n-\t\tpanic(\"template.MustParse error: \" + err.Error())\n-\t}\n-\treturn t\n-}\n-\n-// MustParseFile is like ParseFile but panics if the file cannot be read\n-// or the template cannot be parsed.\n-func MustParseFile(filename string, fmap FormatterMap) *Template {\n-\tb, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\tpanic(\"template.MustParseFile error: \" + err.Error())\n-\t}\n-\treturn MustParse(string(b), fmap)\n-}"}, {"sha": "854a548e5aafd7dc43ee752fb2be3b80116d1127", "filename": "libgo/go/old/template/template_test.go", "status": "removed", "additions": 0, "deletions": 810, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c204ff8673a9c7efd2e6492b3765b60229f6d/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go?ref=151c204ff8673a9c7efd2e6492b3765b60229f6d", "patch": "@@ -1,810 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package template\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-type Test struct {\n-\tin, out, err string\n-}\n-\n-type T struct {\n-\tItem  string\n-\tValue string\n-}\n-\n-type U struct {\n-\tMp map[string]int\n-}\n-\n-type S struct {\n-\tHeader        string\n-\tHeaderPtr     *string\n-\tInteger       int\n-\tIntegerPtr    *int\n-\tNilPtr        *int\n-\tInnerT        T\n-\tInnerPointerT *T\n-\tData          []T\n-\tPdata         []*T\n-\tEmpty         []*T\n-\tEmptystring   string\n-\tNull          []*T\n-\tVec           []interface{}\n-\tTrue          bool\n-\tFalse         bool\n-\tMp            map[string]string\n-\tJSON          interface{}\n-\tInnermap      U\n-\tStringmap     map[string]string\n-\tPtrmap        map[string]*string\n-\tIface         interface{}\n-\tIfaceptr      interface{}\n-}\n-\n-func (s *S) PointerMethod() string { return \"ptrmethod!\" }\n-\n-func (s S) ValueMethod() string { return \"valmethod!\" }\n-\n-var t1 = T{\"ItemNumber1\", \"ValueNumber1\"}\n-var t2 = T{\"ItemNumber2\", \"ValueNumber2\"}\n-\n-func uppercase(v interface{}) string {\n-\ts := v.(string)\n-\tt := \"\"\n-\tfor i := 0; i < len(s); i++ {\n-\t\tc := s[i]\n-\t\tif 'a' <= c && c <= 'z' {\n-\t\t\tc = c + 'A' - 'a'\n-\t\t}\n-\t\tt += string(c)\n-\t}\n-\treturn t\n-}\n-\n-func plus1(v interface{}) string {\n-\ti := v.(int)\n-\treturn fmt.Sprint(i + 1)\n-}\n-\n-func writer(f func(interface{}) string) func(io.Writer, string, ...interface{}) {\n-\treturn func(w io.Writer, format string, v ...interface{}) {\n-\t\tif len(v) != 1 {\n-\t\t\tpanic(\"test writer expected one arg\")\n-\t\t}\n-\t\tio.WriteString(w, f(v[0]))\n-\t}\n-}\n-\n-func multiword(w io.Writer, format string, value ...interface{}) {\n-\tfor _, v := range value {\n-\t\tfmt.Fprintf(w, \"<%v>\", v)\n-\t}\n-}\n-\n-func printf(w io.Writer, format string, v ...interface{}) {\n-\tio.WriteString(w, fmt.Sprintf(v[0].(string), v[1:]...))\n-}\n-\n-var formatters = FormatterMap{\n-\t\"uppercase\": writer(uppercase),\n-\t\"+1\":        writer(plus1),\n-\t\"multiword\": multiword,\n-\t\"printf\":    printf,\n-}\n-\n-var tests = []*Test{\n-\t// Simple\n-\t{\"\", \"\", \"\"},\n-\t{\"abc\", \"abc\", \"\"},\n-\t{\"abc\\ndef\\n\", \"abc\\ndef\\n\", \"\"},\n-\t{\" {.meta-left}   \\n\", \"{\", \"\"},\n-\t{\" {.meta-right}   \\n\", \"}\", \"\"},\n-\t{\" {.space}   \\n\", \" \", \"\"},\n-\t{\" {.tab}   \\n\", \"\\t\", \"\"},\n-\t{\"     {#comment}   \\n\", \"\", \"\"},\n-\t{\"\\tSome Text\\t\\n\", \"\\tSome Text\\t\\n\", \"\"},\n-\t{\" {.meta-right} {.meta-right} {.meta-right} \\n\", \" } } } \\n\", \"\"},\n-\n-\t// Variables at top level\n-\t{\n-\t\tin: \"{Header}={Integer}\\n\",\n-\n-\t\tout: \"Header=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"Pointers: {*HeaderPtr}={*IntegerPtr}\\n\",\n-\n-\t\tout: \"Pointers: Header=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"Stars but not pointers: {*Header}={*Integer}\\n\",\n-\n-\t\tout: \"Stars but not pointers: Header=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"nil pointer: {*NilPtr}={*Integer}\\n\",\n-\n-\t\tout: \"nil pointer: <nil>=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: `{\"Strings\" \":\"} {\"\"} {\"|\"} {\"\\t\\u0123 \\x23\\\\\"} {\"\\\"}{\\\\\"}`,\n-\n-\t\tout: \"Strings:  | \\t\\u0123 \\x23\\\\ \\\"}{\\\\\",\n-\t},\n-\n-\t{\n-\t\tin: \"{`Raw strings` `:`} {``} {`|`} {`\\\\t\\\\u0123 \\\\x23\\\\`} {`}{\\\\`}\",\n-\n-\t\tout: \"Raw strings:  | \\\\t\\\\u0123 \\\\x23\\\\ }{\\\\\",\n-\t},\n-\n-\t{\n-\t\tin: \"Characters: {'a'} {'\\\\u0123'} {' '} {'{'} {'|'} {'}'}\",\n-\n-\t\tout: \"Characters: 97 291 32 123 124 125\",\n-\t},\n-\n-\t{\n-\t\tin: \"Integers: {1} {-2} {+42} {0777} {0x0a}\",\n-\n-\t\tout: \"Integers: 1 -2 42 511 10\",\n-\t},\n-\n-\t{\n-\t\tin: \"Floats: {.5} {-.5} {1.1} {-2.2} {+42.1} {1e10} {1.2e-3} {1.2e3} {-1.2e3}\",\n-\n-\t\tout: \"Floats: 0.5 -0.5 1.1 -2.2 42.1 1e+10 0.0012 1200 -1200\",\n-\t},\n-\n-\t// Method at top level\n-\t{\n-\t\tin: \"ptrmethod={PointerMethod}\\n\",\n-\n-\t\tout: \"ptrmethod=ptrmethod!\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"valmethod={ValueMethod}\\n\",\n-\n-\t\tout: \"valmethod=valmethod!\\n\",\n-\t},\n-\n-\t// Section\n-\t{\n-\t\tin: \"{.section Data }\\n\" +\n-\t\t\t\"some text for the section\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"some text for the section\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Data }\\n\" +\n-\t\t\t\"{Header}={Integer}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"Header=77\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"{Header}={Integer}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"Header=77\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"data present\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"data not present\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"data present\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Empty }\\n\" +\n-\t\t\t\"data present\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"data not present\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"data not present\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Null }\\n\" +\n-\t\t\t\"data present\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"data not present\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"data not present\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"{Header}={Integer}\\n\" +\n-\t\t\t\"{.section @ }\\n\" +\n-\t\t\t\"{Header}={Integer}\\n\" +\n-\t\t\t\"{.end}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"Header=77\\n\" +\n-\t\t\t\"Header=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"{.section Data}{.end} {Header}\\n\",\n-\n-\t\tout: \" Header\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"{.section Integer}{@}{.end}\",\n-\n-\t\tout: \"77\",\n-\t},\n-\n-\t// Repeated\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"{.repeated section @ }\\n\" +\n-\t\t\t\"{Item}={Value}\\n\" +\n-\t\t\t\"{.end}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"ItemNumber1=ValueNumber1\\n\" +\n-\t\t\t\"ItemNumber2=ValueNumber2\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"{.repeated section @ }\\n\" +\n-\t\t\t\"{Item}={Value}\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"this should not appear\\n\" +\n-\t\t\t\"{.end}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"ItemNumber1=ValueNumber1\\n\" +\n-\t\t\t\"ItemNumber2=ValueNumber2\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section @ }\\n\" +\n-\t\t\t\"{.repeated section Empty }\\n\" +\n-\t\t\t\"{Item}={Value}\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"this should appear: empty field\\n\" +\n-\t\t\t\"{.end}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"this should appear: empty field\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Pdata }\\n\" +\n-\t\t\t\"{Item}\\n\" +\n-\t\t\t\"{.alternates with}\\n\" +\n-\t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"ItemNumber1\\n\" +\n-\t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n-\t\t\t\"ItemNumber2\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Pdata }\\n\" +\n-\t\t\t\"{Item}\\n\" +\n-\t\t\t\"{.alternates with}\\n\" +\n-\t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n-\t\t\t\" {.end}\\n\",\n-\n-\t\tout: \"ItemNumber1\\n\" +\n-\t\t\t\"is\\nover\\nmultiple\\nlines\\n\" +\n-\t\t\t\"ItemNumber2\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Pdata }\\n\" +\n-\t\t\t\"{.repeated section @ }\\n\" +\n-\t\t\t\"{Item}={Value}\\n\" +\n-\t\t\t\"{.alternates with}DIVIDER\\n\" +\n-\t\t\t\"{.or}\\n\" +\n-\t\t\t\"this should not appear\\n\" +\n-\t\t\t\"{.end}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"ItemNumber1=ValueNumber1\\n\" +\n-\t\t\t\"DIVIDER\\n\" +\n-\t\t\t\"ItemNumber2=ValueNumber2\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Vec }\\n\" +\n-\t\t\t\"{@}\\n\" +\n-\t\t\t\"{.end}\\n\",\n-\n-\t\tout: \"elt1\\n\" +\n-\t\t\t\"elt2\\n\",\n-\t},\n-\t// Same but with a space before {.end}: was a bug.\n-\t{\n-\t\tin: \"{.repeated section Vec }\\n\" +\n-\t\t\t\"{@} {.end}\\n\",\n-\n-\t\tout: \"elt1 elt2 \\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Integer}{.end}\",\n-\n-\t\terr: \"line 1: .repeated: cannot repeat Integer (type int)\",\n-\t},\n-\n-\t// Nested names\n-\t{\n-\t\tin: \"{.section @ }\\n\" +\n-\t\t\t\"{InnerT.Item}={InnerT.Value}\\n\" +\n-\t\t\t\"{.end}\",\n-\n-\t\tout: \"ItemNumber1=ValueNumber1\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section @ }\\n\" +\n-\t\t\t\"{InnerT.Item}={.section InnerT}{.section Value}{@}{.end}{.end}\\n\" +\n-\t\t\t\"{.end}\",\n-\n-\t\tout: \"ItemNumber1=ValueNumber1\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"{.section Emptystring}emptystring{.end}\\n\" +\n-\t\t\t\"{.section Header}header{.end}\\n\",\n-\n-\t\tout: \"\\nheader\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"{.section True}1{.or}2{.end}\\n\" +\n-\t\t\t\"{.section False}3{.or}4{.end}\\n\",\n-\n-\t\tout: \"1\\n4\\n\",\n-\t},\n-\n-\t// Maps\n-\n-\t{\n-\t\tin: \"{Mp.mapkey}\\n\",\n-\n-\t\tout: \"Ahoy!\\n\",\n-\t},\n-\t{\n-\t\tin: \"{Innermap.Mp.innerkey}\\n\",\n-\n-\t\tout: \"55\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section Innermap}{.section Mp}{innerkey}{.end}{.end}\\n\",\n-\n-\t\tout: \"55\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.section JSON}{.repeated section maps}{a}{b}{.end}{.end}\\n\",\n-\n-\t\tout: \"1234\\n\",\n-\t},\n-\t{\n-\t\tin: \"{Stringmap.stringkey1}\\n\",\n-\n-\t\tout: \"stringresult\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Stringmap}\\n\" +\n-\t\t\t\"{@}\\n\" +\n-\t\t\t\"{.end}\",\n-\n-\t\tout: \"stringresult\\n\" +\n-\t\t\t\"stringresult\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Stringmap}\\n\" +\n-\t\t\t\"\\t{@}\\n\" +\n-\t\t\t\"{.end}\",\n-\n-\t\tout: \"\\tstringresult\\n\" +\n-\t\t\t\"\\tstringresult\\n\",\n-\t},\n-\t{\n-\t\tin: \"{*Ptrmap.stringkey1}\\n\",\n-\n-\t\tout: \"pointedToString\\n\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Ptrmap}\\n\" +\n-\t\t\t\"{*@}\\n\" +\n-\t\t\t\"{.end}\",\n-\n-\t\tout: \"pointedToString\\n\" +\n-\t\t\t\"pointedToString\\n\",\n-\t},\n-\n-\t// Interface values\n-\n-\t{\n-\t\tin: \"{Iface}\",\n-\n-\t\tout: \"[1 2 3]\",\n-\t},\n-\t{\n-\t\tin: \"{.repeated section Iface}{@}{.alternates with} {.end}\",\n-\n-\t\tout: \"1 2 3\",\n-\t},\n-\t{\n-\t\tin: \"{.section Iface}{@}{.end}\",\n-\n-\t\tout: \"[1 2 3]\",\n-\t},\n-\t{\n-\t\tin: \"{.section Ifaceptr}{Item} {Value}{.end}\",\n-\n-\t\tout: \"Item Value\",\n-\t},\n-}\n-\n-func TestAll(t *testing.T) {\n-\t// Parse\n-\ttestAll(t, func(test *Test) (*Template, error) { return Parse(test.in, formatters) })\n-\t// ParseFile\n-\tf, err := ioutil.TempFile(\"\", \"template-test\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer func() {\n-\t\tname := f.Name()\n-\t\tf.Close()\n-\t\tos.Remove(name)\n-\t}()\n-\ttestAll(t, func(test *Test) (*Template, error) {\n-\t\terr := ioutil.WriteFile(f.Name(), []byte(test.in), 0600)\n-\t\tif err != nil {\n-\t\t\tt.Error(\"unexpected write error:\", err)\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn ParseFile(f.Name(), formatters)\n-\t})\n-\t// tmpl.ParseFile\n-\ttestAll(t, func(test *Test) (*Template, error) {\n-\t\terr := ioutil.WriteFile(f.Name(), []byte(test.in), 0600)\n-\t\tif err != nil {\n-\t\t\tt.Error(\"unexpected write error:\", err)\n-\t\t\treturn nil, err\n-\t\t}\n-\t\ttmpl := New(formatters)\n-\t\treturn tmpl, tmpl.ParseFile(f.Name())\n-\t})\n-}\n-\n-func testAll(t *testing.T, parseFunc func(*Test) (*Template, error)) {\n-\ts := new(S)\n-\t// initialized by hand for clarity.\n-\ts.Header = \"Header\"\n-\ts.HeaderPtr = &s.Header\n-\ts.Integer = 77\n-\ts.IntegerPtr = &s.Integer\n-\ts.InnerT = t1\n-\ts.Data = []T{t1, t2}\n-\ts.Pdata = []*T{&t1, &t2}\n-\ts.Empty = []*T{}\n-\ts.Null = nil\n-\ts.Vec = []interface{}{\"elt1\", \"elt2\"}\n-\ts.True = true\n-\ts.False = false\n-\ts.Mp = make(map[string]string)\n-\ts.Mp[\"mapkey\"] = \"Ahoy!\"\n-\tjson.Unmarshal([]byte(`{\"maps\":[{\"a\":1,\"b\":2},{\"a\":3,\"b\":4}]}`), &s.JSON)\n-\ts.Innermap.Mp = make(map[string]int)\n-\ts.Innermap.Mp[\"innerkey\"] = 55\n-\ts.Stringmap = make(map[string]string)\n-\ts.Stringmap[\"stringkey1\"] = \"stringresult\" // the same value so repeated section is order-independent\n-\ts.Stringmap[\"stringkey2\"] = \"stringresult\"\n-\ts.Ptrmap = make(map[string]*string)\n-\tx := \"pointedToString\"\n-\ts.Ptrmap[\"stringkey1\"] = &x // the same value so repeated section is order-independent\n-\ts.Ptrmap[\"stringkey2\"] = &x\n-\ts.Iface = []int{1, 2, 3}\n-\ts.Ifaceptr = &T{\"Item\", \"Value\"}\n-\n-\tvar buf bytes.Buffer\n-\tfor _, test := range tests {\n-\t\tbuf.Reset()\n-\t\ttmpl, err := parseFunc(test)\n-\t\tif err != nil {\n-\t\t\tt.Error(\"unexpected parse error: \", err)\n-\t\t\tcontinue\n-\t\t}\n-\t\terr = tmpl.Execute(&buf, s)\n-\t\tif test.err == \"\" {\n-\t\t\tif err != nil {\n-\t\t\t\tt.Error(\"unexpected execute error:\", err)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"expected execute error %q, got nil\", test.err)\n-\t\t\t} else if err.Error() != test.err {\n-\t\t\t\tt.Errorf(\"expected execute error %q, got %q\", test.err, err.Error())\n-\t\t\t}\n-\t\t}\n-\t\tif buf.String() != test.out {\n-\t\t\tt.Errorf(\"for %q: expected %q got %q\", test.in, test.out, buf.String())\n-\t\t}\n-\t}\n-}\n-\n-func TestMapDriverType(t *testing.T) {\n-\tmp := map[string]string{\"footer\": \"Ahoy!\"}\n-\ttmpl, err := Parse(\"template: {footer}\", nil)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\tvar b bytes.Buffer\n-\terr = tmpl.Execute(&b, mp)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected execute error:\", err)\n-\t}\n-\ts := b.String()\n-\texpect := \"template: Ahoy!\"\n-\tif s != expect {\n-\t\tt.Errorf(\"failed passing string as data: expected %q got %q\", expect, s)\n-\t}\n-}\n-\n-func TestMapNoEntry(t *testing.T) {\n-\tmp := make(map[string]int)\n-\ttmpl, err := Parse(\"template: {notthere}!\", nil)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\tvar b bytes.Buffer\n-\terr = tmpl.Execute(&b, mp)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected execute error:\", err)\n-\t}\n-\ts := b.String()\n-\texpect := \"template: 0!\"\n-\tif s != expect {\n-\t\tt.Errorf(\"failed passing string as data: expected %q got %q\", expect, s)\n-\t}\n-}\n-\n-func TestStringDriverType(t *testing.T) {\n-\ttmpl, err := Parse(\"template: {@}\", nil)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\tvar b bytes.Buffer\n-\terr = tmpl.Execute(&b, \"hello\")\n-\tif err != nil {\n-\t\tt.Error(\"unexpected execute error:\", err)\n-\t}\n-\ts := b.String()\n-\texpect := \"template: hello\"\n-\tif s != expect {\n-\t\tt.Errorf(\"failed passing string as data: expected %q got %q\", expect, s)\n-\t}\n-}\n-\n-func TestTwice(t *testing.T) {\n-\ttmpl, err := Parse(\"template: {@}\", nil)\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\tvar b bytes.Buffer\n-\terr = tmpl.Execute(&b, \"hello\")\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\ts := b.String()\n-\texpect := \"template: hello\"\n-\tif s != expect {\n-\t\tt.Errorf(\"failed passing string as data: expected %q got %q\", expect, s)\n-\t}\n-\terr = tmpl.Execute(&b, \"hello\")\n-\tif err != nil {\n-\t\tt.Error(\"unexpected parse error:\", err)\n-\t}\n-\ts = b.String()\n-\texpect += expect\n-\tif s != expect {\n-\t\tt.Errorf(\"failed passing string as data: expected %q got %q\", expect, s)\n-\t}\n-}\n-\n-func TestCustomDelims(t *testing.T) {\n-\t// try various lengths.  zero should catch error.\n-\tfor i := 0; i < 7; i++ {\n-\t\tfor j := 0; j < 7; j++ {\n-\t\t\ttmpl := New(nil)\n-\t\t\t// first two chars deliberately the same to test equal left and right delims\n-\t\t\tldelim := \"$!#$%^&\"[0:i]\n-\t\t\trdelim := \"$*&^%$!\"[0:j]\n-\t\t\ttmpl.SetDelims(ldelim, rdelim)\n-\t\t\t// if braces, this would be template: {@}{.meta-left}{.meta-right}\n-\t\t\ttext := \"template: \" +\n-\t\t\t\tldelim + \"@\" + rdelim +\n-\t\t\t\tldelim + \".meta-left\" + rdelim +\n-\t\t\t\tldelim + \".meta-right\" + rdelim\n-\t\t\terr := tmpl.Parse(text)\n-\t\t\tif err != nil {\n-\t\t\t\tif i == 0 || j == 0 { // expected\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tt.Error(\"unexpected parse error:\", err)\n-\t\t\t} else if i == 0 || j == 0 {\n-\t\t\t\tt.Errorf(\"expected parse error for empty delimiter: %d %d %q %q\", i, j, ldelim, rdelim)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tvar b bytes.Buffer\n-\t\t\terr = tmpl.Execute(&b, \"hello\")\n-\t\t\ts := b.String()\n-\t\t\tif s != \"template: hello\"+ldelim+rdelim {\n-\t\t\t\tt.Errorf(\"failed delim check(%q %q) %q got %q\", ldelim, rdelim, text, s)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Test that a variable evaluates to the field itself and does not further indirection\n-func TestVarIndirection(t *testing.T) {\n-\ts := new(S)\n-\t// initialized by hand for clarity.\n-\ts.InnerPointerT = &t1\n-\n-\tvar buf bytes.Buffer\n-\tinput := \"{.section @}{InnerPointerT}{.end}\"\n-\ttmpl, err := Parse(input, nil)\n-\tif err != nil {\n-\t\tt.Fatal(\"unexpected parse error:\", err)\n-\t}\n-\terr = tmpl.Execute(&buf, s)\n-\tif err != nil {\n-\t\tt.Fatal(\"unexpected execute error:\", err)\n-\t}\n-\texpect := fmt.Sprintf(\"%v\", &t1) // output should be hex address of t1\n-\tif buf.String() != expect {\n-\t\tt.Errorf(\"for %q: expected %q got %q\", input, expect, buf.String())\n-\t}\n-}\n-\n-func TestHTMLFormatterWithByte(t *testing.T) {\n-\ts := \"Test string.\"\n-\tb := []byte(s)\n-\tvar buf bytes.Buffer\n-\tHTMLFormatter(&buf, \"\", b)\n-\tbs := buf.String()\n-\tif bs != s {\n-\t\tt.Errorf(\"munged []byte, expected: %s got: %s\", s, bs)\n-\t}\n-}\n-\n-type UF struct {\n-\tI int\n-\ts string\n-}\n-\n-func TestReferenceToUnexported(t *testing.T) {\n-\tu := &UF{3, \"hello\"}\n-\tvar buf bytes.Buffer\n-\tinput := \"{.section @}{I}{s}{.end}\"\n-\ttmpl, err := Parse(input, nil)\n-\tif err != nil {\n-\t\tt.Fatal(\"unexpected parse error:\", err)\n-\t}\n-\terr = tmpl.Execute(&buf, u)\n-\tif err == nil {\n-\t\tt.Fatal(\"expected execute error, got none\")\n-\t}\n-\tif strings.Index(err.Error(), \"not exported\") < 0 {\n-\t\tt.Fatal(\"expected unexported error; got\", err)\n-\t}\n-}\n-\n-var formatterTests = []Test{\n-\t{\n-\t\tin: \"{Header|uppercase}={Integer|+1}\\n\" +\n-\t\t\t\"{Header|html}={Integer|str}\\n\",\n-\n-\t\tout: \"HEADER=78\\n\" +\n-\t\t\t\"Header=77\\n\",\n-\t},\n-\n-\t{\n-\t\tin: \"{Header|uppercase}={Integer Header|multiword}\\n\" +\n-\t\t\t\"{Header|html}={Header Integer|multiword}\\n\" +\n-\t\t\t\"{Header|html}={Header Integer}\\n\",\n-\n-\t\tout: \"HEADER=<77><Header>\\n\" +\n-\t\t\t\"Header=<Header><77>\\n\" +\n-\t\t\t\"Header=Header77\\n\",\n-\t},\n-\t{\n-\t\tin: \"{Raw}\\n\" +\n-\t\t\t\"{Raw|html}\\n\",\n-\n-\t\tout: \"a <&> b\\n\" +\n-\t\t\t\"a &lt;&amp;&gt; b\\n\",\n-\t},\n-\t{\n-\t\tin:  \"{Bytes}\",\n-\t\tout: \"hello\",\n-\t},\n-\t{\n-\t\tin:  \"{Raw|uppercase|html|html}\",\n-\t\tout: \"A &amp;lt;&amp;amp;&amp;gt; B\",\n-\t},\n-\t{\n-\t\tin:  \"{Header Integer|multiword|html}\",\n-\t\tout: \"&lt;Header&gt;&lt;77&gt;\",\n-\t},\n-\t{\n-\t\tin:  \"{Integer|no_formatter|html}\",\n-\t\terr: `unknown formatter: \"no_formatter\"`,\n-\t},\n-\t{\n-\t\tin:  \"{Integer|||||}\", // empty string is a valid formatter\n-\t\tout: \"77\",\n-\t},\n-\t{\n-\t\tin:  `{\"%.02f 0x%02X\" 1.1 10|printf}`,\n-\t\tout: \"1.10 0x0A\",\n-\t},\n-\t{\n-\t\tin:  `{\"\"|}{\"\"||}{\"\"|printf}`, // Issue #1896.\n-\t\tout: \"\",\n-\t},\n-}\n-\n-func TestFormatters(t *testing.T) {\n-\tdata := map[string]interface{}{\n-\t\t\"Header\":  \"Header\",\n-\t\t\"Integer\": 77,\n-\t\t\"Raw\":     \"a <&> b\",\n-\t\t\"Bytes\":   []byte(\"hello\"),\n-\t}\n-\tfor _, c := range formatterTests {\n-\t\ttmpl, err := Parse(c.in, formatters)\n-\t\tif err != nil {\n-\t\t\tif c.err == \"\" {\n-\t\t\t\tt.Error(\"unexpected parse error:\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif strings.Index(err.Error(), c.err) < 0 {\n-\t\t\t\tt.Errorf(\"unexpected error: expected %q, got %q\", c.err, err.Error())\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif c.err != \"\" {\n-\t\t\t\tt.Errorf(\"For %q, expected error, got none.\", c.in)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tvar buf bytes.Buffer\n-\t\t\terr = tmpl.Execute(&buf, data)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Error(\"unexpected Execute error: \", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tactual := buf.String()\n-\t\t\tif actual != c.out {\n-\t\t\t\tt.Errorf(\"for %q: expected %q but got %q.\", c.in, c.out, actual)\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}]}