{"sha": "f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiY2Y0NGM1ZTZkOTFmM2RiNTZmYzYwYjk0ZjkxNTdhZTBlZGU5Mg==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-02-04T22:41:59Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-02-04T22:41:59Z"}, "message": "pa.c (DO_FRAME_NOTES): Move forward.\n\n\t* pa.c (DO_FRAME_NOTES): Move forward.\n\t(store_reg): Revise handling of frame notes.\n\t(load_reg): Likewise.\n\t(set_reg_plus_d): Likewise.\n\t(hppa_expand_prologue): Likewise.\n\t(hppa_expand_epilogue): Likewise.\n\nFrom-SVN: r49499", "tree": {"sha": "db5a8882954f2878e42750d55ef0cf5f4495fb05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5a8882954f2878e42750d55ef0cf5f4495fb05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92/comments", "author": null, "committer": null, "parents": [{"sha": "703b0080a480f7a675c37b5de5418ab34a82905d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703b0080a480f7a675c37b5de5418ab34a82905d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703b0080a480f7a675c37b5de5418ab34a82905d"}], "stats": {"total": 191, "additions": 119, "deletions": 72}, "files": [{"sha": "85d8be727476dbab6500762ec0d78f07f6f4cab9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "patch": "@@ -1,3 +1,12 @@\n+2002-02-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa.c (DO_FRAME_NOTES): Move forward.\n+\t(store_reg): Revise handling of frame notes.\n+\t(load_reg): Likewise.\n+\t(set_reg_plus_d): Likewise.\n+\t(hppa_expand_prologue): Likewise.\n+\t(hppa_expand_epilogue): Likewise.\n+\t\n 2002-02-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* unwind-dw2-fde-glibc.c: Define _GNU_SOURCE if not defined."}, {"sha": "423ee62c9cdd7655f00d9cc36cfe6dd788fa6cbb", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 110, "deletions": 72, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f6bcf44c5e6d91f3db56fc60b94f9157ae0ede92", "patch": "@@ -55,6 +55,18 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n+#if DO_FRAME_NOTES\n+#define FRP(INSN) \\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      rtx insn = INSN;\t\t\t\\\n+      RTX_FRAME_RELATED_P (insn) = 1;\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n+#else\n+#define FRP(INSN) INSN\n+#endif\n+\n #ifndef FUNC_BEGIN_PROLOG_LABEL\n #define FUNC_BEGIN_PROLOG_LABEL        \"LFBP\"\n #endif\n@@ -70,9 +82,9 @@ static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *)\n static int compute_movstrsi_length PARAMS ((rtx));\n static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void remove_useless_addtr_insns PARAMS ((rtx, int));\n-static rtx store_reg PARAMS ((int, int, int));\n-static rtx load_reg PARAMS ((int, int, int));\n-static rtx set_reg_plus_d PARAMS ((int, int, int));\n+static void store_reg PARAMS ((int, int, int));\n+static void load_reg PARAMS ((int, int, int));\n+static void set_reg_plus_d PARAMS ((int, int, int));\n static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int pa_adjust_priority PARAMS ((rtx, int));\n@@ -2879,18 +2891,18 @@ static int local_fsize, save_fregs;\n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n-static rtx\n+static void\n store_reg (reg, disp, base)\n      int reg, disp, base;\n {\n-  rtx i, dest, src, basereg;\n+  rtx insn, dest, src, basereg;\n \n   src = gen_rtx_REG (word_mode, reg);\n   basereg = gen_rtx_REG (Pmode, base);\n   if (VAL_14_BITS_P (disp))\n     {\n       dest = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n-      i = emit_move_insn (dest, src);\n+      insn = emit_move_insn (dest, src);\n     }\n   else\n     {\n@@ -2899,9 +2911,22 @@ store_reg (reg, disp, base)\n       rtx tmpreg = gen_rtx_REG (Pmode, 1);\n       emit_move_insn (tmpreg, high);\n       dest = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n-      i = emit_move_insn (dest, src);\n+      insn = emit_move_insn (dest, src);\n+      if (DO_FRAME_NOTES)\n+\t{\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_MEM (word_mode,\n+\t\t\t\t\t  gen_rtx_PLUS (word_mode, basereg,\n+\t\t\t\t\t\t\tdelta)),\n+                             src),\n+                REG_NOTES (insn));\n+\t}\n     }\n-  return i;\n+\n+  if (DO_FRAME_NOTES)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n /* Emit RTL to set REG to the value specified by BASE+DISP.\n@@ -2910,28 +2935,32 @@ store_reg (reg, disp, base)\n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n-static rtx\n+static void\n set_reg_plus_d (reg, base, disp)\n      int reg, base, disp;\n {\n-  rtx i;\n+  rtx insn;\n \n   if (VAL_14_BITS_P (disp))\n     {\n-      i = emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t\t  plus_constant (gen_rtx_REG (Pmode, base), disp));\n+      insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t\t     plus_constant (gen_rtx_REG (Pmode, base), disp));\n     }\n   else\n     {\n+      rtx basereg = gen_rtx_REG (Pmode, base);\n       rtx delta = GEN_INT (disp);\n+\n       emit_move_insn (gen_rtx_REG (Pmode, 1),\n-\t\t      gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, base),\n+\t\t      gen_rtx_PLUS (Pmode, basereg,\n \t\t\t\t    gen_rtx_HIGH (Pmode, delta)));\n-      i = emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t\t  gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, 1),\n-\t\t\t\t\t  delta));\n+      insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t\t     gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, 1),\n+\t\t\t\t\t     delta));\n     }\n-  return i;\n+\n+  if (DO_FRAME_NOTES && reg == STACK_POINTER_REGNUM)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n int\n@@ -3069,18 +3098,6 @@ pa_output_function_prologue (file, size)\n   remove_useless_addtr_insns (get_insns (), 0);\n }\n \n-#if DO_FRAME_NOTES\n-#define FRP(INSN) \\\n-  do\t\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-      rtx insn = INSN;\t\t\t\\\n-      RTX_FRAME_RELATED_P (insn) = 1;\t\\\n-    }\t\t\t\t\t\\\n-  while (0)\n-#else\n-#define FRP(INSN) INSN\n-#endif\n-\n void\n hppa_expand_prologue ()\n {\n@@ -3111,7 +3128,7 @@ hppa_expand_prologue ()\n      always be stored into the caller's frame at sp - 20 or sp - 16\n      depending on which ABI is in use.  */\n   if (regs_ever_live[2])\n-    FRP (store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM));\n+    store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n   if (actual_fsize != 0)\n@@ -3183,9 +3200,8 @@ hppa_expand_prologue ()\n \t\t\t\t\t REG_NOTES (insn));\n \t\t}\n \n-\t      FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t\t   STACK_POINTER_REGNUM,\n-\t\t\t\t   adjust2));\n+\t      set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n+\t\t\t      adjust2);\n \t    }\n \t  /* Prevent register spills from being scheduled before the\n \t     stack pointer is raised.  Necessary as we will be storing\n@@ -3205,9 +3221,8 @@ hppa_expand_prologue ()\n \t  /* Can not optimize.  Adjust the stack frame by actual_fsize\n \t     bytes.  */\n \t  else\n-\t    FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t\t STACK_POINTER_REGNUM,\n-\t\t\t\t actual_fsize));\n+\t    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n+\t\t\t    actual_fsize);\n \t}\n     }\n \n@@ -3220,7 +3235,7 @@ hppa_expand_prologue ()\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    FRP (store_reg (i, offset, FRAME_POINTER_REGNUM));\n+\t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n \t    gr_saved++;\n \t  }\n@@ -3244,17 +3259,16 @@ hppa_expand_prologue ()\n \t\t\t\t\t\tdelta)));\n \t      }\n \t    else\n-\t      FRP (store_reg (i, offset, STACK_POINTER_REGNUM));\n+\t      store_reg (i, offset, STACK_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n \t    gr_saved++;\n \t  }\n \n       /* If we wanted to merge the SP adjustment with a GR save, but we never\n \t did any GR saves, then just emit the adjustment here.  */\n       if (merge_sp_adjust_with_store)\n-\tFRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t     STACK_POINTER_REGNUM,\n-\t\t\t     actual_fsize));\n+\tset_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n+\t\t\tactual_fsize);\n     }\n \n   /* The hppa calling conventions say that %r19, the pic offset\n@@ -3275,47 +3289,54 @@ hppa_expand_prologue ()\n       /* First get the frame or stack pointer to the start of the FP register\n \t save area.  */\n       if (frame_pointer_needed)\n-\tFRP (set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset));\n+\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n       else\n-\tFRP (set_reg_plus_d (1, STACK_POINTER_REGNUM, offset));\n+\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Now actually save the FP registers.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n \t  if (regs_ever_live[i]\n \t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n \t    {\n-\t      rtx addr, reg;\n+\t      rtx addr, insn, reg;\n \t      addr = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n \t      reg = gen_rtx_REG (DFmode, i);\n-\t      FRP (emit_move_insn (addr, reg));\n+\t      insn = emit_move_insn (addr, reg);\n+\t      if (DO_FRAME_NOTES)\n+\t\t{\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t  gen_rtx_MEM (DFmode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)),\n+\t\t\t  reg),\n+\t\t\tREG_NOTES (insn));\n+\t\t}\n+\t      offset += GET_MODE_SIZE (DFmode);\n \t      fr_saved++;\n \t    }\n \t}\n     }\n }\n \n-/* ?!? Do we want frame notes in the epilogue yet?  */\n-#undef DO_FRAME_NOTES\n-#define DO_FRAME_NOTES 0\n-#undef FRP\n-#define FRP(INSN) INSN\n-\n /* Emit RTL to load REG from the memory location specified by BASE+DISP.\n    Handle case where DISP > 8k by using the add_high_const patterns.  */\n \n-static rtx\n+static void\n load_reg (reg, disp, base)\n      int reg, disp, base;\n {\n-  rtx i, src, dest, basereg;\n+  rtx src, dest, basereg;\n \n   dest = gen_rtx_REG (word_mode, reg);\n   basereg = gen_rtx_REG (Pmode, base);\n   if (VAL_14_BITS_P (disp))\n     {\n       src = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n-      i = emit_move_insn (dest, src);\n+      emit_move_insn (dest, src);\n     }\n   else\n     {\n@@ -3324,9 +3345,8 @@ load_reg (reg, disp, base)\n       rtx tmpreg = gen_rtx_REG (Pmode, 1);\n       emit_move_insn (tmpreg, high);\n       src = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n-      i = emit_move_insn (dest, src);\n+      emit_move_insn (dest, src);\n     }\n-  return i;\n }\n \n /* This function generates the assembly code for function exit.\n@@ -3388,15 +3408,15 @@ hppa_expand_epilogue ()\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n \t{\n-\t  FRP (load_reg (2, ret_off, FRAME_POINTER_REGNUM));\n+\t  load_reg (2, ret_off, FRAME_POINTER_REGNUM);\n \t  ret_off = 0;\n \t}\n       else\n \t{\n \t  /* No frame pointer, and stack is smaller than 8k.  */\n \t  if (VAL_14_BITS_P (ret_off - actual_fsize))\n \t    {\n-\t      FRP (load_reg (2, ret_off - actual_fsize, STACK_POINTER_REGNUM));\n+\t      load_reg (2, ret_off - actual_fsize, STACK_POINTER_REGNUM);\n \t      ret_off = 0;\n \t    }\n \t}\n@@ -3408,7 +3428,7 @@ hppa_expand_epilogue ()\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    FRP (load_reg (i, offset, FRAME_POINTER_REGNUM));\n+\t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += UNITS_PER_WORD;\n \t  }\n     }\n@@ -3426,7 +3446,7 @@ hppa_expand_epilogue ()\n \t\t  && VAL_14_BITS_P (-actual_fsize))\n \t        merge_sp_adjust_with_load = i;\n \t      else\n-\t\tFRP (load_reg (i, offset, STACK_POINTER_REGNUM));\n+\t\tload_reg (i, offset, STACK_POINTER_REGNUM);\n \t      offset += UNITS_PER_WORD;\n \t    }\n \t}\n@@ -3440,9 +3460,9 @@ hppa_expand_epilogue ()\n     {\n       /* Adjust the register to index off of.  */\n       if (frame_pointer_needed)\n-\tFRP (set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset));\n+\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n       else\n-\tFRP (set_reg_plus_d (1, STACK_POINTER_REGNUM, offset));\n+\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Actually do the restores now.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n@@ -3451,7 +3471,7 @@ hppa_expand_epilogue ()\n \t  {\n \t    rtx src = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n \t    rtx dest = gen_rtx_REG (DFmode, i);\n-\t    FRP (emit_move_insn (dest, src));\n+\t    emit_move_insn (dest, src);\n \t  }\n     }\n \n@@ -3467,27 +3487,45 @@ hppa_expand_epilogue ()\n   if (frame_pointer_needed)\n     {\n       rtx delta = GEN_INT (-64);\n-      FRP (set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64));\n-      FRP (emit_insn (gen_pre_load (frame_pointer_rtx,\n-\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t    delta)));\n+      rtx insn;\n+      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n+      insn = emit_insn (gen_pre_load (frame_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      delta));\n+      if (DO_FRAME_NOTES)\n+\t{\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t     gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\t   delta)),\n+                REG_NOTES (insn));\n+\t}\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (merge_sp_adjust_with_load)\n     {\n       rtx delta = GEN_INT (-actual_fsize);\n       rtx dest = gen_rtx_REG (word_mode, merge_sp_adjust_with_load);\n-      FRP (emit_insn (gen_pre_load (dest, stack_pointer_rtx, delta)));\n+      rtx insn = emit_insn (gen_pre_load (dest, stack_pointer_rtx, delta));\n+      if (DO_FRAME_NOTES)\n+\t{\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t     gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\t   delta)),\n+                REG_NOTES (insn));\n+\t}\n     }\n   else if (actual_fsize != 0)\n-    FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t STACK_POINTER_REGNUM,\n-\t\t\t - actual_fsize));\n+    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM, - actual_fsize);\n \n   /* If we haven't restored %r2 yet (no frame pointer, and a stack\n      frame greater than 8k), do so now.  */\n   if (ret_off != 0)\n-    FRP (load_reg (2, ret_off, STACK_POINTER_REGNUM));\n+    load_reg (2, ret_off, STACK_POINTER_REGNUM);\n }\n \n rtx"}]}