{"sha": "26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZhZWEwNzM3YjJkMGM0ZWUzMjhkNTQ3NTU1YWUyNWFiNWRlOWEwYQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-19T00:22:51Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-19T00:22:51Z"}, "message": "cppfiles.c (ENABLE_VALGRIND_CHECKING, [...]): Remove.\n\n\t* cppfiles.c (ENABLE_VALGRIND_CHECKING, VALGRIND_DISCARD,\n\tMMAP_THRESHOLD, TEST_THRESHOLD, SHOULD_MMAP): Remove.\n\t(struct include_file): Remove fefcnt, mapped members.\n\t(open_file, stack_include_file, _cpp_pop_file_buffer): Disable caching.\n\t(read_include_file): Don't use mmap, terminate buffers in '\\r'.\n\t(purge_cache): Don't use munmap.\n\t* cpphash.h (CPP_BUF_COLUMN): Update.\n\t(lexer_state): Remove lexing_comment.\n\t(struct _cpp_line_note): New.\n\t(struct cpp_buffer): New members cur_note, notes_used, notes_cap,\n\tnext_line and need_line.  Remove col_adjust and saved_flags.\n\t(_cpp_process_line_notes, _cpp_clean_line, _cpp_get_fresh_line,\n\t_cpp_skip_block_comment, scan_out_logical_line): New.\n\t(_cpp_init_mbchar): Remove.\n\t* cppinit.c (init_library): Remove call to _cpp_init_mbchar.\n\t(cpp_read_main_file): Set line to 1 earlier.\n\t(post_options): -traditional-cpp doesn't want trigraphs.\n\t* cpplex.c (MULTIBYTE_CHARS): Remove code predicated on this.\n\t(add_line_note, _cpp_clean_line, _cpp_process_line_notes,\n\t_cpp_get_fresh_line): New.\n\t(handle_newline, skip_escaped_newlines, trigraph_p,\n\tcontinue_after_nul, _cpp_init_mbchar): Remove.\n\t(get_effective_char): Update.\n\t(_cpp_skip_block_comment): Rename from skip_block_comment, simplify.\n\t(skip_line_comment): Simplify.\n\t(skip_whitespace, parse_identifier, parse_slow, parse_number,\n\tparse_string): Update.\n\t(cpp_lex_direct): Use clean lines and process line notes.  Update.\n\t(cpp_interpret_charconst): No MULTIBYTE_CHARS.\n\t* cpplib.c (prepare_directive_trad): Call scan_out_logical_line\n\tdirectly.\n\t(_cpp_handle_directive): Don't set saved_flags.\n\t(run_directive, destringize_and_run, cpp_define, cpp_define_builtin,\n\tcpp_undef, handle_assertion, cpp_push_buffer): Update.\n\t(_cpp_pop_buffer): Free notes.\n\t* cppmacro.c (builtin_macro, paste_tokens): \\n terminate buffer.\n\t* cpppch.c (cpp_read_state): \\n terminate buffer.\n\t* cpptrad.c (skip_escaped_newlines, handle_newline): Remove.\n\t(copy_comment): Use _cpp_skip_block_comment.\n\t(skip_whitespace, lex_identifier, _cpp_read_logical_line_trad):\n\tSimplify.\n\t(_cpp_overlay_buffer, _cpp_remove_overlay, push_replacement_text,\n\tsave_replacement_text): Update.\n\t(scan_out_logical_line): Update to use clean lines and process\n\tline notes.\n\t* fix-header.c (read_scan_file): Update.\ntestsuite:\n\t* gcc.dg/cpp/_Pragma4.c: Remove stray space.\n\t* gcc.dg/cpp/trad/escaped-eof.c: Correct line number.\n\nFrom-SVN: r65808", "tree": {"sha": "6e2502497aefe03b070107d7b41bbe6be454b727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e2502497aefe03b070107d7b41bbe6be454b727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "606c99912372a1fd5354765992eaef014ab78ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606c99912372a1fd5354765992eaef014ab78ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606c99912372a1fd5354765992eaef014ab78ce2"}], "stats": {"total": 1145, "additions": 451, "deletions": 694}, "files": [{"sha": "978e98ab7947ed926b078b7e735245ce943efb02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -1,3 +1,52 @@\n+2003-04-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cppfiles.c (ENABLE_VALGRIND_CHECKING, VALGRIND_DISCARD,\n+\tMMAP_THRESHOLD, TEST_THRESHOLD, SHOULD_MMAP): Remove.\n+\t(struct include_file): Remove fefcnt, mapped members.\n+\t(open_file, stack_include_file, _cpp_pop_file_buffer): Disable caching.\n+\t(read_include_file): Don't use mmap, terminate buffers in '\\r'.\n+\t(purge_cache): Don't use munmap.\n+\t* cpphash.h (CPP_BUF_COLUMN): Update.\n+\t(lexer_state): Remove lexing_comment.\n+\t(struct _cpp_line_note): New.\n+\t(struct cpp_buffer): New members cur_note, notes_used, notes_cap,\n+\tnext_line and need_line.  Remove col_adjust and saved_flags.\n+\t(_cpp_process_line_notes, _cpp_clean_line, _cpp_get_fresh_line,\n+\t_cpp_skip_block_comment, scan_out_logical_line): New.\n+\t(_cpp_init_mbchar): Remove.\n+\t* cppinit.c (init_library): Remove call to _cpp_init_mbchar.\n+\t(cpp_read_main_file): Set line to 1 earlier.\n+\t(post_options): -traditional-cpp doesn't want trigraphs.\n+\t* cpplex.c (MULTIBYTE_CHARS): Remove code predicated on this.\n+\t(add_line_note, _cpp_clean_line, _cpp_process_line_notes,\n+\t_cpp_get_fresh_line): New.\n+\t(handle_newline, skip_escaped_newlines, trigraph_p,\n+\tcontinue_after_nul, _cpp_init_mbchar): Remove.\n+\t(get_effective_char): Update.\n+\t(_cpp_skip_block_comment): Rename from skip_block_comment, simplify.\n+\t(skip_line_comment): Simplify.\n+\t(skip_whitespace, parse_identifier, parse_slow, parse_number,\n+\tparse_string): Update.\n+\t(cpp_lex_direct): Use clean lines and process line notes.  Update.\n+\t(cpp_interpret_charconst): No MULTIBYTE_CHARS.\n+\t* cpplib.c (prepare_directive_trad): Call scan_out_logical_line\n+\tdirectly.\n+\t(_cpp_handle_directive): Don't set saved_flags.\n+\t(run_directive, destringize_and_run, cpp_define, cpp_define_builtin,\n+\tcpp_undef, handle_assertion, cpp_push_buffer): Update.\n+\t(_cpp_pop_buffer): Free notes.\n+\t* cppmacro.c (builtin_macro, paste_tokens): \\n terminate buffer.\n+\t* cpppch.c (cpp_read_state): \\n terminate buffer.\n+\t* cpptrad.c (skip_escaped_newlines, handle_newline): Remove.\n+\t(copy_comment): Use _cpp_skip_block_comment.\n+\t(skip_whitespace, lex_identifier, _cpp_read_logical_line_trad):\n+\tSimplify.\n+\t(_cpp_overlay_buffer, _cpp_remove_overlay, push_replacement_text,\n+\tsave_replacement_text): Update.\n+\t(scan_out_logical_line): Update to use clean lines and process\n+\tline notes.\n+\t* fix-header.c (read_scan_file): Update.\n+\n 2003-04-18  Douglas B Rupp  <rupp@gnat.com>\n \n \t* unwind-dw2-fde.c (__register_frame_info_bases): Check for"}, {"sha": "4b8643d744532599fae4832e7ba3dbfdcbcf07bd", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 9, "deletions": 89, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -30,47 +30,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"mkdeps.h\"\n #include \"splay-tree.h\"\n-#ifdef ENABLE_VALGRIND_CHECKING\n-# ifdef HAVE_MEMCHECK_H\n-# include <memcheck.h>\n-# else\n-# include <valgrind.h>\n-# endif\n-#else\n-/* Avoid #ifdef:s when we can help it.  */\n-#define VALGRIND_DISCARD(x)\n-#endif\n-\n-#ifdef HAVE_MMAP_FILE\n-# include <sys/mman.h>\n-# ifndef MMAP_THRESHOLD\n-#  define MMAP_THRESHOLD 3 /* Minimum page count to mmap the file.  */\n-# endif\n-# if MMAP_THRESHOLD\n-#  define TEST_THRESHOLD(size, pagesize) \\\n-     (size / pagesize >= MMAP_THRESHOLD && (size % pagesize) != 0)\n-   /* Use mmap if the file is big enough to be worth it (controlled\n-      by MMAP_THRESHOLD) and if we can safely count on there being\n-      at least one readable NUL byte after the end of the file's\n-      contents.  This is true for all tested operating systems when\n-      the file size is not an exact multiple of the page size.  */\n-#  ifndef __CYGWIN__\n-#   define SHOULD_MMAP(size, pagesize) TEST_THRESHOLD (size, pagesize)\n-#  else\n-#   define WIN32_LEAN_AND_MEAN\n-#   include <windows.h>\n-    /* Cygwin can't correctly emulate mmap under Windows 9x style systems so\n-       disallow use of mmap on those systems.  Windows 9x does not zero fill\n-       memory at EOF and beyond, as required.  */\n-#   define SHOULD_MMAP(size, pagesize) ((GetVersion() & 0x80000000) \\\n-    \t\t\t\t\t? 0 : TEST_THRESHOLD (size, pagesize))\n-#  endif\n-# endif\n-\n-#else  /* No MMAP_FILE */\n-#  undef MMAP_THRESHOLD\n-#  define MMAP_THRESHOLD 0\n-#endif\n \n #ifndef O_BINARY\n # define O_BINARY 0\n@@ -102,8 +61,6 @@ struct include_file {\n   int fd;\t\t\t/* fd open on file (short term storage only) */\n   int err_no;\t\t\t/* errno obtained if opening a file failed */\n   unsigned short include_count;\t/* number of times file has been read */\n-  unsigned short refcnt;\t/* number of stacked buffers using this file */\n-  unsigned char mapped;\t\t/* file buffer is mmapped */\n   unsigned char pch;\t\t/* 0: file not known to be a PCH.\n \t\t\t\t   1: file is a PCH \n \t\t\t\t      (on return from find_include_file).\n@@ -278,7 +235,7 @@ open_file (pfile, filename)\n     return file;\n \n   /* Don't reopen one which is already loaded.  */\n-  if (file->buffer != NULL)\n+  if (0 && file->buffer != NULL)\n     return file;\n \n   /* We used to open files in nonblocking mode, but that caused more\n@@ -446,7 +403,7 @@ stack_include_file (pfile, inc)\n     }\n \n   /* Not in cache?  */\n-  if (! inc->buffer)\n+  if (1 || ! inc->buffer)\n     {\n       if (read_include_file (pfile, inc))\n \t{\n@@ -471,7 +428,6 @@ stack_include_file (pfile, inc)\n   fp = cpp_push_buffer (pfile, inc->buffer, inc->st.st_size,\n \t\t\t/* from_stage3 */ CPP_OPTION (pfile, preprocessed), 0);\n   fp->inc = inc;\n-  fp->inc->refcnt++;\n \n   /* Initialize controlling macro state.  */\n   pfile->mi_valid = true;\n@@ -507,9 +463,6 @@ read_include_file (pfile, inc)\n {\n   ssize_t size, offset, count;\n   uchar *buf;\n-#if MMAP_THRESHOLD\n-  static int pagesize = -1;\n-#endif\n \n   if (S_ISREG (inc->st.st_mode))\n     {\n@@ -528,25 +481,6 @@ read_include_file (pfile, inc)\n \t}\n       size = inc->st.st_size;\n \n-      inc->mapped = 0;\n-#if MMAP_THRESHOLD\n-      if (pagesize == -1)\n-\tpagesize = getpagesize ();\n-\n-      if (SHOULD_MMAP (size, pagesize))\n-\t{\n-\t  buf = (uchar *) mmap (0, size, PROT_READ, MAP_PRIVATE, inc->fd, 0);\n-\t  if (buf == (uchar *) -1)\n-\t    goto perror_fail;\n-\n-\t  /* We must tell Valgrind that the byte at buf[size] is actually\n-\t     readable.  Discard the handle to avoid handle leak.  */\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (buf + size, 1));\n-\n-\t  inc->mapped = 1;\n-\t}\n-      else\n-#endif\n \t{\n \t  buf = (uchar *) xmalloc (size + 1);\n \t  offset = 0;\n@@ -567,8 +501,8 @@ read_include_file (pfile, inc)\n \t\t}\n \t      offset += count;\n \t    }\n-\t  /* The lexer requires that the buffer be NUL-terminated.  */\n-\t  buf[size] = '\\0';\n+\t  /* The lexer requires that the buffer be \\n-terminated.  */\n+\t  buf[size] = '\\n';\n \t}\n     }\n   else if (S_ISBLK (inc->st.st_mode))\n@@ -600,8 +534,8 @@ read_include_file (pfile, inc)\n       if (offset + 1 < size)\n \tbuf = xrealloc (buf, offset + 1);\n \n-      /* The lexer requires that the buffer be NUL-terminated.  */\n-      buf[offset] = '\\0';\n+      /* The lexer requires that the buffer be \\n-terminated.  */\n+      buf[offset] = '\\n';\n       inc->st.st_size = offset;\n     }\n \n@@ -614,26 +548,14 @@ read_include_file (pfile, inc)\n   return 1;\n }\n \n-/* Drop INC's buffer from memory, if we are unlikely to need it again.  */\n+/* Drop INC's buffer from memory.  */\n static void\n purge_cache (inc)\n      struct include_file *inc;\n {\n   if (inc->buffer)\n     {\n-#if MMAP_THRESHOLD\n-      if (inc->mapped)\n-\t{\n-\t  /* Undo the previous annotation for the\n-\t     known-zero-byte-after-mmap.  Discard the handle to avoid\n-\t     handle leak.  */\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (inc->buffer\n-\t\t\t\t\t\t    + inc->st.st_size, 1));\n-\t  munmap ((PTR) inc->buffer, inc->st.st_size);\n-\t}\n-      else\n-#endif\n-\tfree ((PTR) inc->buffer);\n+      free ((PTR) inc->buffer);\n       inc->buffer = NULL;\n     }\n }\n@@ -929,9 +851,7 @@ _cpp_pop_file_buffer (pfile, inc)\n   /* Invalidate control macros in the #including file.  */\n   pfile->mi_valid = false;\n \n-  inc->refcnt--;\n-  if (inc->refcnt == 0 && DO_NOT_REREAD (inc))\n-    purge_cache (inc);\n+  purge_cache (inc);\n }\n \n /* Returns the first place in the include chain to start searching for"}, {"sha": "4b5cd499cf00a06424134b7f6d1be7a62b29b4c3", "filename": "gcc/cpphash.h", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -45,7 +45,7 @@ typedef unsigned char uchar;\n \n #define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n-#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n+#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base)\n #define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n \n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n@@ -212,9 +212,6 @@ struct lexer_state\n      all directives apart from #define.  */\n   unsigned char save_comments;\n \n-  /* Nonzero if we're mid-comment.  */\n-  unsigned char lexing_comment;\n-\n   /* Nonzero if lexing __VA_ARGS__ is valid.  */\n   unsigned char va_args_ok;\n \n@@ -240,17 +237,37 @@ struct spec_nodes\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n };\n \n+typedef struct _cpp_line_note _cpp_line_note;\n+struct _cpp_line_note\n+{\n+  /* Location in the clean line the note refers to.  */\n+  const uchar *pos;\n+\n+  /* Type of note.  */\n+  enum { NOTE_ESC_NL = 0,\n+\t NOTE_ESC_SPACE_NL,\n+\t NOTE_TRIGRAPH,\n+\t NOTE_NEWLINE } type;\n+};\n+\n /* Represents the contents of a file cpplib has read in.  */\n struct cpp_buffer\n {\n-  const unsigned char *cur;\t /* current position */\n-  const unsigned char *backup_to; /* if peeked character is not wanted */\n-  const unsigned char *rlimit; /* end of valid data */\n-  const unsigned char *line_base; /* start of current line */\n+  const uchar *cur;\t\t/* Current location.  */\n+  const uchar *line_base;\t/* Start of current physical line.  */\n+  const uchar *next_line;\t/* Start of to-be-cleaned logical line.  */\n+  \n+  const uchar *buf;\t\t/* Entire character buffer.  */\n+  const uchar *rlimit;\t\t/* Writable byte at end of file.  */\n+\n+  _cpp_line_note *notes;\t/* Array of notes.  */\n+  unsigned int cur_note;\t/* Next note to process.  */\n+  unsigned int notes_used;\t/* Number of notes.  */\n+  unsigned int notes_cap;\t/* Size of allocated array.  */\n \n   struct cpp_buffer *prev;\n \n-  const unsigned char *buf;\t /* Entire character buffer.  */\n+  const unsigned char *backup_to; /* Soon to die.  */\n \n   /* Pointer into the include table; non-NULL if this is a file\n      buffer.  Used for include_next and to record control macros.  */\n@@ -260,15 +277,8 @@ struct cpp_buffer\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n   struct if_stack *if_stack;\n \n-  /* Token column position adjustment owing to tabs in whitespace.  */\n-  unsigned int col_adjust;\n-\n-  /* Contains PREV_WHITE and/or AVOID_LPASTE.  */\n-  unsigned char saved_flags;\n-\n-  /* Because of the way the lexer works, -Wtrigraphs can sometimes\n-     warn twice for the same trigraph.  This helps prevent that.  */\n-  const unsigned char *last_Wtrigraphs;\n+  /* True if we need to get the next clean line.  */\n+  bool need_line;\n \n   /* True if we have already warned about C++ comments in this file.\n      The warning happens only for C89 extended mode with -pedantic on,\n@@ -503,13 +513,16 @@ extern bool _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n extern struct op *_cpp_expand_op_stack\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n+extern void _cpp_process_line_notes\tPARAMS ((cpp_reader *, int));\n+extern void _cpp_clean_line\t\tPARAMS ((cpp_reader *));\n+extern bool _cpp_get_fresh_line\t\tPARAMS ((cpp_reader *));\n+extern bool _cpp_skip_block_comment\tPARAMS ((cpp_reader *));\n extern cpp_token *_cpp_temp_token\tPARAMS ((cpp_reader *));\n extern const cpp_token *_cpp_lex_token\tPARAMS ((cpp_reader *));\n extern cpp_token *_cpp_lex_direct\tPARAMS ((cpp_reader *));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n-extern void _cpp_init_mbchar\t\tPARAMS ((void));\n \n /* In cppinit.c.  */\n extern void _cpp_maybe_push_include_file PARAMS ((cpp_reader *));\n@@ -529,6 +542,7 @@ extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n /* In cpptrad.c.  */\n+extern bool scan_out_logical_line PARAMS ((cpp_reader *, cpp_macro *));\n extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n \t\t\t\t\t size_t));"}, {"sha": "74679c0111b234b29142f9b048a8d92bb918f039", "filename": "gcc/cppinit.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -125,8 +125,6 @@ init_library ()\n \t we were compiled with a compiler that supports C99 designated\n \t initializers.  */\n       init_trigraph_map ();\n-\n-      _cpp_init_mbchar ();\n     }\n }\n \n@@ -167,7 +165,6 @@ cpp_create_reader (lang, table)\n   /* Initialize the line map.  Start at logical line 1, so we can use\n      a line number of zero for special states.  */\n   init_line_maps (&pfile->line_maps);\n-  pfile->line = 1;\n \n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n@@ -454,6 +451,7 @@ cpp_read_main_file (pfile, fname)\n     }\n \n   /* Open the main input file.  */\n+  pfile->line = 1;\n   if (!_cpp_read_file (pfile, fname))\n     return NULL;\n \n@@ -556,7 +554,11 @@ post_options (pfile)\n       CPP_OPTION (pfile, traditional) = 0;\n     }\n \n-  /* Traditional CPP does not accurately track column information.  */\n   if (CPP_OPTION (pfile, traditional))\n-    CPP_OPTION (pfile, show_column) = 0;\n+    {\n+      /* Traditional CPP does not accurately track column information.  */\n+      CPP_OPTION (pfile, show_column) = 0;\n+      CPP_OPTION (pfile, trigraphs) = 0;\n+      CPP_OPTION (pfile, warn_trigraphs) = 0;\n+    }\n }"}, {"sha": "930e887948d230df652d4e11ab5b0a8b5b4f98b3", "filename": "gcc/cpplex.c", "status": "modified", "additions": 222, "deletions": 370, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -4,7 +4,6 @@\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n    Broken out to separate file, Zack Weinberg, Mar 2000\n-   Single-pass line tokenization by Neil Booth, April 2000\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -27,11 +26,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-#ifdef MULTIBYTE_CHARS\n-#include \"mbchar.h\"\n-#include <locale.h>\n-#endif\n-\n /* Tokens with SPELL_STRING store their spelling in the token list,\n    and it's length in the token->val.name.len.  */\n enum spell_type\n@@ -63,24 +57,19 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n #define BACKUP() do {buffer->cur = buffer->backup_to;} while (0)\n \n-static void handle_newline PARAMS ((cpp_reader *));\n-static cppchar_t skip_escaped_newlines PARAMS ((cpp_reader *));\n+static void add_line_note PARAMS ((cpp_buffer *, const uchar *, unsigned int));\n static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n \n-static int skip_block_comment PARAMS ((cpp_reader *));\n static int skip_line_comment PARAMS ((cpp_reader *));\n-static void adjust_column PARAMS ((cpp_reader *));\n-static int skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n+static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n static uchar *parse_slow PARAMS ((cpp_reader *, const uchar *, int,\n \t\t\t\t  unsigned int *));\n static void parse_number PARAMS ((cpp_reader *, cpp_string *, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const uchar *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n-static bool trigraph_p PARAMS ((cpp_reader *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n \t\t\t\t  cppchar_t));\n-static bool continue_after_nul PARAMS ((cpp_reader *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n \t\t\t\t   const unsigned char *, cppchar_t *));\n@@ -89,15 +78,6 @@ static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n static unsigned int hex_digit_value PARAMS ((unsigned int));\n static _cpp_buff *new_buff PARAMS ((size_t));\n \n-/* Change to the native locale for multibyte conversions.  */\n-void\n-_cpp_init_mbchar ()\n-{\n-#ifdef MULTIBYTE_CHARS\n-  setlocale (LC_CTYPE, \"\");\n-  GET_ENVIRONMENT (literal_codeset, \"LANG\");\n-#endif\n-}\n \n /* Utility routine:\n \n@@ -114,132 +94,158 @@ cpp_ideq (token, string)\n   return !ustrcmp (NODE_NAME (token->val.node), (const uchar *) string);\n }\n \n-/* Call when meeting a newline, assumed to be in buffer->cur[-1].\n-   Returns with buffer->cur pointing to the character immediately\n-   following the newline (combination).  */\n+/* Record a note TYPE at byte POS into the current cleaned logical\n+   line.  */\n static void\n-handle_newline (pfile)\n-     cpp_reader *pfile;\n+add_line_note (buffer, pos, type)\n+     cpp_buffer *buffer;\n+     const uchar *pos;\n+     unsigned int type;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-\n-  /* Handle CR-LF and LF-CR.  Most other implementations (e.g. java)\n-     only accept CR-LF; maybe we should fall back to that behavior?  */\n-  if (buffer->cur[-1] + buffer->cur[0] == '\\r' + '\\n')\n-    buffer->cur++;\n+  if (buffer->notes_used == buffer->notes_cap)\n+    {\n+      buffer->notes_cap = buffer->notes_cap * 2 + 200;\n+      buffer->notes = (_cpp_line_note *)\n+\txrealloc (buffer->notes, buffer->notes_cap * sizeof (_cpp_line_note));\n+    }\n \n-  buffer->line_base = buffer->cur;\n-  buffer->col_adjust = 0;\n-  pfile->line++;\n+  buffer->notes[buffer->notes_used].pos = pos;\n+  buffer->notes[buffer->notes_used].type = type;\n+  buffer->notes_used++;\n }\n \n-/* Subroutine of skip_escaped_newlines; called when a 3-character\n-   sequence beginning with \"??\" is encountered.  buffer->cur points to\n-   the second '?'.\n-\n-   Warn if necessary, and returns true if the sequence forms a\n-   trigraph and the trigraph should be honored.  */\n-static bool\n-trigraph_p (pfile)\n+/* Returns with a logical line that contains no escaped newlines or\n+   trigraphs.  This is a time-critical inner loop.  */\n+void\n+_cpp_clean_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  cppchar_t from_char = buffer->cur[1];\n-  bool accept;\n-\n-  if (!_cpp_trigraph_map[from_char])\n-    return false;\n+  cpp_buffer *buffer;\n+  const uchar *s;\n+  uchar c, *d, *p;\n \n-  accept = CPP_OPTION (pfile, trigraphs);\n+  buffer = pfile->buffer;\n+  buffer->cur_note = buffer->notes_used = 0;\n+  buffer->cur = buffer->line_base = buffer->next_line;\n+  buffer->need_line = false;\n+  s = buffer->next_line - 1;\n \n-  /* Don't warn about trigraphs in comments.  */\n-  if (CPP_OPTION (pfile, warn_trigraphs) && !pfile->state.lexing_comment)\n+  if (!buffer->from_stage3)\n     {\n-      if (accept)\n-\tcpp_error_with_line (pfile, DL_WARNING,\n-\t\t\t     pfile->line, CPP_BUF_COL (buffer) - 1,\n-\t\t\t     \"trigraph ??%c converted to %c\",\n-\t\t\t     (int) from_char,\n-\t\t\t     (int) _cpp_trigraph_map[from_char]);\n-      else if (buffer->cur != buffer->last_Wtrigraphs)\n+      d = (uchar *) s;\n+\n+      for (;;)\n \t{\n-\t  buffer->last_Wtrigraphs = buffer->cur;\n-\t  cpp_error_with_line (pfile, DL_WARNING,\n-\t\t\t       pfile->line, CPP_BUF_COL (buffer) - 1,\n-\t\t\t       \"trigraph ??%c ignored\", (int) from_char);\n+\t  c = *++s;\n+\t  *++d = c;\n+\n+\t  if (c == '\\n' || c == '\\r')\n+\t    {\n+\t\t  /* Handle DOS line endings.  */\n+\t      if (c == '\\r' && s != buffer->rlimit && s[1] == '\\n')\n+\t\ts++;\n+\t      if (s == buffer->rlimit)\n+\t\tbreak;\n+\n+\t      /* Escaped?  */\n+\t      p = d;\n+\t      while (p != buffer->next_line && is_nvspace (p[-1]))\n+\t\tp--;\n+\t      if (p == buffer->next_line || p[-1] != '\\\\')\n+\t\tbreak;\n+\n+\t      add_line_note (buffer, p - 1,\n+\t\t\t     p != d ? NOTE_ESC_SPACE_NL: NOTE_ESC_NL);\n+\t      d = p - 2;\n+\t      buffer->next_line = p - 1;\n+\t    }\n+\t  else if (c == '?' && s[1] == '?' && _cpp_trigraph_map[s[2]])\n+\t    {\n+\t      /* Add a note regardless, for the benefit of -Wtrigraphs.  */\n+\t      add_line_note (buffer, d, NOTE_TRIGRAPH);\n+\t      if (CPP_OPTION (pfile, trigraphs))\n+\t\t{\n+\t\t  *d = _cpp_trigraph_map[s[2]];\n+\t\t  s += 2;\n+\t\t}\n+\t    }\n \t}\n     }\n+  else\n+    {\n+      do\n+\ts++;\n+      while (*s != '\\n' && *s != '\\r');\n+      d = (uchar *) s;\n+\n+      /* Handle DOS line endings.  */\n+      if (*s == '\\r' && s != buffer->rlimit && s[1] == '\\n')\n+\ts++;\n+    }\n \n-  return accept;\n+  *d = '\\n';\n+  add_line_note (buffer, d + 1, NOTE_NEWLINE);\n+  buffer->next_line = s + 1;\n }\n \n-/* Skips any escaped newlines introduced by '?' or a '\\\\', assumed to\n-   lie in buffer->cur[-1].  Returns the next byte, which will be in\n-   buffer->cur[-1].  This routine performs preprocessing stages 1 and\n-   2 of the ISO C standard.  */\n-static cppchar_t\n-skip_escaped_newlines (pfile)\n+/* Process the notes created by add_line_note as far as the current\n+   location.  */\n+void\n+_cpp_process_line_notes (pfile, in_comment)\n      cpp_reader *pfile;\n+     int in_comment;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cppchar_t next = buffer->cur[-1];\n \n-  /* Only do this if we apply stages 1 and 2.  */\n-  if (!buffer->from_stage3)\n+  for (;;)\n     {\n-      const unsigned char *saved_cur;\n-      cppchar_t next1;\n+      _cpp_line_note *note = &buffer->notes[buffer->cur_note];\n+      unsigned int col;\n \n-      do\n-\t{\n-\t  if (next == '?')\n-\t    {\n-\t      if (buffer->cur[0] != '?' || !trigraph_p (pfile))\n-\t\tbreak;\n-\n-\t      /* Translate the trigraph.  */\n-\t      next = _cpp_trigraph_map[buffer->cur[1]];\n-\t      buffer->cur += 2;\n-\t      if (next != '\\\\')\n-\t\tbreak;\n-\t    }\n+      if (note->pos > buffer->cur)\n+\tbreak;\n \n-\t  if (buffer->cur == buffer->rlimit)\n-\t    break;\n+      buffer->cur_note++;\n+      col = CPP_BUF_COLUMN (buffer, note->pos + 1);\n \n-\t  /* We have a backslash, and room for at least one more\n-\t     character.  Skip horizontal whitespace.  */\n-\t  saved_cur = buffer->cur;\n-\t  do\n-\t    next1 = *buffer->cur++;\n-\t  while (is_nvspace (next1) && buffer->cur < buffer->rlimit);\n+      switch (note->type)\n+\t{\n+\tcase NOTE_NEWLINE:\n+\t  /* This note is a kind of sentinel we should never reach.  */\n+\t  abort ();\n \n-\t  if (!is_vspace (next1))\n+\tcase NOTE_TRIGRAPH:\n+\t  if (!in_comment && CPP_OPTION (pfile, warn_trigraphs))\n \t    {\n-\t      buffer->cur = saved_cur;\n-\t      break;\n+\t      if (CPP_OPTION (pfile, trigraphs))\n+\t\tcpp_error_with_line (pfile, DL_WARNING, pfile->line, col,\n+\t\t\t\t     \"trigraph converted to %c\",\n+\t\t\t\t     (int) note->pos[0]);\n+\t      else\n+\t\tcpp_error_with_line (pfile, DL_WARNING, pfile->line, col,\n+\t\t\t\t     \"trigraph ??%c ignored\",\n+\t\t\t\t     (int) note->pos[2]);\n \t    }\n+\t  break;\n \n-\t  if (saved_cur != buffer->cur - 1\n-\t      && !pfile->state.lexing_comment)\n-\t    cpp_error (pfile, DL_WARNING,\n-\t\t       \"backslash and newline separated by space\");\n-\n-\t  handle_newline (pfile);\n-\t  buffer->backup_to = buffer->cur;\n-\t  if (buffer->cur == buffer->rlimit)\n+\tcase NOTE_ESC_SPACE_NL:\n+\t  if (!in_comment)\n+\t    cpp_error_with_line (pfile, DL_WARNING, pfile->line, col,\n+\t\t\t\t \"backslash and newline separated by space\");\n+\t  /* Fall through... */\n+\tcase NOTE_ESC_NL:\n+\t  if (buffer->next_line > buffer->rlimit)\n \t    {\n-\t      cpp_error (pfile, DL_PEDWARN,\n-\t\t\t \"backslash-newline at end of file\");\n-\t      next = EOF;\n+\t      cpp_error_with_line (pfile, DL_PEDWARN, pfile->line, col,\n+\t\t\t\t   \"backslash-newline at end of file\");\n+\t      /* Prevent \"no newline at end of file\" warning.  */\n+\t      buffer->next_line = buffer->rlimit;\n \t    }\n-\t  else\n-\t    next = *buffer->cur++;\n+\n+\t  buffer->line_base = note->pos;\n+\t  pfile->line++;\n \t}\n-      while (next == '\\\\' || next == '?');\n     }\n-\n-  return next;\n }\n \n /* Obtain the next character, after trigraph conversion and skipping\n@@ -251,42 +257,34 @@ static cppchar_t\n get_effective_char (pfile)\n      cpp_reader *pfile;\n {\n-  cppchar_t next;\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->backup_to = buffer->cur;\n-  next = *buffer->cur++;\n-  if (__builtin_expect (next == '?' || next == '\\\\', 0))\n-    next = skip_escaped_newlines (pfile);\n-\n-  return next;\n+  return *buffer->cur++;\n }\n \n /* Skip a C-style block comment.  We find the end of the comment by\n    seeing if an asterisk is before every '/' we encounter.  Returns\n    nonzero if comment terminated by EOF, zero otherwise.  */\n-static int\n-skip_block_comment (pfile)\n+bool\n+_cpp_skip_block_comment (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cppchar_t c = EOF, prevc = EOF;\n+  cppchar_t c;\n \n-  pfile->state.lexing_comment = 1;\n-  while (buffer->cur != buffer->rlimit)\n-    {\n-      prevc = c, c = *buffer->cur++;\n+  if (*buffer->cur == '/')\n+    buffer->cur++;\n \n-      /* FIXME: For speed, create a new character class of characters\n-\t of interest inside block comments.  */\n-      if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile);\n+  for (;;)\n+    {\n+      c = *buffer->cur++;\n \n       /* People like decorating comments with '*', so check for '/'\n \t instead for efficiency.  */\n       if (c == '/')\n \t{\n-\t  if (prevc == '*')\n+\t  if (buffer->cur[-2] == '*')\n \t    break;\n \n \t  /* Warn about potential nested comments, but not if the '/'\n@@ -298,14 +296,18 @@ skip_block_comment (pfile)\n \t\t\t\t pfile->line, CPP_BUF_COL (buffer),\n \t\t\t\t \"\\\"/*\\\" within comment\");\n \t}\n-      else if (is_vspace (c))\n-\thandle_newline (pfile);\n-      else if (c == '\\t')\n-\tadjust_column (pfile);\n+      else if (c == '\\n')\n+\t{\n+\t  buffer->cur--;\n+\t  _cpp_process_line_notes (pfile, true);\n+\t  if (buffer->next_line >= buffer->rlimit)\n+\t    return true;\n+\t  _cpp_clean_line (pfile);\n+\t  pfile->line++;\n+\t}\n     }\n \n-  pfile->state.lexing_comment = 0;\n-  return c != '/' || prevc != '*';\n+  return false;\n }\n \n /* Skip a C++ line comment, leaving buffer->cur pointing to the\n@@ -317,72 +319,16 @@ skip_line_comment (pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned int orig_line = pfile->line;\n-  cppchar_t c;\n-#ifdef MULTIBYTE_CHARS\n-  wchar_t wc;\n-  int char_len;\n-#endif\n-\n-  pfile->state.lexing_comment = 1;\n-#ifdef MULTIBYTE_CHARS\n-  /* Reset multibyte conversion state.  */\n-  (void) local_mbtowc (NULL, NULL, 0);\n-#endif\n-  do\n-    {\n-      if (buffer->cur == buffer->rlimit)\n-\tgoto at_eof;\n-\n-#ifdef MULTIBYTE_CHARS\n-      char_len = local_mbtowc (&wc, (const char *) buffer->cur,\n-\t\t\t       buffer->rlimit - buffer->cur);\n-      if (char_len == -1)\n-\t{\n-\t  cpp_error (pfile, DL_WARNING,\n-\t\t     \"ignoring invalid multibyte character\");\n-\t  char_len = 1;\n-\t  c = *buffer->cur++;\n-\t}\n-      else\n-\t{\n-\t  buffer->cur += char_len;\n-\t  c = wc;\n-\t}\n-#else\n-      c = *buffer->cur++;\n-#endif\n-      if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile);\n-    }\n-  while (!is_vspace (c));\n \n-  /* Step back over the newline, except at EOF.  */\n-  buffer->cur--;\n- at_eof:\n+  while (*buffer->cur != '\\n')\n+    buffer->cur++;\n \n-  pfile->state.lexing_comment = 0;\n+  _cpp_process_line_notes (pfile, true);\n   return orig_line != pfile->line;\n }\n \n-/* pfile->buffer->cur is one beyond the \\t character.  Update\n-   col_adjust so we track the column correctly.  */\n+/* Skips whitespace, saving the next non-whitespace character.  */\n static void\n-adjust_column (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *buffer = pfile->buffer;\n-  unsigned int col = CPP_BUF_COL (buffer) - 1; /* Zero-based column.  */\n-\n-  /* Round it up to multiple of the tabstop, but subtract 1 since the\n-     tab itself occupies a character position.  */\n-  buffer->col_adjust += (CPP_OPTION (pfile, tabstop)\n-\t\t\t - col % CPP_OPTION (pfile, tabstop)) - 1;\n-}\n-\n-/* Skips whitespace, saving the next non-whitespace character.\n-   Adjusts pfile->col_adjust to account for tabs.  Without this,\n-   tokens might be assigned an incorrect column.  */\n-static int\n skip_whitespace (pfile, c)\n      cpp_reader *pfile;\n      cppchar_t c;\n@@ -393,15 +339,11 @@ skip_whitespace (pfile, c)\n   do\n     {\n       /* Horizontal space always OK.  */\n-      if (c == ' ')\n+      if (c == ' ' || c == '\\t')\n \t;\n-      else if (c == '\\t')\n-\tadjust_column (pfile);\n       /* Just \\f \\v or \\0 left.  */\n       else if (c == '\\0')\n \t{\n-\t  if (buffer->cur - 1 == buffer->rlimit)\n-\t    return 0;\n \t  if (!warned)\n \t    {\n \t      cpp_error (pfile, DL_WARNING, \"null character(s) ignored\");\n@@ -420,7 +362,6 @@ skip_whitespace (pfile, c)\n   while (is_nvspace (c));\n \n   buffer->cur--;\n-  return 1;\n }\n \n /* See if the characters of a number token are valid in a name (no\n@@ -461,7 +402,7 @@ parse_identifier (pfile)\n     cur++;\n \n   /* Check for slow-path cases.  */\n-  if (*cur == '?' || *cur == '\\\\' || *cur == '$')\n+  if (*cur == '$')\n     {\n       unsigned int len;\n \n@@ -532,8 +473,6 @@ parse_slow (pfile, cur, number_p, plen)\n     {\n       /* Potential escaped newline?  */\n       buffer->backup_to = buffer->cur - 1;\n-      if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile);\n \n       if (!is_idchar (c))\n \t{\n@@ -590,7 +529,7 @@ parse_number (pfile, number, leading_period)\n     cur++;\n \n   /* Check for slow-path cases.  */\n-  if (*cur == '?' || *cur == '\\\\' || *cur == '$')\n+  if (*cur == '$')\n     number->text = parse_slow (pfile, cur, 1 + leading_period, &number->len);\n   else\n     {\n@@ -648,18 +587,10 @@ parse_string (pfile, token, terminator)\n   unsigned char *dest, *limit;\n   cppchar_t c;\n   bool warned_nulls = false;\n-#ifdef MULTIBYTE_CHARS\n-  wchar_t wc;\n-  int char_len;\n-#endif\n \n   dest = BUFF_FRONT (pfile->u_buff);\n   limit = BUFF_LIMIT (pfile->u_buff);\n \n-#ifdef MULTIBYTE_CHARS\n-  /* Reset multibyte conversion state.  */\n-  (void) local_mbtowc (NULL, NULL, 0);\n-#endif\n   for (;;)\n     {\n       /* We need room for another char, possibly the terminating NUL.  */\n@@ -671,41 +602,19 @@ parse_string (pfile, token, terminator)\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n \n-#ifdef MULTIBYTE_CHARS\n-      char_len = local_mbtowc (&wc, (const char *) buffer->cur,\n-\t\t\t       buffer->rlimit - buffer->cur);\n-      if (char_len == -1)\n-\t{\n-\t  cpp_error (pfile, DL_WARNING,\n-\t\t     \"ignoring invalid multibyte character\");\n-\t  char_len = 1;\n-\t  c = *buffer->cur++;\n-\t}\n-      else\n-\t{\n-\t  buffer->cur += char_len;\n-\t  c = wc;\n-\t}\n-#else\n       c = *buffer->cur++;\n-#endif\n-\n-      /* Handle trigraphs, escaped newlines etc.  */\n-      if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (pfile);\n \n       if (c == terminator)\n \t{\n \t  if (unescaped_terminator_p (pfile, dest))\n \t    break;\n \t}\n-      else if (is_vspace (c))\n+      else if (c == '\\n')\n \t{\n \t  /* No string literal may extend over multiple lines.  In\n \t     assembly language, suppress the error except for <>\n \t     includes.  This is a kludge around not knowing where\n \t     comments are.  */\n-\tunterminated:\n \t  if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n \t    cpp_error (pfile, DL_ERROR, \"missing terminating %c character\",\n \t\t       (int) terminator);\n@@ -714,23 +623,13 @@ parse_string (pfile, token, terminator)\n \t}\n       else if (c == '\\0')\n \t{\n-\t  if (buffer->cur - 1 == buffer->rlimit)\n-\t    goto unterminated;\n \t  if (!warned_nulls)\n \t    {\n \t      warned_nulls = true;\n \t      cpp_error (pfile, DL_WARNING,\n \t\t\t \"null character(s) preserved in literal\");\n \t    }\n \t}\n-#ifdef MULTIBYTE_CHARS\n-      if (char_len > 1)\n-\t{\n-\t  for ( ; char_len > 0; --char_len)\n-\t    *dest++ = (*buffer->cur - char_len);\n-\t}\n-      else\n-#endif\n \t*dest++ = c;\n     }\n \n@@ -890,55 +789,55 @@ _cpp_lex_token (pfile)\n   return result;\n }\n \n-/* A NUL terminates the current buffer.  For ISO preprocessing this is\n-   EOF, but for traditional preprocessing it indicates we need a line\n-   refill.  Returns TRUE to continue preprocessing a new buffer, FALSE\n-   to return a CPP_EOF to the caller.  */\n-static bool\n-continue_after_nul (pfile)\n+/* Returns true if a fresh line has been loaded.  */\n+bool\n+_cpp_get_fresh_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  bool more = false;\n+  /* We can't get a new line until we leave the current directive.  */\n+  if (pfile->state.in_directive)\n+    return false;\n \n-  buffer->saved_flags = BOL;\n-  if (CPP_OPTION (pfile, traditional))\n+  for (;;)\n     {\n-      if (pfile->state.in_directive)\n-\treturn false;\n+      cpp_buffer *buffer = pfile->buffer;\n \n-      _cpp_remove_overlay (pfile);\n-      more = _cpp_read_logical_line_trad (pfile);\n-      _cpp_overlay_buffer (pfile, pfile->out.base,\n-\t\t\t   pfile->out.cur - pfile->out.base);\n-      pfile->line = pfile->out.first_line;\n-    }\n-  else\n-    {\n-      /* Stop parsing arguments with a CPP_EOF.  When we finally come\n-\t back here, do the work of popping the buffer.  */\n-      if (!pfile->state.parsing_args)\n+      if (!buffer->need_line)\n+\treturn true;\n+\n+      if (buffer->next_line < buffer->rlimit)\n \t{\n-\t  if (buffer->cur != buffer->line_base)\n-\t    {\n-\t      /* Non-empty files should end in a newline.  Don't warn\n-\t\t for command line and _Pragma buffers.  */\n-\t      if (!buffer->from_stage3)\n-\t\tcpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n-\t      handle_newline (pfile);\n-\t    }\n+\t  _cpp_clean_line (pfile);\n+\t  return true;\n+\t}\n \n-\t  /* Similarly, finish an in-progress directive with CPP_EOF\n-\t     before popping the buffer.  */\n-\t  if (!pfile->state.in_directive && buffer->prev)\n-\t    {\n-\t      more = !buffer->return_at_eof;\n-\t      _cpp_pop_buffer (pfile);\n-\t    }\n+      /* First, get out of parsing arguments state.  */\n+      if (pfile->state.parsing_args)\n+\treturn false;\n+\n+      /* End of buffer.  Non-empty files should end in a newline.  */\n+      if (buffer->buf != buffer->rlimit\n+\t  && buffer->next_line > buffer->rlimit\n+\t  && !buffer->from_stage3)\n+\t{\n+\t  /* Only warn once.  */\n+\t  buffer->next_line = buffer->rlimit;\n+\t  cpp_error_with_line (pfile, DL_PEDWARN, pfile->line - 1,\n+\t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur),\n+\t\t\t       \"no newline at end of file\");\n+\t}\n+ \n+      if (buffer->return_at_eof)\n+\t{\n+\t  buffer->return_at_eof = false;\n+\t  return false;\n \t}\n-    }\n \n-  return more;\n+      if (!buffer->prev)\n+\treturn false;\n+\n+      _cpp_pop_buffer (pfile);\n+    }\n }\n \n #define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\\\n@@ -973,74 +872,49 @@ _cpp_lex_direct (pfile)\n   cpp_token *result = pfile->cur_token++;\n \n  fresh_line:\n+  result->flags = 0;\n+  if (pfile->buffer->need_line)\n+    {\n+      if (!_cpp_get_fresh_line (pfile))\n+\t{\n+\t  result->type = CPP_EOF;\n+\t  return result;\n+\t}\n+      if (!pfile->keep_tokens)\n+\t{\n+\t  pfile->cur_run = &pfile->base_run;\n+\t  result = pfile->base_run.base;\n+\t  pfile->cur_token = result + 1;\n+\t}\n+      result->flags = BOL;\n+      if (pfile->state.parsing_args == 2)\n+\tresult->flags |= PREV_WHITE;\n+    }\n   buffer = pfile->buffer;\n-  result->flags = buffer->saved_flags;\n-  buffer->saved_flags = 0;\n  update_tokens_line:\n   result->line = pfile->line;\n \n  skipped_white:\n+  if (buffer->cur >= buffer->notes[buffer->cur_note].pos\n+      && !pfile->overlaid_buffer)\n+    {\n+      _cpp_process_line_notes (pfile, false);\n+      result->line = pfile->line;\n+    }\n   c = *buffer->cur++;\n   result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n \n- trigraph:\n   switch (c)\n     {\n     case ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n       result->flags |= PREV_WHITE;\n-      if (skip_whitespace (pfile, c))\n-\tgoto skipped_white;\n-\n-      /* End of buffer.  */\n-      buffer->cur--;\n-      if (continue_after_nul (pfile))\n-\tgoto fresh_line;\n-      result->type = CPP_EOF;\n-      break;\n+      skip_whitespace (pfile, c);\n+      goto skipped_white;\n \n-    case '\\n': case '\\r':\n-      handle_newline (pfile);\n-      buffer->saved_flags = BOL;\n-      if (! pfile->state.in_directive)\n-\t{\n-\t  if (pfile->state.parsing_args == 2)\n-\t    buffer->saved_flags |= PREV_WHITE;\n-\t  if (!pfile->keep_tokens)\n-\t    {\n-\t      pfile->cur_run = &pfile->base_run;\n-\t      result = pfile->base_run.base;\n-\t      pfile->cur_token = result + 1;\n-\t    }\n-\t  goto fresh_line;\n-\t}\n-      result->type = CPP_EOF;\n-      break;\n-\n-    case '?':\n-    case '\\\\':\n-      /* These could start an escaped newline, or '?' a trigraph.  Let\n-\t skip_escaped_newlines do all the work.  */\n-      {\n-\tunsigned int line = pfile->line;\n-\n-\tc = skip_escaped_newlines (pfile);\n-\tif (line != pfile->line)\n-\t  {\n-\t    buffer->cur--;\n-\t    /* We had at least one escaped newline of some sort.\n-\t       Update the token's line and column.  */\n-\t    goto update_tokens_line;\n-\t  }\n-      }\n-\n-      /* We are either the original '?' or '\\\\', or a trigraph.  */\n-      if (c == '?')\n-\tresult->type = CPP_QUERY;\n-      else if (c == '\\\\')\n-\tgoto random_char;\n-      else\n-\tgoto trigraph;\n-      break;\n+    case '\\n':\n+      pfile->line++;\n+      buffer->need_line = true;\n+      goto fresh_line;\n \n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n@@ -1100,7 +974,7 @@ _cpp_lex_direct (pfile)\n \n       if (c == '*')\n \t{\n-\t  if (skip_block_comment (pfile))\n+\t  if (_cpp_skip_block_comment (pfile))\n \t    cpp_error (pfile, DL_ERROR, \"unterminated comment\");\n \t}\n       else if (c == '/' && (CPP_OPTION (pfile, cplusplus_comments)\n@@ -1331,6 +1205,7 @@ _cpp_lex_direct (pfile)\n     case '^': IF_NEXT_IS ('=', CPP_XOR_EQ, CPP_XOR); break;\n     case '#': IF_NEXT_IS ('#', CPP_PASTE, CPP_HASH); break;\n \n+    case '?': result->type = CPP_QUERY; break;\n     case '~': result->type = CPP_COMPL; break;\n     case ',': result->type = CPP_COMMA; break;\n     case '(': result->type = CPP_OPEN_PAREN; break;\n@@ -1349,7 +1224,6 @@ _cpp_lex_direct (pfile)\n \tgoto start_ident;\n       /* Fall through...  */\n \n-    random_char:\n     default:\n       result->type = CPP_OTHER;\n       result->val.c = c;\n@@ -1927,10 +1801,6 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n   cppchar_t c, mask, result = 0;\n   bool unsigned_p;\n \n-#ifdef MULTIBYTE_CHARS\n-  (void) local_mbtowc (NULL, NULL, 0);\n-#endif\n-\n   /* Width in bits.  */\n   if (token->type == CPP_CHAR)\n     {\n@@ -1952,25 +1822,7 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n \n   while (str < limit)\n     {\n-#ifdef MULTIBYTE_CHARS\n-      wchar_t wc;\n-      int char_len;\n-\n-      char_len = local_mbtowc (&wc, (const char *)str, limit - str);\n-      if (char_len == -1)\n-\t{\n-\t  cpp_error (pfile, DL_WARNING,\n-\t\t     \"ignoring invalid multibyte character\");\n-\t  c = *str++;\n-\t}\n-      else\n-\t{\n-\t  str += char_len;\n-\t  c = wc;\n-\t}\n-#else\n       c = *str++;\n-#endif\n \n       if (c == '\\\\')\n \tc = cpp_parse_escape (pfile, &str, limit, token->type == CPP_WCHAR);"}, {"sha": "bb983b04a292682705db9593ced632eb1df30da2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -295,7 +295,7 @@ prepare_directive_trad (pfile)\n \t\t\t\t    || pfile->directive == &dtable[T_ELIF]);\n       if (no_expand)\n \tpfile->state.prevent_expansion++;\n-      _cpp_read_logical_line_trad (pfile);\n+      scan_out_logical_line (pfile, NULL);\n       if (no_expand)\n \tpfile->state.prevent_expansion--;\n       pfile->state.skipping = was_skipping;\n@@ -451,13 +451,12 @@ _cpp_handle_directive (pfile, indented)\n       /* Restore state when within macro args.  */\n       pfile->state.parsing_args = 2;\n       pfile->state.prevent_expansion = 1;\n-      pfile->buffer->saved_flags |= PREV_WHITE;\n     }\n   return skip;\n }\n \n /* Directive handler wrapper used by the command line option\n-   processor.  */\n+   processor.  BUF is \\n terminated.  */\n static void\n run_directive (pfile, dir_no, buf, count)\n      cpp_reader *pfile;\n@@ -471,8 +470,11 @@ run_directive (pfile, dir_no, buf, count)\n   if (dir_no == T_PRAGMA)\n     pfile->buffer->inc = pfile->buffer->prev->inc;\n   start_directive (pfile);\n-  /* We don't want a leading # to be interpreted as a directive.  */\n-  pfile->buffer->saved_flags = 0;\n+\n+  /* This is a short-term fix to prevent a leading '#' being\n+     interpreted as a directive.  */\n+  _cpp_clean_line (pfile);\n+\n   pfile->directive = &dtable[dir_no];\n   if (CPP_OPTION (pfile, traditional))\n     prepare_directive_trad (pfile);\n@@ -1378,7 +1380,7 @@ destringize_and_run (pfile, in)\n \tsrc++;\n       *dest++ = *src++;\n     }\n-  *dest = '\\0';\n+  *dest = '\\n';\n \n   /* Ugh; an awful kludge.  We are really not set up to be lexing\n      tokens when in the middle of a macro expansion.  Use a new\n@@ -1904,7 +1906,7 @@ cpp_define (pfile, str)\n       buf[count++] = ' ';\n       buf[count++] = '1';\n     }\n-  buf[count] = '\\0';\n+  buf[count] = '\\n';\n \n   run_directive (pfile, T_DEFINE, buf, count);\n }\n@@ -1915,7 +1917,11 @@ _cpp_define_builtin (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  run_directive (pfile, T_DEFINE, str, strlen (str));\n+  size_t len = strlen (str);\n+  char *buf = alloca (len + 1);\n+  memcpy (buf, str, len);\n+  buf[len] = '\\n';\n+  run_directive (pfile, T_DEFINE, buf, len);\n }\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n@@ -1924,7 +1930,11 @@ cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n      const char *macro;\n {\n-  run_directive (pfile, T_UNDEF, macro, strlen (macro));\n+  size_t len = strlen (macro);\n+  char *buf = alloca (len + 1);\n+  memcpy (buf, macro, len);\n+  buf[len] = '\\n';\n+  run_directive (pfile, T_UNDEF, buf, len);\n }\n \n /* Process the string STR as if it appeared as the body of a #assert.  */\n@@ -1955,18 +1965,18 @@ handle_assertion (pfile, str, type)\n   size_t count = strlen (str);\n   const char *p = strchr (str, '=');\n \n+  /* Copy the entire option so we can modify it.  Change the first\n+     \"=\" in the string to a '(', and tack a ')' on the end.  */\n+  char *buf = (char *) alloca (count + 2);\n+\n+  memcpy (buf, str, count);\n   if (p)\n     {\n-      /* Copy the entire option so we can modify it.  Change the first\n-\t \"=\" in the string to a '(', and tack a ')' on the end.  */\n-      char *buf = (char *) alloca (count + 2);\n-\n-      memcpy (buf, str, count);\n       buf[p - str] = '(';\n       buf[count++] = ')';\n-      buf[count] = '\\0';\n-      str = buf;\n     }\n+  buf[count] = '\\n';\n+  str = buf;\n \n   run_directive (pfile, type, str, count);\n }\n@@ -2028,15 +2038,14 @@ cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n \n-  new->line_base = new->buf = new->cur = buffer;\n+  new->next_line = new->buf = buffer;\n   new->rlimit = buffer + len;\n-  new->from_stage3 = from_stage3 || CPP_OPTION (pfile, traditional);\n+  new->from_stage3 = from_stage3;\n   new->prev = pfile->buffer;\n   new->return_at_eof = return_at_eof;\n-  new->saved_flags = BOL;\n+  new->need_line = true;\n \n   pfile->buffer = new;\n-\n   return new;\n }\n \n@@ -2062,6 +2071,8 @@ _cpp_pop_buffer (pfile)\n   /* _cpp_do_file_change expects pfile->buffer to be the new one.  */\n   pfile->buffer = buffer->prev;\n \n+  free (buffer->notes);\n+\n   /* Free the buffer object now; we may want to push a new buffer\n      in _cpp_push_next_include_file.  */\n   obstack_free (&pfile->buffer_ob, buffer);"}, {"sha": "0898dac8cd197563d28050e8369a5e3431865bec", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -265,6 +265,8 @@ builtin_macro (pfile, node)\n      cpp_hashnode *node;\n {\n   const uchar *buf;\n+  size_t len;\n+  char *nbuf;\n \n   if (node->value.builtin == BT_PRAGMA)\n     {\n@@ -278,14 +280,13 @@ builtin_macro (pfile, node)\n     }\n \n   buf = _cpp_builtin_macro_text (pfile, node);\n+  len = ustrlen (buf);\n+  nbuf = alloca (len + 1);\n+  memcpy (nbuf, buf, len);\n+  nbuf[len]='\\n';\n \n-  cpp_push_buffer (pfile, buf, ustrlen (buf), /* from_stage3 */ true, 1);\n-\n-  /* Tweak the column number the lexer will report.  */\n-  pfile->buffer->col_adjust = pfile->cur_token[-1].col - 1;\n-\n-  /* We don't want a leading # to be interpreted as a directive.  */\n-  pfile->buffer->saved_flags = 0;\n+  cpp_push_buffer (pfile, (uchar *) nbuf, len, /* from_stage3 */ true, 1);\n+  _cpp_clean_line (pfile);\n \n   /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n   pfile->cur_token = _cpp_temp_token (pfile);\n@@ -445,15 +446,10 @@ paste_tokens (pfile, plhs, rhs)\n   if (lhs->type == CPP_DIV && rhs->type != CPP_EQ)\n     *end++ = ' ';\n   end = cpp_spell_token (pfile, rhs, end);\n-  *end = '\\0';\n+  *end = '\\n';\n \n   cpp_push_buffer (pfile, buf, end - buf, /* from_stage3 */ true, 1);\n-\n-  /* Tweak the column number the lexer will report.  */\n-  pfile->buffer->col_adjust = pfile->cur_token[-1].col - 1;\n-\n-  /* We don't want a leading # to be interpreted as a directive.  */\n-  pfile->buffer->saved_flags = 0;\n+  _cpp_clean_line (pfile);\n \n   /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n   pfile->cur_token = _cpp_temp_token (pfile);"}, {"sha": "602711a427ed97c6ccf84473d44433a5e945a82b", "filename": "gcc/cpppch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -708,7 +708,7 @@ cpp_read_state (r, name, f, data)\n \n       if (fread (defn, 1, m.definition_length, f) != m.definition_length)\n \tgoto error;\n-      defn[m.definition_length] = '\\0';\n+      defn[m.definition_length] = '\\n';\n       \n       h = cpp_lookup (r, defn, m.name_length);\n \n@@ -722,6 +722,7 @@ cpp_read_state (r, name, f, data)\n \t\t\t       m.definition_length - m.name_length, \n \t\t\t       true, 1) != NULL)\n \t    {\n+\t      _cpp_clean_line (r);\n \t      if (!_cpp_create_definition (r, h))\n \t\tabort ();\n \t      _cpp_pop_buffer (r);"}, {"sha": "f2f94f6d045752da53ebd25fcdf68843e57eac9b", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 80, "deletions": 173, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -81,14 +81,10 @@ enum ls {ls_none = 0,\t\t/* Normal state.  */\n /* Lexing TODO: Maybe handle space in escaped newlines.  Stop cpplex.c\n    from recognizing comments and directives during its lexing pass.  */\n \n-static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n-static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t   const uchar *));\n static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *,\n \t\t\t\t\t     int));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static const uchar *copy_comment PARAMS ((cpp_reader *, const uchar *, int));\n-static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n@@ -125,43 +121,6 @@ check_output_buffer (pfile, n)\n     }\n }\n \n-/* To be called whenever a newline character is encountered in the\n-   input file, at CUR.  Handles DOS, Mac and Unix ends of line, and\n-   increments pfile->line.\n-\n-   Returns a pointer the character after the newline sequence.  */\n-static const uchar *\n-handle_newline (pfile, cur)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n-{\n-  pfile->line++;\n-  if (cur[0] + cur[1] == '\\r' + '\\n')\n-    cur++;\n-  return cur + 1;\n-}\n-\n-/* CUR points to any character in the current context, not necessarily\n-   a backslash.  Advances CUR until all escaped newlines are skipped,\n-   and returns the new position without updating the context.\n-\n-   Warns if a file buffer ends in an escaped newline.  */\n-static const uchar *\n-skip_escaped_newlines (pfile, cur)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n-{\n-  const uchar *orig_cur = cur;\n-\n-  while (*cur == '\\\\' && is_vspace (cur[1]))\n-    cur = handle_newline (pfile, cur + 1);\n-\n-  if (cur != orig_cur && cur == RLIMIT (pfile->context) && pfile->buffer->inc)\n-    cpp_error (pfile, DL_PEDWARN, \"backslash-newline at end of file\");\n-\n-  return cur;\n-}\n-\n /* CUR points to the asterisk introducing a comment in the current\n    context.  IN_DEFINE is true if we are in the replacement text of a\n    macro.\n@@ -180,43 +139,16 @@ copy_comment (pfile, cur, in_define)\n      const uchar *cur;\n      int in_define;\n {\n+  bool unterminated, copy = false;\n   unsigned int from_line = pfile->line;\n-  const uchar *limit = RLIMIT (pfile->context);\n-  uchar *out = pfile->out.cur;\n-\n-  do\n-    {\n-      unsigned int c = *cur++;\n-      *out++ = c;\n-\n-      if (c == '/')\n-\t{\n-\t  /* An immediate slash does not terminate the comment.  */\n-\t  if (out[-2] == '*' && out - 2 > pfile->out.cur)\n-\t    goto done;\n-\n-\t  if (*cur == '*' && cur[1] != '/'\n-\t      && CPP_OPTION (pfile, warn_comments))\n-\t    cpp_error_with_line (pfile, DL_WARNING, pfile->line, 0,\n-\t\t\t\t \"\\\"/*\\\" within comment\");\n-\t}\n-      else if (is_vspace (c))\n-\t{\n-\t  cur = handle_newline (pfile, cur - 1);\n-\t  /* Canonicalize newline sequences and skip escaped ones.  */\n-\t  if (out[-2] == '\\\\')\n-\t    out -= 2;\n-\t  else\n-\t    out[-1] = '\\n';\n-\t}\n-    }\n-  while (cur < limit);\n+  cpp_buffer *buffer = pfile->buffer;\n \n-  cpp_error_with_line (pfile, DL_ERROR, from_line, 0, \"unterminated comment\");\n-  *out++ = '*';\n-  *out++ = '/';\n+  buffer->cur = cur;\n+  unterminated = _cpp_skip_block_comment (pfile);\n+  if (unterminated)\n+    cpp_error_with_line (pfile, DL_ERROR, from_line, 0,\n+\t\t\t \"unterminated comment\");\n \n- done:\n   /* Comments in directives become spaces so that tokens are properly\n      separated when the ISO preprocessor re-lexes the line.  The\n      exception is #define.  */\n@@ -227,17 +159,29 @@ copy_comment (pfile, cur, in_define)\n \t  if (CPP_OPTION (pfile, discard_comments_in_macro_exp))\n \t    pfile->out.cur--;\n \t  else\n-\t    pfile->out.cur = out;\n+\t    copy = true;\n \t}\n       else\n \tpfile->out.cur[-1] = ' ';\n     }\n   else if (CPP_OPTION (pfile, discard_comments))\n     pfile->out.cur--;\n   else\n-    pfile->out.cur = out;\n+    copy = true;\n \n-  return cur;\n+  if (copy)\n+    {\n+      size_t len = (size_t) (buffer->cur - cur);\n+      memcpy (pfile->out.cur, cur, len);\n+      pfile->out.cur += len;\n+      if (unterminated)\n+\t{\n+\t  *pfile->out.cur++ = '*';\n+\t  *pfile->out.cur++ = '/';\n+\t}\n+    }\n+\n+  return buffer->cur;\n }\n \n /* CUR points to any character in the input buffer.  Skips over all\n@@ -265,31 +209,18 @@ skip_whitespace (pfile, cur, skip_comments)\n       unsigned int c = *cur++;\n       *out++ = c;\n \n-      if (is_nvspace (c) && c)\n+      if (is_nvspace (c))\n \tcontinue;\n \n-      if (!c && cur - 1 != RLIMIT (pfile->context))\n-\tcontinue;\n-\n-      if (c == '/' && skip_comments)\n-\t{\n-\t  const uchar *tmp = skip_escaped_newlines (pfile, cur);\n-\t  if (*tmp == '*')\n-\t    {\n-\t      pfile->out.cur = out;\n-\t      cur = copy_comment (pfile, tmp, false /* in_define */);\n-\t      out = pfile->out.cur;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      out--;\n-      if (c == '\\\\' && is_vspace (*cur))\n+      if (c == '/' && *cur == '*' && skip_comments)\n \t{\n-\t  cur = skip_escaped_newlines (pfile, cur - 1);\n+\t  pfile->out.cur = out;\n+\t  cur = copy_comment (pfile, cur, false /* in_define */);\n+\t  out = pfile->out.cur;\n \t  continue;\n \t}\n \n+      out--;\n       break;\n     }\n \n@@ -310,12 +241,7 @@ lex_identifier (pfile, cur)\n   cpp_hashnode *result;\n \n   do\n-    {\n-      do\n-\t*out++ = *cur++;\n-      while (is_numchar (*cur));\n-      cur = skip_escaped_newlines (pfile, cur);\n-    }\n+    *out++ = *cur++;\n   while (is_numchar (*cur));\n \n   CUR (pfile->context) = cur;\n@@ -340,11 +266,12 @@ _cpp_overlay_buffer (pfile, start, len)\n   pfile->overlaid_buffer = buffer;\n   buffer->saved_cur = buffer->cur;\n   buffer->saved_rlimit = buffer->rlimit;\n+  /* Prevent the ISO lexer from scanning a fresh line.  */\n+  pfile->saved_line = pfile->line--;\n+  buffer->need_line = false;\n \n   buffer->cur = start;\n   buffer->rlimit = start + len;\n-\n-  pfile->saved_line = pfile->line;\n }\n \n /* Restores a buffer overlaid by _cpp_overlay_buffer().  */\n@@ -356,7 +283,9 @@ _cpp_remove_overlay (pfile)\n \n   buffer->cur = buffer->saved_cur;\n   buffer->rlimit = buffer->saved_rlimit;\n+  buffer->need_line = true;\n \n+  pfile->overlaid_buffer = NULL;\n   pfile->line = pfile->saved_line;\n }\n \n@@ -368,24 +297,10 @@ _cpp_read_logical_line_trad (pfile)\n {\n   do\n     {\n-      if (pfile->buffer->cur == pfile->buffer->rlimit)\n-\t{\n-\t  bool stop = true;\n-\n-\t  /* Don't pop the last buffer.  */\n-\t  if (pfile->buffer->prev)\n-\t    {\n-\t      stop = pfile->buffer->return_at_eof;\n-\t      _cpp_pop_buffer (pfile);\n-\t    }\n-\n-\t  if (stop)\n-\t    return false;\n-\t}\n-\n-      scan_out_logical_line (pfile, NULL);\n+      if (pfile->buffer->need_line && !_cpp_get_fresh_line (pfile))\n+\treturn false;\n     }\n-  while (pfile->state.skipping);\n+  while (!scan_out_logical_line (pfile, NULL) || pfile->state.skipping);\n \n   return true;\n }\n@@ -428,11 +343,12 @@ save_argument (macro, offset)\n    If MACRO is non-NULL, then we are scanning the replacement list of\n    MACRO, and we call save_replacement_text() every time we meet an\n    argument.  */\n-static void\n+bool\n scan_out_logical_line (pfile, macro)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n {\n+  bool result = true;\n   cpp_context *context;\n   const uchar *cur;\n   uchar *out;\n@@ -443,7 +359,6 @@ scan_out_logical_line (pfile, macro)\n \n   fmacro.buff = NULL;\n \n- start_logical_line:\n   quote = 0;\n   header_ok = pfile->state.angled_headers;\n   CUR (pfile->context) = pfile->buffer->cur;\n@@ -458,6 +373,12 @@ scan_out_logical_line (pfile, macro)\n \n   for (;;)\n     {\n+      if (!context->prev\n+\t  && cur >= pfile->buffer->notes[pfile->buffer->cur_note].pos)\n+\t{\n+\t  pfile->buffer->cur = cur;\n+\t  _cpp_process_line_notes (pfile, false);\n+\t}\n       c = *cur++;\n       *out++ = c;\n \n@@ -469,12 +390,10 @@ scan_out_logical_line (pfile, macro)\n \tcase '\\t':\n \tcase '\\f':\n \tcase '\\v':\n-\t  continue;\n-\n \tcase '\\0':\n-\t  if (cur - 1 != RLIMIT (context))\n-\t    continue;\n+\t  continue;\n \n+\tcase '\\n':\n \t  /* If this is a macro's expansion, pop it.  */\n \t  if (context->prev)\n \t    {\n@@ -483,22 +402,21 @@ scan_out_logical_line (pfile, macro)\n \t      goto new_context;\n \t    }\n \n-\t  /* Premature end of file.  Fake a new line.  */\n-\t  cur--;\n-\t  if (!pfile->buffer->from_stage3)\n-\t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n+\t  /* Omit the newline from the output buffer.  */\n+\t  pfile->out.cur = out - 1;\n+\t  pfile->buffer->cur = cur;\n+\t  pfile->buffer->need_line = true;\n \t  pfile->line++;\n-\t  goto done;\n \n-\tcase '\\r': case '\\n':\n-\t  cur = handle_newline (pfile, cur - 1);\n \t  if ((lex_state == ls_fun_open || lex_state == ls_fun_close)\n-\t      && !pfile->state.in_directive)\n+\t      && !pfile->state.in_directive\n+\t      && _cpp_get_fresh_line (pfile))\n \t    {\n \t      /* Newlines in arguments become a space, but we don't\n \t\t clear any in-progress quote.  */\n \t      if (lex_state == ls_fun_close)\n \t\tout[-1] = ' ';\n+\t      cur = pfile->buffer->cur;\n \t      continue;\n \t    }\n \t  goto done;\n@@ -521,35 +439,20 @@ scan_out_logical_line (pfile, macro)\n \t  break;\n \n \tcase '\\\\':\n-\t  if (is_vspace (*cur))\n-\t    {\n-\t      out--;\n-\t      cur = skip_escaped_newlines (pfile, cur - 1);\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Skip escaped quotes here, it's easier than above, but\n-\t\t take care to first skip escaped newlines.  */\n-\t      cur = skip_escaped_newlines (pfile, cur);\n-\t      if (*cur == '\\\\' || *cur == '\"' || *cur == '\\'')\n-\t\t*out++ = *cur++;\n-\t    }\n+\t  /* Skip escaped quotes here, it's easier than above.  */\n+\t  if (*cur == '\\\\' || *cur == '\"' || *cur == '\\'')\n+\t    *out++ = *cur++;\n \t  break;\n \n \tcase '/':\n \t  /* Traditional CPP does not recognize comments within\n \t     literals.  */\n-\t  if (!quote)\n+\t  if (!quote && *cur == '*')\n \t    {\n-\t      cur = skip_escaped_newlines (pfile, cur);\n-\t      if (*cur == '*')\n-\t\t{\n-\t\t  pfile->out.cur = out;\n-\t\t  cur = copy_comment (pfile, cur, macro != 0);\n-\t\t  out = pfile->out.cur;\n-\t\t  continue;\n-\t\t}\n+\t      pfile->out.cur = out;\n+\t      cur = copy_comment (pfile, cur, macro != 0);\n+\t      out = pfile->out.cur;\n+\t      continue;\n \t    }\n \t  break;\n \n@@ -699,12 +602,14 @@ scan_out_logical_line (pfile, macro)\n \t      cur = skip_whitespace (pfile, cur, true /* skip_comments */);\n \t      out = pfile->out.cur;\n \n-\t      if (is_vspace (*cur))\n+\t      if (*cur == '\\n')\n \t\t{\n \t\t  /* Null directive.  Ignore it and don't invalidate\n \t\t     the MI optimization.  */\n-\t\t  out = pfile->out.base;\n-\t\t  continue;\n+\t\t  pfile->buffer->need_line = true;\n+\t\t  pfile->line++;\n+\t\t  result = false;\n+\t\t  goto done;\n \t\t}\n \t      else\n \t\t{\n@@ -724,9 +629,8 @@ scan_out_logical_line (pfile, macro)\n \t\t\t preprocessor lex the next token.  */\n \t\t      pfile->buffer->cur = cur;\n \t\t      _cpp_handle_directive (pfile, false /* indented */);\n-\t\t      /* #include changes pfile->buffer so we need to\n-\t\t\t update the limits of the current context.  */\n-\t\t      goto start_logical_line;\n+\t\t      result = false;\n+\t\t      goto done;\n \t\t    }\n \t\t}\n \t    }\n@@ -765,16 +669,14 @@ scan_out_logical_line (pfile, macro)\n     }\n \n  done:\n-  out[-1] = '\\0';\n-  pfile->buffer->cur = cur;\n-  pfile->out.cur = out - 1;\n   if (fmacro.buff)\n     _cpp_release_buff (pfile, fmacro.buff);\n \n   if (lex_state == ls_fun_close)\n     cpp_error_with_line (pfile, DL_ERROR, fmacro.line, 0,\n \t\t\t \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t\t NODE_NAME (fmacro.node));\n+  return result;\n }\n \n /* Push a context holding the replacement text of the macro NODE on\n@@ -787,11 +689,16 @@ push_replacement_text (pfile, node)\n {\n   size_t len;\n   const uchar *text;\n+  uchar *buf;\n \n   if (node->flags & NODE_BUILTIN)\n     {\n       text = _cpp_builtin_macro_text (pfile, node);\n       len = ustrlen (text);\n+      buf = _cpp_unaligned_alloc (pfile, len + 1);\n+      memcpy (buf, text, len);\n+      buf[len]='\\n';\n+      text = buf;\n     }\n   else\n     {\n@@ -944,7 +851,7 @@ replace_args_and_push (pfile, fmacro)\n \t  exp += BLOCK_LEN (b->text_len);\n \t}\n \n-      /* Allocate room for the expansion plus NUL.  */\n+      /* Allocate room for the expansion plus \\n.  */\n       buff = _cpp_get_buff (pfile, len + 1);\n \n       /* Copy the expansion and replace arguments.  */\n@@ -966,8 +873,8 @@ replace_args_and_push (pfile, fmacro)\n \t  exp += BLOCK_LEN (b->text_len);\n \t}\n \n-      /* NUL-terminate.  */\n-      *p = '\\0';\n+      /* \\n-terminate.  */\n+      *p = '\\n';\n       _cpp_push_text_context (pfile, fmacro->node, BUFF_FRONT (buff), len);\n \n       /* So we free buffer allocation when macro is left.  */\n@@ -1034,10 +941,10 @@ save_replacement_text (pfile, macro, arg_index)\n   if (macro->paramc == 0)\n     {\n       /* Object-like and function-like macros without parameters\n-\t simply store their NUL-terminated replacement text.  */\n+\t simply store their \\n-terminated replacement text.  */\n       exp = _cpp_unaligned_alloc (pfile, len + 1);\n       memcpy (exp, pfile->out.base, len);\n-      exp[len] = '\\0';\n+      exp[len] = '\\n';\n       macro->exp.text = exp;\n       macro->count = len;\n     }"}, {"sha": "f76cbd146a036e6c3518d0f88d75bb53d8628cfe", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -692,7 +692,7 @@ read_scan_file (in_fname, argc, argv)\n   if (special_file_handling == stdio_h\n       && (fn = lookup_std_proto (\"_filbuf\", 7)) != NULL)\n     {\n-      static const unsigned char getchar_call[] = \"getchar();\";\n+      unsigned char getchar_call[] = \"getchar();\\n\";\n       int seen_filbuf = 0;\n \n       /* Scan the macro expansion of \"getchar();\".  */"}, {"sha": "fc71e0cf9c389f05c6c72c3e836470ef97d346c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -1,3 +1,8 @@\n+2003-04-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* gcc.dg/cpp/_Pragma4.c: Remove stray space.\n+\t* gcc.dg/cpp/trad/escaped-eof.c: Correct line number.\n+\n 2003-04-18  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.c-torture/compile/20030418-1.c: New test."}, {"sha": "5c86b02c710cfbde5acdee177b56a2a28371fe31", "filename": "gcc/testsuite/gcc.dg/cpp/_Pragma4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F_Pragma4.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -7,6 +7,6 @@ a b c\n \n /*\n    { dg-final { if ![file exists _Pragma4.i] { return }                   } }\n-   { dg-final { if { [grep _Pragma4.i \"#pragma bar \"] != \"\" } { return }  } }\n+   { dg-final { if { [grep _Pragma4.i \"#pragma bar\"] != \"\" }  { return }  } }\n    { dg-final { fail \"_Pragma4.c: #pragma appearing on its own line\"      } }\n */"}, {"sha": "2c9c185b1d2022511db56b97eb0af80d71577dd9", "filename": "gcc/testsuite/gcc.dg/cpp/trad/escaped-eof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fescaped-eof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aea0737b2d0c4ee328d547555ae25ab5de9a0a/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fescaped-eof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fescaped-eof.c?ref=26aea0737b2d0c4ee328d547555ae25ab5de9a0a", "patch": "@@ -2,5 +2,5 @@\n \n /* { dg-do preprocess } */\n \n-/* { dg-warning \"backslash-new\" \"escaped EOF warning\" { target *-*-* } 7 } */\n+/* { dg-warning \"backslash-new\" \"escaped EOF warning\" { target *-*-* } 6 } */\n \\"}]}