{"sha": "519e9fdfbac069a01dc359975b50028acc7b0c65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5ZTlmZGZiYWMwNjlhMDFkYzM1OTk3NWI1MDAyOGFjYzdiMGM2NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-14T12:39:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-14T12:39:11Z"}, "message": "[multiple changes]\n\n2016-06-14  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_A_Call): Do nothing if the callee is\n\t(or is in) an instance, and the caller is outside.  Misc cleanup.\n\n2016-06-14  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Quantified_Expression):\n\tGenerating C code avoid spurious warning on loop variable of\n\tinlinined postconditions.\n\nFrom-SVN: r237438", "tree": {"sha": "1fb2911c836fb268a03419df52276af6a0e1cec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb2911c836fb268a03419df52276af6a0e1cec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/519e9fdfbac069a01dc359975b50028acc7b0c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519e9fdfbac069a01dc359975b50028acc7b0c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519e9fdfbac069a01dc359975b50028acc7b0c65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519e9fdfbac069a01dc359975b50028acc7b0c65/comments", "author": null, "committer": null, "parents": [{"sha": "64f5d139b90646f4852d167c859f6678fc74a244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f5d139b90646f4852d167c859f6678fc74a244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f5d139b90646f4852d167c859f6678fc74a244"}], "stats": {"total": 140, "additions": 96, "deletions": 44}, "files": [{"sha": "ef70ce53fd6ec4ad1bd9417eb7e96088cc81adcc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=519e9fdfbac069a01dc359975b50028acc7b0c65", "patch": "@@ -1,3 +1,14 @@\n+2016-06-14  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_A_Call): Do nothing if the callee is\n+\t(or is in) an instance, and the caller is outside.  Misc cleanup.\n+\n+2016-06-14  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Quantified_Expression):\n+\tGenerating C code avoid spurious warning on loop variable of\n+\tinlinined postconditions.\n+\n 2016-06-14  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_attr.adb (Analyze_Attribute_Old_Result): Adding assertion."}, {"sha": "edcfee226d50d5602f247fdb53022ef649351664", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=519e9fdfbac069a01dc359975b50028acc7b0c65", "patch": "@@ -3917,7 +3917,16 @@ package body Sem_Ch4 is\n       if Warn_On_Suspicious_Contract\n         and then not Referenced (Loop_Id, Cond)\n       then\n-         Error_Msg_N (\"?T?unused variable &\", Loop_Id);\n+         --  Generating C this check causes spurious warnings on inlined\n+         --  postconditions; we can safely disable it because this check\n+         --  was previously performed when analying the internally built\n+         --  postconditions procedure.\n+\n+         if Modify_Tree_For_C and then In_Inlined_Body then\n+            null;\n+         else\n+            Error_Msg_N (\"?T?unused variable &\", Loop_Id);\n+         end if;\n       end if;\n \n       --  Diagnose a possible misuse of the SOME existential quantifier. When"}, {"sha": "27fed6f0a477d8259919f01fc5bc502cf3fef6c1", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 75, "deletions": 43, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519e9fdfbac069a01dc359975b50028acc7b0c65/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=519e9fdfbac069a01dc359975b50028acc7b0c65", "patch": "@@ -516,11 +516,11 @@ package body Sem_Elab is\n       Access_Case : constant Boolean := Nkind (N) = N_Attribute_Reference;\n       --  Indicates if we have Access attribute case\n \n-      Variable_Case : constant Boolean :=\n-                        Nkind (N) in N_Has_Entity\n-                          and then Present (Entity (N))\n-                          and then Ekind (Entity (N)) = E_Variable;\n-      --  Indicates if we have variable reference case\n+      function Call_To_Instance_From_Outside\n+        (Ent : Entity_Id) return Boolean;\n+      --  True if we're calling an instance of a generic subprogram, or a\n+      --  subprogram in an instance of a generic package, and the call is\n+      --  outside that instance.\n \n       procedure Elab_Warning\n         (Msg_D : String;\n@@ -531,6 +531,36 @@ package body Sem_Elab is\n        --  warning (output if Msg_D is non-null and Elab_Warnings is set),\n        --  Msg_S is an info message (output if Elab_Info_Messages is set.\n \n+      function Find_W_Scope return Entity_Id;\n+      --  Find top level scope for called entity (not following renamings\n+      --  or derivations). This is where the Elaborate_All will go if it is\n+      --  needed. We start with the called entity, except in the case of an\n+      --  initialization procedure outside the current package, where the init\n+      --  proc is in the root package, and we start from the entity of the name\n+      --  in the call.\n+\n+      -----------------------------------\n+      -- Call_To_Instance_From_Outside --\n+      -----------------------------------\n+\n+      function Call_To_Instance_From_Outside\n+        (Ent : Entity_Id) return Boolean is\n+\n+         X : Entity_Id := Ent;\n+      begin\n+         loop\n+            if X = Standard_Standard then\n+               return False;\n+            end if;\n+\n+            if Is_Generic_Instance (X) then\n+               return not In_Open_Scopes (X);\n+            end if;\n+\n+            X := Scope (X);\n+         end loop;\n+      end Call_To_Instance_From_Outside;\n+\n       ------------------\n       -- Elab_Warning --\n       ------------------\n@@ -565,7 +595,38 @@ package body Sem_Elab is\n          end if;\n       end Elab_Warning;\n \n-      --  Local variables\n+      ------------------\n+      -- Find_W_Scope --\n+      ------------------\n+\n+      function Find_W_Scope return Entity_Id is\n+         Refed_Ent : constant Entity_Id := Get_Referenced_Ent (N);\n+         W_Scope   : Entity_Id;\n+      begin\n+         if Is_Init_Proc (Refed_Ent)\n+           and then not In_Same_Extended_Unit (N, Refed_Ent)\n+         then\n+            W_Scope := Scope (Refed_Ent);\n+         else\n+            W_Scope := E;\n+         end if;\n+\n+         --  Now loop through scopes to get to the enclosing compilation unit\n+\n+         while not Is_Compilation_Unit (W_Scope) loop\n+            W_Scope := Scope (W_Scope);\n+         end loop;\n+\n+         return W_Scope;\n+      end Find_W_Scope;\n+\n+      --  Locals\n+\n+      Variable_Case : constant Boolean :=\n+                        Nkind (N) in N_Has_Entity\n+                          and then Present (Entity (N))\n+                          and then Ekind (Entity (N)) = E_Variable;\n+      --  Indicates if we have variable reference case\n \n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -605,7 +666,7 @@ package body Sem_Elab is\n       Issue_In_SPARK : Boolean;\n       --  Flag set when a source entity is called during elaboration in SPARK\n \n-      W_Scope : Entity_Id;\n+      W_Scope : constant Entity_Id := Find_W_Scope;\n       --  Top level scope of directly called entity for subprogram. This\n       --  differs from E_Scope in the case where renamings or derivations\n       --  are involved, since it does not follow these links. W_Scope is\n@@ -717,17 +778,11 @@ package body Sem_Elab is\n            and then (Is_Child_Unit (E_Scope)\n                       or else Scope (E_Scope) = Standard_Standard);\n \n-         --  If we did not find a compilation unit, other than standard,\n-         --  then nothing to check (happens in some instantiation cases)\n-\n-         if E_Scope = Standard_Standard then\n-            return;\n+         pragma Assert (E_Scope /= Standard_Standard);\n \n-         --  Otherwise move up a scope looking for compilation unit\n+         --  Move up a scope looking for compilation unit\n \n-         else\n-            E_Scope := Scope (E_Scope);\n-         end if;\n+         E_Scope := Scope (E_Scope);\n       end loop;\n \n       --  No checks needed for pure or preelaborated compilation units\n@@ -755,29 +810,6 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Find top level scope for called entity (not following renamings\n-      --  or derivations). This is where the Elaborate_All will go if it is\n-      --  needed. We start with the called entity, except in the case of an\n-      --  initialization procedure outside the current package, where the init\n-      --  proc is in the root package, and we start from the entity of the name\n-      --  in the call.\n-\n-      declare\n-         Ent : constant Entity_Id := Get_Referenced_Ent (N);\n-      begin\n-         if Is_Init_Proc (Ent) and then not In_Same_Extended_Unit (N, Ent) then\n-            W_Scope := Scope (Ent);\n-         else\n-            W_Scope := E;\n-         end if;\n-      end;\n-\n-      --  Now loop through scopes to get to the enclosing compilation unit\n-\n-      while not Is_Compilation_Unit (W_Scope) loop\n-         W_Scope := Scope (W_Scope);\n-      end loop;\n-\n       --  Case of entity is in same unit as call or instantiation. In the\n       --  instantiation case, W_Scope may be different from E_Scope; we want\n       --  the unit in which the instantiation occurs, since we're analyzing\n@@ -806,11 +838,11 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Nothing to do for a generic instance, because in this case the\n-      --  checking was at the point of instantiation of the generic However,\n-      --  this shortcut is only applicable in static mode.\n+      --  Nothing to do for a generic instance, because a call to an instance\n+      --  cannot fail the elaboration check, because the body of the instance\n+      --  is always elaborated immediately after the spec.\n \n-      if Is_Generic_Instance (Ent) and not Dynamic_Elaboration_Checks then\n+      if Call_To_Instance_From_Outside (Ent) then\n          return;\n       end if;\n "}]}