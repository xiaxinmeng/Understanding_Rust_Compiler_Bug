{"sha": "f90b7a5a7913cc7239cce42f6ca328b9a741b387", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwYjdhNWE3OTEzY2M3MjM5Y2NlNDJmNmNhMzI4YjlhNzQxYjM4Nw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-12T09:43:48Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-12T09:43:48Z"}, "message": "Merge cond-optab branch.\n\nFrom-SVN: r147425", "tree": {"sha": "06c940a96a184a178bfadd53e04213225655a68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06c940a96a184a178bfadd53e04213225655a68d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90b7a5a7913cc7239cce42f6ca328b9a741b387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90b7a5a7913cc7239cce42f6ca328b9a741b387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90b7a5a7913cc7239cce42f6ca328b9a741b387", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90b7a5a7913cc7239cce42f6ca328b9a741b387/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7a0af68063c79655c561750e9863799bf846cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a0af68063c79655c561750e9863799bf846cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7a0af68063c79655c561750e9863799bf846cae"}], "stats": {"total": 15375, "additions": 5040, "deletions": 10335}, "files": [{"sha": "cbe7b3097e1b79f52806d370c772215a9e23974c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1,3 +1,570 @@\n+2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * dojump.c (compare_from_rtx): Delete.\n+        * expmed.c (emit_store_flag): Only try cstore_optab.  Canonicalize\n+        any MODE_CC mode to the cstorecc4 pattern.  Use prepare_operand, fail\n+\tif the comparison does not satisfy the predicate; test predicates for\n+\toperands 2 and 3 of a cstore pattern.  Don't try cstore optab\n+\tfurther if one existing pattern fails.\n+        * expr.h (compare_from_rtx): Delete.\n+\t(prepare_operand): Declare it.\n+        * optabs.c: Change \"lib call\" to \"libcall\" throughout.\n+\t(bcc_gen_fctn, setcc_gen_code, trap_rtx,\n+        HAVE_conditional_trap, emit_cmp_insn): Delete.\n+        (can_compare_p): Delete cmp_optab case.\n+\t(prepare_float_lib_cmp): Return an rtx and a machine mode.\n+        Accept other parameters by value.\n+        (prepare_operand): Make non-static.\n+        (prepare_cmp_insn): Return an rtx and a machine mode.  Accept\n+        other parameters by value.  Try to widen operands here based on\n+        an optab_methods argument and looking at cbranch_optab.\n+        (emit_cmp_and_jump_insn_1): Accept test and mode, remove widening loop.\n+\tUse cbranch_optab directly.\n+        (emit_cmp_and_jump_insns): Fix comment.  Adjust call to prepare_cmp_insn\n+\tand emit_cmp_and_jump_insn_1, remove obsolete assertion.\n+        (emit_conditional_move, emit_conditional_add): Inline what's needed\n+        of compare_from_rtx, using new prepare_cmp_insn for the rest.\n+        (init_optabs): Init cmp_optab with UNKNOWN, cbranch_optab\n+        with COMPARE.  Move cmov_optab and cstore_optab above\n+        with cbranch_optab, move cmp_optab down with ucmp_optab,\n+        remove tst_otpab.  Do not initialize trap_rtx.\n+        (gen_cond_trap): Do it here.  Use ctrap_optab.  Test predicate\n+\tfor trap code.  Do not check HAVE_conditional_trap.  Use\n+\tprepare_cmp_insn.  Accept no predicate for operand 3.\n+        * optabs.h (OTI_cmp): Mark as used only for libcalls.\n+        (OTI_ctrap, ctrap_optab): New.\n+        (tst_optab): Delete.\n+        (bcc_gen_fctn, setcc_gen_code, emit_cmp_insn): Delete.\n+        * ifcvt.c (find_if_header): Replace HAVE_conditional_trap\n+        with lookup of ctrap_optab.\n+        * genopinit.c (cmp_optab, tst_optab, bcc_gen_fctn,\n+        setcc_gen_code): Delete.\n+        (ctrap_optab): New.\n+\n+        * combine.c (combine_simplify_rtx, simplify_set): Do not\n+        special case comparing against zero for cc0 machines.\n+\t* simplify-rtx.c (simplify_binary_operation_1): Never remove\n+\tCOMPARE on cc0 machines.\n+\t(simplify_relational_operation): Return a new expression when\n+\ta COMPARE could be removed.\n+        * final.c (final_scan_insn): Compare cc_status values\n+        against LHS of a (compare FOO (const_int 0)) cc0 source.\n+        Also check if cc_status.value is the full compare.\n+\n+        * doc/md.texi (bCC, sCC, tstMM, cmpMM): Delete.\n+        (cstoreMM4): Document.\n+\t(conditional_trap): Document ctrapMM4 instead.\n+        (sync_compare_and_swapMM): Refer to cbranchcc4.\n+\t(Dependent Patterns): Eliminate obsolete information referring to\n+\tthe old jump optimization phase.\n+        (Canonicalization): Include cbranchcc4 case, omit canonicalization\n+\tof compares with 0 on cc0 machines.\n+\t(Jump Patterns): Refer to MODE_CC jump patterns preferably,\n+\tavoiding references to cc0.  Remove text about storing operands\n+\tin cmpMM.\n+\t* doc/tm.texi (Condition Codes): Include blurb on different\n+\tcondition code representations, separate into subsections for\n+\tCC0, MODE_CC and conditional execution.\n+\n+        * config/alpha/alpha-protos.h (alpha_emit_conditional_branch,\n+        alpha_emit_setcc): Accept operands and a machine mode.\n+        * config/alpha/alpha.c (alpha_emit_conditional_branch):\n+        Get code/op0/op1 from operands, use machine mode argument\n+        instead of alpha_compare.fp_p.  Emit the branch here.\n+        (alpha_emit_setcc): Likewise, and return boolean.\n+        (alpha_emit_conditional_move): Likewise.  Assert that\n+        cmp_op_mode == cmp_mode, and simplify accordingly.\n+        * config/alpha/alpha.h (struct alpha_compare, alpha_compare): Delete.\n+        * config/alpha/alpha.md (cmpdf, cmptf, cmpdi, bCC, sCC): Delete.\n+        (cbranchdf4, cbranchtf4, cbranchdi4, cstoredf4, cstoretf4,\n+        cstoredi4): Delete.\n+        (stack probe test): Use cbranchdi4.\n+        * config/alpha/predicates.md (alpha_cbranch_operator): New.\n+\n+        * config/arc/arc.c (gen_compare_reg): Do not emit cmp. \n+        * config/arc/arc.h (movsicc, movsfcc): Use it.\n+        (movdicc, *movdicc_insn, movdfcc, *movdfcc_insn): Remove.\n+        (cbranchsi4, cstoresi4): New.\n+        (cmpsi, bCC and sCC expanders): Remove. \n+\n+        * config/arm/arm.c (arm_compare_op0, arm_compare_op1): Delete.\n+        * config/arm/arm.h (arm_compare_op0, arm_compare_op1): Delete.\n+        * config/arm/predicates.md (arm_comparison_operator): Only include\n+        floating-point operators if there is a hardware floating-point unit.\n+        * config/arm/arm.md (cbranchsi4, cstoresi4): Enable for TARGET_32BIT,\n+        deferring to cbranch_cc and cstore_cc respectively.\n+        (cbranchsf4, cbranchdf4, cbranchdi4, cstoresf4, cstoredf4, cstoredi4,\n+        cbranch_cc, cstore_cc): New.\n+        (movsicc, movsfcc, movdfcc): Do not use arm_compare_op0 and\n+\tarm_compare_op1.\n+        (bCC, sCC, cmpsi, cmpsf, cmpdf, cmpdi): Delete.\n+\n+        * config/avr/avr-protos.h (out_tstsi, out_tsthi): Adjust prototype.\n+        * config/avr/avr.c (out_tstsi, out_tsthi): Get the tested operand\n+        as an argument.\n+        (adjust_insn_length): Adjust calls.\n+        (avr_reorg): Handle (compare (foo) (const_int 0)).\n+        * config/avr/avr.md (tstqi, tsthi, tstsi): Remove.\n+        (*negated_tstqi, *negated_tsthi, *negated_tstsi): Unmacroize.\n+        (*reversed_tsthi, *reversed_tstsi): Add a scratch for simplicity.\n+        (cmpqi, cmphi, cmpsi): Prepend asterisk, fuse tst[qhs]i here.\n+        (bCC): Remove.\n+        (cbranchqi4, cbranchhi4, cbranchsi4): New.\n+\t(tst -> sbrc/sbrs peephole2, cpse peephole): Wrap RHS with COMPARE.\n+\n+        * config/bfin/bfin.md (cmpbi, cmpsi, bCC, sCC): Delete.\n+        (cbranchsi4, cstorebi4, cstoresi4): New.\n+\t(movbisi): This insn is duplicate, split it to zero_extend.\n+        * config/bfin/bfin.c (bfin_compare_op0, bfin_compare_op1): Delete\n+        (bfin_gen_compare): Do not use them.  Emit VOIDmode SET, not BImode.\n+        (bfin_optimize_loop): Use cbranch expander.\n+        * config/bfin/bfin.h (bfin_compare_op0, bfin_compare_op1): Delete.\n+        * config/bfin/predicates.md (bfin_cbranch_operator): Rename to...\n+        (bfin_bimode_comparison_operator): ... this.\n+        (bfin_direct_comparison_operator): New.\n+ \n+        * config/cris/cris.c (cris_normal_notice_update_cc): Look\n+        inside (compare FOO (const_int 0)).\n+        (cris_rtx_costs): Handle ZERO_EXTRACT.\n+        * config/cris/cris.md (tstdi, tst<mode>, cmpdi): Delete.\n+        (*tstdi_non_v32): Fold in *cmpdi_non_v32.\n+        (*tstdi_v32): Delete.\n+        (*cmpdi_non_v32): Add M alternative for operand 1.\n+        (cmpsi, cmp<mode>): Make private.\n+        (*tstsi, *tst<mode>_cmp, *tst<mode>_non_cmp, *btst): Wrap\n+        LHS with COMPARE.\n+        (cbranch<mode>4, cbranchdi4, cstore<mode>4): New.\n+\n+        * config/crx/crx.md (cstore<mode>4, cbranchcc4): New.\n+        (cmp<mode>, bCOND_internal, b<code>, s<code>): Delete.\n+        (cbranch<mode>4, sCOND_internal): Use ordered_comparison_operator.\n+\t(cc_reg_operand): New.\n+\t(any_cond): Delete.\n+        * config/crx/crx.c (crx_compare_op0, crx_compare_op1,\n+        crx_expand_compare, crx_expand_branch, crx_expand_scond): Delete.\n+        * config/crx/crx.h (crx_compare_op0, crx_compare_op1): Delete.\n+        * config/crx/crx-protos.h (crx_expand_compare, crx_expand_branch,\n+        crx_expand_scond): Delete.\n+\n+        * config/fr30/fr30.md (cmp<mode>, bCC): Delete.\n+        (cbranchsi4): New.\n+        * config/fr30/fr30.c (fr30_compare_op0, fr30_compare_op1): Delete\n+        * config/fr30/fr30.h (fr30_compare_op0, fr30_compare_op1): Delete.\n+\n+        * config/frv/frv.md (cbranchsi4, cbranchsf4, cbranchdf4,\n+        cstoresi4, cstoresf4, cstoredf4): New.\n+        (cmpdi, cmpsi, cmpsf, cmpdf, bCC, sCC): Remove.\n+        * config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n+        Receive the entire operands array.\n+        * config/frv/frv.h (frv_compare_op0,\n+        frv_compare_op1): Delete.\n+        * config/frv/frv.c (frv_compare_op0,\n+        frv_compare_op1): Delete.\n+        * config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n+        Get test/op0/op1 from the operands array.\n+        (frv_emit_cond_move): Get test/op0/op1 from the test_rtx.\n+\n+        * config/h8300/h8300-protos.h (h8300_expand_branch): Accept operands.\n+        (h8300_expand_store): New.\n+        * config/h8300/h8300.c (h8300_rtx_costs): Handle (compare FOO\n+        (const_int 0)).\n+        (h8300_expand_branch): Emit compare here.  Adjust for new arguments.\n+        (h8300_expand_store): New.\n+        * config/h8300/h8300.md (btst combine patterns): Wrap with COMPARE\n+        or do not try to produce (set (cc0) REG).\n+        (peepholes): Wrap arguments with COMPARE.  Add a peephole to\n+        change a compare into a move to a scratch register.  Disable some\n+        peepholes when comparing with zero.\n+        (tstsi, tsthi, tstsi, cmpqi): Make private.\n+        (cmphi): Delete.\n+        (bCC, sCC): Delete.\n+        (cbranchqi4, cbranchhi4, cbranchsi4, cstoreqi4, cstorehi4,\n+        cstoresi4): New.\n+\n+\t* config/i386/i386.c (ix86_expand_int_movcc, ix86_expand_int_addcc,\n+\tix86_expand_fp_movcc): Set ix86_compare_op0 and ix86_compare_op1.\n+\t(ix86_emit_i387_log1p): Use gen_cbranchxf4.\n+\t(ix86_emit_i387_log1p): Use cbranchxf2.\n+\t(ix86_expand_setcc): Return void.\n+\t* config/i386/i386-protos.h (ix86_expand_setcc): Return void.\n+\t* config/i386/i386.md (cmpti, cmpdi, cmpsi, cmphi, cmpqi, cmpxf,\n+\tcmp<MODEF>, cmpcc): Remove.\n+\t(cbranchti4, cbranchdi4, cbranchsi4, cbranchhi4, cbranchqi4, cbranchxf4,\n+\tcbranch<MODEF>4, cbranchcc4, cstoredi4, cstoresi4, cstorehi4,\n+\tcstoreqi4, cstorexf4, cstore<MODEF>4, cstorecc): New.\n+\t(sCC and bCC expanders): Remove.\n+\t(stack_protect_test): Use cbranchcc4.\n+\n+        * config/ia64/ia64-protos.h (ia64_compare_op0, ia64_compare_op1):\n+        Delete.\n+        (ia64_expand_compare): Accept three rtx by reference and return void.\n+        * config/ia64/ia64.c (ia64_compare_op0, ia64_compare_op1): Delete.\n+        (ia64_expand_compare): Replace op0/op1 with *op0/*op1.  Get code\n+        from *expr.  Update *expr with the BImode comparison to do.\n+        * config/ia64/ia64.md (cmpbi, cmpsi, cmpdi, cmpsf, cmpdf, cmpxf,\n+        cmptf, bCC, sCC, conditional_trap): Delete.\n+        (cbranchbi4, cbranchsi4, cbranchdi4, cbranchsf4, cbranchdf4, \n+        cbranchxf4, cbranchtf4, cstorebi4, cstoresi4, cstoredi4, cstoresf4,\n+        cstoredf4, cstorexf4, cstoretf4, ctrapbi4, ctrapsi4, ctrapdi4,\n+        ctrapsf4, ctrapdf4, ctrapxf4, ctraptf4): New.\n+        * config/ia64/predicates.md (ia64_cbranch_operator): New.\n+\n+        * config/iq2000/iq2000-protos.h (gen_conditional_branch): Change\n+        type of last argument.\n+        * config/iq2000/iq2000.c (branch_cmp, branch_type): Remove.\n+        (gen_conditional_branch): Get code/cmp0/cmp1 from operands,\n+        use machine mode argument instead of branch_type.  Remove dead\n+        code for floating-point comparisons.\n+        * config/iq2000/iq2000.h (branch_cmp, branch_type): Remove.\n+        * config/iq2000/iq2000.md (cmpsi, cmpdi, cmpsf, cmpdf, tstsi,\n+        bCC): Remove.\n+        (cbranchsi4, cstoresi4): New.\n+        * config/iq2000/predicates.md (reg_or_const_operand): New.\n+\n+        * config/m32c/m32c.md (cbranch splitter): Use match_op_dup.\n+        * config/m32c/m32c.md (any_cond, gl_cond): Delete.\n+        (b<code>_op): Rewrite to...\n+        (bcc_op): ... this, using match_operator.\n+        (s<code>_op): Rewrite to...\n+        (scc_op): ... this, using match_operator.\n+        (s<code>_24_op): Rewrite to...\n+        (scc_op_24): ... this, using match_operator.\n+        (s<code>_<mode>): Rewrite to...\n+        (cstore<mode>4): ... this, using match_operator.\n+        (s<code>_<mode>_24): Rewrite to...\n+        (cstore<mode>4_24): ... this, using match_operator.\n+        * config/m32c/m32c-protos.h (m32c_cmp_flg_0, m32c_pend_compare,\n+        m32c_unpend_compare, m32c_expand_scc): Delete.\n+        * config/m32c/m32c.c (compare_op0, compare_op1, m32c_cmp_flg_0,\n+        m32c_pend_compare, m32c_unpend_compare, m32c_expand_scc): Delete.\n+        (m32c_expand_movcc): Change NE to EQ if necessary.\n+        (m32c_init_libfuncs): Modify cstore optab instead of setcc_gen_code.\n+\n+        * config/m32r/m32r-protos.h (gen_cond_store): New.\n+        * config/m32r/m32r.c (m32r_compare_op0, m32r_compare_op1): Delete.\n+        (gen_cond_store): New, from sCC patterns.\n+        (m32r_expand_block_move): Use cbranchsi4.\n+        * config/m32r/m32r.h (m32r_compare_op0, m32r_compare_op1): Delete.\n+        * config/m32r/m32r.md (cmpsi, bCC, sCC): Delete.\n+        (cbranchsi4, cstoresi4): New.\n+        \n+        * config/m68hc11/m68hc11.c (m68hc11_compare_op0, m68hc11_compare_op1):\n+        Delete.\n+        (m68hc11_rtx_costs_1, m68hc11_rtx_costs): Handle ZERO_EXTRACT.\n+\t(m68hc11_notice_update_cc): Look into a compare with 0.\n+        * config/m68hc11/m68hc11.h (m68hc11_compare_op0, m68hc11_compare_op1):\n+        Delete.\n+        * config/m68hc11/m68hc11.md (tstsi, tsthi, tstqi, cmpsi,\n+        cmphi, cmpqi, bCC): Delete.\n+        (cbranchsi4, cbranchhi4, cbranchqi4): New.\n+        (tstqi_1, tstqi_z_used, tstqi_1, bitcmpqi, bitcmpqi_z_used,\n+        bitcmpqi_12, bitcmphi, various splits and peephole2s): Wrap cc0<-reg\n+        sets with COMPARE.\n+\n+        * config/m68k/predicates.md (m68k_cstore_comparison_operator,\n+        const0_operand, const1_operand, m68k_subword_comparison_operand): New.\n+        * config/m68k/constraints.md (H): New.\n+        * config/m68k/m68k.md (tstdi): Remove define_expand, use name for\n+        the define_insn below.\n+        (tstsi, tsthi, tst<FP:mode>, cmphi, cmpqi, cmp<FP:mode>): Delete.\n+        (*tstsi_internal_68020_cf, *tstsi_internal, *tsthi_internal,\n+        *tstqi_internal, tst<mode>_6881, tst<mode>_cf, many unnamed\n+        patterns): Wrap RHS with COMPARE.\n+        (tst<FP>_68881, tst<FP>_cf): Use const0_operand.\n+        (*cmpdi_internal): Name this pattern.\n+        (cmpdi): Change to define_insn.\n+        (cbranchdi4, cstoredi4, cbranchsi4, cstoresi4, cbranchhi4, cstorehi4,\n+        cbranchqi4, cstoreqi4, cbranch<FP:mode>4, cstore<FP:mode>4): New.\n+        (scc0_di, scc0_di_5200, scc_di): Use the ordered_comparison_operator\n+        predicate.\n+        (seq, sne, sgt, sgtu, slt, sltu, sge, sgeu, sle, sleu, sordered,\n+        sunordered, suneq, sunge, sungt, sunle, sunlt, sltgt): Delete\n+        (conditional_trap): Change to...\n+        (ctrapdi4, ctrapsi4, ctraphi4, ctrapqi4): ... these.\n+        (*conditional_trap): Use the ordered_comparison_operator and\n+        const1_operand predicates.\n+        * config/m68k/m68k.c (m68k_last_compare_had_fp_operands): Delete.\n+        (m68k_expand_prologue): Use ctrapsi4 instead of cmpsi+conditional_trap.\n+        (m68k_rtx_costs): Look for ZERO_EXTRACT in a COMPARE.\n+        * config/m68k/m68k.h (m68k_last_compare_had_fp_operands): Delete.\n+\n+        * config/mcore/mcore-protos.h (arch_compare_op0, arch_compare_op1,\n+        mcore_modify_comparison, mcore_gen_compare_reg): Remove.\n+        (mcore_gen_compare): New. \n+        * config/mcore/mcore.c (arch_compare_op0, arch_compare_op1): Delete.\n+        (mcore_modify_comparison, mcore_gen_compare_reg): Fold into...\n+        (mcore_gen_compare): ... this.\n+        * config/mcore/mcore.md (cmpsi, bCC, sCC): Remove.\n+        (cbranchsi4, cstoresi4): New, using mcore_gen_compare.\n+        (stack probe pattern): Use cbranchsi4.\n+\n+        * config/mips/predicates.md (mips_cstore_operator): New.\n+        * config/mips/mips-ps-3d.md (movv2sfcc): Do not use cmp_operands.\n+        * config/mips/mips.md (any_cond): Delete.\n+        (conditional_trap): Rename to ctrap<GPR:mode>4.  Adjust predicates,\n+        always succeed.\n+        (fixuns_truncdfsi2, fixuns_truncdfdi2, fixuns_truncsfsi2,\n+        fixuns_truncsfdi2): Use cbranch patterns.\n+        (cmp<GPR:mode>, cmp<SCALARF:mode>): Delete. \n+        (b<code>): Change to cbranch<GPR:mode>4 and cbranch<SCALARF:mode>4.\n+        Adjust call to mips_expand_conditional_branch.\n+        (seq, sne, slt<u>, sle<u>, sgt<u>, sge<u>): Change to cstore<GPR:mode>4.\n+        * config/mips/mips-protos.h (mips_expand_conditional_branch,\n+        mips_expand_scc, mips_expand_conditional_trap): Adjust prototypes.\n+        * config/mips/mips.c (cmp_operands): Delete.\n+        (mips_emit_compare): Get comparison operands from *op0/*op1.\n+        (mips_expand_scc): Get code/op0/op1/target from operands.  Assert\n+        that it succeeds.  Use op0/op1 instead of cmp_operands.\n+        (mips_expand_conditional_branch, mips_expand_conditional_move,\n+        mips_expand_conditional_trap): Likewise.\n+        (mips_block_move_loop): Use cbranch patterns. \n+        * config/mips/mips.h (cmp_operands): Delete.\n+\n+        * config/mmix/mmix.c (mmix_valid_comparison): Delete.\n+        (mmix_gen_compare_reg): Just return a register in the right CC mode.\n+        * config/mmix/mmix.h (mmix_compare_op0, mmix_compare_op1): New.\n+        * config/mmix/mmix.md (cmpdi, cmpdf): Remove.\n+        (*cmpcc_folded): Rename to...\n+        (*cmpdi_folded): this.\n+        (*cmpcc): Rename to...\n+        (*cmps): ... this.\n+        (movdfcc, movdicc): Adjust for new semantics of mmix_gen_compare_reg.\n+        (bCC): Remove.\n+        (cbranchdi4): New.\n+        (cbranchdf4): New.  Handle invalid comparisons here.\n+        * config/mmix/predicates.md (float_comparison_operator): New.\n+\n+        * config/mn10300/mn10300.c (mn10300_rtx_costs): Consider 0 and\n+        zero_extract to be cheap in (compare (zero_extract) (const_int 0).\n+        * config/mn10300/mn10300.md (tst): Delete.\n+        (*tst_extqisi_am33, *tst_extqisi, *tst_exthisi_am33, *tst_exthisi):\n+        Name these patterns and wrap RHS in a compare.\n+        (*cmpsi): Make this pattern private.  Include tst.\n+        (*cmpsf): Make this pattern private.\n+        (and and zero_extract cc0 set): Wrap RHS in a COMPARE.\n+        (compare with zero peepholes): Likewise.\n+        (bCC): Remove.\n+        (cbranchsi4, cbranchsf4): New.\n+        (casesi): Use cbranchsi4.\n+\n+        * config/pa/pa.c (hppa_compare_op0, hppa_compare_op1,\n+        hppa_branch_type): Delete.\n+        (return_addr_rtx): Use cbranchsi4.\n+        (emit_bcond_fp): Accept all operands.  Replace CODE with NE.\n+        Emit CCFPmode comparison here.\n+        (gen_cmp_fp): Delete, now part of emit_bcond_fp.\n+        * config/pa/pa.h (enum cmp_type, hppa_compare_op0, hppa_compare_op1,\n+        hppa_branch_type): Delete.\n+        * config/pa/pa.md (cmpdi, cmpsi, cmpsf, cmpdf, sCC, bCC): Delete.\n+        (movsicc, movdicc): Remove references to hppa_compare_op0,\n+        hppa_compare_op1 and compare_from_rtx.\n+        (cbranchdi4, cbranchsi4, cbranchsf4, cbranchdf4, cstoresi4): New.\n+        (casesi): Use cbranchsi4.\n+\n+        * config/pdp11/pdp11-protos.h (output_jump): Change prototype.\n+        * config/pdp11/pdp11.c (output_jump): Embed opcodes here.\n+        * config/pdp11/pdp11.md (register_or_const0_operand): New.\n+        (cmpdf, cmphi, cmpqi): Make private.  Add tst alternatives.\n+        (cmpsi, tstsi, tstdf, tsthi, tstqi): Delete.\n+        (bCC): Delete.\n+        (cbranchdf4, cbranchhi4, cbranchqi4): New.\n+        (*branch, *branch_inverted): New.\n+\n+        * config/picochip/picochip.md (cbranchhi4): Use\n+        ordered_comparison_operator.\n+        (cmphi, bCC): Remove.\n+\n+        * config/rs6000/predicates.md (rs6000_cbranch_operator): New.\n+        (trap_comparison_operator): Delete.\n+        * config/rs6000/rs6000-protos.h (rs6000_emit_sCOND,\n+        rs6000_emit_cbranch): Accept mode and operands.\n+        * config/rs6000/rs6000.c (rs6000_compare_op0, rs6000_compare_op1,\n+        rs6000_compare_fp_p): Delete.   \n+        (rs6000_generate_compare): Accept mode and comparison.  Extract code\n+        and op0/op1 from there.  Replace references to rs6000_compare_op0\n+        and rs6000_compare_op1.\n+        (rs6000_emit_sCOND): Adjust call to rs6000_generate_compare and\n+        extract result from passed operands.\n+        (rs6000_emit_cbranch): Adjust call to rs6000_generate_compare and\n+        extract loc from passed operands.\n+        (rs6000_emit_cmove): Likewise.\n+        * config/rs6000/rs6000.h (rs6000_compare_op0, rs6000_compare_op1,\n+        rs6000_compare_fp_p): Delete.\n+        * config/rs6000/rs6000.md (cmp<GPR>, cmp<FP>, bCC, sCC): Delete.\n+        (cbranch<GPR>4, cbranch<FP>4): New.\n+        (cstore<mode>4): New.  Consolidate here all choices about when to use\n+        portable or specialized sCC sequences.\n+        (stack_protect_test): Use cbranchsi4.\n+        (conditional_trap): Replace with ctrap<GPR>4.\n+        (conditional trap insn): Replace trap_comparison_operator with\n+        ordered_comparison_operator. \n+\n+        * config/s390/s390.c (s390_compare_op0, s390_compare_op1): Delete.\n+        (s390_emit_prologue): Use ctrap.\n+        * config/s390/s390.h (s390_compare_op0, s390_compare_op1): Delete.\n+        * config/s390/predicates.md (s390_eqne_operator, s390_scond_operator):\n+        New predicates replacing...\n+        * config/s390/s390.md (COMPARE, SCOND): ... these iterators.\n+        (cmp<GPR>, cmp<FP>, cmpcc): Delete.\n+        (trunc patterns): Use emit_cmp_and_jump_insns instead of cmp/branch.\n+        (add<mode>cc): Do not use s390_compare_op0/op1.\n+        (s<code>): Change to...\n+        (cstore<mode>4): ... this. Do not use s390_compare_op0/op1.\n+        (seq): Change to...\n+        (cstorecc4): ... this.  Handle EQ or NE equally.\n+        (*sne): Un-privatize for use in cstorecc4.\n+        (b<code>): Change to...\n+        (cbranch<GPR>4, cbranch<FP>4, cbranchcc4): ... these.\n+        (conditional_trap): Replace with...\n+        (ctrap<GPR>4, ctrap<FP>4): ... these.\n+        (stack_protect): Use cbranchcc4.\n+\n+        * config/score/score-conv.h (cmp_op0, cmp_op1): Delete.\n+        * config/score/score-protos.h (score_gen_cmp): Delete.\n+        * config/score/score.c (cmp_op0, cmp_op1, score_gen_cmp): Delete.\n+        (score_block_move-loop): Use cbranchsi4.\n+        * config/score/score.md (cbranchsi4): New.\n+        (cmpsi, bCC): Delete.\n+        * config/score/score3.c (cmp_op0, cmp_op1, score3_gen_cmp): Delete.\n+        (score3_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n+        * config/score/score7.c (cmp_op0, cmp_op1, score7_gen_cmp): Delete.\n+        (score7_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n+        * config/score/score3.h (score3_gen_cmp): Delete.\n+        * config/score/score7.h (score7_gen_cmp): Delete.\n+\n+        * config/sh/sh-protos.h (prepare_scc_operands): Rename to...\n+        (sh_emit_scc_to_t): ... this.  Return void.\n+        (from_compare): Rename to...\n+        (sh_emit_compare_and_branch): ... this.\n+        (sh_emit_compare_and_set): New.\n+        (sh_expand_t_scc): Accept operands.\n+        * config/sh/predicates.md (sh_float_comparison_operator): New.\n+        * config/sh/sh.c (sh_compare_op0, sh_compare_op1): Delete.\n+        (prepare_scc_operands): Rename to...\n+        (sh_emit_scc_to_t): ... this.  Return void.  Get op0/op1 from arguments.\n+        (sh_emit_cheap_store_flag): New.\n+\t(sh_emit_set_t_insn): New.\n+        (from_compare): Rename to...\n+        (sh_emit_compare_and_branch): ... this.  Accept mode.  Rewrite\n+        handling of TARGET_SH2E floating point to avoid recursive call.\n+        Generate branch here.\n+        (sh_emit_compare_and_set): New.\n+        (sh_expand_t_scc): Get op0/op1 from arguments.\n+        (sh_emit_cheap_store_flag): New.\n+        * config/sh/sh.md (cbranchdi4, cbranchsi4): Include -mno-cbranchdi\n+        cases.\n+\t(cbranchdi4_i): Use an \"I08\" constraint instead of an \"i\" constraint.\n+        (cmpsi, cmpdi, cmpsf, cmpdf): Delete.\n+        (movsicc, movdicc): Do nothing when it recreated operands from\n+        sh_compare_*. Use sh_emit_cheap_store_flag.  Adjust call to\n+        prepare_scc_operands (now sh_emit_scc_to_t).\n+        (udivdi3): Use cstoresi4.\n+        (beq_media, bne_media, bge_media, bgtu_media, bgeu_media, beq,\n+        bne, bgt, blt, ble, bge, bgtu, bltu, bgeu, bleu, bunordered):\n+        Delete.\n+        (cbranchint4_media, cbranchfp4_media): New.\n+        (casesi): Use cbranchdi4.\n+        (seq, slt, sle, sgt, sge, sgtu, sltu, sgeu, sne, sleu, sunordered):\n+        Delete.\n+        (cstore4_media, cstoresi4, cstoredi4, cstoresf4, cstoredf4): New.\n+        (movnegt): Remove second operand.\n+        (cbranchsf4, cbranchdf4): New.\n+        (stack_protect): Use cbranchdi4/cbranchsi4.\n+\n+        * config/sparc/sparc.c (sparc_compare_op0, sparc_compare_op1): Delete.\n+        (gen_compare_reg): Accept comparison, extract part of it to...\n+        (gen_compare_reg_1): ... this. \n+        (gen_compare_operator): Delete.\n+        (gen_v9_scc): Accept separate destination, comparison code and arms.\n+        Do not use sparc_compare_op0/sparc_compare_op1.\n+        (emit_scc_insn, emit_conditional_branch_insn): New.\n+        (emit_v9_brxx): Make static.  Remove useless assertion.\n+        (sparc_emit_float_lib_cmp): Return RTL instead of calling emit_cmp_insn.\n+        (sparc_expand_compare_and_swap_12): Use gen_compare_reg_1+cbranchcc4.\n+        * config/sparc/sparc-protos.h (gen_compare_reg,\n+\tsparc_emit_float_lib_cmp): Adjust prototype.\n+\t(emit_scc_insn, emit_conditional_branch_insn): New.\n+\t(gen_v9_scc, emit_v9_brxx_insn, gen_compare_operator): Delete.\n+        * config/sparc/sparc.h (sparc_compare_op0, sparc_compare_op1): Delete.\n+        * config/sparc/sparc.md (P, I, F, V32, V32I, V64, V64I): Move all\n+        iterators to the top.\n+        (cmpsi, cmpdi, cmpsf, cmpdf, cmptf, seqsi_special_extend,\n+        snesi_special_extend, sCC, bCC, seqdi_special_trunc,\n+\tsnedi_special_trunc): Delete.\n+ \t(seqdi_special, snedi_special): Use expansion of seqdi_special_trunc\n+\tand snedi_special_trunc.\n+        (cstoresi4, cstoredi4, cstore<F:mode>4, cbranchcc4, cbranchsi4,\n+        cbranchdi4, cbranch<F:mode>4): New.\n+        (mov<I:mode>cc, mov<F:mode>cc): Handle sparc_emit_float_lib_cmp\n+        here.  Use gen_compare_reg instead of gen_compare_operator.\n+        (conditional_trap): Replace with...\n+        (ctrapsi4, ctrapdi4): ... this.\n+        (stack_protect_test): Use cbranchcc4.\n+\n+        * config/spu/spu-protos.h (spu_emit_branch_or_set): Change second\n+        argument to rtx.\n+        * config/spu/spu.c (spu_compare_op0, spu_compare_op1): Remove. \n+        (spu_emit_branch_or_set): Get code/op0/op1 from second argument.\n+        Change spu_compare_op0/op1 to op0/op1 throughout.  Get target\n+        from operands[0] or operands[3] depending on is_set.\n+        * config/spu/spu.h (spu_compare_op0, spu_compare_op1): Remove.\n+        * config/spu/spu.md (cmp<mode:VQHSI>, cmp<mode:DTI>, cmp<mode:VSF>,\n+        cmpdf, bCC), sCC: Remove.\n+        (cbranch<mode:VQHSI>4, cbranch<mode:DTI>, cbranch<mode:VSF>4, \n+        cbranchdf4, cstore<mode:VQHSI>4, cstore<mode:DTI>, cstore<mode:VSF>4,\n+        cstoredf4): New.\n+        (mov<mode>cc): Accept ordered_comparison_operator, adjust call to\n+        spu_emit_branch_or_set.\n+\n+        * config/stormy16/stormy16-protos.h (xstormy16_emit_cbranch):\n+        Add two arguments.\n+        * config/stormy16/stormy16.h (xstormy16_compare_op0,\n+        xstormy16_compare_op1): Delete.\n+        * config/stormy16/stormy16.c (xstormy16_compare_op0,\n+        xstormy16_compare_op1): Delete. \n+        (xstormy16_emit_cbranch): Get op0/op1 from the new arguments.\n+        Adjust calls.\n+        * config/stormy16/stormy16.md (cbranchsi4, cbranchhi4): New.\n+        (cmphi, cmpsi, bCC): Remove.\n+\n+        * config/v850/v850.md (tstsi, cmpsi): Fold into...\n+        (*cmpsi): ... this one.\n+        (cbranchsi4, cstoresi4): New.\n+        (bCC expanders): Delete.\n+        (sCC insns): Fold into...\n+        (*setcc): ... this one.\n+        (casesi): Do not use gen_cmpsi and gen_bgtu. \n+\t(various splits): Wrap \"naked\" RHS of a cc0 set with COMPARE.\n+\t(movsicc): Simplify.\n+\t* config/v850/v850.c (v850_rtx_costs): Handle ZERO_EXTRACT in COMPARE.\n+\n+        * config/vax/vax-protos.h (cond_name): New.\n+        (vax_output_conditional_branch): Remove.\n+        * config/vax/vax.c (cond_name): New.\n+        (vax_output_conditional_branch): Remove.\n+        * config/vax/vax.h (PRINT_OPERAND): Dispatch %c to cond_name.\n+        * config/vax/vax.md (tst<VAXint>, tst<VAXfp>): Remove.\n+        (cmp<VAXint>, cmp<VAXfp>): Privatize.  Add constraints for tst.\n+        (bit<VAXint>): Wrap source with (compare).\n+        (b<code> and following unnamed pattern): Rename to *branch and\n+        *branch_reversed.  Change macroization to match_operator.\n+        (cbranch<VAXint>4, cbranch<VAXfp>4): New.\n+\n+        * config/xtensa/predicates.md (xtensa_cstoresi_operator): New.\n+        * config/xtensa/xtensa-protos.h (xtensa_expand_conditional_branch):\n+        Change last argument to machine_mode.\n+        (xtensa_expand_scc): Add machine_mode argument.\n+        * config/xtensa/xtensa.c (branch_cmp, branch_type): Remove.\n+        (gen_conditional_move, xtensa_expand_conditional_branch,\n+        xtensa_expand_scc, xtensa_expand_conditional_move): Use mode\n+        instead of branch_type, fetch cmp0/cmp1/test_code from operands[].\n+        Adjust operand numbers.\n+        * config/xtensa/xtensa.h (enum cmp_type, branch_cmp, branch_type):\n+        Delete.\n+        * config/xtensa/xtensa.md (any_cond, any_scc): Delete.\n+        (cmpsi, cmpsf, b<code>, s<code>): Delete.\n+        (cbranchsi4, cbranchsf4, cstoresi4, cstoresf4): New.\n+\n 2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* optabs.c (prepare_cmp_insn): Temporarily disable test that"}, {"sha": "7cdf396a66cda166869815ded24e063a5b5a31ab", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -4906,24 +4906,6 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \treturn gen_lowpart (mode, XEXP (x, 0));\n       break;\n \n-#ifdef HAVE_cc0\n-    case COMPARE:\n-      /* Convert (compare FOO (const_int 0)) to FOO unless we aren't\n-\t using cc0, in which case we want to leave it as a COMPARE\n-\t so we can distinguish it from a register-register-copy.  */\n-      if (XEXP (x, 1) == const0_rtx)\n-\treturn XEXP (x, 0);\n-\n-      /* x - 0 is the same as x unless x's mode has signed zeros and\n-\t allows rounding towards -infinity.  Under those conditions,\n-\t 0 - 0 is -0.  */\n-      if (!(HONOR_SIGNED_ZEROS (GET_MODE (XEXP (x, 0)))\n-\t    && HONOR_SIGN_DEPENDENT_ROUNDING (GET_MODE (XEXP (x, 0))))\n-\t  && XEXP (x, 1) == CONST0_RTX (GET_MODE (XEXP (x, 0))))\n-\treturn XEXP (x, 0);\n-      break;\n-#endif\n-\n     case CONST:\n       /* (const (const X)) can become (const X).  Do it this way rather than\n \t returning the inner CONST since CONST can be shared with a\n@@ -5758,17 +5740,6 @@ simplify_set (rtx x)\n       if (other_changed)\n \tundobuf.other_insn = other_insn;\n \n-#ifdef HAVE_cc0\n-      /* If we are now comparing against zero, change our source if\n-\t needed.  If we do not use cc0, we always have a COMPARE.  */\n-      if (op1 == const0_rtx && dest == cc0_rtx)\n-\t{\n-\t  SUBST (SET_SRC (x), op0);\n-\t  src = op0;\n-\t}\n-      else\n-#endif\n-\n       /* Otherwise, if we didn't previously have a COMPARE in the\n \t correct mode, we need one.  */\n       if (GET_CODE (src) != COMPARE || GET_MODE (src) != compare_mode)"}, {"sha": "7a12d498246875767ad8f0af7f04e7973eab1356", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -88,8 +88,8 @@ extern int check_float_value (enum machine_mode, REAL_VALUE_TYPE *, int);\n #endif\n \n #ifdef RTX_CODE\n-extern rtx alpha_emit_conditional_branch (enum rtx_code);\n-extern rtx alpha_emit_setcc (enum rtx_code);\n+extern void alpha_emit_conditional_branch (rtx[], enum machine_mode);\n+extern bool alpha_emit_setcc (rtx[], enum machine_mode);\n extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);"}, {"sha": "512599d098277f33802a43d2f77feb0ebcac684e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -81,11 +81,6 @@ enum alpha_fp_rounding_mode alpha_fprm;\n \n enum alpha_fp_trap_mode alpha_fptm;\n \n-/* Save information from a \"cmpxx\" operation until the branch or scc is\n-   emitted.  */\n-\n-struct alpha_compare alpha_compare;\n-\n /* Nonzero if inside of a function, because the Alpha asm can't\n    handle .files inside of functions.  */\n \n@@ -2424,19 +2419,20 @@ alpha_emit_floatuns (rtx operands[2])\n \n /* Generate the comparison for a conditional branch.  */\n \n-rtx\n-alpha_emit_conditional_branch (enum rtx_code code)\n+void\n+alpha_emit_conditional_branch (rtx operands[], enum machine_mode cmp_mode)\n {\n   enum rtx_code cmp_code, branch_code;\n-  enum machine_mode cmp_mode, branch_mode = VOIDmode;\n-  rtx op0 = alpha_compare.op0, op1 = alpha_compare.op1;\n+  enum machine_mode branch_mode = VOIDmode;\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx op0 = operands[1], op1 = operands[2];\n   rtx tem;\n \n-  if (alpha_compare.fp_p && GET_MODE (op0) == TFmode)\n+  if (cmp_mode == TFmode)\n     {\n       op0 = alpha_emit_xfloating_compare (&code, op0, op1);\n       op1 = const0_rtx;\n-      alpha_compare.fp_p = 0;\n+      cmp_mode = DImode;\n     }\n \n   /* The general case: fold the comparison code to the types of compares\n@@ -2457,7 +2453,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \n     case GE:  case GT: case GEU:  case GTU:\n       /* For FP, we swap them, for INT, we reverse them.  */\n-      if (alpha_compare.fp_p)\n+      if (cmp_mode == DFmode)\n \t{\n \t  cmp_code = swap_condition (code);\n \t  branch_code = NE;\n@@ -2474,9 +2470,8 @@ alpha_emit_conditional_branch (enum rtx_code code)\n       gcc_unreachable ();\n     }\n \n-  if (alpha_compare.fp_p)\n+  if (cmp_mode == DFmode)\n     {\n-      cmp_mode = DFmode;\n       if (flag_unsafe_math_optimizations && cmp_code != UNORDERED)\n \t{\n \t  /* When we are not as concerned about non-finite values, and we\n@@ -2501,8 +2496,6 @@ alpha_emit_conditional_branch (enum rtx_code code)\n     }\n   else\n     {\n-      cmp_mode = DImode;\n-\n       /* The following optimizations are only for signed compares.  */\n       if (code != LEU && code != LTU && code != GEU && code != GTU)\n \t{\n@@ -2544,36 +2537,38 @@ alpha_emit_conditional_branch (enum rtx_code code)\n       emit_move_insn (tem, gen_rtx_fmt_ee (cmp_code, cmp_mode, op0, op1));\n     }\n \n-  /* Zero the operands.  */\n-  memset (&alpha_compare, 0, sizeof (alpha_compare));\n-\n-  /* Return the branch comparison.  */\n-  return gen_rtx_fmt_ee (branch_code, branch_mode, tem, CONST0_RTX (cmp_mode));\n+  /* Emit the branch instruction.  */\n+  tem = gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t     gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t   gen_rtx_fmt_ee (branch_code,\n+\t\t\t\t\t\t\t   branch_mode, tem,\n+\t\t\t\t\t\t\t   CONST0_RTX (cmp_mode)),\n+\t\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t      operands[3]),\n+\t\t\t\t\t   pc_rtx));\n+  emit_jump_insn (tem);\n }\n \n /* Certain simplifications can be done to make invalid setcc operations\n    valid.  Return the final comparison, or NULL if we can't work.  */\n \n-rtx\n-alpha_emit_setcc (enum rtx_code code)\n+bool\n+alpha_emit_setcc (rtx operands[], enum machine_mode cmp_mode)\n {\n   enum rtx_code cmp_code;\n-  rtx op0 = alpha_compare.op0, op1 = alpha_compare.op1;\n-  int fp_p = alpha_compare.fp_p;\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = operands[2], op1 = operands[3];\n   rtx tmp;\n \n-  /* Zero the operands.  */\n-  memset (&alpha_compare, 0, sizeof (alpha_compare));\n-\n-  if (fp_p && GET_MODE (op0) == TFmode)\n+  if (cmp_mode == TFmode)\n     {\n       op0 = alpha_emit_xfloating_compare (&code, op0, op1);\n       op1 = const0_rtx;\n-      fp_p = 0;\n+      cmp_mode = DImode;\n     }\n \n-  if (fp_p && !TARGET_FIX)\n-    return NULL_RTX;\n+  if (cmp_mode == DFmode && !TARGET_FIX)\n+    return 0;\n \n   /* The general case: fold the comparison code to the types of compares\n      that we have, choosing the branch as necessary.  */\n@@ -2584,12 +2579,12 @@ alpha_emit_setcc (enum rtx_code code)\n     case EQ:  case LE:  case LT:  case LEU:  case LTU:\n     case UNORDERED:\n       /* We have these compares.  */\n-      if (fp_p)\n+      if (cmp_mode == DFmode)\n \tcmp_code = code, code = NE;\n       break;\n \n     case NE:\n-      if (!fp_p && op1 == const0_rtx)\n+      if (cmp_mode == DImode && op1 == const0_rtx)\n \tbreak;\n       /* FALLTHRU */\n \n@@ -2601,10 +2596,10 @@ alpha_emit_setcc (enum rtx_code code)\n     case GE:  case GT: case GEU:  case GTU:\n       /* These normally need swapping, but for integer zero we have\n \t special patterns that recognize swapped operands.  */\n-      if (!fp_p && op1 == const0_rtx)\n+      if (cmp_mode == DImode && op1 == const0_rtx)\n \tbreak;\n       code = swap_condition (code);\n-      if (fp_p)\n+      if (cmp_mode == DFmode)\n \tcmp_code = code, code = NE;\n       tmp = op0, op0 = op1, op1 = tmp;\n       break;\n@@ -2613,7 +2608,7 @@ alpha_emit_setcc (enum rtx_code code)\n       gcc_unreachable ();\n     }\n \n-  if (!fp_p)\n+  if (cmp_mode == DImode)\n     {\n       if (!register_operand (op0, DImode))\n \top0 = force_reg (DImode, op0);\n@@ -2624,18 +2619,18 @@ alpha_emit_setcc (enum rtx_code code)\n   /* Emit an initial compare instruction, if necessary.  */\n   if (cmp_code != UNKNOWN)\n     {\n-      enum machine_mode mode = fp_p ? DFmode : DImode;\n-\n-      tmp = gen_reg_rtx (mode);\n+      tmp = gen_reg_rtx (cmp_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, tmp,\n-\t\t\t      gen_rtx_fmt_ee (cmp_code, mode, op0, op1)));\n+\t\t\t      gen_rtx_fmt_ee (cmp_code, cmp_mode, op0, op1)));\n \n-      op0 = fp_p ? gen_lowpart (DImode, tmp) : tmp;\n+      op0 = cmp_mode == DImode ? gen_lowpart (DImode, tmp) : tmp;\n       op1 = const0_rtx;\n     }\n \n-  /* Return the setcc comparison.  */\n-  return gen_rtx_fmt_ee (code, DImode, op0, op1);\n+  /* Emit the setcc instruction.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_fmt_ee (code, DImode, op0, op1)));\n+  return true;\n }\n \n \n@@ -2651,20 +2646,17 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (cmp);\n   enum rtx_code cmov_code = NE;\n-  rtx op0 = alpha_compare.op0;\n-  rtx op1 = alpha_compare.op1;\n-  int fp_p = alpha_compare.fp_p;\n+  rtx op0 = XEXP (cmp, 0);\n+  rtx op1 = XEXP (cmp, 1);\n   enum machine_mode cmp_mode\n     = (GET_MODE (op0) == VOIDmode ? DImode : GET_MODE (op0));\n-  enum machine_mode cmp_op_mode = fp_p ? DFmode : DImode;\n   enum machine_mode cmov_mode = VOIDmode;\n   int local_fast_math = flag_unsafe_math_optimizations;\n   rtx tem;\n \n-  /* Zero the operands.  */\n-  memset (&alpha_compare, 0, sizeof (alpha_compare));\n+  gcc_assert (cmp_mode == DFmode || cmp_mode == DImode);\n \n-  if (fp_p != FLOAT_MODE_P (mode))\n+  if (FLOAT_MODE_P (cmp_mode) != FLOAT_MODE_P (mode))\n     {\n       enum rtx_code cmp_code;\n \n@@ -2691,7 +2683,7 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n \tcase GE: case GT: case GEU: case GTU:\n \t  /* These normally need swapping, but for integer zero we have\n \t     special patterns that recognize swapped operands.  */\n-\t  if (!fp_p && op1 == const0_rtx)\n+\t  if (cmp_mode == DImode && op1 == const0_rtx)\n \t    cmp_code = code, code = NE;\n \t  else\n \t    {\n@@ -2705,22 +2697,21 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n \t  gcc_unreachable ();\n \t}\n \n-      tem = gen_reg_rtx (cmp_op_mode);\n+      tem = gen_reg_rtx (cmp_mode);\n       emit_insn (gen_rtx_SET (VOIDmode, tem,\n-\t\t\t      gen_rtx_fmt_ee (cmp_code, cmp_op_mode,\n+\t\t\t      gen_rtx_fmt_ee (cmp_code, cmp_mode,\n \t\t\t\t\t      op0, op1)));\n \n-      cmp_mode = cmp_op_mode = fp_p ? DImode : DFmode;\n-      op0 = gen_lowpart (cmp_op_mode, tem);\n-      op1 = CONST0_RTX (cmp_op_mode);\n-      fp_p = !fp_p;\n+      cmp_mode = cmp_mode == DImode ? DFmode : DImode;\n+      op0 = gen_lowpart (cmp_mode, tem);\n+      op1 = CONST0_RTX (cmp_mode);\n       local_fast_math = 1;\n     }\n \n   /* We may be able to use a conditional move directly.\n      This avoids emitting spurious compares.  */\n   if (signed_comparison_operator (cmp, VOIDmode)\n-      && (!fp_p || local_fast_math)\n+      && (cmp_mode == DImode || local_fast_math)\n       && (op0 == CONST0_RTX (cmp_mode) || op1 == CONST0_RTX (cmp_mode)))\n     return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n \n@@ -2757,7 +2748,7 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n       gcc_unreachable ();\n     }\n \n-  if (!fp_p)\n+  if (cmp_mode == DImode)\n     {\n       if (!reg_or_0_operand (op0, DImode))\n \top0 = force_reg (DImode, op0);\n@@ -2768,12 +2759,12 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n   /* ??? We mark the branch mode to be CCmode to prevent the compare\n      and cmov from being combined, since the compare insn follows IEEE\n      rules that the cmov does not.  */\n-  if (fp_p && !local_fast_math)\n+  if (cmp_mode == DFmode && !local_fast_math)\n     cmov_mode = CCmode;\n \n-  tem = gen_reg_rtx (cmp_op_mode);\n-  emit_move_insn (tem, gen_rtx_fmt_ee (code, cmp_op_mode, op0, op1));\n-  return gen_rtx_fmt_ee (cmov_code, cmov_mode, tem, CONST0_RTX (cmp_op_mode));\n+  tem = gen_reg_rtx (cmp_mode);\n+  emit_move_insn (tem, gen_rtx_fmt_ee (code, cmp_mode, op0, op1));\n+  return gen_rtx_fmt_ee (cmov_code, cmov_mode, tem, CONST0_RTX (cmp_mode));\n }\n \n /* Simplify a conditional move of two constants into a setcc with"}, {"sha": "ed9bd747f390b671df5ea823d898182f64e5fbaf", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -803,24 +803,6 @@ extern int alpha_memory_latency;\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n   function_arg((CUM), (MODE), (TYPE), (NAMED))\n \n-/* Try to output insns to set TARGET equal to the constant C if it can be\n-   done in less than N insns.  Do all computations in MODE.  Returns the place\n-   where the output has been placed if it can be done and the insns have been\n-   emitted.  If it would take more than N insns, zero is returned and no\n-   insns and emitted.  */\n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-struct alpha_compare\n-{\n-  struct rtx_def *op0, *op1;\n-  int fp_p;\n-};\n-\n-extern struct alpha_compare alpha_compare;\n-\n /* Make (or fake) .linkage entry for function call.\n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n "}, {"sha": "e6a05780bba501d0696293d381a6cb00ba339b24", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 43, "deletions": 196, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -3963,206 +3963,53 @@\n ;; These are the main define_expand's used to make conditional branches\n ;; and compares.\n \n-(define_expand \"cmpdf\"\n-  [(set (cc0) (compare (match_operand:DF 0 \"reg_or_0_operand\" \"\")\n-\t\t       (match_operand:DF 1 \"reg_or_0_operand\" \"\")))]\n+(define_expand \"cbranchdf4\"\n+  [(use (match_operator 0 \"alpha_cbranch_operator\"\n+         [(match_operand:DF 1 \"reg_or_0_operand\" \"\")\n+          (match_operand:DF 2 \"reg_or_0_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"TARGET_FP\"\n-{\n-  alpha_compare.op0 = operands[0];\n-  alpha_compare.op1 = operands[1];\n-  alpha_compare.fp_p = 1;\n-  DONE;\n-})\n+  { alpha_emit_conditional_branch (operands, DFmode); DONE; })\n \n-(define_expand \"cmptf\"\n-  [(set (cc0) (compare (match_operand:TF 0 \"general_operand\" \"\")\n-\t\t       (match_operand:TF 1 \"general_operand\" \"\")))]\n+(define_expand \"cbranchtf4\"\n+  [(use (match_operator 0 \"alpha_cbranch_operator\"\n+         [(match_operand:TF 1 \"general_operand\")\n+          (match_operand:TF 2 \"general_operand\")]))\n+   (use (match_operand 3 \"\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-{\n-  alpha_compare.op0 = operands[0];\n-  alpha_compare.op1 = operands[1];\n-  alpha_compare.fp_p = 1;\n-  DONE;\n-})\n-\n-(define_expand \"cmpdi\"\n-  [(set (cc0) (compare (match_operand:DI 0 \"some_operand\" \"\")\n-\t\t       (match_operand:DI 1 \"some_operand\" \"\")))]\n-  \"\"\n-{\n-  alpha_compare.op0 = operands[0];\n-  alpha_compare.op1 = operands[1];\n-  alpha_compare.fp_p = 0;\n-  DONE;\n-})\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (EQ); }\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (NE); }\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (LT); }\")\n+  { alpha_emit_conditional_branch (operands, TFmode); DONE; })\n \n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (LE); }\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchdi4\"\n+  [(use (match_operator 0 \"alpha_cbranch_operator\"\n+         [(match_operand:DI 1 \"some_operand\")\n+          (match_operand:DI 2 \"some_operand\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (GT); }\")\n+  { alpha_emit_conditional_branch (operands, DImode); DONE; })\n \n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (GE); }\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (LTU); }\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (LEU); }\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (GTU); }\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (GEU); }\")\n-\n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (UNORDERED); }\")\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{ operands[1] = alpha_emit_conditional_branch (ORDERED); }\")\n-\n-(define_expand \"seq\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (EQ)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (NE)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (LT)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (LE)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (GT)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (GE)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (LTU)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (LEU)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (GTU)) == NULL_RTX) FAIL; }\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (GEU)) == NULL_RTX) FAIL; }\")\n+(define_expand \"cstoredf4\"\n+  [(use (match_operator:DI 1 \"alpha_cbranch_operator\"\n+         [(match_operand:DF 2 \"reg_or_0_operand\")\n+          (match_operand:DF 3 \"reg_or_0_operand\")]))\n+   (clobber (match_operand:DI 0 \"register_operand\"))]\n+  \"TARGET_FP\"\n+  { if (!alpha_emit_setcc (operands, DFmode)) FAIL; else DONE; })\n \n-(define_expand \"sunordered\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (UNORDERED)) == NULL_RTX) FAIL; }\")\n+(define_expand \"cstoretf4\"\n+  [(use (match_operator:DI 1 \"alpha_cbranch_operator\"\n+         [(match_operand:TF 2 \"general_operand\")\n+          (match_operand:TF 3 \"general_operand\")]))\n+   (clobber (match_operand:DI 0 \"register_operand\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  { if (!alpha_emit_setcc (operands, TFmode)) FAIL; else DONE; })\n \n-(define_expand \"sordered\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))]\n+(define_expand \"cstoredi4\"\n+  [(use (match_operator:DI 1 \"alpha_cbranch_operator\"\n+         [(match_operand:DI 2 \"some_operand\")\n+          (match_operand:DI 3 \"some_operand\")]))\n+   (clobber (match_operand:DI 0 \"register_operand\"))]\n   \"\"\n-  \"{ if ((operands[1] = alpha_emit_setcc (ORDERED)) == NULL_RTX) FAIL; }\")\n+  { if (!alpha_emit_setcc (operands, DImode)) FAIL; else DONE; })\n \f\n ;; These are the main define_expand's used to make conditional moves.\n \n@@ -6766,7 +6613,7 @@\n       rtx loop_label = gen_label_rtx ();\n       rtx want = gen_reg_rtx (Pmode);\n       rtx tmp = gen_reg_rtx (Pmode);\n-      rtx memref;\n+      rtx memref, test;\n \n       emit_insn (gen_subdi3 (want, stack_pointer_rtx,\n \t\t\t     force_reg (Pmode, operands[1])));\n@@ -6775,17 +6622,17 @@\n       if (!CONST_INT_P (operands[1]))\n \t{\n \t  out_label = gen_label_rtx ();\n-\t  emit_insn (gen_cmpdi (want, tmp));\n-\t  emit_jump_insn (gen_bgeu (out_label));\n+\t  test = gen_rtx_GEU (VOIDmode, want, tmp);\n+\t  emit_jump_insn (gen_cbranchdi4 (test, want, tmp, out_label));\n \t}\n \n       emit_label (loop_label);\n       memref = gen_rtx_MEM (DImode, tmp);\n       MEM_VOLATILE_P (memref) = 1;\n       emit_move_insn (memref, const0_rtx);\n       emit_insn (gen_adddi3 (tmp, tmp, GEN_INT(-8192)));\n-      emit_insn (gen_cmpdi (tmp, want));\n-      emit_jump_insn (gen_bgtu (loop_label));\n+      test = gen_rtx_GTU (VOIDmode, tmp, want);\n+      emit_jump_insn (gen_cbranchdi4 (test, tmp, want, loop_label));\n \n       memref = gen_rtx_MEM (DImode, want);\n       MEM_VOLATILE_P (memref) = 1;"}, {"sha": "ec11eaa3d1f33bec9acf57885de7bae72c9834c2", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -543,6 +543,12 @@\n   (and (match_code \"reg\")\n        (match_operand 0 \"register_operand\")))\n \n+;; Return 1 if OP is a valid Alpha comparison operator for \"cbranch\"\n+;; instructions.\n+(define_predicate \"alpha_cbranch_operator\"\n+  (ior (match_operand 0 \"ordered_comparison_operator\")\n+       (match_code \"ordered,unordered\")))\n+\n ;; Return 1 if OP is a valid Alpha comparison operator for \"cmp\" style\n ;; instructions.\n (define_predicate \"alpha_comparison_operator\""}, {"sha": "1f456b63cd7e38f5c7ed983a3dfcd144cc0d2f7b", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -49,10 +49,6 @@ int arc_cpu_type;\n    cpu (or NULL).  */\n const char *arc_mangle_cpu;\n \n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-rtx arc_compare_op0, arc_compare_op1;\n-\n /* Name of text, data, and rodata sections used in varasm.c.  */\n const char *arc_text_section;\n const char *arc_data_section;\n@@ -729,21 +725,14 @@ proper_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \f\n /* Misc. utilities.  */\n \n-/* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for the cc reg in the proper mode.  */\n+/* X and Y are two things to compare using CODE.  Return the rtx\n+   for the cc reg in the proper mode.  */\n \n rtx\n gen_compare_reg (enum rtx_code code, rtx x, rtx y)\n {\n   enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg;\n-\n-  cc_reg = gen_rtx_REG (mode, 61);\n-\n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n-\t\t\t  gen_rtx_COMPARE (mode, x, y)));\n-\n-  return cc_reg;\n+  return gen_rtx_REG (mode, 61);\n }\n \n /* Return 1 if VALUE, a const_double, will fit in a limm (4 byte number)."}, {"sha": "4153ad6f6b68bd435adb5753ac4d0c53e731662a", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1067,11 +1067,6 @@ do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n /* ??? Not defined in tm.texi.  */\n #define SETJMP_VIA_SAVE_AREA\n \f\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-extern struct rtx_def *arc_compare_op0, *arc_compare_op1;\n-\n /* ARC function types.  */\n enum arc_function_type {\n   ARC_FUNCTION_UNKNOWN, ARC_FUNCTION_NORMAL,"}, {"sha": "09e47daf1d1e67f5cf1516cd9f9e4941a7adf242", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 38, "deletions": 299, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -585,29 +585,11 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx ccreg\n-    = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-\t\t   61);\n-\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n+  rtx cc_reg = gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\tXEXP (operands[1], 1));\n+  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n }\")\n \n-;(define_expand \"movdicc\"\n-;  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-;\t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n-;\t\t\t (match_operand:DI 2 \"nonmemory_operand\" \"\")\n-;\t\t\t (match_operand:DI 3 \"register_operand\" \"\")))]\n-;  \"0 /* ??? this would work better if we had cmpdi */\"\n-;  \"\n-;{\n-;  enum rtx_code code = GET_CODE (operands[1]);\n-;  rtx ccreg\n-;   = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-;\t\t   61);\n-;\n-;  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n-;}\")\n-\n (define_expand \"movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n@@ -617,29 +599,11 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx ccreg\n-    = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-\t\t   61);\n-\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n+  rtx cc_reg = gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\tXEXP (operands[1], 1));\n+  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n }\")\n \n-;(define_expand \"movdfcc\"\n-;  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-;\t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n-;\t\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")\n-;\t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n-;  \"0 /* ??? can generate less efficient code if constants involved */\"\n-;  \"\n-;{\n-; enum rtx_code code = GET_CODE (operands[1]);\n-; rtx ccreg\n-;   = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-;\t\t   61);\n-;\n-;  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n-;}\")\n-\n (define_insn \"*movsicc_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n@@ -649,32 +613,6 @@\n   \"mov.%d1 %0,%S2\"\n   [(set_attr \"type\" \"cmove\")])\n \n-; ??? This doesn't properly handle constants.\n-;(define_insn \"*movdicc_insn\"\n-;  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-;\t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n-;\t\t\t (match_operand:DI 2 \"nonmemory_operand\" \"r,Ji\")\n-;\t\t\t (match_operand:DI 3 \"register_operand\" \"0,0\")))]\n-;  \"0\"\n-;  \"*\n-;{\n-;  switch (which_alternative)\n-;    {\n-;    case 0 :\n-;      /* We normally copy the low-numbered register first.  However, if\n-;\t the first register operand 0 is the same as the second register of\n-;\t operand 1, we must copy in the opposite order.  */\n-;      if (REGNO (operands[0]) == REGNO (operands[2]) + 1)\n-;\treturn \\\"mov.%d1 %R0,%R2\\;mov.%d1 %0,%2\\\";\n-;      else\n-;\treturn \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n-;    case 1 :\n-;      return \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n-;    }\n-;}\"\n-;  [(set_attr \"type\" \"cmove,cmove\")\n-;   (set_attr \"length\" \"2,4\")])\n-\n (define_insn \"*movsfcc_insn\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n@@ -686,30 +624,6 @@\n    mov.%d1 %0,%2 ; %A2\"\n   [(set_attr \"type\" \"cmove,cmove\")])\n \n-;(define_insn \"*movdfcc_insn\"\n-;  [(set (match_operand:DF 0 \"register_operand\" \"=r,r\")\n-;\t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n-;\t\t\t (match_operand:DF 2 \"nonmemory_operand\" \"r,E\")\n-;\t\t\t (match_operand:DF 3 \"register_operand\" \"0,0\")))]\n-;  \"0\"\n-;  \"*\n-;{\n-;  switch (which_alternative)\n-;    {\n-;    case 0 :\n-;      /* We normally copy the low-numbered register first.  However, if\n-;\t the first register operand 0 is the same as the second register of\n-;\t operand 1, we must copy in the opposite order.  */\n-;      if (REGNO (operands[0]) == REGNO (operands[2]) + 1)\n-;\treturn \\\"mov.%d1 %R0,%R2\\;mov.%d1 %0,%2\\\";\n-;      else\n-;\treturn \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n-;    case 1 :\n-;      return \\\"mov.%d1 %0,%L2\\;mov.%d1 %R0,%H2 ; %A2\\\";\n-;    }\n-;}\"\n-;  [(set_attr \"type\" \"cmove,cmove\")\n-;   (set_attr \"length\" \"2,4\")])\n \f\n ;; Zero extension instructions.\n ;; ??? We don't support volatile memrefs here, but I'm not sure why.\n@@ -1156,22 +1070,6 @@\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n \n-;; We generate RTL for comparisons and branches by having the cmpxx \n-;; patterns store away the operands.  Then, the scc and bcc patterns\n-;; emit RTL for both the compare and the branch.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 61)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  arc_compare_op0 = operands[0];\n-  arc_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;; ??? We may be able to relax this a bit by adding a new constant 'K' for 0.\n ;; This assumes sub.f 0,symbol,0 is a valid insn.\n ;; Note that \"sub.f 0,r0,1\" is an 8 byte insn.  To avoid unnecessarily\n@@ -1211,96 +1109,25 @@\n    sub.f 0,%0,%1\"\n   [(set_attr \"type\" \"compare,compare,compare\")])\n \n-;; Next come the scc insns.\n-\n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (EQ, arc_compare_op0, arc_compare_op1);\n-}\")\n+;; Next come the scc insn and its expander.\n \n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (NE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GT, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(le:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LT, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GTU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LEU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(geu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GEU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ltu:SI (match_dup 1) (const_int 0)))]\n+(define_expand \"cstoresi4\"\n+  [(set (match_dup 4)\n+        (match_op_dup 5\n+         [(match_operand:SI 2 \"register_operand\" \"\")\n+          (match_operand:SI 3 \"nonmemory_operand\" \"\")]))\n+   (set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(match_dup 4)\n+\t  (const_int 0)]))]\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare_reg (LTU, arc_compare_op0, arc_compare_op1);\n+  operands[4] = gen_compare_reg (GET_CODE (operands[1]),\n+\t\t\t\t operands[2], operands[3]);\n+  operands[5] = gen_rtx_fmt_ee (COMPARE,\n+\t\t\t\tGET_MODE (operands[4]),\n+\t\t\t\toperands[2], operands[3]);\n }\")\n \n (define_insn \"*scc_insn\"\n@@ -1332,114 +1159,26 @@\n \f\n ;; These control RTL generation for conditional jump insns\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (EQ, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (NE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GT, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GE, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LT, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GTU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LEU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GEU, arc_compare_op0, arc_compare_op1);\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchsi4\"\n+  [(set (match_dup 4)\n+        (match_op_dup 5\n+\t [(match_operand:SI 1 \"register_operand\" \"\")\n+          (match_operand:SI 2 \"nonmemory_operand\" \"\")]))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\"\n+\t       [(match_dup 4)\n+\t\t(const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare_reg (LTU, arc_compare_op0, arc_compare_op1);\n+  operands[4] = gen_compare_reg (GET_CODE (operands[0]),\n+\t\t\t\t operands[1], operands[2]);\n+  operands[5] = gen_rtx_fmt_ee (COMPARE,\n+\t\t\t\tGET_MODE (operands[4]),\n+\t\t\t\toperands[1], operands[2]);\n }\")\n \n ;; Now match both normal and inverted jump."}, {"sha": "18e009d136878da376428d3a1b2f88b7d12a6886", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -418,10 +418,6 @@ extern FILE * asm_out_file;\n /* True if we are currently building a constant table.  */\n int making_const_table;\n \n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-rtx arm_compare_op0, arm_compare_op1;\n-\n /* The processor for which instructions should be scheduled.  */\n enum processor_type arm_tune = arm_none;\n "}, {"sha": "e0430908901ec97ab466bff42842a91d1f63bc91", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -124,10 +124,6 @@ extern arm_cc arm_current_cc;\n extern int arm_target_label;\n extern int arm_ccfsm_state;\n extern GTY(()) rtx arm_target_insn;\n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-extern GTY(()) rtx arm_compare_op0;\n-extern GTY(()) rtx arm_compare_op1;\n /* The label of the current constant pool.  */\n extern rtx pool_vector_label;\n /* Set to 1 when a return insn is output, this means that the epilogue"}, {"sha": "b18173e1affdc21cf4cfb575cb0950bf481b2e92", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 107, "deletions": 341, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -6386,8 +6386,16 @@\n \t        (match_operand:SI 2 \"nonmemory_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n-  \"TARGET_THUMB1\"\n+  \"TARGET_THUMB1 || TARGET_32BIT\"\n   \"\n+  if (!TARGET_THUMB1)\n+    {\n+      if (!arm_add_operand (operands[2], SImode))\n+\toperands[2] = force_reg (SImode, operands[2]);\n+      emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+\t\t\t\t      operands[3]));\n+      DONE;\n+    }\n   if (thumb1_cmpneg_operand (operands[2], SImode))\n     {\n       emit_jump_insn (gen_cbranchsi4_scratch (NULL, operands[1], operands[2],\n@@ -6398,6 +6406,43 @@\n     operands[2] = force_reg (SImode, operands[2]);\n   \")\n \n+(define_expand \"cbranchsf4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"arm_comparison_operator\"\n+\t       [(match_operand:SF 1 \"s_register_operand\" \"\")\n+\t        (match_operand:SF 2 \"arm_float_compare_operand\" \"\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+\t\t\t\t   operands[3])); DONE;\"\n+)\n+\n+(define_expand \"cbranchdf4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"arm_comparison_operator\"\n+\t       [(match_operand:DF 1 \"s_register_operand\" \"\")\n+\t        (match_operand:DF 2 \"arm_float_compare_operand\" \"\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+\t\t\t\t   operands[3])); DONE;\"\n+)\n+\n+;; this uses the Cirrus DI compare instruction\n+(define_expand \"cbranchdi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"arm_comparison_operator\"\n+\t       [(match_operand:DI 1 \"cirrus_fp_register\" \"\")\n+\t        (match_operand:DI 2 \"cirrus_fp_register\" \"\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n+  \"emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+\t\t\t\t   operands[3])); DONE;\"\n+)\n+\n (define_insn \"*cbranchsi4_insn\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"arm_comparison_operator\"\n@@ -7451,39 +7496,6 @@\n \n ;; Comparison and test insns\n \n-(define_expand \"cmpsi\"\n-  [(match_operand:SI 0 \"s_register_operand\" \"\")\n-   (match_operand:SI 1 \"arm_add_operand\" \"\")]\n-  \"TARGET_32BIT\"\n-  \"{\n-    arm_compare_op0 = operands[0];\n-    arm_compare_op1 = operands[1];\n-    DONE;\n-  }\"\n-)\n-\n-(define_expand \"cmpsf\"\n-  [(match_operand:SF 0 \"s_register_operand\" \"\")\n-   (match_operand:SF 1 \"arm_float_compare_operand\" \"\")]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n-  \"\n-  arm_compare_op0 = operands[0];\n-  arm_compare_op1 = operands[1];\n-  DONE;\n-  \"\n-)\n-\n-(define_expand \"cmpdf\"\n-  [(match_operand:DF 0 \"s_register_operand\" \"\")\n-   (match_operand:DF 1 \"arm_float_compare_operand\" \"\")]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n-  \"\n-  arm_compare_op0 = operands[0];\n-  arm_compare_op1 = operands[1];\n-  DONE;\n-  \"\n-)\n-\n (define_insn \"*arm_cmpsi_insn\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:SI 0 \"s_register_operand\" \"r,r\")\n@@ -7562,17 +7574,6 @@\n    (set_attr \"cirrus\" \"compare\")]\n )\n \n-;; Cirrus DI compare instruction\n-(define_expand \"cmpdi\"\n-  [(match_operand:DI 0 \"cirrus_fp_register\" \"\")\n-   (match_operand:DI 1 \"cirrus_fp_register\" \"\")]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n-  \"{\n-     arm_compare_op0 = operands[0];\n-     arm_compare_op1 = operands[1];\n-     DONE;\n-   }\")\n-\n (define_insn \"*cirrus_cmpdi\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:DI 0 \"cirrus_fp_register\" \"v\")\n@@ -7600,170 +7601,16 @@\n \f\n ;; Conditional branch insns\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (EQ, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bne\"\n+(define_expand \"cbranch_cc\"\n   [(set (pc)\n-\t(if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (NE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"\" [(match_operand 1 \"\" \"\")\n+\t\t\t\t\t    (match_operand 2 \"\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GEU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LTU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (unordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (ordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"bungt\"\n-  [(set (pc)\n-\t(if_then_else (ungt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bunlt\"\n-  [(set (pc)\n-\t(if_then_else (unlt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bunge\"\n-  [(set (pc)\n-\t(if_then_else (unge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bunle\"\n-  [(set (pc)\n-\t(if_then_else (unle (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-;; The following two patterns need two branch instructions, since there is\n-;; no single instruction that will handle all cases.\n-(define_expand \"buneq\"\n-  [(set (pc)\n-\t(if_then_else (uneq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNEQ, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"bltgt\"\n-  [(set (pc)\n-\t(if_then_else (ltgt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (LTGT, arm_compare_op0, arm_compare_op1);\"\n+  \"operands[1] = arm_gen_compare_reg (GET_CODE (operands[0]),\n+\t\t\t\t      operands[1], operands[2]);\n+   operands[2] = const0_rtx;\"\n )\n \n ;;\n@@ -7876,141 +7723,16 @@\n \n ; scc insns\n \n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (EQ, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (NE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(le:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GE, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LT, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sgeu\"\n+(define_expand \"cstore_cc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(geu:SI (match_dup 1) (const_int 0)))]\n+\t(match_operator:SI 1 \"\" [(match_operand 2 \"\" \"\")\n+\t\t\t\t (match_operand 3 \"\" \"\")]))]\n   \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (GEU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ltu:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT\"\n-  \"operands[1] = arm_gen_compare_reg (LTU, arm_compare_op0, arm_compare_op1);\"\n-)\n-\n-(define_expand \"sunordered\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(unordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"sordered\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"sungt\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ungt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"sunge\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(unge:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"sunlt\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(unlt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n-)\n-\n-(define_expand \"sunle\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(unle:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-  \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0,\n-\t\t\t\t      arm_compare_op1);\"\n+  \"operands[2] = arm_gen_compare_reg (GET_CODE (operands[1]),\n+\t\t\t\t      operands[2], operands[3]);\n+   operands[3] = const0_rtx;\"\n )\n \n-;;; DO NOT add patterns for SUNEQ or SLTGT, these can't be represented with\n-;;; simple ARM instructions. \n-;\n-; (define_expand \"suneq\"\n-;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-; \t(uneq:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-;   \"gcc_unreachable ();\"\n-; )\n-;\n-; (define_expand \"sltgt\"\n-;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-; \t(ltgt:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n-;   \"gcc_unreachable ();\"\n-; )\n-\n (define_insn \"*mov_scc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(match_operator:SI 1 \"arm_comparison_operator\"\n@@ -8046,10 +7768,19 @@\n \t(match_operator:SI 1 \"arm_comparison_operator\"\n \t [(match_operand:SI 2 \"s_register_operand\" \"\")\n \t  (match_operand:SI 3 \"reg_or_int_operand\" \"\")]))]\n-  \"TARGET_THUMB1\"\n+  \"TARGET_32BIT || TARGET_THUMB1\"\n   \"{\n   rtx op3, scratch, scratch2;\n \n+  if (!TARGET_THUMB1)\n+    {\n+      if (!arm_add_operand (operands[3], SImode))\n+\toperands[3] = force_reg (SImode, operands[3]);\n+      emit_insn (gen_cstore_cc (operands[0], operands[1],\n+\t\t\t\toperands[2], operands[3]));\n+      DONE;\n+    }\n+\n   if (operands[3] == const0_rtx)\n     {\n       switch (GET_CODE (operands[1]))\n@@ -8170,6 +7901,38 @@\n   DONE;\n }\")\n \n+(define_expand \"cstoresf4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 1 \"arm_comparison_operator\"\n+\t [(match_operand:SF 2 \"s_register_operand\" \"\")\n+\t  (match_operand:SF 3 \"arm_float_compare_operand\" \"\")]))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3])); DONE;\"\n+)\n+\n+(define_expand \"cstoredf4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 1 \"arm_comparison_operator\"\n+\t [(match_operand:DF 2 \"s_register_operand\" \"\")\n+\t  (match_operand:DF 3 \"arm_float_compare_operand\" \"\")]))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3])); DONE;\"\n+)\n+\n+;; this uses the Cirrus DI compare instruction\n+(define_expand \"cstoredi4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operator:SI 1 \"arm_comparison_operator\"\n+\t [(match_operand:DI 2 \"cirrus_fp_register\" \"\")\n+\t  (match_operand:DI 3 \"cirrus_fp_register\" \"\")]))]\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n+  \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3])); DONE;\"\n+)\n+\n+\n (define_expand \"cstoresi_eq0_thumb1\"\n   [(parallel\n     [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n@@ -8250,7 +8013,8 @@\n     if (code == UNEQ || code == LTGT)\n       FAIL;\n \n-    ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);\n+    ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1));\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n   }\"\n )\n@@ -8275,7 +8039,8 @@\n         || (!arm_float_add_operand (operands[3], SFmode)))\n       operands[3] = force_reg (SFmode, operands[3]);\n \n-    ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);\n+    ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1));\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n   }\"\n )\n@@ -8294,7 +8059,8 @@\n     if (code == UNEQ || code == LTGT)\n       FAIL;\n \n-    ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);\n+    ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1));\n     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n   }\"\n )"}, {"sha": "b45faf43cbceb64a1e9e7a74ce96c74b17fe9886", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -191,9 +191,13 @@\n (define_special_predicate \"equality_operator\"\n   (match_code \"eq,ne\"))\n \n-;; True for comparisons other than LTGT or UNEQ.\n+;; True for integer comparisons and, if FP is active, for comparisons\n+;; other than LTGT or UNEQ.\n (define_special_predicate \"arm_comparison_operator\"\n-  (match_code \"eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu,unordered,ordered,unlt,unle,unge,ungt\"))\n+  (ior (match_code \"eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu\")\n+       (and (match_test \"TARGET_32BIT && TARGET_HARD_FLOAT\n+\t\t\t && (TARGET_FPA || TARGET_VFP)\")\n+            (match_code \"unordered,ordered,unlt,unle,unge,ungt\"))))\n \n (define_special_predicate \"minmax_operator\"\n   (and (match_code \"smin,smax,umin,umax\")"}, {"sha": "f4d2119a9983b9ef1c55ebdd751c594063dcdec0", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -72,8 +72,8 @@ extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n-extern const char *out_tstsi (rtx insn, int *l);\n-extern const char *out_tsthi (rtx insn, int *l);\n+extern const char *out_tstsi (rtx insn, rtx src, int *l);\n+extern const char *out_tsthi (rtx insn, rtx src, int *l);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n \n extern const char *ashlqi3_out (rtx insn, rtx operands[], int *len);"}, {"sha": "4811b92637f1db2fc34e0120054375e60e7a843c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2915,21 +2915,21 @@ compare_eq_p (rtx insn)\n /* Output test instruction for HImode.  */\n \n const char *\n-out_tsthi (rtx insn, int *l)\n+out_tsthi (rtx insn, rtx op, int *l)\n {\n   if (compare_sign_p (insn))\n     {\n       if (l) *l = 1;\n       return AS1 (tst,%B0);\n     }\n-  if (reg_unused_after (insn, SET_SRC (PATTERN (insn)))\n+  if (reg_unused_after (insn, op)\n       && compare_eq_p (insn))\n     {\n       /* Faster than sbiw if we can clobber the operand.  */\n       if (l) *l = 1;\n       return AS2 (or,%A0,%B0);\n     }\n-  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n+  if (test_hard_reg_class (ADDW_REGS, op))\n     {\n       if (l) *l = 1;\n       return AS2 (sbiw,%0,0);\n@@ -2943,14 +2943,14 @@ out_tsthi (rtx insn, int *l)\n /* Output test instruction for SImode.  */\n \n const char *\n-out_tstsi (rtx insn, int *l)\n+out_tstsi (rtx insn, rtx op, int *l)\n {\n   if (compare_sign_p (insn))\n     {\n       if (l) *l = 1;\n       return AS1 (tst,%D0);\n     }\n-  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n+  if (test_hard_reg_class (ADDW_REGS, op))\n     {\n       if (l) *l = 3;\n       return (AS2 (sbiw,%A0,0) CR_TAB\n@@ -4367,8 +4367,8 @@ adjust_insn_length (rtx insn, int len)\n \t{\n \t  switch (GET_MODE (op[1]))\n \t    {\n-\t    case HImode: out_tsthi (insn,&len); break;\n-\t    case SImode: out_tstsi (insn,&len); break;\n+\t    case HImode: out_tsthi (insn, op[1], &len); break;\n+\t    case SImode: out_tstsi (insn, op[1], &len); break;\n \t    default: break;\n \t    }\n \t}\n@@ -5734,6 +5734,21 @@ avr_reorg (void)\n \t\t  XEXP (pattern,1) = x;\n \t\t  INSN_CODE (next) = -1;\n \t\t}\n+\t      else if (true_regnum (XEXP (pattern, 0)) >= 0\n+\t\t       && XEXP (pattern, 1) == const0_rtx)\n+\t        {\n+\t          /* This is a tst insn, we can reverse it.  */\n+\t          rtx next = next_real_insn (insn);\n+\t          rtx pat = PATTERN (next);\n+\t          rtx src = SET_SRC (pat);\n+\t          rtx t = XEXP (src,0);\n+    \n+\t          PUT_CODE (t, swap_condition (GET_CODE (t)));\n+\t          XEXP (pattern, 1) = XEXP (pattern, 0);\n+\t          XEXP (pattern, 0) = const0_rtx;\n+\t          INSN_CODE (next) = -1;\n+\t          INSN_CODE (insn) = -1;\n+\t        }\n \t      else if (true_regnum (XEXP (pattern,0)) >= 0\n \t\t       && GET_CODE (XEXP (pattern,1)) == CONST_INT)\n \t\t{\n@@ -5753,20 +5768,6 @@ avr_reorg (void)\n \t\t    }\n \t\t}\n \t    }\n-\t  else if (true_regnum (SET_SRC (pattern)) >= 0)\n-\t    {\n-\t      /* This is a tst insn */\n-\t      rtx next = next_real_insn (insn);\n-\t      rtx pat = PATTERN (next);\n-\t      rtx src = SET_SRC (pat);\n-\t      rtx t = XEXP (src,0);\n-\n-\t      PUT_CODE (t, swap_condition (GET_CODE (t)));\n-\t      SET_SRC (pattern) = gen_rtx_COMPARE (GET_MODE (SET_SRC (pattern)), const0_rtx,\n-\t\t\t\t\t       SET_SRC (pattern));\n-\t      INSN_CODE (next) = -1;\n-\t      INSN_CODE (insn) = -1;\n-\t    }\n \t}\n     }\n }"}, {"sha": "86a217dc23c99bc4845e700905912a0b0db73fc0", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 125, "deletions": 149, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2202,53 +2202,65 @@\n ;;<=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=>\n ;; compare\n \n-(define_insn \"tstqi\"\n+; Optimize negated tests into reverse compare if overflow is undefined.\n+(define_insn \"*negated_tstqi\"\n   [(set (cc0)\n-        (match_operand:QI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"tst %0\"\n+        (compare (neg:QI (match_operand:QI 0 \"register_operand\" \"r\"))\n+\t\t (const_int 0)))]\n+  \"(!flag_wrapv && !flag_trapv && flag_strict_overflow)\"\n+  \"cp __zero_reg__,%0\"\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*reversed_tstqi\"\n   [(set (cc0)\n-        (compare (const_int 0)  \n+        (compare (const_int 0)\n \t\t (match_operand:QI 0 \"register_operand\" \"r\")))]\n   \"\"\n   \"cp __zero_reg__,%0\"\n-  [(set_attr \"cc\" \"compare\")\n-   (set_attr \"length\" \"1\")])\n+[(set_attr \"cc\" \"compare\")\n+ (set_attr \"length\" \"2\")])\n \n-(define_insn \"tsthi\"\n+(define_insn \"*negated_tsthi\"\n   [(set (cc0)\n-        (match_operand:HI 0 \"register_operand\" \"!w,r\"))]\n-  \"\"\n-  \"* return out_tsthi (insn,NULL);\"\n-[(set_attr \"cc\" \"compare,compare\")\n- (set_attr \"length\" \"1,2\")])\n+        (compare (neg:HI (match_operand:HI 0 \"register_operand\" \"r\"))\n+\t\t (const_int 0)))]\n+  \"(!flag_wrapv && !flag_trapv && flag_strict_overflow)\"\n+  \"cp __zero_reg__,%A0\n+\tcpc __zero_reg__,%B0\"\n+[(set_attr \"cc\" \"compare\")\n+ (set_attr \"length\" \"2\")])\n \n+;; Leave here the clobber used by the cmphi pattern for simplicity, even\n+;; though it is unused, because this pattern is synthesized by avr_reorg.\n (define_insn \"*reversed_tsthi\"\n   [(set (cc0)\n         (compare (const_int 0)\n-\t\t (match_operand:HI 0 \"register_operand\" \"r\")))]\n+\t\t (match_operand:HI 0 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:QI 1 \"=X\"))]\n   \"\"\n   \"cp __zero_reg__,%A0\n \tcpc __zero_reg__,%B0\"\n [(set_attr \"cc\" \"compare\")\n  (set_attr \"length\" \"2\")])\n \n-(define_insn \"tstsi\"\n+(define_insn \"*negated_tstsi\"\n   [(set (cc0)\n-        (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"* return out_tstsi (insn,NULL);\"\n+        (compare (neg:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t\t (const_int 0)))]\n+  \"(!flag_wrapv && !flag_trapv && flag_strict_overflow)\"\n+  \"cp __zero_reg__,%A0\n+\tcpc __zero_reg__,%B0\n+\tcpc __zero_reg__,%C0\n+\tcpc __zero_reg__,%D0\"\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*reversed_tstsi\"\n   [(set (cc0)\n-        (compare (const_int 0)  \n-\t\t (match_operand:SI 0 \"register_operand\" \"r\")))]\n+        (compare (const_int 0)\n+\t\t (match_operand:SI 0 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:QI 1 \"=X\"))]\n   \"\"\n   \"cp __zero_reg__,%A0\n \tcpc __zero_reg__,%B0\n@@ -2258,16 +2270,17 @@\n    (set_attr \"length\" \"4\")])\n \n \n-(define_insn \"cmpqi\"\n+(define_insn \"*cmpqi\"\n   [(set (cc0)\n-        (compare (match_operand:QI 0 \"register_operand\"  \"r,d\")\n-\t\t (match_operand:QI 1 \"nonmemory_operand\" \"r,i\")))]\n+        (compare (match_operand:QI 0 \"register_operand\"  \"r,r,d\")\n+\t\t (match_operand:QI 1 \"nonmemory_operand\" \"L,r,i\")))]\n   \"\"\n   \"@\n+\ttst %0\n \tcp %0,%1\n \tcpi %0,lo8(%1)\"\n-  [(set_attr \"cc\" \"compare,compare\")\n-   (set_attr \"length\" \"1,1\")])\n+  [(set_attr \"cc\" \"compare,compare,compare\")\n+   (set_attr \"length\" \"1,1,1\")])\n \n (define_insn \"*cmpqi_sign_extend\"\n   [(set (cc0)\n@@ -2279,66 +2292,72 @@\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"cmphi\"\n+(define_insn \"*cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\"  \"r,d,d,r,r\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"r,M,i,M,i\")))\n-   (clobber (match_scratch:QI 2 \"=X,X,&d,&d,&d\"))]\n+\t(compare (match_operand:HI 0 \"register_operand\"  \"!w,r,r,d,d,r,r\")\n+\t\t (match_operand:HI 1 \"nonmemory_operand\" \"L,L,r,M,i,M,i\")))\n+   (clobber (match_scratch:QI 2 \"=X,X,X,X,&d,&d,&d\"))]\n   \"\"\n   \"*{\n   switch (which_alternative)\n     {\n-    case 0:\n+    case 0: case 1:\n+      return out_tsthi (insn, operands[0], NULL);\n+\n+    case 2:\n       return (AS2 (cp,%A0,%A1) CR_TAB\n               AS2 (cpc,%B0,%B1));\n-    case 1:\n+    case 3:\n       if (reg_unused_after (insn, operands[0])\n           && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n           && test_hard_reg_class (ADDW_REGS, operands[0]))\n         return AS2 (sbiw,%0,%1);\n        else\n         return (AS2 (cpi,%0,%1) CR_TAB\n                 AS2 (cpc,%B0,__zero_reg__));\n-    case 2:\n+    case 4:\n       if (reg_unused_after (insn, operands[0]))\n         return (AS2 (subi,%0,lo8(%1))  CR_TAB\n                 AS2 (sbci,%B0,hi8(%1)));\n       else\n         return (AS2 (ldi, %2,hi8(%1))  CR_TAB\n \t        AS2 (cpi, %A0,lo8(%1)) CR_TAB\n \t        AS2 (cpc, %B0,%2));\n-   case 3:\n+   case 5:\n       return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n \t      AS2 (cp, %A0,%2) CR_TAB\n \t      AS2 (cpc, %B0,__zero_reg__));\n \n-   case 4:\n+   case 6:\n       return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n               AS2 (cp, %A0,%2)       CR_TAB\n               AS2 (ldi, %2,hi8(%1)) CR_TAB\n \t      AS2 (cpc, %B0,%2));\n     }\n   return \\\"bug\\\";\n }\" \n-  [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"2,2,3,3,4\")])\n+  [(set_attr \"cc\" \"compare,compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"1,2,2,2,3,3,4\")])\n \n \n-(define_insn \"cmpsi\"\n+(define_insn \"*cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\"  \"r,d,d,r,r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,M,i,M,i\")))\n-   (clobber (match_scratch:QI 2 \"=X,X,&d,&d,&d\"))]\n+\t(compare (match_operand:SI 0 \"register_operand\"  \"r,r,d,d,r,r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"L,r,M,i,M,i\")))\n+   (clobber (match_scratch:QI 2 \"=X,X,X,&d,&d,&d\"))]\n   \"\"\n   \"*{\n   switch (which_alternative)\n     {\n     case 0:\n+      return out_tstsi (insn, operands[0], NULL);\n+\n+    case 1:\n       return (AS2 (cp,%A0,%A1) CR_TAB\n               AS2 (cpc,%B0,%B1) CR_TAB\n \t      AS2 (cpc,%C0,%C1) CR_TAB\n \t      AS2 (cpc,%D0,%D1));\n-    case 1:\n+    case 2:\n       if (reg_unused_after (insn, operands[0])\n           && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n           && test_hard_reg_class (ADDW_REGS, operands[0]))\n@@ -2350,7 +2369,7 @@\n                 AS2 (cpc,%B0,__zero_reg__) CR_TAB\n                 AS2 (cpc,%C0,__zero_reg__) CR_TAB\n                 AS2 (cpc,%D0,__zero_reg__));\n-    case 2:\n+    case 3:\n       if (reg_unused_after (insn, operands[0]))\n         return (AS2 (subi,%A0,lo8(%1))  CR_TAB\n                 AS2 (sbci,%B0,hi8(%1))  CR_TAB\n@@ -2364,13 +2383,13 @@\n \t       AS2 (cpc, %C0,%2)       CR_TAB\n \t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n \t       AS2 (cpc, %D0,%2));\n-    case 3:\n+    case 4:\n         return (AS2 (ldi,%2,lo8(%1))        CR_TAB\n                 AS2 (cp,%A0,%2)            CR_TAB\n                 AS2 (cpc,%B0,__zero_reg__) CR_TAB\n                 AS2 (cpc,%C0,__zero_reg__) CR_TAB\n                 AS2 (cpc,%D0,__zero_reg__));\n-    case 4:\n+    case 5:\n        return (AS2 (ldi, %2,lo8(%1))   CR_TAB\n                AS2 (cp, %A0,%2)        CR_TAB\n \t       AS2 (ldi, %2,hi8(%1))  CR_TAB\n@@ -2382,113 +2401,53 @@\n     }\n   return \\\"bug\\\";\n }\"\n-  [(set_attr \"cc\" \"compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,7,5,8\")])\n-\n-; Optimize negated tests into reverse compare if overflow is undefined.\n-(define_insn_and_split \"negated_tst<mode>\"\n- [(set (cc0)\n-        (neg:QISI (match_operand:QISI 0 \"register_operand\")))]\n+  [(set_attr \"cc\" \"compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,4,7,5,8\")])\n \n-  \"(!flag_wrapv && !flag_trapv && flag_strict_overflow)\"\n-  \"#\"\n-  \"\"\n-  [(set (cc0)\n-        (compare (const_int 0)  \n-\t\t (match_dup 0)))]\n-  \"\")\n \n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n ;; Conditional jump instructions\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-        (if_then_else (eq (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-        (if_then_else (ne (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-        (if_then_else (ge (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-        (if_then_else (geu (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-        (if_then_else (lt (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-        (if_then_else (ltu (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-\n-\n-/****************************************************************\n- AVR not have following conditional jumps: LE,LEU,GT,GTU.\n- Convert them all to proper jumps.\n-*****************************************************************/\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-        (if_then_else (le (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-        (if_then_else (leu (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n+(define_expand \"cbranchsi4\"\n+  [(parallel [(set (cc0)\n+\t           (compare (match_operand:SI 1 \"register_operand\" \"\")\n+\t                    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 4 \"\"))])\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n+\n+(define_expand \"cbranchhi4\"\n+  [(parallel [(set (cc0)\n+\t           (compare (match_operand:HI 1 \"register_operand\" \"\")\n+\t                    (match_operand:HI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 4 \"\"))])\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n \n-(define_expand \"bgt\"\n-  [(set (pc)\n-        (if_then_else (gt (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n+(define_expand \"cbranchqi4\"\n+  [(set (cc0)\n+        (compare (match_operand:QI 1 \"register_operand\" \"\")\n+                 (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n \n-(define_expand \"bgtu\"\n-  [(set (pc)\n-        (if_then_else (gtu (cc0) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"\")\n \n ;; Test a single bit in a QI/HI/SImode register.\n (define_insn \"*sbrx_branch\"\n@@ -2557,7 +2516,8 @@\n \n ;; Convert sign tests to bit 7/15/31 tests that match the above insns.\n (define_peephole2\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2571,7 +2531,8 @@\n   \"\")\n \n (define_peephole2\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2585,7 +2546,9 @@\n   \"\")\n \n (define_peephole2\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (cc0) (compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t\t \t  (const_int 0)))\n+\t      (clobber (match_operand:HI 2 \"\"))])\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2597,7 +2560,9 @@\n   \"\")\n \n (define_peephole2\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (cc0) (compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t\t \t  (const_int 0)))\n+\t      (clobber (match_operand:HI 2 \"\"))])\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2609,7 +2574,9 @@\n   \"\")\n \n (define_peephole2\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t \t  (const_int 0)))\n+\t      (clobber (match_operand:SI 2 \"\"))])\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2621,7 +2588,9 @@\n   \"operands[2] = GEN_INT (-2147483647 - 1);\")\n \n (define_peephole2\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t \t  (const_int 0)))\n+\t      (clobber (match_operand:SI 2 \"\"))])\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t   (pc)))]\n@@ -2650,6 +2619,11 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n \n+;; ****************************************************************\n+;; AVR does not have following conditional jumps: LE,LEU,GT,GTU.\n+;; Convert them all to proper jumps.\n+;; ****************************************************************/\n+\n (define_insn \"difficult_branch\"\n   [(set (pc)\n         (if_then_else (match_operator 1 \"difficult_comparison_operator\"\n@@ -3150,7 +3124,9 @@\n }\")\n \n (define_peephole\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (const_int 0)))\n    (set (pc)\n \t(if_then_else (eq (cc0) (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))"}, {"sha": "ac237d73bd2e5710528234387d9ede0b0614f054", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -67,10 +67,6 @@ struct GTY(()) machine_function\n   int has_loopreg_clobber;\n };\n \n-/* Test and compare insns in bfin.md store the information needed to\n-   generate branch and scc insns here.  */\n-rtx bfin_compare_op0, bfin_compare_op1;\n-\n /* RTX for condition code flag register and RETS register */\n extern GTY(()) rtx bfin_cc_rtx;\n extern GTY(()) rtx bfin_rets_rtx;\n@@ -2714,7 +2710,7 @@ rtx\n bfin_gen_compare (rtx cmp, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code1, code2;\n-  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n+  rtx op0 = XEXP (cmp, 0), op1 = XEXP (cmp, 1);\n   rtx tem = bfin_cc_rtx;\n   enum rtx_code code = GET_CODE (cmp);\n \n@@ -2742,7 +2738,7 @@ bfin_gen_compare (rtx cmp, enum machine_mode mode ATTRIBUTE_UNUSED)\n \tcode2 = EQ;\n \tbreak;\n       }\n-      emit_insn (gen_rtx_SET (BImode, tem,\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n \t\t\t      gen_rtx_fmt_ee (code1, BImode, op0, op1)));\n     }\n \n@@ -4219,17 +4215,17 @@ bfin_optimize_loop (loop_info loop)\n     {\n       /* If loop->iter_reg is a DREG or PREG, we can split it here\n \t without scratch register.  */\n-      rtx insn;\n+      rtx insn, test;\n \n       emit_insn_before (gen_addsi3 (loop->iter_reg,\n \t\t\t\t    loop->iter_reg,\n \t\t\t\t    constm1_rtx),\n \t\t\tloop->loop_end);\n \n-      emit_insn_before (gen_cmpsi (loop->iter_reg, const0_rtx),\n-\t\t\tloop->loop_end);\n-\n-      insn = emit_jump_insn_before (gen_bne (loop->start_label),\n+      test = gen_rtx_NE (VOIDmode, loop->iter_reg, const0_rtx);\n+      insn = emit_jump_insn_before (gen_cbranchsi4 (test,\n+\t\t\t\t\t\t    loop->iter_reg, const0_rtx,\n+\t\t\t\t\t\t    loop->start_label),\n \t\t\t\t    loop->loop_end);\n \n       JUMP_LABEL (insn) = loop->start_label;"}, {"sha": "352f4b4c208820848fd01d1d0954d039f0fa5cbf", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1292,7 +1292,6 @@ do { \t\t\t\t\t\t\\\n #define ASM_OUTPUT_REG_PUSH(FILE, REGNO) fprintf (FILE, \"[SP--] = %s;\\n\", reg_names[REGNO])\n #define ASM_OUTPUT_REG_POP(FILE, REGNO)  fprintf (FILE, \"%s = [SP++];\\n\", reg_names[REGNO])\n \n-extern struct rtx_def *bfin_compare_op0, *bfin_compare_op1;\n extern struct rtx_def *bfin_cc_rtx, *bfin_rets_rtx;\n \n /* This works for GAS and some other assemblers.  */"}, {"sha": "755a0d3ced64d40b60dcbb79c2e1b46b36001275", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 53, "deletions": 222, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2255,29 +2255,6 @@\n ;; Conditional branch patterns\n ;; The Blackfin has only few condition codes: eq, lt, lte, ltu, leu\n \n-;; The only outcome of this pattern is that global variables\n-;; bfin_compare_op[01] are set for use in bcond patterns.\n-\n-(define_expand \"cmpbi\"\n- [(set (cc0) (compare (match_operand:BI 0 \"register_operand\" \"\")\n-                      (match_operand:BI 1 \"immediate_operand\" \"\")))]\n- \"\"\n-{\n-  bfin_compare_op0 = operands[0];\n-  bfin_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmpsi\"\n- [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n-                      (match_operand:SI 1 \"reg_or_const_int_operand\" \"\")))]\n- \"\"\n-{\n-  bfin_compare_op0 = operands[0];\n-  bfin_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n (define_insn \"compare_eq\"\n   [(set (match_operand:BI 0 \"register_operand\" \"=C,C\")\n         (eq:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n@@ -2326,106 +2303,6 @@\n   \"cc =%1<%2 (iu);\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_expand \"beq\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t   (pc)))]\n-  \"\"\n-{\n-  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n-  operands[1] = bfin_cc_rtx;\t/* hard register: CC */\n-  operands[2] = gen_rtx_EQ (BImode, op0, op1);\n-  /* If we have a BImode input, then we already have a compare result, and\n-     do not need to emit another comparison.  */\n-  if (GET_MODE (bfin_compare_op0) == BImode)\n-    {\n-      gcc_assert (bfin_compare_op1 == const0_rtx);\n-      emit_insn (gen_cbranchbi4 (operands[2], op0, op1, operands[0]));\n-      DONE;\n-    }\n-\n-  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bne\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t    (pc)))]\n-  \"\"\n-{\n-  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n-  /* If we have a BImode input, then we already have a compare result, and\n-     do not need to emit another comparison.  */\n-  if (GET_MODE (bfin_compare_op0) == BImode)\n-    {\n-      rtx cmp = gen_rtx_NE (BImode, op0, op1);\n-\n-      gcc_assert (bfin_compare_op1 == const0_rtx);\n-      emit_insn (gen_cbranchbi4 (cmp, op0, op1, operands[0]));\n-      DONE;\n-    }\n-\n-  operands[1] = bfin_cc_rtx;\t/* hard register: CC */\n-  operands[2] = gen_rtx_EQ (BImode, op0, op1);\n-  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bgt\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t    (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LE (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bgtu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t    (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LEU (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"blt\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t    (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LT (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bltu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LTU (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n-})\n-\n ;; Same as above, but and CC with the overflow bit generated by the first\n ;; multiplication.\n (define_insn \"flag_mul_macv2hi_parts_acconly_andcc0\"\n@@ -2490,63 +2367,25 @@\n    (set_attr \"length\" \"6\")\n    (set_attr \"seq_insns\" \"multi\")])\n \n-(define_expand \"bge\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LT (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bgeu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LTU (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"ble\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LE (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n-})\n-\n-(define_expand \"bleu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-  ]\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                       [(match_operand:SI 1 \"register_operand\" \"\")\n+                        (match_operand:SI 2 \"reg_or_const_int_operand\" \"\")])\n+                   (label_ref (match_operand 3 \"\" \"\"))\n+                   (pc)))]\n   \"\"\n {\n-  operands[1] = bfin_cc_rtx;\n-  operands[2] = gen_rtx_LEU (BImode, bfin_compare_op0, bfin_compare_op1);\n-  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+  rtx bi_compare = bfin_gen_compare (operands[0], SImode);\n+  emit_jump_insn (gen_cbranchbi4 (bi_compare, bfin_cc_rtx, CONST0_RTX (BImode),\n+\t\t\t\t  operands[3]));\n+  DONE;\n })\n \n (define_insn \"cbranchbi4\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t (match_operator 0 \"bfin_bimode_comparison_operator\"\n \t\t\t [(match_operand:BI 1 \"register_operand\" \"C\")\n \t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n \t (label_ref (match_operand 3 \"\" \"\"))\n@@ -2564,7 +2403,7 @@\n (define_insn \"cbranch_predicted_taken\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t (match_operator 0 \"bfin_bimode_comparison_operator\"\n \t\t\t [(match_operand:BI 1 \"register_operand\" \"C\")\n \t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n \t (label_ref (match_operand 3 \"\" \"\"))\n@@ -2580,7 +2419,7 @@\n (define_insn \"cbranch_with_nops\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t (match_operator 0 \"bfin_bimode_comparison_operator\"\n \t\t\t [(match_operand:BI 1 \"register_operand\" \"C\")\n \t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n \t (label_ref (match_operand 3 \"\" \"\"))\n@@ -2594,60 +2433,49 @@\n   [(set_attr \"type\" \"brcc\")\n    (set_attr \"length\" \"8\")])\n \n-;; setcc insns.  */\n-(define_expand \"seq\"\n-  [(set (match_dup 1) (eq:BI (match_dup 2) (match_dup 3)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  operands[2] = bfin_compare_op0;\n-  operands[3] = bfin_compare_op1;\n-  operands[1] = bfin_cc_rtx;\n-})\n+;; setcc insns.\n \n-(define_expand \"slt\"\n-  [(set (match_dup 1) (lt:BI (match_dup 2) (match_dup 3)))\n+(define_expand \"cstorebi4\"\n+  [(set (match_dup 4)\n+        (match_operator:BI 1 \"bfin_bimode_comparison_operator\"\n+                       [(match_operand:BI 2 \"register_operand\" \"\")\n+                        (match_operand:BI 3 \"reg_or_const_int_operand\" \"\")]))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n+       (ne:SI (match_dup 4) (const_int 0)))]\n   \"\"\n {\n-   operands[2] = bfin_compare_op0;\n-   operands[3] = bfin_compare_op1;\n-   operands[1] = bfin_cc_rtx;\n-})\n+  /* It could be expanded as a movbisi instruction, but the portable\n+     alternative produces better code.  */\n+  if (GET_CODE (operands[1]) == NE)\n+    FAIL;\n \n-(define_expand \"sle\"\n-  [(set (match_dup 1) (le:BI (match_dup 2) (match_dup 3)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-   operands[2] = bfin_compare_op0;\n-   operands[3] = bfin_compare_op1;\n-   operands[1] = bfin_cc_rtx;\n+  operands[4] = bfin_cc_rtx;\n })\n \n-(define_expand \"sltu\"\n-  [(set (match_dup 1) (ltu:BI (match_dup 2) (match_dup 3)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 1 \"ordered_comparison_operator\"\n+                       [(match_operand:SI 2 \"register_operand\" \"\")\n+                        (match_operand:SI 3 \"reg_or_const_int_operand\" \"\")]))]\n   \"\"\n {\n-   operands[2] = bfin_compare_op0;\n-   operands[3] = bfin_compare_op1;\n-   operands[1] = bfin_cc_rtx;\n-})\n+  rtx bi_compare, test;\n \n-(define_expand \"sleu\"\n-  [(set (match_dup 1) (leu:BI (match_dup 2) (match_dup 3)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-   operands[2] = bfin_compare_op0;\n-   operands[3] = bfin_compare_op1;\n-   operands[1] = bfin_cc_rtx;\n+  if (!bfin_direct_comparison_operator (operands[1], SImode))\n+    {\n+      if (!register_operand (operands[3], SImode)\n+\t  || GET_CODE (operands[1]) == NE)\n+\tFAIL;\n+      test = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[1])),\n+\t\t\t     SImode, operands[3], operands[2]);\n+    }\n+  else\n+    test = operands[1];\n+\n+  bi_compare = bfin_gen_compare (test, SImode);\n+  gcc_assert (GET_CODE (bi_compare) == NE);\n+  emit_insn (gen_movbisi (operands[0], bfin_cc_rtx));\n+  DONE;\n })\n \n (define_insn \"nop\"\n@@ -2676,13 +2504,16 @@\n   \"CC = %1;\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn \"movbisi\"\n+(define_insn_and_split \"movbisi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ne:SI (match_operand:BI 1 \"register_operand\" \"C\")\n \t       (const_int 0)))]\n   \"\"\n-  \"%0 = CC;\"\n-  [(set_attr \"length\" \"2\")])\n+  \"#\"\n+  \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:BI 1 \"register_operand\" \"\")))]\n+  \"\")\n \n (define_insn \"notbi\"\n   [(set (match_operand:BI 0 \"register_operand\" \"=C\")"}, {"sha": "bce725a7009152676438fc7d837b11b0d2a03fe9", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -172,10 +172,14 @@\n \t       && REGNO (op) <= LAST_VIRTUAL_REGISTER));\n })\n \n-;; Test for an operator valid in a conditional branch\n-(define_predicate \"bfin_cbranch_operator\"\n+;; Test for an operator valid in a BImode conditional branch\n+(define_predicate \"bfin_bimode_comparison_operator\"\n   (match_code \"eq,ne\"))\n \n+;; Test for an operator whose result is accessible with movbisi.\n+(define_predicate \"bfin_direct_comparison_operator\"\n+  (match_code \"eq,lt,le,leu,ltu\"))\n+\n ;; The following two are used to compute the addrtype attribute.  They return\n ;; true if passed a memory address usable for a 16-bit load or store using a\n ;; P or I register, respectively.  If neither matches, we know we have a"}, {"sha": "bc634ddbf3ed9138e884dbf3485015e2ced10c97", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1431,21 +1431,26 @@ cris_normal_notice_update_cc (rtx exp, rtx insn)\n       if (SET_DEST (exp) == cc0_rtx)\n \t{\n \t  CC_STATUS_INIT;\n-\t  cc_status.value1 = SET_SRC (exp);\n \n-\t  /* Handle flags for the special btstq on one bit.  */\n-\t  if (GET_CODE (SET_SRC (exp)) == ZERO_EXTRACT\n-\t      && XEXP (SET_SRC (exp), 1) == const1_rtx)\n+\t  if (GET_CODE (SET_SRC (exp)) == COMPARE\n+\t      && XEXP (SET_SRC (exp), 1) == const0_rtx)\n+\t    cc_status.value1 = XEXP (SET_SRC (exp), 0);\n+\t  else\n+\t    cc_status.value1 = SET_SRC (exp);\n+\n+          /* Handle flags for the special btstq on one bit.  */\n+\t  if (GET_CODE (cc_status.value1) == ZERO_EXTRACT\n+\t      && XEXP (cc_status.value1, 1) == const1_rtx)\n \t    {\n-\t      if (CONST_INT_P (XEXP (SET_SRC (exp), 0)))\n+\t      if (CONST_INT_P (XEXP (cc_status.value1, 0)))\n \t\t/* Using cmpq.  */\n \t\tcc_status.flags = CC_INVERTED;\n \t      else\n \t\t/* A one-bit btstq.  */\n \t\tcc_status.flags = CC_Z_IN_NOT_N;\n \t    }\n \n-\t  if (GET_CODE (SET_SRC (exp)) == COMPARE)\n+\t  else if (GET_CODE (SET_SRC (exp)) == COMPARE)\n \t    {\n \t      if (!REG_P (XEXP (SET_SRC (exp), 0))\n \t\t  && XEXP (SET_SRC (exp), 1) != const0_rtx)\n@@ -1855,6 +1860,11 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t}\n       return false;\n \n+    case ZERO_EXTRACT:\n+      if (outer_code != COMPARE)\n+        return false;\n+      /* fall through */\n+\n     case ZERO_EXTEND: case SIGN_EXTEND:\n       *total = rtx_cost (XEXP (x, 0), outer_code, speed);\n       return true;"}, {"sha": "79eb8da3b0db9c4438556db1cd6a4ff29da1b7cb", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 74, "deletions": 56, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -248,40 +248,16 @@\n \f\n ;; Test insns.\n \n-;; DImode\n-;;\n-;; Allow register and offsettable mem operands only; post-increment is\n-;; not worth the trouble.\n-\n-(define_expand \"tstdi\"\n-  [(set (cc0) (match_operand:DI 0 \"nonimmediate_operand\"))]\n-  \"\"\n-{\n-  if (TARGET_V32 && MEM_P (operands[0]))\n-    operands[0] = force_reg (DImode, operands[0]);\n-})\n-\n-(define_insn \"*tstdi_non_v32\"\n-  [(set (cc0)\n-\t(match_operand:DI 0 \"nonimmediate_operand\" \"r,o\"))]\n-  \"!TARGET_V32\"\n-  \"test.d %M0\\;ax\\;test.d %H0\")\n-\n-(define_insn \"*tstdi_v32\"\n-  [(set (cc0)\n-\t(match_operand:DI 0 \"register_operand\" \"r\"))]\n-  \"TARGET_V32\"\n-  \"cmpq 0,%M0\\;ax\\;cmpq 0,%H0\")\n-\n ;; No test insns with side-effect on the mem addressing.\n ;;\n ;; See note on cmp-insns with side-effects (or lack of them)\n \n ;; Normal named test patterns from SI on.\n \n-(define_insn \"tstsi\"\n+(define_insn \"*tstsi\"\n   [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,Q>,m\")\n+\t\t (const_int 0)))]\n   \"\"\n {\n   if (which_alternative == 0 && TARGET_V32)\n@@ -290,15 +266,10 @@\n }\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n \n-(define_expand \"tst<mode>\"\n-  [(set (cc0)\n-\t(match_operand:BW 0 \"nonimmediate_operand\"))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*tst<mode>_cmp\"\n   [(set (cc0)\n-\t(match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+\t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\")\n+\t\t (const_int 0)))]\n   \"cris_cc0_user_requires_cmp (insn)\"\n   \"@\n    cmp<m> 0,%0\n@@ -308,7 +279,8 @@\n \n (define_insn \"*tst<mode>_non_cmp\"\n   [(set (cc0)\n-\t(match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+\t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\")\n+\t\t (const_int 0)))]\n   \"!cris_cc0_user_requires_cmp (insn)\"\n   \"@\n    move<m> %0,%0\n@@ -332,24 +304,13 @@\n ;; DImode for anything else but a structure/block-mode.  Just do the\n ;; obvious stuff for the straight-forward constraint letters.\n \n-(define_expand \"cmpdi\"\n-  [(set (cc0)\n-\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:DI 1 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  if (TARGET_V32 && !REG_P (operands[0]))\n-    operands[0] = force_reg (DImode, operands[0]);\n-  if (TARGET_V32 && MEM_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-})\n-\n (define_insn \"*cmpdi_non_v32\"\n   [(set (cc0)\n-\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"r,r,r,r,r,r,o\")\n-\t\t (match_operand:DI 1 \"general_operand\" \"Kc,I,P,n,r,o,r\")))]\n+\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"rm,r,r,r,r,r,r,o\")\n+\t\t (match_operand:DI 1 \"general_operand\" \"M,Kc,I,P,n,r,o,r\")))]\n   \"!TARGET_V32\"\n   \"@\n+   test.d %M0\\;ax\\;test.d %H0\n    cmpq %1,%M0\\;ax\\;cmpq 0,%H0\n    cmpq %1,%M0\\;ax\\;cmpq -1,%H0\n    cmp%e1.%z1 %1,%M0\\;ax\\;cmpq %H1,%H0\n@@ -415,9 +376,9 @@\n    (set_attr \"cc\" \"rev\")])\n \f\n ;; The \"normal\" compare patterns, from SI on.  Special-cases with zero\n-;; should not happen.\n+;; are covered above.\n \n-(define_insn \"cmpsi\"\n+(define_insn \"*cmpsi\"\n   [(set (cc0)\n \t(compare\n \t (match_operand:SI 0 \"nonimmediate_operand\" \"r,r,r, Q>,r,r,m\")\n@@ -434,7 +395,7 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no\")\n    (set_attr \"cc\" \"normal,normal,normal,rev,normal,normal,rev\")])\n \n-(define_insn \"cmp<mode>\"\n+(define_insn \"*cmp<mode>\"\n   [(set (cc0)\n \t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,r, Q>,r,m\")\n \t\t (match_operand:BW 1 \"general_operand\"\t    \"r,Q>,r, g,r\")))]\n@@ -457,10 +418,12 @@\n ;; extends subregs for lower-size modes.  FIXME: Add testcase.\n (define_insn \"*btst\"\n   [(set (cc0)\n-\t(zero_extract\n-\t (match_operand:SI 0 \"nonmemory_operand\" \"r, r,r, r,r, r,Kp\")\n-\t (match_operand:SI 1 \"const_int_operand\" \"Kc,n,Kc,n,Kc,n,n\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"M, M,Kc,n,r, r,r\")))]\n+\t(compare\n+\t (zero_extract:SI\n+\t  (match_operand:SI 0 \"nonmemory_operand\" \"r, r,r, r,r, r,Kp\")\n+\t  (match_operand:SI 1 \"const_int_operand\" \"Kc,n,Kc,n,Kc,n,n\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\" \"M, M,Kc,n,r, r,r\"))\n+\t (const_int 0)))]\n   ;; Either it is a single bit, or consecutive ones starting at 0.\n   ;; The btst ones depend on stuff in NOTICE_UPDATE_CC.\n   \"CONST_INT_P (operands[1])\n@@ -3550,6 +3513,36 @@\n \f\n ;; Conditional branches.\n \n+(define_expand \"cbranch<mode>4\"\n+  [(set (cc0) (compare\n+\t       (match_operand:BWD 1 \"nonimmediate_operand\")\n+\t       (match_operand:BWD 2 \"general_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cbranchdi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  if (TARGET_V32 && !REG_P (operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  if (TARGET_V32 && MEM_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+})\n+\n+\n ;; We suffer from the same overflow-bit-gets-in-the-way problem as\n ;; e.g. m68k, so we have to check if overflow bit is set on all \"signed\"\n ;; conditions.\n@@ -3634,6 +3627,31 @@\n \f\n ;; Set on condition: sCC.\n \n+(define_expand \"cstoredi4\"\n+  [(set (cc0) (compare\n+\t       (match_operand:DI 2 \"nonimmediate_operand\")\n+\t       (match_operand:DI 3 \"general_operand\")))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(cc0) (const_int 0)]))]\n+  \"\"\n+{\n+  if (TARGET_V32 && !REG_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  if (TARGET_V32 && MEM_P (operands[3]))\n+    operands[3] = force_reg (DImode, operands[3]);\n+})\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (cc0) (compare\n+\t       (match_operand:BWD 2 \"nonimmediate_operand\")\n+\t       (match_operand:BWD 3 \"general_operand\")))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(cc0) (const_int 0)]))]\n+  \"\"\n+  \"\")\n+\n ;; Like bCC, we have to check the overflow bit for\n ;; signed conditions.\n "}, {"sha": "386fab9fe4374eda7c2919029cbc73b2d9963b36", "filename": "gcc/config/crx/crx-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -62,10 +62,6 @@ extern void crx_print_operand (FILE *, rtx, int);\n extern void crx_print_operand_address (FILE *, rtx);\n \n /* Misc functions called from crx.md.  */\n-extern rtx crx_expand_compare (enum rtx_code, enum machine_mode);\n-extern void crx_expand_branch (enum rtx_code, rtx);\n-extern void crx_expand_scond (enum rtx_code, rtx);\n-\n extern void crx_expand_movmem_single (rtx, rtx, rtx, rtx, rtx, unsigned HOST_WIDE_INT *);\n extern int crx_expand_movmem (rtx, rtx, rtx, rtx);\n #endif /* RTX_CODE */"}, {"sha": "cc3248fb5eee1ccb3c5fd26e29bf7e58ad9a91cb", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -124,10 +124,6 @@ static enum machine_mode output_memory_reference_mode;\n /* Table of machine attributes.  */\n const struct attribute_spec crx_attribute_table[];\n \n-/* Test and compare insns use these globals to generate branch insns.  */\n-rtx crx_compare_op0 = NULL_RTX;\n-rtx crx_compare_op1 = NULL_RTX;\n-\n /*****************************************************************************/\n /* TARGETM FUNCTION PROTOTYPES\t\t\t\t\t\t     */\n /*****************************************************************************/\n@@ -1217,43 +1213,6 @@ crx_expand_movmem (rtx dstbase, rtx srcbase, rtx count_exp, rtx align_exp)\n   return 1;\n }\n \n-rtx\n-crx_expand_compare (enum rtx_code code, enum machine_mode mode)\n-{\n-  rtx op0, op1, cc_reg, ret;\n-\n-  op0 = crx_compare_op0;\n-  op1 = crx_compare_op1;\n-\n-  /* Emit the compare that writes into CC_REGNUM) */\n-  cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n-  ret = gen_rtx_COMPARE (CCmode, op0, op1);\n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg, ret));\n-  /* debug_rtx (get_last_insn ()); */\n-\n-  /* Return the rtx for using the result in CC_REGNUM */\n-  return gen_rtx_fmt_ee (code, mode, cc_reg, const0_rtx);\n-}\n-\n-void\n-crx_expand_branch (enum rtx_code code, rtx label)\n-{\n-  rtx tmp = crx_expand_compare (code, VOIDmode);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t      pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n-  /* debug_rtx (get_last_insn ()); */\n-}\n-\n-void\n-crx_expand_scond (enum rtx_code code, rtx dest)\n-{\n-  rtx tmp = crx_expand_compare (code, GET_MODE (dest));\n-  emit_move_insn (dest, tmp);\n-  /* debug_rtx (get_last_insn ()); */\n-}\n-\n static void\n mpushpop_str (char *stringbuffer, const char *mnemonic, char *mask)\n {"}, {"sha": "cac465701bfc2972beaf56740aac8e6d293c56a9", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -520,11 +520,4 @@ struct cumulative_args\n \n #define FUNCTION_MODE\tQImode\n \n-/*****************************************************************************/\n-/* EXTERNAL DECLARATIONS FOR VARIABLES DEFINED IN CRX.C\t\t\t     */\n-/*****************************************************************************/\n-\n-extern rtx crx_compare_op0;    /* operand 0 for comparisons */\n-extern rtx crx_compare_op1;    /* operand 1 for comparisons */\n-\n #endif /* ! GCC_CRX_H */"}, {"sha": "229e345d32fcf89d2be06feeaac8dd8033f4b8da", "filename": "gcc/config/crx/crx.md", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fcrx%2Fcrx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -63,6 +63,10 @@\n   (ior (match_code \"symbol_ref\")\n        (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"cc_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == CC_REGNUM\")))\n+\n (define_predicate \"nosp_reg_operand\"\n   (and (match_operand 0 \"register_operand\")\n        (match_test \"REGNO (op) != SP_REGNUM\")))\n@@ -107,8 +111,6 @@\n (define_code_iterator mima_oprnd [smax umax smin umin])\n (define_code_attr mimaIsa [(smax \"maxs\") (umax \"maxu\") (smin \"mins\") (umin \"minu\")])\n \n-(define_code_iterator any_cond [eq ne gt gtu lt ltu ge geu le leu])\n-\n ;;  Addition Instructions\n \n (define_insn \"adddi3\"\n@@ -522,9 +524,21 @@\n \n ;;  Compare and Branch Instructions\n \n+(define_insn \"cbranchcc4\"\n+  [(set (pc)\n+       (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:CC 1 \"cc_reg_operand\" \"r\")\n+\t\t\t(match_operand 2 \"cst4_operand\" \"L\")])\n+                     (label_ref (match_operand 3 \"\"))\n+                     (pc)))]\n+  \"\"\n+  \"b%d0\\t%l3\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n (define_insn \"cbranch<mode>4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n \t\t\t[(match_operand:CRXIM 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:CRXIM 2 \"reg_or_cst4_operand\" \"rL\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n@@ -535,18 +549,18 @@\n   [(set_attr \"length\" \"6\")]\n )\n \n-;;  Compare Instructions\n \n-(define_expand \"cmp<mode>\"\n+;;  Scond Instructions\n+\n+(define_expand \"cstore<mode>4\"\n   [(set (reg:CC CC_REGNUM)\n-\t(compare:CC (match_operand:CRXIM 0 \"register_operand\" \"\")\n-\t\t    (match_operand:CRXIM 1 \"nonmemory_operand\" \"\")))]\n+\t(compare:CC (match_operand:CRXIM 2 \"register_operand\" \"\")\n+\t\t    (match_operand:CRXIM 3 \"nonmemory_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t[(reg:CC CC_REGNUM) (const_int 0)]))]\n+  \"\"\n   \"\"\n-  {\n-    crx_compare_op0 = operands[0];\n-    crx_compare_op1 = operands[1];\n-    DONE;\n-  }\n )\n \n (define_insn \"cmp<mode>_internal\"\n@@ -558,48 +572,9 @@\n   [(set_attr \"length\" \"2,<lImmArith>\")]\n )\n \n-;;  Conditional Branch Instructions\n-\n-(define_expand \"b<code>\"\n-  [(set (pc)\n-\t(if_then_else (any_cond (reg:CC CC_REGNUM)\n-\t\t\t\t(const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  {\n-    crx_expand_branch (<CODE>, operands[0]);\n-    DONE;\n-  }\n-)\n-\n-(define_insn \"bCOND_internal\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(reg:CC CC_REGNUM)\n-\t\t\t (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"b%d0\\t%l1\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-;;  Scond Instructions\n-\n-(define_expand \"s<code>\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-  \t(any_cond:SI (reg:CC CC_REGNUM) (const_int 0)))]\n-  \"\"\n-  {\n-    crx_expand_scond (<CODE>, operands[0]);\n-    DONE;\n-  }\n-)\n-\n (define_insn \"sCOND_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 1 \"comparison_operator\"\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n \t  [(reg:CC CC_REGNUM) (const_int 0)]))]\n   \"\"\n   \"s%d1\\t%0\""}, {"sha": "5642c548a2991624cef5aa37b3882193239dcc71", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -48,12 +48,6 @@\n /*}}}*/\n /*{{{  Function Prologues & Epilogues */ \n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-\n-struct rtx_def * fr30_compare_op0;\n-struct rtx_def * fr30_compare_op1;\n-\n /* The FR30 stack looks like this:\n \n              Before call                       After call"}, {"sha": "b958a678db4710a91fc4f9ce2fc9290e74ad04eb", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1105,16 +1105,6 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n #define inhibit_libc\n #endif\n \n-/*}}}*/ \f\n-/*{{{  Exported variables */ \n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def * fr30_compare_op0;\n-extern struct rtx_def * fr30_compare_op1;\n-\n /*}}}*/ \f\n \n /* Local Variables: */"}, {"sha": "fa115c4cfa115134da30bf15fb2b5d9ad91f790c", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 7, "deletions": 169, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -916,23 +916,7 @@\n ;;}}} \f\n ;;{{{ Comparisons \n \n-;; Note, we store the operands in the comparison insns, and use them later\n-;; when generating the branch or scc operation.\n-\n-;; First the routines called by the machine independent part of the compiler\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 16)\n-        (compare:CC (match_operand:SI 0 \"register_operand\"  \"\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"{\n-  fr30_compare_op0 = operands[0];\n-  fr30_compare_op1 = operands[1];\n-  DONE;\n-  }\"\n-)\n-\n-;; Now, the actual comparisons, generated by the branch and/or scc operations\n+;; The actual comparisons, generated by the cbranch and/or cstore expanders\n \n (define_insn \"*cmpsi_internal\"\n   [(set (reg:CC 16)\n@@ -951,165 +935,19 @@\n ;; Define_expands called by the machine independent part of the compiler\n ;; to allocate a new comparison register\n \n-(define_expand \"beq\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (eq:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bne\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (ne:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"blt\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (lt:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"ble\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (le:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bgt\"\n+(define_expand \"cbranchsi4\"\n   [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n+\t(compare:CC (match_operand:SI 1 \"register_operand\"  \"\")\n+\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n    (set (pc)\n-\t(if_then_else (gt:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator:CC 0 \"ordered_comparison_operator\"\n+\t\t       [(reg:CC 16) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bge\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (ge:CC (reg:CC 16)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bltu\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (ltu:CC (reg:CC 16)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bleu\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (leu:CC (reg:CC 16)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n-\n-(define_expand \"bgtu\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (gtu:CC (reg:CC 16)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n   \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n )\n \n-(define_expand \"bgeu\"\n-  [(set (reg:CC 16)\n-\t(compare:CC (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (pc)\n-\t(if_then_else (geu:CC (reg:CC 16)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"{\n-  operands[1] = fr30_compare_op0;\n-  operands[2] = fr30_compare_op1;\n-  }\"\n-)\n \n ;; Actual branches.  We must allow for the (label_ref) and the (pc) to be\n ;; swapped.  If they are swapped, it reverses the sense of the branch."}, {"sha": "98ada2286a52242a0631b39226610e7ae6f46827", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -81,8 +81,8 @@ extern const char *output_move_single\t(rtx *, rtx);\n extern const char *output_move_double\t(rtx *, rtx);\n extern const char *output_condmove_single\n \t\t\t\t\t(rtx *, rtx);\n-extern int frv_emit_cond_branch\t\t(enum rtx_code, rtx);\n-extern int frv_emit_scc\t\t\t(enum rtx_code, rtx);\n+extern int frv_emit_cond_branch\t\t(rtx *);\n+extern int frv_emit_scc\t\t\t(rtx *);\n extern rtx frv_split_scc\t\t(rtx, rtx, rtx, rtx, HOST_WIDE_INT);\n extern int frv_emit_cond_move\t\t(rtx, rtx, rtx, rtx);\n extern rtx frv_split_cond_move\t\t(rtx *);"}, {"sha": "e5476523f13a831001664a3f65427e5d2939bd2a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -193,11 +193,6 @@ typedef struct\n   int base_offset;\n } frv_frame_accessor_t;\n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-rtx frv_compare_op0;\n-rtx frv_compare_op1;\n-\n /* Conditional execution support gathered together in one structure.  */\n typedef struct\n   {\n@@ -4768,51 +4763,50 @@ frv_emit_comparison (enum rtx_code test, rtx op0, rtx op1)\n }\n \n \f\n-/* Emit code for a conditional branch.  The comparison operands were previously\n-   stored in frv_compare_op0 and frv_compare_op1.\n-\n+/* Emit code for a conditional branch.\n    XXX: I originally wanted to add a clobber of a CCR register to use in\n    conditional execution, but that confuses the rest of the compiler.  */\n \n int\n-frv_emit_cond_branch (enum rtx_code test, rtx label)\n+frv_emit_cond_branch (rtx operands[])\n {\n   rtx test_rtx;\n   rtx label_ref;\n   rtx if_else;\n-  rtx cc_reg = frv_emit_comparison (test, frv_compare_op0, frv_compare_op1);\n+  enum rtx_code test = GET_CODE (operands[0]);\n+  rtx cc_reg = frv_emit_comparison (test, operands[1], operands[2]);\n   enum machine_mode cc_mode = GET_MODE (cc_reg);\n \n   /* Branches generate:\n \t(set (pc)\n \t     (if_then_else (<test>, <cc_reg>, (const_int 0))\n \t\t\t    (label_ref <branch_label>)\n \t\t\t    (pc))) */\n-  label_ref = gen_rtx_LABEL_REF (VOIDmode, label);\n+  label_ref = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n   test_rtx = gen_rtx_fmt_ee (test, cc_mode, cc_reg, const0_rtx);\n   if_else = gen_rtx_IF_THEN_ELSE (cc_mode, test_rtx, label_ref, pc_rtx);\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_else));\n   return TRUE;\n }\n \n \f\n-/* Emit code to set a gpr to 1/0 based on a comparison.  The comparison\n-   operands were previously stored in frv_compare_op0 and frv_compare_op1.  */\n+/* Emit code to set a gpr to 1/0 based on a comparison.  */\n \n int\n-frv_emit_scc (enum rtx_code test, rtx target)\n+frv_emit_scc (rtx operands[])\n {\n   rtx set;\n   rtx test_rtx;\n   rtx clobber;\n   rtx cr_reg;\n-  rtx cc_reg = frv_emit_comparison (test, frv_compare_op0, frv_compare_op1);\n+  enum rtx_code test = GET_CODE (operands[1]);\n+  rtx cc_reg = frv_emit_comparison (test, operands[2], operands[3]);\n \n   /* SCC instructions generate:\n \t(parallel [(set <target> (<test>, <cc_reg>, (const_int 0))\n \t\t   (clobber (<ccr_reg>))])  */\n   test_rtx = gen_rtx_fmt_ee (test, SImode, cc_reg, const0_rtx);\n-  set = gen_rtx_SET (VOIDmode, target, test_rtx);\n+  set = gen_rtx_SET (VOIDmode, operands[0], test_rtx);\n \n   cr_reg = ((TARGET_ALLOC_CC)\n \t    ? gen_reg_rtx (CC_CCRmode)\n@@ -4874,7 +4868,8 @@ frv_emit_cond_move (rtx dest, rtx test_rtx, rtx src1, rtx src2)\n   rtx cr_reg;\n   rtx if_rtx;\n   enum rtx_code test = GET_CODE (test_rtx);\n-  rtx cc_reg = frv_emit_comparison (test, frv_compare_op0, frv_compare_op1);\n+  rtx cc_reg = frv_emit_comparison (test,\n+\t\t\t\t    XEXP (test_rtx, 0), XEXP (test_rtx, 1));\n   enum machine_mode cc_mode = GET_MODE (cc_reg);\n \n   /* Conditional move instructions generate:"}, {"sha": "e510de08901169d4e72e656a4a886a1b873d863d", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2913,9 +2913,6 @@ enum frv_builtins\n /* Enable prototypes on the call rtl functions.  */\n #define MD_CALL_PROTOTYPES 1\n \n-extern GTY(()) rtx frv_compare_op0;\t\t\t/* operand save for */\n-extern GTY(()) rtx frv_compare_op1;\t\t\t/* comparison generation */\n-\n #define CPU_UNITS_QUERY 1\n \n #ifdef __FRV_FDPIC__"}, {"sha": "9315f9b623ca21c2eece8654d418799e16d9c795", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 43, "deletions": 287, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -3734,59 +3734,7 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; Note, we store the operands in the comparison insns, and use them later\n-;; when generating the branch or scc operation.\n-\n-;; First the routines called by the machine independent part of the compiler\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-        (compare (match_operand:SI 0 \"integer_register_operand\" \"\")\n-  \t\t (match_operand:SI 1 \"gpr_or_int10_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  frv_compare_op0 = operands[0];\n-  frv_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-;(define_expand \"cmpdi\"\n-;  [(set (cc0)\n-;        (compare (match_operand:DI 0 \"register_operand\" \"\")\n-;  \t\t (match_operand:DI 1 \"nonmemory_operand\" \"\")))]\n-;  \"\"\n-;  \"\n-;{\n-;  frv_compare_op0 = operands[0];\n-;  frv_compare_op1 = operands[1];\n-;  DONE;\n-;}\")\n-\n-(define_expand \"cmpsf\"\n- [(set (cc0)\n-       (compare (match_operand:SF 0 \"fpr_operand\" \"\")\n- \t\t (match_operand:SF 1 \"fpr_operand\" \"\")))]\n- \"TARGET_HARD_FLOAT\"\n- \"\n-{\n-  frv_compare_op0 = operands[0];\n-  frv_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (cc0)\n-        (compare (match_operand:DF 0 \"fpr_operand\" \"\")\n-  \t\t (match_operand:DF 1 \"fpr_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE\"\n-  \"\n-{\n-  frv_compare_op0 = operands[0];\n-  frv_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-;; Now, the actual comparisons, generated by the branch and/or scc operations\n+;; The comparisons are generated by the branch and/or scc operations\n \n (define_insn \"cmpsi_cc\"\n   [(set (match_operand:CC 0 \"icc_operand\" \"=t,t\")\n@@ -3847,137 +3795,31 @@\n ;; ::::::::::::::::::::\n \n ;; Define_expands called by the machine independent part of the compiler\n-;; to allocate a new comparison register.  Each of these named patterns\n-;; must be present, and they cannot be amalgamated into one pattern.\n-;;\n-;; If a fixed condition code register is being used, (as opposed to, say,\n-;; using cc0), then the expands should look like this:\n-;;\n-;; (define_expand \"<name_of_test>\"\n-;;   [(set (reg:CC <number_of_CC_register>)\n-;; \t(compare:CC (match_dup 1)\n-;; \t\t    (match_dup 2)))\n-;;    (set (pc)\n-;; \t(if_then_else (eq:CC (reg:CC <number_of_CC_register>)\n-;; \t\t\t     (const_int 0))\n-;; \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-;; \t\t      (pc)))]\n-;;   \"\"\n-;;   \"{\n-;;     operands[1] = frv_compare_op0;\n-;;     operands[2] = frv_compare_op1;\n-;;   }\"\n-;; )\n-\n-(define_expand \"beq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (EQ, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bne\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (NE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"blt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (LT, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"ble\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (LE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (GT, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (GE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (LTU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (LEU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n+;; to allocate a new comparison register.\n \n-(define_expand \"bgtu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (GTU, operands[0]))\n-    FAIL;\n+(define_expand \"cbranchdf4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:DF 1 \"fpr_operand\" \"\")\n+          (match_operand:DF 2 \"fpr_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE\"\n+  { if (frv_emit_cond_branch (operands)) DONE; gcc_unreachable (); })\n \n-  DONE;\n-}\")\n+(define_expand \"cbranchsf4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:SF 1 \"fpr_operand\" \"\")\n+          (match_operand:SF 2 \"fpr_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"TARGET_HARD_FLOAT\"\n+  { if (frv_emit_cond_branch (operands)) DONE; gcc_unreachable (); })\n \n-(define_expand \"bgeu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranchsi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:SI 1 \"integer_register_operand\" \"\")\n+          (match_operand:SI 2 \"gpr_or_int10_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  \"\n-{\n-  if (! frv_emit_cond_branch (GEU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n+  { if (frv_emit_cond_branch (operands)) DONE; gcc_unreachable (); })\n \n ;; Actual branches.  We must allow for the (label_ref) and the (pc) to be\n ;; swapped.  If they are swapped, it reverses the sense of the branch.\n@@ -4142,115 +3984,29 @@\n ;; Define_expands called by the machine independent part of the compiler\n ;; to allocate a new comparison register\n \n-(define_expand \"seq\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (EQ, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sne\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (NE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"slt\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (LT, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sle\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (LE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (GT, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sge\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (GE, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (LTU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (LEU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"sgtu\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (GTU, operands[0]))\n-    FAIL;\n-\n-  DONE;\n-}\")\n+(define_expand \"cstoredf4\"\n+  [(use (match_operator:SI 1 \"ordered_comparison_operator\"\n+         [(match_operand:DF 2 \"fpr_operand\")\n+          (match_operand:DF 3 \"fpr_operand\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE\"\n+  { if (frv_emit_scc (operands)) DONE; else FAIL; })\n \n-(define_expand \"sgeu\"\n-  [(match_operand:SI 0 \"integer_register_operand\" \"\")]\n-  \"TARGET_SCC\"\n-  \"\n-{\n-  if (! frv_emit_scc (GEU, operands[0]))\n-    FAIL;\n+(define_expand \"cstoresf4\"\n+  [(use (match_operator:SI 1 \"ordered_comparison_operator\"\n+         [(match_operand:SF 2 \"fpr_operand\")\n+          (match_operand:SF 3 \"fpr_operand\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"TARGET_HARD_FLOAT\"\n+  { if (frv_emit_scc (operands)) DONE; else FAIL; })\n \n-  DONE;\n-}\")\n+(define_expand \"cstoresi4\"\n+  [(use (match_operator:SI 1 \"ordered_comparison_operator\"\n+         [(match_operand:SI 2 \"integer_register_operand\")\n+          (match_operand:SI 3 \"gpr_or_int10_operand\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"\"\n+  { if (frv_emit_scc (operands)) DONE; else FAIL; })\n \n (define_insn \"*scc_int\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")"}, {"sha": "4a0b64790a772d76cf8c75150ca695e53d168754", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -44,7 +44,8 @@ extern const char *output_logical_op (enum machine_mode, rtx *);\n extern unsigned int compute_logical_op_length (enum machine_mode,\n \t\t\t\t\t       rtx *);\n extern int compute_logical_op_cc (enum machine_mode, rtx *);\n-extern void h8300_expand_branch (enum rtx_code, rtx);\n+extern void h8300_expand_branch (rtx[]);\n+extern void h8300_expand_store (rtx[]);\n extern bool expand_a_shift (enum machine_mode, int, rtx[]);\n extern int h8300_shift_needs_scratch_p (int, enum machine_mode);\n extern int expand_a_rotate (rtx[]);"}, {"sha": "9946d28078f9c8649e59cf1e777d58d02911bc86", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1226,6 +1226,11 @@ h8300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n       *total = 20;\n       return true;\n \n+    case COMPARE:\n+      if (XEXP (x, 1) == const0_rtx)\n+\t*total = 0;\n+      return false;\n+\n     case AND:\n       if (!h8300_dst_operand (XEXP (x, 0), VOIDmode)\n \t  || !h8300_src_operand (XEXP (x, 1), VOIDmode))\n@@ -3503,16 +3508,42 @@ compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n /* Expand a conditional branch.  */\n \n void\n-h8300_expand_branch (enum rtx_code code, rtx label)\n+h8300_expand_branch (rtx operands[])\n {\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx op0 = operands[1];\n+  rtx op1 = operands[2];\n+  rtx label = operands[3];\n   rtx tmp;\n \n+  tmp = gen_rtx_COMPARE (VOIDmode, op0, op1);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, tmp));\n+\n   tmp = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n   tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t      pc_rtx);\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n }\n+\n+\n+/* Expand a conditional store.  */\n+\n+void\n+h8300_expand_store (rtx operands[])\n+{\n+  rtx dest = operands[0];\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = operands[2];\n+  rtx op1 = operands[3];\n+  rtx tmp;\n+\n+  tmp = gen_rtx_COMPARE (VOIDmode, op0, op1);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, tmp));\n+\n+  tmp = gen_rtx_fmt_ee (code, GET_MODE (dest), cc0_rtx, const0_rtx);\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, tmp));\n+}\n \f\n /* Shifts.\n "}, {"sha": "c05e8c6966ff41efeb3cfacba8f95271c06853de", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 252, "deletions": 243, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -961,28 +961,33 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract:HI (match_operand:QI 0 \"bit_memory_operand\" \"r,U\")\n-\t\t\t       (const_int 1)\n-\t\t\t       (match_operand 1 \"const_int_operand\" \"n,n\")))]\n+  [(set (cc0) (compare\n+\t       (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"r,U\")\n+\t\t\t        (const_int 1)\n+\t\t\t        (match_operand 1 \"const_int_operand\" \"n,n\"))\n+\t       (const_int 0)))]\n   \"TARGET_H8300\"\n   \"btst\t%Z1,%Y0\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"set_zn,set_zn\")])\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"r\")\n-\t\t\t       (const_int 1)\n-\t\t\t       (match_operand 1 \"const_int_operand\" \"n\")))]\n+  [(set (cc0) (compare\n+\t       (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t        (const_int 1)\n+\t\t\t        (match_operand 1 \"const_int_operand\" \"n\"))\n+\t       (const_int 0)))]\n   \"TARGET_H8300\"\n   \"btst\t%Z1,%Y0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_insn_and_split \"*tst_extzv_1_n\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 1 \"const_int_operand\" \"n,n,n\")))\n+  [(set (cc0) (compare\n+\t       (zero_extract:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\")\n+\t\t\t\t(const_int 1)\n+\t\t\t\t(match_operand 1 \"const_int_operand\" \"n,n,n\"))\n+\t       (const_int 0)))\n    (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\"\n   \"@\n@@ -993,29 +998,31 @@\n    && !OK_FOR_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n-   (parallel [(set (cc0) (zero_extract:SI (match_dup 2)\n-\t\t\t\t\t  (const_int 1)\n-\t\t\t\t\t  (match_dup 1)))\n+   (parallel [(set (cc0) (compare (zero_extract:SI (match_dup 2)\n+\t\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t\t   (match_dup 1))\n+\t\t\t\t  (const_int 0)))\n \t      (clobber (scratch:QI))])]\n   \"\"\n   [(set_attr \"length\" \"2,8,10\")\n    (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t       (const_int 1)\n-\t\t\t       (match_operand 1 \"const_int_operand\" \"n\")))]\n+  [(set (cc0) (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t        (const_int 1)\n+\t\t\t\t        (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && INTVAL (operands[1]) <= 15\"\n   \"btst\t%Z1,%Y0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_insn_and_split \"*tstsi_upper_bit\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 1 \"const_int_operand\" \"n\")))\n+  [(set (cc0) (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t        (const_int 1)\n+\t\t\t\t        (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t       (const_int 0)))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && INTVAL (operands[1]) >= 16\"\n@@ -1026,29 +1033,31 @@\n \t\t\t(const_int -65536))\n \t\t(lshiftrt:SI (match_dup 0)\n \t\t\t     (const_int 16))))\n-   (set (cc0)\n-\t(zero_extract:SI (match_dup 2)\n-\t\t\t (const_int 1)\n-\t\t\t (match_dup 3)))]\n+   (set (cc0) (compare (zero_extract:SI (match_dup 2)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t        (match_dup 3))\n+\t\t       (const_int 0)))]\n   \"operands[3] = GEN_INT (INTVAL (operands[1]) - 16);\")\n \n (define_insn \"*tstsi_variable_bit\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t (const_int 7))))]\n+  [(set (cc0) (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t\t\t(const_int 7)))\n+\t\t       (const_int 0)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n   \"btst\t%w1,%w0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_insn_and_split \"*tstsi_variable_bit_qi\"\n   [(set (cc0)\n-\t(zero_extract:SI (zero_extend:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\"))\n-\t\t\t (const_int 1)\n-\t\t\t (and:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n-\t\t\t\t (const_int 7))))\n+\t(compare\n+\t (zero_extract:SI (zero_extend:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\"))\n+\t\t\t  (const_int 1)\n+\t\t\t  (and:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+\t\t\t\t  (const_int 7)))\n+         (const_int 0)))\n    (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n   \"(TARGET_H8300H || TARGET_H8300S)\"\n   \"@\n@@ -1059,55 +1068,59 @@\n    && !OK_FOR_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n-   (parallel [(set (cc0) (zero_extract:SI (zero_extend:SI (match_dup 2))\n-\t\t\t\t\t  (const_int 1)\n-\t\t\t\t\t  (and:SI (match_dup 1)\n-\t\t\t\t\t\t  (const_int 7))))\n+   (parallel [(set (cc0) (compare (zero_extract:SI (zero_extend:SI (match_dup 2))\n+\t\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t\t   (and:SI (match_dup 1)\n+\t\t\t\t\t\t\t   (const_int 7)))\n+\t\t\t\t  (const_int 0)))\n \t      (clobber (scratch:QI))])]\n   \"\"\n   [(set_attr \"length\" \"2,8,10\")\n    (set_attr \"cc\" \"set_zn,set_zn,set_zn\")])\n \n-(define_insn \"tstqi\"\n-  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"r\"))]\n+(define_insn \"*tstqi\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t       (const_int 0)))]\n   \"\"\n   \"mov.b\t%X0,%X0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"tsthi\"\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"r\"))]\n+(define_insn \"*tsthi\"\n+  [(set (cc0) (compare (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t       (const_int 0)))]\n   \"\"\n   \"mov.w\t%T0,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"*tsthi_upper\"\n-  [(set (cc0)\n-\t(and:HI (match_operand:HI 0 \"register_operand\" \"r\")\n-\t\t(const_int -256)))]\n+  [(set (cc0) (compare (and:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t       (const_int -256))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"mov.b\t%t0,%t0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+(define_insn \"*tstsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t       (const_int 0)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n   \"mov.l\t%S0,%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"*tstsi_upper\"\n-  [(set (cc0)\n-\t(and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t(const_int -65536)))]\n+  [(set (cc0) (compare (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t       (const_int -65536))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"mov.w\t%e0,%e0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"cmpqi\"\n+(define_insn \"*cmpqi\"\n   [(set (cc0)\n \t(compare (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n \t\t (match_operand:QI 1 \"h8300_src_operand\" \"rQi\")))]\n@@ -1116,19 +1129,6 @@\n   [(set_attr \"length_table\" \"addb\")\n    (set_attr \"cc\" \"compare\")])\n \n-(define_expand \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"h8300_dst_operand\" \"\")\n-\t\t (match_operand:HI 1 \"h8300_src_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* Force operand1 into a register if we're compiling\n-     for the H8/300.  */\n-  if (GET_CODE (operands[1]) != REG && TARGET_H8300)\n-    operands[1] = force_reg (HImode, operands[1]);\n-}\")\n-\n (define_insn \"*cmphi_h8300_znvc\"\n   [(set (cc0)\n \t(compare (match_operand:HI 0 \"register_operand\" \"r\")\n@@ -2155,55 +2155,37 @@\n \n ;; Conditional jump instructions\n \n-(define_expand \"ble\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (LE, operands[0]); DONE;\")\n-\n-(define_expand \"bleu\"\n-  [(match_operand 0 \"\" \"\")]\n+(define_expand \"cbranchqi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:QI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:QI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  \"h8300_expand_branch (LEU, operands[0]); DONE;\")\n+  \"h8300_expand_branch (operands); DONE;\")\n \n-(define_expand \"bge\"\n-  [(match_operand 0 \"\" \"\")]\n+(define_expand \"cbranchhi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:HI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:HI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  \"h8300_expand_branch (GE, operands[0]); DONE;\")\n-\n-(define_expand \"bgeu\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (GEU, operands[0]); DONE;\")\n-\n-(define_expand \"blt\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (LT, operands[0]); DONE;\")\n-\n-(define_expand \"bltu\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (LTU, operands[0]); DONE;\")\n-\n-(define_expand \"bgt\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (GT, operands[0]); DONE;\")\n-\n-(define_expand \"bgtu\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (GTU, operands[0]); DONE;\")\n-\n-(define_expand \"beq\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (EQ, operands[0]); DONE;\")\n+  \"\n+{\n+  /* Force operand1 into a register if we're compiling\n+     for the H8/300.  */\n+  if ((GET_CODE (operands[2]) != REG && operands[2] != const0_rtx)\n+      && TARGET_H8300)\n+    operands[2] = force_reg (HImode, operands[2]);\n+  h8300_expand_branch (operands); DONE;\n+}\")\n \n-(define_expand \"bne\"\n-  [(match_operand 0 \"\" \"\")]\n-  \"\"\n-  \"h8300_expand_branch (NE, operands[0]); DONE;\")\n+(define_expand \"cbranchsi4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+         [(match_operand:SI 1 \"h8300_dst_operand\" \"\")\n+          (match_operand:SI 2 \"h8300_src_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"h8300_expand_branch (operands); DONE;\")\n \n (define_insn \"branch_true\"\n   [(set (pc)\n@@ -3019,8 +3001,8 @@\n    (clobber (match_operand:QI 3 \"register_operand\" \"\"))]\n   \"epilogue_completed\n    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n-  [(set (cc0)\n-\t(match_dup 1))\n+  [(set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (le (cc0) (const_int 0))\n \t\t      (label_ref (match_dup 5))\n@@ -3032,8 +3014,8 @@\n       (clobber (scratch:QI))])\n    (set (match_dup 1)\n \t(plus:QI (match_dup 1) (const_int -1)))\n-   (set (cc0)\n-\t(match_dup 1))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (ne (cc0) (const_int 0))\n \t\t      (label_ref (match_dup 4))\n@@ -3052,8 +3034,8 @@\n    && !find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\"\n   [(set (match_dup 3)\n \t(match_dup 1))\n-   (set (cc0)\n-\t(match_dup 3))\n+   (set (cc0) (compare (match_dup 3)\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (le (cc0) (const_int 0))\n \t\t      (label_ref (match_dup 5))\n@@ -3065,8 +3047,8 @@\n       (clobber (scratch:QI))])\n    (set (match_dup 3)\n \t(plus:QI (match_dup 3) (const_int -1)))\n-   (set (cc0)\n-\t(match_dup 3))\n+   (set (cc0) (compare (match_dup 3)\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (ne (cc0) (const_int 0))\n \t\t      (label_ref (match_dup 4))\n@@ -3413,17 +3395,29 @@\n   [(set_attr \"cc\" \"none_0hit\")\n    (set_attr \"length_table\" \"bitfield\")])\n \n-(define_expand \"seq\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(eq:HI (cc0) (const_int 0)))]\n+(define_expand \"cstoreqi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:QI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:QI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n   \"TARGET_H8300SX\"\n-  \"\")\n+  \"h8300_expand_store (operands); DONE;\")\n \n-(define_expand \"sne\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ne:HI (cc0) (const_int 0)))]\n+(define_expand \"cstorehi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:HI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:HI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n   \"TARGET_H8300SX\"\n-  \"\")\n+  \"h8300_expand_store (operands); DONE;\")\n+\n+(define_expand \"cstoresi4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:SI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:SI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:HI 0 \"register_operand\"))]\n+  \"TARGET_H8300SX\"\n+  \"h8300_expand_store (operands); DONE;\")\n \n (define_insn \"*bstzhireg\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -3451,13 +3445,7 @@\n   [(set (cc0) (match_dup 5))\n    (set (zero_extract:QI (match_dup 0) (const_int 1) (match_dup 1))\n \t(match_op_dup:QI 2 [(cc0) (const_int 0)]))]\n-  \"\n-{\n-  if (operands[4] == const0_rtx && GET_CODE (operands[3]) == REG)\n-    operands[5] = operands[3];\n-  else\n-    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);\n-}\"\n+  \"operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);\"\n   [(set_attr \"cc\" \"set_znv,compare\")])\n    \n (define_insn \"*bstz\"\n@@ -3499,13 +3487,7 @@\n \t(if_then_else:QI\n \t (match_op_dup 1 [(cc0) (const_int 0)])\n \t (ior:QI (match_dup 4) (match_dup 5)) (match_dup 4)))]\n-  \"\n-{\n-  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n-    operands[6] = operands[2];\n-  else\n-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-}\"\n+  \"operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\"\n   [(set_attr \"cc\" \"set_znv,compare\")])\n    \n (define_insn \"*condbset\"\n@@ -3541,13 +3523,7 @@\n \t(if_then_else:QI\n \t (match_op_dup 1 [(cc0) (const_int 0)])\n \t (and:QI (match_dup 4) (match_dup 5)) (match_dup 4)))]\n-  \"\n-{\n-  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n-    operands[6] = operands[2];\n-  else\n-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-}\"\n+  \"operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\"\n   [(set_attr \"cc\" \"set_znv,compare\")])\n    \n (define_insn \"*condbclr\"\n@@ -3587,13 +3563,7 @@\n \t\t (ashift:QI (const_int 1)\n \t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n \t (match_dup 4)))]\n-  \"\n-{\n-  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n-    operands[6] = operands[2];\n-  else\n-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-}\"\n+  \"operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\"\n   [(set_attr \"cc\" \"set_znv,compare\")])\n    \n (define_insn \"*condbsetreg\"\n@@ -3634,13 +3604,7 @@\n \t\t (ashift:QI (const_int 1)\n \t\t\t    (match_operand:QI 5 \"register_operand\" \"r,r\")))\n \t (match_dup 4)))]\n-  \"\n-{\n-  if (operands[3] == const0_rtx && GET_CODE (operands[2]) == REG)\n-    operands[6] = operands[2];\n-  else\n-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\n-}\"\n+  \"operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);\"\n   [(set_attr \"cc\" \"set_znv,compare\")])\n    \n (define_insn \"*condbclrreg\"\n@@ -3878,10 +3842,10 @@\n   \"(TARGET_H8300H || TARGET_H8300S)\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_dup 1)\n-\t\t\t (const_int 1)\n-\t\t\t (const_int 0)))\n+  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (eq (cc0)\n \t\t\t  (const_int 0))\n@@ -3901,10 +3865,10 @@\n   \"(TARGET_H8300H || TARGET_H8300S)\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_dup 1)\n-\t\t\t (const_int 1)\n-\t\t\t (const_int 0)))\n+  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))\n+\t\t       (const_int 0)))\n    (set (pc)\n         (if_then_else (ne (cc0)\n \t\t\t  (const_int 0))\n@@ -4398,8 +4362,8 @@\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (cc0)\n-\t(match_dup 0))\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (ge (cc0)\n \t\t\t  (const_int 0))\n@@ -4418,8 +4382,8 @@\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (cc0)\n-\t(match_dup 0))\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (lt (cc0)\n \t\t\t  (const_int 0))\n@@ -4852,8 +4816,8 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(plus:HI (match_dup 0)\n \t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 3 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -4864,8 +4828,8 @@\n \t(unspec:HI [(match_dup 0)\n \t\t    (match_dup 1)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -4878,8 +4842,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (match_dup 0)\n \t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 3 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -4890,8 +4854,8 @@\n \t(unspec:SI [(match_dup 0)\n \t\t    (match_dup 1)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -4900,18 +4864,19 @@\n \n (define_peephole2\n   [(parallel [(set (cc0)\n-\t\t   (zero_extract:SI (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t\t\t    (const_int 1)\n-\t\t\t\t    (const_int 7)))\n+\t\t   (compare (zero_extract:SI (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t\t\t\t     (const_int 1)\n+\t\t\t\t\t     (const_int 7))\n+\t\t\t    (const_int 0)))\n \t      (clobber (scratch:QI))])\n    (set (pc)\n \t(if_then_else (match_operator 1 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\"\n-  [(set (cc0)\n-        (match_dup 0))\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5032,6 +4997,45 @@\n   \"operands[3] = gen_lowpart (HImode, operands[0]);\n    operands[4] = gen_lowpart (HImode, operands[1]);\")\n \n+;; Convert a memory comparison to a move if there is a scratch register.\n+\n+(define_peephole2\n+  [(match_scratch:QI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:HI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:HI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:SI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+\n ;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve\n ;; the equivalent with shorter sequences.  Here is the summary.  Cases\n ;; are grouped for each define_peephole2.\n@@ -5073,13 +5077,14 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n+   && INTVAL (operands[1]) != 0\n    && peep2_reg_dead_p (1, operands[0])\"\n   [(set (match_dup 0)\n \t(unspec:HI [(match_dup 0)\n \t\t    (match_dup 4)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5113,8 +5118,8 @@\n \t\t   (ashiftrt:HI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n@@ -5148,8 +5153,8 @@\n \t\t   (ashiftrt:HI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 5)\n \t\t      (label_ref (match_dup 3))\n@@ -5182,9 +5187,9 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n-  [(set (cc0)\n-\t(and:HI (match_dup 0)\n-\t\t(const_int -256)))\n+  [(set (cc0) (compare (and:HI (match_dup 0)\n+\t\t\t       (const_int -256))\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_dup 2))\n@@ -5211,9 +5216,9 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n-  [(set (cc0)\n-\t(and:HI (match_dup 0)\n-\t\t(const_int -256)))\n+  [(set (cc0) (compare (and:HI (match_dup 0)\n+\t\t\t       (const_int -256))\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 3)\n \t\t      (label_ref (match_dup 2))\n@@ -5307,13 +5312,14 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n+   && INTVAL (operands[1]) != 0\n    && peep2_reg_dead_p (1, operands[0])\"\n   [(set (match_dup 0)\n \t(unspec:SI [(match_dup 0)\n \t\t    (match_dup 4)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5348,8 +5354,8 @@\n   [(set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 4)))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5381,13 +5387,14 @@\n    && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n        || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n        || INTVAL (operands[1]) == 0x0000ffff)\n+   && INTVAL (operands[1]) != 0\n    && INTVAL (operands[1]) != 1\n    && INTVAL (operands[1]) != 2\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 0)\n \t\t(match_dup 1)))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5425,8 +5432,8 @@\n \t\t(match_dup 4)))\n    (set (match_dup 0)\n \t(not:SI (match_dup 0)))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5464,8 +5471,8 @@\n \t(unspec:SI [(match_dup 0)\n \t\t    (const_int -1)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5507,8 +5514,8 @@\n \t\t   (ashiftrt:SI (match_dup 4)\n \t\t\t\t(match_dup 5)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n@@ -5550,8 +5557,8 @@\n \t\t   (ashiftrt:SI (match_dup 4)\n \t\t\t\t(match_dup 5)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 6)\n \t\t      (label_ref (match_dup 3))\n@@ -5591,8 +5598,8 @@\n \t\t   (ashiftrt:SI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n@@ -5626,8 +5633,8 @@\n \t\t   (ashiftrt:SI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n \t      (clobber (scratch:QI))])\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 5)\n \t\t      (label_ref (match_dup 3))\n@@ -5672,8 +5679,8 @@\n   [(set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(match_dup 4)))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n@@ -5712,8 +5719,8 @@\n   [(set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(match_dup 4)))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 5)\n \t\t      (label_ref (match_dup 3))\n@@ -5746,9 +5753,9 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n-  [(set (cc0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int -65536)))\n+  [(set (cc0) (compare (and:SI (match_dup 0)\n+\t\t\t       (const_int -65536))\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_dup 2))\n@@ -5775,9 +5782,9 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n-  [(set (cc0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int -65536)))\n+  [(set (cc0) (compare (and:SI (match_dup 0)\n+\t\t\t       (const_int -65536))\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_dup 3)\n \t\t      (label_ref (match_dup 2))\n@@ -5814,6 +5821,7 @@\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"(TARGET_H8300H || TARGET_H8300S)\n+   && INTVAL (operands[1]) != 0\n    && !peep2_reg_dead_p (1, operands[0])\n    && !same_cmp_following_p (insn)\"\n   [(set (match_dup 4)\n@@ -5822,8 +5830,8 @@\n \t(unspec:SI [(match_dup 4)\n \t\t    (match_dup 5)]\n \t\t   UNSPEC_INCDEC))\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5836,8 +5844,8 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(and:HI (match_dup 0)\n \t\t(match_operand:HI 1 \"const_int_qi_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 3 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -5847,8 +5855,8 @@\n   [(set (match_dup 4)\n \t(and:QI (match_dup 4)\n \t\t(match_dup 5)))\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5860,8 +5868,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(and:SI (match_dup 0)\n \t\t(match_operand:SI 1 \"const_int_qi_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 3 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -5871,8 +5879,8 @@\n   [(set (match_dup 4)\n \t(and:QI (match_dup 4)\n \t\t(match_dup 5)))\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5884,8 +5892,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(and:SI (match_dup 0)\n \t\t(match_operand:SI 1 \"const_int_hi_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 3 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -5895,8 +5903,8 @@\n   [(set (match_dup 4)\n \t(and:HI (match_dup 4)\n \t\t(match_dup 5)))\n-   (set (cc0)\n-\t(match_dup 4))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 2))\n@@ -5911,8 +5919,8 @@\n    (set (match_dup 0)\n \t(xor:SI (match_dup 0)\n \t\t(match_operand:SI 2 \"const_int_qi_operand\" \"\")))\n-   (set (cc0)\n-\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_operator 4 \"eqne_operator\"\n \t\t\t[(cc0) (const_int 0)])\n@@ -5926,8 +5934,8 @@\n    (set (match_dup 5)\n \t(xor:QI (match_dup 5)\n \t\t(match_dup 7)))\n-   (set (cc0)\n-\t(match_dup 5))\n+   (set (cc0) (compare (match_dup 5)\n+\t\t       (const_int 0)))\n    (set (pc)\n \t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n \t\t      (label_ref (match_dup 3))\n@@ -6088,7 +6096,8 @@\n \t\t (match_operand 2 \"h8300_src_operand\" \"\")))]\n   \"TARGET_H8300SX\n    && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\n+   && operands[2] != const0_rtx\"\n   [(set (cc0)\n \t(compare (match_dup 1)\n \t\t (match_dup 2)))])"}, {"sha": "9452d2a60ec32b240e7d89645242fa62575d52c3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -106,7 +106,7 @@ extern int ix86_match_ccmode (rtx, enum machine_mode);\n extern rtx ix86_expand_compare (enum rtx_code, rtx *, rtx *);\n extern int ix86_use_fcomi_compare (enum rtx_code);\n extern void ix86_expand_branch (enum rtx_code, rtx);\n-extern int ix86_expand_setcc (enum rtx_code, rtx);\n+extern void ix86_expand_setcc (enum rtx_code, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);"}, {"sha": "bb013a144f612e30928e6bda344ab58679293c49", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -14947,15 +14947,12 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n     emit_label (label);\n }\n \n-int\n+void\n ix86_expand_setcc (enum rtx_code code, rtx dest)\n {\n   rtx ret, tmp, tmpreg, equiv;\n   rtx second_test, bypass_test;\n \n-  if (GET_MODE (ix86_compare_op0) == (TARGET_64BIT ? TImode : DImode))\n-    return 0; /* FAIL */\n-\n   gcc_assert (GET_MODE (dest) == QImode);\n \n   ret = ix86_expand_compare (code, &second_test, &bypass_test);\n@@ -14994,8 +14991,6 @@ ix86_expand_setcc (enum rtx_code code, rtx dest)\n \t\t\t\t       ix86_compare_op0, ix86_compare_op1);\n       set_unique_reg_note (get_last_insn (), REG_EQUAL, equiv);\n     }\n-\n-  return 1; /* DONE */\n }\n \n /* Expand comparison setting or clearing carry flag.  Return true when\n@@ -15143,6 +15138,8 @@ ix86_expand_int_movcc (rtx operands[])\n   bool sign_bit_compare_p = false;;\n \n   start_sequence ();\n+  ix86_compare_op0 = XEXP (operands[1], 0);\n+  ix86_compare_op1 = XEXP (operands[1], 1);\n   compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n   compare_seq = get_insns ();\n   end_sequence ();\n@@ -15860,6 +15857,8 @@ ix86_expand_fp_movcc (rtx operands[])\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx tmp, compare_op, second_test, bypass_test;\n \n+  ix86_compare_op0 = XEXP (operands[1], 0);\n+  ix86_compare_op1 = XEXP (operands[1], 1);\n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n     {\n       enum machine_mode cmode;\n@@ -16387,6 +16386,8 @@ ix86_expand_int_addcc (rtx operands[])\n   bool fpcmp = false;\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n+  ix86_compare_op0 = XEXP (operands[1], 0);\n+  ix86_compare_op1 = XEXP (operands[1], 1);\n   if (operands[3] != const1_rtx\n       && operands[3] != constm1_rtx)\n     return 0;\n@@ -28870,13 +28871,14 @@ void ix86_emit_i387_log1p (rtx op0, rtx op1)\n \n   rtx tmp = gen_reg_rtx (XFmode);\n   rtx tmp2 = gen_reg_rtx (XFmode);\n+  rtx test;\n \n   emit_insn (gen_absxf2 (tmp, op1));\n-  emit_insn (gen_cmpxf (tmp,\n+  test = gen_rtx_GE (VOIDmode, tmp,\n     CONST_DOUBLE_FROM_REAL_VALUE (\n        REAL_VALUE_ATOF (\"0.29289321881345247561810596348408353\", XFmode),\n-       XFmode)));\n-  emit_jump_insn (gen_bge (label1));\n+       XFmode));\n+  emit_jump_insn (gen_cbranchxf4 (test, XEXP (test, 0), XEXP (test, 1), label1));\n \n   emit_move_insn (tmp2, standard_80387_constant_rtx (4)); /* fldln2 */\n   emit_insn (gen_fyl2xp1xf3_i387 (op0, op1, tmp2));"}, {"sha": "198b59d2e4769910af6688f24449fabb15e55e9b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 227, "deletions": 91, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -759,77 +759,183 @@\n (include \"constraints.md\")\n \n \f\n-;; Compare instructions.\n+;; Compare and branch/compare and store instructions.\n \n-;; All compare insns have expanders that save the operands away without\n-;; actually generating RTL.  The bCOND or sCOND (emitted immediately\n-;; after the cmp) will actually emit the cmpM.\n+(define_expand \"cbranchti4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:TI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:TI 2 \"x86_64_general_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"TARGET_64BIT\"\n+{\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (TImode, operands[1]);\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  DONE;\n+})\n \n-(define_expand \"cmpti\"\n+(define_expand \"cbranchdi4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:TI 1 \"x86_64_general_operand\" \"\")))]\n+\t(compare:CC (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"\"\n+{\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"cstoredi4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:DI 2 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:DI 3 \"x86_64_general_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n   \"TARGET_64BIT\"\n {\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[0] = force_reg (TImode, operands[0]);\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  if (MEM_P (operands[2]) && MEM_P (operands[3]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n   DONE;\n })\n \n-(define_expand \"cmpdi\"\n+(define_expand \"cbranchsi4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:DI 1 \"x86_64_general_operand\" \"\")))]\n+\t(compare:CC (match_operand:SI 1 \"cmpsi_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"general_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n {\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[0] = force_reg (DImode, operands[0]);\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n   DONE;\n })\n \n-(define_expand \"cmpsi\"\n+(define_expand \"cstoresi4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:SI 0 \"cmpsi_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"general_operand\" \"\")))]\n+\t(compare:CC (match_operand:SI 2 \"cmpsi_operand\" \"\")\n+\t\t    (match_operand:SI 3 \"general_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n   \"\"\n {\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[0] = force_reg (SImode, operands[0]);\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  if (MEM_P (operands[2]) && MEM_P (operands[3]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n   DONE;\n })\n \n-(define_expand \"cmphi\"\n+(define_expand \"cbranchhi4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:HI 1 \"general_operand\" \"\")))]\n+\t(compare:CC (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:HI 2 \"general_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n {\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[0] = force_reg (HImode, operands[0]);\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n   DONE;\n })\n \n-(define_expand \"cmpqi\"\n+(define_expand \"cstorehi4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:QI 1 \"general_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n+\t(compare:CC (match_operand:HI 2 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:HI 3 \"general_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n+  \"\"\n {\n-  if (MEM_P (operands[0]) && MEM_P (operands[1]))\n-    operands[0] = force_reg (QImode, operands[0]);\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  if (MEM_P (operands[2]) && MEM_P (operands[3]))\n+    operands[2] = force_reg (HImode, operands[2]);\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  DONE;\n+})\n+\n+\n+(define_expand \"cbranchqi4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:QI 2 \"general_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"\"\n+{\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (QImode, operands[1]);\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  DONE;\n+})\n+\n+\n+(define_expand \"cstoreqi4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:QI 2 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:QI 3 \"general_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n+  \"\"\n+{\n+  if (MEM_P (operands[2]) && MEM_P (operands[3]))\n+    operands[2] = force_reg (QImode, operands[2]);\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n   DONE;\n })\n \n+\n (define_insn \"cmpdi_ccno_1_rex64\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"r,?mr\")\n@@ -1078,39 +1184,103 @@\n ;; which would allow mix and match FP modes on the compares.  Which is what\n ;; the old patterns did, but with many more of them.\n \n-(define_expand \"cmpxf\"\n+(define_expand \"cbranchxf4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:XF 1 \"nonmemory_operand\" \"\")\n+\t\t    (match_operand:XF 2 \"nonmemory_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"TARGET_80387\"\n+{\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"cstorexf4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:XF 0 \"nonmemory_operand\" \"\")\n-\t\t    (match_operand:XF 1 \"nonmemory_operand\" \"\")))]\n+\t(compare:CC (match_operand:XF 2 \"nonmemory_operand\" \"\")\n+\t\t    (match_operand:XF 3 \"nonmemory_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n   \"TARGET_80387\"\n {\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n   DONE;\n })\n \n-(define_expand \"cmp<mode>\"\n+(define_expand \"cbranch<mode>4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:MODEF 0 \"cmp_fp_expander_operand\" \"\")\n-\t\t    (match_operand:MODEF 1 \"cmp_fp_expander_operand\" \"\")))]\n+\t(compare:CC (match_operand:MODEF 1 \"cmp_fp_expander_operand\" \"\")\n+\t\t    (match_operand:MODEF 2 \"cmp_fp_expander_operand\" \"\")))\n+   (set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n {\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n   DONE;\n })\n \n-(define_expand \"cmpcc\"\n+(define_expand \"cstore<mode>4\"\n   [(set (reg:CC FLAGS_REG)\n-        (compare:CC (match_operand 0 \"flags_reg_operand\" \"\")\n-                    (match_operand 1 \"general_operand\" \"\")))]\n+\t(compare:CC (match_operand:MODEF 2 \"cmp_fp_expander_operand\" \"\")\n+\t\t    (match_operand:MODEF 3 \"cmp_fp_expander_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(reg:CC FLAGS_REG)\n+                (const_int 0)]))]\n+  \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n+{\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n+  DONE;\n+})\n+\n+(define_expand \"cbranchcc4\"\n+  [(set (pc) (if_then_else\n+              (match_operator 0 \"comparison_operator\"\n+               [(match_operand 1 \"flags_reg_operand\" \"\")\n+                (match_operand 2 \"const0_operand\" \"\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"\"\n+{\n+  ix86_compare_op0 = operands[1];\n+  ix86_compare_op1 = operands[2];\n+  ix86_expand_branch (GET_CODE (operands[0]), operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"cstorecc4\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+              (match_operator 1 \"comparison_operator\"\n+               [(match_operand 2 \"flags_reg_operand\" \"\")\n+                (match_operand 3 \"const0_operand\" \"\")]))]\n   \"\"\n {\n-  ix86_compare_op0 = operands[0];\n-  ix86_compare_op1 = operands[1];\n+  ix86_compare_op0 = operands[2];\n+  ix86_compare_op1 = operands[3];\n+  ix86_expand_setcc (GET_CODE (operands[1]), operands[0]);\n   DONE;\n })\n \n+\n ;; FP compares, step 1:\n ;; Set the FP condition codes.\n ;;\n@@ -14182,18 +14352,6 @@\n ;; to avoid partial register stalls.  Otherwise do things the setcc+movzx\n ;; way, which can later delete the movzx if only QImode is needed.\n \n-(define_expand \"s<code>\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-        (int_cond:QI (reg:CC FLAGS_REG) (const_int 0)))]\n-  \"\"\n-  \"if (ix86_expand_setcc (<CODE>, operands[0])) DONE; else FAIL;\")\n-\n-(define_expand \"s<code>\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-        (fp_cond:QI (reg:CC FLAGS_REG) (const_int 0)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n-  \"if (ix86_expand_setcc (<CODE>, operands[0])) DONE; else FAIL;\")\n-\n (define_insn \"*setcc_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(match_operator:QI 1 \"ix86_comparison_operator\"\n@@ -14322,27 +14480,6 @@\n ;; Basic conditional jump instructions.\n ;; We ignore the overflow flag for signed branch instructions.\n \n-;; For all bCOND expanders, also expand the compare or test insn that\n-;; generates reg FLAGS_REG.  Generate an equality comparison if `beq' or `bne'.\n-\n-(define_expand \"b<code>\"\n-  [(set (pc)\n-\t(if_then_else (int_cond:CC (reg:CC FLAGS_REG)\n-\t\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"ix86_expand_branch (<CODE>, operands[0]); DONE;\")\n-\n-(define_expand \"b<code>\"\n-  [(set (pc)\n-\t(if_then_else (fp_cond:CC (reg:CC FLAGS_REG)\n-\t\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE_MATH\"\n-  \"ix86_expand_branch (<CODE>, operands[0]); DONE;\")\n-\n (define_insn \"*jcc_1\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"ix86_comparison_operator\"\n@@ -22004,9 +22141,8 @@\n     emit_insn (gen_stack_protect_test_si (flags, operands[0], operands[1]));\n #endif\n \n-  ix86_compare_op0 = flags;\n-  ix86_compare_op1 = const0_rtx;\n-  emit_jump_insn (gen_beq (operands[2]));\n+  emit_jump_insn (gen_cbranchcc4 (gen_rtx_EQ (VOIDmode, flags, const0_rtx),\n+\t\t\t\t  flags, const0_rtx, operands[2]));\n   DONE;\n })\n "}, {"sha": "0859c7f53af6ba0cc660c516027151769ee5698c", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -18,13 +18,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Variables defined in ia64.c.  */\n-\n-#ifdef RTX_CODE\n-extern GTY(()) rtx ia64_compare_op0;\n-extern GTY(()) rtx ia64_compare_op1;\n-#endif\n-\n /* Functions defined in ia64.c */\n \n extern int bundling_p;\n@@ -43,7 +36,7 @@ extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);\n extern void ia64_split_tmode_move (rtx[]);\n extern bool ia64_expand_movxf_movrf (enum machine_mode, rtx[]);\n-extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n+extern void ia64_expand_compare (rtx *, rtx *, rtx *);\n extern void ia64_expand_vecint_cmov (rtx[]);\n extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);\n extern void ia64_expand_widen_sum (rtx[], bool);"}, {"sha": "1f433a6fb0fa079bf22167ec37e2f7e54ed10dd8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -63,11 +63,6 @@ along with GCC; see the file COPYING3.  If not see\n    ASM_OUTPUT_LABELREF.  */\n int ia64_asm_output_label = 0;\n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-struct rtx_def * ia64_compare_op0;\n-struct rtx_def * ia64_compare_op1;\n-\n /* Register names for ia64_expand_prologue.  */\n static const char * const ia64_reg_numbers[96] =\n { \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\n@@ -1493,28 +1488,28 @@ ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n   return false;\n }\n \n-/* Emit comparison instruction if necessary, returning the expression\n-   that holds the compare result in the proper mode.  */\n+/* Emit comparison instruction if necessary, replacing *EXPR, *OP0, *OP1\n+   with the expression that holds the compare result (in VOIDmode).  */\n \n static GTY(()) rtx cmptf_libfunc;\n \n-rtx\n-ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n+void\n+ia64_expand_compare (rtx *expr, rtx *op0, rtx *op1)\n {\n-  rtx op0 = ia64_compare_op0, op1 = ia64_compare_op1;\n+  enum rtx_code code = GET_CODE (*expr);\n   rtx cmp;\n \n   /* If we have a BImode input, then we already have a compare result, and\n      do not need to emit another comparison.  */\n-  if (GET_MODE (op0) == BImode)\n+  if (GET_MODE (*op0) == BImode)\n     {\n-      gcc_assert ((code == NE || code == EQ) && op1 == const0_rtx);\n-      cmp = op0;\n+      gcc_assert ((code == NE || code == EQ) && *op1 == const0_rtx);\n+      cmp = *op0;\n     }\n   /* HPUX TFmode compare requires a library call to _U_Qfcmp, which takes a\n      magic number as its third argument, that indicates what to do.\n      The return value is an integer to be compared against zero.  */\n-  else if (TARGET_HPUX && GET_MODE (op0) == TFmode)\n+  else if (TARGET_HPUX && GET_MODE (*op0) == TFmode)\n     {\n       enum qfcmp_magic {\n \tQCMP_INV = 1,\t/* Raise FP_INVALID on SNaN as a side effect.  */\n@@ -1527,7 +1522,7 @@ ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n       enum rtx_code ncode;\n       rtx ret, insns;\n       \n-      gcc_assert (cmptf_libfunc && GET_MODE (op1) == TFmode);\n+      gcc_assert (cmptf_libfunc && GET_MODE (*op1) == TFmode);\n       switch (code)\n \t{\n \t  /* 1 = equal, 0 = not equal.  Equality operators do\n@@ -1552,7 +1547,7 @@ ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n       start_sequence ();\n \n       ret = emit_library_call_value (cmptf_libfunc, 0, LCT_CONST, DImode, 3,\n-\t\t\t\t     op0, TFmode, op1, TFmode,\n+\t\t\t\t     *op0, TFmode, *op1, TFmode,\n \t\t\t\t     GEN_INT (magic), DImode);\n       cmp = gen_reg_rtx (BImode);\n       emit_insn (gen_rtx_SET (VOIDmode, cmp,\n@@ -1563,18 +1558,20 @@ ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n       end_sequence ();\n \n       emit_libcall_block (insns, cmp, cmp,\n-\t\t\t  gen_rtx_fmt_ee (code, BImode, op0, op1));\n+\t\t\t  gen_rtx_fmt_ee (code, BImode, *op0, *op1));\n       code = NE;\n     }\n   else\n     {\n       cmp = gen_reg_rtx (BImode);\n       emit_insn (gen_rtx_SET (VOIDmode, cmp,\n-\t\t\t      gen_rtx_fmt_ee (code, BImode, op0, op1)));\n+\t\t\t      gen_rtx_fmt_ee (code, BImode, *op0, *op1)));\n       code = NE;\n     }\n \n-  return gen_rtx_fmt_ee (code, mode, cmp, const0_rtx);\n+  *expr = gen_rtx_fmt_ee (code, VOIDmode, cmp, const0_rtx);\n+  *op0 = cmp;\n+  *op1 = const0_rtx;\n }\n \n /* Generate an integral vector comparison.  Return true if the condition has"}, {"sha": "e5a6d81730c1bd51acd4c930ddb4ed16feb00c34", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 156, "deletions": 211, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -409,6 +409,7 @@\n    (set_attr \"speculable2\"   \"no,  no,  no,  no,   yes,no,no,  no,  no,   yes,no, no,  no,  no,    no,    no,    no,    no,  no\")])\n \n (define_mode_iterator MODE [BI QI HI SI DI SF DF XF TI])\n+(define_mode_iterator MODE_FOR_CMP [BI SI DI SF DF XF (TF \"TARGET_HPUX\")])\n (define_mode_iterator MODE_FOR_EXTEND [QI HI SI])\n \n (define_mode_attr output_a [\n@@ -4759,82 +4760,76 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-(define_expand \"cmpbi\"\n-  [(set (cc0)\n-        (compare (match_operand:BI 0 \"register_operand\" \"\")\n-  \t\t (match_operand:BI 1 \"const_int_operand\" \"\")))]\n+(define_expand \"cbranchbi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:BI 1 \"register_operand\" \"\")\n+\t                (match_operand:BI 2 \"const_int_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-        (compare (match_operand:SI 0 \"gr_register_operand\" \"\")\n-  \t\t (match_operand:SI 1 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")))]\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:SI 2 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmpdi\"\n-  [(set (cc0)\n-        (compare (match_operand:DI 0 \"gr_register_operand\" \"\")\n-  \t\t (match_operand:DI 1 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")))]\n+(define_expand \"cbranchdi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:DI 2 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmpsf\"\n-  [(set (cc0)\n-        (compare (match_operand:SF 0 \"fr_reg_or_fp01_operand\" \"\")\n-  \t\t (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")))]\n+(define_expand \"cbranchsf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmpdf\"\n-  [(set (cc0)\n-        (compare (match_operand:DF 0 \"fr_reg_or_fp01_operand\" \"\")\n-  \t\t (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")))]\n+(define_expand \"cbranchdf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmpxf\"\n-  [(set (cc0)\n-        (compare (match_operand:XF 0 \"xfreg_or_fp01_operand\" \"\")\n-  \t\t (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"\")))]\n+(define_expand \"cbranchxf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:XF 1 \"xfreg_or_fp01_operand\" \"\")\n+\t                (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"cmptf\"\n-  [(set (cc0)\n-        (compare (match_operand:TF 0 \"gr_register_operand\" \"\")\n-  \t\t (match_operand:TF 1 \"gr_register_operand\" \"\")))]\n+(define_expand \"cbranchtf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:TF 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:TF 2 \"gr_register_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n   \"TARGET_HPUX\"\n-{\n-  ia64_compare_op0 = operands[0];\n-  ia64_compare_op1 = operands[1];\n-  DONE;\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n \n (define_insn \"*cmpsi_normal\"\n   [(set (match_operand:BI 0 \"register_operand\" \"=c\")\n@@ -4933,102 +4928,6 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (EQ, VOIDmode);\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (NE, VOIDmode);\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LT, VOIDmode);\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LE, VOIDmode);\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GT, VOIDmode);\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GE, VOIDmode);\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LTU, VOIDmode);\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LEU, VOIDmode);\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GTU, VOIDmode);\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GEU, VOIDmode);\")\n-\n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (UNORDERED, VOIDmode);\")\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (ORDERED, VOIDmode);\")\n-\n (define_insn \"*br_true\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"predicate_operator\"\n@@ -5094,65 +4993,61 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-(define_expand \"seq\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstorebi4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:BI 2 \"register_operand\" \"\")\n+\t                (match_operand:BI 3 \"const_int_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (EQ, DImode);\")\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n \n-(define_expand \"sne\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SI 2 \"gr_register_operand\" \"\")\n+\t                (match_operand:SI 3 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (NE, DImode);\")\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_expand \"slt\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstoredi4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DI 2 \"gr_register_operand\" \"\")\n+\t                (match_operand:DI 3 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (LT, DImode);\")\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_expand \"sle\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstoresf4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:SF 3 \"fr_reg_or_fp01_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (LE, DImode);\")\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_expand \"sgt\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstoredf4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:DF 3 \"fr_reg_or_fp01_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (GT, DImode);\")\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_expand \"sge\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n+(define_expand \"cstorexf4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:XF 2 \"xfreg_or_fp01_operand\" \"\")\n+\t                (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"\")]))]\n   \"\"\n-  \"operands[1] = ia64_expand_compare (GE, DImode);\")\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n-(define_expand \"sltu\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LTU, DImode);\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (LEU, DImode);\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GTU, DImode);\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (GEU, DImode);\")\n-\n-(define_expand \"sunordered\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (UNORDERED, DImode);\")\n-\n-(define_expand \"sordered\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") (match_dup 1))]\n-  \"\"\n-  \"operands[1] = ia64_expand_compare (ORDERED, DImode);\")\n+(define_expand \"cstoretf4\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"\") \n+\t(match_operator:DI 1 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:TF 2 \"gr_register_operand\" \"\")\n+\t                (match_operand:TF 3 \"gr_register_operand\" \"\")]))]\n+  \"TARGET_HPUX\"\n+  \"ia64_expand_compare (&operands[1], &operands[2], &operands[3]);\")\n \n ;; Don't allow memory as destination here, because cmov/cmov/st is more\n ;; efficient than mov/mov/cst/cst.\n@@ -6018,12 +5913,62 @@\n   \"break %0\"\n   [(set_attr \"itanium_class\" \"chk_s_i\")])\n \n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))]\n+(define_expand \"ctrapbi4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:BI 1 \"register_operand\" \"\")\n+\t                (match_operand:BI 2 \"const_int_operand\" \"\")])\n+\t\t      (match_operand 3 \"\" \"\"))]\n   \"\"\n-{\n-  operands[0] = ia64_expand_compare (GET_CODE (operands[0]), VOIDmode);\n-})\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctrapsi4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SI 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:SI 2 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctrapdi4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DI 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:DI 2 \"gr_reg_or_8bit_and_adjusted_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctrapsf4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctrapdf4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t                (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctrapxf4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:XF 1 \"xfreg_or_fp01_operand\" \"\")\n+\t                (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n+(define_expand \"ctraptf4\"\n+  [(trap_if (match_operator 0 \"ia64_cbranch_operator\"\n+\t\t       [(match_operand:TF 1 \"gr_register_operand\" \"\")\n+\t                (match_operand:TF 2 \"gr_register_operand\" \"\")])\n+\t\t       (match_operand 3 \"\" \"\"))]\n+  \"TARGET_HPUX\"\n+  \"ia64_expand_compare (&operands[0], &operands[1], &operands[2]);\")\n+\n \n (define_insn \"*conditional_trap\"\n   [(trap_if (match_operator 0 \"predicate_operator\""}, {"sha": "1503a0520cb4d7ef45307af446da676675250293", "filename": "gcc/config/ia64/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -536,6 +536,11 @@\n        (and (match_code \"const_double,const_vector\")\n \t    (match_test \"op == CONST0_RTX (GET_MODE (op))\"))))\n \n+;; Return 1 if OP is a valid comparison operator for \"cbranch\" instructions.\n+(define_predicate \"ia64_cbranch_operator\"\n+  (ior (match_operand 0 \"ordered_comparison_operator\")\n+       (match_code \"ordered,unordered\")))\n+\n ;; True if this is a comparison operator, which accepts a normal 8-bit\n ;; signed immediate operand.\n (define_predicate \"normal_comparison_operator\""}, {"sha": "a927452d83c9fab456ee4a5b767836a3d947f514", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -41,7 +41,7 @@ extern void             print_operand (FILE *, rtx, int);\n \n #ifdef RTX_CODE\n extern rtx              gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n-extern void             gen_conditional_branch (rtx *, enum rtx_code);\n+extern void             gen_conditional_branch (rtx *, enum machine_mode);\n #endif\n \n #ifdef TREE_CODE"}, {"sha": "28bb7a831fe6e2a97e57c812068ff6cd3b6e8b63", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -118,13 +118,6 @@ enum processor_type iq2000_tune;\n /* Which instruction set architecture to use.  */\n int iq2000_isa;\n \n-/* Cached operands, and operator to compare for use in set/branch/trap\n-   on condition codes.  */\n-rtx branch_cmp[2];\n-\n-/* What type of branch to use.  */\n-enum cmp_type branch_type;\n-\n /* Local variables.  */\n \n /* The next branch instruction is a branch likely, not branch normal.  */\n@@ -1010,60 +1003,31 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n    The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n-gen_conditional_branch (rtx operands[], enum rtx_code test_code)\n+gen_conditional_branch (rtx operands[], enum machine_mode mode)\n {\n-  enum cmp_type type = branch_type;\n-  rtx cmp0 = branch_cmp[0];\n-  rtx cmp1 = branch_cmp[1];\n-  enum machine_mode mode;\n+  enum rtx_code test_code = GET_CODE (operands[0]);\n+  rtx cmp0 = operands[1];\n+  rtx cmp1 = operands[2];\n   rtx reg;\n   int invert;\n   rtx label1, label2;\n \n-  switch (type)\n-    {\n-    case CMP_SI:\n-    case CMP_DI:\n-      mode = type == CMP_SI ? SImode : DImode;\n-      invert = 0;\n-      reg = gen_int_relational (test_code, NULL_RTX, cmp0, cmp1, &invert);\n-\n-      if (reg)\n-\t{\n-\t  cmp0 = reg;\n-\t  cmp1 = const0_rtx;\n-\t  test_code = NE;\n-\t}\n-      else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\t/* We don't want to build a comparison against a nonzero\n-\t   constant.  */\n-\tcmp1 = force_reg (mode, cmp1);\n-\n-      break;\n-\n-    case CMP_SF:\n-    case CMP_DF:\n-      reg = gen_reg_rtx (CCmode);\n+  invert = 0;\n+  reg = gen_int_relational (test_code, NULL_RTX, cmp0, cmp1, &invert);\n \n-      /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result == 0.  */\n-      emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t      gen_rtx_fmt_ee (test_code == NE ? EQ : test_code,\n-\t\t\t\t\t      CCmode, cmp0, cmp1)));\n-\n-      test_code = test_code == NE ? EQ : NE;\n-      mode = CCmode;\n+  if (reg)\n+    {\n       cmp0 = reg;\n       cmp1 = const0_rtx;\n-      invert = 0;\n-      break;\n-\n-    default:\n-      abort_with_insn (gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1),\n-\t\t       \"bad test\");\n+      test_code = NE;\n     }\n+  else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n+    /* We don't want to build a comparison against a nonzero\n+       constant.  */\n+    cmp1 = force_reg (mode, cmp1);\n \n   /* Generate the branch.  */\n-  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n   label2 = pc_rtx;\n \n   if (invert)"}, {"sha": "0664f511bd387f1307b4c19aed816e9179fc6fb3", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1001,13 +1001,6 @@ extern enum processor_type iq2000_tune;\n /* Which instruction set architecture to use.  */\n extern int iq2000_isa;\n \n-/* Cached operands, and operator to compare for use in set/branch/trap\n-   on condition codes.  */\n-extern rtx branch_cmp[2];\n-\n-/* What type of branch to use.  */\n-extern enum cmp_type branch_type;\n-\n enum iq2000_builtins\n {\n   IQ2000_BUILTIN_ADO16,"}, {"sha": "61275f2c6714eaa5f631a4f85d2cf7ab39dbd719", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 17, "deletions": 383, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -989,63 +989,25 @@\n ;;\n ;;  ....................\n ;;\n-;;\tCOMPARISONS\n+;;\tCONDITIONAL BRANCHES\n ;;\n ;;  ....................\n \n-;; Flow here is rather complex:\n-;;\n-;;  1)\tThe cmp{si,di,sf,df} routine is called.  It deposits the\n-;;\targuments into the branch_cmp array, and the type into\n-;;\tbranch_type.  No RTL is generated.\n-;;\n-;;  2)\tThe appropriate branch define_expand is called, which then\n-;;\tcreates the appropriate RTL for the comparison and branch.\n-;;\tDifferent CC modes are used, based on what type of branch is\n-;;\tdone, so that we can constrain things appropriately.  There\n-;;\tare assumptions in the rest of GCC that break if we fold the\n-;;\toperands into the branches for integer operations, and use cc0\n-;;\tfor floating point, so we use the fp status register instead.\n-;;\tIf needed, an appropriate temporary is created to hold the\n-;;\tof the integer compare.\n-\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"\")))]\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+        (if_then_else\n+         (match_operator:SI 0 \"ordered_comparison_operator\"\n+                            [(match_operand:SI 1 \"register_operand\")\n+                             (match_operand:SI 2 \"reg_or_const_operand\")])\n+\t (label_ref (match_operand:SI 3 \"\"))\n+\t (pc)))]\n   \"\"\n   \"\n {\n-  if (operands[0])\t\t/* avoid unused code message */\n-    {\n-      branch_cmp[0] = operands[0];\n-      branch_cmp[1] = operands[1];\n-      branch_type = CMP_SI;\n-      DONE;\n-    }\n+  gen_conditional_branch (operands, SImode);\n+  DONE;\n }\")\n \n-(define_expand \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code message */\n-    {\n-      branch_cmp[0] = operands[0];\n-      branch_cmp[1] = const0_rtx;\n-      branch_type = CMP_SI;\n-      DONE;\n-    }\n-}\")\n-\f\n-;;\n-;;  ....................\n-;;\n-;;\tCONDITIONAL BRANCHES\n-;;\n-;;  ....................\n \n ;; Conditional branches on comparisons with zero.\n \n@@ -1135,166 +1097,6 @@\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")])\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, EQ);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, NE);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, GT);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, GE);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, LT);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, LE);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, GTU);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, GEU);\n-      DONE;\n-    }\n-}\")\n-\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, LTU);\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code warning */\n-    {\n-      gen_conditional_branch (operands, LEU);\n-      DONE;\n-    }\n-}\")\n \n ;; Recognize bbi and bbin instructions.  These use two unusual template\n ;; patterns, %Ax and %Px.  %Ax outputs an 'i' if operand `x' is a LABEL_REF\n@@ -1390,25 +1192,19 @@\n ;;\n ;;  ....................\n \n-(define_expand \"seq\"\n+(define_expand \"cstoresi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(eq:SI (match_dup 1)\n-\t       (match_dup 2)))]\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:SI 2 \"register_operand\")\n+\t  (match_operand:SI 3 \"reg_or_const_operand\")]))]\n   \"\"\n   \"\n {\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (EQ, operands[0], operands[1], operands[2], (int *)0);\n+  gen_int_relational (GET_CODE (operands[1]), operands[0],\n+\t\t      operands[2], operands[3], (int *)0);\n   DONE;\n }\")\n \n-\n (define_insn \"seq_si_zero\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -1418,24 +1214,6 @@\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ne:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (NE, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sne_si_zero\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -1445,24 +1223,6 @@\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gt:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (GT, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sgt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n \t(gt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n@@ -1474,42 +1234,6 @@\n   [(set_attr \"type\"\t\"arith,arith\")\n    (set_attr \"mode\"\t\"SI,SI\")])\n \n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ge:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (GE, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lt:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (LT, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"slt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n \t(lt:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n@@ -1521,24 +1245,6 @@\n   [(set_attr \"type\"\t\"arith,arith\")\n    (set_attr \"mode\"\t\"SI,SI\")])\n \n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(le:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (LE, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sle_si_const\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -1552,24 +1258,6 @@\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(gtu:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (GTU, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sgtu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(gtu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -1588,42 +1276,6 @@\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (geu:SI (match_dup 1)\n-                (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (GEU, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ltu:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (LTU, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sltu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,=d\")\n \t(ltu:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n@@ -1635,24 +1287,6 @@\n   [(set_attr \"type\"\t\"arith,arith\")\n    (set_attr \"mode\"\t\"SI,SI\")])\n \n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(leu:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (branch_type != CMP_SI && (branch_type != CMP_DI))\n-    FAIL;\n-\n-  /* Set up operands from compare.  */\n-  operands[1] = branch_cmp[0];\n-  operands[2] = branch_cmp[1];\n-\n-  gen_int_relational (LEU, operands[0], operands[1], operands[2], (int *)0);\n-  DONE;\n-}\")\n-\n (define_insn \"sleu_si_const\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")"}, {"sha": "f275090309b2e517dec61d2020f7b9f4deb6e4a4", "filename": "gcc/config/iq2000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -41,6 +41,14 @@\n   return register_operand (op, mode);\n })\n \n+;; Return 1 if OP is a register or a constant.  gen_int_relational\n+;; takes care of forcing out-of-range constants into a register.\n+\n+(define_predicate \"reg_or_const_operand\"\n+  (ior (match_code \"const_int\")\n+       (and (match_code \"reg,subreg\")\n+            (match_operand 0 \"register_operand\"))))\n+\n ;; Return 1 if OP is a integer which fits in 16 bits.\n \n (define_predicate \"small_int\""}, {"sha": "c751070e71659394f3738567634fdec2b4d4d3bb", "filename": "gcc/config/m32c/cond.md", "status": "modified", "additions": 37, "deletions": 65, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fcond.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fcond.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fcond.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -58,12 +58,23 @@\n   [(set (reg:CC FLG_REGNO)\n \t(compare (match_dup 1)\n \t\t (match_dup 2)))\n-   (set (pc) (if_then_else (match_dup 4)\n+   (set (pc) (if_then_else (match_op_dup 0 [(reg:CC FLG_REGNO) (const_int 0)])\n \t\t\t   (label_ref (match_dup 3))\n \t\t\t   (pc)))]\n-  \"operands[4] = m32c_cmp_flg_0 (operands[0]);\"\n+  \"\"\n   )\n \n+(define_insn \"bcc_op\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(reg:CC FLG_REGNO) (const_int 0)])\n+                      (label_ref (match_operand 1 \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"j%c0\\t%l1\"\n+  [(set_attr \"flags\" \"n\")]\n+)\n+\n (define_insn \"stzx_16\"\n   [(set (match_operand:QI 0 \"mrai_operand\" \"=R0w,R0w,R0w\")\n \t(if_then_else:QI (eq (reg:CC FLG_REGNO) (const_int 0))\n@@ -113,34 +124,6 @@\n   \"* return m32c_output_compare(insn, operands); \"\n   [(set_attr \"flags\" \"oszc\")])\n \n-(define_expand \"cmp<mode>\"\n-  [(set (reg:CC FLG_REGNO)\n-\t(compare (match_operand:QHPSI 0 \"mra_operand\" \"RraSd\")\n-\t\t (match_operand:QHPSI 1 \"mrai_operand\" \"RraSdi\")))]\n-  \"\"\n-  \"m32c_pend_compare (operands); DONE;\")\n-\n-(define_insn \"b<code>_op\"\n-  [(set (pc)\n-        (if_then_else (any_cond (reg:CC FLG_REGNO)\n-\t\t\t\t(const_int 0))\n-                      (label_ref (match_operand 0 \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"j<code>\\t%l0\"\n-  [(set_attr \"flags\" \"n\")]\n-)\n-\n-(define_expand \"b<code>\"\n-  [(set (pc)\n-        (if_then_else (any_cond (reg:CC FLG_REGNO)\n-\t\t\t\t(const_int 0))\n-                      (label_ref (match_operand 0 \"\"))\n-                      (pc)))]\n-  \"\"\n-  \"m32c_unpend_compare ();\"\n-)\n-\n ;; m32c_conditional_register_usage changes the setcc_gen_code array to\n ;; point to the _24 variants if needed.\n \n@@ -151,51 +134,54 @@\n \n ;; These are the post-split patterns for the conditional sets.\n \n-(define_insn \"s<code>_op\"\n+(define_insn \"scc_op\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n-\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+\t [(reg:CC FLG_REGNO) (const_int 0)]))]\n   \"TARGET_A16 && reload_completed\"\n-  \"* return m32c_scc_pattern(operands, <CODE>);\")\n+  \"* return m32c_scc_pattern(operands, GET_CODE (operands[1]));\")\n \n-(define_insn \"s<code>_24_op\"\n+(define_insn \"scc_24_op\"\n   [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd\")\n-\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n+\t(match_operator:HI 1 \"ordered_comparison_operator\"\n+\t [(reg:CC FLG_REGNO) (const_int 0)]))]\n   \"TARGET_A24 && reload_completed\"\n-  \"sc<code>\\t%0\"\n+  \"sc%c1\\t%0\"\n   [(set_attr \"flags\" \"n\")]\n )\n \n-;; These are the pre-split patterns for the conditional sets.  Yes,\n-;; there are a lot of permutations.\n+;; These are the pre-split patterns for the conditional sets.\n \n-(define_insn_and_split \"s<code>_<mode>\"\n+(define_insn_and_split \"cstore<mode>4\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n-\t(any_cond:QI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n-\t\t     (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\")))]\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:QHPSI 2 \"mra_operand\" \"RraSd\")\n+\t  (match_operand:QHPSI 3 \"mrai_operand\" \"RraSdi\")]))]\n   \"TARGET_A16\"\n   \"#\"\n   \"reload_completed\"\n   [(set (reg:CC FLG_REGNO)\n-\t(compare (match_dup 1)\n-\t\t (match_dup 2)))\n+\t(compare (match_dup 2)\n+\t\t (match_dup 3)))\n    (set (match_dup 0)\n-\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n+\t(match_op_dup 1 [(reg:CC FLG_REGNO) (const_int 0)]))]\n   \"\"\n   [(set_attr \"flags\" \"x\")]\n )\n \n-(define_insn_and_split \"s<code>_<mode>_24\"\n+(define_insn_and_split \"cstore<mode>4_24\"\n   [(set (match_operand:HI 0 \"mra_nopp_operand\" \"=RhiSd\")\n-\t(any_cond:HI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n-\t\t     (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\")))]\n+\t(match_operator:HI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:QHPSI 2 \"mra_operand\" \"RraSd\")\n+\t  (match_operand:QHPSI 3 \"mrai_operand\" \"RraSdi\")]))]\n   \"TARGET_A24\"\n   \"#\"\n   \"reload_completed\"\n   [(set (reg:CC FLG_REGNO)\n-\t(compare (match_dup 1)\n-\t\t (match_dup 2)))\n+\t(compare (match_dup 2)\n+\t\t (match_dup 3)))\n    (set (match_dup 0)\n-\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n+\t(match_op_dup 1 [(reg:CC FLG_REGNO) (const_int 0)]))]\n   \"\"\n   [(set_attr \"flags\" \"x\")]\n )\n@@ -240,21 +226,7 @@\n   [(set_attr \"flags\" \"x\")]\n   )\n \n-;; And these are the expanders, which read the pending compare\n-;; operands to build a combined insn.\n-\n-(define_expand \"s<code>\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n-\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n-  \"TARGET_A16\"\n-  \"m32c_expand_scc (<CODE>, operands); DONE;\")\n-\n-(define_expand \"s<code>_24\"\n-  [(set (match_operand:HI 0 \"mra_nopp_operand\" \"=RhiSd\")\n-\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n-  \"TARGET_A24\"\n-  \"m32c_expand_scc (<CODE>, operands); DONE;\")\n-\n+;; And these are the expanders.\n \n (define_expand \"movqicc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")"}, {"sha": "ef857275c9dd13af6a191fa8a4fcec21514e4cac", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -45,7 +45,6 @@ void m32c_register_pragmas (void);\n int  m32c_regno_ok_for_base_p (int);\n int  m32c_trampoline_alignment (void);\n int  m32c_trampoline_size (void);\n-void m32c_unpend_compare (void);\n \n #if defined(RTX_CODE) && defined(TREE_CODE)\n \n@@ -58,7 +57,6 @@ rtx  m32c_function_value (const_tree, const_tree);\n \n int  m32c_cannot_change_mode_class (MM, MM, int);\n int  m32c_class_max_nregs (int, MM);\n-rtx  m32c_cmp_flg_0 (rtx);\n rtx  m32c_eh_return_stackadj_rtx (void);\n void m32c_emit_eh_epilogue (rtx);\n int  m32c_expand_cmpstr (rtx *);\n@@ -68,7 +66,6 @@ int  m32c_expand_movmemhi (rtx *);\n int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n-void m32c_expand_scc (int, rtx *);\n int  m32c_extra_constraint_p (rtx, char, const char *);\n int  m32c_extra_constraint_p2 (rtx, char, const char *);\n int  m32c_hard_regno_nregs (int, MM);\n@@ -86,7 +83,6 @@ int  m32c_memory_move_cost (MM, int, int);\n int  m32c_modes_tieable_p (MM, MM);\n bool m32c_mov_ok (rtx *, MM);\n char * m32c_output_compare (rtx, rtx *);\n-void m32c_pend_compare (rtx *);\n int  m32c_preferred_output_reload_class (rtx, int);\n int  m32c_preferred_reload_class (rtx, int);\n int  m32c_prepare_move (rtx *, MM);"}, {"sha": "17d5dd32ebc07f215e70f9d81f952b7da0ebc961", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 9, "deletions": 70, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1746,22 +1746,15 @@ m32c_initialize_trampoline (rtx tramp, rtx function, rtx chainval)\n static void\n m32c_init_libfuncs (void)\n {\n+  /* We do this because the M32C has an HImode operand, but the\n+     M16C has an 8-bit operand.  Since gcc looks at the match data\n+     and not the expanded rtl, we have to reset the optab so that\n+     the right modes are found. */\n   if (TARGET_A24)\n     {\n-      /* We do this because the M32C has an HImode operand, but the\n-\t M16C has an 8-bit operand.  Since gcc looks at the match data\n-\t and not the expanded rtl, we have to reset the array so that\n-\t the right modes are found. */\n-      setcc_gen_code[EQ] = CODE_FOR_seq_24;\n-      setcc_gen_code[NE] = CODE_FOR_sne_24;\n-      setcc_gen_code[GT] = CODE_FOR_sgt_24;\n-      setcc_gen_code[GE] = CODE_FOR_sge_24;\n-      setcc_gen_code[LT] = CODE_FOR_slt_24;\n-      setcc_gen_code[LE] = CODE_FOR_sle_24;\n-      setcc_gen_code[GTU] = CODE_FOR_sgtu_24;\n-      setcc_gen_code[GEU] = CODE_FOR_sgeu_24;\n-      setcc_gen_code[LTU] = CODE_FOR_sltu_24;\n-      setcc_gen_code[LEU] = CODE_FOR_sleu_24;\n+      optab_handler (cstore_optab, QImode)->insn_code = CODE_FOR_cstoreqi4_24;\n+      optab_handler (cstore_optab, HImode)->insn_code = CODE_FOR_cstorehi4_24;\n+      optab_handler (cstore_optab, PSImode)->insn_code = CODE_FOR_cstorepsi4_24;\n     }\n }\n \n@@ -3691,57 +3684,8 @@ m32c_expand_neg_mulpsi3 (rtx * operands)\n   emit_insn (gen_truncsipsi2 (operands[0], temp2));\n }\n \n-static rtx compare_op0, compare_op1;\n-\n-void\n-m32c_pend_compare (rtx *operands)\n-{\n-  compare_op0 = operands[0];\n-  compare_op1 = operands[1];\n-}\n-\n-void\n-m32c_unpend_compare (void)\n-{\n-  switch (GET_MODE (compare_op0))\n-    {\n-    case QImode:\n-      emit_insn (gen_cmpqi_op (compare_op0, compare_op1));\n-    case HImode:\n-      emit_insn (gen_cmphi_op (compare_op0, compare_op1));\n-    case PSImode:\n-      emit_insn (gen_cmppsi_op (compare_op0, compare_op1));\n-    default:\n-      /* Just to silence the \"missing case\" warnings.  */ ;\n-    }\n-}\n-\n-void\n-m32c_expand_scc (int code, rtx *operands)\n-{\n-  enum machine_mode mode = TARGET_A16 ? QImode : HImode;\n-\n-  emit_insn (gen_rtx_SET (mode,\n-\t\t\t  operands[0],\n-\t\t\t  gen_rtx_fmt_ee (code,\n-\t\t\t\t\t  mode,\n-\t\t\t\t\t  compare_op0,\n-\t\t\t\t\t  compare_op1)));\n-}\n-\n /* Pattern Output Functions */\n \n-/* Returns a (OP (reg:CC FLG_REGNO) (const_int 0)) from some other\n-   match_operand rtx's OP.  */\n-rtx\n-m32c_cmp_flg_0 (rtx cmp)\n-{\n-  return gen_rtx_fmt_ee (GET_CODE (cmp),\n-\t\t\t GET_MODE (cmp),\n-\t\t\t gen_rtx_REG (CCmode, FLG_REGNO),\n-\t\t\t GEN_INT (0));\n-}\n-\n int\n m32c_expand_movcc (rtx *operands)\n {\n@@ -3753,22 +3697,17 @@ m32c_expand_movcc (rtx *operands)\n   if (GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT)\n     return 1;\n-  emit_insn (gen_cmpqi(XEXP (rel, 0), XEXP (rel, 1)));\n   if (GET_CODE (rel) == NE)\n     {\n       rtx tmp = operands[2];\n       operands[2] = operands[3];\n       operands[3] = tmp;\n+      rel = gen_rtx_EQ (GET_MODE (rel), XEXP (rel, 0), XEXP (rel, 1));\n     }\n \n-  cmp = gen_rtx_fmt_ee (GET_CODE (rel),\n-\t\t\tGET_MODE (rel),\n-\t\t\tcompare_op0,\n-\t\t\tcompare_op1);\n-\n   emit_move_insn (operands[0],\n \t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n-\t\t\t\t\tcmp,\n+\t\t\t\t\trel,\n \t\t\t\t\toperands[2],\n \t\t\t\t\toperands[3]));\n   return 0;"}, {"sha": "da0f8dd23f9c3bb1d36a0df9abde3c08bd2bdd67", "filename": "gcc/config/m32c/m32c.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32c%2Fm32c.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -60,10 +60,7 @@\n (define_mode_iterator QHSI [QI HI (SI \"TARGET_A24\")])\n (define_mode_attr bwl [(QI \"b\") (HI \"w\") (PSI \"l\") (SI \"l\")])\n \n-(define_code_iterator any_cond [eq ne gt ge lt le gtu geu ltu leu])\n (define_code_iterator eqne_cond [eq ne])\n-(define_code_iterator gl_cond [gt ge lt le gtu geu ltu leu])\n-\n \n \n (define_insn \"nop\""}, {"sha": "04533b9b49e34a48442e113ab8b4268621109776", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -38,6 +38,7 @@ extern enum m32r_function_type m32r_compute_function_type (tree);\n extern int    easy_di_const (rtx);\n extern int    easy_df_const (rtx);\n extern rtx    gen_compare (enum rtx_code, rtx, rtx, int);\n+extern bool   gen_cond_store (enum rtx_code, rtx, rtx, rtx);\n extern rtx    gen_split_move_double (rtx *);\n extern int    m32r_address_code (rtx);\n extern void   m32r_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "0b5ff6bc6fd5929b2e75345a954750f3b83f6738", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 147, "deletions": 6, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -43,10 +43,6 @@\n #include \"target-def.h\"\n #include \"tm-constrs.h\"\n \n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-rtx m32r_compare_op0, m32r_compare_op1;\n-\n /* Array of valid operand punctuation characters.  */\n char m32r_punct_chars[256];\n \n@@ -864,6 +860,151 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \n   return gen_rtx_fmt_ee (branch_code, VOIDmode, cc_reg, CONST0_RTX (CCmode));\n }\n+\n+bool\n+gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  gcc_assert (mode == SImode);\n+  switch (code)\n+    {\n+    case EQ:\n+      if (!register_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+\n+      if (TARGET_M32RX || TARGET_M32R2)\n+\t{\n+\t  if (!reg_or_zero_operand (op2, mode))\n+\t    op2 = force_reg (mode, op2);\n+\n+\t  emit_insn (gen_seq_insn_m32rx (op0, op1, op2));\n+\t  return true;\n+\t}\n+      if (GET_CODE (op2) == CONST_INT && INTVAL (op2) == 0)\n+\t{\n+\t  emit_insn (gen_seq_zero_insn (op0, op1));\n+\t  return true;\n+\t}\n+\n+      if (!reg_or_eq_int16_operand (op2, mode))\n+\top2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_seq_insn (op0, op1, op2));\n+      return true;\n+\n+    case NE:\n+      if (GET_CODE (op2) != CONST_INT\n+\t  || (INTVAL (op2) != 0 && satisfies_constraint_K (op2)))\n+\t{\n+\t  rtx reg;\n+\n+\t  if (reload_completed || reload_in_progress)\n+\t    return false;\n+\n+\t  reg = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_xorsi3 (reg, op1, op2));\n+\t  op1 = reg;\n+\n+\t  if (!register_operand (op1, mode))\n+\t    op1 = force_reg (mode, op1);\n+\n+\t  emit_insn (gen_sne_zero_insn (op0, op1));\n+\t  return true;\n+\t}\n+      return false;\n+\n+    case LT:\n+    case GT:\n+      if (code == GT)\n+\t{\n+\t  rtx tmp = op2;\n+\t  op2 = op1;\n+\t  op1 = tmp;\n+\t  code = LT;\n+\t}\n+\n+      if (!register_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+\n+      if (!reg_or_int16_operand (op2, mode))\n+\top2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_slt_insn (op0, op1, op2));\n+      return true;\n+\n+    case LTU:\n+    case GTU:\n+      if (code == GTU)\n+\t{\n+\t  rtx tmp = op2;\n+\t  op2 = op1;\n+\t  op1 = tmp;\n+\t  code = LTU;\n+\t}\n+\n+      if (!register_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+\n+      if (!reg_or_int16_operand (op2, mode))\n+\top2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_sltu_insn (op0, op1, op2));\n+      return true;\n+\n+    case GE:\n+    case GEU:\n+      if (!register_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+\n+      if (!reg_or_int16_operand (op2, mode))\n+\top2 = force_reg (mode, op2);\n+\n+      if (code == GE)\n+\temit_insn (gen_sge_insn (op0, op1, op2));\n+      else\n+\temit_insn (gen_sgeu_insn (op0, op1, op2));\n+      return true;\n+\n+    case LE:\n+    case LEU:\n+      if (!register_operand (op1, mode))\n+\top1 = force_reg (mode, op1);\n+\n+      if (GET_CODE (op2) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (op2);\n+\t  if (value >= 2147483647)\n+\t    {\n+\t      emit_move_insn (op0, const1_rtx);\n+\t      return true;\n+\t    }\n+\n+\t  op2 = GEN_INT (value + 1);\n+\t  if (value < -32768 || value >= 32767)\n+\t    op2 = force_reg (mode, op2);\n+\n+          if (code == LEU)\n+\t    emit_insn (gen_sltu_insn (op0, op1, op2));\n+\t  else\n+\t    emit_insn (gen_slt_insn (op0, op1, op2));\n+\t  return true;\n+\t}\n+\n+      if (!register_operand (op2, mode))\n+\top2 = force_reg (mode, op2);\n+\n+      if (code == LEU)\n+        emit_insn (gen_sleu_insn (op0, op1, op2));\n+      else\n+        emit_insn (gen_sle_insn (op0, op1, op2));\n+      return true;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n \f\n /* Split a 2 word move (DI or DF) into component parts.  */\n \n@@ -2291,8 +2432,8 @@ m32r_expand_block_move (rtx operands[])\n \n       if (bytes > MAX_MOVE_BYTES)\n \t{\n-\t  emit_insn (gen_cmpsi (src_reg, final_src));\n-\t  emit_jump_insn (gen_bne (label));\n+\t  rtx test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n+\t  emit_jump_insn (gen_cbranchsi4 (test, src_reg, final_src, label));\n \t}\n     }\n "}, {"sha": "41dc07abad6bfbc3e8939ea5eaf2c35c26dd9cb6", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1495,12 +1495,6 @@ extern char m32r_punct_chars[256];\n /* A function address in a call instruction.  */\n #define FUNCTION_MODE SImode\n \f\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-extern struct rtx_def * m32r_compare_op0;\n-extern struct rtx_def * m32r_compare_op1;\n-\n /* M32R function types.  */\n enum m32r_function_type\n {"}, {"sha": "0c76a044ccc2cb0fc494763c41a60966a1b86b6e", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 20, "deletions": 395, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1180,18 +1180,6 @@\n ;; thus merge the compare and branch into one instruction, so they are\n ;; preferred.\n \n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 17)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  m32r_compare_op0 = operands[0];\n-  m32r_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n (define_insn \"cmp_eqsi_zero_insn\"\n   [(set (reg:CC 17)\n         (eq:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n@@ -1256,114 +1244,20 @@\n \f\n ;; These control RTL generation for conditional jump insns.\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (EQ, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (NE, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (GT, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (LE, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (GE, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (LT, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (GTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (LEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare (GEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n-}\")\n-\n-(define_expand \"bltu\"\n+(define_expand \"cbranchsi4\"\n+  ; the comparison is emitted by gen_compare if needed.\n   [(set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"reg_or_cmp_int16_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (LTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[0] = gen_compare (GET_CODE (operands[0]), operands[1], operands[2], FALSE);\n+  operands[1] = XEXP (operands[0], 0);\n+  operands[2] = XEXP (operands[0], 1);\n }\")\n \n ;; Now match both normal and inverted jump.\n@@ -1597,40 +1491,21 @@\n \f\n ;; S<cc> operations to set a register to 1/0 based on a comparison\n \n-(define_expand \"seq\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n+(define_expand \"cstoresi4\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operator:SI 1 \"ordered_comparison_operator\"\n+    [(match_operand:SI 2 \"register_operand\" \"\")\n+     (match_operand:SI 3 \"reg_or_cmp_int16_operand\" \"\")])]\n   \"\"\n   \"\n {\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n+  if (GET_MODE (operands[0]) != SImode)\n     FAIL;\n \n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (TARGET_M32RX || TARGET_M32R2)\n-    {\n-      if (! reg_or_zero_operand (op2, mode))\n-        op2 = force_reg (mode, op2);\n-\n-      emit_insn (gen_seq_insn_m32rx (op0, op1, op2));\n-      DONE;\n-    }\n-  if (GET_CODE (op2) == CONST_INT && INTVAL (op2) == 0)\n-    {\n-      emit_insn (gen_seq_zero_insn (op0, op1));\n-      DONE;\n-    }\n-\n-  if (! reg_or_eq_int16_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n+  if (!gen_cond_store (GET_CODE (operands[1]),\n+\t\t       operands[0], operands[2], operands[3]))\n+    FAIL;\n \n-  emit_insn (gen_seq_insn (op0, op1, op2));\n   DONE;\n }\")\n \n@@ -1739,41 +1614,6 @@\n   end_sequence ();\n }\")\n \n-(define_expand \"sne\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-   if (GET_CODE (op2) != CONST_INT\n-      || (INTVAL (op2) != 0 && satisfies_constraint_K (op2)))\n-    {\n-      rtx reg;\n-\n-      if (reload_completed || reload_in_progress)\n-\tFAIL;\n-\n-      reg = gen_reg_rtx (SImode);\n-      emit_insn (gen_xorsi3 (reg, op1, op2));\n-      op1 = reg;\n-\n-      if (! register_operand (op1, mode))\n-        op1 = force_reg (mode, op1);\n-\n-      emit_insn (gen_sne_zero_insn (op0, op1));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n (define_insn \"sne_zero_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1801,29 +1641,6 @@\n \t(ne:SI (reg:CC 17) (const_int 0)))]\n   \"\")\n \n-(define_expand \"slt\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! reg_or_int16_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_slt_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"slt_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(lt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -1847,46 +1664,6 @@\n \t(ne:SI (reg:CC 17) (const_int 0)))]\n   \"\")\n \n-(define_expand \"sle\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op2);\n-      if (value >= 2147483647)\n-\t{\n-\t  emit_move_insn (op0, const1_rtx);\n-\t  DONE;\n-\t}\n-\n-      op2 = GEN_INT (value+1);\n-      if (value < -32768 || value >= 32767)\n-\top2 = force_reg (mode, op2);\n-\n-      emit_insn (gen_slt_insn (op0, op1, op2));\n-      DONE;\n-    }\n-\n-  if (! register_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sle_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"sle_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1933,52 +1710,6 @@\n \t(neg:SI (match_dup 0)))]\n   \"\")\n \n-(define_expand \"sgt\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! register_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_slt_insn (op0, op2, op1));\n-  DONE;\n-}\")\n-\n-(define_expand \"sge\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! reg_or_int16_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sge_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"sge_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ge:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -2025,29 +1756,6 @@\n \t(neg:SI (match_dup 0)))]\n   \"\")\n \n-(define_expand \"sltu\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! reg_or_int16_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sltu_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"sltu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ltu:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -2071,43 +1779,6 @@\n \t(ne:SI (reg:CC 17) (const_int 0)))]\n   \"\")\n \n-(define_expand \"sleu\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op2);\n-      if (value >= 2147483647)\n-\t{\n-\t  emit_move_insn (op0, const1_rtx);\n-\t  DONE;\n-\t}\n-\n-      op2 = GEN_INT (value+1);\n-      if (value < 0 || value >= 32767)\n-\top2 = force_reg (mode, op2);\n-\n-      emit_insn (gen_sltu_insn (op0, op1, op2));\n-      DONE;\n-    }\n-\n-  if (! register_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sleu_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"sleu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2154,52 +1825,6 @@\n \t(neg:SI (match_dup 0)))]\n   \"\")\n \n-(define_expand \"sgtu\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! register_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sltu_insn (op0, op2, op1));\n-  DONE;\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = m32r_compare_op0;\n-  rtx op2 = m32r_compare_op1;\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (mode != SImode)\n-    FAIL;\n-\n-  if (! register_operand (op1, mode))\n-    op1 = force_reg (mode, op1);\n-\n-  if (! reg_or_int16_operand (op2, mode))\n-    op2 = force_reg (mode, op2);\n-\n-  emit_insn (gen_sgeu_insn (op0, op1, op2));\n-  DONE;\n-}\")\n-\n (define_insn \"sgeu_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(geu:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -2546,8 +2171,8 @@\n     FAIL;\n \n   /* Generate the comparison that will set the carry flag.  */\n-  operands[1] = gen_compare (GET_CODE (operands[1]), m32r_compare_op0,\n-\t\t\t     m32r_compare_op1, TRUE);\n+  operands[1] = gen_compare (GET_CODE (operands[1]), XEXP (operands[1], 0),\n+\t\t\t     XEXP (operands[1], 1), TRUE);\n \n   /* See other movsicc pattern below for reason why.  */\n   emit_insn (gen_blockage ());"}, {"sha": "024e55de476368a7353342624dd170f87e43bfeb", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -141,10 +141,6 @@ int m68hc11_sp_correction;\n \n int m68hc11_addr_mode;\n int m68hc11_mov_addr_mode;\n-\n-/* Comparison operands saved by the \"tstxx\" and \"cmpxx\" expand patterns.  */\n-rtx m68hc11_compare_op0;\n-rtx m68hc11_compare_op1;\n \f\n \n const struct processor_costs *m68hc11_cost;\n@@ -3877,7 +3873,11 @@ m68hc11_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n \t{\n \t  cc_status.flags = 0;\n \t  cc_status.value1 = XEXP (exp, 0);\n-\t  cc_status.value2 = XEXP (exp, 1);\n+\t  if (GET_CODE (XEXP (exp, 1)) == COMPARE\n+\t      && XEXP (XEXP (exp, 1), 1) == CONST0_RTX (GET_MODE (XEXP (XEXP (exp, 1), 0))))\n+\t    cc_status.value2 = XEXP (XEXP (exp, 1), 0);\n+\t  else\n+\t    cc_status.value2 = XEXP (exp, 1);\n \t}\n       else\n \t{\n@@ -5355,6 +5355,7 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n     case COMPARE:\n     case ABS:\n     case ZERO_EXTEND:\n+    case ZERO_EXTRACT:\n       total = extra_cost + rtx_cost (XEXP (x, 0), code, !optimize_size);\n       if (mode == QImode)\n \t{\n@@ -5405,6 +5406,10 @@ m68hc11_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t*total = 0;\n       return true;\n     \n+    case ZERO_EXTRACT:\n+      if (outer_code != COMPARE)\n+\treturn false;\n+\n     case ROTATE:\n     case ROTATERT:\n     case ASHIFT:"}, {"sha": "29d998dbf89e152177784926431e4630cc7cac07", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1498,8 +1498,6 @@ extern int current_function_interrupt;\n extern int current_function_trap;\n extern int current_function_far;\n \n-extern GTY(()) rtx m68hc11_compare_op0;\n-extern GTY(()) rtx m68hc11_compare_op1;\n extern GTY(()) rtx m68hc11_soft_tmp_reg;\n extern GTY(()) rtx ix_reg;\n extern GTY(()) rtx iy_reg;"}, {"sha": "f4ff3ebbb4c5783cfea8e5b708d0878a8d831e6c", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 73, "deletions": 224, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -162,31 +162,11 @@\n ;; An offsetable memory operand should be ok.  The 'tst_operand' and\n ;; 'cmp_operand' predicates take care of this rule.\n ;;\n-(define_expand \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"tst_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = const0_rtx;\n-  DONE;\n-}\")\n-\n-(define_expand \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"tst_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = const0_rtx;\n-  DONE;\n-}\")\n \n (define_insn \"tsthi_1\"\n   [(set (cc0)\n-\t(match_operand:HI 0 \"tst_operand\" \"dx,*y\"))]\n+\t(compare (match_operand:HI 0 \"tst_operand\" \"dx,*y\")\n+\t\t (const_int 0)))]\n   \"\"\n   \"*\n {\n@@ -196,34 +176,26 @@\n      return \\\"cp%0\\\\t#0\\\";\n }\")\n \n-(define_expand \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"tst_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = const0_rtx;\n-  DONE;\n-}\")\n-\n ;;\n ;; Split pattern for (tst:QI) on an address register.\n ;;\n (define_split\n   [(set (cc0)\n-\t(match_operand:QI 0 \"hard_addr_reg_operand\" \"\"))]\n+\t(compare (match_operand:QI 0 \"hard_addr_reg_operand\" \"\")\n+\t\t (const_int 0)))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\"\n   [(parallel [(set (reg:HI D_REGNUM) (match_dup 1))\n \t      (set (match_dup 1) (reg:HI D_REGNUM))])\n-   (set (cc0) (reg:QI D_REGNUM))\n+   (set (cc0) (compare (reg:QI D_REGNUM)\n+\t\t       (const_int 0)))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 1))\n \t      (set (match_dup 1) (reg:HI D_REGNUM))])]\n   \"operands[1] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \n (define_insn \"tstqi_1\"\n   [(set (cc0)\n-\t(match_operand:QI 0 \"tst_operand\" \"m,d,*A,!u\"))]\n+\t(compare (match_operand:QI 0 \"tst_operand\" \"m,d,*A,!u\")\n+\t\t (const_int 0)))]\n   \"\"\n   \"*\n {\n@@ -252,16 +224,17 @@\n ;; after Z register replacement.\n ;;\n (define_insn_and_split \"tstqi_z_used\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"tst_operand\" \"m\"))\n+  [(set (cc0) (compare (match_operand:QI 0 \"tst_operand\" \"m\")\n+\t\t       (const_int 0)))\n    (use (match_operand:HI 1 \"hard_reg_operand\" \"dxy\"))\n    (use (reg:HI SOFT_Z_REGNUM))]\n   \"\"\n   \"#\"\n   \"z_replacement_completed == 2\"\n   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))\n    (set (match_dup 1) (match_dup 2))\n-   (set (cc0) (match_dup 0))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n    (set (match_dup 1) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n   \"operands[2] = gen_rtx_REG (HImode, SOFT_Z_REGNUM);\")\n \n@@ -270,21 +243,6 @@\n ;;- Compare\n ;;--------------------------------------------------------------------\n \n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"tst_operand\" \"\")\n-\t\t (match_operand:SI 1 \"cmp_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    operands[0] = force_reg (SImode, operands[0]);\n-\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;;\n ;; Comparison of a hard register with another one is provided because\n ;; it helps GCC to avoid to spill a pseudo hard register.\n@@ -316,21 +274,6 @@\n         (compare (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM)))))]\n   \"\")\n \n-(define_expand \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"tst_operand\" \"\")\n-\t\t (match_operand:HI 1 \"cmp_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    operands[0] = force_reg (HImode, operands[0]);\n-\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n (define_insn \"cmphi_1_hc12\"\n   [(set (cc0)\n \t(compare (match_operand:HI 0 \"tst_operand\" \n@@ -419,25 +362,11 @@\n    operands[3] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n    operands[4] = gen_rtx_REG (HImode, REGNO (operands[1]));\")\n \n-(define_expand \"cmpqi\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"tst_operand\" \"\")\n-\t\t (match_operand:QI 1 \"cmp_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    operands[0] = force_reg (QImode, operands[0]);\n-\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n (define_insn \"bitcmpqi\"\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"tst_operand\" \"d,d,d,m,!u\")\n-\t        (match_operand:QI 1 \"cmp_operand\" \"im,*B,u,d,d\")))]\n+\t(compare (and:QI (match_operand:QI 0 \"tst_operand\" \"d,d,d,m,!u\")\n+\t\t         (match_operand:QI 1 \"cmp_operand\" \"im,*B,u,d,d\"))\n+\t\t (const_int 0)))]\n   \"\"\n   \"@\n    bitb\\\\t%b1\n@@ -448,8 +377,9 @@\n \n (define_split /* \"bitcmpqi\" */\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"tst_operand\" \"\")\n-\t\t(match_operand:QI 1 \"hard_addr_reg_operand\" \"\")))]\n+\t(compare (and:QI (match_operand:QI 0 \"tst_operand\" \"\")\n+\t\t\t (match_operand:QI 1 \"hard_addr_reg_operand\" \"\"))\n+\t\t (const_int 0)))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 3) (match_dup 2))\n    (set (cc0) (and:QI (match_dup 0) (match_dup 4)))]\n@@ -459,8 +389,9 @@\n \n (define_insn_and_split \"bitcmpqi_z_used\"\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"tst_operand\" \"d,m\")\n-\t\t(match_operand:QI 1 \"cmp_operand\" \"m,d\")))\n+\t(compare (and:QI (match_operand:QI 0 \"tst_operand\" \"d,m\")\n+\t\t\t (match_operand:QI 1 \"cmp_operand\" \"m,d\"))\n+\t\t (const_int 0)))\n    (use (match_operand:HI 2 \"hard_reg_operand\" \"xy,xy\"))\n    (use (reg:HI SOFT_Z_REGNUM))]\n   \"\"\n@@ -474,8 +405,9 @@\n \n (define_insn \"bitcmphi\"\n   [(set (cc0)\n-\t(and:HI (match_operand:HI 0 \"tst_operand\" \"d\")\n-\t        (match_operand:HI 1 \"const_int_operand\" \"i\")))]\n+\t(compare (and:HI (match_operand:HI 0 \"tst_operand\" \"d\")\n+\t\t         (match_operand:HI 1 \"const_int_operand\" \"i\"))\n+\t\t (const_int 0)))]\n   \"(INTVAL (operands[1]) & 0x0ff) == 0\n    || (INTVAL (operands[1]) & 0x0ff00) == 0\"\n   \"*\n@@ -488,9 +420,10 @@\n \n (define_insn \"bitcmpqi_12\"\n   [(set (cc0)\n-\t(zero_extract (match_operand:HI 0 \"tst_operand\" \"d\")\n-\t              (match_operand:HI 1 \"const_int_operand\" \"i\")\n-\t\t      (match_operand:HI 2 \"const_int_operand\" \"i\")))]\n+\t(compare (zero_extract:HI (match_operand:HI 0 \"tst_operand\" \"d\")\n+\t\t                  (match_operand:HI 1 \"const_int_operand\" \"i\")\n+\t\t\t          (match_operand:HI 2 \"const_int_operand\" \"i\"))\n+\t\t (const_int 0)))]\n   \"(unsigned) (INTVAL (operands[2]) + INTVAL (operands[1])) <= 8\n    || (((unsigned) (INTVAL (operands[2]) + INTVAL (operands[1])) <= 16)\n        && (unsigned) INTVAL (operands[2]) >= 8)\"\n@@ -6134,155 +6067,66 @@\n   \"\"\n   \"bra\\\\t%l0\")\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (EQ, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (NE, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchsi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 1 \"tst_operand\" \"\")\n+\t\t (match_operand:SI 2 \"cmp_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  m68hc11_expand_compare_and_branch (GT, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n+  if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[2]) == MEM)\n+    operands[1] = force_reg (SImode, operands[1]);\n \n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (GTU, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n+  m68hc11_expand_compare_and_branch (GET_CODE (operands[0]), operands[1],\n+\t\t\t\t     operands[2], operands[3]);\n   DONE;\n }\")\n \n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (LT, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchhi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 1 \"tst_operand\" \"\")\n+\t\t (match_operand:HI 2 \"cmp_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  m68hc11_expand_compare_and_branch (LTU, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n+  if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[2]) == MEM)\n+    operands[1] = force_reg (HImode, operands[1]);\n \n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (GE, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n+  m68hc11_expand_compare_and_branch (GET_CODE (operands[0]), operands[1],\n+\t\t\t\t     operands[2], operands[3]);\n   DONE;\n }\")\n \n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchqi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 1 \"tst_operand\" \"\")\n+\t\t (match_operand:QI 2 \"cmp_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  m68hc11_expand_compare_and_branch (GEU, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n+  if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[2]) == MEM)\n+    operands[1] = force_reg (QImode, operands[1]);\n \n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (LE, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n+  m68hc11_expand_compare_and_branch (GET_CODE (operands[0]), operands[1],\n+\t\t\t\t     operands[2], operands[3]);\n   DONE;\n }\")\n \n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  m68hc11_expand_compare_and_branch (LEU, m68hc11_compare_op0,\n-\t\t\t\t     m68hc11_compare_op1, \n-\t\t\t\t     operands[0]);\n-  DONE;\n-}\")\n \n ;;\n ;; Test and branch instructions for 68HC12 for EQ and NE.\n@@ -7091,11 +6935,14 @@\n \t(plus:HI (match_dup 0)\n \t         (match_operand:HI 1 \"const_int_operand\" \"\")))\n    (set (cc0)\n-\t(match_operand:QI 2 \"memory_operand\" \"\"))]\n+\t(compare (match_operand:QI 2 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n   \"TARGET_AUTO_INC_DEC\n    && (INTVAL (operands[1]) == -1 || INTVAL (operands[1]) == 1)\n    && reg_mentioned_p (operands[0], operands[2])\"\n-  [(set (cc0) (match_dup 3))]\n+  [(set (cc0)\n+\t(compare (match_dup 3)\n+\t\t (const_int 0)))]\n   \"if (INTVAL (operands[1]) == 1)\n      operands[3] = gen_rtx_MEM (QImode,\n \t\t\t    gen_rtx_PRE_INC (HImode, operands[0]));\n@@ -7326,7 +7173,8 @@\n \t(match_operand:HI 1 \"hard_reg_operand\" \"\"))\n    (set (match_dup 1) (plus:HI (match_dup 1) \n                                (match_operand:HI 2 \"const_int_operand\" \"\")))\n-   (set (cc0) (match_dup 0))]\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))]\n   \"peep2_reg_dead_p (3, operands[0]) && !Z_REG_P (operands[1])\"\n   [(set (match_dup 1) (plus:HI (match_dup 1) (match_dup 2)))\n    (set (cc0) (compare (match_dup 1) (match_dup 2)))]\n@@ -7339,7 +7187,8 @@\n         (plus:HI (match_dup 2) \n                  (match_operand:HI 3 \"const_int_operand\" \"\")))\n    (set (match_operand:HI 4 \"memory_operand\" \"\") (match_dup 2))\n-   (set (cc0) (match_operand:HI 5 \"hard_reg_operand\" \"\"))]\n+   (set (cc0) (compare (match_operand:HI 5 \"hard_reg_operand\" \"\")\n+\t\t       (const_int 0)))]\n   \"peep2_reg_dead_p (4, operands[5]) && !Z_REG_P (operands[2])\n    && !reg_mentioned_p (operands[2], operands[4])\n "}, {"sha": "8be423788d650e7c444e871f5f7ce6308da162d6", "filename": "gcc/config/m68k/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fconstraints.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -78,6 +78,11 @@\n   (and (match_code \"const_double\")\n        (match_test \"!(TARGET_68881 && standard_68881_constant_p (op))\")))\n \n+(define_constraint \"H\"\n+  \"Defines a real zero constant.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n (define_constraint \"S\"\n   \"Used for operands that satisfy 'm' when -mpcrel is in effect.\"\n   (and (match_code \"mem\")"}, {"sha": "1b5c83bb414eb0b61a92e4b383c21d6dd4d30018", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -152,11 +152,6 @@ static bool m68k_return_in_memory (const_tree, const_tree);\n \n /* Specify the identification number of the library being built */\n const char *m68k_library_id_string = \"_current_shared_library_a5_offset_\";\n-\n-/* Nonzero if the last compare/test insn had FP operands.  The\n-   sCC expanders peek at this to determine what to do for the\n-   68060, which has no fsCC instructions.  */\n-int m68k_last_compare_had_fp_operands;\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -1024,10 +1019,10 @@ m68k_expand_prologue (void)\n \t  emit_move_insn (gen_rtx_REG (Pmode, D0_REG), limit);\n \t  limit = gen_rtx_REG (Pmode, D0_REG);\n \t}\n-      emit_insn (gen_cmpsi (stack_pointer_rtx, limit));\n-      emit_insn (gen_conditional_trap (gen_rtx_LTU (VOIDmode,\n-\t\t\t\t\t\t    cc0_rtx, const0_rtx),\n-\t\t\t\t       const1_rtx));\n+      emit_insn (gen_ctrapsi4 (gen_rtx_LTU (VOIDmode,\n+\t\t\t\t\t    stack_pointer_rtx, limit),\n+\t\t\t       stack_pointer_rtx, limit,\n+\t\t\t       const1_rtx));\n     }\n \n   fsize_with_regs = current_frame.size;\n@@ -1110,12 +1105,11 @@ m68k_expand_prologue (void)\n   if (crtl->limit_stack)\n     {\n       if (REG_P (stack_limit_rtx))\n-\t{\n-\t  emit_insn (gen_cmpsi (stack_pointer_rtx, stack_limit_rtx));\n-\t  emit_insn (gen_conditional_trap (gen_rtx_LTU (VOIDmode,\n-\t\t\t\t\t\t\tcc0_rtx, const0_rtx),\n-\t\t\t\t\t   const1_rtx));\n-\t}\n+        emit_insn (gen_ctrapsi4 (gen_rtx_LTU (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t\t      stack_limit_rtx),\n+\t\t\t         stack_pointer_rtx, stack_limit_rtx,\n+\t\t\t         const1_rtx));\n+\n       else if (GET_CODE (stack_limit_rtx) != SYMBOL_REF)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n@@ -2418,6 +2412,11 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t*total = COSTS_N_INSNS (43);\t\t/* div.l */\n       return true;\n \n+    case ZERO_EXTRACT:\n+      if (outer_code == COMPARE)\n+        *total = 0;\n+      return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "ec0b35bdc1b29c80bd1eb330e067c0156969dc0d", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1060,7 +1060,6 @@ enum m68k_function_kind\n \n /* Variables in m68k.c; see there for details.  */\n extern const char *m68k_library_id_string;\n-extern int m68k_last_compare_had_fp_operands;\n extern enum target_device m68k_cpu;\n extern enum uarch_type m68k_tune;\n extern enum fpu_type m68k_fpu;"}, {"sha": "33058fa08b889d504a01d2590dc9d517dc40001a", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 251, "deletions": 302, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -300,17 +300,10 @@\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n \n-(define_expand \"tstdi\"\n-  [(parallel [(set (cc0)\n-\t\t   (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n-\t      (clobber (match_scratch:SI 1 \"\"))\n-\t      (clobber (match_scratch:DI 2 \"\"))])]\n-  \"\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n-\n-(define_insn \"\"\n+(define_insn \"tstdi\"\n   [(set (cc0)\n-\t(match_operand:DI 0 \"nonimmediate_operand\" \"am,d\"))\n+\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"am,d\")\n+\t\t (const_int 0)))\n    (clobber (match_scratch:SI 1 \"=X,d\"))\n    (clobber (match_scratch:DI 2 \"=d,X\"))]\n   \"\"\n@@ -339,25 +332,21 @@\n     return \"sub%.l %1,%1\\;tst%.l %R0\\;subx%.l %1,%0\";\n })\n \n-(define_expand \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n-\n ;; If you think that the 68020 does not support tstl a0,\n ;; reread page B-167 of the 68020 manual more carefully.\n (define_insn \"*tstsi_internal_68020_cf\"\n   [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t (const_int 0)))]\n   \"TARGET_68020 || TARGET_COLDFIRE\"\n   \"tst%.l %0\"\n   [(set_attr \"type\" \"tst_l\")])\n \n ;; On an address reg, cmpw may replace cmpl.\n (define_insn \"*tstsi_internal\"\n   [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"dm,r\"))]\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"dm,r\")\n+\t\t (const_int 0)))]\n   \"!(TARGET_68020 || TARGET_COLDFIRE)\"\n   \"@\n    tst%.l %0\n@@ -366,43 +355,26 @@\n \n ;; This can't use an address register, because comparisons\n ;; with address registers as second operand always test the whole word.\n-(define_expand \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n-\n (define_insn \"*tsthi_internal\"\n   [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"dm\"))]\n+\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"dm\")\n+\t\t (const_int 0)))]\n   \"\"\n   \"tst%.w %0\"\n   [(set_attr \"type\" \"tst\")])\n \n-(define_expand \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n-\n (define_insn \"*tstqi_internal\"\n   [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n+\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"dm\")\n+\t\t (const_int 0)))]\n   \"\"\n   \"tst%.b %0\"\n   [(set_attr \"type\" \"tst\")])\n \n-(define_expand \"tst<mode>\"\n-  [(set (cc0)\n-\t(match_operand:FP 0 \"general_operand\" \"\"))]\n-  \"TARGET_HARD_FLOAT\"\n-{\n-  m68k_last_compare_had_fp_operands = 1;\n-})\n-\n (define_insn \"tst<mode>_68881\"\n   [(set (cc0)\n-\t(match_operand:FP 0 \"general_operand\" \"f<FP:dreg>m\"))]\n+\t(compare (match_operand:FP 0 \"general_operand\" \"f<FP:dreg>m\")\n+\t\t (match_operand:FP 1 \"const0_operand\" \"H\")))]\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n@@ -414,7 +386,8 @@\n \n (define_insn \"tst<mode>_cf\"\n   [(set (cc0)\n-\t(match_operand:FP 0 \"general_operand\" \"f<FP:dreg><Q>U\"))]\n+\t(compare (match_operand:FP 0 \"general_operand\" \"f<FP:dreg><Q>U\")\n+\t\t (match_operand:FP 1 \"const0_operand\" \"H\")))]\n   \"TARGET_COLDFIRE_FPU\"\n {\n   cc_status.flags = CC_IN_68881;\n@@ -427,20 +400,11 @@\n \f\n ;; compare instructions.\n \n-(define_expand \"cmpdi\"\n-  [(parallel\n-    [(set (cc0)\n-\t  (compare (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:DI 1 \"general_operand\" \"\")))\n-     (clobber (match_scratch:DI 2 \"\"))])]\n-  \"\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:DI 1 \"nonimmediate_operand\" \"0,d\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d,0\")))\n-   (clobber (match_scratch:DI 0 \"=d,d\"))]\n+(define_insn \"*cmpdi_internal\"\n+ [(set (cc0)\n+       (compare (match_operand:DI 1 \"nonimmediate_operand\" \"0,d\")\n+                (match_operand:DI 2 \"general_operand\" \"d,0\")))\n+  (clobber (match_scratch:DI 0 \"=d,d\"))]\n   \"\"\n {\n   if (rtx_equal_p (operands[0], operands[1]))\n@@ -452,15 +416,71 @@\n     }\n })\n \n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"\")))]\n+(define_insn \"cmpdi\"\n+ [(set (cc0)\n+       (compare (match_operand:DI 0 \"nonimmediate_operand\")\n+                (match_operand:DI 1 \"general_operand\")))\n+  (clobber (match_scratch:DI 2))]\n+  \"\"\n+  \"\")\n+\n+\n+(define_expand \"cbranchdi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:DI 1 \"nonimmediate_operand\")\n+\t\t\t(match_operand:DI 2 \"general_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n   \"\"\n {\n-  m68k_last_compare_had_fp_operands = 0;\n+  if (operands[2] == const0_rtx)\n+    emit_insn (gen_tstdi (operands[1]));\n+  else\n+    emit_insn (gen_cmpdi (operands[1], operands[2]));\n+  operands[1] = cc0_rtx;\n+  operands[2] = const0_rtx;\n+})\n+\n+(define_expand \"cstoredi4\"\n+  [(set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:DI 2 \"nonimmediate_operand\")\n+\t  (match_operand:DI 3 \"general_operand\")]))]\n+  \"\"\n+{\n+  if (operands[3] == const0_rtx)\n+    emit_insn (gen_tstdi (operands[2]));\n+  else\n+    emit_insn (gen_cmpdi (operands[2], operands[3]));\n+  operands[2] = cc0_rtx;\n+  operands[3] = const0_rtx;\n })\n \n+\n+(define_expand \"cbranchsi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cstoresi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:SI 3 \"general_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+         [(cc0) (const_int 0)]))]\n+  \"\"\n+  \"\")\n+\n+\n ;; A composite of the cmp, cmpa, cmpi & cmpm m68000 op codes.\n (define_insn \"\"\n   [(set (cc0)\n@@ -500,12 +520,27 @@\n }\n   [(set_attr \"type\" \"cmp_l\")])\n \n-(define_expand \"cmphi\"\n+(define_expand \"cbranchhi4\"\n   [(set (cc0)\n-        (compare (match_operand:HI 0 \"nonimmediate_src_operand\" \"\")\n-                 (match_operand:HI 1 \"general_src_operand\" \"\")))]\n-  \"!TARGET_COLDFIRE\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n+\t(compare (match_operand:HI 1 \"nonimmediate_src_operand\" \"\")\n+\t\t (match_operand:HI 2 \"m68k_subword_comparison_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cstorehi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 2 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:HI 3 \"m68k_subword_comparison_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+         [(cc0) (const_int 0)]))]\n+  \"\"\n+  \"\")\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -524,12 +559,27 @@\n   return \"cmp%.w %d1,%d0\";\n })\n \n-(define_expand \"cmpqi\"\n+(define_expand \"cbranchqi4\"\n   [(set (cc0)\n-        (compare (match_operand:QI 0 \"nonimmediate_src_operand\" \"\")\n-                 (match_operand:QI 1 \"general_src_operand\" \"\")))]\n-  \"!TARGET_COLDFIRE\"\n-  \"m68k_last_compare_had_fp_operands = 0;\")\n+\t(compare (match_operand:QI 1 \"nonimmediate_src_operand\" \"\")\n+\t\t (match_operand:QI 2 \"m68k_subword_comparison_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cstoreqi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 2 \"nonimmediate_src_operand\" \"\")\n+\t\t (match_operand:QI 3 \"m68k_subword_comparison_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator:QI 1 \"ordered_comparison_operator\"\n+         [(cc0) (const_int 0)]))]\n+  \"\"\n+  \"\")\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -548,12 +598,28 @@\n   return \"cmp%.b %d1,%d0\";\n })\n \n-(define_expand \"cmp<mode>\"\n+(define_expand \"cbranch<mode>4\"\n   [(set (cc0)\n-\t(compare (match_operand:FP 0 \"register_operand\" \"\")\n-\t\t (match_operand:FP 1 \"fp_src_operand\" \"\")))]\n+\t(compare (match_operand:FP 1 \"register_operand\" \"\")\n+\t\t (match_operand:FP 2 \"fp_src_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+                       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n   \"TARGET_HARD_FLOAT\"\n-  \"m68k_last_compare_had_fp_operands = 1;\")\n+  \"\")\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (cc0)\n+\t(compare (match_operand:FP 2 \"register_operand\" \"\")\n+\t\t (match_operand:FP 3 \"fp_src_operand\" \"\")))\n+   (set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator:QI 1 \"m68k_cstore_comparison_operator\"\n+         [(cc0) (const_int 0)]))]\n+  \"TARGET_HARD_FLOAT && !(TUNE_68060 || TARGET_COLDFIRE_FPU)\"\n+  \"if (TARGET_COLDFIRE && operands[2] != const0_rtx)\n+     FAIL;\")\n \n (define_insn \"*cmp<mode>_68881\"\n   [(set (cc0)\n@@ -588,10 +654,13 @@\n ;; from a MEM at a constant bit position if we can't use this as a constraint.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_src_operand\" \"oS\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 7)\n-\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:QI 0 \"memory_src_operand\" \"oS\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (minus:SI (const_int 7)\n+\t\t\t\t         (match_operand:SI 1 \"general_operand\" \"di\")))\n+\t     (const_int 0)))]\n   \"!TARGET_COLDFIRE\"\n {\n   return output_btst (operands, operands[1], operands[0], insn, 7);\n@@ -601,20 +670,26 @@\n ;; has been deleted.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 7)\n-\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"d\"))))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (minus:SI (const_int 7)\n+\t\t\t\t         (match_operand:SI 1 \"general_operand\" \"d\")))\n+\t     (const_int 0)))]\n   \"TARGET_COLDFIRE\"\n {\n   return output_btst (operands, operands[1], operands[0], insn, 7);\n })\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 31)\n-\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (minus:SI (const_int 31)\n+\t\t\t\t         (match_operand:SI 1 \"general_operand\" \"di\")))\n+\t     (const_int 0)))]\n   \"\"\n {\n   return output_btst (operands, operands[1], operands[0], insn, 31);\n@@ -625,24 +700,30 @@\n ;; are automatically masked to 3 or 5 bits.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 7)\n-\t\t\t\t      (and:SI\n-\t\t\t\t       (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t\t       (const_int 7)))))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (minus:SI (const_int 7)\n+\t\t\t\t         (and:SI\n+\t\t\t\t          (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t\t          (const_int 7))))\n+\t     (const_int 0)))]\n   \"\"\n {\n   return output_btst (operands, operands[1], operands[0], insn, 7);\n })\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 31)\n-\t\t\t\t      (and:SI\n-\t\t\t\t       (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t\t       (const_int 31)))))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (minus:SI (const_int 31)\n+\t\t\t\t         (and:SI\n+\t\t\t\t          (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t\t          (const_int 31))))\n+\t     (const_int 0)))]\n   \"\"\n {\n   return output_btst (operands, operands[1], operands[0], insn, 31);\n@@ -651,19 +732,25 @@\n ;; Nonoffsettable mem refs are ok in this one pattern\n ;; since we don't try to adjust them.\n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t     (const_int 0)))]\n   \"(unsigned) INTVAL (operands[1]) < 8 && !TARGET_COLDFIRE\"\n {\n   operands[1] = GEN_INT (7 - INTVAL (operands[1]));\n   return output_btst (operands, operands[1], operands[0], insn, 7);\n })\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"do\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"do\")\n+\t\t\t      (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t     (const_int 0)))]\n   \"!TARGET_COLDFIRE\"\n {\n   if (GET_CODE (operands[0]) == MEM)\n@@ -681,9 +768,12 @@\n ;; The 'o' has been replaced with 'Q'.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"dQ\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n+  [(set\n+    (cc0)\n+    (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dQ\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t     (const_int 0)))]\n   \"TARGET_COLDFIRE\"\n {\n   if (GET_CODE (operands[0]) == MEM)\n@@ -5751,9 +5841,10 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"dn\")))]\n+\t(compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t\t  (match_operand:SI 2 \"general_operand\" \"dn\"))\n+\t         (const_int 0)))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   if (operands[1] == const1_rtx\n@@ -5776,9 +5867,10 @@\n ;;; now handle the register cases\n (define_insn \"\"\n   [(set (cc0)\n-\t(zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"dn\")))]\n+\t(compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t \t  (match_operand:SI 2 \"general_operand\" \"dn\"))\n+\t\t (const_int 0)))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   if (operands[1] == const1_rtx\n@@ -5798,7 +5890,7 @@\n \f\n (define_insn \"scc0_di\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n-    (match_operator 1 \"valid_dbcc_comparison_p\"\n+    (match_operator 1 \"ordered_comparison_operator\"\n       [(match_operand:DI 2 \"general_operand\" \"ro\") (const_int 0)]))]\n   \"! TARGET_COLDFIRE\"\n {\n@@ -5807,7 +5899,7 @@\n \n (define_insn \"scc0_di_5200\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n-    (match_operator 1 \"valid_dbcc_comparison_p\"\n+    (match_operator 1 \"ordered_comparison_operator\"\n       [(match_operand:DI 2 \"general_operand\" \"ro\") (const_int 0)]))]\n   \"TARGET_COLDFIRE\"\n {\n@@ -5816,7 +5908,7 @@\n \n (define_insn \"scc_di\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm,dm\")\n-    (match_operator 1 \"valid_dbcc_comparison_p\"\n+    (match_operator 1 \"ordered_comparison_operator\"\n       [(match_operand:DI 2 \"general_operand\" \"ro,r\")\n        (match_operand:DI 3 \"general_operand\" \"r,ro\")]))]\n   \"! TARGET_COLDFIRE\"\n@@ -5826,7 +5918,7 @@\n \n (define_insn \"scc_di_5200\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d\")\n-    (match_operator 1 \"valid_dbcc_comparison_p\"\n+    (match_operator 1 \"ordered_comparison_operator\"\n       [(match_operand:DI 2 \"general_operand\" \"ro,r\")\n        (match_operand:DI 3 \"general_operand\" \"r,ro\")]))]\n   \"TARGET_COLDFIRE\"\n@@ -5838,19 +5930,6 @@\n ;; memory, but we cannot allow it to be in memory in case the address\n ;; needs to be reloaded.\n \n-(define_expand \"seq\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(eq:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(eq:QI (cc0) (const_int 0)))]\n@@ -5860,19 +5939,6 @@\n   OUTPUT_JUMP (\"seq %0\", \"fseq %0\", \"seq %0\");\n })\n \n-(define_expand \"sne\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ne:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ne:QI (cc0) (const_int 0)))]\n@@ -5882,19 +5948,6 @@\n   OUTPUT_JUMP (\"sne %0\", \"fsne %0\", \"sne %0\");\n })\n \n-(define_expand \"sgt\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(gt:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(gt:QI (cc0) (const_int 0)))]\n@@ -5904,12 +5957,6 @@\n   OUTPUT_JUMP (\"sgt %0\", \"fsgt %0\", 0);\n })\n \n-(define_expand \"sgtu\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(gtu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(gtu:QI (cc0) (const_int 0)))]\n@@ -5919,19 +5966,6 @@\n   return \"shi %0\";\n })\n \n-(define_expand \"slt\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(lt:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(lt:QI (cc0) (const_int 0)))]\n@@ -5941,12 +5975,6 @@\n    OUTPUT_JUMP (\"slt %0\", \"fslt %0\", \"smi %0\");\n })\n \n-(define_expand \"sltu\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ltu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ltu:QI (cc0) (const_int 0)))]\n@@ -5956,19 +5984,6 @@\n    return \"scs %0\";\n })\n \n-(define_expand \"sge\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ge:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ge:QI (cc0) (const_int 0)))]\n@@ -5978,12 +5993,6 @@\n    OUTPUT_JUMP (\"sge %0\", \"fsge %0\", \"spl %0\");\n })\n \n-(define_expand \"sgeu\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(geu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*scc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(geu:QI (cc0) (const_int 0)))]\n@@ -5994,19 +6003,6 @@\n }\n   [(set_attr \"type\" \"scc\")])\n \n-(define_expand \"sle\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(le:QI (cc0) (const_int 0)))]\n-  \"\"\n-{\n-  if ((TUNE_68060 || TARGET_COLDFIRE_FPU)\n-      && m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n-})\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(le:QI (cc0) (const_int 0)))]\n@@ -6016,12 +6012,6 @@\n   OUTPUT_JUMP (\"sle %0\", \"fsle %0\", 0);\n })\n \n-(define_expand \"sleu\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(leu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*sls\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(leu:QI (cc0) (const_int 0)))]\n@@ -6032,15 +6022,6 @@\n }\n   [(set_attr \"type\" \"scc\")])\n \n-(define_expand \"sordered\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sordered_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ordered:QI (cc0) (const_int 0)))]\n@@ -6050,15 +6031,6 @@\n   return \"fsor %0\";\n })\n \n-(define_expand \"sunordered\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(unordered:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sunordered_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unordered:QI (cc0) (const_int 0)))]\n@@ -6068,15 +6040,6 @@\n   return \"fsun %0\";\n })\n \n-(define_expand \"suneq\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(uneq:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*suneq_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(uneq:QI (cc0) (const_int 0)))]\n@@ -6086,15 +6049,6 @@\n   return \"fsueq %0\";\n })\n \n-(define_expand \"sunge\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(unge:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sunge_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unge:QI (cc0) (const_int 0)))]\n@@ -6104,15 +6058,6 @@\n   return \"fsuge %0\";\n })\n \n-(define_expand \"sungt\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ungt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sungt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ungt:QI (cc0) (const_int 0)))]\n@@ -6122,15 +6067,6 @@\n   return \"fsugt %0\";\n })\n \n-(define_expand \"sunle\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(unle:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sunle_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unle:QI (cc0) (const_int 0)))]\n@@ -6140,15 +6076,6 @@\n   return \"fsule %0\";\n })\n \n-(define_expand \"sunlt\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(unlt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sunlt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(unlt:QI (cc0) (const_int 0)))]\n@@ -6158,15 +6085,6 @@\n   return \"fsult %0\";\n })\n \n-(define_expand \"sltgt\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ltgt:QI (cc0) (const_int 0)))]\n-  \"TARGET_68881 && !TUNE_68060\"\n-{\n-  gcc_assert (m68k_last_compare_had_fp_operands);\n-  m68k_last_compare_had_fp_operands = 0;\n-})\n-\n (define_insn \"*sltgt_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ltgt:QI (cc0) (const_int 0)))]\n@@ -7758,23 +7676,54 @@\n   \"trap #7\"\n   [(set_attr \"type\" \"trap\")])\n \n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"valid_dbcc_comparison_p\"\n+(define_expand \"ctrapdi4\"\n+  [(trap_if (match_operator 0 \"ordered_comparison_operator\"\n \t\t\t    [(cc0) (const_int 0)])\n-\t    (match_operand:SI 1 \"const_int_operand\" \"I\"))]\n+\t    (match_operand:SI 3 \"const1_operand\" \"\"))]\n   \"TARGET_68020\"\n {\n-  if (m68k_last_compare_had_fp_operands)\n-    {\n-      m68k_last_compare_had_fp_operands = 0;\n-      FAIL;\n-    }\n+  if (operands[2] == const0_rtx)\n+    emit_insn (gen_tstdi (operands[1]));\n+  else\n+    emit_insn (gen_cmpdi (operands[1], operands[2]));\n+  operands[1] = cc0_rtx;\n+  operands[2] = const0_rtx;\n })\n \n+(define_expand \"ctrapsi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+   (trap_if (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t    (match_operand:SI 3 \"const1_operand\" \"\"))]\n+  \"TARGET_68020\"\n+  \"\")\n+\n+(define_expand \"ctraphi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 1 \"nonimmediate_src_operand\" \"\")\n+\t\t (match_operand:HI 2 \"general_src_operand\" \"\")))\n+   (trap_if (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t    (match_operand:SI 3 \"const1_operand\" \"\"))]\n+  \"TARGET_68020\"\n+  \"\")\n+\n+(define_expand \"ctrapqi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 1 \"nonimmediate_src_operand\" \"\")\n+\t\t (match_operand:QI 2 \"general_src_operand\" \"\")))\n+   (trap_if (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t    (match_operand:SI 3 \"const1_operand\" \"\"))]\n+  \"TARGET_68020\"\n+  \"\")\n+\n (define_insn \"*conditional_trap\"\n-  [(trap_if (match_operator 0 \"valid_dbcc_comparison_p\"\n+  [(trap_if (match_operator 0 \"ordered_comparison_operator\"\n \t\t\t    [(cc0) (const_int 0)])\n-\t    (match_operand:SI 1 \"const_int_operand\" \"I\"))]\n+\t    (match_operand:SI 1 \"const1_operand\" \"I\"))]\n   \"TARGET_68020 && ! flags_in_68881 ()\"\n {\n   switch (GET_CODE (operands[0]))"}, {"sha": "417989f6d6c408fa82af9f9649a204b9a754d1dc", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -124,6 +124,11 @@\n   (and (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\")\n        (match_test \"valid_dbcc_comparison_p_2 (op, mode)\")))\n \n+(define_predicate \"m68k_cstore_comparison_operator\"\n+  (if_then_else (match_test \"TARGET_68881\")\n+\t        (match_operand 0 \"comparison_operator\")\n+\t\t(match_operand 0 \"ordered_comparison_operator\")))\n+\n ;; Check for sign_extend or zero_extend.  Used for bit-count operands.\n \n (define_predicate \"extend_operator\"\n@@ -193,6 +198,24 @@\n   (and (match_code \"mem\")\n        (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\")))\n \n+;; A zero constant.\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; A one constant (operand for conditional_trap).\n+(define_predicate \"const1_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"op == const1_rtx\")))\n+\n+;; A valid operand for a HImode or QImode conditional operation.\n+;; ColdFire has tst patterns, but not cmp patterns.\n+(define_predicate \"m68k_subword_comparison_operand\"\n+  (if_then_else (match_test \"TARGET_COLDFIRE\")\n+                (and (match_code \"const_int\")\n+\t\t     (match_test \"op == const0_rtx\"))\n+\t\t(match_operand 0 \"general_src_operand\")))\n+\n ;; An operand for movsi_const0 pattern.\n (define_predicate \"movsi_const0_operand\"\n   (and (match_operand 0 \"nonimmediate_operand\")"}, {"sha": "331cf7191d7be99feb7803e54dc815094c2a5e01", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -46,21 +46,17 @@ extern rtx          mcore_function_value         \t(const_tree, const_tree);\n \n #ifdef RTX_CODE\n \n-extern GTY(()) rtx arch_compare_op0;\n-extern GTY(()) rtx arch_compare_op1;\n-\n extern const char * mcore_output_bclri         \t\t(rtx, int);\n extern const char * mcore_output_bseti         \t\t(rtx, int);\n extern const char * mcore_output_cmov          \t\t(rtx *, int, const char *);\n extern char *       mcore_output_call          \t\t(rtx *, int);\n extern int          mcore_is_dead                \t(rtx, rtx);\n extern int          mcore_expand_insv            \t(rtx *);\n-extern int          mcore_modify_comparison      \t(RTX_CODE);\n extern bool         mcore_expand_block_move      \t(rtx *);\n extern const char * mcore_output_andn          \t\t(rtx, rtx *);\n extern void         mcore_print_operand_address  \t(FILE *, rtx);\n extern void         mcore_print_operand          \t(FILE *, rtx, int);\n-extern rtx          mcore_gen_compare_reg        \t(RTX_CODE);\n+extern bool         mcore_gen_compare\t        \t(RTX_CODE, rtx, rtx);\n extern int          mcore_symbolic_address_p     \t(rtx);\n extern bool         mcore_r15_operand_p\t\t\t(rtx);\n extern enum reg_class mcore_secondary_reload_class\t(enum reg_class, enum machine_mode, rtx);"}, {"sha": "472bb75562a6d991ecae7fd2917fbe88f318133c", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -57,11 +57,6 @@ long   mcore_current_compilation_timestamp = 0;\n \n /* Global variables for machine-dependent things.  */\n \n-/* Saved operands from the last compare to use when we generate an scc\n-  or bcc insn.  */\n-rtx arch_compare_op0;\n-rtx arch_compare_op1;\n-\n /* Provides the class number of the smallest class containing\n    reg number.  */\n const int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n@@ -519,55 +514,55 @@ mcore_rtx_costs (rtx x, int code, int outer_code, int * total,\n     }\n }\n \n-/* Check to see if a comparison against a constant can be made more efficient\n-   by incrementing/decrementing the constant to get one that is more efficient\n-   to load.  */\n+/* Prepare the operands for a comparison.  Return whether the branch/setcc\n+   should reverse the operands.  */\n \n-int\n-mcore_modify_comparison (enum rtx_code code)\n+bool\n+mcore_gen_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n-  rtx op1 = arch_compare_op1;\n-  \n+  rtx cc_reg = gen_rtx_REG (CCmode, CC_REG);\n+  bool invert;\n+\n   if (GET_CODE (op1) == CONST_INT)\n     {\n       HOST_WIDE_INT val = INTVAL (op1);\n       \n       switch (code)\n \t{\n+\tcase GTU:\n+\t  /* Unsigned > 0 is the same as != 0; everything else is converted\n+\t     below to LEU (reversed cmphs).  */\n+\t  if (val == 0)\n+\t    code = NE;\n+\t  break;\n+\n+        /* Check whether (LE A imm) can become (LT A imm + 1),\n+\t   or (GT A imm) can become (GE A imm + 1).  */\n+\tcase GT:\n \tcase LE:\n \t  if (CONST_OK_FOR_J (val + 1))\n \t    {\n-\t      arch_compare_op1 = GEN_INT (val + 1);\n-\t      return 1;\n+\t      op1 = GEN_INT (val + 1);\n+\t      code = code == LE ? LT : GE;\n \t    }\n \t  break;\n \t  \n \tdefault:\n \t  break;\n \t}\n     }\n-  \n-  return 0;\n-}\n-\n-/* Prepare the operands for a comparison.  */\n-\n-rtx\n-mcore_gen_compare_reg (enum rtx_code code)\n-{\n-  rtx op0 = arch_compare_op0;\n-  rtx op1 = arch_compare_op1;\n-  rtx cc_reg = gen_rtx_REG (CCmode, CC_REG);\n-\n+ \n   if (CONSTANT_P (op1) && GET_CODE (op1) != CONST_INT)\n     op1 = force_reg (SImode, op1);\n \n   /* cmpnei: 0-31 (K immediate)\n      cmplti: 1-32 (J immediate, 0 using btsti x,31).  */\n+  invert = false;\n   switch (code)\n     {\n     case EQ:\t/* Use inverted condition, cmpne.  */\n       code = NE;\n+      invert = true;\n       /* Drop through.  */\n       \n     case NE:\t/* Use normal condition, cmpne.  */\n@@ -577,6 +572,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n \n     case LE:\t/* Use inverted condition, reversed cmplt.  */\n       code = GT;\n+      invert = true;\n       /* Drop through.  */\n       \n     case GT:\t/* Use normal condition, reversed cmplt.  */\n@@ -586,6 +582,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n \n     case GE:\t/* Use inverted condition, cmplt.  */\n       code = LT;\n+      invert = true;\n       /* Drop through.  */\n       \n     case LT:\t/* Use normal condition, cmplt.  */\n@@ -597,13 +594,10 @@ mcore_gen_compare_reg (enum rtx_code code)\n       break;\n \n     case GTU:\t/* Use inverted condition, cmple.  */\n-      /* Unsigned > 0 is the same as != 0, but we need to invert the\n-\t condition, so we want to set code = EQ.  This cannot be done\n-\t however, as the mcore does not support such a test.  Instead\n-\t we cope with this case in the \"bgtu\" pattern itself so we\n-\t should never reach this point.  */\n+      /* We coped with unsigned > 0 above.  */\n       gcc_assert (GET_CODE (op1) != CONST_INT || INTVAL (op1) != 0);\n       code = LEU;\n+      invert = true;\n       /* Drop through.  */\n       \n     case LEU:\t/* Use normal condition, reversed cmphs.  */\n@@ -613,6 +607,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n \n     case LTU:\t/* Use inverted condition, cmphs.  */\n       code = GEU;\n+      invert = true;\n       /* Drop through.  */\n       \n     case GEU:\t/* Use normal condition, cmphs.  */\n@@ -624,9 +619,10 @@ mcore_gen_compare_reg (enum rtx_code code)\n       break;\n     }\n \n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg, gen_rtx_fmt_ee (code, CCmode, op0, op1)));\n-  \n-  return cc_reg;\n+  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t  cc_reg,\n+\t\t\t  gen_rtx_fmt_ee (code, CCmode, op0, op1)));\n+  return invert;\n }\n \n int"}, {"sha": "65b91588fc2f80d27d42219b1b76d5a98250eecb", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 36, "deletions": 304, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -303,22 +303,6 @@\n   \"\"\n   \"cmphs\t%1,%0\")\n \n-;; We save the compare operands in the cmpxx patterns and use them when\n-;; we generate the branch.\n-\n-;; We accept constants here, in case we can modify them to ones which\n-;; are more efficient to load.  E.g. change 'x <= 62' to 'x < 63'.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 17) (compare:CC (match_operand:SI 0 \"mcore_compare_operand\" \"\")\n-\t\t\t\t(match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{ arch_compare_op0 = operands[0];\n-  arch_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;; -------------------------------------------------------------------------\n ;; Logical operations\n ;; -------------------------------------------------------------------------\n@@ -1479,6 +1463,10 @@\n ;; Define the real conditional branch instructions.\n ;; ------------------------------------------------------------------------\n \n+;; At top-level, condition test are eq/ne, because we\n+;; are comparing against the condition register (which\n+;; has the result of the true relational test\n+\n (define_insn \"branch_true\"\n   [(set (pc) (if_then_else (ne (reg:CC 17) (const_int 0))\n \t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n@@ -1513,189 +1501,28 @@\n \n ;; Conditional branch insns\n \n-;; At top-level, condition test are eq/ne, because we\n-;; are comparing against the condition register (which\n-;; has the result of the true relational test\n-\n-; There is no beq compare, so we reverse the branch arms.\n-\n-(define_expand \"beq\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (EQ);\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (NE);\n-}\")\n-\n-; check whether (GT A imm) can become (LE A imm) with the branch reversed.  \n-; if so, emit a (LT A imm + 1) in place of the (LE A imm).  BRC\n-\n-(define_expand \"bgt\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (mcore_modify_comparison (LE))\n-    {\n-      emit_jump_insn (gen_reverse_blt (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = mcore_gen_compare_reg (GT);\n-}\")\n-\n-; There is no ble compare, so we reverse the branch arms.\n-; reversed the condition and branch arms for ble -- the check_dbra_loop()\n-; transformation assumes that ble uses a branch-true with the label as\n-; as the target. BRC\n-\n-; check whether (LE A imm) can become (LT A imm + 1).\n-\n-(define_expand \"ble\"\n-  [(set (pc) (if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-                           (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (mcore_modify_comparison (LE))\n-    {\n-      emit_jump_insn (gen_blt (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = mcore_gen_compare_reg (LE);\n-}\")\n-\n-; make generating a reversed blt simple\n-(define_expand \"reverse_blt\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-                           (pc)\n-                           (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LT);\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LT);\n-}\")\n-\n-; There is no bge compare, so we reverse the branch arms.\n-\n-(define_expand \"bge\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (GE);\n-}\")\n-\n-; There is no gtu compare, so we reverse the branch arms\n-\n-;(define_expand \"bgtu\"\n-;  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-;\t\t\t   (pc)\n-;\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-;  \"\"\n-;  \"\n-;{\n-;  if (GET_CODE (arch_compare_op1) == CONST_INT\n-;      && INTVAL (arch_compare_op1) == 0)\n-;    operands[1] = mcore_gen_compare_reg (NE);\n-;  else \n-;    { if (mcore_modify_comparison (GTU))\n-;\t{\n-;\t  emit_jump_insn (gen_bgeu (operands[0]));\n-;\t  DONE;\n-;\t}\n-;      operands[1] = mcore_gen_compare_reg (LEU);\n-;    }\n-;}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (arch_compare_op1) == CONST_INT\n-      && INTVAL (arch_compare_op1) == 0)\n-    {\n-      /* The inverse of '> 0' for an unsigned test is\n-\t '== 0' but we do not have such an instruction available.\n-\t Instead we must reverse the branch (back to the normal\n-\t ordering) and test '!= 0'.  */\n-\t \n-      operands[1] = mcore_gen_compare_reg (NE);\n-      \n-      emit_jump_insn (gen_rtx_SET (VOIDmode,\n-\tpc_rtx,\n-\tgen_rtx_IF_THEN_ELSE (VOIDmode,\n-\tgen_rtx_NE (VOIDmode,\n-\toperands[1],\n-\tconst0_rtx),\n-\tgen_rtx_LABEL_REF (VOIDmode,operands[0]),\n-\tpc_rtx)));\n-      DONE;\t      \n-    }\n-  operands[1] = mcore_gen_compare_reg (GTU);\n-}\")\n-\n-\n-(define_expand \"bleu\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:SI 1 \"mcore_compare_operand\")\n+\t\t\t(match_operand:SI 2 \"nonmemory_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n   \"\"\n   \"\n {\n-  operands[1] = mcore_gen_compare_reg (LEU);\n-}\")\n+  bool invert;\n+  invert = mcore_gen_compare (GET_CODE (operands[0]),\n+\t\t\t      operands[1], operands[2]);\n \n-; There is no bltu compare, so we reverse the branch arms\n-(define_expand \"bltu\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LTU);\n+  if (invert)\n+    emit_jump_insn (gen_branch_false (operands[3]));\n+  else\n+    emit_jump_insn (gen_branch_true (operands[3]));\n+  DONE;\n }\")\n \n-(define_expand \"bgeu\"\n-  [(set (pc) (if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\n-{\n \n-  operands[1] = mcore_gen_compare_reg (GEU);\n-}\")\n \n ;; ------------------------------------------------------------------------\n ;; Jump and linkage insns\n@@ -1853,118 +1680,23 @@\n    (set (match_dup 0) (eq:SI (reg:CC 17) (const_int 0)))])\n      \n \n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (NE);\n-}\")\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (NE);\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LT);\n-}\")\n-\n-; make generating a LT with the comparison reversed easy.  BRC\n-(define_expand \"reverse_slt\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-        (eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LT);\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LT);\n-}\")\n-\n-; check whether (GT A imm) can become (LE A imm) with the comparison\n-; reversed.  if so, emit a (LT A imm + 1) in place of the (LE A imm).  BRC\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  if (mcore_modify_comparison (LE))\n-    {\n-      emit_insn (gen_reverse_slt (operands[0]));\n-      DONE;\n-    }\n-  \n-  operands[1] = mcore_gen_compare_reg (GT);\n-}\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  if (mcore_modify_comparison (LE))\n-    {\n-      emit_insn (gen_slt (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = mcore_gen_compare_reg (GT);\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (GEU);\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (GEU);\n-}\")\n-\n-(define_expand \"sgtu\"\n+(define_expand \"cstoresi4\"\n   [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:SI 2 \"mcore_compare_operand\" \"\")\n+\t  (match_operand:SI 3 \"nonmemory_operand\" \"\")]))]\n   \"\"\n   \"\n {\n-  operands[1] = mcore_gen_compare_reg (LEU);\n-}\")\n+  bool invert;\n+  invert = mcore_gen_compare (GET_CODE (operands[1]),\n+\t\t\t      operands[2], operands[3]);\n \n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = mcore_gen_compare_reg (LEU);\n+  if (invert)\n+    emit_insn (gen_mvcv (operands[0]));\n+  else\n+    emit_insn (gen_mvc (operands[0]));\n+  DONE;\n }\")\n \n (define_insn \"incscc\"\n@@ -3308,7 +3040,7 @@\n       rtx loop_label = gen_label_rtx ();\n       rtx step = gen_reg_rtx (Pmode);\n       rtx tmp = gen_reg_rtx (Pmode);\n-      rtx memref;\n+      rtx test, memref;\n \n #if 1\n       emit_insn (gen_movsi (tmp, operands[1]));\n@@ -3317,8 +3049,8 @@\n       if (GET_CODE (operands[1]) != CONST_INT)\n \t{\n \t  out_label = gen_label_rtx ();\n-\t  emit_insn (gen_cmpsi (step, tmp));\t\t/* quick out */\n-\t  emit_jump_insn (gen_bgeu (out_label));\n+\t  test = gen_rtx_GEU (VOIDmode, step, tmp);\t\t/* quick out */\n+\t  emit_jump_insn (gen_cbranchsi4 (test, step, tmp, out_label));\n \t}\n \n       /* Run a loop that steps it incrementally.  */\n@@ -3332,8 +3064,8 @@\n       emit_insn(gen_subsi3(tmp, tmp, step));\n \n       /* Loop condition -- going back up.  */\n-      emit_insn (gen_cmpsi (step, tmp));\n-      emit_jump_insn (gen_bltu (loop_label));\n+      test = gen_rtx_LTU (VOIDmode, step, tmp);\n+      emit_jump_insn (gen_cbranchsi4 (test, step, tmp, loop_label));\n \n       if (out_label)\n \temit_label (out_label);"}, {"sha": "f2c67b84908b9b68d65ab7a21078082c76823027", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -222,11 +222,11 @@ extern void mips_split_doubleword_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern void mips_restore_gp (rtx);\n #ifdef RTX_CODE\n-extern bool mips_expand_scc (enum rtx_code, rtx);\n-extern void mips_expand_conditional_branch (rtx *, enum rtx_code);\n+extern void mips_expand_scc (rtx *);\n+extern void mips_expand_conditional_branch (rtx *);\n extern void mips_expand_vcondv2sf (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n extern void mips_expand_conditional_move (rtx *);\n-extern void mips_expand_conditional_trap (enum rtx_code);\n+extern void mips_expand_conditional_trap (rtx);\n #endif\n extern bool mips_use_pic_fn_addr_reg_p (const_rtx);\n extern rtx mips_expand_call (enum mips_call_type, rtx, rtx, rtx, rtx, bool);"}, {"sha": "98932d85b11cd8cf19ce9df376c2b763d4287b94", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -58,7 +58,7 @@\n \t   MOVZ.PS.  MOVT.PS and MOVF.PS depend on two CC values and move \n \t   each item independently.  */\n \n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n+  if (GET_MODE_CLASS (GET_MODE (XEXP (operands[1], 0))) != MODE_INT)\n     FAIL;\n \n   mips_expand_conditional_move (operands);"}, {"sha": "9d712d2f096ef3880fea1d0a5090bc04f7e3dc34", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -448,9 +448,6 @@ static int set_noat;\n    normal branch.  */\n static bool mips_branch_likely;\n \n-/* The operands passed to the last cmpMM expander.  */\n-rtx cmp_operands[2];\n-\n /* The current instruction-set architecture.  */\n enum processor_type mips_arch;\n const struct mips_cpu_info *mips_arch_info;\n@@ -4221,8 +4218,8 @@ mips_reversed_fp_cond (enum rtx_code *code)\n }\n \n /* Convert a comparison into something that can be used in a branch or\n-   conditional move.  cmp_operands[0] and cmp_operands[1] are the values\n-   being compared and *CODE is the code used to compare them.\n+   conditional move.  On entry, *OP0 and *OP1 are the values being\n+   compared and *CODE is the code used to compare them.\n \n    Update *CODE, *OP0 and *OP1 so that they describe the final comparison.\n    If NEED_EQ_NE_P, then only EQ or NE comparisons against zero are possible,\n@@ -4235,42 +4232,38 @@ mips_reversed_fp_cond (enum rtx_code *code)\n static void\n mips_emit_compare (enum rtx_code *code, rtx *op0, rtx *op1, bool need_eq_ne_p)\n {\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) == MODE_INT)\n+  rtx cmp_op0 = *op0;\n+  rtx cmp_op1 = *op1;\n+\n+  if (GET_MODE_CLASS (GET_MODE (*op0)) == MODE_INT)\n     {\n-      if (!need_eq_ne_p && cmp_operands[1] == const0_rtx)\n-\t{\n-\t  *op0 = cmp_operands[0];\n-\t  *op1 = cmp_operands[1];\n-\t}\n+      if (!need_eq_ne_p && *op1 == const0_rtx)\n+\t;\n       else if (*code == EQ || *code == NE)\n \t{\n \t  if (need_eq_ne_p)\n \t    {\n-\t      *op0 = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n+\t      *op0 = mips_zero_if_equal (cmp_op0, cmp_op1);\n \t      *op1 = const0_rtx;\n \t    }\n \t  else\n-\t    {\n-\t      *op0 = cmp_operands[0];\n-\t      *op1 = force_reg (GET_MODE (*op0), cmp_operands[1]);\n-\t    }\n+\t    *op1 = force_reg (GET_MODE (cmp_op0), cmp_op1);\n \t}\n       else\n \t{\n \t  /* The comparison needs a separate scc instruction.  Store the\n \t     result of the scc in *OP0 and compare it against zero.  */\n \t  bool invert = false;\n-\t  *op0 = gen_reg_rtx (GET_MODE (cmp_operands[0]));\n-\t  mips_emit_int_order_test (*code, &invert, *op0,\n-\t\t\t\t    cmp_operands[0], cmp_operands[1]);\n+\t  *op0 = gen_reg_rtx (GET_MODE (cmp_op0));\n+\t  mips_emit_int_order_test (*code, &invert, *op0, cmp_op0, cmp_op1);\n \t  *code = (invert ? EQ : NE);\n \t  *op1 = const0_rtx;\n \t}\n     }\n-  else if (ALL_FIXED_POINT_MODE_P (GET_MODE (cmp_operands[0])))\n+  else if (ALL_FIXED_POINT_MODE_P (GET_MODE (cmp_op0)))\n     {\n       *op0 = gen_rtx_REG (CCDSPmode, CCDSP_CC_REGNUM);\n-      mips_emit_binary (*code, *op0, cmp_operands[0], cmp_operands[1]);\n+      mips_emit_binary (*code, *op0, cmp_op0, cmp_op1);\n       *code = NE;\n       *op1 = const0_rtx;\n     }\n@@ -4290,49 +4283,55 @@ mips_emit_compare (enum rtx_code *code, rtx *op0, rtx *op1, bool need_eq_ne_p)\n \t      ? gen_reg_rtx (CCmode)\n \t      : gen_rtx_REG (CCmode, FPSW_REGNUM));\n       *op1 = const0_rtx;\n-      mips_emit_binary (cmp_code, *op0, cmp_operands[0], cmp_operands[1]);\n+      mips_emit_binary (cmp_code, *op0, cmp_op0, cmp_op1);\n     }\n }\n \f\n-/* Try comparing cmp_operands[0] and cmp_operands[1] using rtl code CODE.\n-   Store the result in TARGET and return true if successful.\n+/* Try performing the comparison in OPERANDS[1], whose arms are OPERANDS[2]\n+   and OPERAND[3].  Store the result in OPERANDS[0].\n \n-   On 64-bit targets, TARGET may be narrower than cmp_operands[0].  */\n+   On 64-bit targets, the mode of the comparison and target will always be\n+   SImode, thus possibly narrower than that of the comparison's operands.  */\n \n-bool\n-mips_expand_scc (enum rtx_code code, rtx target)\n+void\n+mips_expand_scc (rtx operands[])\n {\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    return false;\n+  rtx target = operands[0];\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = operands[2];\n+  rtx op1 = operands[3];\n+\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT);\n \n   if (code == EQ || code == NE)\n     {\n       if (ISA_HAS_SEQ_SNE\n-\t  && reg_imm10_operand (cmp_operands[1], GET_MODE (cmp_operands[1])))\n-\tmips_emit_binary (code, target, cmp_operands[0], cmp_operands[1]);\n+\t  && reg_imm10_operand (op1, GET_MODE (op1)))\n+\tmips_emit_binary (code, target, op0, op1);\n       else\n \t{\n-\t  rtx zie = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n+\t  rtx zie = mips_zero_if_equal (op0, op1);\n \t  mips_emit_binary (code, target, zie, const0_rtx);\n \t}\n     }\n   else\n-    mips_emit_int_order_test (code, 0, target,\n-\t\t\t      cmp_operands[0], cmp_operands[1]);\n-  return true;\n+    mips_emit_int_order_test (code, 0, target, op0, op1);\n }\n \n-/* Compare cmp_operands[0] with cmp_operands[1] using comparison code\n-   CODE and jump to OPERANDS[0] if the condition holds.  */\n+/* Compare OPERANDS[1] with OPERANDS[2] using comparison code\n+   CODE and jump to OPERANDS[3] if the condition holds.  */\n \n void\n-mips_expand_conditional_branch (rtx *operands, enum rtx_code code)\n+mips_expand_conditional_branch (rtx *operands)\n {\n-  rtx op0, op1, condition;\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx op0 = operands[1];\n+  rtx op1 = operands[2];\n+  rtx condition;\n \n   mips_emit_compare (&code, &op0, &op1, TARGET_MIPS16);\n   condition = gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n-  emit_jump_insn (gen_condjump (condition, operands[0]));\n+  emit_jump_insn (gen_condjump (condition, operands[3]));\n }\n \n /* Implement:\n@@ -4359,53 +4358,54 @@ mips_expand_vcondv2sf (rtx dest, rtx true_src, rtx false_src,\n \t\t\t\t\t cmp_result));\n }\n \n-/* Compare cmp_operands[0] with cmp_operands[1] using the code of\n-   OPERANDS[1].  Move OPERANDS[2] into OPERANDS[0] if the condition\n-   holds, otherwise move OPERANDS[3] into OPERANDS[0].  */\n+/* Perform the comparison in OPERANDS[1].  Move OPERANDS[2] into OPERANDS[0]\n+   if the condition holds, otherwise move OPERANDS[3] into OPERANDS[0].  */\n \n void\n mips_expand_conditional_move (rtx *operands)\n {\n-  enum rtx_code code;\n-  rtx cond, op0, op1;\n+  rtx cond;\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = XEXP (operands[1], 0);\n+  rtx op1 = XEXP (operands[1], 1);\n \n-  code = GET_CODE (operands[1]);\n   mips_emit_compare (&code, &op0, &op1, true);\n-  cond = gen_rtx_fmt_ee (code, GET_MODE (op0), op0, op1),\n+  cond = gen_rtx_fmt_ee (code, GET_MODE (op0), op0, op1);\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]), cond,\n \t\t\t\t\t\toperands[2], operands[3])));\n }\n \n-/* Compare cmp_operands[0] with cmp_operands[1] using rtl code CODE,\n-   then trap if the condition holds.  */\n+/* Perform the comparison in COMPARISON, then trap if the condition holds.  */\n \n void\n-mips_expand_conditional_trap (enum rtx_code code)\n+mips_expand_conditional_trap (rtx comparison)\n {\n   rtx op0, op1;\n   enum machine_mode mode;\n+  enum rtx_code code;\n \n   /* MIPS conditional trap instructions don't have GT or LE flavors,\n      so we must swap the operands and convert to LT and GE respectively.  */\n+  code = GET_CODE (comparison);\n   switch (code)\n     {\n     case GT:\n     case LE:\n     case GTU:\n     case LEU:\n       code = swap_condition (code);\n-      op0 = cmp_operands[1];\n-      op1 = cmp_operands[0];\n+      op0 = XEXP (comparison, 1);\n+      op1 = XEXP (comparison, 0);\n       break;\n \n     default:\n-      op0 = cmp_operands[0];\n-      op1 = cmp_operands[1];\n+      op0 = XEXP (comparison, 0);\n+      op1 = XEXP (comparison, 1);\n       break;\n     }\n \n-  mode = GET_MODE (cmp_operands[0]);\n+  mode = GET_MODE (XEXP (comparison, 0));\n   op0 = force_reg (mode, op0);\n   if (!arith_operand (op1, mode))\n     op1 = force_reg (mode, op1);\n@@ -6396,7 +6396,7 @@ static void\n mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n \t\t      HOST_WIDE_INT bytes_per_iter)\n {\n-  rtx label, src_reg, dest_reg, final_src;\n+  rtx label, src_reg, dest_reg, final_src, test;\n   HOST_WIDE_INT leftover;\n \n   leftover = length % bytes_per_iter;\n@@ -6423,11 +6423,11 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n   mips_emit_move (dest_reg, plus_constant (dest_reg, bytes_per_iter));\n \n   /* Emit the loop condition.  */\n+  test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n   if (Pmode == DImode)\n-    emit_insn (gen_cmpdi (src_reg, final_src));\n+    emit_jump_insn (gen_cbranchdi4 (test, src_reg, final_src, label));\n   else\n-    emit_insn (gen_cmpsi (src_reg, final_src));\n-  emit_jump_insn (gen_bne (label));\n+    emit_jump_insn (gen_cbranchsi4 (test, src_reg, final_src, label));\n \n   /* Mop up any left-over bytes.  */\n   if (leftover)"}, {"sha": "301a26ec1ad914870658074c52c379a7e2e81b90", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -3432,7 +3432,6 @@ extern int mips_dbx_regno[];\n extern int mips_dwarf_regno[];\n extern bool mips_split_p[];\n extern bool mips_split_hi_p[];\n-extern GTY(()) rtx cmp_operands[2];\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */\n extern int mips_isa;\t\t\t/* architectural level */"}, {"sha": "713bd834730212503fbd6b97a22b94bb75414734", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 45, "deletions": 114, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -791,11 +791,6 @@\n    (DF \"ISA_HAS_FP4 && TARGET_FLOAT64\")\n    (V2SF \"TARGET_SB1\")])\n \n-;; This code iterator allows all branch instructions to be generated from\n-;; a single define_expand template.\n-(define_code_iterator any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n-\t\t\t        eq ne gt ge lt le gtu geu ltu leu])\n-\n ;; This code iterator allows signed and unsigned widening multiplications\n ;; to use the same template.\n (define_code_iterator any_extend [sign_extend zero_extend])\n@@ -994,19 +989,15 @@\n }\n   [(set_attr \"type\" \"trap\")])\n \n-(define_expand \"conditional_trap\"\n+(define_expand \"ctrap<mode>4\"\n   [(trap_if (match_operator 0 \"comparison_operator\"\n-\t\t\t    [(match_dup 2) (match_dup 3)])\n-\t    (match_operand 1 \"const_int_operand\"))]\n+\t\t\t    [(match_operand:GPR 1 \"reg_or_0_operand\")\n+\t\t\t     (match_operand:GPR 2 \"arith_operand\")])\n+\t    (match_operand 3 \"const_0_operand\"))]\n   \"ISA_HAS_COND_TRAP\"\n {\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) == MODE_INT\n-      && operands[1] == const0_rtx)\n-    {\n-      mips_expand_conditional_trap (GET_CODE (operands[0]));\n-      DONE;\n-    }\n-  FAIL;\n+  mips_expand_conditional_trap (operands[0]);\n+  DONE;\n })\n \n (define_insn \"*conditional_trap<mode>\"\n@@ -3243,6 +3234,7 @@\n   rtx reg3 = gen_reg_rtx (SImode);\n   rtx label1 = gen_label_rtx ();\n   rtx label2 = gen_label_rtx ();\n+  rtx test;\n   REAL_VALUE_TYPE offset;\n \n   real_2expN (&offset, 31, DFmode);\n@@ -3252,8 +3244,8 @@\n       mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n       do_pending_stack_adjust ();\n \n-      emit_insn (gen_cmpdf (operands[1], reg1));\n-      emit_jump_insn (gen_bge (label1));\n+      test = gen_rtx_GE (VOIDmode, operands[1], reg1);\n+      emit_jump_insn (gen_cbranchdf4 (test, operands[1], reg1, label1));\n \n       emit_insn (gen_fix_truncdfsi2 (operands[0], operands[1]));\n       emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n@@ -3288,15 +3280,16 @@\n   rtx reg3 = gen_reg_rtx (DImode);\n   rtx label1 = gen_label_rtx ();\n   rtx label2 = gen_label_rtx ();\n+  rtx test;\n   REAL_VALUE_TYPE offset;\n \n   real_2expN (&offset, 63, DFmode);\n \n   mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n   do_pending_stack_adjust ();\n \n-  emit_insn (gen_cmpdf (operands[1], reg1));\n-  emit_jump_insn (gen_bge (label1));\n+  test = gen_rtx_GE (VOIDmode, operands[1], reg1);\n+  emit_jump_insn (gen_cbranchdf4 (test, operands[1], reg1, label1));\n \n   emit_insn (gen_fix_truncdfdi2 (operands[0], operands[1]));\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n@@ -3330,15 +3323,16 @@\n   rtx reg3 = gen_reg_rtx (SImode);\n   rtx label1 = gen_label_rtx ();\n   rtx label2 = gen_label_rtx ();\n+  rtx test;\n   REAL_VALUE_TYPE offset;\n \n   real_2expN (&offset, 31, SFmode);\n \n   mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n   do_pending_stack_adjust ();\n \n-  emit_insn (gen_cmpsf (operands[1], reg1));\n-  emit_jump_insn (gen_bge (label1));\n+  test = gen_rtx_GE (VOIDmode, operands[1], reg1);\n+  emit_jump_insn (gen_cbranchsf4 (test, operands[1], reg1, label1));\n \n   emit_insn (gen_fix_truncsfsi2 (operands[0], operands[1]));\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n@@ -3372,15 +3366,16 @@\n   rtx reg3 = gen_reg_rtx (DImode);\n   rtx label1 = gen_label_rtx ();\n   rtx label2 = gen_label_rtx ();\n+  rtx test;\n   REAL_VALUE_TYPE offset;\n \n   real_2expN (&offset, 63, SFmode);\n \n   mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n   do_pending_stack_adjust ();\n \n-  emit_insn (gen_cmpsf (operands[1], reg1));\n-  emit_jump_insn (gen_bge (label1));\n+  test = gen_rtx_GE (VOIDmode, operands[1], reg1);\n+  emit_jump_insn (gen_cbranchsf4 (test, operands[1], reg1, label1));\n \n   emit_insn (gen_fix_truncsfdi2 (operands[0], operands[1]));\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n@@ -5011,50 +5006,6 @@\n ;;\n ;;  ....................\n ;;\n-;;\tCOMPARISONS\n-;;\n-;;  ....................\n-\n-;; Flow here is rather complex:\n-;;\n-;;  1)\tThe cmp{si,di,sf,df} routine is called.  It deposits the arguments\n-;;\tinto cmp_operands[] but generates no RTL.\n-;;\n-;;  2)\tThe appropriate branch define_expand is called, which then\n-;;\tcreates the appropriate RTL for the comparison and branch.\n-;;\tDifferent CC modes are used, based on what type of branch is\n-;;\tdone, so that we can constrain things appropriately.  There\n-;;\tare assumptions in the rest of GCC that break if we fold the\n-;;\toperands into the branches for integer operations, and use cc0\n-;;\tfor floating point, so we use the fp status register instead.\n-;;\tIf needed, an appropriate temporary is created to hold the\n-;;\tof the integer compare.\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:GPR 0 \"register_operand\")\n-\t\t    (match_operand:GPR 1 \"nonmemory_operand\")))]\n-  \"\"\n-{\n-  cmp_operands[0] = operands[0];\n-  cmp_operands[1] = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SCALARF 0 \"register_operand\")\n-\t\t    (match_operand:SCALARF 1 \"register_operand\")))]\n-  \"\"\n-{\n-  cmp_operands[0] = operands[0];\n-  cmp_operands[1] = operands[1];\n-  DONE;\n-})\n-\f\n-;;\n-;;  ....................\n-;;\n ;;\tCONDITIONAL BRANCHES\n ;;\n ;;  ....................\n@@ -5189,15 +5140,29 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n-(define_expand \"b<code>\"\n+(define_expand \"cbranch<mode>4\"\n   [(set (pc)\n-\t(if_then_else (any_cond:CC (cc0)\n-\t\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:GPR 1 \"register_operand\")\n+\t\t        (match_operand:GPR 2 \"nonmemory_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n \t\t      (pc)))]\n   \"\"\n {\n-  mips_expand_conditional_branch (operands, <CODE>);\n+  mips_expand_conditional_branch (operands);\n+  DONE;\n+})\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:SCALARF 1 \"register_operand\")\n+\t\t        (match_operand:SCALARF 2 \"register_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  mips_expand_conditional_branch (operands);\n   DONE;\n })\n \n@@ -5261,12 +5226,16 @@\n \n ;; Destination is always set in SI mode.\n \n-(define_expand \"seq\"\n+(define_expand \"cstore<mode>4\"\n   [(set (match_operand:SI 0 \"register_operand\")\n-\t(eq:SI (match_dup 1)\n-\t       (match_dup 2)))]\n+\t(match_operator:SI 1 \"mips_cstore_operator\"\n+\t [(match_operand:GPR 2 \"register_operand\")\n+\t  (match_operand:GPR 3 \"nonmemory_operand\")]))]\n   \"\"\n-  { if (mips_expand_scc (EQ, operands[0])) DONE; else FAIL; })\n+{\n+  mips_expand_scc (operands);\n+  DONE;\n+})\n \n (define_insn \"*seq_zero_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n@@ -5299,16 +5268,6 @@\n   [(set_attr \"type\" \"slt\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-;; \"sne\" uses sltu instructions in which the first operand is $0.\n-;; This isn't possible in mips16 code.\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(ne:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_MIPS16\"\n-  { if (mips_expand_scc (NE, operands[0])) DONE; else FAIL; })\n-\n (define_insn \"*sne_zero_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n \t(ne:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n@@ -5331,13 +5290,6 @@\n   [(set_attr \"type\" \"slt\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_expand \"sgt<u>\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(any_gt:SI (match_dup 1)\n-\t\t   (match_dup 2)))]\n-  \"\"\n-  { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n-\n (define_insn \"*sgt<u>_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n \t(any_gt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n@@ -5356,13 +5308,6 @@\n   [(set_attr \"type\" \"slt\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_expand \"sge<u>\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(any_ge:SI (match_dup 1)\n-\t\t   (match_dup 2)))]\n-  \"\"\n-  { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n-\n (define_insn \"*sge<u>_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n \t(any_ge:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n@@ -5372,13 +5317,6 @@\n   [(set_attr \"type\" \"slt\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_expand \"slt<u>\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(any_lt:SI (match_dup 1)\n-\t\t   (match_dup 2)))]\n-  \"\"\n-  { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n-\n (define_insn \"*slt<u>_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n \t(any_lt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n@@ -5402,13 +5340,6 @@\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))])])\n \n-(define_expand \"sle<u>\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(any_le:SI (match_dup 1)\n-\t\t   (match_dup 2)))]\n-  \"\"\n-  { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n-\n (define_insn \"*sle<u>_<GPR:mode><GPR2:mode>\"\n   [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n \t(any_le:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")"}, {"sha": "d32eaf13f8e984f7778d0155cacb000239a353a9", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -285,6 +285,12 @@\n (define_predicate \"order_operator\"\n   (match_code \"lt,ltu,le,leu,ge,geu,gt,gtu\"))\n \n+;; For NE, cstore uses sltu instructions in which the first operand is $0.\n+;; This isn't possible in mips16 code.\n+\n+(define_predicate \"mips_cstore_operator\"\n+  (ior (match_code \"eq,gt,gtu,ge,geu,lt,ltu,le,leu\")\n+       (and (match_code \"ne\") (match_test \"!TARGET_MIPS16\"))))\n \n (define_predicate \"small_data_pattern\"\n   (and (match_code \"set,parallel,unspec,unspec_volatile,prefetch\")"}, {"sha": "d294d8ff0edbd737b7a25bf65cd2780832005559", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -96,7 +96,6 @@ extern void mmix_setup_frame_addresses (void);\n /* Needs to be ifdef:d for sake of enum rtx_code.  */\n extern enum machine_mode mmix_select_cc_mode (enum rtx_code, rtx, rtx);\n extern void mmix_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n-extern int mmix_valid_comparison (enum rtx_code, enum machine_mode, rtx);\n extern rtx mmix_gen_compare_reg (enum rtx_code, rtx, rtx);\n #endif\n "}, {"sha": "6ced05c04dcca2cbc4ce256f2cbeef7d93c26fad", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 59, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2359,70 +2359,14 @@ mmix_shiftable_wyde_value (unsigned HOST_WIDEST_INT value)\n   return 1;\n }\n \n-/* Returns zero if code and mode is not a valid condition from a\n-   compare-type insn.  Nonzero if it is.  The parameter op, if non-NULL,\n-   is the comparison of mode is CC-somethingmode.  */\n-\n-int\n-mmix_valid_comparison (RTX_CODE code, enum machine_mode mode, rtx op)\n-{\n-  if (mode == VOIDmode && op != NULL_RTX)\n-    mode = GET_MODE (op);\n-\n-  /* We don't care to look at these, they should always be valid.  */\n-  if (mode == CCmode || mode == CC_UNSmode || mode == DImode)\n-    return 1;\n-\n-  if ((mode == CC_FPmode || mode == DFmode)\n-      && (code == GT || code == LT))\n-    return 1;\n-\n-  if ((mode == CC_FPEQmode || mode == DFmode)\n-      && (code == EQ || code == NE))\n-    return 1;\n-\n-  if ((mode == CC_FUNmode || mode == DFmode)\n-      && (code == ORDERED || code == UNORDERED))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* X and Y are two things to compare using CODE.  Emit a compare insn if\n-   possible and return the rtx for the cc-reg in the proper mode, or\n-   NULL_RTX if this is not a valid comparison.  */\n+/* X and Y are two things to compare using CODE.  Return the rtx for\n+   the cc-reg in the proper mode.  */\n \n rtx\n mmix_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n {\n   enum machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg;\n-\n-  /* FIXME: Do we get constants here?  Of double mode?  */\n-  enum machine_mode mode\n-    = GET_MODE (x) == VOIDmode\n-    ? GET_MODE (y)\n-    : GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT ? DFmode : DImode;\n-\n-  if (! mmix_valid_comparison (code, mode, x))\n-    return NULL_RTX;\n-\n-  cc_reg = gen_reg_rtx (ccmode);\n-\n-  /* FIXME:  Can we avoid emitting a compare insn here?  */\n-  if (! REG_P (x) && ! REG_P (y))\n-    x = force_reg (mode, x);\n-\n-  /* If it's not quite right yet, put y in a register.  */\n-  if (! REG_P (y)\n-      && (GET_CODE (y) != CONST_INT\n-\t  || ! CONST_OK_FOR_LETTER_P (INTVAL (y), 'I')))\n-    y = force_reg (mode, y);\n-\n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n-\t\t\t  gen_rtx_COMPARE (ccmode, x, y)));\n-\n-  return cc_reg;\n+  return gen_reg_rtx (ccmode);\n }\n \n /* Local (static) helper functions.  */"}, {"sha": "5a0582df26bc34df4c1a847475bcef4b5acde219", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -81,11 +81,6 @@ along with GCC; see the file COPYING3.  If not see\n #define MMIX_FUNCTION_ARG_SIZE(MODE, TYPE) \\\n  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE) : int_size_in_bytes (TYPE))\n \n-/* Declarations for helper variables that are not tied to a particular\n-   target macro.  */\n-extern GTY(()) rtx mmix_compare_op0;\n-extern GTY(()) rtx mmix_compare_op1;\n-\n /* Per-function machine data.  This is normally an opaque type just\n    defined and used in the tm.c file, but we need to see the definition in\n    mmix.md too.  */"}, {"sha": "44263e47f64e346e518727fd0d5069b31e0d20ec", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 63, "deletions": 187, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -440,30 +440,6 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\"\n   \"NOR %0,%1,0\")\n \f\n-;; Since we don't have cc0, we do what is recommended in the manual;\n-;; store away the operands for use in the branch, scc or movcc insn.\n-(define_expand \"cmpdi\"\n-  [(match_operand:DI 0 \"register_operand\" \"\")\n-   (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  mmix_compare_op0 = operands[0];\n-  mmix_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(match_operand:DF 0 \"register_operand\" \"\")\n-   (match_operand:DF 1 \"register_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  mmix_compare_op0 = operands[0];\n-  mmix_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;; When the user-patterns expand, the resulting insns will match the\n ;; patterns below.\n \n@@ -474,7 +450,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n ;; unsigned, so that has to be done another way.\n ;;  FIXME: Perhaps a peep2 changing CCcode to a new code, that\n ;; gets folded here.\n-(define_insn \"*cmpcc_folded\"\n+(define_insn \"*cmpdi_folded\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n \t(compare:CC\n \t (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -485,7 +461,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n    && REGNO (operands[1]) == REGNO (operands[0])\"\n   \"%% folded: cmp %0,%1,0\")\n \n-(define_insn \"*cmpcc\"\n+(define_insn \"*cmps\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n \t(compare:CC\n \t (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -724,7 +700,8 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n ;; 0 to use in movdfcc.\n \n (define_expand \"movdfcc\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+  [(set (match_dup 4) (match_dup 5))\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF\n \t (match_operand 1 \"comparison_operator\" \"\")\n \t (match_operand:DF 2 \"mmix_reg_or_0_operand\" \"\")\n@@ -733,15 +710,20 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx cc_reg = mmix_gen_compare_reg (code, mmix_compare_op0,\n-\t\t\t\t     mmix_compare_op1);\n-  if (cc_reg == NULL_RTX)\n+  if (code == LE || code == GE)\n     FAIL;\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n+\n+  operands[4] = mmix_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t      XEXP (operands[1], 1));\n+  operands[5] = gen_rtx_COMPARE (GET_MODE (operands[4]),\n+\t\t\t\t XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1));\n+  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, operands[4], const0_rtx);\n }\")\n \n (define_expand \"movdicc\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+  [(set (match_dup 4) (match_dup 5))\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI\n \t (match_operand 1 \"comparison_operator\" \"\")\n \t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"\")\n@@ -750,11 +732,15 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx cc_reg = mmix_gen_compare_reg (code, mmix_compare_op0,\n-\t\t\t\t     mmix_compare_op1);\n-  if (cc_reg == NULL_RTX)\n+  if (code == LE || code == GE)\n     FAIL;\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n+\n+  operands[4] = mmix_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t      XEXP (operands[1], 1));\n+  operands[5] = gen_rtx_COMPARE (GET_MODE (operands[4]),\n+\t\t\t\t XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1));\n+  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, operands[4], const0_rtx);\n }\")\n \n ;; FIXME: Is this the right way to do \"folding\" of CCmode -> DImode?\n@@ -854,175 +840,65 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n    CS%d2 %0,%3,%1\n    ZS%d2 %0,%3,%1\")\n \n-;; FIXME: scc patterns will probably help, I just skip them\n+;; FIXME: scc insns will probably help, I just skip them\n ;; right now.  Revisit.\n \f\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (EQ, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchdi4\"\n+  [(set (match_dup 4)\n+        (match_op_dup 5\n+         [(match_operand:DI 1 \"register_operand\" \"\")\n+          (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"\")]))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\"\n+               [(match_dup 4)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n   \"\n {\n-  operands[1]\n-    = mmix_gen_compare_reg (NE, mmix_compare_op0, mmix_compare_op1);\n+  operands[4] = mmix_gen_compare_reg (GET_CODE (operands[0]),\n+                                      operands[1], operands[2]);\n+  operands[5] = gen_rtx_fmt_ee (COMPARE,\n+                                GET_MODE (operands[4]),\n+                                operands[1], operands[2]);\n }\")\n \n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchdf4\"\n+  [(set (match_dup 4)\n+        (match_op_dup 5\n+         [(match_operand:DF 1 \"register_operand\" \"\")\n+          (match_operand:DF 2 \"register_operand\" \"\")]))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"float_comparison_operator\"\n+               [(match_dup 4)\n+                (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n   \"\n {\n-  operands[1]\n-    = mmix_gen_compare_reg (GT, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (LE, mmix_compare_op0, mmix_compare_op1);\n-\n   /* The head comment of optabs.c:can_compare_p says we're required to\n      implement this, so we have to clean up the mess here.  */\n-  if (operands[1] == NULL_RTX)\n+  if (GET_CODE (operands[0]) == LE || GET_CODE (operands[0]) == GE)\n     {\n-      /* FIXME: Watch out for sharing/unsharing of rtx:es.  */\n-      emit_jump_insn ((*bcc_gen_fctn[(int) LT]) (operands[0]));\n-      emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (operands[0]));\n+      enum rtx_code ltgt_code = GET_CODE (operands[0]) == LE ? LT : GT;\n+      emit_cmp_and_jump_insns (operands[1], operands[2], ltgt_code, NULL_RTX,\n+\t\t\t       DFmode, 0, operands[3]);\n+      emit_cmp_and_jump_insns (operands[1], operands[2], EQ, NULL_RTX,\n+\t\t\t       DFmode, 0, operands[3]);\n       DONE;\n     }\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (GE, mmix_compare_op0, mmix_compare_op1);\n \n-  /* The head comment of optabs.c:can_compare_p says we're required to\n-     implement this, so we have to clean up the mess here.  */\n-  if (operands[1] == NULL_RTX)\n-    {\n-      /* FIXME: Watch out for sharing/unsharing of rtx:es.  */\n-      emit_jump_insn ((*bcc_gen_fctn[(int) GT]) (operands[0]));\n-      emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (operands[0]));\n-      DONE;\n-    }\n+  operands[4] = mmix_gen_compare_reg (GET_CODE (operands[0]),\n+                                      operands[1], operands[2]);\n+  operands[5] = gen_rtx_fmt_ee (COMPARE,\n+                                GET_MODE (operands[4]),\n+                                operands[1], operands[2]);\n }\")\n \n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (LT, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (GTU, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (LEU, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (GEU, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (LTU, mmix_compare_op0, mmix_compare_op1);\n-}\")\n-\n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (unordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (UNORDERED, mmix_compare_op0, mmix_compare_op1);\n-\n-  if (operands[1] == NULL_RTX)\n-    FAIL;\n-}\")\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (ordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[1]\n-    = mmix_gen_compare_reg (ORDERED, mmix_compare_op0, mmix_compare_op1);\n-}\")\n \n ;; FIXME: we can emit an unordered-or-*not*-equal compare in one insn, but\n ;; there's no RTL code for it.  Maybe revisit in future."}, {"sha": "b5773b87aee7ff4c8386161a74e9a4886edc84f1", "filename": "gcc/config/mmix/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmmix%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -17,6 +17,11 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Return 1 if OP is a valid comparison operator for \"cbranch\" instructions.\n+;; LE and GE are further lowered by the cbranchdf4 pattern.\n+(define_predicate \"float_comparison_operator\"\n+  (match_code \"ne, eq, le, ge, lt, gt, ordered, unordered\"))\n+\n ;; True if this is a foldable comparison operator\n ;; - one where a the result of (compare:CC (reg) (const_int 0)) can be\n ;; replaced by (reg).  */"}, {"sha": "47fd5cbf93307894e895ef92dac0703c0a5d5cd5", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2030,7 +2030,7 @@ mn10300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRI\n     {\n     case CONST_INT:\n       /* Zeros are extremely cheap.  */\n-      if (INTVAL (x) == 0 && outer_code == SET)\n+      if (INTVAL (x) == 0 && (outer_code == SET || outer_code == COMPARE))\n \t*total = 0;\n       /* If it fits in 8 bits, then it's still relatively cheap.  */\n       else if (INT_8_BITS (INTVAL (x)))\n@@ -2059,6 +2059,12 @@ mn10300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRI\n       *total = 8;\n       return true;\n \n+    case ZERO_EXTRACT:\n+      /* This is cheap, we can use btst.  */\n+      if (outer_code == COMPARE)\n+\t*total = 0;\n+      return false;\n+\n    /* ??? This probably needs more work.  */\n     case MOD:\n     case DIV:"}, {"sha": "a2b6296912fb2be4b8c4b3b64b1d9c697e9905cd", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 78, "deletions": 126, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -826,34 +826,34 @@\n ;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-;; Go ahead and define tstsi so we can eliminate redundant tst insns\n-;; when we start trying to optimize this port.\n-(define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dax\"))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx,!a\")))]\n+(define_insn \"*tst_extqisi_am33\"\n+  [(set (cc0) (compare\n+\t       (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx,!a\"))\n+\t       (const_int 0)))]\n   \"TARGET_AM33\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx\")))]\n+(define_insn \"*tst_extqisi\"\n+  [(set (cc0) (compare\n+\t       (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx\"))\n+\t       (const_int 0)))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx,!a\")))]\n+(define_insn \"*tst_exthisi_am33\"\n+  [(set (cc0) (compare\n+\t       (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx,!a\"))\n+\t       (const_int 0)))]\n   \"TARGET_AM33\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx\")))]\n+(define_insn \"*tst_exthisi\"\n+  [(set (cc0) (compare\n+\t       (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx\"))\n+\t       (const_int 0)))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n@@ -874,17 +874,22 @@\n ;; possibly satisfied, so just mark the alternative with a `!', so\n ;; that it is not considered by reload.\n \n-(define_insn \"cmpsi\"\n+(define_insn \"*cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"*0,daxi\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax,dax\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"*0,I,daxi\")))]\n   \"\"\n-  \"@\n-  btst 0,d0\n-  cmp %1,%0\"\n-  [(set_attr \"cc\" \"compare,compare\")])\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"btst 0,d0\\\";\n+  if (which_alternative == 1)\n+    return output_tst (operands[0], insn);\n+  return \\\"cmp %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"compare,set_znv,compare\")])\n \n-(define_insn \"cmpsf\"\n+(define_insn \"*cmpsf\"\n   [(set (cc0)\n \t(compare (match_operand:SF 0 \"register_operand\" \"f,f\")\n \t\t (match_operand:SF 1 \"nonmemory_operand\" \"f,F\")))]\n@@ -1510,9 +1515,10 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-     (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t      (match_operand 1 \"const_int_operand\" \"\")\n-\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n+     (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n+\t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n+\t      (const_int 0)))]\n   \"\"\n   \"*\n {\n@@ -1537,9 +1543,10 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-     (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,dx\")\n-\t\t      (match_operand 1 \"const_int_operand\" \"\")\n-\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n+     (compare (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,dx\")\n+\t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n+\t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n+\t      (const_int 0)))]\n   \"mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n   \"*\n {\n@@ -1581,17 +1588,19 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"\"\n-  [(set (cc0) (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))]\n+  [(set (cc0) (compare (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t\t       (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"btst %1,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"\"\n   [(set (cc0)\n-     (and:SI\n-       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,dx\") 0)\n-       (match_operand:SI 1 \"const_8bit_operand\" \"\")))]\n+     (compare (and:SI\n+\t       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,dx\") 0)\n+\t       (match_operand:SI 1 \"const_8bit_operand\" \"\"))\n+\t      (const_int 0)))]\n   \"\"\n   \"@\n   btst %U1,%A0\n@@ -1603,97 +1612,34 @@\n ;; JUMP INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-;; Conditional jump instructions\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchsi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+   (set (pc)\n+      (if_then_else\n+            (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+\t                                                     (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n   \"\"\n   \"\")\n \n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n+(define_expand \"cbranchsf4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")))\n+   (set (pc)\n+      (if_then_else\n+            (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+\t                                                     (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+  \"TARGET_AM33_2\"\n   \"\")\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n \n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n+;; Conditional jump instructions\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1774,11 +1720,13 @@\n   rtx table = gen_reg_rtx (SImode);\n   rtx index = gen_reg_rtx (SImode);\n   rtx addr = gen_reg_rtx (Pmode);\n+  rtx test;\n \n   emit_move_insn (table, gen_rtx_LABEL_REF (VOIDmode, operands[3]));\n   emit_move_insn (index, plus_constant (operands[0], - INTVAL (operands[1])));\n-  emit_insn (gen_cmpsi (index, operands[2]));\n-  emit_jump_insn (gen_bgtu (operands[4]));\n+  test = gen_rtx_fmt_ee (GTU, VOIDmode, index, operands[2]);\n+  emit_jump_insn (gen_cbranchsi4 (test, index, operands[2], operands[4]));\n+ \n   emit_move_insn (index, gen_rtx_ASHIFT (SImode, index, const2_rtx));\n   emit_move_insn (addr, gen_rtx_MEM (SImode,\n \t\t\t\t     gen_rtx_PLUS (SImode, table, index)));\n@@ -2518,7 +2466,8 @@\n ;; This will work on the mn10200 because we can check the ZX flag\n ;; if the comparison is in HImode.\n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (match_operand 1 \"\" \"\")\n \t\t\t   (pc)))]\n@@ -2527,7 +2476,8 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (match_operand 1 \"\" \"\")\n \t\t\t   (pc)))]\n@@ -2536,7 +2486,8 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (pc)\n \t\t\t   (match_operand 1 \"\" \"\")))]\n@@ -2545,7 +2496,8 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t       (const_int 0)))\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (pc)\n \t\t\t   (match_operand 1 \"\" \"\")))]"}, {"sha": "526081acd52e522c4a1913d0e56ad3ad4737ac6b", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -56,7 +56,6 @@ extern void output_arg_descriptor (rtx);\n extern void output_global_address (FILE *, rtx, int);\n extern void print_operand (FILE *, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n-extern struct rtx_def *gen_cmp_fp (enum rtx_code, rtx, rtx);\n extern void hppa_encode_label (rtx);\n extern int arith11_operand (rtx, enum machine_mode);\n extern int adddi3_operand (rtx, enum machine_mode);\n@@ -96,7 +95,7 @@ extern int fmpyaddoperands (rtx *);\n extern int fmpysuboperands (rtx *);\n extern int call_operand_address (rtx, enum machine_mode);\n extern int ior_operand (rtx, enum machine_mode);\n-extern void emit_bcond_fp (enum rtx_code, rtx);\n+extern void emit_bcond_fp (rtx[]);\n extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern int emit_hpdiv_const (rtx *, int);\n extern int is_function_label_plus_const (rtx);"}, {"sha": "882fac1aad45b856d51f3598e793ca5c40899c82", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -165,11 +165,6 @@ static GTY(()) section *som_readonly_data_section;\n static GTY(()) section *som_one_only_readonly_data_section;\n static GTY(()) section *som_one_only_data_section;\n \n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-rtx hppa_compare_op0, hppa_compare_op1;\n-enum cmp_type hppa_branch_type;\n-\n /* Which cpu we are scheduling for.  */\n enum processor_type pa_cpu = TARGET_SCHED_DEFAULT;\n \n@@ -4383,6 +4378,19 @@ return_addr_rtx (int count, rtx frameaddr)\n   rtx saved_rp;\n   rtx ins;\n \n+  /* Instruction stream at the normal return address for the export stub:\n+\n+\t0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp\n+\t0x004010a1 | stub+12:  ldsid (sr0,rp),r1\n+\t0x00011820 | stub+16:  mtsp r1,sr0\n+\t0xe0400002 | stub+20:  be,n 0(sr0,rp)\n+\n+     0xe0400002 must be specified as -532676606 so that it won't be\n+     rejected as an invalid immediate operand on 64-bit hosts.  */\n+\n+  HOST_WIDE_INT insns[4] = {0x4bc23fd1, 0x004010a1, 0x00011820, -532676606};\n+  int i;\n+\n   if (count != 0)\n     return NULL_RTX;\n \n@@ -4391,6 +4399,9 @@ return_addr_rtx (int count, rtx frameaddr)\n   if (TARGET_64BIT || TARGET_NO_SPACE_REGS)\n     return rp;\n \n+  /* If there is no export stub then just use the value saved from\n+     the return pointer register.  */\n+\n   saved_rp = gen_reg_rtx (Pmode);\n   emit_move_insn (saved_rp, rp);\n \n@@ -4402,37 +4413,15 @@ return_addr_rtx (int count, rtx frameaddr)\n   label = gen_label_rtx ();\n \n   /* Check the instruction stream at the normal return address for the\n-     export stub:\n-\n-\t0x4bc23fd1 | stub+8:   ldw -18(sr0,sp),rp\n-\t0x004010a1 | stub+12:  ldsid (sr0,rp),r1\n-\t0x00011820 | stub+16:  mtsp r1,sr0\n-\t0xe0400002 | stub+20:  be,n 0(sr0,rp)\n+     export stub.  If it is an export stub, than our return address is\n+     really in -24[frameaddr].  */\n \n-     If it is an export stub, than our return address is really in\n-     -24[frameaddr].  */\n-\n-  emit_cmp_insn (gen_rtx_MEM (SImode, ins), GEN_INT (0x4bc23fd1), NE,\n-\t\t NULL_RTX, SImode, 1);\n-  emit_jump_insn (gen_bne (label));\n-\n-  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 4)),\n-\t\t GEN_INT (0x004010a1), NE, NULL_RTX, SImode, 1);\n-  emit_jump_insn (gen_bne (label));\n-\n-  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 8)),\n-\t\t GEN_INT (0x00011820), NE, NULL_RTX, SImode, 1);\n-  emit_jump_insn (gen_bne (label));\n-\n-  /* 0xe0400002 must be specified as -532676606 so that it won't be\n-     rejected as an invalid immediate operand on 64-bit hosts.  */\n-  emit_cmp_insn (gen_rtx_MEM (SImode, plus_constant (ins, 12)),\n-\t\t GEN_INT (-532676606), NE, NULL_RTX, SImode, 1);\n-\n-  /* If there is no export stub then just use the value saved from\n-     the return pointer register.  */\n-\n-  emit_jump_insn (gen_bne (label));\n+  for (i = 0; i < 3; i++)\n+    {\n+      rtx op0 = gen_rtx_MEM (SImode, plus_constant (ins, i * 4)); \n+      rtx op1 = GEN_INT (insns[i]);\n+      emit_cmp_and_jump_insns (op0, op1, NE, NULL, SImode, 0, label);\n+    }\n \n   /* Here we know that our return address points to an export\n      stub.  We don't want to return the address of the export stub,\n@@ -4446,30 +4435,32 @@ return_addr_rtx (int count, rtx frameaddr)\n \t\t\t\t\t\t\t      -24))));\n \n   emit_label (label);\n+\n   return saved_rp;\n }\n \n void\n-emit_bcond_fp (enum rtx_code code, rtx operand0)\n+emit_bcond_fp (rtx operands[])\n {\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx operand0 = operands[1];\n+  rtx operand1 = operands[2];\n+  rtx label = operands[3];\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (CCFPmode, 0),\n+\t\t          gen_rtx_fmt_ee (code, CCFPmode, operand0, operand1)));\n+\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t\t     gen_rtx_fmt_ee (code,\n+\t\t\t\t\t\t     gen_rtx_fmt_ee (NE,\n \t\t\t\t\t\t\t      VOIDmode,\n \t\t\t\t\t\t\t      gen_rtx_REG (CCFPmode, 0),\n \t\t\t\t\t\t\t      const0_rtx),\n-\t\t\t\t\t\t     gen_rtx_LABEL_REF (VOIDmode, operand0),\n+\t\t\t\t\t\t     gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t\t\t     pc_rtx)));\n \n }\n \n-rtx\n-gen_cmp_fp (enum rtx_code code, rtx operand0, rtx operand1)\n-{\n-  return gen_rtx_SET (VOIDmode, gen_rtx_REG (CCFPmode, 0),\n-\t\t      gen_rtx_fmt_ee (code, CCFPmode, operand0, operand1));\n-}\n-\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n "}, {"sha": "576916f5b7bbc4d391584de148d99c26b7e14fb2", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -21,14 +21,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-enum cmp_type\t\t\t\t/* comparison type */\n-{\n-  CMP_SI,\t\t\t\t/* compare integers */\n-  CMP_SF,\t\t\t\t/* compare single precision floats */\n-  CMP_DF,\t\t\t\t/* compare double precision floats */\n-  CMP_MAX\t\t\t\t/* max comparison type */\n-};\n-\n /* For long call handling.  */\n extern unsigned long total_code_bytes;\n \n@@ -755,10 +747,6 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n    ? PARM_BOUNDARY : MAX_PARM_BOUNDARY)\n \n \f\n-extern GTY(()) rtx hppa_compare_op0;\n-extern GTY(()) rtx hppa_compare_op1;\n-extern enum cmp_type hppa_branch_type;\n-\n /* On HPPA, we emit profiling code as rtl via PROFILE_HOOK rather than\n    as assembly via FUNCTION_PROFILER.  Just output a local label.\n    We can't use the function label because the GAS SOM target can't"}, {"sha": "1f5a69b9352cade59f574d19680cf1a983ffbf02", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 41, "deletions": 490, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -653,64 +653,6 @@\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n \n-;; We generate RTL for comparisons and branches by having the cmpxx\n-;; patterns store away the operands.  Then, the scc and bcc patterns\n-;; emit RTL for both the compare and the branch.\n-;;\n-\n-(define_expand \"cmpdi\"\n-  [(set (reg:CC 0)\n-\t(compare:CC (match_operand:DI 0 \"reg_or_0_operand\" \"\")\n-\t\t    (match_operand:DI 1 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-\n-  \"\n-{\n- hppa_compare_op0 = operands[0];\n- hppa_compare_op1 = operands[1];\n- hppa_branch_type = CMP_SI;\n- DONE;\n-}\")\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 0)\n-\t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"arith5_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n- hppa_compare_op0 = operands[0];\n- hppa_compare_op1 = operands[1];\n- hppa_branch_type = CMP_SI;\n- DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (reg:CCFP 0)\n-\t(compare:CCFP (match_operand:SF 0 \"reg_or_0_operand\" \"\")\n-\t\t      (match_operand:SF 1 \"reg_or_0_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  hppa_compare_op0 = operands[0];\n-  hppa_compare_op1 = operands[1];\n-  hppa_branch_type = CMP_SF;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (reg:CCFP 0)\n-      (compare:CCFP (match_operand:DF 0 \"reg_or_0_operand\" \"\")\n-                    (match_operand:DF 1 \"reg_or_0_operand\" \"\")))]\n-  \"! TARGET_SOFT_FLOAT\"\n-  \"\n-{\n-  hppa_compare_op0 = operands[0];\n-  hppa_compare_op1 = operands[1];\n-  hppa_branch_type = CMP_DF;\n-  DONE;\n-}\")\n-\n (define_insn \"\"\n   [(set (reg:CCFP 0)\n \t(match_operator:CCFP 2 \"comparison_operator\"\n@@ -767,143 +709,13 @@\n \n ;; scc insns.\n \n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(eq:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  /* set up operands from compare.  */\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-  /* fall through and generate default code */\n-}\")\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lt:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(gt:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(le:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ge:SI (match_dup 1)\n-\t       (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  /* fp scc patterns rarely match, and are not a win on the PA.  */\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ltu:SI (match_dup 1)\n-\t        (match_dup 2)))]\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:SI 2 \"reg_or_0_operand\" \"\")\n+\t  (match_operand:SI 3 \"arith5_operand\" \"\")]))]\n   \"!TARGET_64BIT\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(gtu:SI (match_dup 1)\n-\t        (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(leu:SI (match_dup 1)\n-\t        (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(geu:SI (match_dup 1)\n-\t        (match_dup 2)))]\n-  \"!TARGET_64BIT\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n+  \"\")\n \n ;; Instruction canonicalization puts immediate operands second, which\n ;; is the reverse of what we want.\n@@ -1346,28 +1158,15 @@\n (define_expand \"movsicc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(if_then_else:SI\n-\t (match_operator 1 \"comparison_operator\"\n-\t    [(match_dup 4)\n-\t     (match_dup 5)])\n+\t (match_operand 1 \"comparison_operator\" \"\")\n \t (match_operand:SI 2 \"reg_or_cint_move_operand\" \"\")\n \t (match_operand:SI 3 \"reg_or_cint_move_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (hppa_branch_type != CMP_SI)\n+  if (GET_MODE (XEXP (operands[1], 0)) != SImode\n+      || GET_MODE (XEXP (operands[1], 0)) != GET_MODE (XEXP (operands[1], 1)))\n     FAIL;\n-\n-  if (GET_MODE (hppa_compare_op0) != GET_MODE (hppa_compare_op1)\n-      || GET_MODE (hppa_compare_op0) != GET_MODE (operands[0]))\n-    FAIL;\n-\n-  /* operands[1] is currently the result of compare_from_rtx.  We want to\n-     emit a compare of the original operands.  */\n-  operands[1] = gen_rtx_fmt_ee (code, SImode, hppa_compare_op0, hppa_compare_op1);\n-  operands[4] = hppa_compare_op0;\n-  operands[5] = hppa_compare_op1;\n }\")\n \n ;; We used to accept any register for op1.\n@@ -1419,28 +1218,15 @@\n (define_expand \"movdicc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI\n-\t (match_operator 1 \"comparison_operator\"\n-\t    [(match_dup 4)\n-\t     (match_dup 5)])\n+\t (match_operand 1 \"comparison_operator\" \"\")\n \t (match_operand:DI 2 \"reg_or_cint_move_operand\" \"\")\n \t (match_operand:DI 3 \"reg_or_cint_move_operand\" \"\")))]\n   \"TARGET_64BIT\"\n   \"\n {\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (hppa_branch_type != CMP_SI)\n+  if (GET_MODE (XEXP (operands[1], 0)) != DImode\n+      || GET_MODE (XEXP (operands[1], 0)) != GET_MODE (XEXP (operands[1], 1)))\n     FAIL;\n-\n-  if (GET_MODE (hppa_compare_op0) != GET_MODE (hppa_compare_op1)\n-      || GET_MODE (hppa_compare_op0) != GET_MODE (operands[0]))\n-    FAIL;\n-\n-  /* operands[1] is currently the result of compare_from_rtx.  We want to\n-     emit a compare of the original operands.  */\n-  operands[1] = gen_rtx_fmt_ee (code, DImode, hppa_compare_op0, hppa_compare_op1);\n-  operands[4] = hppa_compare_op0;\n-  operands[5] = hppa_compare_op1;\n }\")\n \n ; We need the first constraint alternative in order to avoid\n@@ -1486,289 +1272,52 @@\n \n ;; Conditional Branches\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (EQ, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  /* set up operands from compare.  */\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-  /* fall through and generate default code */\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (NE, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bgt\"\n+(define_expand \"cbranchdi4\"\n   [(set (pc)\n-\t(if_then_else (gt (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+                        (match_operand:DI 2 \"register_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (GT, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (LT, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (GE, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    {\n-      emit_insn (gen_cmp_fp (LE, hppa_compare_op0, hppa_compare_op1));\n-      emit_bcond_fp (NE, operands[0]);\n-      DONE;\n-    }\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type != CMP_SI)\n-    FAIL;\n-  operands[1] = hppa_compare_op0;\n-  operands[2] = hppa_compare_op1;\n-}\")\n-\n-(define_expand \"bltgt\"\n-  [(set (pc)\n-\t(if_then_else (ltgt (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (LTGT, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunle\"\n-  [(set (pc)\n-\t(if_then_else (unle (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNLE, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunlt\"\n-  [(set (pc)\n-\t(if_then_else (unlt (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNLT, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n-\n-(define_expand \"bunge\"\n-  [(set (pc)\n-\t(if_then_else (unge (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNGE, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n+  \"TARGET_64BIT\"\n+  \"\")\n \n-(define_expand \"bungt\"\n+(define_expand \"cbranchsi4\"\n   [(set (pc)\n-\t(if_then_else (ungt (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(match_operand:SI 1 \"reg_or_0_operand\" \"\")\n+                        (match_operand:SI 2 \"arith5_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNGT, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n+  \"\")\n \n-(define_expand \"buneq\"\n+(define_expand \"cbranchsf4\"\n   [(set (pc)\n-\t(if_then_else (uneq (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:SF 1 \"reg_or_0_operand\" \"\")\n+                        (match_operand:SF 2 \"reg_or_0_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNEQ, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n+  emit_bcond_fp (operands);\n   DONE;\n }\")\n \n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (unordered (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (UNORDERED, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n-  DONE;\n-}\")\n \n-(define_expand \"bordered\"\n+(define_expand \"cbranchdf4\"\n   [(set (pc)\n-\t(if_then_else (ordered (match_dup 1) (match_dup 2))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:DF 1 \"reg_or_0_operand\" \"\")\n+                        (match_operand:DF 2 \"reg_or_0_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n   \"\n {\n-  if (hppa_branch_type == CMP_SI)\n-    FAIL;\n-  emit_insn (gen_cmp_fp (ORDERED, hppa_compare_op0, hppa_compare_op1));\n-  emit_bcond_fp (NE, operands[0]);\n+  emit_bcond_fp (operands);\n   DONE;\n }\")\n \n@@ -7527,8 +7076,10 @@\n      then be worthwhile to split the casesi patterns to improve scheduling.\n      However, it's not clear that all this extra complexity is worth\n      the effort.  */\n-  emit_insn (gen_cmpsi (operands[0], operands[2]));\n-  emit_jump_insn (gen_bgtu (operands[4]));\n+  {\n+    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[2]);\n+    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[2], operands[4]));\n+  }\n \n   if (TARGET_BIG_SWITCH)\n     {"}, {"sha": "1ed272e508146aac51b1eaa6772bb34b6907c3bf", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -33,9 +33,9 @@ extern void output_addr_const_pdp11 (FILE *, rtx);\n extern const char *output_move_double (rtx *);\n extern const char *output_move_quad (rtx *);\n extern const char *output_block_move (rtx *);\n+extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n extern int register_move_cost (enum reg_class, enum reg_class);\n #endif /* RTX_CODE */\n \n extern void output_ascii (FILE *, const char *, int);\n-extern const char *output_jump (const char *, const char *, int);"}, {"sha": "8f2d78fe555ca5c337d9fb1925bc4d3a25da8f9c", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1170,11 +1170,27 @@ pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n }\n \n const char *\n-output_jump (const char *pos, const char *neg, int length)\n+output_jump (enum rtx_code code, int inv, int length)\n {\n     static int x = 0;\n     \n     static char buf[1000];\n+    const char *pos, *neg;\n+\n+    switch (code)\n+      {\n+      case EQ: pos = \"beq\", neg = \"bne\"; break;\n+      case NE: pos = \"bne\", neg = \"beq\"; break;\n+      case GT: pos = \"bgt\", neg = \"ble\"; break;\n+      case GTU: pos = \"bhi\", neg = \"blos\"; break;\n+      case LT: pos = \"blt\", neg = \"bge\"; break;\n+      case LTU: pos = \"blo\", neg = \"bhis\"; break;\n+      case GE: pos = \"bge\", neg = \"blt\"; break;\n+      case GEU: pos = \"bhis\", neg = \"blo\"; break;\n+      case LE: pos = \"ble\", neg = \"bgt\"; break;\n+      case LEU: pos = \"blos\", neg = \"bhi\"; break;\n+      default: gcc_unreachable ();\n+      }\n \n #if 0\n /* currently we don't need this, because the tstdf and cmpdf \n@@ -1190,14 +1206,13 @@ output_jump (const char *pos, const char *neg, int length)\n     {\n       case 1:\n \t\n-\tstrcpy(buf, pos);\n-\tstrcat(buf, \" %l0\");\n+\tsprintf(buf, \"%s %%l1\", inv ? neg : pos);\n \t\n \treturn buf;\n \t\n       case 3:\n \t\n-\tsprintf(buf, \"%s JMP_%d\\n\\tjmp %%l0\\nJMP_%d:\", neg, x, x);\n+\tsprintf(buf, \"%s JMP_%d\\n\\tjmp %%l1\\nJMP_%d:\", inv ? pos : neg, x, x);\n \t\n \tx++;\n \t"}, {"sha": "437e2b81e2e1eba0cbedde88b41ab622d8a9ff57", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1031,6 +1031,9 @@ JMP\tFUNCTION\t0x0058  0x0000 <- FUNCTION\n \n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  flag_finite_math_only\t\t= 0;\t\t\t\t\t\\\n+  flag_trapping_math\t\t= 0;\t\t\t\t\t\\\n+  flag_signaling_nans\t\t= 0;\t\t\t\t\t\\\n   if (LEVEL >= 3)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       flag_omit_frame_pointer\t\t= 1;\t\t\t\t\\"}, {"sha": "64d57e056b3976169cfe74d390ad8c40e1326b44", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 82, "deletions": 440, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -19,6 +19,11 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Match CONST_DOUBLE zero for tstd/tstf.\n+(define_predicate \"register_or_const0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n \n ;; HI is 16 bit\n ;; QI is 8 bit \n@@ -81,141 +86,50 @@\n ;(define_function_unit \"fpu\" 1 1 (eq_attr \"type\" \"fp\") 0 0)\n \n ;; compare\n-(define_insn \"cmpdf\"\n+(define_insn \"*cmpdf\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"fR,Q,F\")\n-\t\t (match_operand:DF 1 \"register_operand\" \"a,a,a\")))]\n+\t(compare (match_operand:DF 0 \"general_operand\" \"fR,fR,Q,Q,F\")\n+\t\t (match_operand:DF 1 \"register_or_const0_operand\" \"G,a,G,a,a\")))]\n   \"TARGET_FPU\"\n   \"*\n {\n   cc_status.flags = CC_IN_FPU;\n-  return \\\"{cmpd|cmpf} %0, %1\\;cfcc\\\";\n-}\"\n-  [(set_attr \"length\" \"2,3,6\")])\n-\n-;; a bit of brain damage, maybe inline later - \n-;; problem is - gcc seems to NEED SImode because \n-;; of the cmp weirdness - maybe change gcc to handle this?\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:SI 0)\n-\t(match_operand:SI 0 \"general_operand\" \"g\"))\n-   (set (reg:SI 2)\n-\t(match_operand:SI 1 \"general_operand\" \"g\"))\n-   (parallel [(set (cc0)\n-\t\t   (compare (reg:SI 0)\n-\t\t\t    (reg:SI 2)))\n-\t      (clobber (reg:SI 0))])]\n-  \"0\" ;; disable for test\n-  \"\")\n-\n-;; check for next insn for branch code - does this still\n-;; work in gcc 2.* ?\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (reg:SI 0)\n-\t\t (reg:SI 2)))\n-   (clobber (reg:SI 0))]\n-  \"\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  gcc_assert (GET_CODE (br_insn) == JUMP_INSN);\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-  \n-  switch(br_code)\n-  {\n-    case GEU:\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-      \n-      return \\\"jsr pc, ___ucmpsi\\;cmp $1,r0\\\";\n-\n-    case GE:\n-    case LT:\n-    case GT:\n-    case LE:\n-    case EQ:\n-    case NE:\n-\n-      return \\\"jsr pc, ___cmpsi\\;tst r0\\\";\n-\n-    default:\n-\n-      gcc_unreachable ();\n-  }\n+  if (which_alternative == 0 || which_alternative == 2)\n+    return \\\"{tstd|tstf} %0, %1\\;cfcc\\\";\n+  else\n+    return \\\"{cmpd|cmpf} %0, %1\\;cfcc\\\";\n }\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"2,2,3,3,6\")]) \n \n-\n-(define_insn \"cmphi\"\n+(define_insn \"*cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"general_operand\" \"rR,rR,Qi,Qi\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+\t(compare (match_operand:HI 0 \"general_operand\" \"rR,rR,rR,Q,Qi,Qi\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"N,rR,Qi,N,rR,Qi\")))]\n   \"\"\n-  \"cmp %0,%1\"\n-  [(set_attr \"length\" \"1,2,2,3\")])\n-\n-(define_insn \"cmpqi\"\n+  \"@\n+   tst %0\n+   cmp %0,%1\n+   cmp %0,%1\n+   tst %0\n+   cmp %0,%1\n+   cmp %0,%1\"\n+  [(set_attr \"length\" \"1,1,2,2,2,3\")])\n+\n+(define_insn \"*cmpqi\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"general_operand\" \"rR,rR,Qi,Qi\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+\t(compare (match_operand:QI 0 \"general_operand\" \"rR,rR,rR,Q,Qi,Qi\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"N,rR,Qi,N,rR,Qi\")))]\n   \"\"\n-  \"cmpb %0,%1\"\n-  [(set_attr \"length\" \"1,2,2,3\")])\n+  \"@\n+   tstb %0\n+   cmpb %0,%1\n+   cmpb %0,%1\n+   tstb %0\n+   cmpb %0,%1\n+   cmpb %0,%1\"\n+  [(set_attr \"length\" \"1,1,2,2,2,3\")])\n \t\t\t   \n \n-;; We have to have this because cse can optimize the previous pattern\n-;; into this one.\n-\n-(define_insn \"tstdf\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"fR,Q\"))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FPU;\n-  return \\\"{tstd|tstf} %0\\;cfcc\\\";\n-}\"\n-  [(set_attr \"length\" \"2,3\")])\n-\n-\n-(define_expand \"tstsi\"\n-  [(set (reg:SI 0)\n-\t(match_operand:SI 0 \"general_operand\" \"g\"))\n-   (parallel [(set (cc0)\n-\t\t   (reg:SI 0))\n-\t      (clobber (reg:SI 0))])]\n-  \"0\" ;; disable for test\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(reg:SI 0))\n-   (clobber (reg:SI 0))]\n-  \"\"\n-  \"jsr pc, ___tstsi\\;tst r0\"\n-  [(set_attr \"length\" \"3\")])\n-\n-\n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"general_operand\" \"rR,Q\"))]\n-  \"\"\n-  \"tst %0\"\n-  [(set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"general_operand\" \"rR,Q\"))]\n-  \"\"\n-  \"tstb %0\"\n-  [(set_attr \"length\" \"1,2\")])\n-\n ;; sob instruction - we need an assembler which can make this instruction\n ;; valid under _all_ circumstances!\n \n@@ -264,353 +178,81 @@\n ;; These control RTL generation for conditional jump insns\n ;; and match them for register allocation.\n \n-;; problem with too short jump distance! we need an assembler which can \n-;; make this valid for all jump distances!\n-;; e.g. gas!\n-\n-;; these must be changed to check for CC_IN_FCCR if float is to be \n-;; enabled\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"beq\\\", \\\"bne\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"bne\\\", \\\"beq\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"bgt\\\", \\\"ble\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchdf4\"\n+  [(set (cc0)\n+        (compare (match_operand:DF 1 \"general_operand\")\n+\t\t (match_operand:DF 2 \"general_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return output_jump(\\\"bhi\\\", \\\"blos\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n+  \"\")\n \n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchhi4\"\n+  [(set (cc0)\n+        (compare (match_operand:HI 1 \"general_operand\")\n+\t\t (match_operand:HI 2 \"general_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return output_jump(\\\"blt\\\", \\\"bge\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n+  \"\")\n \n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"cbranchqi4\"\n+  [(set (cc0)\n+        (compare (match_operand:QI 1 \"general_operand\")\n+\t\t (match_operand:QI 2 \"general_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return output_jump(\\\"blo\\\", \\\"bhis\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n+  \"\")\n \n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"bge\\\", \\\"blt\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n+;; problem with too short jump distance! we need an assembler which can \n+;; make this valid for all jump distances!\n+;; e.g. gas!\n \n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"bhis\\\", \\\"blo\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n+;; these must be changed to check for CC_IN_FCCR if float is to be \n+;; enabled\n \n-(define_insn \"ble\"\n+(define_insn \"*branch\"\n   [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return output_jump(\\\"ble\\\", \\\"bgt\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+  \"* return output_jump(GET_CODE (operands[0]), 0, get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t   (ge (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int 128)))\n \t\t\t\t      (const_int 3)\n \t\t\t\t      (const_int 1)))])\n \n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(\\\"blos\\\", \\\"bhi\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n \n-\f\n ;; These match inverted jump insns for register allocation.\n \n-(define_insn \"\"\n+(define_insn \"*branch_inverted\"\n   [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t       [(cc0) (const_int 0)])\n \t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n-  \"* return output_jump(\\\"bne\\\", \\\"beq\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+  \"* return output_jump(GET_CODE (operands[0]), 1, get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"beq\\\", \\\"bne\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"ble\\\", \\\"bgt\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"blos\\\", \\\"bhi\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"bge\\\", \\\"blt\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"bhis\\\", \\\"blo\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"  \n-  \"* return output_jump(\\\"blt\\\", \\\"bge\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"blo\\\", \\\"bhis\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"bgt\\\", \\\"ble\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int 128)))\n-\t\t\t\t      (const_int 3)\n-\t\t\t\t      (const_int 1)))])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(\\\"bhi\\\", \\\"blos\\\", get_attr_length(insn));\"\n-  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n-\t\t\t\t\t\t      (pc))\n-\t\t\t\t\t       (const_int -128))\n-\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t   (ge (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int 128)))\n \t\t\t\t      (const_int 3)"}, {"sha": "02f0f14850d9d4d7040ac61d2ea1cfe8a075a679", "filename": "gcc/config/picochip/picochip.md", "status": "modified", "additions": 1, "deletions": 112, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -551,7 +551,7 @@\n (define_insn_and_split \"cbranchhi4\"\n   [(set (pc)\n         (if_then_else\n-            (match_operator:CC 0 \"comparison_operator\"\n+            (match_operator:CC 0 \"ordered_comparison_operator\"\n                             [(match_operand:HI 1 \"register_operand\" \"r\")\n                              (match_operand:HI 2 \"picochip_comparison_operand\" \"ri\")])\n             (label_ref       (match_operand    3 \"\" \"\"))\n@@ -2524,117 +2524,6 @@\n    (set_attr \"type\" \"picoAlu,picoAlu\")\n    (set_attr \"longConstant\" \"false,true\")])\n \n-;; cmphi - This needs to be defined, to ensure that the conditional\n-;; move works properly (because the if-cvt code uses this pattern to\n-;; build the conditional move, even though normally we use cbranch to\n-;; directly generate the instructions).\n-\n-(define_expand \"cmphi\"\n-  [(match_operand:HI 0 \"general_operand\" \"g\")\n-   (match_operand:HI 1 \"general_operand\" \"g\")]\n-  \"\"\n-  \"DONE;\")\n-\n-;;============================================================================\n-;; Branch patterns - needed for conditional moves.  This is because\n-;; they result in the bcc_gen_fctn array being initialised with the\n-;; code to define_expand the following, and this in turn means that\n-;; when noce_emit_cmove is called, the correct pattern can be\n-;; generated, based upon the assumed presence of the following.  The\n-;; following are never actually used, because the earlier cbranch\n-;; patterns take precendence.\n-;;============================================================================\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (ne (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (eq (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (lt (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (ge (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (geu (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (ltu (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (le (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (gt (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (leu (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else\n-\t    (gtu (reg:CC CC_REGNUM) (const_int 0))\n-\t    (label_ref       (match_operand    0 \"\" \"\"))\n-\t    (pc)))]\n-  \"\"\n-  \"gcc_unreachable();\")\n-\n ;;============================================================================\n ;; Scheduling, including delay slot scheduling.\n ;;============================================================================"}, {"sha": "dbf78734b17fecf2812c83cb59a2b689739f57c5", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -830,6 +830,11 @@\n \t\t\t\t\t\t   GET_MODE (XEXP (op, 0))),\n \t\t\t  1\"))))\n \n+(define_predicate \"rs6000_cbranch_operator\"\n+  (if_then_else (match_test \"TARGET_HARD_FLOAT && !TARGET_FPRS\")\n+\t\t(match_operand 0 \"ordered_comparison_operator\")\n+\t\t(match_operand 0 \"comparison_operator\")))\n+\n ;; Return 1 if OP is a comparison operation that is valid for an SCC insn --\n ;; it must be a positive comparison.\n (define_predicate \"scc_comparison_operator\"\n@@ -842,11 +847,6 @@\n   (and (match_operand 0 \"branch_comparison_operator\")\n        (match_code \"eq,lt,gt,ltu,gtu,unordered\")))\n \n-;; Return 1 is OP is a comparison operation that is valid for a trap insn.\n-(define_predicate \"trap_comparison_operator\"\n-   (and (match_operand 0 \"comparison_operator\")\n-\t(match_code \"eq,ne,le,lt,ge,gt,leu,ltu,geu,gtu\")))\n-\n ;; Return 1 if OP is a load multiple operation, known to be a PARALLEL.\n (define_predicate \"load_multiple_operation\"\n   (match_code \"parallel\")"}, {"sha": "f40adabd00a94b7c463aab880f835fed7cf67a4d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -81,8 +81,8 @@ extern void print_operand_address (FILE *, rtx);\n extern bool rs6000_output_addr_const_extra (FILE *, rtx);\n extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n \t\t\t\t\t       enum rtx_code);\n-extern void rs6000_emit_sCOND (enum rtx_code, rtx);\n-extern void rs6000_emit_cbranch (enum rtx_code, rtx);\n+extern void rs6000_emit_sCOND (enum machine_mode, rtx[]);\n+extern void rs6000_emit_cbranch (enum machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx);\n extern char * output_e500_flip_gt_bit (rtx, rtx);\n extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);"}, {"sha": "2d34b14f63f117b9796094944a70ea50e74790ee", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 61, "deletions": 92, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -190,11 +190,6 @@ int rs6000_darwin64_abi;\n /* Set to nonzero once AIX common-mode calls have been defined.  */\n static GTY(()) int common_mode_defined;\n \n-/* Save information from a \"cmpxx\" operation until the branch or scc is\n-   emitted.  */\n-rtx rs6000_compare_op0, rs6000_compare_op1;\n-int rs6000_compare_fp_p;\n-\n /* Label number of label created for -mrelocatable, to call to so we can\n    get the address of the GOT section */\n int rs6000_pic_labelno;\n@@ -752,7 +747,7 @@ struct processor_costs power6_cost = {\n \f\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static const char *rs6000_invalid_within_doloop (const_rtx);\n-static rtx rs6000_generate_compare (enum rtx_code);\n+static rtx rs6000_generate_compare (rtx, enum machine_mode);\n static void rs6000_emit_stack_tie (void);\n static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n static bool spe_func_has_64bit_regs_p (void);\n@@ -12788,21 +12783,24 @@ rs6000_reverse_condition (enum machine_mode mode, enum rtx_code code)\n    represents the result of the compare.  */\n \n static rtx\n-rs6000_generate_compare (enum rtx_code code)\n+rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n {\n   enum machine_mode comp_mode;\n   rtx compare_result;\n+  enum rtx_code code = GET_CODE (cmp);\n+  rtx op0 = XEXP (cmp, 0);\n+  rtx op1 = XEXP (cmp, 1);\n \n-  if (rs6000_compare_fp_p)\n+  if (FLOAT_MODE_P (mode))\n     comp_mode = CCFPmode;\n   else if (code == GTU || code == LTU\n \t   || code == GEU || code == LEU)\n     comp_mode = CCUNSmode;\n   else if ((code == EQ || code == NE)\n-\t   && GET_CODE (rs6000_compare_op0) == SUBREG\n-\t   && GET_CODE (rs6000_compare_op1) == SUBREG\n-\t   && SUBREG_PROMOTED_UNSIGNED_P (rs6000_compare_op0)\n-\t   && SUBREG_PROMOTED_UNSIGNED_P (rs6000_compare_op1))\n+\t   && GET_CODE (op0) == SUBREG\n+\t   && GET_CODE (op1) == SUBREG\n+\t   && SUBREG_PROMOTED_UNSIGNED_P (op0)\n+\t   && SUBREG_PROMOTED_UNSIGNED_P (op1))\n     /* These are unsigned values, perhaps there will be a later\n        ordering compare that can be shared with this one.\n        Unfortunately we cannot detect the signedness of the operands\n@@ -12816,13 +12814,13 @@ rs6000_generate_compare (enum rtx_code code)\n \n   /* E500 FP compare instructions on the GPRs.  Yuck!  */\n   if ((!TARGET_FPRS && TARGET_HARD_FLOAT)\n-      && rs6000_compare_fp_p)\n+      && FLOAT_MODE_P (mode))\n     {\n       rtx cmp, or_result, compare_result2;\n-      enum machine_mode op_mode = GET_MODE (rs6000_compare_op0);\n+      enum machine_mode op_mode = GET_MODE (op0);\n \n       if (op_mode == VOIDmode)\n-\top_mode = GET_MODE (rs6000_compare_op1);\n+\top_mode = GET_MODE (op1);\n \n       /* The E500 FP compare instructions toggle the GT bit (CR bit 1) only.\n \t This explains the following mess.  */\n@@ -12834,26 +12832,20 @@ rs6000_generate_compare (enum rtx_code code)\n \t    {\n \t    case SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstsfeq_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpsfeq_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpdfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstdfeq_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpdfeq_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case TFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmptfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tsttfeq_gpr (compare_result, op0, op1)\n+\t\t: gen_cmptfeq_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    default:\n@@ -12866,26 +12858,20 @@ rs6000_generate_compare (enum rtx_code code)\n \t    {\n \t    case SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstsfgt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpsfgt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpdfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstdfgt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpdfgt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case TFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmptfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tsttfgt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmptfgt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    default:\n@@ -12898,26 +12884,20 @@ rs6000_generate_compare (enum rtx_code code)\n \t    {\n \t    case SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstsflt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpsflt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpdflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstdflt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmpdflt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    case TFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmptflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tsttflt_gpr (compare_result, op0, op1)\n+\t\t: gen_cmptflt_gpr (compare_result, op0, op1);\n \t      break;\n \n \t    default:\n@@ -12949,26 +12929,20 @@ rs6000_generate_compare (enum rtx_code code)\n \t    {\n \t    case SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstsfeq_gpr (compare_result2, op0, op1)\n+\t\t: gen_cmpsfeq_gpr (compare_result2, op0, op1);\n \t      break;\n \n \t    case DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tstdfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmpdfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tstdfeq_gpr (compare_result2, op0, op1)\n+\t\t: gen_cmpdfeq_gpr (compare_result2, op0, op1);\n \t      break;\n \n \t    case TFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n-\t\t? gen_tsttfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1)\n-\t\t: gen_cmptfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t\t   rs6000_compare_op1);\n+\t\t? gen_tsttfeq_gpr (compare_result2, op0, op1)\n+\t\t: gen_cmptfeq_gpr (compare_result2, op0, op1);\n \t      break;\n \n \t    default:\n@@ -12998,16 +12972,14 @@ rs6000_generate_compare (enum rtx_code code)\n       /* Generate XLC-compatible TFmode compare as PARALLEL with extra\n \t CLOBBERs to match cmptf_internal2 pattern.  */\n       if (comp_mode == CCFPmode && TARGET_XL_COMPAT\n-\t  && GET_MODE (rs6000_compare_op0) == TFmode\n+\t  && GET_MODE (op0) == TFmode\n \t  && !TARGET_IEEEQUAD\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128)\n \temit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t  gen_rtvec (9,\n \t\t     gen_rtx_SET (VOIDmode,\n \t\t\t\t  compare_result,\n-\t\t\t\t  gen_rtx_COMPARE (comp_mode,\n-\t\t\t\t\t\t   rs6000_compare_op0,\n-\t\t\t\t\t\t   rs6000_compare_op1)),\n+\t\t\t\t  gen_rtx_COMPARE (comp_mode, op0, op1)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n@@ -13016,29 +12988,25 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n \t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)))));\n-      else if (GET_CODE (rs6000_compare_op1) == UNSPEC\n-\t       && XINT (rs6000_compare_op1, 1) == UNSPEC_SP_TEST)\n+      else if (GET_CODE (op1) == UNSPEC\n+\t       && XINT (op1, 1) == UNSPEC_SP_TEST)\n \t{\n-\t  rtx op1 = XVECEXP (rs6000_compare_op1, 0, 0);\n+\t  rtx op1 = XVECEXP (op1, 0, 0);\n \t  comp_mode = CCEQmode;\n \t  compare_result = gen_reg_rtx (CCEQmode);\n \t  if (TARGET_64BIT)\n-\t    emit_insn (gen_stack_protect_testdi (compare_result,\n-\t\t\t\t\t\t rs6000_compare_op0, op1));\n+\t    emit_insn (gen_stack_protect_testdi (compare_result, op0, op1));\n \t  else\n-\t    emit_insn (gen_stack_protect_testsi (compare_result,\n-\t\t\t\t\t\t rs6000_compare_op0, op1));\n+\t    emit_insn (gen_stack_protect_testsi (compare_result, op0, op1));\n \t}\n       else\n \temit_insn (gen_rtx_SET (VOIDmode, compare_result,\n-\t\t\t\tgen_rtx_COMPARE (comp_mode,\n-\t\t\t\t\t\t rs6000_compare_op0,\n-\t\t\t\t\t\t rs6000_compare_op1)));\n+\t\t\t\tgen_rtx_COMPARE (comp_mode, op0, op1)));\n     }\n \n   /* Some kinds of FP comparisons need an OR operation;\n      under flag_finite_math_only we don't bother.  */\n-  if (rs6000_compare_fp_p\n+  if (FLOAT_MODE_P (mode)\n       && !flag_finite_math_only\n       && !(TARGET_HARD_FLOAT && !TARGET_FPRS)\n       && (code == LE || code == GE\n@@ -13081,16 +13049,17 @@ rs6000_generate_compare (enum rtx_code code)\n /* Emit the RTL for an sCOND pattern.  */\n \n void\n-rs6000_emit_sCOND (enum rtx_code code, rtx result)\n+rs6000_emit_sCOND (enum machine_mode mode, rtx operands[])\n {\n   rtx condition_rtx;\n   enum machine_mode op_mode;\n   enum rtx_code cond_code;\n+  rtx result = operands[0];\n \n-  condition_rtx = rs6000_generate_compare (code);\n+  condition_rtx = rs6000_generate_compare (operands[1], mode);\n   cond_code = GET_CODE (condition_rtx);\n \n-  if (rs6000_compare_fp_p\n+  if (FLOAT_MODE_P (mode)\n       && !TARGET_FPRS && TARGET_HARD_FLOAT)\n     {\n       rtx t;\n@@ -13125,11 +13094,11 @@ rs6000_emit_sCOND (enum rtx_code code, rtx result)\n       condition_rtx = gen_rtx_EQ (VOIDmode, not_result, const0_rtx);\n     }\n \n-  op_mode = GET_MODE (rs6000_compare_op0);\n+  op_mode = GET_MODE (XEXP (operands[1], 0));\n   if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n+    op_mode = GET_MODE (XEXP (operands[1], 1));\n \n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n+  if (TARGET_POWERPC64 && (op_mode == DImode || FLOAT_MODE_P (mode)))\n     {\n       PUT_MODE (condition_rtx, DImode);\n       convert_move (result, condition_rtx, 0);\n@@ -13144,12 +13113,12 @@ rs6000_emit_sCOND (enum rtx_code code, rtx result)\n /* Emit a branch of kind CODE to location LOC.  */\n \n void\n-rs6000_emit_cbranch (enum rtx_code code, rtx loc)\n+rs6000_emit_cbranch (enum machine_mode mode, rtx operands[])\n {\n   rtx condition_rtx, loc_ref;\n \n-  condition_rtx = rs6000_generate_compare (code);\n-  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n+  condition_rtx = rs6000_generate_compare (operands[0], mode);\n+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n \t\t\t\t\t\t     loc_ref, pc_rtx)));\n@@ -13595,8 +13564,8 @@ int\n rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   enum rtx_code code = GET_CODE (op);\n-  rtx op0 = rs6000_compare_op0;\n-  rtx op1 = rs6000_compare_op1;\n+  rtx op0 = XEXP (op, 0);\n+  rtx op1 = XEXP (op, 1);\n   REAL_VALUE_TYPE c1;\n   enum machine_mode compare_mode = GET_MODE (op0);\n   enum machine_mode result_mode = GET_MODE (dest);\n@@ -13616,7 +13585,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n \n   /* First, work out if the hardware can do this at all, or\n      if it's too slow....  */\n-  if (! rs6000_compare_fp_p)\n+  if (!FLOAT_MODE_P (compare_mode))\n     {\n       if (TARGET_ISEL)\n \treturn rs6000_emit_int_cmove (dest, op, true_cond, false_cond);\n@@ -13781,13 +13750,13 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   rtx condition_rtx, cr;\n \n   /* All isel implementations thus far are 32-bits.  */\n-  if (GET_MODE (rs6000_compare_op0) != SImode)\n+  if (GET_MODE (XEXP (op, 0)) != SImode)\n     return 0;\n \n   /* We still have to do the compare, because isel doesn't do a\n      compare, it just looks at the CRx bits set by a previous compare\n      instruction.  */\n-  condition_rtx = rs6000_generate_compare (GET_CODE (op));\n+  condition_rtx = rs6000_generate_compare (op, SImode);\n   cr = XEXP (condition_rtx, 0);\n \n   if (GET_MODE (cr) == CCmode)"}, {"sha": "e65bf5d95dfa04bb27170f1ad9d3a7c7dc9d492f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1986,12 +1986,6 @@ do {\t\t\t\t\t\t\t\t\\\n /* Given a condition code and a mode, return the inverse condition.  */\n #define REVERSE_CONDITION(CODE, MODE) rs6000_reverse_condition (MODE, CODE)\n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-\n-extern GTY(()) rtx rs6000_compare_op0;\n-extern GTY(()) rtx rs6000_compare_op1;\n-extern int rs6000_compare_fp_p;\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "9d4a96051b751e9b45cbe43b02f6f7655d88b657", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 67, "deletions": 240, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -11897,262 +11897,90 @@\n ;; signed & unsigned, and one type of branch.\n ;;\n ;; Start with the DEFINE_EXPANDs to generate the rtl for compares, scc\n-;; insns, and branches.  We store the operands of compares until we see\n-;; how it is used.\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-        (compare (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n-  \t\t (match_operand:GPR 1 \"reg_or_short_operand\" \"\")))]\n+;; insns, and branches.\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(use (match_operator 0 \"rs6000_cbranch_operator\"\n+         [(match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+          (match_operand:GPR 2 \"reg_or_short_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n   \"\n {\n-  /* Take care of the possibility that operands[1] might be negative but\n+  /* Take care of the possibility that operands[2] might be negative but\n      this might be a logical operation.  That insn doesn't exist.  */\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && INTVAL (operands[1]) < 0)\n-    operands[1] = force_reg (<MODE>mode, operands[1]);\n-\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = operands[1];\n-  rs6000_compare_fp_p = 0;\n-  DONE;\n-}\")\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0)\n+    {\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+      operands[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]),\n+\t\t\t\t    GET_MODE (operands[0]),\n+\t\t\t\t    operands[1], operands[2]);\n+   }\n \n-(define_expand \"cmp<mode>\"\n-  [(set (cc0) (compare (match_operand:FP 0 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:FP 1 \"gpc_reg_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = operands[1];\n-  rs6000_compare_fp_p = 1;\n+  rs6000_emit_cbranch (<MODE>mode, operands);\n   DONE;\n }\")\n \n-(define_expand \"beq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (EQ, operands[0]); DONE; }\")\n-\n-(define_expand \"bne\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (NE, operands[0]); DONE; }\")\n-\n-(define_expand \"bge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (GE, operands[0]); DONE; }\")\n-\n-(define_expand \"bgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (GT, operands[0]); DONE; }\")\n-\n-(define_expand \"ble\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (LE, operands[0]); DONE; }\")\n-\n-(define_expand \"blt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (LT, operands[0]); DONE; }\")\n-\n-(define_expand \"bgeu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (GEU, operands[0]); DONE; }\")\n-\n-(define_expand \"bgtu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (GTU, operands[0]); DONE; }\")\n-\n-(define_expand \"bleu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (LEU, operands[0]); DONE; }\")\n-\n-(define_expand \"bltu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_cbranch (LTU, operands[0]); DONE; }\")\n-\n-(define_expand \"bunordered\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNORDERED, operands[0]); DONE; }\")\n-\n-(define_expand \"bordered\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (ORDERED, operands[0]); DONE; }\")\n-\n-(define_expand \"buneq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNEQ, operands[0]); DONE; }\")\n-\n-(define_expand \"bunge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNGE, operands[0]); DONE; }\")\n-\n-(define_expand \"bungt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNGT, operands[0]); DONE; }\")\n-\n-(define_expand \"bunle\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNLE, operands[0]); DONE; }\")\n-\n-(define_expand \"bunlt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (UNLT, operands[0]); DONE; }\")\n-\n-(define_expand \"bltgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_cbranch (LTGT, operands[0]); DONE; }\")\n-\n-;; For SNE, we would prefer that the xor/abs sequence be used for integers.\n-;; For SEQ, likewise, except that comparisons with zero should be done\n-;; with an scc insns.  However, due to the order that combine see the\n-;; resulting insns, we must, in fact, allow SEQ for integers.  Fail in\n-;; the cases we don't want to handle.\n-(define_expand \"seq\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_sCOND (EQ, operands[0]); DONE; }\")\n-\n-(define_expand \"sne\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+(define_expand \"cbranch<mode>4\"\n+  [(use (match_operator 0 \"rs6000_cbranch_operator\"\n+         [(match_operand:FP 1 \"gpc_reg_operand\" \"\")\n+          (match_operand:FP 2 \"gpc_reg_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n   \"\n {\n-  if (! rs6000_compare_fp_p)\n-    FAIL;\n-\n-  rs6000_emit_sCOND (NE, operands[0]);\n+  rs6000_emit_cbranch (<MODE>mode, operands);\n   DONE;\n }\")\n \n-;; A >= 0 is best done the portable way for A an integer.\n-(define_expand \"sge\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"rs6000_cbranch_operator\"\n+         [(match_operand:GPR 2 \"gpc_reg_operand\" \"\")\n+          (match_operand:GPR 3 \"reg_or_short_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n   \"\"\n   \"\n {\n-  if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n-    FAIL;\n-\n-  rs6000_emit_sCOND (GE, operands[0]);\n-  DONE;\n-}\")\n+  /* Take care of the possibility that operands[3] might be negative but\n+     this might be a logical operation.  That insn doesn't exist.  */\n+  if (GET_CODE (operands[3]) == CONST_INT\n+      && INTVAL (operands[3]) < 0)\n+    {\n+      operands[3] = force_reg (<MODE>mode, operands[3]);\n+      operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n+\t\t\t\t    GET_MODE (operands[1]),\n+\t\t\t\t    operands[2], operands[3]);\n+    }\n \n-;; A > 0 is best done using the portable sequence, so fail in that case.\n-(define_expand \"sgt\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n+  /* For SNE, we would prefer that the xor/abs sequence be used for integers.\n+     For SEQ, likewise, except that comparisons with zero should be done\n+     with an scc insns.  However, due to the order that combine see the\n+     resulting insns, we must, in fact, allow SEQ for integers.  Fail in\n+     the cases we don't want to handle or are best handled by portable\n+     code.  */\n+  if (GET_CODE (operands[1]) == NE)\n     FAIL;\n-\n-  rs6000_emit_sCOND (GT, operands[0]);\n-  DONE;\n-}\")\n-\n-;; A <= 0 is best done the portable way for A an integer.\n-(define_expand \"sle\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n+  if ((GET_CODE (operands[1]) == LT || GET_CODE (operands[1]) == LE\n+       || GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n+      && operands[3] == const0_rtx)\n     FAIL;\n-\n-  rs6000_emit_sCOND (LE, operands[0]);\n+  rs6000_emit_sCOND (<MODE>mode, operands);\n   DONE;\n }\")\n \n-;; A < 0 is best done in the portable way for A an integer.\n-(define_expand \"slt\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"rs6000_cbranch_operator\"\n+         [(match_operand:FP 2 \"gpc_reg_operand\" \"\")\n+          (match_operand:FP 3 \"gpc_reg_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n   \"\"\n   \"\n {\n-  if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n-    FAIL;\n-\n-  rs6000_emit_sCOND (LT, operands[0]);\n+  rs6000_emit_sCOND (<MODE>mode, operands);\n   DONE;\n }\")\n \n-(define_expand \"sgeu\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_sCOND (GEU, operands[0]); DONE; }\")\n-\n-(define_expand \"sgtu\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_sCOND (GTU, operands[0]); DONE; }\")\n-\n-(define_expand \"sleu\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_sCOND (LEU, operands[0]); DONE; }\")\n-\n-(define_expand \"sltu\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_sCOND (LTU, operands[0]); DONE; }\")\n-\n-(define_expand \"sunordered\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNORDERED, operands[0]); DONE; }\")\n-\n-(define_expand \"sordered\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (ORDERED, operands[0]); DONE; }\")\n-\n-(define_expand \"suneq\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNEQ, operands[0]); DONE; }\")\n-\n-(define_expand \"sunge\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNGE, operands[0]); DONE; }\")\n-\n-(define_expand \"sungt\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNGT, operands[0]); DONE; }\")\n-\n-(define_expand \"sunle\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNLE, operands[0]); DONE; }\")\n-\n-(define_expand \"sunlt\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (UNLT, operands[0]); DONE; }\")\n-\n-(define_expand \"sltgt\"\n-  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n-  \"! (TARGET_HARD_FLOAT && !TARGET_FPRS)\"\n-  \"{ rs6000_emit_sCOND (LTGT, operands[0]); DONE; }\")\n \n (define_expand \"stack_protect_set\"\n   [(match_operand 0 \"memory_operand\" \"\")\n@@ -12195,16 +12023,16 @@\n    (match_operand 2 \"\" \"\")]\n   \"\"\n {\n+  rtx test, op0, op1;\n #ifdef TARGET_THREAD_SSP_OFFSET\n   rtx tlsreg = gen_rtx_REG (Pmode, TARGET_64BIT ? 13 : 2);\n   rtx addr = gen_rtx_PLUS (Pmode, tlsreg, GEN_INT (TARGET_THREAD_SSP_OFFSET));\n   operands[1] = gen_rtx_MEM (Pmode, addr);\n #endif\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, operands[1]),\n-\t\t\t\t       UNSPEC_SP_TEST);\n-  rs6000_compare_fp_p = 0;\n-  emit_jump_insn (gen_beq (operands[2]));\n+  op0 = operands[0];\n+  op1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, operands[1]), UNSPEC_SP_TEST);\n+  test = gen_rtx_EQ (VOIDmode, op0, op1);\n+  emit_jump_insn (gen_cbranchsi4 (test, op0, op1, operands[2]));\n   DONE;\n })\n \n@@ -14775,17 +14603,16 @@\n   \"{t 31,0,0|trap}\"\n   [(set_attr \"type\" \"trap\")])\n \n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n-\t\t\t    [(match_dup 2) (match_dup 3)])\n-\t    (match_operand 1 \"const_int_operand\" \"\"))]\n+(define_expand \"ctrap<mode>4\"\n+  [(trap_if (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t    [(match_operand:GPR 1 \"register_operand\")\n+\t\t\t     (match_operand:GPR 2 \"reg_or_short_operand\")])\n+\t    (match_operand 3 \"zero_constant\" \"\"))]\n   \"\"\n-  \"if (rs6000_compare_fp_p || operands[1] != const0_rtx) FAIL;\n-   operands[2] = rs6000_compare_op0;\n-   operands[3] = rs6000_compare_op1;\")\n+  \"\")\n \n (define_insn \"\"\n-  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n+  [(trap_if (match_operator 0 \"ordered_comparison_operator\"\n                             [(match_operand:GPR 1 \"register_operand\" \"r\")\n                              (match_operand:GPR 2 \"reg_or_short_operand\" \"rI\")])\n \t    (const_int 0))]"}, {"sha": "d09c9b3e161c1199db7e137af5c19ef53177a0f0", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -189,6 +189,14 @@\n   return (s390_compare_and_branch_condition_mask (op) >= 0);\n })\n \n+;; Return nonzero if OP is a valid comparison operator for the\n+;; cstore expanders -- respectively cstorecc4 and integer cstore.\n+(define_predicate \"s390_eqne_operator\"\n+  (match_code \"eq, ne\"))\n+\n+(define_predicate \"s390_scond_operator\"\n+  (match_code \"ltu, gtu, leu, geu\"))\n+\n ;; Return nonzero if OP is a valid comparison operator\n ;; for an ALC condition.\n "}, {"sha": "17891c6492ff5f20f139159c96b686f7a12ddc2e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -223,11 +223,6 @@ struct processor_costs z10_cost =\n \n extern int reload_completed;\n \n-/* Save information from a \"cmpxx\" operation until the branch or scc is\n-   emitted.  A pair of a MODE_CC register and a const0_rtx if a compare\n-   has been emitted already.  */\n-rtx s390_compare_op0, s390_compare_op1;\n-\n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n    form\n@@ -7747,15 +7742,11 @@ s390_emit_prologue (void)\n \t      rtx t = gen_rtx_AND (Pmode, stack_pointer_rtx,\n \t\t\t\t   GEN_INT (stack_check_mask));\n \t      if (TARGET_64BIT)\n-\t\tgen_cmpdi (t, const0_rtx);\n+\t        emit_insn (gen_ctrapdi4 (gen_rtx_EQ (VOIDmode, t, const0_rtx),\n+\t\t\t\t         t, const0_rtx, const0_rtx));\n \t      else\n-\t\tgen_cmpsi (t, const0_rtx);\n-\n-\t      emit_insn (gen_conditional_trap (gen_rtx_EQ (CCmode,\n-\t\t\t\t\t\t\t   gen_rtx_REG (CCmode,\n-\t\t\t\t\t\t\t\t     CC_REGNUM),\n-\t\t\t\t\t\t\t   const0_rtx),\n-\t\t\t\t\t       const0_rtx));\n+\t        emit_insn (gen_ctrapsi4 (gen_rtx_EQ (VOIDmode, t, const0_rtx),\n+\t\t\t\t         t, const0_rtx, const0_rtx));\n \t    }\n   \t}\n "}, {"sha": "b25418571702c661a10dba36f551289b86338621", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -803,12 +803,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define CANONICALIZE_COMPARISON(CODE, OP0, OP1) \\\n   s390_canonicalize_comparison (&(CODE), &(OP0), &(OP1))\n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n-\n-\n /* Relative costs of operations.  */\n \n /* On s390, copy between fprs and gprs is expensive.  */"}, {"sha": "7c9a2b281005b86581c591d4bfab2321e59f77b6", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 106, "deletions": 102, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -354,13 +354,6 @@\n (define_mode_iterator INT [(DI \"TARGET_64BIT\") SI HI QI])\n (define_mode_iterator INTALL [TI DI SI HI QI])\n \n-;; This iterator allows to unify all 'bCOND' expander patterns.\n-(define_code_iterator COMPARE [eq ne gt gtu lt ltu ge geu le leu unordered \n-\t\t            ordered uneq unlt ungt unle unge ltgt])\n-\n-;; This iterator allows to unify all 'sCOND' patterns.\n-(define_code_iterator SCOND [ltu gtu leu geu])\n-\n ;; This iterator allows some 'ashift' and 'lshiftrt' pattern to be defined from\n ;; the same template.\n (define_code_iterator SHIFT [ashift lshiftrt])\n@@ -493,39 +486,6 @@\n ;;- Compare instructions.\n ;;\n \n-(define_expand \"cmp<mode>\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:GPR 0 \"register_operand\" \"\")\n-                    (match_operand:GPR 1 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  s390_compare_op0 = operands[0];\n-  s390_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:FP 0 \"register_operand\" \"\")\n-                    (match_operand:FP 1 \"general_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n-{\n-  s390_compare_op0 = operands[0];\n-  s390_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmpcc\"\n-  [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand 0 \"cc_reg_operand\" \"\")\n-                    (match_operand 1 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  s390_compare_op0 = operands[0];\n-  s390_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n ; Test-under-Mask instructions\n \n (define_insn \"*tmqi_mem\"\n@@ -3812,9 +3772,9 @@\n      TD -> DI convert afterwards.  */\n   emit_insn (gen_extendddtd2 (temp, operands[1]));\n   temp = force_reg (TDmode, temp);\n-  emit_insn (gen_cmptd (temp,\n-\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode)));\n-  emit_jump_insn (gen_blt (label1));\n+  emit_cmp_and_jump_insns (temp,\n+\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode),\n+\tLT, NULL_RTX, VOIDmode, 0, label1);\n   emit_insn (gen_subtd3 (temp, temp,\n \tCONST_DOUBLE_FROM_REAL_VALUE (sub, TDmode)));\n   emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp, GEN_INT (11)));\n@@ -3840,9 +3800,9 @@\n   decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n   decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n \n-  emit_insn (gen_cmptd (operands[1],\n-\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode)));\n-  emit_jump_insn (gen_blt (label1));\n+  emit_cmp_and_jump_insns (operands[1],\n+\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode),\n+\tLT, NULL_RTX, VOIDmode, 0, label1);\n   emit_insn (gen_subtd3 (temp, operands[1],\n \tCONST_DOUBLE_FROM_REAL_VALUE (sub, TDmode)));\n   emit_insn (gen_fix_trunctddi2_dfp (operands[0], temp, GEN_INT (11)));\n@@ -3873,9 +3833,9 @@\n   real_2expN (&cmp, GET_MODE_BITSIZE(<GPR:MODE>mode) - 1, <BFP:MODE>mode);\n   real_2expN (&sub, GET_MODE_BITSIZE(<GPR:MODE>mode), <BFP:MODE>mode);\n \n-  emit_insn (gen_cmp<BFP:mode> (operands[1],\n-\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, <BFP:MODE>mode)));\n-  emit_jump_insn (gen_blt (label1));\n+  emit_cmp_and_jump_insns (operands[1],\n+\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, <BFP:MODE>mode),\n+\tLT, NULL_RTX, VOIDmode, 0, label1);\n   emit_insn (gen_sub<BFP:mode>3 (temp, operands[1],\n \tCONST_DOUBLE_FROM_REAL_VALUE (sub, <BFP:MODE>mode)));\n   emit_insn (gen_fix_trunc<BFP:mode><GPR:mode>2_bfp (operands[0], temp,\n@@ -5074,7 +5034,7 @@\n    (match_operand:GPR 3 \"const_int_operand\" \"\")]\n   \"TARGET_CPU_ZARCH\"\n   \"if (!s390_expand_addcc (GET_CODE (operands[1]),\n-\t\t\t   s390_compare_op0, s390_compare_op1,\n+\t\t\t   XEXP (operands[1], 0), XEXP (operands[1], 1),\n \t\t\t   operands[0], operands[2],\n \t\t\t   operands[3])) FAIL; DONE;\")\n \n@@ -5114,31 +5074,29 @@\n   \"\")\n \n \n-(define_expand \"s<code>\"\n+(define_expand \"cstore<mode>4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(SCOND (match_dup 0)\n-\t       (match_dup 0)))]\n+        (match_operator:SI 1 \"s390_scond_operator\"\n+  \t [(match_operand:GPR 2 \"register_operand\" \"\")\n+          (match_operand:GPR 3 \"general_operand\" \"\")]))]\n   \"TARGET_CPU_ZARCH\"\n-  \"if (!s390_expand_addcc (<CODE>, s390_compare_op0, s390_compare_op1,\n+  \"if (!s390_expand_addcc (GET_CODE (operands[1]), operands[2], operands[3],\n \t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n \n-(define_expand \"seq\"\n+(define_expand \"cstorecc4\"\n   [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-          (match_dup 1))\n-     (clobber (reg:CC CC_REGNUM))])\n-   (parallel\n-    [(set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (match_operator:SI 1 \"s390_eqne_operator\"\n+           [(match_operand:CCZ1 2 \"register_operand\")\n+\t    (match_operand 3 \"const0_operand\")]))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n-{\n-  if (GET_MODE (s390_compare_op0) != CCZ1mode)\n-    FAIL;\n-  operands[1] = s390_emit_compare (NE, s390_compare_op0, s390_compare_op1);\n-  PUT_MODE (operands[1], SImode);\n-})\n+  \"emit_insn (gen_sne (operands[0], operands[2]));\n+   if (GET_CODE (operands[1]) == EQ)\n+     emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n+   DONE;\")\n \n-(define_insn_and_split \"*sne\"\n+(define_insn_and_split \"sne\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ne:SI (match_operand:CCZ1 1 \"register_operand\" \"0\")\n \t       (const_int 0)))\n@@ -5566,8 +5524,8 @@\n \n \t  operands[1] = make_safe_from (operands[1], operands[0]);\n           emit_move_insn (operands[0], const0_rtx);\n-          emit_insn (gen_cmpsi (operands[1], operands[2]));\n-          emit_jump_insn (gen_bltu (label1));\n+\t  emit_cmp_and_jump_insns (operands[1], operands[2], LT, NULL_RTX,\n+\t\t\t\t   SImode, 1, label1);\n           emit_move_insn (operands[0], const1_rtx);\n           emit_label (label1);\n         }\n@@ -5598,12 +5556,12 @@\n       operands[2] = make_safe_from (operands[2], operands[0]);\n \n       emit_move_insn (operands[0], const0_rtx);\n-      emit_insn (gen_cmpsi (operands[2], operands[1]));\n-      emit_jump_insn (gen_bgtu (label3));\n-      emit_insn (gen_cmpsi (operands[2], const0_rtx));\n-      emit_jump_insn (gen_blt (label2));\n-      emit_insn (gen_cmpsi (operands[2], const1_rtx));\n-      emit_jump_insn (gen_beq (label1));\n+      emit_cmp_and_jump_insns (operands[2], operands[1], GT, NULL_RTX,\n+\t\t\t       SImode, 1, label3);\n+      emit_cmp_and_jump_insns (operands[2], const0_rtx, LT, NULL_RTX,\n+\t\t\t       SImode, 0, label2);\n+      emit_cmp_and_jump_insns (operands[2], const1_rtx, EQ, NULL_RTX,\n+\t\t\t       SImode, 0, label1);\n       emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n       insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n \t\t\t\t\t operands[2]));\n@@ -5652,8 +5610,8 @@\n \n           operands[1] = make_safe_from (operands[1], operands[0]);\n \t  emit_move_insn (operands[0], operands[1]);\n-          emit_insn (gen_cmpsi (operands[0], operands[2]));\n-          emit_jump_insn (gen_bltu (label1));\n+          emit_cmp_and_jump_insns (operands[0], operands[2], LT, NULL_RTX,\n+\t\t\t           SImode, 1, label1);\n \t  emit_insn (gen_abssi2 (operands[0], operands[2]));\n           emit_insn (gen_addsi3 (operands[0], operands[0], operands[1]));\n           emit_label (label1);\n@@ -5685,12 +5643,12 @@\n       operands[2] = make_safe_from (operands[2], operands[0]);\n \n       emit_move_insn(operands[0], operands[1]);\n-      emit_insn (gen_cmpsi (operands[2], operands[1]));\n-      emit_jump_insn (gen_bgtu (label3));\n-      emit_insn (gen_cmpsi (operands[2], const0_rtx));\n-      emit_jump_insn (gen_blt (label2));\n-      emit_insn (gen_cmpsi (operands[2], const1_rtx));\n-      emit_jump_insn (gen_beq (label1));\n+      emit_cmp_and_jump_insns (operands[2], operands[1], GT, NULL_RTX,\n+\t\t\t       SImode, 1, label3);\n+      emit_cmp_and_jump_insns (operands[2], const0_rtx, LT, NULL_RTX,\n+\t\t\t       SImode, 0, label2);\n+      emit_cmp_and_jump_insns (operands[2], const1_rtx, EQ, NULL_RTX,\n+\t\t\t       SImode, 0, label1);\n       emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n       insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n \t\t\t\t\t operands[2]));\n@@ -7359,15 +7317,42 @@\n ;; Branch instruction patterns.\n ;;\n \n-(define_expand \"b<code>\"\n+(define_expand \"cbranch<mode>4\"\n   [(set (pc)\n-        (if_then_else (COMPARE (match_operand 0 \"\" \"\")\n-                               (const_int 0))\n-                      (match_dup 0)\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+        \t       [(match_operand:GPR 1 \"register_operand\" \"\")\n+                        (match_operand:GPR 2 \"general_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"s390_emit_jump (operands[0],\n-    s390_emit_compare (<CODE>, s390_compare_op0, s390_compare_op1)); DONE;\")\n+  \"s390_emit_jump (operands[3],\n+    s390_emit_compare (GET_CODE (operands[0]), operands[1], operands[2]));\n+   DONE;\")\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n+        \t       [(match_operand:FP 1 \"register_operand\" \"\")\n+                        (match_operand:FP 2 \"general_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"s390_emit_jump (operands[3],\n+    s390_emit_compare (GET_CODE (operands[0]), operands[1], operands[2]));\n+   DONE;\")\n+\n+(define_expand \"cbranchcc4\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"s390_eqne_operator\"\n+        \t       [(match_operand 1 \"cc_reg_operand\" \"\")\n+                        (match_operand 2 \"const0_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"s390_emit_jump (operands[3],\n+    s390_emit_compare (GET_CODE (operands[0]), operands[1], operands[2]));\n+   DONE;\")\n+\n \n \n ;;\n@@ -7506,18 +7491,36 @@\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"  \"branch\")])\n \n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operand 0 \"comparison_operator\" \"\")\n-\t    (match_operand 1 \"general_operand\" \"\"))]\n+(define_expand \"ctrap<mode>4\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+             [(match_operand:GPR 1 \"register_operand\" \"\")\n+              (match_operand:GPR 2 \"general_operand\" \"\")])\n+\t     (match_operand 3 \"const0_operand\" \"\"))]\n   \"\"\n-{\n-  if (operands[1] != const0_rtx) FAIL;\n-  operands[0] = s390_emit_compare (GET_CODE (operands[0]),\n-                                   s390_compare_op0, s390_compare_op1);\n-})\n+  {\n+    rtx cond = s390_emit_compare (GET_CODE (operands[0]),\n+                                  operands[1], operands[2]);\n+    emit_insn (gen_condtrap (cond, XEXP (cond, 0)));\n+    DONE;\n+  })\n+\n+(define_expand \"ctrap<mode>4\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+             [(match_operand:FP 1 \"register_operand\" \"\")\n+              (match_operand:FP 2 \"general_operand\" \"\")])\n+\t     (match_operand 3 \"const0_operand\" \"\"))]\n+  \"\"\n+  {\n+    rtx cond = s390_emit_compare (GET_CODE (operands[0]),\n+                                  operands[1], operands[2]);\n+    emit_insn (gen_condtrap (cond, XEXP (cond, 0)));\n+    DONE;\n+  })\n \n-(define_insn \"*trap\"\n-  [(trap_if (match_operator 0 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n+(define_insn \"condtrap\"\n+  [(trap_if (match_operator 0 \"s390_comparison\"\n+             [(match_operand 1 \"cc_reg_operand\" \"c\")\n+              (const_int 0)])\n \t    (const_int 0))]\n   \"\"\n   \"j%C0\\t.+2\";\n@@ -8665,6 +8668,7 @@\n    (match_operand 2 \"\" \"\")]\n   \"\"\n {\n+  rtx cc_reg, test;\n #ifdef TARGET_THREAD_SSP_OFFSET\n   operands[1]\n     = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, s390_get_thread_pointer (),\n@@ -8675,9 +8679,9 @@\n   else\n     emit_insn (gen_stack_protect_testsi (operands[0], operands[1]));\n \n-  s390_compare_op0 = gen_rtx_REG (CCZmode, CC_REGNUM);\n-  s390_compare_op1 = const0_rtx;\n-  emit_jump_insn (gen_beq (operands[2]));\n+  cc_reg = gen_rtx_REG (CCZmode, CC_REGNUM);\n+  test = gen_rtx_EQ (VOIDmode, cc_reg, const0_rtx);\n+  emit_jump_insn (gen_cbranchcc4 (test, cc_reg, const0_rtx, operands[2]));\n   DONE;\n })\n "}, {"sha": "e042dc1b7d31cdea9fd7d4fa4d3ac1f119687f63", "filename": "gcc/config/score/score-conv.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-conv.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -22,11 +22,6 @@\n \n extern int target_flags;\n \n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-extern GTY(()) rtx cmp_op0;\n-extern GTY(()) rtx cmp_op1;\n-\n #define GP_REG_FIRST                    0U\n #define GP_REG_LAST                     31U\n #define GP_REG_NUM                      (GP_REG_LAST - GP_REG_FIRST + 1U)"}, {"sha": "204dc1876a46eb8033d9e045ca811c1780972edd", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -25,7 +25,6 @@ enum score_mem_unit {SCORE_BYTE = 0, SCORE_HWORD = 1, SCORE_WORD = 2};\n \n #define SCORE_ALIGN_UNIT(V, UNIT)   !(V & ((1 << UNIT) - 1))\n \n-extern void score_gen_cmp (enum machine_mode mode);\n extern void score_prologue (void);\n extern void score_epilogue (int sibcall_p);\n extern void score_call (rtx *ops, bool sib);"}, {"sha": "e517eeb6608b7dcb5ac6fa2ef27490f264357a15", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -117,7 +117,6 @@\n #define TARGET_ADDRESS_COST             score_address_cost\n \n struct extern_list *extern_head = 0;\n-rtx cmp_op0, cmp_op1;\n \n /* default 0 = NO_REGS  */\n enum reg_class score_char_to_class[256];\n@@ -698,17 +697,6 @@ score_epilogue (int sibcall_p)\n   gcc_unreachable ();\n }\n \n-void\n-score_gen_cmp (enum machine_mode mode)\n-{\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_gen_cmp (mode);\n-  else if (TARGET_SCORE3)\n-    return score3_gen_cmp (mode);\n-\n-  gcc_unreachable ();\n-}\n-\n /* Call and sibcall pattern all need call this function.  */\n void\n score_call (rtx *ops, bool sib)\n@@ -1118,7 +1106,7 @@ score_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n   HOST_WIDE_INT loop_mov_bytes;\n   HOST_WIDE_INT iteration = 0;\n   HOST_WIDE_INT head_length = 0, leftover;\n-  rtx label, src_reg, dst_reg, final_dst;\n+  rtx label, src_reg, dst_reg, final_dst, test;\n \n   bool gen_loop_head = (src_align < BITS_PER_WORD\n                         || dst_align < BITS_PER_WORD);\n@@ -1158,8 +1146,8 @@ score_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n   score_block_move_loop_body (dst_reg, dst_align,\n                             src_reg, src_align, loop_mov_bytes);\n \n-  emit_insn (gen_cmpsi (dst_reg, final_dst));\n-  emit_jump_insn (gen_bne (label));\n+  test = gen_rtx_NE (VOIDmode, dst_reg, final_dst);\n+  emit_jump_insn (gen_cbranchsi4 (test, dst_reg, final_dst, label));\n \n   score_block_move_loop_foot (dst_reg, dst_align,\n                             src_reg, src_align, leftover);"}, {"sha": "b426e14e0acce6560e97024532a1c083830e6b62", "filename": "gcc/config/score/score.md", "status": "modified", "additions": 14, "deletions": 110, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -2175,6 +2175,20 @@\n    (set_attr \"length\" \"4,4\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_expand \"cbranchsi4\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_operand:SI 1 \"score_register_operand\" \"\")\n+                    (match_operand:SI 2 \"arith_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else\n+\t (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t [(reg:CC CC_REGNUM)\n+\t\t \t  (const_int 0)]) \n+         (label_ref (match_operand 3 \"\" \"\"))\n+         (pc)))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"cbrancheqz\"\n   [(set (pc) (if_then_else\n               (eq (match_operand:SI 0 \"score_register_operand\" \"d\")\n@@ -2259,16 +2273,6 @@\n        (const_int 4)\n        (const_int 6)))])\n \n-(define_expand \"cmpsi\"\n-  [(match_operand:SI 0 \"score_register_operand\")\n-   (match_operand:SI 1 \"arith_operand\")]\n-  \"\"\n-{\n-  cmp_op0 = operands[0];\n-  cmp_op1 = operands[1];\n-  DONE;\n-})\n-\n (define_insn \"cmpsi_nz_score7\"\n   [(set (reg:CC_NZ CC_REGNUM)\n         (compare:CC_NZ (match_operand:SI 0 \"register_operand\" \"d,e,d\")\n@@ -2375,106 +2379,6 @@\n    (set_attr \"up_c\" \"yes\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"beq\"\n-  [(set (pc)\n-        (if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-        (if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-        (if_then_else (gt (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-        (if_then_else (le (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-        (if_then_else (ge (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-        (if_then_else (lt (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-        (if_then_else (gtu (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-        (if_then_else (leu (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-        (if_then_else (geu (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-        (if_then_else (ltu (reg:CC CC_REGNUM) (const_int 0))\n-                      (label_ref (match_operand 0 \"\" \"\"))\n-                      (pc)))]\n-  \"\"\n-{\n-  score_gen_cmp (CCmode);\n-})\n-\n (define_insn \"*branch_n_score7\"\n   [(set (pc)\n         (if_then_else"}, {"sha": "3ddc3b8c7985855141ec0999218f1b8d1419e64f", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -54,9 +54,6 @@\n #define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n #define INS_BUF_SZ                128\n \n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-extern rtx cmp_op0, cmp_op1;\n extern enum reg_class score_char_to_class[256];\n \n static int score3_sdata_max;\n@@ -1647,13 +1644,6 @@ score3_epilogue (int sibcall_p)\n     emit_jump_insn (gen_return_internal_score3 (gen_rtx_REG (Pmode, RA_REGNUM)));\n }\n \n-void\n-score3_gen_cmp (enum machine_mode mode)\n-{\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n-}\n-\n /* Return true if X is a symbolic constant that can be calculated in\n    the same way as a bare symbol.  If it is, store the type of the\n    symbol in *SYMBOL_TYPE.  */\n@@ -1692,7 +1682,8 @@ score3_movsicc (rtx *ops)\n \n   mode = score3_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n   emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n+\t\t\t\t\t   XEXP (ops[1], 1))));\n }\n \n /* Call and sibcall pattern all need call this function.  */"}, {"sha": "d718d12e8d95a60d0b8cae8342d2515313310483", "filename": "gcc/config/score/score3.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -138,7 +138,6 @@ extern enum machine_mode\n score3_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n extern void score3_prologue (void);\n extern void score3_epilogue (int sibcall_p);\n-extern void score3_gen_cmp (enum machine_mode mode);\n extern void score3_call (rtx *ops, bool sib);\n extern void score3_call_value (rtx *ops, bool sib);\n extern void score3_movsicc (rtx *ops);"}, {"sha": "661cae73bd395e2dcc58229ac08864e2694538da", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -54,9 +54,6 @@\n #define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n #define INS_BUF_SZ                128\n \n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-extern rtx cmp_op0, cmp_op1;\n extern enum reg_class score_char_to_class[256];\n \n static int score7_sdata_max;\n@@ -1531,13 +1528,6 @@ score7_epilogue (int sibcall_p)\n     emit_jump_insn (gen_return_internal_score7 (gen_rtx_REG (Pmode, RA_REGNUM)));\n }\n \n-void\n-score7_gen_cmp (enum machine_mode mode)\n-{\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n-}\n-\n /* Return true if X is a symbolic constant that can be calculated in\n    the same way as a bare symbol.  If it is, store the type of the\n    symbol in *SYMBOL_TYPE.  */\n@@ -1576,7 +1566,8 @@ score7_movsicc (rtx *ops)\n \n   mode = score7_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n   emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n+\t\t\t\t\t   XEXP (ops[1], 1))));\n }\n \n /* Call and sibcall pattern all need call this function.  */"}, {"sha": "0c0a3b20f8efa18d98b645e22b25137db63f7c05", "filename": "gcc/config/score/score7.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -139,7 +139,6 @@ extern enum machine_mode score7_select_cc_mode (enum rtx_code op,\n                                                 rtx y);\n extern void score7_prologue (void);\n extern void score7_epilogue (int sibcall_p);\n-extern void score7_gen_cmp (enum machine_mode mode);\n extern void score7_call (rtx *ops, bool sib);\n extern void score7_call_value (rtx *ops, bool sib);\n extern void score7_movsicc (rtx *ops);"}, {"sha": "ea924d830f5b0ed3b036cf9b17db36598b2471f8", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -552,6 +552,17 @@\n   (and (match_code \"minus,div\")\n        (match_test \"GET_MODE (op) == mode\")))\n \n+;; UNORDERED is only supported on SHMEDIA.\n+\n+(define_predicate \"sh_float_comparison_operator\"\n+  (ior (match_operand 0 \"ordered_comparison_operator\")\n+       (and (match_test \"TARGET_SHMEDIA\")\n+\t    (match_code \"unordered\"))))\n+\n+(define_predicate \"shmedia_cbranch_comparison_operator\"\n+  (ior (match_operand 0 \"equality_comparison_operator\")\n+       (match_operand 0 \"greater_comparison_operator\")))\n+\n ;; TODO: Add a comment here.\n \n (define_predicate \"sh_const_vec\""}, {"sha": "0c89f17b15d9870e6b79a42cd44c10bf93a6816f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -41,7 +41,6 @@ enum sh_function_kind {\n extern rtx sh_fsca_sf2int (void);\n extern rtx sh_fsca_df2int (void);\n extern rtx sh_fsca_int2sf (void);\n-extern struct rtx_def *prepare_scc_operands (enum rtx_code);\n \n /* Declare functions defined in sh.c and used in templates.  */\n \n@@ -72,7 +71,10 @@ extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);\n extern bool expand_cbranchdi4 (rtx *operands, enum rtx_code comparison);\n-extern void from_compare (rtx *, int);\n+extern void sh_emit_scc_to_t (enum rtx_code, rtx, rtx);\n+extern rtx sh_emit_cheap_store_flag (enum machine_mode, enum rtx_code, rtx, rtx);\n+extern void sh_emit_compare_and_branch (rtx *, enum machine_mode);\n+extern void sh_emit_compare_and_set (rtx *, enum machine_mode);\n extern int shift_insns_rtx (rtx);\n extern void gen_ashift (int, int, rtx);\n extern void gen_ashift_hi (int, int, rtx);\n@@ -117,7 +119,7 @@ extern int sh_insn_length_adjustment (rtx);\n extern int sh_can_redirect_branch (rtx, rtx);\n extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n-extern int sh_expand_t_scc (enum rtx_code code, rtx target);\n+extern int sh_expand_t_scc (rtx *);\n extern rtx sh_gen_truncate (enum machine_mode, rtx, int);\n extern bool sh_vector_mode_supported_p (enum machine_mode);\n #endif /* RTX_CODE */"}, {"sha": "e25cd42e871f8aaa43895d5669c8e36cbe1ed16a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 220, "deletions": 61, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -105,12 +105,6 @@ static int skip_cycles = 0;\n    and returned from sh_reorder2.  */\n static short cached_can_issue_more;\n \n-/* Saved operands from the last compare to use when we generate an scc\n-   or bcc insn.  */\n-\n-rtx sh_compare_op0;\n-rtx sh_compare_op1;\n-\n /* Provides the class number of the smallest class containing\n    reg number.  */\n \n@@ -1677,10 +1671,26 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   return true;\n }\n \n+/* Emit INSN, possibly in a PARALLEL with an USE of fpscr for SH4.  */\n+\n+static void\n+sh_emit_set_t_insn (rtx insn, enum machine_mode mode)\n+{\n+  if ((TARGET_SH4 || TARGET_SH2A) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      insn = gen_rtx_PARALLEL (VOIDmode,\n+\t               gen_rtvec (2, insn,\n+\t\t\t          gen_rtx_USE (VOIDmode, get_fpscr_rtx ())));\n+      (mode == SFmode ? emit_sf_insn : emit_df_insn) (insn);\n+    }\n+  else\n+    emit_insn (insn);\n+}\n+\n /* Prepare the operands for an scc instruction; make sure that the\n-   compare has been done.  */\n-rtx\n-prepare_scc_operands (enum rtx_code code)\n+   compare has been done and the result is in T_REG.  */\n+void\n+sh_emit_scc_to_t (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx t_reg = gen_rtx_REG (SImode, T_REG);\n   enum rtx_code oldcode = code;\n@@ -1709,77 +1719,222 @@ prepare_scc_operands (enum rtx_code code)\n     }\n   if (code != oldcode)\n     {\n-      rtx tmp = sh_compare_op0;\n-      sh_compare_op0 = sh_compare_op1;\n-      sh_compare_op1 = tmp;\n+      rtx tmp = op0;\n+      op0 = op1;\n+      op1 = tmp;\n     }\n \n-  mode = GET_MODE (sh_compare_op0);\n+  mode = GET_MODE (op0);\n   if (mode == VOIDmode)\n-    mode = GET_MODE (sh_compare_op1);\n+    mode = GET_MODE (op1);\n \n-  sh_compare_op0 = force_reg (mode, sh_compare_op0);\n+  op0 = force_reg (mode, op0);\n   if ((code != EQ && code != NE\n-       && (sh_compare_op1 != const0_rtx\n+       && (op1 != const0_rtx\n \t   || code == GTU  || code == GEU || code == LTU || code == LEU))\n-      || (mode == DImode && sh_compare_op1 != const0_rtx)\n+      || (mode == DImode && op1 != const0_rtx)\n       || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n-    sh_compare_op1 = force_reg (mode, sh_compare_op1);\n+    op1 = force_reg (mode, op1);\n \n-  if ((TARGET_SH4 || TARGET_SH2A) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    (mode == SFmode ? emit_sf_insn : emit_df_insn)\n-     (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n-\t\tgen_rtx_SET (VOIDmode, t_reg,\n-\t\t\t     gen_rtx_fmt_ee (code, SImode,\n-\t\t\t\t\t     sh_compare_op0, sh_compare_op1)),\n-\t\tgen_rtx_USE (VOIDmode, get_fpscr_rtx ()))));\n-  else\n-    emit_insn (gen_rtx_SET (VOIDmode, t_reg,\n-\t\t\t    gen_rtx_fmt_ee (code, SImode,\n-\t\t\t\t\t    sh_compare_op0, sh_compare_op1)));\n+  sh_emit_set_t_insn (gen_rtx_SET (VOIDmode, t_reg,\n+\t\t\t           gen_rtx_fmt_ee (code, SImode, op0, op1)),\n+\t\t      mode);\n+}\n \n-  return t_reg;\n+rtx\n+sh_emit_cheap_store_flag (enum machine_mode mode, enum rtx_code code,\n+\t\t\t  rtx op0, rtx op1)\n+{\n+  rtx target = gen_reg_rtx (SImode);\n+  rtx tmp;\n+\n+  gcc_assert (TARGET_SHMEDIA);\n+  switch (code)\n+    {\n+    case EQ:\n+    case GT:\n+    case LT:\n+    case UNORDERED:\n+    case GTU:\n+    case LTU:\n+      tmp = gen_rtx_fmt_ee (code, SImode, op0, op1);\n+      emit_insn (gen_cstore4_media (target, tmp, op0, op1));\n+      code = NE;\n+      break;\n+\n+    case NE:\n+    case GE:\n+    case LE:\n+    case ORDERED:\n+    case GEU:\n+    case LEU:\n+      tmp = gen_rtx_fmt_ee (reverse_condition (code), mode, op0, op1);\n+      emit_insn (gen_cstore4_media (target, tmp, op0, op1));\n+      code = EQ;\n+      break;\n+\n+    case UNEQ:\n+    case UNGE:\n+    case UNGT:\n+    case UNLE:\n+    case UNLT:\n+    case LTGT:\n+      return NULL_RTX;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (mode == DImode)\n+    {\n+      rtx t2 = gen_reg_rtx (DImode);\n+      emit_insn (gen_extendsidi2 (t2, target));\n+      target = t2;\n+    }\n+\n+  return gen_rtx_fmt_ee (code, VOIDmode, target, const0_rtx);\n }\n \n /* Called from the md file, set up the operands of a compare instruction.  */\n \n void\n-from_compare (rtx *operands, int code)\n+sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n {\n-  enum machine_mode mode = GET_MODE (sh_compare_op0);\n-  rtx insn;\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (sh_compare_op1);\n-  if (code != EQ\n-      || mode == DImode\n-      || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  enum rtx_code branch_code;\n+  rtx op0 = operands[1];\n+  rtx op1 = operands[2];\n+  rtx insn, tem;\n+  bool need_ccmpeq = false;\n+\n+  if (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n-      /* Force args into regs, since we can't use constants here.  */\n-      sh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx\n-\t  || code == GTU  || code == GEU\n-\t  || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n+      op0 = force_reg (mode, op0);\n+      op1 = force_reg (mode, op1);\n     }\n-  if (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT && code == GE)\n+  else\n     {\n-      from_compare (operands, GT);\n-      insn = gen_ieee_ccmpeqsf_t (sh_compare_op0, sh_compare_op1);\n+      if (code != EQ || mode == DImode)\n+        {\n+          /* Force args into regs, since we can't use constants here.  */\n+          op0 = force_reg (mode, op0);\n+          if (op1 != const0_rtx || code == GTU  || code == GEU)\n+\t    op1 = force_reg (mode, op1);\n+        }\n     }\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      if (code == LT\n+\t  || (code == LE && TARGET_IEEE && TARGET_SH2E)\n+\t  || (code == GE && !(TARGET_IEEE && TARGET_SH2E)))\n+\t{\n+\t  tem = op0, op0 = op1, op1 = tem;\n+\t  code = swap_condition (code);\n+\t}\n+\n+      /* GE becomes fcmp/gt+fcmp/eq, for SH2E and TARGET_IEEE only.  */\n+      if (code == GE)\n+\t{\n+\t  gcc_assert (TARGET_IEEE && TARGET_SH2E);\n+          need_ccmpeq = true;\n+\t  code = GT;\n+\t}\n+\n+      /* Now we can have EQ, NE, GT, LE.  NE and LE are then transformed\n+\t to EQ/GT respectively.  */\n+      gcc_assert (code == EQ || code == GT || code == NE || code == LE);\n+    }\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case GT:\n+    case GE:\n+    case GTU:\n+    case GEU:\n+      branch_code = code;\n+      break;\n+    case NE:\n+    case LT:\n+    case LE:\n+    case LTU:\n+    case LEU:\n+      branch_code = reverse_condition (code);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  insn = gen_rtx_SET (VOIDmode,\n+\t\t      gen_rtx_REG (SImode, T_REG),\n+\t\t      gen_rtx_fmt_ee (branch_code, SImode, op0, op1));\n+\n+  sh_emit_set_t_insn (insn, mode);\n+  if (need_ccmpeq)\n+    sh_emit_set_t_insn (gen_ieee_ccmpeqsf_t (op0, op1), mode);\n+\n+  if (branch_code == code)\n+    emit_jump_insn (gen_branch_true (operands[3]));\n   else\n-    insn = gen_rtx_SET (VOIDmode,\n-\t\t\tgen_rtx_REG (SImode, T_REG),\n-\t\t\tgen_rtx_fmt_ee ((enum rtx_code) code, SImode,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-  if ((TARGET_SH4 || TARGET_SH2A) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    emit_jump_insn (gen_branch_false (operands[3]));\n+}\n+\n+void\n+sh_emit_compare_and_set (rtx *operands, enum machine_mode mode)\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = operands[2];\n+  rtx op1 = operands[3];\n+  rtx lab = NULL_RTX;\n+  bool invert = false;\n+  rtx tem;\n+\n+  op0 = force_reg (mode, op0);\n+  if ((code != EQ && code != NE\n+       && (op1 != const0_rtx\n+\t   || code == GTU  || code == GEU || code == LTU || code == LEU))\n+      || (mode == DImode && op1 != const0_rtx)\n+      || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n+    op1 = force_reg (mode, op1);\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n-      insn = gen_rtx_PARALLEL (VOIDmode,\n-\t\t      gen_rtvec (2, insn,\n-\t\t\t\t gen_rtx_USE (VOIDmode, get_fpscr_rtx ())));\n-      (mode == SFmode ? emit_sf_insn : emit_df_insn) (insn);\n+      if (code == LT || code == LE)\n+\t{\n+\t  code = swap_condition (code);\n+\t  tem = op0, op0 = op1, op1 = tem;\n+\t}\n+      if (code == GE)\n+        {\n+          if (TARGET_IEEE)\n+            {\n+              lab = gen_label_rtx ();\n+              sh_emit_scc_to_t (EQ, op0, op1);\n+              emit_jump_insn (gen_branch_true (lab));\n+              code = GT;\n+           }\n+          else\n+            {\n+              code = LT;\n+              invert = true;\n+\t    }\n+        }\n     }\n+\n+  if (code == NE)\n+    {\n+      code = EQ;\n+      invert = true;\n+    }\n+\n+  sh_emit_scc_to_t (code, op0, op1);\n+  if (lab)\n+    emit_label (lab);\n+  if (invert)\n+    emit_insn (gen_movnegt (operands[0]));\n   else\n-    emit_insn (insn);\n+    emit_move_insn (operands[0], gen_rtx_REG (SImode, T_REG));\n }\n \f\n /* Functions to output assembly code.  */\n@@ -10782,17 +10937,21 @@ sh_get_pr_initial_val (void)\n }\n \n int\n-sh_expand_t_scc (enum rtx_code code, rtx target)\n+sh_expand_t_scc (rtx operands[])\n {\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx target = operands[0];\n+  rtx op0 = operands[2];\n+  rtx op1 = operands[3];\n   rtx result = target;\n   HOST_WIDE_INT val;\n \n-  if (GET_CODE (sh_compare_op0) != REG || REGNO (sh_compare_op0) != T_REG\n-      || GET_CODE (sh_compare_op1) != CONST_INT)\n+  if (GET_CODE (op0) != REG || REGNO (op0) != T_REG\n+      || GET_CODE (op1) != CONST_INT)\n     return 0;\n   if (GET_CODE (result) != REG)\n     result = gen_reg_rtx (SImode);\n-  val = INTVAL (sh_compare_op1);\n+  val = INTVAL (op1);\n   if ((code == EQ && val == 1) || (code == NE && val == 0))\n     emit_insn (gen_movt (result));\n   else if (TARGET_SH2A && ((code == EQ && val == 0)"}, {"sha": "ffd0db08225503d824a854909ceacab3f71fafdc", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 390, "deletions": 1253, "changes": 1643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -646,8 +646,15 @@\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_CBRANCHDI4\"\n-  \"expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1); DONE;\")\n+  \"\"\n+  \"if (TARGET_SHMEDIA)\n+      emit_jump_insn (gen_cbranchint4_media (operands[0], operands[1],\n+\t\t\t\t\t     operands[2], operands[3]));\n+   else if (TARGET_CBRANCHDI4)\n+     expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1);\n+   else\n+     sh_emit_compare_and_branch (operands, SImode);\n+   DONE;\")\n \n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n@@ -676,23 +683,6 @@\n   \"cmp/hi\t%1,%0\"\n    [(set_attr \"type\" \"mt_group\")])\n \n-;; We save the compare operands in the cmpxx patterns and use them when\n-;; we generate the branch.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:SI T_REG)\n-\t(compare (match_operand:SI 0 \"cmpsi_operand\" \"\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"\")))]\n-  \"TARGET_SH1 || TARGET_SHMEDIA\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == T_REG\n-      && GET_CODE (operands[1]) != CONST_INT)\n-    operands[0] = copy_to_mode_reg (SImode, operands[0]);\n-  sh_compare_op0 = operands[0];\n-  sh_compare_op1 = operands[1];\n-  DONE;\n-}\")\n \f\n ;; -------------------------------------------------------------------------\n ;; DImode compare and branch\n@@ -713,29 +703,45 @@\n \t\t      (pc)))\n    (clobber (match_dup 4))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_CBRANCHDI4\"\n+  \"TARGET_CBRANCHDI4 || TARGET_SH2 || TARGET_SHMEDIA\"\n   \"\n {\n   enum rtx_code comparison;\n \n-  if (TARGET_EXPAND_CBRANCHDI4)\n+  if (TARGET_SHMEDIA)\n+    {\n+      emit_jump_insn (gen_cbranchint4_media (operands[0], operands[1],\n+\t\t\t\t\t     operands[2], operands[3]));\n+      DONE;\n+    }\n+\n+  else if (!TARGET_CBRANCHDI4)\n     {\n-      if (expand_cbranchdi4 (operands, LAST_AND_UNUSED_RTX_CODE))\n-\tDONE;\n+      sh_emit_compare_and_branch (operands, DImode);\n+      DONE;\n+    }\n+\n+  else\n+    {\n+      if (TARGET_EXPAND_CBRANCHDI4)\n+        {\n+          if (expand_cbranchdi4 (operands, LAST_AND_UNUSED_RTX_CODE))\n+\t    DONE;\n+        }\n+      comparison = prepare_cbranch_operands (operands, DImode,\n+\t\t\t\t\t     LAST_AND_UNUSED_RTX_CODE);\n+      if (comparison != GET_CODE (operands[0]))\n+        operands[0]\n+          = gen_rtx_fmt_ee (comparison, VOIDmode, operands[1], operands[2]);\n+       operands[4] = gen_rtx_SCRATCH (SImode);\n     }\n-  comparison = prepare_cbranch_operands (operands, DImode,\n-\t\t\t\t\t LAST_AND_UNUSED_RTX_CODE);\n-  if (comparison != GET_CODE (operands[0]))\n-    operands[0]\n-      = gen_rtx_fmt_ee (comparison, VOIDmode, operands[1], operands[2]);\n-   operands[4] = gen_rtx_SCRATCH (SImode);\n }\")\n \n (define_insn_and_split \"cbranchdi4_i\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand:DI 1 \"arith_operand\" \"r,r\")\n-\t\t\t (match_operand:DI 2 \"arith_operand\" \"rN,i\")])\n+\t\t\t (match_operand:DI 2 \"arith_operand\" \"rN,I08\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))\n    (clobber (match_scratch:SI 4 \"=X,&r\"))\n@@ -907,20 +913,6 @@\n   \"cmpgtu\t%1,r63,%0\"\n   [(set_attr \"type\" \"cmp_media\")])\n \n-;; We save the compare operands in the cmpxx patterns and use them when\n-;; we generate the branch.\n-\n-(define_expand \"cmpdi\"\n-  [(set (reg:SI T_REG)\n-\t(compare (match_operand:DI 0 \"arith_operand\" \"\")\n-\t\t (match_operand:DI 1 \"arith_operand\" \"\")))]\n-  \"TARGET_SH2 || TARGET_SHMEDIA\"\n-  \"\n-{\n-  sh_compare_op0 = operands[0];\n-  sh_compare_op1 = operands[1];\n-  DONE;\n-}\")\n ;; -------------------------------------------------------------------------\n ;; Conditional move instructions\n ;; -------------------------------------------------------------------------\n@@ -988,92 +980,20 @@\n   \"\n {\n   if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n-      && GET_MODE (sh_compare_op0) == DImode\n-      && sh_compare_op1 == const0_rtx)\n-    operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n-\t\t\t\t  sh_compare_op0, sh_compare_op1);\n+      && GET_MODE (XEXP (operands[1], 0)) == DImode\n+      && XEXP (operands[1], 1) == const0_rtx)\n+    ;\n   else\n     {\n-      rtx tmp;\n-\n       if (!can_create_pseudo_p ())\n \tFAIL;\n \n-      tmp = gen_reg_rtx (DImode);\n-\n-      switch (GET_CODE (operands[1]))\n-\t{\n-\tcase EQ:\n-\t  emit_insn (gen_seq (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase NE:\n-\t  emit_insn (gen_seq (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GT:\n-\t  emit_insn (gen_sgt (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LT:\n-\t  emit_insn (gen_slt (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GE:\n-\t  emit_insn (gen_slt (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LE:\n-\t  emit_insn (gen_sgt (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GTU:\n-\t  emit_insn (gen_sgtu (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LTU:\n-\t  emit_insn (gen_sltu (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GEU:\n-\t  emit_insn (gen_sltu (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LEU:\n-\t  emit_insn (gen_sgtu (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase UNORDERED:\n-\t  emit_insn (gen_sunordered (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase ORDERED:\n-\t  emit_insn (gen_sunordered (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase UNEQ:\n-\tcase UNGE:\n-\tcase UNGT:\n-\tcase UNLE:\n-\tcase UNLT:\n-\tcase LTGT:\n-\t  FAIL;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      operands[1] = sh_emit_cheap_store_flag (GET_MODE (operands[0]),\n+\t\t\t\t\t      GET_CODE (operands[1]),\n+\t\t\t\t\t      XEXP (operands[1], 0),\n+\t                                      XEXP (operands[1], 1));\n+      if (!operands[1])\n+\tFAIL;\n     }\n }\")\n \n@@ -1268,24 +1188,26 @@\n   \"\n {\n   if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n-      && GET_MODE (sh_compare_op0) == SImode\n+      && GET_MODE (XEXP (operands[1], 0)) == SImode\n       && (TARGET_SHMEDIA\n-\t  || (REG_P (sh_compare_op0) && REGNO (sh_compare_op0) == T_REG))\n-      && sh_compare_op1 == const0_rtx)\n-    operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n-\t\t\t\t  sh_compare_op0, sh_compare_op1);\n+\t  || (REG_P (XEXP (operands[1], 0))\n+\t      && REGNO (XEXP (operands[1], 0)) == T_REG))\n+      && XEXP (operands[1], 1) == const0_rtx)\n+    ;\n+\n   else if (TARGET_PRETEND_CMOVE)\n     {\n       enum rtx_code code = GET_CODE (operands[1]);\n       enum rtx_code new_code = code;\n-      rtx tmp;\n+      rtx op0 = XEXP (operands[1], 0);\n+      rtx op1 = XEXP (operands[1], 1);\n \n       if (! currently_expanding_to_rtl)\n \tFAIL;\n       switch (code)\n \t{\n \tcase LT: case LE: case LEU: case LTU:\n-\t  if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) != MODE_INT)\n+\t  if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_INT)\n \t    break;\n \tcase NE:\n \t  new_code = reverse_condition (code);\n@@ -1295,92 +1217,21 @@\n \tdefault:\n \t  FAIL;\n \t}\n-      tmp = prepare_scc_operands (new_code);\n+      sh_emit_scc_to_t (new_code, op0, op1);\n       operands[1] = gen_rtx_fmt_ee (new_code == code ? NE : EQ, VOIDmode,\n-\t\t\t\t    tmp, const0_rtx);\n+\t\t\t\t    gen_rtx_REG (SImode, T_REG), const0_rtx);\n     }\n   else\n     {\n-      rtx tmp;\n-\n       if (!can_create_pseudo_p ())\n \tFAIL;\n \n-      tmp = gen_reg_rtx (SImode);\n-\n-      switch (GET_CODE (operands[1]))\n-\t{\n-\tcase EQ:\n-\t  emit_insn (gen_seq (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase NE:\n-\t  emit_insn (gen_seq (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GT:\n-\t  emit_insn (gen_sgt (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LT:\n-\t  emit_insn (gen_slt (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GE:\n-\t  emit_insn (gen_slt (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LE:\n-\t  emit_insn (gen_sgt (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GTU:\n-\t  emit_insn (gen_sgtu (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LTU:\n-\t  emit_insn (gen_sltu (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase GEU:\n-\t  emit_insn (gen_sltu (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase LEU:\n-\t  emit_insn (gen_sgtu (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase UNORDERED:\n-\t  emit_insn (gen_sunordered (tmp));\n-\t  operands[1] = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase ORDERED:\n-\t  emit_insn (gen_sunordered (tmp));\n-\t  operands[1] = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-\t  break;\n-\n-\tcase UNEQ:\n-\tcase UNGE:\n-\tcase UNGT:\n-\tcase UNLE:\n-\tcase UNLT:\n-\tcase LTGT:\n-\t  FAIL;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      operands[1] = sh_emit_cheap_store_flag (GET_MODE (operands[0]),\n+\t\t\t\t\t      GET_CODE (operands[1]),\n+\t\t\t\t\t      XEXP (operands[1], 0),\n+\t                                      XEXP (operands[1], 1));\n+      if (!operands[1])\n+\tFAIL;\n     }\n }\")\n \n@@ -1887,8 +1738,9 @@\n \t implemented by comparing with the divisor.  */\n       if (operands[1] == const1_rtx && currently_expanding_to_rtl)\n \t{\n-\t  emit_insn (gen_cmpsi (operands[1], operands[2]));\n-\t  emit_insn (gen_sgeu (operands[0]));\n+\t  rtx test = gen_rtx_GEU (VOIDmode, operands[1], operands[2]);\n+\t  emit_insn (gen_cstoresi4 (operands[0], test,\n+\t\t\t\t    operands[1], operands[2]));\n \t  DONE;\n \t}\n       else if (operands[2] == const0_rtx)\n@@ -6877,14 +6729,83 @@ label:\n \f\n ;; Conditional branch insns\n \n-(define_expand \"beq_media\"\n+(define_expand \"cbranchint4_media\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"shmedia_cbranch_comparison_operator\"\n+\t\t       [(match_operand 1 \"\" \"\")\n+\t\t\t(match_operand 2 \"\" \"\")])\n+\t\t      (match_operand 3 \"\" \"\")\n+\t\t      (pc)))]\n+  \"TARGET_SHMEDIA\"\n+  \"\n+{\n+  enum machine_mode mode = GET_MODE (operands[1]);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (operands[2]);\n+  if (GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n+    {\n+      operands[1] = force_reg (mode, operands[1]);\n+      if (CONSTANT_P (operands[2])\n+          && (! satisfies_constraint_I06 (operands[2])))\n+        operands[2] = force_reg (mode, operands[2]);\n+    }\n+  else\n+    {\n+      if (operands[1] != const0_rtx)\n+        operands[1] = force_reg (mode, operands[1]);\n+      if (operands[2] != const0_rtx)\n+        operands[2] = force_reg (mode, operands[2]);\n+    }\n+  switch (GET_CODE (operands[0]))\n+    {\n+    case LEU:\n+    case LE:\n+    case LTU:\n+    case LT:\n+      operands[0] = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[0])),\n+\t\t\t\t    VOIDmode, operands[2], operands[1]);\n+      operands[1] = XEXP (operands[0], 0);\n+      operands[2] = XEXP (operands[0], 1);\n+      break;\n+    default:\n+      operands[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]),\n+\t\t\t\t    VOIDmode, operands[1], operands[2]);\n+      break;\n+    }\n+  operands[3] = gen_rtx_LABEL_REF (Pmode, operands[3]);\n+}\")\n+\n+(define_expand \"cbranchfp4_media\"\n   [(set (pc)\n-\t(if_then_else (eq (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:DI 2 \"arith_operand\" \"r,I06\"))\n-\t\t      (match_operand 0 \"\" \"\")\n+\t(if_then_else (match_operator 0 \"sh_float_comparison_operator\"\n+\t\t       [(match_operand 1 \"\" \"\")\n+\t\t\t(match_operand 2 \"\" \"\")])\n+\t\t      (match_operand 3 \"\" \"\")\n \t\t      (pc)))]\n   \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n+  \"\n+{\n+  /* hack to generate same code.  */\n+  rtx tmp_di = GET_CODE (operands[0]) == UNORDERED ? NULL : gen_reg_rtx (DImode);\n+  rtx tmp = gen_reg_rtx (SImode);\n+  rtx cmp;\n+  if (GET_CODE (operands[0]) == NE)\n+    cmp = gen_rtx_EQ (SImode, operands[1], operands[2]);\n+  else\n+    cmp = gen_rtx_fmt_ee (GET_CODE (operands[0]), SImode,\n+\t\t\t  operands[1], operands[2]);\n+\n+  emit_insn (gen_cstore4_media (tmp, cmp, operands[1], operands[2]));\n+  if (tmp_di) emit_insn (gen_extendsidi2 (tmp_di, tmp)); else tmp_di = tmp;\n+\n+  if (GET_CODE (cmp) == GET_CODE (operands[0]))\n+    operands[0] = gen_rtx_NE (VOIDmode, tmp_di, const0_rtx);\n+  else\n+    operands[0] = gen_rtx_EQ (VOIDmode, tmp_di, const0_rtx);\n+  operands[1] = tmp_di;\n+  operands[2] = const0_rtx;\n+  operands[3] = gen_rtx_LABEL_REF (Pmode, operands[3]);\n+}\")\n \n (define_insn \"*beq_media_i\"\n   [(set (pc)\n@@ -6912,51 +6833,6 @@ label:\n \tb%o3i%'\t%1, %2, %0%>\"\n   [(set_attr \"type\" \"cbranch_media\")])\n \n-(define_expand \"bne_media\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:DI 2 \"arith_operand\" \"r,I06\"))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n-\n-(define_expand \"bgt_media\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n-\t\t\t  (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\"))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n-\n-(define_expand \"bge_media\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n-\t\t\t  (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\"))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n-\n-(define_expand \"bgtu_media\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n-\t\t\t   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\"))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n-\n-(define_expand \"bgeu_media\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n-\t\t\t   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\"))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\")\n-\n (define_insn \"*bgt_media_i\"\n   [(set (pc)\n \t(if_then_else (match_operator 3 \"greater_comparison_operator\"\n@@ -7003,421 +6879,84 @@ label:\n   \"b%o3%'\t%N2, %N1, %0%>\"\n   [(set_attr \"type\" \"cbranch_media\")])\n \n-(define_expand \"beq\"\n+;; combiner splitter for test-and-branch on single bit in register.  This\n+;; is endian dependent because the non-paradoxical subreg looks different\n+;; on big endian.\n+(define_split\n   [(set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n+\t(if_then_else\n+\t  (match_operator 3 \"equality_comparison_operator\"\n+\t    [(subreg:SI (zero_extract:DI (subreg:DI (match_operand:SI 1\n+\t\t\t\t\t\t      \"extend_reg_operand\" \"\")\n+\t\t\t\t\t\t    0)\n+\t\t\t\t\t (const_int 1)\n+\t\t\t\t\t (match_operand 2\n+\t\t\t\t\t  \"const_int_operand\" \"\")) 0)\n+\t     (const_int 0)])\n+\t  (match_operand 0 \"target_operand\" \"\")\n+\t  (pc)))\n+   (clobber (match_operand:SI 4 \"arith_reg_dest\" \"\"))]\n+  \"TARGET_SHMEDIA && TARGET_LITTLE_ENDIAN\"\n+  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 5)))\n+   (set (pc) (if_then_else (match_dup 6) (match_dup 0) (pc)))]\n+\n   \"\n {\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_seq (tmp));\n-\t  emit_jump_insn (gen_bne_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n-\n-      sh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (CONSTANT_P (sh_compare_op1)\n-\t  && (! satisfies_constraint_I06 (sh_compare_op1)))\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_beq_media (operands[0],\n-\t\t\t\t     sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  from_compare (operands, EQ);\n+  operands[5] = GEN_INT (31 - INTVAL (operands[2]));\n+  operands[6] = (GET_CODE (operands[3]) == EQ\n+\t\t ? gen_rtx_GE (VOIDmode, operands[4], const0_rtx)\n+\t\t : gen_rtx_GT (VOIDmode, const0_rtx, operands[4]));\n }\")\n \n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n+; operand 0 is the loop count pseudo register\n+; operand 1 is the number of loop iterations or 0 if it is unknown\n+; operand 2 is the maximum number of loop iterations\n+; operand 3 is the number of levels of enclosed loops\n+; operand 4 is the label to jump to at the top of the loop\n+\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc) (if_then_else\n+\t\t\t  (ne:SI (match_operand:SI 0 \"\" \"\")\n+\t\t\t      (const_int 1))\n+\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t  (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0) (const_int -1)))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"TARGET_SH2\"\n   \"\n {\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_seq (tmp));\n-\t  emit_jump_insn (gen_beq_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n-\n-      sh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (CONSTANT_P (sh_compare_op1)\n-\t  && (! satisfies_constraint_I06 (sh_compare_op1)))\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bne_media (operands[0],\n-\t\t\t\t     sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  from_compare (operands, EQ);\n-}\")\n+  if (GET_MODE (operands[0]) != SImode)\n+    FAIL;\n+}\n+\")\n \n-(define_expand \"bgt\"\n+(define_insn_and_split \"doloop_end_split\"\n   [(set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else (ne:SI (match_operand:SI 0 \"arith_reg_dest\" \"+r\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus (match_dup 0) (const_int -1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH2\"\n+  \"#\"\n   \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_sgt (tmp));\n-\t  emit_jump_insn (gen_bne_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n+  [(parallel [(set (reg:SI T_REG)\n+\t\t   (eq:SI (match_operand:SI 0 \"arith_reg_dest\" \"+r\")\n+\t\t\t  (const_int 1)))\n+\t      (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))])\n+   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+\"\"\n+   [(set_attr \"type\" \"cbranch\")])\n \n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgt_media (operands[0],\n-\t\t\t\t     sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  from_compare (operands, GT);\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_slt (tmp));\n-\t  emit_jump_insn (gen_bne_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgt_media (operands[0],\n-\t\t\t\t     sh_compare_op1, sh_compare_op0));\n-      DONE;\n-    }\n-\n-  if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n-    {\n-      rtx tmp = sh_compare_op0;\n-      sh_compare_op0 = sh_compare_op1;\n-      sh_compare_op1 = tmp;\n-      emit_insn (gen_bgt (operands[0]));\n-      DONE;\n-    }\n-  from_compare (operands, GE);\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_sle (tmp));\n-\t  emit_jump_insn (gen_bne_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bge_media (operands[0],\n-\t\t\t\t     sh_compare_op1, sh_compare_op0));\n-      DONE;\n-    }\n-\n-  if (TARGET_SH2E\n-      && TARGET_IEEE\n-      && GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n-    {\n-      rtx tmp = sh_compare_op0;\n-      sh_compare_op0 = sh_compare_op1;\n-      sh_compare_op1 = tmp;\n-      emit_insn (gen_bge (operands[0]));\n-      DONE;\n-    }\n-  from_compare (operands, GT);\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (mode != DImode && mode != SImode)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (DImode);\n-\n-\t  emit_insn (gen_sge (tmp));\n-\t  emit_jump_insn (gen_bne_media (operands[0], tmp, const0_rtx));\n-\t  DONE;\n-\t}\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bge_media (operands[0],\n-\t\t\t\t     sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  if (TARGET_SH2E\n-      && ! TARGET_IEEE\n-      && GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n-    {\n-      rtx tmp = sh_compare_op0;\n-      sh_compare_op0 = sh_compare_op1;\n-      sh_compare_op1 = tmp;\n-      emit_insn (gen_ble (operands[0]));\n-      DONE;\n-    }\n-  from_compare (operands, GE);\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgtu_media (operands[0],\n-\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  from_compare (operands, GTU);\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgtu_media (operands[0],\n-\t\t\t\t      sh_compare_op1, sh_compare_op0));\n-      DONE;\n-    }\n-\n-  from_compare (operands, GEU);\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgeu_media (operands[0],\n-\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-      DONE;\n-    }\n-\n-  from_compare (operands, GEU);\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if (sh_compare_op0 != const0_rtx)\n-\tsh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-      emit_jump_insn (gen_bgeu_media (operands[0],\n-\t\t\t\t      sh_compare_op1, sh_compare_op0));\n-      DONE;\n-    }\n-\n-  from_compare (operands, GTU);\n-}\")\n-\n-(define_expand \"bunordered\"\n-  [(set (match_dup 1) (unordered:SI (match_dup 2) (match_dup 3)))\n-   (set (pc)\n-\t(if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))]\n-  \"TARGET_SHMEDIA\"\n-  \"\n-{\n-  operands[0] = gen_rtx_LABEL_REF (Pmode, operands[0]);\n-  operands[1] = gen_reg_rtx (SImode);\n-  operands[2] = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-  operands[3] = force_reg (GET_MODE (sh_compare_op1), sh_compare_op1);\n-}\")\n-\n-;; combiner splitter for test-and-branch on single bit in register.  This\n-;; is endian dependent because the non-paradoxical subreg looks different\n-;; on big endian.\n-(define_split\n-  [(set (pc)\n-\t(if_then_else\n-\t  (match_operator 3 \"equality_comparison_operator\"\n-\t    [(subreg:SI (zero_extract:DI (subreg:DI (match_operand:SI 1\n-\t\t\t\t\t\t      \"extend_reg_operand\" \"\")\n-\t\t\t\t\t\t    0)\n-\t\t\t\t\t (const_int 1)\n-\t\t\t\t\t (match_operand 2\n-\t\t\t\t\t  \"const_int_operand\" \"\")) 0)\n-\t     (const_int 0)])\n-\t  (match_operand 0 \"target_operand\" \"\")\n-\t  (pc)))\n-   (clobber (match_operand:SI 4 \"arith_reg_dest\" \"\"))]\n-  \"TARGET_SHMEDIA && TARGET_LITTLE_ENDIAN\"\n-  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 5)))\n-   (set (pc) (if_then_else (match_dup 6) (match_dup 0) (pc)))]\n-\n-  \"\n-{\n-  operands[5] = GEN_INT (31 - INTVAL (operands[2]));\n-  operands[6] = (GET_CODE (operands[3]) == EQ\n-\t\t ? gen_rtx_GE (VOIDmode, operands[4], const0_rtx)\n-\t\t : gen_rtx_GT (VOIDmode, const0_rtx, operands[4]));\n-}\")\n-\n-; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n-\n-(define_expand \"doloop_end\"\n-  [(parallel [(set (pc) (if_then_else\n-\t\t\t  (ne:SI (match_operand:SI 0 \"\" \"\")\n-\t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n-\t\t\t  (pc)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0) (const_int -1)))\n-\t      (clobber (reg:SI T_REG))])]\n-  \"TARGET_SH2\"\n-  \"\n-{\n-  if (GET_MODE (operands[0]) != SImode)\n-    FAIL;\n-}\n-\")\n-\n-(define_insn_and_split \"doloop_end_split\"\n-  [(set (pc)\n-\t(if_then_else (ne:SI (match_operand:SI 0 \"arith_reg_dest\" \"+r\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_dup 0)\n-\t(plus (match_dup 0) (const_int -1)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH2\"\n-  \"#\"\n-  \"\"\n-  [(parallel [(set (reg:SI T_REG)\n-\t\t   (eq:SI (match_operand:SI 0 \"arith_reg_dest\" \"+r\")\n-\t\t\t  (const_int 1)))\n-\t      (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))])\n-   (set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t   (pc)))]\n-\"\"\n-   [(set_attr \"type\" \"cbranch\")])\n-\n-\f\n-;; ------------------------------------------------------------------------\n-;; Jump and linkage insns\n-;; ------------------------------------------------------------------------\n+\f\n+;; ------------------------------------------------------------------------\n+;; Jump and linkage insns\n+;; ------------------------------------------------------------------------\n \n (define_insn \"jump_compact\"\n   [(set (pc)\n@@ -9120,15 +8659,17 @@ mov.l\\\\t1f,r0\\\\n\\\\\n       rtx reg3 = gen_reg_rtx (Pmode);\n       rtx reg4 = gen_reg_rtx (Pmode);\n       rtx reg5 = gen_reg_rtx (Pmode);\n-      rtx load;\n+      rtx load, test;\n \n       operands[0] = convert_modes (DImode, SImode, operands[0], 0);\n       operands[1] = convert_modes (DImode, SImode, operands[1], 0);\n       operands[2] = convert_modes (DImode, SImode, operands[2], 1);\n \n-      emit_jump_insn (gen_bgt_media (operands[4], operands[1], operands[0]));\n+      test = gen_rtx_GT (VOIDmode, operands[1], operands[0]);\n+      emit_jump_insn (gen_cbranchdi4 (test, operands[1], operands[0], operands[4]));\n       emit_move_insn (reg, gen_rtx_MINUS (DImode, operands[0], operands[1]));\n-      emit_jump_insn (gen_bgtu_media (operands[4], reg, operands[2]));\n+      test = gen_rtx_GTU (VOIDmode, reg, operands[2]);\n+      emit_jump_insn (gen_cbranchdi4 (test, reg, operands[2], operands[4]));\n       emit_insn (gen_casesi_shift_media (reg2, reg, operands[3]));\n       emit_move_insn (reg3, gen_datalabel_ref (gen_rtx_LABEL_REF\n \t\t\t\t\t       (Pmode, operands[3])));\n@@ -9580,536 +9121,133 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"movrt\\\\t%0\"\n    [(set_attr \"type\" \"arith\")])\n \n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      rtx reg;\n-\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-      if (GET_MODE_SIZE (GET_MODE (operands[0])) <= 4)\n-\t{\n-\t  if (GET_MODE (operands[0]) != SImode)\n-\t    operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n-\n-\t  switch (GET_MODE (sh_compare_op0))\n-\t    {\n-\t    case SImode:\n-\t      emit_insn (gen_cmpeqsi_media (operands[0],\n-\t\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-\t      break;\n-\n-\t    case DImode:\n-\t      emit_insn (gen_cmpeqdi_media (operands[0],\n-\t\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-\t      break;\n-\n-\t    case SFmode:\n-\t      if (! TARGET_SHMEDIA_FPU)\n-\t\tFAIL;\n-\t      emit_insn (gen_cmpeqsf_media (operands[0],\n-\t\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-\t      break;\n-\n-\t    case DFmode:\n-\t      if (! TARGET_SHMEDIA_FPU)\n-\t\tFAIL;\n-\t      emit_insn (gen_cmpeqdf_media (operands[0],\n-\t\t\t\t\t      sh_compare_op0, sh_compare_op1));\n-\t      break;\n-\n-\t    default:\n-\t      FAIL;\n-\t    }\n-\t  DONE;\n-\t}\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-\n-      switch (GET_MODE (sh_compare_op0))\n-\t{\n-\tcase SImode:\n-\t  emit_insn (gen_cmpeqsi_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase DImode:\n-\t  emit_insn (gen_cmpeqdi_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase SFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpeqsf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase DFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpeqdf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tdefault:\n-\t  FAIL;\n-\t}\n-\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n-      DONE;\n-    }\n-  if (sh_expand_t_scc (EQ, operands[0]))\n-    DONE;\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (EQ);\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n+(define_expand \"cstore4_media\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"sh_float_comparison_operator\"\n+\t [(match_operand 2 \"logical_operand\" \"\")\n+\t  (match_operand 3 \"cmp_operand\" \"\")]))]\n+  \"TARGET_SHMEDIA\"\n   \"\n {\n-  if (TARGET_SHMEDIA)\n+  enum machine_mode mode = GET_MODE (operands[2]);\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  bool invert, swap;\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (operands[3]);\n+  if (operands[2] == const0_rtx)\n     {\n-      rtx reg;\n-\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-\n-      switch (GET_MODE (sh_compare_op0))\n-\t{\n-\tcase SImode:\n-\t  emit_insn (gen_cmpgtsi_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n-\n-\tcase DImode:\n-\t  emit_insn (gen_cmpgtdi_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n-\n-\tcase SFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgtsf_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n-\n-\tcase DFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgtdf_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n-\n-\tdefault:\n-\t  FAIL;\n-\t}\n-\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n-      DONE;\n+      if (code == EQ || code == NE)\n+\toperands[2] = operands[3], operands[3] = const0_rtx;\n     }\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (LT);\n-}\")\n-\n-(define_expand \"sle\"\n-  [(match_operand:SI 0 \"arith_reg_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx tmp = sh_compare_op0;\n+  else\n+    operands[2] = force_reg (mode, operands[2]);\n+  if (operands[3] != const0_rtx)\n+    operands[3] = force_reg (mode, operands[3]);\n \n-  if (TARGET_SHMEDIA)\n+  switch (code)\n     {\n-      rtx reg;\n-\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-\n-      switch (GET_MODE (sh_compare_op0))\n-\t{\n-\tcase SImode:\n-\t  {\n-\t    tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-\t    emit_insn (gen_cmpgtsi_media (tmp,\n-\t\t\t\t\t  sh_compare_op0, sh_compare_op1));\n-\t    emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-\t    break;\n-\t  }\n-\n-\tcase DImode:\n-\t  {\n-\t    tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-\t    emit_insn (gen_cmpgtdi_media (tmp,\n-\t\t\t\t\t  sh_compare_op0, sh_compare_op1));\n-\t    emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-\t    break;\n-\t  }\n-\n-\tcase SFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgesf_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n+    case GEU:\n+    case GE:\n+      swap = invert = !FLOAT_MODE_P (mode);\n+      break;\n \n-\tcase DFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgedf_media (reg,\n-\t\t\t\t\tsh_compare_op1, sh_compare_op0));\n-\t  break;\n+    case LEU:\n+    case LE:\n+      swap = FLOAT_MODE_P (mode), invert = !swap;\n+      break;\n \n-\tdefault:\n-\t  FAIL;\n-\t}\n+    case LTU:\n+    case LT:\n+      swap = true, invert = false;\n+      break;\n \n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n+    case GTU:\n+    case GT:\n+    case EQ:\n+    case UNORDERED:\n+      swap = invert = false;\n+      break;\n \n-      DONE;\n-    }\n+    case NE:\n+      swap = invert = true;\n+      break;\n \n-  sh_compare_op0 = sh_compare_op1;\n-  sh_compare_op1 = tmp;\n-  emit_insn (gen_sge (operands[0]));\n-  DONE;\n-}\")\n+    default:\n+      gcc_unreachable ();\n+  }\n \n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n+  if (swap)\n     {\n-      rtx reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p () ?\n-\t       gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      switch (GET_MODE (sh_compare_op0))\n-\t{\n-\tcase SImode:\n-\t  emit_insn (gen_cmpgtsi_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase DImode:\n-\t  emit_insn (gen_cmpgtdi_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase SFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgtsf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase DFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgtdf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tdefault:\n-\t  FAIL;\n-\t}\n-\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n-      DONE;\n+      rtx tem = operands[2];\n+      operands[2] = operands[3];\n+      operands[3] = tem;\n+      code = swap_condition (code);\n     }\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (GT);\n-}\")\n \n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n+  if (invert)\n     {\n-      rtx reg;\n-      enum machine_mode mode = GET_MODE (sh_compare_op0);\n-\n-      if ((mode) == VOIDmode)\n-\tmode = GET_MODE (sh_compare_op1);\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (mode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n-\n-      switch (mode)\n-\t{\n-\tcase SImode:\n-\t  {\n-\t    rtx tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-\t    emit_insn (gen_cmpgtsi_media (tmp,\n-\t\t\t\t\t  sh_compare_op1, sh_compare_op0));\n-\t    emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-\t    break;\n-\t  }\n-\n-\tcase DImode:\n-\t  {\n-\t    rtx tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-\t    emit_insn (gen_cmpgtdi_media (tmp,\n-\t\t\t\t\t  sh_compare_op1, sh_compare_op0));\n-\t    emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-\t    break;\n-\t  }\n-\n-\tcase SFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgesf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tcase DFmode:\n-\t  if (! TARGET_SHMEDIA_FPU)\n-\t    FAIL;\n-\t  emit_insn (gen_cmpgedf_media (reg,\n-\t\t\t\t\tsh_compare_op0, sh_compare_op1));\n-\t  break;\n-\n-\tdefault:\n-\t  FAIL;\n-\t}\n-\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n-      DONE;\n+      rtx tem = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n+      code = reverse_condition (code);\n+      operands[1] = gen_rtx_fmt_ee (code, VOIDmode, operands[2], operands[3]);\n+      emit_insn (gen_cstore4_media (tem, operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+      code = EQ;\n+      operands[2] = tem;\n+      operands[3] = const0_rtx;\n     }\n \n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n-    {\n-      if (TARGET_IEEE)\n-\t{\n-\t  rtx lab = gen_label_rtx ();\n-\t  prepare_scc_operands (EQ);\n-\t  emit_jump_insn (gen_branch_true (lab));\n-\t  prepare_scc_operands (GT);\n-\t  emit_label (lab);\n-\t  emit_insn (gen_movt (operands[0]));\n-\t}\n-      else\n-\temit_insn (gen_movnegt (operands[0], prepare_scc_operands (LT)));\n-      DONE;\n-    }\n-  operands[1] = prepare_scc_operands (GE);\n+  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, operands[2], operands[3]);\n }\")\n \n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"comparison_operator\"\n+\t [(match_operand:SI 2 \"cmpsi_operand\" \"\")\n+\t  (match_operand:SI 3 \"arith_operand\" \"\")]))]\n+  \"TARGET_SH1 || TARGET_SHMEDIA\"\n+  \"if (TARGET_SHMEDIA)\n     {\n-      rtx reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) == DImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      emit_insn (gen_cmpgtudi_media (reg,\n-\t\t\t\t     sh_compare_op0, sh_compare_op1));\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n+      emit_insn (gen_cstore4_media (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n       DONE;\n     }\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (GTU);\n-}\")\n \n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      rtx reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) == DImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      emit_insn (gen_cmpgtudi_media (reg,\n-\t\t\t\t     sh_compare_op1, sh_compare_op0));\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n+   if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n+       && sh_expand_t_scc (operands))\n+     DONE;\n \n-      DONE;\n-    }\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (LTU);\n-}\")\n+   if (! currently_expanding_to_rtl)\n+     FAIL;\n+   \n+   sh_emit_compare_and_set (operands, SImode);\n+   DONE;\n+\")\n \n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n+(define_expand \"cstoredi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"comparison_operator\"\n+\t [(match_operand:DI 2 \"arith_operand\" \"\")\n+\t  (match_operand:DI 3 \"arith_operand\" \"\")]))]\n+  \"TARGET_SH2 || TARGET_SHMEDIA\"\n+  \"if (TARGET_SHMEDIA)\n     {\n-      rtx tmp, reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_cmpgtudi_media (tmp, sh_compare_op0, sh_compare_op1));\n-      emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n+      emit_insn (gen_cstore4_media (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n       DONE;\n     }\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (LEU);\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      rtx tmp, reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n \n-      tmp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (SImode);\n+   if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n+       && sh_expand_t_scc (operands))\n+     DONE;\n \n-      emit_insn (gen_cmpgtudi_media (tmp, sh_compare_op1, sh_compare_op0));\n-      emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n+   if (! currently_expanding_to_rtl)\n+     FAIL;\n+   \n+   sh_emit_compare_and_set (operands, DImode);\n+   DONE;\n+\")\n \n-      DONE;\n-    }\n \n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (GEU);\n-}\")\n \n ;; sne moves the complement of the T reg to DEST like this:\n ;;      cmp/eq ...\n@@ -10119,81 +9257,20 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;;   not require r0 and further, the -1 may be CSE-ed or lifted out of a\n ;;   loop.\n \n-(define_expand \"sne\"\n-  [(set (match_dup 2) (const_int -1))\n-   (parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t   (neg:SI (plus:SI (match_dup 1)\n-\t\t\t\t    (match_dup 2))))\n+(define_expand \"movnegt\"\n+  [(set (match_dup 1) (const_int -1))\n+   (parallel [(set (match_operand:SI 0 \"\" \"\")\n+\t\t   (neg:SI (plus:SI (reg:SI T_REG)\n+\t\t\t\t    (match_dup 1))))\n \t      (set (reg:SI T_REG)\n-\t\t   (ne:SI (ior:SI (match_dup 1) (match_dup 2))\n+\t\t   (ne:SI (ior:SI (reg:SI T_REG) (match_dup 1))\n \t\t\t  (const_int 0)))])]\n   \"\"\n   \"\n {\n-  if (TARGET_SHMEDIA)\n-    {\n-      rtx tmp, reg;\n-\n-      reg = operands[0];\n-      if (GET_MODE (operands[0]) != SImode)\n-\treg = (!can_create_pseudo_p ()\n-\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t       : gen_reg_rtx (SImode));\n-      if (! TARGET_SHMEDIA_FPU\n-\t  && GET_MODE (sh_compare_op0) != DImode\n-\t  && GET_MODE (sh_compare_op0) != SImode)\n-\tFAIL;\n-\n-      sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n-\t\t\t\t    ? GET_MODE (sh_compare_op0)\n-\t\t\t\t    : GET_MODE (sh_compare_op1),\n-\t\t\t\t    sh_compare_op1);\n-\n-      tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_seq (tmp));\n-      emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extendsidi2 (operands[0], reg));\n-\n-      DONE;\n-    }\n-\n-  if (sh_expand_t_scc (NE, operands[0]))\n-    DONE;\n-  if (! currently_expanding_to_rtl)\n-    FAIL;\n-  operands[1] = prepare_scc_operands (EQ);\n-  operands[2] = gen_reg_rtx (SImode);\n-}\")\n-\n-(define_expand \"sunordered\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(unordered:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_SHMEDIA_FPU\"\n-  \"\n-{\n-  operands[1] = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n-  operands[2] = force_reg (GET_MODE (sh_compare_op1), sh_compare_op1);\n+  operands[1] = gen_reg_rtx (SImode);\n }\")\n \n-;; Use the same trick for FP sle / sge\n-\n-;; Apart from the constant use and the T setting, this is like movt,\n-;; except that it uses the logically negated value of T, i.e.\n-;; operand[0] := T ? 0 : 1.\n-(define_expand \"movnegt\"\n-  [(set (match_dup 2) (const_int -1))\n-   (parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (neg:SI (plus:SI (match_dup 1)\n-\t\t\t\t    (match_dup 2))))\n-\t      (set (reg:SI T_REG)\n-\t\t   (ne:SI (ior:SI (match_operand 1 \"\" \"\") (match_dup 2))\n-\t\t\t  (const_int 0)))])]\n-  \"TARGET_SH1\"\n-  \"operands[2] = gen_reg_rtx (SImode);\")\n \n ;; Recognize mov #-1/negc/neg sequence, and change it to movt/add #-1.\n ;; This prevents a regression that occurred when we switched from xor to\n@@ -10208,6 +9285,47 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))]\n   \"\")\n \n+(define_expand \"cstoresf4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"sh_float_comparison_operator\"\n+\t [(match_operand:SF 2 \"arith_operand\" \"\")\n+\t  (match_operand:SF 3 \"arith_operand\" \"\")]))]\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n+  \"if (TARGET_SHMEDIA)\n+     {\n+       emit_insn (gen_cstore4_media (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+       DONE;\n+     }\n+\n+   if (! currently_expanding_to_rtl)\n+     FAIL;\n+   \n+   sh_emit_compare_and_set (operands, SFmode);\n+   DONE;\n+\")\n+\n+(define_expand \"cstoredf4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"sh_float_comparison_operator\"\n+\t [(match_operand:DF 2 \"arith_operand\" \"\")\n+\t  (match_operand:DF 3 \"arith_operand\" \"\")]))]\n+  \"(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU\"\n+  \"if (TARGET_SHMEDIA)\n+     {\n+       emit_insn (gen_cstore4_media (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+       DONE;\n+     }\n+\n+    if (! currently_expanding_to_rtl)\n+      FAIL;\n+   \n+   sh_emit_compare_and_set (operands, DFmode);\n+   DONE;\n+\")\n+\n+\n ;; -------------------------------------------------------------------------\n ;; Instructions to cope with inline literal tables\n ;; -------------------------------------------------------------------------\n@@ -10986,15 +10104,21 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"fcmpun.s\t%1, %2, %0\"\n   [(set_attr \"type\" \"fcmp_media\")])\n \n-(define_expand \"cmpsf\"\n-  [(set (reg:SI T_REG)\n-\t(compare (match_operand:SF 0 \"arith_operand\" \"\")\n-\t\t (match_operand:SF 1 \"arith_operand\" \"\")))]\n+(define_expand \"cbranchsf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"sh_float_comparison_operator\"\n+\t\t       [(match_operand:SF 1 \"arith_operand\" \"\")\n+\t\t\t(match_operand:SF 2 \"arith_operand\" \"\")])\n+\t\t      (match_operand 3 \"\" \"\")\n+\t\t      (pc)))]\n   \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  sh_compare_op0 = operands[0];\n-  sh_compare_op1 = operands[1];\n+  if (TARGET_SHMEDIA)\n+    emit_jump_insn (gen_cbranchfp4_media (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3]));\n+  else\n+    sh_emit_compare_and_branch (operands, SFmode);\n   DONE;\n }\")\n \n@@ -11484,18 +10608,25 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"fcmpun.d\t%1,%2,%0\"\n   [(set_attr \"type\" \"fcmp_media\")])\n \n-(define_expand \"cmpdf\"\n-  [(set (reg:SI T_REG)\n-\t(compare (match_operand:DF 0 \"arith_operand\" \"\")\n-\t\t (match_operand:DF 1 \"arith_operand\" \"\")))]\n+(define_expand \"cbranchdf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"sh_float_comparison_operator\"\n+\t\t       [(match_operand:DF 1 \"arith_operand\" \"\")\n+\t\t\t(match_operand:DF 2 \"arith_operand\" \"\")])\n+\t\t      (match_operand 3 \"\" \"\")\n+\t\t      (pc)))]\n   \"(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  sh_compare_op0 = operands[0];\n-  sh_compare_op1 = operands[1];\n+  if (TARGET_SHMEDIA)\n+    emit_jump_insn (gen_cbranchfp4_media (operands[0], operands[1], operands[2],\n+\t\t\t\t\t  operands[3]));\n+  else\n+    sh_emit_compare_and_branch (operands, DFmode);\n   DONE;\n }\")\n \n+\n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"arith_reg_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"arith_reg_operand\" \"\")))]\n@@ -14144,15 +13275,21 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   if (TARGET_SHMEDIA)\n     {\n       rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      rtx test;\n \n+      test = gen_rtx_NE (VOIDmode, tmp, const0_rtx);\n       if (TARGET_SHMEDIA64)\n-\temit_insn (gen_stack_protect_test_di_media (tmp, operands[0],\n-\t\t\t\t\t\t    operands[1]));\n+\t{\n+\t  emit_insn (gen_stack_protect_test_di_media (tmp, operands[0],\n+\t\t\t\t\t\t      operands[1]));\n+          emit_jump_insn (gen_cbranchdi4 (test, tmp, const0_rtx, operands[2]));\n+\t}\n       else\n-\temit_insn (gen_stack_protect_test_si_media (tmp, operands[0],\n-\t\t\t\t\t\t    operands[1]));\n-\n-      emit_jump_insn (gen_bne_media (operands[2], tmp, const0_rtx));\n+\t{\n+\t  emit_insn (gen_stack_protect_test_si_media (tmp, operands[0],\n+\t\t\t\t\t\t      operands[1]));\n+          emit_jump_insn (gen_cbranchsi4 (test, tmp, const0_rtx, operands[2]));\n+\t}\n     }\n   else\n     {"}, {"sha": "fd388dd8139231112ec942b1cd8c15d417053f8f", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -54,16 +54,14 @@ extern void sparc_output_scratch_registers (FILE *);\n #ifdef RTX_CODE\n extern enum machine_mode select_cc_mode (enum rtx_code, rtx, rtx);\n /* Define the function that build the compare insn for scc and bcc.  */\n-extern rtx gen_compare_reg (enum rtx_code code);\n-extern rtx gen_compare_operator (enum rtx_code code);\n-extern enum rtx_code sparc_emit_float_lib_cmp (rtx, rtx, enum rtx_code);\n+extern rtx gen_compare_reg (rtx cmp);\n+extern rtx sparc_emit_float_lib_cmp (rtx, rtx, enum rtx_code);\n extern void sparc_emit_floatunsdi (rtx [2], enum machine_mode);\n extern void sparc_emit_fixunsdi (rtx [2], enum machine_mode);\n extern void emit_tfmode_binop (enum rtx_code, rtx *);\n extern void emit_tfmode_unop (enum rtx_code, rtx *);\n extern void emit_tfmode_cvt (enum rtx_code, rtx *);\n /* This function handles all v9 scc insns */\n-extern int gen_v9_scc (enum rtx_code, rtx *);\n extern void sparc_initialize_trampoline (rtx, rtx, rtx);\n extern void sparc64_initialize_trampoline (rtx, rtx, rtx);\n extern bool legitimate_constant_p (rtx);\n@@ -86,7 +84,8 @@ extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n extern const char *output_v8plus_shift (rtx *, rtx, const char *);\n extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n-extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);\n+extern bool emit_scc_insn (rtx []);\n+extern void emit_conditional_branch_insn (rtx []);\n extern void print_operand (FILE *, rtx, int);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n extern int arith_double_4096_operand (rtx, enum machine_mode);"}, {"sha": "330c2c0698173f8c6582674fec5eb4f90e545da5", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 186, "deletions": 92, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -280,10 +280,6 @@ static GTY(()) alias_set_type sparc_sr_alias_set;\n /* The alias set for the structure return value.  */\n static GTY(()) alias_set_type struct_value_alias_set;\n \n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-rtx sparc_compare_op0, sparc_compare_op1;\n-\n /* Vector to say how input registers are mapped to output registers.\n    HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to\n    eliminate it.  You must use -fomit-frame-pointer to get that.  */\n@@ -2005,19 +2001,18 @@ select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n     }\n }\n \n-/* Emit the compare insn and return the CC reg for a CODE comparison.  */\n+/* Emit the compare insn and return the CC reg for a CODE comparison\n+   with operands X and Y.  */\n \n-rtx\n-gen_compare_reg (enum rtx_code code)\n+static rtx\n+gen_compare_reg_1 (enum rtx_code code, rtx x, rtx y)\n {\n   enum machine_mode mode;\n-  rtx x, y, cc_reg;\n+  rtx cc_reg;\n \n-  if (GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_CC)\n-    return sparc_compare_op0;\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_CC)\n+    return x;\n \n-  x = sparc_compare_op0;\n-  y = sparc_compare_op1;\n   mode = SELECT_CC_MODE (code, x, y);\n \n   /* ??? We don't have movcc patterns so we cannot generate pseudo regs for the\n@@ -2073,26 +2068,19 @@ gen_compare_reg (enum rtx_code code)\n   return cc_reg;\n }\n \n-/* Same as above but return the whole compare operator.  */\n+\n+/* Emit the compare insn and return the CC reg for the comparison in CMP.  */\n \n rtx\n-gen_compare_operator (enum rtx_code code)\n+gen_compare_reg (rtx cmp)\n {\n-  rtx cc_reg;\n-\n-  if (GET_MODE (sparc_compare_op0) == TFmode && !TARGET_HARD_QUAD)\n-    code\n-      = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, code);\n-\n-  cc_reg = gen_compare_reg (code);\n-  return gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+  return gen_compare_reg_1 (GET_CODE (cmp), XEXP (cmp, 0), XEXP (cmp, 1));\n }\n \n /* This function is used for v9 only.\n+   DEST is the target of the Scc insn.\n    CODE is the code for an Scc's comparison.\n-   OPERANDS[0] is the target of the Scc insn.\n-   OPERANDS[1] is the value we compare against const0_rtx (which hasn't\n-   been generated yet).\n+   X and Y are the values we compare.\n \n    This function is needed to turn\n \n@@ -2106,101 +2094,188 @@ gen_compare_operator (enum rtx_code code)\n \n    IE: The instruction recognizer needs to see the mode of the comparison to\n    find the right instruction. We could use \"gt:DI\" right in the\n-   define_expand, but leaving it out allows us to handle DI, SI, etc.\n+   define_expand, but leaving it out allows us to handle DI, SI, etc.  */\n \n-   We refer to the global sparc compare operands sparc_compare_op0 and\n-   sparc_compare_op1.  */\n-\n-int\n-gen_v9_scc (enum rtx_code compare_code, register rtx *operands)\n+static int\n+gen_v9_scc (rtx dest, enum rtx_code compare_code, rtx x, rtx y)\n {\n   if (! TARGET_ARCH64\n-      && (GET_MODE (sparc_compare_op0) == DImode\n-\t  || GET_MODE (operands[0]) == DImode))\n+      && (GET_MODE (x) == DImode\n+\t  || GET_MODE (dest) == DImode))\n     return 0;\n \n   /* Try to use the movrCC insns.  */\n   if (TARGET_ARCH64\n-      && GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_INT\n-      && sparc_compare_op1 == const0_rtx\n+      && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n+      && y == const0_rtx\n       && v9_regcmp_p (compare_code))\n     {\n-      rtx op0 = sparc_compare_op0;\n+      rtx op0 = x;\n       rtx temp;\n \n       /* Special case for op0 != 0.  This can be done with one instruction if\n-\t operands[0] == sparc_compare_op0.  */\n+\t dest == x.  */\n \n       if (compare_code == NE\n-\t  && GET_MODE (operands[0]) == DImode\n-\t  && rtx_equal_p (op0, operands[0]))\n+\t  && GET_MODE (dest) == DImode\n+\t  && rtx_equal_p (op0, dest))\n \t{\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dest,\n \t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n \t\t\t\t       gen_rtx_fmt_ee (compare_code, DImode,\n \t\t\t\t\t\t       op0, const0_rtx),\n \t\t\t\t       const1_rtx,\n-\t\t\t\t       operands[0])));\n+\t\t\t\t       dest)));\n \t  return 1;\n \t}\n \n-      if (reg_overlap_mentioned_p (operands[0], op0))\n+      if (reg_overlap_mentioned_p (dest, op0))\n \t{\n-\t  /* Handle the case where operands[0] == sparc_compare_op0.\n+\t  /* Handle the case where dest == x.\n \t     We \"early clobber\" the result.  */\n-\t  op0 = gen_reg_rtx (GET_MODE (sparc_compare_op0));\n-\t  emit_move_insn (op0, sparc_compare_op0);\n+\t  op0 = gen_reg_rtx (GET_MODE (x));\n+\t  emit_move_insn (op0, x);\n \t}\n \n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, const0_rtx));\n       if (GET_MODE (op0) != DImode)\n \t{\n \t  temp = gen_reg_rtx (DImode);\n \t  convert_move (temp, op0, 0);\n \t}\n       else\n \ttemp = op0;\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+      emit_insn (gen_rtx_SET (VOIDmode, dest,\n+\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (dest),\n \t\t\t\t   gen_rtx_fmt_ee (compare_code, DImode,\n \t\t\t\t\t\t   temp, const0_rtx),\n \t\t\t\t   const1_rtx,\n-\t\t\t\t   operands[0])));\n+\t\t\t\t   dest)));\n       return 1;\n     }\n   else\n     {\n-      operands[1] = gen_compare_reg (compare_code);\n+      x = gen_compare_reg_1 (compare_code, x, y);\n+      y = const0_rtx;\n \n-      switch (GET_MODE (operands[1]))\n-\t{\n-\t  case CCmode :\n-\t  case CCXmode :\n-\t  case CCFPEmode :\n-\t  case CCFPmode :\n-\t    break;\n-\t  default :\n-\t    gcc_unreachable ();\n-\t}\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], const0_rtx));\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+      gcc_assert (GET_MODE (x) != CC_NOOVmode\n+\t\t  && GET_MODE (x) != CCX_NOOVmode);\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, dest,\n+\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (dest),\n \t\t\t\t   gen_rtx_fmt_ee (compare_code,\n-\t\t\t\t\t\t   GET_MODE (operands[1]),\n-\t\t\t\t\t\t   operands[1], const0_rtx),\n-\t\t\t\t    const1_rtx, operands[0])));\n+\t\t\t\t\t\t   GET_MODE (x), x, y),\n+\t\t\t\t    const1_rtx, dest)));\n       return 1;\n     }\n }\n \n+\n+/* Emit an scc insn.  For seq, sne, sgeu, and sltu, we can do this\n+   without jumps using the addx/subx instructions.  */\n+\n+bool\n+emit_scc_insn (rtx operands[])\n+{\n+  rtx tem;\n+  rtx x;\n+  rtx y;\n+  enum rtx_code code;\n+\n+  /* The quad-word fp compare library routines all return nonzero to indicate\n+     true, which is different from the equivalent libgcc routines, so we must\n+     handle them specially here.  */\n+  if (GET_MODE (operands[2]) == TFmode && ! TARGET_HARD_QUAD)\n+    {\n+      operands[1] = sparc_emit_float_lib_cmp (operands[2], operands[3],\n+\t\t\t\t\t      GET_CODE (operands[1]));\n+      operands[2] = XEXP (operands[1], 0);\n+      operands[3] = XEXP (operands[1], 1);\n+    }\n+\n+  code = GET_CODE (operands[1]);\n+  x = operands[2];\n+  y = operands[3];\n+\n+  /* For seq/sne on v9 we use the same code as v8 (the addx/subx method has\n+     more applications).  The exception to this is \"reg != 0\" which can\n+     be done in one instruction on v9 (so we do it).  */\n+  if (code == EQ)\n+    {\n+      if (GET_MODE (x) == SImode)\n+        {\n+          rtx pat = gen_seqsi_special (operands[0], x, y);\n+          emit_insn (pat);\n+          return true;\n+        }\n+      else if (GET_MODE (x) == DImode)\n+        {\n+          rtx pat = gen_seqdi_special (operands[0], x, y);\n+          emit_insn (pat);\n+          return true;\n+        }\n+    }\n+\n+  if (code == NE)\n+    {\n+      if (GET_MODE (x) == SImode)\n+        {\n+          rtx pat = gen_snesi_special (operands[0], x, y);\n+          emit_insn (pat);\n+          return true;\n+        }\n+      else if (GET_MODE (x) == DImode)\n+        {\n+          rtx pat = gen_snedi_special (operands[0], x, y);\n+          emit_insn (pat);\n+          return true;\n+        }\n+    }\n+\n+  /* For the rest, on v9 we can use conditional moves.  */\n+\n+  if (TARGET_V9)\n+    {\n+      if (gen_v9_scc (operands[0], code, x, y))\n+        return true;\n+    }\n+\n+  /* We can do LTU and GEU using the addx/subx instructions too.  And\n+     for GTU/LEU, if both operands are registers swap them and fall\n+     back to the easy case.  */\n+  if (code == GTU || code == LEU)\n+    {\n+      if ((GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+          && (GET_CODE (y) == REG || GET_CODE (y) == SUBREG))\n+        {\n+          tem = x;\n+          x = y;\n+          y = tem;\n+          code = swap_condition (code);\n+        }\n+    }\n+\n+  if (code == LTU || code == GEU)\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t      gen_rtx_fmt_ee (code, SImode, \n+\t\t\t\t\t      gen_compare_reg_1 (code, x, y),\n+\t\t\t\t\t      const0_rtx)));\n+      return true;\n+    }\n+\n+  /* Nope, do branches.  */\n+  return false;\n+}\n+\n /* Emit a conditional jump insn for the v9 architecture using comparison code\n    CODE and jump target LABEL.\n    This function exists to take advantage of the v9 brxx insns.  */\n \n-void\n+static void\n emit_v9_brxx_insn (enum rtx_code code, rtx op0, rtx label)\n {\n-  gcc_assert (GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) != MODE_CC);\n   emit_jump_insn (gen_rtx_SET (VOIDmode,\n \t\t\t   pc_rtx,\n \t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n@@ -2210,6 +2285,37 @@ emit_v9_brxx_insn (enum rtx_code code, rtx op0, rtx label)\n \t\t\t\t    pc_rtx)));\n }\n \n+void\n+emit_conditional_branch_insn (rtx operands[])\n+{\n+  /* The quad-word fp compare library routines all return nonzero to indicate\n+     true, which is different from the equivalent libgcc routines, so we must\n+     handle them specially here.  */\n+  if (GET_MODE (operands[1]) == TFmode && ! TARGET_HARD_QUAD)\n+    {\n+      operands[0] = sparc_emit_float_lib_cmp (operands[1], operands[2],\n+\t\t\t\t\t      GET_CODE (operands[0]));\n+      operands[1] = XEXP (operands[0], 0);\n+      operands[2] = XEXP (operands[0], 1);\n+    }\n+\n+  if (TARGET_ARCH64 && operands[2] == const0_rtx\n+      && GET_CODE (operands[1]) == REG\n+      && GET_MODE (operands[1]) == DImode)\n+    {\n+      emit_v9_brxx_insn (GET_CODE (operands[0]), operands[1], operands[3]);\n+      return;\n+    }\n+\n+  operands[1] = gen_compare_reg (operands[0]);\n+  operands[2] = const0_rtx;\n+  operands[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]), VOIDmode,\n+\t\t\t\toperands[1], operands[2]);\n+  emit_jump_insn (gen_cbranchcc4 (operands[0], operands[1], operands[2],\n+\t\t\t\t  operands[3]));\n+}\n+\n+\n /* Generate a DFmode part of a hard TFmode register.\n    REG is the TFmode hard register, LOW is 1 for the\n    low 64bit of the register and 0 otherwise.\n@@ -6116,7 +6222,7 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n    values as arguments instead of the TFmode registers themselves,\n    that's why we cannot call emit_float_lib_cmp.  */\n \n-enum rtx_code\n+rtx\n sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n {\n   const char *qpfunc;\n@@ -6207,32 +6313,24 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n   switch (comparison)\n     {\n     default:\n-      new_comparison = NE;\n-      emit_cmp_insn (result, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_NE (VOIDmode, result, const0_rtx);\n     case ORDERED:\n     case UNORDERED:\n       new_comparison = (comparison == UNORDERED ? EQ : NE);\n-      emit_cmp_insn (result, GEN_INT(3), new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_fmt_ee (new_comparison, VOIDmode, result, GEN_INT(3));\n     case UNGT:\n     case UNGE:\n       new_comparison = (comparison == UNGT ? GT : NE);\n-      emit_cmp_insn (result, const1_rtx, new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_fmt_ee (new_comparison, VOIDmode, result, const1_rtx);\n     case UNLE:\n-      new_comparison = NE;\n-      emit_cmp_insn (result, const2_rtx, new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_NE (VOIDmode, result, const2_rtx);\n     case UNLT:\n       tem = gen_reg_rtx (mode);\n       if (TARGET_ARCH32)\n \temit_insn (gen_andsi3 (tem, result, const1_rtx));\n       else\n \temit_insn (gen_anddi3 (tem, result, const1_rtx));\n-      new_comparison = NE;\n-      emit_cmp_insn (tem, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_NE (VOIDmode, tem, const0_rtx);\n     case UNEQ:\n     case LTGT:\n       tem = gen_reg_rtx (mode);\n@@ -6246,11 +6344,10 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n       else\n \temit_insn (gen_anddi3 (tem2, tem, const2_rtx));\n       new_comparison = (comparison == UNEQ ? EQ : NE);\n-      emit_cmp_insn (tem2, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n-      break;\n+      return gen_rtx_fmt_ee (new_comparison, VOIDmode, tem2, const0_rtx);\n     }\n \n-  return new_comparison;\n+  gcc_unreachable ();\n }\n \n /* Generate an unsigned DImode to FP conversion.  This is the same code\n@@ -9021,15 +9118,12 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n \t\t\t  gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),\n \t\t\t\t       res)));\n \n-  sparc_compare_op0 = resv;\n-  sparc_compare_op1 = val;\n-  cc = gen_compare_reg (NE);\n-\n+  cc = gen_compare_reg_1 (NE, resv, val);\n   emit_insn (gen_rtx_SET (VOIDmode, val, resv));\n \n-  sparc_compare_op0 = cc;\n-  sparc_compare_op1 = const0_rtx;\n-  emit_jump_insn (gen_bne (loop_label));\n+  /* Use cbranchcc4 to separate the compare and branch!  */\n+  emit_jump_insn (gen_cbranchcc4 (gen_rtx_NE (VOIDmode, cc, const0_rtx),\n+\t\t\t\t  cc, const0_rtx, loop_label));\n \n   emit_label (end_label);\n "}, {"sha": "280036224bee722dc439f6af72c6c27ec1472441", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -1558,12 +1558,6 @@ function_arg_padding ((MODE), (TYPE))\n   && (GET_MODE_ALIGNMENT (MODE) == 128\t\t\\\n       || ((TYPE) && TYPE_ALIGN (TYPE) == 128)))\t\\\n  ? 128 : PARM_BOUNDARY)\n-\f\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-\n-extern GTY(()) rtx sparc_compare_op0;\n-extern GTY(()) rtx sparc_compare_op1;\n \n \f\n /* Generate the special assembly code needed to tell the assembler whatever"}, {"sha": "9e35910f4db22efdf58dbefe110c140bb43e1d5d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 141, "deletions": 776, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -76,6 +76,18 @@\n    (UNSPECV_LDSTUB\t\t10)\n   ])\n \n+\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_iterator I [QI HI SI DI])\n+(define_mode_iterator F [SF DF TF])\n+\n+;; We don't define V1SI because SI should work just fine.\n+(define_mode_iterator V32 [SF V2HI V4QI])\n+(define_mode_iterator V32I [SI V2HI V4QI])\n+\n+(define_mode_iterator V64 [DF V2SI V4HI V8QI])\n+(define_mode_iterator V64I [DI V2SI V4HI V8QI])\n+\n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n ;; a second register class, EXTRA_FP_REGS, exists for the v9 chip.  The name\n ;; is a bit of a misnomer as it covers all 64 fp regs.  The corresponding\n@@ -340,84 +352,11 @@\n \n ;; Compare instructions.\n \n-;; We generate RTL for comparisons and branches by having the cmpxx \n-;; patterns store away the operands.  Then, the scc and bcc patterns\n-;; emit RTL for both the compare and the branch.\n-;;\n-;; We do this because we want to generate different code for an sne and\n-;; seq insn.  In those cases, if the second operand of the compare is not\n-;; const0_rtx, we want to compute the xor of the two operands and test\n-;; it against zero.\n-;;\n-;; We start with the DEFINE_EXPANDs, then the DEFINE_INSNs to match\n-;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n-;; insns that actually require more than one machine instruction.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 100)\n-\t(compare:CC (match_operand:SI 0 \"compare_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"\")))]\n-  \"\"\n-{\n-  if (GET_CODE (operands[0]) == ZERO_EXTRACT && operands[1] != const0_rtx)\n-    operands[0] = force_reg (SImode, operands[0]);\n-\n-  sparc_compare_op0 = operands[0];\n-  sparc_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmpdi\"\n-  [(set (reg:CCX 100)\n-\t(compare:CCX (match_operand:DI 0 \"compare_operand\" \"\")\n-\t\t     (match_operand:DI 1 \"arith_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n-{\n-  if (GET_CODE (operands[0]) == ZERO_EXTRACT && operands[1] != const0_rtx)\n-    operands[0] = force_reg (DImode, operands[0]);\n-\n-  sparc_compare_op0 = operands[0];\n-  sparc_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmpsf\"\n-  ;; The 96 here isn't ever used by anyone.\n-  [(set (reg:CCFP 96)\n-\t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t      (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU\"\n-{\n-  sparc_compare_op0 = operands[0];\n-  sparc_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmpdf\"\n-  ;; The 96 here isn't ever used by anyone.\n-  [(set (reg:CCFP 96)\n-\t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t      (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU\"\n-{\n-  sparc_compare_op0 = operands[0];\n-  sparc_compare_op1 = operands[1];\n-  DONE;\n-})\n-\n-(define_expand \"cmptf\"\n-  ;; The 96 here isn't ever used by anyone.\n-  [(set (reg:CCFP 96)\n-\t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n-\t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU\"\n-{\n-  sparc_compare_op0 = operands[0];\n-  sparc_compare_op1 = operands[1];\n-  DONE;\n-})\n+;; These are just the DEFINE_INSNs to match the patterns and the\n+;; DEFINE_SPLITs for some of the scc insns that actually require\n+;; more than one machine instruction.  DEFINE_EXPANDs are further down.\n \n-;; Now the compare DEFINE_INSNs.\n+;; The compare DEFINE_INSNs.\n \n (define_insn \"*cmpsi_insn\"\n   [(set (reg:CC 100)\n@@ -509,12 +448,41 @@\n }\n   [(set_attr \"type\" \"fpcmp\")])\n \f\n-;; Next come the scc insns.  For seq, sne, sgeu, and sltu, we can do this\n-;; without jumps using the addx/subx instructions.  For seq/sne on v9 we use\n-;; the same code as v8 (the addx/subx method has more applications).  The\n-;; exception to this is \"reg != 0\" which can be done in one instruction on v9\n-;; (so we do it).  For the rest, on v9 we use conditional moves; on v8, we do\n-;; branches.\n+;; Next come the scc insns.\n+\n+(define_expand \"cstoresi4\"\n+  [(use (match_operator 1 \"comparison_operator\"\n+         [(match_operand:SI 2 \"compare_operand\" \"\")\n+          (match_operand:SI 3 \"arith_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"\"\n+{\n+  if (GET_CODE (operands[2]) == ZERO_EXTRACT && operands[3] != const0_rtx)\n+    operands[2] = force_reg (SImode, operands[2]);\n+  if (emit_scc_insn (operands)) DONE; else FAIL;\n+})\n+\n+(define_expand \"cstoredi4\"\n+  [(use (match_operator 1 \"comparison_operator\"\n+         [(match_operand:DI 2 \"compare_operand\" \"\")\n+          (match_operand:DI 3 \"arith_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"TARGET_ARCH64\"\n+{\n+  if (GET_CODE (operands[2]) == ZERO_EXTRACT && operands[3] != const0_rtx)\n+    operands[2] = force_reg (DImode, operands[2]);\n+  if (emit_scc_insn (operands)) DONE; else FAIL;\n+})\n+\n+(define_expand \"cstore<F:mode>4\"\n+  [(use (match_operator 1 \"comparison_operator\"\n+         [(match_operand:F 2 \"register_operand\" \"\")\n+          (match_operand:F 3 \"register_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"register_operand\"))]\n+  \"TARGET_FPU\"\n+  { if (emit_scc_insn (operands)) DONE; else FAIL; })\n+\n+\f\n \n ;; Seq_special[_xxx] and sne_special[_xxx] clobber the CC reg, because they\n ;; generate addcc/subcc instructions.\n@@ -533,8 +501,8 @@\n   [(set (match_dup 3)\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(eq:DI (match_dup 3) (const_int 0)))]\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_dup 3) (const_int 0)))]\n   \"TARGET_ARCH64\"\n   { operands[3] = gen_reg_rtx (DImode); })\n \n@@ -549,24 +517,6 @@\n   { operands[3] = gen_reg_rtx (SImode); })\n \n (define_expand \"snedi_special\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ne:DI (match_dup 3) (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-(define_expand \"seqdi_special_trunc\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(eq:SI (match_dup 3) (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-(define_expand \"snedi_special_trunc\"\n   [(set (match_dup 3)\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n@@ -575,315 +525,6 @@\n   \"TARGET_ARCH64\"\n   { operands[3] = gen_reg_rtx (DImode); })\n \n-(define_expand \"seqsi_special_extend\"\n-  [(set (match_dup 3)\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (eq:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 100))])]\n-  \"TARGET_ARCH64\"\n-  { operands[3] = gen_reg_rtx (SImode); })\n-\n-(define_expand \"snesi_special_extend\"\n-  [(set (match_dup 3)\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (ne:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC 100))])]\n-  \"TARGET_ARCH64\"\n-  { operands[3] = gen_reg_rtx (SImode); })\n-\n-;; ??? v9: Operand 0 needs a mode, so SImode was chosen.\n-;; However, the code handles both SImode and DImode.\n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == SImode)\n-    {\n-      rtx pat;\n-\n-      if (GET_MODE (operands[0]) == SImode)\n-\tpat = gen_seqsi_special (operands[0], sparc_compare_op0,\n-\t\t\t\t sparc_compare_op1);\n-      else if (! TARGET_ARCH64)\n-\tFAIL;\n-      else\n-\tpat = gen_seqsi_special_extend (operands[0], sparc_compare_op0,\n-\t\t\t\t\tsparc_compare_op1);\n-      emit_insn (pat);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      rtx pat;\n-\n-      if (! TARGET_ARCH64)\n-\tFAIL;\n-      else if (GET_MODE (operands[0]) == SImode)\n-\tpat = gen_seqdi_special_trunc (operands[0], sparc_compare_op0,\n-\t\t\t\t       sparc_compare_op1);\n-      else\n-\tpat = gen_seqdi_special (operands[0], sparc_compare_op0,\n-\t\t\t\t sparc_compare_op1);\n-      emit_insn (pat);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (EQ, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-;; ??? v9: Operand 0 needs a mode, so SImode was chosen.\n-;; However, the code handles both SImode and DImode.\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == SImode)\n-    {\n-      rtx pat;\n-\n-      if (GET_MODE (operands[0]) == SImode)\n-\tpat = gen_snesi_special (operands[0], sparc_compare_op0,\n-\t\t\t\t sparc_compare_op1);\n-      else if (! TARGET_ARCH64)\n-\tFAIL;\n-      else\n-\tpat = gen_snesi_special_extend (operands[0], sparc_compare_op0,\n-\t\t\t\t\tsparc_compare_op1);\n-      emit_insn (pat);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      rtx pat;\n-\n-      if (! TARGET_ARCH64)\n-\tFAIL;\n-      else if (GET_MODE (operands[0]) == SImode)\n-\tpat = gen_snedi_special_trunc (operands[0], sparc_compare_op0,\n-\t\t\t\t       sparc_compare_op1);\n-      else\n-\tpat = gen_snedi_special (operands[0], sparc_compare_op0,\n-\t\t\t\t sparc_compare_op1);\n-      emit_insn (pat);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (NE, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (GT, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (LT, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (GE, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(le:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n-      gcc_assert (code == NE);\n-      emit_insn (gen_sne (operands[0]));\n-      DONE;\n-    }\n-  else if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (LE, operands))\n-\tDONE;\n-      /* fall through */\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (! TARGET_V9)\n-    {\n-      rtx tem, pat;\n-\n-      /* We can do ltu easily, so if both operands are registers, swap them and\n-\t do a LTU.  */\n-      if ((GET_CODE (sparc_compare_op0) == REG\n-\t   || GET_CODE (sparc_compare_op0) == SUBREG)\n-\t  && (GET_CODE (sparc_compare_op1) == REG\n-\t      || GET_CODE (sparc_compare_op1) == SUBREG))\n-\t{\n-\t  tem = sparc_compare_op0;\n-\t  sparc_compare_op0 = sparc_compare_op1;\n-\t  sparc_compare_op1 = tem;\n-\t  pat = gen_sltu (operands[0]);\n-          if (pat == NULL_RTX)\n-            FAIL;\n-          emit_insn (pat);\n-\t  DONE;\n-\t}\n-    }\n-  else\n-    {\n-      if (gen_v9_scc (GTU, operands))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(ltu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (LTU, operands))\n-\tDONE;\n-    }\n-  operands[1] = gen_compare_reg (LTU);\n-})\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(geu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (TARGET_V9)\n-    {\n-      if (gen_v9_scc (GEU, operands))\n-\tDONE;\n-    }\n-  operands[1] = gen_compare_reg (GEU);\n-})\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"int_register_operand\" \"\")\n-\t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-{\n-  if (! TARGET_V9)\n-    {\n-      rtx tem, pat;\n-\n-      /* We can do geu easily, so if both operands are registers, swap them and\n-\t do a GEU.  */\n-      if ((GET_CODE (sparc_compare_op0) == REG\n-\t   || GET_CODE (sparc_compare_op0) == SUBREG)\n-\t  && (GET_CODE (sparc_compare_op1) == REG\n-\t      || GET_CODE (sparc_compare_op1) == SUBREG))\n-\t{\n-\t  tem = sparc_compare_op0;\n-\t  sparc_compare_op0 = sparc_compare_op1;\n-\t  sparc_compare_op1 = tem;\n-\t  pat = gen_sgeu (operands[0]);\n-          if (pat == NULL_RTX)\n-            FAIL;\n-          emit_insn (pat);\n-\t  DONE;\n-\t}\n-    }\n-  else\n-    {\n-      if (gen_v9_scc (LEU, operands))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n \n ;; Now the DEFINE_INSNs for the scc cases.\n \n@@ -1275,344 +916,51 @@\n \f\n ;; These control RTL generation for conditional jump insns\n \n-;; The quad-word fp compare library routines all return nonzero to indicate\n-;; true, which is different from the equivalent libgcc routines, so we must\n-;; handle them specially here.\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (EQ, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (EQ);\n-})\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (NE, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (NE);\n-})\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (GT, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (GT);\n-})\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = gen_compare_reg (GTU);\n-})\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (LT, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (LT);\n-})\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = gen_compare_reg (LTU);\n-})\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (GE, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (GE);\n-})\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = gen_compare_reg (GEU);\n-})\n-\n-(define_expand \"ble\"\n+(define_expand \"cbranchcc4\"\n   [(set (pc)\n-\t(if_then_else (le (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t          [(match_operand 1 \"compare_operand\" \"\")\n+\t\t           (match_operand 2 \"const_zero_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-{\n-  if (TARGET_ARCH64 && sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode)\n-    {\n-      emit_v9_brxx_insn (LE, sparc_compare_op0, operands[0]);\n-      DONE;\n-    }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (LE);\n-})\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  operands[1] = gen_compare_reg (LEU);\n-})\n-\n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (unordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNORDERED);\n-      gcc_assert (code == EQ);\n-      emit_jump_insn (gen_beq (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNORDERED);\n-})\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (ordered (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, ORDERED);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (ORDERED);\n-})\n-\n-(define_expand \"bungt\"\n-  [(set (pc)\n-\t(if_then_else (ungt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGT);\n-      gcc_assert (code == GT);\n-      emit_jump_insn (gen_bgt (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNGT);\n-})\n+  \"\")\n \n-(define_expand \"bunlt\"\n-  [(set (pc)\n-\t(if_then_else (unlt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"cbranchsi4\"\n+  [(use (match_operator 0 \"comparison_operator\"\n+         [(match_operand:SI 1 \"compare_operand\" \"\")\n+          (match_operand:SI 2 \"arith_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLT);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNLT);\n+  if (GET_CODE (operands[1]) == ZERO_EXTRACT && operands[2] != const0_rtx)\n+    operands[1] = force_reg (SImode, operands[1]);\n+  emit_conditional_branch_insn (operands);\n+  DONE;\n })\n \n-(define_expand \"buneq\"\n-  [(set (pc)\n-\t(if_then_else (uneq (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n+(define_expand \"cbranchdi4\"\n+  [(use (match_operator 0 \"comparison_operator\"\n+         [(match_operand:DI 1 \"compare_operand\" \"\")\n+          (match_operand:DI 2 \"arith_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"TARGET_ARCH64\"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNEQ);\n-      gcc_assert (code == EQ);\n-      emit_jump_insn (gen_beq (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNEQ);\n+  if (GET_CODE (operands[1]) == ZERO_EXTRACT && operands[2] != const0_rtx)\n+    operands[1] = force_reg (DImode, operands[1]);\n+  emit_conditional_branch_insn (operands);\n+  DONE;\n })\n \n-(define_expand \"bunge\"\n-  [(set (pc)\n-\t(if_then_else (unge (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGE);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNGE);\n-})\n+(define_expand \"cbranch<F:mode>4\"\n+  [(use (match_operator 0 \"comparison_operator\"\n+         [(match_operand:F 1 \"register_operand\" \"\")\n+          (match_operand:F 2 \"register_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n+  \"TARGET_FPU\"\n+  { emit_conditional_branch_insn (operands); DONE; })\n \n-(define_expand \"bunle\"\n-  [(set (pc)\n-\t(if_then_else (unle (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLE);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (UNLE);\n-})\n \n-(define_expand \"bltgt\"\n-  [(set (pc)\n-\t(if_then_else (ltgt (match_dup 1) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n-    {\n-      enum rtx_code code\n-        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LTGT);\n-      gcc_assert (code == NE);\n-      emit_jump_insn (gen_bne (operands[0]));\n-      DONE;\n-    }\n-  operands[1] = gen_compare_reg (LTGT);\n-})\n-\f\n ;; Now match both normal and inverted jump.\n \n ;; XXX fpcmp nop braindamage\n@@ -1755,8 +1103,6 @@\n    (set_attr \"branch_type\" \"reg\")])\n \n \n-(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n-\n ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic\n ;; value subject to a PC-relative relocation.  Operand 2 is a helper function\n ;; that adds the PC value at the call point to operand 0.\n@@ -2393,9 +1739,6 @@\n \n ;; Floating point and vector move instructions\n \n-;; We don't define V1SI because SI should work just fine.\n-(define_mode_iterator V32 [SF V2HI V4QI])\n-\n ;; Yes, you guessed it right, the former movsf expander.\n (define_expand \"mov<V32:mode>\"\n   [(set (match_operand:V32 0 \"nonimmediate_operand\" \"\")\n@@ -2530,8 +1873,6 @@\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-(define_mode_iterator V64 [DF V2SI V4HI V8QI])\n-\n ;; Yes, you again guessed it right, the former movdf expander.\n (define_expand \"mov<V64:mode>\"\n   [(set (match_operand:V64 0 \"nonimmediate_operand\" \"\")\n@@ -3073,8 +2414,6 @@\n ;; 3 contains the constant if one is present, but we handle either for\n ;; generality (sparc.c puts a constant in operand 2).\n \n-(define_mode_iterator I [QI HI SI DI])\n-\n (define_expand \"mov<I:mode>cc\"\n   [(set (match_operand:I 0 \"register_operand\" \"\")\n \t(if_then_else:I (match_operand 1 \"comparison_operator\" \"\")\n@@ -3083,21 +2422,27 @@\n   \"TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n+  rtx cc_reg;\n \n-  if (GET_MODE (sparc_compare_op0) == DImode\n+  if (GET_MODE (XEXP (operands[1], 0)) == DImode\n       && ! TARGET_ARCH64)\n     FAIL;\n \n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n+  if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)\n+    operands[1]\n+      = sparc_emit_float_lib_cmp (XEXP (operands[1], 0), XEXP (operands[1], 1),\n+\t\t\t\t  GET_CODE (operands[1]));\n+\n+  if (XEXP (operands[1], 1) == const0_rtx\n+      && GET_CODE (XEXP (operands[1], 0)) == REG\n+      && GET_MODE (XEXP (operands[1], 0)) == DImode\n       && v9_regcmp_p (code))\n-    operands[1] = gen_rtx_fmt_ee (code, DImode, sparc_compare_op0, const0_rtx);\n+    cc_reg = XEXP (operands[1], 0);\n   else\n-    operands[1] = gen_compare_operator (code);\n-})\n+    cc_reg = gen_compare_reg (operands[1]);\n \n-(define_mode_iterator F [SF DF TF])\n+  operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+})\n \n (define_expand \"mov<F:mode>cc\"\n   [(set (match_operand:F 0 \"register_operand\" \"\")\n@@ -3107,18 +2452,26 @@\n   \"TARGET_V9 && TARGET_FPU\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n+  rtx cc_reg;\n \n-  if (GET_MODE (sparc_compare_op0) == DImode\n+  if (GET_MODE (XEXP (operands[1], 0)) == DImode\n       && ! TARGET_ARCH64)\n     FAIL;\n \n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n+  if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)\n+    operands[1]\n+      = sparc_emit_float_lib_cmp (XEXP (operands[1], 0), XEXP (operands[1], 1),\n+\t\t\t\t  GET_CODE (operands[1]));\n+\n+  if (XEXP (operands[1], 1) == const0_rtx\n+      && GET_CODE (XEXP (operands[1], 0)) == REG\n+      && GET_MODE (XEXP (operands[1], 0)) == DImode\n       && v9_regcmp_p (code))\n-    operands[1] = gen_rtx_fmt_ee (code, DImode, sparc_compare_op0, const0_rtx);\n+    cc_reg = XEXP (operands[1], 0);\n   else\n-    operands[1] = gen_compare_operator (code);\n+    cc_reg = gen_compare_reg (operands[1]);\n+\n+  operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n })\n \n ;; Conditional move define_insns\n@@ -5133,9 +4486,6 @@\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n-(define_mode_iterator V64I [DI V2SI V4HI V8QI])\n-(define_mode_iterator V32I [SI V2HI V4QI])\n-\n (define_expand \"and<V64I:mode>3\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"\")\n \t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n@@ -7434,14 +6784,28 @@\n   \"ta\\t5\"\n   [(set_attr \"type\" \"trap\")])\n \n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"noov_compare_operator\" [(match_dup 2) (match_dup 3)])\n-\t    (match_operand:SI 1 \"arith_operand\" \"\"))]\n+(define_expand \"ctrapsi4\"\n+  [(trap_if (match_operator 0 \"noov_compare_operator\"\n+\t     [(match_operand:SI 1 \"compare_operand\" \"\")\n+\t      (match_operand:SI 2 \"arith_operand\" \"\")])\n+\t   (match_operand 3 \"\"))]\n   \"\"\n-  \"operands[2] = gen_compare_reg (GET_CODE (operands[0]));\n-   if (GET_MODE (operands[2]) != CCmode && GET_MODE (operands[2]) != CCXmode)\n+  \"operands[1] = gen_compare_reg (operands[0]);\n+   if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n      FAIL;\n-   operands[3] = const0_rtx;\")\n+   operands[2] = const0_rtx;\")\n+\n+(define_expand \"ctrapdi4\"\n+  [(trap_if (match_operator 0 \"noov_compare_operator\"\n+\t     [(match_operand:DI 1 \"compare_operand\" \"\")\n+\t      (match_operand:DI 2 \"arith_operand\" \"\")])\n+\t   (match_operand 3 \"\"))]\n+  \"TARGET_ARCH64\"\n+  \"operands[1] = gen_compare_reg (operands[0]);\n+   if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n+     FAIL;\n+   operands[2] = const0_rtx;\")\n+\n \n (define_insn \"\"\n   [(trap_if (match_operator 0 \"noov_compare_operator\" [(reg:CC 100) (const_int 0)])\n@@ -8071,25 +7435,26 @@\n    (match_operand 2 \"\" \"\")]\n   \"\"\n {\n+  rtx result, test;\n #ifdef TARGET_THREAD_SSP_OFFSET\n   rtx tlsreg = gen_rtx_REG (Pmode, 7);\n   rtx addr = gen_rtx_PLUS (Pmode, tlsreg, GEN_INT (TARGET_THREAD_SSP_OFFSET));\n   operands[1] = gen_rtx_MEM (Pmode, addr);\n #endif\n   if (TARGET_ARCH64)\n     {\n-      rtx temp = gen_reg_rtx (Pmode);\n-      emit_insn (gen_stack_protect_testdi (temp, operands[0], operands[1]));\n-      sparc_compare_op0 = temp;\n-      sparc_compare_op1 = const0_rtx;\n+      result = gen_reg_rtx (Pmode);\n+      emit_insn (gen_stack_protect_testdi (result, operands[0], operands[1]));\n+      test = gen_rtx_EQ (VOIDmode, result, const0_rtx);\n+      emit_jump_insn (gen_cbranchdi4 (test, result, const0_rtx, operands[2]));\n     }\n   else\n     {\n       emit_insn (gen_stack_protect_testsi (operands[0], operands[1]));\n-      sparc_compare_op0 = gen_rtx_REG (CCmode, SPARC_ICC_REG);\n-      sparc_compare_op1 = const0_rtx;\n+      result = gen_rtx_REG (CCmode, SPARC_ICC_REG);\n+      test = gen_rtx_EQ (VOIDmode, result, const0_rtx);\n+      emit_jump_insn (gen_cbranchcc4 (test, result, const0_rtx, operands[2]));\n     }\n-  emit_jump_insn (gen_beq (operands[2]));\n   DONE;\n })\n "}, {"sha": "3e2600b996b1d31b23310ef4780b7e941178d57f", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -28,8 +28,7 @@ extern int valid_subreg (rtx op);\n extern void spu_expand_extv (rtx * ops, int unsignedp);\n extern void spu_expand_insv (rtx * ops);\n extern int spu_expand_block_move (rtx * ops);\n-extern void spu_emit_branch_or_set (int is_set, enum rtx_code code,\n-\t\t\t\t    rtx * operands);\n+extern void spu_emit_branch_or_set (int is_set, rtx cmp, rtx * operands);\n extern int spu_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern HOST_WIDE_INT const_double_to_hwint (rtx x);\n extern rtx hwint_to_const_double (enum machine_mode mode, HOST_WIDE_INT v);"}, {"sha": "f73bb217605f9c8b6019bb814755ca6b3ec7b476", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -212,7 +212,6 @@ static void asm_file_start (void);\n static unsigned int spu_section_type_flags (tree, const char *, int);\n \n extern const char *reg_names[];\n-rtx spu_compare_op0, spu_compare_op1;\n \n /* Which instruction set architecture to use.  */\n int spu_arch;\n@@ -844,42 +843,44 @@ int spu_comp_icode[12][3] = {\n    WORD_MODE, we can generate better code in most cases if we do it\n    ourselves.  */\n void\n-spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n+spu_emit_branch_or_set (int is_set, rtx cmp, rtx operands[])\n {\n   int reverse_compare = 0;\n   int reverse_test = 0;\n   rtx compare_result, eq_result;\n   rtx comp_rtx, eq_rtx;\n-  rtx target = operands[0];\n   enum machine_mode comp_mode;\n   enum machine_mode op_mode;\n   enum spu_comp_code scode, eq_code;\n   enum insn_code ior_code;\n+  enum rtx_code code = GET_CODE (cmp);\n+  rtx op0 = XEXP (cmp, 0);\n+  rtx op1 = XEXP (cmp, 1);\n   int index;\n   int eq_test = 0;\n \n-  /* When spu_compare_op1 is a CONST_INT change (X >= C) to (X > C-1),\n+  /* When op1 is a CONST_INT change (X >= C) to (X > C-1),\n      and so on, to keep the constant in operand 1. */\n-  if (GET_CODE (spu_compare_op1) == CONST_INT)\n+  if (GET_CODE (op1) == CONST_INT)\n     {\n-      HOST_WIDE_INT val = INTVAL (spu_compare_op1) - 1;\n-      if (trunc_int_for_mode (val, GET_MODE (spu_compare_op0)) == val)\n+      HOST_WIDE_INT val = INTVAL (op1) - 1;\n+      if (trunc_int_for_mode (val, GET_MODE (op0)) == val)\n \tswitch (code)\n \t  {\n \t  case GE:\n-\t    spu_compare_op1 = GEN_INT (val);\n+\t    op1 = GEN_INT (val);\n \t    code = GT;\n \t    break;\n \t  case LT:\n-\t    spu_compare_op1 = GEN_INT (val);\n+\t    op1 = GEN_INT (val);\n \t    code = LE;\n \t    break;\n \t  case GEU:\n-\t    spu_compare_op1 = GEN_INT (val);\n+\t    op1 = GEN_INT (val);\n \t    code = GTU;\n \t    break;\n \t  case LTU:\n-\t    spu_compare_op1 = GEN_INT (val);\n+\t    op1 = GEN_INT (val);\n \t    code = LEU;\n \t    break;\n \t  default:\n@@ -888,7 +889,7 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n     }\n \n   comp_mode = SImode;\n-  op_mode = GET_MODE (spu_compare_op0);\n+  op_mode = GET_MODE (op0);\n \n   switch (code)\n     {\n@@ -1012,42 +1013,41 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n       abort ();\n     }\n \n-  if (GET_MODE (spu_compare_op1) == DFmode\n+  if (GET_MODE (op1) == DFmode\n       && (scode != SPU_GT && scode != SPU_EQ))\n     abort ();\n \n-  if (is_set == 0 && spu_compare_op1 == const0_rtx\n-      && (GET_MODE (spu_compare_op0) == SImode\n-\t  || GET_MODE (spu_compare_op0) == HImode) && scode == SPU_EQ)\n+  if (is_set == 0 && op1 == const0_rtx\n+      && (GET_MODE (op0) == SImode\n+\t  || GET_MODE (op0) == HImode) && scode == SPU_EQ)\n     {\n       /* Don't need to set a register with the result when we are \n          comparing against zero and branching. */\n       reverse_test = !reverse_test;\n-      compare_result = spu_compare_op0;\n+      compare_result = op0;\n     }\n   else\n     {\n       compare_result = gen_reg_rtx (comp_mode);\n \n       if (reverse_compare)\n \t{\n-\t  rtx t = spu_compare_op1;\n-\t  spu_compare_op1 = spu_compare_op0;\n-\t  spu_compare_op0 = t;\n+\t  rtx t = op1;\n+\t  op1 = op0;\n+\t  op0 = t;\n \t}\n \n       if (spu_comp_icode[index][scode] == 0)\n \tabort ();\n \n       if (!(*insn_data[spu_comp_icode[index][scode]].operand[1].predicate)\n-\t  (spu_compare_op0, op_mode))\n-\tspu_compare_op0 = force_reg (op_mode, spu_compare_op0);\n+\t  (op0, op_mode))\n+\top0 = force_reg (op_mode, op0);\n       if (!(*insn_data[spu_comp_icode[index][scode]].operand[2].predicate)\n-\t  (spu_compare_op1, op_mode))\n-\tspu_compare_op1 = force_reg (op_mode, spu_compare_op1);\n+\t  (op1, op_mode))\n+\top1 = force_reg (op_mode, op1);\n       comp_rtx = GEN_FCN (spu_comp_icode[index][scode]) (compare_result,\n-\t\t\t\t\t\t\t spu_compare_op0,\n-\t\t\t\t\t\t\t spu_compare_op1);\n+\t\t\t\t\t\t\t op0, op1);\n       if (comp_rtx == 0)\n \tabort ();\n       emit_insn (comp_rtx);\n@@ -1056,8 +1056,7 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n         {\n           eq_result = gen_reg_rtx (comp_mode);\n           eq_rtx = GEN_FCN (spu_comp_icode[index][eq_code]) (eq_result,\n-\t\t\t\t\t\t\t     spu_compare_op0,\n-\t\t\t\t\t\t\t     spu_compare_op1);\n+\t\t\t\t\t\t\t     op0, op1);\n           if (eq_rtx == 0)\n \t    abort ();\n           emit_insn (eq_rtx);\n@@ -1088,13 +1087,14 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n       else\n \tbcomp = gen_rtx_NE (comp_mode, compare_result, const0_rtx);\n \n-      loc_ref = gen_rtx_LABEL_REF (VOIDmode, target);\n+      loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n       emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n \t\t\t\t\t\t\t loc_ref, pc_rtx)));\n     }\n   else if (is_set == 2)\n     {\n+      rtx target = operands[0];\n       int compare_size = GET_MODE_BITSIZE (comp_mode);\n       int target_size = GET_MODE_BITSIZE (GET_MODE (target));\n       enum machine_mode mode = mode_for_size (target_size, MODE_INT, 0);\n@@ -1129,6 +1129,7 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n     }\n   else\n     {\n+      rtx target = operands[0];\n       if (reverse_test)\n \temit_insn (gen_rtx_SET (VOIDmode, compare_result,\n \t\t\t\tgen_rtx_NOT (comp_mode, compare_result)));"}, {"sha": "ddd464ac579bb123a8594e5a361ee784c18b44b7", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -606,11 +606,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n       }                                                                   \\\n   } while (0)\n \n-/* These are set by the cmp patterns and used while expanding\n-   conditional branches. */\n-extern GTY(()) rtx spu_compare_op0;\n-extern GTY(()) rtx spu_compare_op1;\n-\n \n /* Builtins.  */\n "}, {"sha": "db42db1611149cefba8c080b066857deab446d28", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 50, "deletions": 137, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -3657,57 +3657,6 @@ selb\\t%0,%4,%0,%3\"\n   [(set_attr \"type\" \"br\")])\n \n \f\n-;; Compare insns are next.  Note that the spu has two types of compares,\n-;; signed & unsigned, and one type of branch.\n-;;\n-;; Start with the DEFINE_EXPANDs to generate the rtl for compares, scc\n-;; insns, and branches.  We store the operands of compares until we see\n-;; how it is used.\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:VQHSI 0 \"spu_reg_operand\" \"\")\n-  \t\t (match_operand:VQHSI 1 \"spu_nonmem_operand\" \"\")))]\n-  \"\"\n-  {\n-    spu_compare_op0 = operands[0];\n-    spu_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:DTI 0 \"spu_reg_operand\" \"\")\n-  \t\t (match_operand:DTI 1 \"spu_reg_operand\" \"\")))]\n-  \"\"\n-  {\n-    spu_compare_op0 = operands[0];\n-    spu_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:VSF 0 \"spu_reg_operand\" \"\")\n-  \t\t (match_operand:VSF 1 \"spu_reg_operand\" \"\")))]\n-  \"\"\n-  {\n-    spu_compare_op0 = operands[0];\n-    spu_compare_op1 = operands[1];\n-    DONE;\n-  })\n-\n-(define_expand \"cmpdf\"\n-  [(set (cc0)\n-        (compare (match_operand:DF 0 \"register_operand\" \"\")\n-                 (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"{\n-  spu_compare_op0 = operands[0];\n-  spu_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;; vector conditional compare patterns\n (define_expand \"vcond<mode>\"\n   [(set (match_operand:VCMP 0 \"spu_reg_operand\" \"=r\")\n@@ -3746,108 +3695,72 @@ selb\\t%0,%4,%0,%3\"\n \f\n ;; branch on condition\n \n-(define_expand \"beq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, EQ, operands); DONE; })\n-\n-(define_expand \"bne\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, NE, operands); DONE; })\n-\n-(define_expand \"bge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, GE, operands); DONE; })\n-\n-(define_expand \"bgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, GT, operands); DONE; })\n-\n-(define_expand \"ble\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, LE, operands); DONE; })\n-\n-(define_expand \"blt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranch<mode>4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:VQHSI 1 \"spu_reg_operand\" \"\")\n+\t  (match_operand:VQHSI 2 \"spu_nonmem_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  { spu_emit_branch_or_set (0, LT, operands); DONE; })\n+  { spu_emit_branch_or_set (0, operands[0], operands); DONE; })\n \n-(define_expand \"bgeu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranch<mode>4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:DTI 1 \"spu_reg_operand\" \"\")\n+\t  (match_operand:DTI 2 \"spu_reg_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  { spu_emit_branch_or_set (0, GEU, operands); DONE; })\n+  { spu_emit_branch_or_set (0, operands[0], operands); DONE; })\n \n-(define_expand \"bgtu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranch<mode>4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:VSF 1 \"spu_reg_operand\" \"\")\n+\t  (match_operand:VSF 2 \"spu_reg_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  { spu_emit_branch_or_set (0, GTU, operands); DONE; })\n+  { spu_emit_branch_or_set (0, operands[0], operands); DONE; })\n \n-(define_expand \"bleu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranchdf4\"\n+  [(use (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:DF 1 \"spu_reg_operand\" \"\")\n+\t  (match_operand:DF 2 \"spu_reg_operand\" \"\")]))\n+   (use (match_operand 3 \"\"))]\n   \"\"\n-  { spu_emit_branch_or_set (0, LEU, operands); DONE; })\n-\n-(define_expand \"bltu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (0, LTU, operands); DONE; })\n+  { spu_emit_branch_or_set (0, operands[0], operands); DONE; })\n \n \f\n ;; set on condition\n \n-(define_expand \"seq\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, EQ, operands); DONE; })\n-\n-(define_expand \"sne\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, NE, operands); DONE; })\n-\n-(define_expand \"sgt\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, GT, operands); DONE; })\n-\n-(define_expand \"slt\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, LT, operands); DONE; })\n-\n-(define_expand \"sge\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, GE, operands); DONE; })\n-\n-(define_expand \"sle\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n-  \"\"\n-  { spu_emit_branch_or_set (1, LE, operands); DONE; })\n-\n-(define_expand \"sgtu\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"ordered_comparison_operator\"\n+\t [(match_operand:VQHSI 2 \"spu_reg_operand\" \"\")\n+\t  (match_operand:VQHSI 3 \"spu_nonmem_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"spu_reg_operand\"))]\n   \"\"\n-  { spu_emit_branch_or_set (1, GTU, operands); DONE; })\n+  { spu_emit_branch_or_set (1, operands[1], operands); DONE; })\n \n-(define_expand \"sltu\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"ordered_comparison_operator\"\n+\t [(match_operand:DTI 2 \"spu_reg_operand\" \"\")\n+\t  (match_operand:DTI 3 \"spu_reg_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"spu_reg_operand\"))]\n   \"\"\n-  { spu_emit_branch_or_set (1, LTU, operands); DONE; })\n+  { spu_emit_branch_or_set (1, operands[1], operands); DONE; })\n \n-(define_expand \"sgeu\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"ordered_comparison_operator\"\n+\t [(match_operand:VSF 2 \"spu_reg_operand\" \"\")\n+\t  (match_operand:VSF 3 \"spu_reg_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"spu_reg_operand\"))]\n   \"\"\n-  { spu_emit_branch_or_set (1, GEU, operands); DONE; })\n+  { spu_emit_branch_or_set (1, operands[1], operands); DONE; })\n \n-(define_expand \"sleu\"\n-  [(clobber (match_operand:SI 0 \"spu_reg_operand\" \"\"))]\n+(define_expand \"cstoredf4\"\n+  [(use (match_operator 1 \"ordered_comparison_operator\"\n+\t [(match_operand:DF 2 \"spu_reg_operand\" \"\")\n+\t  (match_operand:DF 3 \"spu_reg_operand\" \"\")]))\n+   (clobber (match_operand:SI 0 \"spu_reg_operand\"))]\n   \"\"\n-  { spu_emit_branch_or_set (1, LEU, operands); DONE; })\n+  { spu_emit_branch_or_set (1, operands[1], operands); DONE; })\n \n \f\n ;; conditional move\n@@ -3863,12 +3776,12 @@ selb\\t%0,%4,%0,%3\"\n \n (define_expand \"mov<mode>cc\"\n   [(set (match_operand:ALL 0 \"spu_reg_operand\" \"\")\n-\t(if_then_else:ALL (match_operand 1 \"comparison_operator\" \"\")\n+\t(if_then_else:ALL (match_operand 1 \"ordered_comparison_operator\" \"\")\n \t\t      (match_operand:ALL 2 \"spu_reg_operand\" \"\")\n \t\t      (match_operand:ALL 3 \"spu_reg_operand\" \"\")))]\n   \"\"\n   {\n-    spu_emit_branch_or_set(2, GET_CODE(operands[1]), operands);\n+    spu_emit_branch_or_set(2, operands[1], operands);\n     DONE;\n   })\n "}, {"sha": "bde411b4e3af5e1cfd23c933569f6822de271bc1", "filename": "gcc/config/stormy16/stormy16-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -48,7 +48,7 @@ extern rtx xstormy16_function_value (const_tree, const_tree);\n #endif\n \n #ifdef RTX_CODE\n-extern void xstormy16_emit_cbranch (enum rtx_code, rtx);\n+extern void xstormy16_emit_cbranch (enum rtx_code, rtx, rtx, rtx);\n extern char *xstormy16_output_cbranch_hi (rtx, const char *, int, rtx);\n extern char *xstormy16_output_cbranch_si (rtx, const char *, int, rtx);\n extern int xstormy16_mode_dependent_address_p (rtx);"}, {"sha": "4d04cae95d9bc387a134ca027d81aa22b8df2c82", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -61,11 +61,6 @@ static bool xstormy16_rtx_costs (rtx, int, int, int *, bool);\n static int xstormy16_address_cost (rtx, bool);\n static bool xstormy16_return_in_memory (const_tree, const_tree);\n \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-struct rtx_def * xstormy16_compare_op0;\n-struct rtx_def * xstormy16_compare_op1;\n-\n static GTY(()) section *bss100_section;\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete\n@@ -139,10 +134,8 @@ xstormy16_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n /* Emit a branch of kind CODE to location LOC.  */\n \n void\n-xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n+xstormy16_emit_cbranch (enum rtx_code code, rtx op0, rtx op1, rtx loc)\n {\n-  rtx op0 = xstormy16_compare_op0;\n-  rtx op1 = xstormy16_compare_op1;\n   rtx condition_rtx, loc_ref, branch, cy_clobber;\n   rtvec vec;\n   enum machine_mode mode;\n@@ -159,10 +152,10 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n \n       if (gt_p)\n \tlab = gen_label_rtx ();\n-      xstormy16_emit_cbranch (unsigned_p ? LTU : LT, gt_p ? lab : loc);\n+      xstormy16_emit_cbranch (unsigned_p ? LTU : LT, op0, op1, gt_p ? lab : loc);\n       /* This should be generated as a comparison against the temporary\n \t created by the previous insn, but reload can't handle that.  */\n-      xstormy16_emit_cbranch (gt_p ? NE : EQ, loc);\n+      xstormy16_emit_cbranch (gt_p ? NE : EQ, op0, op1, loc);\n       if (gt_p)\n \temit_label (lab);\n       return;\n@@ -171,6 +164,7 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n \t   && (code == NE || code == EQ)\n \t   && op1 != const0_rtx)\n     {\n+      rtx op0_word, op1_word;\n       rtx lab = NULL_RTX;\n       int num_words = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n       int i;\n@@ -180,17 +174,17 @@ xstormy16_emit_cbranch (enum rtx_code code, rtx loc)\n \n       for (i = 0; i < num_words - 1; i++)\n \t{\n-\t  xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode,\n-\t\t\t\t\t\t      i * UNITS_PER_WORD);\n-\t  xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode,\n-\t\t\t\t\t\t      i * UNITS_PER_WORD);\n-\t  xstormy16_emit_cbranch (NE, code == EQ ? lab : loc);\n+\t  op0_word = simplify_gen_subreg (word_mode, op0, mode,\n+\t\t\t\t\t  i * UNITS_PER_WORD);\n+\t  op1_word = simplify_gen_subreg (word_mode, op1, mode,\n+\t\t\t\t\t  i * UNITS_PER_WORD);\n+\t  xstormy16_emit_cbranch (NE, op0_word, op1_word, code == EQ ? lab : loc);\n \t}\n-      xstormy16_compare_op0 = simplify_gen_subreg (word_mode, op0, mode,\n-\t\t\t\t\t\t  i * UNITS_PER_WORD);\n-      xstormy16_compare_op1 = simplify_gen_subreg (word_mode, op1, mode,\n-\t\t\t\t\t\t  i * UNITS_PER_WORD);\n-      xstormy16_emit_cbranch (code, loc);\n+      op0_word = simplify_gen_subreg (word_mode, op0, mode,\n+\t\t\t\t      i * UNITS_PER_WORD);\n+      op1_word = simplify_gen_subreg (word_mode, op1, mode,\n+\t\t\t\t      i * UNITS_PER_WORD);\n+      xstormy16_emit_cbranch (code, op0_word, op1_word, loc);\n \n       if (code == EQ)\n \temit_label (lab);"}, {"sha": "d626edf6e5091c558165d1df7bc7c0568eb47cdd", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -801,11 +801,4 @@ do  {\t\t\t\t\t\t\\\n    is responsible for updating the value of MORE (typically by (MORE)--).  */\n /* #define MD_SCHED_VARIABLE_ISSUE (FILE, VERBOSE, INSN, MORE) */\n \n-\f\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def *xstormy16_compare_op0, *xstormy16_compare_op1;\n-\n /* End of xstormy16.h */"}, {"sha": "9c86d43e627742604c9d61e2f579acf19f0f3102", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 26, "deletions": 79, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -736,96 +736,43 @@\n \t\t\t\t    operands[0], operands[2], operands[3]);\"\n   [(set_attr \"length\" \"6,10\")\n    (set_attr \"psw_operand\" \"clobber,clobber\")])\n-\f\n-;; ::::::::::::::::::::\n-;; ::\n-;; :: Comparisons\n-;; ::\n-;; ::::::::::::::::::::\n-\n-;; Note, we store the operands in the comparison insns, and use them later\n-;; when generating the branch or scc operation.\n-\n-;; First the routines called by the machine independent part of the compiler\n-(define_expand \"cmphi\"\n-  [(set (cc0)\n-        (compare (match_operand:HI 0 \"register_operand\" \"\")\n-  \t\t (match_operand:HI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    xstormy16_compare_op0 = operands[0];\n-    xstormy16_compare_op1 = operands[1];\n-    DONE;\n-  })\n \n-; There are no real SImode comparisons, but some can be emulated\n-; by performing a SImode subtract and looking at the condition flags.\n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-        (compare (match_operand:SI 0 \"register_operand\" \"\")\n-  \t\t (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    xstormy16_compare_op0 = operands[0];\n-    xstormy16_compare_op1 = operands[1];\n-    DONE;\n-  })\n \f\n ;; ::::::::::::::::::::\n ;; ::\n ;; :: Branches\n ;; ::\n ;; ::::::::::::::::::::\n \n-(define_expand \"beq\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (EQ, operands[0]); DONE; })\n-\n-(define_expand \"bne\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (NE, operands[0]); DONE; })\n-\n-(define_expand \"bge\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (GE, operands[0]); DONE; })\n-\n-(define_expand \"bgt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (GT, operands[0]); DONE; })\n-\n-(define_expand \"ble\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (LE, operands[0]); DONE; })\n-\n-(define_expand \"blt\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (LT, operands[0]); DONE; })\n-\n-(define_expand \"bgeu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (GEU, operands[0]); DONE; })\n-\n-(define_expand \"bgtu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n-  \"\"\n-  { xstormy16_emit_cbranch (GTU, operands[0]); DONE; })\n-\n-(define_expand \"bleu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranchhi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t\t       (match_operand:HI 2 \"nonmemory_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (reg:BI CARRY_REG))]\n   \"\"\n-  { xstormy16_emit_cbranch (LEU, operands[0]); DONE; })\n+  {\n+  xstormy16_emit_cbranch (GET_CODE (operands[0]), operands[1], operands[2],\n+\t\t\t  operands[3]);\n+  DONE;\n+})\n \n-(define_expand \"bltu\"\n-  [(use (match_operand 0 \"\" \"\"))]\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (reg:BI CARRY_REG))]\n   \"\"\n-  { xstormy16_emit_cbranch (LTU, operands[0]); DONE; })\n+  {\n+  xstormy16_emit_cbranch (GET_CODE (operands[0]), operands[1], operands[2],\n+\t\t\t  operands[3]);\n+  DONE;\n+})\n \n (define_insn \"cbranchhi\"\n   [(set (pc)"}, {"sha": "f9e8a7dd8b03c56407effd7f8d31659bc7a0d6a7", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -464,6 +464,11 @@ v850_rtx_costs (rtx x,\n \t*total = 20;\n       return true;\n \n+    case ZERO_EXTRACT:\n+      if (outer_code == COMPARE)\n+\t*total = 0;\n+      return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "69c8d881f898bdd49c3dd9fd290c19fb9b7abf92", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 57, "deletions": 245, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -227,47 +227,64 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"*v850_tst1\"\n-  [(set (cc0) (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n-                               (const_int 1)\n-                               (match_operand:QI 1 \"const_int_operand\" \"n\")))]\n+  [(set (cc0)\n+\t(compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n+                                  (const_int 1)\n+                                  (match_operand:QI 1 \"const_int_operand\" \"n\"))\n+\t\t (const_int 0)))]\n   \"\"\n   \"tst1 %1,%0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n ;; This replaces ld.b;sar;andi with tst1;setf nz.\n \n-;; ??? The zero_extract sets the Z bit to the opposite of what one would\n-;; expect.  This perhaps should be wrapped in a (eq: X (const_int 0)).\n-\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (zero_extract:SI (match_dup 1)\n-\t\t\t       (const_int 1)\n-\t\t\t       (match_dup 2)))\n+\t(compare (zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (match_operand 2 \"const_int_operand\" \"\"))\n+\t\t (const_int 0)))]\n+  \"\"\n+  [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n+\t\t\t\t        (const_int 1)\n+\t\t\t\t        (match_dup 2))\n+\t\t       (const_int 0)))\n    (set (match_dup 0) (ne:SI (cc0) (const_int 0)))])\n \n-(define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"cmp %.,%0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_znv\")])\n+(define_expand \"cbranchsi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"reg_or_int5_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else\n+\t      (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+\t\t\t\t\t\t\t       (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n+\n+(define_expand \"cstoresi4\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t (match_operand:SI 3 \"reg_or_int5_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 1 \"ordered_comparison_operator\" [(cc0)\n+\t\t\t\t\t\t\t    (const_int 0)]))]\n+  \"\")\n \n-(define_insn \"cmpsi\"\n+(define_insn \"*cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,I,J\")))]\n   \"\"\n   \"@\n   cmp %1,%0\n+  cmp %.,%0\n   cmp %1,%0\"\n-  [(set_attr \"length\" \"2,2\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"length\" \"2,2,2\")\n+   (set_attr \"cc\" \"compare,set_znv,compare\")])\n+\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n@@ -688,110 +705,25 @@\n ;; Scc INSTRUCTIONS\n ;; -----------------------------------------------------------------\n \n-(define_insn \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (le:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n-    return 0;\n-\n-  return \\\"setf le,%0\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (leu:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf nh,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (ge:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n-    return 0;\n-\n-  return \\\"setf ge,%0\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sgeu\"\n+(define_insn \"*setcc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (geu:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf nl,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (lt:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n-    return 0;\n-\n-  return \\\"setf lt,%0\\\";\n-}\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (ltu:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf l,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (gt:SI (cc0) (const_int 0)))]\n+        (match_operator:SI 1 \"comparison_operator\"\n+\t [(cc0) (const_int 0)]))]\n   \"\"\n   \"*\n {\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+\t  || GET_CODE (operands[1]) == GE\n+\t  || GET_CODE (operands[1]) == LE\n+\t  || GET_CODE (operands[1]) == LT))\n     return 0;\n \n-  return \\\"setf gt,%0\\\";\n+  return \\\"setf %c1,%0\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n-(define_insn \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (gtu:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf h,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"seq\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (eq:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf z,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (ne:SI (cc0) (const_int 0)))]\n-  \"\"\n-  \"setf nz,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")])\n-\n ;; ----------------------------------------------------------------------\n ;; CONDITIONAL MOVE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -800,25 +732,15 @@\n ;; hide the fact that this instruction uses cc0.  We do so by including the\n ;; compare instruction inside it.\n \n-;; ??? This is very ugly.  The right way to do this is to modify cmpsi so\n-;; that it doesn't emit RTL, and then modify the bcc/scc patterns so that\n-;; they emit RTL for the compare instruction.  Unfortunately, this requires\n-;; lots of changes that will be hard to sanitize.  So for now, cmpsi still\n-;; emits RTL, and I get the compare operands here from the previous insn.\n-\n (define_expand \"movsicc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n-\t (match_operator 1 \"comparison_operator\"\n-\t\t\t [(match_dup 4) (match_dup 5)])\n+\t (match_operand 1 \"comparison_operator\")\n \t (match_operand:SI 2 \"reg_or_const_operand\" \"rJ\")\n \t (match_operand:SI 3 \"reg_or_const_operand\" \"rI\")))]\n   \"TARGET_V850E\"\n   \"\n {\n-  rtx insn = get_last_insn_anywhere ();\n-  rtx src;\n-\n   if (   (GET_CODE (operands[2]) == CONST_INT\n        && GET_CODE (operands[3]) == CONST_INT))\n     {\n@@ -845,28 +767,6 @@\n       if (GET_CODE (operands[3]) != REG)\n \toperands[3] = copy_to_mode_reg (SImode, operands[3]);\n     }\n-  gcc_assert (GET_CODE (insn) == INSN\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && SET_DEST (PATTERN (insn)) == cc0_rtx);\n-    \n-  src = SET_SRC (PATTERN (insn));\n-\n-  switch (GET_CODE (src))\n-    {\n-    case COMPARE:\n-      operands[4] = XEXP (src, 0);\n-      operands[5] = XEXP (src, 1);\n-      break;\n-\n-    case REG:\n-    case SUBREG:\n-      operands[4] = src;\n-      operands[5] = const0_rtx;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n }\")\n \n ;; ??? Clobbering the condition codes is overkill.\n@@ -1037,96 +937,6 @@\n \n ;; Conditional jump instructions\n \n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*branch_normal\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n@@ -1241,14 +1051,16 @@\n {\n   rtx reg = gen_reg_rtx (SImode);\n   rtx tableaddress = gen_reg_rtx (SImode);\n+  rtx test;\n   rtx mem;\n \n   /* Subtract the lower bound from the index.  */\n   emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n-  /* Compare the result against the number of table entries.  */\n-  emit_insn (gen_cmpsi (reg, operands[2]));\n-  /* Branch to the default label if out of range of the table.  */\n-  emit_jump_insn (gen_bgtu (operands[4]));\n+\n+  /* Compare the result against the number of table entries;\n+     branch to the default label if out of range of the table.  */\n+  test = gen_rtx_fmt_ee (GTU, VOIDmode, reg, operands[2]);\n+  emit_jump_insn (gen_cbranchsi4 (test, reg, operands[2], operands[4]));\n \n   /* Shift index for the table array access.  */\n   emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));"}, {"sha": "c038b300d91a04e8452ec5652cad7933098a449b", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -26,6 +26,7 @@ extern bool legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool vax_mode_dependent_address_p (rtx);\n \n #ifdef RTX_CODE\n+extern const char *cond_name (rtx);\n extern bool adjacent_operands_p (rtx, rtx, enum machine_mode);\n extern const char *rev_cond_name (rtx);\n extern void print_operand_address (FILE *, rtx);\n@@ -35,7 +36,6 @@ extern void vax_expand_addsub_di_operands (rtx *, enum rtx_code);\n extern const char * vax_output_int_move (rtx, rtx *, enum machine_mode);\n extern const char * vax_output_int_add (rtx, rtx *, enum machine_mode);\n extern const char * vax_output_int_subtract (rtx, rtx *, enum machine_mode);\n-extern const char * vax_output_conditional_branch (enum rtx_code);\n extern const char * vax_output_movmemsi (rtx, rtx *);\n #endif /* RTX_CODE */\n "}, {"sha": "cd66bb4e2d7ed9f343cdcda48c26f7d6bb5399f1", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -428,6 +428,8 @@ print_operand (FILE *file, rtx x, int code)\n     fputc (ASM_DOUBLE_CHAR, file);\n   else if (code == '|')\n     fputs (REGISTER_PREFIX, file);\n+  else if (code == 'c')\n+    fputs (cond_name (x), file);\n   else if (code == 'C')\n     fputs (rev_cond_name (x), file);\n   else if (code == 'D' && CONST_INT_P (x) && INTVAL (x) < 0)\n@@ -479,6 +481,37 @@ print_operand (FILE *file, rtx x, int code)\n     }\n }\n \f\n+const char *\n+cond_name (rtx op)\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case NE:\n+      return \"neq\";\n+    case EQ:\n+      return \"eql\";\n+    case GE:\n+      return \"geq\";\n+    case GT:\n+      return \"gtr\";\n+    case LE:\n+      return \"leq\";\n+    case LT:\n+      return \"lss\";\n+    case GEU:\n+      return \"gequ\";\n+    case GTU:\n+      return \"gtru\";\n+    case LEU:\n+      return \"lequ\";\n+    case LTU:\n+      return \"lssu\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n const char *\n rev_cond_name (rtx op)\n {\n@@ -1516,27 +1549,6 @@ vax_output_int_subtract (rtx insn, rtx *operands, enum machine_mode mode)\n   }\n }\n \n-/* Output a conditional branch.  */\n-const char *\n-vax_output_conditional_branch (enum rtx_code code)\n-{\n-  switch (code)\n-    {\n-      case EQ:  return \"jeql %l0\";\n-      case NE:  return \"jneq %l0\";\n-      case GT:  return \"jgtr %l0\";\n-      case LT:  return \"jlss %l0\";\n-      case GTU: return \"jgtru %l0\";\n-      case LTU: return \"jlssu %l0\";\n-      case GE:  return \"jgeq %l0\";\n-      case LE:  return \"jleq %l0\";\n-      case GEU: return \"jgequ %l0\";\n-      case LEU: return \"jlequ %l0\";\n-      default:\n-\tgcc_unreachable ();\n-    }\n-}\n-\n /* True if X is an rtx for a constant that is a valid address.  */\n \n bool"}, {"sha": "7fa2fbb870e0e3177c7747870e9481bef84cb174", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -802,6 +802,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n VAX operand formatting codes:\n \n  letter\t   print\n+   c\tdirect branch condition\n    C\treverse branch condition\n    D\t64-bit immediate operand\n    B\tthe low 8 bits of the complement of a constant operand"}, {"sha": "649f17e36ba8fd243f0cc6b51d1ad52e43de8a64", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -58,30 +58,16 @@\n (include \"constraints.md\")\n (include \"predicates.md\")\n \n-;; We don't want to allow a constant operand for test insns because\n-;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n-;; be folded while optimizing anyway.\n-\n-(define_insn \"tst<mode>\"\n-  [(set (cc0)\n-\t(match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT\"))]\n-  \"\"\n-  \"tst<VAXint:isfx> %0\")\n-\n-(define_insn \"tst<mode>\"\n+(define_insn \"*cmp<mode>\"\n   [(set (cc0)\n-\t(match_operand:VAXfp 0 \"general_operand\" \"gF\"))]\n+\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT,nrmT\")\n+\t\t (match_operand:VAXint 1 \"general_operand\" \"I,nrmT\")))]\n   \"\"\n-  \"tst<VAXfp:fsfx> %0\")\n-\n-(define_insn \"cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT\")\n-\t\t (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n-  \"\"\n-  \"cmp<VAXint:isfx> %0,%1\")\n+  \"@\n+   tst<VAXint:isfx> %0\n+   cmp<VAXint:isfx> %0,%1\")\n \n-(define_insn \"cmp<mode>\"\n+(define_insn \"*cmp<mode>\"\n   [(set (cc0)\n \t(compare (match_operand:VAXfp 0 \"general_operand\" \"gF,gF\")\n \t\t (match_operand:VAXfp 1 \"general_operand\" \"G,gF\")))]\n@@ -92,8 +78,9 @@\n \n (define_insn \"*bit<mode>\"\n   [(set (cc0)\n-\t(and:VAXint (match_operand:VAXint 0 \"general_operand\" \"nrmT\")\n-\t\t   (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n+\t(compare (and:VAXint (match_operand:VAXint 0 \"general_operand\" \"nrmT\")\n+\t\t\t     (match_operand:VAXint 1 \"general_operand\" \"nrmT\"))\n+\t\t (const_int 0)))]\n   \"\"\n   \"bit<VAXint:isfx> %0,%1\")\n \n@@ -1078,21 +1065,45 @@\n   \"jbr %l0\")\n \n ;; Conditional jumps\n-(define_code_iterator any_cond [eq ne gt lt gtu ltu ge le geu leu])\n \n-(define_insn \"b<code>\"\n+(define_expand \"cbranch<mode>4\"\n+  [(set (cc0)\n+        (compare (match_operand:VAXint 1 \"nonimmediate_operand\" \"\")\n+                 (match_operand:VAXint 2 \"general_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (cc0)\n+        (compare (match_operand:VAXfp 1 \"general_operand\" \"\")\n+                 (match_operand:VAXfp 2 \"general_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+              (pc)))]\n+ \"\")\n+\n+(define_insn \"*branch\"\n   [(set (pc)\n-\t(if_then_else (any_cond (cc0)\n-\t\t\t\t(const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t\t      [(cc0)\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return vax_output_conditional_branch (<CODE>);\")\n+  \"j%c0 %l1\")\n \n ;; Recognize reversed jumps.\n-(define_insn \"\"\n+(define_insn \"*branch_reversed\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n \t\t\t\t      [(cc0)\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n@@ -1452,6 +1463,8 @@\n    (match_operand 4 \"\" \"\")]\n   \"\"\n {\n+  rtx test;\n+\n   /* i = index - minimum_bound;\n      But only if the lower bound is not already zero.  */\n   if (operands[1] != const0_rtx)\n@@ -1463,9 +1476,9 @@\n       operands[0] = index;\n     }\n \n-  /* if (i > (maximum_bound - minimum_bound + 1) goto default;  */\n-  emit_insn (gen_cmpsi (operands[0], operands[2]));\n-  emit_jump_insn (gen_bgtu (operands[4]));\n+  /* if (i > (maximum_bound - minimum_bound + 1)) goto default;  */\n+  test = gen_rtx_fmt_ee (GTU, VOIDmode, operands[0], operands[2]);\n+  emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[2], operands[4]));\n \n   /* casesi (i, 0, table);  */\n   emit_jump_insn (gen_casesi1 (operands[0], operands[2], operands[3]));"}, {"sha": "27f058de796baa8e5357aa4ed3419dcf15e311b3", "filename": "gcc/config/xtensa/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fpredicates.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -167,6 +167,9 @@\n (define_predicate \"boolean_operator\"\n   (match_code \"eq,ne\"))\n \n+(define_predicate \"xtensa_cstoresi_operator\"\n+  (match_code \"eq,ne,gt,ge,lt,le\"))\n+\n (define_predicate \"tls_symbol_operand\"\n   (and (match_code \"symbol_ref\")\n        (match_test \"SYMBOL_REF_TLS_MODEL (op) != 0\")))"}, {"sha": "76f10179c75d87b8b239c816b2918f759328b649", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -39,9 +39,9 @@ extern int smalloffset_mem_p (rtx);\n extern int constantpool_address_p (rtx);\n extern int constantpool_mem_p (rtx);\n extern void xtensa_extend_reg (rtx, rtx);\n-extern void xtensa_expand_conditional_branch (rtx *, enum rtx_code);\n+extern void xtensa_expand_conditional_branch (rtx *, enum machine_mode);\n extern int xtensa_expand_conditional_move (rtx *, int);\n-extern int xtensa_expand_scc (rtx *);\n+extern int xtensa_expand_scc (rtx *, enum machine_mode);\n extern int xtensa_expand_block_move (rtx *);\n extern void xtensa_split_operand_pair (rtx *, enum machine_mode);\n extern int xtensa_emit_move_sequence (rtx *, enum machine_mode);"}, {"sha": "35e399f54b40222a92fa49bdb7f0170e83b7e891", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -71,13 +71,6 @@ enum internal_test\n   ITEST_MAX\n };\n \n-/* Cached operands, and operator to compare for use in set/branch on\n-   condition codes.  */\n-rtx branch_cmp[2];\n-\n-/* what type of branch to use */\n-enum cmp_type branch_type;\n-\n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n char xtensa_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n@@ -128,7 +121,7 @@ const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER] =\n static enum internal_test map_test_to_internal_test (enum rtx_code);\n static rtx gen_int_relational (enum rtx_code, rtx, rtx, int *);\n static rtx gen_float_relational (enum rtx_code, rtx, rtx);\n-static rtx gen_conditional_move (rtx);\n+static rtx gen_conditional_move (enum rtx_code, enum machine_mode, rtx, rtx);\n static rtx fixup_subreg_mem (rtx);\n static struct machine_function * xtensa_init_machine_status (void);\n static rtx xtensa_legitimize_tls_address (rtx);\n@@ -712,27 +705,27 @@ gen_float_relational (enum rtx_code test_code, /* relational test (EQ, etc) */\n \n \n void\n-xtensa_expand_conditional_branch (rtx *operands, enum rtx_code test_code)\n+xtensa_expand_conditional_branch (rtx *operands, enum machine_mode mode)\n {\n-  enum cmp_type type = branch_type;\n-  rtx cmp0 = branch_cmp[0];\n-  rtx cmp1 = branch_cmp[1];\n+  enum rtx_code test_code = GET_CODE (operands[0]);\n+  rtx cmp0 = operands[1];\n+  rtx cmp1 = operands[2];\n   rtx cmp;\n   int invert;\n   rtx label1, label2;\n \n-  switch (type)\n+  switch (mode)\n     {\n-    case CMP_DF:\n+    case DFmode:\n     default:\n       fatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n \n-    case CMP_SI:\n+    case SImode:\n       invert = FALSE;\n       cmp = gen_int_relational (test_code, cmp0, cmp1, &invert);\n       break;\n \n-    case CMP_SF:\n+    case SFmode:\n       if (!TARGET_HARD_FLOAT)\n \tfatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode,\n \t\t\t\t\t\tcmp0, cmp1));\n@@ -743,7 +736,7 @@ xtensa_expand_conditional_branch (rtx *operands, enum rtx_code test_code)\n \n   /* Generate the branch.  */\n \n-  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n   label2 = pc_rtx;\n \n   if (invert)\n@@ -760,14 +753,13 @@ xtensa_expand_conditional_branch (rtx *operands, enum rtx_code test_code)\n \n \n static rtx\n-gen_conditional_move (rtx cmp)\n+gen_conditional_move (enum rtx_code code, enum machine_mode mode,\n+\t\t      rtx op0, rtx op1)\n {\n-  enum rtx_code code = GET_CODE (cmp);\n-  rtx op0 = branch_cmp[0];\n-  rtx op1 = branch_cmp[1];\n-\n-  if (branch_type == CMP_SI)\n+  if (mode == SImode)\n     {\n+      rtx cmp;\n+\n       /* Jump optimization calls get_condition() which canonicalizes\n \t comparisons like (GE x <const>) to (GT x <const-1>).\n \t Transform those comparisons back to GE, since that is the\n@@ -825,7 +817,7 @@ gen_conditional_move (rtx cmp)\n       return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n     }\n \n-  if (TARGET_HARD_FLOAT && (branch_type == CMP_SF))\n+  if (TARGET_HARD_FLOAT && mode == SFmode)\n     return gen_float_relational (code, op0, op1);\n \n   return 0;\n@@ -835,44 +827,47 @@ gen_conditional_move (rtx cmp)\n int\n xtensa_expand_conditional_move (rtx *operands, int isflt)\n {\n-  rtx cmp;\n+  rtx dest = operands[0];\n+  rtx cmp = operands[1];\n+  enum machine_mode cmp_mode = GET_MODE (XEXP (cmp, 0));\n   rtx (*gen_fn) (rtx, rtx, rtx, rtx, rtx);\n \n-  if (!(cmp = gen_conditional_move (operands[1])))\n+  if (!(cmp = gen_conditional_move (GET_CODE (cmp), cmp_mode,\n+\t\t\t\t    XEXP (cmp, 0), XEXP (cmp, 1))))\n     return 0;\n \n   if (isflt)\n-    gen_fn = (branch_type == CMP_SI\n+    gen_fn = (cmp_mode == SImode\n \t      ? gen_movsfcc_internal0\n \t      : gen_movsfcc_internal1);\n   else\n-    gen_fn = (branch_type == CMP_SI\n+    gen_fn = (cmp_mode == SImode\n \t      ? gen_movsicc_internal0\n \t      : gen_movsicc_internal1);\n \n-  emit_insn (gen_fn (operands[0], XEXP (cmp, 0),\n-\t\t     operands[2], operands[3], cmp));\n+  emit_insn (gen_fn (dest, XEXP (cmp, 0), operands[2], operands[3], cmp));\n   return 1;\n }\n \n \n int\n-xtensa_expand_scc (rtx *operands)\n+xtensa_expand_scc (rtx operands[4], enum machine_mode cmp_mode)\n {\n   rtx dest = operands[0];\n-  rtx cmp = operands[1];\n+  rtx cmp;\n   rtx one_tmp, zero_tmp;\n   rtx (*gen_fn) (rtx, rtx, rtx, rtx, rtx);\n \n-  if (!(cmp = gen_conditional_move (cmp)))\n+  if (!(cmp = gen_conditional_move (GET_CODE (operands[1]), cmp_mode,\n+\t\t\t\t    operands[2], operands[3])))\n     return 0;\n \n   one_tmp = gen_reg_rtx (SImode);\n   zero_tmp = gen_reg_rtx (SImode);\n   emit_insn (gen_movsi (one_tmp, const_true_rtx));\n   emit_insn (gen_movsi (zero_tmp, const0_rtx));\n \n-  gen_fn = (branch_type == CMP_SI\n+  gen_fn = (cmp_mode == SImode\n \t    ? gen_movsicc_internal0\n \t    : gen_movsicc_internal1);\n   emit_insn (gen_fn (dest, XEXP (cmp, 0), one_tmp, zero_tmp, cmp));"}, {"sha": "c01a778bf2b5a22b66a767f2792c9bcd765e7ca2", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -27,17 +27,6 @@ extern int optimize;\n \n /* External variables defined in xtensa.c.  */\n \n-/* comparison type */\n-enum cmp_type {\n-  CMP_SI,\t\t\t\t/* four byte integers */\n-  CMP_DI,\t\t\t\t/* eight byte integers */\n-  CMP_SF,\t\t\t\t/* single precision floats */\n-  CMP_DF,\t\t\t\t/* double precision floats */\n-  CMP_MAX\t\t\t\t/* max comparison type */\n-};\n-\n-extern struct rtx_def * branch_cmp[2];\t/* operands for compare */\n-extern enum cmp_type branch_type;\t/* what type of branch to use */\n extern unsigned xtensa_current_frame_size;\n \n /* Macros used in the machine description to select various Xtensa"}, {"sha": "13883f1d5cab0e241b977f0f87ada78af04ca8bb", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387", "patch": "@@ -64,15 +64,6 @@\n (define_code_attr minmax [(smin \"min\") (umin \"minu\")\n \t\t\t  (smax \"max\") (umax \"maxu\")])\n \n-;; This code iterator allows all branch instructions to be generated from\n-;; a single define_expand template.\n-(define_code_iterator any_cond [eq ne gt ge lt le gtu geu ltu leu\n-\t\t\t\tuneq ltgt ungt unge unlt unle\n-\t\t\t\tunordered ordered])\n-\n-;; This code iterator is for setting a register from a comparison.\n-(define_code_iterator any_scc [eq ne gt ge lt le])\n-\n ;; This code iterator is for floating-point comparisons.\n (define_code_iterator any_scc_sf [eq lt le uneq unlt unle unordered])\n (define_code_attr scc_sf [(eq \"oeq\") (lt \"olt\") (le \"ole\") \n@@ -1131,44 +1122,27 @@\n \f\n ;; Comparisons.\n \n-;; Handle comparisons by stashing away the operands and then using that\n-;; information in the subsequent conditional branch.\n+;; Conditional branches.\n \n-(define_expand \"cmpsi\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+(define_expand \"cbranchsi4\"\n+  [(match_operator 0 \"comparison_operator\"\n+    [(match_operand:SI 1 \"register_operand\")\n+     (match_operand:SI 2 \"nonmemory_operand\")])\n+   (match_operand 3 \"\")]\n   \"\"\n {\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_SI;\n+  xtensa_expand_conditional_branch (operands, SImode);\n   DONE;\n })\n \n-(define_expand \"cmpsf\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SF 1 \"register_operand\" \"\")))]\n+(define_expand \"cbranchsf4\"\n+  [(match_operator 0 \"comparison_operator\"\n+    [(match_operand:SF 1 \"register_operand\")\n+     (match_operand:SF 2 \"register_operand\")])\n+   (match_operand 3 \"\")]\n   \"TARGET_HARD_FLOAT\"\n {\n-  branch_cmp[0] = operands[0];\n-  branch_cmp[1] = operands[1];\n-  branch_type = CMP_SF;\n-  DONE;\n-})\n-\n-\f\n-;; Conditional branches.\n-\n-(define_expand \"b<code>\"\n-  [(set (pc)\n-\t(if_then_else (any_cond (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  xtensa_expand_conditional_branch (operands, <CODE>);\n+  xtensa_expand_conditional_branch (operands, SFmode);\n   DONE;\n })\n \n@@ -1353,18 +1327,31 @@\n \f\n ;; Setting a register from a comparison.\n \n-(define_expand \"s<code>\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(any_scc:SI (match_dup 1)\n-\t\t    (match_dup 2)))]\n+(define_expand \"cstoresi4\"\n+  [(match_operand:SI 0 \"register_operand\")\n+   (match_operator 1 \"xtensa_cstoresi_operator\"\n+    [(match_operand:SI 2 \"register_operand\")\n+     (match_operand:SI 3 \"nonmemory_operand\")])]\n   \"\"\n {\n-  operands[1] = gen_rtx_<CODE> (SImode, branch_cmp[0], branch_cmp[1]);\n-  if (!xtensa_expand_scc (operands))\n+  if (!xtensa_expand_scc (operands, SImode))\n     FAIL;\n   DONE;\n })\n \n+(define_expand \"cstoresf4\"\n+  [(match_operand:SI 0 \"register_operand\")\n+   (match_operator:SI 1 \"comparison_operator\"\n+    [(match_operand:SF 2 \"register_operand\")\n+     (match_operand:SF 3 \"register_operand\")])]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  if (!xtensa_expand_scc (operands, SFmode))\n+    FAIL;\n+  DONE;\n+})\n+\n+\n \f\n ;; Conditional moves.\n "}, {"sha": "f91d6e12480bec5b1d9eba291842c402207cd986", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "05e04761bc4d4b845cde2bdcb2fea3505a50c727", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 106, "deletions": 21, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "76f62c62ebaf4b1ebc30b8a5d3844039acae8e8c", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "16f7415b549df97d4725a07ac34f0a06db3985f4", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 97, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "64794834771252a3378c9428bc0d0725a13d1043", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "30ccc852991058aa0215cacae2059851a8fc08e1", "filename": "gcc/final.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "f8cbf9549f8c5a45fa6a01fb9aae29825ecb72bb", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "a4324a59b9f2926493f341f6ee8ead8b54ee5350", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "970f1501700f16ae02bdc379330f96c3e4de1eb0", "filename": "gcc/optabs.c", "status": "modified", "additions": 177, "deletions": 207, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "f4ddfa1480b6ec587e803fb251c811169eab76bd", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}, {"sha": "667b5b5c8984148e9ccd1979ffe703a5fbd874a2", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90b7a5a7913cc7239cce42f6ca328b9a741b387/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f90b7a5a7913cc7239cce42f6ca328b9a741b387"}]}