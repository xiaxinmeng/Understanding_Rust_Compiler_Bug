{"sha": "ff95551244ee90bc9649cb3137dee18b7d909ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5NTU1MTI0NGVlOTBiYzk2NDljYjMxMzdkZWUxOGI3ZDkwOWNlMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-04-05T16:48:31Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-04-05T16:48:31Z"}, "message": "decl.c (set_current_binding_level): Delete, revert last change.\n\n\t* decl.c (set_current_binding_level): Delete, revert last change.\n\t(current_binding_level): Modify to allow it as as lvalue.\n\nFrom-SVN: r65273", "tree": {"sha": "f831750853f3be856c11bb9457affc24715fe3db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f831750853f3be856c11bb9457affc24715fe3db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff95551244ee90bc9649cb3137dee18b7d909ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff95551244ee90bc9649cb3137dee18b7d909ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff95551244ee90bc9649cb3137dee18b7d909ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff95551244ee90bc9649cb3137dee18b7d909ce0/comments", "author": null, "committer": null, "parents": [{"sha": "94f24ddce6d75529a8865f365df4b08c871c2c41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f24ddce6d75529a8865f365df4b08c871c2c41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f24ddce6d75529a8865f365df4b08c871c2c41"}], "stats": {"total": 41, "additions": 19, "deletions": 22}, "files": [{"sha": "d8464aa5724b5fe0686d2feacc8487181a3cf480", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff95551244ee90bc9649cb3137dee18b7d909ce0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff95551244ee90bc9649cb3137dee18b7d909ce0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff95551244ee90bc9649cb3137dee18b7d909ce0", "patch": "@@ -1,3 +1,8 @@\n+2003-04-05  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* decl.c (set_current_binding_level): Delete, revert last change.\n+\t(current_binding_level): Modify to allow it as as lvalue.\n+\n 2003-04-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* name-lookup.c (find_binding): Pass appropriate pointer type to"}, {"sha": "376db755d9d16acb3ade5708784f3d16c5a606c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff95551244ee90bc9649cb3137dee18b7d909ce0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff95551244ee90bc9649cb3137dee18b7d909ce0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ff95551244ee90bc9649cb3137dee18b7d909ce0", "patch": "@@ -434,17 +434,9 @@ struct cp_binding_level GTY(())\n /* The binding level currently in effect.  */\n \n #define current_binding_level\t\t\t\\\n-  (cfun && cp_function_chain->bindings\t\t\\\n-   ? cp_function_chain->bindings\t\t\\\n-   : scope_chain->bindings)\n-\n-#define set_current_binding_level(bl) do {\t\\\n-   struct cp_binding_level * const bl_ = bl;\t\\\n-   if (cfun && cp_function_chain->bindings)\t\\\n-     cp_function_chain->bindings = bl_;\t\t\\\n-   else\t\t\t\t\t\t\\\n-     scope_chain->bindings = bl_;\t\t\\\n- } while (0)\n+  (*(cfun && cp_function_chain->bindings\t\\\n+   ? &cp_function_chain->bindings\t\t\\\n+   : &scope_chain->bindings))\n \n /* The binding level of the current class, if any.  */\n \n@@ -495,7 +487,7 @@ push_binding_level (struct cp_binding_level *newlevel,\n      are active.  */\n   memset ((char*) newlevel, 0, sizeof (struct cp_binding_level));\n   newlevel->level_chain = current_binding_level;\n-  set_current_binding_level (newlevel);\n+  current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n \n@@ -551,7 +543,7 @@ pop_binding_level (void)\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n   {\n     register struct cp_binding_level *level = current_binding_level;\n-    set_current_binding_level (current_binding_level->level_chain);\n+    current_binding_level = current_binding_level->level_chain;\n     level->level_chain = free_binding_level;\n #if 0 /* defined(DEBUG_BINDING_LEVELS) */\n     if (level->binding_depth != binding_depth)\n@@ -566,7 +558,7 @@ static void\n suspend_binding_level (void)\n {\n   if (class_binding_level)\n-    set_current_binding_level (class_binding_level);\n+    current_binding_level = class_binding_level;\n \n   if (global_binding_level)\n     {\n@@ -588,7 +580,7 @@ suspend_binding_level (void)\n     }\n   is_class_level = 0;\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n-  set_current_binding_level (current_binding_level->level_chain);\n+  current_binding_level = current_binding_level->level_chain;\n   find_class_binding_level ();\n }\n \n@@ -600,7 +592,7 @@ resume_binding_level (struct cp_binding_level* b)\n   my_friendly_assert(!class_binding_level, 386);\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n   my_friendly_assert(b->level_chain == current_binding_level, 386);\n-  set_current_binding_level (b);\n+  current_binding_level = b;\n #if defined(DEBUG_BINDING_LEVELS)\n   b->binding_depth = binding_depth;\n   indent ();\n@@ -4074,9 +4066,9 @@ pushdecl_with_scope (tree x, struct cp_binding_level* level)\n   else\n     {\n       b = current_binding_level;\n-      set_current_binding_level (level);\n+      current_binding_level = level;\n       x = pushdecl (x);\n-      set_current_binding_level (b);\n+      current_binding_level = b;\n     }\n   current_function_decl = function_decl;\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n@@ -6203,7 +6195,7 @@ cxx_init_decl_processing (void)\n   current_lang_name = lang_name_c;\n \n   current_function_decl = NULL_TREE;\n-  set_current_binding_level (NULL_BINDING_LEVEL);\n+  current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n \n   build_common_tree_nodes (flag_signed_char);\n@@ -9979,10 +9971,10 @@ grokdeclarator (tree declarator,\n   if (decl_context == NORMAL && !toplevel_bindings_p ())\n     {\n       struct cp_binding_level *b = current_binding_level;\n-      set_current_binding_level (b->level_chain);\n+      current_binding_level = b->level_chain;\n       if (current_binding_level != 0 && toplevel_bindings_p ())\n \tdecl_context = PARM;\n-      set_current_binding_level (b);\n+      current_binding_level = b;\n     }\n \n   if (name == NULL)\n@@ -13452,7 +13444,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n      FIXME factor out the non-RTL stuff.  */\n   bl = current_binding_level;\n   init_function_start (decl1, input_filename, lineno);\n-  set_current_binding_level (bl);\n+  current_binding_level = bl;\n \n   /* Even though we're inside a function body, we still don't want to\n      call expand_expr to calculate the size of a variable-sized array."}]}