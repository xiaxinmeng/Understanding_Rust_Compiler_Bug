{"sha": "7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FlYzJjNjM0M2FlYTMwZjFiODI1Y2NmYjQyZGFmOGMwYjE0YzUxYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-30T09:34:04Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-30T09:34:04Z"}, "message": "[multiple changes]\n\n2009-11-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/tr1_impl/functional: Remove file, copy its contents,\n\ttrivially adjusted...\n\t* include/std/functional: ... here, and...\n\t* include/tr1_impl/functional: ... here.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\n2009-11-30  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n        * include/tr1_impl/functional (function): Add rvalue support and\n        tweak doxygen markup.\n        * testsuite/20_util/function/assign/move.cc: New.\n        * testsuite/20_util/function/cons/move.cc: New.\n        * testsuite/20_util/function/invoke/move_only.cc: New.\n        * testsuite/20_util/function/cmp/cmp_neg.cc: New.\n        * testsuite/20_util/function/1.cc: Copy from testsuite/tr1/.\n        * testsuite/20_util/function/2.cc: Likewise.\n        * testsuite/20_util/function/3.cc: Likewise.\n        * testsuite/20_util/function/4.cc: Likewise.\n        * testsuite/20_util/function/5.cc: Likewise.\n        * testsuite/20_util/function/6.cc: Likewise.\n        * testsuite/20_util/function/7.cc: Likewise.\n        * testsuite/20_util/function/8.cc: Likewise.\n        * testsuite/20_util/function/9.cc: Likewise.\n\nFrom-SVN: r154759", "tree": {"sha": "1d9e0fd986412747338b6ddb26fc86e872d68493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d9e0fd986412747338b6ddb26fc86e872d68493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/comments", "author": null, "committer": null, "parents": [{"sha": "5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a"}], "stats": {"total": 7439, "additions": 5263, "deletions": 2176}, "files": [{"sha": "c275cdd46a59490aebb2824a470d4ec4a40c36c3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -1,3 +1,30 @@\n+2009-11-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/tr1_impl/functional: Remove file, copy its contents,\n+\ttrivially adjusted...\n+\t* include/std/functional: ... here, and...\n+\t* include/tr1_impl/functional: ... here.\n+\t* include/Makefile.am: Adjust.\n+\t* include/Makefile.in: Regenerate.\n+\n+2009-11-30  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+        * include/tr1_impl/functional (function): Add rvalue support and\n+        tweak doxygen markup.\n+        * testsuite/20_util/function/assign/move.cc: New.\n+        * testsuite/20_util/function/cons/move.cc: New.\n+        * testsuite/20_util/function/invoke/move_only.cc: New.\n+        * testsuite/20_util/function/cmp/cmp_neg.cc: New.\n+        * testsuite/20_util/function/1.cc: Copy from testsuite/tr1/.\n+        * testsuite/20_util/function/2.cc: Likewise.\n+        * testsuite/20_util/function/3.cc: Likewise.\n+        * testsuite/20_util/function/4.cc: Likewise.\n+        * testsuite/20_util/function/5.cc: Likewise.\n+        * testsuite/20_util/function/6.cc: Likewise.\n+        * testsuite/20_util/function/7.cc: Likewise.\n+        * testsuite/20_util/function/8.cc: Likewise.\n+        * testsuite/20_util/function/9.cc: Likewise.\n+\n 2009-11-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/doxygen/user.cfg.in: Add __GXX_RTTI to PREDEFINED macros."}, {"sha": "8d4ece7ee448aeeed1d19559f89e3ef66c4cbe80", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -609,7 +609,6 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/cstdlib \\\n \t${tr1_impl_srcdir}/cwchar \\\n \t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/functional \\\n \t${tr1_impl_srcdir}/hashtable \\\n \t${tr1_impl_srcdir}/hashtable_policy.h \\\n \t${tr1_impl_srcdir}/regex \\"}, {"sha": "221ae5575303bd54059c7c80746052102ee6eba1", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -849,7 +849,6 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/cstdlib \\\n \t${tr1_impl_srcdir}/cwchar \\\n \t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/functional \\\n \t${tr1_impl_srcdir}/hashtable \\\n \t${tr1_impl_srcdir}/hashtable_policy.h \\\n \t${tr1_impl_srcdir}/regex \\"}, {"sha": "eb10b348ad1ced62c7516bfe7014f9e15f7f3084", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 2139, "deletions": 22, "changes": 2161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -50,28 +50,2145 @@\n #include <bits/stl_function.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#  if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#    error C++0x header cannot be included from TR1 header\n-#  endif\n-#  include <typeinfo>\n-#  include <new>\n-#  include <tuple>\n-#  include <type_traits>\n-#  include <bits/functional_hash.h>\n-#  include <ext/type_traits.h>\n-#  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#    include <tr1_impl/functional>\n-#  else\n-#    define _GLIBCXX_INCLUDE_AS_CXX0X\n-#    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    define _GLIBCXX_END_NAMESPACE_TR1\n-#    define _GLIBCXX_TR1\n-#    include <tr1_impl/functional>\n-#    undef _GLIBCXX_TR1\n-#    undef _GLIBCXX_END_NAMESPACE_TR1\n-#    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#    undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#  endif\n+\n+#include <typeinfo>\n+#include <new>\n+#include <tuple>\n+#include <type_traits>\n+#include <bits/functional_hash.h>\n+#include <ext/type_traits.h>\n+\n+namespace std\n+{\n+  template<typename _MemberPointer>\n+    class _Mem_fn;\n+\n+  /**\n+   *  Actual implementation of _Has_result_type, which uses SFINAE to\n+   *  determine if the type _Tp has a publicly-accessible member type\n+   *  result_type.\n+  */\n+  template<typename _Tp>\n+    class _Has_result_type_helper : __sfinae_types\n+    {\n+      template<typename _Up>\n+        struct _Wrap_type\n+\t{ };\n+\n+      template<typename _Up>\n+        static __one __test(_Wrap_type<typename _Up::result_type>*);\n+\n+      template<typename _Up>\n+        static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test<_Tp>(0)) == 1;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Has_result_type\n+    : integral_constant<bool,\n+\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n+    { };\n+\n+  /**\n+   *  \n+  */\n+  /// If we have found a result_type, extract it.\n+  template<bool _Has_result_type, typename _Functor>\n+    struct _Maybe_get_result_type\n+    { };\n+\n+  template<typename _Functor>\n+    struct _Maybe_get_result_type<true, _Functor>\n+    {\n+      typedef typename _Functor::result_type result_type;\n+    };\n+\n+  /**\n+   *  Base class for any function object that has a weak result type, as\n+   *  defined in 3.3/3 of TR1.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type_impl\n+    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n+    {\n+    };\n+\n+  /// Retrieve the result type for a function type.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve the result type for a function reference.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve the result type for a function pointer.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a const member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a volatile member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a const volatile member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   *  Strip top-level cv-qualifiers from the function object and let\n+   *  _Weak_result_type_impl perform the real work.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type\n+    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n+    {\n+    };\n+\n+  template<typename _Signature>\n+    class result_of;\n+\n+  /**\n+   *  Actual implementation of result_of. When _Has_result_type is\n+   *  true, gets its result from _Weak_result_type. Otherwise, uses\n+   *  the function object's member template result to extract the\n+   *  result type.\n+  */\n+  template<bool _Has_result_type, typename _Signature>\n+    struct _Result_of_impl;\n+\n+  // Handle member data pointers using _Mem_fn's logic\n+  template<typename _Res, typename _Class, typename _T1>\n+    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n+    {\n+      typedef typename _Mem_fn<_Res _Class::*>\n+                ::template _Result_type<_T1>::type type;\n+    };\n+\n+  /**\n+   * Determine whether we can determine a result type from @c Functor \n+   * alone.\n+   */ \n+  template<typename _Functor, typename... _ArgTypes>\n+    class result_of<_Functor(_ArgTypes...)>\n+    : public _Result_of_impl<\n+               _Has_result_type<_Weak_result_type<_Functor> >::value,\n+               _Functor(_ArgTypes...)>\n+    {\n+    };\n+\n+  /// We already know the result type for @c Functor; use it.\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Weak_result_type<_Functor>::result_type type;\n+    };\n+\n+  /**\n+   * We need to compute the result type for this invocation the hard \n+   * way.\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Functor\n+                ::template result<_Functor(_ArgTypes...)>::type type;\n+    };\n+\n+  /**\n+   * It is unsafe to access ::result when there are zero arguments, so we \n+   * return @c void instead.\n+   */\n+  template<typename _Functor>\n+    struct _Result_of_impl<false, _Functor()>\n+    {\n+      typedef void type;\n+    };\n+\n+  /// Determines if the type _Tp derives from unary_function.\n+  template<typename _Tp>\n+    struct _Derives_from_unary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _Res>\n+        static __one __test(const volatile unary_function<_T1, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /// Determines if the type _Tp derives from binary_function.\n+  template<typename _Tp>\n+    struct _Derives_from_binary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _T2, typename _Res>\n+        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /// Turns a function type into a function pointer type\n+  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n+    struct _Function_to_function_pointer\n+    {\n+      typedef _Tp type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Function_to_function_pointer<_Tp, true>\n+    {\n+      typedef _Tp* type;\n+    };\n+\n+  /**\n+   * Invoke a function object, which may be either a member pointer or a\n+   * function object. The first parameter will tell which.\n+   */\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (!is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return mem_fn(__f)(__args...);\n+    }\n+\n+  // To pick up function references (that will become function pointers)\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_pointer<_Functor>::value\n+              && is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  /**\n+   *  Knowing which of unary_function and binary_function _Tp derives\n+   *  from, derives from the same and ensures that reference_wrapper\n+   *  will have a weak result type. See cases below.\n+   */\n+  template<bool _Unary, bool _Binary, typename _Tp>\n+    struct _Reference_wrapper_base_impl;\n+\n+  // Not a unary_function or binary_function, so try a weak result type.\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, false, _Tp>\n+    : _Weak_result_type<_Tp>\n+    { };\n+\n+  // unary_function but not binary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, false, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>\n+    { };\n+\n+  // binary_function but not unary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, true, _Tp>\n+    : binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    { };\n+\n+  // Both unary_function and binary_function. Import result_type to\n+  // avoid conflicts.\n+   template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, true, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>,\n+      binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    {\n+      typedef typename _Tp::result_type result_type;\n+    };\n+\n+  /**\n+   *  Derives from unary_function or binary_function when it\n+   *  can. Specializations handle all of the easy cases. The primary\n+   *  template determines what to do with a class type, which may\n+   *  derive from both unary_function and binary_function.\n+  */\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base\n+    : _Reference_wrapper_base_impl<\n+      _Derives_from_unary_function<_Tp>::value,\n+      _Derives_from_binary_function<_Tp>::value,\n+      _Tp>\n+    { };\n+\n+  // - a function type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a function pointer type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(*)(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function pointer type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, no qualifiers)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)()>\n+    : unary_function<_T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, no qualifiers)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n+    : binary_function<_T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n+    : unary_function<const _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n+    : binary_function<const _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n+    : unary_function<volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n+    : binary_function<volatile _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n+    : unary_function<const volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n+    : binary_function<const volatile _T1*, _T2, _Res>\n+    { };\n+\n+  /// reference_wrapper\n+  template<typename _Tp>\n+    class reference_wrapper\n+    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    {\n+      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n+      // so turn it into a function pointer type.\n+      typedef typename _Function_to_function_pointer<_Tp>::type\n+        _M_func_type;\n+\n+      _Tp* _M_data;\n+    public:\n+      typedef _Tp type;\n+\n+      explicit\n+      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n+      { }\n+\n+      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n+      _M_data(__inref._M_data)\n+      { }\n+\n+      reference_wrapper&\n+      operator=(const reference_wrapper<_Tp>& __inref)\n+      {\n+        _M_data = __inref._M_data;\n+        return *this;\n+      }\n+\n+      operator _Tp&() const\n+      { return this->get(); }\n+\n+      _Tp&\n+      get() const\n+      { return *_M_data; }\n+\n+      template<typename... _Args>\n+        typename result_of<_M_func_type(_Args...)>::type\n+        operator()(_Args&... __args) const\n+        {\n+\t  return __invoke(get(), __args...);\n+\t}\n+    };\n+\n+\n+  // Denotes a reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(_Tp& __t)\n+    { return reference_wrapper<_Tp>(__t); }\n+\n+  // Denotes a const reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(const _Tp& __t)\n+    { return reference_wrapper<const _Tp>(__t); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(reference_wrapper<_Tp> __t)\n+    { return ref(__t.get()); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(reference_wrapper<_Tp> __t)\n+    { return cref(__t.get()); }\n+\n+  template<typename _Tp, bool>\n+    struct _Mem_fn_const_or_non\n+    {\n+      typedef const _Tp& type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Mem_fn_const_or_non<_Tp, false>\n+    {\n+      typedef _Tp& type;\n+    };\n+\n+  /**\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Maybe_unary_or_binary_function { };\n+\n+  /// Derives from @c unary_function, as appropriate. \n+  template<typename _Res, typename _T1> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1>\n+    : std::unary_function<_T1, _Res> { };\n+\n+  /// Derives from @c binary_function, as appropriate. \n+  template<typename _Res, typename _T1, typename _T2> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+    : std::binary_function<_T1, _T2, _Res> { };\n+\n+  /// Implementation of @c mem_fn for member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(_Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(_Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for const member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n+    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(const _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(const _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for volatile member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for const volatile member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res \n+      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res \n+      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+\n+  template<typename _Res, typename _Class>\n+    class _Mem_fn<_Res _Class::*>\n+    {\n+      // This bit of genius is due to Peter Dimov, improved slightly by\n+      // Douglas Gregor.\n+      template<typename _Tp>\n+        _Res&\n+        _M_call(_Tp& __object, _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        _Res&\n+        _M_call(_Tp& __object, _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __ptr, const volatile void*) const\n+        { return (*__ptr).*__pm; }\n+\n+      template<typename _Tp> static _Tp& __get_ref();\n+\n+      template<typename _Tp>\n+        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+\n+    public:\n+      template<typename _Tp>\n+        struct _Result_type\n+\t: _Mem_fn_const_or_non<_Res,\n+\t  (sizeof(__sfinae_types::__two)\n+\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+        { };\n+\n+      template<typename _Signature>\n+        struct result;\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp)>\n+\t: public _Result_type<_Tp> { };\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp&)>\n+\t: public _Result_type<_Tp> { };\n+\n+      explicit\n+      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+\n+      // Handle objects\n+      _Res&\n+      operator()(_Class& __object) const\n+      { return __object.*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class& __object) const\n+      { return __object.*__pm; }\n+\n+      // Handle pointers\n+      _Res&\n+      operator()(_Class* __object) const\n+      { return __object->*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class* __object) const\n+      { return __object->*__pm; }\n+\n+      // Handle smart pointers and derived\n+      template<typename _Tp>\n+        typename _Result_type<_Tp>::type\n+        operator()(_Tp& __unknown) const\n+        { return _M_call(__unknown, &__unknown); }\n+\n+    private:\n+      _Res _Class::*__pm;\n+    };\n+\n+  /**\n+   *  @brief Returns a function object that forwards to the member\n+   *  pointer @a pm.\n+   */\n+  template<typename _Tp, typename _Class>\n+    inline _Mem_fn<_Tp _Class::*>\n+    mem_fn(_Tp _Class::* __pm)\n+    {\n+      return _Mem_fn<_Tp _Class::*>(__pm);\n+    }\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a function object\n+   *  should be treated as a subexpression when evaluating calls to\n+   *  function objects returned by bind(). [TR1 3.6.1]\n+   */\n+  template<typename _Tp>\n+    struct is_bind_expression\n+    { static const bool value = false; };\n+\n+  template<typename _Tp>\n+    const bool is_bind_expression<_Tp>::value;\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a placeholder in a\n+   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n+   */\n+  template<typename _Tp>\n+    struct is_placeholder\n+    { static const int value = 0; };\n+\n+  template<typename _Tp>\n+    const int is_placeholder<_Tp>::value;\n+\n+  /// The type of placeholder objects defined by libstdc++.\n+  template<int _Num> struct _Placeholder { };\n+\n+  /** @namespace std::placeholders\n+   *  @brief ISO C++ 0x entities sub namespace for functional.\n+   *\n+   *  Define a large number of placeholders. There is no way to\n+   *  simplify this with variadic templates, because we're introducing\n+   *  unique names for each.\n+   */\n+  namespace placeholders \n+  { \n+    namespace \n+    {\n+      _Placeholder<1> _1;\n+      _Placeholder<2> _2;\n+      _Placeholder<3> _3;\n+      _Placeholder<4> _4;\n+      _Placeholder<5> _5;\n+      _Placeholder<6> _6;\n+      _Placeholder<7> _7;\n+      _Placeholder<8> _8;\n+      _Placeholder<9> _9;\n+      _Placeholder<10> _10;\n+      _Placeholder<11> _11;\n+      _Placeholder<12> _12;\n+      _Placeholder<13> _13;\n+      _Placeholder<14> _14;\n+      _Placeholder<15> _15;\n+      _Placeholder<16> _16;\n+      _Placeholder<17> _17;\n+      _Placeholder<18> _18;\n+      _Placeholder<19> _19;\n+      _Placeholder<20> _20;\n+      _Placeholder<21> _21;\n+      _Placeholder<22> _22;\n+      _Placeholder<23> _23;\n+      _Placeholder<24> _24;\n+      _Placeholder<25> _25;\n+      _Placeholder<26> _26;\n+      _Placeholder<27> _27;\n+      _Placeholder<28> _28;\n+      _Placeholder<29> _29;\n+    } \n+  }\n+\n+  /**\n+   *  Partial specialization of is_placeholder that provides the placeholder\n+   *  number for the placeholder objects defined by libstdc++.\n+   */\n+  template<int _Num>\n+    struct is_placeholder<_Placeholder<_Num> >\n+    { static const int value = _Num; };\n+\n+  template<int _Num>\n+    const int is_placeholder<_Placeholder<_Num> >::value;\n+\n+  /**\n+   * Stores a tuple of indices. Used by bind() to extract the elements\n+   * in a tuple. \n+   */\n+  template<int... _Indexes>\n+    struct _Index_tuple { };\n+\n+  /// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n+  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n+    struct _Build_index_tuple;\n+ \n+  template<std::size_t _Num, int... _Indexes> \n+    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n+    : _Build_index_tuple<_Num - 1, \n+                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n+    {\n+    };\n+\n+  template<int... _Indexes>\n+    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n+    {\n+      typedef _Index_tuple<_Indexes...> __type;\n+    };\n+\n+  /** \n+   * Used by _Safe_tuple_element to indicate that there is no tuple\n+   * element at this position.\n+   */\n+  struct _No_tuple_element;\n+\n+  /**\n+   * Implementation helper for _Safe_tuple_element. This primary\n+   * template handles the case where it is safe to use @c\n+   * tuple_element.\n+   */\n+  template<int __i, typename _Tuple, bool _IsSafe>\n+    struct _Safe_tuple_element_impl\n+    : tuple_element<__i, _Tuple> { };\n+\n+  /**\n+   * Implementation helper for _Safe_tuple_element. This partial\n+   * specialization handles the case where it is not safe to use @c\n+   * tuple_element. We just return @c _No_tuple_element.\n+   */\n+  template<int __i, typename _Tuple>\n+    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n+    {\n+      typedef _No_tuple_element type;\n+    };\n+\n+  /**\n+   * Like tuple_element, but returns @c _No_tuple_element when\n+   * tuple_element would return an error.\n+   */\n+ template<int __i, typename _Tuple>\n+   struct _Safe_tuple_element\n+   : _Safe_tuple_element_impl<__i, _Tuple, \n+                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   {\n+   };\n+\n+  /**\n+   *  Maps an argument to bind() into an actual argument to the bound\n+   *  function object [TR1 3.6.3/5]. Only the first parameter should\n+   *  be specified: the rest are used to determine among the various\n+   *  implementations. Note that, although this class is a function\n+   *  object, it isn't entirely normal because it takes only two\n+   *  parameters regardless of the number of parameters passed to the\n+   *  bind expression. The first parameter is the bound argument and\n+   *  the second parameter is a tuple containing references to the\n+   *  rest of the arguments.\n+   */\n+  template<typename _Arg,\n+           bool _IsBindExp = is_bind_expression<_Arg>::value,\n+           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n+    class _Mu;\n+\n+  /**\n+   *  If the argument is reference_wrapper<_Tp>, returns the\n+   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n+   */\n+  template<typename _Tp>\n+    class _Mu<reference_wrapper<_Tp>, false, false>\n+    {\n+    public:\n+      typedef _Tp& result_type;\n+\n+      /* Note: This won't actually work for const volatile\n+       * reference_wrappers, because reference_wrapper::get() is const\n+       * but not volatile-qualified. This might be a defect in the TR.\n+       */\n+      template<typename _CVRef, typename _Tuple>\n+        result_type\n+        operator()(_CVRef& __arg, const _Tuple&) const volatile\n+        { return __arg.get(); }\n+    };\n+\n+  /**\n+   *  If the argument is a bind expression, we invoke the underlying\n+   *  function object with the same cv-qualifiers as we are given and\n+   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, true, false>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      // Determine the result type when we pass the arguments along. This\n+      // involves passing along the cv-qualifiers placed on _Mu and\n+      // unwrapping the argument bundle.\n+      template<typename _CVMu, typename _CVArg, typename... _Args>\n+        class result<_CVMu(_CVArg, tuple<_Args...>)>\n+\t: public result_of<_CVArg(_Args...)> { };\n+\n+      template<typename _CVArg, typename... _Args>\n+        typename result_of<_CVArg(_Args...)>::type\n+        operator()(_CVArg& __arg,\n+\t\t   const tuple<_Args...>& __tuple) const volatile\n+        {\n+\t  // Construct an index tuple and forward to __call\n+\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n+\t    _Indexes;\n+\t  return this->__call(__arg, __tuple, _Indexes());\n+\t}\n+\n+    private:\n+      // Invokes the underlying function object __arg by unpacking all\n+      // of the arguments in the tuple. \n+      template<typename _CVArg, typename... _Args, int... _Indexes>\n+        typename result_of<_CVArg(_Args...)>::type\n+        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+\t       const _Index_tuple<_Indexes...>&) const volatile\n+        {\n+\t  return __arg(get<_Indexes>(__tuple)...);\n+\t}\n+    };\n+\n+  /**\n+   *  If the argument is a placeholder for the Nth argument, returns\n+   *  a reference to the Nth argument to the bind function object.\n+   *  [TR1 3.6.3/5 bullet 3]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, true>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        class result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  // Add a reference, if it hasn't already been done for us.\n+\t  // This allows us to be a little bit sloppy in constructing\n+\t  // the tuple that we pass to result_of<...>.\n+\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n+\t\t\t\t\t\t- 1), _Tuple>::type\n+\t    __base_type;\n+\n+\tpublic:\n+\t  typedef typename add_lvalue_reference<__base_type>::type type;\n+\t};\n+\n+      template<typename _Tuple>\n+        typename result<_Mu(_Arg, _Tuple)>::type\n+        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n+        {\n+\t  return ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple);\n+\t}\n+    };\n+\n+  /**\n+   *  If the argument is just a value, returns a reference to that\n+   *  value. The cv-qualifiers on the reference are the same as the\n+   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, false>\n+    {\n+    public:\n+      template<typename _Signature> struct result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        struct result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  typedef typename add_lvalue_reference<_CVArg>::type type;\n+\t};\n+\n+      // Pick up the cv-qualifiers of the argument\n+      template<typename _CVArg, typename _Tuple>\n+        _CVArg&\n+        operator()(_CVArg& __arg, const _Tuple&) const volatile\n+        { return __arg; }\n+    };\n+\n+  /**\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). The\n+   *  primary template handles the non--member-pointer case.\n+   */\n+  template<typename _Tp>\n+    struct _Maybe_wrap_member_pointer\n+    {\n+      typedef _Tp type;\n+      \n+      static const _Tp&\n+      __do_wrap(const _Tp& __x)\n+      { return __x; }\n+    };\n+\n+  /**\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). This\n+   *  partial specialization handles the member pointer case.\n+   */\n+  template<typename _Tp, typename _Class>\n+    struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n+    {\n+      typedef _Mem_fn<_Tp _Class::*> type;\n+      \n+      static type\n+      __do_wrap(_Tp _Class::* __pm)\n+      { return type(__pm); }\n+    };\n+\n+  /// Type of the function object returned from bind().\n+  template<typename _Signature>\n+    struct _Bind;\n+\n+   template<typename _Functor, typename... _Bound_args>\n+    class _Bind<_Functor(_Bound_args...)>\n+    : public _Weak_result_type<_Functor>\n+    {\n+      typedef _Bind __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (volatile _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const volatile _Bound_args, \n+                                     tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+     public:\n+      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n+        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const volatile _Bound_args, \n+                             tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /// Type of the function object returned from bind<R>().\n+  template<typename _Result, typename _Signature>\n+    struct _Bind_result;\n+\n+  template<typename _Result, typename _Functor, typename... _Bound_args>\n+    class _Bind_result<_Result, _Functor(_Bound_args...)>\n+    {\n+      typedef _Bind_result __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+    public:\n+      typedef _Result result_type;\n+\n+      explicit\n+      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n+      : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /// Class template _Bind is always a bind expression.\n+  template<typename _Signature>\n+    struct is_bind_expression<_Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<_Bind<_Signature> >::value;\n+\n+  /// Class template _Bind_result is always a bind expression.\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n+\n+  /// bind\n+  template<typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    } \n+\n+  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind_result<_Result,\n+\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n+                            (_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n+\t__result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    }\n+\n+  /**\n+   *  @brief Exception class thrown when class template function's\n+   *  operator() is called with an empty target.\n+   *  @ingroup exceptions\n+   */\n+  class bad_function_call : public std::exception { };\n+\n+  /**\n+   *  The integral constant expression 0 can be converted into a\n+   *  pointer to this type. It is used by the function template to\n+   *  accept NULL pointers.\n+   */\n+  struct _M_clear_type;\n+\n+  /**\n+   *  Trait identifying \"location-invariant\" types, meaning that the\n+   *  address of the object (or any of its members) will not escape.\n+   *  Also implies a trivial copy constructor and assignment operator.\n+   */\n+  template<typename _Tp>\n+    struct __is_location_invariant\n+    : integral_constant<bool,\n+                        (is_pointer<_Tp>::value\n+                         || is_member_pointer<_Tp>::value)>\n+    {\n+    };\n+\n+  class _Undefined_class;\n+\n+  union _Nocopy_types\n+  {\n+    void*       _M_object;\n+    const void* _M_const_object;\n+    void (*_M_function_pointer)();\n+    void (_Undefined_class::*_M_member_pointer)();\n+  };\n+\n+  union _Any_data\n+  {\n+    void*       _M_access()       { return &_M_pod_data[0]; }\n+    const void* _M_access() const { return &_M_pod_data[0]; }\n+\n+    template<typename _Tp>\n+      _Tp&\n+      _M_access()\n+      { return *static_cast<_Tp*>(_M_access()); }\n+\n+    template<typename _Tp>\n+      const _Tp&\n+      _M_access() const\n+      { return *static_cast<const _Tp*>(_M_access()); }\n+\n+    _Nocopy_types _M_unused;\n+    char _M_pod_data[sizeof(_Nocopy_types)];\n+  };\n+\n+  enum _Manager_operation\n+  {\n+    __get_type_info,\n+    __get_functor_ptr,\n+    __clone_functor,\n+    __destroy_functor\n+  };\n+\n+  // Simple type wrapper that helps avoid annoying const problems\n+  // when casting between void pointers and pointers-to-pointers.\n+  template<typename _Tp>\n+    struct _Simple_type_wrapper\n+    {\n+      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n+\n+      _Tp __value;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n+    : __is_location_invariant<_Tp>\n+    {\n+    };\n+\n+  // Converts a reference to a function object into a callable\n+  // function object.\n+  template<typename _Functor>\n+    inline _Functor&\n+    __callable_functor(_Functor& __f)\n+    { return __f; }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* const &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Signature>\n+    class function;\n+\n+  /// Base class of all polymorphic function object wrappers.\n+  class _Function_base\n+  {\n+  public:\n+    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n+    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n+\n+    template<typename _Functor>\n+      class _Base_manager\n+      {\n+      protected:\n+\tstatic const bool __stored_locally =\n+        (__is_location_invariant<_Functor>::value\n+         && sizeof(_Functor) <= _M_max_size\n+         && __alignof__(_Functor) <= _M_max_align\n+         && (_M_max_align % __alignof__(_Functor) == 0));\n+\t\n+\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+\t// Retrieve a pointer to the function object\n+\tstatic _Functor*\n+\t_M_get_pointer(const _Any_data& __source)\n+\t{\n+\t  const _Functor* __ptr =\n+\t    __stored_locally? &__source._M_access<_Functor>()\n+\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n+\t  return const_cast<_Functor*>(__ptr);\n+\t}\n+\n+\t// Clone a location-invariant function object that fits within\n+\t// an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+\t{\n+\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+\t}\n+\n+\t// Clone a function object that is not location-invariant or\n+\t// that cannot fit into an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+\t{\n+\t  __dest._M_access<_Functor*>() =\n+\t    new _Functor(*__source._M_access<_Functor*>());\n+\t}\n+\n+\t// Destroying a location-invariant object may still require\n+\t// destruction.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, true_type)\n+\t{\n+\t  __victim._M_access<_Functor>().~_Functor();\n+\t}\n+\t\n+\t// Destroying an object located on the heap.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, false_type)\n+\t{\n+\t  delete __victim._M_access<_Functor*>();\n+\t}\n+\t\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#ifdef __GXX_RTTI\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+#endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+\t      break;\n+\t      \n+\t    case __clone_functor:\n+\t      _M_clone(__dest, __source, _Local_storage());\n+\t      break;\n+\n+\t    case __destroy_functor:\n+\t      _M_destroy(__dest, _Local_storage());\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n+\t{ _M_init_functor(__functor, __f, _Local_storage()); }\n+\t\n+\ttemplate<typename _Signature>\n+\t  static bool\n+\t  _M_not_empty_function(const function<_Signature>& __f)\n+          { return static_cast<bool>(__f); }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp*& __fp)\n+\t  { return __fp; }\n+\n+\ttemplate<typename _Class, typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n+\t  { return __mp; }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp&)\n+\t  { return true; }\n+\n+      private:\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n+\t{ new (__functor._M_access()) _Functor(__f); }\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n+\t{ __functor._M_access<_Functor*>() = new _Functor(__f); }\n+      };\n+\n+    template<typename _Functor>\n+      class _Ref_manager : public _Base_manager<_Functor*>\n+      {\n+\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n+\n+    public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#ifdef __GXX_RTTI\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n #endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+\t      return is_const<_Functor>::value;\n+\t      break;\n+\t      \n+\t    default:\n+\t      _Base::_M_manager(__dest, __source, __op);\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+\t{\n+\t  // TBD: Use address_of function instead.\n+\t  _Base::_M_init_functor(__functor, &__f.get());\n+\t}\n+      };\n+\n+    _Function_base() : _M_manager(0) { }\n+    \n+    ~_Function_base()\n+    {\n+      if (_M_manager)\n+\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n+    }\n+\n+\n+    bool _M_empty() const { return !_M_manager; }\n+\n+    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n+                                  _Manager_operation);\n+\n+    _Any_data     _M_functor;\n+    _Manager_type _M_manager;\n+  };\n+\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+    public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return (*_Base::_M_get_pointer(__functor))(\n+            std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        (*_Base::_M_get_pointer(__functor))(\n+            std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return __callable_functor(**_Base::_M_get_pointer(__functor))(\n+              std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        __callable_functor(**_Base::_M_get_pointer(__functor))(\n+            std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename _Res, \n+           typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n+    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    {\n+      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+        _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return mem_fn(_Base::_M_get_pointer(__functor)->__value)(\n+            std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    : public _Function_base::_Base_manager<\n+                 _Simple_type_wrapper< _Member _Class::* > >\n+    {\n+      typedef _Member _Class::* _Functor;\n+      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n+      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+     public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op)\n+\t  {\n+#ifdef __GXX_RTTI\n+\t  case __get_type_info:\n+\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t    break;\n+#endif\t    \n+\t  case __get_functor_ptr:\n+\t    __dest._M_access<_Functor*>() =\n+\t      &_Base::_M_get_pointer(__source)->__value;\n+\t    break;\n+\t    \n+\t  default:\n+\t    _Base::_M_manager(__dest, __source, __op);\n+\t  }\n+        return false;\n+      }\n+\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+\tmem_fn(_Base::_M_get_pointer(__functor)->__value)(\n+            std::forward<_ArgTypes>(__args)...);\n+      }\n+    };\n+\n+  /// class function\n+  template<typename _Res, typename... _ArgTypes>\n+    class function<_Res(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n+      private _Function_base\n+    {\n+      typedef _Res _Signature_type(_ArgTypes...);\n+      \n+      struct _Useless { };\n+      \n+    public:\n+      typedef _Res result_type;\n+      \n+      // [3.7.2.1] construct/copy/destroy\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      explicit\n+      function() : _Function_base() { }\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function(_M_clear_type*) : _Function_base() { }\n+      \n+      /**\n+       *  @brief %Function copy constructor.\n+       *  @param x A %function object with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *\n+       *  The newly-created %function contains a copy of the target of @a\n+       *  x (if it has one).\n+       */\n+      function(const function& __x);\n+\n+      /**\n+       *  @brief %Function move constructor.\n+       *  @param x A %function object rvalue with identical call signature.\n+       *\n+       *  The newly-created %function contains the target of @a x\n+       *  (if it has one).\n+       */\n+      function(function&& __x) : _Function_base()\n+      {\n+        __x.swap(*this);\n+      }\n+\n+      // TODO: needs allocator_arg_t\n+      \n+      /**\n+       *  @brief Builds a %function that targets a copy of the incoming\n+       *  function object.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *\n+       *  The newly-created %function object will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, the newly-created object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        function(_Functor __f,\n+                 typename __gnu_cxx::__enable_if<\n+                           !is_integral<_Functor>::value, _Useless>::__type\n+                   = _Useless());\n+\n+      /**\n+       *  @brief %Function assignment operator.\n+       *  @param x A %function with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *  @returns @c *this\n+       *\n+       *  The target of @a x is copied to @c *this. If @a x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an %exception.\n+       */\n+      function&\n+      operator=(const function& __x)\n+      {\n+        function(__x).swap(*this);\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function move-assignment operator.\n+       *  @param x A %function rvalue with identical call signature.\n+       *  @returns @c *this\n+       *\n+       *  The target of @a x is moved to @c *this. If @a x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an %exception.\n+       */\n+      function&\n+      operator=(function&& __x)\n+      {\n+        function(std::move(__x)).swap(*this);\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to zero.\n+       *  @post @c !(bool)*this\n+       *  @returns @c *this\n+       *\n+       *  The target of @c *this is deallocated, leaving it empty.\n+       */\n+      function&\n+      operator=(_M_clear_type*)\n+      {\n+        if (_M_manager)\n+\t  {\n+\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n+\t    _M_manager = 0;\n+\t    _M_invoker = 0;\n+\t  }\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to a new target.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *  @return @c *this\n+       *\n+       *  This  %function object wrapper will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, @c this object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+\t                                function&>::__type\n+\toperator=(_Functor __f)\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      /// @overload\n+      template<typename _Functor>\n+        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+\t                                function&>::__type\n+\toperator=(reference_wrapper<_Functor> __f)\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      // [3.7.2.2] function modifiers\n+      \n+      /**\n+       *  @brief Swap the targets of two %function objects.\n+       *  @param f A %function with identical call signature.\n+       *\n+       *  Swap the targets of @c this function object and @a f. This\n+       *  function will not throw an %exception.\n+       */\n+      void swap(function& __x)\n+      {\n+\t_Any_data __old_functor = _M_functor;\n+\t_M_functor = __x._M_functor;\n+\t__x._M_functor = __old_functor;\n+\t_Manager_type __old_manager = _M_manager;\n+\t_M_manager = __x._M_manager;\n+\t__x._M_manager = __old_manager;\n+\t_Invoker_type __old_invoker = _M_invoker;\n+\t_M_invoker = __x._M_invoker;\n+\t__x._M_invoker = __old_invoker;\n+      }\n+\n+      // TODO: needs allocator_arg_t\n+      /*\n+      template<typename _Functor, typename _Alloc>\n+        void\n+        assign(_Functor __f, const _Alloc& __a)\n+        {\n+          function(__f, __a).swap(*this);\n+        }\n+      */\n+      \n+      // [3.7.2.3] function capacity\n+\n+      /**\n+       *  @brief Determine if the %function wrapper has a target.\n+       *\n+       *  @return @c true when this %function object contains a target,\n+       *  or @c false when it is empty.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+      explicit operator bool() const\n+      { return !_M_empty(); }\n+\n+      // [3.7.2.4] function invocation\n+\n+      /**\n+       *  @brief Invokes the function targeted by @c *this.\n+       *  @returns the result of the target.\n+       *  @throws bad_function_call when @c !(bool)*this\n+       *\n+       *  The function call operator invokes the target function object\n+       *  stored by @c this.\n+       */\n+      _Res operator()(_ArgTypes... __args) const;\n+\n+#ifdef __GXX_RTTI\n+      // [3.7.2.5] function target access\n+      /**\n+       *  @brief Determine the type of the target of this function object\n+       *  wrapper.\n+       *\n+       *  @returns the type identifier of the target function object, or\n+       *  @c typeid(void) if @c !(bool)*this.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+      const type_info& target_type() const;\n+      \n+      /**\n+       *  @brief Access the stored target function object.\n+       *\n+       *  @return Returns a pointer to the stored target function object,\n+       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  pointer.\n+       *\n+       * This function will not throw an %exception.\n+       */\n+      template<typename _Functor>       _Functor* target();\n+      \n+      /// @overload\n+      template<typename _Functor> const _Functor* target() const;\n+#endif\n+\n+      // deleted overloads\n+      template<typename _Res2, typename... _ArgTypes2>\n+\tvoid operator==(const function<_Res2(_ArgTypes2...)>&) const = delete;\n+      template<typename _Res2, typename... _ArgTypes2>\n+\tvoid operator!=(const function<_Res2(_ArgTypes2...)>&) const = delete;\n+\n+    private:\n+      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+      _Invoker_type _M_invoker;\n+  };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    function<_Res(_ArgTypes...)>::\n+    function(const function& __x)\n+    : _Function_base()\n+    {\n+      if (static_cast<bool>(__x))\n+\t{\n+\t  _M_invoker = __x._M_invoker;\n+\t  _M_manager = __x._M_manager;\n+\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+\t}\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f,\n+\t       typename __gnu_cxx::__enable_if<\n+                       !is_integral<_Functor>::value, _Useless>::__type)\n+      : _Function_base()\n+      {\n+\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+\n+\tif (_My_handler::_M_not_empty_function(__f))\n+\t  {\n+\t    _M_invoker = &_My_handler::_M_invoke;\n+\t    _M_manager = &_My_handler::_M_manager;\n+\t    _My_handler::_M_init_functor(_M_functor, __f);\n+\t  }\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    _Res\n+    function<_Res(_ArgTypes...)>::\n+    operator()(_ArgTypes... __args) const\n+    {\n+      if (_M_empty())\n+        {\n+#if __EXCEPTIONS\n+          throw bad_function_call();\n+#else\n+          __builtin_abort();\n+#endif\n+        }\n+      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);\n+    }\n+\n+#ifdef __GXX_RTTI\n+  template<typename _Res, typename... _ArgTypes>\n+    const type_info&\n+    function<_Res(_ArgTypes...)>::\n+    target_type() const\n+    {\n+      if (_M_manager)\n+        {\n+          _Any_data __typeinfo_result;\n+          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+          return *__typeinfo_result._M_access<const type_info*>();\n+        }\n+      else\n+\treturn typeid(void);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target()\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+\t\t&& !is_const<_Functor>::value)\n+\t      return 0;\n+\t    else\n+\t      return __ptr._M_access<_Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      const _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() const\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t    return __ptr._M_access<const _Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+#endif\n+\n+  // [20.7.15.2.6] null pointer comparisons\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c true if the wrapper has no target, @c false otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator==(const function<_Res(_Args...)>& __f, _M_clear_type*)\n+    { return !static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator==(_M_clear_type*, const function<_Res(_Args...)>& __f)\n+    { return !static_cast<bool>(__f); }\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c false if the wrapper has no target, @c true otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator!=(const function<_Res(_Args...)>& __f, _M_clear_type*)\n+    { return static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Res, typename... _Args>\n+    inline bool\n+    operator!=(_M_clear_type*, const function<_Res(_Args...)>& __f)\n+    { return static_cast<bool>(__f); }\n+\n+  // [20.7.15.2.7] specialized algorithms\n+\n+  /**\n+   *  @brief Swap the targets of two polymorphic function object wrappers.\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Res, typename... _Args>\n+    inline void\n+    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)\n+    { __x.swap(__y); }\n+}\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_FUNCTIONAL"}, {"sha": "4825509aed79ced7de8d60417028514088a4d23f", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 2095, "deletions": 15, "changes": 2110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -31,10 +31,6 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n #include <bits/c++config.h>\n #include <bits/stl_function.h>\n \n@@ -46,18 +42,2102 @@\n #include <tr1/functional_hash.h>\n #include <ext/type_traits.h>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/functional>\n+namespace std\n+{\n+namespace tr1\n+{\n+  template<typename _MemberPointer>\n+    class _Mem_fn;\n+\n+  /**\n+   *  Actual implementation of _Has_result_type, which uses SFINAE to\n+   *  determine if the type _Tp has a publicly-accessible member type\n+   *  result_type.\n+  */\n+  template<typename _Tp>\n+    class _Has_result_type_helper : __sfinae_types\n+    {\n+      template<typename _Up>\n+        struct _Wrap_type\n+\t{ };\n+\n+      template<typename _Up>\n+        static __one __test(_Wrap_type<typename _Up::result_type>*);\n+\n+      template<typename _Up>\n+        static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test<_Tp>(0)) == 1;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Has_result_type\n+    : integral_constant<bool,\n+\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n+    { };\n+\n+  /**\n+   *  \n+  */\n+  /// If we have found a result_type, extract it.\n+  template<bool _Has_result_type, typename _Functor>\n+    struct _Maybe_get_result_type\n+    { };\n+\n+  template<typename _Functor>\n+    struct _Maybe_get_result_type<true, _Functor>\n+    {\n+      typedef typename _Functor::result_type result_type;\n+    };\n+\n+  /**\n+   *  Base class for any function object that has a weak result type, as\n+   *  defined in 3.3/3 of TR1.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type_impl\n+    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n+    {\n+    };\n+\n+  /// Retrieve the result type for a function type.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve the result type for a function reference.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve the result type for a function pointer.\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a const member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a volatile member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /// Retrieve result type for a const volatile member function pointer. \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   *  Strip top-level cv-qualifiers from the function object and let\n+   *  _Weak_result_type_impl perform the real work.\n+  */\n+  template<typename _Functor>\n+    struct _Weak_result_type\n+    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n+    {\n+    };\n+\n+  template<typename _Signature>\n+    class result_of;\n+\n+  /**\n+   *  Actual implementation of result_of. When _Has_result_type is\n+   *  true, gets its result from _Weak_result_type. Otherwise, uses\n+   *  the function object's member template result to extract the\n+   *  result type.\n+  */\n+  template<bool _Has_result_type, typename _Signature>\n+    struct _Result_of_impl;\n+\n+  // Handle member data pointers using _Mem_fn's logic\n+  template<typename _Res, typename _Class, typename _T1>\n+    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n+    {\n+      typedef typename _Mem_fn<_Res _Class::*>\n+                ::template _Result_type<_T1>::type type;\n+    };\n+\n+  /**\n+   * Determine whether we can determine a result type from @c Functor \n+   * alone.\n+   */ \n+  template<typename _Functor, typename... _ArgTypes>\n+    class result_of<_Functor(_ArgTypes...)>\n+    : public _Result_of_impl<\n+               _Has_result_type<_Weak_result_type<_Functor> >::value,\n+               _Functor(_ArgTypes...)>\n+    {\n+    };\n+\n+  /// We already know the result type for @c Functor; use it.\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Weak_result_type<_Functor>::result_type type;\n+    };\n+\n+  /**\n+   * We need to compute the result type for this invocation the hard \n+   * way.\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Functor\n+                ::template result<_Functor(_ArgTypes...)>::type type;\n+    };\n+\n+  /**\n+   * It is unsafe to access ::result when there are zero arguments, so we \n+   * return @c void instead.\n+   */\n+  template<typename _Functor>\n+    struct _Result_of_impl<false, _Functor()>\n+    {\n+      typedef void type;\n+    };\n+\n+  /// Determines if the type _Tp derives from unary_function.\n+  template<typename _Tp>\n+    struct _Derives_from_unary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _Res>\n+        static __one __test(const volatile unary_function<_T1, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /// Determines if the type _Tp derives from binary_function.\n+  template<typename _Tp>\n+    struct _Derives_from_binary_function : __sfinae_types\n+    {\n+    private:\n+      template<typename _T1, typename _T2, typename _Res>\n+        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n+\n+      // It's tempting to change \"...\" to const volatile void*, but\n+      // that fails when _Tp is a function type.\n+      static __two __test(...);\n+\n+    public:\n+      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n+    };\n+\n+  /// Turns a function type into a function pointer type\n+  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n+    struct _Function_to_function_pointer\n+    {\n+      typedef _Tp type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Function_to_function_pointer<_Tp, true>\n+    {\n+      typedef _Tp* type;\n+    };\n+\n+  /**\n+   * Invoke a function object, which may be either a member pointer or a\n+   * function object. The first parameter will tell which.\n+   */\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (!is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return mem_fn(__f)(__args...);\n+    }\n+\n+  // To pick up function references (that will become function pointers)\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+             (is_pointer<_Functor>::value\n+              && is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n+    __invoke(_Functor __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  /**\n+   *  Knowing which of unary_function and binary_function _Tp derives\n+   *  from, derives from the same and ensures that reference_wrapper\n+   *  will have a weak result type. See cases below.\n+   */\n+  template<bool _Unary, bool _Binary, typename _Tp>\n+    struct _Reference_wrapper_base_impl;\n+\n+  // Not a unary_function or binary_function, so try a weak result type.\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, false, _Tp>\n+    : _Weak_result_type<_Tp>\n+    { };\n+\n+  // unary_function but not binary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, false, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>\n+    { };\n+\n+  // binary_function but not unary_function\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<false, true, _Tp>\n+    : binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    { };\n+\n+  // Both unary_function and binary_function. Import result_type to\n+  // avoid conflicts.\n+   template<typename _Tp>\n+    struct _Reference_wrapper_base_impl<true, true, _Tp>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>,\n+      binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n+    {\n+      typedef typename _Tp::result_type result_type;\n+    };\n+\n+  /**\n+   *  Derives from unary_function or binary_function when it\n+   *  can. Specializations handle all of the easy cases. The primary\n+   *  template determines what to do with a class type, which may\n+   *  derive from both unary_function and binary_function.\n+  */\n+  template<typename _Tp>\n+    struct _Reference_wrapper_base\n+    : _Reference_wrapper_base_impl<\n+      _Derives_from_unary_function<_Tp>::value,\n+      _Derives_from_binary_function<_Tp>::value,\n+      _Tp>\n+    { };\n+\n+  // - a function type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a function pointer type (unary)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(*)(_T1)>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  // - a function pointer type (binary)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, no qualifiers)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)()>\n+    : unary_function<_T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, no qualifiers)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n+    : binary_function<_T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n+    : unary_function<const _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n+    : binary_function<const _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n+    : unary_function<volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n+    : binary_function<volatile _T1*, _T2, _Res>\n+    { };\n+\n+  // - a pointer to member function type (unary, const volatile)\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n+    : unary_function<const volatile _T1*, _Res>\n+    { };\n+\n+  // - a pointer to member function type (binary, const volatile)\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n+    : binary_function<const volatile _T1*, _T2, _Res>\n+    { };\n+\n+  /// reference_wrapper\n+  template<typename _Tp>\n+    class reference_wrapper\n+    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    {\n+      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n+      // so turn it into a function pointer type.\n+      typedef typename _Function_to_function_pointer<_Tp>::type\n+        _M_func_type;\n+\n+      _Tp* _M_data;\n+    public:\n+      typedef _Tp type;\n+\n+      explicit\n+      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n+      { }\n+\n+      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n+      _M_data(__inref._M_data)\n+      { }\n+\n+      reference_wrapper&\n+      operator=(const reference_wrapper<_Tp>& __inref)\n+      {\n+        _M_data = __inref._M_data;\n+        return *this;\n+      }\n+\n+      operator _Tp&() const\n+      { return this->get(); }\n+\n+      _Tp&\n+      get() const\n+      { return *_M_data; }\n+\n+      template<typename... _Args>\n+        typename result_of<_M_func_type(_Args...)>::type\n+        operator()(_Args&... __args) const\n+        {\n+\t  return __invoke(get(), __args...);\n+\t}\n+    };\n+\n+\n+  // Denotes a reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(_Tp& __t)\n+    { return reference_wrapper<_Tp>(__t); }\n+\n+  // Denotes a const reference should be taken to a variable.\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(const _Tp& __t)\n+    { return reference_wrapper<const _Tp>(__t); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<_Tp>\n+    ref(reference_wrapper<_Tp> __t)\n+    { return ref(__t.get()); }\n+\n+  template<typename _Tp>\n+    inline reference_wrapper<const _Tp>\n+    cref(reference_wrapper<_Tp> __t)\n+    { return cref(__t.get()); }\n+\n+  template<typename _Tp, bool>\n+    struct _Mem_fn_const_or_non\n+    {\n+      typedef const _Tp& type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Mem_fn_const_or_non<_Tp, false>\n+    {\n+      typedef _Tp& type;\n+    };\n+\n+  /**\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Maybe_unary_or_binary_function { };\n+\n+  /// Derives from @c unary_function, as appropriate. \n+  template<typename _Res, typename _T1> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1>\n+    : std::unary_function<_T1, _Res> { };\n+\n+  /// Derives from @c binary_function, as appropriate. \n+  template<typename _Res, typename _T1, typename _T2> \n+    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+    : std::binary_function<_T1, _T2, _Res> { };\n+\n+  /// Implementation of @c mem_fn for member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(_Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(_Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for const member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n+    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(const _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(const _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for volatile member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res\n+      operator()(volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res\n+      operator()(volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /// Implementation of @c mem_fn for const volatile member function pointers.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n+    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res \n+      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res \n+      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+\n+  template<typename _Res, typename _Class>\n+    class _Mem_fn<_Res _Class::*>\n+    {\n+      // This bit of genius is due to Peter Dimov, improved slightly by\n+      // Douglas Gregor.\n+      template<typename _Tp>\n+        _Res&\n+        _M_call(_Tp& __object, _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        _Res&\n+        _M_call(_Tp& __object, _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp, typename _Up>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Up * const *) const\n+        { return (*__object).*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Class *) const\n+        { return __object.*__pm; }\n+\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __ptr, const volatile void*) const\n+        { return (*__ptr).*__pm; }\n+\n+      template<typename _Tp> static _Tp& __get_ref();\n+\n+      template<typename _Tp>\n+        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+\n+    public:\n+      template<typename _Tp>\n+        struct _Result_type\n+\t: _Mem_fn_const_or_non<_Res,\n+\t  (sizeof(__sfinae_types::__two)\n+\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+        { };\n+\n+      template<typename _Signature>\n+        struct result;\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp)>\n+\t: public _Result_type<_Tp> { };\n+\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp&)>\n+\t: public _Result_type<_Tp> { };\n+\n+      explicit\n+      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+\n+      // Handle objects\n+      _Res&\n+      operator()(_Class& __object) const\n+      { return __object.*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class& __object) const\n+      { return __object.*__pm; }\n+\n+      // Handle pointers\n+      _Res&\n+      operator()(_Class* __object) const\n+      { return __object->*__pm; }\n+\n+      const _Res&\n+      operator()(const _Class* __object) const\n+      { return __object->*__pm; }\n+\n+      // Handle smart pointers and derived\n+      template<typename _Tp>\n+        typename _Result_type<_Tp>::type\n+        operator()(_Tp& __unknown) const\n+        { return _M_call(__unknown, &__unknown); }\n+\n+    private:\n+      _Res _Class::*__pm;\n+    };\n+\n+  /**\n+   *  @brief Returns a function object that forwards to the member\n+   *  pointer @a pm.\n+   */\n+  template<typename _Tp, typename _Class>\n+    inline _Mem_fn<_Tp _Class::*>\n+    mem_fn(_Tp _Class::* __pm)\n+    {\n+      return _Mem_fn<_Tp _Class::*>(__pm);\n+    }\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a function object\n+   *  should be treated as a subexpression when evaluating calls to\n+   *  function objects returned by bind(). [TR1 3.6.1]\n+   */\n+  template<typename _Tp>\n+    struct is_bind_expression\n+    { static const bool value = false; };\n+\n+  template<typename _Tp>\n+    const bool is_bind_expression<_Tp>::value;\n+\n+  /**\n+   *  @brief Determines if the given type _Tp is a placeholder in a\n+   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n+   */\n+  template<typename _Tp>\n+    struct is_placeholder\n+    { static const int value = 0; };\n+\n+  template<typename _Tp>\n+    const int is_placeholder<_Tp>::value;\n+\n+  /// The type of placeholder objects defined by libstdc++.\n+  template<int _Num> struct _Placeholder { };\n+\n+  /** @namespace std::placeholders\n+   *  @brief ISO C++ 0x entities sub namespace for functional.\n+   *\n+   *  Define a large number of placeholders. There is no way to\n+   *  simplify this with variadic templates, because we're introducing\n+   *  unique names for each.\n+   */\n+  namespace placeholders \n+  { \n+    namespace \n+    {\n+      _Placeholder<1> _1;\n+      _Placeholder<2> _2;\n+      _Placeholder<3> _3;\n+      _Placeholder<4> _4;\n+      _Placeholder<5> _5;\n+      _Placeholder<6> _6;\n+      _Placeholder<7> _7;\n+      _Placeholder<8> _8;\n+      _Placeholder<9> _9;\n+      _Placeholder<10> _10;\n+      _Placeholder<11> _11;\n+      _Placeholder<12> _12;\n+      _Placeholder<13> _13;\n+      _Placeholder<14> _14;\n+      _Placeholder<15> _15;\n+      _Placeholder<16> _16;\n+      _Placeholder<17> _17;\n+      _Placeholder<18> _18;\n+      _Placeholder<19> _19;\n+      _Placeholder<20> _20;\n+      _Placeholder<21> _21;\n+      _Placeholder<22> _22;\n+      _Placeholder<23> _23;\n+      _Placeholder<24> _24;\n+      _Placeholder<25> _25;\n+      _Placeholder<26> _26;\n+      _Placeholder<27> _27;\n+      _Placeholder<28> _28;\n+      _Placeholder<29> _29;\n+    } \n+  }\n+\n+  /**\n+   *  Partial specialization of is_placeholder that provides the placeholder\n+   *  number for the placeholder objects defined by libstdc++.\n+   */\n+  template<int _Num>\n+    struct is_placeholder<_Placeholder<_Num> >\n+    { static const int value = _Num; };\n+\n+  template<int _Num>\n+    const int is_placeholder<_Placeholder<_Num> >::value;\n+\n+  /**\n+   * Stores a tuple of indices. Used by bind() to extract the elements\n+   * in a tuple. \n+   */\n+  template<int... _Indexes>\n+    struct _Index_tuple { };\n+\n+  /// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n+  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n+    struct _Build_index_tuple;\n+ \n+  template<std::size_t _Num, int... _Indexes> \n+    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n+    : _Build_index_tuple<_Num - 1, \n+                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n+    {\n+    };\n+\n+  template<int... _Indexes>\n+    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n+    {\n+      typedef _Index_tuple<_Indexes...> __type;\n+    };\n+\n+  /** \n+   * Used by _Safe_tuple_element to indicate that there is no tuple\n+   * element at this position.\n+   */\n+  struct _No_tuple_element;\n+\n+  /**\n+   * Implementation helper for _Safe_tuple_element. This primary\n+   * template handles the case where it is safe to use @c\n+   * tuple_element.\n+   */\n+  template<int __i, typename _Tuple, bool _IsSafe>\n+    struct _Safe_tuple_element_impl\n+    : tuple_element<__i, _Tuple> { };\n+\n+  /**\n+   * Implementation helper for _Safe_tuple_element. This partial\n+   * specialization handles the case where it is not safe to use @c\n+   * tuple_element. We just return @c _No_tuple_element.\n+   */\n+  template<int __i, typename _Tuple>\n+    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n+    {\n+      typedef _No_tuple_element type;\n+    };\n+\n+  /**\n+   * Like tuple_element, but returns @c _No_tuple_element when\n+   * tuple_element would return an error.\n+   */\n+ template<int __i, typename _Tuple>\n+   struct _Safe_tuple_element\n+   : _Safe_tuple_element_impl<__i, _Tuple, \n+                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   {\n+   };\n+\n+  /**\n+   *  Maps an argument to bind() into an actual argument to the bound\n+   *  function object [TR1 3.6.3/5]. Only the first parameter should\n+   *  be specified: the rest are used to determine among the various\n+   *  implementations. Note that, although this class is a function\n+   *  object, it isn't entirely normal because it takes only two\n+   *  parameters regardless of the number of parameters passed to the\n+   *  bind expression. The first parameter is the bound argument and\n+   *  the second parameter is a tuple containing references to the\n+   *  rest of the arguments.\n+   */\n+  template<typename _Arg,\n+           bool _IsBindExp = is_bind_expression<_Arg>::value,\n+           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n+    class _Mu;\n+\n+  /**\n+   *  If the argument is reference_wrapper<_Tp>, returns the\n+   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n+   */\n+  template<typename _Tp>\n+    class _Mu<reference_wrapper<_Tp>, false, false>\n+    {\n+    public:\n+      typedef _Tp& result_type;\n+\n+      /* Note: This won't actually work for const volatile\n+       * reference_wrappers, because reference_wrapper::get() is const\n+       * but not volatile-qualified. This might be a defect in the TR.\n+       */\n+      template<typename _CVRef, typename _Tuple>\n+        result_type\n+        operator()(_CVRef& __arg, const _Tuple&) const volatile\n+        { return __arg.get(); }\n+    };\n+\n+  /**\n+   *  If the argument is a bind expression, we invoke the underlying\n+   *  function object with the same cv-qualifiers as we are given and\n+   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, true, false>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      // Determine the result type when we pass the arguments along. This\n+      // involves passing along the cv-qualifiers placed on _Mu and\n+      // unwrapping the argument bundle.\n+      template<typename _CVMu, typename _CVArg, typename... _Args>\n+        class result<_CVMu(_CVArg, tuple<_Args...>)>\n+\t: public result_of<_CVArg(_Args...)> { };\n+\n+      template<typename _CVArg, typename... _Args>\n+        typename result_of<_CVArg(_Args...)>::type\n+        operator()(_CVArg& __arg,\n+\t\t   const tuple<_Args...>& __tuple) const volatile\n+        {\n+\t  // Construct an index tuple and forward to __call\n+\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n+\t    _Indexes;\n+\t  return this->__call(__arg, __tuple, _Indexes());\n+\t}\n+\n+    private:\n+      // Invokes the underlying function object __arg by unpacking all\n+      // of the arguments in the tuple. \n+      template<typename _CVArg, typename... _Args, int... _Indexes>\n+        typename result_of<_CVArg(_Args...)>::type\n+        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+\t       const _Index_tuple<_Indexes...>&) const volatile\n+        {\n+\t  return __arg(tr1::get<_Indexes>(__tuple)...);\n+\t}\n+    };\n+\n+  /**\n+   *  If the argument is a placeholder for the Nth argument, returns\n+   *  a reference to the Nth argument to the bind function object.\n+   *  [TR1 3.6.3/5 bullet 3]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, true>\n+    {\n+    public:\n+      template<typename _Signature> class result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        class result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  // Add a reference, if it hasn't already been done for us.\n+\t  // This allows us to be a little bit sloppy in constructing\n+\t  // the tuple that we pass to result_of<...>.\n+\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n+\t\t\t\t\t\t- 1), _Tuple>::type\n+\t    __base_type;\n+\n+\tpublic:\n+\t  typedef typename add_reference<__base_type>::type type;\n+\t};\n+\n+      template<typename _Tuple>\n+        typename result<_Mu(_Arg, _Tuple)>::type\n+        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n+        {\n+\t  return ::std::tr1::get<(is_placeholder<_Arg>::value - 1)>(__tuple);\n+\t}\n+    };\n+\n+  /**\n+   *  If the argument is just a value, returns a reference to that\n+   *  value. The cv-qualifiers on the reference are the same as the\n+   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n+   */\n+  template<typename _Arg>\n+    class _Mu<_Arg, false, false>\n+    {\n+    public:\n+      template<typename _Signature> struct result;\n+\n+      template<typename _CVMu, typename _CVArg, typename _Tuple>\n+        struct result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  typedef typename add_reference<_CVArg>::type type;\n+\t};\n+\n+      // Pick up the cv-qualifiers of the argument\n+      template<typename _CVArg, typename _Tuple>\n+        _CVArg&\n+        operator()(_CVArg& __arg, const _Tuple&) const volatile\n+        { return __arg; }\n+    };\n+\n+  /**\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). The\n+   *  primary template handles the non--member-pointer case.\n+   */\n+  template<typename _Tp>\n+    struct _Maybe_wrap_member_pointer\n+    {\n+      typedef _Tp type;\n+      \n+      static const _Tp&\n+      __do_wrap(const _Tp& __x)\n+      { return __x; }\n+    };\n+\n+  /**\n+   *  Maps member pointers into instances of _Mem_fn but leaves all\n+   *  other function objects untouched. Used by tr1::bind(). This\n+   *  partial specialization handles the member pointer case.\n+   */\n+  template<typename _Tp, typename _Class>\n+    struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n+    {\n+      typedef _Mem_fn<_Tp _Class::*> type;\n+      \n+      static type\n+      __do_wrap(_Tp _Class::* __pm)\n+      { return type(__pm); }\n+    };\n+\n+  /// Type of the function object returned from bind().\n+  template<typename _Signature>\n+    struct _Bind;\n+\n+   template<typename _Functor, typename... _Bound_args>\n+    class _Bind<_Functor(_Bound_args...)>\n+    : public _Weak_result_type<_Functor>\n+    {\n+      typedef _Bind __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (volatile _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const volatile _Bound_args, \n+                                     tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+     public:\n+      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n+        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const volatile _Bound_args, \n+                             tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /// Type of the function object returned from bind<R>().\n+  template<typename _Result, typename _Signature>\n+    struct _Bind_result;\n+\n+  template<typename _Result, typename _Functor, typename... _Bound_args>\n+    class _Bind_result<_Result, _Functor(_Bound_args...)>\n+    {\n+      typedef _Bind_result __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (tr1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+    public:\n+      typedef _Result result_type;\n+\n+      explicit\n+      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n+      : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(tr1::tie(__args...), _Bound_indexes());\n+        }\n+    };\n+\n+  /// Class template _Bind is always a bind expression.\n+  template<typename _Signature>\n+    struct is_bind_expression<_Bind<_Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Signature>\n+    const bool is_bind_expression<_Bind<_Signature> >::value;\n+\n+  /// Class template _Bind_result is always a bind expression.\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n+    { static const bool value = true; };\n+\n+  template<typename _Result, typename _Signature>\n+    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n+\n+  /// bind\n+  template<typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    } \n+\n+  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind_result<_Result,\n+\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n+                            (_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n+\t__result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    }\n+\n+  /**\n+   *  @brief Exception class thrown when class template function's\n+   *  operator() is called with an empty target.\n+   *  @ingroup exceptions\n+   */\n+  class bad_function_call : public std::exception { };\n+\n+  /**\n+   *  The integral constant expression 0 can be converted into a\n+   *  pointer to this type. It is used by the function template to\n+   *  accept NULL pointers.\n+   */\n+  struct _M_clear_type;\n+\n+  /**\n+   *  Trait identifying \"location-invariant\" types, meaning that the\n+   *  address of the object (or any of its members) will not escape.\n+   *  Also implies a trivial copy constructor and assignment operator.\n+   */\n+  template<typename _Tp>\n+    struct __is_location_invariant\n+    : integral_constant<bool,\n+                        (is_pointer<_Tp>::value\n+                         || is_member_pointer<_Tp>::value)>\n+    {\n+    };\n+\n+  class _Undefined_class;\n+\n+  union _Nocopy_types\n+  {\n+    void*       _M_object;\n+    const void* _M_const_object;\n+    void (*_M_function_pointer)();\n+    void (_Undefined_class::*_M_member_pointer)();\n+  };\n+\n+  union _Any_data\n+  {\n+    void*       _M_access()       { return &_M_pod_data[0]; }\n+    const void* _M_access() const { return &_M_pod_data[0]; }\n+\n+    template<typename _Tp>\n+      _Tp&\n+      _M_access()\n+      { return *static_cast<_Tp*>(_M_access()); }\n+\n+    template<typename _Tp>\n+      const _Tp&\n+      _M_access() const\n+      { return *static_cast<const _Tp*>(_M_access()); }\n+\n+    _Nocopy_types _M_unused;\n+    char _M_pod_data[sizeof(_Nocopy_types)];\n+  };\n+\n+  enum _Manager_operation\n+  {\n+    __get_type_info,\n+    __get_functor_ptr,\n+    __clone_functor,\n+    __destroy_functor\n+  };\n+\n+  // Simple type wrapper that helps avoid annoying const problems\n+  // when casting between void pointers and pointers-to-pointers.\n+  template<typename _Tp>\n+    struct _Simple_type_wrapper\n+    {\n+      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n+\n+      _Tp __value;\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n+    : __is_location_invariant<_Tp>\n+    {\n+    };\n+\n+  // Converts a reference to a function object into a callable\n+  // function object.\n+  template<typename _Functor>\n+    inline _Functor&\n+    __callable_functor(_Functor& __f)\n+    { return __f; }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Member, typename _Class>\n+    inline _Mem_fn<_Member _Class::*>\n+    __callable_functor(_Member _Class::* const &__p)\n+    { return mem_fn(__p); }\n+\n+  template<typename _Signature>\n+    class function;\n+\n+  /// Base class of all polymorphic function object wrappers.\n+  class _Function_base\n+  {\n+  public:\n+    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n+    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n+\n+    template<typename _Functor>\n+      class _Base_manager\n+      {\n+      protected:\n+\tstatic const bool __stored_locally =\n+        (__is_location_invariant<_Functor>::value\n+         && sizeof(_Functor) <= _M_max_size\n+         && __alignof__(_Functor) <= _M_max_align\n+         && (_M_max_align % __alignof__(_Functor) == 0));\n+\t\n+\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+\t// Retrieve a pointer to the function object\n+\tstatic _Functor*\n+\t_M_get_pointer(const _Any_data& __source)\n+\t{\n+\t  const _Functor* __ptr =\n+\t    __stored_locally? &__source._M_access<_Functor>()\n+\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n+\t  return const_cast<_Functor*>(__ptr);\n+\t}\n+\n+\t// Clone a location-invariant function object that fits within\n+\t// an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+\t{\n+\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+\t}\n+\n+\t// Clone a function object that is not location-invariant or\n+\t// that cannot fit into an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+\t{\n+\t  __dest._M_access<_Functor*>() =\n+\t    new _Functor(*__source._M_access<_Functor*>());\n+\t}\n+\n+\t// Destroying a location-invariant object may still require\n+\t// destruction.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, true_type)\n+\t{\n+\t  __victim._M_access<_Functor>().~_Functor();\n+\t}\n+\t\n+\t// Destroying an object located on the heap.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, false_type)\n+\t{\n+\t  delete __victim._M_access<_Functor*>();\n+\t}\n+\t\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#ifdef __GXX_RTTI\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+#endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+\t      break;\n+\t      \n+\t    case __clone_functor:\n+\t      _M_clone(__dest, __source, _Local_storage());\n+\t      break;\n+\n+\t    case __destroy_functor:\n+\t      _M_destroy(__dest, _Local_storage());\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n+\t{ _M_init_functor(__functor, __f, _Local_storage()); }\n+\t\n+\ttemplate<typename _Signature>\n+\t  static bool\n+\t  _M_not_empty_function(const function<_Signature>& __f)\n+          { return static_cast<bool>(__f); }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp*& __fp)\n+\t  { return __fp; }\n+\n+\ttemplate<typename _Class, typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n+\t  { return __mp; }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp&)\n+\t  { return true; }\n+\n+      private:\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n+\t{ new (__functor._M_access()) _Functor(__f); }\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n+\t{ __functor._M_access<_Functor*>() = new _Functor(__f); }\n+      };\n+\n+    template<typename _Functor>\n+      class _Ref_manager : public _Base_manager<_Functor*>\n+      {\n+\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n+\n+    public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+#ifdef __GXX_RTTI\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+#endif\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+\t      return is_const<_Functor>::value;\n+\t      break;\n+\t      \n+\t    default:\n+\t      _Base::_M_manager(__dest, __source, __op);\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+\t{\n+\t  // TBD: Use address_of function instead.\n+\t  _Base::_M_init_functor(__functor, &__f.get());\n+\t}\n+      };\n+\n+    _Function_base() : _M_manager(0) { }\n+    \n+    ~_Function_base()\n+    {\n+      if (_M_manager)\n+\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n+    }\n+\n+\n+    bool _M_empty() const { return !_M_manager; }\n+\n+    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n+                                  _Manager_operation);\n+\n+    _Any_data     _M_functor;\n+    _Manager_type _M_manager;\n+  };\n+\n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+    public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return \n+          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n+    : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename _Res, \n+           typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n+    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    {\n+      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+        _Base;\n+\n+     public:\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return tr1::\n+\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    : public _Function_base::_Base_manager<\n+                 _Simple_type_wrapper< _Member _Class::* > >\n+    {\n+      typedef _Member _Class::* _Functor;\n+      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n+      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+     public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op)\n+\t  {\n+#ifdef __GXX_RTTI\n+\t  case __get_type_info:\n+\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t    break;\n+#endif\t    \n+\t  case __get_functor_ptr:\n+\t    __dest._M_access<_Functor*>() =\n+\t      &_Base::_M_get_pointer(__source)->__value;\n+\t    break;\n+\t    \n+\t  default:\n+\t    _Base::_M_manager(__dest, __source, __op);\n+\t  }\n+        return false;\n+      }\n+\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+\ttr1::mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  /// class function\n+  template<typename _Res, typename... _ArgTypes>\n+    class function<_Res(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n+      private _Function_base\n+    {\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+      /// This class is used to implement the safe_bool idiom.\n+      struct _Hidden_type\n+      {\n+\t_Hidden_type* _M_bool;\n+      };\n+\n+      /// This typedef is used to implement the safe_bool idiom.\n+      typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n+#endif\n+\n+      typedef _Res _Signature_type(_ArgTypes...);\n+      \n+      struct _Useless { };\n+      \n+    public:\n+      typedef _Res result_type;\n+      \n+      // [3.7.2.1] construct/copy/destroy\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function() : _Function_base() { }\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function(_M_clear_type*) : _Function_base() { }\n+      \n+      /**\n+       *  @brief %Function copy constructor.\n+       *  @param x A %function object with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *\n+       *  The newly-created %function contains a copy of the target of @a\n+       *  x (if it has one).\n+       */\n+      function(const function& __x);\n+\n+      /**\n+       *  @brief Builds a %function that targets a copy of the incoming\n+       *  function object.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *\n+       *  The newly-created %function object will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, the newly-created object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        function(_Functor __f,\n+                 typename __gnu_cxx::__enable_if<\n+                           !is_integral<_Functor>::value, _Useless>::__type\n+                   = _Useless());\n+\n+      /**\n+       *  @brief %Function assignment operator.\n+       *  @param x A %function with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *  @returns @c *this\n+       *\n+       *  The target of @a x is copied to @c *this. If @a x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an %exception.\n+       */\n+      function&\n+      operator=(const function& __x)\n+      {\n+        function(__x).swap(*this);\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to zero.\n+       *  @post @c !(bool)*this\n+       *  @returns @c *this\n+       *\n+       *  The target of @c *this is deallocated, leaving it empty.\n+       */\n+      function&\n+      operator=(_M_clear_type*)\n+      {\n+        if (_M_manager)\n+\t  {\n+\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n+\t    _M_manager = 0;\n+\t    _M_invoker = 0;\n+\t  }\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief %Function assignment to a new target.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *  @return @c *this\n+       *\n+       *  This  %function object wrapper will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, @c this object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+\t                                function&>::__type\n+\toperator=(_Functor __f)\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      // [3.7.2.2] function modifiers\n+      \n+      /**\n+       *  @brief Swap the targets of two %function objects.\n+       *  @param f A %function with identical call signature.\n+       *\n+       *  Swap the targets of @c this function object and @a f. This\n+       *  function will not throw an %exception.\n+       */\n+      void swap(function& __x)\n+      {\n+\t_Any_data __old_functor = _M_functor;\n+\t_M_functor = __x._M_functor;\n+\t__x._M_functor = __old_functor;\n+\t_Manager_type __old_manager = _M_manager;\n+\t_M_manager = __x._M_manager;\n+\t__x._M_manager = __old_manager;\n+\t_Invoker_type __old_invoker = _M_invoker;\n+\t_M_invoker = __x._M_invoker;\n+\t__x._M_invoker = __old_invoker;\n+      }\n+\n+      // [3.7.2.3] function capacity\n+\n+      /**\n+       *  @brief Determine if the %function wrapper has a target.\n+       *\n+       *  @return @c true when this %function object contains a target,\n+       *  or @c false when it is empty.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      explicit operator bool() const\n+      { return !_M_empty(); }\n #else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/functional>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n+      operator _Safe_bool() const\n+      {\n+        if (_M_empty())\n+\t  return 0;\n+\telse\n+\t  return &_Hidden_type::_M_bool;\n+      }\n #endif\n \n+      // [3.7.2.4] function invocation\n+\n+      /**\n+       *  @brief Invokes the function targeted by @c *this.\n+       *  @returns the result of the target.\n+       *  @throws bad_function_call when @c !(bool)*this\n+       *\n+       *  The function call operator invokes the target function object\n+       *  stored by @c this.\n+       */\n+      _Res operator()(_ArgTypes... __args) const;\n+\n+#ifdef __GXX_RTTI\n+      // [3.7.2.5] function target access\n+      /**\n+       *  @brief Determine the type of the target of this function object\n+       *  wrapper.\n+       *\n+       *  @returns the type identifier of the target function object, or\n+       *  @c typeid(void) if @c !(bool)*this.\n+       *\n+       *  This function will not throw an %exception.\n+       */\n+      const type_info& target_type() const;\n+      \n+      /**\n+       *  @brief Access the stored target function object.\n+       *\n+       *  @return Returns a pointer to the stored target function object,\n+       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  pointer.\n+       *\n+       * This function will not throw an %exception.\n+       */\n+      template<typename _Functor>       _Functor* target();\n+      \n+      /// @overload\n+      template<typename _Functor> const _Functor* target() const;\n+#endif\n+\n+    private:\n+      // [3.7.2.6] undefined operators\n+      template<typename _Function>\n+\tvoid operator==(const function<_Function>&) const;\n+      template<typename _Function>\n+\tvoid operator!=(const function<_Function>&) const;\n+\n+      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+      _Invoker_type _M_invoker;\n+  };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    function<_Res(_ArgTypes...)>::\n+    function(const function& __x)\n+    : _Function_base()\n+    {\n+      if (static_cast<bool>(__x))\n+\t{\n+\t  _M_invoker = __x._M_invoker;\n+\t  _M_manager = __x._M_manager;\n+\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+\t}\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f,\n+\t       typename __gnu_cxx::__enable_if<\n+                       !is_integral<_Functor>::value, _Useless>::__type)\n+      : _Function_base()\n+      {\n+\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+\n+\tif (_My_handler::_M_not_empty_function(__f))\n+\t  {\n+\t    _M_invoker = &_My_handler::_M_invoke;\n+\t    _M_manager = &_My_handler::_M_manager;\n+\t    _My_handler::_M_init_functor(_M_functor, __f);\n+\t  }\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    _Res\n+    function<_Res(_ArgTypes...)>::\n+    operator()(_ArgTypes... __args) const\n+    {\n+      if (_M_empty())\n+        {\n+#if __EXCEPTIONS\n+          throw bad_function_call();\n+#else\n+          __builtin_abort();\n+#endif\n+        }\n+      return _M_invoker(_M_functor, __args...);\n+    }\n+\n+#ifdef __GXX_RTTI\n+  template<typename _Res, typename... _ArgTypes>\n+    const type_info&\n+    function<_Res(_ArgTypes...)>::\n+    target_type() const\n+    {\n+      if (_M_manager)\n+        {\n+          _Any_data __typeinfo_result;\n+          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+          return *__typeinfo_result._M_access<const type_info*>();\n+        }\n+      else\n+\treturn typeid(void);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target()\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+\t\t&& !is_const<_Functor>::value)\n+\t      return 0;\n+\t    else\n+\t      return __ptr._M_access<_Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    template<typename _Functor>\n+      const _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() const\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t    return __ptr._M_access<const _Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+#endif\n+\n+  // [3.7.2.7] null pointer comparisons\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c true if the wrapper has no target, @c false otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator==(const function<_Signature>& __f, _M_clear_type*)\n+    { return !static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Signature>\n+    inline bool\n+    operator==(_M_clear_type*, const function<_Signature>& __f)\n+    { return !static_cast<bool>(__f); }\n+\n+  /**\n+   *  @brief Compares a polymorphic function object wrapper against 0\n+   *  (the NULL pointer).\n+   *  @returns @c false if the wrapper has no target, @c true otherwise\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(const function<_Signature>& __f, _M_clear_type*)\n+    { return static_cast<bool>(__f); }\n+\n+  /// @overload\n+  template<typename _Signature>\n+    inline bool\n+    operator!=(_M_clear_type*, const function<_Signature>& __f)\n+    { return static_cast<bool>(__f); }\n+\n+  // [3.7.2.8] specialized algorithms\n+\n+  /**\n+   *  @brief Swap the targets of two polymorphic function object wrappers.\n+   *\n+   *  This function will not throw an %exception.\n+   */\n+  template<typename _Signature>\n+    inline void\n+    swap(function<_Signature>& __x, function<_Signature>& __y)\n+    { __x.swap(__y); }\n+}\n+}\n+\n #endif // _GLIBCXX_TR1_FUNCTIONAL"}, {"sha": "9911d46d67833af3e8179460028a4cd4448f655f", "filename": "libstdc++-v3/include/tr1_impl/functional", "status": "removed", "additions": 0, "deletions": 2137, "changes": 2137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ffunctional?ref=5da0f2d96bbf59c8fe666d9e7c3a2983e3003f8a", "patch": "@@ -1,2137 +0,0 @@\n-// TR1 functional header -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/functional\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n-\n-  template<typename _MemberPointer>\n-    class _Mem_fn;\n-\n-  /**\n-   *  Actual implementation of _Has_result_type, which uses SFINAE to\n-   *  determine if the type _Tp has a publicly-accessible member type\n-   *  result_type.\n-  */\n-  template<typename _Tp>\n-    class _Has_result_type_helper : __sfinae_types\n-    {\n-      template<typename _Up>\n-        struct _Wrap_type\n-\t{ };\n-\n-      template<typename _Up>\n-        static __one __test(_Wrap_type<typename _Up::result_type>*);\n-\n-      template<typename _Up>\n-        static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test<_Tp>(0)) == 1;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Has_result_type\n-    : integral_constant<bool,\n-\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n-    { };\n-\n-  /**\n-   *  \n-  */\n-  /// If we have found a result_type, extract it.\n-  template<bool _Has_result_type, typename _Functor>\n-    struct _Maybe_get_result_type\n-    { };\n-\n-  template<typename _Functor>\n-    struct _Maybe_get_result_type<true, _Functor>\n-    {\n-      typedef typename _Functor::result_type result_type;\n-    };\n-\n-  /**\n-   *  Base class for any function object that has a weak result type, as\n-   *  defined in 3.3/3 of TR1.\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type_impl\n-    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n-    {\n-    };\n-\n-  /// Retrieve the result type for a function type.\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve the result type for a function reference.\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve the result type for a function pointer.\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve result type for a member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve result type for a const member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve result type for a volatile member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /// Retrieve result type for a const volatile member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n-\n-  /**\n-   *  Strip top-level cv-qualifiers from the function object and let\n-   *  _Weak_result_type_impl perform the real work.\n-  */\n-  template<typename _Functor>\n-    struct _Weak_result_type\n-    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>\n-    {\n-    };\n-\n-  template<typename _Signature>\n-    class result_of;\n-\n-  /**\n-   *  Actual implementation of result_of. When _Has_result_type is\n-   *  true, gets its result from _Weak_result_type. Otherwise, uses\n-   *  the function object's member template result to extract the\n-   *  result type.\n-  */\n-  template<bool _Has_result_type, typename _Signature>\n-    struct _Result_of_impl;\n-\n-  // Handle member data pointers using _Mem_fn's logic\n-  template<typename _Res, typename _Class, typename _T1>\n-    struct _Result_of_impl<false, _Res _Class::*(_T1)>\n-    {\n-      typedef typename _Mem_fn<_Res _Class::*>\n-                ::template _Result_type<_T1>::type type;\n-    };\n-\n-  /**\n-   * Determine whether we can determine a result type from @c Functor \n-   * alone.\n-   */ \n-  template<typename _Functor, typename... _ArgTypes>\n-    class result_of<_Functor(_ArgTypes...)>\n-    : public _Result_of_impl<\n-               _Has_result_type<_Weak_result_type<_Functor> >::value,\n-               _Functor(_ArgTypes...)>\n-    {\n-    };\n-\n-  /// We already know the result type for @c Functor; use it.\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n-    {\n-      typedef typename _Weak_result_type<_Functor>::result_type type;\n-    };\n-\n-  /**\n-   * We need to compute the result type for this invocation the hard \n-   * way.\n-   */\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n-    {\n-      typedef typename _Functor\n-                ::template result<_Functor(_ArgTypes...)>::type type;\n-    };\n-\n-  /**\n-   * It is unsafe to access ::result when there are zero arguments, so we \n-   * return @c void instead.\n-   */\n-  template<typename _Functor>\n-    struct _Result_of_impl<false, _Functor()>\n-    {\n-      typedef void type;\n-    };\n-\n-  /// Determines if the type _Tp derives from unary_function.\n-  template<typename _Tp>\n-    struct _Derives_from_unary_function : __sfinae_types\n-    {\n-    private:\n-      template<typename _T1, typename _Res>\n-        static __one __test(const volatile unary_function<_T1, _Res>*);\n-\n-      // It's tempting to change \"...\" to const volatile void*, but\n-      // that fails when _Tp is a function type.\n-      static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n-    };\n-\n-  /// Determines if the type _Tp derives from binary_function.\n-  template<typename _Tp>\n-    struct _Derives_from_binary_function : __sfinae_types\n-    {\n-    private:\n-      template<typename _T1, typename _T2, typename _Res>\n-        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n-\n-      // It's tempting to change \"...\" to const volatile void*, but\n-      // that fails when _Tp is a function type.\n-      static __two __test(...);\n-\n-    public:\n-      static const bool value = sizeof(__test((_Tp*)0)) == 1;\n-    };\n-\n-  /// Turns a function type into a function pointer type\n-  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>\n-    struct _Function_to_function_pointer\n-    {\n-      typedef _Tp type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Function_to_function_pointer<_Tp, true>\n-    {\n-      typedef _Tp* type;\n-    };\n-\n-  /**\n-   * Invoke a function object, which may be either a member pointer or a\n-   * function object. The first parameter will tell which.\n-   */\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (!is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n-    {\n-      return __f(__args...);\n-    }\n-\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor& __f, _Args&... __args)\n-    {\n-      return mem_fn(__f)(__args...);\n-    }\n-\n-  // To pick up function references (that will become function pointers)\n-  template<typename _Functor, typename... _Args>\n-    inline\n-    typename __gnu_cxx::__enable_if<\n-             (is_pointer<_Functor>::value\n-              && is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::__type\n-    __invoke(_Functor __f, _Args&... __args)\n-    {\n-      return __f(__args...);\n-    }\n-\n-  /**\n-   *  Knowing which of unary_function and binary_function _Tp derives\n-   *  from, derives from the same and ensures that reference_wrapper\n-   *  will have a weak result type. See cases below.\n-   */\n-  template<bool _Unary, bool _Binary, typename _Tp>\n-    struct _Reference_wrapper_base_impl;\n-\n-  // Not a unary_function or binary_function, so try a weak result type.\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<false, false, _Tp>\n-    : _Weak_result_type<_Tp>\n-    { };\n-\n-  // unary_function but not binary_function\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<true, false, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>\n-    { };\n-\n-  // binary_function but not unary_function\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<false, true, _Tp>\n-    : binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n-    { };\n-\n-  // Both unary_function and binary_function. Import result_type to\n-  // avoid conflicts.\n-   template<typename _Tp>\n-    struct _Reference_wrapper_base_impl<true, true, _Tp>\n-    : unary_function<typename _Tp::argument_type,\n-\t\t     typename _Tp::result_type>,\n-      binary_function<typename _Tp::first_argument_type,\n-\t\t      typename _Tp::second_argument_type,\n-\t\t      typename _Tp::result_type>\n-    {\n-      typedef typename _Tp::result_type result_type;\n-    };\n-\n-  /**\n-   *  Derives from unary_function or binary_function when it\n-   *  can. Specializations handle all of the easy cases. The primary\n-   *  template determines what to do with a class type, which may\n-   *  derive from both unary_function and binary_function.\n-  */\n-  template<typename _Tp>\n-    struct _Reference_wrapper_base\n-    : _Reference_wrapper_base_impl<\n-      _Derives_from_unary_function<_Tp>::value,\n-      _Derives_from_binary_function<_Tp>::value,\n-      _Tp>\n-    { };\n-\n-  // - a function type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a function pointer type (unary)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res(*)(_T1)>\n-    : unary_function<_T1, _Res>\n-    { };\n-\n-  // - a function pointer type (binary)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n-    : binary_function<_T1, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, no qualifiers)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)()>\n-    : unary_function<_T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, no qualifiers)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n-    : binary_function<_T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const>\n-    : unary_function<const _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n-    : binary_function<const _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n-    : unary_function<volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n-    : binary_function<volatile _T1*, _T2, _Res>\n-    { };\n-\n-  // - a pointer to member function type (unary, const volatile)\n-  template<typename _Res, typename _T1>\n-    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n-    : unary_function<const volatile _T1*, _Res>\n-    { };\n-\n-  // - a pointer to member function type (binary, const volatile)\n-  template<typename _Res, typename _T1, typename _T2>\n-    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n-    : binary_function<const volatile _T1*, _T2, _Res>\n-    { };\n-\n-  /// reference_wrapper\n-  template<typename _Tp>\n-    class reference_wrapper\n-    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n-    {\n-      // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n-      // so turn it into a function pointer type.\n-      typedef typename _Function_to_function_pointer<_Tp>::type\n-        _M_func_type;\n-\n-      _Tp* _M_data;\n-    public:\n-      typedef _Tp type;\n-\n-      explicit\n-      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n-      { }\n-\n-      reference_wrapper(const reference_wrapper<_Tp>& __inref):\n-      _M_data(__inref._M_data)\n-      { }\n-\n-      reference_wrapper&\n-      operator=(const reference_wrapper<_Tp>& __inref)\n-      {\n-        _M_data = __inref._M_data;\n-        return *this;\n-      }\n-\n-      operator _Tp&() const\n-      { return this->get(); }\n-\n-      _Tp&\n-      get() const\n-      { return *_M_data; }\n-\n-      template<typename... _Args>\n-        typename result_of<_M_func_type(_Args...)>::type\n-        operator()(_Args&... __args) const\n-        {\n-\t  return __invoke(get(), __args...);\n-\t}\n-    };\n-\n-\n-  // Denotes a reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(_Tp& __t)\n-    { return reference_wrapper<_Tp>(__t); }\n-\n-  // Denotes a const reference should be taken to a variable.\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(const _Tp& __t)\n-    { return reference_wrapper<const _Tp>(__t); }\n-\n-  template<typename _Tp>\n-    inline reference_wrapper<_Tp>\n-    ref(reference_wrapper<_Tp> __t)\n-    { return ref(__t.get()); }\n-\n-  template<typename _Tp>\n-    inline reference_wrapper<const _Tp>\n-    cref(reference_wrapper<_Tp> __t)\n-    { return cref(__t.get()); }\n-\n-  template<typename _Tp, bool>\n-    struct _Mem_fn_const_or_non\n-    {\n-      typedef const _Tp& type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Mem_fn_const_or_non<_Tp, false>\n-    {\n-      typedef _Tp& type;\n-    };\n-\n-  /**\n-   * Derives from @c unary_function or @c binary_function, or perhaps\n-   * nothing, depending on the number of arguments provided. The\n-   * primary template is the basis case, which derives nothing.\n-   */\n-  template<typename _Res, typename... _ArgTypes> \n-    struct _Maybe_unary_or_binary_function { };\n-\n-  /// Derives from @c unary_function, as appropriate. \n-  template<typename _Res, typename _T1> \n-    struct _Maybe_unary_or_binary_function<_Res, _T1>\n-    : std::unary_function<_T1, _Res> { };\n-\n-  /// Derives from @c binary_function, as appropriate. \n-  template<typename _Res, typename _T1, typename _T2> \n-    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n-    : std::binary_function<_T1, _T2, _Res> { };\n-\n-  /// Implementation of @c mem_fn for member function pointers.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(_Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(_Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /// Implementation of @c mem_fn for const member function pointers.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n-    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(const _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(const _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /// Implementation of @c mem_fn for volatile member function pointers.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res\n-      operator()(volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res\n-      operator()(volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res\n-\toperator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-  /// Implementation of @c mem_fn for const volatile member function pointers.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(__args...); }\n-\n-      template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(__args...); }\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      _Res \n-      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(__args...); }\n-\n-      // Handle pointers\n-      _Res \n-      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(__args...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        { return _M_call(__object, &__object, __args...); }\n-\n-    private:\n-      _Functor __pmf;\n-    };\n-\n-\n-  template<typename _Res, typename _Class>\n-    class _Mem_fn<_Res _Class::*>\n-    {\n-      // This bit of genius is due to Peter Dimov, improved slightly by\n-      // Douglas Gregor.\n-      template<typename _Tp>\n-        _Res&\n-        _M_call(_Tp& __object, _Class *) const\n-        { return __object.*__pm; }\n-\n-      template<typename _Tp, typename _Up>\n-        _Res&\n-        _M_call(_Tp& __object, _Up * const *) const\n-        { return (*__object).*__pm; }\n-\n-      template<typename _Tp, typename _Up>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Up * const *) const\n-        { return (*__object).*__pm; }\n-\n-      template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Class *) const\n-        { return __object.*__pm; }\n-\n-      template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __ptr, const volatile void*) const\n-        { return (*__ptr).*__pm; }\n-\n-      template<typename _Tp> static _Tp& __get_ref();\n-\n-      template<typename _Tp>\n-        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n-      template<typename _Tp, typename _Up>\n-        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n-      template<typename _Tp, typename _Up>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n-      template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n-      template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n-\n-    public:\n-      template<typename _Tp>\n-        struct _Result_type\n-\t: _Mem_fn_const_or_non<_Res,\n-\t  (sizeof(__sfinae_types::__two)\n-\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n-        { };\n-\n-      template<typename _Signature>\n-        struct result;\n-\n-      template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp)>\n-\t: public _Result_type<_Tp> { };\n-\n-      template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp&)>\n-\t: public _Result_type<_Tp> { };\n-\n-      explicit\n-      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n-\n-      // Handle objects\n-      _Res&\n-      operator()(_Class& __object) const\n-      { return __object.*__pm; }\n-\n-      const _Res&\n-      operator()(const _Class& __object) const\n-      { return __object.*__pm; }\n-\n-      // Handle pointers\n-      _Res&\n-      operator()(_Class* __object) const\n-      { return __object->*__pm; }\n-\n-      const _Res&\n-      operator()(const _Class* __object) const\n-      { return __object->*__pm; }\n-\n-      // Handle smart pointers and derived\n-      template<typename _Tp>\n-        typename _Result_type<_Tp>::type\n-        operator()(_Tp& __unknown) const\n-        { return _M_call(__unknown, &__unknown); }\n-\n-    private:\n-      _Res _Class::*__pm;\n-    };\n-\n-  /**\n-   *  @brief Returns a function object that forwards to the member\n-   *  pointer @a pm.\n-   */\n-  template<typename _Tp, typename _Class>\n-    inline _Mem_fn<_Tp _Class::*>\n-    mem_fn(_Tp _Class::* __pm)\n-    {\n-      return _Mem_fn<_Tp _Class::*>(__pm);\n-    }\n-\n-  /**\n-   *  @brief Determines if the given type _Tp is a function object\n-   *  should be treated as a subexpression when evaluating calls to\n-   *  function objects returned by bind(). [TR1 3.6.1]\n-   */\n-  template<typename _Tp>\n-    struct is_bind_expression\n-    { static const bool value = false; };\n-\n-  template<typename _Tp>\n-    const bool is_bind_expression<_Tp>::value;\n-\n-  /**\n-   *  @brief Determines if the given type _Tp is a placeholder in a\n-   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n-   */\n-  template<typename _Tp>\n-    struct is_placeholder\n-    { static const int value = 0; };\n-\n-  template<typename _Tp>\n-    const int is_placeholder<_Tp>::value;\n-\n-  /// The type of placeholder objects defined by libstdc++.\n-  template<int _Num> struct _Placeholder { };\n-\n-  /** @namespace std::placeholders\n-   *  @brief ISO C++ 0x entities sub namespace for functional.\n-   *\n-   *  Define a large number of placeholders. There is no way to\n-   *  simplify this with variadic templates, because we're introducing\n-   *  unique names for each.\n-   */\n-  namespace placeholders \n-  { \n-    namespace \n-    {\n-      _Placeholder<1> _1;\n-      _Placeholder<2> _2;\n-      _Placeholder<3> _3;\n-      _Placeholder<4> _4;\n-      _Placeholder<5> _5;\n-      _Placeholder<6> _6;\n-      _Placeholder<7> _7;\n-      _Placeholder<8> _8;\n-      _Placeholder<9> _9;\n-      _Placeholder<10> _10;\n-      _Placeholder<11> _11;\n-      _Placeholder<12> _12;\n-      _Placeholder<13> _13;\n-      _Placeholder<14> _14;\n-      _Placeholder<15> _15;\n-      _Placeholder<16> _16;\n-      _Placeholder<17> _17;\n-      _Placeholder<18> _18;\n-      _Placeholder<19> _19;\n-      _Placeholder<20> _20;\n-      _Placeholder<21> _21;\n-      _Placeholder<22> _22;\n-      _Placeholder<23> _23;\n-      _Placeholder<24> _24;\n-      _Placeholder<25> _25;\n-      _Placeholder<26> _26;\n-      _Placeholder<27> _27;\n-      _Placeholder<28> _28;\n-      _Placeholder<29> _29;\n-    } \n-  }\n-\n-  /**\n-   *  Partial specialization of is_placeholder that provides the placeholder\n-   *  number for the placeholder objects defined by libstdc++.\n-   */\n-  template<int _Num>\n-    struct is_placeholder<_Placeholder<_Num> >\n-    { static const int value = _Num; };\n-\n-  template<int _Num>\n-    const int is_placeholder<_Placeholder<_Num> >::value;\n-\n-  /**\n-   * Stores a tuple of indices. Used by bind() to extract the elements\n-   * in a tuple. \n-   */\n-  template<int... _Indexes>\n-    struct _Index_tuple { };\n-\n-  /// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n-  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n-    struct _Build_index_tuple;\n- \n-  template<std::size_t _Num, int... _Indexes> \n-    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n-    : _Build_index_tuple<_Num - 1, \n-                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n-    {\n-    };\n-\n-  template<int... _Indexes>\n-    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n-    {\n-      typedef _Index_tuple<_Indexes...> __type;\n-    };\n-\n-  /** \n-   * Used by _Safe_tuple_element to indicate that there is no tuple\n-   * element at this position.\n-   */\n-  struct _No_tuple_element;\n-\n-  /**\n-   * Implementation helper for _Safe_tuple_element. This primary\n-   * template handles the case where it is safe to use @c\n-   * tuple_element.\n-   */\n-  template<int __i, typename _Tuple, bool _IsSafe>\n-    struct _Safe_tuple_element_impl\n-    : tuple_element<__i, _Tuple> { };\n-\n-  /**\n-   * Implementation helper for _Safe_tuple_element. This partial\n-   * specialization handles the case where it is not safe to use @c\n-   * tuple_element. We just return @c _No_tuple_element.\n-   */\n-  template<int __i, typename _Tuple>\n-    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n-    {\n-      typedef _No_tuple_element type;\n-    };\n-\n-  /**\n-   * Like tuple_element, but returns @c _No_tuple_element when\n-   * tuple_element would return an error.\n-   */\n- template<int __i, typename _Tuple>\n-   struct _Safe_tuple_element\n-   : _Safe_tuple_element_impl<__i, _Tuple, \n-                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n-   {\n-   };\n-\n-  /**\n-   *  Maps an argument to bind() into an actual argument to the bound\n-   *  function object [TR1 3.6.3/5]. Only the first parameter should\n-   *  be specified: the rest are used to determine among the various\n-   *  implementations. Note that, although this class is a function\n-   *  object, it isn't entirely normal because it takes only two\n-   *  parameters regardless of the number of parameters passed to the\n-   *  bind expression. The first parameter is the bound argument and\n-   *  the second parameter is a tuple containing references to the\n-   *  rest of the arguments.\n-   */\n-  template<typename _Arg,\n-           bool _IsBindExp = is_bind_expression<_Arg>::value,\n-           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n-    class _Mu;\n-\n-  /**\n-   *  If the argument is reference_wrapper<_Tp>, returns the\n-   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n-   */\n-  template<typename _Tp>\n-    class _Mu<reference_wrapper<_Tp>, false, false>\n-    {\n-    public:\n-      typedef _Tp& result_type;\n-\n-      /* Note: This won't actually work for const volatile\n-       * reference_wrappers, because reference_wrapper::get() is const\n-       * but not volatile-qualified. This might be a defect in the TR.\n-       */\n-      template<typename _CVRef, typename _Tuple>\n-        result_type\n-        operator()(_CVRef& __arg, const _Tuple&) const volatile\n-        { return __arg.get(); }\n-    };\n-\n-  /**\n-   *  If the argument is a bind expression, we invoke the underlying\n-   *  function object with the same cv-qualifiers as we are given and\n-   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, true, false>\n-    {\n-    public:\n-      template<typename _Signature> class result;\n-\n-      // Determine the result type when we pass the arguments along. This\n-      // involves passing along the cv-qualifiers placed on _Mu and\n-      // unwrapping the argument bundle.\n-      template<typename _CVMu, typename _CVArg, typename... _Args>\n-        class result<_CVMu(_CVArg, tuple<_Args...>)>\n-\t: public result_of<_CVArg(_Args...)> { };\n-\n-      template<typename _CVArg, typename... _Args>\n-        typename result_of<_CVArg(_Args...)>::type\n-        operator()(_CVArg& __arg,\n-\t\t   const tuple<_Args...>& __tuple) const volatile\n-        {\n-\t  // Construct an index tuple and forward to __call\n-\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n-\t    _Indexes;\n-\t  return this->__call(__arg, __tuple, _Indexes());\n-\t}\n-\n-    private:\n-      // Invokes the underlying function object __arg by unpacking all\n-      // of the arguments in the tuple. \n-      template<typename _CVArg, typename... _Args, int... _Indexes>\n-        typename result_of<_CVArg(_Args...)>::type\n-        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n-\t       const _Index_tuple<_Indexes...>&) const volatile\n-        {\n-\t  return __arg(_GLIBCXX_TR1 get<_Indexes>(__tuple)...);\n-\t}\n-    };\n-\n-  /**\n-   *  If the argument is a placeholder for the Nth argument, returns\n-   *  a reference to the Nth argument to the bind function object.\n-   *  [TR1 3.6.3/5 bullet 3]\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, false, true>\n-    {\n-    public:\n-      template<typename _Signature> class result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        class result<_CVMu(_CVArg, _Tuple)>\n-        {\n-\t  // Add a reference, if it hasn't already been done for us.\n-\t  // This allows us to be a little bit sloppy in constructing\n-\t  // the tuple that we pass to result_of<...>.\n-\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n-\t\t\t\t\t\t- 1), _Tuple>::type\n-\t    __base_type;\n-\n-\tpublic:\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-\t  typedef typename add_lvalue_reference<__base_type>::type type;\n-#else\n-\t  typedef typename add_reference<__base_type>::type type;\n-#endif\n-\t};\n-\n-      template<typename _Tuple>\n-        typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n-        {\n-\t  return ::std::_GLIBCXX_TR1 get<(is_placeholder<_Arg>::value\n-\t\t\t\t\t  - 1)>(__tuple);\n-\t}\n-    };\n-\n-  /**\n-   *  If the argument is just a value, returns a reference to that\n-   *  value. The cv-qualifiers on the reference are the same as the\n-   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n-   */\n-  template<typename _Arg>\n-    class _Mu<_Arg, false, false>\n-    {\n-    public:\n-      template<typename _Signature> struct result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        struct result<_CVMu(_CVArg, _Tuple)>\n-        {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-\t  typedef typename add_lvalue_reference<_CVArg>::type type;\n-#else\n-\t  typedef typename add_reference<_CVArg>::type type;\n-#endif\n-\t};\n-\n-      // Pick up the cv-qualifiers of the argument\n-      template<typename _CVArg, typename _Tuple>\n-        _CVArg&\n-        operator()(_CVArg& __arg, const _Tuple&) const volatile\n-        { return __arg; }\n-    };\n-\n-  /**\n-   *  Maps member pointers into instances of _Mem_fn but leaves all\n-   *  other function objects untouched. Used by tr1::bind(). The\n-   *  primary template handles the non--member-pointer case.\n-   */\n-  template<typename _Tp>\n-    struct _Maybe_wrap_member_pointer\n-    {\n-      typedef _Tp type;\n-      \n-      static const _Tp&\n-      __do_wrap(const _Tp& __x)\n-      { return __x; }\n-    };\n-\n-  /**\n-   *  Maps member pointers into instances of _Mem_fn but leaves all\n-   *  other function objects untouched. Used by tr1::bind(). This\n-   *  partial specialization handles the member pointer case.\n-   */\n-  template<typename _Tp, typename _Class>\n-    struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n-    {\n-      typedef _Mem_fn<_Tp _Class::*> type;\n-      \n-      static type\n-      __do_wrap(_Tp _Class::* __pm)\n-      { return type(__pm); }\n-    };\n-\n-  /// Type of the function object returned from bind().\n-  template<typename _Signature>\n-    struct _Bind;\n-\n-   template<typename _Functor, typename... _Bound_args>\n-    class _Bind<_Functor(_Bound_args...)>\n-    : public _Weak_result_type<_Functor>\n-    {\n-      typedef _Bind __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n-        _Bound_indexes;\n-\n-      _Functor _M_f;\n-      tuple<_Bound_args...> _M_bound_args;\n-\n-      // Call unqualified\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   const _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const _Bound_args, tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (volatile _Bound_args, tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args, int... _Indexes>\n-        typename result_of<\n-                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                                    (const volatile _Bound_args, \n-                                     tuple<_Args...>)\n-                                  >::type...)>::type\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-     public:\n-      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n-        : _M_f(__f), _M_bound_args(__bound_args...) { }\n-\n-      // Call unqualified\n-      template<typename... _Args>\n-        typename result_of<\n-                   _Functor(typename result_of<_Mu<_Bound_args> \n-                            (_Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args)\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const\n-      template<typename... _Args>\n-        typename result_of<\n-                   const _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const _Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) const\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-\n-      // Call as volatile\n-      template<typename... _Args>\n-        typename result_of<\n-                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-\n-      // Call as const volatile\n-      template<typename... _Args>\n-        typename result_of<\n-                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n-                            (const volatile _Bound_args, \n-                             tuple<_Args...>)>::type...)\n-                 >::type\n-        operator()(_Args&... __args) const volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-    };\n-\n-  /// Type of the function object returned from bind<R>().\n-  template<typename _Result, typename _Signature>\n-    struct _Bind_result;\n-\n-  template<typename _Result, typename _Functor, typename... _Bound_args>\n-    class _Bind_result<_Result, _Functor(_Bound_args...)>\n-    {\n-      typedef _Bind_result __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n-        _Bound_indexes;\n-\n-      _Functor _M_f;\n-      tuple<_Bound_args...> _M_bound_args;\n-\n-      // Call unqualified\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args, int... _Indexes>\n-        _Result\n-        __call(const tuple<_Args...>& __args, \n-               _Index_tuple<_Indexes...>) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (_GLIBCXX_TR1 get<_Indexes>(_M_bound_args), __args)...);\n-        }\n-\n-    public:\n-      typedef _Result result_type;\n-\n-      explicit\n-      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n-      : _M_f(__f), _M_bound_args(__bound_args...) { }\n-\n-      // Call unqualified\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args)\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) const\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as volatile\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-\n-      // Call as const volatile\n-      template<typename... _Args>\n-        result_type\n-        operator()(_Args&... __args) const volatile\n-        {\n-          return this->__call(_GLIBCXX_TR1 tie(__args...), _Bound_indexes());\n-        }\n-    };\n-\n-  /// Class template _Bind is always a bind expression.\n-  template<typename _Signature>\n-    struct is_bind_expression<_Bind<_Signature> >\n-    { static const bool value = true; };\n-\n-  template<typename _Signature>\n-    const bool is_bind_expression<_Bind<_Signature> >::value;\n-\n-  /// Class template _Bind_result is always a bind expression.\n-  template<typename _Result, typename _Signature>\n-    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n-    { static const bool value = true; };\n-\n-  template<typename _Result, typename _Signature>\n-    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n-\n-  /// bind\n-  template<typename _Functor, typename... _ArgTypes>\n-    inline\n-    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n-    {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n-    } \n-\n-  template<typename _Result, typename _Functor, typename... _ArgTypes>\n-    inline\n-    _Bind_result<_Result,\n-\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n-                            (_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n-    {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n-\t__result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n-    }\n-\n-  /**\n-   *  @brief Exception class thrown when class template function's\n-   *  operator() is called with an empty target.\n-   *  @ingroup exceptions\n-   */\n-  class bad_function_call : public std::exception { };\n-\n-  /**\n-   *  The integral constant expression 0 can be converted into a\n-   *  pointer to this type. It is used by the function template to\n-   *  accept NULL pointers.\n-   */\n-  struct _M_clear_type;\n-\n-  /**\n-   *  Trait identifying \"location-invariant\" types, meaning that the\n-   *  address of the object (or any of its members) will not escape.\n-   *  Also implies a trivial copy constructor and assignment operator.\n-   */\n-  template<typename _Tp>\n-    struct __is_location_invariant\n-    : integral_constant<bool,\n-                        (is_pointer<_Tp>::value\n-                         || is_member_pointer<_Tp>::value)>\n-    {\n-    };\n-\n-  class _Undefined_class;\n-\n-  union _Nocopy_types\n-  {\n-    void*       _M_object;\n-    const void* _M_const_object;\n-    void (*_M_function_pointer)();\n-    void (_Undefined_class::*_M_member_pointer)();\n-  };\n-\n-  union _Any_data\n-  {\n-    void*       _M_access()       { return &_M_pod_data[0]; }\n-    const void* _M_access() const { return &_M_pod_data[0]; }\n-\n-    template<typename _Tp>\n-      _Tp&\n-      _M_access()\n-      { return *static_cast<_Tp*>(_M_access()); }\n-\n-    template<typename _Tp>\n-      const _Tp&\n-      _M_access() const\n-      { return *static_cast<const _Tp*>(_M_access()); }\n-\n-    _Nocopy_types _M_unused;\n-    char _M_pod_data[sizeof(_Nocopy_types)];\n-  };\n-\n-  enum _Manager_operation\n-  {\n-    __get_type_info,\n-    __get_functor_ptr,\n-    __clone_functor,\n-    __destroy_functor\n-  };\n-\n-  // Simple type wrapper that helps avoid annoying const problems\n-  // when casting between void pointers and pointers-to-pointers.\n-  template<typename _Tp>\n-    struct _Simple_type_wrapper\n-    {\n-      _Simple_type_wrapper(_Tp __value) : __value(__value) { }\n-\n-      _Tp __value;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n-    : __is_location_invariant<_Tp>\n-    {\n-    };\n-\n-  // Converts a reference to a function object into a callable\n-  // function object.\n-  template<typename _Functor>\n-    inline _Functor&\n-    __callable_functor(_Functor& __f)\n-    { return __f; }\n-\n-  template<typename _Member, typename _Class>\n-    inline _Mem_fn<_Member _Class::*>\n-    __callable_functor(_Member _Class::* &__p)\n-    { return mem_fn(__p); }\n-\n-  template<typename _Member, typename _Class>\n-    inline _Mem_fn<_Member _Class::*>\n-    __callable_functor(_Member _Class::* const &__p)\n-    { return mem_fn(__p); }\n-\n-  template<typename _Signature>\n-    class function;\n-\n-  /// Base class of all polymorphic function object wrappers.\n-  class _Function_base\n-  {\n-  public:\n-    static const std::size_t _M_max_size = sizeof(_Nocopy_types);\n-    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n-\n-    template<typename _Functor>\n-      class _Base_manager\n-      {\n-      protected:\n-\tstatic const bool __stored_locally =\n-        (__is_location_invariant<_Functor>::value\n-         && sizeof(_Functor) <= _M_max_size\n-         && __alignof__(_Functor) <= _M_max_align\n-         && (_M_max_align % __alignof__(_Functor) == 0));\n-\t\n-\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n-\n-\t// Retrieve a pointer to the function object\n-\tstatic _Functor*\n-\t_M_get_pointer(const _Any_data& __source)\n-\t{\n-\t  const _Functor* __ptr =\n-\t    __stored_locally? &__source._M_access<_Functor>()\n-\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n-\t  return const_cast<_Functor*>(__ptr);\n-\t}\n-\n-\t// Clone a location-invariant function object that fits within\n-\t// an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n-\t{\n-\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n-\t}\n-\n-\t// Clone a function object that is not location-invariant or\n-\t// that cannot fit into an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n-\t{\n-\t  __dest._M_access<_Functor*>() =\n-\t    new _Functor(*__source._M_access<_Functor*>());\n-\t}\n-\n-\t// Destroying a location-invariant object may still require\n-\t// destruction.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, true_type)\n-\t{\n-\t  __victim._M_access<_Functor>().~_Functor();\n-\t}\n-\t\n-\t// Destroying an object located on the heap.\n-\tstatic void\n-\t_M_destroy(_Any_data& __victim, false_type)\n-\t{\n-\t  delete __victim._M_access<_Functor*>();\n-\t}\n-\t\n-      public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-#ifdef __GXX_RTTI\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-#endif\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n-\t      break;\n-\t      \n-\t    case __clone_functor:\n-\t      _M_clone(__dest, __source, _Local_storage());\n-\t      break;\n-\n-\t    case __destroy_functor:\n-\t      _M_destroy(__dest, _Local_storage());\n-\t      break;\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n-\t{ _M_init_functor(__functor, __f, _Local_storage()); }\n-\t\n-\ttemplate<typename _Signature>\n-\t  static bool\n-\t  _M_not_empty_function(const function<_Signature>& __f)\n-          { return static_cast<bool>(__f); }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(const _Tp*& __fp)\n-\t  { return __fp; }\n-\n-\ttemplate<typename _Class, typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n-\t  { return __mp; }\n-\n-\ttemplate<typename _Tp>\n-\t  static bool\n-\t  _M_not_empty_function(const _Tp&)\n-\t  { return true; }\n-\n-      private:\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n-\t{ new (__functor._M_access()) _Functor(__f); }\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n-\t{ __functor._M_access<_Functor*>() = new _Functor(__f); }\n-      };\n-\n-    template<typename _Functor>\n-      class _Ref_manager : public _Base_manager<_Functor*>\n-      {\n-\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n-\n-    public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-#ifdef __GXX_RTTI\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-#endif\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n-\t      return is_const<_Functor>::value;\n-\t      break;\n-\t      \n-\t    default:\n-\t      _Base::_M_manager(__dest, __source, __op);\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n-\t{\n-\t  // TBD: Use address_of function instead.\n-\t  _Base::_M_init_functor(__functor, &__f.get());\n-\t}\n-      };\n-\n-    _Function_base() : _M_manager(0) { }\n-    \n-    ~_Function_base()\n-    {\n-      if (_M_manager)\n-\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n-    }\n-\n-\n-    bool _M_empty() const { return !_M_manager; }\n-\n-    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n-                                  _Manager_operation);\n-\n-    _Any_data     _M_functor;\n-    _Manager_type _M_manager;\n-  };\n-\n-  template<typename _Signature, typename _Functor>\n-    class _Function_handler;\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-    public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return (*_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Functor>\n-    : public _Function_base::_Base_manager<_Functor>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        (*_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return \n-          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename _Res, \n-           typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n-    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    {\n-      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-        _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        return _GLIBCXX_TR1\n-\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n-      }\n-    };\n-\n-  template<typename _Class, typename _Member, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-    : public _Function_base::_Base_manager<\n-                 _Simple_type_wrapper< _Member _Class::* > >\n-    {\n-      typedef _Member _Class::* _Functor;\n-      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n-      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n-\n-     public:\n-      static bool\n-      _M_manager(_Any_data& __dest, const _Any_data& __source,\n-                 _Manager_operation __op)\n-      {\n-        switch (__op)\n-\t  {\n-#ifdef __GXX_RTTI\n-\t  case __get_type_info:\n-\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t    break;\n-#endif\t    \n-\t  case __get_functor_ptr:\n-\t    __dest._M_access<_Functor*>() =\n-\t      &_Base::_M_get_pointer(__source)->__value;\n-\t    break;\n-\t    \n-\t  default:\n-\t    _Base::_M_manager(__dest, __source, __op);\n-\t  }\n-        return false;\n-      }\n-\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n-      {\n-        _GLIBCXX_TR1\n-\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n-      }\n-    };\n-\n-  /// class function\n-  template<typename _Res, typename... _ArgTypes>\n-    class function<_Res(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n-      private _Function_base\n-    {\n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-      /// This class is used to implement the safe_bool idiom.\n-      struct _Hidden_type\n-      {\n-\t_Hidden_type* _M_bool;\n-      };\n-\n-      /// This typedef is used to implement the safe_bool idiom.\n-      typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n-#endif\n-\n-      typedef _Res _Signature_type(_ArgTypes...);\n-      \n-      struct _Useless { };\n-      \n-    public:\n-      typedef _Res result_type;\n-      \n-      // [3.7.2.1] construct/copy/destroy\n-      \n-      /**\n-       *  @brief Default construct creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function() : _Function_base() { }\n-      \n-      /**\n-       *  @brief Default construct creates an empty function call wrapper.\n-       *  @post @c !(bool)*this\n-       */\n-      function(_M_clear_type*) : _Function_base() { }\n-      \n-      /**\n-       *  @brief %Function copy constructor.\n-       *  @param x A %function object with identical call signature.\n-       *  @pre @c (bool)*this == (bool)x\n-       *\n-       *  The newly-created %function contains a copy of the target of @a\n-       *  x (if it has one).\n-       */\n-      function(const function& __x);\n-      \n-      /**\n-       *  @brief Builds a %function that targets a copy of the incoming\n-       *  function object.\n-       *  @param f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *\n-       *  The newly-created %function object will target a copy of @a\n-       *  f. If @a f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  f.get(). If @a f is a NULL function pointer or NULL\n-       *  pointer-to-member, the newly-created object will be empty.\n-       *\n-       *  If @a f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor>\n-        function(_Functor __f,\n-                 typename __gnu_cxx::__enable_if<\n-                           !is_integral<_Functor>::value, _Useless>::__type\n-                   = _Useless());\n-\n-      /**\n-       *  @brief %Function assignment operator.\n-       *  @param x A %function with identical call signature.\n-       *  @post @c (bool)*this == (bool)x\n-       *  @returns @c *this\n-       *\n-       *  The target of @a x is copied to @c *this. If @a x has no\n-       *  target, then @c *this will be empty.\n-       *\n-       *  If @a x targets a function pointer or a reference to a function\n-       *  object, then this operation will not throw an exception.\n-       */\n-      function&\n-      operator=(const function& __x)\n-      {\n-        function(__x).swap(*this);\n-        return *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to zero.\n-       *  @post @c !(bool)*this\n-       *  @returns @c *this\n-       *\n-       *  The target of @a *this is deallocated, leaving it empty.\n-       */\n-      function&\n-      operator=(_M_clear_type*)\n-      {\n-        if (_M_manager)\n-\t  {\n-\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n-\t    _M_manager = 0;\n-\t    _M_invoker = 0;\n-\t  }\n-        return *this;\n-      }\n-\n-      /**\n-       *  @brief %Function assignment to a new target.\n-       *  @param f A %function object that is callable with parameters of\n-       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-       *  to @c Res.\n-       *  @return @c *this\n-       *\n-       *  This  %function object wrapper will target a copy of @a\n-       *  f. If @a f is @c reference_wrapper<F>, then this function\n-       *  object will contain a reference to the function object @c\n-       *  f.get(). If @a f is a NULL function pointer or NULL\n-       *  pointer-to-member, @c this object will be empty.\n-       *\n-       *  If @a f is a non-NULL function pointer or an object of type @c\n-       *  reference_wrapper<F>, this function will not throw.\n-       */\n-      template<typename _Functor>\n-        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n-\t                                function&>::__type\n-\toperator=(_Functor __f)\n-\t{\n-\t  function(__f).swap(*this);\n-\t  return *this;\n-\t}\n-\n-      // [3.7.2.2] function modifiers\n-      \n-      /**\n-       *  @brief Swap the targets of two %function objects.\n-       *  @param f A %function with identical call signature.\n-       *\n-       *  Swap the targets of @c this function object and @a f. This\n-       *  function will not throw an exception.\n-       */\n-      void swap(function& __x)\n-      {\n-\t_Any_data __old_functor = _M_functor;\n-\t_M_functor = __x._M_functor;\n-\t__x._M_functor = __old_functor;\n-\t_Manager_type __old_manager = _M_manager;\n-\t_M_manager = __x._M_manager;\n-\t__x._M_manager = __old_manager;\n-\t_Invoker_type __old_invoker = _M_invoker;\n-\t_M_invoker = __x._M_invoker;\n-\t__x._M_invoker = __old_invoker;\n-      }\n-      \n-      // [3.7.2.3] function capacity\n-\n-      /**\n-       *  @brief Determine if the %function wrapper has a target.\n-       *\n-       *  @return @c true when this %function object contains a target,\n-       *  or @c false when it is empty.\n-       *\n-       *  This function will not throw an exception.\n-       */\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      explicit operator bool() const\n-      { return !_M_empty(); }\n-#else\n-      operator _Safe_bool() const\n-      {\n-        if (_M_empty())\n-\t  return 0;\n-\telse\n-\t  return &_Hidden_type::_M_bool;\n-      }\n-#endif\n-\n-      // [3.7.2.4] function invocation\n-\n-      /**\n-       *  @brief Invokes the function targeted by @c *this.\n-       *  @returns the result of the target.\n-       *  @throws bad_function_call when @c !(bool)*this\n-       *\n-       *  The function call operator invokes the target function object\n-       *  stored by @c this.\n-       */\n-      _Res operator()(_ArgTypes... __args) const;\n-\n-#ifdef __GXX_RTTI\n-      // [3.7.2.5] function target access\n-      /**\n-       *  @brief Determine the type of the target of this function object\n-       *  wrapper.\n-       *\n-       *  @returns the type identifier of the target function object, or\n-       *  @c typeid(void) if @c !(bool)*this.\n-       *\n-       *  This function will not throw an exception.\n-       */\n-      const type_info& target_type() const;\n-      \n-      /**\n-       *  @brief Access the stored target function object.\n-       *\n-       *  @return Returns a pointer to the stored target function object,\n-       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n-       *  pointer.\n-       *\n-       * This function will not throw an exception.\n-       */\n-      template<typename _Functor>       _Functor* target();\n-      \n-      /// @overload\n-      template<typename _Functor> const _Functor* target() const;\n-#endif\n-\n-    private:\n-      // [3.7.2.6] undefined operators\n-      template<typename _Function>\n-\tvoid operator==(const function<_Function>&) const;\n-      template<typename _Function>\n-\tvoid operator!=(const function<_Function>&) const;\n-\n-      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n-      _Invoker_type _M_invoker;\n-  };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    function<_Res(_ArgTypes...)>::\n-    function(const function& __x)\n-    : _Function_base()\n-    {\n-      if (static_cast<bool>(__x))\n-\t{\n-\t  _M_invoker = __x._M_invoker;\n-\t  _M_manager = __x._M_manager;\n-\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n-\t}\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      function<_Res(_ArgTypes...)>::\n-      function(_Functor __f,\n-\t       typename __gnu_cxx::__enable_if<\n-                       !is_integral<_Functor>::value, _Useless>::__type)\n-      : _Function_base()\n-      {\n-\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n-\n-\tif (_My_handler::_M_not_empty_function(__f))\n-\t  {\n-\t    _M_invoker = &_My_handler::_M_invoke;\n-\t    _M_manager = &_My_handler::_M_manager;\n-\t    _My_handler::_M_init_functor(_M_functor, __f);\n-\t  }\n-      }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    _Res\n-    function<_Res(_ArgTypes...)>::\n-    operator()(_ArgTypes... __args) const\n-    {\n-      if (_M_empty())\n-        {\n-#if __EXCEPTIONS\n-          throw bad_function_call();\n-#else\n-          __builtin_abort();\n-#endif\n-        }\n-      return _M_invoker(_M_functor, __args...);\n-    }\n-\n-#ifdef __GXX_RTTI\n-  template<typename _Res, typename... _ArgTypes>\n-    const type_info&\n-    function<_Res(_ArgTypes...)>::\n-    target_type() const\n-    {\n-      if (_M_manager)\n-        {\n-          _Any_data __typeinfo_result;\n-          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-          return *__typeinfo_result._M_access<const type_info*>();\n-        }\n-      else\n-\treturn typeid(void);\n-    }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target()\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-\t\t&& !is_const<_Functor>::value)\n-\t      return 0;\n-\t    else\n-\t      return __ptr._M_access<_Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    template<typename _Functor>\n-      const _Functor*\n-      function<_Res(_ArgTypes...)>::\n-      target() const\n-      {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-\t    return __ptr._M_access<const _Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n-      }\n-#endif\n-\n-  // [3.7.2.7] null pointer comparisons\n-\n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c true if the wrapper has no target, @c false otherwise\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator==(const function<_Signature>& __f, _M_clear_type*)\n-    { return !static_cast<bool>(__f); }\n-\n-  /// @overload\n-  template<typename _Signature>\n-    inline bool\n-    operator==(_M_clear_type*, const function<_Signature>& __f)\n-    { return !static_cast<bool>(__f); }\n-\n-  /**\n-   *  @brief Compares a polymorphic function object wrapper against 0\n-   *  (the NULL pointer).\n-   *  @returns @c false if the wrapper has no target, @c true otherwise\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline bool\n-    operator!=(const function<_Signature>& __f, _M_clear_type*)\n-    { return static_cast<bool>(__f); }\n-\n-  /// @overload\n-  template<typename _Signature>\n-    inline bool\n-    operator!=(_M_clear_type*, const function<_Signature>& __f)\n-    { return static_cast<bool>(__f); }\n-\n-  // [3.7.2.8] specialized algorithms\n-\n-  /**\n-   *  @brief Swap the targets of two polymorphic function object wrappers.\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  template<typename _Signature>\n-    inline void\n-    swap(function<_Signature>& __x, function<_Signature>& __y)\n-    { __x.swap(__y); }\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n-}"}, {"sha": "89a22542ba072dee517b488bc70d0f6e5b334e0a", "filename": "libstdc++-v3/testsuite/20_util/function/1.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F1.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,94 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Operations on empty function<> objects\n+void test01()\n+{\n+  using std::function;\n+  using std::bad_function_call;\n+\n+  // Default-construction\n+  function<int(float)> f1;\n+  VERIFY( ((bool)f1 == false) );\n+  VERIFY( !f1 );\n+  VERIFY( f1 == 0 );\n+  VERIFY( 0 == f1 );\n+  VERIFY( !(f1 != 0) );\n+  VERIFY( !(0 != f1) );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( !f2 );\n+\n+  // Construct with NULL pointer\n+  function<int(float)> f3(0);\n+  VERIFY( !f3 );\n+\n+  // Assignment\n+  f1 = f2;\n+  VERIFY( !f1);\n+\n+  // Assignment to NULL pointer\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  swap(f1, f2);\n+  VERIFY( !f1 );\n+  VERIFY( !f2 );\n+\n+  // Invocation should throw bad_function_call\n+  bool thrown = false;\n+  try\n+    {\n+      f1(3.14159f);\n+      VERIFY( false );\n+    }\n+  catch (bad_function_call)\n+    {\n+      thrown = true;\n+    }\n+  VERIFY( thrown );\n+\n+  // target_type returns typeid(void)\n+  VERIFY( f1.target_type() == typeid(void) );\n+\n+  // target() always returns a NULL pointer\n+  VERIFY( f1.target<int (*)(float)>() == 0);\n+\n+  // Check const version\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( f1c.target<int (*)(float)>() == 0 );\n+  VERIFY( !f1c );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f2866d08546355d3e4e5a8583e735043bc2cb108", "filename": "libstdc++-v3/testsuite/20_util/function/2.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F2.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function pointers into function<> wrappers\n+void test02()\n+{\n+  using std::function;\n+\n+  function<int(float)> f1(truncate_float);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = truncate_float;\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(int(*)(float)) == f1.target_type() );\n+  VERIFY( f2.target<int(*)(float)>() != 0 );\n+  VERIFY( *f2.target<int(*)(float)>() == &truncate_float );\n+  VERIFY( f1c.target<int(*)(float)>() != 0 );\n+  VERIFY( *f1c.target<int(*)(float)>() == &truncate_float );\n+}\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}"}, {"sha": "7f9239015e599ac9168566dd96e50b2e2d731119", "filename": "libstdc++-v3/testsuite/20_util/function/3.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F3.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put nearly-matching function pointers into function<> wrappers\n+void test03()\n+{\n+  using std::function;\n+\n+  function<int(float)> f1(truncate_double);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = truncate_double;\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(long(*)(double)) == f1.target_type() );\n+  VERIFY( f2.target<long(*)(double)>() != 0 );\n+  VERIFY( *f2.target<long(*)(double)>() == &truncate_double );\n+  VERIFY( f1c.target<long(*)(double)>() != 0 );\n+  VERIFY( *f1c.target<long(*)(double)>() == &truncate_double );\n+}\n+\n+int main()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "824d17f5928de7f11e5f746b24b308f02d8889ac", "filename": "libstdc++-v3/testsuite/20_util/function/4.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F4.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function objects into function<> wrappers\n+void test04()\n+{\n+  using std::function;\n+\n+  do_truncate_float_t truncate_float;\n+\n+  function<int(float)> f1(truncate_float);\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Copy-construction\n+  function<int(float)> f2(f1);\n+  VERIFY( f2 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // Assignment to zero\n+  f1 = 0;\n+  VERIFY( !f1 );\n+\n+  // Swap\n+  f1.swap(f2);\n+  VERIFY( f1 );\n+  VERIFY( !f2 );\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // Assignment from a function pointer\n+  f2 = do_truncate_float_t();\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(do_truncate_float_t) == f1.target_type() );\n+  VERIFY( f2.target<do_truncate_float_t>() != 0 );\n+  VERIFY( f1c.target<do_truncate_float_t>() != 0 );\n+}\n+\n+int main()\n+{\n+  test04();\n+\n+  VERIFY( do_truncate_double_t::live_objects == 0 );\n+  VERIFY( do_truncate_float_t::live_objects == 0 );\n+\n+  return 0;\n+}"}, {"sha": "b86b198f031f740e7662ee5c02ff97cd4c68b32d", "filename": "libstdc++-v3/testsuite/20_util/function/5.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F5.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,107 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put member pointers into function<> wrappers\n+void test05()\n+{\n+  using std::function;\n+\n+  X x;\n+  x.bar = 17;\n+\n+  function<int(X&)> frm(&X::bar);\n+  VERIFY( frm );\n+  VERIFY( frm(x) == 17 );\n+  VERIFY( typeid(int X::*) == frm.target_type() );\n+  VERIFY( *frm.target<int X::*>() == &X::bar );\n+\n+  function<int(X&)> fr(&X::foo);\n+  VERIFY( fr );\n+  VERIFY( fr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == fr.target_type() );\n+  VERIFY( *fr.target<int (X::*)()>() == &X::foo );\n+\n+  function<int(const X&)> frc(&X::foo_c);\n+  VERIFY( frc );\n+  VERIFY( frc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == frc.target_type() );\n+  VERIFY( *frc.target<int (X::*)() const >() == &X::foo_c );\n+\n+  function<int(volatile X&)> frv(&X::foo_v);\n+  VERIFY( frv );\n+  VERIFY( frv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == frv.target_type() );\n+  VERIFY( *frv.target<int (X::*)() volatile >() == &X::foo_v );\n+  VERIFY( frv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> frcv(&X::foo_cv);\n+  VERIFY( frcv );\n+  VERIFY( frcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == frcv.target_type() );\n+  VERIFY( *frcv.target<int (X::*)() const volatile >() == &X::foo_cv );\n+  VERIFY( frcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X*)> grm(&X::bar);\n+  VERIFY( grm );\n+  VERIFY( grm(&x) == 17 );\n+  VERIFY( typeid(int X::*) == grm.target_type() );\n+  VERIFY( *grm.target<int X::*>() == &X::bar );\n+\n+  function<int(X*)> gr(&X::foo);\n+  VERIFY( gr );\n+  VERIFY( gr(&x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == gr.target_type() );\n+  VERIFY( *gr.target<int (X::*)()>() == &X::foo );\n+\n+  function<int(const X*)> grc(&X::foo_c);\n+  VERIFY( grc );\n+  VERIFY( grc(&x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == grc.target_type() );\n+  VERIFY( *grc.target<int (X::*)() const >() == &X::foo_c );\n+\n+  function<int(volatile X*)> grv(&X::foo_v);\n+  VERIFY( grv );\n+  VERIFY( grv(&x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == grv.target_type() );\n+  VERIFY( *grv.target<int (X::*)() volatile >() == &X::foo_v );\n+  VERIFY( grv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X*)> grcv(&X::foo_cv);\n+  VERIFY( grcv );\n+  VERIFY( grcv(&x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == grcv.target_type() );\n+  VERIFY( *grcv.target<int (X::*)() const volatile >() == &X::foo_cv );\n+  VERIFY( grcv.target<int (X::*)() const>() == 0 );\n+}\n+\n+int main()\n+{\n+  test05();\n+  return 0;\n+}"}, {"sha": "47d2c1f9bd72e3176dd1f479c069d6b20dbd9d19", "filename": "libstdc++-v3/testsuite/20_util/function/6.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct secret {};\n+\n+struct noncopyable_function_object_type\n+{\n+  noncopyable_function_object_type(secret) {}\n+\n+  int operator()() const { return 42; }\n+  int operator()()       { return 17; }\n+\n+ private:\n+  noncopyable_function_object_type();\n+  noncopyable_function_object_type(const noncopyable_function_object_type&);\n+  void operator=(const noncopyable_function_object_type&);\n+};\n+\n+// Put reference_wrappers into function<> wrappers\n+void test06()\n+{\n+  using std::function;\n+  using std::ref;\n+  using std::cref;\n+\n+  secret password;\n+  noncopyable_function_object_type x(password);\n+\n+  function<int()> f(ref(x));\n+  VERIFY( f );\n+  VERIFY( f() == 17 );\n+  VERIFY( f.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( f.target<noncopyable_function_object_type>() == &x );\n+\n+  function<int()> g = f;\n+  VERIFY( g );\n+  VERIFY( g() == 17 );\n+  VERIFY( g.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( g.target<noncopyable_function_object_type>() == &x );\n+\n+  function<int()> h = cref(x);\n+  VERIFY( h );\n+  VERIFY( h() == 42 );\n+  VERIFY( h.target_type() == typeid(noncopyable_function_object_type) );\n+  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n+  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n+\n+  const function<int()>& hc = h;\n+  VERIFY( h.target<noncopyable_function_object_type>() == 0 );\n+  VERIFY( hc.target<noncopyable_function_object_type>() == &x );\n+}\n+\n+int main()\n+{\n+  test06();\n+  return 0;\n+}"}, {"sha": "3b922116b73a7f937f792fc14d135bb75c767b0f", "filename": "libstdc++-v3/testsuite/20_util/function/7.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put reference_wrappers to function pointers into function<> wrappers\n+void test07()\n+{\n+  using std::function;\n+  using std::ref;\n+  using std::cref;\n+\n+  int (*fptr)(float) = truncate_float;\n+\n+  function<int(float)> f1(ref(fptr));\n+  VERIFY( f1 );\n+  VERIFY( !!f1 );\n+  VERIFY( !(f1 == 0) );\n+  VERIFY( !(0 == f1) );\n+  VERIFY( f1 != 0 );\n+  VERIFY( 0 != f1 );\n+\n+  // Invocation\n+  VERIFY( f1(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f1c = f1;\n+  VERIFY( typeid(int(*)(float)) == f1.target_type() );\n+  VERIFY( f1.target<int(*)(float)>() != 0 );\n+  VERIFY( f1.target<int(*)(float)>() == &fptr );\n+  VERIFY( f1c.target<int(*)(float)>() != 0 );\n+  VERIFY( f1c.target<int(*)(float)>() == &fptr );\n+\n+  function<int(float)> f2(cref(fptr));\n+  VERIFY( f2 );\n+  VERIFY( !!f2 );\n+  VERIFY( !(f2 == 0) );\n+  VERIFY( !(0 == f2) );\n+  VERIFY( f2 != 0 );\n+  VERIFY( 0 != f2 );\n+\n+  // Invocation\n+  VERIFY( f2(3.1f) == 3 );\n+\n+  // target_type and target() functions\n+  const function<int(float)>& f2c = f2;\n+  VERIFY( typeid(int(*)(float)) == f2.target_type() );\n+  VERIFY( f2.target<int(*)(float)>() == 0 );\n+  VERIFY( f2.target<int(* const)(float)>() == &fptr );\n+  VERIFY( f2c.target<int(*)(float)>() != 0 );\n+  VERIFY( f2c.target<int(*)(float)>() == &fptr );\n+}\n+\n+int main()\n+{\n+  test07();\n+  return 0;\n+}"}, {"sha": "620f616105cbc712704ba53ce89da4271ed161f9", "filename": "libstdc++-v3/testsuite/20_util/function/8.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,148 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put reference_wrappers to member pointers\n+void test08()\n+{\n+  using std::function;\n+  using std::ref;\n+  using std::cref;\n+\n+  int X::* X_bar = &X::bar;\n+  int (X::* X_foo)() = &X::foo;\n+  int (X::* X_foo_c)() const = &X::foo_c;\n+  int (X::* X_foo_v)() volatile = &X::foo_v;\n+  int (X::* X_foo_cv)() const volatile = &X::foo_cv;\n+\n+  X x;\n+  x.bar = 17;\n+\n+  function<int(X&)> frm(ref(X_bar));\n+  VERIFY( frm );\n+  VERIFY( frm(x) == 17 );\n+  VERIFY( typeid(int X::*) == frm.target_type() );\n+  VERIFY( frm.target<int X::*>() == &X_bar );\n+\n+  function<int(X&)> fr(ref(X_foo));\n+  VERIFY( fr );\n+  VERIFY( fr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == fr.target_type() );\n+  VERIFY( fr.target<int (X::*)()>() == &X_foo );\n+\n+  function<int(const X&)> frc(ref(X_foo_c));\n+  VERIFY( frc );\n+  VERIFY( frc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == frc.target_type() );\n+  VERIFY( frc.target<int (X::*)() const >() == &X_foo_c );\n+\n+  function<int(volatile X&)> frv(ref(X_foo_v));\n+  VERIFY( frv );\n+  VERIFY( frv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == frv.target_type() );\n+  VERIFY( *frv.target<int (X::*)() volatile >() == X_foo_v );\n+  VERIFY( frv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> frcv(ref(X_foo_cv));\n+  VERIFY( frcv );\n+  VERIFY( frcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == frcv.target_type() );\n+  VERIFY( *frcv.target<int (X::*)() const volatile >() == X_foo_cv );\n+  VERIFY( frcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X*)> grm(ref(X_bar));\n+  VERIFY( grm );\n+  VERIFY( grm(&x) == 17 );\n+  VERIFY( typeid(int X::*) == grm.target_type() );\n+  VERIFY( *grm.target<int X::*>() == X_bar );\n+\n+  function<int(X*)> gr(ref(X_foo));\n+  VERIFY( gr );\n+  VERIFY( gr(&x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == gr.target_type() );\n+  VERIFY( *gr.target<int (X::*)()>() == X_foo );\n+\n+  function<int(const X*)> grc(ref(X_foo_c));\n+  VERIFY( grc );\n+  VERIFY( grc(&x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == grc.target_type() );\n+  VERIFY( *grc.target<int (X::*)() const >() == X_foo_c );\n+\n+  function<int(volatile X*)> grv(ref(X_foo_v));\n+  VERIFY( grv );\n+  VERIFY( grv(&x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == grv.target_type() );\n+  VERIFY( *grv.target<int (X::*)() volatile >() == X_foo_v );\n+  VERIFY( grv.target<int (X::*)() const volatile>() == 0 );\n+\n+  function<int(const volatile X*)> grcv(ref(X_foo_cv));\n+  VERIFY( grcv );\n+  VERIFY( grcv(&x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == grcv.target_type() );\n+  VERIFY( *grcv.target<int (X::*)() const volatile >() == X_foo_cv );\n+  VERIFY( grcv.target<int (X::*)() const>() == 0 );\n+\n+  function<int(X&)> hrm(cref(X_bar));\n+  VERIFY( hrm );\n+  VERIFY( hrm(x) == 17 );\n+  VERIFY( typeid(int X::*) == hrm.target_type() );\n+  VERIFY( hrm.target<int X::*>() == 0 );\n+  VERIFY( hrm.target<int X::* const>() == &X_bar );\n+\n+  function<int(X&)> hr(cref(X_foo));\n+  VERIFY( hr );\n+  VERIFY( hr(x) == 1 );\n+  VERIFY( typeid(int (X::*)()) == hr.target_type() );\n+  VERIFY( hr.target<int (X::* const)()>() == &X_foo );\n+\n+  function<int(const X&)> hrc(cref(X_foo_c));\n+  VERIFY( hrc );\n+  VERIFY( hrc(x) == 2 );\n+  VERIFY( typeid(int (X::*)() const) == hrc.target_type() );\n+  VERIFY( hrc.target<int (X::* const)() const >() == &X_foo_c );\n+\n+  function<int(volatile X&)> hrv(cref(X_foo_v));\n+  VERIFY( hrv );\n+  VERIFY( hrv(x) == 3 );\n+  VERIFY( typeid(int (X::*)() volatile) == hrv.target_type() );\n+  VERIFY( hrv.target<int (X::* const)() volatile >() == &X_foo_v );\n+  VERIFY( hrv.target<int (X::* const)() const volatile>() == 0 );\n+\n+  function<int(const volatile X&)> hrcv(cref(X_foo_cv));\n+  VERIFY( hrcv );\n+  VERIFY( hrcv(x) == 4 );\n+  VERIFY( typeid(int (X::*)() const volatile) == hrcv.target_type() );\n+  VERIFY( hrcv.target<int (X::* const)() const volatile >() == &X_foo_cv );\n+  VERIFY( hrcv.target<int (X::* const)() const>() == 0 );\n+}\n+\n+int main()\n+{\n+  test08();\n+  return 0;\n+}"}, {"sha": "474ce6145ef01b7c8ec7d97d0293bc5d3dc768c7", "filename": "libstdc++-v3/testsuite/20_util/function/9.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F9.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2005-01-15 Douglas Gregor <dgregor@cs.indiana.edu>\n+//\n+// Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.7.15 polymorphic function object wrapper\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// Put function objects into a void-returning function<> wrapper\n+void test09()\n+{\n+  using std::function;\n+  using std::ref;\n+  using std::cref;\n+\n+  int (X::*X_foo_c)() const = &X::foo_c;\n+  function<void(X&)> f(&X::bar);\n+  f = &X::foo;\n+  f = ref(X_foo_c);\n+  f = cref(X_foo_c);\n+\n+  function<void(float)> g = &truncate_float;\n+  g = do_truncate_float_t();\n+}\n+\n+int main()\n+{\n+  test09();\n+\n+  VERIFY( do_truncate_double_t::live_objects == 0 );\n+  VERIFY( do_truncate_float_t::live_objects == 0 );\n+\n+  return 0;\n+}"}, {"sha": "a2ab96245ca5c2eabfb35eed71699616b4485d52", "filename": "libstdc++-v3/testsuite/20_util/function/assign/move.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fassign%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fassign%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fassign%2Fmove.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+int f1() { return 1; }\n+struct { int operator()() { return 2; } } f2;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::function<int()> function;\n+\n+  function fo(f1);\n+  function fo1;\n+  fo1 = (std::move(fo));\n+  VERIFY( static_cast<bool>(fo1) );\n+  VERIFY( fo1() == 1 );\n+\n+  fo = function(f2);\n+  function fo2;\n+  fo2 = (std::move(fo));\n+  VERIFY( static_cast<bool>(fo2) );\n+  VERIFY( fo2() == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}, {"sha": "a196ef64e2e3be5ea528b20eddc4513134a20f3c", "filename": "libstdc++-v3/testsuite/20_util/function/cmp/cmp_neg.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcmp%2Fcmp_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcmp%2Fcmp_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcmp%2Fcmp_neg.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+void test01()\n+{\n+  std::function<void()> f1;\n+  std::function<void()> f2;\n+  f1 == f2;  // { dg-error \"here\" }\n+  f1 != f2;  // { dg-error \"here\" }\n+  // { dg-excess-errors \"\" }\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}, {"sha": "43d71858c9f2a8fc1e217a54465cc2dc59fed647", "filename": "libstdc++-v3/testsuite/20_util/function/cons/move.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fmove.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+int f1() { return 1; }\n+struct { int operator()() { return 2; } } f2;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::function<int()> function;\n+\n+  function fo(f1);\n+  function fo1(std::move(fo));\n+  VERIFY( static_cast<bool>(fo1) );\n+  VERIFY( fo1() == 1 );\n+\n+  fo = function(f2);\n+  function fo2(std::move(fo));\n+  VERIFY( static_cast<bool>(fo2) );\n+  VERIFY( fo2() == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}, {"sha": "fbfb0624a00c8abc55c99333465865aee3483a72", "filename": "libstdc++-v3/testsuite/20_util/function/invoke/move_only.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Finvoke%2Fmove_only.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aec2c6343aea30f1b825ccfb42daf8c0b14c51a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Finvoke%2Fmove_only.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Finvoke%2Fmove_only.cc?ref=7aec2c6343aea30f1b825ccfb42daf8c0b14c51a", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+struct moveable\n+{\n+  moveable() = default;\n+  ~moveable() = default;\n+  moveable(const moveable& c) = delete;\n+  moveable& operator=(const moveable&) = delete;\n+  moveable(moveable&&) { }\n+};\n+\n+void f1(moveable) { }\n+void f2(moveable&&) { }\n+struct { void operator()(moveable&&) { } } f3;\n+\n+void test01()\n+{\n+  std::function<void (moveable)> fo1a(f1);\n+  fo1a(moveable());\n+\n+  std::function<void (moveable)> fo2a(f2);\n+  fo2a(moveable());\n+\n+  std::function<void (moveable)> fo3a(f3);\n+  fo3a(moveable());\n+\n+  std::function<void (moveable&&)> fo1b(f1);\n+  fo1b(moveable());\n+\n+  std::function<void (moveable&&)> fo2b(f2);\n+  fo2b(moveable());\n+\n+  std::function<void (moveable&&)> fo3b(f3);\n+  fo3b(moveable());\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}]}