{"sha": "2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM3M2Y5ZjU3YWMzMWI0Yzc5YzhlOTI4MmM3NDhlMzI5NGNkN2U5NQ==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1998-05-08T02:06:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-05-08T02:06:26Z"}, "message": "massive namespace patch\n\nFrom-SVN: r19631", "tree": {"sha": "b63320f941aa58f44dbdc20a5d48fb3384cb73c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b63320f941aa58f44dbdc20a5d48fb3384cb73c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/comments", "author": null, "committer": null, "parents": [{"sha": "0d33d22e9ff0d6cba03b7ef6f099f215b260c7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d33d22e9ff0d6cba03b7ef6f099f215b260c7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d33d22e9ff0d6cba03b7ef6f099f215b260c7e1"}], "stats": {"total": 4545, "additions": 2839, "deletions": 1706}, "files": [{"sha": "887026dd07b8bd1c948cbda896819f8fb3b3946e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -1,3 +1,243 @@\n+Mon Apr 27 07:17:38 1998  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n+\n+\t* cp-tree.def (OVERLOAD): New node.  \n+\t* cp-tree.h (BINDING_TYPE, SET_IDENTIFIER_GLOBAL_VALUE,\n+\tSET_IDENTIFIER_NAMESPACE_VALUE): Define.\n+\t(NAMESPACE_BINDING): Remove.\n+\t(IDENTIFIER_GLOBAL_VALUE, IDENTIFIER_NAMESPACE_VALUE): Use\n+\tnamespace_binding.\n+\t(OVL_FUNCTION, OVL_CHAIN, OVL_CURRENT, OVL_NEXT, OVL_USED):\n+\tDefine.\n+\t(tree_overload): New struct.\n+\t(IDENTIFIER_TYPE_VALUE): Use identifier_type_value.\n+\t(REAL_IDENTIFIER_TYPE_VALUE): Define.\n+\t(IDENTIFIER_HAS_TYPE_VALUE): Use IDENTIFIER_TYPE_VALUE.\n+\t(lang_decl_flags): Remove in_namespace.\n+\t(lang_decl): Remove chain.\n+\t(DECL_CHAIN, DECL_NAMESPACE): Remove.\n+\t(flag_honor_std): Declare extern.\n+\t(identifier_type_value, pushdecl_namespace_level, push_using_decl,\n+\tnamespace_binding, set_namespace_binding,\n+\tlookup_function_nonclass, cat_namespace_levels,\n+\tset_decl_namespace, lookup_arg_dependent, binding_init, ovl_cons,\n+\tscratch_ovl_cons, ovl_member, build_overload): Declare.\n+\t(decl_list_length, get_namespace_id, current_namespace_id,\n+\toverloaded_globals_p): Remove.\n+\t(lookup_using_namespace, qualified_lookup_using_namespace): Change\n+\treturn type.\n+\t(push_scratch_obstack): New macro.\n+\t* call.c (add_function_candidate): Special-case type of OVERLOAD node.\n+\t(build_user_conversions_1): Iterate using OVL_NEXT for ctors,\n+\tconvs, fns.\n+\t(build_new_function_call): Iterate using OVL_CHAIN.  \n+\tPrint DECL_NAME in when reporting ambiguities.\n+\t(build_object_call): Iterate using OVL_NEXT for fns, convs.\n+\t(build_new_op): Call lookup_function_nonclass.  \n+\tIterate using OVL_NEXT.\n+\t(build_op_delete_call): Change detection of members.\n+\tDo not wrap TREE_LIST around fields and single global functions.\n+\t(build_over_call): Don't push a class level if the context is a\n+\tnamespace.\n+\t(build_new_method_call): Iterate using OVL_NEXT.\n+\t* class.c (add_method): Chain overloaded members using\n+\tbuild_overload.  Remove copying of method.\n+\t(grow_method): When iterating through the obstack, expect OVERLOAD\n+\tnodes.  Chain overload members.\n+\t(finish_struct_methods): Chain overload members.  Unpack OVERLOAD\n+\tnodes in call to get_baselinks.\n+\t(duplicate_tag_error): Expect OVERLOAD nodes when unchaining.\n+\t(finish_struct_1): Iterate over ctor using OVL_NEXT.  Handle\n+\tfdecls that are OVERLOAD nodes.\n+\t(validate_lhs): New function.\n+\t(instantiate_type): Do not copy OVERLOAD nodes.  Remove dead\n+\tcode. Use DECL_NAME in error messages. Split code between global\n+\tand member function processing.\n+\t* decl.c (global_type_node): New static variable.\n+\t(in_std): New global.\n+\t(struct binding_level): New field usings.\n+\t(resume_binding_level): Assert that we are not in a class.\n+\t(toplevel_bindings_p): Just check for namespace_p or\n+\tpseudo_global.\n+\t(resume_level): Remove.\n+\t(find_binding): New function.\n+\t(binding_for_name): Call it.\n+\t(namespace_binding, set_namespace_binding): New functions.\n+\t(push_namespace): Associate binding level with new namespace,\n+\tresume_binding_level for existing namespace.  Remove old code.\n+\tFake std by counting.\n+\t(store_bindings): Use REAL_IDENTIFIER_TYPE_VALUE.\n+\t(maybe_push_to_top_level): Save current namespace.\n+\t(pop_from_top_level): Restore saved namespace.\n+\t(pop_namespace): Call suspend_binding_level.  Remove old code.\n+\t(cat_namespace_levels): New function.\n+\t(set_identifier_type_value_with_scope): For namespace bindings,\n+\tset BINDING_TYPE, and use global_type_node.\n+\tUse REAL_IDENTIFIER_TYPE_VALUE otherwise.\n+\t(identifier_type_value): New function.\n+\t(pushtag): If no context, use current_namespace.\n+\t(duplicate_decls): Don't process DECL_CHAIN.\n+\t(pushdecl): Set DECL_CONTEXT to current_namespace, if it is not\n+\talready set. Never reset it to NULL_TREE.  Lookup global variables\n+\tin their namespace.  Push overloaded templates if they are on\n+\tnamespace level.\n+\t(pushdecl_namespace_level): New function.\n+\t(pushdecl_top_level): Implement using pushdecl_namespace_level.\n+\t(pushdecl_using_decl): New function.\n+\t(overloaded_globals_p): Remove.\n+\t(push_overloaded_decl): Create OVERLOAD nodes, and iterate through\n+\tthem. Use namespace_binding and set_namespace_value.\n+\t(redeclaration_error_message): Complain if the declarations come\n+\tfrom different namespaces.\n+\t(lookup_tag): On namespace level, look in the BINDING_TYPE.\n+\t(lookup_namespace_name): Pass tree_bindings from stack.  Remove\n+\told code.\n+\t(select_decl): New function.\n+\t(lookup_name_real): Call it for qualified and unqualified lookup.\n+\tPass tree_bindings from the stack.\n+\tIf prefer_type is 1, also accept namespaces.\n+\t(lookup_function_nonclass): New function.\n+\t(init_decl_processing): Set the binding level of the global\n+\tnamespace to global_binding_level.\n+\tBuild a proper type list for __builtin_apply.\n+\tInitialize std_node to \"fake std\" if flag_honor_std is set.\n+\tInitialize global_type_node.\n+\tAllocated bad_alloc in namespace std if flag_honor_std.\n+\t(define_function): Set the DECL_CONTEXT to the current_namespace.\n+\t(start_decl): A namespace is not considered as a context here.  If\n+\tthe DECL_CONTEXT is a namespace, push the decl.\n+\t(cp_finish_decl): Check for namespaces used as initializers.\n+\t(grokfndecl): Add namespace parameter.  Remove processing of\n+\tDECL_CHAIN.\n+\t(grokvardecl): Add namespace parameter.\n+\t(grokdeclarator): Process SCOPEs that are namespaces.  For\n+\tmangling, temporarily set the DECL_CONTEXT on anonymous structs.\n+\t(start_function): Check for contexts that are namespaces.  \n+\tSet context for declarations that have not been pushed.\n+\t(store_parm_decls): Check for ::main only.\n+\t(finish_function): Likewise.\n+\t(start_method): Check for contexts that are namespaces.\n+\t(start_method): Remove DECL_CHAIN processing.\n+\t* decl2.c (flag_honor_std): Declare.\n+\t(lang_decode_option): Set it if -fhonor-std or -fnew-abi is given.\n+\t(decl_namespace_list): New static global.\n+\t(grok_x_components): Ignore namespaces as type contexts.\n+\t(check_classfn): Expect OVERLOAD nodes.\n+\t(grokfield): Remove DECL_CHAIN processing.\n+\t(finish_file): Call cat_namespace_levels.\n+\t(merge_functions): New function.\n+\t(ambiguous_decl): Rewrite.\n+\t(lookup_using_namespace): Produce tree_bindings.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(set_decl_namespace, decl_namespace, current_decl_namespace,\n+\tpush_decl_namespace, pop_decl_namespace): New functions.\n+\t(arg_lookup): New struct.\n+\t(add_function, arg_assoc_namespace, arg_assoc_class,\n+\targ_assoc_type, arg_assoc_args, arg_assoc, lookup_arg_dependent):\n+\tNew functions.\n+\t(get_namespace_id, current_namespace_id): Remove.\n+\t(do_toplevel_using_decl): Rewrite.\n+\t(do_class_using_decl): Complain about namespace qualifiers.\n+\t(do_using_directive): Sorry if not on namespace level.  Complain\n+\tabout unknown namespaces.\n+\t* error.c (dump_aggr_type): Check for namespace contexts.\n+\t* except.c (init_exception_processing): Push terminate into std.\n+\t* friend.c (is_friend): A namespace is not a context, here.\n+\t* init.c (expand_member_init): Remove DECL_CHAIN processing.\n+\t(build_offset_ref): Process OVERLOAD nodes.\n+\t* lang-specs.h (__HONOR_STD): Define if -fnew-abi or -fhonor-std.\n+\t* lex.c (identifier_type): Loop using OVL_CHAIN.\n+\t(see_typename): Set looking_for_typename to 2.\n+\t(real_yylex): Likewise.\t\n+\t(do_identifier): Expect OVERLOAD nodes instead of TREE_LISTs.\n+\t(do_scoped_id): Expect OVERLOAD nodes.\n+\tChange calling convention for qualified_lookup_using_namespace.\n+\t(build_lang_decl): Don't set in_namespace anymore.\n+\t* method.c (typevec_size): New global.\n+\t(build_overload_nested_name): Return if global_namespace.\n+\tOtherwise, always expect a declaration context.\n+\t(build_qualified_name): Likewise.\n+\tMake sure we don't write beyond typevec_size.\n+\t(build_decl_overload_real): Likewise.\n+\tAllocate one extra slot for the namespace.\n+\t(hack_identifier): Mark code dead.\n+\tProcess OVERLOAD and NAMESPACE_DECL nodes.\n+\t* parse.y (program): Pop namespaces until in global namespace.\n+\t(extdef): In a using-declaration, don't discard the identifier if\n+\tthere is no declaration.\n+\t(left_curly): Ignore type contexts which are namespaces.\n+\t(typename_sub2): Use IDENTIFIER_TYPE_VALUE to retrieve the type\n+\tused as scope.\n+\t* pt.c (template_class_depth): Expect types to be namespaces.\n+\t(determine_specialization): Simplify by expecting OVERLOAD nodes.\n+\t(push_template_decl): Push into namespace level.\n+\tReset ctx if it is a namespace.\n+\tSet DECL_CONTEXT to current_namespace if not set already.\n+\tIgnore real contexts that are namespaces.\n+\t(mangle_class_name_for_template): Skip global_namespace.\n+\tMangle other namepaces as declarations.\n+\t(lookup_template_function): Set type of OVERLOAD nodes to unknown.\n+\t(lookup_template_class): Push into namespace of context.\n+\tIf the context is a namespace, set it to global_namespace.\n+\tUse id_context for mangling.\n+\t(for_each_template_parm): Handle OVERLOAD and NAMESPACE_DECL nodes.\n+\t(tsubst_friend_function): Ignore namespace contexts.\n+\tPush into namespace level.\n+\t(tsubst): Handle NAMESPACE_DECL nodes.\n+\tRemove DECL_CHAIN processing.\n+\t(type_unification_real): Recognize OVERLOAD instead of TREE_LIST nodes.\n+\t* ptree.c (print_lang_identifier): Print bindings.\n+\t(lang_print_xnode): Print OVERLOAD nodes.\n+\t* rtti.c (init_rtti_processing): Push type_info into std.\n+\t* search.c (lookup_fnfields_here): Expect OVERLOAD nodes.\n+\t(lookup_fnfields_1, get_virtuals_named_this, get_matching_virtual,\n+\tdfs_debug_mark, dfs_pushdecls, dfs_compress_decls, add_conversions,\n+\tlookup_fnfields_here): Likewise.\n+\tProcess all nodes, instead of going through TREE_CHAIN.\n+\t* sig.c (build_signature_pointer_or_reference_type): Set context\n+\tto global_namespace.\n+\t(build_signature_table_constructor): Expect OVERLOAD nodes.\n+\t* spew.c (yylex): Save old setting of looking_for_typename.\n+\t* tree.c (decl_list_length): Remove.\n+\t(binding_init): New function.\n+\t(count_functions): Rewrite.\n+\t(is_overloaded_fn): Expect OVERLOAD nodes.\n+\t(really_overloaded_fn, get_first_fn, lvalue_type): Likewise.\n+\t(ovl_cons, scratch_ovl_cons, build_overload, build_overload_after,\n+\tovl_member): New functions.\n+\t* typeck.c (require_complete_type): Expect OVERLOAD nodes.\n+\t(type_unknown_p): Likewise.\n+\t(require_instantiated_type): Likewise.\n+\t(build_component_ref): Declare code dead.\n+\t(build_x_function_call): Create and expect OVERLOAD nodes.\n+\t(build_function_call_real): Check for ::main only.\n+\t(build_unary_op): Likewise.  Expect OVERLOAD nodes.\n+\t(convert_for_assignment): Check for TREE_LIST before accessing\n+\tTREE_VALUE.\n+\t* decl.c (duplicate_decls): Check for namespace bindings instead\n+\tof global bindings.\n+\t(pushdecl, push_overloaded_decl, lookup_tag, lookup_name_real,\n+\tlookup_name_current_level, start_decl, xref_tag, \n+\tfinish_enum): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t* search.c (lookup_field): Likewise.\n+\t(lookup_fnfields): Likewise.\n+\t(dfs_debug_mark): Likewise.\n+\t* decl.c (poplevel): Use SET_IDENTIFIER_TYPE_VALUE.\n+\t(poplevel_class, pop_from_top_level): Likewise.\n+\t* decl2.c (finish_method): Likewise.\n+\t* class.c (build_vtable): Use SET_IDENTIFIER_GLOBAL_VALUE.\n+\t* decl.c (record_builtin_type): Likewise.\n+\t(init_decl_processing, grokfndecl): Likewise.\n+\t* lex.c (get_time_identifier, do_identifier, do_scoped_id): Likewise.\n+\t(make_lang_type): Likewise.\n+\t* parse.y (make_thunk): Likewise.\n+\t* pt.c (tsubst): Likewise.\n+\t* tree.c (debug_binfo): Likewise.\n+\t* exception.cc, new.cc, new1.cc, new2.cc, tinfo.cc, tinfo.h, \n+\ttinfo2.cc, inc/new.h: Add std qualifications.\n+\t* inc/new: Wrap with namespace std if __HONOR_STD.\n+\t* inc/typeinfo: Likewise.\n+\n Fri May  8 00:43:50 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_user_type_conversion_1): Handle second_conv "}, {"sha": "e9ca9af376ef4bff19808606daa6e325436dce23", "filename": "gcc/cp/call.c", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -1117,6 +1117,9 @@ add_function_candidate (candidates, fn, arglist, flags)\n       tree argtype = TREE_TYPE (arg);\n       tree t;\n \n+      /* An overloaded function does not have an argument type */\n+      if (TREE_CODE (arg) == OVERLOAD)\n+\targtype = unknown_type_node;\n       argtype = cp_build_type_variant\n \t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n \n@@ -2044,20 +2047,21 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n       ctors = TREE_VALUE (ctors);\n     }\n-  for (; ctors; ctors = DECL_CHAIN (ctors))\n+  for (; ctors; ctors = OVL_NEXT (ctors))\n     {\n-      if (DECL_NONCONVERTING_P (ctors))\n+      tree ctor = OVL_CURRENT (ctors);\n+      if (DECL_NONCONVERTING_P (ctor))\n \tcontinue;\n \n-      if (TREE_CODE (ctors) == TEMPLATE_DECL) \n+      if (TREE_CODE (ctor) == TEMPLATE_DECL) \n \t{\n-\t  templates = scratch_tree_cons (NULL_TREE, ctors, templates);\n+\t  templates = scratch_tree_cons (NULL_TREE, ctor, templates);\n \t  candidates = \n-\t    add_template_candidate (candidates, ctors,\n+\t    add_template_candidate (candidates, ctor,\n \t\t\t\t    NULL_TREE, args, NULL_TREE, flags);\n \t} \n       else \n-\tcandidates = add_function_candidate (candidates, ctors,\n+\tcandidates = add_function_candidate (candidates, ctor,\n \t\t\t\t\t     args, flags); \n \n       if (candidates) \n@@ -2072,7 +2076,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n-      tree fn = TREE_VALUE (convs);\n+      tree fns = TREE_VALUE (convs);\n       int convflags = LOOKUP_NO_CONVERSION;\n       tree ics;\n \n@@ -2083,18 +2087,19 @@ build_user_type_conversion_1 (totype, expr, flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n \n-      if (TREE_CODE (fn) != TEMPLATE_DECL)\n+      if (TREE_CODE (fns) != TEMPLATE_DECL)\n \tics = implicit_conversion\n-\t  (totype, TREE_TYPE (TREE_TYPE (fn)), 0, convflags);\n+\t  (totype, TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns))), 0, convflags);\n       else\n \t/* We can't compute this yet.  */\n \tics = error_mark_node;\n \n       if (TREE_CODE (totype) == REFERENCE_TYPE && ics && ICS_BAD_FLAG (ics))\n \t/* ignore the near match.  */;\n       else if (ics)\n-\tfor (; fn; fn = DECL_CHAIN (fn))\n+\tfor (; fns; fns = OVL_NEXT (fns))\n \t  {\n+\t    tree fn = OVL_CURRENT (fns);\n \t    struct z_candidate *old_candidates = candidates;\n \n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n@@ -2240,16 +2245,17 @@ build_new_function_call (fn, args)\n \n   if (really_overloaded_fn (fn))\n     {\n-      tree t;\n+      tree t1;\n       tree templates = NULL_TREE;\n \n       args = resolve_args (args);\n \n       if (args == error_mark_node)\n \treturn error_mark_node;\n \n-      for (t = TREE_VALUE (fn); t; t = DECL_CHAIN (t))\n+      for (t1 = fn; t1; t1 = OVL_CHAIN (t1))\n \t{\n+\t  tree t = OVL_FUNCTION (t1);\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n@@ -2267,7 +2273,7 @@ build_new_function_call (fn, args)\n \t  if (candidates && ! candidates->next)\n \t    return build_function_call (candidates->fn, args);\n \t  cp_error (\"no matching function for call to `%D (%A)'\",\n-\t\t    TREE_PURPOSE (fn), args);\n+\t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  if (candidates)\n \t    print_z_candidates (candidates);\n \t  return error_mark_node;\n@@ -2278,7 +2284,7 @@ build_new_function_call (fn, args)\n       if (cand == 0)\n \t{\n \t  cp_error (\"call of overloaded `%D (%A)' is ambiguous\",\n-\t\t    TREE_PURPOSE (fn), args);\n+\t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  print_z_candidates (candidates);\n \t  return error_mark_node;\n \t}\n@@ -2293,6 +2299,9 @@ build_new_function_call (fn, args)\n       return build_over_call (cand, args, LOOKUP_NORMAL);\n     }\n \n+  /* This is not really overloaded. */\n+  fn = OVL_CURRENT (fn);\n+\n   return build_function_call (fn, args);\n }\n \n@@ -2325,11 +2334,12 @@ build_object_call (obj, args)\n \n   if (fns)\n     {\n-      tree fn = TREE_VALUE (fns);\n+      tree base = TREE_PURPOSE (fns);\n       mem_args = scratch_tree_cons (NULL_TREE, build_this (obj), args);\n \n-      for (; fn; fn = DECL_CHAIN (fn))\n+      for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n \t{\n+\t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n \t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n@@ -2343,21 +2353,23 @@ build_object_call (obj, args)\n \t      (candidates, fn, mem_args, LOOKUP_NORMAL);\n \n \t  if (candidates)\n-\t    candidates->basetype_path = TREE_PURPOSE (fns);\n+\t    candidates->basetype_path = base;\n \t}\n     }\n \n   convs = lookup_conversions (type);\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n-      tree fn = TREE_VALUE (convs);\n-      tree totype = TREE_TYPE (TREE_TYPE (fn));\n+      tree fns = TREE_VALUE (convs);\n+      tree totype = TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns)));\n+      tree fn;\n \n       if (TREE_CODE (totype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n-\tfor (; fn; fn = DECL_CHAIN (fn))\n+\tfor (; fns; fns = OVL_NEXT (fn))\n \t  {\n+\t    fn = OVL_CURRENT (fn);\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n \t      {\n \t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n@@ -2477,7 +2489,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \targlist = scratch_tree_cons (NULL_TREE, arg2, arg3);\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_new_function_call\n-\t    (lookup_name_nonclass (fnname), arglist);\n+\t    (lookup_function_nonclass (fnname, arglist), arglist);\n \n \t/* FIXME */\n \trval = build_method_call\n@@ -2499,9 +2511,11 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \ttree rval;\n \n \tif (flags & LOOKUP_GLOBAL)\n-\t  return build_new_function_call\n-\t    (lookup_name_nonclass (fnname),\n-\t     build_scratch_list (NULL_TREE, arg1));\n+\t  {\n+\t    arglist = build_scratch_list (NULL_TREE, arg1);\n+\t    return build_new_function_call\n+\t      (lookup_function_nonclass (fnname, arglist), arglist);\n+\t  }    \n \n \targlist = scratch_tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n \n@@ -2576,23 +2590,23 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   else\n     arglist = build_scratch_list (NULL_TREE, arg1);\n \n-  fns = lookup_name_nonclass (fnname);\n-  /* + Koenig lookup */\n+  fns = lookup_function_nonclass (fnname, arglist);\n \n   if (fns && TREE_CODE (fns) == TREE_LIST)\n     fns = TREE_VALUE (fns);\n-  for (; fns; fns = DECL_CHAIN (fns))\n+  for (; fns; fns = OVL_NEXT (fns))\n     {\n-      if (TREE_CODE (fns) == TEMPLATE_DECL)\n+      tree fn = OVL_CURRENT (fns);\n+      if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t{\n-\t  templates = scratch_tree_cons (NULL_TREE, fns, templates);\n+\t  templates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t  candidates \n-\t    = add_template_candidate (candidates, fns, NULL_TREE,\n+\t    = add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n \t\t\t\t      flags); \n \t}\n       else\n-\tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n+\tcandidates = add_function_candidate (candidates, fn, arglist, flags);\n     }\n \n   if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n@@ -2606,10 +2620,11 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n   if (fns)\n     {\n-      tree fn = TREE_VALUE (fns);\n+      tree basetype = TREE_PURPOSE (fns);\n       mem_arglist = scratch_tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n-      for (; fn; fn = DECL_CHAIN (fn))\n+      for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n \t{\n+\t  tree fn = OVL_CURRENT (fns);\n \t  tree this_arglist;\n \n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n@@ -2631,7 +2646,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t      (candidates, fn, this_arglist, flags);\n \n \t  if (candidates) \n-\t    candidates->basetype_path = TREE_PURPOSE (fns);\n+\t    candidates->basetype_path = basetype;\n \t}\n     }\n \n@@ -2860,7 +2875,8 @@ build_op_new_call (code, type, args, flags)\n       return build_method_call (dummy, fnname, args, NULL_TREE, flags);\n     }\n   else\n-    return build_new_function_call (lookup_name_nonclass (fnname), args);\n+    return build_new_function_call \n+      (lookup_function_nonclass (fnname, args), args);\n }\n \n /* Build a call to operator delete.  This has to be handled very specially,\n@@ -2908,9 +2924,12 @@ build_op_delete_call (code, addr, size, flags)\n \n   if (fns)\n     {\n+#if 0\n+      /* It is unnecessary to wrap another TREE_LIST around it. (MvL) */\n       /* Build this up like build_offset_ref does.  */\n       fns = build_tree_list (error_mark_node, fns);\n       TREE_TYPE (fns) = build_offset_type (type, unknown_type_node);\n+#endif\n     }\n   else\n     fns = lookup_name_nonclass (fnname);\n@@ -2957,15 +2976,15 @@ build_op_delete_call (code, addr, size, flags)\n   /* instantiate_type will always return a plain function; pretend it's\n      overloaded.  */\n   if (TREE_CODE (fns) == FUNCTION_DECL)\n-    fns = scratch_tree_cons (NULL_TREE, fns, NULL_TREE);\n+    fns = scratch_ovl_cons (fns, NULL_TREE);\n \n   fn = instantiate_type (fntype, fns, 0);\n \n   if (fn != error_mark_node)\n     {\n-      if (TREE_CODE (TREE_VALUE (fns)) == TREE_LIST)\n+      if (TREE_CODE (fns) == TREE_LIST)\n \t/* Member functions.  */\n-\tenforce_access (TREE_PURPOSE (TREE_VALUE (fns)), fn);\n+\tenforce_access (TREE_PURPOSE (fns), fn);\n       return build_function_call (fn, expr_tree_cons (NULL_TREE, addr, args));\n     }\n \n@@ -3268,12 +3287,14 @@ build_over_call (cand, args, flags)\n \n \t     we must be careful to do name lookup in the scope of\n \t     S<T>, rather than in the current class.  */\n-\t  if (DECL_REAL_CONTEXT (fn))\n+\t  if (DECL_REAL_CONTEXT (fn) \n+\t      && TREE_CODE (DECL_REAL_CONTEXT (fn)) != NAMESPACE_DECL)\n \t    pushclass (DECL_REAL_CONTEXT (fn), 2);\n \n \t  arg = tsubst_expr (arg, DECL_TI_ARGS (fn), NULL_TREE);\n \n-\t  if (DECL_REAL_CONTEXT (fn))\n+\t  if (DECL_REAL_CONTEXT (fn)\n+\t      && TREE_CODE (DECL_CONTEXT (fn)) != NAMESPACE_DECL)\n \t    popclass (0);\n \t}\n       converted_args = expr_tree_cons\n@@ -3540,16 +3561,17 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     return error_mark_node;\n   if (fns)\n     {\n-      tree t = TREE_VALUE (fns);\n+      tree fn = TREE_VALUE (fns);\n       if (name == ctor_identifier && TYPE_USES_VIRTUAL_BASECLASSES (basetype)\n \t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n \t{\n \t  flags |= LOOKUP_HAS_IN_CHARGE;\n \t  args = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n \t}\n       mem_args = scratch_tree_cons (NULL_TREE, instance_ptr, args);\n-      for (; t; t = DECL_CHAIN (t))\n+      for (; fn; fn = OVL_NEXT (fn))\n \t{\n+\t  tree t = OVL_CURRENT (fn);\n \t  tree this_arglist;\n \n \t  /* We can end up here for copy-init of same or base class.  */"}, {"sha": "fe5b86142061fcc71706c3aa7d50d7e1b0d6a8cd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 217, "deletions": 180, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -710,7 +710,8 @@ build_vtable (binfo, type)\n   /* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */\n   import_export_vtable (decl, type, 0);\n \n-  IDENTIFIER_GLOBAL_VALUE (name) = decl = pushdecl_top_level (decl);\n+  decl = pushdecl_top_level (decl);\n+  SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n   /* Initialize the association list for this type, based\n      on our first approximation.  */\n   TYPE_BINFO_VTABLE (type) = decl;\n@@ -1072,42 +1073,24 @@ void\n add_method (type, fields, method)\n      tree type, *fields, method;\n {\n-  /* We must make a copy of METHOD here, since we must be sure that\n-     we have exclusive title to this method's DECL_CHAIN.  */\n-  tree decl;\n-\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n-  {\n-    decl = copy_node (method);\n-    if (DECL_RTL (decl) == 0\n-        && (!processing_template_decl\n-\t    || !uses_template_parms (decl)))\n-      {\n-\tmake_function_rtl (decl);\n-\tDECL_RTL (method) = DECL_RTL (decl);\n-      }\n-  }\n \n   if (fields && *fields)\n-    {\n-      /* Take care not to hide destructor.  */\n-      DECL_CHAIN (decl) = DECL_CHAIN (*fields);\n-      DECL_CHAIN (*fields) = decl;\n-    }\n+      *fields = build_overload (method, *fields);\n   else if (CLASSTYPE_METHOD_VEC (type) == 0)\n     {\n       tree method_vec = make_node (TREE_VEC);\n-      if (TYPE_IDENTIFIER (type) == DECL_NAME (decl))\n+      if (TYPE_IDENTIFIER (type) == DECL_NAME (method))\n \t{\n \t  /* ??? Is it possible for there to have been enough room in the\n \t     current chunk for the tree_vec structure but not a tree_vec\n \t     plus a tree*?  Will this work in that case?  */\n \t  obstack_free (current_obstack, method_vec);\n \t  obstack_blank (current_obstack, sizeof (struct tree_vec) + sizeof (tree *));\n-\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n-\t    TREE_VEC_ELT (method_vec, 1) = decl;\n+\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)))\n+\t    TREE_VEC_ELT (method_vec, 1) = method;\n \t  else\n-\t    TREE_VEC_ELT (method_vec, 0) = decl;\n+\t    TREE_VEC_ELT (method_vec, 0) = method;\n \t  TREE_VEC_LENGTH (method_vec) = 2;\n \t}\n       else\n@@ -1117,7 +1100,7 @@ add_method (type, fields, method)\n \t     plus a tree*?  Will this work in that case?  */\n \t  obstack_free (current_obstack, method_vec);\n \t  obstack_blank (current_obstack, sizeof (struct tree_vec) + 2*sizeof (tree *));\n-\t  TREE_VEC_ELT (method_vec, 2) = decl;\n+\t  TREE_VEC_ELT (method_vec, 2) = method;\n \t  TREE_VEC_LENGTH (method_vec) = 3;\n \t  obstack_finish (current_obstack);\n \t}\n@@ -1130,15 +1113,13 @@ add_method (type, fields, method)\n \n       /* Adding a new ctor or dtor.  This is easy because our\n          METHOD_VEC always has a slot for such entries.  */\n-      if (TYPE_IDENTIFIER (type) == DECL_NAME (decl))\n+      if (TYPE_IDENTIFIER (type) == DECL_NAME (method))\n \t{\n-\t  int idx = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl));\n-\t  /* TREE_VEC_ELT (method_vec, idx) = decl; */\n-\t  if (decl != TREE_VEC_ELT (method_vec, idx))\n-\t    {\n-\t      DECL_CHAIN (decl) = TREE_VEC_ELT (method_vec, idx);\n-\t      TREE_VEC_ELT (method_vec, idx) = decl;\n-\t    }\n+\t  int idx = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method));\n+\t  /* TREE_VEC_ELT (method_vec, idx) = method; */\n+\t  if (method != TREE_VEC_ELT (method_vec, idx))\n+\t    TREE_VEC_ELT (method_vec, idx) =\n+\t      build_overload (method, TREE_VEC_ELT (method_vec, idx));\n \t}\n       else\n \t{\n@@ -1177,7 +1158,7 @@ add_method (type, fields, method)\n \t    }\n \n \t  obstack_finish (ob);\n-\t  TREE_VEC_ELT (method_vec, len) = decl;\n+\t  TREE_VEC_ELT (method_vec, len) = method;\n \t  TREE_VEC_LENGTH (method_vec) = len + 1;\n \t  CLASSTYPE_METHOD_VEC (type) = method_vec;\n \n@@ -1194,8 +1175,8 @@ add_method (type, fields, method)\n \t    }\n \t}\n     }\n-  DECL_CONTEXT (decl) = type;\n-  DECL_CLASS_CONTEXT (decl) = type;\n+  DECL_CONTEXT (method) = type;\n+  DECL_CLASS_CONTEXT (method) = type;\n \n   pop_obstacks ();\n }\n@@ -1866,16 +1847,11 @@ grow_method (fndecl, method_vec_ptr)\n   tree *testp = &TREE_VEC_ELT (method_vec, 2);\n \n   while (testp < (tree *) obstack_next_free (&class_obstack)\n-\t && (*testp == NULL_TREE || DECL_NAME (*testp) != DECL_NAME (fndecl)))\n+\t && (*testp == NULL_TREE || DECL_NAME (OVL_CURRENT (*testp)) != DECL_NAME (fndecl)))\n     testp++;\n \n   if (testp < (tree *) obstack_next_free (&class_obstack))\n-    {\n-      tree *p;\n-      for (p = testp; *p; )\n-\tp = &DECL_CHAIN (*p);\n-      *p = fndecl;\n-    }\n+    *testp = build_overload (fndecl, *testp);\n   else\n     {\n       obstack_ptr_grow (&class_obstack, fndecl);\n@@ -1966,14 +1942,14 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn_fields)))\n \t    {\t    \n \t      /* Destructors go in slot 1.  */\n-\t      DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 1);\n-\t      TREE_VEC_ELT (method_vec, 1) = fn_fields;\n+\t      TREE_VEC_ELT (method_vec, 1) = \n+\t\tbuild_overload (fn_fields, TREE_VEC_ELT (method_vec, 1));\n \t    }\n \t  else\n \t    {\n \t      /* Constructors go in slot 0.  */\n-\t      DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n-\t      TREE_VEC_ELT (method_vec, 0) = fn_fields;\n+\t      TREE_VEC_ELT (method_vec, 0) = \n+\t\tbuild_overload (fn_fields, TREE_VEC_ELT (method_vec, 0));\n \t    }\n  \t}\n       else if (IDENTIFIER_TYPENAME_P (fn_name))\n@@ -2057,7 +2033,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n       for (i = 2; i < len; i++)\n \t{\n \t  TREE_VEC_ELT (baselink_vec, i)\n-\t    = get_baselinks (baselink_binfo, t, DECL_NAME (TREE_VEC_ELT (method_vec, i)));\n+\t    = get_baselinks (baselink_binfo, t, \n+\t\t\t     DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i))));\n \t  if (TREE_VEC_ELT (baselink_vec, i) != 0)\n \t    any_links = 1;\n \t}\n@@ -2098,8 +2075,8 @@ duplicate_tag_error (t)\n \t  tree unchain = TREE_VEC_ELT (method_vec, i);\n \t  while (unchain != NULL_TREE) \n \t    {\n-\t      TREE_CHAIN (unchain) = NULL_TREE;\n-\t      unchain = DECL_CHAIN (unchain);\n+\t      TREE_CHAIN (OVL_CURRENT (unchain)) = NULL_TREE;\n+\t      unchain = OVL_NEXT (unchain);\n \t    }\n \t}\n     }\n@@ -3675,8 +3652,8 @@ finish_struct_1 (t, warn_anon)\n \n \t  for (ctor = TREE_VEC_ELT (method_vec, 0);\n \t       ctor;\n-\t       ctor = DECL_CHAIN (ctor))\n-\t    if (! TREE_PRIVATE (ctor))\n+\t       ctor = OVL_NEXT (ctor))\n+\t    if (! TREE_PRIVATE (OVL_CURRENT (ctor)))\n \t      {\n \t\tnonprivate_ctor = 1;\n \t\tbreak;\n@@ -3710,10 +3687,19 @@ finish_struct_1 (t, warn_anon)\n \tint i = 2;\n \ttree tmp;\n \n+\t/* Functions are represented as TREE_LIST, with the purpose\n+\t   being the type and the value the functions. Other members\n+\t   come as themselves. */\n \tif (TREE_CODE (fdecl) == TREE_LIST)\n \t  {\n+\t    /* Ignore base type this came from. */\n+\t    fdecl = TREE_VALUE (fdecl);\n+\t  }\n+\tif (TREE_CODE (fdecl) == OVERLOAD)\n+\t  {\n+\t    /* We later iterate over all functions. */\n \t    flist = fdecl;\n-\t    fdecl = TREE_VALUE (flist);\n+\t    fdecl = OVL_FUNCTION (flist);\n \t  }\n \n \tname = DECL_NAME (fdecl);\n@@ -3746,12 +3732,11 @@ finish_struct_1 (t, warn_anon)\n \t/* Make type T see field decl FDECL with access ACCESS.*/\n \tif (flist)\n \t  {\n-\t    fdecl = TREE_VALUE (flist);\n-\t    while (fdecl)\n+\t    while (flist)\n \t      {\n-\t\tif (alter_access (t, fdecl, access) == 0)\n+\t\tif (alter_access (t, OVL_FUNCTION (flist), access) == 0)\n \t\t  break;\n-\t\tfdecl = DECL_CHAIN (fdecl);\n+\t\tflist = OVL_CHAIN (flist);\n \t      }\n \t  }\n \telse\n@@ -4921,6 +4906,29 @@ pop_lang_context ()\n \f\n /* Type instantiation routines.  */\n \n+static tree\n+validate_lhs (lhstype, complain)\n+     tree lhstype;\n+     int complain;\n+{\n+  if (TYPE_PTRMEMFUNC_P (lhstype))\n+    lhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+\n+  if (TREE_CODE (lhstype) == POINTER_TYPE)\n+    {\n+      if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n+\t  || TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n+\tlhstype = TREE_TYPE (lhstype);\n+      else\n+\t{\n+\t  if (complain)\n+\t    error (\"invalid type combination for overload\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+  return lhstype;\n+}\n+\n /* This function will instantiate the type of the expression given in\n    RHS to match the type of LHSTYPE.  If errors exist, then return\n    error_mark_node.  If only complain is COMPLAIN is set.  If we are\n@@ -4955,7 +4963,10 @@ instantiate_type (lhstype, rhs, complain)\n       return error_mark_node;\n     }\n \n-  rhs = copy_node (rhs);\n+  /* We don't overwrite rhs if it is an overloaded function.\n+     Copying it would destroy the tree link.  */\n+  if (TREE_CODE (rhs) != OVERLOAD)\n+    rhs = copy_node (rhs);\n \n   /* This should really only be used when attempting to distinguish\n      what sort of a pointer to function we have.  For now, any\n@@ -5016,6 +5027,9 @@ instantiate_type (lhstype, rhs, complain)\n \t    return function;\n \t  }\n \n+\t/* I could not trigger this code. MvL */\n+\tmy_friendly_abort (980326);\n+#if 0\n \tmy_friendly_assert (TREE_CODE (field) == FIELD_DECL, 178);\n \tmy_friendly_assert (!(TREE_CODE (TREE_TYPE (field)) == FUNCTION_TYPE\n \t\t\t      || TREE_CODE (TREE_TYPE (field)) == METHOD_TYPE),\n@@ -5056,6 +5070,7 @@ instantiate_type (lhstype, rhs, complain)\n \t      error (\"no appropriate overload exists for COMPONENT_REF\");\n \t    return error_mark_node;\n \t  }\n+#endif\n \treturn rhs;\n       }\n \n@@ -5064,149 +5079,167 @@ instantiate_type (lhstype, rhs, complain)\n \texplicit_targs = TREE_OPERAND (rhs, 1);\n \trhs = TREE_OPERAND (rhs, 0);\n       }\n-    /* fall through */\n+      /* fall through */\n+      my_friendly_assert (TREE_CODE (rhs) == OVERLOAD, 980401);\n \n-    case TREE_LIST:\n+    case OVERLOAD:\n       {\n-\ttree elem, baselink, name = NULL_TREE;\n-\tint globals = overloaded_globals_p (rhs);\n+\ttree elem, elems;\n \n-\t/* First look for an exact match.  Search either overloaded\n-\t   functions or member functions.  May have to undo what\n-\t   `default_conversion' might do to lhstype.  */\n+\t/* First look for an exact match.  Search overloaded\n+\t   functions.  May have to undo what `default_conversion'\n+\t   might do to lhstype.  */\n \n-\tif (TYPE_PTRMEMFUNC_P (lhstype))\n-\t  lhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+\tlhstype = validate_lhs (lhstype, complain);\n+\tif (lhstype == error_mark_node)\n+\t  return lhstype;\n \n-\tif (TREE_CODE (lhstype) == POINTER_TYPE)\n-\t  {\n-\t    if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n-\t\t|| TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n-\t      lhstype = TREE_TYPE (lhstype);\n-\t    else\n-\t      {\n-\t\tif (complain)\n-\t\t  error (\"invalid type combination for overload\");\n-\t\treturn error_mark_node;\n-\t      }\n-\t  }\n-\n-\tif (TREE_CODE (lhstype) != FUNCTION_TYPE && globals > 0)\n+\tif (TREE_CODE (lhstype) != FUNCTION_TYPE)\n \t  {\n+\t    rhs = DECL_NAME (OVL_FUNCTION (rhs));\n \t    if (complain)\n-\t      cp_error (\"cannot resolve overloaded function `%D' based on non-function type\",\n-\t\t     TREE_PURPOSE (rhs));\n+\t      cp_error(\"cannot resolve overloaded function `%D' \" \n+\t\t       \"based on non-function type\", rhs);\n \t    return error_mark_node;\n \t  }\n-\n-\tif (globals > 0)\n-\t  {\n-\t    elem = get_first_fn (rhs);\n-\t    /* If there are explicit_targs, only a template function\n-\t       can match.  */\n-\t    if (explicit_targs == NULL_TREE)\n-\t      while (elem)\n+\t\n+\telems = rhs;\n+\t/* If there are explicit_targs, only a template function\n+\t   can match.  */\n+\tif (explicit_targs == NULL_TREE)\n+\t  while (elems)\n+\t    {\n+\t      elem = OVL_FUNCTION (elems);\n+\t      if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t\telems = OVL_CHAIN (elems);\n+\t      else\n \t\t{\n-\t\t  if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n-\t\t    elem = DECL_CHAIN (elem);\n-\t\t  else\n-\t\t    {\n-\t\t      mark_used (elem);\n-\t\t      return elem;\n-\t\t    }\n+\t\t  mark_used (elem);\n+\t\t  return elem;\n \t\t}\n+\t    }\n \n-\t    /* No exact match found, look for a compatible template.  */\n-\t    {\n-\t      tree save_elem = 0;\n-\t      for (elem = get_first_fn (rhs); elem; elem = DECL_CHAIN (elem))\n-\t\tif (TREE_CODE (elem) == TEMPLATE_DECL)\n+\t/* No exact match found, look for a compatible template.  */\n+\t{\n+\t  tree save_elem = 0;\n+\t  elems = rhs;\n+\t  if (TREE_CODE (elems) == TREE_LIST)\n+\t    elems = TREE_VALUE (rhs);\n+\t  for (; elems; elems = OVL_NEXT (elems))\n+\t    if (TREE_CODE (elem = OVL_CURRENT (elems)) == TEMPLATE_DECL)\n+\t      {\n+\t\tint n = DECL_NTPARMS (elem);\n+\t\ttree t = make_scratch_vec (n);\n+\t\tint i;\n+\t\ti = type_unification\n+\t\t  (DECL_INNERMOST_TEMPLATE_PARMS (elem), t,\n+\t\t   TYPE_ARG_TYPES (TREE_TYPE (elem)),\n+\t\t   TYPE_ARG_TYPES (lhstype), explicit_targs, 1, 1);\n+\t\tif (i == 0)\n \t\t  {\n-\t\t    int n = DECL_NTPARMS (elem);\n-\t\t    tree t = make_scratch_vec (n);\n-\t\t    int i;\n-\t\t    i = type_unification\n-\t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), t,\n-\t\t       TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t       TYPE_ARG_TYPES (lhstype), explicit_targs, 1, 1);\n-\t\t    if (i == 0)\n+\t\t    if (save_elem)\n \t\t      {\n-\t\t\tif (save_elem)\n-\t\t\t  {\n-\t\t\t    cp_error (\"ambiguous template instantiation converting to `%#T'\", lhstype);\n-\t\t\t    return error_mark_node;\n-\t\t\t  }\n-\t\t\tsave_elem = instantiate_template (elem, t);\n-\t\t\t/* Check the return type.  */\n-\t\t\tif (! comptypes (TREE_TYPE (lhstype),\n-\t\t\t\t\t TREE_TYPE (TREE_TYPE (save_elem)), 1))\n-\t\t\t  save_elem = 0;\n+\t\t\tcp_error (\"ambiguous template instantiation converting to `%#T'\", lhstype);\n+\t\t\treturn error_mark_node;\n \t\t      }\n+\t\t    save_elem = instantiate_template (elem, t);\n+\t\t    /* Check the return type.  */\n+\t\t    if (! comptypes (TREE_TYPE (lhstype),\n+\t\t\t\t     TREE_TYPE (TREE_TYPE (save_elem)), 1))\n+\t\t      save_elem = 0;\n \t\t  }\n-\t      if (save_elem)\n-\t\t{\n-\t\t  mark_used (save_elem);\n-\t\t  return save_elem;\n-\t\t}\n+\t      }\n+\t  if (save_elem)\n+\t    {\n+\t      mark_used (save_elem);\n+\t      return save_elem;\n \t    }\n+\t}\n \n-\t    /* If there are explicit_targs, only a template function\n-\t       can match.  */\n-\t    if (explicit_targs == NULL_TREE) \n+\t/* If there are explicit_targs, only a template function\n+\t   can match.  */\n+\tif (explicit_targs == NULL_TREE) \n+\t  {\n+\t    /* No match found, look for a compatible function.  */\n+\t    tree elems = rhs;\n+\t    elems = rhs;\n+\t    for (; elems; elems = OVL_NEXT (elems))\n \t      {\n-\t\t/* No match found, look for a compatible function.  */\n-\t\telem = get_first_fn (rhs);\n-\t\twhile (elem && comp_target_types (lhstype,\n-\t\t\t\t\t\t  TREE_TYPE (elem), 1) <= 0)\n-\t\t  elem = DECL_CHAIN (elem);\n-\t\tif (elem)\n+\t\telem = OVL_CURRENT (elems);\n+\t\tif (comp_target_types (lhstype, TREE_TYPE (elem), 1) > 0)\n+\t\t  break;\n+\t      }\n+\t    if (elems)\n+\t      {\n+\t\ttree save_elem = elem;\n+\t\tfor (elems = OVL_CHAIN (elems); elems; \n+\t\t     elems = OVL_CHAIN (elems))\n+\t\t  {\n+\t\t    elem = OVL_FUNCTION (elems);\n+\t\t    if (comp_target_types (lhstype, TREE_TYPE (elem), 0) > 0)\n+\t\t      break;\n+\t\t  }\n+\t\tif (elems)\n \t\t  {\n-\t\t    tree save_elem = elem;\n-\t\t    elem = DECL_CHAIN (elem);\n-\t\t    while (elem \n-\t\t\t   && comp_target_types (lhstype,\n-\t\t\t\t\t\t TREE_TYPE (elem), 0) <= 0)\n-\t\t      elem = DECL_CHAIN (elem);\n-\t\t    if (elem)\n+\t\t    if (complain)\n \t\t      {\n-\t\t\tif (complain)\n-\t\t\t  {\n-\t\t\t    cp_error \n-\t\t\t      (\"cannot resolve overload to target type `%#T'\",\n-\t\t\t       lhstype);\n-\t\t\t    cp_error_at (\"  ambiguity between `%#D'\",\n-\t\t\t\t\t save_elem); \n-\t\t\t    cp_error_at (\"  and `%#D', at least\", elem);\n-\t\t\t  }\n-\t\t\treturn error_mark_node;\n+\t\t\tcp_error \n+\t\t\t  (\"cannot resolve overload to target type `%#T'\",\n+\t\t\t   lhstype);\n+\t\t\tcp_error_at (\"  ambiguity between `%#D'\", save_elem); \n+\t\t\tcp_error_at (\"  and `%#D', at least\", elem);\n \t\t      }\n-\t\t    mark_used (save_elem);\n-\t\t    return save_elem;\n+\t\t    return error_mark_node;\n \t\t  }\n+\t\tmark_used (save_elem);\n+\t\treturn save_elem;\n \t      }\n-\t    if (complain)\n-\t      {\n-\t\tcp_error (\"cannot resolve overload to target type `%#T'\",\n-\t\t\t  lhstype);\n-\t\tcp_error \n-\t\t  (\"  because no suitable overload of function `%D' exists\",\n-\t\t   TREE_PURPOSE (rhs));\n-\t      }\n-\t    return error_mark_node;\n \t  }\n+\tif (complain)\n+\t  {\n+\t    cp_error (\"cannot resolve overload to target type `%#T'\", lhstype);\n+\t    cp_error \n+\t      (\"  because no suitable overload of function `%D' exists\",\n+\t       DECL_NAME (OVL_FUNCTION (rhs)));\n+\t  }\n+\treturn error_mark_node;\n+      }\n+\n+    case TREE_LIST:\n+      {\n+\ttree elem, baselink, name = NULL_TREE;\n+\n+\tif (TREE_PURPOSE (rhs) == error_mark_node)\n+\t{\n+\t  /* Make sure we don't drop the non-local flag, as the old code\n+\t     would rely on it. */\n+\t  int nl = TREE_NONLOCAL_FLAG (rhs);\n+\t  /* We don't need the type of this node. */\n+\t  rhs = TREE_VALUE (rhs);\n+\t  my_friendly_assert (TREE_NONLOCAL_FLAG (rhs) == nl, 980331);\n+\t}\n+\t/* Now we should have a baselink. */\n+\tmy_friendly_assert (TREE_CODE (TREE_PURPOSE (rhs)) == TREE_VEC, 980331);\n+\t/* First look for an exact match.  Search member functions.\n+\t   May have to undo what `default_conversion' might do to\n+\t   lhstype.  */\n+\n+\tlhstype = validate_lhs (lhstype, complain);\n+\tif (lhstype == error_mark_node)\n+\t  return lhstype;\n \n \tif (TREE_NONLOCAL_FLAG (rhs))\n \t  {\n+\t    my_friendly_abort (980401);\n \t    /* Got to get it as a baselink.  */\n \t    rhs = lookup_fnfields (TYPE_BINFO (current_class_type),\n-\t\t\t\t   TREE_PURPOSE (rhs), 0);\n+\t\t\t\t   DECL_NAME (OVL_FUNCTION (rhs)), 0);\n \t  }\n \telse\n \t  {\n \t    my_friendly_assert (TREE_CHAIN (rhs) == NULL_TREE, 181);\n-\t    if (TREE_CODE (TREE_VALUE (rhs)) == TREE_LIST)\n-\t      rhs = TREE_VALUE (rhs);\n-\t    my_friendly_assert (TREE_CODE (TREE_VALUE (rhs)) == FUNCTION_DECL,\n+\t    my_friendly_assert (TREE_CODE (TREE_VALUE (rhs)) == FUNCTION_DECL\n+\t\t\t\t|| TREE_CODE (TREE_VALUE (rhs)) == OVERLOAD,\n \t\t\t\t182);\n \t  }\n \n@@ -5215,30 +5248,31 @@ instantiate_type (lhstype, rhs, complain)\n \t  {\n \t    elem = TREE_VALUE (baselink);\n \t    while (elem)\n-\t      if (comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t      if (comptypes (lhstype, TREE_TYPE (OVL_CURRENT (elem)), 1))\n \t\t{\n-\t\t  mark_used (elem);\n-\t\t  return elem;\n+\t\t  mark_used (OVL_CURRENT (elem));\n+\t\t  return OVL_CURRENT (elem);\n \t\t}\n \t      else\n-\t\telem = DECL_CHAIN (elem);\n+\t\telem = OVL_NEXT (elem);\n \t  }\n \n \t/* No exact match found, look for a compatible method.  */\n \tfor (baselink = rhs; baselink;\n \t     baselink = next_baselink (baselink))\n \t  {\n \t    elem = TREE_VALUE (baselink);\n-\t    while (elem && comp_target_types (lhstype,\n-\t\t\t\t\t      TREE_TYPE (elem), 1) <= 0)\n-\t      elem = DECL_CHAIN (elem);\n+\t    for (; elem; elem = OVL_NEXT (elem))\n+\t      if (comp_target_types (lhstype, \n+\t\t\t\t     TREE_TYPE (OVL_CURRENT (elem)), 1) > 0)\n+\t\tbreak;\n \t    if (elem)\n \t      {\n-\t\ttree save_elem = elem;\n-\t\telem = DECL_CHAIN (elem);\n-\t\twhile (elem && comp_target_types (lhstype,\n-\t\t\t\t\t\t  TREE_TYPE (elem), 0) <= 0)\n-\t\t  elem = DECL_CHAIN (elem);\n+\t\ttree save_elem = OVL_CURRENT (elem);\n+\t\tfor (elem = OVL_NEXT (elem); elem; elem = OVL_NEXT (elem))\n+\t\t  if (comp_target_types (lhstype, \n+\t\t\t\t\t TREE_TYPE (OVL_CURRENT (elem)), 0) > 0)\n+\t\t    break;\n \t\tif (elem)\n \t\t  {\n \t\t    if (complain)\n@@ -5248,7 +5282,10 @@ instantiate_type (lhstype, rhs, complain)\n \t\tmark_used (save_elem);\n \t\treturn save_elem;\n \t      }\n-\t    name = DECL_NAME (TREE_VALUE (rhs));\n+\t    name = rhs;\n+\t    while (TREE_CODE (name) == TREE_LIST)\n+\t      name = TREE_VALUE (name);\n+\t    name = DECL_NAME (OVL_CURRENT (name));\n #if 0\n \t    if (TREE_CODE (lhstype) == FUNCTION_TYPE && globals < 0)\n \t      {"}, {"sha": "2124a04e69365e98a64a64476aaf5a8908289d7e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -166,10 +166,15 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n    the template will be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n-/* has two fields: scope and value */\n-/* XXX: could recycle some of the common fields */\n+/* An association between namespace and entity. Parameters are the\n+   scope and the (non-type) value.\n+   TREE_TYPE indicates the type bound to the name. */\n DEFTREECODE (CPLUS_BINDING, \"binding\", 'x', 2)\n \n+/* A list-like node for chaining overloading candidates. TREE_TYPE is \n+   the original name, and the parameter is the FUNCTION_DECL.  */\n+DEFTREECODE (OVERLOAD, \"overload\", 'x', 1)\n+\n /* A generic wrapper for something not tree that we want to include in\n    tree structure.  */\n DEFTREECODE (WRAPPER, \"wrapper\", 'x', 1)"}, {"sha": "9c90531eb609830e5dbd14e1186b6dd41a321b79", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -58,13 +58,23 @@ typedef struct\n   tree decl;\n } template_parm_index;\n \n-#define BINDING_SCOPE(NODE)\t(((struct tree_binding*)NODE)->scope)\n-#define BINDING_VALUE(NODE)\t(((struct tree_binding*)NODE)->value)\n-#define NAMESPACE_BINDING(ID,NS) BINDING_VALUE (binding_for_name (ID, NS))\n+/* For a binding between a name and an entity, defines the scope\n+   where the binding is declared. Currently always points to a\n+   namespace declaration.  */\n+#define BINDING_SCOPE(NODE)    (((struct tree_binding*)NODE)->scope)\n+/* This is the declaration bound to the name. Possible values:\n+   variable, overloaded function, namespace, template, enumerator.  */\n+#define BINDING_VALUE(NODE)    (((struct tree_binding*)NODE)->value)\n+/* If name is bound to a type, this is the type (struct, union, enum).  */\n+#define BINDING_TYPE(NODE)     TREE_TYPE(NODE)\n #define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n-  NAMESPACE_BINDING (NODE, global_namespace)\n+  namespace_binding (NODE, global_namespace)\n+#define SET_IDENTIFIER_GLOBAL_VALUE(NODE, VAL) \\\n+  set_namespace_binding (NODE, global_namespace, VAL)\n #define IDENTIFIER_NAMESPACE_VALUE(NODE) \\\n-  NAMESPACE_BINDING (NODE, current_namespace)\n+  namespace_binding (NODE, current_namespace)\n+#define SET_IDENTIFIER_NAMESPACE_VALUE(NODE, VAL) \\\n+  set_namespace_binding (NODE, current_namespace, VAL)\n \n struct tree_binding\n {\n@@ -73,6 +83,25 @@ struct tree_binding\n   tree value;\n };\n \n+/* The overloaded FUNCTION_DECL. */\n+#define OVL_FUNCTION(NODE)   (((struct tree_overload*)NODE)->function)\n+#define OVL_CHAIN(NODE)      TREE_CHAIN(NODE)\n+/* Polymorphic access to FUNCTION and CHAIN. */\n+#define OVL_CURRENT(NODE)     \\\n+  ((TREE_CODE(NODE)==OVERLOAD) ? OVL_FUNCTION(NODE) : NODE)\n+#define OVL_NEXT(NODE)        \\\n+  ((TREE_CODE(NODE)==OVERLOAD) ? TREE_CHAIN(NODE) : NULL_TREE)\n+/* If set, this was imported in a using declaration.\n+   This is not to confuse with being used somewhere, which\n+   is not important for this node. */\n+#define OVL_USED(NODE)        TREE_USED(NODE)\n+\n+struct tree_overload\n+{\n+  char common[sizeof (struct tree_common)];\n+  tree function;\n+};\n+\n #define WRAPPER_PTR(NODE) (((struct tree_wrapper*)NODE)->u.ptr)\n #define WRAPPER_INT(NODE) (((struct tree_wrapper*)NODE)->u.i)\n \n@@ -100,9 +129,14 @@ struct tree_wrapper\n #define IDENTIFIER_TEMPLATE(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->class_template_info)\n \n-#define IDENTIFIER_TYPE_VALUE(NODE) (TREE_TYPE (NODE))\n+/* TREE_TYPE only indicates on local and class scope the current\n+   type. For namespace scope, the presence of a type in any namespace\n+   is indicated with global_type_node, and the real type behind must\n+   be found through lookup. */\n+#define IDENTIFIER_TYPE_VALUE(NODE) (identifier_type_value(NODE))\n+#define REAL_IDENTIFIER_TYPE_VALUE(NODE) (TREE_TYPE (NODE))\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = TYPE)\n-#define IDENTIFIER_HAS_TYPE_VALUE(NODE) (TREE_TYPE (NODE) ? 1 : 0)\n+#define IDENTIFIER_HAS_TYPE_VALUE(NODE) (IDENTIFIER_TYPE_VALUE (NODE) ? 1 : 0)\n \n #define LANG_ID_FIELD(NAME,NODE) \\\n   (((struct lang_identifier *)(NODE))->x \\\n@@ -950,7 +984,6 @@ struct lang_decl_flags\n   tree memfunc_pointer_to;\n   tree template_info;\n   struct binding_level *level;\n-  tree in_namespace;\n };\n \n struct lang_decl\n@@ -959,7 +992,6 @@ struct lang_decl\n \n   tree main_decl_variant;\n   struct pending_inline *pending_inline_info;\n-  tree chain;\n };\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n@@ -1065,21 +1097,13 @@ struct lang_decl\n   ((TREE_CODE (NODE) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (NODE)) \\\n    ? DECL_CLASS_CONTEXT (NODE) : DECL_CONTEXT (NODE))\n \n-/* For a FUNCTION_DECL: the chain through which the next method\n-   with the same name is found.  We now use TREE_CHAIN to\n-   walk through the methods in order of declaration.  \n-   For a NAMESPACE_DECL: the list of using namespace directives\n+/* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n-   that is the common ancestor */\n-#if 1\n-#define DECL_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n-#else\n-#define DECL_CHAIN(NODE) (TREE_CHAIN (NODE))\n-#endif\n-#define DECL_NAMESPACE_USING(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n+   that is the common ancestor. */\n+#define DECL_NAMESPACE_USING(NODE) DECL_VINDEX(NODE)\n \n /* In a NAMESPACE_DECL, the DECL_INITIAL is used to record all users\n-   of a namespace, to record the transitive closure of using namespace */\n+   of a namespace, to record the transitive closure of using namespace. */\n #define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NODE)\n \n /* In a TREE_LIST concatenating using directives, indicate indirekt\n@@ -1494,12 +1518,6 @@ extern int flag_new_for_scope;\n #define DECL_REALLY_EXTERN(NODE) \\\n   (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))\n \n-/* Records the namespace we are in */\n-#define DECL_NAMESPACE(NODE) \\\n-     (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->decl_flags.in_namespace : 0)\n-#define SET_DECL_NAMESPACE(NODE, val) \\\n-     DECL_LANG_SPECIFIC (NODE)->decl_flags.in_namespace = val\n-\n /* Used to tell cp_finish_decl that it should approximate comdat linkage\n    as best it can for this decl.  */\n #define DECL_COMDAT(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.comdat)\n@@ -1952,6 +1970,10 @@ extern int flag_weak;\n \n extern int flag_new_abi;\n \n+/* Nonzero to not ignore namespace std. */\n+\n+extern int flag_honor_std;\n+\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n extern int at_eof;\n@@ -2153,6 +2175,7 @@ extern void pop_namespace\t\t\tPROTO((void));\n extern void maybe_push_to_top_level\t\tPROTO((int));\n extern void push_to_top_level\t\t\tPROTO((void));\n extern void pop_from_top_level\t\t\tPROTO((void));\n+extern tree identifier_type_value\t\tPROTO((tree));\n extern void set_identifier_type_value\t\tPROTO((tree, tree));\n extern void pop_everything\t\t\tPROTO((void));\n extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n@@ -2166,8 +2189,9 @@ extern tree pushdecl_class_level\t\tPROTO((tree));\n #if 0\n extern void pushdecl_nonclass_level\t\tPROTO((tree));\n #endif\n+extern tree pushdecl_namespace_level            PROTO((tree));\n+extern tree push_using_decl                     PROTO((tree, tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n-extern int overloaded_globals_p\t\t\tPROTO((tree));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n extern tree lookup_label\t\t\tPROTO((tree));\n extern tree shadow_label\t\t\tPROTO((tree));\n@@ -2181,13 +2205,16 @@ extern tree gettags\t\t\t\tPROTO((void));\n extern void set_current_level_tags_transparency\tPROTO((int));\n #endif\n extern tree binding_for_name                    PROTO((tree, tree));\n+extern tree namespace_binding                   PROTO((tree, tree));\n+extern void set_namespace_binding               PROTO((tree, tree, tree));\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n extern tree make_typename_type\t\t\tPROTO((tree, tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n+extern tree lookup_function_nonclass            PROTO((tree, tree));\n extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n-extern tree lookup_using_namespace              PROTO((tree,tree,tree,tree));\n-extern tree qualified_lookup_using_namespace    PROTO((tree,tree));\n+extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree));\n+extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));\n@@ -2234,6 +2261,7 @@ extern int in_function_p\t\t\tPROTO((void));\n extern void replace_defarg\t\t\tPROTO((tree, tree));\n extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n+extern void cat_namespace_levels                PROTO((void));\n \n /* in decl2.c */\n extern int flag_assume_nonnull_objects;\n@@ -2281,15 +2309,18 @@ extern tree build_expr_from_tree\t\tPROTO((tree));\n extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree check_cp_case_value\t\t\tPROTO((tree));\n-extern tree get_namespace_id\t\t\tPROTO((void));\n-extern tree current_namespace_id\t\tPROTO((tree));\n+extern void set_decl_namespace                  PROTO((tree, tree));\n+extern tree current_decl_namespace              PROTO((void));\n+extern void push_decl_namespace                 PROTO((tree));\n+extern void pop_decl_namespace                  PROTO((void));\n extern void do_namespace_alias\t\t\tPROTO((tree, tree));\n extern void do_toplevel_using_decl\t\tPROTO((tree));\n extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern void do_using_directive\t\t\tPROTO((tree));\n extern void check_default_args\t\t\tPROTO((tree));\n extern void mark_used\t\t\t\tPROTO((tree));\n extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n+extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n \n /* in errfn.c */\n extern void cp_error\t\t\t\t();\n@@ -2636,10 +2667,14 @@ extern tree get_decl_list\t\t\tPROTO((tree));\n extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n extern tree reverse_path\t\t\tPROTO((tree));\n-extern int decl_list_length\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));\n+extern tree binding_init                        PROTO((struct tree_binding*));\n+extern tree ovl_cons                            PROTO((tree, tree));\n+extern tree scratch_ovl_cons                    PROTO((tree, tree));\n+extern int ovl_member                           PROTO((tree, tree));\n+extern tree build_overload                      PROTO((tree, tree));\n extern tree fnaddr_from_vtable_entry\t\tPROTO((tree));\n extern tree function_arg_chain\t\t\tPROTO((tree));\n extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n@@ -2674,6 +2709,7 @@ extern void push_expression_obstack\t\tPROTO((void));\n #define scratch_tree_cons expr_tree_cons\n #define build_scratch_list build_expr_list\n #define make_scratch_vec make_temp_vec\n+#define push_scratch_obstack push_expression_obstack\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "c73bea15111bbd31b6a872106174f14bd2dc6a79", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 510, "deletions": 337, "changes": 847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -160,9 +160,9 @@ static tree lookup_name_real PROTO((tree, int, int));\n static void warn_extern_redeclared_static PROTO((tree, tree));\n static void grok_reference_init PROTO((tree, tree, tree));\n static tree grokfndecl PROTO((tree, tree, tree, tree, int,\n-\t\t\t      enum overload_flags,\n-\t\t\t      tree, tree, tree, int, int, int, int, int, int));\n-static tree grokvardecl PROTO((tree, tree, RID_BIT_TYPE *, int, int));\n+\t\t\t      enum overload_flags, tree,\n+\t\t\t      tree, tree, int, int, int, int, int, int, tree));\n+static tree grokvardecl PROTO((tree, tree, RID_BIT_TYPE *, int, int, tree));\n static tree lookup_tag PROTO((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n@@ -176,7 +176,7 @@ static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n static void indent PROTO((void));\n #endif\n \n-/* a node which has tree code ERROR_MARK, and whose type is itself.\n+/* A node which has tree code ERROR_MARK, and whose type is itself.\n    All erroneous expressions are replaced with this node.  All functions\n    that accept nodes as arguments should avoid generating error messages\n    if this node is one of the arguments, since it is undesirable to get\n@@ -231,7 +231,7 @@ tree unsigned_intSI_type_node;\n tree unsigned_intDI_type_node;\n tree unsigned_intTI_type_node;\n \n-/* a VOID_TYPE node, and the same, packaged in a TREE_LIST.  */\n+/* A VOID_TYPE node, and the same, packaged in a TREE_LIST.  */\n \n tree void_type_node, void_list_node;\n tree void_zero_node;\n@@ -263,11 +263,11 @@ tree wchar_array_type_node;\n /* The bool data type, and constants */\n tree boolean_type_node, boolean_true_node, boolean_false_node;\n \n-/* type `int ()' -- used for implicit declaration of functions.  */\n+/* Type `int ()' -- used for implicit declaration of functions.  */\n \n tree default_function_type;\n \n-/* function types `double (double)' and `double (double, double)', etc.  */\n+/* Function types `double (double)' and `double (double, double)', etc.  */\n \n static tree double_ftype_double, double_ftype_double_double;\n static tree int_ftype_int, long_ftype_long;\n@@ -301,6 +301,11 @@ tree __ptr_desc_array_type, __attr_dec_array_type, __func_desc_array_type;\n tree __ptmf_desc_array_type, __ptmd_desc_array_type;\n #endif\n \n+/* Indicates that there is a type value in some namespace, although\n+   that is not necessarily in scope at the moment. */\n+\n+static tree global_type_node;\n+\n tree class_star_type_node;\n tree class_type_node, record_type_node, union_type_node, enum_type_node;\n tree unknown_type_node;\n@@ -312,6 +317,7 @@ tree vtbl_type_node;\n \n /* namespace std */\n tree std_node;\n+int in_std = 0;\n \n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n@@ -589,6 +595,9 @@ struct binding_level\n        component_bindings.  */\n     tree tags;\n \n+    /* A list of USING_DECL nodes. */\n+    tree usings;\n+\n     /* For each level, a list of shadowed outer-level local definitions\n        to be restored when this level is popped.\n        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n@@ -747,7 +756,7 @@ pop_binding_level ()\n \n   if (global_binding_level)\n     {\n-      /* cannot pop a level, if there are none left to pop.  */\n+      /* Cannot pop a level, if there are none left to pop.  */\n       if (current_binding_level == global_binding_level)\n \tmy_friendly_abort (123);\n     }\n@@ -791,7 +800,7 @@ suspend_binding_level ()\n \n   if (global_binding_level)\n     {\n-      /* cannot suspend a level, if there are none left to suspend.  */\n+      /* Cannot suspend a level, if there are none left to suspend.  */\n       if (current_binding_level == global_binding_level)\n \tmy_friendly_abort (123);\n     }\n@@ -823,29 +832,11 @@ static void\n resume_binding_level (b)\n      struct binding_level *b;\n {\n-  if (class_binding_level)\n-    {\n-#if 1\n-      /* These are here because we cannot deal with shadows yet.  */\n-      sorry (\"cannot resume a namespace inside class\");\n-      return;\n-#else\n-      b->level_chain = class_binding_level;\n-      class_binding_level = (struct binding_level *)0;\n-#endif\n-    }\n-  else\n-    {\n-#if 1\n-      /* These are here because we cannot deal with shadows yet.  */\n-      if (b->level_chain != current_binding_level)\n-\t{\n-\t  sorry (\"cannot resume a namespace inside a different namespace\");\n-\t  return;\n-\t}\n-#endif\n-      b->level_chain = current_binding_level;\n-    }\n+  /* Resuming binding levels is meant only for namespaces,\n+     and those cannot nest into classes. */\n+  my_friendly_assert(!class_binding_level, 386);\n+  /* Also, resuming a non-directly nested namespace is a no-no.  */\n+  my_friendly_assert(b->level_chain == current_binding_level, 386);\n   current_binding_level = b;\n #if defined(DEBUG_CP_BINDING_LEVELS)\n   b->binding_depth = binding_depth;\n@@ -877,23 +868,15 @@ global_bindings_p ()\n \n /* Nonzero if we are currently in a toplevel binding level.  This\n    means either the global binding level or a namespace in a toplevel\n-   binding level.  */\n+   binding level.\n+   Since there are no non-toplevel namespace levels, this really\n+   means any namespace or pseudo-global level.  */\n \n int\n toplevel_bindings_p ()\n {\n-  struct binding_level *b = current_binding_level;\n-\n-  while (1)\n-    {\n-      if (b == global_binding_level)\n-\treturn 1;\n-      if (b->pseudo_global)\n-\treturn 1;\n-      if (! b->namespace_p)\n-\treturn 0;\n-      b=b->level_chain;\n-    }\n+  return current_binding_level->namespace_p \n+    || current_binding_level->pseudo_global;\n }\n \n /* Nonzero if this is a namespace scope.  */\n@@ -1229,7 +1212,7 @@ poplevel (keep, reverse, functionbody)\n \tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n       for (link = current_binding_level->type_shadowed;\n \t   link; link = TREE_CHAIN (link))\n-\tIDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n     }\n \n   /* If the level being exited is the top level of a function,\n@@ -1333,35 +1316,6 @@ poplevel (keep, reverse, functionbody)\n   return block;\n }\n \n-/* Resume a binding level for a namespace.  */\n-\n-void\n-resume_level (b)\n-     struct binding_level *b;\n-{\n-  tree decls, link;\n-\n-  resume_binding_level (b);\n-\n-  /* Resume the variable caches.  */\n-  decls = current_binding_level->names;\n-\n-  /* Restore the meanings of the local variables of this level.  */\n-\n-  for (link = decls; link; link = TREE_CHAIN (link))\n-    {\n-      /* If it doesn't have a name, there is nothing left to do with it.  */\n-      if (DECL_NAME (link) == NULL_TREE)\n-\tcontinue;\n-\n-      IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = link;\n-\n-      /* If this is a TYPE_DECL, push it into the type value slot.  */\n-      if (TREE_CODE (link) == TYPE_DECL)\n-\tSET_IDENTIFIER_TYPE_VALUE (DECL_NAME (link), TREE_TYPE (link));\n-    }\n-}\n-\n /* Delete the node BLOCK from the current binding level.\n    This is used for the block inside a stmt expr ({...})\n    so that the block can be reinserted where appropriate.  */\n@@ -1486,7 +1440,7 @@ poplevel_class (force)\n   for (shadowed = level->type_shadowed;\n        shadowed;\n        shadowed = TREE_CHAIN (shadowed))\n-    IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed)) = TREE_VALUE (shadowed);\n+    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n \n   GNU_xref_end_scope ((HOST_WIDE_INT) class_binding_level,\n \t\t      (HOST_WIDE_INT) class_binding_level->level_chain,\n@@ -1665,32 +1619,114 @@ print_binding_stack ()\n   print_binding_level (global_binding_level);\n }\n \n-/* Return the tree_binding for the name in the given scope\n-   If there are no bindings for the name in the scope, make a new\n-   bindings node. This bindings list of this node will be empty, though.  */\n+/* Namespace binding access routines: The namespace_bindings field of\n+   the identifier is polymorphic, with three possible values:\n+   NULL_TREE, a list of CPLUS_BINDINGS, or any other tree_node\n+   indicating the BINDING_VALUE of global_namespace. */\n \n-tree\n-binding_for_name (name, scope)\n+/* Check whether the a binding for the name to scope is known.\n+   Assumes that the bindings of the name are already a list\n+   of bindings. Returns the binding found, or NULL_TREE. */\n+\n+static tree\n+find_binding (name, scope)\n      tree name;\n      tree scope;\n {\n-  tree iter;\n+  tree iter, prev = NULL_TREE;\n   for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n        iter = TREE_CHAIN (iter))\n     {\n       my_friendly_assert (TREE_CODE (iter) == CPLUS_BINDING, 374);\n       if (BINDING_SCOPE (iter) == scope)\n-\treturn iter;\n+\t{\n+\t  /* Move binding found to the fron of the list, so\n+             subsequent lookups will find it faster. */\n+\t  if (prev)\n+\t    {\n+\t      TREE_CHAIN (prev) = TREE_CHAIN (iter);\n+\t      TREE_CHAIN (iter) = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+\t      IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n+\t    }\n+\t  return iter;\n+\t}\n+      prev = iter;\n     }\n-  /* not found, make a new permanent one */\n+  return NULL_TREE;\n+}\n+\n+/* Always returns a binding for name in scope. If the\n+   namespace_bindings is not a list, convert it to one first.\n+   If no binding is found, make a new one. */\n+\n+tree\n+binding_for_name (name, scope)\n+     tree name;\n+     tree scope;\n+{\n+  tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  tree result;\n+  if (b && TREE_CODE (b) != CPLUS_BINDING)\n+    {\n+      /* Get rid of optimization for global scope. */\n+      IDENTIFIER_NAMESPACE_BINDINGS (name) = NULL_TREE;\n+      BINDING_VALUE (binding_for_name (name, global_namespace)) = b;\n+      b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+    }\n+  if (b && (result = find_binding (name, scope)))\n+    return result;\n+  /* Not found, make a new permanent one. */\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n-  iter = make_node (CPLUS_BINDING);\n-  TREE_CHAIN (iter) = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n-  BINDING_SCOPE (iter) = scope;\n-  BINDING_VALUE (iter) = NULL_TREE;\n+  result = make_node (CPLUS_BINDING);\n+  TREE_CHAIN (result) = b;\n+  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n+  BINDING_SCOPE (result) = scope;\n+  BINDING_TYPE (result) = NULL_TREE;\n+  BINDING_VALUE (result) = NULL_TREE;\n   pop_obstacks ();\n-  return iter;\n+  return result;\n+}\n+\n+/* Return the binding value for name in scope, considering that\n+   namespace_binding may or may not be a list of CPLUS_BINDINGS. */\n+\n+tree\n+namespace_binding (name, scope)\n+     tree name;\n+     tree scope;\n+{\n+  tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  if (b == NULL_TREE)\n+    return NULL_TREE;\n+  if (TREE_CODE (b) != CPLUS_BINDING)\n+    return (scope == global_namespace) ? b : NULL_TREE;\n+  name = find_binding (name,scope);\n+  if (name == NULL_TREE)\n+    return name;\n+  return BINDING_VALUE (name);\n+}\n+\n+/* Set the binding value for name in scope. If modifying the binding\n+   of global_namespace is attempted, try to optimize it. */\n+\n+void\n+set_namespace_binding (name, scope, val)\n+     tree name;\n+     tree scope;\n+     tree val;\n+{\n+  tree b;\n+  if (scope == global_namespace)\n+    {\n+      b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+      if (b == NULL_TREE || TREE_CODE (b) != CPLUS_BINDING)\n+\t{\n+\t  IDENTIFIER_NAMESPACE_BINDINGS (name) = val;\n+\t  return;\n+\t}\n+    }\n+  b = binding_for_name (name, scope);\n+  BINDING_VALUE (b) = val;\n }\n \n extern char * first_global_object_name;\n@@ -1744,132 +1780,100 @@ void\n push_namespace (name)\n      tree name;\n {\n-#if 1\n   tree d;\n   int need_new = 1;\n   int implicit_use = 0;\n-  int nodecl = 0;\n+  int global = 0;\n   if (!global_namespace)\n     {\n-      /* this must be :: */\n+      /* This must be ::. */\n       my_friendly_assert (name == get_identifier (\"::\"), 377);\n-      nodecl = 1;\n+      global = 1;\n     }\n   else if (!name)\n     {\n       name = get_unique_name ();\n       implicit_use = 1;\n-    } \n+    }\n+  else if (current_namespace == global_namespace\n+\t   && name == DECL_NAME (std_node))\n+    {\n+      in_std++;\n+      return;\n+    }\n   else\n     {\n-      /* check whether this is an extended namespace definition */\n+      /* Check whether this is an extended namespace definition. */\n       d = IDENTIFIER_NAMESPACE_VALUE (name);\n       if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n \tneed_new = 0;\n     }\n   \n   if (need_new)\n     {\n-      /* make a new namespace, binding the name to it */\n-      d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-      if (!nodecl)\n-\td = pushdecl (d);\n+      /* Make a new namespace, binding the name to it. */\n+      d = build_lang_decl (NAMESPACE_DECL, name, NULL_TREE);\n+      /* The global namespace is not pushed, and the global binding\n+\t level is set elsewhere.  */\n+      if (!global)\n+\t{\n+\t  d = pushdecl (d);\n+\t  pushlevel (0);\n+\t  declare_namespace_level ();\n+\t  NAMESPACE_LEVEL (d) = current_binding_level;\n+\t}\n     }\n+  else\n+    resume_binding_level (NAMESPACE_LEVEL (d));\n+\n   if (implicit_use)\n     do_using_directive (d);\n-  /* enter the name space */\n+  /* Enter the name space. */\n   current_namespace = d;\n-\n-#else\n-  tree old_id = get_namespace_id ();\n-  char *buf;\n-  tree d;\n-\n-  if (! name)\n-    {\n-      /* Create a truly ugly name! */\n-      name = get_unique_name ();\n-    }\n-\n-  d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-\n-  /* Mark them as external, so redeclaration_error_message doesn't think\n-     they are duplicates.  */\n-\n-  DECL_EXTERNAL (d) = 1;\n-  d = pushdecl (d);\n-\n-  if (NAMESPACE_LEVEL (d) == 0)\n-    {\n-      /* This is new for this compilation unit.  */\n-      pushlevel (0);\n-      declare_namespace_level ();\n-      NAMESPACE_LEVEL (d) = current_binding_level;\n-    }\n-  else\n-    resume_level (NAMESPACE_LEVEL (d));\n-\n-  /* This code is just is bit old now...  */ \n-  current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n-  buf = (char *) alloca (4 + (old_id ? IDENTIFIER_LENGTH (old_id) : 0)\n-\t\t\t + IDENTIFIER_LENGTH (name));\n-  sprintf (buf, \"%s%s\", old_id ? IDENTIFIER_POINTER (old_id) : \"\",\n-\t   IDENTIFIER_POINTER (name));\n-  TREE_PURPOSE (current_namespace) = get_identifier (buf);\n-#endif\n }\n \n /* Pop from the scope of the current namespace.  */\n \n void\n pop_namespace ()\n {\n-#if 1\n-  current_namespace = DECL_NAMESPACE (current_namespace);\n-#else\n-  tree decls, link;\n-  current_namespace = TREE_CHAIN (current_namespace);\n-\n-  /* Just in case we get out of sync.  */\n-  if (! namespace_bindings_p ())\n-    poplevel (0, 0, 0);\n+  if (current_namespace == global_namespace)\n+    {\n+      my_friendly_assert (in_std>0, 980421);\n+      in_std--;\n+      return;\n+    }\n+  current_namespace = DECL_CONTEXT (current_namespace);\n+  /* The binding level is not popped, as it might be re-opened later.  */\n+  suspend_binding_level ();\n+}\n \n-  decls = current_binding_level->names;\n+/* Concatenate the binding levels of all namespaces. */\n \n-  /* Clear out the meanings of the local variables of this level.  */\n+void\n+cat_namespace_levels()\n+{\n+  tree current;\n+  tree last;\n+  struct binding_level *b;\n \n-  for (link = decls; link; link = TREE_CHAIN (link))\n+  last = NAMESPACE_LEVEL (global_namespace) -> names;\n+  /* The nested namespaces appear in the names list of their ancestors. */\n+  for (current = last; current; current = TREE_CHAIN (current))\n     {\n-      if (DECL_NAME (link) != NULL_TREE)\n+      if (TREE_CODE (current) != NAMESPACE_DECL)\n+\tcontinue;\n+      if (!DECL_LANG_SPECIFIC (current))\n \t{\n-\t  /* If the ident. was used or addressed via a local extern decl,\n-\t     don't forget that fact.  */\n-\t  if (DECL_EXTERNAL (link))\n-\t    {\n-\t      if (TREE_USED (link))\n-\t\tTREE_USED (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t      if (TREE_ADDRESSABLE (link))\n-\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t    }\n-\t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n+\t  /* Hmm. std. */\n+\t  my_friendly_assert (current == std_node, 393);\n+\t  continue;\n \t}\n+      b = NAMESPACE_LEVEL (current);\n+      while (TREE_CHAIN (last))\n+\tlast = TREE_CHAIN (last);\n+      TREE_CHAIN (last) = NAMESPACE_LEVEL (current) -> names;\n     }\n-\n-  /* Restore all name-meanings of the outer levels\n-     that were shadowed by this level.  */\n-\n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->class_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->type_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-\n-  /* suspend a level.  */\n-  suspend_binding_level ();\n-#endif\n }\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n@@ -1880,6 +1884,7 @@ pop_namespace ()\n struct saved_scope {\n   struct binding_level *old_binding_level;\n   tree old_bindings;\n+  tree old_namespace;\n   struct saved_scope *prev;\n   tree class_name, class_type, function_decl;\n   struct binding_level *class_bindings;\n@@ -1935,7 +1940,7 @@ store_bindings (names, old_bindings)\n \t{\n \t  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n \t  TREE_VEC_ELT (binding, 0) = id;\n-\t  TREE_VEC_ELT (binding, 1) = IDENTIFIER_TYPE_VALUE (id);\n+\t  TREE_VEC_ELT (binding, 1) = REAL_IDENTIFIER_TYPE_VALUE (id);\n \t  TREE_VEC_ELT (binding, 2) = IDENTIFIER_LOCAL_VALUE (id);\n \t  TREE_VEC_ELT (binding, 3) = IDENTIFIER_CLASS_VALUE (id);\n \t  IDENTIFIER_LOCAL_VALUE (id) = NULL_TREE;\n@@ -1971,6 +1976,10 @@ maybe_push_to_top_level (pseudo)\n     {\n       tree t;\n \n+      /* Template IDs are inserted into the global level. If they were\n+\t inserted into namespace level, finish_file wouldn't find them\n+\t when doing pending instantiations. Therefore, don't stop at\n+\t namespace level, but continue until :: .  */\n       if (b == global_binding_level || (pseudo && b->pseudo_global))\n \tbreak;\n \n@@ -1988,6 +1997,7 @@ maybe_push_to_top_level (pseudo)\n   s->old_binding_level = current_binding_level;\n   current_binding_level = b;\n \n+  s->old_namespace = current_namespace;\n   s->class_name = current_class_name;\n   s->class_type = current_class_type;\n   s->function_decl = current_function_decl;\n@@ -2020,6 +2030,7 @@ maybe_push_to_top_level (pseudo)\n   processing_explicit_instantiation = 0;\n   current_template_parms = NULL_TREE;\n   processing_template_decl = 0;\n+  current_namespace = global_namespace;\n \n   s->prev = current_saved_scope;\n   s->old_bindings = old_bindings;\n@@ -2058,14 +2069,15 @@ pop_from_top_level ()\n       tree id = TREE_VEC_ELT (t, 0);\n       if (id)\n \t{\n-\t  IDENTIFIER_TYPE_VALUE (id) = TREE_VEC_ELT (t, 1);\n+\t  SET_IDENTIFIER_TYPE_VALUE (id, TREE_VEC_ELT (t, 1));\n \t  IDENTIFIER_LOCAL_VALUE (id) = TREE_VEC_ELT (t, 2);\n \t  IDENTIFIER_CLASS_VALUE (id) = TREE_VEC_ELT (t, 3);\n \t}\n       t = TREE_CHAIN (t);\n       TREE_CHAIN (save) = free_binding_vecs;\n       free_binding_vecs = save;\n     }\n+  current_namespace = s->old_namespace;\n   current_class_name = s->class_name;\n   current_class_type = s->class_type;\n   current_function_decl = s->function_decl;\n@@ -2113,12 +2125,21 @@ set_identifier_type_value_with_scope (id, type, b)\n      tree type;\n      struct binding_level *b;\n {\n-  if (b != global_binding_level)\n+  if (!b->namespace_p)\n     {\n-      tree old_type_value = IDENTIFIER_TYPE_VALUE (id);\n+      /* Shadow the marker, not the real thing, so that the marker\n+\t gets restored later. */\n+      tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n       b->type_shadowed\n \t= tree_cons (id, old_type_value, b->type_shadowed);\n     }\n+  else\n+    {\n+      tree binding = binding_for_name (id, current_namespace);\n+      BINDING_TYPE (binding) = type;\n+      /* Store marker instead of real type. */\n+      type = global_type_node;\n+    }\n   SET_IDENTIFIER_TYPE_VALUE (id, type);\n }\n \n@@ -2132,6 +2153,26 @@ set_identifier_type_value (id, type)\n   set_identifier_type_value_with_scope (id, type, inner_binding_level);\n }\n \n+/* Return the type associated with id. */\n+\n+tree\n+identifier_type_value (id)\n+     tree id;\n+{\n+  /* There is no type with that name, anywhere. */\n+  if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n+    return NULL_TREE;\n+  /* This is not the type marker, but the real thing. */\n+  if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n+    return REAL_IDENTIFIER_TYPE_VALUE (id);\n+  /* Have to search for it. It must be on the global level, now.\n+     Ask lookup_name not to return non-types. */\n+  id = lookup_name_real (id, 2, 1);\n+  if (id)\n+    return TREE_TYPE (id);\n+  return NULL_TREE;\n+}\n+\n /* Pop off extraneous binding levels left over due to syntax errors.\n \n    We don't pop past namespaces, as they might be valid.  */\n@@ -2198,6 +2239,9 @@ pushtag (name, type, globalize)\n \tc_decl = TREE_CODE (context) == FUNCTION_DECL\n \t  ? context : TYPE_MAIN_DECL (context);\n \n+      if (!context)\n+\tcontext = current_namespace;\n+\n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n@@ -2683,7 +2727,7 @@ duplicate_decls (newdecl, olddecl)\n \t  cp_error (errmsg, newdecl);\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n \t    cp_error_at ((DECL_INITIAL (olddecl)\n-\t\t\t  && current_binding_level == global_binding_level)\n+\t\t\t  && namespace_bindings_p ())\n \t\t\t ? \"`%#D' previously defined here\"\n \t\t\t : \"`%#D' previously declared here\", olddecl);\n \t}\n@@ -2783,8 +2827,6 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n       if (DECL_CLASS_CONTEXT (olddecl))\n \tDECL_CLASS_CONTEXT (newdecl) = DECL_CLASS_CONTEXT (olddecl);\n-      if (DECL_CHAIN (newdecl) == NULL_TREE)\n-\tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n       if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n       DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);\n@@ -3048,8 +3090,6 @@ duplicate_decls (newdecl, olddecl)\n     {\n       DECL_TEMPLATE_SPECIALIZATIONS (newdecl)\n \t= DECL_TEMPLATE_SPECIALIZATIONS (olddecl);\n-      if (DECL_CHAIN (newdecl) == NULL_TREE)\n-\tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n     }\n \n   /* Now preserve various other info from the definition.  */\n@@ -3189,14 +3229,15 @@ pushdecl (x)\n   register tree name = DECL_ASSEMBLER_NAME (x);\n   register struct binding_level *b = current_binding_level;\n \n-  if (x != current_function_decl\n+  if (current_function_decl && x != current_function_decl\n+      /* A local declaration for a function doesn't constitute nesting.  */\n+      && (TREE_CODE (x) != FUNCTION_DECL || DECL_INITIAL (x))\n       /* Don't change DECL_CONTEXT of virtual methods.  */\n       && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n       && ! DECL_CONTEXT (x))\n     DECL_CONTEXT (x) = current_function_decl;\n-  /* A local declaration for a function doesn't constitute nesting.  */\n-  if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0)\n-    DECL_CONTEXT (x) = 0;\n+  if (!DECL_CONTEXT (x))\n+    DECL_CONTEXT (x) = current_namespace;\n \n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use.  */\n@@ -3215,7 +3256,12 @@ pushdecl (x)\n       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \tname = TREE_OPERAND (name, 0);\n       \n-      t = lookup_name_current_level (name);\n+      /* Namespace-scoped variables are not found in the current level. */\n+      if (TREE_CODE (x) == VAR_DECL\n+\t  && TREE_CODE (DECL_CONTEXT (x)) == NAMESPACE_DECL)\n+\tt = namespace_binding (name, DECL_CONTEXT (x));\n+      else\n+\tt = lookup_name_current_level (name);\n       if (t == error_mark_node)\n \t{\n \t  /* error_mark_node is 0 for a while during initialization!  */\n@@ -3243,7 +3289,7 @@ pushdecl (x)\n \t  else if (((TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c)\n \t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n \t\t   && is_overloaded_fn (t))\n-\t    /* don't do anything just yet */;\n+\t    /* Don't do anything just yet. */;\n \t  else if (t == wchar_decl_node)\n \t    {\n \t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n@@ -3321,7 +3367,8 @@ pushdecl (x)\n \t  if (t != x || DECL_LANGUAGE (x) == lang_c)\n \t    return t;\n \t}\n-      else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_CONTEXT (x) == NULL_TREE)\n+      else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_CONTEXT (x)\n+\t       && TREE_CODE (DECL_CONTEXT (x)) == NAMESPACE_DECL)\n \treturn push_overloaded_decl (x, 0);\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n@@ -3380,7 +3427,7 @@ pushdecl (x)\n \n       /* This name is new in its binding level.\n \t Install the new declaration and return it.  */\n-      if (b == global_binding_level)\n+      if (namespace_bindings_p ())\n \t{\n \t  /* Install a global value.  */\n \t  tree bindings = binding_for_name (name, current_namespace);\n@@ -3585,15 +3632,17 @@ pushdecl_with_scope (x, level)\n   return x;\n }\n \n-/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,\n+/* Like pushdecl, only it places X in the current namespace,\n    if appropriate.  */\n \n tree\n-pushdecl_top_level (x)\n+pushdecl_namespace_level (x)\n      tree x;\n {\n   register struct binding_level *b = inner_binding_level;\n-  register tree t = pushdecl_with_scope (x, global_binding_level);\n+  register tree t;\n+\n+  t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n      what we want.  */\n@@ -3629,6 +3678,20 @@ pushdecl_top_level (x)\n   return t;\n }\n \n+/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,\n+   if appropriate.  */\n+\n+tree\n+pushdecl_top_level (x)\n+     tree x;\n+{\n+  tree cur_namespace = current_namespace;\n+  current_namespace = global_namespace;\n+  x = pushdecl_namespace_level (x);\n+  current_namespace = cur_namespace;\n+  return x;\n+}\n+\n /* Like push_overloaded_decl, only it places X in GLOBAL_BINDING_LEVEL,\n    if appropriate.  */\n \n@@ -3734,23 +3797,35 @@ push_class_level_binding (name, x)\n   obstack_ptr_grow (&decl_obstack, x);\n }\n \n-/* Tell caller how to interpret a TREE_LIST which contains\n-   chains of FUNCTION_DECLS.  */\n+/* Insert another USING_DECL into the current binding level,\n+   returning this declaration. If this is a redeclaration,\n+   do nothing and return NULL_TREE.  */\n \n-int\n-overloaded_globals_p (list)\n-     tree list;\n+tree\n+push_using_decl (scope, name)\n+     tree scope;\n+     tree name;\n {\n-  my_friendly_assert (TREE_CODE (list) == TREE_LIST, 142);\n+  tree decl;\n+  \n+  if (!toplevel_bindings_p ())\n+    {\n+      sorry (\"using declaration inside function\");\n+      return NULL_TREE;\n+    }\n \n-  /* Don't commit caller to seeing them as globals.  */\n-  if (TREE_NONLOCAL_FLAG (list))\n-    return -1;\n-  /* Do commit caller to not seeing them as globals.  */\n-  if (TREE_CODE (TREE_VALUE (list)) == TREE_LIST)\n-    return 0;\n-  /* Do commit caller to seeing them as globals.  */\n-  return 1;\n+  my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n+  for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n+    if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n+      break;\n+  if (decl)\n+    return NULL_TREE;\n+  decl = build_lang_decl (USING_DECL, name, void_type_node);\n+  DECL_INITIAL (decl) = scope;\n+  TREE_CHAIN (decl) = current_binding_level->usings;\n+  current_binding_level->usings = decl;\n+  return decl;\n }\n \n /* DECL is a FUNCTION_DECL which may have other definitions already in\n@@ -3773,11 +3848,11 @@ push_overloaded_decl (decl, forgettable)\n {\n   tree orig_name = DECL_NAME (decl);\n   tree old;\n-  int doing_global = (global_bindings_p () || ! forgettable);\n+  int doing_global = (namespace_bindings_p () || ! forgettable);\n \n   if (doing_global)\n     {\n-      old =  IDENTIFIER_NAMESPACE_VALUE (orig_name);\n+      old = namespace_binding (orig_name, DECL_CONTEXT (decl));\n       if (old && TREE_CODE (old) == FUNCTION_DECL\n \t  && DECL_ARTIFICIAL (old)\n \t  && (DECL_BUILT_IN (old) || DECL_BUILT_IN_NONANSI (old)))\n@@ -3814,9 +3889,10 @@ push_overloaded_decl (decl, forgettable)\n         {\n           tree tmp;\n \t  \n-\t  for (tmp = get_first_fn (old); tmp; tmp = DECL_CHAIN (tmp))\n-\t    if (decl == tmp || duplicate_decls (decl, tmp))\n-\t      return tmp;\n+\t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n+\t    if (decl == OVL_CURRENT (tmp) \n+\t\t|| duplicate_decls (decl, OVL_CURRENT (tmp)))\n+\t      return OVL_CURRENT (tmp);\n \t}\n       else\n \t{\n@@ -3828,19 +3904,16 @@ push_overloaded_decl (decl, forgettable)\n \n   if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n-      if (old && is_overloaded_fn (old))\n-\tDECL_CHAIN (decl) = get_first_fn (old);\n-      else\n-\tDECL_CHAIN (decl) = NULL_TREE;\n-      old = tree_cons (orig_name, decl, NULL_TREE);\n-      TREE_TYPE (old) = unknown_type_node;\n+      if (old && TREE_CODE (old) != OVERLOAD)\n+\told = ovl_cons (old, NULL_TREE);\n+      old = ovl_cons (decl, old);\n     }\n   else\n     /* orig_name is not ambiguous.  */\n     old = decl;\n \n   if (doing_global)\n-    IDENTIFIER_NAMESPACE_VALUE (orig_name) = old;\n+    set_namespace_binding (orig_name, DECL_CONTEXT (decl), old);\n   else\n     IDENTIFIER_LOCAL_VALUE (orig_name) = old;\n \n@@ -3920,10 +3993,16 @@ redeclaration_error_message (newdecl, olddecl)\n       if (DECL_LANG_SPECIFIC (olddecl) && DECL_ABSTRACT_VIRTUAL_P (olddecl))\n \treturn 0;\n \n+      /* If both functions come from different namespaces, this is not\n+\t a redeclaration - this is a conflict with a used function. */\n+      if (TREE_CODE (DECL_CONTEXT (olddecl)) == NAMESPACE_DECL\n+\t  && DECL_CONTEXT (olddecl) != DECL_CONTEXT (newdecl))\n+\treturn \"`%D' conflicts with used function\";\n+\n       /* We'll complain about linkage mismatches in\n          warn_extern_redeclared_static.  */\n \n-      /* defining the same name twice is no good.  */\n+      /* Defining the same name twice is no good.  */\n       if (DECL_INITIAL (olddecl) != NULL_TREE\n \t  && DECL_INITIAL (newdecl) != NULL_TREE)\n \t{\n@@ -4320,6 +4399,27 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t    if (TYPE_IDENTIFIER (TREE_VALUE (tail)) == name)\n \t      return TREE_VALUE (tail);\n \t  }\n+      else if (level->namespace_p)\n+\t/* Do namespace lookup. */\n+\t/* XXX: is this a real lookup, considering using-directives etc. ??? */\n+\tfor (tail = current_namespace; 1; tail = DECL_CONTEXT (tail))\n+\t  {\n+\t    tree old = BINDING_TYPE (binding_for_name (name, tail));\n+\t    /* If it has an original type, it is a typedef, and we\n+\t       should not return it.  */\n+\t    if (old && DECL_ORIGINAL_TYPE (TYPE_NAME (old)))\n+\t      old = NULL_TREE;\n+\t    if (old && TREE_CODE (old) != form\n+\t\t&& !(form != ENUMERAL_TYPE && TREE_CODE (old) == TEMPLATE_DECL))\n+\t      {\n+\t\tcp_error (\"`%#D' redeclared as %C\", old, form);\n+\t\treturn NULL_TREE;\n+\t      }\n+\t    if (old)\n+\t      return old;\n+\t    if (thislevel_only || tail == global_namespace)\n+\t      return NULL_TREE;\n+\t  }\n       else\n \tfor (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n \t  {\n@@ -4343,15 +4443,14 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t{\n \t  if (level->pseudo_global)\n \t    {\n-\t      /* XXX MvL */\n \t      tree t = IDENTIFIER_NAMESPACE_VALUE (name);\n \t      if (t && TREE_CODE (t) == TEMPLATE_DECL\n \t\t  && TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n \t\treturn TREE_TYPE (t);\n \t    }\n \t  return NULL_TREE;\n \t}\n-      if (current_class_type && level->level_chain == global_binding_level)\n+      if (current_class_type && level->level_chain->namespace_p)\n \t{\n \t  /* Try looking in this class's tags before heading into\n \t     global binding level.  */\n@@ -4495,38 +4594,20 @@ tree\n lookup_namespace_name (namespace, name)\n      tree namespace, name;\n {\n-#if 1\n+  struct tree_binding _b;\n   tree val;\n+\n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n   \n-  val = qualified_lookup_using_namespace (name, namespace);\n-  if (val)\n-    return val;\n+  val = binding_init (&_b);\n+  if (!qualified_lookup_using_namespace (name, namespace, val))\n+    return error_mark_node;\n+\n+  if (BINDING_VALUE (val))\n+    return BINDING_VALUE (val);\n   cp_error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n   return error_mark_node;\n-#else\n-  struct binding_level *b = (struct binding_level *)NAMESPACE_LEVEL (namespace);\n-  tree x = NULL_TREE;\n-#if 1\n-  /* This searches just one level.  */\n-  if (b)\n-    {\n-      for (x = b->names; x; x = TREE_CHAIN (x))\n-\tif (DECL_NAME (x) == name || DECL_ASSEMBLER_NAME (x) == name)\n-\t  break;\n-    }\n-#else\n-  /* This searches all levels.  */\n-  for (; b && !x; b = b->level_chain)\n-    {\n-      for (x = b->names; x; x = TREE_CHAIN (x))\n-\tif (DECL_NAME (x) == name || DECL_ASSEMBLER_NAME (x) == name)\n-\t  break;\n-    }\n-#endif\n-  return x;\n-#endif\n }\n \n tree\n@@ -4607,13 +4688,35 @@ make_typename_type (context, name)\n   return t;\n }\n \n+/* Select the right _DECL from multiple choices. */\n+\n+static tree\n+select_decl (binding, prefer_type)\n+     tree binding;\n+     int prefer_type;\n+{\n+  tree val;\n+  val = BINDING_VALUE (binding);\n+  /* If we could have a type and\n+     we have nothing or we need a type and have none.  */\n+  if (BINDING_TYPE (binding)\n+      && (!val || (prefer_type && TREE_CODE (val) != TYPE_DECL)))\n+    val = TYPE_STUB_DECL (BINDING_TYPE (binding));\n+  /* Don't return non-types if we really prefer types. */\n+  else if (val && prefer_type > 1  && TREE_CODE (val) != TYPE_DECL\n+\t   && (!looking_for_template || TREE_CODE (val) != TEMPLATE_DECL))\n+    val = NULL_TREE;\n+  return val;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n    such declaration, or return a TREE_LIST with all the overloaded\n    definitions if there are many, or return 0 if it is undefined.\n \n-   If PREFER_TYPE is > 0, we prefer TYPE_DECLs.\n+   If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n+   If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n    Otherwise we prefer non-TYPE_DECLs.  \n \n@@ -4657,10 +4760,14 @@ lookup_name_real (name, prefer_type, nonclass)\n \t  type = complete_type (type);\n \n \t  if (TREE_CODE (type) == VOID_TYPE)\n-\t    val = IDENTIFIER_GLOBAL_VALUE (name);\n-\t  else if (TREE_CODE (type) == NAMESPACE_DECL)\n+\t    type = global_namespace;\n+\t  if (TREE_CODE (type) == NAMESPACE_DECL)\n \t    {\n-\t      val = NAMESPACE_BINDING (name, type);\n+\t      struct tree_binding b;\n+\t      val = binding_init (&b);\n+\t      if (!qualified_lookup_using_namespace (name, type, val))\n+\t\treturn NULL_TREE;\n+\t      val = select_decl (val, prefer_type);\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n@@ -4704,7 +4811,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \n   locval = classval = NULL_TREE;\n \n-  if (current_binding_level != global_binding_level\n+  if (!current_binding_level->namespace_p\n       && IDENTIFIER_LOCAL_VALUE (name))\n     locval = IDENTIFIER_LOCAL_VALUE (name);\n \n@@ -4765,20 +4872,31 @@ lookup_name_real (name, prefer_type, nonclass)\n     val = classval;\n   else\n     {\n-      /* unscoped lookup of a global, iterate over namespaces,\n-         considering using namespace statements */\n-      tree binding;\n-      tree scope = current_namespace;\n-      do\n-\t{\n-\t  binding = binding_for_name (name, scope);\n-\t  val = BINDING_VALUE (binding);\n-\t  val = lookup_using_namespace (name, val, current_namespace, scope);\n+      /* Unscoped lookup of a global, iterate over namespaces,\n+         considering using namespace statements. */\n+      struct tree_binding _binding;\n+      tree b = binding_init (&_binding);\n+      tree initial = current_decl_namespace();\n+      tree scope = initial;\n+      val = NULL_TREE;\n+      while (!val)\n+\t{\n+\t  val = binding_for_name (name, scope);\n+\t  /* Initialize binding for this context. */\n+\t  BINDING_VALUE (b) = BINDING_VALUE (val);\n+\t  BINDING_TYPE (b) = BINDING_TYPE (val);\n+\t  /* Add all _DECLs seen through using-directives. */\n+\t  if (!lookup_using_namespace (name, b, initial, scope))\n+\t    {\n+\t      /* Give up because of error. */\n+\t      val = NULL_TREE;\n+\t      break;\n+\t    }\n+\t  val = select_decl (b, prefer_type);\n \t  if (scope == global_namespace)\n \t    break;\n-\t  scope = DECL_NAMESPACE (scope);\n+\t  scope = DECL_CONTEXT (scope);\n \t}\n-      while (!val);\n     }\n \n  done:\n@@ -4803,6 +4921,9 @@ lookup_name_real (name, prefer_type, nonclass)\n       if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n \t  || TREE_CODE (val) == TYPE_DECL || prefer_type <= 0)\n \t;\n+      /* Caller wants a class-or-namespace-name. */\n+      else if(prefer_type == 1 && TREE_CODE (val) == NAMESPACE_DECL)\n+\t;\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n \tval = TYPE_MAIN_DECL (IDENTIFIER_TYPE_VALUE (name));\n       else if (TREE_TYPE (val) == error_mark_node)\n@@ -4821,6 +4942,14 @@ lookup_name_nonclass (name)\n   return lookup_name_real (name, 0, 1);\n }\n \n+tree\n+lookup_function_nonclass (name, args)\n+     tree name;\n+     tree args;\n+{\n+  return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n+}\n+\n tree\n lookup_name (name, prefer_type)\n      tree name;\n@@ -4837,7 +4966,7 @@ lookup_name_current_level (name)\n {\n   register tree t = NULL_TREE;\n \n-  if (current_binding_level == global_binding_level)\n+  if (current_binding_level->namespace_p)\n     {\n       t =  IDENTIFIER_NAMESPACE_VALUE (name);\n \n@@ -4926,15 +5055,15 @@ record_builtin_type (rid_index, name, type)\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n       set_identifier_type_value (tname, NULL_TREE);\n       if ((int) rid_index < (int) RID_MAX)\n-\t/* builtin types live in the global namespace */\n-\tIDENTIFIER_GLOBAL_VALUE (tname) = tdecl;\n+\t/* Built-in types live in the global namespace. */\n+\tSET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n   if (rname != NULL_TREE)\n     {\n       if (tname != NULL_TREE)\n \t{\n \t  set_identifier_type_value (rname, NULL_TREE);\n-\t  IDENTIFIER_GLOBAL_VALUE (rname) = tdecl;\n+\t  SET_IDENTIFIER_GLOBAL_VALUE (rname, tdecl);\n \t}\n       else\n \t{\n@@ -4997,7 +5126,7 @@ init_decl_processing ()\n   lang_name_c = get_identifier (\"C\");\n   lang_name_java = get_identifier (\"Java\");\n \n-  /* enter the global namespace */\n+  /* Enter the global namespace. */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n   my_friendly_assert (current_lang_name == NULL_TREE, 375);\n   current_lang_name = lang_name_cplusplus;\n@@ -5064,6 +5193,9 @@ init_decl_processing ()\n   /* Make the binding_level structure for global names.  */\n   pushlevel (0);\n   global_binding_level = current_binding_level;\n+  /* The global level is the namespace level of ::.  */\n+  NAMESPACE_LEVEL (global_namespace) = global_binding_level;\n+  declare_namespace_level ();\n \n   this_identifier = get_identifier (THIS_NAME);\n   in_charge_identifier = get_identifier (IN_CHARGE_NAME);\n@@ -5254,7 +5386,7 @@ init_decl_processing ()\n      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */\n   array_domain_type = build_index_type (build_int_2 (200, 0));\n \n-  /* make a type for arrays of characters.\n+  /* Make a type for arrays of characters.\n      With luck nothing will ever really depend on the length of this\n      array type.  */\n   char_array_type_node\n@@ -5432,7 +5564,7 @@ init_decl_processing ()\n   temp = tree_cons (NULL_TREE,\n \t\t    build_pointer_type (build_function_type (void_type_node,\n \t\t\t\t\t\t\t     NULL_TREE)),\n-\t\t    ptr_ftype_sizetype);\n+\t\t    tree_cons (NULL_TREE, ptr_ftype_sizetype, NULL_TREE));\n   builtin_function (\"__builtin_apply\",\n \t\t    build_function_type (ptr_type_node, temp),\n \t\t    BUILT_IN_APPLY, NULL_PTR);\n@@ -5661,19 +5793,28 @@ init_decl_processing ()\n       record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n     }\n \n-  std_node = build_decl (NAMESPACE_DECL, get_identifier (\"std\"),\n+  std_node = build_decl (NAMESPACE_DECL, \n+\t\t\t get_identifier (flag_honor_std ? \"fake std\":\"std\"),\n \t\t\t void_type_node);\n   pushdecl (std_node);\n \n+  global_type_node = make_node (LANG_TYPE);\n+  record_builtin_type (RID_MAX, \"global type\", global_type_node);\n+\n   /* Now, C++.  */\n   current_lang_name = lang_name_cplusplus;\n \n   {\n-    tree bad_alloc_type_node = xref_tag\n+    tree bad_alloc_type_node, newtype, deltype;\n+    if (flag_honor_std)\n+      push_namespace (get_identifier (\"std\"));\n+    bad_alloc_type_node = xref_tag\n       (class_type_node, get_identifier (\"bad_alloc\"), NULL_TREE, 1);\n-    tree newtype = build_exception_variant\n+    if (flag_honor_std)\n+      pop_namespace ();\n+    newtype = build_exception_variant\n       (ptr_ftype_sizetype, build_tree_list (NULL_TREE, bad_alloc_type_node));\n-    tree deltype = build_exception_variant\n+    deltype = build_exception_variant\n       (void_ftype_ptr, build_tree_list (NULL_TREE, NULL_TREE));\n     auto_function (ansi_opname[(int) NEW_EXPR], newtype, NOT_BUILT_IN);\n     auto_function (ansi_opname[(int) VEC_NEW_EXPR], newtype, NOT_BUILT_IN);\n@@ -5733,6 +5874,9 @@ define_function (name, type, function_code, pfn, library_name)\n   TREE_PUBLIC (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n \n+  my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 392);\n+  DECL_CONTEXT (decl) = current_namespace;\n+\n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n      function in the namespace.  */\n@@ -5964,6 +6108,10 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       ? DECL_CLASS_CONTEXT (decl)\n       : DECL_CONTEXT (decl);\n \n+  /* We are only interested in class contexts, later. */\n+  if (context && TREE_CODE (context) == NAMESPACE_DECL)\n+    context = NULL_TREE;\n+\n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n        If not, set INITIALIZED to zero, which will indirectly\n@@ -6083,8 +6231,11 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n      comes from another scope, e.g. a static member variable.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n   \n-  if ((TREE_CODE (decl) != PARM_DECL && DECL_CONTEXT (decl) != NULL_TREE)\n-      || (TREE_CODE (decl) == TEMPLATE_DECL && !global_bindings_p ())\n+  if ((TREE_CODE (decl) != PARM_DECL && DECL_CONTEXT (decl) != NULL_TREE \n+       /* Definitions of namespace members outside their namespace are\n+\t  possible. */\n+       && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n+      || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n       || TREE_CODE (type) == LANG_TYPE\n       /* The declaration of template specializations does not affect\n \t the functions available for overload resolution, so we do not\n@@ -6407,6 +6558,13 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (asmspec_tree)\n       asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n+  if (init && TREE_CODE (init) == NAMESPACE_DECL)\n+    {\n+      cp_error (\"Cannot initialize `%D' to namespace `%D'\",\n+\t\tdecl, init);\n+      init = NULL_TREE;\n+    }\n+\n   /* If the type of the thing we are declaring either has\n      a constructor, or has a virtual function table pointer,\n      AND its initialization was accepted by `start_decl',\n@@ -6785,7 +6943,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\tmake_decl_one_only (decl);\n \t      else\n \t\t{\n-\t\t  /* we can't do anything useful; leave vars for explicit\n+\t\t  /* We can't do anything useful; leave vars for explicit\n \t\t     instantiation.  */\n \t\t  DECL_EXTERNAL (decl) = 1;\n \t\t  DECL_NOT_REALLY_EXTERN (decl) = 0;\n@@ -7329,14 +7487,15 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n static tree\n grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t    raises, attrlist, check, friendp, publicp, inlinep, funcdef_flag,\n-\t    template_count)\n+\t    template_count, in_namespace)\n      tree ctype, type;\n      tree declarator;\n      tree orig_declarator;\n      int virtualp;\n      enum overload_flags flags;\n      tree quals, raises, attrlist;\n      int check, friendp, publicp, inlinep, funcdef_flag, template_count;\n+     tree in_namespace;\n {\n   tree cname, decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n@@ -7354,10 +7513,14 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     }\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n-  /* propagate volatile out from type to decl */\n+  /* Propagate volatile out from type to decl. */\n   if (TYPE_VOLATILE (type))\n     TREE_THIS_VOLATILE (decl) = 1;\n \n+  /* This decl is not from the current namespace. */\n+  if (in_namespace)\n+    set_decl_namespace (decl, in_namespace);\n+\n   /* Should probably propagate const out from type to decl I bet (mrs).  */\n   if (staticp)\n     {\n@@ -7463,18 +7626,16 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       if (check == 0 && ! current_function_decl)\n \t{\n-\t  /* assembler names live in the global namespace */\n+\t  /* Assembler names live in the global namespace. */\n \t  tmp = IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl));\n \t  if (tmp == NULL_TREE)\n-\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n+\t    SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl), decl);\n \t  else if (TREE_CODE (tmp) != TREE_CODE (decl))\n \t    cp_error (\"inconsistent declarations for `%D'\", decl);\n \t  else\n \t    {\n \t      duplicate_decls (decl, tmp);\n \t      decl = tmp;\n-\t      /* avoid creating circularities.  */\n-\t      DECL_CHAIN (decl) = NULL_TREE;\n \t    }\n \t  make_decl_rtl (decl, NULL_PTR, 1);\n \t}\n@@ -7538,15 +7699,13 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t IDENTIFIER_GLOBAL_VALUE.  */\n \t      tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n \t      if (tmp == NULL_TREE)\n-\t\tIDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n+\t\tSET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl), decl);\n \t      else if (TREE_CODE (tmp) != TREE_CODE (decl))\n \t\tcp_error (\"inconsistent declarations for `%D'\", decl);\n \t      else\n \t\t{\n \t\t  duplicate_decls (decl, tmp);\n \t\t  decl = tmp;\n-\t\t  /* avoid creating circularities.  */\n-\t\t  DECL_CHAIN (decl) = NULL_TREE;\n \t\t}\n \t    }\n \n@@ -7567,12 +7726,13 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n }\n \n static tree\n-grokvardecl (type, declarator, specbits_in, initialized, constp)\n+grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n      tree type;\n      tree declarator;\n      RID_BIT_TYPE *specbits_in;\n      int initialized;\n      int constp;\n+     tree in_namespace;\n {\n   tree decl;\n   RID_BIT_TYPE specbits;\n@@ -7592,12 +7752,16 @@ grokvardecl (type, declarator, specbits_in, initialized, constp)\n     }\n   else\n     {\n+      tree context = in_namespace ? in_namespace : current_namespace;\n       decl = build_decl (VAR_DECL, declarator, complete_type (type));\n-      if (current_namespace != global_namespace)\n-\tDECL_ASSEMBLER_NAME (decl) =  build_static_name (current_namespace,\n+      if (context != global_namespace)\n+\tDECL_ASSEMBLER_NAME (decl) =  build_static_name (context,\n \t\t\t\t\t\t\t declarator);\n     }\n \n+  if (in_namespace)\n+    set_decl_namespace (decl, in_namespace);\n+\n   if (RIDBIT_SETP (RID_EXTERN, specbits))\n     {\n       DECL_THIS_EXTERN (decl) = 1;\n@@ -7659,9 +7823,9 @@ build_ptrmemfunc_type (type)\n \n   t = make_lang_type (RECORD_TYPE);\n \n-  /* Let the front-end know this is a pointer to member function.  */\n+  /* Let the front-end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n-  /* and not really an aggregate.  */\n+  /* ... and not really an aggregate.  */\n   IS_AGGR_TYPE (t) = 0;\n \n   fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n@@ -7788,6 +7952,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   tree quals = NULL_TREE;\n   tree raises = NULL_TREE;\n   int template_count = 0;\n+  tree in_namespace = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -7814,7 +7979,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    next = &TREE_OPERAND (decl, 0);\n \t    break;\n \n-\t  case BIT_NOT_EXPR:\t/* for C++ destructors!  */\n+\t  case BIT_NOT_EXPR:\t/* For C++ destructors!  */\n \t    {\n \t      tree name = TREE_OPERAND (decl, 0);\n \t      tree rename = NULL_TREE;\n@@ -7857,7 +8022,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    break;\n \n \t  case ADDR_EXPR:\t/* C++ reference declaration */\n-\t    /* fall through */\n+\t    /* Fall through. */\n \t  case ARRAY_REF:\n \t  case INDIRECT_REF:\n \t    ctype = NULL_TREE;\n@@ -7919,7 +8084,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\telse\n \t\t  my_friendly_abort (0);\n \t      }\n-\t  /* fall through */\n+\t  /* Fall through. */\n \n \t  case IDENTIFIER_NODE:\n \t    if (TREE_CODE (decl) == IDENTIFIER_NODE)\n@@ -7957,6 +8122,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      tree cname = TREE_OPERAND (decl, 0);\n \t      if (cname == NULL_TREE)\n \t\tctype = NULL_TREE;\n+\t      else if (TREE_CODE (cname) == NAMESPACE_DECL)\n+\t\t{\n+\t\t  ctype = NULL_TREE;\n+\t\t  in_namespace = TREE_OPERAND (decl, 0);\n+\t\t  TREE_OPERAND (decl, 0) = NULL_TREE;\n+\t\t}\n \t      else if (! is_aggr_type (cname, 1))\n \t\tTREE_OPERAND (decl, 0) = NULL_TREE;\n \t      /* Must test TREE_OPERAND (decl, 1), in case user gives\n@@ -8747,7 +8918,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   the function; then build_vec_delete will need this\n \t\t   value.  */\n \t\tint yes = suspend_momentary ();\n-\t\t/* might be a cast */\n+\t\t/* Might be a cast. */\n \t\tif (TREE_CODE (size) == NOP_EXPR\n \t\t    && TREE_TYPE (size) == TREE_TYPE (TREE_OPERAND (size, 0)))\n \t\t  size = TREE_OPERAND (size, 0);\n@@ -8939,7 +9110,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t  return void_type_node;\n \t\t      }\n \t\t  }\n-\t\telse            /* it's a constructor.  */\n+\t\telse            /* It's a constructor.  */\n \t\t  {\n \t\t    if (explicitp == 1)\n \t\t      explicitp = 2;\n@@ -9203,7 +9374,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      /* This needs to be here, in case we are called\n \t\t multiple times.  */ ;\n \t    else if (friendp && (TREE_COMPLEXITY (declarator) < 2))\n-\t      /* don't fall out into global scope. Hides real bug? --eichin */ ;\n+\t      /* Don't fall out into global scope. Hides real bug? --eichin */ ;\n \t    else if (! IS_AGGR_TYPE_CODE\n \t\t     (TREE_CODE (TREE_OPERAND (declarator, 0))))\n \t      ;\n@@ -9292,7 +9463,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\telse if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n \t\t\t || TYPE_SIZE (complete_type (ctype)) != NULL_TREE)\n \t\t  {\n-\t\t    /* have to move this code elsewhere in this function.\n+\t\t    /* Have to move this code elsewhere in this function.\n \t\t       this code is used for i.e., typedef int A::M; M *pm;\n \n \t\t       It is?  How? jason 10/2/94 */\n@@ -9418,16 +9589,26 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n \t{\n-\t  /* replace the anonymous name with the real name everywhere.  */\n+\t  /* Replace the anonymous name with the real name everywhere.  */\n \t  lookup_tag_reverse (type, declarator);\n \t  TYPE_NAME (type) = decl;\n \n \t  if (TYPE_LANG_SPECIFIC (type))\n \t    TYPE_WAS_ANONYMOUS (type) = 1;\n \n+\t  /* XXX Temporarily set the scope. \n+\t     When returning, start_decl expects it as NULL_TREE,\n+\t     and will then then set it using pushdecl. */\n+\t  my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n+\t  if (current_class_type)\n+\t    DECL_CONTEXT (decl) = current_class_type;\n+\t  else\n+\t    DECL_CONTEXT (decl) = current_namespace;\n+\n \t  DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n \t  DECL_ASSEMBLER_NAME (decl)\n \t    = get_identifier (build_overload_name (type, 1, 1));\n+\t  DECL_CONTEXT (decl) = NULL_TREE;\n \t}\n \n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n@@ -9688,7 +9869,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t       declarator,\n \t\t\t       virtualp, flags, quals, raises, attrlist,\n \t\t\t       friendp ? -1 : 0, friendp, publicp, inlinep,\n-\t\t\t       funcdef_flag, template_count);\n+\t\t\t       funcdef_flag, template_count, in_namespace);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n #if 0\n@@ -9709,7 +9890,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    decl = grokfndecl (ctype, type, declarator, declarator,\n \t\t\t       virtualp, flags, quals, raises, attrlist,\n \t\t\t       friendp ? -1 : 0, friendp, 1, 0, funcdef_flag,\n-\t\t\t       template_count);\n+\t\t\t       template_count, in_namespace);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t  }\n@@ -9907,19 +10088,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t   virtualp, flags, quals, raises, attrlist,\n \t\t\t   1, friendp,\n \t\t\t   publicp, inlinep, funcdef_flag, \n-\t\t\t   template_count);\n+\t\t\t   template_count, in_namespace);\n \tif (decl == NULL_TREE)\n \t  return NULL_TREE;\n \n \tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c\n \t    && (! DECL_USE_TEMPLATE (decl) ||\n \t\tname_mangling_version < 1)) \n-#if 0\n-\t/* XXX is support for the old __ns_ mangling really needed? MvL */\n-\t  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (declarator);\n-#else\n \t  DECL_ASSEMBLER_NAME (decl) = declarator;\n-#endif\t\n \t\n \tif (staticp == 1)\n \t  {\n@@ -9977,7 +10153,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  }\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, declarator, &specbits, initialized, constp);\n+\tdecl = grokvardecl (type, declarator, &specbits, \n+\t\t\t    initialized, constp, in_namespace);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n@@ -10239,14 +10416,14 @@ grokparms (first_parm, funcdef_flag)\n                            && CLASSTYPE_ABSTRACT_VIRTUALS (type))\n                     {\n                       abstract_virtuals_error (decl, type);\n-                      any_error = 1;  /* seems like a good idea */\n+                      any_error = 1;  /* Seems like a good idea. */\n                     }\n                   else if (TREE_CODE (type) == RECORD_TYPE\n                            && TYPE_LANG_SPECIFIC (type)\n                            && IS_SIGNATURE (type))\n                     {\n                       signature_error (decl, type);\n-                      any_error = 1;  /* seems like a good idea */\n+                      any_error = 1;  /* Seems like a good idea. */\n                     }\n \t\t}\n \n@@ -10591,7 +10768,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t}\n       \n       if (name == ansi_opname[(int) CALL_EXPR])\n-\treturn;\t\t\t/* no restrictions on args */\n+\treturn;\t\t\t/* No restrictions on args. */\n \n       if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n \t{\n@@ -10924,13 +11101,11 @@ xref_tag (code_type_node, name, binfo, globalize)\n       /* If it no longer looks like a nested type, make sure it's\n \t in global scope.  \n          If it is not an IDENTIFIER, this is not a declaration */\n-      if (b == global_binding_level && !class_binding_level\n+      if (b->namespace_p && !class_binding_level\n \t  && TREE_CODE (name) == IDENTIFIER_NODE)\n \t{\n-\t  tree binding;\n-\t  binding = binding_for_name (name, current_namespace);\n-\t  if (BINDING_VALUE (binding) == NULL_TREE)\n-\t    BINDING_VALUE (binding) = TYPE_NAME (ref);\n+\t  if (IDENTIFIER_NAMESPACE_VALUE (name) == NULL_TREE)\n+\t    SET_IDENTIFIER_NAMESPACE_VALUE (name, TYPE_NAME (ref));\n \t}\n \n       if (!globalize && processing_template_decl && IS_AGGR_TYPE (ref))\n@@ -11265,7 +11440,7 @@ finish_enum (enumtype, values)\n   }\n \n   /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (enumtype, global_bindings_p ());\n+  rest_of_type_compilation (enumtype, namespace_bindings_p ());\n \n   return enumtype;\n }\n@@ -11461,6 +11636,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       if (! DECL_ARGUMENTS (decl1)\n \t  && !DECL_STATIC_FUNCTION_P (decl1)\n \t  && DECL_CONTEXT (decl1)\n+\t  && TREE_CODE (DECL_CONTEXT (decl1)) != NAMESPACE_DECL\n \t  && TYPE_IDENTIFIER (DECL_CONTEXT (decl1))\n \t  && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (DECL_CONTEXT (decl1))))\n \t{\n@@ -11625,6 +11801,10 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t   || !DECL_TEMPLATE_SPECIALIZATION (decl1))\n \t  && ! DECL_FUNCTION_MEMBER_P (decl1))\n \tdecl1 = pushdecl (decl1);\n+      else\n+\t/* We need to set the DECL_CONTEXT. */\n+\tif (!DECL_CONTEXT (decl1) && DECL_TEMPLATE_INFO (decl1))\n+\t  DECL_CONTEXT (decl1) = DECL_CONTEXT (DECL_TI_TEMPLATE (decl1));\n       DECL_MAIN_VARIANT (decl1) = decl1;\n       fntype = TREE_TYPE (decl1);\n     }\n@@ -11931,7 +12111,7 @@ store_parm_decls ()\n   if (DECL_NAME (fndecl)\n       && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 4\n       && strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\") == 0\n-      && DECL_CONTEXT (fndecl) == NULL_TREE)\n+      && DECL_CONTEXT (fndecl) == global_namespace)\n     {\n       expand_main_function ();\n     }\n@@ -12385,7 +12565,7 @@ finish_function (lineno, call_poplevel, nested)\n \t}\n       else if (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 4\n \t       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\")\n-\t       && DECL_CONTEXT (fndecl) == NULL_TREE)\n+\t       && DECL_CONTEXT (fndecl) == global_namespace)\n \t{\n \t  /* Make it so that `main' always returns 0 by default.  */\n #ifdef VMS\n@@ -12430,7 +12610,7 @@ finish_function (lineno, call_poplevel, nested)\n \n       if (cleanup_label)\n \t{\n-\t  /* remove the binding contour which is used\n+\t  /* Remove the binding contour which is used\n \t     to catch cleanup-generated temporaries.  */\n \t  expand_end_bindings (0, 0, 0);\n \t  poplevel (0, 0, 0);\n@@ -12466,7 +12646,7 @@ finish_function (lineno, call_poplevel, nested)\n     my_friendly_abort (122);\n   poplevel (1, 0, 1);\n \n-  /* reset scope for C++: if we were in the scope of a class,\n+  /* Reset scope for C++: if we were in the scope of a class,\n      then when we finish this function, we are not longer so.\n      This cannot be done until we know for sure that no more\n      class members will ever be referenced in this function\n@@ -12658,7 +12838,8 @@ start_method (declspecs, declarator)\n     {\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (fndecl)) != current_class_type)\n \t{\n-\t  if (DECL_CONTEXT (fndecl))\n+\t  if (DECL_CONTEXT (fndecl) \n+\t      && TREE_CODE( DECL_CONTEXT (fndecl)) != NAMESPACE_DECL)\n \t    cp_error (\"`%D' is already defined in class %s\", fndecl,\n \t\t\t     TYPE_NAME_STRING (DECL_CONTEXT (fndecl)));\n \t}\n@@ -12681,14 +12862,6 @@ start_method (declspecs, declarator)\n \n   if (! DECL_FRIEND_P (fndecl))\n     {\n-      if (DECL_CHAIN (fndecl) != NULL_TREE)\n-\t{\n-\t  /* Need a fresh node here so that we don't get circularity\n-\t     when we link these together.  If FNDECL was a friend, then\n-\t     `pushdecl' does the right thing, which is nothing wrt its\n-\t     current value of DECL_CHAIN.  */\n-\t  fndecl = copy_node (fndecl);\n-\t}\n       if (TREE_CHAIN (fndecl))\n \t{\n \t  fndecl = copy_node (fndecl);\n@@ -12768,7 +12941,7 @@ finish_method (decl)\n     IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n   for (link = current_binding_level->type_shadowed;\n        link; link = TREE_CHAIN (link))\n-    IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n \n   GNU_xref_end_scope ((HOST_WIDE_INT) current_binding_level,\n \t\t      (HOST_WIDE_INT) current_binding_level->level_chain,"}, {"sha": "3d6dc2510bf378850a708ec8da583e4285a2e398", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 565, "deletions": 129, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -88,11 +88,15 @@ int at_eof;\n \n tree static_ctors, static_dtors;\n \n-/* The current open namespace, and :: */\n+/* The current open namespace, and ::. */\n \n tree current_namespace;\n tree global_namespace;\n \n+/* The stack for namespaces of current declarations. */\n+\n+static tree decl_namespace_list;\n+\n \f\n /* C (and C++) language-specific option variables.  */\n \n@@ -410,6 +414,10 @@ int flag_weak = 1;\n \n int flag_new_abi;\n \n+/* Nonzero to not ignore namespace std. */\n+\n+int flag_honor_std;\n+\n /* Maximum template instantiation depth. Must be at least 17 for ANSI\n    compliance. */\n \n@@ -460,6 +468,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"default-inline\", &flag_default_inline, 1},\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n   {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n+  {\"honor-std\", &flag_honor_std, 1},\n   {\"rtti\", &flag_rtti, 1},\n   {\"xref\", &flag_gnu_xref, 1},\n   {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n@@ -572,12 +581,14 @@ lang_decode_option (p)\n \t{\n \t  flag_new_abi = 1;\n \t  flag_do_squangling = 1;\n+\t  flag_honor_std = 1;\n \t  flag_vtable_thunks = 1;\n \t}\n       else if (!strcmp (p, \"no-new-abi\"))\n \t{\n \t  flag_new_abi = 0;\n \t  flag_do_squangling = 0;\n+\t  flag_honor_std = 0;\n \t}\n       else if (!strncmp (p, \"template-depth-\", 15))\n \t{\n@@ -1391,7 +1402,7 @@ check_classfn (ctype, function)\n      tree ctype, function;\n {\n   tree fn_name = DECL_NAME (function);\n-  tree fndecl;\n+  tree fndecl, fndecls;\n   tree method_vec = CLASSTYPE_METHOD_VEC (complete_type (ctype));\n   tree *methods = 0;\n   tree *end = 0;\n@@ -1403,22 +1414,23 @@ check_classfn (ctype, function)\n       end = TREE_VEC_END (method_vec);\n \n       /* First suss out ctors and dtors.  */\n-      if (*methods && fn_name == DECL_NAME (*methods)\n+      if (*methods && fn_name == DECL_NAME (OVL_CURRENT (*methods))\n \t  && DECL_CONSTRUCTOR_P (function))\n \tgoto got_it;\n-      if (*++methods && fn_name == DECL_NAME (*methods)\n+      if (*++methods && fn_name == DECL_NAME (OVL_CURRENT (*methods))\n \t  && DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function)))\n \tgoto got_it;\n \n       while (++methods != end)\n \t{\n \t  fndecl = *methods;\n-\t  if (fn_name == DECL_NAME (*methods))\n+\t  if (fn_name == DECL_NAME (OVL_CURRENT (*methods)))\n \t    {\n \t    got_it:\n-\t      for (fndecl = *methods; fndecl != NULL_TREE;\n-\t\t   fndecl = DECL_CHAIN (fndecl))\n+\t      for (fndecls = *methods; fndecls != NULL_TREE;\n+\t\t   fndecls = OVL_NEXT (fndecls))\n \t\t{\n+\t\t  fndecl = OVL_CURRENT (fndecls);\n \t\t  /* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL is\n \t\t     not mangled, so the check below does not work\n \t\t     correctly in that case.  */\n@@ -1489,10 +1501,10 @@ check_classfn (ctype, function)\n       tree fndecl = *methods;\n       cp_error (\"prototype for `%#D' does not match any in class `%T'\",\n \t\tfunction, ctype);\n-      cp_error_at (\"candidate%s: %+#D\", DECL_CHAIN (fndecl) ? \"s are\" : \" is\",\n-\t\t   fndecl);\n-      while (fndecl = DECL_CHAIN (fndecl), fndecl)\n-\tcp_error_at (\"                %#D\", fndecl);\n+      cp_error_at (\"candidate%s: %+#D\", OVL_NEXT (fndecl) ? \"s are\" : \" is\",\n+\t\t   OVL_CURRENT (fndecl));\n+      while (fndecl = OVL_NEXT (fndecl), fndecl)\n+\tcp_error_at (\"                %#D\", OVL_CURRENT(fndecl));\n     }\n   else\n     {\n@@ -1745,14 +1757,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n       check_default_args (value);\n-      if (DECL_CHAIN (value) != NULL_TREE)\n-\t{\n-\t  /* Need a fresh node here so that we don't get circularity\n-\t     when we link these together.  */\n-\t  value = copy_node (value);\n-\t  /* When does this happen?  */\n-\t  my_friendly_assert (init == NULL_TREE, 193);\n-\t}\n       if (asmspec)\n \t{\n \t  /* This must override the asm specifier which was placed\n@@ -2777,7 +2781,7 @@ get_sentry (base)\n      tree base;\n {\n   tree sname = get_id_2 (\"__sn\", base);\n-  /* for struct X foo __attribute__((weak)), there is a counter\n+  /* For struct X foo __attribute__((weak)), there is a counter\n      __snfoo. Since base is already an assembler name, sname should\n      be globally unique */\n   tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n@@ -2855,6 +2859,8 @@ finish_file ()\n       instantiate_decl (fn);\n     }\n \n+  cat_namespace_levels();\n+\n   /* Push into C language context, because that's all\n      we'll need here.  */\n   push_lang_context (lang_name_c);\n@@ -2973,7 +2979,7 @@ finish_file ()\n \n   assemble_destructor (IDENTIFIER_POINTER (fnname));\n \n-  /* if it needed cleaning, then it will need messing up: drop through  */\n+  /* If it needed cleaning, then it will need messing up: drop through.  */\n \n  mess_up:\n   /* Must do this while we think we are at the top level.  */\n@@ -3666,7 +3672,8 @@ check_cp_case_value (value)\n   return value;\n }\n \n-/* return 1 if root encloses child */\n+/* Return 1 if root encloses child. */\n+\n static int\n is_namespace_ancestor (root, child)\n      tree root, child;\n@@ -3677,19 +3684,20 @@ is_namespace_ancestor (root, child)\n     return 1;\n   if (child == global_namespace)\n     return 0;\n-  return is_namespace_ancestor (root, DECL_NAMESPACE (child));\n+  return is_namespace_ancestor (root, DECL_CONTEXT (child));\n }\n   \n \n-/* return the namespace that is the common ancestor \n-   of two given namespaces */\n+/* Return the namespace that is the common ancestor \n+   of two given namespaces. */\n+\n static tree\n namespace_ancestor (ns1, ns2)\n      tree ns1, ns2;\n {\n   if (is_namespace_ancestor (ns1, ns2))\n     return ns1;\n-  return namespace_ancestor (DECL_NAMESPACE (ns1), ns2);\n+  return namespace_ancestor (DECL_CONTEXT (ns1), ns2);\n }\n \n /* Insert used into the using list of user. Set indirect_flag if this\n@@ -3702,23 +3710,23 @@ add_using_namespace (user, used, indirect)\n      int indirect;\n {\n   tree iter;\n-  /* using oneself is a no-op */\n+  /* Using oneself is a no-op. */\n   if (user == used)\n     return;\n   my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n   my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n-  /* check if we already have this */\n+  /* Check if we already have this. */\n   if (purpose_member (used, DECL_NAMESPACE_USING (user)) != NULL_TREE)\n     return;\n \n-  /* add used to the user's using list */\n+  /* Add used to the user's using list. */\n   DECL_NAMESPACE_USING (user) \n     = perm_tree_cons (used, namespace_ancestor (user, used), \n \t\t      DECL_NAMESPACE_USING (user));\n \n   TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n \n-  /* add user to the used's users list */\n+  /* Add user to the used's users list. */\n   DECL_NAMESPACE_USERS (used)\n     = perm_tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n \t\t      \n@@ -3727,102 +3735,130 @@ add_using_namespace (user, used, indirect)\n     add_using_namespace (TREE_PURPOSE (iter), used, 1);\n }\n \n+/* Combines two sets of overloaded functions into an OVERLOAD chain.\n+   The first list becomes the tail of the result. */\n+\n+static tree\n+merge_functions (s1, s2)\n+     tree s1;\n+     tree s2;\n+{\n+  tree tmp, tempn;\n+  if (TREE_CODE (s2) == OVERLOAD)\n+    while (s2)\n+      {\n+\ts1 = build_overload (OVL_FUNCTION (s2), s1);\n+\ts2 = OVL_CHAIN (s2);\n+      }\n+  else\n+    s1 = build_overload (s2, s1);\n+  return s1;\n+}\n+\n /* This should return an error not all definitions define functions.\n    It is not an error if we find two functions with exactly the\n    same signature, only if these are selected in overload resolution.\n+   old is the current set of bindings, new the freshly-found binding.\n    XXX Do we want to give *all* candidates in case of ambiguity?\n    XXX In what way should I treat extern declarations?\n    XXX I don't want to repeat the entire duplicate_decls here */\n+\n static tree\n-ambiguous_decl (name, val1, val2)\n-     tree name, val1, val2;\n+ambiguous_decl (name, old, new)\n+     tree name;\n+     tree old;\n+     tree new;\n {\n-  my_friendly_assert (val1 != val2, 376);\n-  if (is_overloaded_fn (val1) && is_overloaded_fn (val1))\n+  my_friendly_assert (old != NULL_TREE, 393);\n+  /* Copy the value. */\n+  if (!BINDING_VALUE (old))\n+    BINDING_VALUE (old) = BINDING_VALUE (new);\n+  else if (BINDING_VALUE (new) \n+\t   && BINDING_VALUE (new) != BINDING_VALUE (old))\n+    {\n+      if (is_overloaded_fn (BINDING_VALUE (old)) \n+\t  && is_overloaded_fn (BINDING_VALUE (new)))\n+\t{\n+\t  BINDING_VALUE (old) = merge_functions (BINDING_VALUE (old),\n+\t\t\t\t\t\t BINDING_VALUE (new));\n+\t}\n+      else\n+\t{\n+\t  /* Some declarations are functions, some are not. */\n+\t  cp_error (\"ambiguous definition `%D' used\", name);\n+\t  cp_error_at (\"first definition here\", BINDING_VALUE (old));\n+\t  cp_error_at (\"other definition here\", BINDING_VALUE (new));\n+\t  return error_mark_node;\n+\t}\n+    }\n+  /* ... and copy the type. */\n+  if (!BINDING_TYPE (old))\n+    BINDING_TYPE (old) = BINDING_TYPE (new);\n+  else if(BINDING_TYPE (new)\n+\t  && BINDING_TYPE (old) != BINDING_TYPE (new))\n     {\n-      /* now built a joint list of all overloaded declarations */\n-      /* XXX if I chain'em together, they will be always considered\n-\t as overloaded */\n-      sorry (\"overloaded functions used from different namespaces\");\n+      cp_error (\"`%D' denotes an ambiguous type\",name);\n+      cp_error_at (\"first type here\", BINDING_TYPE (old));\n+      cp_error_at (\"other type here\", BINDING_TYPE (new));\n     }\n-  cp_error (\"ambiguous definition `%D' used\", name);\n-  cp_error_at (\"first definition here\", val1);\n-  cp_error_at (\"other definition here\", val2);\n-  return error_mark_node;\n+  return old;\n }\n \n-/* add the bindings of name in used namespaces to val \n-   the using list is defined by current, and the lookup goes to scope */\n-tree\n+/* Add the bindings of name in used namespaces to val.\n+   The using list is defined by current, and the lookup goes to scope.\n+   Returns zero on errors. */\n+\n+int\n lookup_using_namespace (name, val, current, scope)\n      tree name, val, current, scope;\n {\n   tree iter;\n   tree val1;\n-  /* iterate over all namespaces from current to scope */\n-  while (1)\n+  /* Iterate over all namespaces from current to scope. */\n+  while (val != error_mark_node)\n     {\n-      /* iterate over all used namespaces in current, searching for\n-\t using directives of scope */\n+      /* Iterate over all used namespaces in current, searching for\n+\t using directives of scope. */\n       for (iter = DECL_NAMESPACE_USING (current); \n \t   iter; iter = TREE_CHAIN (iter))\n \tif (TREE_VALUE (iter) == scope)\n \t  {\n-\t    val1 = NAMESPACE_BINDING (name, TREE_PURPOSE (iter));\n-\t    /* name not found in this space */\n-\t    if (!val1) \n-\t      continue;\n-\t    /* first definition ever */\n-\t    if (!val)\n-\t      {\n-\t\tval = val1;\n-\t\tcontinue;\n-\t      }\n-\t    /* Hmmm. Ambiguity. As long as both are overloaded functions,\n-\t       this is fine */\n+\t    val1 = binding_for_name (name, TREE_PURPOSE (iter));\n+\t    /* Resolve ambiguities. */\n \t    val = ambiguous_decl (name, val, val1);\n-\t    if (val == error_mark_node)\n-\t      break;\n \t  }\n       if (current == scope)\n \tbreak;\n-      current = DECL_NAMESPACE (current);\n+      current = DECL_CONTEXT (current);\n     }\n-  return val;\n+  return val != error_mark_node;\n }\n \n-/* [namespace.qual] */\n-tree\n-qualified_lookup_using_namespace (name, scope)\n+/* [namespace.qual]\n+   Excepts the name to lookup and its qualifying scope.\n+   Returns the name/type pair found into the CPLUS_BINDING result,\n+   or 0 on error. */\n+\n+int\n+qualified_lookup_using_namespace (name, scope, result)\n      tree name;\n      tree scope;\n+     tree result;\n {\n-  tree val = NULL_TREE;\n-  tree val1;\n-  /* maintain a list of namespaces visited */\n+  /* Maintain a list of namespaces visited... */\n   tree seen = NULL_TREE;\n-  /* and a list of namespace yet to see */\n+  /* ... and a list of namespace yet to see. */\n   tree todo = NULL_TREE;\n   tree usings;\n-  while (scope)\n+  while (scope && (result != error_mark_node))\n     {\n       seen = temp_tree_cons (scope, NULL_TREE, seen);\n-      val1 = NAMESPACE_BINDING (name, scope);\n-      if (val1)\n-\t{\n-\t  if (val)\n-\t    {\n-\t      val = ambiguous_decl (name, val, val1);\n-\t      break;\n-\t    }\n-\t  else\n-\t    val = val1;\n-\t}\n-      else\n-\t/* consider using directives */\n+      result = ambiguous_decl (name, result, binding_for_name (name, scope));\n+      if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n+\t/* Consider using directives. */\n \tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n \t     usings = TREE_CHAIN (usings))\n-\t  /* if this was a real directive, and we have not seen it */\n+\t  /* If this was a real directive, and we have not seen it. */\n \t  if (!TREE_INDIRECT_USING (usings)\n \t      && !purpose_member (seen, TREE_PURPOSE (usings)))\n \t    todo = temp_tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n@@ -3832,45 +3868,360 @@ qualified_lookup_using_namespace (name, scope)\n \t  todo = TREE_CHAIN (todo);\n \t}\n       else\n-\tscope = NULL_TREE; /* if there never was a todo list */\n+\tscope = NULL_TREE; /* If there never was a todo list. */\n     }\n-  return val;\n+  return result != error_mark_node;\n }\n \n-#if 0\n-/* this is broken and should not be called anymore */\n-/* Get the inner part of a namespace id.  It doesn't have any prefix, nor\n-   postfix.  Returns 0 if in global namespace.  */\n+/* [namespace.memdef]/2 */\n+\n+/* Set the context of a declaration to scope. Complain if we are not\n+   outside scope. */\n+\n+void\n+set_decl_namespace (decl, scope)\n+     tree decl;\n+     tree scope;\n+{\n+  tree old;\n+  if (scope == std_node)\n+    scope = global_namespace;\n+  if (!is_namespace_ancestor (current_namespace, scope))\n+    cp_error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n+\t      decl, scope);\n+  DECL_CONTEXT (decl) = scope;\n+  if (scope != current_namespace)\n+    {\n+      /* See whether this has been declared in the namespace. */\n+      old = namespace_binding (DECL_NAME (decl), scope);\n+      if (!old)\n+\t/* No old declaration at all. */\n+\tgoto complain;\n+      if (!is_overloaded_fn (decl))\n+\t/* Don't compare non-function decls with decls_match here,\n+\t   since it can't check for the correct constness at this\n+\t   point. pushdecl will find those errors later.  */\n+\treturn;\n+      /* Since decl is a function, old should contain a function decl. */\n+      if (!is_overloaded_fn (old))\n+\tgoto complain;\n+      for (; old; old = OVL_NEXT (old))\n+\tif (decls_match (decl, OVL_CURRENT (old)))\n+\t  return;\n+    }\n+  else\n+    return;\n+ complain:\n+  cp_error (\"`%D' should have been declared inside `%D'\",\n+\t    decl, scope);\n+} \n+\n+/* Compute the namespace where a declaration is defined. */\n \n tree\n-get_namespace_id ()\n+decl_namespace (decl)\n+     tree decl;\n {\n-  tree x = current_namespace;\n-  if (x)\n-    x = TREE_PURPOSE (x);\n-  return x;\n+  while (DECL_CONTEXT (decl))\n+    {\n+      decl = DECL_CONTEXT (decl);\n+      if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\treturn decl;\n+      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n+\tdecl = TYPE_STUB_DECL (decl);\n+      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd', 390);\n+    }\n+\n+  /* We should always find the namespace. */\n+  my_friendly_abort (390);\n+  return NULL_TREE;\n }\n \n-/* Build up a DECL_ASSEMBLER_NAME for NAME in the current namespace.  */\n+/* Return the namespace where the current declaration is declared. */\n \n tree\n-current_namespace_id (name)\n-     tree name;\n+current_decl_namespace ()\n {\n-  tree old_id = get_namespace_id ();\n-  char *buf;\n+  tree result;\n+  /* If we have been pushed into a different namespace, use it. */\n+  if (decl_namespace_list)\n+    return TREE_PURPOSE (decl_namespace_list);\n+\n+  if (current_class_type)\n+    if (CLASSTYPE_USE_TEMPLATE (current_class_type))\n+      result = decl_namespace (CLASSTYPE_TI_TEMPLATE (current_class_type));\n+    else\n+      result = decl_namespace (TYPE_STUB_DECL (current_class_type));\n+  else if (current_function_decl)\n+    if (DECL_USE_TEMPLATE (current_function_decl))\n+      result = decl_namespace (DECL_TI_TEMPLATE (current_function_decl));\n+    else\n+      result = decl_namespace (current_function_decl);\n+  else \n+    result = current_namespace;\n+  return result;\n+}\n \n-  /* Global names retain old encoding.  */\n-  if (! old_id)\n-    return name;\n+/* Temporarily set the namespace for the current declaration. */\n \n-  buf = (char *) alloca (8 + IDENTIFIER_LENGTH (old_id)\n-\t\t\t + IDENTIFIER_LENGTH (name));\n-  sprintf (buf, \"__ns_%s_%s\", IDENTIFIER_POINTER (old_id),\n-\t   IDENTIFIER_POINTER (name));\n-  return get_identifier (buf);\n+void\n+push_decl_namespace (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) != NAMESPACE_DECL)\n+    decl = decl_namespace (decl);\n+  decl_namespace_list = tree_cons (decl, NULL_TREE, decl_namespace_list);\n+}\n+\n+void\n+pop_decl_namespace ()\n+{\n+  decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n+}\n+\n+/* [basic.lookup.koenig] */\n+/* A non-zero return value in the functions below indicates an error.\n+   All nodes allocated in the procedure are on the scratch obstack. */\n+\n+struct arg_lookup\n+{\n+  tree name;\n+  tree namespaces;\n+  tree classes;\n+  tree functions;\n+};\n+\n+static int arg_assoc         PROTO((struct arg_lookup*, tree));\n+static int arg_assoc_args    PROTO((struct arg_lookup*, tree));\n+\n+/* Add a function to the lookup structure. */\n+\n+static int\n+add_function (k, fn)\n+     struct arg_lookup *k;\n+     tree fn;\n+{\n+  if (ovl_member (fn, k->functions))\n+    return 0;\n+  k->functions = build_overload (fn, k->functions);\n+  return 0;\n+}\n+\n+/* Add functions of a namespace to the lookup structure. */\n+\n+static int\n+arg_assoc_namespace (k, scope)\n+     struct arg_lookup *k;\n+     tree scope;\n+{\n+  tree value;\n+\n+  if (purpose_member (scope, k->namespaces))\n+    return 0;\n+  k->namespaces = tree_cons (scope, NULL_TREE, k->namespaces);\n+  \n+  value = namespace_binding (k->name, scope);\n+  if (!value)\n+    return 0;\n+  \n+  if (!is_overloaded_fn (value))\n+    {\n+      cp_error_at (\"`%D' is not a function\", value);\n+      cp_error (\"in call to `%D'\", k->name);\n+      return 1;\n+    }\n+  \n+  for (; value; value = OVL_NEXT (value))\n+    if (add_function (k, OVL_CURRENT (value)))\n+      return 1;\n+  \n+  return 0;\n }\n-#endif\n+\n+/* Adds everything associated with class to the lookup structure. */\n+\n+static int\n+arg_assoc_class (k, type)\n+     struct arg_lookup* k;\n+     tree type;\n+{\n+  tree list, friends, context;\n+  int i;\n+  \n+  if (purpose_member (type, k->classes))\n+    return 0;\n+  k->classes = tree_cons (type, NULL_TREE, k->classes);\n+  \n+  context = decl_namespace (TYPE_MAIN_DECL (type));\n+  if (arg_assoc_namespace (k, context))\n+    return 1;\n+  \n+  /* Process baseclasses. */\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n+    if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n+      return 1;\n+  \n+  /* Process friends. */\n+  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n+       list = TREE_CHAIN (list))\n+    if (k->name == TREE_PURPOSE (list))\n+      for (friends = TREE_VALUE (list); friends; \n+\t   friends = TREE_CHAIN (friends))\n+\t/* Only interested in global functions with potentially hidden\n+           (i.e. unqualified) declarations. */\n+\tif (TREE_PURPOSE (list) == error_mark_node && TREE_VALUE (list)\n+\t    && decl_namespace (TREE_VALUE (list)) == context)\n+\t  if (add_function (k, TREE_VALUE (list)))\n+\t    return 1;\n+  return 0;\n+}\n+\n+/* Adds everything associated with a given type. */\n+\n+static int\n+arg_assoc_type (k, type)\n+     struct arg_lookup *k;\n+     tree type;\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case CHAR_TYPE:\n+    case BOOLEAN_TYPE:\n+      return 0;\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n+      return arg_assoc_class (k, type);\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case ARRAY_TYPE:\n+      return arg_assoc_type (k, TREE_TYPE (type));\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n+    case METHOD_TYPE:\n+      /* Associate the class of the method. */\n+      if (arg_assoc_type (k, TYPE_METHOD_BASETYPE (type)))\n+\treturn 1;\n+      /* Fall through. */\n+    case FUNCTION_TYPE:\n+      /* Associate the parameter types. */\n+      if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n+\treturn 1;\n+      /* Associate the return type. */\n+      return arg_assoc_type (k, TREE_TYPE (type));\n+    default:\n+      my_friendly_abort (390);\n+    }\n+  return 0;\n+}\n+\n+/* Adds everything associated with arguments. */\n+\n+static int\n+arg_assoc_args (k, args)\n+     struct arg_lookup* k;\n+     tree args;\n+{\n+  for (; args; args = TREE_CHAIN (args))\n+    if (arg_assoc (k, TREE_VALUE (args)))\n+      return 1;\n+  return 0;\n+}\n+\n+/* Adds everything associated with a given tree_node. */\n+\n+static int\n+arg_assoc (k, n)\n+     struct arg_lookup* k;\n+     tree n;\n+{\n+  switch (TREE_CODE_CLASS (TREE_CODE (n)))\n+    {\n+    case 't':\n+      return arg_assoc_type (k, n);\n+    case 'c':\n+    case '1':\n+    case '2':\n+    case '<':\n+    case 'r':\n+      return arg_assoc_type (k, TREE_TYPE (n));\n+    case 'e':\n+      switch (TREE_CODE (n))\n+\t{\n+\tcase ADDR_EXPR:\n+\t  /* special processing */\n+\t  break;\n+\tdefault:\n+\t  return arg_assoc_type (k, TREE_TYPE (n));\n+\t}\n+    default:\n+      break;\n+    }\n+\n+  while (n)\n+    switch (TREE_CODE (n))\n+      {\n+      case CONST_DECL: /* 'd' */\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\treturn arg_assoc_type (k, TREE_TYPE (n));\n+      case ADDR_EXPR: /* 'e' */\n+\t/* We can't use the TREE_TYPE, as the type of an overloaded function\n+\t   will be useless here. */\n+\tn = TREE_OPERAND (n, 0);\n+\tcontinue;\n+      case OVERLOAD:  /* 'x' */\n+\tif (arg_assoc (k, OVL_CURRENT (n)))\n+\t  return 1;\n+\tn = OVL_NEXT (n);\n+\tcontinue;\n+      case TREE_LIST: /* 'x' */\n+\t/* XXX Overloaded member, should get an OVERLOAD directly, here. */\n+\tn = TREE_VALUE (n);\n+\tcontinue;\n+      case FUNCTION_DECL: /* 'd' */\n+\tif (arg_assoc_args (k, FUNCTION_ARG_CHAIN (n)))\n+\t  return 1;\t\n+\tif (DECL_FUNCTION_MEMBER_P (n))\n+\t  if (arg_assoc_type (k, DECL_CLASS_CONTEXT (n)))\n+\t    return 1;\n+\treturn 0;\n+      default:\n+\tcp_error (\"sorry, Koenig lookup for `%s' of type `%T' failed\",\n+\t\t  tree_code_name [(int)TREE_CODE (n)], TREE_TYPE (n));\n+\tmy_friendly_abort (391);\n+      }\n+  return 0;\n+}\n+\n+/* Performs Koenig lookup depending on arguments, where fns\n+   are the functions found in normal lookup. */\n+\n+tree\n+lookup_arg_dependent (name, fns, args)\n+     tree name;\n+     tree fns;\n+     tree args;\n+{\n+  struct arg_lookup k;\n+  k.name = name;\n+  k.functions = fns;\n+  k.namespaces = NULL_TREE;\n+  k.classes = NULL_TREE;\n+  \n+  push_scratch_obstack ();\n+  arg_assoc_args (&k, args);\n+  pop_obstacks ();\n+  return k.functions;\n+}\n+\n+/* Process a namespace-alias declaration. */\n \n void\n do_namespace_alias (alias, namespace)\n@@ -3901,34 +4252,100 @@ do_namespace_alias (alias, namespace)\n     }\n }\n \n+/* Process a using-declaration not appearing in class or local scope. */\n+\n void\n do_toplevel_using_decl (decl)\n      tree decl;\n {\n-#if 1\n+  tree scope, name, binding, decls, newval, newtype;\n+  struct tree_binding _decls;\n+\n   if (TREE_CODE (decl) == SCOPE_REF\n       && TREE_OPERAND (decl, 0) == std_node)\n     return;\n-  sorry (\"using-declaration\");\n-#else\n-  if (decl == NULL_TREE || decl == error_mark_node)\n+  if (TREE_CODE (decl) == SCOPE_REF)\n+    {\n+      scope = TREE_OPERAND (decl, 0);\n+      name = TREE_OPERAND (decl, 1);\n+    }\n+  else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+    {\n+      scope = global_namespace;\n+      name = decl;\n+    }\n+  else\n+    my_friendly_abort (382);\n+  if (TREE_CODE_CLASS (TREE_CODE (name)) == 'd')\n+    name = DECL_NAME (name);\n+  /* Make a USING_DECL. */\n+  decl = push_using_decl (scope, name);\n+  if (!decl)\n+    return;\n+  \n+  binding = binding_for_name (name, current_namespace);\n+  decls = binding_init (&_decls);\n+  if (!qualified_lookup_using_namespace (name, scope, decls))\n+    /* Lookup error */\n     return;\n \n-  if (TREE_CODE (decl) == SCOPE_REF)\n-    decl = resolve_scope_to_name (NULL_TREE, decl);\n+  if (!BINDING_VALUE (decls) && !BINDING_TYPE (decls))\n+    {\n+      cp_error (\"`%D' not declared\", name);\n+      return;\n+    }\n+  newval = newtype = NULL_TREE;\n+\n+  /* Check for using functions. */\n+  if (BINDING_VALUE (decls) && is_overloaded_fn (BINDING_VALUE (decls)))\n+    {\n+      tree oldval = BINDING_VALUE (binding);\n+      tree tmp, tmp1;\n+      newval = oldval;\n+      for (tmp = BINDING_VALUE (decls); tmp; tmp = OVL_NEXT (tmp))\n+\t{\n+\n+\t  /* Compare each new function with each old one.\n+\t     If the old function was also used, there is no conflict. */\n+\t  for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n+\t    if (OVL_CURRENT (tmp) == OVL_CURRENT (tmp1))\n+\t      break;\n+\t    else if (OVL_USED (tmp1))\n+\t      continue;\n+\t    else if (duplicate_decls (OVL_CURRENT (tmp), OVL_CURRENT (tmp1)))\n+\t      return;\n \n-  /* Is this the right way to do an id list? */\n-  if (TREE_CODE (decl) != TREE_LIST)\n+\t  /* Duplicate use, ignore */\n+\t  if (tmp1)\n+\t    continue;\n+\t    \n+\t  newval = build_overload (OVL_CURRENT (tmp), newval);\n+\t  if (TREE_CODE (newval) != OVERLOAD)\n+\t    newval = ovl_cons (newval, NULL_TREE);\n+\t  OVL_USED (newval) = 1;\n+\t}\n+    }\n+  else \n     {\n-      pushdecl (decl);\n+      tree oldval = BINDING_VALUE (binding);\n+      newval = BINDING_VALUE (decls);\n+      if (oldval && oldval != newval && !duplicate_decls (newval, oldval))\n+\tnewval = oldval;\n+    } \n+\n+  newtype = BINDING_TYPE (decls);\n+  if (BINDING_TYPE (binding) && newtype && BINDING_TYPE (binding) != newtype)\n+    {\n+      cp_error (\"using directive `%D' introduced ambiguous type `%T'\",\n+\t\tname, BINDING_TYPE (decls));\n+      return;\n     }\n-  else\n-    while (decl)\n-      {\n-\tpushdecl (TREE_VALUE (decl));\n-\tdecl = TREE_CHAIN (decl);\n-      }\n-#endif\n+  /* Copy declarations found. */\n+  if (newval)\n+    BINDING_VALUE (binding) = newval;\n+  if (newtype)\n+    BINDING_TYPE (binding) = newtype;\n+  return;\n }\n \n tree\n@@ -3937,7 +4354,8 @@ do_class_using_decl (decl)\n {\n   tree name, value;\n \n-  if (TREE_CODE (decl) != SCOPE_REF)\n+  if (TREE_CODE (decl) != SCOPE_REF\n+      || TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (decl, 0))) != 't')\n     {\n       cp_error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n@@ -3954,15 +4372,33 @@ do_class_using_decl (decl)\n   return value;\n }\n \n+/* Process a using-directive. */\n+\n void\n do_using_directive (namespace)\n      tree namespace;\n {\n   if (namespace == std_node)\n     return;\n+  if (!toplevel_bindings_p ())\n+    {\n+      sorry (\"using directives inside functions\");\n+      return;\n+    }\n   /* using A::B::C; */\n   if (TREE_CODE (namespace) == SCOPE_REF)\n       namespace = TREE_OPERAND (namespace, 1);\n+  if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n+    {\n+      /* Lookup in lexer did not find a namespace. */\n+      cp_error (\"namespace `%T' undeclared\", namespace);\n+      return;\n+    }\n+  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n+    {\n+      cp_error (\"`%T' is not a namespace\", namespace);\n+      return;\n+    }\n   /* direct usage */\n   add_using_namespace (current_namespace, namespace, 0);\n }"}, {"sha": "cbb9927dc3f2bf74befca496eb8537e9a0d6c43c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -341,7 +341,7 @@ dump_aggr_type (t, v, canonical_name)\n   \n   name = TYPE_NAME (canonical_name ? TYPE_MAIN_VARIANT (t) : t);\n \n-  if (name && DECL_CONTEXT (name))\n+  if (name && DECL_CONTEXT (name) && DECL_CONTEXT (name) != global_namespace)\n     {\n       /* FUNCTION_DECL or RECORD_TYPE */\n       dump_decl (DECL_CONTEXT (name), 0);\n@@ -710,9 +710,9 @@ dump_decl (t, v)\n       break;\n \n     case NAMESPACE_DECL:\n-      if (DECL_NAMESPACE (t) != global_namespace)\n+      if (DECL_CONTEXT (t) != global_namespace)\n \t{\n-\t  dump_decl (DECL_NAMESPACE (t), v);\n+\t  dump_decl (DECL_CONTEXT (t), v);\n \t  OB_PUTC2 (':',':');\n \t}\n       OB_PUTID (DECL_NAME (t));"}, {"sha": "6a98a13e58856f5b16b3ece13d2a951b31fac557", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -217,9 +217,13 @@ init_exception_processing ()\n   /* void vtype () */\n   tree vtype = build_function_type (void_type_node, void_list_node);\n   \n+  if (flag_honor_std)\n+    push_namespace (get_identifier (\"std\"));\n   Terminate = auto_function (get_identifier (\"terminate\"),\n \t\t\t     vtype, NOT_BUILT_IN);\n   TREE_THIS_VOLATILE (Terminate) = 1;\n+  if (flag_honor_std)\n+    pop_namespace ();\n \n   push_lang_context (lang_name_c);\n "}, {"sha": "d6709c5d23d97054e0edf6192bf81492f0daf5ee", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -34,10 +34,11 @@\n /* Define terminate, unexpected, set_terminate, set_unexpected as\n    well as the default terminate func and default unexpected func.  */\n \n-extern terminate_handler __terminate_func __attribute__((__noreturn__));\n+extern std::terminate_handler __terminate_func __attribute__((__noreturn__));\n+using std::terminate;\n \n void\n-terminate ()\n+std::terminate ()\n {\n   __terminate_func ();\n }\n@@ -48,29 +49,29 @@ __default_unexpected ()\n   terminate ();\n }\n \n-static unexpected_handler __unexpected_func __attribute__((__noreturn__))\n+static std::unexpected_handler __unexpected_func __attribute__((__noreturn__))\n   = __default_unexpected;\n \n-terminate_handler\n-set_terminate (terminate_handler func)\n+std::terminate_handler\n+std::set_terminate (std::terminate_handler func)\n {\n-  terminate_handler old = __terminate_func;\n+  std::terminate_handler old = __terminate_func;\n \n   __terminate_func = func;\n   return old;\n }\n \n-unexpected_handler\n-set_unexpected (unexpected_handler func)\n+std::unexpected_handler\n+std::set_unexpected (std::unexpected_handler func)\n {\n-  unexpected_handler old = __unexpected_func;\n+  std::unexpected_handler old = __unexpected_func;\n \n   __unexpected_func = func;\n   return old;\n }\n \n void\n-unexpected ()\n+std::unexpected ()\n {\n   __unexpected_func ();\n }\n@@ -223,7 +224,7 @@ __check_eh_spec (int n, const void **spec)\n \n   try\n     {\n-      unexpected ();\n+      std::unexpected ();\n     }\n   catch (...)\n     {\n@@ -238,11 +239,11 @@ __check_eh_spec (int n, const void **spec)\n \t    }\n \t}\n \n-      const type_info &bad_exc = typeid (bad_exception);\n+      const std::type_info &bad_exc = typeid (std::bad_exception);\n       for (int i = 0; i < n; ++i)\n \t{\n \t  if (__throw_type_match_rtti (spec[i], &bad_exc, p->value))\n-\t    throw bad_exception ();\n+\t    throw std::bad_exception ();\n \t}\n \n       terminate ();\n@@ -252,25 +253,25 @@ __check_eh_spec (int n, const void **spec)\n extern \"C\" void\n __throw_bad_cast (void)\n {\n-  throw bad_cast ();\n+  throw std::bad_cast ();\n }\n \n extern \"C\" void\n __throw_bad_typeid (void)\n {\n-  throw bad_typeid ();\n+  throw std::bad_typeid ();\n }\n \n /* Has the current exception been caught?  */\n \n bool\n-uncaught_exception ()\n+std::uncaught_exception ()\n {\n   cp_eh_info *p = __cp_exception_info ();\n   return p && ! p->caught;\n }\n \n-const char * exception::\n+const char * std::exception::\n what () const\n {\n   return typeid (*this).name ();"}, {"sha": "52a84a54d39634e4b0085e6fd6edd40ee0a6a9b0", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -118,6 +118,10 @@ is_friend (type, supplicant)\n   else\n     context = NULL_TREE;\n \n+  /* A namespace is not friend to anybody. */\n+  if (context && TREE_CODE (context) == NAMESPACE_DECL)\n+    context = NULL_TREE;\n+\n   if (context)\n     return is_friend (type, context);\n "}, {"sha": "c684b7e66c2ad9e8b14bcd34488089a6d322ba1d", "filename": "gcc/cp/inc/exception", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fexception?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -8,7 +8,7 @@\n \n extern \"C++\" {\n \n-#if 0\n+#ifdef __HONOR_STD\n namespace std {\n #endif\n \n@@ -34,7 +34,7 @@ unexpected_handler set_unexpected (unexpected_handler);\n void unexpected (void) __attribute__ ((__noreturn__));\n bool uncaught_exception ();\n \n-#if 0\n+#ifdef __HONOR_STD\n } // namespace std\n #endif\n "}, {"sha": "0f25a5c2b8527800608151aa1da80eb468558fa5", "filename": "gcc/cp/inc/new", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -10,7 +10,7 @@\n \n extern \"C++\" {\n \n-#if 0\n+#ifdef __HONOR_STD\n namespace std {\n #endif\n \n@@ -24,7 +24,7 @@ namespace std {\n   typedef void (*new_handler)();\n   new_handler set_new_handler (new_handler);\n \n-#if 0\n+#ifdef __HONOR_STD\n } // namespace std\n #endif\n \n@@ -33,10 +33,10 @@ void *operator new (size_t) throw (std::bad_alloc);\n void *operator new[] (size_t) throw (std::bad_alloc);\n void operator delete (void *) throw();\n void operator delete[] (void *) throw();\n-void *operator new (size_t, const nothrow_t&) throw();\n-void *operator new[] (size_t, const nothrow_t&) throw();\n-void operator delete (void *, const nothrow_t&) throw();\n-void operator delete[] (void *, const nothrow_t&) throw();\n+void *operator new (size_t, const std::nothrow_t&) throw();\n+void *operator new[] (size_t, const std::nothrow_t&) throw();\n+void operator delete (void *, const std::nothrow_t&) throw();\n+void operator delete[] (void *, const std::nothrow_t&) throw();\n \n // default placement versions of operator new\n inline void *operator new(size_t, void *place) throw() { return place; }"}, {"sha": "799db7eeaedf4ac791eafc32478cf0fd8c6efc52", "filename": "gcc/cp/inc/new.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fnew.h?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -5,7 +5,7 @@\n \n #include <new>\n \n-#if 0\n+#ifdef __HONOR_STD\n using std::new_handler;\n using std::set_new_handler;\n #endif"}, {"sha": "64b2a819a1e2c4e37650ac46cd0696d3bb9b3e42", "filename": "gcc/cp/inc/typeinfo", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -8,7 +8,7 @@\n \n extern \"C++\" {\n \n-#if 0\n+#ifdef __HONOR_STD\n namespace std {\n #endif\n \n@@ -63,7 +63,7 @@ class bad_typeid : public exception {\n   virtual ~bad_typeid () { }\n };\n \n-#if 0\n+#ifdef __HONOR_STD\n } // namespace std\n #endif\n "}, {"sha": "b92f79da2473848b4559a4799c8db2877c02b419", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -1069,22 +1069,8 @@ expand_member_init (exp, name, init)\n       if (fndecl)\n \tmy_friendly_assert (TREE_CODE (fndecl) == FUNCTION_DECL, 209);\n \n-      /* If the field is unique, we can use the parameter\n-\t types to guide possible type instantiation.  */\n-      if (DECL_CHAIN (fndecl) == NULL_TREE)\n-\t{\n-\t  /* There was a confusion here between\n-\t     FIELD and FNDECL.  The following code\n-\t     should be correct, but abort is here\n-\t     to make sure.  */\n-\t  my_friendly_abort (48);\n-\t  parmtypes = FUNCTION_ARG_CHAIN (fndecl);\n-\t}\n-      else\n-\t{\n-\t  parmtypes = NULL_TREE;\n-\t  fndecl = NULL_TREE;\n-\t}\n+      parmtypes = NULL_TREE;\n+      fndecl = NULL_TREE;\n \n       init = convert_arguments (parm, parmtypes, NULL_TREE, fndecl, LOOKUP_NORMAL);\n       if (init == NULL_TREE || TREE_TYPE (init) != error_mark_node)\n@@ -1711,10 +1697,13 @@ build_offset_ref (type, name)\n       /* Go from the TREE_BASELINK to the member function info.  */\n       t = TREE_VALUE (fnfields);\n \n-      if (DECL_CHAIN (t) == NULL_TREE)\n+      if (!really_overloaded_fn (t))\n \t{\n \t  tree access;\n \n+\t  /* Get rid of a potential OVERLOAD around it */\n+\t  t = OVL_CURRENT (t);\n+\n \t  /* unique functions are handled easily.  */\n \t  access = compute_access (basebinfo, t);\n \t  if (access == access_protected_node)\n@@ -1742,7 +1731,7 @@ build_offset_ref (type, name)\n \t ??? The smart thing to do for the case of saving initializers\n \t is to resolve them before we're done with this scope.  */\n       if (!TREE_PERMANENT (fnfields)\n-\t  && ((flag_save_memoized_contexts && global_bindings_p ())\n+\t  && ((flag_save_memoized_contexts && toplevel_bindings_p ())\n \t      || ! allocation_temporary_p ()))\n \tfnfields = copy_list (fnfields);\n "}, {"sha": "ab575a4a6549eccefba7ff4a89c5410015245836", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -56,6 +56,8 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-handle-exceptions\",\n   \"-fhandle-signatures\",\n   \"-fno-handle-signatures\",\n+  \"-fhonor-std\",\n+  \"-fno-honor-std\",\n   \"-fhuge-objects\",\n   \"-fno-huge-objects\",\n   \"-fimplement-inlines\","}, {"sha": "79b6f1669fc1e22d79fefd23ed55dbee9c25181a", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02111-1307, USA.  */\n \t-undef -D__GNUC__=%v1 -D__GNUG__=%v1 -D__cplusplus -D__GNUC_MINOR__=%v2\\\n \t%{ansi:-trigraphs -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\\\n \t%{!fno-exceptions:-D__EXCEPTIONS}\\\n+        %{fhonor-std:-D__HONOR_STD} %{fnew-abi:-D__HONOR_STD}\\\n         %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:%{!O0:-D__OPTIMIZE__}} %{trigraphs}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\\\n         %i %{!M:%{!MM:%{!E:%{!pipe:%g.ii}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\","}, {"sha": "75358ae969ea47192e194d2be5ca29f6376b58b7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -332,7 +332,7 @@ get_time_identifier (name)\n       end_temporary_allocation ();\n       IDENTIFIER_LOCAL_VALUE (time_identifier) = build_int_2 (0, 0);\n       IDENTIFIER_CLASS_VALUE (time_identifier) = build_int_2 (0, 1);\n-      IDENTIFIER_GLOBAL_VALUE (time_identifier) = filename_times;\n+      SET_IDENTIFIER_GLOBAL_VALUE (time_identifier, filename_times);\n       filename_times = time_identifier;\n       pop_obstacks ();\n     }\n@@ -2740,8 +2740,8 @@ identifier_type (decl)\n   if (looking_for_template && really_overloaded_fn (decl))\n     {\n       tree t;\n-      for (t = TREE_VALUE (decl); t != NULL_TREE; t = DECL_CHAIN (t))\n-\tif (DECL_FUNCTION_TEMPLATE_P (t)) \n+      for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n+\tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t))) \n \t  return PFUNCNAME;\n     }\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n@@ -2758,7 +2758,8 @@ identifier_type (decl)\n void\n see_typename ()\n {\n-  looking_for_typename = 1;\n+  /* Only types expected, not even namespaces. */\n+  looking_for_typename = 2;\n   if (yychar < 0)\n     if ((yychar = yylex ()) < 0) yychar = 0;\n   looking_for_typename = 0;\n@@ -2827,7 +2828,7 @@ do_identifier (token, parsing)\n \t refers to an overloaded method.  Eventually this will not be\n \t necessary, since default arguments shouldn't be parsed until\n \t after the class is complete.  (jason 3/12/97) */\n-      && TREE_CODE (id) != TREE_LIST)\n+      && TREE_CODE (id) != OVERLOAD)\n     pushdecl_class_level (id);\n     \n   if (!id || id == error_mark_node)\n@@ -2876,7 +2877,7 @@ do_identifier (token, parsing)\n \t    }\n \t  id = error_mark_node;\n \t  /* Prevent repeated error messages.  */\n-\t  IDENTIFIER_NAMESPACE_VALUE (token) = error_mark_node;\n+\t  SET_IDENTIFIER_NAMESPACE_VALUE (token, error_mark_node);\n \t  SET_IDENTIFIER_ERROR_LOCUS (token, current_function_decl);\n \t}\n     }\n@@ -2966,7 +2967,14 @@ do_scoped_id (token, parsing)\n   tree id;\n   /* during parsing, this is ::name. Otherwise, it is black magic. */\n   if (parsing)\n-    id = qualified_lookup_using_namespace (token, global_namespace);\n+    {\n+      struct tree_binding _b;\n+      id = binding_init (&_b);\n+      if (!qualified_lookup_using_namespace (token, global_namespace, id))\n+\tid = NULL_TREE;\n+      else\n+\tid = BINDING_VALUE (id);\n+    } \n   else\n     id = IDENTIFIER_GLOBAL_VALUE (token);\n   if (parsing && yychar == YYEMPTY)\n@@ -2988,14 +2996,14 @@ do_scoped_id (token, parsing)\n \t\t   IDENTIFIER_POINTER (token));\n \t  id = error_mark_node;\n \t  /* Prevent repeated error messages.  */\n-\t  IDENTIFIER_NAMESPACE_VALUE (token) = error_mark_node;\n+\t  SET_IDENTIFIER_NAMESPACE_VALUE (token, error_mark_node);\n \t}\n     }\n   else\n     {\n       if (TREE_CODE (id) == ADDR_EXPR)\n \tmark_used (TREE_OPERAND (id, 0));\n-      else if (TREE_CODE (id) != TREE_LIST)\n+      else if (TREE_CODE (id) != OVERLOAD)\n \tmark_used (id);\n     }\n   if (TREE_CODE (id) == CONST_DECL && ! processing_template_decl)\n@@ -3232,7 +3240,7 @@ real_yylex ()\n \t\t      && TREE_CODE (IDENTIFIER_GLOBAL_VALUE (old_ttype)) == TYPE_DECL)\n \t\t    looking_for_typename = 0;\n \t\t  else if (ptr->token == AGGR || ptr->token == ENUM)\n-\t\t    looking_for_typename = 1;\n+\t\t    looking_for_typename = 2;\n \n \t\t  /* Check if this is a language-type declaration.\n \t\t     Just glimpse the next non-white character.  */\n@@ -4375,8 +4383,6 @@ build_lang_decl (code, name, type)\n     DECL_LANGUAGE (t) = lang_java;\n   else my_friendly_abort (64);\n \n-  SET_DECL_NAMESPACE (t, current_namespace);\n-\n #if 0 /* not yet, should get fixed properly later */\n   if (code == TYPE_DECL)\n     {\n@@ -4508,7 +4514,7 @@ dump_time_statistics ()\n   for (decl = filename_times; decl; decl = next)\n     {\n       next = IDENTIFIER_GLOBAL_VALUE (decl);\n-      IDENTIFIER_GLOBAL_VALUE (decl) = prev;\n+      SET_IDENTIFIER_GLOBAL_VALUE (decl, prev);\n       prev = decl;\n     }\n "}, {"sha": "9d8b8f0d778c75d19e1a1396c8dc363e79783df1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -187,6 +187,7 @@ static int nrepeats = 0;\n /* Array of types seen so far in top-level call to `build_mangled_name'.\n    Allocated and deallocated by caller.  */\n static tree *typevec = NULL;\n+static int  typevec_size;\n \n /* Number of types interned by `build_mangled_name' so far.  */\n static int maxtype = 0;\n@@ -418,6 +419,9 @@ build_overload_nested_name (decl)\n   if (ktypelist && issue_ktype (decl))\n       return;\n \n+  if (decl == global_namespace)\n+    return;\n+\n    if (DECL_CONTEXT (decl))\n     {\n       tree context = DECL_CONTEXT (decl);\n@@ -438,14 +442,8 @@ build_overload_nested_name (decl)\n             }\n         }\n     }\n-  else if (decl == global_namespace)\n-    return;\n-  else if (DECL_NAMESPACE (decl))\n-    build_overload_nested_name (DECL_NAMESPACE (decl));\n-  else\n-    /* XXX the above does not work for non-namespaces */\n-    if (current_namespace && TREE_CODE (decl) != NAMESPACE_DECL)\n-      build_overload_nested_name (current_namespace);\n+  else \n+    my_friendly_abort (392);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -946,8 +944,8 @@ build_qualified_name (decl)\n   /* if we can't find a Ktype, do it the hard way */\n   if (check_ktype (context, FALSE) == -1)\n     {\n-      /* count type scopes */\n-      while (DECL_CONTEXT (context))\n+      /* count type and namespace scopes */\n+      while (DECL_CONTEXT (context) && DECL_CONTEXT (context) != global_namespace)\n \t{\n \t  i += 1;\n \t  context = DECL_CONTEXT (context);\n@@ -956,25 +954,6 @@ build_qualified_name (decl)\n \t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n \t    context = TYPE_NAME (context);\n \t}\n-      /* now count namespace scopes */\n-      if (TREE_CODE (decl) == NAMESPACE_DECL)\n-\t{\n-\t  i = 0; /* we have nothing done, yet: reset */\n-\t  context = decl;\n-\t}\n-      else\n-\t/* decl must be a type, which we have to scope with the\n-\t   namespace */\n-\t{\n-\t  /* XXX MvL somehow, types have no lang_decl, so no namespace */\n-\t  context = current_namespace;\n-\t}    \n-    }\n-\n-  while (context != global_namespace)\n-    {\n-      i += 1;\n-      context = DECL_NAMESPACE (context);\n     }\n \n   if (i > 1)\n@@ -1052,6 +1031,7 @@ build_mangled_name (parmtypes, begin, end)\n           if (!nofold && typevec)\n             {\n               /* Every argument gets counted.  */\n+\t      my_friendly_assert (maxtype < typevec_size, 387);\n               typevec[maxtype++] = parmtype;\n \n               if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2]\n@@ -1588,14 +1568,19 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n         {\n           maxtype = 0;\n           Nrepeats = 0;\n-          typevec = (tree *)alloca (list_length (parms) * sizeof (tree));\n+\t  typevec_size = list_length (parms);\n+\t  if (!for_method && current_namespace != global_namespace)\n+\t    /* the namespace of a global function needs one slot */\n+\t    typevec_size++;\n+          typevec = (tree *)alloca (typevec_size * sizeof (tree));\n         }\n       nofold = 0;\n       if (for_method)\n \t{\n \t  build_mangled_name (TREE_VALUE (parms), 0, 0);\n \n           if (!flag_do_squangling) {\n+\t    my_friendly_assert (maxtype < typevec_size, 387);\n             typevec[maxtype++] = TREE_VALUE (parms);\n             TREE_USED (TREE_VALUE (parms)) = 1;\n           }\n@@ -1611,7 +1596,10 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t     will count as type */\n \t  if (current_namespace != global_namespace\n \t      && !flag_do_squangling)\n-\t    typevec[maxtype++] = current_namespace;\n+\t    {\n+\t      my_friendly_assert (maxtype < typevec_size, 387);\n+\t      typevec[maxtype++] = current_namespace;\n+\t    }\n \t  build_mangled_name (parms, 0, 0);\n \t}\n \n@@ -1805,6 +1793,9 @@ hack_identifier (value, name)\n \n \t      fndecl = TREE_VALUE (fields);\n \t      my_friendly_assert (TREE_CODE (fndecl) == FUNCTION_DECL, 251);\n+\t      /* I could not trigger this code. MvL */\n+\t      my_friendly_abort (980325);\n+#ifdef DEAD\n \t      if (DECL_CHAIN (fndecl) == NULL_TREE)\n \t\t{\n \t\t  warning (\"methods cannot be converted to function pointers\");\n@@ -1816,6 +1807,7 @@ hack_identifier (value, name)\n \t\t\t IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n+#endif\n \t    }\n \t}\n       if (flag_labels_ok && IDENTIFIER_LABEL_VALUE (name))\n@@ -1856,6 +1848,9 @@ hack_identifier (value, name)\n \t}\n #endif\n     }\n+  else if (TREE_CODE (value) == OVERLOAD)\n+    /* not really overloaded function */\n+    mark_used (OVL_FUNCTION (value));\n   else if (TREE_CODE (value) == TREE_LIST)\n     {\n       /* Ambiguous reference to base members, possibly other cases?.  */\n@@ -1866,6 +1861,9 @@ hack_identifier (value, name)\n \t  t = TREE_CHAIN (t);\n \t}\n     }\n+  else if (TREE_CODE (value) == NAMESPACE_DECL)\n+    /* A namespace is not really expected here; this is likely illegal code. */\n+    return value;\n   else\n     mark_used (value);\n \n@@ -1957,7 +1955,8 @@ make_thunk (function, delta)\n   if (thunk && TREE_CODE (thunk) != THUNK_DECL)\n     {\n       cp_error (\"implementation-reserved name `%D' used\", thunk_id);\n-      IDENTIFIER_GLOBAL_VALUE (thunk_id) = thunk = NULL_TREE;\n+      thunk = NULL_TREE;\n+      SET_IDENTIFIER_GLOBAL_VALUE (thunk_id, thunk);\n     }\n   if (thunk == NULL_TREE)\n     {"}, {"sha": "28187a43884b494499084b6d62dcd088db1e3830", "filename": "gcc/cp/new.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -28,8 +28,9 @@\n #pragma implementation \"new\"\n #include \"new\"\n \n-const nothrow_t nothrow = { };\n+const std::nothrow_t std::nothrow = { };\n \n+using std::new_handler;\n new_handler __new_handler;\n \n new_handler"}, {"sha": "5bb85c94f15759e93bbcd9aeee2a5b5e294031fa", "filename": "gcc/cp/new1.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew1.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -26,6 +26,8 @@\n // the executable file might be covered by the GNU General Public License.\n \n #include \"new\"\n+using std::new_handler;\n+using std::bad_alloc;\n \n extern \"C\" void *malloc (size_t);\n extern new_handler __new_handler;\n@@ -35,7 +37,7 @@ extern new_handler __new_handler;\n   x\n \n #ifdef L_op_newnt\n-WEAK (void * operator new (size_t sz, const nothrow_t&) throw())\n+WEAK (void * operator new (size_t sz, const std::nothrow_t&) throw())\n {\n   void *p;\n "}, {"sha": "0be1c0d8c7f3db63a100e242694efa1b6f666d9a", "filename": "gcc/cp/new2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fnew2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew2.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -41,7 +41,7 @@ WEAK(void * operator new[] (size_t sz) throw (std::bad_alloc))\n #endif\n \n #ifdef L_op_vnewnt\n-WEAK(void *operator new[] (size_t sz, const nothrow_t& nothrow) throw())\n+WEAK(void *operator new[] (size_t sz, const std::nothrow_t& nothrow) throw())\n {\n   return ::operator new(sz, nothrow);\n }"}, {"sha": "6c466b4fa6c9077bb5fb2ce4403ceb20a3782dc2", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 785, "deletions": 777, "changes": 1562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95"}, {"sha": "074f640f0ee4f4a73b0612781c4a35532085cdd3", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -331,8 +331,10 @@ program:\n \t\t{\n \t\t  /* In case there were missing closebraces,\n \t\t     get us back to the global binding level.  */\n-\t\t  while (! global_bindings_p ())\n+\t\t  while (! toplevel_bindings_p ())\n \t\t    poplevel (0, 0, 0);\n+\t\t  while (current_namespace != global_namespace)\n+\t\t    pop_namespace ();\n \t\t  finish_file ();\n \t\t}\n \t;\n@@ -413,7 +415,10 @@ extdef:\n \t\t{ do_toplevel_using_decl ($1); }\n \t| USING NAMESPACE any_id ';'\n \t\t{\n-\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE)\n+\t\t  /* If no declaration was found, the using-directive is\n+\t\t     invalid. Since that was not reported, we need the\n+\t\t     identifier for the error message. */\n+\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE && lastiddecl)\n \t\t    $3 = lastiddecl;\n \t\t  do_using_directive ($3);\n \t\t}\n@@ -2348,6 +2353,7 @@ left_curly:\n                       $<ttype>0 = t;\n                     }\n \t\t  if (processing_template_decl && TYPE_CONTEXT (t)\n+\t\t      && TREE_CODE (TYPE_CONTEXT (t)) != NAMESPACE_DECL\n \t\t      && ! current_class_type)\n \t\t    push_template_decl (TYPE_STUB_DECL (t));\n \t\t  pushclass (t, 0);\n@@ -3014,7 +3020,9 @@ typename_sub2:\n \t\t  if (TREE_CODE ($1) != IDENTIFIER_NODE)\n \t\t    $1 = lastiddecl;\n \n-\t\t  got_scope = $$ = complete_type (TREE_TYPE ($1));\n+\t\t  /* Retrieve the type for the identifier, which might involve\n+\t\t     some computation. */\n+\t\t  got_scope = $$ = complete_type (IDENTIFIER_TYPE_VALUE ($1));\n \n \t\t  if ($$ == error_mark_node)\n \t\t    cp_error (\"`%T' is not a class or namespace\", $1);"}, {"sha": "f30164f30bafeac31edc191c7e2e93ab0089d843", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 82, "deletions": 35, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -171,7 +171,9 @@ template_class_depth (type)\n {\n   int depth;\n \n-  for (depth = 0; type && TREE_CODE (type) != FUNCTION_DECL;\n+  for (depth = 0; \n+       type && TREE_CODE (type) != FUNCTION_DECL \n+\t && TREE_CODE (type) != NAMESPACE_DECL;\n        type = TYPE_CONTEXT (type))\n     if (CLASSTYPE_TEMPLATE_INFO (type)\n \t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n@@ -730,22 +732,19 @@ determine_specialization (template_id, decl, targs_out,\n   tree targs_in = TREE_OPERAND (template_id, 1);\n   tree templates = NULL_TREE;\n   tree fn;\n-  int overloaded;\n   int i;\n \n   *targs_out = NULL_TREE;\n \n-  if (is_overloaded_fn (fns))\n-    fn = get_first_fn (fns);\n-  else\n-    fn = NULL_TREE;\n+  /* Check for baselinks. */\n+  if (TREE_CODE (fns) == TREE_LIST)\n+    fns = TREE_VALUE (fns);\n \n-  overloaded = really_overloaded_fn (fns);\n-  for (; fn != NULL_TREE; \n-       fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n+  for (; fns; fns = OVL_NEXT (fns))\n     {\n       tree tmpl;\n \n+      fn = OVL_CURRENT (fns);\n       if (!need_member_template \n \t  && TREE_CODE (fn) == FUNCTION_DECL \n \t  && DECL_FUNCTION_MEMBER_P (fn)\n@@ -1576,7 +1575,8 @@ push_template_decl_real (decl, is_friend)\n     /* For a friend, we want the context of the friend function, not\n        the type of which it is a friend.  */\n     ctx = DECL_CONTEXT (decl);\n-  else if (DECL_REAL_CONTEXT (decl))\n+  else if (DECL_REAL_CONTEXT (decl)\n+\t   && TREE_CODE (DECL_REAL_CONTEXT (decl)) != NAMESPACE_DECL)\n     /* In the case of a virtual function, we want the class in which\n        it is defined.  */\n     ctx = DECL_REAL_CONTEXT (decl);\n@@ -1585,6 +1585,12 @@ push_template_decl_real (decl, is_friend)\n        is assumed to be a member of the class.  */\n     ctx = current_class_type;\n \n+  if (ctx && TREE_CODE (ctx) == NAMESPACE_DECL)\n+    ctx = NULL_TREE;\n+\n+  if (!DECL_CONTEXT (decl))\n+    DECL_CONTEXT (decl) = current_namespace;\n+\n   /* For determining whether this is a primary template or not, we're really\n      interested in the lexical context, not the true context.  */\n   if (is_friend)\n@@ -1818,7 +1824,7 @@ push_template_decl_real (decl, is_friend)\n     /* Note that we do not try to push a global template friend\n        declared in a template class; such a thing may well depend on\n        the template parameters of the class.  */\n-    tmpl = pushdecl_top_level (tmpl);\n+    tmpl = pushdecl_namespace_level (tmpl);\n \n   if (primary)\n     DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n@@ -2602,14 +2608,16 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n #define cat(s)\tobstack_grow (&scratch_obstack, (s), strlen (s))\n #endif\n \n-  if (ctx)\n+  if (ctx && ctx != global_namespace)\n     {\n       char* s;\n \n       if (TREE_CODE (ctx) == FUNCTION_DECL)\n \ts = fndecl_as_string (ctx, 0);\n       else if (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't')\n \ts = type_as_string_real (ctx, 0, 1);\n+      else if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\ts = decl_as_string (ctx, 0);\n       else\n \tmy_friendly_abort (0);\n       cat (s);\n@@ -2635,9 +2643,18 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n \t  if (TREE_CODE (arg) == TEMPLATE_DECL)\n-\t    /* Already substituted with real template.  Just output \n-\t       the template name here */\n-\t    cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n+\t    {\n+\t      /* Already substituted with real template.  Just output \n+\t\t the template name here */\n+\t      my_friendly_assert (TREE_CODE (DECL_CONTEXT (arg)) \n+\t\t\t\t  == NAMESPACE_DECL, 980422);\n+\t      if (DECL_CONTEXT (arg) != global_namespace)\n+\t\t{\n+\t\t  cat(decl_as_string (DECL_CONTEXT (arg), 0));\n+\t\t  cat(\"::\");\n+\t\t}\n+\t      cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n+\t    }\n \t  else\n \t    /* Output the parameter declaration */\n \t    cat (type_as_string_real (arg, 0, 1));\n@@ -2729,7 +2746,7 @@ tree\n lookup_template_function (fns, arglist)\n      tree fns, arglist;\n {\n-  tree t;\n+  tree type;\n \n   if (fns == NULL_TREE)\n     {\n@@ -2740,10 +2757,11 @@ lookup_template_function (fns, arglist)\n   if (arglist != NULL_TREE && !TREE_PERMANENT (arglist))\n     copy_to_permanent (arglist);\n \n-  return build_min (TEMPLATE_ID_EXPR,\n-\t\t    TREE_TYPE (fns) \n-\t\t    ? TREE_TYPE (fns) : unknown_type_node, \n-\t\t    fns, arglist);  \n+  type = TREE_TYPE (fns);\n+  if (TREE_CODE (fns) == OVERLOAD || !type)\n+    type = unknown_type_node;\n+\n+  return build_min (TEMPLATE_ID_EXPR, type, fns, arglist);  \n }\n \n /* Within the scope of a template class S<T>, the name S gets bound\n@@ -2786,7 +2804,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n {\n   tree template = NULL_TREE, parmlist;\n   char *mangled_name;\n-  tree id, t;\n+  tree id, t, id_context;\n \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n@@ -2795,11 +2813,15 @@ lookup_template_class (d1, arglist, in_decl, context)\n \ttemplate = IDENTIFIER_LOCAL_VALUE (d1);\n       else\n \t{\n+\t  if (context)\n+\t    push_decl_namespace (context);\n \t  template = \n \t    maybe_get_template_decl_from_type_decl\n \t    (IDENTIFIER_CLASS_VALUE (d1));\n \t  if (template == NULL_TREE)\n-\t    template = IDENTIFIER_NAMESPACE_VALUE (d1);\n+\t    template = lookup_name_nonclass (d1);\n+\t  if (context)\n+\t    pop_decl_namespace ();\n \t}\n       if (template)\n \tcontext = DECL_CONTEXT (template);\n@@ -2826,12 +2848,28 @@ lookup_template_class (d1, arglist, in_decl, context)\n   else\n     my_friendly_abort (272);\n \n+  /* A namespace is used as context only for mangling.\n+     Template IDs with namespace context are found \n+     in the global binding level.  */\n+  if (context != NULL_TREE && TREE_CODE (context) == NAMESPACE_DECL)\n+    context = global_namespace;\n+\n   /* With something like `template <class T> class X class X { ... };'\n      we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.\n      We don't want to do that, but we have to deal with the situation, so\n      let's give them some syntax errors to chew on instead of a crash.  */\n   if (! template)\n     return error_mark_node;\n+\n+  /* We need an id_context to get the mangling right. If this is a\n+     nested template, use the context. If it is global, retrieve the\n+     context from the template.  */\n+  if (context && TREE_CODE (context) != NAMESPACE_DECL)\n+    id_context = context;\n+  else\n+    id_context = DECL_CONTEXT (template);\n+  my_friendly_assert (id_context != NULL_TREE, 980410);\n+\n   if (TREE_CODE (template) != TEMPLATE_DECL)\n     {\n       cp_error (\"non-template type `%T' used as a template\", d1);\n@@ -2903,7 +2941,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n       mangled_name = mangle_class_name_for_template (IDENTIFIER_POINTER (d1),\n \t\t\t\t\t\t     parmlist,\n \t\t\t\t\t\t     arglist,\n-\t\t\t\t\t\t     context);\n+\t\t\t\t\t\t     id_context);\n       id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = d1;\n \n@@ -3027,6 +3065,11 @@ for_each_template_parm (t, fn, data)\n \treturn 1;\n       return for_each_template_parm (TREE_CHAIN (t), fn, data);\n \n+    case OVERLOAD:\n+      if (for_each_template_parm (OVL_FUNCTION (t), fn, data))\n+\treturn 1;\n+      return for_each_template_parm (OVL_CHAIN (t), fn, data);\n+\n       /* constructed type nodes */\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -3118,6 +3161,7 @@ for_each_template_parm (t, fn, data)\n     case COMPLEX_TYPE:\n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n+    case NAMESPACE_DECL:\n       return 0;\n \n     case ENUMERAL_TYPE:\n@@ -3366,14 +3410,15 @@ tsubst_friend_function (decl, args)\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     DECL_USE_TEMPLATE (DECL_TEMPLATE_RESULT (new_friend)) = 0;\n   \n-  if (DECL_CONTEXT (new_friend) == NULL_TREE)\n+  if (!DECL_CONTEXT (new_friend) \n+      || TREE_CODE (DECL_CONTEXT (new_friend)) == NAMESPACE_DECL)\n     {\n       if (TREE_CODE (new_friend) == TEMPLATE_DECL)\n \t/* This declaration is a `primary' template.  */\n \tTREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (new_friend))\n \t    = new_friend;\n \n-\tnew_friend = pushdecl_top_level (new_friend);\n+\tnew_friend = pushdecl_namespace_level (new_friend);\n     }\n   else if (TYPE_SIZE (DECL_CONTEXT (new_friend)))\n     {\n@@ -3852,10 +3897,14 @@ tsubst (t, args, in_decl)\n   if (t == NULL_TREE || t == error_mark_node\n       || t == integer_type_node\n       || t == void_type_node\n-      || t == char_type_node)\n+      || t == char_type_node\n+      || TREE_CODE (t) == NAMESPACE_DECL)\n     return t;\n \n-  type = TREE_TYPE (t);\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    type = IDENTIFIER_TYPE_VALUE (t);\n+  else\n+    type = TREE_TYPE (t);\n   if (type == unknown_type_node)\n     my_friendly_abort (42);\n   if (type && TREE_CODE (t) != FUNCTION_DECL\n@@ -3904,12 +3953,13 @@ tsubst (t, args, in_decl)\n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n+    case NAMESPACE_DECL:\n       return t;\n \n     case ENUMERAL_TYPE:\n       {\n \ttree ctx = tsubst (TYPE_CONTEXT (t), args, in_decl);\n-\tif (ctx == NULL_TREE)\n+\tif (ctx == NULL_TREE || TREE_CODE (ctx) == NAMESPACE_DECL)\n \t  return t;\n \telse if (ctx == current_function_decl)\n \t  return lookup_name (TYPE_IDENTIFIER (t), 1);\n@@ -4089,7 +4139,6 @@ tsubst (t, args, in_decl)\n \ttmpl = copy_node (t);\n \tcopy_lang_decl (tmpl);\n \tmy_friendly_assert (DECL_LANG_SPECIFIC (tmpl) != 0, 0);\n-\tDECL_CHAIN (tmpl) = NULL_TREE;\n \tTREE_CHAIN (tmpl) = NULL_TREE;\n \n \tif (is_template_template_parm)\n@@ -4407,7 +4456,6 @@ tsubst (t, args, in_decl)\n \tDECL_INTERFACE_KNOWN (r) = 0;\n \tDECL_DEFER_OUTPUT (r) = 0;\n \tTREE_CHAIN (r) = NULL_TREE;\n-\tDECL_CHAIN (r) = NULL_TREE;\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n \tTREE_USED (r) = 0;\n \n@@ -4436,7 +4484,7 @@ tsubst (t, args, in_decl)\n \t   TREE_CHAIN because it doesn't find a previous decl.  Sigh.  */\n \tif (member\n \t    && IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) == NULL_TREE)\n-\t  IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) = r;\n+\t  SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r), r);\n \n \treturn r;\n       }\n@@ -5632,15 +5680,14 @@ type_unification_real (tparms, targs, parms, args, subr,\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n \t{\n \t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n-\t  if (TREE_CODE (arg) == TREE_LIST\n-\t      && TREE_TYPE (arg) == unknown_type_node\n-\t      && TREE_CODE (TREE_VALUE (arg)) == TEMPLATE_DECL)\n+\t  if (TREE_CODE (arg) == OVERLOAD\n+\t      && TREE_CODE (OVL_FUNCTION (arg)) == TEMPLATE_DECL)\n \t    {\n \t      int ntparms;\n \t      tree targs;\n \n \t      /* Have to back unify here */\n-\t      arg = TREE_VALUE (arg);\n+\t      arg = OVL_FUNCTION (arg);\n \t      ntparms = DECL_NTPARMS (arg);\n \t      targs = make_scratch_vec (ntparms);\n \t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);"}, {"sha": "1f5e3a8382fd3535a5819cb294470931e5fe9742", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -147,7 +147,7 @@ print_lang_identifier (file, node, indent)\n      tree node;\n      int indent;\n {\n-  print_node (file, \"global\", IDENTIFIER_GLOBAL_VALUE (node), indent + 4);\n+  print_node (file, \"bindings\", IDENTIFIER_NAMESPACE_BINDINGS (node), indent + 4);\n   print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n   print_node (file, \"local\", IDENTIFIER_LOCAL_VALUE (node), indent + 4);\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n@@ -169,6 +169,9 @@ lang_print_xnode (file, node, indent)\n       print_node (file, \"value\", BINDING_VALUE (node), indent+4);\n       print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n       break;\n+    case OVERLOAD:\n+      print_node (file, \"function\", OVL_FUNCTION (node), indent+4);\n+      print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n     case TEMPLATE_PARM_INDEX:\n       indent_to (file, indent + 3);\n       fprintf (file, \"index %d level %d orig_level %d\","}, {"sha": "d452e03efd10163142f94cfa16917be8c0cb7f17", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -57,8 +57,12 @@ tree tinfo_fn_type;\n void\n init_rtti_processing ()\n {\n+  if (flag_honor_std)\n+    push_namespace (get_identifier (\"std\"));\n   type_info_type_node = xref_tag\n     (class_type_node, get_identifier (\"type_info\"), NULL_TREE, 1);\n+  if (flag_honor_std)\n+    pop_namespace ();\n   tinfo_fn_id = get_identifier (\"__tf\");\n   tinfo_fn_type = build_function_type\n     (build_reference_type (build_type_variant (type_info_type_node, 1, 0)),"}, {"sha": "bbcf40c3cee37fc1d86b98ab3b55d1dceb278e7e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -1152,10 +1152,10 @@ lookup_fnfields_here (type, name)\n   fndecls = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n   while (fndecls)\n     {\n-      if (TYPE_MAIN_VARIANT (DECL_CLASS_CONTEXT (fndecls))\n+      if (TYPE_MAIN_VARIANT (DECL_CLASS_CONTEXT (OVL_CURRENT (fndecls)))\n \t  == TYPE_MAIN_VARIANT (type))\n \treturn idx;\n-      fndecls = TREE_CHAIN (fndecls);\n+      fndecls = OVL_CHAIN (fndecls);\n     }\n   return -1;\n }\n@@ -1266,7 +1266,7 @@ lookup_field (xbasetype, name, protect, want_type)\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n-  if (protect && flag_memoize_lookups && ! global_bindings_p ())\n+  if (protect && flag_memoize_lookups && ! toplevel_bindings_p ())\n     entry = make_memoized_table_entry (type, name, 0);\n   else\n     entry = 0;\n@@ -1662,7 +1662,7 @@ lookup_fnfields_1 (type, name)\n #ifdef GATHER_STATISTICS\n \t  n_outer_fields_searched++;\n #endif /* GATHER_STATISTICS */\n-\t  if (DECL_NAME (*methods) == name)\n+\t  if (DECL_NAME (OVL_CURRENT (*methods)) == name)\n \t    break;\n \t}\n \n@@ -1676,8 +1676,8 @@ lookup_fnfields_1 (type, name)\n \t  \n \t  while (++methods != end)\n \t    {\n-\t      if (TREE_CODE (*methods) == TEMPLATE_DECL \n-\t\t  && IDENTIFIER_TYPENAME_P (DECL_NAME (*methods)))\n+\t      if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL \n+\t\t  && IDENTIFIER_TYPENAME_P (DECL_NAME (OVL_CURRENT (*methods))))\n \t\tbreak;\n \t    }\n \t}\n@@ -1815,7 +1815,7 @@ lookup_fnfields (basetype_path, name, complain)\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_fnfields++;\n #endif /* GATHER_STATISTICS */\n-  if (protect && flag_memoize_lookups && ! global_bindings_p ())\n+  if (protect && flag_memoize_lookups && ! toplevel_bindings_p ())\n     entry = make_memoized_table_entry (type, name, 1);\n   else\n     entry = 0;\n@@ -2101,8 +2101,8 @@ get_virtuals_named_this (binfo)\n     {\n       tree fndecl;\n \n-      for (fndecl = TREE_VALUE (fields); fndecl; fndecl = DECL_CHAIN (fndecl))\n-\tif (DECL_VINDEX (fndecl))\n+      for (fndecl = TREE_VALUE (fields); fndecl; fndecl = OVL_NEXT (fndecl))\n+\tif (DECL_VINDEX (OVL_CURRENT (fndecl)))\n \t  return fields;\n       fields = next_baselink (fields);\n     }\n@@ -2187,8 +2187,10 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \n       for (; baselink; baselink = next_baselink (baselink))\n \t{\n-\t  for (tmp = TREE_VALUE (baselink); tmp; tmp = DECL_CHAIN (tmp))\n+\t  tree tmps;\n+\t  for (tmps = TREE_VALUE (baselink); tmps; tmps = OVL_NEXT (tmps))\n \t    {\n+\t      tmp = OVL_CURRENT (tmps);\n \t      if (! DECL_VINDEX (tmp))\n \t\tcontinue;\n \n@@ -2256,7 +2258,8 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t  break;\n \t\t}\n \t    }\n-\t  if (tmp)\n+\t  /* If not at the end */\n+\t  if (tmps)\n \t    {\n \t      best = tmp;\n \t      break;\n@@ -2680,6 +2683,7 @@ dfs_debug_mark (binfo)\n \tmethods = TREE_VEC_ELT (methods, 0);\n       else\n \tmethods = TREE_VEC_ELT (methods, 2);\n+      methods = OVL_CURRENT (methods);\n       while (methods)\n \t{\n \t  if (DECL_VINDEX (methods)\n@@ -2697,7 +2701,7 @@ dfs_debug_mark (binfo)\n   /* We cannot rely on some alien method to solve our problems,\n      so we must write out the debug info ourselves.  */\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n-  rest_of_type_compilation (t, global_bindings_p ());\n+  rest_of_type_compilation (t, toplevel_bindings_p ());\n }\n \f\n /*  Attach to the type of the virtual base class, the pointer to the\n@@ -3471,7 +3475,7 @@ dfs_pushdecls (binfo)\n \t{\n \t  /* This will cause lookup_name to return a pointer\n \t     to the tree_list of possible methods of this name.  */\n-\t  tree name = DECL_NAME (*methods);\n+\t  tree name = DECL_NAME (OVL_CURRENT (*methods));\n \t  tree class_value = IDENTIFIER_CLASS_VALUE (name);\n \n \t  /* If the class value is not an envelope of the kind described in\n@@ -3491,7 +3495,7 @@ dfs_pushdecls (binfo)\n \t     If we can't do that, keep a TREE_LIST with possibly ambiguous\n \t     decls in there.  */\n \t  maybe_push_cache_obstack ();\n-\t  envelope_add_decl (type, *methods, &TREE_PURPOSE (class_value));\n+\t  envelope_add_decl (type, OVL_CURRENT (*methods), &TREE_PURPOSE (class_value));\n \t  pop_obstacks ();\n \n \t  methods++;\n@@ -3519,7 +3523,8 @@ dfs_compress_decls (binfo)\n \t{\n \t  /* This is known to be an envelope of the kind described before\n \t     dfs_pushdecls.  */\n-\t  tree class_value = IDENTIFIER_CLASS_VALUE (DECL_NAME (*methods));\n+\t  tree class_value = \n+\t    IDENTIFIER_CLASS_VALUE (DECL_NAME (OVL_CURRENT (*methods)));\n \t  tree tmp = TREE_PURPOSE (class_value);\n \n \t  /* This was replaced in scope by somebody else.  Just leave it\n@@ -3529,7 +3534,7 @@ dfs_compress_decls (binfo)\n \n \t  if (TREE_CHAIN (tmp) == NULL_TREE\n \t      && TREE_VALUE (tmp)\n-\t      && DECL_CHAIN (TREE_VALUE (tmp)) == NULL_TREE)\n+\t      && OVL_NEXT (TREE_VALUE (tmp)) == NULL_TREE)\n \t    {\n \t      TREE_PURPOSE (class_value) = TREE_VALUE (tmp);\n \t    }\n@@ -3738,7 +3743,7 @@ add_conversions (binfo)\n   for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n-      if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n+      if (! IDENTIFIER_TYPENAME_P (DECL_NAME (OVL_CURRENT (tmp))))\n \tbreak;\n       conversions = scratch_tree_cons (binfo, tmp, conversions);\n     }"}, {"sha": "ba5717350b9a505d753d596845ba9fc898359550", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -96,6 +96,8 @@ build_signature_pointer_or_reference_decl (type, name)\n   decl = build_decl (TYPE_DECL, name, type);\n   TYPE_NAME (type) = decl;\n   TREE_CHAIN (type) = decl;\n+  /* But we mangle it, so it needs a scope. */\n+  DECL_CONTEXT (decl) = global_namespace;\n }\n \n /* Construct, lay out and return the type of pointers or references\n@@ -532,19 +534,20 @@ build_signature_table_constructor (sig_ty, rhs)\n       else\n \t{\n \t  /* Find the class method of the correct type.  */\n-\n+\t  tree rhs_methods;\n \t  basetypes = TREE_PURPOSE (baselink);\n \t  if (TREE_CODE (basetypes) == TREE_LIST)\n \t    basetypes = TREE_VALUE (basetypes);\n \n-\t  rhs_method = TREE_VALUE (baselink);\n-\t  for (; rhs_method; rhs_method = TREE_CHAIN (rhs_method))\n-\t    if (sig_mname == DECL_NAME (rhs_method)\n+\t  rhs_methods = TREE_VALUE (baselink);\n+\t  for (; rhs_methods; rhs_methods = OVL_NEXT (rhs_methods))\n+\t    if ((rhs_method = OVL_CURRENT (rhs_methods))\n+\t\t&& sig_mname == DECL_NAME (rhs_method)\n \t\t&& ! DECL_STATIC_FUNCTION_P (rhs_method)\n \t\t&& match_method_types (sig_mtype, TREE_TYPE (rhs_method)))\n \t      break;\n \n-\t  if (rhs_method == NULL_TREE\n+\t  if (rhs_methods == NULL_TREE\n \t      || (compute_access (basetypes, rhs_method)\n \t\t  != access_public_node))\n \t    {\n@@ -754,7 +757,7 @@ build_sigtable (sig_type, rhs_type, init_from)\n \tdecl = pushdecl_top_level (build_decl (VAR_DECL, name, sig_type));\n \tcurrent_function_decl = context;\n       }\n-      IDENTIFIER_GLOBAL_VALUE (name) = decl;\n+      SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n       store_init_value (decl, init_expr);\n       if (IS_SIGNATURE (rhs_type))\n \t{"}, {"sha": "0c9e4e39918f4f5e40c80835e7c999be98d8299a", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -245,6 +245,7 @@ yylex ()\n {\n   struct token tmp_token;\n   tree trrr;\n+  int old_looking_for_typename = 0;\n \n  retry:\n #ifdef SPEW_DEBUG\n@@ -306,8 +307,11 @@ yylex ()\n     case IDENTIFIER:\n       scan_tokens (1);\n       if (nth_token (1)->yychar == SCOPE)\n-\t/* Don't interfere with the setting from an 'aggr' prefix.  */\n-\tlooking_for_typename++;\n+\t{\n+\t  /* Don't interfere with the setting from an 'aggr' prefix.  */\n+\t  old_looking_for_typename = looking_for_typename;\n+\t  looking_for_typename = 1;\n+\t}\n       else if (nth_token (1)->yychar == '<')\n \tlooking_for_template = 1;\n \n@@ -346,8 +350,9 @@ yylex ()\n     case PTYPENAME:\n     case PTYPENAME_DEFN:\n       consume_token ();\n-      if (looking_for_typename > 0)\n-\tlooking_for_typename--;\n+      /* If we see a SCOPE next, restore the old value.\n+\t Otherwise, we got what we want. */\n+      looking_for_typename = old_looking_for_typename;\n       looking_for_template = 0;\n       break;\n \n@@ -368,7 +373,7 @@ yylex ()\n       /* fall through to output...  */\n     case ENUM:\n       /* Set this again, in case we are rescanning.  */\n-      looking_for_typename = 1;\n+      looking_for_typename = 2;\n       /* fall through...  */\n     default:\n       consume_token ();"}, {"sha": "3f320817504718c952f63d8688de5c9385c8de2f", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -33,7 +33,7 @@\n // that uses virtual functions and -frtti but does not actually use RTTI\n // functionality.\n \n-type_info::\n+std::type_info::\n ~type_info ()\n { }\n \n@@ -43,7 +43,7 @@ __rtti_class (void *addr, const char *name,\n { new (addr) __class_type_info (name, bl, bn); }\n \n extern \"C\" void\n-__rtti_si (void *addr, const char *n, const type_info *ti)\n+__rtti_si (void *addr, const char *n, const std::type_info *ti)\n {\n   new (addr) __si_type_info\n     (n, static_cast <const __user_type_info &> (*ti));"}, {"sha": "3cfee04cec017647d3abd9b7c5681cba86fae6b6", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -7,7 +7,7 @@\n \n // type_info for a class with no base classes (or an enum).\n \n-struct __user_type_info : public type_info {\n+struct __user_type_info : public std::type_info {\n   __user_type_info (const char *n) : type_info (n) {}\n \n   // If our type can be converted to the desired type, "}, {"sha": "b797cc3e1dbb7f10b522d608b69ff90850a4a567", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -29,6 +29,7 @@\n #include \"tinfo.h\"\n #include \"new\"\t\t\t// for placement new\n \n+using std::type_info;\n // service function for comparing types by name.\n \n static inline int"}, {"sha": "4b2c82deffa4fb6886af2f321ead549cff1d780c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 105, "deletions": 26, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -1271,33 +1271,38 @@ debug_binfo (elem)\n     }\n }\n \n-/* Return the length of a chain of nodes chained through DECL_CHAIN.\n-   We expect a null pointer to mark the end of the chain.\n-   This is the Lisp primitive `length'.  */\n+/* Initialize an CPLUS_BINDING node that does not live on an obstack. */\n \n-int\n-decl_list_length (t)\n-     tree t;\n+tree\n+binding_init (node)\n+     struct tree_binding* node;\n {\n-  register tree tail;\n-  register int len = 0;\n-\n-  my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL\n-\t\t      || TREE_CODE (t) == TEMPLATE_DECL, 300);\n-  for (tail = t; tail; tail = DECL_CHAIN (tail))\n-    len++;\n-\n-  return len;\n+  static struct tree_binding* source;\n+  if (!source)\n+    {\n+      extern struct obstack permanent_obstack;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      source = (struct tree_binding*)make_node (CPLUS_BINDING);\n+      pop_obstacks ();\n+    }\n+  *node = *source;\n+  TREE_PERMANENT ((tree)node) = 0;\n+  return (tree)node;\n }\n \n int\n count_functions (t)\n      tree t;\n {\n+  int i;\n   if (TREE_CODE (t) == FUNCTION_DECL)\n     return 1;\n-  else if (TREE_CODE (t) == TREE_LIST)\n-    return decl_list_length (TREE_VALUE (t));\n+  else if (TREE_CODE (t) == OVERLOAD)\n+    {\n+      for (i=0; t; t = OVL_CHAIN (t))\n+\ti++;\n+      return i;\n+    }\n \n   my_friendly_abort (359);\n   return 0;\n@@ -1307,31 +1312,102 @@ int\n is_overloaded_fn (x)\n      tree x;\n {\n+  /* XXX A baselink is also considered an overloaded function. */\n+  if (TREE_CODE (x) == TREE_LIST)\n+    {\n+      my_friendly_assert (TREE_CODE (TREE_PURPOSE (x)) == TREE_VEC, 388);\n+      x = TREE_VALUE (x);\n+    }\n   return (TREE_CODE (x) == FUNCTION_DECL\n \t  || TREE_CODE (x) == TEMPLATE_ID_EXPR\n \t  || DECL_FUNCTION_TEMPLATE_P (x)\n-\t  || really_overloaded_fn (x));\n+\t  || TREE_CODE (x) == OVERLOAD);\n }\n \n int\n really_overloaded_fn (x)\n      tree x;\n {     \n-  return (TREE_CODE (x) == TREE_LIST\n-\t  && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n-\t      || DECL_FUNCTION_TEMPLATE_P (TREE_VALUE (x))));\n+  /* A baselink is also considered an overloaded function.\n+     This might also be an ambiguous class member. */\n+  while (TREE_CODE (x) == TREE_LIST)\n+    x = TREE_VALUE (x);\n+  return (TREE_CODE (x) == OVERLOAD \n+\t  && (TREE_CHAIN (x) != NULL_TREE\n+\t      || DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (x))));\n }\n \n tree\n get_first_fn (from)\n      tree from;\n {\n   my_friendly_assert (is_overloaded_fn (from), 9);\n+  /* A baselink is also considered an overloaded function. */\n+  if (TREE_CODE (from) == TREE_LIST)\n+    from = TREE_VALUE (from);\n+  return OVL_CURRENT (from);\n+}\n \n-  if (really_overloaded_fn (from))\n-    return TREE_VALUE (from);\n-  else\n-    return from;\n+/* Return a new OVL node, concatenating it with the old one. */\n+\n+tree\n+ovl_cons (decl, chain)\n+     tree decl;\n+     tree chain;\n+{\n+  tree result = make_node (OVERLOAD);\n+  TREE_TYPE (result) = unknown_type_node;\n+  OVL_FUNCTION (result) = decl;\n+  TREE_CHAIN (result) = chain;\n+  \n+  return result;\n+}\n+\n+/* Same as ovl_cons, but on the scratch_obstack. */\n+\n+tree\n+scratch_ovl_cons (value, chain)\n+     tree value, chain;\n+{\n+  register tree node;\n+  register struct obstack *ambient_obstack = current_obstack;\n+  extern struct obstack *expression_obstack;\n+  current_obstack = expression_obstack;\n+  node = ovl_cons (value, chain);\n+  current_obstack = ambient_obstack;\n+  return node;\n+}\n+\n+/* Build a new overloaded function. If this is the first one,\n+   just return it; otherwise, ovl_cons the _DECLs */\n+\n+tree\n+build_overload (decl, chain)\n+     tree decl;\n+     tree chain;\n+{\n+  if (!chain)\n+    return decl;\n+  if (TREE_CODE (chain) != OVERLOAD)\n+    chain = ovl_cons (chain, NULL_TREE);\n+  return ovl_cons (decl, chain);\n+}\n+\n+/* True if fn is in ovl. */\n+\n+int\n+ovl_member (fn, ovl)\n+     tree fn;\n+     tree ovl;\n+{\n+  if (fn == ovl)\n+    return 1;\n+  if (!ovl || TREE_CODE (ovl) != OVERLOAD)\n+    return 0;\n+  for (; ovl; ovl = OVL_CHAIN (ovl))\n+    if (OVL_FUNCTION (ovl) == fn)\n+      return 1;\n+  return 0;\n }\n \n int\n@@ -2193,8 +2269,11 @@ tree\n lvalue_type (arg)\n      tree arg;\n {\n+  tree type = TREE_TYPE (arg);\n+  if (TREE_CODE (arg) == OVERLOAD)\n+    type = unknown_type_node;\n   return cp_build_type_variant\n-    (TREE_TYPE (arg), TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+    (type, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n }\n \n /* The type of ARG for printing error messages; denote lvalues with"}, {"sha": "6c1a1a6341b586ca07d2a6f642d413fb7cd00edb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c73f9f57ac31b4c79c8e9282c748e3294cd7e95/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2c73f9f57ac31b4c79c8e9282c748e3294cd7e95", "patch": "@@ -91,7 +91,10 @@ require_complete_type (value)\n   if (processing_template_decl)\n     return value;\n \n-  type = TREE_TYPE (value);\n+  if (TREE_CODE (value) == OVERLOAD)\n+    type = unknown_type_node;\n+  else\n+    type = TREE_TYPE (value);\n \n   /* First, detect a valid value with a complete type.  */\n   if (TYPE_SIZE (type) != 0\n@@ -161,7 +164,7 @@ int\n type_unknown_p (exp)\n      tree exp;\n {\n-  return (TREE_CODE (exp) == TREE_LIST\n+  return (TREE_CODE (exp) == OVERLOAD\n \t  || TREE_TYPE (exp) == unknown_type_node\n \t  || (TREE_CODE (TREE_TYPE (exp)) == OFFSET_TYPE\n \t      && TREE_TYPE (TREE_TYPE (exp)) == unknown_type_node));\n@@ -193,7 +196,8 @@ require_instantiated_type (type, exp, errval)\n       return errval;\n     }\n \n-  if (TREE_TYPE (exp) == unknown_type_node\n+  if (TREE_CODE (exp) == OVERLOAD\n+      || TREE_TYPE (exp) == unknown_type_node\n       || (TREE_CODE (TREE_TYPE (exp)) == OFFSET_TYPE\n \t  && TREE_TYPE (TREE_TYPE (exp)) == unknown_type_node))\n     {\n@@ -1837,8 +1841,12 @@ build_component_ref (datum, component, basetype_path, protect)\n   /* First, see if there is a field or component with name COMPONENT.  */\n   if (TREE_CODE (component) == TREE_LIST)\n     {\n+      /* I could not trigger this code. MvL */\n+      my_friendly_abort (980326);\n+#ifdef DEAD\n       my_friendly_assert (!(TREE_CHAIN (component) == NULL_TREE\n \t\t&& DECL_CHAIN (TREE_VALUE (component)) == NULL_TREE), 309);\n+#endif\n       return build (COMPONENT_REF, TREE_TYPE (component), datum, component);\n     }\n \n@@ -1907,7 +1915,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  if (fndecls)\n \t    {\n \t      if (TREE_CHAIN (fndecls) == NULL_TREE\n-\t\t  && DECL_CHAIN (TREE_VALUE (fndecls)) == NULL_TREE)\n+\t\t  && TREE_CODE (TREE_VALUE (fndecls)) != OVERLOAD)\n \t\t{\n \t\t  tree access, fndecl;\n \n@@ -2365,7 +2373,7 @@ build_x_function_call (function, params, decl)\n \n   /* A friend template.  Make it look like a toplevel declaration.  */\n   if (! is_method && TREE_CODE (function) == TEMPLATE_DECL)\n-    function = build_scratch_list (NULL_TREE, function);\n+    function = scratch_ovl_cons (function, NULL_TREE);\n \n   /* Handle methods, friends, and overloaded functions, respectively.  */\n   if (is_method)\n@@ -2453,7 +2461,7 @@ build_x_function_call (function, params, decl)\n     }\n   else if (really_overloaded_fn (function))\n     {\n-      if (TREE_VALUE (function) == NULL_TREE)\n+      if (OVL_FUNCTION (function) == NULL_TREE)\n \t{\n \t  cp_error (\"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?\",\n \t\t    TREE_PURPOSE (function));\n@@ -2467,6 +2475,9 @@ build_x_function_call (function, params, decl)\n \t  return build_new_function_call (function, params);\n \t}\n     }\n+  else\n+    /* Remove a potential OVERLOAD around it */\n+    function = OVL_CURRENT (function);\n \n  do_x_function:\n   if (TREE_CODE (function) == OFFSET_REF)\n@@ -2673,7 +2684,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t  && name\n \t  && IDENTIFIER_LENGTH (name) == 4\n \t  && ! strcmp (IDENTIFIER_POINTER (name), \"main\")\n-\t  && DECL_CONTEXT (function) == NULL_TREE)\n+\t  && DECL_CONTEXT (function) == global_namespace)\n \t{\n \t  pedwarn (\"ANSI C++ forbids calling `main' from within program\");\n \t}\n@@ -4437,7 +4448,7 @@ build_unary_op (code, xarg, noconvert)\n       else if (pedantic\n \t       && TREE_CODE (arg) == FUNCTION_DECL\n \t       && DECL_NAME (arg)\n-\t       && DECL_CONTEXT (arg) == NULL_TREE\n+\t       && DECL_CONTEXT (arg) == global_namespace\n \t       && IDENTIFIER_LENGTH (DECL_NAME (arg)) == 4\n \t       && IDENTIFIER_POINTER (DECL_NAME (arg))[0] == 'm'\n \t       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (arg)), \"main\"))\n@@ -4488,15 +4499,16 @@ build_unary_op (code, xarg, noconvert)\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n-      if (TREE_CODE (arg) == TREE_LIST)\n+      if (TREE_CODE (arg) == OVERLOAD)\n+\treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n+      else if (TREE_CODE (arg) == TREE_LIST)\n \t{\n-\t  if (TREE_CODE (TREE_VALUE (arg)) == FUNCTION_DECL\n-\t      && DECL_CHAIN (TREE_VALUE (arg)) == NULL_TREE)\n+\t  if (TREE_CODE (TREE_VALUE (arg)) == FUNCTION_DECL)\n \t    /* Unique overloaded non-member function.  */\n \t    return build_unary_op (ADDR_EXPR, TREE_VALUE (arg), 0);\n \t  if (TREE_CHAIN (arg) == NULL_TREE\n \t      && TREE_CODE (TREE_VALUE (arg)) == TREE_LIST\n-\t      && DECL_CHAIN (TREE_VALUE (TREE_VALUE (arg))) == NULL_TREE)\n+\t      && TREE_CODE (TREE_VALUE (TREE_VALUE (arg))) != OVERLOAD)\n \t    /* Unique overloaded member function.  */\n \t    return build_unary_op (ADDR_EXPR, TREE_VALUE (TREE_VALUE (arg)),\n \t\t\t\t   0);\n@@ -6500,7 +6512,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   if (rhs == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_VALUE (rhs) == error_mark_node)\n+  if (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node)\n     return error_mark_node;\n \n   if (TREE_CODE (TREE_TYPE (rhs)) == OFFSET_TYPE)"}]}