{"sha": "3dc85dfb4af5543dc2b997d19e4c33260e58983b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjODVkZmI0YWY1NTQzZGMyYjk5N2QxOWU0YzMzMjYwZTU4OTgzYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-21T16:10:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-21T16:10:36Z"}, "message": "real.c (struct real_format): Move to real.h.\n\n\t* real.c (struct real_format): Move to real.h.\n\t(real_format_for_mode): Rename from fmt_for_mode; update all users;\n\tinitialize with ieee defaults.\n\t(real_to_target_fmt, real_from_target_fmt): New.\n\t(ieee_single_format, ieee_double_format, ieee_extended_motorola_format,\n\tieee_extended_intel_96_format, ieee_extended_intel_128_format,\n\tieee_quad_format, i370_single_format, i370_double_format,\n\tc4x_single_format, c4x_extended_format): Rename from s/_format//.\n\t(ieee_quad_format): Fix emin.\n\t(format_for_size, init_real_once): Remove.\n\t* real.h (struct real_format): Move from real.c.\n\t(real_format_for_mode): Declare.\n\t(real_to_target_fmt, real_from_target_fmt): Declare.\n\t(ieee_single_format, ieee_double_format, ieee_extended_motorola_format,\n\tieee_extended_intel_96_format, ieee_extended_intel_128_format,\n\tieee_quad_format, vax_f_format, vax_d_format, vax_g_format,\n\ti370_single_format, i370_double_format, c4x_single_format,\n\tc4x_extended_format): Declare.\n\t* toplev.c (do_compile): Don't call init_real_once.\n\n\t* defaults.h (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n\t* doc/tm.texi (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n\n\t* config/alpha/alpha.h (TARGET_FLOAT_FORMAT): Define.\n\t* config/alpha/osf5.h (LONG_DOUBLE_TYPE_SIZE): 64, if vax mode.\n\t* config/alpha/alpha.c (override_options): Set real_format_for_mode\n\tfor VAX, if enabled.\n\n\t* config/c4x/c4x.c (c4x_override_options): Set real_format_for_mode\n\tfor C4X.\n\n\t* config/i370/i370.h (OVERRIDE_OPTIONS): New.\n\t* config/i370/i370.c (override_options): New.\n\t* config/i370/i370-protos.h: Update.\n\n\t* config/i386/i386.c (override_options): Set real_format_for_mode\n\tfor Intel 80-bit extended.\n\t* config/i386/i386.h (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n\n\t* config/i960/i960.h (LONG_DOUBLE_TYPE_SIZE): Mind -mlong-double-64.\n\t(OVERRIDE_OPTIONS): Move code...\n\t* config/i960/i960.c (i960_initialize): ... here.  Set\n\treal_format_for_mode for Intel 80-bit extended.\n\n\t* config/ia64/ia64.c (ia64_override_options): Set real_format_for_mode\n\tfor Intel 80-bit extended, if enabled.\n\n\t* config/m68k/m68k.c (override_options): Set real_format_for_mode\n        for Motorola 96-bit extended.\n\n\t* config/vax/vax.h (OVERRIDE_OPTIONS): New.\n\t* config/vax/vax.c (override_options): New.\n\t* config/vax/vax-protos.h: Update.\n\nFrom-SVN: r57388", "tree": {"sha": "cf255ab7cc385de8be819f436b5513ec3c5357c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf255ab7cc385de8be819f436b5513ec3c5357c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dc85dfb4af5543dc2b997d19e4c33260e58983b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc85dfb4af5543dc2b997d19e4c33260e58983b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dc85dfb4af5543dc2b997d19e4c33260e58983b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc85dfb4af5543dc2b997d19e4c33260e58983b/comments", "author": null, "committer": null, "parents": [{"sha": "838dfd8a4ef2572d4831643b01d70f78ba6e7747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838dfd8a4ef2572d4831643b01d70f78ba6e7747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/838dfd8a4ef2572d4831643b01d70f78ba6e7747"}], "stats": {"total": 564, "additions": 321, "deletions": 243}, "files": [{"sha": "62058c3c93942d12b39199299a2b1b80d3d45134", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -1,3 +1,59 @@\n+2002-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.c (struct real_format): Move to real.h.\n+\t(real_format_for_mode): Rename from fmt_for_mode; update all users;\n+\tinitialize with ieee defaults.\n+\t(real_to_target_fmt, real_from_target_fmt): New.\n+\t(ieee_single_format, ieee_double_format, ieee_extended_motorola_format,\n+\tieee_extended_intel_96_format, ieee_extended_intel_128_format,\n+\tieee_quad_format, i370_single_format, i370_double_format, \n+\tc4x_single_format, c4x_extended_format): Rename from s/_format//.\n+\t(ieee_quad_format): Fix emin.\n+\t(format_for_size, init_real_once): Remove.\n+\t* real.h (struct real_format): Move from real.c.\n+\t(real_format_for_mode): Declare.\n+\t(real_to_target_fmt, real_from_target_fmt): Declare.\n+\t(ieee_single_format, ieee_double_format, ieee_extended_motorola_format,\n+\tieee_extended_intel_96_format, ieee_extended_intel_128_format,\n+\tieee_quad_format, vax_f_format, vax_d_format, vax_g_format,\n+\ti370_single_format, i370_double_format, c4x_single_format,\n+\tc4x_extended_format): Declare.\n+\t* toplev.c (do_compile): Don't call init_real_once.\n+\n+\t* defaults.h (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n+\t* doc/tm.texi (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n+\n+\t* config/alpha/alpha.h (TARGET_FLOAT_FORMAT): Define.\n+\t* config/alpha/osf5.h (LONG_DOUBLE_TYPE_SIZE): 64, if vax mode.\n+\t* config/alpha/alpha.c (override_options): Set real_format_for_mode\n+\tfor VAX, if enabled.\n+\n+\t* config/c4x/c4x.c (c4x_override_options): Set real_format_for_mode\n+\tfor C4X.\n+\n+\t* config/i370/i370.h (OVERRIDE_OPTIONS): New.\n+\t* config/i370/i370.c (override_options): New.\n+\t* config/i370/i370-protos.h: Update.\n+\n+\t* config/i386/i386.c (override_options): Set real_format_for_mode\n+\tfor Intel 80-bit extended.\n+\t* config/i386/i386.h (INTEL_EXTENDED_IEEE_FORMAT): Remove.\n+\n+\t* config/i960/i960.h (LONG_DOUBLE_TYPE_SIZE): Mind -mlong-double-64.\n+\t(OVERRIDE_OPTIONS): Move code...\n+\t* config/i960/i960.c (i960_initialize): ... here.  Set\n+\treal_format_for_mode for Intel 80-bit extended.\n+\n+\t* config/ia64/ia64.c (ia64_override_options): Set real_format_for_mode\n+\tfor Intel 80-bit extended, if enabled.\n+\n+\t* config/m68k/m68k.c (override_options): Set real_format_for_mode\n+        for Motorola 96-bit extended.\n+\n+\t* config/vax/vax.h (OVERRIDE_OPTIONS): New.\n+\t* config/vax/vax.c (override_options): New.\n+\t* config/vax/vax-protos.h: Update.\n+\n 2002-09-21  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.md (builtin_setjmp_receiver): Add"}, {"sha": "d26cb547425b6b5bb85839eca01eeaccd062bbb1", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -567,6 +567,14 @@ override_options ()\n \n   /* Set up function hooks.  */\n   init_machine_status = alpha_init_machine_status;\n+\n+  /* Tell the compiler when we're using VAX floating point.  */\n+  if (TARGET_FLOAT_VAX)\n+    {\n+      real_format_for_mode[SFmode - QFmode] = &vax_f_format;\n+      real_format_for_mode[DFmode - QFmode] = &vax_g_format;\n+      real_format_for_mode[TFmode - QFmode] = NULL;\n+    }\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */"}, {"sha": "4e94e881cc06416f02644b321f6a51b4cd48ab38", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -411,6 +411,10 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n /* Define the size of `long long'.  The default is the twice the word size.  */\n #define LONG_LONG_TYPE_SIZE 64\n \n+/* We're IEEE unless someone says to use VAX.  */\n+#define TARGET_FLOAT_FORMAT \\\n+  (TARGET_FLOAT_VAX ? VAX_FLOAT_FORMAT : IEEE_FLOAT_FORMAT)\n+\n /* The two floating-point formats we support are S-floating, which is\n    4 bytes, and T-floating, which is 8 bytes.  `float' is S and `double'\n    and `long double' are T.  */"}, {"sha": "e483124691e76adda843148c81e0ef56a1a46a6a", "filename": "gcc/config/alpha/osf5.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Fosf5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Falpha%2Fosf5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf5.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -18,8 +18,12 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+/* Tru64 5.1 uses IEEE QUAD format.  */\n+/* ??? However, since there is no support for VAX H_floating, we must\n+   drop back to a 64-bit long double to avoid a crash looking for the\n+   format associated with TFmode.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE  128\n+#define LONG_DOUBLE_TYPE_SIZE  (TARGET_FLOAT_VAX ? 64 : 128)\n \n /* In Tru64 UNIX V5.1, Compaq introduced a new assembler\n    (/usr/lib/cmplrs/cc/adu) which currently (versions between 3.04.29 and"}, {"sha": "cbf056798269eb73da80b0cdd1551fec21de171b", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -294,6 +294,11 @@ c4x_override_options ()\n      This provides compatibility with the old -mno-aliases option.  */\n   if (! TARGET_ALIASES && ! flag_argument_noalias)\n     flag_argument_noalias = 1;\n+\n+  /* We're C4X floating point, not IEEE floating point.  */\n+  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n+  real_format_for_mode[QFmode - QFmode] = &c4x_single_format;\n+  real_format_for_mode[HFmode - QFmode] = &c4x_extended_format;\n }\n \n "}, {"sha": "a3f4acd8eb8a138e0a49271a3e1ef1c054d83609", "filename": "gcc/config/i370/i370-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -24,6 +24,8 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_I370_PROTOS_H\n #define GCC_I370_PROTOS_H\n \n+extern void override_options PARAMS ((void));\n+\n #ifdef RTX_CODE\n extern int i370_branch_dest PARAMS ((rtx));\n extern int i370_branch_length PARAMS ((rtx));"}, {"sha": "b4474db3273bbc70cf1dd160460309b5a5c84318", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -315,6 +315,18 @@ static const unsigned char ebcasc[256] =\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Set global variables as needed for the options enabled.  */\n+\n+void\n+override_options ()\n+{\n+  /* We're 370 floating point, not IEEE floating point.  */\n+  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n+  real_format_for_mode[SFmode - QFmode] = &i370_single_format;\n+  real_format_for_mode[DFmode - QFmode] = &i370_double_format;\n+}\n+\n+\n /* Map characters from one character set to another.\n    C is the character to be translated.  */\n "}, {"sha": "a2aff6754d92a140794bc1d764b39523f973db80", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -76,6 +76,8 @@ extern int mvs_function_name_length;\n   { \"no-char-instructions\", -1, N_(\"Do not generate char instructions\")}, \\\n   { \"\", TARGET_DEFAULT, 0} }\n \n+#define OVERRIDE_OPTIONS  override_options ()\n+\n /* To use IBM supplied macro function prologue and epilogue, define the\n    following to 1.  Should only be needed if IBM changes the definition\n    of their prologue and epilogue.  */"}, {"sha": "252c724f2dec9f20a2f8d6bb449679d63cee11dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -937,6 +937,11 @@ override_options ()\n \n   int const pta_size = ARRAY_SIZE (processor_alias_table);\n \n+  /* By default our XFmode is the 80-bit extended format.  If we have\n+     use TFmode instead, it's also the 80-bit format, but with padding.  */\n+  real_format_for_mode[XFmode - QFmode] = &ieee_extended_intel_96_format;\n+  real_format_for_mode[TFmode - QFmode] = &ieee_extended_intel_128_format;\n+\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif"}, {"sha": "7cd3962b195f88d65c8e64ef29c418ea3dd64fd1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -631,18 +631,14 @@ extern int x86_prefetch_sse;\n \n /* Define for XFmode or TFmode extended real floating point support.\n    The XFmode is specified by i386 ABI, while TFmode may be faster\n-   due to alignment and simplifications in the address calculations.\n- */\n+   due to alignment and simplifications in the address calculations.  */\n #define LONG_DOUBLE_TYPE_SIZE (TARGET_128BIT_LONG_DOUBLE ? 128 : 96)\n #define MAX_LONG_DOUBLE_TYPE_SIZE 128\n #ifdef __x86_64__\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n #else\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 96\n #endif\n-/* Tell real.c that this is the 80-bit Intel extended float format\n-   packaged in a 128-bit or 96bit entity.  */\n-#define INTEL_EXTENDED_IEEE_FORMAT 1\n \n /* Set the value of FLT_EVAL_METHOD in float.h.  When using only the\n    FPU, assume that the fpcw is set to extended precision; when using"}, {"sha": "7dbe85240cfa320872f73058b0e744077794818c", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -100,11 +100,47 @@ static int ret_label = 0;\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Initialize variables before compiling any files.  */\n+/* Override conflicting target switch options.\n+   Doesn't actually detect if more than one -mARCH option is given, but\n+   does handle the case of two blatantly conflicting -mARCH options.\n+\n+   Also initialize variables before compiling any files.  */\n \n void\n i960_initialize ()\n {\n+  if (TARGET_K_SERIES && TARGET_C_SERIES)\n+    {\n+      warning (\"conflicting architectures defined - using C series\");\n+      target_flags &= ~TARGET_FLAG_K_SERIES;\n+    }\n+  if (TARGET_K_SERIES && TARGET_MC)\n+    {\n+      warning (\"conflicting architectures defined - using K series\");\n+      target_flags &= ~TARGET_FLAG_MC;\n+    }\n+  if (TARGET_C_SERIES && TARGET_MC)\n+    {\n+      warning (\"conflicting architectures defined - using C series\");\n+      target_flags &= ~TARGET_FLAG_MC;\n+    }\n+  if (TARGET_IC_COMPAT3_0)\n+    {\n+      flag_short_enums = 1;\n+      flag_signed_char = 1;\n+      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n+      if (TARGET_IC_COMPAT2_0)\n+\t{\n+\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\");\n+\t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\n+\t}\n+    }\n+  if (TARGET_IC_COMPAT2_0)\n+    {\n+      flag_signed_char = 1;\n+      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n+    }\n+\n   if (TARGET_IC_COMPAT2_0)\n     {\n       i960_maxbitalignment = 8;\n@@ -115,6 +151,9 @@ i960_initialize ()\n       i960_maxbitalignment = 128;\n       i960_last_maxbitalignment = 8;\n     }\n+\n+  /* Tell the compiler which flavor of XFmode we're using.  */\n+  real_format_for_mode[XFmode - QFmode] = &ieee_extended_intel_96_format;\n }\n \f\n /* Return true if OP can be used as the source of an fp move insn.  */"}, {"sha": "a669cf462b17c5c58754e8c08944ff6daa92f879", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -335,44 +335,7 @@ extern int target_flags;\n /* Override conflicting target switch options.\n    Doesn't actually detect if more than one -mARCH option is given, but\n    does handle the case of two blatantly conflicting -mARCH options.  */\n-#define OVERRIDE_OPTIONS\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (TARGET_K_SERIES && TARGET_C_SERIES)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using C series\"); \\\n-      target_flags &= ~TARGET_FLAG_K_SERIES;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (TARGET_K_SERIES && TARGET_MC)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using K series\"); \\\n-      target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (TARGET_C_SERIES && TARGET_MC)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using C series\");\\\n-      target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (TARGET_IC_COMPAT3_0)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      flag_short_enums = 1;\t\t\t\t\t\\\n-      flag_signed_char = 1;\t\t\t\t\t\\\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\t\t\\\n-      if (TARGET_IC_COMPAT2_0)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\"); \\\n-\t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (TARGET_IC_COMPAT2_0)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      flag_signed_char = 1;\t\t\t\t\t\\\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  /* ??? See the LONG_DOUBLE_TYPE_SIZE definition below.  */\t\\\n-  if (TARGET_LONG_DOUBLE_64)\t\t\t\t\t\\\n-    warning (\"the -mlong-double-64 option does not work yet\");\\\n-  i960_initialize ();\t\t\t\t\t\t\\\n-}\n+#define OVERRIDE_OPTIONS  i960_initialize ()\n \n /* Don't enable anything by default.  The user is expected to supply a -mARCH\n    option.  If none is given, then -mka is added by CC1_SPEC.  */\n@@ -402,10 +365,7 @@ extern int target_flags;\n /* Width in bits of a long double.  Define to 96, and let\n    ROUND_TYPE_ALIGN adjust the alignment for speed.  */\n #define\tLONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_64 ? 64 : 96)\n-\n-/* ??? This must be a constant, because real.c and real.h test it with #if.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 96\n+#define MAX_LONG_DOUBLE_TYPE_SIZE 96\n \n /* Define this to set long double type size to use in libgcc2.c, which can\n    not depend on target_flags.  */"}, {"sha": "d1af4a0d418217946ecad4017ac390552c81e5ff", "filename": "gcc/config/ia64/hpux_longdouble.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -18,8 +18,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Tell real.c that we are not using INTEL_EXTENDED_IEEE_FORMAT */\n-\n+/* We are using IEEE quad precision, not a double-extended with padding.  */\n #undef INTEL_EXTENDED_IEEE_FORMAT\n #define INTEL_EXTENDED_IEEE_FORMAT 0\n "}, {"sha": "ad2d9b7645f77d5caebfedb5578584faeb207975", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -4182,6 +4182,10 @@ ia64_override_options ()\n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n   init_machine_status = ia64_init_machine_status;\n+\n+  /* Tell the compiler which flavor of TFmode we're using.  */\n+  if (INTEL_EXTENDED_IEEE_FORMAT)\n+    real_format_for_mode[TFmode - QFmode] = &ieee_extended_intel_128_format;\n }\n \f\n static enum attr_itanium_requires_unit0 ia64_safe_itanium_requires_unit0 PARAMS((rtx));"}, {"sha": "31dd3cde7498a605c935df898baa9a4e3a0ea69c", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -381,9 +381,8 @@ while (0)\n \n #define LONG_DOUBLE_TYPE_SIZE 128\n \n-/* Tell real.c that this is the 80-bit Intel extended float format\n-   packaged in a 128-bit entity.  */\n-\n+/* By default we use the 80-bit Intel extended float format packaged\n+   in a 128-bit entity.  */\n #define INTEL_EXTENDED_IEEE_FORMAT 1\n \n #define DEFAULT_SIGNED_CHAR 1"}, {"sha": "6114664bb8b161bc101895f7394f30b1f0c412ed", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -174,6 +174,9 @@ override_options ()\n       else\n \tm68k_align_funcs = i;\n     }\n+\n+  /* Tell the compiler which flavor of XFmode we're using.  */\n+  real_format_for_mode[XFmode - QFmode] = &ieee_extended_motorola_format;\n }\n \f\n /* This function generates the assembly code for function entry."}, {"sha": "059994f11968e47fcb8e789126c194476d6189a7", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+extern void override_options PARAMS ((void));\n+\n #ifdef RTX_CODE\n extern const char *rev_cond_name PARAMS ((rtx));\n extern void split_quadword_operands PARAMS ((rtx *, rtx *, int));"}, {"sha": "1a83eba2ff8d65854adb00d111a0594d44036bf9", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -66,6 +66,18 @@ static void vms_globalize_label PARAMS ((FILE *, const char *));\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Set global variables as needed for the options enabled.  */\n+\n+void\n+override_options ()\n+{\n+  /* We're VAX floating point, not IEEE floating point.  */\n+  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n+  real_format_for_mode[SFmode - QFmode] = &vax_f_format;\n+  real_format_for_mode[DFmode - QFmode]\n+    = (TARGET_G_FLOAT ? &vax_g_format : &vax_d_format);\n+}\n+\n /* Generate the assembly code for function entry.  FILE is a stdio\n    stream to output the code to.  SIZE is an int: how many units of\n    temporary storage to allocate."}, {"sha": "6651a0260c522ce5bd03abbe1c87c983f5c1e8f3", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -106,6 +106,9 @@ extern int target_flags;\n #ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_UNIX_ASM)\n #endif\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n \f\n /* Target machine storage layout */\n "}, {"sha": "700d04e77978c237da4164a69e20f74d3f651696", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -576,10 +576,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n    && !ROUND_TOWARDS_ZERO)\n #endif\n \n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n-#define INTEL_EXTENDED_IEEE_FORMAT 0\n-#endif\n-\n /* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n    in the header files, then this implies the word-endianness is the same as\n    for integers.  */"}, {"sha": "c328ce709fa38cd054a9a10f4decfc896ece18f6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -1530,13 +1530,6 @@ target machine.  If this is undefined, the default is\n the largest value that @code{LONG_DOUBLE_TYPE_SIZE} can have at run-time.\n This is used in @code{cpp}.\n \n-@findex INTEL_EXTENDED_IEEE_FORMAT\n-@item INTEL_EXTENDED_IEEE_FORMAT\n-Define this macro to be 1 if the target machine uses 80-bit floating-point\n-values with 128-bit size and alignment.  This is used in @file{real.c}.\n-This also distinguishes the Intel 80-bit floating-point format from the\n-Motorola 96-bit floating-point format.\n-\n @findex TARGET_FLT_EVAL_METHOD\n @item TARGET_FLT_EVAL_METHOD\n A C expression for the value for @code{FLT_EVAL_METHOD} in @file{float.h},"}, {"sha": "1f73f9de2e959453d0768087b5c83c0c5e5462e4", "filename": "gcc/real.c", "status": "modified", "additions": 94, "deletions": 170, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -70,42 +70,6 @@\n  #error \"Some constant folding done by hand to avoid shift count warnings\"\n #endif\n \n-/* Describes the properties of the specific target format in use.  */\n-struct real_format\n-{\n-  /* Move to and from the target bytes.  */\n-  void (*encode) (const struct real_format *, long *,\n-\t\t  const REAL_VALUE_TYPE *);\n-  void (*decode) (const struct real_format *, REAL_VALUE_TYPE *,\n-\t\t  const long *);\n-\n-  /* The radix of the exponent and digits of the significand.  */\n-  int b;\n-\n-  /* log2(b).  */\n-  int log2_b;\n-\n-  /* Size of the significand in digits of radix B.  */\n-  int p;\n-\n-  /* The minimum negative integer, x, such that b**(x-1) is normalized.  */\n-  int emin;\n-\n-  /* The maximum integer, x, such that b**(x-1) is representable.  */\n-  int emax;\n-\n-  /* Properties of the format.  */\n-  bool has_nans;\n-  bool has_inf;\n-  bool has_denorm;\n-  bool has_signed_zero;\n-  bool qnan_msb_set;\n-};\n-\n-\n-static const struct real_format *fmt_for_mode[TFmode - QFmode + 1];\n-\n-\n static void get_zero PARAMS ((REAL_VALUE_TYPE *, int));\n static void get_canonical_qnan PARAMS ((REAL_VALUE_TYPE *, int));\n static void get_canonical_snan PARAMS ((REAL_VALUE_TYPE *, int));\n@@ -1942,7 +1906,7 @@ real_nan (r, str, quiet, mode)\n {\n   const struct real_format *fmt;\n \n-  fmt = fmt_for_mode[mode - QFmode];\n+  fmt = real_format_for_mode[mode - QFmode];\n   if (fmt == NULL)\n     abort ();\n \n@@ -2211,7 +2175,7 @@ real_convert (r, mode, a)\n {\n   const struct real_format *fmt;\n \n-  fmt = fmt_for_mode[mode - QFmode];\n+  fmt = real_format_for_mode[mode - QFmode];\n   if (fmt == NULL)\n     abort ();\n \n@@ -2247,26 +2211,21 @@ exact_real_truncate (mode, a)\n   return real_identical (&t, a);\n }\n \n-/* Write R to the target format of MODE.  Place the words of the \n-   result in target word order in BUF.  There are always 32 bits\n-   in each long, no matter the size of the host long.\n+/* Write R to the given target format.  Place the words of the result\n+   in target word order in BUF.  There are always 32 bits in each\n+   long, no matter the size of the host long.\n \n    Legacy: return word 0 for implementing REAL_VALUE_TO_TARGET_SINGLE.  */\n \n long\n-real_to_target (buf, r_orig, mode)\n+real_to_target_fmt (buf, r_orig, fmt)\n      long *buf;\n      const REAL_VALUE_TYPE *r_orig;\n-     enum machine_mode mode;\n+     const struct real_format *fmt;\n {\n   REAL_VALUE_TYPE r;\n-  const struct real_format *fmt;\n   long buf1;\n \n-  fmt = fmt_for_mode[mode - QFmode];\n-  if (fmt == NULL)\n-    abort ();\n-\n   r = *r_orig;\n   round_for_format (fmt, &r);\n \n@@ -2277,9 +2236,37 @@ real_to_target (buf, r_orig, mode)\n   return *buf;\n }\n \n-/* Read R from the target format of MODE.  Read the words of the\n-   result in target word order in BUF.  There are always 32 bits\n-   in each long, no matter the size of the host long.  */\n+/* Similar, but look up the format from MODE.  */\n+\n+long\n+real_to_target (buf, r, mode)\n+     long *buf;\n+     const REAL_VALUE_TYPE *r;\n+     enum machine_mode mode;\n+{\n+  const struct real_format *fmt;\n+\n+  fmt = real_format_for_mode[mode - QFmode];\n+  if (fmt == NULL)\n+    abort ();\n+\n+  return real_to_target_fmt (buf, r, fmt);\n+}\n+\n+/* Read R from the given target format.  Read the words of the result\n+   in target word order in BUF.  There are always 32 bits in each\n+   long, no matter the size of the host long.  */\n+\n+void\n+real_from_target_fmt (r, buf, fmt)\n+     REAL_VALUE_TYPE *r;\n+     const long *buf;\n+     const struct real_format *fmt;\n+{\n+  (*fmt->decode) (fmt, r, buf);\n+}     \n+\n+/* Similar, but look up the format from MODE.  */\n \n void\n real_from_target (r, buf, mode)\n@@ -2289,7 +2276,7 @@ real_from_target (r, buf, mode)\n {\n   const struct real_format *fmt;\n \n-  fmt = fmt_for_mode[mode - QFmode];\n+  fmt = real_format_for_mode[mode - QFmode];\n   if (fmt == NULL)\n     abort ();\n \n@@ -2305,7 +2292,7 @@ significand_size (mode)\n {\n   const struct real_format *fmt;\n \n-  fmt = fmt_for_mode[mode - QFmode];\n+  fmt = real_format_for_mode[mode - QFmode];\n   if (fmt == NULL)\n     return 0;\n \n@@ -2467,7 +2454,7 @@ decode_ieee_single (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_single = \n+const struct real_format ieee_single_format = \n   {\n     encode_ieee_single,\n     decode_ieee_single,\n@@ -2660,7 +2647,7 @@ decode_ieee_double (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_double = \n+const struct real_format ieee_double_format = \n   {\n     encode_ieee_double,\n     decode_ieee_double,\n@@ -2915,7 +2902,7 @@ decode_ieee_extended_128 (fmt, r, buf)\n   decode_ieee_extended (fmt, r, buf+!!FLOAT_WORDS_BIG_ENDIAN);\n }\n \n-const struct real_format ieee_extended_motorola = \n+const struct real_format ieee_extended_motorola_format = \n   {\n     encode_ieee_extended,\n     decode_ieee_extended,\n@@ -2931,7 +2918,7 @@ const struct real_format ieee_extended_motorola =\n     true\n   };\n \n-const struct real_format ieee_extended_intel_96 = \n+const struct real_format ieee_extended_intel_96_format = \n   {\n     encode_ieee_extended,\n     decode_ieee_extended,\n@@ -2947,7 +2934,7 @@ const struct real_format ieee_extended_intel_96 =\n     true\n   };\n \n-const struct real_format ieee_extended_intel_128 = \n+const struct real_format ieee_extended_intel_128_format = \n   {\n     encode_ieee_extended_128,\n     decode_ieee_extended_128,\n@@ -3200,25 +3187,32 @@ decode_ieee_quad (fmt, r, buf)\n     }\n }\n \n-const struct real_format ieee_quad = \n+const struct real_format ieee_quad_format = \n   {\n     encode_ieee_quad,\n     decode_ieee_quad,\n     2,\n     1,\n     113,\n-    -16382,\n+    -16381,\n     16384,\n     true,\n     true,\n     true,\n     true,\n     true\n   };\n-\n \f\n-/* The VAX floating point formats.  */\n+/* Descriptions of VAX floating point formats can be found beginning at\n+\n+   http://www.openvms.compaq.com:8000/73final/4515/4515pro_013.html#f_floating_point_format\n+\n+   The thing to remember is that they're almost IEEE, except for word\n+   order, exponent bias, and the lack of infinities, nans, and denormals.\n \n+   We don't implement the H_floating format here, simply because neither\n+   the VAX or Alpha ports use it.  */\n+   \n static void encode_vax_f PARAMS ((const struct real_format *fmt,\n \t\t\t\t  long *, const REAL_VALUE_TYPE *));\n static void decode_vax_f PARAMS ((const struct real_format *,\n@@ -3547,11 +3541,10 @@ const struct real_format vax_g_format =\n     false,\n     false\n   };\n-\n \f\n-/* The IBM S/390 floating point formats.  A good reference for these can\n-   be found in chapter 9 of \"ESA/390 Principles of Operation\", IBM document\n-   number SA22-7201-01.  An on-line version can be found here:\n+/* A good reference for these can be found in chapter 9 of\n+   \"ESA/390 Principles of Operation\", IBM document number SA22-7201-01.\n+   An on-line version can be found here:\n \n    http://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS/DZ9AR001/9.1?DT=19930923083613\n */\n@@ -3714,7 +3707,7 @@ decode_i370_double (fmt, r, buf)\n     }\n }\n \n-const struct real_format i370_single =\n+const struct real_format i370_single_format =\n   {\n     encode_i370_single,\n     decode_i370_single,\n@@ -3730,7 +3723,7 @@ const struct real_format i370_single =\n     false\n   };\n \n-const struct real_format i370_double =\n+const struct real_format i370_double_format =\n   {\n     encode_i370_double,\n     decode_i370_double,\n@@ -3745,9 +3738,25 @@ const struct real_format i370_double =\n     false, /* ??? The encoding does allow for \"unnormals\".  */\n     false\n   };\n-\n \f\n-/* TMS320C[34]x twos complement floating point format.  */\n+/* The \"twos-compliment\" c4x format is officially defined as\n+\n+\tx = s(~s).f * 2**e\n+\n+   This is rather misleading.  One must remember that F is signed.\n+   A better description would be\n+\n+\tx = -1**s * ((s + 1 + .f) * 2**e\n+\n+   So if we have a (4 bit) fraction of .1000 with a sign bit of 1,\n+   that's -1 * (1+1+(-.5)) == -1.5.  I think.\n+\n+   The constructions here are taken from Tables 5-1 and 5-2 of the\n+   TMS320C4x User's Guide wherein step-by-step instructions for\n+   conversion from IEEE are presented.  That's close enough to our\n+   internal representation so as to make things easy.\n+\n+   See http://www-s.ti.com/sc/psheets/spru063c/spru063c.pdf  */\n \n static void encode_c4x_single PARAMS ((const struct real_format *fmt,\n \t\t\t\t       long *, const REAL_VALUE_TYPE *));\n@@ -3928,7 +3937,7 @@ decode_c4x_extended (fmt, r, buf)\n     }\n }\n \n-const struct real_format c4x_single = \n+const struct real_format c4x_single_format = \n   {\n     encode_c4x_single,\n     decode_c4x_single,\n@@ -3944,7 +3953,7 @@ const struct real_format c4x_single =\n     false\n   };\n \n-const struct real_format c4x_extended = \n+const struct real_format c4x_extended_format = \n   {\n     encode_c4x_extended,\n     decode_c4x_extended,\n@@ -3959,105 +3968,20 @@ const struct real_format c4x_extended =\n     false,\n     false\n   };\n-\n \f\n-/* Initialize things at start of compilation.  */\n-\n-static const struct real_format * format_for_size PARAMS ((int));\n-\n-static const struct real_format *\n-format_for_size (size)\n-     int size;\n-{\n-#ifndef TARGET_G_FORMAT\n-#define TARGET_G_FORMAT 0\n-#endif\n-\n-  switch (TARGET_FLOAT_FORMAT)\n-    {\n-    case IEEE_FLOAT_FORMAT:\n-      switch (size)\n-\t{\n-\tcase 32:\n-\t  return &ieee_single;\n-\n-\tcase 64:\n-\t  return &ieee_double;\n-\n-\tcase 96:\n-\t  if (!INTEL_EXTENDED_IEEE_FORMAT)\n-\t    return &ieee_extended_motorola;\n-\t  else\n-\t    return &ieee_extended_intel_96;\n-\n-\tcase 128:\n-\t  if (!INTEL_EXTENDED_IEEE_FORMAT)\n-\t    return &ieee_quad;\n-\t  else\n-\t    return &ieee_extended_intel_128;\n-\t}\n-      break;\n-\n-    case VAX_FLOAT_FORMAT:\n-      switch (size)\n-\t{\n-\tcase 32:\n-\t  return &vax_f_format;\n-\n-\tcase 64:\n-\t  if (TARGET_G_FORMAT)\n-\t    return &vax_g_format;\n-\t  else\n-\t    return &vax_d_format;\n-\t}\n-      break;\n-\n-    case IBM_FLOAT_FORMAT:\n-      switch (size)\n-\t{\n-\tcase 32:\n-\t  return &i370_single;\n-\tcase 64:\n-\t  return &i370_double;\n-\t}\n-      break;\n-\n-    case C4X_FLOAT_FORMAT:\n-      switch (size)\n-\t{\n-\tcase 32:\n-\t  return &c4x_single;\n-\tcase 64:\n-\t  return &c4x_extended;\n-\t}\n-      break;\n-    }\n-\n-  abort ();\n-}\n+/* Set up default mode to format mapping for IEEE.  Everyone else has\n+   to set these values in OVERRIDE_OPTIONS.  */\n \n-void\n-init_real_once ()\n+const struct real_format *real_format_for_mode[TFmode - QFmode + 1] =\n {\n-  int i;\n-\n-  /* Set up the mode->format table.  */\n-  for (i = 0; i < 3; ++i)\n-    {\n-      enum machine_mode mode;\n-      int size;\n-\n-      if (i == 0)\n-\tsize = FLOAT_TYPE_SIZE;\n-      else if (i == 1)\n-\tsize = DOUBLE_TYPE_SIZE;\n-      else\n-\tsize = LONG_DOUBLE_TYPE_SIZE;\n-\n-      mode = mode_for_size (size, MODE_FLOAT, 0);\n-      if (mode == BLKmode)\n-\tabort ();\n+  NULL,\t\t\t\t/* QFmode */\n+  NULL,\t\t\t\t/* HFmode */\n+  NULL,\t\t\t\t/* TQFmode */\n+  &ieee_single_format,\t\t/* SFmode */\n+  &ieee_double_format,\t\t/* DFmode */\n \n-      fmt_for_mode[mode - QFmode] = format_for_size (size);\n-    }\n-}\n+  /* We explicitly don't handle XFmode.  There are two formats,\n+     pretty much equally common.  Choose one in OVERRIDE_OPTIONS.  */\n+  NULL,\t\t\t\t/* XFmode */\n+  &ieee_quad_format\t\t/* TFmode */\n+};"}, {"sha": "6f8f7d8ef04da96213b5aacc77ef3b4f17d03c34", "filename": "gcc/real.h", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -95,10 +95,44 @@ extern char test_real_width\n # endif\n #endif\n \n-/* Declare functions in real.c.  */\n \n-/* Initialize the emulator.  */\n-extern void init_real_once\tPARAMS ((void));\n+/* Describes the properties of the specific target format in use.  */\n+struct real_format\n+{\n+  /* Move to and from the target bytes.  */\n+  void (*encode) (const struct real_format *, long *, const REAL_VALUE_TYPE *);\n+  void (*decode) (const struct real_format *, REAL_VALUE_TYPE *, const long *);\n+\n+  /* The radix of the exponent and digits of the significand.  */\n+  int b;\n+\n+  /* log2(b).  */\n+  int log2_b;\n+\n+  /* Size of the significand in digits of radix B.  */\n+  int p;\n+\n+  /* The minimum negative integer, x, such that b**(x-1) is normalized.  */\n+  int emin;\n+\n+  /* The maximum integer, x, such that b**(x-1) is representable.  */\n+  int emax;\n+\n+  /* Properties of the format.  */\n+  bool has_nans;\n+  bool has_inf;\n+  bool has_denorm;\n+  bool has_signed_zero;\n+  bool qnan_msb_set;\n+};\n+\n+\n+/* The target format used for each floating floating point mode.\n+   Indexed by MODE - QFmode.  */\n+extern const struct real_format *real_format_for_mode[TFmode - QFmode + 1];\n+\n+\n+/* Declare functions in real.c.  */\n \n /* Binary or unary arithmetic on tree_code.  */\n extern void real_arithmetic\tPARAMS ((REAL_VALUE_TYPE *, int,\n@@ -156,9 +190,13 @@ extern void real_from_integer\tPARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, int));\n \n+extern long real_to_target_fmt\tPARAMS ((long *, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t const struct real_format *));\n extern long real_to_target\tPARAMS ((long *, const REAL_VALUE_TYPE *,\n \t\t\t\t\t enum machine_mode));\n \n+extern void real_from_target_fmt PARAMS ((REAL_VALUE_TYPE *, const long *,\n+\t\t\t\t\t  const struct real_format *));\n extern void real_from_target\tPARAMS ((REAL_VALUE_TYPE *, const long *,\n \t\t\t\t\t enum machine_mode));\n \n@@ -171,6 +209,23 @@ extern void real_2expN\t\tPARAMS ((REAL_VALUE_TYPE *, int));\n \n extern unsigned int real_hash\tPARAMS ((const REAL_VALUE_TYPE *));\n \n+\n+/* Target formats defined in real.c.  */\n+extern const struct real_format ieee_single_format;\n+extern const struct real_format ieee_double_format;\n+extern const struct real_format ieee_extended_motorola_format;\n+extern const struct real_format ieee_extended_intel_96_format;\n+extern const struct real_format ieee_extended_intel_128_format;\n+extern const struct real_format ieee_quad_format;\n+extern const struct real_format vax_f_format;\n+extern const struct real_format vax_d_format;\n+extern const struct real_format vax_g_format;\n+extern const struct real_format i370_single_format;\n+extern const struct real_format i370_double_format;\n+extern const struct real_format c4x_single_format;\n+extern const struct real_format c4x_extended_format;\n+\n+\n /* ====================================================================== */\n /* Crap.  */\n "}, {"sha": "366dfdf0f9a8599a80044e09795669e2b6d574a4", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc85dfb4af5543dc2b997d19e4c33260e58983b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3dc85dfb4af5543dc2b997d19e4c33260e58983b", "patch": "@@ -5322,11 +5322,6 @@ do_compile ()\n   init_timevar ();\n   timevar_start (TV_TOTAL);\n \n-  /* We need to initialize real.c in order to define __FLT_MIN__ etc,\n-     which must happen even with -E.  But with -E we'll suppress the\n-     rest of backend_init.  */\n-  init_real_once ();\n-\n   /* Set up the back-end if requested.  */\n   if (!no_backend)\n     backend_init ();"}]}