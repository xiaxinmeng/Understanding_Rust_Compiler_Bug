{"sha": "2bcb2ab32669b224d76d010a1e690857bad100aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJjYjJhYjMyNjY5YjIyNGQ3NmQwMTBhMWU2OTA4NTdiYWQxMDBhYQ==", "commit": {"author": {"name": "Gavin Koch", "email": "gavin@cygnus.com", "date": "1998-01-04T15:43:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-04T15:43:52Z"}, "message": "mips.c, [...]: First cut at merging in mips16 support.\n\n        * mips.c, mips.h, mips.md: First cut at merging in mips16\n        support.  Major modifications throughout all three files.\nNote mips16 doesn't work yet (no epilogue support), but I'll be working\non that shortly :-)\n\nCo-Authored-By: Ian Lance Taylor <ian@cygnus.com>\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r17292", "tree": {"sha": "6c752f0de8e81771418b1631ff36fdf5499ad7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c752f0de8e81771418b1631ff36fdf5499ad7af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bcb2ab32669b224d76d010a1e690857bad100aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bcb2ab32669b224d76d010a1e690857bad100aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bcb2ab32669b224d76d010a1e690857bad100aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bcb2ab32669b224d76d010a1e690857bad100aa/comments", "author": null, "committer": null, "parents": [{"sha": "d39cd7a1e974515c82a12cc377111f2fd65efe7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39cd7a1e974515c82a12cc377111f2fd65efe7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d39cd7a1e974515c82a12cc377111f2fd65efe7e"}], "stats": {"total": 6200, "additions": 5806, "deletions": 394}, "files": [{"sha": "400f65ab5878b477fe6206dd026d37ef29778776", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bcb2ab32669b224d76d010a1e690857bad100aa", "patch": "@@ -1,3 +1,10 @@\n+Sun Jan  4 14:25:18 1998  Gavin Koch  <gavin@cygnus.com>\n+                          Ian Lance Taylor  <ian@cygnus.com>\n+                          Jeff Law  <law@cygnus.com>\n+\n+\t* mips.c, mips.h, mips.md: First cut at merging in mips16\n+\tsupport.  Major modifications throughout all three files.\n+\n Sun Jan  4 01:01:50 1998  scott snyder  <snyder@d0sgif.fnal.gov>\n \n \t* configure.in: Make gthr-default.h a forwarding header instead of"}, {"sha": "6ea2659ba1c13c36b2e5a7a6deacc72ceff7d3ec", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2518, "deletions": 88, "changes": 2606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=2bcb2ab32669b224d76d010a1e690857bad100aa"}, {"sha": "e0b9cc39ee583ef07d1d7a764f7cbac84ed144b1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 510, "deletions": 101, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=2bcb2ab32669b224d76d010a1e690857bad100aa", "patch": "@@ -134,9 +134,14 @@ extern enum cmp_type branch_type;\t/* what type of branch to use */\n extern enum processor_type mips_cpu;\t/* which cpu are we scheduling for */\n extern enum mips_abicalls_type mips_abicalls;/* for svr4 abi pic calls */\n extern int mips_isa;\t\t\t/* architectural level */\n+extern int mips16;\t\t\t/* whether generating mips16 code */\n+extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n+extern int mips_entry;\t\t\t/* generate entry/exit for mips16 */\n extern char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n extern char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n extern char *mips_abi_string;\t\t/* for -misa={32,n32,64} */\n+extern char *mips_entry_string;\t\t/* for -mentry */\n+extern char *mips_no_mips16_string;\t/* for -mno-mips16 */\n extern int mips_split_addresses;\t/* perform high/lo_sum support */\n extern int dslots_load_total;\t\t/* total # load related delay slots */\n extern int dslots_load_filled;\t\t/* # filled load delay slots */\n@@ -149,6 +154,8 @@ extern struct rtx_def *mips_load_reg2;\t/* 2nd reg to check for load delay */\n extern struct rtx_def *mips_load_reg3;\t/* 3rd reg to check for load delay */\n extern struct rtx_def *mips_load_reg4;\t/* 4th reg to check for load delay */\n extern struct rtx_def *embedded_pic_fnaddr_rtx;\t/* function address */\n+extern int mips_string_length;\t\t/* length of strings for mips16 */\n+extern struct rtx_def *mips16_gp_pseudo_rtx; /* psuedo reg holding $gp */\n \n /* Functions within mips.c that we reference.  */\n \n@@ -157,7 +164,6 @@ extern int\t\tarith32_operand ();\n extern int\t\tarith_operand ();\n extern int\t\tcmp_op ();\n extern long\t\tcompute_frame_size ();\n-extern int\t\tepilogue_reg_mentioned_p ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n extern void\t\tfinal_prescan_insn ();\n@@ -200,10 +206,17 @@ extern void\t\tprint_options ();\n extern int\t\treg_or_0_operand ();\n extern int\t\tsimple_epilogue_p ();\n extern int\t\tsimple_memory_operand ();\n+extern int\t\tdouble_memory_operand ();\n extern int\t\tsmall_int ();\n extern void\t\ttrace();\n extern int\t\tuns_arith_operand ();\n extern struct rtx_def *\tembedded_pic_offset ();\n+extern void\t\tmips_order_regs_for_local_alloc ();\n+extern struct rtx_def *\tmips16_gp_pseudo_reg ();\n+extern struct rtx_def * mips16_gp_offset ();\n+extern int\t\tmips16_gp_offset_p ();\n+extern int\t\tmips16_constant_after_function_p ();\n+extern int\t\tbuild_mips16_call_stub ();\n \n /* Recognition functions that return if a condition is true.  */\n extern int\t\taddress_operand ();\n@@ -225,6 +238,24 @@ extern int\t\tse_uns_arith_operand ();\n extern int\t\tse_arith_operand ();\n extern int\t\tse_nonmemory_operand ();\n extern int\t\tse_nonimmediate_operand ();\n+extern int\t\tm16_uimm3_b ();\n+extern int\t\tm16_simm4_1 ();\n+extern int\t\tm16_nsimm4_1 ();\n+extern int\t\tm16_simm5_1 ();\n+extern int\t\tm16_nsimm5_1 ();\n+extern int\t\tm16_uimm5_4 ();\n+extern int\t\tm16_nuimm5_4 ();\n+extern int\t\tm16_simm8_1 ();\n+extern int\t\tm16_nsimm8_1 ();\n+extern int\t\tm16_uimm8_1 ();\n+extern int\t\tm16_nuimm8_1 ();\n+extern int\t\tm16_uimm8_m1_1 ();\n+extern int\t\tm16_uimm8_4 ();\n+extern int\t\tm16_nuimm8_4 ();\n+extern int\t\tm16_simm8_8 ();\n+extern int\t\tm16_nsimm8_8 ();\n+extern int\t\tm16_usym8_4 ();\n+extern int\t\tm16_usym5_4 ();\n \n /* Functions to change what output section we are using.  */\n extern void\t\tdata_section ();\n@@ -274,6 +305,7 @@ extern void\t\ttext_section ();\n #define MASK_MAD\t0x00040000\t/* Generate mad/madu as on 4650.  */\n #define MASK_4300_MUL_FIX 0x00080000    /* Work-around early Vr4300 CPU bug */\n #define MASK_MIPS3900\t0x00100000\t/* like -mips1 only 3900 */\n+#define MASK_MIPS16\t0x01000000\t/* Generate mips16 code */\n \n \t\t\t\t\t/* Dummy switches used only in spec's*/\n #define MASK_MIPS_TFILE\t0x00000000\t/* flag for mips-tfile usage */\n@@ -285,8 +317,8 @@ extern void\t\ttext_section ();\n #define MASK_DEBUG_C\t0x08000000\t/* don't expand seq, etc. */\n #define MASK_DEBUG_D\t0x04000000\t/* don't do define_split's */\n #define MASK_DEBUG_E\t0x02000000\t/* function_arg debug */\n-#define MASK_DEBUG_F\t0x01000000\t/* don't try to suppress load nop's */\n-#define MASK_DEBUG_G\t0x00800000\t/* don't support 64 bit arithmetic */\n+#define MASK_DEBUG_F\t0\n+#define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n #define MASK_DEBUG_H\t0               /* allow ints in FP registers */\n #define MASK_DEBUG_I\t0x00200000\t/* unused */\n \n@@ -373,6 +405,9 @@ extern void\t\ttext_section ();\n    to debug the resulting code.  */\n #define NO_DBX_FUNCTION_END TARGET_FILE_SWITCHING\n \n+\t\t\t\t\t/* Generate mips16 code */\n+#define TARGET_MIPS16\t\t(target_flags & MASK_MIPS16)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -500,15 +535,19 @@ extern void\t\ttext_section ();\n {\t\t\t\t\t\t\t\t\t\\\n   SUBTARGET_TARGET_OPTIONS\t\t\t\t\t\t\\\n   { \"cpu=\",\t&mips_cpu_string\t},\t\t\t\t\\\n-  { \"ips\",\t&mips_isa_string\t}\t\t\t\t\\\n+  { \"ips\",\t&mips_isa_string\t},\t\t\t\t\\\n+  { \"entry\",\t&mips_entry_string\t},\t\t\t\t\\\n+  { \"no-mips16\", &mips_no_mips16_string\t}\n }\n \n /* This is meant to be redefined in the host dependent files.  */\n #define SUBTARGET_TARGET_OPTIONS\n \n-#define GENERATE_BRANCHLIKELY  (TARGET_MIPS3900 || (mips_isa >= 2))\n-#define GENERATE_MULT3         (TARGET_MIPS3900)\n-#define GENERATE_MADD          (TARGET_MIPS3900)\n+#define GENERATE_BRANCHLIKELY  (!TARGET_MIPS16 && (TARGET_MIPS3900 || (mips_isa >= 2)))\n+#define GENERATE_MULT3         (TARGET_MIPS3900\t\t\t\t\\\n+\t\t\t\t&& !TARGET_MIPS16\n+#define GENERATE_MADD          (TARGET_MIPS3900\t\t\t\t\\\n+\t\t\t\t&& !TARGET_MIPS16)\n \n \n \n@@ -596,6 +635,22 @@ do\t\t\t\t\t\t\t\t\t\\\n \tfor (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\t\\\n \t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    /* In mips16 mode, we permit the $t temporary registers to be used\t\\\n+       for reload.  We prohibit the unused $s registers, since they\t\\\n+       are caller saved, and saving them via a mips16 register would\t\\\n+       probably waste more time than just reloading the value.  */\t\\\n+    if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfixed_regs[18] = call_used_regs[18] = 1;                        \\\n+\tfixed_regs[19] = call_used_regs[19] = 1;                        \\\n+\tfixed_regs[20] = call_used_regs[20] = 1;                        \\\n+\tfixed_regs[21] = call_used_regs[21] = 1;                        \\\n+\tfixed_regs[22] = call_used_regs[22] = 1;                        \\\n+\tfixed_regs[23] = call_used_regs[23] = 1;                        \\\n+\tfixed_regs[26] = call_used_regs[26] = 1;                        \\\n+\tfixed_regs[27] = call_used_regs[27] = 1;                        \\\n+\tfixed_regs[30] = call_used_regs[30] = 1;                        \\\n+      }\t\t\t\t\t\t\t\t\t\\\n     SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n@@ -720,6 +775,7 @@ while (0)\n \n #define ASM_SPEC \"\\\n %{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \\\n+%{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n %{membedded-pic} \\\n@@ -852,6 +908,7 @@ while (0)\n %{m4650:%{!msoft-float:-D__mips_single_float}} \\\n %{msoft-float:-D__mips_soft_float} \\\n %{mabi=eabi:-D__mips_eabi} \\\n+%{mips16:%{!mno-mips16:-D__mips16}} \\\n %{EB:-UMIPSEL -U_MIPSEL -U__MIPSEL -U__MIPSEL__ -D_MIPSEB -D__MIPSEB -D__MIPSEB__ %{!ansi:-DMIPSEB}} \\\n %{EL:-UMIPSEB -U_MIPSEB -U__MIPSEB -U__MIPSEB__ -D_MIPSEL -D__MIPSEL -D__MIPSEL__ %{!ansi:-DMIPSEL}} \\\n %(long_max_spec) \\\n@@ -1348,6 +1405,31 @@ do {\t\t\t\t\t\t\t\\\n    be the code that says which one of the two operations is implicitly\n    done, NIL if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   We promote any value smaller than SImode up to SImode.  We don't\n+   want to promote to DImode when in 64 bit mode, because that would\n+   prevent us from using the faster SImode multiply and divide\n+   instructions.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)\t\t\\\n+    (MODE) = SImode;\n+\n+/* Define this if function arguments should also be promoted using the above\n+   procedure.  */\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Likewise, if the function return value is promoted.  */\n+\n+#define PROMOTE_FUNCTION_RETURN\n \f\n /* Standard register usage.  */\n \n@@ -1436,6 +1518,8 @@ do {\t\t\t\t\t\t\t\\\n #define FPSW_REGNUM\tST_REG_FIRST\n \n #define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define M16_REG_P(REGNO) \\\n+  (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 16 || (REGNO) == 17)\n #define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n #define MD_REG_P(REGNO) ((unsigned) ((REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n #define ST_REG_P(REGNO) ((unsigned) ((REGNO) - ST_REG_FIRST) < ST_REG_NUM)\n@@ -1490,8 +1574,16 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    the default value zero.  */\n /* #define STACK_POINTER_OFFSET 0 */\n \n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 30)\n+/* Base register for access to local variables of the function.  We\n+   pretend that the frame pointer is $1, and then eliminate it to\n+   HARD_FRAME_POINTER_REGNUM.  We can get away with this because $1 is\n+   a fixed register, and will not be used for anything else.  */\n+#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 1)\n+\n+/* $30 is not available on the mips16, so we use $17 as the frame\n+   pointer.  */\n+#define HARD_FRAME_POINTER_REGNUM \\\n+  (TARGET_MIPS16 ? GP_REG_FIRST + 17 : GP_REG_FIRST + 30)\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -1552,7 +1644,11 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Initialize embedded_pic_fnaddr_rtx before RTL generation for\n    each function.  We used to do this in FINALIZE_PIC, but FINALIZE_PIC\n    isn't always called for static inline functions.  */\n-#define INIT_EXPANDERS embedded_pic_fnaddr_rtx = NULL;\n+#define INIT_EXPANDERS\t\t\t\\\n+do {\t\t\t\t\t\\\n+  embedded_pic_fnaddr_rtx = NULL;\t\\\n+  mips16_gp_pseudo_rtx = NULL;\t\t\\\n+} while (0)\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -1577,6 +1673,10 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n enum reg_class\n {\n   NO_REGS,\t\t\t/* no registers in set */\n+  M16_NA_REGS,\t\t\t/* mips16 regs not used to pass args */\n+  M16_REGS,\t\t\t/* mips16 directly accessible registers */\n+  T_REG,\t\t\t/* mips16 T register ($24) */\n+  M16_T_REGS,\t\t\t/* mips16 registers plus T register */\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating point registers */\n   HI_REG,\t\t\t/* hi register */\n@@ -1599,6 +1699,10 @@ enum reg_class\n #define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"M16_NA_REGS\",\t\t\t\t\t\t\t\\\n+  \"M16_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"T_REG\",\t\t\t\t\t\t\t\t\\\n+  \"M16_T_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_REG\",\t\t\t\t\t\t\t\t\\\n@@ -1623,6 +1727,10 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000 },\t/* no registers */\t\\\n+  { 0x0003000c, 0x00000000, 0x00000000 },\t/* mips16 nonarg regs */\\\n+  { 0x000300fc, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n+  { 0x01000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n+  { 0x010300fc, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n   { 0xffffffff, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n   { 0x00000000, 0xffffffff, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001 },\t/* hi register */\t\\\n@@ -1647,7 +1755,7 @@ extern enum reg_class mips_regno_to_class[];\n    valid base register must belong.  A base register is one used in\n    an address which is the register value plus a displacement.  */\n \n-#define BASE_REG_CLASS  GR_REGS\n+#define BASE_REG_CLASS  (TARGET_MIPS16 ? M16_REGS : GR_REGS)\n \n /* A macro whose definition is the name of the class to which a\n    valid index register must belong.  An index register is one used\n@@ -1657,6 +1765,37 @@ extern enum reg_class mips_regno_to_class[];\n \n #define INDEX_REG_CLASS NO_REGS\n \n+/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers. */\n+\n+#define SMALL_REGISTER_CLASSES (TARGET_MIPS16)\n+\n+/* This macro is used later on in the file.  */\n+#define GR_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n+  ((CLASS) == GR_REGS || (CLASS) == M16_REGS || (CLASS) == T_REG\t\\\n+   || (CLASS) == M16_T_REGS || (CLASS) == M16_NA_REGS)\n+\n+/* REG_ALLOC_ORDER is to order in which to allocate registers.  This\n+   is the default value (allocate the registers in numeric order).  We\n+   define it just so that we can override it for the mips16 target in\n+   ORDER_REGS_FOR_LOCAL_ALLOC.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75\t\t\t\\\n+}\n+\n+/* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order\n+   to be rearranged based on a particular function.  On the mips16, we\n+   want to allocate $24 (T_REG) before other registers for\n+   instructions for which it is possible.  */\n+\n+#define ORDER_REGS_FOR_LOCAL_ALLOC mips_order_regs_for_local_alloc ()\n \n /* REGISTER AND CONSTANT CLASSES */\n \n@@ -1666,6 +1805,10 @@ extern enum reg_class mips_regno_to_class[];\n    DEFINED REGISTER CLASSES:\n \n    'd'  General (aka integer) registers\n+        Normally this is GR_REGS, but in mips16 mode this is M16_REGS\n+   'y'  General registers (in both mips16 and non mips16 mode)\n+   'e'\tmips16 non argument registers (M16_NA_REGS)\n+   't'  mips16 temporary register ($24)\n    'f'\tFloating point registers\n    'h'\tHi register\n    'l'\tLo register\n@@ -1700,9 +1843,9 @@ extern enum reg_class mips_char_to_class[];\n    `M'\tis used for the range of constants that take two words to load\n \t(ie, not matched by `I', `K', and `L').\n \n-   `N'\tis used for negative 16 bit constants.\n+   `N'\tis used for negative 16 bit constants other than -65536.\n \n-   `O'\tis an exact power of 2 (not yet used in the md file).\n+   `O'\tis a 15 bit signed integer.\n \n    `P'\tis used for positive 16 bit constants.  */\n \n@@ -1721,8 +1864,8 @@ extern enum reg_class mips_char_to_class[];\n \t\t   && (((VALUE) & 0x0000ffff) != 0\t\t\t\\\n \t\t       || (((VALUE) & ~2147483647) != 0\t\t\t\\\n \t\t\t   && ((VALUE) & ~2147483647) != ~2147483647)))\t\\\n-   : (C) == 'N' ? (((VALUE) & ~0x0000ffff) == ~0x0000ffff)\t\t\\\n-   : (C) == 'O' ? (exact_log2 (VALUE) >= 0)\t\t\t\t\\\n+   : (C) == 'N' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0xffff) < 0xffff) \\\n+   : (C) == 'O' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x4000) < 0x8000) \\\n    : (C) == 'P' ? ((VALUE) != 0 && (((VALUE) & ~0x0000ffff) == 0))\t\\\n    : 0)\n \n@@ -1743,13 +1886,16 @@ extern enum reg_class mips_char_to_class[];\n    operand as its first argument and the constraint letter as its\n    second operand.\n \n-   `Q'\tis for memory references which take more than 1 instruction.\n+   `Q'\tis for mips16 GP relative constants\n    `R'\tis for memory references which take 1 word for the instruction.\n-   `S'\tis for references to extern items which are PIC for OSF/rose.  */\n+   `S'\tis for references to extern items which are PIC for OSF/rose.\n+   `T'\tis for memory addresses that can be used to load two words.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n-  ((GET_CODE (OP) != MEM) ? FALSE\t\t\t\t\t\\\n-   : ((CODE) == 'Q')\t  ? !simple_memory_operand (OP, GET_MODE (OP))\t\\\n+  (((CODE) == 'T')\t  ? double_memory_operand (OP, GET_MODE (OP))\t\\\n+   : ((CODE) == 'Q')\t  ? (GET_CODE (OP) == CONST\t\t\t\\\n+\t\t\t     && mips16_gp_offset_p (OP))\t\t\\\n+   : (GET_CODE (OP) != MEM) ? FALSE\t\t\t\t\t\\\n    : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n    : ((CODE) == 'S')\t  ? (HALF_PIC_P () && CONSTANT_P (OP)\t\t\\\n \t\t\t     && HALF_PIC_ADDRESS_P (OP))\t\t\\\n@@ -1762,13 +1908,19 @@ extern enum reg_class mips_char_to_class[];\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n   ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n-   ? (CLASS)\t\t\t\t\t\t\t\t\\\n+   ? (! TARGET_MIPS16\t\t\t\t\t\t\t\\\n+      ? (CLASS)\t\t\t\t\t\t\t\t\\\n+      : ((CLASS) != GR_REGS\t\t\t\t\t\t\\\n+\t ? (CLASS)\t\t\t\t\t\t\t\\\n+\t : M16_REGS))\t\t\t\t\t\t\t\\\n    : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n-      ? (TARGET_SOFT_FLOAT ? GR_REGS : FP_REGS)\t\t\t\t\\\n+      ? (TARGET_SOFT_FLOAT\t\t\t\t\t\t\\\n+\t ? (TARGET_MIPS16 ? M16_REGS : GR_REGS)\t\t\t\t\\\n+\t : FP_REGS)\t\t\t\t\t\t\t\\\n       : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n \t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n-\t ? GR_REGS\t\t\t\t\t\t\t\\\n+\t ? (TARGET_MIPS16 ? M16_REGS : GR_REGS)\t\t\t\t\\\n \t : (CLASS))))\n \n /* Certain machines have the property that some registers cannot be\n@@ -1783,11 +1935,11 @@ extern enum reg_class mips_char_to_class[];\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n   ((!TARGET_DEBUG_H_MODE\t\t\t\t\t\t\\\n     && GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n-    && ((CLASS1 == FP_REGS && CLASS2 == GR_REGS)\t\t\t\\\n-\t|| (CLASS1 == GR_REGS && CLASS2 == FP_REGS)))\t\t\t\\\n+    && ((CLASS1 == FP_REGS && GR_REG_CLASS_P (CLASS2))\t\t\t\\\n+\t|| (GR_REG_CLASS_P (CLASS1) && CLASS2 == FP_REGS)))\t\t\\\n    || (TARGET_FLOAT64 && !TARGET_64BIT && (MODE) == DFmode\t\t\\\n-       && ((CLASS1 == GR_REGS && CLASS2 == FP_REGS)\t\t\t\\\n-\t   || (CLASS2 == GR_REGS && CLASS1 == FP_REGS))))\n+       && ((GR_REG_CLASS_P (CLASS1) && CLASS2 == FP_REGS)\t\t\\\n+\t   || (GR_REG_CLASS_P (CLASS2) && CLASS1 == FP_REGS))))\n \n /* The HI and LO registers can only be reloaded via the general\n    registers.  Condition code registers can only be loaded to the\n@@ -1911,6 +2063,7 @@ struct mips_frame_info\n   int  initialized;\t\t/* != 0 if frame size already calculated */\n   int  num_gp;\t\t\t/* number of gp registers saved */\n   int  num_fp;\t\t\t/* number of fp registers saved */\n+  long insns_len;\t\t/* length of insns; mips16 only */\n };\n \n extern struct mips_frame_info current_frame_info;\n@@ -1939,27 +2092,41 @@ extern struct mips_frame_info current_frame_info;\n          {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n    Note that the elimination of the argument pointer with the stack\n-   pointer is specified first since that is the preferred elimination.  */\n+   pointer is specified first since that is the preferred elimination.\n+\n+   The eliminations to $17 are only used on the mips16.  See the\n+   definition of HARD_FRAME_POINTER_REGNUM.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n {{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n- { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   GP_REG_FIRST + 30},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   GP_REG_FIRST + 17},\t\t\t\t\\\n  { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- { RETURN_ADDRESS_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 17},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n \n /* A C expression that returns non-zero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the\n    cases preventing register elimination are things that the compiler\n-   already knows about.  */\n+   already knows about.\n+\n+   We can always eliminate to the frame pointer.  We can eliminate to\n+   the stack pointer unless a frame pointer is needed.  In mips16\n+   mode, we need a frame pointer for a large frame; otherwise, reload\n+   may be unable to compute the address of a local variable, since\n+   there is no way to add a large constant to the stack pointer\n+   without using a temporary register.  */\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n-  (!frame_pointer_needed\t\t\t\t\t\t\\\n-   || ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n-   || ((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n-       && (TO) == FRAME_POINTER_REGNUM))\n+  ((TO) == HARD_FRAME_POINTER_REGNUM\t\t\t\t\t\\\n+   || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed\t\t\\\n+       && (! TARGET_MIPS16\t\t\t\t\t\t\\\n+\t   || compute_frame_size (get_frame_size ()) < 32768)))\n \n /* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n    specifies the initial difference between the specified pair of\n@@ -1968,23 +2135,25 @@ extern struct mips_frame_info current_frame_info;\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n {  compute_frame_size (get_frame_size ());\t\t\t\t \\\n-  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t \\\n+  if (TARGET_MIPS16 && (FROM) == FRAME_POINTER_REGNUM\t\t\t \\\n+      && (TO) == HARD_FRAME_POINTER_REGNUM)\t\t\t\t \\\n+    (OFFSET) = - current_function_outgoing_args_size;\t\t\t \\\n+  else if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t \\\n     (OFFSET) = 0;\t\t\t\t\t\t\t \\\n-  else if ((FROM) == ARG_POINTER_REGNUM\t\t\t\t\t \\\n-\t    && ((TO) == FRAME_POINTER_REGNUM\t\t\t\t \\\n-\t\t|| (TO) == STACK_POINTER_REGNUM))\t\t\t \\\n+  else if (TARGET_MIPS16 && (FROM) == ARG_POINTER_REGNUM\t\t \\\n+\t   && (TO) == HARD_FRAME_POINTER_REGNUM)\t\t\t \\\n+    (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n+\t\t- current_function_outgoing_args_size\t\t\t \\\n+\t\t- ((mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t \\\n+\t\t   ? current_function_pretend_args_size\t\t\t \\\n+\t\t   : 0));\t\t\t\t\t\t \\\n+  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t \\\n     (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n \t\t- ((mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t \\\n \t\t   ? current_function_pretend_args_size\t\t\t \\\n \t\t   : 0));\t\t\t\t\t\t \\\n-  else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t \\\n-\t   && ((TO) == FRAME_POINTER_REGNUM\t\t\t\t \\\n-\t       || (TO) == STACK_POINTER_REGNUM))\t\t\t \\\n-    (OFFSET) = current_frame_info.gp_sp_offset\t\t\t\t \\\n-\t       + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT))\t \\\n-\t\t  * (BYTES_BIG_ENDIAN != 0));\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    abort ();\t\t\t\t\t\t\t\t \\\n+  else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM)\t\t\t \\\n+    (OFFSET) = current_frame_info.gp_sp_offset;\t\t\t\t \\\n }\n \n /* If we generate an insn to push BYTES bytes,\n@@ -2105,10 +2274,16 @@ extern struct mips_frame_info current_frame_info;\n #define MAX_ARGS_IN_REGISTERS\t4\n \n /* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n+   assuming the value has mode MODE.  Because we define\n+   PROMOTE_FUNCTION_RETURN, we must promote the mode just as\n+   PROMOTE_MODE does.  */\n \n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n+  gen_rtx (REG,\t\t\t\t\t\t\t\t\\\n+\t   ((GET_MODE_CLASS (MODE) != MODE_INT\t\t\t\t\\\n+\t     || GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+\t    ? (MODE)\t\t\t\t\t\t\t\\\n+\t    : SImode),\t\t\t\t\t\t\t\\\n \t   ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n \t     && (! TARGET_SINGLE_FLOAT\t\t\t\t\t\\\n \t\t || GET_MODE_SIZE (MODE) <= 4))\t\t\t\t\\\n@@ -2137,7 +2312,8 @@ extern struct mips_frame_info current_frame_info;\n   (((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST)\t\t\t\\\n    || (! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n        && ((N) >= FP_ARG_FIRST && (N) <= FP_ARG_LAST)\t\t\\\n-       && (TARGET_FLOAT64 || (0 == (N) % 2))))\n+       && (TARGET_FLOAT64 || (0 == (N) % 2)))\t\t\t\\\n+   && ! fixed_regs[N])\n \n /* A C expression which can inhibit the returning of certain function\n    values in registers, based on the type of value.  A nonzero value says\n@@ -2172,14 +2348,26 @@ extern struct mips_frame_info current_frame_info;\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n-*/\n+\n+   On the mips16, we need to keep track of which floating point\n+   arguments were passed in general registers, but would have been\n+   passed in the FP regs if this were a 32 bit function, so that we\n+   can move them to the FP regs if we wind up calling a 32 bit\n+   function.  We record this information in fp_code, encoded in base\n+   four.  A zero digit means no floating point argument, a one digit\n+   means an SFmode argument, and a two digit means a DFmode argument,\n+   and a three digit is not used.  The low order digit is the first\n+   argument.  Thus 6 == 1 * 4 + 2 means a DFmode argument followed by\n+   an SFmode argument.  ??? A more sophisticated approach will be\n+   needed if MIPS_ABI != ABI_32.  */\n \n typedef struct mips_args {\n   int gp_reg_found;\t\t/* whether a gp register was found yet */\n   int arg_number;\t\t/* argument number */\n   int arg_words;\t\t/* # total words the arguments take */\n   int fp_arg_words;\t\t/* # words for FP args (MIPS_EABI only) */\n   int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n+  int fp_code;\t\t\t/* Mode of FP arguments (mips16) */\n   int num_adjusts;\t\t/* number of adjustments made */\n \t\t\t\t/* Adjustments made to args pass in regs.  */\n \t\t\t\t/* ??? The size is doubled to work around a \n@@ -2261,8 +2449,8 @@ typedef struct mips_args {\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define MUST_SAVE_REGISTER(regno) \\\n- ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-  || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n+ ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\t\\\n+  || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n   || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n \n /* ALIGN FRAMES on double word boundaries */\n@@ -2275,6 +2463,8 @@ typedef struct mips_args {\n \n #define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n+    sorry (\"mips16 function profiling\");\t\t\t\t\\\n   fprintf (FILE, \"\\t.set\\tnoreorder\\n\");\t\t\t\t\\\n   fprintf (FILE, \"\\t.set\\tnoat\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tmove\\t%s,%s\\t\\t# save current return address\\n\",\t\\\n@@ -2390,14 +2580,26 @@ typedef struct mips_args {\n    or a pseudo reg currently allocated to a suitable hard reg.\n    These definitions are NOT overridden anywhere.  */\n \n-#define GP_REG_OR_PSEUDO_STRICT_P(regno) \\\n-  GP_REG_P((regno < FIRST_PSEUDO_REGISTER) ? regno : reg_renumber[regno])\n+#define BASE_REG_P(regno, mode)\t\t\t\t\t\\\n+  (TARGET_MIPS16\t\t\t\t\t\t\\\n+   ? (M16_REG_P (regno)\t\t\t\t\t\t\\\n+      || (regno) == FRAME_POINTER_REGNUM\t\t\t\\\n+      || (regno) == ARG_POINTER_REGNUM\t\t\t\t\\\n+      || ((regno) == STACK_POINTER_REGNUM\t\t\t\\\n+\t  && (GET_MODE_SIZE (mode) == 4\t\t\t\t\\\n+\t      || GET_MODE_SIZE (mode) == 8)))\t\t\t\\\n+   : GP_REG_P (regno))\n \n-#define GP_REG_OR_PSEUDO_NONSTRICT_P(regno) \\\n-  (((regno) >= FIRST_PSEUDO_REGISTER) || (GP_REG_P (regno)))\n+#define GP_REG_OR_PSEUDO_STRICT_P(regno, mode)\t\t\t\t    \\\n+  BASE_REG_P((regno < FIRST_PSEUDO_REGISTER) ? regno : reg_renumber[regno], \\\n+\t     (mode))\n+\n+#define GP_REG_OR_PSEUDO_NONSTRICT_P(regno, mode) \\\n+  (((regno) >= FIRST_PSEUDO_REGISTER) || (BASE_REG_P ((regno), (mode))))\n \n #define REGNO_OK_FOR_INDEX_P(regno)\t0\n-#define REGNO_OK_FOR_BASE_P(regno)\tGP_REG_OR_PSEUDO_STRICT_P (regno)\n+#define REGNO_MODE_OK_FOR_BASE_P(regno, mode) \\\n+  GP_REG_OR_PSEUDO_STRICT_P ((regno), (mode))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -2414,13 +2616,15 @@ typedef struct mips_args {\n \n #define REG_OK_STRICT_P 0\n #define REG_OK_FOR_INDEX_P(X) 0\n-#define REG_OK_FOR_BASE_P(X)  GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (X))\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (X), (MODE))\n \n #else\n \n #define REG_OK_STRICT_P 1\n #define REG_OK_FOR_INDEX_P(X) 0\n-#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P  (REGNO (X))\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  REGNO_MODE_OK_FOR_BASE_P (REGNO (X), (MODE))\n \n #endif\n \n@@ -2501,19 +2705,23 @@ typedef struct mips_args {\n       GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == REG && REG_OK_FOR_BASE_P (xinsn))\t\t\\\n+  /* The mips16 can only use the stack pointer as a base register when\t\\\n+     loading SImode or DImode values.  */\t\t\t\t\\\n+  if (GET_CODE (xinsn) == REG && REG_MODE_OK_FOR_BASE_P (xinsn, MODE))\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (CONSTANT_ADDRESS_P (xinsn)\t\t\t\t\t\\\n-      && ! (mips_split_addresses && mips_check_split (xinsn, MODE)))\t\\\n+      && ! (mips_split_addresses && mips_check_split (xinsn, MODE))\t\\\n+      && (! TARGET_MIPS16 || mips16_constant (xinsn, MODE, 1, 0)))\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (xinsn) == LO_SUM && mips_split_addresses)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       register rtx xlow0 = XEXP (xinsn, 0);\t\t\t\t\\\n       register rtx xlow1 = XEXP (xinsn, 1);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (xlow0) == REG && REG_OK_FOR_BASE_P (xlow0)\t\t\\\n+      if (GET_CODE (xlow0) == REG\t\t\t\t\t\\\n+\t  && REG_MODE_OK_FOR_BASE_P (xlow0, MODE)\t\t\t\\\n \t  && mips_check_split (xlow1, MODE))\t\t\t\t\\\n \tgoto ADDR;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2525,13 +2733,22 @@ typedef struct mips_args {\n       register enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\\\n       register enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (code0 == REG && REG_OK_FOR_BASE_P (xplus0))\t\t\t\\\n+      /* The mips16 can only use the stack pointer as a base register\t\\\n+         when loading SImode or DImode values.  */\t\t\t\\\n+      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE))\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (code1 == CONST_INT\t\t\t\t\t\\\n \t      && INTVAL (xplus1) >= -32768\t\t\t\t\\\n \t      && INTVAL (xplus1) + GET_MODE_SIZE (MODE) - 1 <= 32767)\t\\\n \t    goto ADDR;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+\t  /* On the mips16, we represent GP relative offsets in RTL.\t\\\n+             These are 16 bit signed values, and can serve as register\t\\\n+             offsets.  */\t\t\t\t\t\t\\\n+\t  if (TARGET_MIPS16\t\t\t\t\t\t\\\n+\t      && mips16_gp_offset_p (xplus1))\t\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n \t  /* For some code sequences, you actually get better code by\t\\\n \t     pretending that the MIPS supports an address mode of a\t\\\n \t     constant address + a register, even though the real\t\\\n@@ -2556,7 +2773,8 @@ typedef struct mips_args {\n \t      && ! mips_split_addresses\t\t\t\t\t\\\n \t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\\\n \t\t  || code1 != CONST\t\t\t\t\t\\\n-\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS))\t\t\\\n+\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS)\t\t\\\n+\t      && !TARGET_MIPS16)\t\t\t\t\t\\\n \t    goto ADDR;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2601,7 +2819,8 @@ typedef struct mips_args {\n   ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n     || mips_const_double_ok (X, GET_MODE (X)))\t\t\t\t\\\n    && ! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t && mips_abi != ABI_32 && mips_abi != ABI_EABI))\n+\t && mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t\t\\\n+   && (! TARGET_MIPS16 || mips16_constant (X, GET_MODE (X), 0, 0)))\n \n /* A C compound statement that attempts to replace X with a valid\n    memory address for an operand of mode MODE.  WIN will be a C\n@@ -2693,7 +2912,7 @@ typedef struct mips_args {\n \t  code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (code0 == REG && REG_OK_FOR_BASE_P (xplus0)\t\t\t\\\n+      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE)\t\t\\\n \t  && code1 == CONST_INT && !SMALL_INT (xplus1))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  rtx int_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n@@ -2755,11 +2974,32 @@ typedef struct mips_args {\n \n    You can also check the information stored in the `symbol_ref' in\n    the definition of `GO_IF_LEGITIMATE_ADDRESS' or\n-   `PRINT_OPERAND_ADDRESS'. */\n+   `PRINT_OPERAND_ADDRESS'.\n+\n+   When optimizing for the $gp pointer, SYMBOL_REF_FLAG is set for all\n+   small objects.\n+\n+   When generating embedded PIC code, SYMBOL_REF_FLAG is set for\n+   symbols which are not in the .text section.\n+\n+   When generating mips16 code, SYMBOL_REF_FLAG is set for string\n+   constants which are put in the .text section.  We also record the\n+   total length of all such strings; this total is used to decide\n+   whether we need to split the constant table, and need not be\n+   precisely correct.  */\n \n #define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (TREE_CODE (DECL) == STRING_CST\t\t\t\t\\\n+\t    && ! flag_writable_strings)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    SYMBOL_REF_FLAG (XEXP (TREE_CST_RTL (DECL), 0)) = 1;\t\\\n+\t    mips_string_length += TREE_STRING_LENGTH (DECL);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n     if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n         if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n@@ -2786,15 +3026,33 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+/* The mips16 wants the constant pool to be after the function,\n+   because the PC relative load instructions use unsigned offsets.  */\n+\n+#define CONSTANT_POOL_BEFORE_FUNCTION (! TARGET_MIPS16)\n+\n+#define ASM_OUTPUT_POOL_EPILOGUE(FILE, FNNAME, FNDECL, SIZE)\t\\\n+  mips_string_length = 0;\n+\n+#if 0\n+/* In mips16 mode, put most string constants after the function.  */\n+#define CONSTANT_AFTER_FUNCTION_P(tree)\t\t\t\t\\\n+  (TARGET_MIPS16 && mips16_constant_after_function_p (tree))\n+#endif\n \f\n /* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE (TARGET_LONG64 ? DImode : SImode)\n-\n-/* Define this if the tablejump instruction expects the table\n-   to contain offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n+   for the index in the tablejump instruction.\n+   ??? Using HImode in mips16 mode can cause overflow.  However, the\n+   overflow is no more likely than the overflow in a branch\n+   instruction.  Large functions can currently break in both ways.  */\n+#define CASE_VECTOR_MODE \\\n+  (TARGET_MIPS16 ? HImode : TARGET_LONG64 ? DImode : SImode)\n+\n+/* Define as C expression which evaluates to nonzero if the tablejump\n+   instruction expects the table to contain offsets from the address of the\n+   table.\n+   Do not define this if the table should contain absolute addresses. */\n+#define CASE_VECTOR_PC_RELATIVE (TARGET_MIPS16)\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n@@ -2879,10 +3137,65 @@ while (0)\n \n #define CONST_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n   case CONST_INT:\t\t\t\t\t\t\t\\\n-    /* Always return 0, since we don't have different sized\t\t\\\n-       instructions, hence different costs according to Richard\t\t\\\n-       Kenner */\t\t\t\t\t\t\t\\\n-    return 0;\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_MIPS16)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t/* Always return 0, since we don't have different sized\t\t\\\n+\t   instructions, hence different costs according to Richard\t\\\n+\t   Kenner */\t\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if ((OUTER_CODE) == SET)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (INTVAL (X) >= 0 && INTVAL (X) < 0x100)\t\t\t\\\n+\t  return 0;\t\t\t\t\t\t\t\\\n+\telse if ((INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\\\n+\t\t || (INTVAL (X) < 0 && INTVAL (X) > -0x100))\t\t\\\n+\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (2);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* A PLUS could be an address.  We don't want to force an address\t\\\n+       to use a register, so accept any signed 16 bit value without\t\\\n+       complaint.  */\t\t\t\t\t\t\t\\\n+    if ((OUTER_CODE) == PLUS\t\t\t\t\t\t\\\n+\t&& INTVAL (X) >= -0x8000 && INTVAL (X) < 0x8000)\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    /* A number between 1 and 8 inclusive is efficient for a shift.\t\\\n+       Otherwise, we will need an extended instruction.  */\t\t\\\n+    if ((OUTER_CODE) == ASHIFT || (OUTER_CODE) == ASHIFTRT\t\t\\\n+\t|| (OUTER_CODE) == LSHIFTRT)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (INTVAL (X) >= 1 && INTVAL (X) <= 8)\t\t\t\t\\\n+\t  return 0;\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* We can use cmpi for an xor with an unsigned 16 bit value.  */\t\\\n+    if ((OUTER_CODE) == XOR\t\t\t\t\t\t\\\n+\t&& INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    /* We may be able to use slt or sltu for a comparison with a\t\\\n+       signed 16 bit value.  (The boundary conditions aren't quite\t\\\n+       right, but this is just a heuristic anyhow.)  */\t\t\t\\\n+    if (((OUTER_CODE) == LT || (OUTER_CODE) == LE\t\t\t\\\n+\t || (OUTER_CODE) == GE || (OUTER_CODE) == GT\t\t\t\\\n+\t || (OUTER_CODE) == LTU || (OUTER_CODE) == LEU\t\t\t\\\n+\t || (OUTER_CODE) == GEU || (OUTER_CODE) == GTU)\t\t\t\\\n+\t&& INTVAL (X) >= -0x8000 && INTVAL (X) < 0x8000)\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    /* Equality comparisons with 0 are cheap.  */\t\t\t\\\n+    if (((OUTER_CODE) == EQ || (OUTER_CODE) == NE)\t\t\t\\\n+\t&& INTVAL (X) == 0)\t\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Otherwise, work out the cost to load the value into a\t\t\\\n+       register.  */\t\t\t\t\t\t\t\\\n+    if (INTVAL (X) >= 0 && INTVAL (X) < 0x100)\t\t\t\t\\\n+      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+    else if ((INTVAL (X) >= 0 && INTVAL (X) < 0x10000)\t\t\t\\\n+\t     || (INTVAL (X) < 0 && INTVAL (X) > -0x100))\t\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n@@ -2892,6 +3205,17 @@ while (0)\n       rtx offset = const0_rtx;\t\t\t\t\t\t\\\n       rtx symref = eliminate_constant_term (XEXP (X, 0), &offset);\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_MIPS16 && mips16_gp_offset_p (X))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Treat this like a signed 16 bit CONST_INT.  */\t\t\\\n+\t  if ((OUTER_CODE) == PLUS)\t\t\t\t\t\\\n+\t    return 0;\t\t\t\t\t\t\t\\\n+\t  else if ((OUTER_CODE) == SET)\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (1);\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n \treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -2911,6 +3235,8 @@ while (0)\n   case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx high, low;\t\t\t\t\t\t\t\\\n+      if (TARGET_MIPS16)\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n       split_double (X, &high, &low);\t\t\t\t\t\\\n       return COSTS_N_INSNS ((high == CONST0_RTX (GET_MODE (high))\t\\\n \t\t\t     || low == CONST0_RTX (GET_MODE (low)))\t\\\n@@ -2953,15 +3279,15 @@ while (0)\n     if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n       return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\t\\\n     if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n       return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT) ? 4 : 12); \\\n \t\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case ABS:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2990,11 +3316,14 @@ while (0)\n       if (xmode == DImode && !TARGET_64BIT)\t\t\t\t\\\n \treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS ((GET_MODE (X) == DImode && !TARGET_64BIT) ? 4 : 1); \\\n+    if (GET_MODE (X) == DImode && !TARGET_64BIT)\t\t\t\\\n+      return 4;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -3154,17 +3483,24 @@ while (0)\n    not allow such copying.  */\n \n #define REGISTER_MOVE_COST(FROM, TO)\t\\\n-  ((FROM) == GR_REGS && (TO) == GR_REGS ? 2\t\t\t\t\\\n+  ((FROM) == M16_REGS && GR_REG_CLASS_P (TO) ? 2\t\t\t\\\n+   : (FROM) == M16_NA_REGS && GR_REG_CLASS_P (TO) ? 2\t\t\t\\\n+   : GR_REG_CLASS_P (FROM) && (TO) == M16_REGS ? 2\t\t\t\\\n+   : GR_REG_CLASS_P (FROM) && (TO) == M16_NA_REGS ? 2\t\t\t\\\n+   : GR_REG_CLASS_P (FROM) && GR_REG_CLASS_P (TO) ? (TARGET_MIPS16 ? 4 : 2) \\\n    : (FROM) == FP_REGS && (TO) == FP_REGS ? 2\t\t\t\t\\\n-   : (FROM) == GR_REGS && (TO) == FP_REGS ? 4\t\t\t\t\\\n-   : (FROM) == FP_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n+   : GR_REG_CLASS_P (FROM) && (TO) == FP_REGS ? 4\t\t\t\\\n+   : (FROM) == FP_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\t\\\n+   : (((FROM) == HI_REG || (FROM) == LO_REG\t\t\t\t\\\n+       || (FROM) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n+      && ((TO) == M16_REGS || (TO) == M16_NA_REGS)) ? 6\t\t\t\\\n    : (((FROM) == HI_REG || (FROM) == LO_REG\t\t\t\t\\\n        || (FROM) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n-      && (TO) == GR_REGS) ? 6\t\t\t\t\t\t\\\n+      && GR_REG_CLASS_P (TO)) ? (TARGET_MIPS16 ? 8 : 6)\t\t\t\\\n    : (((TO) == HI_REG || (TO) == LO_REG\t\t\t\t\t\\\n-       || (TO) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n-      && (FROM) == GR_REGS) ? 6\t\t\t\t\t\t\\\n-   : (FROM) == ST_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n+       || (TO) == MD_REGS || (TO) == HILO_REG)\t\t\t\t\\\n+      && GR_REG_CLASS_P (FROM)) ? (TARGET_MIPS16 ? 12 : 6)\t\t\\\n+   : (FROM) == ST_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\t\\\n    : (FROM) == FP_REGS && (TO) == ST_REGS ? 8\t\t\t\t\\\n    : 12)\n \n@@ -3176,8 +3512,10 @@ while (0)\n    1 is the default; other values are interpreted relative to that.  */\n \n /* ??? Fix this to be right for the R8000.  */\n-#define BRANCH_COST \\\n-  ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 2 : 1)\n+#define BRANCH_COST\t\t\t\t\t\t\t\\\n+  ((! TARGET_MIPS16\t\t\t\t\t\t\t\\\n+    && (mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000))\t\\\n+   ? 2 : 1)\n \n /* A C statement (sans semicolon) to update the integer variable COST\n    based on the relationship between INSN that is dependent on\n@@ -3241,7 +3579,9 @@ while (0)\n   {\"se_nonmemory_operand\",\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n \t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n \t\t\t\t  REG, SIGN_EXTEND }},\t\t\t\\\n-  {\"se_nonimmediate_operand\",   { SUBREG, REG, MEM, SIGN_EXTEND }},\n+  {\"se_nonimmediate_operand\",   { SUBREG, REG, MEM, SIGN_EXTEND }},\t\\\n+  {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n+\t\t\t\t  CONST_DOUBLE, CONST }},\n \n \f\n /* If defined, a C statement to be executed just prior to the\n@@ -3677,7 +4017,7 @@ while (0)\n #define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   extern FILE *asm_out_text_file;\t\t\t\t\t\\\n-  if (TARGET_GP_OPT)\t\t\t\t\t\t\t\\\n+  if (TARGET_GP_OPT && ! TARGET_MIPS16)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       STREAM = asm_out_text_file;\t\t\t\t\t\\\n       /* ??? text_section gets called too soon.  If the previous\t\\\n@@ -3787,7 +4127,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n+  if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.half\\t%sL%d-%sL%d\\n\",\t\t\t\t\\\n+\t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n+  else if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d-%sLS%d\\n\",\t\t\t\t\\\n \t     TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n@@ -3801,16 +4144,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n } while (0)\n \n-/* When generating embedded PIC code we want to put the jump table in\n-   the .text section.  In all other cases, we want to put the jump\n-   table in the .rdata section.  Unfortunately, we can't use\n+/* When generating embedded PIC or mips16 code we want to put the jump\n+   table in the .text section.  In all other cases, we want to put the\n+   jump table in the .rdata section.  Unfortunately, we can't use\n    JUMP_TABLES_IN_TEXT_SECTION, because it is not conditional.\n    Instead, we use ASM_OUTPUT_CASE_LABEL to switch back to the .text\n    section if appropriate.  */\n #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, INSN)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n-    text_section ();\t\t\t\t\t\t\t\\\n+  if (TARGET_EMBEDDED_PIC || TARGET_MIPS16)\t\t\t\t\\\n+    function_section (current_function_decl);\t\t\t\t\\\n   ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n } while (0)\n \n@@ -4052,6 +4395,13 @@ while (0)\n    true.  */\n \n #define DONT_ACCESS_GBLS_AFTER_EPILOGUE (TARGET_ABICALLS && mips_abi != ABI_32)\n+\f\n+/* In mips16 mode, we need to look through the function to check for\n+   PC relative loads that are out of range.  */\n+#define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg (X)\n+\n+/* We need to use a special set of functions to handle hard floating\n+   point code in mips16 mode.  */\n \n #ifndef INIT_SUBTARGET_OPTABS\n #define INIT_SUBTARGET_OPTABS\n@@ -4060,6 +4410,65 @@ while (0)\n #define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n+    if (! TARGET_MIPS16 || ! mips16_hard_float)\t\t\t\t\\\n+      INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tadd_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_addsf3\");\t\t\\\n+\tsub_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_subsf3\");\t\t\\\n+\tsmul_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_mulsf3\");\t\t\\\n+\tflodiv_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_divsf3\");\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\teqsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_eqsf2\");\t\\\n+\tnesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_nesf2\");\t\\\n+\tgtsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_gtsf2\");\t\\\n+\tgesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_gesf2\");\t\\\n+\tltsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_ltsf2\");\t\\\n+\tlesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__mips16_lesf2\");\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfloatsisf_libfunc =\t\t\t\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_floatsisf\");\t\t\\\n+\tfixsfsi_libfunc =\t\t\t\t\t\t\\\n+\t  gen_rtx (SYMBOL_REF, Pmode, \"__mips16_fixsfsi\");\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_DOUBLE_FLOAT)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    add_optab->handlers[(int) DFmode].libfunc =\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_adddf3\");\t\t\\\n+\t    sub_optab->handlers[(int) DFmode].libfunc =\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_subdf3\");\t\t\\\n+\t    smul_optab->handlers[(int) DFmode].libfunc =\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_muldf3\");\t\t\\\n+\t    flodiv_optab->handlers[(int) DFmode].libfunc =\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_divdf3\");\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    extendsfdf2_libfunc =\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_extendsfdf2\");\t\\\n+\t    truncdfsf2_libfunc =\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_truncdfsf2\");\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    eqdf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_eqdf2\");\t\t\\\n+\t    nedf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_nedf2\");\t\t\\\n+\t    gtdf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_gtdf2\");\t\t\\\n+\t    gedf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_gedf2\");\t\t\\\n+\t    ltdf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_ltdf2\");\t\t\\\n+\t    ledf2_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_ledf2\");\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    floatsidf_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_floatsidf\");\t\\\n+\t    fixdfsi_libfunc =\t\t\t\t\t\t\\\n+\t      gen_rtx (SYMBOL_REF, Pmode, \"__mips16_fixdfsi\");\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)"}, {"sha": "8fd4dfdaddf647000aadfebefc592c5c52fcac7f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2771, "deletions": 205, "changes": 2976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bcb2ab32669b224d76d010a1e690857bad100aa/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=2bcb2ab32669b224d76d010a1e690857bad100aa"}]}