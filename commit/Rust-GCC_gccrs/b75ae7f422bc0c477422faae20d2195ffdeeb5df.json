{"sha": "b75ae7f422bc0c477422faae20d2195ffdeeb5df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc1YWU3ZjQyMmJjMGM0Nzc0MjJmYWFlMjBkMjE5NWZmZGVlYjVkZg==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@gmail.com", "date": "2014-10-24T08:22:24Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-10-24T08:22:24Z"}, "message": "Improve scheduler dumps of ready list\n\n\t* sched-int.h (struct _haifa_insn_data:last_rfs_win): New field.\n\t* haifa-sched.c (INSN_LAST_RFS_WIN): New access macro.\n\t(rfs_result): Set INSN_LAST_RFS_WIN.  Update signature.\n\t(rank_for_schedule): Update calls to rfs_result to pass new parameters.\n\t(print_rank_for_schedule_stats): Print out elements of ready list that\n\tended up on their respective places due to each of the sorting\n\theuristics.\n\t(ready_sort): Update.\n\t(debug_ready_list_1): Improve printout for SCHED_PRESSURE_MODEL.\n\t(schedule_block): Update.\n\nFrom-SVN: r216621", "tree": {"sha": "e4144307b9de4b526b97ba90568b4161c2c35b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4144307b9de4b526b97ba90568b4161c2c35b31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b75ae7f422bc0c477422faae20d2195ffdeeb5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b75ae7f422bc0c477422faae20d2195ffdeeb5df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b75ae7f422bc0c477422faae20d2195ffdeeb5df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b75ae7f422bc0c477422faae20d2195ffdeeb5df/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea"}], "stats": {"total": 92, "additions": 71, "deletions": 21}, "files": [{"sha": "296419bbfe5d21cbe0f2e69acf6e27defff0c649", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b75ae7f422bc0c477422faae20d2195ffdeeb5df", "patch": "@@ -1,3 +1,16 @@\n+2014-10-24  Maxim Kuvyrkov  <maxim.kuvyrkov@gmail.com>\n+\n+\t* sched-int.h (struct _haifa_insn_data:last_rfs_win): New field.\n+\t* haifa-sched.c (INSN_LAST_RFS_WIN): New access macro.\n+\t(rfs_result): Set INSN_LAST_RFS_WIN.  Update signature.\n+\t(rank_for_schedule): Update calls to rfs_result to pass new parameters.\n+\t(print_rank_for_schedule_stats): Print out elements of ready list that\n+\tended up on their respective places due to each of the sorting\n+\theuristics.\n+\t(ready_sort): Update.\n+\t(debug_ready_list_1): Improve printout for SCHED_PRESSURE_MODEL.\n+\t(schedule_block): Update.\n+\n 2014-10-24  Maxim Kuvyrkov  <maxim.kuvyrkov@gmail.com>\n \n \t* haifa-sched.c (sched_class_regs_num, call_used_regs_num): New static"}, {"sha": "faf2e46940f4eb3d2a1616abede0f4bcdc20a224", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b75ae7f422bc0c477422faae20d2195ffdeeb5df", "patch": "@@ -244,6 +244,9 @@ struct common_sched_info_def *common_sched_info;\n /* The minimal value of the INSN_TICK of an instruction.  */\n #define MIN_TICK (-max_insn_queue_index)\n \n+/* The deciding reason for INSN's place in the ready list.  */\n+#define INSN_LAST_RFS_WIN(INSN) (HID (INSN)->last_rfs_win)\n+\n /* List of important notes we must keep around.  This is a pointer to the\n    last element in the list.  */\n rtx_insn *note_list;\n@@ -2553,10 +2556,18 @@ static const char *rfs_str[RFS_N] = {\n typedef struct { unsigned stats[RFS_N]; } rank_for_schedule_stats_t;\n static rank_for_schedule_stats_t rank_for_schedule_stats;\n \n+/* Return the result of comparing insns TMP and TMP2 and update\n+   Rank_For_Schedule statistics.  */\n static int\n-rfs_result (enum rfs_decision decision, int result)\n+rfs_result (enum rfs_decision decision, int result, rtx tmp, rtx tmp2)\n {\n   ++rank_for_schedule_stats.stats[decision];\n+  if (result < 0)\n+    INSN_LAST_RFS_WIN (tmp) = decision;\n+  else if (result > 0)\n+    INSN_LAST_RFS_WIN (tmp2) = decision;\n+  else\n+    gcc_unreachable ();\n   return result;\n }\n \n@@ -2576,11 +2587,12 @@ rank_for_schedule (const void *x, const void *y)\n     {\n       /* Schedule debug insns as early as possible.  */\n       if (DEBUG_INSN_P (tmp) && !DEBUG_INSN_P (tmp2))\n-\treturn rfs_result (RFS_DEBUG, -1);\n+\treturn rfs_result (RFS_DEBUG, -1, tmp, tmp2);\n       else if (!DEBUG_INSN_P (tmp) && DEBUG_INSN_P (tmp2))\n-\treturn rfs_result (RFS_DEBUG, 1);\n+\treturn rfs_result (RFS_DEBUG, 1, tmp, tmp2);\n       else if (DEBUG_INSN_P (tmp) && DEBUG_INSN_P (tmp2))\n-\treturn rfs_result (RFS_DEBUG, INSN_LUID (tmp) - INSN_LUID (tmp2));\n+\treturn rfs_result (RFS_DEBUG, INSN_LUID (tmp) - INSN_LUID (tmp2),\n+\t\t\t   tmp, tmp2);\n     }\n \n   if (live_range_shrinkage_p)\n@@ -2592,18 +2604,19 @@ rank_for_schedule (const void *x, const void *y)\n \t   || INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2) < 0)\n \t  && (diff = (INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp)\n \t\t      - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2))) != 0)\n-\treturn rfs_result (RFS_LIVE_RANGE_SHRINK1, diff);\n+\treturn rfs_result (RFS_LIVE_RANGE_SHRINK1, diff, tmp, tmp2);\n       /* Sort by INSN_LUID (original insn order), so that we make the\n \t sort stable.  This minimizes instruction movement, thus\n \t minimizing sched's effect on debugging and cross-jumping.  */\n       return rfs_result (RFS_LIVE_RANGE_SHRINK2,\n-\t\t\t INSN_LUID (tmp) - INSN_LUID (tmp2));\n+\t\t\t INSN_LUID (tmp) - INSN_LUID (tmp2), tmp, tmp2);\n     }\n \n   /* The insn in a schedule group should be issued the first.  */\n   if (flag_sched_group_heuristic &&\n       SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n-    return rfs_result (RFS_SCHED_GROUP, SCHED_GROUP_P (tmp2) ? 1 : -1);\n+    return rfs_result (RFS_SCHED_GROUP, SCHED_GROUP_P (tmp2) ? 1 : -1,\n+\t\t       tmp, tmp2);\n \n   /* Make sure that priority of TMP and TMP2 are initialized.  */\n   gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n@@ -2616,15 +2629,15 @@ rank_for_schedule (const void *x, const void *y)\n \t\t   + insn_delay (tmp)\n \t\t   - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2)\n \t\t   - insn_delay (tmp2))))\n-\treturn rfs_result (RFS_PRESSURE_DELAY, diff);\n+\treturn rfs_result (RFS_PRESSURE_DELAY, diff, tmp, tmp2);\n     }\n \n   if (sched_pressure != SCHED_PRESSURE_NONE\n       && (INSN_TICK (tmp2) > clock_var || INSN_TICK (tmp) > clock_var)\n       && INSN_TICK (tmp2) != INSN_TICK (tmp))\n     {\n       diff = INSN_TICK (tmp) - INSN_TICK (tmp2);\n-      return rfs_result (RFS_PRESSURE_TICK, diff);\n+      return rfs_result (RFS_PRESSURE_TICK, diff, tmp, tmp2);\n     }\n \n   /* If we are doing backtracking in this schedule, prefer insns that\n@@ -2634,14 +2647,14 @@ rank_for_schedule (const void *x, const void *y)\n     {\n       priority_val = FEEDS_BACKTRACK_INSN (tmp2) - FEEDS_BACKTRACK_INSN (tmp);\n       if (priority_val)\n-\treturn rfs_result (RFS_FEEDS_BACKTRACK_INSN, priority_val);\n+\treturn rfs_result (RFS_FEEDS_BACKTRACK_INSN, priority_val, tmp, tmp2);\n     }\n \n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n \n   if (flag_sched_critical_path_heuristic && priority_val)\n-    return rfs_result (RFS_PRIORITY, priority_val);\n+    return rfs_result (RFS_PRIORITY, priority_val, tmp, tmp2);\n \n   /* Prefer speculative insn with greater dependencies weakness.  */\n   if (flag_sched_spec_insn_heuristic && spec_info)\n@@ -2664,12 +2677,12 @@ rank_for_schedule (const void *x, const void *y)\n \n       dw = dw2 - dw1;\n       if (dw > (NO_DEP_WEAK / 8) || dw < -(NO_DEP_WEAK / 8))\n-\treturn rfs_result (RFS_SPECULATION, dw);\n+\treturn rfs_result (RFS_SPECULATION, dw, tmp, tmp2);\n     }\n \n   info_val = (*current_sched_info->rank) (tmp, tmp2);\n   if (flag_sched_rank_heuristic && info_val)\n-    return rfs_result (RFS_SCHED_RANK, info_val);\n+    return rfs_result (RFS_SCHED_RANK, info_val, tmp, tmp2);\n \n   /* Compare insns based on their relation to the last scheduled\n      non-debug insn.  */\n@@ -2705,7 +2718,7 @@ rank_for_schedule (const void *x, const void *y)\n \ttmp2_class = 2;\n \n       if ((val = tmp2_class - tmp_class))\n-\treturn rfs_result (RFS_LAST_INSN, val);\n+\treturn rfs_result (RFS_LAST_INSN, val, tmp, tmp2);\n     }\n \n   /* Prefer instructions that occur earlier in the model schedule.  */\n@@ -2714,7 +2727,7 @@ rank_for_schedule (const void *x, const void *y)\n     {\n       diff = model_index (tmp) - model_index (tmp2);\n       gcc_assert (diff != 0);\n-      return rfs_result (RFS_PRESSURE_INDEX, diff);\n+      return rfs_result (RFS_PRESSURE_INDEX, diff, tmp, tmp2);\n     }\n \n   /* Prefer the insn which has more later insns that depend on it.\n@@ -2725,12 +2738,12 @@ rank_for_schedule (const void *x, const void *y)\n \t - dep_list_size (tmp, SD_LIST_FORW));\n \n   if (flag_sched_dep_count_heuristic && val != 0)\n-    return rfs_result (RFS_DEP_COUNT, val);\n+    return rfs_result (RFS_DEP_COUNT, val, tmp, tmp2);\n \n   /* If insns are equally good, sort by INSN_LUID (original insn order),\n      so that we make the sort stable.  This minimizes instruction movement,\n      thus minimizing sched's effect on debugging and cross-jumping.  */\n-  return rfs_result (RFS_TIE, INSN_LUID (tmp) - INSN_LUID (tmp2));\n+  return rfs_result (RFS_TIE, INSN_LUID (tmp) - INSN_LUID (tmp2), tmp, tmp2);\n }\n \n /* Resort the array A in which only element at index N may be out of order.  */\n@@ -2948,11 +2961,28 @@ rank_for_schedule_stats_diff (rank_for_schedule_stats_t *was,\n /* Print rank_for_schedule statistics.  */\n static void\n print_rank_for_schedule_stats (const char *prefix,\n-\t\t\t       const rank_for_schedule_stats_t *stats)\n+\t\t\t       const rank_for_schedule_stats_t *stats,\n+\t\t\t       struct ready_list *ready)\n {\n   for (int i = 0; i < RFS_N; ++i)\n     if (stats->stats[i])\n-      fprintf (sched_dump, \"%s%20s: %u\\n\", prefix, rfs_str[i], stats->stats[i]);\n+      {\n+\tfprintf (sched_dump, \"%s%20s: %u\", prefix, rfs_str[i], stats->stats[i]);\n+\n+\tif (ready != NULL)\n+\t  /* Print out insns that won due to RFS_<I>.  */\n+\t  {\n+\t    rtx_insn **p = ready_lastpos (ready);\n+\n+\t    fprintf (sched_dump, \":\");\n+\t    /* Start with 1 since least-priority insn didn't have any wins.  */\n+\t    for (int j = 1; j < ready->n_ready; ++j)\n+\t      if (INSN_LAST_RFS_WIN (p[j]) == i)\n+\t\tfprintf (sched_dump, \" %s\",\n+\t\t\t (*current_sched_info->print_insn) (p[j], 0));\n+\t  }\n+\tfprintf (sched_dump, \"\\n\");\n+      }\n }\n \n /* Sort the ready list READY by ascending priority, using the SCHED_SORT\n@@ -2986,7 +3016,7 @@ ready_sort (struct ready_list *ready)\n   if (sched_verbose >= 4)\n     {\n       rank_for_schedule_stats_diff (&stats1, &rank_for_schedule_stats);\n-      print_rank_for_schedule_stats (\";;\\t\\t\", &stats1);\n+      print_rank_for_schedule_stats (\";;\\t\\t\", &stats1, ready);\n     }\n }\n \n@@ -5263,6 +5293,9 @@ debug_ready_list_1 (struct ready_list *ready, signed char *ready_try)\n       fprintf (sched_dump, \":prio=%d\", INSN_PRIORITY (p[i]));\n       if (INSN_TICK (p[i]) > clock_var)\n \tfprintf (sched_dump, \":delay=%d\", INSN_TICK (p[i]) - clock_var);\n+      if (sched_pressure == SCHED_PRESSURE_MODEL)\n+\tfprintf (sched_dump, \":idx=%d\",\n+\t\t model_index (p[i]));\n       if (sched_pressure != SCHED_PRESSURE_NONE)\n \tfprintf (sched_dump, \")\");\n     }\n@@ -6662,7 +6695,8 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       if (sched_verbose >= 2)\n \t{\n \t  dump_insn_stream (head, tail);\n-\t  print_rank_for_schedule_stats (\";; TOTAL \", &rank_for_schedule_stats);\n+\t  print_rank_for_schedule_stats (\";; TOTAL \", &rank_for_schedule_stats,\n+\t\t\t\t\t NULL);\n \t}\n \n       fprintf (sched_dump, \"\\n\");"}, {"sha": "71a4b5cd5fe92bf0fb6cdb162c3e162678830be7", "filename": "gcc/sched-int.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75ae7f422bc0c477422faae20d2195ffdeeb5df/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b75ae7f422bc0c477422faae20d2195ffdeeb5df", "patch": "@@ -888,6 +888,9 @@ struct _haifa_insn_data\n      pressure excess (between source and target).  */\n   int reg_pressure_excess_cost_change;\n   int model_index;\n+\n+  /* The deciding reason for INSN's place in the ready list.  */\n+  int last_rfs_win;\n };\n \n typedef struct _haifa_insn_data haifa_insn_data_def;"}]}