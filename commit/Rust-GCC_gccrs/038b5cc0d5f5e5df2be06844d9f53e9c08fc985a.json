{"sha": "038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4YjVjYzBkNWY1ZTVkZjJiZTA2ODQ0ZDlmNTNlOWMwOGZjOTg1YQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2016-10-11T07:02:40Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2016-10-11T07:02:40Z"}, "message": "Makefile.in (C_COMMON_OBJS): Add c-family/c-warn.o.\n\n\t* Makefile.in (C_COMMON_OBJS): Add c-family/c-warn.o.\n\n\t* c-common.c (fold_for_warn): No longer static.\n\t(bool_promoted_to_int_p): Likewise.\n\t(c_common_get_narrower): Likewise.\n\t(constant_expression_warning): Move to c-warn.c.\n\t(constant_expression_error): Likewise.\n\t(overflow_warning): Likewise.\n\t(warn_logical_operator): Likewise.\n\t(find_array_ref_with_const_idx_r): Likewise.\n\t(warn_tautological_cmp): Likewise.\n\t(expr_has_boolean_operands_p): Likewise.\n\t(warn_logical_not_parentheses): Likewise.\n\t(warn_if_unused_value): Likewise.\n\t(strict_aliasing_warning): Likewise.\n\t(sizeof_pointer_memaccess_warning): Likewise.\n\t(check_main_parameter_types): Likewise.\n\t(conversion_warning): Likewise.\n\t(warnings_for_convert_and_check): Likewise.\n\t(match_case_to_enum_1): Likewise.\n\t(match_case_to_enum): Likewise.\n\t(c_do_switch_warnings): Likewise.\n\t(warn_for_omitted_condop): Likewise.\n\t(readonly_error): Likewise.\n\t(lvalue_error): Likewise.\n\t(invalid_indirection_error): Likewise.\n\t(warn_array_subscript_with_type_char): Likewise.\n\t(warn_about_parentheses): Likewise.\n\t(warn_for_unused_label): Likewise.\n\t(warn_for_div_by_zero): Likewise.\n\t(warn_for_memset): Likewise.\n\t(warn_for_sign_compare): Likewise.\n\t(do_warn_double_promotion): Likewise.\n\t(do_warn_unused_parameter): Likewise.\n\t(record_locally_defined_typedef): Likewise.\n\t(maybe_record_typedef_use): Likewise.\n\t(maybe_warn_unused_local_typedefs): Likewise.\n\t(maybe_warn_bool_compare): Likewise.\n\t(maybe_warn_shift_overflow): Likewise.\n\t(warn_duplicated_cond_add_or_warn): Likewise.\n\t(diagnose_mismatched_attributes): Likewise.\n\t* c-common.h: Move the declarations from c-warn.c to its own section.\n\t* c-warn.c: New file.\n\nFrom-SVN: r240963", "tree": {"sha": "18dcf99a40d4a245774d07be423e9f1807c22b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18dcf99a40d4a245774d07be423e9f1807c22b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07f5170726afa917f90da7e1a033348888b46f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07f5170726afa917f90da7e1a033348888b46f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07f5170726afa917f90da7e1a033348888b46f57"}], "stats": {"total": 4509, "additions": 2296, "deletions": 2213}, "files": [{"sha": "f2f1a15675f927552b498991da5d2d719d538093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -1,3 +1,7 @@\n+2016-10-11  Marek Polacek  <polacek@redhat.com>\n+\n+\t* Makefile.in (C_COMMON_OBJS): Add c-family/c-warn.o.\n+\n 2016-10-11  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* tree-vrp.c (evrp_dom_walker::try_add_new_range): New."}, {"sha": "291460520184d22e4e2472b261af760b89eb5bbc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -1187,7 +1187,8 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o \\\n   c-family/c-cilkplus.o \\\n-  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o\n+  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o \\\n+  c-family/c-warn.o\n \n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make"}, {"sha": "c198fa806cd0e3b2ba6a2a476ffca1675714cca7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -1,3 +1,47 @@\n+2016-10-11  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-common.c (fold_for_warn): No longer static.\n+\t(bool_promoted_to_int_p): Likewise.\n+\t(c_common_get_narrower): Likewise.\n+\t(constant_expression_warning): Move to c-warn.c.\n+\t(constant_expression_error): Likewise.\n+\t(overflow_warning): Likewise.\n+\t(warn_logical_operator): Likewise.\n+\t(find_array_ref_with_const_idx_r): Likewise.\n+\t(warn_tautological_cmp): Likewise.\n+\t(expr_has_boolean_operands_p): Likewise.\n+\t(warn_logical_not_parentheses): Likewise.\n+\t(warn_if_unused_value): Likewise.\n+\t(strict_aliasing_warning): Likewise.\n+\t(sizeof_pointer_memaccess_warning): Likewise.\n+\t(check_main_parameter_types): Likewise.\n+\t(conversion_warning): Likewise.\n+\t(warnings_for_convert_and_check): Likewise.\n+\t(match_case_to_enum_1): Likewise.\n+\t(match_case_to_enum): Likewise.\n+\t(c_do_switch_warnings): Likewise.\n+\t(warn_for_omitted_condop): Likewise.\n+\t(readonly_error): Likewise.\n+\t(lvalue_error): Likewise.\n+\t(invalid_indirection_error): Likewise.\n+\t(warn_array_subscript_with_type_char): Likewise.\n+\t(warn_about_parentheses): Likewise.\n+\t(warn_for_unused_label): Likewise.\n+\t(warn_for_div_by_zero): Likewise.\n+\t(warn_for_memset): Likewise.\n+\t(warn_for_sign_compare): Likewise.\n+\t(do_warn_double_promotion): Likewise.\n+\t(do_warn_unused_parameter): Likewise.\n+\t(record_locally_defined_typedef): Likewise.\n+\t(maybe_record_typedef_use): Likewise.\n+\t(maybe_warn_unused_local_typedefs): Likewise.\n+\t(maybe_warn_bool_compare): Likewise.\n+\t(maybe_warn_shift_overflow): Likewise.\n+\t(warn_duplicated_cond_add_or_warn): Likewise.\n+\t(diagnose_mismatched_attributes): Likewise.\n+\t* c-common.h: Move the declarations from c-warn.c to its own section.\n+\t* c-warn.c: New file.\n+\n 2016-10-08  Jason Merrill  <jason@redhat.com>\n \n \t* c-common.c (c_common_truthvalue_conversion): Don't distribute"}, {"sha": "4437ffbf8a9fd23e56914d32bc188b352c751ba2", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 25, "deletions": 2154, "changes": 2179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -1182,7 +1182,7 @@ c_get_substring_location (const substring_loc &substr_loc,\n /* Fold X for consideration by one of the warning functions when checking\n    whether an expression has a constant value.  */\n \n-static tree\n+tree\n fold_for_warn (tree x)\n {\n   if (c_dialect_cxx ())\n@@ -1192,900 +1192,16 @@ fold_for_warn (tree x)\n     return x;\n }\n \n-/* Print a warning if a constant expression had overflow in folding.\n-   Invoke this function on every expression that the language\n-   requires to be a constant expression.\n-   Note the ANSI C standard says it is erroneous for a\n-   constant expression to overflow.  */\n-\n-void\n-constant_expression_warning (tree value)\n-{\n-  if (warn_overflow && pedantic\n-      && (TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n-\t  || TREE_CODE (value) == FIXED_CST\n-\t  || TREE_CODE (value) == VECTOR_CST\n-\t  || TREE_CODE (value) == COMPLEX_CST)\n-      && TREE_OVERFLOW (value))\n-    pedwarn (input_location, OPT_Woverflow, \"overflow in constant expression\");\n-}\n-\n-/* The same as above but print an unconditional error.  */\n-void\n-constant_expression_error (tree value)\n-{\n-  if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n-       || TREE_CODE (value) == FIXED_CST\n-       || TREE_CODE (value) == VECTOR_CST\n-       || TREE_CODE (value) == COMPLEX_CST)\n-      && TREE_OVERFLOW (value))\n-    error (\"overflow in constant expression\");\n-}\n-\n-/* Print a warning if an expression had overflow in folding and its\n-   operands hadn't.\n-\n-   Invoke this function on every expression that\n-   (1) appears in the source code, and\n-   (2) is a constant expression that overflowed, and\n-   (3) is not already checked by convert_and_check;\n-   however, do not invoke this function on operands of explicit casts\n-   or when the expression is the result of an operator and any operand\n-   already overflowed.  */\n-\n-void\n-overflow_warning (location_t loc, tree value)\n-{\n-  if (c_inhibit_evaluation_warnings != 0)\n-    return;\n-\n-  switch (TREE_CODE (value))\n-    {\n-    case INTEGER_CST:\n-      warning_at (loc, OPT_Woverflow, \"integer overflow in expression\");\n-      break;\n-\n-    case REAL_CST:\n-      warning_at (loc, OPT_Woverflow,\n-\t\t  \"floating point overflow in expression\");\n-      break;\n-\n-    case FIXED_CST:\n-      warning_at (loc, OPT_Woverflow, \"fixed-point overflow in expression\");\n-      break;\n-\n-    case VECTOR_CST:\n-      warning_at (loc, OPT_Woverflow, \"vector overflow in expression\");\n-      break;\n-\n-    case COMPLEX_CST:\n-      if (TREE_CODE (TREE_REALPART (value)) == INTEGER_CST)\n-\twarning_at (loc, OPT_Woverflow,\n-\t\t    \"complex integer overflow in expression\");\n-      else if (TREE_CODE (TREE_REALPART (value)) == REAL_CST)\n-\twarning_at (loc, OPT_Woverflow,\n-\t\t    \"complex floating point overflow in expression\");\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Warn about uses of logical || / && operator in a context where it\n-   is likely that the bitwise equivalent was intended by the\n-   programmer.  We have seen an expression in which CODE is a binary\n-   operator used to combine expressions OP_LEFT and OP_RIGHT, which before folding\n-   had CODE_LEFT and CODE_RIGHT, into an expression of type TYPE.  */\n-void\n-warn_logical_operator (location_t location, enum tree_code code, tree type,\n-\t\t       enum tree_code code_left, tree op_left,\n-\t\t       enum tree_code ARG_UNUSED (code_right), tree op_right)\n-{\n-  int or_op = (code == TRUTH_ORIF_EXPR || code == TRUTH_OR_EXPR);\n-  int in0_p, in1_p, in_p;\n-  tree low0, low1, low, high0, high1, high, lhs, rhs, tem;\n-  bool strict_overflow_p = false;\n-\n-  if (code != TRUTH_ANDIF_EXPR\n-      && code != TRUTH_AND_EXPR\n-      && code != TRUTH_ORIF_EXPR\n-      && code != TRUTH_OR_EXPR)\n-    return;\n-\n-  /* We don't want to warn if either operand comes from a macro\n-     expansion.  ??? This doesn't work with e.g. NEGATE_EXPR yet;\n-     see PR61534.  */\n-  if (from_macro_expansion_at (EXPR_LOCATION (op_left))\n-      || from_macro_expansion_at (EXPR_LOCATION (op_right)))\n-    return;\n-\n-  /* Warn if &&/|| are being used in a context where it is\n-     likely that the bitwise equivalent was intended by the\n-     programmer. That is, an expression such as op && MASK\n-     where op should not be any boolean expression, nor a\n-     constant, and mask seems to be a non-boolean integer constant.  */\n-  if (TREE_CODE (op_right) == CONST_DECL)\n-    /* An enumerator counts as a constant.  */\n-    op_right = DECL_INITIAL (op_right);\n-  if (!truth_value_p (code_left)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (op_left))\n-      && !CONSTANT_CLASS_P (op_left)\n-      && !TREE_NO_WARNING (op_left)\n-      && TREE_CODE (op_right) == INTEGER_CST\n-      && !integer_zerop (op_right)\n-      && !integer_onep (op_right))\n-    {\n-      if (or_op)\n-\twarning_at (location, OPT_Wlogical_op, \"logical %<or%>\"\n-\t\t    \" applied to non-boolean constant\");\n-      else\n-\twarning_at (location, OPT_Wlogical_op, \"logical %<and%>\"\n-\t\t    \" applied to non-boolean constant\");\n-      TREE_NO_WARNING (op_left) = true;\n-      return;\n-    }\n-\n-  /* We do not warn for constants because they are typical of macro\n-     expansions that test for features.  */\n-  if (CONSTANT_CLASS_P (fold_for_warn (op_left))\n-      || CONSTANT_CLASS_P (fold_for_warn (op_right)))\n-    return;\n-\n-  /* This warning only makes sense with logical operands.  */\n-  if (!(truth_value_p (TREE_CODE (op_left))\n-\t|| INTEGRAL_TYPE_P (TREE_TYPE (op_left)))\n-      || !(truth_value_p (TREE_CODE (op_right))\n-\t   || INTEGRAL_TYPE_P (TREE_TYPE (op_right))))\n-    return;\n-\n-  /* The range computations only work with scalars.  */\n-  if (VECTOR_TYPE_P (TREE_TYPE (op_left))\n-      || VECTOR_TYPE_P (TREE_TYPE (op_right)))\n-    return;\n-\n-  /* We first test whether either side separately is trivially true\n-     (with OR) or trivially false (with AND).  If so, do not warn.\n-     This is a common idiom for testing ranges of data types in\n-     portable code.  */\n-  lhs = make_range (op_left, &in0_p, &low0, &high0, &strict_overflow_p);\n-  if (!lhs)\n-    return;\n-  if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n-    lhs = C_MAYBE_CONST_EXPR_EXPR (lhs);\n-\n-  /* If this is an OR operation, invert both sides; now, the result\n-     should be always false to get a warning.  */\n-  if (or_op)\n-    in0_p = !in0_p;\n-\n-  tem = build_range_check (UNKNOWN_LOCATION, type, lhs, in0_p, low0, high0);\n-  if (tem && integer_zerop (tem))\n-    return;\n-\n-  rhs = make_range (op_right, &in1_p, &low1, &high1, &strict_overflow_p);\n-  if (!rhs)\n-    return;\n-  if (TREE_CODE (rhs) == C_MAYBE_CONST_EXPR)\n-    rhs = C_MAYBE_CONST_EXPR_EXPR (rhs);\n-\n-  /* If this is an OR operation, invert both sides; now, the result\n-     should be always false to get a warning.  */\n-  if (or_op)\n-    in1_p = !in1_p;\n-\n-  tem = build_range_check (UNKNOWN_LOCATION, type, rhs, in1_p, low1, high1);\n-  if (tem && integer_zerop (tem))\n-    return;\n-\n-  /* If both expressions have the same operand, if we can merge the\n-     ranges, ...  */\n-  if (operand_equal_p (lhs, rhs, 0)\n-      && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n-\t\t       in1_p, low1, high1))\n-    {\n-      tem = build_range_check (UNKNOWN_LOCATION, type, lhs, in_p, low, high);\n-      /* ... and if the range test is always false, then warn.  */\n-      if (tem && integer_zerop (tem))\n-\t{\n-\t  if (or_op)\n-\t    warning_at (location, OPT_Wlogical_op,\n-\t\t\t\"logical %<or%> of collectively exhaustive tests is \"\n-\t\t\t\"always true\");\n-\t  else\n-\t    warning_at (location, OPT_Wlogical_op,\n-\t\t\t\"logical %<and%> of mutually exclusive tests is \"\n-\t\t\t\"always false\");\n-\t}\n-      /* Or warn if the operands have exactly the same range, e.g.\n-\t A > 0 && A > 0.  */\n-      else if (tree_int_cst_equal (low0, low1)\n-\t       && tree_int_cst_equal (high0, high1))\n-\t{\n-\t  if (or_op)\n-\t    warning_at (location, OPT_Wlogical_op,\n-\t\t\t\"logical %<or%> of equal expressions\");\n-\t  else\n-\t    warning_at (location, OPT_Wlogical_op,\n-\t\t\t\"logical %<and%> of equal expressions\");\n-\t}\n-    }\n-}\n-\n-/* Helper function for warn_tautological_cmp.  Look for ARRAY_REFs\n-   with constant indices.  */\n-\n-static tree\n-find_array_ref_with_const_idx_r (tree *expr_p, int *walk_subtrees, void *data)\n-{\n-  tree expr = *expr_p;\n-\n-  if ((TREE_CODE (expr) == ARRAY_REF\n-       || TREE_CODE (expr) == ARRAY_RANGE_REF)\n-      && TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST)\n-    {\n-      *(bool *) data = true;\n-      *walk_subtrees = 0;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Warn if a self-comparison always evaluates to true or false.  LOC\n-   is the location of the comparison with code CODE, LHS and RHS are\n-   operands of the comparison.  */\n-\n-void\n-warn_tautological_cmp (location_t loc, enum tree_code code, tree lhs, tree rhs)\n-{\n-  if (TREE_CODE_CLASS (code) != tcc_comparison)\n-    return;\n-\n-  /* Don't warn for various macro expansions.  */\n-  if (from_macro_expansion_at (loc)\n-      || from_macro_expansion_at (EXPR_LOCATION (lhs))\n-      || from_macro_expansion_at (EXPR_LOCATION (rhs)))\n-    return;\n-\n-  /* We do not warn for constants because they are typical of macro\n-     expansions that test for features, sizeof, and similar.  */\n-  if (CONSTANT_CLASS_P (fold_for_warn (lhs))\n-      || CONSTANT_CLASS_P (fold_for_warn (rhs)))\n-    return;\n-\n-  /* Don't warn for e.g.\n-     HOST_WIDE_INT n;\n-     ...\n-     if (n == (long) n) ...\n-   */\n-  if ((CONVERT_EXPR_P (lhs) || TREE_CODE (lhs) == NON_LVALUE_EXPR)\n-      || (CONVERT_EXPR_P (rhs) || TREE_CODE (rhs) == NON_LVALUE_EXPR))\n-    return;\n-\n-  /* Don't warn if either LHS or RHS has an IEEE floating-point type.\n-     It could be a NaN, and NaN never compares equal to anything, even\n-     itself.  */\n-  if (FLOAT_TYPE_P (TREE_TYPE (lhs)) || FLOAT_TYPE_P (TREE_TYPE (rhs)))\n-    return;\n-\n-  if (operand_equal_p (lhs, rhs, 0))\n-    {\n-      /* Don't warn about array references with constant indices;\n-\t these are likely to come from a macro.  */\n-      bool found = false;\n-      walk_tree_without_duplicates (&lhs, find_array_ref_with_const_idx_r,\n-\t\t\t\t    &found);\n-      if (found)\n-\treturn;\n-      const bool always_true = (code == EQ_EXPR || code == LE_EXPR\n-\t\t\t\t|| code == GE_EXPR || code == UNLE_EXPR\n-\t\t\t\t|| code == UNGE_EXPR || code == UNEQ_EXPR);\n-      if (always_true)\n-\twarning_at (loc, OPT_Wtautological_compare,\n-\t\t    \"self-comparison always evaluates to true\");\n-      else\n-\twarning_at (loc, OPT_Wtautological_compare,\n-\t\t    \"self-comparison always evaluates to false\");\n-    }\n-}\n-\n /* Return true iff T is a boolean promoted to int.  */\n \n-static bool\n+bool\n bool_promoted_to_int_p (tree t)\n {\n   return (CONVERT_EXPR_P (t)\n \t  && TREE_TYPE (t) == integer_type_node\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == BOOLEAN_TYPE);\n }\n \n-/* Return true iff EXPR only contains boolean operands, or comparisons.  */\n-\n-static bool\n-expr_has_boolean_operands_p (tree expr)\n-{\n-  STRIP_NOPS (expr);\n-\n-  if (CONVERT_EXPR_P (expr))\n-    return bool_promoted_to_int_p (expr);\n-  else if (UNARY_CLASS_P (expr))\n-    return expr_has_boolean_operands_p (TREE_OPERAND (expr, 0));\n-  else if (BINARY_CLASS_P (expr))\n-    return (expr_has_boolean_operands_p (TREE_OPERAND (expr, 0))\n-\t    && expr_has_boolean_operands_p (TREE_OPERAND (expr, 1)));\n-  else if (COMPARISON_CLASS_P (expr))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* Warn about logical not used on the left hand side operand of a comparison.\n-   This function assumes that the LHS is inside of TRUTH_NOT_EXPR.\n-   Do not warn if RHS is of a boolean type, a logical operator, or\n-   a comparison.  */\n-\n-void\n-warn_logical_not_parentheses (location_t location, enum tree_code code,\n-\t\t\t      tree lhs, tree rhs)\n-{\n-  if (TREE_CODE_CLASS (code) != tcc_comparison\n-      || TREE_TYPE (rhs) == NULL_TREE\n-      || TREE_CODE (TREE_TYPE (rhs)) == BOOLEAN_TYPE\n-      || truth_value_p (TREE_CODE (rhs)))\n-    return;\n-\n-  /* Don't warn for expression like !x == ~(bool1 | bool2).  */\n-  if (expr_has_boolean_operands_p (rhs))\n-    return;\n-\n-  /* Don't warn for !x == 0 or !y != 0, those are equivalent to\n-     !(x == 0) or !(y != 0).  */\n-  if ((code == EQ_EXPR || code == NE_EXPR)\n-      && integer_zerop (rhs))\n-    return;\n-\n-  if (warning_at (location, OPT_Wlogical_not_parentheses,\n-\t\t  \"logical not is only applied to the left hand side of \"\n-\t\t  \"comparison\")\n-      && EXPR_HAS_LOCATION (lhs))\n-    {\n-      location_t lhs_loc = EXPR_LOCATION (lhs);\n-      rich_location richloc (line_table, lhs_loc);\n-      richloc.add_fixit_insert_before (lhs_loc, \"(\");\n-      richloc.add_fixit_insert_after (lhs_loc, \")\");\n-      inform_at_rich_loc (&richloc, \"add parentheses around left hand side \"\n-\t\t\t  \"expression to silence this warning\");\n-    }\n-}\n-\n-/* Warn if EXP contains any computations whose results are not used.\n-   Return true if a warning is printed; false otherwise.  LOCUS is the\n-   (potential) location of the expression.  */\n-\n-bool\n-warn_if_unused_value (const_tree exp, location_t locus)\n-{\n- restart:\n-  if (TREE_USED (exp) || TREE_NO_WARNING (exp))\n-    return false;\n-\n-  /* Don't warn about void constructs.  This includes casting to void,\n-     void function calls, and statement expressions with a final cast\n-     to void.  */\n-  if (VOID_TYPE_P (TREE_TYPE (exp)))\n-    return false;\n-\n-  if (EXPR_HAS_LOCATION (exp))\n-    locus = EXPR_LOCATION (exp);\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case PREINCREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-    case TARGET_EXPR:\n-    case CALL_EXPR:\n-    case TRY_CATCH_EXPR:\n-    case WITH_CLEANUP_EXPR:\n-    case EXIT_EXPR:\n-    case VA_ARG_EXPR:\n-      return false;\n-\n-    case BIND_EXPR:\n-      /* For a binding, warn if no side effect within it.  */\n-      exp = BIND_EXPR_BODY (exp);\n-      goto restart;\n-\n-    case SAVE_EXPR:\n-    case NON_LVALUE_EXPR:\n-    case NOP_EXPR:\n-      exp = TREE_OPERAND (exp, 0);\n-      goto restart;\n-\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-      /* In && or ||, warn if 2nd operand has no side effect.  */\n-      exp = TREE_OPERAND (exp, 1);\n-      goto restart;\n-\n-    case COMPOUND_EXPR:\n-      if (warn_if_unused_value (TREE_OPERAND (exp, 0), locus))\n-\treturn true;\n-      /* Let people do `(foo (), 0)' without a warning.  */\n-      if (TREE_CONSTANT (TREE_OPERAND (exp, 1)))\n-\treturn false;\n-      exp = TREE_OPERAND (exp, 1);\n-      goto restart;\n-\n-    case COND_EXPR:\n-      /* If this is an expression with side effects, don't warn; this\n-\t case commonly appears in macro expansions.  */\n-      if (TREE_SIDE_EFFECTS (exp))\n-\treturn false;\n-      goto warn;\n-\n-    case INDIRECT_REF:\n-      /* Don't warn about automatic dereferencing of references, since\n-\t the user cannot control it.  */\n-      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n-\t{\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  goto restart;\n-\t}\n-      /* Fall through.  */\n-\n-    default:\n-      /* Referencing a volatile value is a side effect, so don't warn.  */\n-      if ((DECL_P (exp) || REFERENCE_CLASS_P (exp))\n-\t  && TREE_THIS_VOLATILE (exp))\n-\treturn false;\n-\n-      /* If this is an expression which has no operands, there is no value\n-\t to be unused.  There are no such language-independent codes,\n-\t but front ends may define such.  */\n-      if (EXPRESSION_CLASS_P (exp) && TREE_OPERAND_LENGTH (exp) == 0)\n-\treturn false;\n-\n-    warn:\n-      return warning_at (locus, OPT_Wunused_value, \"value computed is not used\");\n-    }\n-}\n-\n-\n-/* Print a warning about casts that might indicate violation\n-   of strict aliasing rules if -Wstrict-aliasing is used and\n-   strict aliasing mode is in effect. OTYPE is the original\n-   TREE_TYPE of EXPR, and TYPE the type we're casting to. */\n-\n-bool\n-strict_aliasing_warning (tree otype, tree type, tree expr)\n-{\n-  /* Strip pointer conversion chains and get to the correct original type.  */\n-  STRIP_NOPS (expr);\n-  otype = TREE_TYPE (expr);\n-\n-  if (!(flag_strict_aliasing\n-\t&& POINTER_TYPE_P (type)\n-\t&& POINTER_TYPE_P (otype)\n-\t&& !VOID_TYPE_P (TREE_TYPE (type)))\n-      /* If the type we are casting to is a ref-all pointer\n-         dereferencing it is always valid.  */\n-      || TYPE_REF_CAN_ALIAS_ALL (type))\n-    return false;\n-\n-  if ((warn_strict_aliasing > 1) && TREE_CODE (expr) == ADDR_EXPR\n-      && (DECL_P (TREE_OPERAND (expr, 0))\n-          || handled_component_p (TREE_OPERAND (expr, 0))))\n-    {\n-      /* Casting the address of an object to non void pointer. Warn\n-         if the cast breaks type based aliasing.  */\n-      if (!COMPLETE_TYPE_P (TREE_TYPE (type)) && warn_strict_aliasing == 2)\n-\t{\n-\t  warning (OPT_Wstrict_aliasing, \"type-punning to incomplete type \"\n-\t\t   \"might break strict-aliasing rules\");\n-\t  return true;\n-\t}\n-      else\n-        {\n-          /* warn_strict_aliasing >= 3.   This includes the default (3).\n-             Only warn if the cast is dereferenced immediately.  */\n-          alias_set_type set1 =\n-\t    get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n-          alias_set_type set2 = get_alias_set (TREE_TYPE (type));\n-\n-          if (set1 != set2 && set2 != 0\n-\t      && (set1 == 0\n-\t\t  || (!alias_set_subset_of (set2, set1)\n-\t\t      && !alias_sets_conflict_p (set1, set2))))\n-\t    {\n-\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n-\t\t       \"pointer will break strict-aliasing rules\");\n-\t      return true;\n-\t    }\n-          else if (warn_strict_aliasing == 2\n-\t\t   && !alias_sets_must_conflict_p (set1, set2))\n-\t    {\n-\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n-\t\t       \"pointer might break strict-aliasing rules\");\n-\t      return true;\n-\t    }\n-        }\n-    }\n-  else\n-    if ((warn_strict_aliasing == 1) && !VOID_TYPE_P (TREE_TYPE (otype)))\n-      {\n-        /* At this level, warn for any conversions, even if an address is\n-           not taken in the same statement.  This will likely produce many\n-           false positives, but could be useful to pinpoint problems that\n-           are not revealed at higher levels.  */\n-        alias_set_type set1 = get_alias_set (TREE_TYPE (otype));\n-        alias_set_type set2 = get_alias_set (TREE_TYPE (type));\n-        if (!COMPLETE_TYPE_P (type)\n-            || !alias_sets_must_conflict_p (set1, set2))\n-\t  {\n-            warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n-                     \"pointer might break strict-aliasing rules\");\n-            return true;\n-          }\n-      }\n-\n-  return false;\n-}\n-\n-/* Warn about memset (&a, 0, sizeof (&a)); and similar mistakes with\n-   sizeof as last operand of certain builtins.  */\n-\n-void\n-sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n-\t\t\t\t  vec<tree, va_gc> *params, tree *sizeof_arg,\n-\t\t\t\t  bool (*comp_types) (tree, tree))\n-{\n-  tree type, dest = NULL_TREE, src = NULL_TREE, tem;\n-  bool strop = false, cmp = false;\n-  unsigned int idx = ~0;\n-  location_t loc;\n-\n-  if (TREE_CODE (callee) != FUNCTION_DECL\n-      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n-      || vec_safe_length (params) <= 1)\n-    return;\n-\n-  switch (DECL_FUNCTION_CODE (callee))\n-    {\n-    case BUILT_IN_STRNCMP:\n-    case BUILT_IN_STRNCASECMP:\n-      cmp = true;\n-      /* FALLTHRU */\n-    case BUILT_IN_STRNCPY:\n-    case BUILT_IN_STRNCPY_CHK:\n-    case BUILT_IN_STRNCAT:\n-    case BUILT_IN_STRNCAT_CHK:\n-    case BUILT_IN_STPNCPY:\n-    case BUILT_IN_STPNCPY_CHK:\n-      strop = true;\n-      /* FALLTHRU */\n-    case BUILT_IN_MEMCPY:\n-    case BUILT_IN_MEMCPY_CHK:\n-    case BUILT_IN_MEMMOVE:\n-    case BUILT_IN_MEMMOVE_CHK:\n-      if (params->length () < 3)\n-\treturn;\n-      src = (*params)[1];\n-      dest = (*params)[0];\n-      idx = 2;\n-      break;\n-    case BUILT_IN_BCOPY:\n-      if (params->length () < 3)\n-\treturn;\n-      src = (*params)[0];\n-      dest = (*params)[1];\n-      idx = 2;\n-      break;\n-    case BUILT_IN_MEMCMP:\n-    case BUILT_IN_BCMP:\n-      if (params->length () < 3)\n-\treturn;\n-      src = (*params)[1];\n-      dest = (*params)[0];\n-      idx = 2;\n-      cmp = true;\n-      break;\n-    case BUILT_IN_MEMSET:\n-    case BUILT_IN_MEMSET_CHK:\n-      if (params->length () < 3)\n-\treturn;\n-      dest = (*params)[0];\n-      idx = 2;\n-      break;\n-    case BUILT_IN_BZERO:\n-      dest = (*params)[0];\n-      idx = 1;\n-      break;\n-    case BUILT_IN_STRNDUP:\n-      src = (*params)[0];\n-      strop = true;\n-      idx = 1;\n-      break;\n-    case BUILT_IN_MEMCHR:\n-      if (params->length () < 3)\n-\treturn;\n-      src = (*params)[0];\n-      idx = 2;\n-      break;\n-    case BUILT_IN_SNPRINTF:\n-    case BUILT_IN_SNPRINTF_CHK:\n-    case BUILT_IN_VSNPRINTF:\n-    case BUILT_IN_VSNPRINTF_CHK:\n-      dest = (*params)[0];\n-      idx = 1;\n-      strop = true;\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  if (idx >= 3)\n-    return;\n-\n-  if (sizeof_arg[idx] == NULL || sizeof_arg[idx] == error_mark_node)\n-    return;\n-\n-  type = TYPE_P (sizeof_arg[idx])\n-\t ? sizeof_arg[idx] : TREE_TYPE (sizeof_arg[idx]);\n-  if (!POINTER_TYPE_P (type))\n-    return;\n-\n-  if (dest\n-      && (tem = tree_strip_nop_conversions (dest))\n-      && POINTER_TYPE_P (TREE_TYPE (tem))\n-      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n-    return;\n-\n-  if (src\n-      && (tem = tree_strip_nop_conversions (src))\n-      && POINTER_TYPE_P (TREE_TYPE (tem))\n-      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n-    return;\n-\n-  loc = sizeof_arg_loc[idx];\n-\n-  if (dest && !cmp)\n-    {\n-      if (!TYPE_P (sizeof_arg[idx])\n-\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n-\t  && comp_types (TREE_TYPE (dest), type))\n-\t{\n-\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the destination; did you mean to \"\n-\t\t\t\"remove the addressof?\", callee);\n-\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n-\t\t    == TYPE_PRECISION (char_type_node))\n-\t\t   || strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the destination; did you mean to \"\n-\t\t\t\"provide an explicit length?\", callee);\n-\t  else\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the destination; did you mean to \"\n-\t\t\t\"dereference it?\", callee);\n-\t  return;\n-\t}\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (dest))\n-\t  && !strop\n-\t  && comp_types (TREE_TYPE (dest), type)\n-\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n-\t\t      \"pointer type %qT as the destination; expected %qT \"\n-\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n-\t\t      TREE_TYPE (TREE_TYPE (dest)));\n-\t  return;\n-\t}\n-    }\n-\n-  if (src && !cmp)\n-    {\n-      if (!TYPE_P (sizeof_arg[idx])\n-\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n-\t  && comp_types (TREE_TYPE (src), type))\n-\t{\n-\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the source; did you mean to \"\n-\t\t\t\"remove the addressof?\", callee);\n-\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n-\t\t    == TYPE_PRECISION (char_type_node))\n-\t\t   || strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the source; did you mean to \"\n-\t\t\t\"provide an explicit length?\", callee);\n-\t  else\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the source; did you mean to \"\n-\t\t\t\"dereference it?\", callee);\n-\t  return;\n-\t}\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (src))\n-\t  && !strop\n-\t  && comp_types (TREE_TYPE (src), type)\n-\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n-\t\t      \"pointer type %qT as the source; expected %qT \"\n-\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n-\t\t      TREE_TYPE (TREE_TYPE (src)));\n-\t  return;\n-\t}\n-    }\n-\n-  if (dest)\n-    {\n-      if (!TYPE_P (sizeof_arg[idx])\n-\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n-\t  && comp_types (TREE_TYPE (dest), type))\n-\t{\n-\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the first source; did you mean to \"\n-\t\t\t\"remove the addressof?\", callee);\n-\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n-\t\t    == TYPE_PRECISION (char_type_node))\n-\t\t   || strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the first source; did you mean to \"\n-\t\t\t\"provide an explicit length?\", callee);\n-\t  else\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the first source; did you mean to \"\n-\t\t\t\"dereference it?\", callee);\n-\t  return;\n-\t}\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (dest))\n-\t  && !strop\n-\t  && comp_types (TREE_TYPE (dest), type)\n-\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n-\t\t      \"pointer type %qT as the first source; expected %qT \"\n-\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n-\t\t      TREE_TYPE (TREE_TYPE (dest)));\n-\t  return;\n-\t}\n-    }\n-\n-  if (src)\n-    {\n-      if (!TYPE_P (sizeof_arg[idx])\n-\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n-\t  && comp_types (TREE_TYPE (src), type))\n-\t{\n-\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the second source; did you mean to \"\n-\t\t\t\"remove the addressof?\", callee);\n-\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n-\t\t    == TYPE_PRECISION (char_type_node))\n-\t\t   || strop)\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the second source; did you mean to \"\n-\t\t\t\"provide an explicit length?\", callee);\n-\t  else\n-\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n-\t\t\t\"expression as the second source; did you mean to \"\n-\t\t\t\"dereference it?\", callee);\n-\t  return;\n-\t}\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (src))\n-\t  && !strop\n-\t  && comp_types (TREE_TYPE (src), type)\n-\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n-\t{\n-\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n-\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n-\t\t      \"pointer type %qT as the second source; expected %qT \"\n-\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n-\t\t      TREE_TYPE (TREE_TYPE (src)));\n-\t  return;\n-\t}\n-    }\n-\n-}\n-\n-/* Warn for unlikely, improbable, or stupid DECL declarations\n-   of `main'.  */\n-\n-void\n-check_main_parameter_types (tree decl)\n-{\n-  function_args_iterator iter;\n-  tree type;\n-  int argct = 0;\n-\n-  FOREACH_FUNCTION_ARGS (TREE_TYPE (decl), type, iter)\n-    {\n-      /* XXX void_type_node belies the abstraction.  */\n-      if (type == void_type_node || type == error_mark_node )\n-\tbreak;\n-\n-      tree t = type;\n-      if (TYPE_ATOMIC (t))\n-\t  pedwarn (input_location, OPT_Wmain,\n-\t\t   \"%<_Atomic%>-qualified parameter type %qT of %q+D\",\n-\t\t   type, decl);\n-      while (POINTER_TYPE_P (t))\n-\t{\n-\t  t = TREE_TYPE (t);\n-\t  if (TYPE_ATOMIC (t))\n-\t    pedwarn (input_location, OPT_Wmain,\n-\t\t     \"%<_Atomic%>-qualified parameter type %qT of %q+D\",\n-\t\t     type, decl);\n-\t}\n-\n-      ++argct;\n-      switch (argct)\n-\t{\n-\tcase 1:\n-\t  if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-\t    pedwarn (input_location, OPT_Wmain,\n-\t\t     \"first argument of %q+D should be %<int%>\", decl);\n-\t  break;\n-\n-\tcase 2:\n-\t  if (TREE_CODE (type) != POINTER_TYPE\n-\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n-\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n-\t\t  != char_type_node))\n-\t    pedwarn (input_location, OPT_Wmain,\n-\t\t     \"second argument of %q+D should be %<char **%>\", decl);\n-\t  break;\n-\n-\tcase 3:\n-\t  if (TREE_CODE (type) != POINTER_TYPE\n-\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n-\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n-\t\t  != char_type_node))\n-\t    pedwarn (input_location, OPT_Wmain,\n-\t\t     \"third argument of %q+D should probably be \"\n-\t\t     \"%<char **%>\", decl);\n-\t  break;\n-\t}\n-    }\n-\n-  /* It is intentional that this message does not mention the third\n-    argument because it's only mentioned in an appendix of the\n-    standard.  */\n-  if (argct > 0 && (argct < 2 || argct > 3))\n-    pedwarn (input_location, OPT_Wmain,\n-\t     \"%q+D takes only zero or two arguments\", decl);\n-\n-  if (stdarg_p (TREE_TYPE (decl)))\n-    pedwarn (input_location, OPT_Wmain,\n-\t     \"%q+D declared as variadic function\", decl);\n-}\n-\n /* vector_targets_convertible_p is used for vector pointer types.  The\n    callers perform various checks that the qualifiers are satisfactory,\n    while OTOH vector_targets_convertible_p ignores the number of elements\n@@ -2264,7 +1380,7 @@ c_build_vec_perm_expr (location_t loc, tree v0, tree v1, tree mask,\n /* Like tree.c:get_narrower, but retain conversion from C++0x scoped enum\n    to integral type.  */\n \n-static tree\n+tree\n c_common_get_narrower (tree op, int *unsignedp_ptr)\n {\n   op = get_narrower (op, unsignedp_ptr);\n@@ -2693,143 +1809,6 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, bool produce_warns)\n   return give_warning;\n }\n \n-/* Warns if the conversion of EXPR to TYPE may alter a value.\n-   This is a helper function for warnings_for_convert_and_check.  */\n-\n-static void\n-conversion_warning (location_t loc, tree type, tree expr)\n-{\n-  tree expr_type = TREE_TYPE (expr);\n-  enum conversion_safety conversion_kind;\n-\n-  if (!warn_conversion && !warn_sign_conversion && !warn_float_conversion)\n-    return;\n-\n-  /* This may happen, because for LHS op= RHS we preevaluate\n-     RHS and create C_MAYBE_CONST_EXPR <SAVE_EXPR <RHS>>, which\n-     means we could no longer see the code of the EXPR.  */\n-  if (TREE_CODE (expr) == C_MAYBE_CONST_EXPR)\n-    expr = C_MAYBE_CONST_EXPR_EXPR (expr);\n-  if (TREE_CODE (expr) == SAVE_EXPR)\n-    expr = TREE_OPERAND (expr, 0);\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_NOT_EXPR:\n-      /* Conversion from boolean to a signed:1 bit-field (which only\n-\t can hold the values 0 and -1) doesn't lose information - but\n-\t it does change the value.  */\n-      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT from boolean expression\", type);\n-      return;\n-\n-    case REAL_CST:\n-    case INTEGER_CST:\n-    case COMPLEX_CST:\n-      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n-      if (conversion_kind == UNSAFE_REAL)\n-\twarning_at (loc, OPT_Wfloat_conversion,\n-\t\t    \"conversion to %qT alters %qT constant value\",\n-\t\t    type, expr_type);\n-      else if (conversion_kind)\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT alters %qT constant value\",\n-\t\t    type, expr_type);\n-      return;\n-\n-    case COND_EXPR:\n-      {\n-        /* In case of COND_EXPR, we do not care about the type of\n-           COND_EXPR, only about the conversion of each operand.  */\n-        tree op1 = TREE_OPERAND (expr, 1);\n-        tree op2 = TREE_OPERAND (expr, 2);\n-        \n-        conversion_warning (loc, type, op1);\n-        conversion_warning (loc, type, op2);\n-        return;\n-      }\n-\n-    default: /* 'expr' is not a constant.  */\n-      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n-      if (conversion_kind == UNSAFE_REAL)\n-\twarning_at (loc, OPT_Wfloat_conversion,\n-\t\t    \"conversion to %qT from %qT may alter its value\",\n-\t\t    type, expr_type);\n-      else if (conversion_kind == UNSAFE_IMAGINARY)\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT from %qT discards imaginary component\",\n-\t\t    type, expr_type);\n-      else if (conversion_kind)\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion to %qT from %qT may alter its value\",\n-\t\t    type, expr_type);\n-    }\n-}\n-\n-/* Produce warnings after a conversion. RESULT is the result of\n-   converting EXPR to TYPE.  This is a helper function for\n-   convert_and_check and cp_convert_and_check.  */\n-\n-void\n-warnings_for_convert_and_check (location_t loc, tree type, tree expr,\n-\t\t\t\ttree result)\n-{\n-  loc = expansion_point_location_if_in_system_header (loc);\n-\n-  if (TREE_CODE (expr) == INTEGER_CST\n-      && (TREE_CODE (type) == INTEGER_TYPE\n-          || TREE_CODE (type) == ENUMERAL_TYPE)\n-      && !int_fits_type_p (expr, type))\n-    {\n-      /* Do not diagnose overflow in a constant expression merely\n-         because a conversion overflowed.  */\n-      if (TREE_OVERFLOW (result))\n-        TREE_OVERFLOW (result) = TREE_OVERFLOW (expr);\n-\n-      if (TYPE_UNSIGNED (type))\n-        {\n-          /* This detects cases like converting -129 or 256 to\n-             unsigned char.  */\n-          if (!int_fits_type_p (expr, c_common_signed_type (type)))\n-            warning_at (loc, OPT_Woverflow,\n-\t\t\t\"large integer implicitly truncated to unsigned type\");\n-          else\n-            conversion_warning (loc, type, expr);\n-        }\n-      else if (!int_fits_type_p (expr, c_common_unsigned_type (type)))\n-\twarning_at (loc, OPT_Woverflow,\n-\t\t \"overflow in implicit constant conversion\");\n-      /* No warning for converting 0x80000000 to int.  */\n-      else if (pedantic\n-\t       && (TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE\n-\t\t   || TYPE_PRECISION (TREE_TYPE (expr))\n-\t\t   != TYPE_PRECISION (type)))\n-\twarning_at (loc, OPT_Woverflow,\n-\t\t    \"overflow in implicit constant conversion\");\n-\n-      else\n-\tconversion_warning (loc, type, expr);\n-    }\n-  else if ((TREE_CODE (result) == INTEGER_CST\n-\t    || TREE_CODE (result) == FIXED_CST) && TREE_OVERFLOW (result))\n-    warning_at (loc, OPT_Woverflow,\n-\t\t\"overflow in implicit constant conversion\");\n-  else\n-    conversion_warning (loc, type, expr);\n-}\n-\n \n /* Convert EXPR to TYPE, warning about conversion problems with constants.\n    Invoke this function on every expression that is converted implicitly,\n@@ -6299,250 +5278,32 @@ c_add_case_label (location_t loc, splay_tree cases, tree cond, tree orig_type,\n \t}\n       else\n \t{\n-\t  error_at (loc, \"multiple default labels in one switch\");\n-\t  error_at (DECL_SOURCE_LOCATION (duplicate),\n-\t\t    \"this is the first default label\");\n-\t}\n-      goto error_out;\n-    }\n-\n-  /* Add a CASE_LABEL to the statement-tree.  */\n-  case_label = add_stmt (build_case_label (low_value, high_value, label));\n-  /* Register this case label in the splay tree.  */\n-  splay_tree_insert (cases,\n-\t\t     (splay_tree_key) low_value,\n-\t\t     (splay_tree_value) case_label);\n-\n-  return case_label;\n-\n- error_out:\n-  /* Add a label so that the back-end doesn't think that the beginning of\n-     the switch is unreachable.  Note that we do not add a case label, as\n-     that just leads to duplicates and thence to failure later on.  */\n-  if (!cases->root)\n-    {\n-      tree t = create_artificial_label (loc);\n-      add_stmt (build_stmt (loc, LABEL_EXPR, t));\n-    }\n-  return error_mark_node;\n-}\n-\n-/* Subroutines of c_do_switch_warnings, called via splay_tree_foreach.\n-   Used to verify that case values match up with enumerator values.  */\n-\n-static void\n-match_case_to_enum_1 (tree key, tree type, tree label)\n-{\n-  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n-\n-  if (tree_fits_uhwi_p (key))\n-    print_dec (key, buf, UNSIGNED);\n-  else if (tree_fits_shwi_p (key))\n-    print_dec (key, buf, SIGNED);\n-  else\n-    print_hex (key, buf);\n-\n-  if (TYPE_NAME (type) == 0)\n-    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n-\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n-\t\t\"case value %qs not in enumerated type\",\n-\t\tbuf);\n-  else\n-    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n-\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n-\t\t\"case value %qs not in enumerated type %qT\",\n-\t\tbuf, type);\n-}\n-\n-/* Subroutine of c_do_switch_warnings, called via splay_tree_foreach.\n-   Used to verify that case values match up with enumerator values.  */\n-\n-static int\n-match_case_to_enum (splay_tree_node node, void *data)\n-{\n-  tree label = (tree) node->value;\n-  tree type = (tree) data;\n-\n-  /* Skip default case.  */\n-  if (!CASE_LOW (label))\n-    return 0;\n-\n-  /* If CASE_LOW_SEEN is not set, that means CASE_LOW did not appear\n-     when we did our enum->case scan.  Reset our scratch bit after.  */\n-  if (!CASE_LOW_SEEN (label))\n-    match_case_to_enum_1 (CASE_LOW (label), type, label);\n-  else\n-    CASE_LOW_SEEN (label) = 0;\n-\n-  /* If CASE_HIGH is non-null, we have a range.  If CASE_HIGH_SEEN is\n-     not set, that means that CASE_HIGH did not appear when we did our\n-     enum->case scan.  Reset our scratch bit after.  */\n-  if (CASE_HIGH (label))\n-    {\n-      if (!CASE_HIGH_SEEN (label))\n-\tmatch_case_to_enum_1 (CASE_HIGH (label), type, label);\n-      else\n-\tCASE_HIGH_SEEN (label) = 0;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Handle -Wswitch*.  Called from the front end after parsing the\n-   switch construct.  */\n-/* ??? Should probably be somewhere generic, since other languages\n-   besides C and C++ would want this.  At the moment, however, C/C++\n-   are the only tree-ssa languages that support enumerations at all,\n-   so the point is moot.  */\n-\n-void\n-c_do_switch_warnings (splay_tree cases, location_t switch_location,\n-\t\t      tree type, tree cond, bool bool_cond_p,\n-\t\t      bool outside_range_p)\n-{\n-  splay_tree_node default_node;\n-  splay_tree_node node;\n-  tree chain;\n-\n-  if (!warn_switch && !warn_switch_enum && !warn_switch_default\n-      && !warn_switch_bool)\n-    return;\n-\n-  default_node = splay_tree_lookup (cases, (splay_tree_key) NULL);\n-  if (!default_node)\n-    warning_at (switch_location, OPT_Wswitch_default,\n-\t\t\"switch missing default case\");\n-\n-  /* There are certain cases where -Wswitch-bool warnings aren't\n-     desirable, such as\n-     switch (boolean)\n-       {\n-       case true: ...\n-       case false: ...\n-       }\n-     so be careful here.  */\n-  if (warn_switch_bool && bool_cond_p)\n-    {\n-      splay_tree_node min_node;\n-      /* If there's a default node, it's also the value with the minimal\n-\t key.  So look at the penultimate key (if any).  */\n-      if (default_node)\n-\tmin_node = splay_tree_successor (cases, (splay_tree_key) NULL);\n-      else\n-\tmin_node = splay_tree_min (cases);\n-      tree min = min_node ? (tree) min_node->key : NULL_TREE;\n-\n-      splay_tree_node max_node = splay_tree_max (cases);\n-      /* This might be a case range, so look at the value with the\n-\t maximal key and then check CASE_HIGH.  */\n-      tree max = max_node ? (tree) max_node->value : NULL_TREE;\n-      if (max)\n-\tmax = CASE_HIGH (max) ? CASE_HIGH (max) : CASE_LOW (max);\n-\n-      /* If there's a case value > 1 or < 0, that is outside bool\n-\t range, warn.  */\n-      if (outside_range_p\n-\t  || (max && wi::gts_p (max, 1))\n-\t  || (min && wi::lts_p (min, 0))\n-\t  /* And handle the\n-\t     switch (boolean)\n-\t       {\n-\t       case true: ...\n-\t       case false: ...\n-\t       default: ...\n-\t       }\n-\t     case, where we want to warn.  */\n-\t  || (default_node\n-\t      && max && wi::eq_p (max, 1)\n-\t      && min && wi::eq_p (min, 0)))\n-\twarning_at (switch_location, OPT_Wswitch_bool,\n-\t\t    \"switch condition has boolean value\");\n-    }\n-\n-  /* From here on, we only care about enumerated types.  */\n-  if (!type || TREE_CODE (type) != ENUMERAL_TYPE)\n-    return;\n-\n-  /* From here on, we only care about -Wswitch and -Wswitch-enum.  */\n-  if (!warn_switch_enum && !warn_switch)\n-    return;\n-\n-  /* Check the cases.  Warn about case values which are not members of\n-     the enumerated type.  For -Wswitch-enum, or for -Wswitch when\n-     there is no default case, check that exactly all enumeration\n-     literals are covered by the cases.  */\n-\n-  /* Clearing COND if it is not an integer constant simplifies\n-     the tests inside the loop below.  */\n-  if (TREE_CODE (cond) != INTEGER_CST)\n-    cond = NULL_TREE;\n-\n-  /* The time complexity here is O(N*lg(N)) worst case, but for the\n-      common case of monotonically increasing enumerators, it is\n-      O(N), since the nature of the splay tree will keep the next\n-      element adjacent to the root at all times.  */\n-\n-  for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n-    {\n-      tree value = TREE_VALUE (chain);\n-      if (TREE_CODE (value) == CONST_DECL)\n-        value = DECL_INITIAL (value);\n-      node = splay_tree_lookup (cases, (splay_tree_key) value);\n-      if (node)\n-\t{\n-\t  /* Mark the CASE_LOW part of the case entry as seen.  */\n-\t  tree label = (tree) node->value;\n-\t  CASE_LOW_SEEN (label) = 1;\n-\t  continue;\n-\t}\n-\n-      /* Even though there wasn't an exact match, there might be a\n-\t case range which includes the enumerator's value.  */\n-      node = splay_tree_predecessor (cases, (splay_tree_key) value);\n-      if (node && CASE_HIGH ((tree) node->value))\n-\t{\n-\t  tree label = (tree) node->value;\n-\t  int cmp = tree_int_cst_compare (CASE_HIGH (label), value);\n-\t  if (cmp >= 0)\n-\t    {\n-\t      /* If we match the upper bound exactly, mark the CASE_HIGH\n-\t\t part of the case entry as seen.  */\n-\t      if (cmp == 0)\n-\t\tCASE_HIGH_SEEN (label) = 1;\n-\t      continue;\n-\t    }\n+\t  error_at (loc, \"multiple default labels in one switch\");\n+\t  error_at (DECL_SOURCE_LOCATION (duplicate),\n+\t\t    \"this is the first default label\");\n \t}\n-\n-      /* We've now determined that this enumerated literal isn't\n-\t handled by the case labels of the switch statement.  */\n-\n-      /* If the switch expression is a constant, we only really care\n-\t about whether that constant is handled by the switch.  */\n-      if (cond && tree_int_cst_compare (cond, value))\n-\tcontinue;\n-\n-      /* If there is a default_node, the only relevant option is\n-\t Wswitch-enum.  Otherwise, if both are enabled then we prefer\n-\t to warn using -Wswitch because -Wswitch is enabled by -Wall\n-\t while -Wswitch-enum is explicit.  */\n-      warning_at (switch_location,\n-\t\t  (default_node || !warn_switch\n-\t\t   ? OPT_Wswitch_enum\n-\t\t   : OPT_Wswitch),\n-\t\t  \"enumeration value %qE not handled in switch\",\n-\t\t  TREE_PURPOSE (chain));\n+      goto error_out;\n     }\n \n-  /* Warn if there are case expressions that don't correspond to\n-     enumerators.  This can occur since C and C++ don't enforce\n-     type-checking of assignments to enumeration variables.\n+  /* Add a CASE_LABEL to the statement-tree.  */\n+  case_label = add_stmt (build_case_label (low_value, high_value, label));\n+  /* Register this case label in the splay tree.  */\n+  splay_tree_insert (cases,\n+\t\t     (splay_tree_key) low_value,\n+\t\t     (splay_tree_value) case_label);\n \n-     The time complexity here is now always O(N) worst case, since\n-     we should have marked both the lower bound and upper bound of\n-     every disjoint case label, with CASE_LOW_SEEN and CASE_HIGH_SEEN\n-     above.  This scan also resets those fields.  */\n+  return case_label;\n \n-  splay_tree_foreach (cases, match_case_to_enum, type);\n+ error_out:\n+  /* Add a label so that the back-end doesn't think that the beginning of\n+     the switch is unreachable.  Note that we do not add a case label, as\n+     that just leads to duplicates and thence to failure later on.  */\n+  if (!cases->root)\n+    {\n+      tree t = create_artificial_label (loc);\n+      add_stmt (build_stmt (loc, LABEL_EXPR, t));\n+    }\n+  return error_mark_node;\n }\n \n /* Finish an expression taking the address of LABEL (an\n@@ -10647,164 +9408,6 @@ fold_offsetof (tree expr)\n   return convert (size_type_node, fold_offsetof_1 (expr));\n }\n \n-/* Warn for A ?: C expressions (with B omitted) where A is a boolean\n-   expression, because B will always be true. */\n-\n-void\n-warn_for_omitted_condop (location_t location, tree cond)\n-{\n-  /* In C++ template declarations it can happen that the type is dependent\n-     and not yet known, thus TREE_TYPE (cond) == NULL_TREE.  */\n-  if (truth_value_p (TREE_CODE (cond))\n-      || (TREE_TYPE (cond) != NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (cond)) == BOOLEAN_TYPE))\n-      warning_at (location, OPT_Wparentheses,\n-\t\t\"the omitted middle operand in ?: will always be %<true%>, \"\n-\t\t\"suggest explicit middle operand\");\n-}\n-\n-/* Give an error for storing into ARG, which is 'const'.  USE indicates\n-   how ARG was being used.  */\n-\n-void\n-readonly_error (location_t loc, tree arg, enum lvalue_use use)\n-{\n-  gcc_assert (use == lv_assign || use == lv_increment || use == lv_decrement\n-\t      || use == lv_asm);\n-  /* Using this macro rather than (for example) arrays of messages\n-     ensures that all the format strings are checked at compile\n-     time.  */\n-#define READONLY_MSG(A, I, D, AS) (use == lv_assign ? (A)\t\t\\\n-\t\t\t\t   : (use == lv_increment ? (I)\t\t\\\n-\t\t\t\t   : (use == lv_decrement ? (D) : (AS))))\n-  if (TREE_CODE (arg) == COMPONENT_REF)\n-    {\n-      if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        error_at (loc, READONLY_MSG (G_(\"assignment of member \"\n-\t\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t\t     G_(\"increment of member \"\n-\t\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t\t     G_(\"decrement of member \"\n-\t\t\t\t\t\"%qD in read-only object\"),\n-\t\t\t\t     G_(\"member %qD in read-only object \"\n-\t\t\t\t\t\"used as %<asm%> output\")),\n-\t\t  TREE_OPERAND (arg, 1));\n-      else\n-\terror_at (loc, READONLY_MSG (G_(\"assignment of read-only member %qD\"),\n-\t\t\t\t     G_(\"increment of read-only member %qD\"),\n-\t\t\t\t     G_(\"decrement of read-only member %qD\"),\n-\t\t\t\t     G_(\"read-only member %qD used as %<asm%> output\")),\n-\t\t  TREE_OPERAND (arg, 1));\n-    }\n-  else if (VAR_P (arg))\n-    error_at (loc, READONLY_MSG (G_(\"assignment of read-only variable %qD\"),\n-\t\t\t\t G_(\"increment of read-only variable %qD\"),\n-\t\t\t\t G_(\"decrement of read-only variable %qD\"),\n-\t\t\t\t G_(\"read-only variable %qD used as %<asm%> output\")),\n-\t      arg);\n-  else if (TREE_CODE (arg) == PARM_DECL)\n-    error_at (loc, READONLY_MSG (G_(\"assignment of read-only parameter %qD\"),\n-\t\t\t\t G_(\"increment of read-only parameter %qD\"),\n-\t\t\t\t G_(\"decrement of read-only parameter %qD\"),\n-\t\t\t\t G_(\"read-only parameter %qD use as %<asm%> output\")),\n-\t      arg);\n-  else if (TREE_CODE (arg) == RESULT_DECL)\n-    {\n-      gcc_assert (c_dialect_cxx ());\n-      error_at (loc, READONLY_MSG (G_(\"assignment of \"\n-\t\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t\t   G_(\"increment of \"\n-\t\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t\t   G_(\"decrement of \"\n-\t\t\t\t      \"read-only named return value %qD\"),\n-\t\t\t\t   G_(\"read-only named return value %qD \"\n-\t\t\t\t      \"used as %<asm%>output\")),\n-\t\targ);\n-    }\n-  else if (TREE_CODE (arg) == FUNCTION_DECL)\n-    error_at (loc, READONLY_MSG (G_(\"assignment of function %qD\"),\n-\t\t\t\t G_(\"increment of function %qD\"),\n-\t\t\t\t G_(\"decrement of function %qD\"),\n-\t\t\t\t G_(\"function %qD used as %<asm%> output\")),\n-\t      arg);\n-  else\n-    error_at (loc, READONLY_MSG (G_(\"assignment of read-only location %qE\"),\n-\t\t\t\t G_(\"increment of read-only location %qE\"),\n-\t\t\t\t G_(\"decrement of read-only location %qE\"),\n-\t\t\t\t G_(\"read-only location %qE used as %<asm%> output\")),\n-\t      arg);\n-}\n-\n-/* Print an error message for an invalid lvalue.  USE says\n-   how the lvalue is being used and so selects the error message.  LOC\n-   is the location for the error.  */\n-\n-void\n-lvalue_error (location_t loc, enum lvalue_use use)\n-{\n-  switch (use)\n-    {\n-    case lv_assign:\n-      error_at (loc, \"lvalue required as left operand of assignment\");\n-      break;\n-    case lv_increment:\n-      error_at (loc, \"lvalue required as increment operand\");\n-      break;\n-    case lv_decrement:\n-      error_at (loc, \"lvalue required as decrement operand\");\n-      break;\n-    case lv_addressof:\n-      error_at (loc, \"lvalue required as unary %<&%> operand\");\n-      break;\n-    case lv_asm:\n-      error_at (loc, \"lvalue required in asm statement\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Print an error message for an invalid indirection of type TYPE.\n-   ERRSTRING is the name of the operator for the indirection.  */\n-\n-void\n-invalid_indirection_error (location_t loc, tree type, ref_operator errstring)\n-{\n-  switch (errstring)\n-    {\n-    case RO_NULL:\n-      gcc_assert (c_dialect_cxx ());\n-      error_at (loc, \"invalid type argument (have %qT)\", type);\n-      break;\n-    case RO_ARRAY_INDEXING:\n-      error_at (loc,\n-\t\t\"invalid type argument of array indexing (have %qT)\",\n-\t\ttype);\n-      break;\n-    case RO_UNARY_STAR:\n-      error_at (loc,\n-\t\t\"invalid type argument of unary %<*%> (have %qT)\",\n-\t\ttype);\n-      break;\n-    case RO_ARROW:\n-      error_at (loc,\n-\t\t\"invalid type argument of %<->%> (have %qT)\",\n-\t\ttype);\n-      break;\n-    case RO_ARROW_STAR:\n-      error_at (loc,\n-\t\t\"invalid type argument of %<->*%> (have %qT)\",\n-\t\ttype);\n-      break;\n-    case RO_IMPLICIT_CONVERSION:\n-      error_at (loc,\n-\t\t\"invalid type argument of implicit conversion (have %qT)\",\n-\t\ttype);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n \f\n /* *PTYPE is an incomplete array.  Complete it with a domain based on\n    INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT\n@@ -11836,470 +10439,6 @@ check_missing_format_attribute (tree ltype, tree rtype)\n     return false;\n }\n \n-/* Subscripting with type char is likely to lose on a machine where\n-   chars are signed.  So warn on any machine, but optionally.  Don't\n-   warn for unsigned char since that type is safe.  Don't warn for\n-   signed char because anyone who uses that must have done so\n-   deliberately. Furthermore, we reduce the false positive load by\n-   warning only for non-constant value of type char.  */\n-\n-void\n-warn_array_subscript_with_type_char (location_t loc, tree index)\n-{\n-  if (TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node\n-      && TREE_CODE (index) != INTEGER_CST)\n-    warning_at (loc, OPT_Wchar_subscripts,\n-\t\t\"array subscript has type %<char%>\");\n-}\n-\n-/* Implement -Wparentheses for the unexpected C precedence rules, to\n-   cover cases like x + y << z which readers are likely to\n-   misinterpret.  We have seen an expression in which CODE is a binary\n-   operator used to combine expressions ARG_LEFT and ARG_RIGHT, which\n-   before folding had CODE_LEFT and CODE_RIGHT.  CODE_LEFT and\n-   CODE_RIGHT may be ERROR_MARK, which means that that side of the\n-   expression was not formed using a binary or unary operator, or it\n-   was enclosed in parentheses.  */\n-\n-void\n-warn_about_parentheses (location_t loc, enum tree_code code,\n-\t\t\tenum tree_code code_left, tree arg_left,\n-\t\t\tenum tree_code code_right, tree arg_right)\n-{\n-  if (!warn_parentheses)\n-    return;\n-\n-  /* This macro tests that the expression ARG with original tree code\n-     CODE appears to be a boolean expression. or the result of folding a\n-     boolean expression.  */\n-#define APPEARS_TO_BE_BOOLEAN_EXPR_P(CODE, ARG)                             \\\n-\t(truth_value_p (TREE_CODE (ARG))                                    \\\n-\t || TREE_CODE (TREE_TYPE (ARG)) == BOOLEAN_TYPE                     \\\n-\t /* Folding may create 0 or 1 integers from other expressions.  */  \\\n-\t || ((CODE) != INTEGER_CST                                          \\\n-\t     && (integer_onep (ARG) || integer_zerop (ARG))))\n-\n-  switch (code)\n-    {\n-    case LSHIFT_EXPR:\n-      if (code_left == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<+%> inside %<<<%>\");\n-      else if (code_right == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<+%> inside %<<<%>\");\n-      else if (code_left == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<-%> inside %<<<%>\");\n-      else if (code_right == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<-%> inside %<<<%>\");\n-      return;\n-\n-    case RSHIFT_EXPR:\n-      if (code_left == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<+%> inside %<>>%>\");\n-      else if (code_right == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<+%> inside %<>>%>\");\n-      else if (code_left == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<-%> inside %<>>%>\");\n-      else if (code_right == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<-%> inside %<>>%>\");\n-      return;\n-\n-    case TRUTH_ORIF_EXPR:\n-      if (code_left == TRUTH_ANDIF_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<&&%> within %<||%>\");\n-      else if (code_right == TRUTH_ANDIF_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around %<&&%> within %<||%>\");\n-      return;\n-\n-    case BIT_IOR_EXPR:\n-      if (code_left == BIT_AND_EXPR || code_left == BIT_XOR_EXPR\n-\t  || code_left == PLUS_EXPR || code_left == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around arithmetic in operand of %<|%>\");\n-      else if (code_right == BIT_AND_EXPR || code_right == BIT_XOR_EXPR\n-\t       || code_right == PLUS_EXPR || code_right == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around arithmetic in operand of %<|%>\");\n-      /* Check cases like x|y==z */\n-      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<|%>\");\n-      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<|%>\");\n-      /* Check cases like !x | y */\n-      else if (code_left == TRUTH_NOT_EXPR\n-\t       && !APPEARS_TO_BE_BOOLEAN_EXPR_P (code_right, arg_right))\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around operand of \"\n-\t\t    \"%<!%> or change %<|%> to %<||%> or %<!%> to %<~%>\");\n-      return;\n-\n-    case BIT_XOR_EXPR:\n-      if (code_left == BIT_AND_EXPR\n-\t  || code_left == PLUS_EXPR || code_left == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around arithmetic in operand of %<^%>\");\n-      else if (code_right == BIT_AND_EXPR\n-\t       || code_right == PLUS_EXPR || code_right == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around arithmetic in operand of %<^%>\");\n-      /* Check cases like x^y==z */\n-      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<^%>\");\n-      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<^%>\");\n-      return;\n-\n-    case BIT_AND_EXPR:\n-      if (code_left == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around %<+%> in operand of %<&%>\");\n-      else if (code_right == PLUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around %<+%> in operand of %<&%>\");\n-      else if (code_left == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around %<-%> in operand of %<&%>\");\n-      else if (code_right == MINUS_EXPR)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around %<-%> in operand of %<&%>\");\n-      /* Check cases like x&y==z */\n-      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<&%>\");\n-      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<&%>\");\n-      /* Check cases like !x & y */\n-      else if (code_left == TRUTH_NOT_EXPR\n-\t       && !APPEARS_TO_BE_BOOLEAN_EXPR_P (code_right, arg_right))\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t    \"suggest parentheses around operand of \"\n-\t\t    \"%<!%> or change %<&%> to %<&&%> or %<!%> to %<~%>\");\n-      return;\n-\n-    case EQ_EXPR:\n-      if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<==%>\");\n-      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<==%>\");\n-      return;\n-    case NE_EXPR:\n-      if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<!=%>\");\n-      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n-\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t \"suggest parentheses around comparison in operand of %<!=%>\");\n-      return;\n-\n-    default:\n-      if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t{\n-\t  if (TREE_CODE_CLASS (code_left) == tcc_comparison\n-\t\t&& code_left != NE_EXPR && code_left != EQ_EXPR\n-\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (arg_left)))\n-\t    warning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n-\t\t\t\"comparisons like %<X<=Y<=Z%> do not \"\n-\t\t\t\"have their mathematical meaning\");\n-\t  else if (TREE_CODE_CLASS (code_right) == tcc_comparison\n-\t\t   && code_right != NE_EXPR && code_right != EQ_EXPR\n-\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (arg_right)))\n-\t    warning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n-\t\t\t\"comparisons like %<X<=Y<=Z%> do not \"\n-\t\t\t\"have their mathematical meaning\");\n-\t}\n-      return;\n-    }\n-#undef NOT_A_BOOLEAN_EXPR_P\n-}\n-\n-/* If LABEL (a LABEL_DECL) has not been used, issue a warning.  */\n-\n-void\n-warn_for_unused_label (tree label)\n-{\n-  if (!TREE_USED (label))\n-    {\n-      if (DECL_INITIAL (label))\n-\twarning (OPT_Wunused_label, \"label %q+D defined but not used\", label);\n-      else\n-        warning (OPT_Wunused_label, \"label %q+D declared but not defined\", label);\n-    }\n-}\n-\n-/* Warn for division by zero according to the value of DIVISOR.  LOC\n-   is the location of the division operator.  */\n-\n-void\n-warn_for_div_by_zero (location_t loc, tree divisor)\n-{\n-  /* If DIVISOR is zero, and has integral or fixed-point type, issue a warning\n-     about division by zero.  Do not issue a warning if DIVISOR has a\n-     floating-point type, since we consider 0.0/0.0 a valid way of\n-     generating a NaN.  */\n-  if (c_inhibit_evaluation_warnings == 0\n-      && (integer_zerop (divisor) || fixed_zerop (divisor)))\n-    warning_at (loc, OPT_Wdiv_by_zero, \"division by zero\");\n-}\n-\n-/* Warn for patterns where memset appears to be used incorrectly.  The\n-   warning location should be LOC.  ARG0, and ARG2 are the first and\n-   last arguments to the call, while LITERAL_ZERO_MASK has a 1 bit for\n-   each argument that was a literal zero.  */\n-\n-void\n-warn_for_memset (location_t loc, tree arg0, tree arg2,\n-\t\t int literal_zero_mask)\n-{\n-  if (warn_memset_transposed_args\n-      && integer_zerop (arg2)\n-      && (literal_zero_mask & (1 << 2)) != 0\n-      && (literal_zero_mask & (1 << 1)) == 0)\n-    warning_at (loc, OPT_Wmemset_transposed_args,\n-\t\t\"%<memset%> used with constant zero length \"\n-\t\t\"parameter; this could be due to transposed \"\n-\t\t\"parameters\");\n-\n-  if (warn_memset_elt_size && TREE_CODE (arg2) == INTEGER_CST)\n-    {\n-      STRIP_NOPS (arg0);\n-      if (TREE_CODE (arg0) == ADDR_EXPR)\n-\targ0 = TREE_OPERAND (arg0, 0);\n-      tree type = TREE_TYPE (arg0);\n-      if (type != NULL_TREE && TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  tree elt_type = TREE_TYPE (type);\n-\t  tree domain = TYPE_DOMAIN (type);\n-\t  if (!integer_onep (TYPE_SIZE_UNIT (elt_type))\n-\t      && domain != NULL_TREE\n-\t      && TYPE_MAXVAL (domain)\n-\t      && TYPE_MINVAL (domain)\n-\t      && integer_zerop (TYPE_MINVAL (domain))\n-\t      && integer_onep (fold_build2 (MINUS_EXPR, domain,\n-\t\t\t\t\t    arg2,\n-\t\t\t\t\t    TYPE_MAXVAL (domain))))\n-\t    warning_at (loc, OPT_Wmemset_elt_size,\n-\t\t\t\"%<memset%> used with length equal to \"\n-\t\t\t\"number of elements without multiplication \"\n-\t\t\t\"by element size\");\n-\t}\n-    }\n-}\n-\n-/* Subroutine of build_binary_op. Give warnings for comparisons\n-   between signed and unsigned quantities that may fail. Do the\n-   checking based on the original operand trees ORIG_OP0 and ORIG_OP1,\n-   so that casts will be considered, but default promotions won't\n-   be.\n-\n-   LOCATION is the location of the comparison operator.\n-\n-   The arguments of this function map directly to local variables\n-   of build_binary_op.  */\n-\n-void\n-warn_for_sign_compare (location_t location,\n-\t\t       tree orig_op0, tree orig_op1,\n-\t\t       tree op0, tree op1,\n-\t\t       tree result_type, enum tree_code resultcode)\n-{\n-  int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n-  int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n-  int unsignedp0, unsignedp1;\n-\n-  /* In C++, check for comparison of different enum types.  */\n-  if (c_dialect_cxx()\n-      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n-      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n-\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n-    {\n-      warning_at (location,\n-\t\t  OPT_Wsign_compare, \"comparison between types %qT and %qT\",\n-\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n-    }\n-\n-  /* Do not warn if the comparison is being done in a signed type,\n-     since the signed type will only be chosen if it can represent\n-     all the values of the unsigned type.  */\n-  if (!TYPE_UNSIGNED (result_type))\n-    /* OK */;\n-  /* Do not warn if both operands are unsigned.  */\n-  else if (op0_signed == op1_signed)\n-    /* OK */;\n-  else\n-    {\n-      tree sop, uop, base_type;\n-      bool ovf;\n-\n-      if (op0_signed)\n-        sop = orig_op0, uop = orig_op1;\n-      else\n-        sop = orig_op1, uop = orig_op0;\n-\n-      STRIP_TYPE_NOPS (sop);\n-      STRIP_TYPE_NOPS (uop);\n-      base_type = (TREE_CODE (result_type) == COMPLEX_TYPE\n-\t\t   ? TREE_TYPE (result_type) : result_type);\n-\n-      /* Do not warn if the signed quantity is an unsuffixed integer\n-         literal (or some static constant expression involving such\n-         literals or a conditional expression involving such literals)\n-         and it is non-negative.  */\n-      if (tree_expr_nonnegative_warnv_p (sop, &ovf))\n-        /* OK */;\n-      /* Do not warn if the comparison is an equality operation, the\n-         unsigned quantity is an integral constant, and it would fit\n-         in the result if the result were signed.  */\n-      else if (TREE_CODE (uop) == INTEGER_CST\n-               && (resultcode == EQ_EXPR || resultcode == NE_EXPR)\n-\t       && int_fits_type_p (uop, c_common_signed_type (base_type)))\n-        /* OK */;\n-      /* In C, do not warn if the unsigned quantity is an enumeration\n-         constant and its maximum value would fit in the result if the\n-         result were signed.  */\n-      else if (!c_dialect_cxx() && TREE_CODE (uop) == INTEGER_CST\n-               && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n-               && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n-\t\t\t\t   c_common_signed_type (base_type)))\n-        /* OK */;\n-      else\n-        warning_at (location,\n-\t\t    OPT_Wsign_compare,\n-\t\t    \"comparison between signed and unsigned integer expressions\");\n-    }\n-\n-  /* Warn if two unsigned values are being compared in a size larger\n-     than their original size, and one (and only one) is the result of\n-     a `~' operator.  This comparison will always fail.\n-\n-     Also warn if one operand is a constant, and the constant does not\n-     have all bits set that are set in the ~ operand when it is\n-     extended.  */\n-\n-  op0 = c_common_get_narrower (op0, &unsignedp0);\n-  op1 = c_common_get_narrower (op1, &unsignedp1);\n-\n-  if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n-      ^ (TREE_CODE (op1) == BIT_NOT_EXPR))\n-    {\n-      if (TREE_CODE (op0) == BIT_NOT_EXPR)\n-\top0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n-      if (TREE_CODE (op1) == BIT_NOT_EXPR)\n-\top1 = c_common_get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n-\n-      if (tree_fits_shwi_p (op0) || tree_fits_shwi_p (op1))\n-        {\n-          tree primop;\n-          HOST_WIDE_INT constant, mask;\n-          int unsignedp;\n-          unsigned int bits;\n-\n-          if (tree_fits_shwi_p (op0))\n-            {\n-              primop = op1;\n-              unsignedp = unsignedp1;\n-              constant = tree_to_shwi (op0);\n-            }\n-          else\n-            {\n-              primop = op0;\n-              unsignedp = unsignedp0;\n-              constant = tree_to_shwi (op1);\n-            }\n-\n-          bits = TYPE_PRECISION (TREE_TYPE (primop));\n-          if (bits < TYPE_PRECISION (result_type)\n-              && bits < HOST_BITS_PER_LONG && unsignedp)\n-            {\n-              mask = HOST_WIDE_INT_M1U << bits;\n-              if ((mask & constant) != mask)\n-\t\t{\n-\t\t  if (constant == 0)\n-\t\t    warning_at (location, OPT_Wsign_compare,\n-\t\t\t\t\"promoted ~unsigned is always non-zero\");\n-\t\t  else\n-\t\t    warning_at (location, OPT_Wsign_compare,\n-\t\t\t\t\"comparison of promoted ~unsigned with constant\");\n-\t\t}\n-            }\n-        }\n-      else if (unsignedp0 && unsignedp1\n-               && (TYPE_PRECISION (TREE_TYPE (op0))\n-                   < TYPE_PRECISION (result_type))\n-               && (TYPE_PRECISION (TREE_TYPE (op1))\n-                   < TYPE_PRECISION (result_type)))\n-        warning_at (location, OPT_Wsign_compare,\n-                 \"comparison of promoted ~unsigned with unsigned\");\n-    }\n-}\n-\n-/* RESULT_TYPE is the result of converting TYPE1 and TYPE2 to a common\n-   type via c_common_type.  If -Wdouble-promotion is in use, and the\n-   conditions for warning have been met, issue a warning.  GMSGID is\n-   the warning message.  It must have two %T specifiers for the type\n-   that was converted (generally \"float\") and the type to which it was\n-   converted (generally \"double), respectively.  LOC is the location\n-   to which the awrning should refer.  */\n-\n-void\n-do_warn_double_promotion (tree result_type, tree type1, tree type2,\n-\t\t\t const char *gmsgid, location_t loc)\n-{\n-  tree source_type;\n-\n-  if (!warn_double_promotion)\n-    return;\n-  /* If the conversion will not occur at run-time, there is no need to\n-     warn about it.  */\n-  if (c_inhibit_evaluation_warnings)\n-    return;\n-  if (TYPE_MAIN_VARIANT (result_type) != double_type_node\n-      && TYPE_MAIN_VARIANT (result_type) != complex_double_type_node)\n-    return;\n-  if (TYPE_MAIN_VARIANT (type1) == float_type_node\n-      || TYPE_MAIN_VARIANT (type1) == complex_float_type_node)\n-    source_type = type1;\n-  else if (TYPE_MAIN_VARIANT (type2) == float_type_node\n-\t   || TYPE_MAIN_VARIANT (type2) == complex_float_type_node)\n-    source_type = type2;\n-  else\n-    return;\n-  warning_at (loc, OPT_Wdouble_promotion, gmsgid, source_type, result_type);\n-}\n-\n-/* Possibly warn about unused parameters.  */\n-\n-void\n-do_warn_unused_parameter (tree fn)\n-{\n-  tree decl;\n-\n-  for (decl = DECL_ARGUMENTS (fn);\n-       decl; decl = DECL_CHAIN (decl))\n-    if (!TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n-\t&& DECL_NAME (decl) && !DECL_ARTIFICIAL (decl)\n-\t&& !TREE_NO_WARNING (decl))\n-      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wunused_parameter,\n-\t\t  \"unused parameter %qD\", decl);\n-}\n-\n-\n /* Setup a TYPE_DECL node as a typedef representation.\n \n    X is a TYPE_DECL for a typedef statement.  Create a brand new\n@@ -12381,180 +10520,6 @@ record_types_used_by_current_var_decl (tree decl)\n     }\n }\n \n-/* If DECL is a typedef that is declared in the current function,\n-   record it for the purpose of -Wunused-local-typedefs.  */\n-\n-void\n-record_locally_defined_typedef (tree decl)\n-{\n-  struct c_language_function *l;\n-\n-  if (!warn_unused_local_typedefs\n-      || cfun == NULL\n-      /* if this is not a locally defined typedef then we are not\n-\t interested.  */\n-      || !is_typedef_decl (decl)\n-      || !decl_function_context (decl))\n-    return;\n-\n-  l = (struct c_language_function *) cfun->language;\n-  vec_safe_push (l->local_typedefs, decl);\n-}\n-\n-/* If T is a TYPE_DECL declared locally, mark it as used.  */\n-\n-void\n-maybe_record_typedef_use (tree t)\n-{\n-  if (!is_typedef_decl (t))\n-    return;\n-\n-  TREE_USED (t) = true;\n-}\n-\n-/* Warn if there are some unused locally defined typedefs in the\n-   current function. */\n-\n-void\n-maybe_warn_unused_local_typedefs (void)\n-{\n-  int i;\n-  tree decl;\n-  /* The number of times we have emitted -Wunused-local-typedefs\n-     warnings.  If this is different from errorcount, that means some\n-     unrelated errors have been issued.  In which case, we'll avoid\n-     emitting \"unused-local-typedefs\" warnings.  */\n-  static int unused_local_typedefs_warn_count;\n-  struct c_language_function *l;\n-\n-  if (cfun == NULL)\n-    return;\n-\n-  if ((l = (struct c_language_function *) cfun->language) == NULL)\n-    return;\n-\n-  if (warn_unused_local_typedefs\n-      && errorcount == unused_local_typedefs_warn_count)\n-    {\n-      FOR_EACH_VEC_SAFE_ELT (l->local_typedefs, i, decl)\n-\tif (!TREE_USED (decl))\n-\t  warning_at (DECL_SOURCE_LOCATION (decl),\n-\t\t      OPT_Wunused_local_typedefs,\n-\t\t      \"typedef %qD locally defined but not used\", decl);\n-      unused_local_typedefs_warn_count = errorcount;\n-    }\n-\n-  vec_free (l->local_typedefs);\n-}\n-\n-/* Warn about boolean expression compared with an integer value different\n-   from true/false.  Warns also e.g. about \"(i1 == i2) == 2\".\n-   LOC is the location of the comparison, CODE is its code, OP0 and OP1\n-   are the operands of the comparison.  The caller must ensure that\n-   either operand is a boolean expression.  */\n-\n-void\n-maybe_warn_bool_compare (location_t loc, enum tree_code code, tree op0,\n-\t\t\t tree op1)\n-{\n-  if (TREE_CODE_CLASS (code) != tcc_comparison)\n-    return;\n-\n-  tree f, cst;\n-  if (f = fold_for_warn (op0),\n-      TREE_CODE (f) == INTEGER_CST)\n-    cst = op0 = f;\n-  else if (f = fold_for_warn (op1),\n-\t   TREE_CODE (f) == INTEGER_CST)\n-    cst = op1 = f;\n-  else\n-    return;\n-\n-  if (!integer_zerop (cst) && !integer_onep (cst))\n-    {\n-      int sign = (TREE_CODE (op0) == INTEGER_CST\n-\t\t ? tree_int_cst_sgn (cst) : -tree_int_cst_sgn (cst));\n-      if (code == EQ_EXPR\n-\t  || ((code == GT_EXPR || code == GE_EXPR) && sign < 0)\n-\t  || ((code == LT_EXPR || code == LE_EXPR) && sign > 0))\n-\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n-\t\t    \"with boolean expression is always false\", cst);\n-      else\n-\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n-\t\t    \"with boolean expression is always true\", cst);\n-    }\n-  else if (integer_zerop (cst) || integer_onep (cst))\n-    {\n-      /* If the non-constant operand isn't of a boolean type, we\n-\t don't want to warn here.  */\n-      tree noncst = TREE_CODE (op0) == INTEGER_CST ? op1 : op0;\n-      /* Handle booleans promoted to integers.  */\n-      if (bool_promoted_to_int_p (noncst))\n-\t/* Warn.  */;\n-      else if (TREE_CODE (TREE_TYPE (noncst)) != BOOLEAN_TYPE\n-\t       && !truth_value_p (TREE_CODE (noncst)))\n-\treturn;\n-      /* Do some magic to get the right diagnostics.  */\n-      bool flag = TREE_CODE (op0) == INTEGER_CST;\n-      flag = integer_zerop (cst) ? flag : !flag;\n-      if ((code == GE_EXPR && !flag) || (code == LE_EXPR && flag))\n-\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n-\t\t    \"with boolean expression is always true\", cst);\n-      else if ((code == LT_EXPR && !flag) || (code == GT_EXPR && flag))\n-\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n-\t\t    \"with boolean expression is always false\", cst);\n-    }\n-}\n-\n-/* Warn if signed left shift overflows.  We don't warn\n-   about left-shifting 1 into the sign bit in C++14; cf.\n-   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3367.html#1457>\n-   LOC is a location of the shift; OP0 and OP1 are the operands.\n-   Return true if an overflow is detected, false otherwise.  */\n-\n-bool\n-maybe_warn_shift_overflow (location_t loc, tree op0, tree op1)\n-{\n-  if (TREE_CODE (op0) != INTEGER_CST\n-      || TREE_CODE (op1) != INTEGER_CST)\n-    return false;\n-\n-  tree type0 = TREE_TYPE (op0);\n-  unsigned int prec0 = TYPE_PRECISION (type0);\n-\n-  /* Left-hand operand must be signed.  */\n-  if (TYPE_UNSIGNED (type0))\n-    return false;\n-\n-  unsigned int min_prec = (wi::min_precision (op0, SIGNED)\n-\t\t\t   + TREE_INT_CST_LOW (op1));\n-  /* Handle the case of left-shifting 1 into the sign bit.\n-   * However, shifting 1 _out_ of the sign bit, as in\n-   * INT_MIN << 1, is considered an overflow.\n-   */\n-  if (!tree_int_cst_sign_bit(op0) && min_prec == prec0 + 1)\n-    {\n-      /* Never warn for C++14 onwards.  */\n-      if (cxx_dialect >= cxx14)\n-\treturn false;\n-      /* Otherwise only if -Wshift-overflow=2.  But return\n-\t true to signal an overflow for the sake of integer\n-\t constant expressions.  */\n-      if (warn_shift_overflow < 2)\n-\treturn true;\n-    }\n-\n-  bool overflowed = min_prec > prec0;\n-  if (overflowed && c_inhibit_evaluation_warnings == 0)\n-    warning_at (loc, OPT_Wshift_overflow_,\n-\t\t\"result of %qE requires %u bits to represent, \"\n-\t\t\"but %qT only has %u bits\",\n-\t\tbuild2_loc (loc, LSHIFT_EXPR, type0, op0, op1),\n-\t\tmin_prec, type0, prec0);\n-\n-  return overflowed;\n-}\n-\n /* The C and C++ parsers both use vectors to hold function arguments.\n    For efficiency, we keep a cache of unused vectors.  This is the\n    cache.  */\n@@ -12973,6 +10938,7 @@ pointer_to_zero_sized_aggr_p (tree t)\n    issues an error pointing to the location LOC.\n    Returns true when the expression has been diagnosed and false\n    otherwise.  */\n+\n bool\n reject_gcc_builtin (const_tree expr, location_t loc /* = UNKNOWN_LOCATION */)\n {\n@@ -13005,47 +10971,6 @@ reject_gcc_builtin (const_tree expr, location_t loc /* = UNKNOWN_LOCATION */)\n   return false;\n }\n \n-/* If we're creating an if-else-if condition chain, first see if we\n-   already have this COND in the CHAIN.  If so, warn and don't add COND\n-   into the vector, otherwise add the COND there.  LOC is the location\n-   of COND.  */\n-\n-void\n-warn_duplicated_cond_add_or_warn (location_t loc, tree cond, vec<tree> **chain)\n-{\n-  /* No chain has been created yet.  Do nothing.  */\n-  if (*chain == NULL)\n-    return;\n-\n-  if (TREE_SIDE_EFFECTS (cond))\n-    {\n-      /* Uh-oh!  This condition has a side-effect, thus invalidates\n-\t the whole chain.  */\n-      delete *chain;\n-      *chain = NULL;\n-      return;\n-    }\n-\n-  unsigned int ix;\n-  tree t;\n-  bool found = false;\n-  FOR_EACH_VEC_ELT (**chain, ix, t)\n-    if (operand_equal_p (cond, t, 0))\n-      {\n-\tif (warning_at (loc, OPT_Wduplicated_cond,\n-\t\t\t\"duplicated %<if%> condition\"))\n-\t  inform (EXPR_LOCATION (t), \"previously used here\");\n-\tfound = true;\n-\tbreak;\n-      }\n-\n-  if (!found\n-      && !CONSTANT_CLASS_P (cond)\n-      /* Don't infinitely grow the chain.  */\n-      && (*chain)->length () < 512)\n-    (*chain)->safe_push (cond);\n-}\n-\n /* Check if array size calculations overflow or if the array covers more\n    than half of the address space.  Return true if the size of the array\n    is valid, false otherwise.  TYPE is the type of the array and NAME is\n@@ -13117,58 +11042,4 @@ cb_get_suggestion (cpp_reader *, const char *goal,\n   return bm.get_best_meaningful_candidate ();\n }\n \n-/* Check and possibly warn if two declarations have contradictory\n-   attributes, such as always_inline vs. noinline.  */\n-\n-bool\n-diagnose_mismatched_attributes (tree olddecl, tree newdecl)\n-{\n-  bool warned = false;\n-\n-  tree a1 = lookup_attribute (\"optimize\", DECL_ATTRIBUTES (olddecl));\n-  tree a2 = lookup_attribute (\"optimize\", DECL_ATTRIBUTES (newdecl));\n-  /* An optimization attribute applied on a declaration after the\n-     definition is likely not what the user wanted.  */\n-  if (a2 != NULL_TREE\n-      && DECL_SAVED_TREE (olddecl) != NULL_TREE\n-      && (a1 == NULL_TREE || !attribute_list_equal (a1, a2)))\n-    warned |= warning (OPT_Wattributes,\n-\t\t       \"optimization attribute on %qD follows \"\n-\t\t       \"definition but the attribute doesn%'t match\",\n-\t\t       newdecl);\n-\n-  /* Diagnose inline __attribute__ ((noinline)) which is silly.  */\n-  if (DECL_DECLARED_INLINE_P (newdecl)\n-      && DECL_UNINLINABLE (olddecl)\n-      && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"inline declaration of %qD follows \"\n-\t\t       \"declaration with attribute noinline\", newdecl);\n-  else if (DECL_DECLARED_INLINE_P (olddecl)\n-\t   && DECL_UNINLINABLE (newdecl)\n-\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"noinline follows inline declaration \", newdecl);\n-  else if (lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"noinline\", \"always_inline\");\n-  else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"always_inline\", \"noinline\");\n-  else if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"hot\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"cold\", \"hot\");\n-  else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"cold\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"hot\", \"cold\");\n-  return warned;\n-}\n-\n #include \"gt-c-family-c-common.h\""}, {"sha": "8ef1d742eb77ed552b2ce24c487c290f38713fa0", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -838,22 +838,7 @@ extern tree c_alignof_expr (location_t, tree);\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error (rich_location *, enum tree_code, tree, tree);\n extern tree fix_string_type (tree);\n-extern void constant_expression_warning (tree);\n-extern void constant_expression_error (tree);\n-extern bool strict_aliasing_warning (tree, tree, tree);\n-extern void sizeof_pointer_memaccess_warning (location_t *, tree,\n-\t\t\t\t\t      vec<tree, va_gc> *, tree *,\n-\t\t\t\t\t      bool (*) (tree, tree));\n-extern void warnings_for_convert_and_check (location_t, tree, tree, tree);\n extern tree convert_and_check (location_t, tree, tree);\n-extern void overflow_warning (location_t, tree);\n-extern bool warn_if_unused_value (const_tree, location_t);\n-extern void warn_logical_operator (location_t, enum tree_code, tree,\n-\t\t\t\t   enum tree_code, tree, enum tree_code, tree);\n-extern void warn_logical_not_parentheses (location_t, enum tree_code, tree,\n-\t\t\t\t\t  tree);\n-extern void warn_tautological_cmp (location_t, enum tree_code, tree, tree);\n-extern void check_main_parameter_types (tree decl);\n extern bool c_determine_visibility (tree);\n extern bool vector_types_compatible_elements_p (tree, tree);\n extern void mark_valid_location_for_stdc_pragma (bool);\n@@ -869,7 +854,9 @@ extern bool keyword_is_decl_specifier (enum rid);\n extern unsigned max_align_t_align (void);\n extern bool cxx_fundamental_alignment_p (unsigned);\n extern bool pointer_to_zero_sized_aggr_p (tree);\n-extern bool diagnose_mismatched_attributes (tree, tree);\n+extern bool bool_promoted_to_int_p (tree);\n+extern tree fold_for_warn (tree);\n+extern tree c_common_get_narrower (tree, int *);\n \n #define c_sizeof(LOC, T)  c_sizeof_or_alignof_type (LOC, T, true, false, 1)\n #define c_alignof(LOC, T) c_sizeof_or_alignof_type (LOC, T, false, false, 1)\n@@ -923,9 +910,6 @@ extern void c_parse_file (void);\n \n extern void c_parse_final_cleanups (void);\n \n-extern void warn_for_omitted_condop (location_t, tree);\n-extern void warn_for_memset (location_t, tree, tree, int);\n-\n /* These macros provide convenient access to the various _STMT nodes.  */\n \n /* Nonzero if a given STATEMENT_LIST represents the outermost binding\n@@ -991,9 +975,6 @@ extern int case_compare (splay_tree_key, splay_tree_key);\n extern tree c_add_case_label (location_t, splay_tree, tree, tree, tree, tree,\n \t\t\t      bool *);\n \n-extern void c_do_switch_warnings (splay_tree, location_t, tree, tree, bool,\n-\t\t\t\t  bool);\n-\n extern tree build_function_call (location_t, tree, tree);\n \n extern tree build_function_call_vec (location_t, vec<location_t>, tree,\n@@ -1066,49 +1047,14 @@ extern void verify_sequence_points (tree);\n extern tree fold_offsetof_1 (tree, tree_code ctx = ERROR_MARK);\n extern tree fold_offsetof (tree);\n \n-/* Places where an lvalue, or modifiable lvalue, may be required.\n-   Used to select diagnostic messages in lvalue_error and\n-   readonly_error.  */\n-enum lvalue_use {\n-  lv_assign,\n-  lv_increment,\n-  lv_decrement,\n-  lv_addressof,\n-  lv_asm\n-};\n-\n-extern void readonly_error (location_t, tree, enum lvalue_use);\n-extern void lvalue_error (location_t, enum lvalue_use);\n-extern void invalid_indirection_error (location_t, tree, ref_operator);\n-\n extern int complete_array_type (tree *, tree, bool);\n \n extern tree builtin_type_for_size (int, bool);\n \n extern void c_common_mark_addressable_vec (tree);\n \n-extern void warn_array_subscript_with_type_char (location_t, tree);\n-extern void warn_about_parentheses (location_t,\n-\t\t\t\t    enum tree_code,\n-\t\t\t\t    enum tree_code, tree,\n-\t\t\t\t    enum tree_code, tree);\n-extern void warn_for_unused_label (tree label);\n-extern void warn_for_div_by_zero (location_t, tree divisor);\n-extern void warn_for_sign_compare (location_t,\n-\t\t\t\t   tree orig_op0, tree orig_op1,\n-\t\t\t\t   tree op0, tree op1,\n-\t\t\t\t   tree result_type,\n-\t\t\t\t   enum tree_code resultcode);\n-extern void do_warn_unused_parameter (tree);\n-extern void do_warn_double_promotion (tree, tree, tree, const char *, \n-\t\t\t\t      location_t);\n extern void set_underlying_type (tree);\n extern void record_types_used_by_current_var_decl (tree);\n-extern void record_locally_defined_typedef (tree);\n-extern void maybe_record_typedef_use (tree);\n-extern void maybe_warn_unused_local_typedefs (void);\n-extern void maybe_warn_bool_compare (location_t, enum tree_code, tree, tree);\n-extern bool maybe_warn_shift_overflow (location_t, tree, tree);\n extern vec<tree, va_gc> *make_tree_vector (void);\n extern void release_tree_vector (vec<tree, va_gc> *);\n extern vec<tree, va_gc> *make_tree_vector_single (tree);\n@@ -1529,12 +1475,69 @@ extern tree cilk_for_number_of_iterations (tree);\n extern bool check_no_cilk (tree, const char *, const char *,\n \t\t           location_t loc = UNKNOWN_LOCATION);\n extern bool reject_gcc_builtin (const_tree, location_t = UNKNOWN_LOCATION);\n-extern void warn_duplicated_cond_add_or_warn (location_t, tree, vec<tree> **);\n extern bool valid_array_size_p (location_t, tree, tree);\n \n extern bool cilk_ignorable_spawn_rhs_op (tree);\n extern bool cilk_recognize_spawn (tree, tree *);\n \n+/* In c-warn.c.  */\n+extern void constant_expression_warning (tree);\n+extern void constant_expression_error (tree);\n+extern void overflow_warning (location_t, tree);\n+extern void warn_logical_operator (location_t, enum tree_code, tree,\n+\t\t\t\t   enum tree_code, tree, enum tree_code, tree);\n+extern void warn_tautological_cmp (location_t, enum tree_code, tree, tree);\n+extern void warn_logical_not_parentheses (location_t, enum tree_code, tree,\n+\t\t\t\t\t  tree);\n+extern bool warn_if_unused_value (const_tree, location_t);\n+extern bool strict_aliasing_warning (tree, tree, tree);\n+extern void sizeof_pointer_memaccess_warning (location_t *, tree,\n+\t\t\t\t\t      vec<tree, va_gc> *, tree *,\n+\t\t\t\t\t      bool (*) (tree, tree));\n+extern void check_main_parameter_types (tree decl);\n+extern void warnings_for_convert_and_check (location_t, tree, tree, tree);\n+extern void c_do_switch_warnings (splay_tree, location_t, tree, tree, bool,\n+\t\t\t\t  bool);\n+extern void warn_for_omitted_condop (location_t, tree);\n+\n+/* Places where an lvalue, or modifiable lvalue, may be required.\n+   Used to select diagnostic messages in lvalue_error and\n+   readonly_error.  */\n+enum lvalue_use {\n+  lv_assign,\n+  lv_increment,\n+  lv_decrement,\n+  lv_addressof,\n+  lv_asm\n+};\n+\n+extern void lvalue_error (location_t, enum lvalue_use);\n+extern void invalid_indirection_error (location_t, tree, ref_operator);\n+extern void readonly_error (location_t, tree, enum lvalue_use);\n+extern void warn_array_subscript_with_type_char (location_t, tree);\n+extern void warn_about_parentheses (location_t,\n+\t\t\t\t    enum tree_code,\n+\t\t\t\t    enum tree_code, tree,\n+\t\t\t\t    enum tree_code, tree);\n+extern void warn_for_unused_label (tree label);\n+extern void warn_for_div_by_zero (location_t, tree divisor);\n+extern void warn_for_memset (location_t, tree, tree, int);\n+extern void warn_for_sign_compare (location_t,\n+\t\t\t\t   tree orig_op0, tree orig_op1,\n+\t\t\t\t   tree op0, tree op1,\n+\t\t\t\t   tree result_type,\n+\t\t\t\t   enum tree_code resultcode);\n+extern void do_warn_double_promotion (tree, tree, tree, const char *,\n+\t\t\t\t      location_t);\n+extern void do_warn_unused_parameter (tree);\n+extern void record_locally_defined_typedef (tree);\n+extern void maybe_record_typedef_use (tree);\n+extern void maybe_warn_unused_local_typedefs (void);\n+extern void maybe_warn_bool_compare (location_t, enum tree_code, tree, tree);\n+extern bool maybe_warn_shift_overflow (location_t, tree, tree);\n+extern void warn_duplicated_cond_add_or_warn (location_t, tree, vec<tree> **);\n+extern bool diagnose_mismatched_attributes (tree, tree);\n+\n #if CHECKING_P\n namespace selftest {\n   extern void c_format_c_tests (void);"}, {"sha": "cac5b36e4789cfcbd737ea8990e4ec14a5f772ec", "filename": "gcc/c-family/c-warn.c", "status": "added", "additions": 2160, "deletions": 0, "changes": 2160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038b5cc0d5f5e5df2be06844d9f53e9c08fc985a/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=038b5cc0d5f5e5df2be06844d9f53e9c08fc985a", "patch": "@@ -0,0 +1,2160 @@\n+/* Diagnostic routines shared by all languages that are variants of C.\n+   Copyright (C) 1992-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"function.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"tm_p.h\"\n+#include \"diagnostic.h\"\n+#include \"intl.h\"\n+\n+\n+/* Print a warning if a constant expression had overflow in folding.\n+   Invoke this function on every expression that the language\n+   requires to be a constant expression.\n+   Note the ANSI C standard says it is erroneous for a\n+   constant expression to overflow.  */\n+\n+void\n+constant_expression_warning (tree value)\n+{\n+  if (warn_overflow && pedantic\n+      && (TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n+\t  || TREE_CODE (value) == FIXED_CST\n+\t  || TREE_CODE (value) == VECTOR_CST\n+\t  || TREE_CODE (value) == COMPLEX_CST)\n+      && TREE_OVERFLOW (value))\n+    pedwarn (input_location, OPT_Woverflow, \"overflow in constant expression\");\n+}\n+\n+/* The same as above but print an unconditional error.  */\n+\n+void\n+constant_expression_error (tree value)\n+{\n+  if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n+       || TREE_CODE (value) == FIXED_CST\n+       || TREE_CODE (value) == VECTOR_CST\n+       || TREE_CODE (value) == COMPLEX_CST)\n+      && TREE_OVERFLOW (value))\n+    error (\"overflow in constant expression\");\n+}\n+\n+/* Print a warning if an expression had overflow in folding and its\n+   operands hadn't.\n+\n+   Invoke this function on every expression that\n+   (1) appears in the source code, and\n+   (2) is a constant expression that overflowed, and\n+   (3) is not already checked by convert_and_check;\n+   however, do not invoke this function on operands of explicit casts\n+   or when the expression is the result of an operator and any operand\n+   already overflowed.  */\n+\n+void\n+overflow_warning (location_t loc, tree value)\n+{\n+  if (c_inhibit_evaluation_warnings != 0)\n+    return;\n+\n+  switch (TREE_CODE (value))\n+    {\n+    case INTEGER_CST:\n+      warning_at (loc, OPT_Woverflow, \"integer overflow in expression\");\n+      break;\n+\n+    case REAL_CST:\n+      warning_at (loc, OPT_Woverflow,\n+\t\t  \"floating point overflow in expression\");\n+      break;\n+\n+    case FIXED_CST:\n+      warning_at (loc, OPT_Woverflow, \"fixed-point overflow in expression\");\n+      break;\n+\n+    case VECTOR_CST:\n+      warning_at (loc, OPT_Woverflow, \"vector overflow in expression\");\n+      break;\n+\n+    case COMPLEX_CST:\n+      if (TREE_CODE (TREE_REALPART (value)) == INTEGER_CST)\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"complex integer overflow in expression\");\n+      else if (TREE_CODE (TREE_REALPART (value)) == REAL_CST)\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"complex floating point overflow in expression\");\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Warn about uses of logical || / && operator in a context where it\n+   is likely that the bitwise equivalent was intended by the\n+   programmer.  We have seen an expression in which CODE is a binary\n+   operator used to combine expressions OP_LEFT and OP_RIGHT, which before folding\n+   had CODE_LEFT and CODE_RIGHT, into an expression of type TYPE.  */\n+\n+void\n+warn_logical_operator (location_t location, enum tree_code code, tree type,\n+\t\t       enum tree_code code_left, tree op_left,\n+\t\t       enum tree_code ARG_UNUSED (code_right), tree op_right)\n+{\n+  int or_op = (code == TRUTH_ORIF_EXPR || code == TRUTH_OR_EXPR);\n+  int in0_p, in1_p, in_p;\n+  tree low0, low1, low, high0, high1, high, lhs, rhs, tem;\n+  bool strict_overflow_p = false;\n+\n+  if (code != TRUTH_ANDIF_EXPR\n+      && code != TRUTH_AND_EXPR\n+      && code != TRUTH_ORIF_EXPR\n+      && code != TRUTH_OR_EXPR)\n+    return;\n+\n+  /* We don't want to warn if either operand comes from a macro\n+     expansion.  ??? This doesn't work with e.g. NEGATE_EXPR yet;\n+     see PR61534.  */\n+  if (from_macro_expansion_at (EXPR_LOCATION (op_left))\n+      || from_macro_expansion_at (EXPR_LOCATION (op_right)))\n+    return;\n+\n+  /* Warn if &&/|| are being used in a context where it is\n+     likely that the bitwise equivalent was intended by the\n+     programmer. That is, an expression such as op && MASK\n+     where op should not be any boolean expression, nor a\n+     constant, and mask seems to be a non-boolean integer constant.  */\n+  if (TREE_CODE (op_right) == CONST_DECL)\n+    /* An enumerator counts as a constant.  */\n+    op_right = DECL_INITIAL (op_right);\n+  if (!truth_value_p (code_left)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (op_left))\n+      && !CONSTANT_CLASS_P (op_left)\n+      && !TREE_NO_WARNING (op_left)\n+      && TREE_CODE (op_right) == INTEGER_CST\n+      && !integer_zerop (op_right)\n+      && !integer_onep (op_right))\n+    {\n+      if (or_op)\n+\twarning_at (location, OPT_Wlogical_op, \"logical %<or%>\"\n+\t\t    \" applied to non-boolean constant\");\n+      else\n+\twarning_at (location, OPT_Wlogical_op, \"logical %<and%>\"\n+\t\t    \" applied to non-boolean constant\");\n+      TREE_NO_WARNING (op_left) = true;\n+      return;\n+    }\n+\n+  /* We do not warn for constants because they are typical of macro\n+     expansions that test for features.  */\n+  if (CONSTANT_CLASS_P (fold_for_warn (op_left))\n+      || CONSTANT_CLASS_P (fold_for_warn (op_right)))\n+    return;\n+\n+  /* This warning only makes sense with logical operands.  */\n+  if (!(truth_value_p (TREE_CODE (op_left))\n+\t|| INTEGRAL_TYPE_P (TREE_TYPE (op_left)))\n+      || !(truth_value_p (TREE_CODE (op_right))\n+\t   || INTEGRAL_TYPE_P (TREE_TYPE (op_right))))\n+    return;\n+\n+  /* The range computations only work with scalars.  */\n+  if (VECTOR_TYPE_P (TREE_TYPE (op_left))\n+      || VECTOR_TYPE_P (TREE_TYPE (op_right)))\n+    return;\n+\n+  /* We first test whether either side separately is trivially true\n+     (with OR) or trivially false (with AND).  If so, do not warn.\n+     This is a common idiom for testing ranges of data types in\n+     portable code.  */\n+  lhs = make_range (op_left, &in0_p, &low0, &high0, &strict_overflow_p);\n+  if (!lhs)\n+    return;\n+  if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n+    lhs = C_MAYBE_CONST_EXPR_EXPR (lhs);\n+\n+  /* If this is an OR operation, invert both sides; now, the result\n+     should be always false to get a warning.  */\n+  if (or_op)\n+    in0_p = !in0_p;\n+\n+  tem = build_range_check (UNKNOWN_LOCATION, type, lhs, in0_p, low0, high0);\n+  if (tem && integer_zerop (tem))\n+    return;\n+\n+  rhs = make_range (op_right, &in1_p, &low1, &high1, &strict_overflow_p);\n+  if (!rhs)\n+    return;\n+  if (TREE_CODE (rhs) == C_MAYBE_CONST_EXPR)\n+    rhs = C_MAYBE_CONST_EXPR_EXPR (rhs);\n+\n+  /* If this is an OR operation, invert both sides; now, the result\n+     should be always false to get a warning.  */\n+  if (or_op)\n+    in1_p = !in1_p;\n+\n+  tem = build_range_check (UNKNOWN_LOCATION, type, rhs, in1_p, low1, high1);\n+  if (tem && integer_zerop (tem))\n+    return;\n+\n+  /* If both expressions have the same operand, if we can merge the\n+     ranges, ...  */\n+  if (operand_equal_p (lhs, rhs, 0)\n+      && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n+\t\t       in1_p, low1, high1))\n+    {\n+      tem = build_range_check (UNKNOWN_LOCATION, type, lhs, in_p, low, high);\n+      /* ... and if the range test is always false, then warn.  */\n+      if (tem && integer_zerop (tem))\n+\t{\n+\t  if (or_op)\n+\t    warning_at (location, OPT_Wlogical_op,\n+\t\t\t\"logical %<or%> of collectively exhaustive tests is \"\n+\t\t\t\"always true\");\n+\t  else\n+\t    warning_at (location, OPT_Wlogical_op,\n+\t\t\t\"logical %<and%> of mutually exclusive tests is \"\n+\t\t\t\"always false\");\n+\t}\n+      /* Or warn if the operands have exactly the same range, e.g.\n+\t A > 0 && A > 0.  */\n+      else if (tree_int_cst_equal (low0, low1)\n+\t       && tree_int_cst_equal (high0, high1))\n+\t{\n+\t  if (or_op)\n+\t    warning_at (location, OPT_Wlogical_op,\n+\t\t\t\"logical %<or%> of equal expressions\");\n+\t  else\n+\t    warning_at (location, OPT_Wlogical_op,\n+\t\t\t\"logical %<and%> of equal expressions\");\n+\t}\n+    }\n+}\n+\n+/* Helper function for warn_tautological_cmp.  Look for ARRAY_REFs\n+   with constant indices.  */\n+\n+static tree\n+find_array_ref_with_const_idx_r (tree *expr_p, int *walk_subtrees, void *data)\n+{\n+  tree expr = *expr_p;\n+\n+  if ((TREE_CODE (expr) == ARRAY_REF\n+       || TREE_CODE (expr) == ARRAY_RANGE_REF)\n+      && TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST)\n+    {\n+      *(bool *) data = true;\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Warn if a self-comparison always evaluates to true or false.  LOC\n+   is the location of the comparison with code CODE, LHS and RHS are\n+   operands of the comparison.  */\n+\n+void\n+warn_tautological_cmp (location_t loc, enum tree_code code, tree lhs, tree rhs)\n+{\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    return;\n+\n+  /* Don't warn for various macro expansions.  */\n+  if (from_macro_expansion_at (loc)\n+      || from_macro_expansion_at (EXPR_LOCATION (lhs))\n+      || from_macro_expansion_at (EXPR_LOCATION (rhs)))\n+    return;\n+\n+  /* We do not warn for constants because they are typical of macro\n+     expansions that test for features, sizeof, and similar.  */\n+  if (CONSTANT_CLASS_P (fold_for_warn (lhs))\n+      || CONSTANT_CLASS_P (fold_for_warn (rhs)))\n+    return;\n+\n+  /* Don't warn for e.g.\n+     HOST_WIDE_INT n;\n+     ...\n+     if (n == (long) n) ...\n+   */\n+  if ((CONVERT_EXPR_P (lhs) || TREE_CODE (lhs) == NON_LVALUE_EXPR)\n+      || (CONVERT_EXPR_P (rhs) || TREE_CODE (rhs) == NON_LVALUE_EXPR))\n+    return;\n+\n+  /* Don't warn if either LHS or RHS has an IEEE floating-point type.\n+     It could be a NaN, and NaN never compares equal to anything, even\n+     itself.  */\n+  if (FLOAT_TYPE_P (TREE_TYPE (lhs)) || FLOAT_TYPE_P (TREE_TYPE (rhs)))\n+    return;\n+\n+  if (operand_equal_p (lhs, rhs, 0))\n+    {\n+      /* Don't warn about array references with constant indices;\n+\t these are likely to come from a macro.  */\n+      bool found = false;\n+      walk_tree_without_duplicates (&lhs, find_array_ref_with_const_idx_r,\n+\t\t\t\t    &found);\n+      if (found)\n+\treturn;\n+      const bool always_true = (code == EQ_EXPR || code == LE_EXPR\n+\t\t\t\t|| code == GE_EXPR || code == UNLE_EXPR\n+\t\t\t\t|| code == UNGE_EXPR || code == UNEQ_EXPR);\n+      if (always_true)\n+\twarning_at (loc, OPT_Wtautological_compare,\n+\t\t    \"self-comparison always evaluates to true\");\n+      else\n+\twarning_at (loc, OPT_Wtautological_compare,\n+\t\t    \"self-comparison always evaluates to false\");\n+    }\n+}\n+\n+/* Return true iff EXPR only contains boolean operands, or comparisons.  */\n+\n+static bool\n+expr_has_boolean_operands_p (tree expr)\n+{\n+  STRIP_NOPS (expr);\n+\n+  if (CONVERT_EXPR_P (expr))\n+    return bool_promoted_to_int_p (expr);\n+  else if (UNARY_CLASS_P (expr))\n+    return expr_has_boolean_operands_p (TREE_OPERAND (expr, 0));\n+  else if (BINARY_CLASS_P (expr))\n+    return (expr_has_boolean_operands_p (TREE_OPERAND (expr, 0))\n+\t    && expr_has_boolean_operands_p (TREE_OPERAND (expr, 1)));\n+  else if (COMPARISON_CLASS_P (expr))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Warn about logical not used on the left hand side operand of a comparison.\n+   This function assumes that the LHS is inside of TRUTH_NOT_EXPR.\n+   Do not warn if RHS is of a boolean type, a logical operator, or\n+   a comparison.  */\n+\n+void\n+warn_logical_not_parentheses (location_t location, enum tree_code code,\n+\t\t\t      tree lhs, tree rhs)\n+{\n+  if (TREE_CODE_CLASS (code) != tcc_comparison\n+      || TREE_TYPE (rhs) == NULL_TREE\n+      || TREE_CODE (TREE_TYPE (rhs)) == BOOLEAN_TYPE\n+      || truth_value_p (TREE_CODE (rhs)))\n+    return;\n+\n+  /* Don't warn for expression like !x == ~(bool1 | bool2).  */\n+  if (expr_has_boolean_operands_p (rhs))\n+    return;\n+\n+  /* Don't warn for !x == 0 or !y != 0, those are equivalent to\n+     !(x == 0) or !(y != 0).  */\n+  if ((code == EQ_EXPR || code == NE_EXPR)\n+      && integer_zerop (rhs))\n+    return;\n+\n+  if (warning_at (location, OPT_Wlogical_not_parentheses,\n+\t\t  \"logical not is only applied to the left hand side of \"\n+\t\t  \"comparison\")\n+      && EXPR_HAS_LOCATION (lhs))\n+    {\n+      location_t lhs_loc = EXPR_LOCATION (lhs);\n+      rich_location richloc (line_table, lhs_loc);\n+      richloc.add_fixit_insert_before (lhs_loc, \"(\");\n+      richloc.add_fixit_insert_after (lhs_loc, \")\");\n+      inform_at_rich_loc (&richloc, \"add parentheses around left hand side \"\n+\t\t\t  \"expression to silence this warning\");\n+    }\n+}\n+\n+/* Warn if EXP contains any computations whose results are not used.\n+   Return true if a warning is printed; false otherwise.  LOCUS is the\n+   (potential) location of the expression.  */\n+\n+bool\n+warn_if_unused_value (const_tree exp, location_t locus)\n+{\n+ restart:\n+  if (TREE_USED (exp) || TREE_NO_WARNING (exp))\n+    return false;\n+\n+  /* Don't warn about void constructs.  This includes casting to void,\n+     void function calls, and statement expressions with a final cast\n+     to void.  */\n+  if (VOID_TYPE_P (TREE_TYPE (exp)))\n+    return false;\n+\n+  if (EXPR_HAS_LOCATION (exp))\n+    locus = EXPR_LOCATION (exp);\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case MODIFY_EXPR:\n+    case INIT_EXPR:\n+    case TARGET_EXPR:\n+    case CALL_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case WITH_CLEANUP_EXPR:\n+    case EXIT_EXPR:\n+    case VA_ARG_EXPR:\n+      return false;\n+\n+    case BIND_EXPR:\n+      /* For a binding, warn if no side effect within it.  */\n+      exp = BIND_EXPR_BODY (exp);\n+      goto restart;\n+\n+    case SAVE_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      exp = TREE_OPERAND (exp, 0);\n+      goto restart;\n+\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      /* In && or ||, warn if 2nd operand has no side effect.  */\n+      exp = TREE_OPERAND (exp, 1);\n+      goto restart;\n+\n+    case COMPOUND_EXPR:\n+      if (warn_if_unused_value (TREE_OPERAND (exp, 0), locus))\n+\treturn true;\n+      /* Let people do `(foo (), 0)' without a warning.  */\n+      if (TREE_CONSTANT (TREE_OPERAND (exp, 1)))\n+\treturn false;\n+      exp = TREE_OPERAND (exp, 1);\n+      goto restart;\n+\n+    case COND_EXPR:\n+      /* If this is an expression with side effects, don't warn; this\n+\t case commonly appears in macro expansions.  */\n+      if (TREE_SIDE_EFFECTS (exp))\n+\treturn false;\n+      goto warn;\n+\n+    case INDIRECT_REF:\n+      /* Don't warn about automatic dereferencing of references, since\n+\t the user cannot control it.  */\n+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n+\t{\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  goto restart;\n+\t}\n+      /* Fall through.  */\n+\n+    default:\n+      /* Referencing a volatile value is a side effect, so don't warn.  */\n+      if ((DECL_P (exp) || REFERENCE_CLASS_P (exp))\n+\t  && TREE_THIS_VOLATILE (exp))\n+\treturn false;\n+\n+      /* If this is an expression which has no operands, there is no value\n+\t to be unused.  There are no such language-independent codes,\n+\t but front ends may define such.  */\n+      if (EXPRESSION_CLASS_P (exp) && TREE_OPERAND_LENGTH (exp) == 0)\n+\treturn false;\n+\n+    warn:\n+      return warning_at (locus, OPT_Wunused_value, \"value computed is not used\");\n+    }\n+}\n+\n+/* Print a warning about casts that might indicate violation\n+   of strict aliasing rules if -Wstrict-aliasing is used and\n+   strict aliasing mode is in effect. OTYPE is the original\n+   TREE_TYPE of EXPR, and TYPE the type we're casting to. */\n+\n+bool\n+strict_aliasing_warning (tree otype, tree type, tree expr)\n+{\n+  /* Strip pointer conversion chains and get to the correct original type.  */\n+  STRIP_NOPS (expr);\n+  otype = TREE_TYPE (expr);\n+\n+  if (!(flag_strict_aliasing\n+\t&& POINTER_TYPE_P (type)\n+\t&& POINTER_TYPE_P (otype)\n+\t&& !VOID_TYPE_P (TREE_TYPE (type)))\n+      /* If the type we are casting to is a ref-all pointer\n+\t dereferencing it is always valid.  */\n+      || TYPE_REF_CAN_ALIAS_ALL (type))\n+    return false;\n+\n+  if ((warn_strict_aliasing > 1) && TREE_CODE (expr) == ADDR_EXPR\n+      && (DECL_P (TREE_OPERAND (expr, 0))\n+\t  || handled_component_p (TREE_OPERAND (expr, 0))))\n+    {\n+      /* Casting the address of an object to non void pointer. Warn\n+\t if the cast breaks type based aliasing.  */\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (type)) && warn_strict_aliasing == 2)\n+\t{\n+\t  warning (OPT_Wstrict_aliasing, \"type-punning to incomplete type \"\n+\t\t   \"might break strict-aliasing rules\");\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  /* warn_strict_aliasing >= 3.   This includes the default (3).\n+\t     Only warn if the cast is dereferenced immediately.  */\n+\t  alias_set_type set1\n+\t    = get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\t  alias_set_type set2 = get_alias_set (TREE_TYPE (type));\n+\n+\t  if (set1 != set2 && set2 != 0\n+\t      && (set1 == 0\n+\t\t  || (!alias_set_subset_of (set2, set1)\n+\t\t      && !alias_sets_conflict_p (set1, set2))))\n+\t    {\n+\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t       \"pointer will break strict-aliasing rules\");\n+\t      return true;\n+\t    }\n+\t  else if (warn_strict_aliasing == 2\n+\t\t   && !alias_sets_must_conflict_p (set1, set2))\n+\t    {\n+\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t       \"pointer might break strict-aliasing rules\");\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  else if ((warn_strict_aliasing == 1) && !VOID_TYPE_P (TREE_TYPE (otype)))\n+    {\n+      /* At this level, warn for any conversions, even if an address is\n+\t not taken in the same statement.  This will likely produce many\n+\t false positives, but could be useful to pinpoint problems that\n+\t are not revealed at higher levels.  */\n+      alias_set_type set1 = get_alias_set (TREE_TYPE (otype));\n+      alias_set_type set2 = get_alias_set (TREE_TYPE (type));\n+      if (!COMPLETE_TYPE_P (type)\n+\t  || !alias_sets_must_conflict_p (set1, set2))\n+\t{\n+\t  warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t   \"pointer might break strict-aliasing rules\");\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Warn about memset (&a, 0, sizeof (&a)); and similar mistakes with\n+   sizeof as last operand of certain builtins.  */\n+\n+void\n+sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n+\t\t\t\t  vec<tree, va_gc> *params, tree *sizeof_arg,\n+\t\t\t\t  bool (*comp_types) (tree, tree))\n+{\n+  tree type, dest = NULL_TREE, src = NULL_TREE, tem;\n+  bool strop = false, cmp = false;\n+  unsigned int idx = ~0;\n+  location_t loc;\n+\n+  if (TREE_CODE (callee) != FUNCTION_DECL\n+      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n+      || vec_safe_length (params) <= 1)\n+    return;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCASECMP:\n+      cmp = true;\n+      /* FALLTHRU */\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+      strop = true;\n+      /* FALLTHRU */\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+      if (params->length () < 3)\n+\treturn;\n+      src = (*params)[1];\n+      dest = (*params)[0];\n+      idx = 2;\n+      break;\n+    case BUILT_IN_BCOPY:\n+      if (params->length () < 3)\n+\treturn;\n+      src = (*params)[0];\n+      dest = (*params)[1];\n+      idx = 2;\n+      break;\n+    case BUILT_IN_MEMCMP:\n+    case BUILT_IN_BCMP:\n+      if (params->length () < 3)\n+\treturn;\n+      src = (*params)[1];\n+      dest = (*params)[0];\n+      idx = 2;\n+      cmp = true;\n+      break;\n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n+      if (params->length () < 3)\n+\treturn;\n+      dest = (*params)[0];\n+      idx = 2;\n+      break;\n+    case BUILT_IN_BZERO:\n+      dest = (*params)[0];\n+      idx = 1;\n+      break;\n+    case BUILT_IN_STRNDUP:\n+      src = (*params)[0];\n+      strop = true;\n+      idx = 1;\n+      break;\n+    case BUILT_IN_MEMCHR:\n+      if (params->length () < 3)\n+\treturn;\n+      src = (*params)[0];\n+      idx = 2;\n+      break;\n+    case BUILT_IN_SNPRINTF:\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      dest = (*params)[0];\n+      idx = 1;\n+      strop = true;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (idx >= 3)\n+    return;\n+\n+  if (sizeof_arg[idx] == NULL || sizeof_arg[idx] == error_mark_node)\n+    return;\n+\n+  type = TYPE_P (sizeof_arg[idx])\n+\t ? sizeof_arg[idx] : TREE_TYPE (sizeof_arg[idx]);\n+  if (!POINTER_TYPE_P (type))\n+    return;\n+\n+  if (dest\n+      && (tem = tree_strip_nop_conversions (dest))\n+      && POINTER_TYPE_P (TREE_TYPE (tem))\n+      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n+    return;\n+\n+  if (src\n+      && (tem = tree_strip_nop_conversions (src))\n+      && POINTER_TYPE_P (TREE_TYPE (tem))\n+      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n+    return;\n+\n+  loc = sizeof_arg_loc[idx];\n+\n+  if (dest && !cmp)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (dest), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (dest))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (dest), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the destination; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n+\t\t      TREE_TYPE (TREE_TYPE (dest)));\n+\t  return;\n+\t}\n+    }\n+\n+  if (src && !cmp)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (src), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (src))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (src), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n+\t\t      TREE_TYPE (TREE_TYPE (src)));\n+\t  return;\n+\t}\n+    }\n+\n+  if (dest)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (dest), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (dest))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (dest), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the first source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n+\t\t      TREE_TYPE (TREE_TYPE (dest)));\n+\t  return;\n+\t}\n+    }\n+\n+  if (src)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (src), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (src))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (src), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the second source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n+\t\t      TREE_TYPE (TREE_TYPE (src)));\n+\t  return;\n+\t}\n+    }\n+\n+}\n+\n+/* Warn for unlikely, improbable, or stupid DECL declarations\n+   of `main'.  */\n+\n+void\n+check_main_parameter_types (tree decl)\n+{\n+  function_args_iterator iter;\n+  tree type;\n+  int argct = 0;\n+\n+  FOREACH_FUNCTION_ARGS (TREE_TYPE (decl), type, iter)\n+    {\n+      /* XXX void_type_node belies the abstraction.  */\n+      if (type == void_type_node || type == error_mark_node)\n+\tbreak;\n+\n+      tree t = type;\n+      if (TYPE_ATOMIC (t))\n+\t  pedwarn (input_location, OPT_Wmain,\n+\t\t   \"%<_Atomic%>-qualified parameter type %qT of %q+D\",\n+\t\t   type, decl);\n+      while (POINTER_TYPE_P (t))\n+\t{\n+\t  t = TREE_TYPE (t);\n+\t  if (TYPE_ATOMIC (t))\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"%<_Atomic%>-qualified parameter type %qT of %q+D\",\n+\t\t     type, decl);\n+\t}\n+\n+      ++argct;\n+      switch (argct)\n+\t{\n+\tcase 1:\n+\t  if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"first argument of %q+D should be %<int%>\", decl);\n+\t  break;\n+\n+\tcase 2:\n+\t  if (TREE_CODE (type) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n+\t\t  != char_type_node))\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"second argument of %q+D should be %<char **%>\", decl);\n+\t  break;\n+\n+\tcase 3:\n+\t  if (TREE_CODE (type) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n+\t\t  != char_type_node))\n+\t    pedwarn (input_location, OPT_Wmain,\n+\t\t     \"third argument of %q+D should probably be \"\n+\t\t     \"%<char **%>\", decl);\n+\t  break;\n+\t}\n+    }\n+\n+  /* It is intentional that this message does not mention the third\n+    argument because it's only mentioned in an appendix of the\n+    standard.  */\n+  if (argct > 0 && (argct < 2 || argct > 3))\n+    pedwarn (input_location, OPT_Wmain,\n+\t     \"%q+D takes only zero or two arguments\", decl);\n+\n+  if (stdarg_p (TREE_TYPE (decl)))\n+    pedwarn (input_location, OPT_Wmain,\n+\t     \"%q+D declared as variadic function\", decl);\n+}\n+\n+/* Warns if the conversion of EXPR to TYPE may alter a value.\n+   This is a helper function for warnings_for_convert_and_check.  */\n+\n+static void\n+conversion_warning (location_t loc, tree type, tree expr)\n+{\n+  tree expr_type = TREE_TYPE (expr);\n+  enum conversion_safety conversion_kind;\n+\n+  if (!warn_conversion && !warn_sign_conversion && !warn_float_conversion)\n+    return;\n+\n+  /* This may happen, because for LHS op= RHS we preevaluate\n+     RHS and create C_MAYBE_CONST_EXPR <SAVE_EXPR <RHS>>, which\n+     means we could no longer see the code of the EXPR.  */\n+  if (TREE_CODE (expr) == C_MAYBE_CONST_EXPR)\n+    expr = C_MAYBE_CONST_EXPR_EXPR (expr);\n+  if (TREE_CODE (expr) == SAVE_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case TRUTH_NOT_EXPR:\n+      /* Conversion from boolean to a signed:1 bit-field (which only\n+\t can hold the values 0 and -1) doesn't lose information - but\n+\t it does change the value.  */\n+      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT from boolean expression\", type);\n+      return;\n+\n+    case REAL_CST:\n+    case INTEGER_CST:\n+    case COMPLEX_CST:\n+      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n+      if (conversion_kind == UNSAFE_REAL)\n+\twarning_at (loc, OPT_Wfloat_conversion,\n+\t\t    \"conversion to %qT alters %qT constant value\",\n+\t\t    type, expr_type);\n+      else if (conversion_kind)\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT alters %qT constant value\",\n+\t\t    type, expr_type);\n+      return;\n+\n+    case COND_EXPR:\n+      {\n+\t/* In case of COND_EXPR, we do not care about the type of\n+\t   COND_EXPR, only about the conversion of each operand.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\n+\tconversion_warning (loc, type, op1);\n+\tconversion_warning (loc, type, op2);\n+\treturn;\n+      }\n+\n+    default: /* 'expr' is not a constant.  */\n+      conversion_kind = unsafe_conversion_p (loc, type, expr, true);\n+      if (conversion_kind == UNSAFE_REAL)\n+\twarning_at (loc, OPT_Wfloat_conversion,\n+\t\t    \"conversion to %qT from %qT may alter its value\",\n+\t\t    type, expr_type);\n+      else if (conversion_kind == UNSAFE_IMAGINARY)\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT from %qT discards imaginary component\",\n+\t\t    type, expr_type);\n+      else if (conversion_kind)\n+\twarning_at (loc, OPT_Wconversion,\n+\t\t    \"conversion to %qT from %qT may alter its value\",\n+\t\t    type, expr_type);\n+    }\n+}\n+\n+/* Produce warnings after a conversion. RESULT is the result of\n+   converting EXPR to TYPE.  This is a helper function for\n+   convert_and_check and cp_convert_and_check.  */\n+\n+void\n+warnings_for_convert_and_check (location_t loc, tree type, tree expr,\n+\t\t\t\ttree result)\n+{\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  if (TREE_CODE (expr) == INTEGER_CST\n+      && (TREE_CODE (type) == INTEGER_TYPE\n+\t  || TREE_CODE (type) == ENUMERAL_TYPE)\n+      && !int_fits_type_p (expr, type))\n+    {\n+      /* Do not diagnose overflow in a constant expression merely\n+\t because a conversion overflowed.  */\n+      if (TREE_OVERFLOW (result))\n+\tTREE_OVERFLOW (result) = TREE_OVERFLOW (expr);\n+\n+      if (TYPE_UNSIGNED (type))\n+\t{\n+\t  /* This detects cases like converting -129 or 256 to\n+\t     unsigned char.  */\n+\t  if (!int_fits_type_p (expr, c_common_signed_type (type)))\n+\t    warning_at (loc, OPT_Woverflow,\n+\t\t\t\"large integer implicitly truncated to unsigned type\");\n+\t  else\n+\t    conversion_warning (loc, type, expr);\n+\t}\n+      else if (!int_fits_type_p (expr, c_common_unsigned_type (type)))\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t \"overflow in implicit constant conversion\");\n+      /* No warning for converting 0x80000000 to int.  */\n+      else if (pedantic\n+\t       && (TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE\n+\t\t   || TYPE_PRECISION (TREE_TYPE (expr))\n+\t\t   != TYPE_PRECISION (type)))\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"overflow in implicit constant conversion\");\n+\n+      else\n+\tconversion_warning (loc, type, expr);\n+    }\n+  else if ((TREE_CODE (result) == INTEGER_CST\n+\t    || TREE_CODE (result) == FIXED_CST) && TREE_OVERFLOW (result))\n+    warning_at (loc, OPT_Woverflow,\n+\t\t\"overflow in implicit constant conversion\");\n+  else\n+    conversion_warning (loc, type, expr);\n+}\n+\n+/* Subroutines of c_do_switch_warnings, called via splay_tree_foreach.\n+   Used to verify that case values match up with enumerator values.  */\n+\n+static void\n+match_case_to_enum_1 (tree key, tree type, tree label)\n+{\n+  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+\n+  if (tree_fits_uhwi_p (key))\n+    print_dec (key, buf, UNSIGNED);\n+  else if (tree_fits_shwi_p (key))\n+    print_dec (key, buf, SIGNED);\n+  else\n+    print_hex (key, buf);\n+\n+  if (TYPE_NAME (type) == 0)\n+    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n+\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n+\t\t\"case value %qs not in enumerated type\",\n+\t\tbuf);\n+  else\n+    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n+\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n+\t\t\"case value %qs not in enumerated type %qT\",\n+\t\tbuf, type);\n+}\n+\n+/* Subroutine of c_do_switch_warnings, called via splay_tree_foreach.\n+   Used to verify that case values match up with enumerator values.  */\n+\n+static int\n+match_case_to_enum (splay_tree_node node, void *data)\n+{\n+  tree label = (tree) node->value;\n+  tree type = (tree) data;\n+\n+  /* Skip default case.  */\n+  if (!CASE_LOW (label))\n+    return 0;\n+\n+  /* If CASE_LOW_SEEN is not set, that means CASE_LOW did not appear\n+     when we did our enum->case scan.  Reset our scratch bit after.  */\n+  if (!CASE_LOW_SEEN (label))\n+    match_case_to_enum_1 (CASE_LOW (label), type, label);\n+  else\n+    CASE_LOW_SEEN (label) = 0;\n+\n+  /* If CASE_HIGH is non-null, we have a range.  If CASE_HIGH_SEEN is\n+     not set, that means that CASE_HIGH did not appear when we did our\n+     enum->case scan.  Reset our scratch bit after.  */\n+  if (CASE_HIGH (label))\n+    {\n+      if (!CASE_HIGH_SEEN (label))\n+\tmatch_case_to_enum_1 (CASE_HIGH (label), type, label);\n+      else\n+\tCASE_HIGH_SEEN (label) = 0;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Handle -Wswitch*.  Called from the front end after parsing the\n+   switch construct.  */\n+/* ??? Should probably be somewhere generic, since other languages\n+   besides C and C++ would want this.  At the moment, however, C/C++\n+   are the only tree-ssa languages that support enumerations at all,\n+   so the point is moot.  */\n+\n+void\n+c_do_switch_warnings (splay_tree cases, location_t switch_location,\n+\t\t      tree type, tree cond, bool bool_cond_p,\n+\t\t      bool outside_range_p)\n+{\n+  splay_tree_node default_node;\n+  splay_tree_node node;\n+  tree chain;\n+\n+  if (!warn_switch && !warn_switch_enum && !warn_switch_default\n+      && !warn_switch_bool)\n+    return;\n+\n+  default_node = splay_tree_lookup (cases, (splay_tree_key) NULL);\n+  if (!default_node)\n+    warning_at (switch_location, OPT_Wswitch_default,\n+\t\t\"switch missing default case\");\n+\n+  /* There are certain cases where -Wswitch-bool warnings aren't\n+     desirable, such as\n+     switch (boolean)\n+       {\n+       case true: ...\n+       case false: ...\n+       }\n+     so be careful here.  */\n+  if (warn_switch_bool && bool_cond_p)\n+    {\n+      splay_tree_node min_node;\n+      /* If there's a default node, it's also the value with the minimal\n+\t key.  So look at the penultimate key (if any).  */\n+      if (default_node)\n+\tmin_node = splay_tree_successor (cases, (splay_tree_key) NULL);\n+      else\n+\tmin_node = splay_tree_min (cases);\n+      tree min = min_node ? (tree) min_node->key : NULL_TREE;\n+\n+      splay_tree_node max_node = splay_tree_max (cases);\n+      /* This might be a case range, so look at the value with the\n+\t maximal key and then check CASE_HIGH.  */\n+      tree max = max_node ? (tree) max_node->value : NULL_TREE;\n+      if (max)\n+\tmax = CASE_HIGH (max) ? CASE_HIGH (max) : CASE_LOW (max);\n+\n+      /* If there's a case value > 1 or < 0, that is outside bool\n+\t range, warn.  */\n+      if (outside_range_p\n+\t  || (max && wi::gts_p (max, 1))\n+\t  || (min && wi::lts_p (min, 0))\n+\t  /* And handle the\n+\t     switch (boolean)\n+\t       {\n+\t       case true: ...\n+\t       case false: ...\n+\t       default: ...\n+\t       }\n+\t     case, where we want to warn.  */\n+\t  || (default_node\n+\t      && max && wi::eq_p (max, 1)\n+\t      && min && wi::eq_p (min, 0)))\n+\twarning_at (switch_location, OPT_Wswitch_bool,\n+\t\t    \"switch condition has boolean value\");\n+    }\n+\n+  /* From here on, we only care about enumerated types.  */\n+  if (!type || TREE_CODE (type) != ENUMERAL_TYPE)\n+    return;\n+\n+  /* From here on, we only care about -Wswitch and -Wswitch-enum.  */\n+  if (!warn_switch_enum && !warn_switch)\n+    return;\n+\n+  /* Check the cases.  Warn about case values which are not members of\n+     the enumerated type.  For -Wswitch-enum, or for -Wswitch when\n+     there is no default case, check that exactly all enumeration\n+     literals are covered by the cases.  */\n+\n+  /* Clearing COND if it is not an integer constant simplifies\n+     the tests inside the loop below.  */\n+  if (TREE_CODE (cond) != INTEGER_CST)\n+    cond = NULL_TREE;\n+\n+  /* The time complexity here is O(N*lg(N)) worst case, but for the\n+      common case of monotonically increasing enumerators, it is\n+      O(N), since the nature of the splay tree will keep the next\n+      element adjacent to the root at all times.  */\n+\n+  for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n+    {\n+      tree value = TREE_VALUE (chain);\n+      if (TREE_CODE (value) == CONST_DECL)\n+\tvalue = DECL_INITIAL (value);\n+      node = splay_tree_lookup (cases, (splay_tree_key) value);\n+      if (node)\n+\t{\n+\t  /* Mark the CASE_LOW part of the case entry as seen.  */\n+\t  tree label = (tree) node->value;\n+\t  CASE_LOW_SEEN (label) = 1;\n+\t  continue;\n+\t}\n+\n+      /* Even though there wasn't an exact match, there might be a\n+\t case range which includes the enumerator's value.  */\n+      node = splay_tree_predecessor (cases, (splay_tree_key) value);\n+      if (node && CASE_HIGH ((tree) node->value))\n+\t{\n+\t  tree label = (tree) node->value;\n+\t  int cmp = tree_int_cst_compare (CASE_HIGH (label), value);\n+\t  if (cmp >= 0)\n+\t    {\n+\t      /* If we match the upper bound exactly, mark the CASE_HIGH\n+\t\t part of the case entry as seen.  */\n+\t      if (cmp == 0)\n+\t\tCASE_HIGH_SEEN (label) = 1;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* We've now determined that this enumerated literal isn't\n+\t handled by the case labels of the switch statement.  */\n+\n+      /* If the switch expression is a constant, we only really care\n+\t about whether that constant is handled by the switch.  */\n+      if (cond && tree_int_cst_compare (cond, value))\n+\tcontinue;\n+\n+      /* If there is a default_node, the only relevant option is\n+\t Wswitch-enum.  Otherwise, if both are enabled then we prefer\n+\t to warn using -Wswitch because -Wswitch is enabled by -Wall\n+\t while -Wswitch-enum is explicit.  */\n+      warning_at (switch_location,\n+\t\t  (default_node || !warn_switch\n+\t\t   ? OPT_Wswitch_enum\n+\t\t   : OPT_Wswitch),\n+\t\t  \"enumeration value %qE not handled in switch\",\n+\t\t  TREE_PURPOSE (chain));\n+    }\n+\n+  /* Warn if there are case expressions that don't correspond to\n+     enumerators.  This can occur since C and C++ don't enforce\n+     type-checking of assignments to enumeration variables.\n+\n+     The time complexity here is now always O(N) worst case, since\n+     we should have marked both the lower bound and upper bound of\n+     every disjoint case label, with CASE_LOW_SEEN and CASE_HIGH_SEEN\n+     above.  This scan also resets those fields.  */\n+\n+  splay_tree_foreach (cases, match_case_to_enum, type);\n+}\n+\n+/* Warn for A ?: C expressions (with B omitted) where A is a boolean\n+   expression, because B will always be true. */\n+\n+void\n+warn_for_omitted_condop (location_t location, tree cond)\n+{\n+  /* In C++ template declarations it can happen that the type is dependent\n+     and not yet known, thus TREE_TYPE (cond) == NULL_TREE.  */\n+  if (truth_value_p (TREE_CODE (cond))\n+      || (TREE_TYPE (cond) != NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (cond)) == BOOLEAN_TYPE))\n+      warning_at (location, OPT_Wparentheses,\n+\t\t\"the omitted middle operand in ?: will always be %<true%>, \"\n+\t\t\"suggest explicit middle operand\");\n+}\n+\n+/* Give an error for storing into ARG, which is 'const'.  USE indicates\n+   how ARG was being used.  */\n+\n+void\n+readonly_error (location_t loc, tree arg, enum lvalue_use use)\n+{\n+  gcc_assert (use == lv_assign || use == lv_increment || use == lv_decrement\n+\t      || use == lv_asm);\n+  /* Using this macro rather than (for example) arrays of messages\n+     ensures that all the format strings are checked at compile\n+     time.  */\n+#define READONLY_MSG(A, I, D, AS) (use == lv_assign ? (A)\t\t\\\n+\t\t\t\t   : (use == lv_increment ? (I)\t\t\\\n+\t\t\t\t   : (use == lv_decrement ? (D) : (AS))))\n+  if (TREE_CODE (arg) == COMPONENT_REF)\n+    {\n+      if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n+\terror_at (loc, READONLY_MSG (G_(\"assignment of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"increment of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"decrement of member \"\n+\t\t\t\t\t\"%qD in read-only object\"),\n+\t\t\t\t     G_(\"member %qD in read-only object \"\n+\t\t\t\t\t\"used as %<asm%> output\")),\n+\t\t  TREE_OPERAND (arg, 1));\n+      else\n+\terror_at (loc, READONLY_MSG (G_(\"assignment of read-only member %qD\"),\n+\t\t\t\t     G_(\"increment of read-only member %qD\"),\n+\t\t\t\t     G_(\"decrement of read-only member %qD\"),\n+\t\t\t\t     G_(\"read-only member %qD used as %<asm%> output\")),\n+\t\t  TREE_OPERAND (arg, 1));\n+    }\n+  else if (VAR_P (arg))\n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only variable %qD\"),\n+\t\t\t\t G_(\"increment of read-only variable %qD\"),\n+\t\t\t\t G_(\"decrement of read-only variable %qD\"),\n+\t\t\t\t G_(\"read-only variable %qD used as %<asm%> output\")),\n+\t      arg);\n+  else if (TREE_CODE (arg) == PARM_DECL)\n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only parameter %qD\"),\n+\t\t\t\t G_(\"increment of read-only parameter %qD\"),\n+\t\t\t\t G_(\"decrement of read-only parameter %qD\"),\n+\t\t\t\t G_(\"read-only parameter %qD use as %<asm%> output\")),\n+\t      arg);\n+  else if (TREE_CODE (arg) == RESULT_DECL)\n+    {\n+      gcc_assert (c_dialect_cxx ());\n+      error_at (loc, READONLY_MSG (G_(\"assignment of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"increment of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"decrement of \"\n+\t\t\t\t      \"read-only named return value %qD\"),\n+\t\t\t\t   G_(\"read-only named return value %qD \"\n+\t\t\t\t      \"used as %<asm%>output\")),\n+\t\targ);\n+    }\n+  else if (TREE_CODE (arg) == FUNCTION_DECL)\n+    error_at (loc, READONLY_MSG (G_(\"assignment of function %qD\"),\n+\t\t\t\t G_(\"increment of function %qD\"),\n+\t\t\t\t G_(\"decrement of function %qD\"),\n+\t\t\t\t G_(\"function %qD used as %<asm%> output\")),\n+\t      arg);\n+  else\n+    error_at (loc, READONLY_MSG (G_(\"assignment of read-only location %qE\"),\n+\t\t\t\t G_(\"increment of read-only location %qE\"),\n+\t\t\t\t G_(\"decrement of read-only location %qE\"),\n+\t\t\t\t G_(\"read-only location %qE used as %<asm%> output\")),\n+\t      arg);\n+}\n+\n+/* Print an error message for an invalid lvalue.  USE says\n+   how the lvalue is being used and so selects the error message.  LOC\n+   is the location for the error.  */\n+\n+void\n+lvalue_error (location_t loc, enum lvalue_use use)\n+{\n+  switch (use)\n+    {\n+    case lv_assign:\n+      error_at (loc, \"lvalue required as left operand of assignment\");\n+      break;\n+    case lv_increment:\n+      error_at (loc, \"lvalue required as increment operand\");\n+      break;\n+    case lv_decrement:\n+      error_at (loc, \"lvalue required as decrement operand\");\n+      break;\n+    case lv_addressof:\n+      error_at (loc, \"lvalue required as unary %<&%> operand\");\n+      break;\n+    case lv_asm:\n+      error_at (loc, \"lvalue required in asm statement\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Print an error message for an invalid indirection of type TYPE.\n+   ERRSTRING is the name of the operator for the indirection.  */\n+\n+void\n+invalid_indirection_error (location_t loc, tree type, ref_operator errstring)\n+{\n+  switch (errstring)\n+    {\n+    case RO_NULL:\n+      gcc_assert (c_dialect_cxx ());\n+      error_at (loc, \"invalid type argument (have %qT)\", type);\n+      break;\n+    case RO_ARRAY_INDEXING:\n+      error_at (loc,\n+\t\t\"invalid type argument of array indexing (have %qT)\",\n+\t\ttype);\n+      break;\n+    case RO_UNARY_STAR:\n+      error_at (loc,\n+\t\t\"invalid type argument of unary %<*%> (have %qT)\",\n+\t\ttype);\n+      break;\n+    case RO_ARROW:\n+      error_at (loc,\n+\t\t\"invalid type argument of %<->%> (have %qT)\",\n+\t\ttype);\n+      break;\n+    case RO_ARROW_STAR:\n+      error_at (loc,\n+\t\t\"invalid type argument of %<->*%> (have %qT)\",\n+\t\ttype);\n+      break;\n+    case RO_IMPLICIT_CONVERSION:\n+      error_at (loc,\n+\t\t\"invalid type argument of implicit conversion (have %qT)\",\n+\t\ttype);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Subscripting with type char is likely to lose on a machine where\n+   chars are signed.  So warn on any machine, but optionally.  Don't\n+   warn for unsigned char since that type is safe.  Don't warn for\n+   signed char because anyone who uses that must have done so\n+   deliberately. Furthermore, we reduce the false positive load by\n+   warning only for non-constant value of type char.  */\n+\n+void\n+warn_array_subscript_with_type_char (location_t loc, tree index)\n+{\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node\n+      && TREE_CODE (index) != INTEGER_CST)\n+    warning_at (loc, OPT_Wchar_subscripts,\n+\t\t\"array subscript has type %<char%>\");\n+}\n+\n+/* Implement -Wparentheses for the unexpected C precedence rules, to\n+   cover cases like x + y << z which readers are likely to\n+   misinterpret.  We have seen an expression in which CODE is a binary\n+   operator used to combine expressions ARG_LEFT and ARG_RIGHT, which\n+   before folding had CODE_LEFT and CODE_RIGHT.  CODE_LEFT and\n+   CODE_RIGHT may be ERROR_MARK, which means that that side of the\n+   expression was not formed using a binary or unary operator, or it\n+   was enclosed in parentheses.  */\n+\n+void\n+warn_about_parentheses (location_t loc, enum tree_code code,\n+\t\t\tenum tree_code code_left, tree arg_left,\n+\t\t\tenum tree_code code_right, tree arg_right)\n+{\n+  if (!warn_parentheses)\n+    return;\n+\n+  /* This macro tests that the expression ARG with original tree code\n+     CODE appears to be a boolean expression. or the result of folding a\n+     boolean expression.  */\n+#define APPEARS_TO_BE_BOOLEAN_EXPR_P(CODE, ARG)\t\t\t\t    \\\n+\t(truth_value_p (TREE_CODE (ARG))\t\t\t\t    \\\n+\t || TREE_CODE (TREE_TYPE (ARG)) == BOOLEAN_TYPE\t\t\t    \\\n+\t /* Folding may create 0 or 1 integers from other expressions.  */  \\\n+\t || ((CODE) != INTEGER_CST\t\t\t\t\t    \\\n+\t     && (integer_onep (ARG) || integer_zerop (ARG))))\n+\n+  switch (code)\n+    {\n+    case LSHIFT_EXPR:\n+      if (code_left == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<+%> inside %<<<%>\");\n+      else if (code_right == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<+%> inside %<<<%>\");\n+      else if (code_left == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<-%> inside %<<<%>\");\n+      else if (code_right == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<-%> inside %<<<%>\");\n+      return;\n+\n+    case RSHIFT_EXPR:\n+      if (code_left == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<+%> inside %<>>%>\");\n+      else if (code_right == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<+%> inside %<>>%>\");\n+      else if (code_left == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<-%> inside %<>>%>\");\n+      else if (code_right == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<-%> inside %<>>%>\");\n+      return;\n+\n+    case TRUTH_ORIF_EXPR:\n+      if (code_left == TRUTH_ANDIF_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<&&%> within %<||%>\");\n+      else if (code_right == TRUTH_ANDIF_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around %<&&%> within %<||%>\");\n+      return;\n+\n+    case BIT_IOR_EXPR:\n+      if (code_left == BIT_AND_EXPR || code_left == BIT_XOR_EXPR\n+\t  || code_left == PLUS_EXPR || code_left == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around arithmetic in operand of %<|%>\");\n+      else if (code_right == BIT_AND_EXPR || code_right == BIT_XOR_EXPR\n+\t       || code_right == PLUS_EXPR || code_right == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around arithmetic in operand of %<|%>\");\n+      /* Check cases like x|y==z */\n+      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<|%>\");\n+      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<|%>\");\n+      /* Check cases like !x | y */\n+      else if (code_left == TRUTH_NOT_EXPR\n+\t       && !APPEARS_TO_BE_BOOLEAN_EXPR_P (code_right, arg_right))\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around operand of \"\n+\t\t    \"%<!%> or change %<|%> to %<||%> or %<!%> to %<~%>\");\n+      return;\n+\n+    case BIT_XOR_EXPR:\n+      if (code_left == BIT_AND_EXPR\n+\t  || code_left == PLUS_EXPR || code_left == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around arithmetic in operand of %<^%>\");\n+      else if (code_right == BIT_AND_EXPR\n+\t       || code_right == PLUS_EXPR || code_right == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around arithmetic in operand of %<^%>\");\n+      /* Check cases like x^y==z */\n+      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<^%>\");\n+      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<^%>\");\n+      return;\n+\n+    case BIT_AND_EXPR:\n+      if (code_left == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around %<+%> in operand of %<&%>\");\n+      else if (code_right == PLUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around %<+%> in operand of %<&%>\");\n+      else if (code_left == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around %<-%> in operand of %<&%>\");\n+      else if (code_right == MINUS_EXPR)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around %<-%> in operand of %<&%>\");\n+      /* Check cases like x&y==z */\n+      else if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<&%>\");\n+      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<&%>\");\n+      /* Check cases like !x & y */\n+      else if (code_left == TRUTH_NOT_EXPR\n+\t       && !APPEARS_TO_BE_BOOLEAN_EXPR_P (code_right, arg_right))\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t    \"suggest parentheses around operand of \"\n+\t\t    \"%<!%> or change %<&%> to %<&&%> or %<!%> to %<~%>\");\n+      return;\n+\n+    case EQ_EXPR:\n+      if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<==%>\");\n+      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<==%>\");\n+      return;\n+    case NE_EXPR:\n+      if (TREE_CODE_CLASS (code_left) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<!=%>\");\n+      else if (TREE_CODE_CLASS (code_right) == tcc_comparison)\n+\twarning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t \"suggest parentheses around comparison in operand of %<!=%>\");\n+      return;\n+\n+    default:\n+      if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t{\n+\t  if (TREE_CODE_CLASS (code_left) == tcc_comparison\n+\t\t&& code_left != NE_EXPR && code_left != EQ_EXPR\n+\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (arg_left)))\n+\t    warning_at (EXPR_LOC_OR_LOC (arg_left, loc), OPT_Wparentheses,\n+\t\t\t\"comparisons like %<X<=Y<=Z%> do not \"\n+\t\t\t\"have their mathematical meaning\");\n+\t  else if (TREE_CODE_CLASS (code_right) == tcc_comparison\n+\t\t   && code_right != NE_EXPR && code_right != EQ_EXPR\n+\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (arg_right)))\n+\t    warning_at (EXPR_LOC_OR_LOC (arg_right, loc), OPT_Wparentheses,\n+\t\t\t\"comparisons like %<X<=Y<=Z%> do not \"\n+\t\t\t\"have their mathematical meaning\");\n+\t}\n+      return;\n+    }\n+#undef NOT_A_BOOLEAN_EXPR_P\n+}\n+\n+/* If LABEL (a LABEL_DECL) has not been used, issue a warning.  */\n+\n+void\n+warn_for_unused_label (tree label)\n+{\n+  if (!TREE_USED (label))\n+    {\n+      if (DECL_INITIAL (label))\n+\twarning (OPT_Wunused_label, \"label %q+D defined but not used\", label);\n+      else\n+\twarning (OPT_Wunused_label, \"label %q+D declared but not defined\", label);\n+    }\n+}\n+\n+/* Warn for division by zero according to the value of DIVISOR.  LOC\n+   is the location of the division operator.  */\n+\n+void\n+warn_for_div_by_zero (location_t loc, tree divisor)\n+{\n+  /* If DIVISOR is zero, and has integral or fixed-point type, issue a warning\n+     about division by zero.  Do not issue a warning if DIVISOR has a\n+     floating-point type, since we consider 0.0/0.0 a valid way of\n+     generating a NaN.  */\n+  if (c_inhibit_evaluation_warnings == 0\n+      && (integer_zerop (divisor) || fixed_zerop (divisor)))\n+    warning_at (loc, OPT_Wdiv_by_zero, \"division by zero\");\n+}\n+\n+/* Warn for patterns where memset appears to be used incorrectly.  The\n+   warning location should be LOC.  ARG0, and ARG2 are the first and\n+   last arguments to the call, while LITERAL_ZERO_MASK has a 1 bit for\n+   each argument that was a literal zero.  */\n+\n+void\n+warn_for_memset (location_t loc, tree arg0, tree arg2,\n+\t\t int literal_zero_mask)\n+{\n+  if (warn_memset_transposed_args\n+      && integer_zerop (arg2)\n+      && (literal_zero_mask & (1 << 2)) != 0\n+      && (literal_zero_mask & (1 << 1)) == 0)\n+    warning_at (loc, OPT_Wmemset_transposed_args,\n+\t\t\"%<memset%> used with constant zero length \"\n+\t\t\"parameter; this could be due to transposed \"\n+\t\t\"parameters\");\n+\n+  if (warn_memset_elt_size && TREE_CODE (arg2) == INTEGER_CST)\n+    {\n+      STRIP_NOPS (arg0);\n+      if (TREE_CODE (arg0) == ADDR_EXPR)\n+\targ0 = TREE_OPERAND (arg0, 0);\n+      tree type = TREE_TYPE (arg0);\n+      if (type != NULL_TREE && TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree elt_type = TREE_TYPE (type);\n+\t  tree domain = TYPE_DOMAIN (type);\n+\t  if (!integer_onep (TYPE_SIZE_UNIT (elt_type))\n+\t      && domain != NULL_TREE\n+\t      && TYPE_MAXVAL (domain)\n+\t      && TYPE_MINVAL (domain)\n+\t      && integer_zerop (TYPE_MINVAL (domain))\n+\t      && integer_onep (fold_build2 (MINUS_EXPR, domain,\n+\t\t\t\t\t    arg2,\n+\t\t\t\t\t    TYPE_MAXVAL (domain))))\n+\t    warning_at (loc, OPT_Wmemset_elt_size,\n+\t\t\t\"%<memset%> used with length equal to \"\n+\t\t\t\"number of elements without multiplication \"\n+\t\t\t\"by element size\");\n+\t}\n+    }\n+}\n+\n+/* Subroutine of build_binary_op. Give warnings for comparisons\n+   between signed and unsigned quantities that may fail. Do the\n+   checking based on the original operand trees ORIG_OP0 and ORIG_OP1,\n+   so that casts will be considered, but default promotions won't\n+   be.\n+\n+   LOCATION is the location of the comparison operator.\n+\n+   The arguments of this function map directly to local variables\n+   of build_binary_op.  */\n+\n+void\n+warn_for_sign_compare (location_t location,\n+\t\t       tree orig_op0, tree orig_op1,\n+\t\t       tree op0, tree op1,\n+\t\t       tree result_type, enum tree_code resultcode)\n+{\n+  int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n+  int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n+  int unsignedp0, unsignedp1;\n+\n+  /* In C++, check for comparison of different enum types.  */\n+  if (c_dialect_cxx()\n+      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n+      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n+\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n+    {\n+      warning_at (location,\n+\t\t  OPT_Wsign_compare, \"comparison between types %qT and %qT\",\n+\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+    }\n+\n+  /* Do not warn if the comparison is being done in a signed type,\n+     since the signed type will only be chosen if it can represent\n+     all the values of the unsigned type.  */\n+  if (!TYPE_UNSIGNED (result_type))\n+    /* OK */;\n+  /* Do not warn if both operands are unsigned.  */\n+  else if (op0_signed == op1_signed)\n+    /* OK */;\n+  else\n+    {\n+      tree sop, uop, base_type;\n+      bool ovf;\n+\n+      if (op0_signed)\n+\tsop = orig_op0, uop = orig_op1;\n+      else\n+\tsop = orig_op1, uop = orig_op0;\n+\n+      STRIP_TYPE_NOPS (sop);\n+      STRIP_TYPE_NOPS (uop);\n+      base_type = (TREE_CODE (result_type) == COMPLEX_TYPE\n+\t\t   ? TREE_TYPE (result_type) : result_type);\n+\n+      /* Do not warn if the signed quantity is an unsuffixed integer\n+\t literal (or some static constant expression involving such\n+\t literals or a conditional expression involving such literals)\n+\t and it is non-negative.  */\n+      if (tree_expr_nonnegative_warnv_p (sop, &ovf))\n+\t/* OK */;\n+      /* Do not warn if the comparison is an equality operation, the\n+\t unsigned quantity is an integral constant, and it would fit\n+\t in the result if the result were signed.  */\n+      else if (TREE_CODE (uop) == INTEGER_CST\n+\t       && (resultcode == EQ_EXPR || resultcode == NE_EXPR)\n+\t       && int_fits_type_p (uop, c_common_signed_type (base_type)))\n+\t/* OK */;\n+      /* In C, do not warn if the unsigned quantity is an enumeration\n+\t constant and its maximum value would fit in the result if the\n+\t result were signed.  */\n+      else if (!c_dialect_cxx() && TREE_CODE (uop) == INTEGER_CST\n+\t       && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n+\t       && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n+\t\t\t\t   c_common_signed_type (base_type)))\n+\t/* OK */;\n+      else\n+\twarning_at (location,\n+\t\t    OPT_Wsign_compare,\n+\t\t    \"comparison between signed and unsigned integer expressions\");\n+    }\n+\n+  /* Warn if two unsigned values are being compared in a size larger\n+     than their original size, and one (and only one) is the result of\n+     a `~' operator.  This comparison will always fail.\n+\n+     Also warn if one operand is a constant, and the constant does not\n+     have all bits set that are set in the ~ operand when it is\n+     extended.  */\n+\n+  op0 = c_common_get_narrower (op0, &unsignedp0);\n+  op1 = c_common_get_narrower (op1, &unsignedp1);\n+\n+  if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n+      ^ (TREE_CODE (op1) == BIT_NOT_EXPR))\n+    {\n+      if (TREE_CODE (op0) == BIT_NOT_EXPR)\n+\top0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n+      if (TREE_CODE (op1) == BIT_NOT_EXPR)\n+\top1 = c_common_get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n+\n+      if (tree_fits_shwi_p (op0) || tree_fits_shwi_p (op1))\n+\t{\n+\t  tree primop;\n+\t  HOST_WIDE_INT constant, mask;\n+\t  int unsignedp;\n+\t  unsigned int bits;\n+\n+\t  if (tree_fits_shwi_p (op0))\n+\t    {\n+\t      primop = op1;\n+\t      unsignedp = unsignedp1;\n+\t      constant = tree_to_shwi (op0);\n+\t    }\n+\t  else\n+\t    {\n+\t      primop = op0;\n+\t      unsignedp = unsignedp0;\n+\t      constant = tree_to_shwi (op1);\n+\t    }\n+\n+\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n+\t  if (bits < TYPE_PRECISION (result_type)\n+\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n+\t    {\n+\t      mask = HOST_WIDE_INT_M1U << bits;\n+\t      if ((mask & constant) != mask)\n+\t\t{\n+\t\t  if (constant == 0)\n+\t\t    warning_at (location, OPT_Wsign_compare,\n+\t\t\t\t\"promoted ~unsigned is always non-zero\");\n+\t\t  else\n+\t\t    warning_at (location, OPT_Wsign_compare,\n+\t\t\t\t\"comparison of promoted ~unsigned with constant\");\n+\t\t}\n+\t    }\n+\t}\n+      else if (unsignedp0 && unsignedp1\n+\t       && (TYPE_PRECISION (TREE_TYPE (op0))\n+\t\t   < TYPE_PRECISION (result_type))\n+\t       && (TYPE_PRECISION (TREE_TYPE (op1))\n+\t\t   < TYPE_PRECISION (result_type)))\n+\twarning_at (location, OPT_Wsign_compare,\n+\t\t    \"comparison of promoted ~unsigned with unsigned\");\n+    }\n+}\n+\n+/* RESULT_TYPE is the result of converting TYPE1 and TYPE2 to a common\n+   type via c_common_type.  If -Wdouble-promotion is in use, and the\n+   conditions for warning have been met, issue a warning.  GMSGID is\n+   the warning message.  It must have two %T specifiers for the type\n+   that was converted (generally \"float\") and the type to which it was\n+   converted (generally \"double), respectively.  LOC is the location\n+   to which the awrning should refer.  */\n+\n+void\n+do_warn_double_promotion (tree result_type, tree type1, tree type2,\n+\t\t\t const char *gmsgid, location_t loc)\n+{\n+  tree source_type;\n+\n+  if (!warn_double_promotion)\n+    return;\n+  /* If the conversion will not occur at run-time, there is no need to\n+     warn about it.  */\n+  if (c_inhibit_evaluation_warnings)\n+    return;\n+  if (TYPE_MAIN_VARIANT (result_type) != double_type_node\n+      && TYPE_MAIN_VARIANT (result_type) != complex_double_type_node)\n+    return;\n+  if (TYPE_MAIN_VARIANT (type1) == float_type_node\n+      || TYPE_MAIN_VARIANT (type1) == complex_float_type_node)\n+    source_type = type1;\n+  else if (TYPE_MAIN_VARIANT (type2) == float_type_node\n+\t   || TYPE_MAIN_VARIANT (type2) == complex_float_type_node)\n+    source_type = type2;\n+  else\n+    return;\n+  warning_at (loc, OPT_Wdouble_promotion, gmsgid, source_type, result_type);\n+}\n+\n+/* Possibly warn about unused parameters.  */\n+\n+void\n+do_warn_unused_parameter (tree fn)\n+{\n+  tree decl;\n+\n+  for (decl = DECL_ARGUMENTS (fn);\n+       decl; decl = DECL_CHAIN (decl))\n+    if (!TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n+\t&& DECL_NAME (decl) && !DECL_ARTIFICIAL (decl)\n+\t&& !TREE_NO_WARNING (decl))\n+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wunused_parameter,\n+\t\t  \"unused parameter %qD\", decl);\n+}\n+\n+/* If DECL is a typedef that is declared in the current function,\n+   record it for the purpose of -Wunused-local-typedefs.  */\n+\n+void\n+record_locally_defined_typedef (tree decl)\n+{\n+  struct c_language_function *l;\n+\n+  if (!warn_unused_local_typedefs\n+      || cfun == NULL\n+      /* if this is not a locally defined typedef then we are not\n+\t interested.  */\n+      || !is_typedef_decl (decl)\n+      || !decl_function_context (decl))\n+    return;\n+\n+  l = (struct c_language_function *) cfun->language;\n+  vec_safe_push (l->local_typedefs, decl);\n+}\n+\n+/* If T is a TYPE_DECL declared locally, mark it as used.  */\n+\n+void\n+maybe_record_typedef_use (tree t)\n+{\n+  if (!is_typedef_decl (t))\n+    return;\n+\n+  TREE_USED (t) = true;\n+}\n+\n+/* Warn if there are some unused locally defined typedefs in the\n+   current function. */\n+\n+void\n+maybe_warn_unused_local_typedefs (void)\n+{\n+  int i;\n+  tree decl;\n+  /* The number of times we have emitted -Wunused-local-typedefs\n+     warnings.  If this is different from errorcount, that means some\n+     unrelated errors have been issued.  In which case, we'll avoid\n+     emitting \"unused-local-typedefs\" warnings.  */\n+  static int unused_local_typedefs_warn_count;\n+  struct c_language_function *l;\n+\n+  if (cfun == NULL)\n+    return;\n+\n+  if ((l = (struct c_language_function *) cfun->language) == NULL)\n+    return;\n+\n+  if (warn_unused_local_typedefs\n+      && errorcount == unused_local_typedefs_warn_count)\n+    {\n+      FOR_EACH_VEC_SAFE_ELT (l->local_typedefs, i, decl)\n+\tif (!TREE_USED (decl))\n+\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t      OPT_Wunused_local_typedefs,\n+\t\t      \"typedef %qD locally defined but not used\", decl);\n+      unused_local_typedefs_warn_count = errorcount;\n+    }\n+\n+  vec_free (l->local_typedefs);\n+}\n+\n+/* If we're creating an if-else-if condition chain, first see if we\n+   already have this COND in the CHAIN.  If so, warn and don't add COND\n+   into the vector, otherwise add the COND there.  LOC is the location\n+   of COND.  */\n+\n+void\n+warn_duplicated_cond_add_or_warn (location_t loc, tree cond, vec<tree> **chain)\n+{\n+  /* No chain has been created yet.  Do nothing.  */\n+  if (*chain == NULL)\n+    return;\n+\n+  if (TREE_SIDE_EFFECTS (cond))\n+    {\n+      /* Uh-oh!  This condition has a side-effect, thus invalidates\n+\t the whole chain.  */\n+      delete *chain;\n+      *chain = NULL;\n+      return;\n+    }\n+\n+  unsigned int ix;\n+  tree t;\n+  bool found = false;\n+  FOR_EACH_VEC_ELT (**chain, ix, t)\n+    if (operand_equal_p (cond, t, 0))\n+      {\n+\tif (warning_at (loc, OPT_Wduplicated_cond,\n+\t\t\t\"duplicated %<if%> condition\"))\n+\t  inform (EXPR_LOCATION (t), \"previously used here\");\n+\tfound = true;\n+\tbreak;\n+      }\n+\n+  if (!found\n+      && !CONSTANT_CLASS_P (cond)\n+      /* Don't infinitely grow the chain.  */\n+      && (*chain)->length () < 512)\n+    (*chain)->safe_push (cond);\n+}\n+\n+/* Check and possibly warn if two declarations have contradictory\n+   attributes, such as always_inline vs. noinline.  */\n+\n+bool\n+diagnose_mismatched_attributes (tree olddecl, tree newdecl)\n+{\n+  bool warned = false;\n+\n+  tree a1 = lookup_attribute (\"optimize\", DECL_ATTRIBUTES (olddecl));\n+  tree a2 = lookup_attribute (\"optimize\", DECL_ATTRIBUTES (newdecl));\n+  /* An optimization attribute applied on a declaration after the\n+     definition is likely not what the user wanted.  */\n+  if (a2 != NULL_TREE\n+      && DECL_SAVED_TREE (olddecl) != NULL_TREE\n+      && (a1 == NULL_TREE || !attribute_list_equal (a1, a2)))\n+    warned |= warning (OPT_Wattributes,\n+\t\t       \"optimization attribute on %qD follows \"\n+\t\t       \"definition but the attribute doesn%'t match\",\n+\t\t       newdecl);\n+\n+  /* Diagnose inline __attribute__ ((noinline)) which is silly.  */\n+  if (DECL_DECLARED_INLINE_P (newdecl)\n+      && DECL_UNINLINABLE (olddecl)\n+      && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n+    warned |= warning (OPT_Wattributes, \"inline declaration of %qD follows \"\n+\t\t       \"declaration with attribute noinline\", newdecl);\n+  else if (DECL_DECLARED_INLINE_P (olddecl)\n+\t   && DECL_UNINLINABLE (newdecl)\n+\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n+    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t       \"noinline follows inline declaration \", newdecl);\n+  else if (lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl))\n+\t   && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (olddecl)))\n+    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t       \"%qs follows declaration with attribute %qs\",\n+\t\t       newdecl, \"noinline\", \"always_inline\");\n+  else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (newdecl))\n+\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n+    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t       \"%qs follows declaration with attribute %qs\",\n+\t\t       newdecl, \"always_inline\", \"noinline\");\n+  else if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (newdecl))\n+\t   && lookup_attribute (\"hot\", DECL_ATTRIBUTES (olddecl)))\n+    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t       \"%qs follows declaration with attribute %qs\",\n+\t\t       newdecl, \"cold\", \"hot\");\n+  else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (newdecl))\n+\t   && lookup_attribute (\"cold\", DECL_ATTRIBUTES (olddecl)))\n+    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n+\t\t       \"%qs follows declaration with attribute %qs\",\n+\t\t       newdecl, \"hot\", \"cold\");\n+  return warned;\n+}\n+\n+/* Warn if signed left shift overflows.  We don't warn\n+   about left-shifting 1 into the sign bit in C++14; cf.\n+   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3367.html#1457>\n+   LOC is a location of the shift; OP0 and OP1 are the operands.\n+   Return true if an overflow is detected, false otherwise.  */\n+\n+bool\n+maybe_warn_shift_overflow (location_t loc, tree op0, tree op1)\n+{\n+  if (TREE_CODE (op0) != INTEGER_CST\n+      || TREE_CODE (op1) != INTEGER_CST)\n+    return false;\n+\n+  tree type0 = TREE_TYPE (op0);\n+  unsigned int prec0 = TYPE_PRECISION (type0);\n+\n+  /* Left-hand operand must be signed.  */\n+  if (TYPE_UNSIGNED (type0))\n+    return false;\n+\n+  unsigned int min_prec = (wi::min_precision (op0, SIGNED)\n+\t\t\t   + TREE_INT_CST_LOW (op1));\n+  /* Handle the case of left-shifting 1 into the sign bit.\n+   * However, shifting 1 _out_ of the sign bit, as in\n+   * INT_MIN << 1, is considered an overflow.\n+   */\n+  if (!tree_int_cst_sign_bit(op0) && min_prec == prec0 + 1)\n+    {\n+      /* Never warn for C++14 onwards.  */\n+      if (cxx_dialect >= cxx14)\n+\treturn false;\n+      /* Otherwise only if -Wshift-overflow=2.  But return\n+\t true to signal an overflow for the sake of integer\n+\t constant expressions.  */\n+      if (warn_shift_overflow < 2)\n+\treturn true;\n+    }\n+\n+  bool overflowed = min_prec > prec0;\n+  if (overflowed && c_inhibit_evaluation_warnings == 0)\n+    warning_at (loc, OPT_Wshift_overflow_,\n+\t\t\"result of %qE requires %u bits to represent, \"\n+\t\t\"but %qT only has %u bits\",\n+\t\tbuild2_loc (loc, LSHIFT_EXPR, type0, op0, op1),\n+\t\tmin_prec, type0, prec0);\n+\n+  return overflowed;\n+}\n+\n+/* Warn about boolean expression compared with an integer value different\n+   from true/false.  Warns also e.g. about \"(i1 == i2) == 2\".\n+   LOC is the location of the comparison, CODE is its code, OP0 and OP1\n+   are the operands of the comparison.  The caller must ensure that\n+   either operand is a boolean expression.  */\n+\n+void\n+maybe_warn_bool_compare (location_t loc, enum tree_code code, tree op0,\n+\t\t\t tree op1)\n+{\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    return;\n+\n+  tree f, cst;\n+  if (f = fold_for_warn (op0),\n+      TREE_CODE (f) == INTEGER_CST)\n+    cst = op0 = f;\n+  else if (f = fold_for_warn (op1),\n+\t   TREE_CODE (f) == INTEGER_CST)\n+    cst = op1 = f;\n+  else\n+    return;\n+\n+  if (!integer_zerop (cst) && !integer_onep (cst))\n+    {\n+      int sign = (TREE_CODE (op0) == INTEGER_CST\n+\t\t ? tree_int_cst_sgn (cst) : -tree_int_cst_sgn (cst));\n+      if (code == EQ_EXPR\n+\t  || ((code == GT_EXPR || code == GE_EXPR) && sign < 0)\n+\t  || ((code == LT_EXPR || code == LE_EXPR) && sign > 0))\n+\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n+\t\t    \"with boolean expression is always false\", cst);\n+      else\n+\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n+\t\t    \"with boolean expression is always true\", cst);\n+    }\n+  else if (integer_zerop (cst) || integer_onep (cst))\n+    {\n+      /* If the non-constant operand isn't of a boolean type, we\n+\t don't want to warn here.  */\n+      tree noncst = TREE_CODE (op0) == INTEGER_CST ? op1 : op0;\n+      /* Handle booleans promoted to integers.  */\n+      if (bool_promoted_to_int_p (noncst))\n+\t/* Warn.  */;\n+      else if (TREE_CODE (TREE_TYPE (noncst)) != BOOLEAN_TYPE\n+\t       && !truth_value_p (TREE_CODE (noncst)))\n+\treturn;\n+      /* Do some magic to get the right diagnostics.  */\n+      bool flag = TREE_CODE (op0) == INTEGER_CST;\n+      flag = integer_zerop (cst) ? flag : !flag;\n+      if ((code == GE_EXPR && !flag) || (code == LE_EXPR && flag))\n+\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n+\t\t    \"with boolean expression is always true\", cst);\n+      else if ((code == LT_EXPR && !flag) || (code == GT_EXPR && flag))\n+\twarning_at (loc, OPT_Wbool_compare, \"comparison of constant %qE \"\n+\t\t    \"with boolean expression is always false\", cst);\n+    }\n+}"}]}