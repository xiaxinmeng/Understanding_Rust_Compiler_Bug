{"sha": "b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjNGZmNzg4OGE4ZmMxN2MwY2UwNDdmNTM5NTQ4ZGFjZjJjOGY4ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-21T15:25:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-21T15:25:09Z"}, "message": "tree-ssa-threadedge.c (thread_through_normal_block): New argument VISITED.\n\n       * tree-ssa-threadedge.c (thread_through_normal_block): New argument VISITED.\n        Remove VISISTED as a local variable.  When we have a threadable jump, verify\n        the destination of the jump has not been visised.\n        (thread_across_edge): Allocate VISITED bitmap once at function scope and\n        use it throughout.  Make sure to set appropriate bits in VISITED for E (start\n        of jump thread path).\n\n        * tree-ssa-threadupdate.c (mark_threaded_blocks): Reject threading through\n        a joiner if any edge on the path has a recorded jump thread.\n\nFrom-SVN: r203895", "tree": {"sha": "27dc71626562b27de9139558e8f1fc715449171e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27dc71626562b27de9139558e8f1fc715449171e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/comments", "author": null, "committer": null, "parents": [{"sha": "ce0770fc7bb93ca051c0ccacbd98031f276a2b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0770fc7bb93ca051c0ccacbd98031f276a2b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce0770fc7bb93ca051c0ccacbd98031f276a2b91"}], "stats": {"total": 59, "additions": 42, "deletions": 17}, "files": [{"sha": "54298e482b7b00a88ddd650d2658d86072936062", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "patch": "@@ -1,3 +1,15 @@\n+2013-10-21  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (thread_through_normal_block): New argument VISITED.\n+\tRemove VISISTED as a local variable.  When we have a threadable jump, verify\n+\tthe destination of the jump has not been visised.\n+\t(thread_across_edge): Allocate VISITED bitmap once at function scope and\n+\tuse it throughout.  Make sure to set appropriate bits in VISITED for E (start\n+\tof jump thread path).\n+\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Reject threading through\n+\ta joiner if any edge on the path has a recorded jump thread.\n+\n 2013-10-21  Ian Lance Taylor  <iant@google.com>\n \n \t* doc/invoke.texi (Optimize Options): For -fno-toplevel-reorder,"}, {"sha": "ebd93cbfd27ebe46fe55753b720e2624ac30dd38", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "patch": "@@ -883,7 +883,8 @@ thread_through_normal_block (edge e,\n \t\t\t     bool handle_dominating_asserts,\n \t\t\t     vec<tree> *stack,\n \t\t\t     tree (*simplify) (gimple, gimple),\n-\t\t\t     vec<jump_thread_edge *> *path)\n+\t\t\t     vec<jump_thread_edge *> *path,\n+\t\t\t     bitmap visited)\n {\n   /* If E is a backedge, then we want to verify that the COND_EXPR,\n      SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected\n@@ -922,11 +923,10 @@ thread_through_normal_block (edge e,\n \t{\n \t  edge taken_edge = find_taken_edge (e->dest, cond);\n \t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n-\t  bitmap visited;\n \n \t  /* DEST could be NULL for a computed jump to an absolute\n \t     address.  */\n-\t  if (dest == NULL || dest == e->dest)\n+\t  if (dest == NULL || dest == e->dest || bitmap_bit_p (visited, dest->index))\n \t    return false;\n \n           jump_thread_edge *x\n@@ -944,7 +944,6 @@ thread_through_normal_block (edge e,\n \t    {\n \t      /* We don't want to thread back to a block we have already\n  \t\t visited.  This may be overly conservative.  */\n-\t      visited = BITMAP_ALLOC (NULL);\n \t      bitmap_set_bit (visited, dest->index);\n \t      bitmap_set_bit (visited, e->dest->index);\n \t      thread_around_empty_blocks (taken_edge,\n@@ -953,7 +952,6 @@ thread_through_normal_block (edge e,\n \t\t\t\t\t  simplify,\n \t\t\t\t\t  visited,\n \t\t\t\t\t  path);\n-\t      BITMAP_FREE (visited);\n \t    }\n \t  return true;\n \t}\n@@ -995,15 +993,21 @@ thread_across_edge (gimple dummy_cond,\n \t\t    vec<tree> *stack,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n+  bitmap visited = BITMAP_ALLOC (NULL);\n+\n   stmt_count = 0;\n \n   vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n+  bitmap_clear (visited);\n+  bitmap_set_bit (visited, e->src->index);\n+  bitmap_set_bit (visited, e->dest->index);\n   if (thread_through_normal_block (e, dummy_cond, handle_dominating_asserts,\n-\t\t\t\t   stack, simplify, path))\n+\t\t\t\t   stack, simplify, path, visited))\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n       remove_temporary_equivalences (stack);\n+      BITMAP_FREE (visited);\n       register_jump_thread (path);\n       return;\n     }\n@@ -1030,7 +1034,6 @@ thread_across_edge (gimple dummy_cond,\n     edge taken_edge;\n     edge_iterator ei;\n     bool found;\n-    bitmap visited = BITMAP_ALLOC (NULL);\n \n     /* Look at each successor of E->dest to see if we can thread through it.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)"}, {"sha": "737a6a2b62a50afec01eb3abd1812dc673d5e985", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b5c4ff7888a8fc17c0ce047f539548dacf2c8f8d", "patch": "@@ -1244,7 +1244,7 @@ mark_threaded_blocks (bitmap threaded_blocks)\n      When this occurs ignore the jump thread request with the joiner\n      block.  It's totally subsumed by the simpler jump thread request.\n \n-     This results in less block copying, simpler CFGs.  More improtantly,\n+     This results in less block copying, simpler CFGs.  More importantly,\n      when we duplicate the joiner block, B, in this case we will create\n      a new threading opportunity that we wouldn't be able to optimize\n      until the next jump threading iteration.\n@@ -1263,20 +1263,30 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t}\n     }\n \n-\n-  /* Now iterate again, converting cases where we threaded through\n-     a joiner block, but ignoring those where we have already\n-     threaded through the joiner block.  */\n+  /* Now iterate again, converting cases where we want to thread\n+     through a joiner block, but only if no other edge on the path\n+     already has a jump thread attached to it.  */\n   for (i = 0; i < paths.length (); i++)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n \n-      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK\n-\t  && (*path)[0]->e->aux == NULL)\n+      \n+      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n-\t  edge e = (*path)[0]->e;\n-\t  e->aux = path;\n-\t  bitmap_set_bit (tmp, e->dest->index);\n+\t  unsigned int j;\n+\n+\t  for (j = 0; j < path->length (); j++)\n+\t    if ((*path)[j]->e->aux != NULL)\n+\t      break;\n+\n+\t  /* If we iterated through the entire path without exiting the loop,\n+\t     then we are good to go, attach the path to the starting edge.  */\n+\t  if (j == path->length ())\n+\t    {\n+\t      edge e = (*path)[0]->e;\n+\t      e->aux = path;\n+\t      bitmap_set_bit (tmp, e->dest->index);\n+\t    }\n \t}\n     }\n "}]}